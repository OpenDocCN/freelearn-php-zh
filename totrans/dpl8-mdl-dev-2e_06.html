<html><head></head><body>
        <section>

                            <header>
                    <h1 class="header-title">Data Modeling and Storage</h1>
                </header>
            
            <article>
                
<p>We have gone through five chapters already in this book, but we have yet to cover a topic that has to do with one of the main purposes of a CMS—data storage. Okay, we hinted at it in the previous chapter and also saw an example of a configuration object in the second one. However, we merely scratched the surface of what is possible. It's now time to go ahead and dive into everything related to how you can store data in Drupal 8.</p>
<p>In this and the next chapter, we will talk about a lot of things related to storage and data manipulation, and take a look at a lot of examples in the process. The focus of this chapter will, however, be more theoretical. There is a lot of ground to cover, as there are many APIs and concepts that you will need to understand. However, we will still see plenty of code examples to demonstrate in practice what we are talking about. In the next chapter, though, to make up for it, we will almost entirely work with code and build a few functionalities.</p>
<p>More concretely, however, this chapter will be divided into three main logical parts (not necessarily represented by headings).</p>
<p>First, we will talk about your options for data storage. We will talk about the State system with its key/value store, tempstore, user data, configuration, and finally, entities—the big one. We will leave the cache out of this, because it will be covered in a separate chapter. We will see examples of all these options and go into the architectural details necessary to understand how they work.</p>
<p>Second, we will dive deep into the Drupal 8 Entity API to understand the architecture behind it<span>—</span>how data is stored and, more importantly, modeled. I am referring to the <kbd>TypedData</kbd> system here.</p>
<p>Finally, we will look at how we can manipulate entities; in other words, how we can work with them and extract data<span>—</span>basically, the day-to-day working with entities. One of the main topics here will be, of course, querying and loading entities. Moreover, we will also cover the validation aspect of this process.</p>
<p>By the end of this chapter, you should be able to understand a great deal about storage in Drupal 8 and make decisions on which options to choose for your requirements. You'll know the differences and the reasons for using one over another. Moreover, you'll get a good understanding of the Entity API, which, in turn, will allow you to more easily navigate through Drupal code and integrate with the entity system. Lastly, and probably, the most common thing Drupal developers do, you'll be able to work with entities: perform CRUD operations, read and write field values, and more of this good stuff.</p>
<p>So, let's begin.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Different types of data storage</h1>
                </header>
            
            <article>
                
<p>Storing and using data are a critical part of any (web) application. Without somehow persisting data we wouldn't be able to build much of anything. However, different uses of data warrant different systems for storing and manipulating it. For the purposes of this chapter, I will use the word <em>data</em> to mean almost anything that has to be persisted somewhere, for any given period of time.</p>
<p>If you've done development in Drupal 7, you already know a few ways of storing data. We had entities (primarily the Node entity type, but others could be defined as well); the <kbd>variables</kbd> table, which was a relatively simple key/value store; and an API to interact with the database and do whatever we fancied. This caused many problems, such as a lack of consistency between APIs and much too heavy a reliance on the database for configuration storage.</p>
<p>In Drupal 8, various layered APIs have been introduced to tackle common use cases for data storage. The strength of these new systems is mirrored in the fact that we rarely, if ever, need to even use the mother of all storage APIs, the database API. This is because everything has been abstracted into different layers that help us handle most of what we need. So, creating a custom table is most likely not something you should be doing for storing your data anymore, although it definitely was a common practice in Drupal 7.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">State API</h1>
                </header>
            
            <article>
                
<p>The State API is a key/value database storage and the simplest way you can store some data in Drupal 8. One of its main purposes is to allow developers to store information that relates to the <em>state</em> of the system (hence the name). And because the <em>state</em> of the system can be interpreted in various ways, think of this as simple information related to the current environment (Drupal installation) that is not editorial (content). An example would be the timestamp of the last time the Cron ran or any flags or markers that the system sets to keep track of its tasks. It is different from caching in that it is not meant to be cleared as often, and only the code that sets it is responsible for updating it.</p>
<p>One of the main characteristics of this system is the fact that it is not designed for human interaction. I mean this in the sense that it is the application itself that needs to make use of it. The option for humans is the configuration system that we will talk about in detail in a later section.</p>
<p>So now that we know about the State API, let's jump into the technicalities and see what it's made of and how we can use it.</p>
<p>The State system revolves around the <kbd>Drupal\Core\State\StateInterface</kbd>, which provides all the methods you need to interact with it. This interface is implemented by the <kbd>State</kbd> service, which we can inject into your classes or use statically via the <kbd>\Drupal::state()</kbd> shorthand. Once we have that, things could not be easier, as the interface tells us exactly what we can do.</p>
<p>We can set a value:</p>
<pre>\Drupal::state()-&gt;set('my_unique_key_name', 'value'); </pre>
<p>Or we can get a value:</p>
<pre>$value = \Drupal::state()-&gt;get('my_unique_key_name');</pre>
<p>We can also set/get multiple values at once (how convenient!):</p>
<pre>\Drupal::state()-&gt;setMultiple(['my_unique_key_one' =&gt; 'value', 'my_unique_key_two' =&gt; 'value']);<br/>$values = \Drupal::state()-&gt;getMultiple(['my_unique_key_one', 'my_unique_key_two']);</pre>
<p>Isn't that easy? We can also get rid of them:</p>
<pre>\Drupal::state()-&gt;delete('my_unique_key_name');<br/>\Drupal::state()-&gt;deleteMultiple(['my_unique_key_one', 'my_unique_key_two']);</pre>
<p>There are a couple of things to note here:</p>
<ul>
<li>First, the key names you choose live in a single namespace, so it's recommended that you prefix them with your module name<span>—</span><kbd>my_module.my_key</kbd>. That way you avoid collision.</li>
<li>Second, the values you store can also be more complex than simple strings. You can store any scalar value, but also objects as they get serialized and deserialized automatically. Be careful, though, about which objects you plan on storing.</li>
</ul>
<p>Ensure that any classed objects you dump in there serialize and deserialize properly.</p>
<p>By now, you are probably wondering where these values end up. They go into the <kbd>key_value</kbd> table, namespaced under the <kbd>state</kbd> collection. Also, the latter is a nice segue into a talk about the underlying system that powers the State API: the key/value store.</p>
<p>Note that the State system is only one implementation of an underlying framework of key/value stores. If you look at the <kbd>State</kbd> service, you will note that it uses the <kbd>KeyValueFactoryInterface</kbd> (which by default is implemented by the <kbd>KeyValueDatabaseFactory</kbd>). This, in turn, creates a key/value storage instance (by default, the <kbd>DatabaseStorage</kbd>), which implements the public API to interact with the store. If you take a look at the <kbd>key_value</kbd> table in the database, you'll note other collections besides <em>state</em>. Those are other implementations specific to various subsystems, such as the Entity API and System schema. Guess what? You can easily write your own and customize it to your needs. However, the reason why the State API was created was so that module developers can use it. Also, valid uses of it cover much of the need for something such as a key/value store. So odds are that you won't have to implement your own.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">TempStore</h1>
                </header>
            
            <article>
                
<p>The next system we will look at is the <em>TempStore</em> (temporary store).</p>
<p>The tempstore is a key/value, session-like storage system for keeping temporary data across multiple requests. Imagine a multistep form or a wizard with multiple pages as great examples of tempstore use cases. You can even consider "work in progress", that is, not yet permanently saved somewhere but kept in the tempstore so that a certain user can keep working on it until it's finished. Another key feature of the tempstore is that entries can have an expiration date, at which point they get automatically cleared. So that user had better hurry up.</p>
<p>There are two kinds of tempstore APIs: a private and a shared one. The difference between the two is that with the first one, entries strictly belong to a single user, whereas with the second one, they can be shared between users. For example, the process of filling in a multistep form is the domain of a single user, so the data related to that must be private to them. However, that form can also be open to multiple users, in which case the data can either be shared between the users (quite uncommon) or used to trigger a locking mechanism that blocks user B from making changes while user A is editing (much more common). So, there are many options, but we will see some examples soon.</p>
<p>First, though, let's look at some of the key players in this system.</p>
<p>We start with the <kbd>PrivateTempStore</kbd> class, which provides the API for dealing with the private tempstore. It is not a service, because in order to use it, we must instantiate it via the <kbd>PrivateTempStoreFactory</kbd>. So that is what we have to inject into our classes if we want to use it. The latter has a <kbd>get($collection)</kbd> method which takes a collection name that we decide upon and creates a new <kbd>PrivateTempStore</kbd> object for it. If you look closely, the storage it uses is based on the <kbd>KeyValueStoreExpirableInterface</kbd>, which is very similar to the <kbd>KeyValueStoreInterface</kbd> used by the State API. The only difference is that the former has an expiration date, which allows the automatic removal of old entries. By default, the storage used in Drupal 8 is the <kbd>DatabaseStorageExpirable</kbd>, which uses the <kbd>key_value_expire</kbd> table to store the entries.</p>
<p>Up to this point, the <kbd>SharedTempStore</kbd> is strikingly similar to the private one. It is instantiated using the <kbd>SharedTempStoreFactory</kbd> service and uses the same underlying database storage by default. The main difference is the namespace occupied in the <kbd>key_value_expire</kbd> table, which is composed by <kbd>user.shared_tempstore.collection_name</kbd> as opposed to <kbd>user.private_tempstore.collection_name</kbd>.</p>
<p>Additionally, when asking the factory for the <kbd>SharedTempStore</kbd>, we have the option of passing an owner to retrieve it for. Otherwise, it defaults to the current user (the logged-in user ID or the anonymous session ID). Also, the way we interact with it and its purpose, more than anything, differ.</p>
<p>So, let's take a look at how we can work with the private and the shared tempstores.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Private TempStore</h1>
                </header>
            
            <article>
                
<p>The following is a simple example of what we just talked about:</p>
<pre>/** @var \Drupal\Core\TempStore\PrivateTempStoreFactory $factory */<br/>$factory = \Drupal::service('user.private_tempstore');<br/>$store = $factory-&gt;get('my_module.my_collection');<br/>$store-&gt;set('my_key', 'my_value');<br/>$value = $store-&gt;get('my_key');</pre>
<p>First, we get the <kbd>PrivateTempStoreFactory</kbd> service and ask it for the store identified by a collection name we choose. It's always a good idea to prefix it with your module name to avoid collisions. If another module names their own collection <kbd>my_collection</kbd>, it's not going to be pretty (even if the store is private).</p>
<p>Next, we use very simple setters and getters to set values similar to how we did with the State API.</p>
<p>If you run this code as user 1 (the main admin user), you'll note a new entry in the <kbd>key_value_expire</kbd> database table. The collection will be <kbd>user.private_tempstore.my_module.my_collection</kbd>, while the name will be <kbd>1:my_key</kbd>. This is the core principle of the private tempstore: each entry name is prefixed with the ID of the user who is logged in when the entry was created. Had you been an anonymous user, it would have been something like this: <kbd>4W2kLm0ovYlBneHMKPBUPdEM8GEpjQcU3_-B3X6nLh0:my_key</kbd>, where that long string is the session ID of the user.</p>
<p>The entry value will be a bit more complex than with the State API. This time it will always be a serialized <kbd>stdClass</kbd> object, which contains the actual value we set (which itself can be any scalar value or object that can be properly serialized), the owner (the user or session ID), and the last updated timestamp.</p>
<p>Lastly, we have the <kbd>expire</kbd> column, which, by default, will be one week from the moment the entry was created. This is a "global" timeframe set as a parameter in the <kbd>user.services.yml</kbd> definition file and can be altered in your own services definition file if you want. However, it is still global.</p>
<p>We can also delete entries like so:</p>
<pre>$store-&gt;delete('my_key'); </pre>
<p>And we can also read the information I mentioned before about the entry (the last update date, owner):</p>
<pre>$metadata = $store-&gt;getMetadata('my_key'); </pre>
<p>This returns the <kbd>stdClass</kbd> object that wraps the entry value, but without the actual value.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Shared TempStore</h1>
                </header>
            
            <article>
                
<p>Now that we've seen how the private tempstore works, let's look at the shared one. The first thing we need to do in order to interact with it is to use the factory to create a new shared store:</p>
<pre><span>/** </span><span>@var </span><span>\Drupal\Core\TempStore\SharedTempStoreFactory $factory */<br/></span><span>$factory </span><span>= \Drupal::</span><span>service</span><span>(</span><span>'user.shared_tempstore'</span><span>)</span><span>;<br/></span><span>$store </span><span>= </span><span>$factory</span><span>-&gt;</span><span>get</span><span>(</span><span>'my_module.my_collection'</span><span>)</span><span>;</span></pre>
<p>However, unlike the private tempstore, we can pass a user identifier (ID or session ID) as a second parameter to the <kbd>get()</kbd> method to retrieve the shared store of a particular owner. If we don't, it defaults to the current user (logged in or anonymous).</p>
<p>Then, the simplest way we can store/read an entry is like before:</p>
<pre>$store-&gt;set('my_key', 'my_value');<br/>$value = $store-&gt;get('my_key');</pre>
<p>Now, if we quickly jump to the database, we can see that the value column is the same as before, but the collection reflects that this is the shared store and the key is no longer prefixed by the owner. This is because another user should be able to retrieve the entry if they like. And the original owner can still be determined by checking the metadata of the entry:</p>
<pre>$metadata = $store-&gt;getMetadata('my_key'); </pre>
<p>Also, we can delete it exactly as with the private store:</p>
<pre>$store-&gt;delete('my_key'); </pre>
<p>Okay. However, what else can we do with the shared store that we cannot do with the other one?</p>
<p>First, we have two extra ways we can set an entry. We can set it if it doesn't already exist:</p>
<pre>$store-&gt;setIfNotExists('my_key', 'my_value'); </pre>
<p>Alternatively, we can set it if it doesn't exist or it belongs to the current user (that is, the user owns it):</p>
<pre>$store-&gt;setIfOwner('my_key', 'my_value'); </pre>
<p>Both these methods will return a Boolean, indicating whether the operation was successful or not. And essentially, they are handy to check for collisions. For example, if you have like a big piece of configuration that multiple users can edit, you can create the entry that stores the work in progress only if it doesn't exist, or if it exists and the current user owns it (virtually overwriting their own previous work, which may be okay).</p>
<p>Then, you also have the <kbd>getIfOwner()</kbd> and <kbd>deleteIfOwner()</kbd> methods that you can use to ensure that you only use or delete the entry if it belongs to the current user.</p>
<p>All this fuss, and for what? Why not just use the private store? This is because, in many cases, a flow can only be worked by one person at the time. So, if somebody started working on it, you will need to know in order to prevent others from working on it, but even more than that, you can allow certain users to "kick out" the previous user from the flow if they "went home without finishing it". They can then continue or clear out all the changes. It all depends on your use case.</p>
<p>Also, as a final point, the shared tempstore also works with the same expiration system as the private one.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Tempstore conclusion</h1>
                </header>
            
            <article>
                
<p>So, there we have two different, albeit similar, tempstores that you can use for various cases. If you need to store session-like data available to the user across multiple requests but which is private to them, you can use the <kbd>PrivateTempStore</kbd>. Alternatively, if this data needs to be used by either multiple users at the same time or the opposite, preventing multiple users from working on something at the same time, you can use the <kbd>SharedTempStore</kbd>.</p>
<p>Both of them have an easy-to-understand API with simple methods and you can be flexible in terms of creating your own collections for whichever use case you need.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">UserData</h1>
                </header>
            
            <article>
                
<p>Now, I want to briefly talk about another user-specific storage option, provided by the User module, called <em>UserData</em>.</p>
<p>The purpose of the UserData API is to allow the storage of certain pieces of information related to a particular user. Its concept is similar to the State API in that the type of information stored is not configuration that should be exported. In other words, it is specific to the current environment (but belonging to a given user rather than a system or subsystem).</p>
<p>Users are content entities, who can have fields of various data types. These fields are typically used for structured information pertaining to the user, for example, a first and a last name. However, if you need to store something more irregular, such as user preferences or flag that a given user has done something, the UserData is a good place to do that. This is because the information is either not something structured or is not meant for the users themselves to manage. So, let's see how this works.</p>
<p>The UserData API is made up of two things<span>—</span>the <kbd>UserDataInterface</kbd>, which contains the methods we can use to interact with it (plus developer documentation), and the <kbd>UserData</kbd> service, which implements it and can be used by the client code (us):</p>
<pre>/** @var \Drupal\user\UsedDataInterface $userData */<br/>$userData = \Drupal::service('user.data');</pre>
<p>We are now ready to use the three methods on the interface:</p>
<ul>
<li><kbd>get()</kbd></li>
<li><kbd>set()</kbd></li>
<li><kbd>delete()</kbd></li>
</ul>
<p>The first three arguments of all these methods are the same:</p>
<ul>
<li><kbd>$module</kbd>: to store data in a namespace specific to our module name, thereby preventing collisions</li>
<li><kbd>$uid</kbd>: to tie data to a given user<span>—</span>it doesn't have to be the current user</li>
<li><kbd>$name</kbd>: the name of the entry being stored</li>
</ul>
<p>Naturally, the <kbd>set()</kbd> method also has the <kbd>$value</kbd> argument, which is the data being stored, and this can be any scalar value or serializable object.</p>
<p>Together, all these arguments make for a very flexible storage system, a much improved one compared to the Drupal 7 option. We can essentially, for one module, store multiple entries for a given user and it doesn't stop there. Since that is possible, many of these parameters are optional. For example, we can get all the entries for a given module at once or all the entries for a given module and user combination at once. The same goes for deleting them. But where does all this data go?</p>
<p>The user module defines the <kbd>users_data</kbd> database table whose columns pretty much map to the arguments of these methods. The extra <kbd>serialized</kbd> column is there to indicate whether the stored data is serialized. Also, in this table, multiple records for a given user can coexist.</p>
<p>That is all there is to say about the UserData API. Use it wisely. Now it's time to turn to the configuration API, one of the biggest subsystems in Drupal 8.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Configuration</h1>
                </header>
            
            <article>
                
<p>The configuration API is one of the most important topics a Drupal 8 developer needs to understand. There are many aspects to it that tie it into other subsystems, so it is critical to be able to both use and understand it properly.</p>
<p>In this sub-chapter, we will cover a lot about the configuration system. We start by understanding what configuration is and what it is typically used for. Then, we will go through the different options we have for managing configuration in Drupal 8, both as a site builder and a developer using the Drush commands. Next, we will talk about how configuration is stored, where it belongs, and how it is defined in the system. We will also cover a few ways in which configuration can be overridden at different levels. Finally, we look at how we can interact with a simple configuration programmatically. So, let's begin with an introduction.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Introduction</h1>
                </header>
            
            <article>
                
<p>Configuration is the data that the proper functioning of an application relies upon. It is those bits of information that describe how things need to behave and helps control what code does. In other words, it configures the system to behave in a certain way with the expectation that it could also configure it to behave in a different way. To this end, configuration can be as simple as a toggle (turning something on or off) or as complicated as containing hundreds of parameters that describe an entire process.</p>
<p>The Drupal 8 configuration system is nothing short of a revolution in the Drupal world. It is not an improvement<span>—</span>it is a brand new way of thinking about managing configuration. Previously, there was no configuration management to speak of. Everything was stored in the database in a way that made it impossible to properly and consistently deploy the many configuration options that Drupal is known for. Yes, there was the Features module and the Ctools exportables, but their very existence highlighted that lack of consistency and this meant many a headache for lots of Drupal developers.</p>
<p>In Drupal 8, the entire thing has been revamped into a well-defined and consistent subsystem, upon which any little thing that needs to be configured can depend. Far be it for me to call it perfect; it still has its shortcomings and there is work in progress on making it better and creating tools for dealing with specific configuration flows. However, it has made managing and deploying configuration so much easier.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">What is configuration used for?</h1>
                </header>
            
            <article>
                
<p>Configuration is used in Drupal 8 for storing everything that has to be synchronized between the different environments (for example, moving from development to production). As such, it differs from the other types of data storage we have seen so far in that they were specific to one environment.</p>
<p>Another way of looking at configuration is by examining the role of a traditional site builder. They typically navigate the UI and configure the site to behave in a certain way<span>—</span>show this title on the home page, use this logo, show this type of content on the home page, and so on. As we mentioned, the result of their interactions materializes into configuration that the site builder expects would travel easily to the acceptance environment where it could be reviewed, and finally, to production.</p>
<p>Some configuration can actually be critical to the proper functioning of the application. Certain code might break without a parameter having a value it can use. For example, if there is no site-wide email address set, what email will the system use to send its automated mails to the user? For this reason, many of these configuration parameters come with sane defaults (upon installation). However, this also shows that configuration is a part of the application and just as important as the actual code is.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Managing configuration</h1>
                </header>
            
            <article>
                
<p>As we will see in a bit, Drupal stores configuration data in the database (for performance reasons), but it makes it all exportable to YAML files. So, a typical flow for managing it will have you perform changes in the UI, export the configuration, add it into Git, and deploy the code upstream to the next environment. There, it's just a matter of importing what is in code.</p>
<p>The import, export, and synchronization can be done both via Drush and through the UI at <kbd>admin/config/development/configuration</kbd>:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/4fda6b29-d07b-45cc-a14b-4e6d3e10d26b.png" style="width:44.58em;height:14.75em;"/></p>
<p>The typical flow is for the active site configuration to be synchronized with the one in the YAML files. This means importing into the database all the configurations that are different in the YAML files from those in the database. These YAML files are inside the configuration <kbd>sync</kbd> folder, which should be committed to Git (you can configure in the <kbd>settings.php</kbd> file which directory should be the <kbd>sync</kbd> folder) and the opposite is to export the active configuration to the YAML files in order to commit them into code.</p>
<p>The UI allows only the first option (sync what's in the YAML files with the database), but it provides you with a nice Diff interface to see what is different in YAML compared with the database:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/cd479d37-876d-4f0d-b607-e1e1e5c90fc1.png" style="width:42.08em;height:18.92em;"/></p>
<p>In this screenshot we can see that the YAML files contain a small change in the site name configuration. Clicking on <span class="packt_screen">Import all</span> will bring the database in line with the YAML files.</p>
<p>The first time you install a Drupal 8 site, the configuration <kbd>sync</kbd> folder will be empty. It is up to you to do a manual export of all the active configuration and put it there. You can do so via the UI manual export or through Drush:</p>
<pre><strong>drush config-export</strong></pre>
<p>You would perform this step every time you make configuration changes through the UI that you want exported into YAML files.</p>
<p>Then, you can synchronize either in the UI as we've seen, or through Drush, with the following command:</p>
<pre><strong>drush config-import</strong></pre>
<p>As a Drupal developer, you will be mostly using these two Drush commands.</p>
<p>In addition to the entire set of configuration items, you can also import/export individual ones by copying and pasting. Be careful though, as some dependencies might not allow you to do so. However, this is useful if you want to quickly see something working in another environment, but the approach does not lend itself to a nice version control-based flow if you abuse it.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Different types of configuration</h1>
                </header>
            
            <article>
                
<p>Drupal 8 comes with two distinct types of configuration<span>—</span>simple and configuration entities. Let's see what the difference is.</p>
<p>Simple configuration is the type that stores basic data, typically represented by scalar values such as integers or strings. On the other hand, configuration entities are more complex and use the same CRUD API as the content entities.</p>
<p>Typically, simple configuration items are one of a kind. A module, for instance, may create and manage a configuration item that enables or disables one of its features. Most likely, this module needs this configuration to know what it should do about that feature. However, even if it doesn't, it is still a singular item that relates to that piece of functionality.</p>
<p>Configuration entities, on the other hand, are multiple instances of the same configuration type. For example, a View is a configuration entity and a given site can have an unlimited number of views. It can even have none. We will talk more about configuration entities when we cover entities in general.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Configuration storage</h1>
                </header>
            
            <article>
                
<p>Configuration is essentially stored in two places:</p>
<ul>
<li>The active storage (by default in the database)</li>
<li>The sync storage (by default the YAML files)</li>
</ul>
<p>Here is an example of a simple configuration YAML file:</p>
<pre>my_string: 'Hello!'<br/>  my_int: 10<br/>  my_boolean: true<br/>  my_array:<br/>    my_deep_string: 'Yes, hello!'</pre>
<p>The name of this file is given by the ID you need to use with the configuration API to read this data.</p>
<p>In addition to the actual data, you can have a <kbd>dependencies</kbd> key under which you can list what this configuration item depends on:</p>
<pre>dependencies:<br/>  module:<br/>    - views<br/>  theme:<br/>    - bootstrap<br/>  config:<br/>    - system.site</pre>
<p>There are three types of dependencies: modules, themes, and other configuration items.</p>
<p>If you remember in <a href="601b4dd0-c521-459e-9342-2645a109642c.xhtml"><span class="MsoHyperlink">Chapter 2</span></a>, <em>Creating Your First Module,</em> we created a configuration object with the <kbd>hello_world.custom_salutation</kbd> ID in which we stored a simple value:</p>
<pre>salutation: 'Whatever the user set in the form' </pre>
<p>And we did so programmatically through our form and did not provide a YAML file. This meant that our code for displaying the salutation did not depend on this configuration item existing or having a value of some kind. Had it been mandatory for our code to work, we could have created it upon module installation. There are two ways this can be done.</p>
<p>The most common way is statically. Inside the <kbd>config/install</kbd> folder of a module, we can have YAML configuration files that get imported when the module is installed. However, if the values we need to set in this configuration are unknown (they need to be retrieved dynamically), we can do so in a <kbd>hook_install()</kbd> implementation (remember those from <span class="MsoHyperlink"><a href="360802d2-dd46-4d08-b478-9351d56ed2a0.xhtml">Chapter 3</a></span>, <em>Logging and Mailing</em>?). There, we can try to get our value and create the configuration object containing it.</p>
<div class="packt_infobox">Note that configurations found inside the <kbd>config/install</kbd> folder of the module will not be imported when the module is installed if they have unmet dependencies; that is, if whatever they depend on does not exist in the system. As a matter of fact, the module itself would not install.</div>
<p>As a bonus, you can also provide configuration files with the module that should only be imported if their dependencies are met. In other words, optional configuration. If dependencies of these configurations are not met, the module will install correctly but without those configurations. Moreover, if later on the dependencies are met, these optional configurations do get also imported automatically. Keep in mind, however, that optional configuration is reserved for configuration entities as it does not make sense with simple configurations.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Schema</h1>
                </header>
            
            <article>
                
<p>In order for various systems to properly interact with the configuration items, configuration schemas have been introduced. Schemas are a way to define the configuration items and specify what kind of data they store, be it strings, Booleans, integers, and so on. They are, of course, notated in YAML format and go inside the <kbd>config/schema</kbd> folder of a module.</p>
<p>There are three main reasons why configuration needs a schema definition:</p>
<ul>
<li><strong>Multilingual support</strong>: As we will see later, configuration is translatable in Drupal 8. However, in order to know which parts of the configuration are needed to be, or can be, translated, the schema system has been brought in to provide this additional layer. This way, configuration items that ship with contributed modules can get their own translations on the <span class="MsoHyperlink"><a href="https://localize.drupal.org/">localize.drupal.org</a></span> website. Moreover, the schema identifies which configuration bits can be translated, and this allows users to provide translations for those in the UI.</li>
<li><strong>Configuration entities</strong>: Configuration entities require schema definitions in order for the proper identification in the persistence layer of the data types that need to be exported with them. Moreover, schemas are used for the validation of configuration entities.</li>
<li><strong>Typecasting</strong>: Configuration schema ensures that the configuration API is able to always typecast properly the values to their right data types.</li>
</ul>
<p>Let's look at a configuration example provided by Drupal core to see how the schema works, namely the <kbd>system.mail</kbd> configuration provided by the <kbd>System</kbd> module. Remember in <a href="360802d2-dd46-4d08-b478-9351d56ed2a0.xhtml"><span class="MsoHyperlink">Chapter 3</span></a>, <em>Logging and Mailing,</em> we talked about how this configuration item controls the mail plugin used for sending out emails? Well, by default, this is what it looks like:</p>
<pre>interface:<br/>  default: 'php_mail'</pre>
<p>It's a very simple multidimensional array. So, if we now look in the <kbd>system.schema.yml</kbd> file for the schema definition, we will find the definitions for all the configuration items that come with the System module. The top-level line represents the name of the configuration item, so if we scroll down, we will find <kbd>system.mail</kbd>:</p>
<pre><span>system.mail:<br/></span><span>  type: </span>config_object<br/>  <span>label: </span><span>'Mail system'<br/></span><span>  </span><span>mapping:<br/></span><span>   interface:<br/></span><span>     type: </span>sequence<br/>     <span>label: </span><span>'Interfaces'<br/></span><span>     </span><span>sequence:<br/></span><span>       type: </span>string<br/>       <span>label: </span><span>'Interface'</span></pre>
<p>If we look past the irony of the schema being five times bigger than the actual configuration, we can get a pretty good understanding of what this configuration item is all about. And more importantly, Drupal itself can too.</p>
<p>We can see that the <kbd>system.mail</kbd> configuration is of the <kbd>config_object</kbd> type. This is one of the two main types of configurations, the other being <kbd>config_entity</kbd>. The <kbd>label</kbd> key is used to indicate the human-readable name of this item, whereas the <kbd>mapping</kbd> key contains the definition of its individual elements. We can see the <kbd>interface</kbd> having the label "Interfaces" and the type <kbd>sequence</kbd>. The latter is a specific type that denotes an array in which the keys are not important. Whenever we want the keys to be taken into account, we will use <kbd>mapping</kbd> (as it's done at the top level of this schema definition). And since we are looking at a <kbd>sequence</kbd> type, the individual items inside it are also defined as a string type with their own label.</p>
<p>Let's now write our own schema definition for the example configuration file we saw before:</p>
<pre>my_string: 'Hello!'<br/>my_int: 10<br/>my_boolean: true<br/>my_array:<br/>  my_deep_text: 'Yes, hello, is anybody there?!'</pre>
<p>If this configuration was found inside a file called <kbd>my_module.settings.yml</kbd>, this would be the corresponding schema definition:</p>
<pre>my_module.settings:<br/>  type: config_object<br/>  label: 'Module settings'<br/>  mapping:<br/>     my_string:<br/>       type: string<br/>       label: 'My string that can also be of type text if it was longer'<br/>     my_boolean:<br/>       type: boolean<br/>       label: 'My boolean'<br/>     my_array:<br/>        type: mapping<br/>        label: 'My array in which the keys are also important, hence not a sequence'<br/>        mapping:<br/>          my_deep_text:<br/>            type: text<br/>            label: 'My hello string'</pre>
<p>As a bonus piece of information, any <kbd>config_object</kbd>-typed configuration inherits the following property:</p>
<pre>langcode:<br/>  type: string<br/>  label: 'Language code'</pre>
<p>This helps with the multilingual system and invites us to add a <kbd>langcode</kbd> property to each configuration item.</p>
<p>Most of the properties we've seen so far have been <kbd>type</kbd>, <kbd>label</kbd>, <kbd>mapping</kbd>, and <kbd>sequence</kbd>. There are two more that you should be aware of:</p>
<ul>
<li><kbd>translatable</kbd> : very important as it indicates whether a type can be translated. By default, <kbd>text</kbd> and <kbd>label</kbd> types are already set to translatable, so you don't need to do so yourself.</li>
<li><kbd>nullable</kbd> : indicates whether the value can be left empty. If missing, it's considered as being required.</li>
</ul>
<p>Here are some types you can use to define configuration:</p>
<ul>
<li>Scalar types: <kbd>string</kbd>, <kbd>integer</kbd>, <kbd>boolean</kbd>, <kbd>email</kbd>, <kbd>float</kbd>, <kbd>uri</kbd>, <kbd>path</kbd></li>
<li>Lists: <kbd>mapping</kbd>, <kbd>sequence</kbd></li>
<li>Complex (extending scalar types): <kbd>label</kbd>, <kbd>path</kbd>, <kbd>text</kbd>, <kbd>date_format</kbd> and more.</li>
</ul>
<p>Make sure you check out the <kbd>core.data_types.schema.yml</kbd> file where all  of these are defined.</p>
<p>Before we move on, let's make sure we create the configuration schema for our configuration item we created programmatically in <a href="601b4dd0-c521-459e-9342-2645a109642c.xhtml"><span class="MsoHyperlink">Chapter 2</span></a>, <em>Creating Your First Module</em>, namely the one storing the overridden salutation message. So, inside the <kbd>/config/schema</kbd> folder of the <em>Hello World</em> module, we can have the <kbd>hello_world.schema.yml</kbd> file with the following:</p>
<pre><span>hello_world.custom_salutation:<br/></span><span>  type: </span>config_object<br/>  <span>label: </span><span>'Salutation settings'<br/></span><span>  </span><span>mapping:<br/></span><span>   salutation:<br/></span><span>     type: </span>string<br/>     <span>label: </span><span>'The salutation message'</span></pre>
<p>That takes care of some technical debt we introduced back when we didn't know about configuration schemas.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Overrides</h1>
                </header>
            
            <article>
                
<p>We saw that configuration exists in the but actually belongs in organized and well-described YAML files. In order for the configuration from the YAML files to be used, they need to be imported<span>—</span>either via synchronization or upon module installation for those provided by modules. So, this means that the database still holds the active configuration.</p>
<p>To make things more dynamic, the configuration API also provides an override system by which we can, at various levels, override the active configuration <span>on the fly</span>. In Drupal 7 that was done via the global <kbd>$conf</kbd> variable, but that was also a way to, unfortunately, leak the overrides into the actual configuration pool. This is no longer the case in Drupal 8, and we also have three different layers at which we can override configuration (global, module and language overrides).</p>
<p>The configuration API then takes into account these overrides in a way that prevents leaking them by accident into the active configuration. We will see examples when we talk about how to interact with the configuration API in general.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Global overrides</h1>
                </header>
            
            <article>
                
<p>In Drupal 8, we still have this possibility via a global variable, this time called <kbd>$config</kbd>. This variable is available in the <kbd>settings.php</kbd> file for site-wide overrides, but you can also use it inside your module (if you really have to!) in order to override a specific piece of configuration:</p>
<pre>global $config;<br/>$config['system.maintenance']['message'] = 'Our own message for the site maintenance mode';</pre>
<p>In this example, we changed, on the fly, the message used for the site maintenance mode. Why you would want to do that is beside the point, but you may have some other configuration which would benefit from being overridable like this. In any case, you notice the array notation we use. The first key is the name of the configuration item (name of the file minus the <kbd>.yml</kbd> extension) and then we have the key of the individual element in the configuration file. If this were to be nested, we'd be traversing further down.</p>
<p>Global config overrides are a great place where you can use environment-specific and/or sensitive data such as API keys. Things like this should never be exported to the sync storage. Instead, you can define a configuration object in the module and have it installed without a value. Then, using the global override, you provide the value specific to the relevant environment.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Module overrides</h1>
                </header>
            
            <article>
                
<p>Although you can simply use the global <kbd>$config</kbd> array, that is not really the place where modules should be tinkering. First of all, because it's a global variable and it's never a good idea to change global variables<span>, </span>it should be left to the <kbd>settings.php</kbd> file. Second of all, because there is no way of controlling priority if multiple modules try to change it in the same way. Instead, we have the module override system that we can use.</p>
<p>Via the module overrides, we can create a service with the <kbd>config.factory.override</kbd> tag (remember what tagged services are?) and in this service, handle our overrides. To exemplify, let's use this system to override the maintenance mode message. Inside our Hello World module, we can have the following service class:</p>
<pre><span>namespace </span><span>Drupal\hello_world</span><span>;<br/></span><span><br/></span><span>use </span><span>Drupal\Core\Cache\CacheableMetadata</span><span>;<br/></span><span>use </span><span>Drupal\Core\Config\ConfigFactoryOverrideInterface</span><span>;<br/></span><span>use </span><span>Drupal\Core\Config\StorageInterface</span><span>;<br/></span><span><br/></span><span>/**<br/></span><span> * Overrides configuration for the Hello World module.<br/></span><span> */<br/></span><span>class </span><span>HelloWorldConfigOverrides </span><span>implements </span><span>ConfigFactoryOverrideInterface {<br/></span><span><br/></span><span>  </span><span>/**<br/></span><span>   * {</span><span>@inheritdoc</span><span>}<br/></span><span>   */<br/></span><span>  </span><span>public function </span><span>loadOverrides</span><span>(</span><span>$names</span><span>) {<br/></span><span>    </span><span>$overrides </span><span>= []</span><span>;<br/></span><span>    </span><span>if </span><span>(in_array(</span><span>'system.maintenance'</span><span>, </span><span>$names</span><span>)) {<br/></span><span>      </span><span>$overrides</span><span>[</span><span>'system.maintenance'</span><span>] = [</span><span>'message' </span><span>=&gt; </span><span>'Our own message for the site maintenance mode.'</span><span>]</span><span>;<br/></span><span>    </span><span>}<br/></span><span><br/></span><span>    </span><span>return </span><span>$overrides</span><span>;<br/></span><span>  </span><span>}<br/></span><span><br/></span><span>  </span><span>/**<br/></span><span>   * {</span><span>@inheritdoc</span><span>}<br/></span><span>   */<br/></span><span>  </span><span>public function </span><span>getCacheSuffix</span><span>() {<br/></span><span>    </span><span>return </span><span>'HelloWorldConfigOverrider'</span><span>;<br/></span><span>  </span><span>}<br/></span><span><br/></span><span>  </span><span>/**<br/></span><span>   * {</span><span>@inheritdoc</span><span>}<br/></span><span>   */<br/></span><span>  </span><span>public function </span><span>createConfigObject</span><span>(</span><span>$name</span><span>, </span><span>$collection </span><span>= StorageInterface::</span><span>DEFAULT_COLLECTION</span><span>) {<br/></span><span>    </span><span>return NULL</span><span>;<br/></span><span>  </span><span>}<br/></span><span><br/></span><span>  </span><span>/**<br/></span><span>   * {</span><span>@inheritdoc</span><span>}<br/></span><span>   */<br/></span><span>  </span><span>public function </span><span>getCacheableMetadata</span><span>(</span><span>$name</span><span>) {<br/></span><span>    </span><span>return new </span><span>CacheableMetadata()</span><span>;<br/></span><span>  </span><span>}<br/></span><span>}</span></pre>
<p>Here, we have to implement the <kbd>ConfigFactoryOverrideInterface</kbd> interface which comes with four methods:</p>
<ul>
<li>In <kbd>loadOverrides()</kbd> we provide our overridden configuration values.</li>
<li>In <kbd>getCacheSuffix()</kbd> we return a simple string to be used in the static cache identifier of our overrides.</li>
<li>In <kbd>createConfigObject()</kbd> we don't actually do anything but we could create a configuration API object that would be used during installation or synchronization.</li>
<li>In <kbd>getCacheableMetadata()</kbd> we return any cache metadata related to our override. We don't have any so we return an empty object.</li>
</ul>
<p>Since this is a service, we can inject dependencies and make use of them if we want to calculate the overrides. Depending on this calculation, it can become important to set some proper cache metadata as well, but we will cover caching in another chapter.</p>
<p>Next, we register this as a tagged service:</p>
<pre> hello_world.config_overrider:<br/>   class: \Drupal\hello_world\HelloWorldConfigOverrides<br/>   tags:<br/>     - {name: config.factory.override, priority: 5}</pre>
<p>We set the priority to 5 and, with this, we can control the order in which modules get their chance at overriding configuration. The higher priority will take precedence over the lower one.</p>
<p>And that's it. Clearing the cache will register this service and alter our configuration. If you now put the site in maintenance mode, you will notice that the message is the one we set here. However, if you go to the maintenance mode administration page at <kbd>admin/config/development/maintenance</kbd>, you will still see the original message. This is so that administrators do not, by accident, save the override value into the configuration storage.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Language overrides</h1>
                </header>
            
            <article>
                
<p>Although we will talk some more about the multilingual features of Drupal 8, let's briefly note the possibility of the language overrides.</p>
<p>If we enable configuration translation and add some more languages to our site, we can translate configuration items that are translatable (as described by their schema). In doing so, we are overriding the default configuration for a particular language, an override that gets stored in the configuration storage and can be exported to YAML files. So this is an exportable type of override.</p>
<p>We can make use of this override programmatically, even if we are not in a specific language context. This is what the code would look like, assuming we have an override in French for our maintenance mode message and we want to use that:</p>
<pre><span>$language_manager </span><span>= \Drupal::</span><span>service</span><span>(</span><span>'language_manager'</span><span>)</span><span>;<br/></span><span>$language </span><span>= </span><span>$language_manager</span><span>-&gt;</span><span>getLanguage</span><span>(</span><span>'fr'</span><span>)</span><span>;<br/></span><span>$original_language </span><span>= </span><span>$language_manager</span><span>-&gt;</span><span>getConfigOverrideLanguage</span><span>()</span><span>;<br/></span><span>$language_manager</span><span>-&gt;</span><span>setConfigOverrideLanguage</span><span>(</span><span>$language</span><span>)</span><span>;<br/></span><span>$config </span><span>= \Drupal::</span><span>config</span><span>(</span><span>'system.maintenance'</span><span>)</span><span>;<br/></span><span>$message </span><span>= </span><span>$config</span><span>-&gt;</span><span>get</span><span>(</span><span>'message'</span><span>)</span><span>;<br/></span><span>$language_manager</span><span>-&gt;</span><span>setConfigOverrideLanguage</span><span>(</span><span>$original_language</span><span>)</span><span>;</span></pre>
<p>This looks a bit complicated, but it's not really. First, we load the language manager service and get the <kbd>Language</kbd> object for our language (the one we want to get the overridden value for). Then, we keep track of the original configuration override language (which is essentially the current language) but also set the French language as the one to be used going forward. Finally, we load the <kbd>system.maintenance</kbd> configuration object and read its message in French before <span><span>restoring </span></span>the original language on the language manager. This is a quick way to illustrate an approach by which we can temporarily switch language contexts for configuration overrides. And this will be the way to load configuration entities in a different language to the current one.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Priority</h1>
                </header>
            
            <article>
                
<p>We have three layers for configuration overrides: global, modules, and languages. This is actually also the order of the actual priority they have. Global overrides take precedence over everything else, while module overrides take precedence over the language ones. This is why, if we have overridden the <kbd>system.maintenance</kbd> configuration in the module, we cannot use the language override in our code. So, keep this in mind.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Interacting with simple configuration</h1>
                </header>
            
            <article>
                
<p>Now that we have talked about what the Drupal 8 configuration API is, what is it used for, how is it managed and stored, and what are some of the options for overriding it, it's time to talk about the API itself and how we can interact with it. In this section, we will focus only on simple configuration as we will talk more about configuration entities when we cover all entities.</p>
<p>In <a href="">Chapter 2</a>, <em>Creating Your First Module</em>, we already became somewhat exposed to the configuration API in our <kbd>SalutationConfigurationForm</kbd> where we stored and read a simple configuration value. Now it's time to go a bit deeper to understand the API and look at some more examples of how we can use it.</p>
<p>The class that represents simple configuration is <kbd>Drupal\Core\Config</kbd> and it wraps around the data found in one individual configuration item. Moreover, it does all the necessary in terms of interacting with the underlying storage system in order to persist the configuration (by default into the database). In addition, it handles the overrides we talked about earlier automatically.</p>
<p>An important subclass of <kbd>Config</kbd> that we work with a lot is <kbd>ImmutableConfig</kbd>. Its purpose is to prevent changes being made to the configuration object, and as such, it is for read-only uses.</p>
<p>The way we get to use instances of these classes is through the <kbd>ConfigFactory</kbd> service which has two handy methods for getting a configuration object:</p>
<pre><span>/** </span><span>@var </span><span>\Drupal\Core\Config\ConfigFactoryInterface $factory */<br/></span><span>$factory </span><span>= \Drupal::</span><span>service</span><span>(</span><span>'config.factory'</span><span>)</span><span>;<br/></span><span>$read_only_config </span><span>= </span><span>$factory</span><span>-&gt;</span><span>get</span><span>(</span><span>'hello_world.custom_salutation'</span><span>)</span><span>;<br/></span><span>$read_and_write_config </span><span>= </span><span>$factory</span><span>-&gt;</span><span>getEditable</span><span>(</span><span>'hello_world.custom_salutation'</span><span>)</span><span>;</span></pre>
<p>The <kbd>get()</kbd> method returns an <kbd>ImmutableConfig</kbd> object that is read-only, while the <kbd>getEditable()</kbd> method returns a <kbd>Config</kbd> object that can be used also for changing the configuration values. The way we do this is via the <kbd>set()</kbd> and <kbd>save()</kbd> methods:</p>
<pre>$read_and_write_config-&gt;set('salutation', 'Another salutation');<br/>$read_and_write_config-&gt;save();</pre>
<p>Very simple. We also have the <kbd>setData()</kbd> method which allows us to change the entire data of the configuration item at once. As a parameter, it expects an associative array of values.</p>
<div class="packt_tip">TIP: If you cannot inject the <kbd>ConfigFactory</kbd> but have to rely on the static call, the <kbd>Drupal</kbd> class has a shortcut for loading config objects directly: <kbd>$config = \Drupal::config('system.maintenance');</kbd>. The <kbd>config()</kbd> method takes the name of the configuration as a parameter and returns an <kbd>ImmutableConfig</kbd> object.</div>
<p>To read the data, we have a number of options. We can read one element from the config:</p>
<pre>$value = $read_and_write_config-&gt;get('salutation'); </pre>
<p>If the element is nested, we can traverse down via the dot <kbd>(.)</kbd> notation:</p>
<pre>$config = $factory-&gt;get('system.site');<br/>$value = $config-&gt;get('page.403');</pre>
<p>This will return the value set for the 403 page in the <kbd>system.site</kbd> configuration. We can also get all the values by simply not passing any parameters to the <kbd>get()</kbd> method, which would return an associative array.</p>
<p>If you remember our discussion about the configuration overrides, by default, the <kbd>get()</kbd> method will return the values as they had been overridden through the module or globally (or as a language if the language manager has a different language set for configuration). However, if we want, we can also retrieve the original value:</p>
<pre>$config = $factory-&gt;get('system.maintenance');<br/>$value = $config-&gt;getOriginal('message', FALSE);</pre>
<p>The second parameter of <kbd>getOriginal()</kbd> indicates whether to apply overrides and, by default, it is <kbd>TRUE</kbd>. So this way, we get the configuration value that is set in the active storage.</p>
<p>Finally, we can also clear configuration values or the entire objects themselves. For example, consider the following code:</p>
<pre>$config-&gt;clear('message')-&gt;save();</pre>
<p>It will remove the <kbd>message</kbd> key from the configuration object and save it without that value. Alternatively, we can also remove the entire thing:</p>
<pre>$config-&gt;delete(); </pre>
<p>That is pretty much it. The power of this API also stems from its simplicity.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Entities</h1>
                </header>
            
            <article>
                
<p>We have finally reached the point where we talk about the most complex, robust, and powerful system for modeling data and content in Drupal 8<span>—</span>the Entity API.</p>
<p>Entities have been around since Drupal 7 which shipped with a few types such as node, taxonomy terms, users, comments, files, and so on. However, Drupal core only provided a basic API for defining entities and loading them consistently. The <em>Entity API</em> contributed module bridged a large gap and provided a lot of functionality to make entities much more powerful. In Drupal 8, however, these principles (and more) are found in core as part of a robust data modeling system.</p>
<p>The Entity API integrates seamlessly with the multilingual system to bring fully translatable content and configuration entities. This means that most data you store can be translated easily into multiple languages. In Drupal 7, this was always a herculean task that involved over 10 contributed modules to achieve something not nearly as powerful as we have now.</p>
<p>Because there is so much to cover about entities, in this section we will start with just a general overview of the entity system. But not to worry, in the next section, and all the way to the end of this chapter, we will break it down and talk about all the important aspects.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Content versus configuration entity types</h1>
                </header>
            
            <article>
                
<p>Let us start by establishing some basic terminology in order to prevent confusion down the line:</p>
<ul>
<li>Entities are instances of a given entity type. Thus, we can have one or more entities of a certain type, the latter being like a blueprint for the individual entities.</li>
<li>Entity types can be of two kinds: content and configuration.</li>
</ul>
<p>We talked a little bit about configuration entities in the previous section. There, we saw that they are multiple instances of a certain <em>type</em> of configuration, as opposed to simple configuration, which is only one set of configuration values. Essentially, configuration entities are exportable sets of configuration values that inherit much of the same handling API as content entities.</p>
<p>Some examples of configuration entity types:</p>
<ul>
<li>View: A set of configuration values that make up a view</li>
<li>Image Style: Defines how an image needs to be manipulated in that given style</li>
<li>Role: Defines a role that can be given to a user</li>
</ul>
<p>Content entities, on the other hand, are not exportable and are the most important way we can model and persist data in Drupal 8. These can be used for content and all sorts of other structured data used in your business logic that needs to be persisted but not deployed to other environments.</p>
<p>Some examples of content entity types:</p>
<ul>
<li>Node</li>
<li>Comment</li>
<li>User</li>
<li>Taxonomy Term</li>
</ul>
<p>Apart from the exportability aspect, the main difference between content and configuration entities is the type of fields they use. The latter uses simpler fields, the combination of which gets stored as one entity "record" in the database (and exported to YAML). The content entity fields are complex and structured both in code modeling and in the persistence layer (the database).</p>
<p>Moreover, configuration entities also lack bundles. Bundles are yet another categorization of entities that sits below the content entity type. That means that each content entity type can have (but it doesn't have to have) one or more bundles, onto which configurable fields can be attached. And not to throw more confusion at you but bundles are actually configuration entities themselves as they need to be exported, and there can be multiples of them.</p>
<p>The Entity API is very flexible in terms of the types of data that you can store. Content entity types come with a number of different field types for various forms of data, from primitive values to more complex ones such as dates or references.</p>
<p>Content entities can also be made revisionable. This means content entity types can be configured to keep in store older versions of the same entity with some extra metadata related to the change process.</p>
<p>In this section and going forward, I will illustrate the most common features of entities by way of exemplifying two entity types:</p>
<ul>
<li>Node: The most prolific content entity type that comes with Drupal core and that is typically used as the main content modeling entity type</li>
<li>NodeType: The configuration entity type that defines Node bundles</li>
</ul>
<p>In the next chapter, we will learn how to create our own. But after everything we will have  here, it will be a breeze.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Entity type plugins</h1>
                </header>
            
            <article>
                
<p>Entity types are registered with Drupal as plugins. Yes, again. The <kbd>Drupal\Core\Entity\Annotation\EntityType</kbd> class is the base annotation class for these plugins and you will mainly see two subclasses (annotations): <kbd>ContentEntityType</kbd> and <kbd>ConfigEntityType</kbd>. These are used to register content and configuration entity types, respectively.</p>
<p>The annotations classes map to plugin classes used to represent the entity types. The base class for these is <kbd>Drupal\Core\Entity\EntityType</kbd>, which is then extended by another <kbd>ContentEntityType</kbd> and <kbd>ConfigEntityType</kbd>. These plugin classes are used to represent the entity types in the system and are a good resource for seeing what kind of data we can use on the annotation of these plugins. At a quick glance we can already see that the differences between the two types is not so big.</p>
<p>The plugin manager for entity types is the <kbd>EntityTypeManager</kbd>, an important service you will probably interact with most as a Drupal developer. Apart from various handy things we will see a bit later, it is responsible for managing the entity type plugins using the regular annotation-based discovery method.</p>
<p>The Node entity type is defined in <kbd>Drupal\node\Entity\Node</kbd>, where you will see a huge annotation at the top of the class. The NodeType configuration entity type, on the other hand, is found in <kbd>Drupal\node\Entity\NodeType</kbd>. You can spot the difference in the annotation they use.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Identifiers</h1>
                </header>
            
            <article>
                
<p>The entity type annotations start with some basic information about them: ID, label, and things like that. For example, consider the Node entity:</p>
<pre>  *   id = "node",<br/>  *   label = @Translation("Content"),<br/>  *   label_singular = @Translation("content item"),<br/>  *   label_plural = @Translation("content items"),<br/>  *   label_count = @PluralTranslation(<br/>  *     singular = "@count content item",<br/>  *     plural = "@count content items"<br/>  *   ),</pre>
<p>These are used in various places in the system to properly reference the entity type by machine and human readable names.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Bundles</h1>
                </header>
            
            <article>
                
<p>The Node entity type happens to have bundles which is the reason why we have a <kbd>bundle_label</kbd> property as well:</p>
<pre>bundle_label = @Translation("Content type"), </pre>
<p>We can deduce that Node has bundles by the fact that it references the ID of the plugin defining the bundle configuration entity type:</p>
<pre>bundle_entity_type = "node_type", </pre>
<p>Lo and behold, that is the NodeType's <kbd>ConfigEntityType</kbd> plugin ID. On its plugin annotation, we can find the reverse <kbd>bundle_of</kbd> property that references the Node entity type. Needless to say, this is not mandatory for all configuration entity types but used for the ones that act as content entity bundles. For example, the <kbd>View</kbd> configuration entity type does not have this.</p>
<p>In addition, we also find on the Node plugin annotation the route to where the bundles are configured:</p>
<pre>field_ui_base_route = "entity.node_type.edit_form",</pre>
<p>This is a route defined for the NodeType configuration entity.</p>
<p>As I mentioned earlier, bundles do not exist for configuration entities.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Database tables</h1>
                </header>
            
            <article>
                
<p>Another important bit of information for content entities is the database table name they will use for storage:</p>
<pre>base_table = "node",<br/>data_table = "node_field_data",</pre>
<p>The <kbd>node</kbd> table in this case holds the primary information about the entities such as ID, uuid or bundle, while the <kbd>node_field_data</kbd> table holds field data that is singular and not translatable. Otherwise, these fields get their own database tables automatically. I will explain how field data is stored a bit later on.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Entity keys</h1>
                </header>
            
            <article>
                
<p>The entity API defines a set of <em>keys</em> that are consistent across all entity types and by which common entity information can be retrieved. Since not all entity types need to have the same fields for storing that data, there is a mapping that can be done in the annotation for these:</p>
<pre>*   entity_keys = { 
*     "id" = "nid", 
*     "revision" = "vid", 
*     "bundle" = "type", 
*     "label" = "title", 
*     "langcode" = "langcode", 
*     "uuid" = "uuid", 
*     "status" = "status", 
*     "published" = "status", 
*     "uid" = "uid", 
*     "owner" = "uid", 
*   }, 
 </pre>
<p>The Node entity type has a relatively comprehensive example of entity keys. As you can see, the unique identifier field for Nodes has always been <kbd>nid</kbd>. However, the common identifier for entities across the system is <kbd>id</kbd>. So, a mapping here helps facilitate that.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Links</h1>
                </header>
            
            <article>
                
<p>Each entity type has a series of links the system needs to know about. Things like the canonical URL, the edit URL, the creation URL, and so on. For the node entities we have the following:</p>
<pre>*   links = { 
*     "canonical" = "/node/{node}", 
*     "delete-form" = "/node/{node}/delete", 
*     "delete-multiple-form" = "/admin/content/node/delete", 
*     "edit-form" = "/node/{node}/edit", 
*     "version-history" = "/node/{node}/revisions", 
*     "revision" = "/node/{node}/revisions/{node_revision}/view", 
*     "create" = "/node", 
*   } </pre>
<p>Like the entity keys, these links are common across all entity types (depending on their enabled capabilities). For example, all entity types have a canonical URL and the API allows to quickly find out which one that is based on the definition.</p>
<p>One thing to note about these paths is that they need to be defined as routes. So, you can find them inside the <kbd>node.routing.yml</kbd> file (where you also find the routes used by the NodeType configuration entity type). Alternatively, though, these routes can be defined dynamically in order to prevent duplication. This can be done using a route provider handler. We will talk about handlers soon but also see a concrete example in the next chapter. In case you were wondering where the missing routes for the Node links are, check the <kbd>NodeRouteProvider</kbd> that registers them.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Entity translation</h1>
                </header>
            
            <article>
                
<p>Entities are translatable across the board<span>—</span>like most of everything else in Drupal 8. To mark an entity type as such, all we need is the following in the plugin annotation:</p>
<pre>translatable = TRUE, </pre>
<p>This exposes the entity type to all the multilingual goodness. However, as we will see a bit later, the individual fields also need to be declared translatable.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Entity revisions</h1>
                </header>
            
            <article>
                
<p>In Drupal 8, all content entity types can be made revisionable (and publishable) with minimal effort. Since Node is such an example, we can check out how it's built to understand this better.</p>
<p>First, the annotation needs to have the database table information where revisions are stored. This mirrors exactly the original tables we saw before:</p>
<pre>revision_table = "node_revision",<br/>revision_data_table = "node_field_revision",</pre>
<p>Second, the annotation needs to have the entity keys for the revision ID and the published status we saw earlier:</p>
<pre>*   entity_keys = { 
*     "revision" = "vid", 
*     "published" = "status", 
*   }, </pre>
<p>Third, also in the annotation, the revision metadata keys need to be referenced:</p>
<pre>*   revision_metadata_keys = { 
*     "revision_user" = "revision_uid", 
*     "revision_created" = "revision_timestamp", 
*     "revision_log_message" = "revision_log" 
*   },   </pre>
<p>These map to table columns in the revision table. And in order to ensure that all the necessary columns get created, the entity type class should extend from <kbd>EditorialContentEntityBase</kbd> which provides the necessary field definitions for this. But good to know also that this base class already implements the <kbd>EntityPublishedInterface</kbd> which allows to make the entity type publishable.</p>
<p>Finally, the entity fields themselves are not automatically revisionable so a flag<span> </span>needs to be <span>also </span>set on them. Again, we will see that in a minute when we talk about the fields.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Configuration export</h1>
                </header>
            
            <article>
                
<p>Configuration entity types have a few extra options on their plugin definitions that relate to the exportability of the entities. By default, a number of configuration entity fields are persisted and exported. However, the <kbd>config_export</kbd> property needs to be used to declare which other fields should be included in the export. For example, the NodeType configuration entity type defines the following:</p>
<pre>*   config_export = {<br/>*     "name",<br/>*     "type",<br/>*     "description",<br/>*     "help",<br/>*     "new_revision",<br/>*     "preview_mode",<br/>*     "display_submitted",<br/>*   }</pre>
<p>Keep in mind that, without this definition, the configuration schema is used as a fallback to determine which fields to persist. If the configuration entity type doesn't have a schema (which it should though), no extra fields will get persisted.</p>
<p>Additionally, configuration entity types have a prefix that is used for the namespace in the configuration system. This is also defined in the plugin annotation:</p>
<pre>config_prefix = "type", </pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Handlers</h1>
                </header>
            
            <article>
                
<p>The last main group of settings found on the entity type plugin annotations are the handlers. Handlers are the objects used by the entity API to manage various tasks related to entities. The Node entity type is a good example to look at because it defines quite a lot of them, giving us an opportunity to learn:</p>
<pre>*   handlers = { 
*     "storage" = "Drupal\node\NodeStorage", 
*     "storage_schema" = "Drupal\node\NodeStorageSchema", 
*     "view_builder" = "Drupal\node\NodeViewBuilder", 
*     "access" = "Drupal\node\NodeAccessControlHandler", 
*     "views_data" = "Drupal\node\NodeViewsData", 
*     "form" = { 
*       "default" = "Drupal\node\NodeForm", 
*       "delete" = "Drupal\node\Form\NodeDeleteForm", 
*       "edit" = "Drupal\node\NodeForm", 
*       "delete-multiple-confirm" = "Drupal\node\Form\DeleteMultiple" 
*     }, 
*     "route_provider" = { 
*       "html" = "Drupal\node\Entity\NodeRouteProvider", 
*     }, 
*     "list_builder" = "Drupal\node\NodeListBuilder", 
*     "translation" = "Drupal\node\NodeTranslationHandler" 
*   }, </pre>
<p>As we can immediately notice, these are all simple references to classes. So, when in doubt, it's always a good idea to go and see what they do and how they work. But let's briefly talk about all of them and see what their main responsibility is.</p>
<ul>
<li>The <kbd>storage</kbd> handler is one of the most important. It does all that has to do with CRUD operations and interacting with the underlying storage system. It is always an implementation of <kbd>EntityStorageInterface</kbd> and sometimes a parent of the <kbd>ContentEntityStorageBase</kbd> or <kbd>ConfigEntityStorage</kbd> classes. If the entity type does not declare one, it will default to <kbd>SqlContentEntityStorage</kbd> (since we are using a SQL database most of the time) or <kbd>ConfigEntityStorage</kbd> for configuration entities.</li>
<li>The <kbd>storage_schema</kbd> handler is not something you will deal with too much. Its purpose is to handle the schema preparations for the storage handler. It will default to the <kbd>SqlContentEntityStorageSchema</kbd> if one is not provided and it will take care of the database tables needed for the entity type definition.</li>
<li>The <kbd>view_builder</kbd> handler is an <kbd>EntityViewBuilderInterface</kbd> implementation responsible for creating a render array out of an entity with the purpose of preparing it for display. If one is not specified, it defaults to <kbd>EntityViewBuilder</kbd>.</li>
<li>The <kbd>access</kbd> handler is an <kbd>EntityAccessControlHandlerInterface</kbd> implementation responsible for checking the access for any of the CRUD operations on a given entity of the respective type. If one is not provided, the default <kbd>EntityAccessControlHandler</kbd> is used; it also triggers the access hooks modules can implement to have a say in the access rules of a given entity. We will talk a lot more about access in a dedicated chapter later on.</li>
<li>The <kbd>views_data</kbd> handler is an <kbd>EntityViewsDataInterface</kbd> implementation responsible for exposing the respective entity type to the Views API. This is used so that Views is able to properly understand the entity and fields. By default, it uses the generic <kbd>EntityViewsData</kbd> if one is not provided.</li>
<li>The <kbd>form</kbd> handlers are <kbd>EntityFormInterface</kbd> implementations used for various types of entity manipulations such as create, edit and delete. The referenced classes are forms that are used for managing the entities.</li>
</ul>
<ul>
<li>The <kbd>route_provider</kbd> handlers are <kbd>EntityRouteProviderInterface</kbd> implementations responsible for dynamically providing routes necessary for the respective entity type. The Node entity type defines one for HTML pages, but others can be defined for other kinds of HTTP formats as well.</li>
<li>The <kbd>list_builder</kbd> handler is an <kbd>EntityListBuilderInterface</kbd> implementation responsible for building a listing of entities of the respective type. This listing is typically used on the administration screen for managing the entities. This is an important one to have since, without it, the admin listing won't work. The default implementation is <kbd>EntityListBuilder</kbd>.</li>
<li>The <kbd>translation</kbd> handler is a <kbd>ContentTranslationHandlerInterface</kbd> implementation responsible for exposing the entities of this type to the translation API.</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Fields</h1>
                </header>
            
            <article>
                
<p>The principal way data is modeled by entities is through fields. Entities themselves are essentially just a collection of different types of fields that hold various types of data.</p>
<p>Drupal 7 developers will remember that in D7, entities had two types of fields, usually referred to as properties and Field UI fields. The former were essentially simple properties on the entity class and were stored in the entity table itself. The latter were fields that were attached to bundles through the UI and had separate database tables.</p>
<p>Things are somewhat similar in Drupal 8 but also very different. First of all, <span><span>there is </span></span>a big difference between the fields that belong to content versus configuration entities. Then, as in D7, we still make a distinction between two types of content entity fields: base fields and configurable fields. However, this is not as big as it used to be in D7 as they both have the same foundation.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Configuration entity fields</h1>
                </header>
            
            <article>
                
<p>Configuration entities have relatively simple fields, due to their storage handling. We can store complex configuration but there is no complex database schema to reflect that. Instead, we have the configuration schema layer that describes configuration entities so the Entity API can understand the types of data they store and represent. We talked about this earlier in the chapter when we looked at the configuration system. But let's examine the NodeType configuration entity type to better understand its fields.</p>
<p>The fields on configuration entities are essentially declared as class properties. So, we can see that NodeType has fields such as <kbd>$description</kbd>, <kbd>$help</kbd> and others. As I mentioned a bit earlier, the plugin annotation includes a reference to the class properties that are to be persisted and exported. As you can imagine, a class should be allowed to also have some properties that are not actually field values that need to be exported.</p>
<p>The configuration entity class can also have some specific getter and setter methods for its field, but can also rely on the <kbd>ConfigEntityBase</kbd> parent class <kbd>set()</kbd> and <kbd>get()</kbd> methods for setting and accessing field values. Things are relatively simple to understand.</p>
<p>Now, let's check out the NodeType configuration schema found in <kbd>node.schema.yml</kbd> and see what that is all about:</p>
<pre><span>node.type.*:<br/></span><span>  type: </span>config_entity<br/>  <span>label: </span><span>'Content type'<br/></span><span>  </span><span>mapping:<br/></span><span>   name:<br/></span><span>     type: </span>label<br/>     <span>label: </span><span>'Name'<br/></span><span>   </span><span>type:<br/></span><span>     type: </span>string<br/>     <span>label: </span><span>'Machine-readable name'<br/></span><span>   </span>....<br/>   <span>new_revision:<br/></span><span>     type: </span>boolean<br/>     <span>label: </span><span>'Whether a new revision should be created by default'<br/></span><span>   </span>...</pre>
<p>This is just a sample of the schema definition without some of the fields because we already know how to read those. However, there are some things that are new though.</p>
<p>We can see the wildcard notation that indicates that this schema should apply to all configuration items that start with that prefix. So, essentially, to all entities of a certain type. In this case, the entity type name is <kbd>type</kbd>, as denoted in the NodeType annotation <kbd>config_prefix</kbd> property. Of course, the namespace is prefixed by the module name.</p>
<p>Next, we see that the type is <kbd>config_entity</kbd>, which is the other major complex type besides <kbd>config_object</kbd> used to denote simple configuration. These are basically extensions of the <kbd>mapping</kbd> type with some extra information. In the case of configuration entities, these are the definitions for the fields that automatically get exported<span>—</span><kbd>uuid</kbd>, <kbd>langcode</kbd>, <kbd>status</kbd>, <kbd>dependencies</kbd> and <kbd>third_party_settings</kbd>. That is to say, these fields exist on all configuration entities of any type and are always persisted/exported.</p>
<p>Lastly, we have the schema definitions for each individual field, such as <kbd>name</kbd>, <kbd>type</kbd>, and more. So, now the system knows that the <kbd>new_revision</kbd> field should be treated as a Boolean, or that the <kbd>name</kbd> field is translatable (since it is of a type label that extends the simple <kbd>string</kbd> type with the translation flag on).</p>
<p>So, as you can see, the field matrix of a configuration entity type is not so complex to understand. Content entities are much more complex and we will talk about those next.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Content entity fields</h1>
                </header>
            
            <article>
                
<p>As in Drupal 7, content entities in D8 have two types of fields: base fields and configurable fields. For Drupal 7 developers, the former are essentially the old "property" fields, while the latter are the "Field UI" fields. However, as we will see in a moment, they are now very different implementations in that they are very similar to each other.</p>
<p>First and foremost, content entity fields in Drupal 8 are built on top of the low-level TypedData API. The latter is a complex system for modeling data in code and is widely used in Drupal 8. Unfortunately, it is also one of the APIs least understood by developers. Not to worry, in the next section I will break it down for you. Since we still don't know anything about it, we will now talk about fields from a higher-level perspective.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Base fields</h1>
                </header>
            
            <article>
                
<p>Base fields are the fields closest to a given entity type, things like the title, creation/modification date, publication status, and so on. They are defined in the entity type class as <kbd>BaseFieldDefinition</kbd> implementations and are installed in the database based on these definitions. Once installed, they are no longer configurable from a storage point of view from the UI (except in some cases, in which certain aspects can be overridden). Additionally, some display and form widget configuration changes can still be made (also depending on whether the individual definitions allow this).</p>
<p>Let's check out the Node entity type's <kbd>baseFieldDefinitions()</kbd> method and see an example of a base field definition:</p>
<pre><span>$fields</span><span>[</span><span>'title'</span><span>] = BaseFieldDefinition::</span><span>create</span><span>(</span><span>'string'</span><span>)<br/></span><span>  -&gt;</span><span>setLabel</span><span>(t(</span><span>'Title'</span><span>))<br/></span><span>  -&gt;</span><span>setRequired</span><span>(</span><span>TRUE</span><span>)<br/></span><span>  -&gt;</span><span>setTranslatable</span><span>(</span><span>TRUE</span><span>)<br/></span><span>  -&gt;</span><span>setRevisionable</span><span>(</span><span>TRUE</span><span>)<br/></span><span>  -&gt;</span><span>setSetting</span><span>(</span><span>'max_length'</span><span>, </span><span>255</span><span>)<br/></span><span>  -&gt;</span><span>setDisplayOptions</span><span>(</span><span>'view'</span><span>, </span><span>[<br/></span><span>    </span><span>'label' </span><span>=&gt; </span><span>'hidden'</span><span>,<br/></span><span>    </span><span>'type' </span><span>=&gt; </span><span>'string'</span><span>,<br/></span><span>    </span><span>'weight' </span><span>=&gt; -</span><span>5</span><span>,<br/></span><span>  </span><span>])<br/></span><span>  -&gt;</span><span>setDisplayOptions</span><span>(</span><span>'form'</span><span>, </span><span>[<br/></span><span>    </span><span>'type' </span><span>=&gt; </span><span>'string_textfield'</span><span>,<br/></span><span>    </span><span>'weight' </span><span>=&gt; -</span><span>5</span><span>,<br/></span><span>  </span><span>])<br/></span><span>  -&gt;</span><span>setDisplayConfigurable</span><span>(</span><span>'form'</span><span>, </span><span>TRUE</span><span>)</span><span>;</span></pre>
<p>This is the definition of the Node <kbd>title</kbd> field. We can deduce <span><span>that is of</span></span> of the <kbd>string</kbd> type due to the argument passed to the <kbd>create()</kbd> method of the <kbd>BaseFieldDefinition</kbd> class. The latter is a complex data definition class on top of the TypedData API.</p>
<p>Other common types of fields that can be defined are <kbd>boolean</kbd>, <kbd>integer</kbd>, <kbd>float</kbd>, <kbd>timestamp</kbd>, <kbd>datetime</kbd>, <kbd>entity_reference</kbd>, <kbd>text_long</kbd>, and many others. You can find out what field types you can use by checking the available <kbd>FieldType</kbd> plugins provided by Drupal core and any other modules. These are the same types of fields that can be used by configurable fields in the UI. In a later chapter, we will see how we can write our own custom field type.</p>
<p>The field definition can have a number of options that may also differ depending on the type of field being defined. I will skip the obvious ones here and jump to the <kbd>setTranslatable()</kbd> and <kbd>setRevisionable()</kbd> methods and ask you to remember when we saw earlier how the Node entity type plugin annotation indicated that Nodes will be translatable and revisionable. This is where the fields themselves are configured to that effect. Without these settings, they'd be left out of the translation capability and revisions.</p>
<div class="packt_infobox">If you take a look at how the <kbd>baseFieldDefinitions()</kbd> method starts, you'll see that it inherits some fields from the parent class as well. This is where common field definitions are inherited, which allow for the entity type to be revisionable and publishable.</div>
<p>The <kbd>setSetting()</kbd> method is used to provide various options to the field. In this case, it's used to indicate the maximum length, which is also mirrored in the table column in the database. Then, we have the display options that configure the view formatter and form widget the field should use. They reference plugin IDs of the type <kbd>FieldFormatter</kbd> (<kbd>string</kbd>) and <kbd>FieldWidget</kbd> (<kbd>string_textfield</kbd>) plugins, respectively. In a later chapter, we will see how we can define our own field plugins that can be used for both base and configurable fields.</p>
<p>Lastly, we have the <kbd>setDisplayConfigurable()</kbd> method which is used to enable/disable configuration changes on the form widget or display through the UI. In this case, only the form widget is exposed to changes.</p>
<p>Not all these options and configurations are always used or mandatory. It depends on what type of field we are defining, how we want the field to be configured, and whether defaults are okay for us. An important option that can be used on all field types is cardinality<span>—</span>whether the field can have more than one value of the same type. This allows a field to store multiple values that follow the same data definition on that entity field.</p>
<p>If we create our own entity type and want to later add or modify a base field, we can do that in the same place as we originally defined them<span>—</span>in the entity class. However, for entities that do not "belong" to us, we need to implement some hooks in order to contribute with our own changes. To provide a new base field definition to an existing entity type, we can implement <kbd>hook_entity_base_field_info()</kbd> in our module and return an array of <kbd>BaseFieldDefinition</kbd> items just as we saw before in the Node entity type. Alternatively, we can implement <kbd>hook_entity_base_field_info_alter()</kbd> and alter existing base field definitions to our liking. Do keep in mind that this latter hook might be changed in the future, although at the time of writing, no great priority has been given to that.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Configurable fields</h1>
                </header>
            
            <article>
                
<p>Configurable fields are typically created through the UI, <strong>attached to an entity type bundle</strong>, and exported to code. The part highlighted with bold is a critical difference between these and base fields in that base fields exist on all bundles of the entity type. You should already be familiar with the UI for creating a configurable field:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/ef0059e3-790d-4d44-a6e6-f2bb926f1a72.png" style="width:28.58em;height:36.08em;"/></p>
<p>They also use the TypedData API for their definitions, as well as the same field type, widget, and formatter plugins we talked about earlier. Architecturally speaking, the main difference between base and configurable fields is that the latter are made up of two parts: storage configuration (<kbd>FieldStorageConfig</kbd>) and field configuration (<kbd>FieldConfig</kbd>). These are both configuration entity types, whose entities, together, make up a configurable field. The former defines the field settings that relate to how the field is stored. These are options that apply to that particular field across all the bundles of an entity type it may be attached to (such as cardinality, the field type, and so on). The latter defines options for the field specific to the bundle it is attached to. These can, in some cases, be overrides of the storage config but also new settings (such as the field description, whether it is required, and more).</p>
<p>The easiest way to create configurable fields is through the UI. Just as easily, you get them exported into code. You could alternatively write the field storage configuration and field configuration yourself and add it to your module's <kbd>config/install</kbd> folder, but you can achieve the same if you just export them through the UI.</p>
<p>Moreover, you can use a couple of hooks to make alterations to existing fields. For example, by implementing <kbd>hook_entity_field_storage_info_alter()</kbd> you can alter field storage configurations, while with <kbd>hook_entity_bundle_field_info_alter()</kbd> you can alter field configurations as they are attached to an entity type bundle.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Field storage</h1>
                </header>
            
            <article>
                
<p>We earlier saw how configuration entities are persisted and exported based on the configuration schema and plugin definition. Let's quickly talk about how the fields used on content entities are stored in the database.</p>
<p>Base fields, by default, end up in the entity base table (the one defined in the plugin annotation as <kbd>base_table</kbd>). This makes things more performant than having them in individual tables. However, there are some exceptions to this.</p>
<p>If the entity type is translatable, a "data" table gets created where records of the same entity base field values in different languages can be stored. This is the table the Node entity type plugin annotation declared with the property <kbd>data_table</kbd>. If this property is missing, the table name will by default be <kbd>[base_table]_field_data</kbd>.</p>
<p>Moreover, if the field cardinality of a given field is higher than 1, a new table is created for the field with the name <kbd>[entity_type_name]__[field_name]</kbd> where multiple records for the same field can be stored.</p>
<p>If the entity and field have translation enabled and the respective field cardinality is higher than <span><span>one</span></span>, the "data" table holds the records for an entity in all languages it is translated into, while the <kbd>[entity_type_name]__[field_name]</kbd> table holds all the value records in all languages for a given field.</p>
<p>Configurable fields, on the other hand, always get a separate field data table named <kbd>[entity_type_name]__[field_name]</kbd>, where the multiple values for the same field and in multiple languages can be stored.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Entity types summary</h1>
                </header>
            
            <article>
                
<p>The Entity API is quite complex. We have only begun our journey to understanding the different kinds of entity types, bundles, fields, and so on. We have so far talked about the differences between configuration and content entity types and what exactly they are made up of. To this end, we also touched upon the different types of fields they can use and how the data in these fields is stored.</p>
<p>However, there is still a lot to understand about entities, especially content entities, which will be our focus in the next sections. We are going to first look at the TypedData API to better understand how content entity field data is modeled. As of now, that is still a black box; am I right? Next, we'll look at how to actually work with the API to query, create, and manipulate entities (both content and configuration). Finally, we'll talk a bit about the validation API the content entities and fields use consistently to ensure they hold proper data. So, let's get to it.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">TypedData</h1>
                </header>
            
            <article>
                
<p>In order to really understand how entity data is modeled, we need to understand the TypedData API. Unfortunately, this API still remains quite a mystery for many. But you're in luck because, in this section, we're going to get to the bottom of it.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Why TypedData?</h1>
                </header>
            
            <article>
                
<p>It helps to understand things better if we first talk about why there was the need for this API. It all has to do with the way PHP as a language <em>is</em>, compared to others, and that is, loosely typed. This means that in PHP it is very difficult to use native language constructs to rely on the type of certain data or understand more about that data.</p>
<p>The difference between the string <kbd>"1"</kbd> and integer <kbd>1</kbd> is a very common example. We are often afraid of using the <kbd>===</kbd> sign to compare them because we never know what they actually come back as from the database or wherever. So, we either use <kbd>==</kbd> (which is not really good) or forcefully cast them to the same type and hope PHP will be able to get it right.</p>
<p>In PHP 7, we have type hinting for scalar values in function parameters which is good, but still not enough. Scalar values alone are not going to cut it if you think of the difference between <kbd>1495875076</kbd> and <kbd>2495877076</kbd>. The first is a timestamp while the second is an integer. Even more importantly, the first has meaning while the second one does not. At least seemingly. Maybe I want it to have some meaning because it is the specific formatting for the IDs in my package tracking app.</p>
<p>Drupal was not exempt from the problems this loosely typed nature of PHP can create. Drupal 7 developers know very well what it meant to deal with field values in this way. But not anymore because we now have the TypedData API in Drupal 8.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">What is TypedData?</h1>
                </header>
            
            <article>
                
<p>The TypedData API is a low-level and generic API that essentially does two things from which a lot of power and flexibility is derived.</p>
<p>First, it wraps "values" of any kind of complexity. More importantly, it forms "values". This can be a simple scalar value to a multidimensional map of related values of different types that together are considered one value. Let's take, for example, a New York license plate: <kbd>405-307</kbd>. This is a simple string but we "wrap" it with TypedData to give it meaning. In other words, we know programmatically that it is a license plate and not just a random PHP string. But wait, that plate number can be found in other states as well (possibly, I have no idea). So, in order to better define a plate, we need also a state code: <kbd>NY</kbd>. This is another simple string wrapped with TypedData to give it meaning<span>—</span>a state code. Together, they can become a slightly more complex piece of TypedData: US license plate, which has its own meaning.</p>
<p>Second, as you can probably infer, it gives meaning to the data that it wraps. If we continue our previous example, the US license plate TypedData now has plenty of meaning. So, we can programmatically ask it what it is and all sorts of other things about it, such as what is the state code for that plate. And the API facilitates this interaction with the data.</p>
<p>As I mentioned, from this flexibility, a lot of power can be built on top. Things like data validation are very important in Drupal 8 and rely on TypedData. As we will see later in this chapter, validation happens at the TypedData level using constraints on the underlying data.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The low-level API</h1>
                </header>
            
            <article>
                
<p>Now that we have a basic understanding of the principles behind TypedData and why we need it, let's start exploring the API, starting from the smallest pieces and going up.</p>
<p>There are two main pillars of this API: <kbd>DataType</kbd> plugins and data definitions.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">DataType plugins</h1>
                </header>
            
            <article>
                
<p>DataType plugins are responsible for defining the available types of data that can be used in the system. For example, the <kbd>StringData</kbd> plugin is used to model a simple primitive string. Moreover, they are responsible for interacting with the data itself; things like setting and accessing the respective values.</p>
<p>The DataType plugins are managed by the <kbd>TypedDataManager</kbd> and are annotated by the <kbd>DataType</kbd> annotation class. They implement the <kbd>TypedDataInterface</kbd> and typically extend the <kbd>TypedData</kbd> base class or one of its subclasses.</p>
<p>There are three main types of DataType plugins out there, depending on the interface they implement:</p>
<ul>
<li>First, there is the <kbd>TypedDataInterface</kbd> I mentioned before; this is typically used for simple primitive values such as strings or integers.</li>
<li>Second, there is the <kbd>ListInterface</kbd> which is used to form a collection of other TypedData elements. It comes with methods specific to interacting with lists of elements.</li>
<li>Third, there is <kbd>ComplexDataInterface</kbd> which is used for more complex data formed of multiple properties that have names and can be accessed accordingly. Going forward, we will see examples of all these types.</li>
</ul>
<p>The best way to understand how these plugins are used is to first talk about data definitions as well.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Data definitions</h1>
                </header>
            
            <article>
                
<p>Data definitions are the objects used to store all that meaning about the underlying data we talked about. They define the type of data they can hold (using an existing DataType plugin) and any kind of other meaningful information about that data. So, together with the plugins, the data definitions are one mean data modeling machine.</p>
<p>At the lowest level, they implement the <kbd>DataDefinitionInterface</kbd> and typically extend the <kbd>DataDefinition</kbd> class (or one of its subclasses). Important subclasses of <kbd>DataDefinition</kbd> are <kbd>ListDefinition</kbd> and <kbd>ComplexDefinitionBase</kbd> which are used to define more complex data types. And as you might expect, they correlate to the <kbd>ListInterface</kbd> and <kbd>ComplexDataInterface</kbd> plugins I mentioned earlier.</p>
<p>Let us see an example of a simple usage of data definitions and DataType plugins by modeling a simple string<span>—</span><kbd>my_value</kbd>.</p>
<p>It all starts with the definition:</p>
<pre>$definition = DataDefinition::create('string'); </pre>
<p>The argument we pass to the <kbd>create()</kbd> method is the DataType plugin ID we want to be defining our data as. In this case, it is the <kbd>StringData</kbd> plugin.</p>
<p>We already have some options out of the box to define our string data. For example, we can set a label:</p>
<pre>$definition-&gt;setLabel('Defines a simple string');  </pre>
<p>We can also mark it as read only or set whatever "settings" we want onto the definition. However, one thing we don't do is deal with the actual value. This is where the DataType plugin comes into play. The way this happens is that we have to create a new plugin instance, based on our definition and a value:</p>
<pre>/** @var \Drupal\Core\TypedData\TypedDataInterface $data */<br/>$data = \Drupal::typedDataManager()-&gt;create($definition, 'my_value');</pre>
<p>We used the <kbd>TypedDataManager</kbd> to create a new instance of our definition with our actual string value. What we get is a plugin that we can use to interact with our data, understand it better, change its value, and so on:</p>
<pre>$value = $data-&gt;getValue();<br/>$data-&gt;setValue('another string');<br/>$type = $data-&gt;getDataDefinition()-&gt;getDataType();<br/>$label = $data-&gt;getDataDefinition()-&gt;getLabel();</pre>
<p>We can see what kind of data we are dealing with, its label, and other things.</p>
<p>Let's take a look at a slightly more complex example and model our license plate use case we talked about earlier.</p>
<p>We first define the number:</p>
<pre>$plate_number_definition = DataDefinition::create('string');<br/>$plate_number_definition-&gt;setLabel('A license plate number.');</pre>
<p>Then, we define the state code:</p>
<pre>$state_code_definition = DataDefinition::create('string');<br/>$state_code_definition-&gt;setLabel('A state code');</pre>
<p>We are keeping these generic because nobody says we cannot reuse these elsewhere; we might need to deal with state codes.</p>
<p>Next, we create our full plate definition:</p>
<pre>$plate_definition = MapDataDefinition::create();<br/>$plate_definition-&gt;setLabel('A US license plate');</pre>
<p>We use the <kbd>MapDataDefinition</kbd> here which by default uses the <kbd>Map</kbd> DataType plugin. Essentially, this is a well-defined associative array of properties. So, let's add our definitions to it:</p>
<pre>$plate_definition-&gt;setPropertyDefinition('number', $plate_number_definition);<br/>$plate_definition-&gt;setPropertyDefinition('state', $state_code_definition);</pre>
<p>This map definition gets two named property definitions: <kbd>number</kbd> and <kbd>state</kbd>. You can see now the hierarchical aspect of the TypedData API.</p>
<p>Finally, we instantiate the plugin:</p>
<pre>/** @var \Drupal\Core\TypedData\Plugin\DataType\Map $plate */<br/>$plate = \Drupal::typedDataManager()-&gt;create($plate_definition, ['state' =&gt; 'NY', 'number' =&gt; '405-307']);</pre>
<p>The value we pass to this type of data is an array whose keys should map to the property names and values to the individual property definitions (which in this case are strings).</p>
<p>Now, we can benefit from all the goodness of the TypedData API:</p>
<pre>$label = $plate-&gt;getDataDefinition()-&gt;getLabel();<br/>$number = $plate-&gt;get('number');<br/>$state = $plate-&gt;get('state');</pre>
<p>The <kbd>$number</kbd> and <kbd>$state</kbd> variables are <kbd>StringData</kbd> plugins that can then be used to access the individual values inside:</p>
<pre>$state_code = $state-&gt;getValue(); </pre>
<p>Their respective definitions can be accessed in the same way that we did before. So, we managed in these few lines to properly define a US license plate construct and make it intelligible by the rest of our code. Next, we will look at even more complex examples and inspect how content entity data is modeled using TypedData. Configuration entities, as we saw, rely on configuration schemas to define the data types. Under the hood, the schema types themselves reference TypedData API data type plugins themselves. So, behind the scenes, the same low-level API is used. To keep things a bit simpler, we will look at content entities where this API is much more explicit and you will actually have to deal with it.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Content entities</h1>
                </header>
            
            <article>
                
<p>Let's now examine entities and fields and see how they make use of the TypedData API for modeling the data they store and manage. This will also help you better understand how data is organized when you are debugging entities and their fields.</p>
<p>The main place where data is stored and modeled is fields. As we saw, we have two types: base fields and configurable fields. However, when it comes to TypedData, they do not differ very much. They both use the <kbd>FieldItemList</kbd> DataType plugin (either directly or a subclass). In terms of definitions, base fields use <kbd>BaseFieldDefinition</kbd> instances while configurable fields use <kbd>FieldConfig</kbd> instances. The latter are slightly more complicated because they are actually configuration entities themselves (to store the field configuration), but that implement down the line the <kbd>DataDefinitionInterface</kbd>. So, they combine the two tasks. Moreover, base fields can also use <kbd>BaseFieldOverride</kbd> definition instances which are essentially also configuration entities and are used for storing alterations made through the UI to the fields defined as base fields. Just like the <kbd>FieldConfig</kbd> definitions, these extend the <kbd>FieldConfigBase</kbd> class, because they share the same exportable characteristics.</p>
<p>In addition to fields, entities themselves have a TypedData plugin that can be used to wrap entities and expose them to the API directly<span>—</span>the <kbd>EntityAdapter</kbd>. These use an <kbd>EntityDataDefinition</kbd> instance which basically includes all the individual field definitions. Using plugin derivatives, each entity types dynamically gets an <kbd>EntityAdapter</kbd> plugin instance.</p>
<p>Let's now examine a simple base field and understand the usage of the TypedData API in the context of fields. The <kbd>BaseFieldDefinition</kbd> class extends <kbd>ListDataDefinition</kbd> which is responsible for defining multiple items of data in a list. Each item in the list is an instance of <kbd>DataDefinitionInterface</kbd> as well, so you can see the same kind of hierarchy as we had with our license plate example. But why is one field a list of items?</p>
<p>You probably know that when you create a field, you can choose how many items this one field can hold<span>—</span>its cardinality. You typically choose one, but can choose many. The same is true with all types of fields. Regardless of the cardinality you choose, the data is modeled as a list. If the field has a cardinality of one, the list will only have one item. It is as simple as that. So, if base field definitions are lists of definitions, what are the individual item definitions? The answer is implementations of <kbd>FieldItemDataDefinition</kbd>.</p>
<p>In terms of DataType plugins, as I mentioned, we have the <kbd>FieldItemList</kbd> class which implements the <kbd>ListInterface</kbd> I mentioned earlier as one of the more complex data types. The individual items inside are subclasses of <kbd>FieldItemBase</kbd> (which extends the <kbd>Map</kbd> DataType we encountered earlier). So, we have the same kind of data structure. But just to make matters slightly more complicated, another plugin type comes into play here<span>—</span><kbd>FieldType</kbd>. The individual field items are actually instances of this plugin type (which extend <kbd>FieldItemBase</kbd> and down the line a <kbd>DataType</kbd> plugin of some kind). So, for instance, a text field will use the <kbd>StringItem</kbd><kbd>FieldType</kbd> plugin, which inherits a bunch of functionality from the <kbd>Map</kbd> DataType. So, you can see how the TypedData API is at a very low level and things can be built on top of it.</p>
<p>So now, if we combine what we learned and look at a base field, we see the following: a <kbd>FieldItemList</kbd> data type using a <kbd>BaseFieldDefinition</kbd> (or <kbd>BaseFieldOverride</kbd>) data definition. Inside, each item is a <kbd>FieldItemBase</kbd> implementation (a <kbd>FieldType</kbd> plugin extending some sort of <kbd>DataType</kbd> plugin) using a <kbd>FieldItemDataDefinition</kbd>. So, not that complicated after all. We will put this knowledge to good use in the final section of this chapter when we see how we can interact with entities and field data. I am not throwing all these notions at you just for the sake of it.</p>
<p>The configurable fields work almost exactly the same way, except that the definition corresponding to the <kbd>FieldItemList</kbd> is an instance of <kbd>FieldConfig</kbd> (which is also a configuration entity that stores the settings for this field, and which is similar to the <kbd>BaseFieldOverride</kbd>). However, it is also a type of list definition with the individual list items being the same as with the base fields.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">TypedData summary</h1>
                </header>
            
            <article>
                
<p>So, as we've seen, the scope of understanding the TypedData API in Drupal 8 is quite broad. We can make things very simple, as with our first example, but then hit some really complicated territory with its use in the Entity system. The point of this section has been to make you aware of this API, understand its reasoning, see a couple of simple examples, and break down all the components that are used in the Entity API.</p>
<p>However, I admit, it must have been quite a difficult section to follow. All this terminology and theory can be pretty daunting. But don't worry if you didn't fully understand everything, that's fine. It's there for you to reference as we go through the next section because we will apply all that knowledge and you will see why it's useful to be aware of it. In other words, we will now focus on interacting with entities (both content and configuration) and in doing so, make heavy use of the functionality made possible by the TypedData API.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Interacting with the Entity API</h1>
                </header>
            
            <article>
                
<p>In this final section of the chapter, we're going to cover the most common things you will be doing with content and configuration entities. These are the main topics we will discuss going forward:</p>
<ul>
<li>Querying and loading entities</li>
<li>Reading entities</li>
<li>Manipulating entities (update/save)</li>
<li>Creating entities</li>
<li>Rendering entities</li>
<li>Validating entity data</li>
</ul>
<p>So, let's hit it.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Querying entities</h1>
                </header>
            
            <article>
                
<p>One of the most common things you will do as a programmer is query for stuff, such as data in the database. This is what we were doing a lot in Drupal 7 to get our data. A lot. We'd either use the database API or simple query strings and load our data. However, in Drupal 8, the entity API has become much more robust and offers a layer that reduces the need to query the database directly. In a later chapter, we will see how to do we can still do that when things become more complex. For now, since most of our structured data belongs in entities, we will use the entity query system for retrieving entities.</p>
<p>If you remember when we spoke about the entity type handlers, one of them was the storage handler that provides the API for CRUD operations on the entities. This is the handler we will use to access also the entity query. And we do this via the <kbd>entity_type.manager</kbd> service (<kbd>EntityTypeManager</kbd>):</p>
<pre>$query = \Drupal::entityTypeManager()-&gt;getStorage('node')-&gt;getQuery(); </pre>
<p>We request the storage handler which can then give us the query factory for that entity type. In this example, I used a static call but, as always, you should inject the service where you can.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Building queries</h1>
                </header>
            
            <article>
                
<p>Now that we have an entity query factory on our hands, we can build a query that is made up of conditions and all sorts of typical query elements. Here's a simple example of querying for the last 10 published article nodes:</p>
<pre><span>$query<br/></span><span>  </span><span>-&gt;</span><span>condition</span><span>(</span><span>'type'</span><span>, </span><span>'article'</span><span>)<br/></span><span>  -&gt;</span><span>condition</span><span>(</span><span>'status'</span><span>, </span><span>TRUE</span><span>)<br/></span><span>  -&gt;</span><span>range</span><span>(</span><span>0</span><span>, </span><span>10</span><span>)<br/></span><span>  -&gt;</span><span>sort</span><span>(</span><span>'created'</span><span>, </span><span>'DESC'</span><span>)</span><span>;<br/></span><span>$ids </span><span>= </span><span>$query</span><span>-&gt;</span><span>execute</span><span>()</span><span>;</span></pre>
<p>The first thing you can see is that the methods on the factory are chainable. We have some expected methods to set conditions, range, sorting, and so on. As you can already deduce, the first parameter is the field name and the second is the value. An optional third parameter can also be the operator for the condition.</p>
<div class="packt_tip">I strongly recommend you check out the <kbd>\Drupal\Core\Entity\Query\QueryInterface</kbd> class for some documentation about these methods, especially the <kbd>condition()</kbd> method which is the most complex.</div>
<p>Here is a slightly more complex condition that would return nodes of two different types:</p>
<pre>-&gt;condition('type', ['article', 'page'], 'IN') </pre>
<p>Additionally, you can also use condition groups, with OR or AND conjunctions:</p>
<pre>$query<br/>   -&gt;condition('status', TRUE);<br/> $or = $query-&gt;orConditionGroup()<br/>   -&gt;condition('title', 'Drupal', 'CONTAINS')<br/>   -&gt;condition('field_tags.entity.name', 'Drupal', 'CONTAINS');<br/> $query-&gt;condition($or);<br/> $ids = $query-&gt;execute();</pre>
<p>In the previous query, we see a few new things. First, we create a condition group of the type OR in which we add two conditions. One of them checks whether the node title field contains the string "Drupal". The other checks whether any of the entities referenced by the <kbd>field_tags</kbd> field (in this case taxonomy terms) has the string "Drupal" in their name. So, you can see the power we have in traversing into referenced entities. Finally, we use this condition group as the first parameter to the <kbd>condition()</kbd> method of the query (instead of field name and value).</p>
<div class="packt_tip">Entity queries for the Node entity type take access restrictions into account as they are run from the context of the current user. This means that, for example, a query for unpublished nodes triggered on a page hit by an anonymous user is not going to return results, but it will if triggered by an administrator. You can disable this by adding the <kbd>-&gt;accessCheck(FALSE)</kbd> instruction to the query IF you are sure the results are not going to expose unwanted content to users. We will talk more about node access in a later chapter.</div>
<p>Configuration entities work in the same way. We get the query factory for that entity type and build a query. Under the hood, the query is of course run differently due to the flat nature of the storage.</p>
<p>Each configuration entity gets one record in the database, so they need to be loaded and then examined. Moreover, the conditions can be written to also match the nested nature of configuration entity field data. For example:</p>
<pre>$query = \Drupal::entityTypeManager()-&gt;getStorage('view')-&gt;getQuery();<br/>$query<br/>  -&gt;condition('display.*.display_plugin', 'page');<br/>$ids = $query-&gt;execute();</pre>
<p>This query searches for all the View configuration entities that have the display plugin of the type "page". The condition essentially looks inside the <kbd>display</kbd> array for any of the elements (hence the <kbd>*</kbd> wildcard). If any of these elements has a <kbd>display_plugin</kbd> key with the value "page", it's a match. This is what an example view entity looks like in YAML format:</p>
<pre>...<br/> base_field: nid<br/> core: 8.x<br/> display:<br/>   default:<br/>     display_options:<br/>       ...<br/>     display_plugin: default<br/>     display_title: Master<br/>    ...<br/>   page_1:<br/>     display_options:<br/>       ...<br/>     display_plugin: page<br/>     display_title: Page</pre>
<p>I removed a bunch of data from this entity just to keep it short. But as you can see, we have the <kbd>display</kbd> array, with the <kbd>default</kbd> and <kbd>page_1</kbd> elements, and each has a <kbd>display_plugin</kbd> key with a plugin ID.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Loading entities</h1>
                </header>
            
            <article>
                
<p>Now that we have our entity IDs found by the query, it's time to load them. It couldn't be simpler to do so. We just use the storage handler for that entity type (and we get that from the entity type manager):</p>
<pre>$nodes = \Drupal::entityTypeManager()-&gt;getStorage('node')-&gt;loadMultiple($ids); </pre>
<p>This will return an array of <kbd>EntityInterface</kbd> objects (in this case <kbd>NodeInterface</kbd>). Or if we have only one ID to load:</p>
<pre>$nodes = \Drupal::entityTypeManager()-&gt;getStorage('node')-&gt;load($id); </pre>
<p>These will return a single <kbd>NodeInterface</kbd> object.</p>
<p>The Entity type storage handler also has a shortcut method that allows you to perform simple queries and load the resulting entities in one go. For example, if we wanted to load all article nodes:</p>
<pre>$nodes = \Drupal::entityTypeManager()-&gt;getStorage('node')-&gt;loadByProperties(['type' =&gt; 'article']); </pre>
<p>The <kbd>loadByProperties()</kbd> method takes one parameter: an associative array that contains simple field value conditions that need to match. Behind the scenes, it builds a query based on these and loads the returning entities. Do keep in mind that you cannot have complex queries here and access checks will be taken into account in the query being built under the hood. So, for full control, just build the query yourself.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Reading entities</h1>
                </header>
            
            <article>
                
<p>So, we have our entity loaded and we can now read its data. For content entities, this is where the TypedData knowledge comes into play. Before we look at that, let's see quickly how we can get the data from configuration entities. Let's inspect the Article <kbd>NodeType</kbd> for this purpose:</p>
<pre>/** @var \Drupal\node\Entity\NodeType $type */<br/>$type = \Drupal::entityTypeManager()-&gt;getStorage('node_type')-&gt;load('article');</pre>
<p>The first and simplest thing we can do is inspect the individual methods on the entity type class. For example, <kbd>NodeType</kbd> has a <kbd>getDescription()</kbd> method which is a handy helper to get the description field:</p>
<pre>$description = $type-&gt;getDescription(); </pre>
<p>This is always the best way to try to get the field values of configuration entities, because you potentially get return type documentation that can come in handy with your IDE. Alternatively, the <kbd>ConfigEntityBase</kbd> class has the <kbd>get()</kbd> method that can be used to access any of the fields:</p>
<pre><span class="ChapterrefPACKT">$description = $type-&gt;get('description');</span></pre>
<p>This is going to do the same thing and it is the common way any field can be accessed across the different configuration entity types. The resulting value is the raw field value, in this case a string. So, this is pretty simple.</p>
<p>Apart from the typical field data, we have the entity keys (if you remember from the entity type plugin definitions). These are common for both configuration and content entities and the relevant accessor methods are found on the <kbd>EntityInterface</kbd>. Here are some of the more common ones:</p>
<pre>$id = $type-&gt;id();<br/>$label = $type-&gt;label();<br/>$uuid = $type-&gt;uuid();<br/>$bundle = $type-&gt;bundle();<br/>$language = $type-&gt;language();</pre>
<p>The resulting information naturally depends on the entity type. For example, configuration entities don't have bundles or some content entity types either. So, the <kbd>bundle()</kbd> method will return the name of the entity type if there are no bundles. By far the most important one is <kbd>id()</kbd> but you will often use <kbd>label()</kbd> as well as a shortcut to the primitive field value of the field used as the label for the entity type. There are other entity keys as well that individual entity types can declare. For example, entity types that extend the <kbd>EditorialContentEntityBase</kbd>, such as the Node entity, have a <kbd>published</kbd> entity key and a corresponding <kbd>isPublished()</kbd> method. So, for any other entity keys, do check the respective entity type if you can use them.</p>
<p>Some extra methods you can use to inspect entities of any type:</p>
<ul>
<li><kbd>isNew()</kbd> checks whether the entity has been persisted already.</li>
<li><kbd>getEntityTypeId()</kbd> returns the machine name of the entity type of the entity.</li>
<li><kbd>getEntityType()</kbd> returns the <kbd>EntityTypeInterface</kbd> plugin of the given entity.</li>
<li><kbd>getTypedData()</kbd> returns the <kbd>EntityAdapter</kbd> DataType plugin instance that wraps the entity. It can be used for further inspection as well as validation;</li>
</ul>
<p>Moreover, we can also check whether they are a content or a configuration entity:</p>
<pre>$entity instanceof ContentEntityInterface<br/>$entity instanceof ConfigEntityInterface</pre>
<p>Similarly, we can also check whether they are a specific type of entity:</p>
<pre>$entity instanceof NodeInterface  </pre>
<p>This is similar to using <kbd>$entity-&gt;getEntityTypeId === 'node'</kbd> but it is much more explicit and clear, plus the IDE can benefit from the information in many cases.</p>
<p>Now, let's turn to content entities and see how we can read their field data.</p>
<p>Similar to configuration entity types, many content entity types can have helper methods on their class (or parent) to make accessing certain fields easier. For example, the Node entity type has the <kbd>getTitle()</kbd> method which gets the first primitive value of its title field. However, let's see how we can apply what we learned in the TypedData section and navigate through the field values like a pro. To exemplify, we will examine a simple article node.</p>
<p>Content entities also have the <kbd>get()</kbd> method, but unlike configuration entities, it doesn't return the raw field value. Instead, it returns an instance of <kbd>FieldItemList</kbd>:</p>
<pre>/** @var \Drupal\node\NodeInterface $node */<br/>$node = Node::load(1);<br/>/** @var \Drupal\Core\Field\FieldItemListInterface $title */<br/>$title = $node-&gt;get('title');</pre>
<p>For quick prototyping, in this example I used the static <kbd>load()</kbd> method on the content entity class to load an entity by ID. Under the hood, this will delegate to the relevant storage class. This is a quick alternative to using the entity manager, but you should only rely on it wherever you cannot inject dependencies.</p>
<p>Here are some of the things we can learn about the title <kbd>FieldItemList</kbd>:</p>
<pre>$parent = $title-&gt;getParent();  </pre>
<p>This is its parent (the DataType plugin it belongs in, in this case, the <kbd>EntityAdapter</kbd>):</p>
<pre>$definition = $title-&gt;getFieldDefinition();  </pre>
<p>This is the <kbd>DataDefinitionInterface</kbd> of the list. In this case it's a <kbd>BaseFieldDefinition</kbd> instance but can be a <kbd>BaseFieldOverride</kbd> or a <kbd>FieldConfig</kbd> for fully configurable fields:</p>
<pre><span class="ChapterrefPACKT">$item_definition = $title-&gt;getItemDefinition();</span>  </pre>
<p>This is the <kbd>DataDefinitionInterface</kbd> for the individual items in the list, typically a <kbd>FieldItemDataDefinition</kbd>:</p>
<pre>$total = $title-&gt;count();<br/>$empty = $title-&gt;isEmpty();<br/>$exists = $title-&gt;offsetExists(1);</pre>
<p>These are some handy methods for inspecting the list. We can see how many items there are in it, whether it's empty, and whether there are any values at a given offset. Do keep in mind that value keys start at 0, so if the cardinality of the field is 1, the value will be at the key 0.</p>
<p>To retrieve values from the list, we have a number of options. The most common thing you'll end up doing is the following:</p>
<pre>$value = $title-&gt;value; </pre>
<p>This is a magic property pointing to the first primitive value in the list. However, it's very important to note that, although most fields use the <kbd>value</kbd> property, some fields have a different property name. For example, entity reference fields use <kbd>target_id</kbd>:</p>
<pre>$id = $field-&gt;target_id; </pre>
<p>This returns the ID of the referenced entity. As an added bonus, if you use the magic <kbd>entity</kbd> property, you get the fully loaded entity object:</p>
<pre>$entity = $field-&gt;entity; </pre>
<p>But enough of this magic way of doing things<span><span>;</span></span> let's see what other options we have:</p>
<pre>$value = $title-&gt;getValue(); </pre>
<p>The <kbd>getValue()</kbd> method is present on all <kbd>TypedData</kbd> objects and returns the raw values that it stores. In our case, it will return an array with one item (since we only have one item in the list) that contains the individual item raw values. Which in this case is an array with one element keyed <kbd>value</kbd> and the title string as its actual value. We will see in a moment why this is keyed <kbd>value</kbd>.</p>
<p>In some cases, we might want this to be returned and can find it useful. In other cases though, we might just want the one field value. For this, we can ask for a given item in the list:</p>
<pre>$item = $title-&gt;get(0);<br/>$item = $title-&gt;offsetGet(0);</pre>
<p>Both of these do the same thing and return a <kbd>FieldType</kbd> plugin which, as we saw, extends <kbd>FieldItemBase</kbd>, which is nothing more than a fancy <kbd>Map</kbd> DataType plugin. Once we have this, we again have a few choices:</p>
<pre>$value = $item-&gt;getValue(); </pre>
<p>This again returns an array of the raw values, in this case with one key called <kbd>value</kbd> and the string title as the actual value. So, just as we called <kbd>getValue()</kbd> on the list, but this time returning the raw values of only one item instead of an array of raw values of multiple items.</p>
<p>The reason why we have the actual title string keyed by <kbd>value</kbd> is because we are requesting the raw value from the <kbd>StringItem</kbd> field type plugin, which in this case happens to define the value columns as <kbd>value</kbd>. Others might differ (for example the entity reference field that stores a <kbd>target_id</kbd> named value).</p>
<p>Alternatively, again, we can navigate a bit further down:</p>
<pre>$data = $item-&gt;get('value');  </pre>
<p>We know that this field uses the name <kbd>value</kbd> for its property so we can use the <kbd>get()</kbd> method from the <kbd>Map</kbd> DataType (which, if you remember, is subclassed by the <kbd>StringItem</kbd> field type) to retrieve its own property by name. This is exactly the same as we did with the license plate map and when we requested the number or state code. In the case of <kbd>StringItem</kbd> field types, this is going to be a <kbd>StringData</kbd> DataType plugin.</p>
<p>And as we did before, we can ask this final plugin for its value:</p>
<pre>$value = $data-&gt;getValue();  </pre>
<p>Now we have the final string for the title. Of course, all the way down from the top, we have the opportunity to inspect the definitions of each of these plugins and learn more information about them.</p>
<p>Typically, on the day to day, you will use two methods for retrieving values from fields, depending on the cardinality. If the field has only one value, you will end up using something like this:</p>
<pre>$title = $node-&gt;get('title')-&gt;value;<br/>$id = $node-&gt;get('field_referencing_some_entity')-&gt;target_id;<br/>$entity = $node-&gt;get('field_referencing_some_entity')-&gt;entity;</pre>
<p>If the field can have multiple values, you will end up using something like this:</p>
<pre>$names = $node-&gt;get('field_names')-&gt;getValue();<br/>$tags = $node-&gt;get('field_tags')-&gt;referencedEntities();</pre>
<p>The <kbd>referencedEntities()</kbd> method is a helper one provided by <kbd>EntityReferenceFieldItemList</kbd> (which is a subclass of <kbd>FieldItemList</kbd>) that loads all the referenced entities and returns them in an array keyed by the position in the field (the delta).</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Manipulating entities</h1>
                </header>
            
            <article>
                
<p>Now that we know how we can read field data programmatically, let's see how we can change this data and persist it to the storage. So, let's look at the same Node title field and update its value programmatically.</p>
<p>The most common way you can change a field value on a content entity is this:</p>
<pre>$node-&gt;set('title', 'new title');  </pre>
<p>This works well with fields that have only one value (cardinality = 1) and, behind the scenes, essentially this happens:</p>
<pre>$node-&gt;get('title')-&gt;setValue('new title');</pre>
<p>This one value gets transformed into a raw array of one value because we are dealing with a list of items and the first item receives the changed value. If the field has a higher cardinality and we pass only one value as such, we essentially remove both of them and replace them with only one. So, if we want to make sure we are not deleting items but instead adding to the list, we can do this:</p>
<pre>$values = $node-&gt;get('field_multiple')-&gt;getValue();<br/>$values[] = ['value' =&gt; 'extra value'];<br/>$node-&gt;set('field_multiple', $values);</pre>
<p>If we want to change a specific item in the list, we can do this:</p>
<pre>$node-&gt;get('field_multiple')-&gt;get(1)-&gt;setValue('changed value');  </pre>
<p>This will change the value of the second item in the list. You just have to make sure it is set first before chaining:</p>
<pre><span class="ChapterrefPACKT">$node-&gt;get('field_test')-&gt;offsetExists(1);</span></pre>
<p>All these modifications we make to field values are, however, kept in memory (they are not persisted). To save them to a database we have to do something extremely complicated:</p>
<pre>$node-&gt;save();  </pre>
<p>That's it. We can achieve the same thing via the entity type manager as well:</p>
<pre>\Drupal::entityTypeManager()-&gt;getStorage('node')-&gt;save($node);  </pre>
<p>Since we are talking about saving, deleting entities can be done in the exact same way, except by using the <kbd>delete()</kbd> method on the entity object. We also have this method on the storage handler. However, it accepts an array of entities to delete, so you can use that to delete more entities at once.</p>
<p>Configuration entities have it a bit easier since their fields do not deal with TypedData. This is how we can easily change the value of a configuration entity field:</p>
<pre>/** @var \Drupal\node\Entity\NodeType $type */<br/>$type = \Drupal::entityTypeManager()-&gt;getStorage('node_type')-&gt;load('article');<br/>$type-&gt;set('name', 'News');<br/>$type-&gt;save();</pre>
<p>Nothing too complex going on here. We load the entity, set a property value and save it using the same API.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Creating entities</h1>
                </header>
            
            <article>
                
<p>Programmatically creating new entities is also not rocket science and, again, we use the entity type storage handler to do so:</p>
<pre><span>$values </span><span>= [<br/></span><span>  </span><span>'type' </span><span>=&gt; </span><span>'article'</span><span>,<br/></span><span>  </span><span>'title' </span><span>=&gt; </span><span>'My title'<br/></span><span>]</span><span>;<br/></span><span>/** </span><span>@var </span><span>\Drupal\node\NodeInterface $node */<br/></span><span>$node </span><span>= \Drupal::</span><span>entityTypeManager</span><span>()-&gt;</span><span>getStorage</span><span>(</span><span>'node'</span><span>)-&gt;</span><span>create</span><span>(</span><span>$values</span><span>)</span><span>;<br/></span><span>$node</span><span>-&gt;</span><span>set</span><span>(</span><span>'field_custom'</span><span>, </span><span>'some text'</span><span>)</span><span>;<br/></span><span>$node</span><span>-&gt;</span><span>save</span><span>()</span><span>;</span></pre>
<p>The storage handler has the <kbd>create()</kbd> method, which takes one argument in the form of an associative array of field values. The keys represent the field name and the values the value. This is where you can set initially some simpler values, and for more complex fields you still have the API we covered earlier.</p>
<p>If the entity type has bundles, such as the Node example above, the bundle needs to be specified in the <kbd>create()</kbd> method. The key it corresponds to is the entity key for the bundle. If you remember the Node entity type plugin, that is <kbd>type</kbd>.</p>
<p>That is pretty much it. Again, we need to save it in order to persist it in our storage.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Rendering content entities</h1>
                </header>
            
            <article>
                
<p>Now, let's see what we can do with an entity to render it on the page. In doing so, we will stick to the existing view modes and try not to break it up into pieces for rendering in a custom template through our own theme hook. If you want to do that, you can. You should have all the knowledge for that already:</p>
<ul>
<li>Defining a theme hook with variables</li>
<li>Querying and loading entities</li>
<li>Reading the values of an entity</li>
<li>Creating a render array that uses the theme hook</li>
</ul>
<p>Instead, we will rely on the entity's default building methodology that allows us to render it according to the display mode configured in the UI, so, for example, as a teaser or as the full display mode. As always, we will continue with the Node as an example.</p>
<p>The first thing we need to do is get our hands on the <em>view builder</em> handler of the entity type. Remember this from the entity type plugin definition? Just like the storage handler, we can request it from the <kbd>EntityTypeManager</kbd>:</p>
<pre>/** @var \Drupal\node\NodeViewBuilder $builder */<br/>$builder = \Drupal::entityTypeManager()-&gt;getViewBuilder('node');</pre>
<p>Now that we have that, the simplest way of turning our entity into a render array is to use the <kbd>view()</kbd> method:</p>
<pre>$build = $builder-&gt;view($node);  </pre>
<p>By default, this will use the full view mode, but we can pass a second parameter and specify another, such as teaser or whatever we have configured. A third optional parameter is the langcode of the translation (if we have it) we want to render in.</p>
<p>The <kbd>$build</kbd> variable is now a render array that uses the <kbd>node</kbd> theme hook defined by the Node module. You will notice also a <kbd>#pre_render</kbd> theme property that specifies a callable to be run before the rendering of this array. That is actually a reference back to the <kbd>NodeViewBuilder</kbd> (the node entity type view builder) which is responsible for preparing all the field values and all sorts of other processing we are not going to cover now. But the <kbd>node.twig.html</kbd> template file, preprocessed by the <kbd>*_preprocess_node()</kbd> preprocessors, also plays a big role in providing some extra variables to be used or rendered in the template.</p>
<p>If we want, we can also build render arrays for multiple entities at once:</p>
<pre>$build = $builder-&gt;viewMultiple($node); </pre>
<p>This will still return a render array that contains multiple children for each entity being rendered. The <kbd>#pre_render</kbd> property I mentioned earlier, however, will stay at the top level and, this time, be responsible for building multiple entities.</p>
<p>Essentially, it is that simple to get from loading an entity to turning it into a render array. You have many different places where you can take control over the output. As I said, you can write your own theme hook and break up the entity into variables. You can also implement the preprocessor for its default theme functions and change some variables in there. You can even change the theme hook used and append a suggestion to it and then take it from there, as we saw in the chapter on theming:</p>
<pre>$build = $builder-&gt;view($node);<br/>$build['#theme'] = $build['#theme'] . '__my_suggestion';</pre>
<p>Another important way in which we can control the output is by implementing a hook that gets fired when the entity is being built for rendering: <kbd>hook_entity_view()</kbd> or <kbd>hook_ENTITY_TYPE_view()</kbd>. So, let's see an example by which we want to append a disclaimer message at the bottom of all our Node entities when they are displayed in their <kbd>full</kbd> view mode. We can do something like this:</p>
<pre>function module_name_entity_view(array &amp;$build, EntityInterface $entity, EntityViewDisplayInterface $display, $view_mode) { 
  if ($entity-&gt;getEntityTypeId() == 'node' &amp;&amp; $view_mode == 'full') { 
    $build['disclaimer'] = [ 
      '#markup' =&gt; t('The content provided is for general information purposes only.'), 
      '#weight' =&gt; 100 
    ]; 
  } 
} </pre>
<p>The three important arguments we work with are the <kbd>$build</kbd> array passed by reference, and which contains the render array for the entire entity, the <kbd>$entity</kbd> object itself, and the <kbd>$view_mode</kbd> the latter is being rendered in. So, all we have to do is add our own render bits inside the <kbd>$build</kbd> array. As a bonus, we try to ensure that the message gets printed at the bottom by using the <kbd>#weight</kbd> property on the render array.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Pseudo-fields</h1>
                </header>
            
            <article>
                
<p>Drawing from our example on implementing <kbd>hook_entity_view()</kbd>, there's a neat little technique we can use to empower our site builders further with respect to that disclaimer message. This is by turning it into a <em>pseudo field</em>. By doing this, site builders will be able to choose the bundles it should show on, as well as the position relative to the other fields, all through the UI in the <span class="packt_screen">Manage Display</span> section:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/a2251d18-b89a-4aa3-ae6a-17759425c36f.png" style="width:32.58em;height:16.92em;"/></p>
<p>So, there are two things we need to do for this. First, we need to implement <kbd>hook_entity_extra_field_info()</kbd> and define our <em>pseudo field</em>:</p>
<pre>/** 
 * Implements hook_entity_extra_field_info(). 
 */ 
function module_name_entity_extra_field_info() { 
  $extra = []; 
 
  foreach (NodeType::loadMultiple() as $bundle) { 
    $extra['node'][$bundle-&gt;id()]['display']['disclaimer'] = [ 
      'label' =&gt; t('Disclaimer'), 
      'description' =&gt; t('A general disclaimer'), 
      'weight' =&gt; 100, 
      'visible' =&gt; TRUE, 
    ]; 
  } 
 
  return $extra; 
} </pre>
<p>As you can see, we loop through all the available node types and for the <kbd>node</kbd> entity display list, we add our <kbd>disclaimer</kbd> definition with some defaults to use. The weight and visibility will, of course, be overridable by the user, per node bundle.</p>
<p>Next, we need to go back to our <kbd>hook_entity_view()</kbd> implementation and make some changes. Because we know we want this applied to Node entities only, we can implement the more specific hook instead:</p>
<pre>/** 
 * Implements hook_ENTITY_TYPE_view(). 
 */ 
function module_name_node_view(array &amp;$build, EntityInterface $entity, EntityViewDisplayInterface $display, $view_mode) { 
  if ($display-&gt;getComponent('disclaimer')) { 
    $build['disclaimer'] = [ 
      '#markup' =&gt; t('The content provided is for general information purposes only.'), 
    ]; 
  } 
} </pre>
<p>In this case we don't need to check for view modes or entity types, but rather use the entity view display configuration object to check for the existence of this extra <kbd>disclaimer</kbd> field (technically called a <em>component</em>). If found, we simply add our markup to the <kbd>$build</kbd> array. Drupal will take care of things like weight and visibility to match whatever the user has set through the UI, and that's it. Clearing the cache, we should still see our disclaimer message, but we can now control it a bit from the UI.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Entity validation</h1>
                </header>
            
            <article>
                
<p>The last thing we are going to talk about in this chapter is entity validation and how we can make sure that field and entity data as a whole contains valid data. When I say valid, I don't mean whether it complies with the strict TypedData definition but whether, within that, it complies with certain restrictions (constraints) we impose on it. As such, most of the time, entity validation applies to content entities. However, we can also run validation on configuration entities but only insofar as to ensure that the field values are of the correct data type as described in the configuration schema. And in this respect, we are talking about TypedData definitions under the hood.</p>
<p>Drupal 8 uses the Symfony Validator component for applying constraints and then validating entities, fields and any other data against those constraints. I do recommend that you check out the Symfony documentation page on this component to better understand its principles. For now, let's quickly see how it is applied in Drupal 8.</p>
<p>There are three main parts to a validation: a constraint plugin, a validator class and potential violations. The first is mainly responsible for defining what kind of data it can be applied to, the error message it should show, and which validator class is responsible for validating it. If it omits the latter, the validator class name defaults to the name of the constraint class with the word <kbd>Validator</kbd> appended to it. The validator, on the other hand, is called by the validation service to validate the constraint and build a list of violations. Finally, the violations are data objects that provide helpful information about what went wrong in the validation: things like the error message from the constraint, the offending value and the path to the property that failed.</p>
<p>To better understand things, we have to go back to the TypedData and see some simple examples, because that is the level at which the validation happens.</p>
<p>So, let's look at the same example I introduced TypedData with earlier in this chapter:</p>
<pre>$definition = DataDefinition::create('string');<br/>$definition-&gt;addConstraint('Length', ['max' =&gt; 20]);</pre>
<p>The data definitions have methods for applying and reading constraints. If you remember, one of the reasons why we need this API is to be able to enrich data with meta information. Constraints are such information. In this example, we are applying a constraint called <kbd>Length</kbd> (the plugin ID of the constraint) with some arbitrary parameters expected by that constraint (in this case a maximum length but also a minimum would work). Having applied this constraint, we are essentially saying that this piece of string data is only valid if it's shorter than 20 characters. And we can use it like so:</p>
<pre>/** @var \Drupal\Core\TypedData\TypedDataInterface $data */<br/>$data = \Drupal::typedDataManager()-&gt;create($definition, 'my value that is too long');<br/>$violations = $data-&gt;validate();</pre>
<p>DataType plugins have a <kbd>validate()</kbd> method on them that uses the validation service to validate their underlying data definition against any of the constraints applied to it. The result is an instance of the <kbd>ConstraintViolationList</kbd> iterator which contains a <kbd>ConstraintViolationInterface</kbd> instance for each validation failure. In this example, we should have a violation from which we can get some information like so:</p>
<pre><span>/** </span><span>@var </span><span>\Symfony\Component\Validator\ConstraintViolationInterface $violation */<br/></span><span>foreach </span><span>(</span><span>$violations </span><span>as </span><span>$violation</span><span>) {<br/></span><span>  </span><span>$message </span><span>= </span><span>$violation</span><span>-&gt;getMessage()</span><span>;<br/></span><span>  </span><span>$value </span><span>= </span><span>$violation</span><span>-&gt;getInvalidValue()</span><span>;<br/></span><span>  </span><span>$path </span><span>= </span><span>$violation</span><span>-&gt;getPropertyPath()</span><span>;<br/></span><span>}</span></pre>
<p>The <kbd>$message</kbd> is the error message that comes from the failing constraint, the <kbd>$value</kbd> is the actual incorrect value, and <kbd>$path</kbd> is a string representation of the hierarchical path down to the value that has failed. If you remember our license plate example or the content entity fields, TypedData can be nested, which means you can have all sorts of values at different levels. In our previous example, <kbd>$path</kbd> is, however, going to be <kbd>""</kbd> (an empty string) because the data definition has only one level.</p>
<p>Let's revisit our license plate example and see how such a constraint would work there. Imagine we wanted to add a similar constraint to the state code definition:</p>
<pre><span>$state_code_definition </span><span>= DataDefinition::</span><span>create</span><span>(</span><span>'string'</span><span>)</span><span>;<br/></span><span>$state_code_definition</span><span>-&gt;</span><span>addConstraint</span><span>(</span><span>'Length'</span><span>, </span><span>array</span><span>(</span><span>'max' </span><span>=&gt; </span><span>2</span><span>))</span><span>;<br/></span><span>// The rest of the set up code we saw earlier.<br/></span><span><br/></span><span>/** </span><span>@var </span><span>Map $plate */<br/></span><span>$plate </span><span>= \Drupal::</span><span>typedDataManager</span><span>()-&gt;</span><span>create</span><span>(</span><span>$plate_definition</span><span>, </span><span>[</span><span>'state' </span><span>=&gt; </span><span>'NYC'</span><span>, </span><span>'number' </span><span>=&gt; </span><span>'405-307'</span><span>])</span><span>;<br/></span><span>$violations </span><span>= </span><span>$plate</span><span>-&gt;</span><span>validate</span><span>()</span><span>;</span></pre>
<p>If you look closely, I instantiated the plate with a state code longer than two characters. Now, if we ask our individual violations for the property path, we get <kbd>state</kbd>, because that is what we called the state definition property within the bigger map definition.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Content entities</h1>
                </header>
            
            <article>
                
<p>Let's now see an example of validating constraints on entities. First of all, we can run the <kbd>validate()</kbd> method on an entire entity, which will then use its TypedData wrapper (<kbd>EntityAdapter</kbd>) to run a validation on all the fields on the entity plus any of the entity-level constraints. The latter can be added via the <kbd>EntityType</kbd> plugin definition (the annotation). For example, the Comment entity type has this bit:</p>
<pre>*    constraints = {<br/>*     "CommentName" = {}<br/>*   }</pre>
<p>This means that the constraint plugin ID is <kbd>CommentName</kbd> and it takes no parameters (since the braces are empty). We can even add constraints to entity types that do not "belong" to us by implementing <kbd>hook_entity_type_alter()</kbd>, for example:</p>
<pre>function my_module_entity_type_alter(array &amp;$entity_types) {<br/>  $node = $entity_types['node'];<br/>  $node-&gt;addConstraint('ConstraintPluginID', ['option']);<br/>}</pre>
<p>Going one level below and knowing that content entity fields are built on top of the TypedData API, it follows that all those levels can have constraints. We can add the constraints regularly to the field definitions or, in the case of either fields that are not "ours" or configurable fields, we can use hooks to add constraints. Using <kbd>hook_entity_base_field_info_alter()</kbd> we can add constraints to base fields while with <kbd>hook_entity_bundle_field_info_alter()</kbd> we can add constraints to configurable fields (and overridden base fields). Let's see an example of how we can add constraints to the Node ID field:</p>
<pre><span>function </span><span>my_module_entity_base_field_info_alter</span><span>(&amp;</span><span>$fields</span><span>, </span><span>EntityTypeInterface </span><span>$entity_type</span><span>) {<br/></span><span>  </span><span>if </span><span>(</span><span>$entity_type</span><span>-&gt;</span><span>id</span><span>() === </span><span>'node'</span><span>) {<br/></span><span>    </span><span>$nid </span><span>= </span><span>$fields</span><span>[</span><span>'nid'</span><span>]</span><span>;<br/></span><span>    </span><span>$nid</span><span>-&gt;</span><span>addPropertyConstraints</span><span>(</span><span>'value'</span><span>, </span><span>[</span><span>'Range' </span><span>=&gt; [</span><span>'mn' </span><span>=&gt; </span><span>5</span><span>, </span><span>'max' </span><span>=&gt; </span><span>10</span><span>]])</span><span>;<br/></span><span>  </span><span>}<br/></span><span>}</span></pre>
<p>As you can see, we are still just working with data definitions. One thing to note, however, is that when it comes to base fields and configurable fields (which are lists of items), we also have the <kbd>addPropertyConstraints()</kbd> method available. This simply makes sure that whatever constraint we are adding is targeted toward the actual items in the list (specifying which property), rather than the entire list as it would have happened had we used the main <kbd>addConstraint()</kbd> API. Another difference with this method is that constraints get wrapped into a <kbd>ComplexDataConstraint</kbd> plugin. However, you don't have to worry too much about that<span><span>;</span></span> just be aware when you see it.</p>
<p>We can even inspect the constraints found on a data definition object. For example, this is how we can read the constraints found on the Node ID field:</p>
<pre>$nid = $node-&gt;get('nid');<br/>$constraints = $nid-&gt;getConstraints();<br/>$item_constraints = $nid-&gt;getItemDefinition()-&gt;getConstraints();</pre>
<p>Where the <kbd>getConstraints()</kbd> method returns an array of constraint plugin instances.</p>
<p>Now let's see how we can validate entities:</p>
<pre>$node_violations = $node-&gt;validate(); 
$nid = $node-&gt;get('nid');<br/>$nid_list_violations = $nid-&gt;validate();<br/>$nid_item_violations = $nid-&gt;get(0)-&gt;validate();</pre>
<p>The entity-level <kbd>validate()</kbd> method returns an instance of <kbd>EntityConstraintViolationList</kbd> which is a more specific version of the <kbd>ConstraintViolationList</kbd> we talked about earlier. The latter is, however, returned by the <kbd>validate()</kbd> method of the other cases above. But for all of them, inside we have a collection of <kbd>ConstraintViolationInterface</kbd> instances from which we can learn some things about what did not validate.</p>
<p>The entity-level validation goes through all the fields and validates them all. Next, the list will contain violations of any of the items in the list, while the item will contain only the violations on that individual item in the list. The property path is something interesting to observe. The following is the result of calling <kbd>getPropertyPath()</kbd> on a violation found in all three of the resulting violation lists from the example above:</p>
<pre>nid.0.value<br/>0.value<br/>value</pre>
<p>As you can see, this reflects the TypedData hierarchy. When we validate the entire entity, it gives us a property path all the way down to the value: field name -&gt; delta (position in the list) -&gt; property name. Once we validate the field, we already know what field we are validating, so that is omitted. And the same goes for the individual item (we know also the delta of the item).</p>
<p>A word of warning about base fields that can be overridden per bundle such as the Node title field. As I mentioned earlier, the base definition for these fields uses an instance of <kbd>BaseFieldOverride</kbd>, which allows certain changes to be made to the definition via the UI. In this respect, they are very close to configurable fields. The "problem" with this is that, if we tried to apply a constraint like we just did with the <kbd>nid</kbd> to, say, the Node <kbd>title</kbd> field, we wouldn't have gotten any violations when validating. This is because the validator performs the validation on the <kbd>BaseFieldOverride</kbd> definition rather than the <kbd>BaseFieldDefinition</kbd>.</p>
<p>This is no problem, though, as we can use <kbd>hook_entity_bundle_field_info_alter()</kbd> and do the same thing as we did before, which will then apply the constraint to the overridden definition. In doing so, we can also account for the bundle we want this applied to. This is the same way you apply constraints to a configurable field you create in the UI.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Configuration entities</h1>
                </header>
            
            <article>
                
<p>Configuration entity fields are not exposed to the TypedData API in terms of data definition. If you remember, though, we do have the configuration schema that describes the type of data that is considered valid in the entity. This is, for the moment, the extent to which we can validate configuration entities as they are not (yet) exposed to the constraint-validator system.</p>
<p>But before we conclude this chapter, let's quickly see how we can validate a configuration entity. Here is a quick example:</p>
<pre>$config_entity = View::load('content'); 
$config_entity-&gt;set('status', 'not a boolean'); 
$typed_config_entity = ConfigEntityAdapter::createFromEntity($config_entity); 
$violations = $typed_config_entity-&gt;validate(); </pre>
<p>The first thing we do is load a configuration entity. In this case it's a View, but it doesn't matter as it's backed by a schema definition (found in <kbd>views.schema.yml</kbd>). By default, the entity is valid, so in this example, I change the <kbd>status</kbd> field to a string (not a Boolean). Then for the actual validation we create a new <kbd>ConfigEntityAdapter</kbd> instance (which is like the <kbd>EntityAdapter</kbd> we saw earlier for content entities). And we can now call <kbd>validate()</kbd> <span>on that </span>like before. The result will be a list of violations, which in the case of this example, will contain one that says we are using an incorrect primitive value for the <kbd>status</kbd> field. And that is pretty much it.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Validation summary</h1>
                </header>
            
            <article>
                
<p>As we've seen, Drupal 8 applies the Symfony validation component to its very own TypedData and plugin API both for discoverability and data validation handling. In doing so, we get a low-level API for applying constraints to any kind of data, ranging from simple primitive data definitions all the way to complex entities and fields. We have not covered this here, but we can also easily create our own constraints and validators if the ones provided are not enough.</p>
<p>Moreover, we saw that we can also apply schema validations to configuration entities. This capability has been made available in version 8.6. And work is underway to expose configuration entities to the full validation system.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Summary</h1>
                </header>
            
            <article>
                
<p>You didn't think you were ever going to see this heading did you? This chapter has been very long but highly theoretical. We haven't built anything fun and the only code we saw was to exemplify most of the things we talked about. It was a difficult chapter as it covered many complex aspects of data storage and handling. But trust me, these things are important to know and this chapter can serve both as a starting point to dig deeper into the code and a reference to get back to when unsure of certain aspects.</p>
<p>We saw what the main options for storing data in Drupal 8 are. Ranging from the State API all the way to entities, you have a host of alternatives. After covering the more simple ways, such as the State API, the private and shared tempstores and the UserData API, we dove a bit more into the configuration system, which is a very important one to understand. There, we saw what kinds of configuration types we have, how to work with simple configuration, how it's managed and stored, and so on. Finally, in what is arguably the most complex part of the chapter, we looked at entities, both content and configuration. Just as you were recovering from reading all about how entity types are plugins with so many options, I hit you with the TypedData API. But right after that we put it to good use and saw how we can interact with entities: query, load, manipulate and validate data based on TypedData.</p>
<p>In the next chapter, we will apply in a very practical way a lot of the knowledge we learned in this one, especially related to content and configuration entities, but also plugin types and so on. So, that should be much more enjoyable, as we are going to create a new module that actually does something useful.</p>


            </article>

            
        </section>
    </body></html>