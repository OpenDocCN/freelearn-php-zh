<html><head></head><body>
<div id="page" style="height:0pt"/><div class="book" title="Chapter&#xA0;6.&#xA0;Plugins"><div class="book" id="190862-818f5224668745eb9070ddf1d85e6bfa"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch06" class="calibre1"/>Chapter 6. Plugins</h1></div></div></div><p class="calibre7">In this chapter, we will take a look at a feature of Magento called <span class="strong"><strong class="calibre8">plugins</strong></span>. Before we start with <a id="id208" class="calibre1"/>plugins, we first need to understand the term interception because the two terms are used somewhat interchangeably when dealing with Magento.</p><p class="calibre7"><span class="strong"><strong class="calibre8">Interception</strong></span> is<a id="id209" class="calibre1"/> a software design pattern that is used when we want to insert code dynamically without necessarily changing the original class behavior. This works by dynamically inserting code between the calling code and the target object.</p><p class="calibre7">The interception pattern in Magento is implemented via plugins. They provide the before, after, and around listeners, which help us extend the observed method behavior.</p><p class="calibre7">In this chapter, we will cover the following topics:</p><div class="book"><ul class="itemizedlist"><li class="listitem">Creating a plugin</li><li class="listitem">Using the <code class="email">before</code> listener</li><li class="listitem">Using the <code class="email">after</code> listener</li><li class="listitem">Using the <code class="email">around</code> listener</li><li class="listitem">The plugin sort order</li></ul></div><p class="calibre7">Before we start creating a plugin, it is worth noting their limitations. Plugins cannot be created for just any class or method, as they do not work for the following:</p><div class="book"><ul class="itemizedlist"><li class="listitem">Final classes</li><li class="listitem">Final methods</li><li class="listitem">The classes that are created without a dependency injection</li></ul></div><p class="calibre7">Let's go ahead and create a plugin using a simple module called <code class="email">Foggyline_Plugged</code>.</p></div>

<div class="book" title="Chapter&#xA0;6.&#xA0;Plugins">
<div class="book" title="Creating a plugin"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_1"><a id="ch06lvl1sec37" class="calibre1"/>Creating a plugin</h1></div></div></div><p class="calibre7">Start by<a id="id210" class="calibre1"/> creating the <code class="email">app/code/Foggyline/Plugged/registration.php</code> file with partial content, as follows:</p><div class="informalexample"><pre class="programlisting">\Magento\Framework\Component\ComponentRegistrar::register(
    \Magento\Framework\Component\ComponentRegistrar::MODULE,
    'Foggyline_Plugged',
    __DIR__
);</pre></div><p class="calibre7">Then, create the <code class="email">app/code/Foggyline/Plugged/etc/module.xml</code> file with partial content, as follows:</p><div class="informalexample"><pre class="programlisting">&lt;config  xsi:noNamespaceSchemaLocation="urn:magento:framework:Module/ etc/module.xsd"&gt;
    &lt;module name="Foggyline_Plugged" setup_version="1.0.0"&gt;
        &lt;sequence&gt;
            &lt;module name="Magento_Catalog"/&gt;
        &lt;/sequence&gt;
    &lt;/module&gt;
&lt;/config&gt;</pre></div><p class="calibre7">The preceding file is simply a new module declaration with the dependency set against the <code class="email">Magento_Catalog</code> module, as we will be observing its class. We will not go into the details of module declaration right now, as that will be covered later in the following chapters.</p><p class="calibre7">Now, create the <code class="email">app/code/Foggyline/Plugged/etc/di.xml</code> file with partial content, as follows:</p><div class="informalexample"><pre class="programlisting">&lt;config  xsi:noNamespaceSchemaLocation="urn:magento:framework: ObjectManager/etc/config.xsd"&gt;
    &lt;type name="Magento\Catalog\Block\Product\AbstractProduct"&gt;
        &lt;plugin name="foggyPlugin1" type="Foggyline\Plugged\Block\Catalog\Product\ AbstractProductPlugin1" disabled="false" sortOrder="100"/&gt;
        &lt;plugin name="foggyPlugin2" type="Foggyline\Plugged\Block\Catalog\Product\ AbstractProductPlugin2" disabled="false" sortOrder="200"/&gt;
        &lt;plugin name="foggyPlugin3" type="Foggyline\Plugged\Block\Catalog\Product\ AbstractProductPlugin3" disabled="false" sortOrder="300"/&gt;
    &lt;/type&gt;
&lt;/config&gt;</pre></div><p class="calibre7">Plugins are defined within the module <code class="email">di.xml</code> file. To define a plugin, by using the <code class="email">type</code> element <a id="id211" class="calibre1"/>and its <code class="email">name</code> attribute, we first map the class that we want to observe. In this case, we are observing the <code class="email">Magento\Catalog\Block\Product\AbstractProduct</code> class. Note that even though the file and class name imply an abstract type of class, the <code class="email">AbstractProduct</code> class is not abstract.</p><p class="calibre7">In the <code class="email">type</code> element, we then define one or more plugins using the <code class="email">plugin</code> element.</p><p class="calibre7">The <code class="email">plugin</code> element has the following four attributes assigned to it:</p><div class="book"><ul class="itemizedlist"><li class="listitem"><code class="email">name</code>: Using this attribute, you can provide a unique and recognizable name value that is specific to the plugin</li><li class="listitem"><code class="email">sortOrder</code>: This attribute determines the order of execution when multiple plugins are observing the same method</li><li class="listitem"><code class="email">disabled</code>: The default value of this attribute is set to <code class="email">false</code>, but if it is set to <code class="email">true</code>, it will disable the plugin</li><li class="listitem"><code class="email">type</code>: This attribute points to the class that we will be using to implement the <code class="email">before</code>, <code class="email">after</code>, or <code class="email">around</code> listener</li></ul></div><p class="calibre7">After doing this, create the <code class="email">app/code/Foggyline/Plugged/Block/Catalog/Product/AbstractProductPlugin1.php</code> file with partial content, as follows:</p><div class="informalexample"><pre class="programlisting">namespace Foggyline\Plugged\Block\Catalog\Product;

class AbstractProductPlugin1
{
    public function beforeGetAddToCartUrl(
        $subject,
        $product, $additional = []
    )
    {
        var_dump('Plugin1 - beforeGetAddToCartUrl');
    }

    public function afterGetAddToCartUrl($subject)
    {
        var_dump('Plugin1 - afterGetAddToCartUrl');
    }

    public function aroundGetAddToCartUrl(
        $subject,
        \Closure $proceed,
        $product,
        $additional = []
    )
    {
        var_dump('Plugin1 - aroundGetAddToCartUrl');
        return $proceed($product, $additional);
    }
}</pre></div><p class="calibre7">As per<a id="id212" class="calibre1"/> the type definition in the <code class="email">di.xml</code> file, the plugin observes the <code class="email">Magento\Catalog\Block\Product\AbstractProduct</code> class, and this class has a method called <code class="email">getAddToCartUrl</code>, which is defined as follows:</p><div class="informalexample"><pre class="programlisting">public function getAddToCartUrl($product, $additional = [])
{
    //method body here...
}</pre></div><p class="calibre7">The <code class="email">AbstractProductPlugin1</code> class does not have to be extended from another class for the plugin to work. We define the <code class="email">before</code>, <code class="email">after</code> and <code class="email">around</code> listeners for the <code class="email">getAddToCartUrl</code> method by using the naming convention, as follows:</p><div class="informalexample"><pre class="programlisting">&lt;before&gt; + &lt;getAddToCartUrl&gt; =&gt; beforeGetAddToCartUrl
&lt;after&gt; + &lt;getAddToCartUrl&gt; =&gt; afterGetAddToCartUrl
&lt;around&gt; + &lt;getAddToCartUrl&gt; =&gt; aroundGetAddToCartUrl</pre></div><p class="calibre7">We will go into the details of each listener later. Right now we need to finish the module by creating the <code class="email">AbstractProductPlugin2.php</code> and <code class="email">AbstractProductPlugin3.php</code> files as a copy of <code class="email">AbstractProductPlugin1.php</code> and along with that, simply changing all the number values within their code from <code class="email">1</code> to <code class="email">2</code> or <code class="email">3</code>.</p><p class="calibre7">It's a good practice to organize the listeners into folders matching the structure of the observed class location. For example, if a module is called <code class="email">Foggyline_Plugged</code> and we are observing the method in the <code class="email">Magento\Catalog\Block\Product\AbstractProduct</code> class, we should consider putting the plugin class into the <code class="email">Foggyline/Plugged/Block/Catalog/Product/AbstractProductPlugin.php</code> file. This is a not a requirement. Rather, it is a nice convention for other developers to easily manage the code.</p><p class="calibre7">Once the module is in place, we need to execute the following commands on the console:</p><div class="informalexample"><pre class="programlisting">php bin/magento module:enable Foggyline_Plugged
php bin/magento setup:upgrade</pre></div><p class="calibre7">This will make the module visible to Magento.</p><p class="calibre7">If we now open the storefront in a browser for a category page, we will see the results of all the <code class="email">var_dump</code> function calls.</p><p class="calibre7">Let's go ahead and take a look at each and every listener method in detail.</p></div></div>
<div class="book" title="Using the before listener" id="19UOO1-818f5224668745eb9070ddf1d85e6bfa"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch06lvl1sec38" class="calibre1"/>Using the before listener</h1></div></div></div><p class="calibre7">The <code class="email">before</code> listeners are used when we want to change the arguments of an original method <a id="id213" class="calibre1"/>or add some behavior before an original method is called.</p><p class="calibre7">Looking back at the <code class="email">beforeGetAddToCartUrl</code> listener method definition, you will see that it has three properties assigned in sequence—<code class="email">$subject</code>, <code class="email">$product</code>, and <code class="email">$additional</code>.</p><p class="calibre7">With the <code class="email">before</code> method listener, the first property is always the <code class="email">$subject</code> property, which contains the instance of the object type being observed. Properties following the <code class="email">$subject</code> property match the properties of the observed <code class="email">getAddToCartUrl</code> method in a sequential order.</p><p class="calibre7">This simple rule used for transformation is as follows:</p><div class="informalexample"><pre class="programlisting">getAddToCartUrl($product, $additional = [])
beforeGetAddToCartUrl($subject, $product, $additional = [])</pre></div><p class="calibre7">The <code class="email">before</code> listener methods do not need to have a return value.</p><p class="calibre7">If we run <code class="email">get_class($subject)</code> in the <code class="email">beforeGetAddToCartUrl</code> listener method that we previously saw, we will have the following result:</p><div class="informalexample"><pre class="programlisting">\Magento\Catalog\Block\Product\ListProduct\Interceptor
    extends \Magento\Catalog\Block\Product\ListProduct
        extends \Magento\Catalog\Block\Product\AbstractProduct</pre></div><p class="calibre7">What this shows is that even though we are observing the <code class="email">AbstractProduct</code> class, the <code class="email">$subject</code> property is not directly of that type. Rather, it is of the <code class="email">ListProduct\Interceptor</code> type. This is something that you should keep in mind during development.</p></div>
<div class="book" title="Using the after listener" id="1AT9A1-818f5224668745eb9070ddf1d85e6bfa"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch06lvl1sec39" class="calibre1"/>Using the after listener</h1></div></div></div><p class="calibre7">The <code class="email">after</code> listeners <a id="id214" class="calibre1"/>are used when we want to change the values returned by an original method or add some behavior after an original method is called.</p><p class="calibre7">Looking back at the <code class="email">afterGetAddToCartUrl</code> listener method definition, you will see that it has only one <code class="email">$subject</code> property assigned.</p><p class="calibre7">With the <code class="email">after</code> method listener, the first and only property is always the <code class="email">$subject</code> property, which contains the instance of the object type being observed and not the return value of the observed method.</p><p class="calibre7">This<a id="id215" class="calibre1"/> simple rule used for transformation is as follows:</p><div class="informalexample"><pre class="programlisting">getAddToCartUrl($product, $additional = [])
afterGetAddToCartUrl($subject)</pre></div><p class="calibre7">The <code class="email">after</code> listener methods do not need to have a return value.</p><p class="calibre7">Like the <code class="email">before</code> interceptor method, the <code class="email">$subject</code> property in this case is not directly of the <code class="email">AbstractProduct</code> type. Rather, it is of the parent <code class="email">ListProduct\Interceptor</code> type.</p></div>
<div class="book" title="Using the around listener" id="1BRPS1-818f5224668745eb9070ddf1d85e6bfa"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch06lvl1sec40" class="calibre1"/>Using the around listener</h1></div></div></div><p class="calibre7">The <code class="email">around</code> listeners are used when we want to change both the arguments and the returned <a id="id216" class="calibre1"/>values of an original method or add some behavior before and after an original method is called.</p><p class="calibre7">Looking back at the <code class="email">aroundGetAddToCartUrl</code> listener method definition, you will see that it has four properties assigned in sequence—<code class="email">$subject</code>, <code class="email">$proceed</code>, <code class="email">$product</code>, and <code class="email">$additional</code>.</p><p class="calibre7">With the <code class="email">after</code> method listener, the first property is always the <code class="email">$subject</code> property, which contains the instance of the object type being observed and not the return value of the observed method. The second property is always the <code class="email">$proceed</code> property of <code class="email">\Closure</code>. The properties following the <code class="email">$subject</code> and <code class="email">$proceed</code> match the properties of the observed <code class="email">getAddToCartUrl</code> method in the sequential order too.</p><p class="calibre7">This simple rule used for transformation is as follows:</p><div class="informalexample"><pre class="programlisting">getAddToCartUrl($product, $additional = [])
aroundGetAddToCartUrl(
    $subject,
    \Closure $proceed,
    $product,
    $additional = []
)</pre></div><p class="calibre7">The <code class="email">around</code> listener methods must have a return value. The return value is formed in such way that the parameters following the <code class="email">$closure</code> parameter in the <code class="email">around</code> listener method definition are passed to the <code class="email">$closure</code> function call in a sequential order, as follows:</p><div class="informalexample"><pre class="programlisting">return $proceed($product, $additional);
//or
$result = $proceed($product, $additional);
return $result;</pre></div></div>
<div class="book" title="The plugin sort order" id="1CQAE1-818f5224668745eb9070ddf1d85e6bfa"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch06lvl1sec41" class="calibre1"/>The plugin sort order</h1></div></div></div><p class="calibre7">Looking<a id="id217" class="calibre1"/> back, when we defined a plugin in the <code class="email">di.xml</code> file, one of the attributes that we set for every plugin definition was <code class="email">sortOrder</code>. It was set to <code class="email">100</code>, <code class="email">200</code> to <code class="email">300</code> for <code class="email">foggyPlugin1</code>, <code class="email">foggyPlugin2</code> and <code class="email">foggyPlugin3</code> respectively.</p><p class="calibre7">The flow of the code execution for the preceding plugins is as follows:</p><div class="book"><ul class="itemizedlist"><li class="listitem"><code class="email">Plugin1 - beforeGetAddToCartUrl</code></li><li class="listitem"><code class="email">Plugin1 - aroundGetAddToCartUrl</code></li><li class="listitem"><code class="email">Plugin2 - beforeGetAddToCartUrl</code></li><li class="listitem"><code class="email">Plugin2 - aroundGetAddToCartUrl</code></li><li class="listitem"><code class="email">Plugin3 - beforeGetAddToCartUrl</code></li><li class="listitem"><code class="email">Plugin3 - aroundGetAddToCartUrl</code></li><li class="listitem"><code class="email">Plugin3 - afterGetAddToCartUrl</code></li><li class="listitem"><code class="email">Plugin2 - afterGetAddToCartUrl</code></li><li class="listitem"><code class="email">Plugin1 - afterGetAddToCartUrl</code></li></ul></div><p class="calibre7">In other words, if multiple plugins are listening to the same method, the following execution order is used:</p><div class="book"><ul class="itemizedlist"><li class="listitem">The <code class="email">before</code> plugin functions with the lowest <code class="email">sortOrder</code> value</li><li class="listitem">The <code class="email">around</code> plugin functions with the lowest <code class="email">sortOrder</code> value</li><li class="listitem">The <code class="email">before</code> plugin functions following the <code class="email">sortOrder</code> value from the lowest to the highest</li><li class="listitem">The <code class="email">around</code> plugin functions following the <code class="email">sortOrder</code> value from the lowest to the highest</li><li class="listitem">The <code class="email">after</code> plugin functions with the highest <code class="email">sortOrder</code> value</li><li class="listitem">The <code class="email">after</code> plugin functions following the <code class="email">sortOrder</code> value from the highest to the lowest</li></ul></div><div class="informalexample" title="Note"><h3 class="title2"><a id="note15" class="calibre1"/>Note</h3><p class="calibre7">Special care needs to be taken when it comes to the <code class="email">around</code> listener, as it is the only listener that needs to return a value. If we omit the return value, we risk breaking the execution flow in such a way that the other around plugins for the same method won't be executed.</p></div></div>
<div class="book" title="Summary" id="1DOR01-818f5224668745eb9070ddf1d85e6bfa"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch06lvl1sec42" class="calibre1"/>Summary</h1></div></div></div><p class="calibre7">In this chapter, we had a look at a powerful feature of Magento called plugins. We created a small module with three plugins; each plugin had a different sort order. This enabled us to trace the execution flow of multiple plugins that observe the same method. We explored in detail the <code class="email">before</code>, <code class="email">after</code>, and <code class="email">around</code> listener methods, while having a strong emphasis on the parameter order. The finalized module used in this chapter can be found at <a class="calibre1" href="https://github.com/ajzele/B05032-Foggyline_Plugged">https://github.com/ajzele/B05032-Foggyline_Plugged</a>.</p><p class="calibre7">In the next chapter, we are going to dive deep into backend development.</p></div></body></html>