- en: Chapter 4. Reactive versus a Typical Event-Driven Approach
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第4章。响应式与典型的事件驱动方法
- en: So far, we've been focused mainly on CLI applications. In this chapter, we'll
    apply what we've already learned to a typical component of all web frameworks,
    and add a little on top of that. We're going to use the Symfony `EventDispatcher`
    component, which is an independent library that can be used in any framework.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们主要关注CLI应用程序。在本章中，我们将把我们已经学到的知识应用到所有Web框架的典型组件中，并在此基础上增加一些内容。我们将使用Symfony的`EventDispatcher`组件，这是一个可以在任何框架中使用的独立库。
- en: Its main purpose is dispatching events during an application's lifetime, and
    easy extendability. Most notably, it's a core building block of the Symfony3 framework
    and the Silex micro-framework.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 它的主要目的是在应用程序的生命周期中派发事件，并且易于扩展。最值得注意的是，它是Symfony3框架和Silex微框架的核心构建块。
- en: 'In this chapter, we''re going to do the following:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将做以下事情：
- en: Have a look at error handling in RxPHP and explain the `retry()`, `retryWhen()`,
    and `catchError()` operators. We'll see how these three relate to what we've talked
    about in the previous chapter.
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 查看RxPHP中的错误处理，并解释`retry()`、`retryWhen()`和`catchError()`操作符。我们将看到这三个操作符如何与我们之前章节中讨论的内容相关联。
- en: We'll see how to combine two Observables using `concat()` and `merge()` operators.
    Then we'll also have a look at `concatMap()` and its very common use-case with
    ordered HTTP requests.
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们将看到如何使用`concat()`和`merge()`操作符组合两个Observables。然后我们还将看看`concatMap()`及其与有序HTTP请求的非常常见的用例。
- en: Have a quick introduction to `EventDispatcher` component using examples.
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用示例快速介绍`EventDispatcher`组件。
- en: Write a drop-in replacement for the default `EventDispatcher` class called `ReactiveEventDispatcher`
    that's built on the top of the default `EventDispatcher`, with a reactive approach
    using RxPHP.
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写一个默认`EventDispatcher`类的替代品，称为`ReactiveEventDispatcher`，它基于默认的`EventDispatcher`，并使用RxPHP的响应式方法。
- en: See how we can use Subjects to construct Observable chains on the fly.
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 看看我们如何使用Subjects动态构建Observable链。
- en: Enhance our event dispatcher implementation using Observables instead of closures
    as event listeners.
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Observables而不是闭包作为事件监听器来增强我们的事件派发器实现。
- en: Test our event-dispatcher implementation on the same examples we used when introducing
    the default `EventDispatcher`.
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在介绍默认`EventDispatcher`时使用的相同示例上测试我们的事件派发器实现。
- en: Before we jump into the `EventDispatcher` component, we should also talk about
    how to handle error states in operator chains.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们深入探讨`EventDispatcher`组件之前，我们也应该谈谈如何在操作符链中处理错误状态。
- en: We've worked with `onError` handlers already in  [Chapter 2](part0024_split_000.html#MSDG2-bd355a22cf10407cb10df27e65585b8d
    "Chapter 2. Reactive Programming with RxPHP") , *Reactive Programming with RxPHP*,
    with `CURLObservable`, for example. However, we haven't seen how to gracefully
    recover from errors and what unexpected implications these might have.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经在[第2章](part0024_split_000.html#MSDG2-bd355a22cf10407cb10df27e65585b8d "第2章。使用RxPHP进行响应式编程")，*使用RxPHP进行响应式编程*中与`onError`处理程序一起工作过，例如。然而，我们还没有看到如何优雅地恢复错误以及这些可能带来的意外影响。
- en: Handling error states in operator chains
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在操作符链中处理错误状态
- en: If we go back to [Chapter 2](part0024_split_000.html#MSDG2-bd355a22cf10407cb10df27e65585b8d
    "Chapter 2. Reactive Programming with RxPHP") , *Reactive Programming with RxPHP*,
    and `CURLObservable`, we know that it emits `onError` when it wasn't able to download
    any data. The question is, what if we want to try downloading the URL again? And
    even more interestingly, repeat the failed attempt every few seconds.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们回到[第2章](part0024_split_000.html#MSDG2-bd355a22cf10407cb10df27e65585b8d "第2章。使用RxPHP进行响应式编程")，*使用RxPHP进行响应式编程*和`CURLObservable`，我们知道当它无法下载任何数据时会发出`onError`。问题是，如果我们想再次尝试下载URL怎么办？甚至更有趣的是，每隔几秒重复失败的尝试。
- en: 'Subscribing only to `onError` signals is simple with the second parameter to
    the `subscribeCallback()` method:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`subscribeCallback()`方法的第二个参数仅订阅`onError`信号非常简单：
- en: '[PRE0]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: It's obvious that nesting another `CURLObservable` into `onError` handler is
    probably not an option. This is exactly what the `retry()` operator is designed
    for.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，将另一个`CURLObservable`嵌套到`onError`处理程序中可能不是一个选择。这正是`retry()`操作符的设计目的。
- en: The retry() operator
  id: totrans-18
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: retry()操作符
- en: When the `retry()` operator receives an `onError` signal, it captures it and
    tries to resubscribe to its source Observable. It takes as an argument the number
    of times it tries to resubscribe until it passes the error signal down the operator
    chain.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 当 `retry()` 操作符收到 `onError` 信号时，它会捕获它并尝试重新订阅其源 Observable。它将尝试重新订阅的次数作为参数，直到它将错误信号传递到操作符链。
- en: 'Let''s rewrite the preceding example with the `retry()` operator:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们用 `retry()` 操作符重写前面的例子：
- en: '[PRE1]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: This tries to resubscribe to the `CURLObservable` three times, until `DebugSubject`
    receives the `onError` signal. By default, the `retry()` operator takes no parameters
    and tries to resubscribe infinitely.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 这尝试重新订阅 `CURLObservable` 三次，直到 `DebugSubject` 收到 `onError` 信号。默认情况下，`retry()`
    操作符不接收任何参数，并无限尝试重新订阅。
- en: Well, testing error states on third-party web services isn't very convenient,
    because we can't force it to return error states. For this reason, we're better
    off using the `map()` operator to trigger `onError` signals from now on.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，在第三方网络服务上测试错误状态并不方便，因为我们无法强制它返回错误状态。因此，从现在开始，我们最好使用 `map()` 操作符来触发 `onError`
    信号。
- en: 'To our advantage, the `map()` operator calls its callable wrapped inside a
    `try...catch` block, so any exception thrown will be turned into an `onError`
    signal:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 优势在于，`map()` 操作符在其 `try...catch` 块中调用其可调用包装器，因此任何抛出的异常都将转换为 `onError` 信号：
- en: '[PRE2]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Consider the following code, which is supposed to print numbers from `1` to `6`,
    but fails every time on number `3`:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下代码，它本应打印从 `1` 到 `6` 的数字，但每次在数字 `3` 处都会失败：
- en: '[PRE3]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Now, try to guess what happens before looking at the actual output, and keep
    in mind what we talked about in [Chapter 03](part0033_split_000.html#VF2I2-bd355a22cf10407cb10df27e65585b8d
    "Chapter 3. Writing a Reddit Reader with RxPHP") , *Writing a Reddit Reader with
    RxPHP*, in the section called *A closer look at Operator chains* and *A closer
    look on subscribing to Observables*:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在查看实际输出之前，试着猜测会发生什么，并记住我们在 [第 03 章](part0033_split_000.html#VF2I2-bd355a22cf10407cb10df27e65585b8d
    "第 3 章。使用 RxPHP 编写 Reddit 阅读器")，*使用 RxPHP 编写 Reddit 阅读器*，在名为 *操作符链的深入探讨* 和 *观察者订阅的深入探讨*
    的部分中讨论的内容：
- en: '[PRE4]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: It prints only the numbers `1` and `2` three times and then ends with `onError`.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 它只打印数字 `1` 和 `2` 三次，然后以 `onError` 结束。
- en: What might be confusing at first is that common sense tells us to expect this
    code to print the numbers `1`, `2`, `4`, `5`, and `6`. Number `3` throws an exception,
    but thanks to the `retry()` operator it continues with the next value.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 起初可能会让人困惑的是，常识告诉我们预期这段代码会打印出数字 `1`、`2`、`4`、`5` 和 `6`。数字 `3` 抛出异常，但多亏了 `retry()`
    操作符，它继续下一个值。
- en: However, this is not what happens, due to the fact that `retry()` resubscribes
    to its source Observable, and emitting an `onError` signal always makes the chain
    stop propagating further values. In  [Chapter 03](part0033_split_000.html#VF2I2-bd355a22cf10407cb10df27e65585b8d
    "Chapter 3. Writing a Reddit Reader with RxPHP") , *Writing a Reddit Reader with
    RxPHP*, we saw that subscribing to an Observable triggers generation of the entire
    chain of Observables that subscribe to each other in the order they were defined.
    At the end, it subscribes to the source Observable that starts emitting values.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，情况并非如此，因为 `retry()` 重新订阅其源 Observable，并且发出 `onError` 信号总是会使链停止传播更多值。在 [第
    03 章](part0033_split_000.html#VF2I2-bd355a22cf10407cb10df27e65585b8d "第 3 章。使用
    RxPHP 编写 Reddit 阅读器")，*使用 RxPHP 编写 Reddit 阅读器* 中，我们看到了订阅一个 Observable 会触发生成整个
    Observable 链，这些 Observable 按照它们定义的顺序相互订阅。最后，它订阅了开始发出值的源 Observable。
- en: We've encountered the exact same situation here. When the `map()` operator signals `onError`,
    it's immediately resubscribed thanks to the `retry()` operator, which in turn
    resubscribes to `RangeObservable` and starts emitting values from the beginning.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里遇到了完全相同的情况。当 `map()` 操作符发出 `onError` 信号时，由于 `retry()` 操作符的存在，它会立即重新订阅，然后
    `retry()` 操作符会重新订阅到 `RangeObservable` 并从开始处开始发出值。
- en: 'This is nicely demonstrated by the following marble diagram for this operator
    (note the red and yellow marbles):'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 这通过以下操作符的宝石图得到了很好的展示（注意红色和黄色的宝石）：
- en: '![The retry() operator](img/00017.jpeg)'
  id: totrans-35
  prefs: []
  type: TYPE_IMG
  zh: '![retry() 操作符](img/00017.jpeg)'
- en: Marble diagram representing the retry() operator, from http://reactivex.io/documentation/operators/retry.html
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 表示 retry() 操作符的宝石图，来自 http://reactivex.io/documentation/operators/retry.html
- en: 'If we wanted to simulate a situation where we get numbers from 1 to 6 except
    number 3, we could make an external variable, `$count`, and increment it, instead
    of relying on values coming from `RangeObservable`. To stop emitting values, we
    can use `takeWhile()`, which calls `onCompleted` when its callable returns `false`:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想要模拟一个从 1 到 6 的数字（除了数字 3）的情况，我们可以创建一个外部变量 `$count` 并递增它，而不是依赖于来自 `RangeObservable`
    的值。为了停止发出值，我们可以使用 `takeWhile()`，当其可调用返回 `false` 时，它会调用 `onCompleted`：
- en: '[PRE5]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The output is then as we expected:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 输出结果正如我们所预期的：
- en: '[PRE6]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: CURLObservable and the retry() operator
  id: totrans-41
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: CURLObservable 和 retry() 操作符
- en: 'We can make a simple test scenario that is closer to a real world application.
    We''ll take our CURLObservable and try to repeat an HTTP request three times.
    We''ll choose any non-existing URL to be sure it fails every time to see how the
    error is propagated through the operator chain when using `retry()`:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以创建一个更接近真实世界应用的简单测试场景。我们将使用我们的 CURLObservable 并尝试重复进行三次 HTTP 请求。我们将选择任何不存在的
    URL 以确保每次都失败，以便查看在使用 `retry()` 时错误是如何通过操作符链传播的：
- en: '[PRE7]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: We've already seen the `Observable::defer()` static method in [Chapter 3](part0033_split_000.html#VF2I2-bd355a22cf10407cb10df27e65585b8d
    "Chapter 3. Writing a Reddit Reader with RxPHP"), *Writing a Reddit Reader with
    RxPHP*. We're using it here to show that the `retry()` operator causes resubscription
    to the source Observable.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经在 [第 3 章](part0033_split_000.html#VF2I2-bd355a22cf10407cb10df27e65585b8d
    "第 3 章。使用 RxPHP 编写 Reddit 读者") 中看到了 `Observable::defer()` 静态方法，*使用 RxPHP 编写 Reddit
    读者*。我们在这里使用它来显示 `retry()` 操作符会导致重新订阅到源 Observable。
- en: 'This example prints to the console the following output:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 此示例将以下输出打印到控制台：
- en: '[PRE8]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: We can see that it took three iterations before the error (in fact an exception)
    reached `DebugSubject`.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到错误（实际上是一个异常）在达到 `DebugSubject` 之前经过了三次迭代。
- en: The retryWhen() operator
  id: totrans-48
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: retryWhen() 操作符
- en: Similar to `retry()`, there's also an operator called `retryWhen()`, which in
    contrast to `retry()`, doesn't re-subscribe immediately. Operator `retryWhen()`
    takes as an argument a callable that returns another Observable. This Observable
    is then used when the `onError` signal occurs, to schedule resubscription.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 与 `retry()` 类似，还有一个名为 `retryWhen()` 的操作符，与 `retry()` 不同的是，它不会立即重新订阅。操作符 `retryWhen()`
    将一个可调用参数作为参数，该参数返回另一个 Observable。然后，当发生 `onError` 信号时，使用此 Observable 来安排重新订阅。
- en: '![The retryWhen() operator](img/00018.jpeg)'
  id: totrans-50
  prefs: []
  type: TYPE_IMG
  zh: '![retryWhen() 操作符](img/00018.jpeg)'
- en: Marble diagram representing the retryWhen() operator, from http://reactivex.io/rxjs/class/es6/Observable.js~Observable.html#instance-method-retryWhen
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 表示 retryWhen() 操作符的宝石图，来自 http://reactivex.io/rxjs/class/es6/Observable.js~Observable.html#instance-method-retryWhen
- en: CURLObservable and the retryWhen() operator
  id: totrans-52
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: CURLObservable 和 retryWhen() 操作符
- en: 'For example, we can consider our `CURLObservable` once more and imagine we
    want to repeat the failed request after a one-second delay. Since the functionality
    of `retryWhen()` is a little more complicated, we''ll start with an example:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，我们可以再次考虑我们的 `CURLObservable` 并想象我们希望在延迟一秒后重复失败的请求。由于 `retryWhen()` 的功能稍微复杂一些，我们将从一个示例开始：
- en: '[PRE9]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Note
  id: totrans-55
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: We need to use an event loop to schedule the `delay()` operator.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要使用事件循环来安排 `delay()` 操作符。
- en: 'The callable to `retryWhen()` takes an Observable as an argument and has to
    return an Observable. Then, when an error signal occurs, it''s pushed to `$errObs`
    as `onNext` so we can decide based on the type of error what we want to do. Depending
    on the emissions from the returned `$notificationObs` we can control what happens
    next:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 传递给 `retryWhen()` 的可调用参数是一个 Observable，并且必须返回一个 Observable。然后，当发生错误信号时，它作为 `onNext`
    推送到 `$errObs`，这样我们就可以根据错误的类型决定我们想要做什么。根据返回的 `$notificationObs` 的发射，我们可以控制接下来会发生什么：
- en: '`onNext`: When `$notificationObs` emits the `onNext` signal, the `retryWhen()`
    operator resubscribes to its source Observable. Note that the value emitted is
    not important.'
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`onNext`：当 `$notificationObs` 发出 `onNext` 信号时，`retryWhen()` 操作符会重新订阅到其源 Observable。请注意，发出的值并不重要。'
- en: '`onError`: The error is propagated further down the operator chain.'
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`onError`：错误会进一步传播到操作符链。'
- en: '`onComplete`: The `onComplete` signal is propagated further down the operator
    chain.'
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`onComplete`：`onComplete` 信号会进一步传播到操作符链。'
- en: 'What the preceding example does should be obvious. When `CURLObservable` fails
    (emits `onError`), the `retryWhen()` operator waits one second, thanks to the `delay()`
    operator, and then resubscribes, which will make CURLObservable try to download
    the URL again indefinitely. The output from this example looks like the following:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的例子所做的事情应该是显而易见的。当 `CURLObservable` 失败（发出 `onError`）时，`retryWhen()` 操作符会等待一秒钟，多亏了
    `delay()` 操作符，然后重新订阅，这将使 CURLObservable 无限期地再次尝试下载 URL。此示例的输出如下所示：
- en: '[PRE10]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Since the `retryWhen()` operator is slightly more complicated, we can have
    a look into its internals to understand why it works the way it works:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 `retryWhen()` 操作符稍微复杂一些，我们可以查看其内部结构来理解它为什么能按这种方式工作：
- en: It creates an instance of `Subject` and stores its reference in a variable called `$errors`.
    Subjects work as both Observables and observers. It needs to use Subject, because
    it's important to be able to manually trigger signals such as `onNext`, which
    is not possible with just an Observable.
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它创建了一个 `Subject` 实例并将其引用存储在一个名为 `$errors` 的变量中。Subjects 同时作为 Observables 和观察者工作。它需要使用
    Subject，因为它很重要，能够手动触发信号，如 `onNext`，而仅仅使用 Observables 是不可能的。
- en: When the operator calls its callable, it passes along the `$errors->asObservable()`
    and expects to receive an Observable, which is stored in another variable, called `$when`.
    The method `asObservable()` wraps Subject with an `AnonymousObservable`, and thus
    hides that it is, in fact, an instance of `Subject`.
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当操作符调用其可调用函数时，它会传递 `$errors->asObservable()` 并期望接收一个 Observables，该 Observables
    存储在另一个变量中，称为 `$when`。`asObservable()` 方法用 `AnonymousObservable` 包装 Subject，因此隐藏了它实际上是一个
    `Subject` 实例的事实。
- en: Then, `CallbackObserver` is subscribed to `$when`, which can later resubscribe
    to the source Observable of this operator.
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 然后，`CallbackObserver` 订阅了 `$when`，它稍后可以重新订阅此操作符的源 Observables。
- en: This means that we have the "head" and "tail" of the chain of Observables in
    variables `$errors` and `$when`, respectively.
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这意味着我们有 Observables 链的“头部”和“尾部”分别存储在变量 `$errors` 和 `$when` 中。
- en: Later on, when an `onError` signal is received, the operator calls `$errors->onNext()`,
    which sends the value through the chain of Observables. In our case, it goes through
    the `delay()` operator.
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 之后，当接收到 `onError` 信号时，操作符会调用 `$errors->onNext()`，这会将值通过 Observables 的链式传递。在我们的例子中，它通过
    `delay()` 操作符。
- en: 'If we rewrote the preceding points into an actual heavily simplified code it
    would look like the following:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们将前面的点重写为实际的、高度简化的代码，它看起来会像以下这样：
- en: '[PRE11]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: This operator doesn't care about `onNext` or `onComplete`, and passes them right
    into `$observer`. The only signal it needs to handle is `onError`, which calls `$errors->onNext()`,
    and therefore triggers the chain of Observables, eventually resulting in resubscribing
    to the source Observable inside the `$when->subscribe()` callable.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 这个操作符不关心 `onNext` 或 `onComplete`，而是直接将它们传递给 `$observer`。它需要处理的唯一信号是 `onError`，该信号会调用
    `$errors->onNext()`，从而触发 Observables 的链式调用，最终在 `$when->subscribe()` 可调用内部重新订阅源
    Observables。
- en: This technique of using an instance of `Subject` to be able to manually trigger
    signals and at the same time subscribe observers to it is very useful. We're going
    to use it in a moment, when we implement our event dispatcher.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `Subject` 实例来手动触发信号并同时订阅观察者的这种技术非常有用。我们将在实现事件分发器时使用它。
- en: CURLObservable and controlled number of retries
  id: totrans-73
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: CURLObservable 和受控的重试次数
- en: When talking about the `retry()` operator, we made a demo where we tried to
    download a URL three times and then failed. The number of retries was fixed to
    3.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 当讨论 `retry()` 操作符时，我们做了一个演示，尝试下载一个 URL 三次，然后失败。重试次数被固定为 3。
- en: 'We can create the same example with the `retryWhen()` operator while having
    more control if and when we want to retry the HTTP request. Consider the following
    example where we make three attempts to download a URL and then propagate the
    error further:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用 `retryWhen()` 操作符创建相同的示例，同时如果我们想要重试 HTTP 请求，我们可以有更多的控制。考虑以下示例，我们尝试下载一个
    URL 三次，然后进一步传播错误：
- en: '[PRE12]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: In this example, we make three attempts where each is delayed by one second
    and then re-throw the exception, which is caught by the `map()` operator and passed
    as an `onError` signal. Since `$notificationObs` sends the `onError` signal, the
    `retryWhen()` operator passes this error further as explained previously. We also
    print the string `retryWhen` to prove that the callable is called just once even
    when there're multiple retries.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们尝试了三次，每次延迟一秒然后重新抛出异常，该异常被 `map()` 操作符捕获并作为 `onError` 信号传递。由于 `$notificationObs`
    发送了 `onError` 信号，`retryWhen()` 操作符将此错误进一步传递，正如之前解释的那样。我们还打印了字符串 `retryWhen` 来证明即使有多次重试，可调用函数也只被调用一次。
- en: 'The output from this example is the following:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 这个示例的输出如下：
- en: '[PRE13]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: What's interesting about this demo is that it doesn't need to end with the error
    at all. We could use `$notificationObs` to signal `onComplete` instead.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 这个演示有趣的地方在于它根本不需要以错误结束。我们可以使用 `$notificationObs` 来发出 `onComplete` 信号。
- en: 'The inner callable could look, for example, like the following code:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 内部可调用函数可能看起来像以下代码：
- en: '[PRE14]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'In contrast to the previous example we''re not re-throwing the exception, and
    just emitting `onComplete` instead:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 与前一个示例相比，我们不是重新抛出异常，而是只发出 `onComplete`：
- en: '[PRE15]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: This might be useful in situations where even multiple failed retries don't
    necessarily mean an error state.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能在即使多次失败重试也不一定意味着错误状态的情况下很有用。
- en: The catchError() operator
  id: totrans-86
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: catchError() 操作符
- en: The operator `catchError()` also handles only error signals. When it receives
    an `onError`, it calls a callable that returns an Observable, which is then used
    to continue the Observable sequence instead of the source Observable.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 操作符 `catchError()` 也只处理错误信号。当它收到一个 `onError` 时，它会调用一个返回 Observable 的可调用函数，然后使用该
    Observable 来继续 Observable 序列，而不是源 Observable。
- en: 'Consider the following example:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下示例：
- en: '[PRE16]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'In this example, the `onError` signal is captured by `catchError()` and, instead
    of ending the entire Observable sequence, it continues with a single value, thanks
    to `Observable::just()`, and then ends with `onComplete`:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，`onError` 信号被 `catchError()` 捕获，并且由于 `Observable::just()`，它继续以单个值结束整个
    Observable 序列，然后以 `onComplete` 结束：
- en: '[PRE17]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The concat() and merge() operators
  id: totrans-92
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: concat() 和 merge() 操作符
- en: With `retry()` and `retryWhen()` we've stumbled upon operators that take as
    parameters other Observables and work with their emissions. Combining multiple
    Observables into a single chain is a common practice mostly in RxJS due to the
    asynchronous nature of JavaScript by design. In RxPHP we don't use them as often,
    but it's worth having a quick look at them.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `retry()` 和 `retryWhen()`，我们遇到了一些接受其他 Observables 作为参数并处理它们的发射的算子。将多个 Observables
    合并成一个单一的链是 RxJS 中的常见做法，这主要是由于 JavaScript 设计上的异步性质。在 RxPHP 中，我们并不经常使用它们，但快速看一下它们是值得的。
- en: The merge() operator
  id: totrans-94
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: merge() 操作符
- en: In order to merge two Observables into a single one that emits all values from
    both of them (including `onError` signals) we can use the `merge()` operator.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 为了将两个 Observables 合并成一个单一的 Observable，该 Observable 发射来自它们的所有值（包括 `onError` 信号），我们可以使用
    `merge()` 操作符。
- en: '![The merge() operator](img/00019.jpeg)'
  id: totrans-96
  prefs: []
  type: TYPE_IMG
  zh: '![merge() 操作符](img/00019.jpeg)'
- en: Marble diagram representing the merge() operator, from http://reactivex.io/rxjs/class/es6/Observable.js~Observable.html#static-method-merge
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 来自 http://reactivex.io/rxjs/class/es6/Observable.js~Observable.html#static-method-merge
    的 merge() 操作符的宝石图
- en: As we can see from the marble diagram, this operator reemits values from source
    and the merged Observables. This means it subscribes to both of them and emits
    values as they arrive.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们从宝石图中可以看到，这个操作符重新发射来自源和合并的 Observables 的值。这意味着它订阅了它们两个，并且随着它们的到达而发射值。
- en: 'To better understand how it works, we can make a simple example with two interval
    Observables where each emits three values with different delays:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更好地理解它是如何工作的，我们可以用一个简单的示例来演示，其中包含两个间隔 Observables，每个间隔以不同的延迟发射三个值：
- en: '[PRE18]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The `$merge` Observable emits its values faster than `$source`. We also prefix
    each value to mark where it came from so the output from this example is the following:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '`$merge` Observable 发射其值的速度比 `$source` 快。我们还为每个值添加前缀以标记其来源，所以这个示例的输出如下：'
- en: '[PRE19]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: We can see that the values are mixed together. However, there's only one `onComplete`
    signal when both Observables complete, so overall it behaves like a single Observable.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到值被混合在一起。然而，当两个 Observables 都完成时，只有一个 `onComplete` 信号，所以整体上它表现得像一个单一的 Observable。
- en: The concat() operator
  id: totrans-104
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: concat() 操作符
- en: 'In contrast to `merge()` sometimes we might want to combine two Observables
    but first emit all values from the first Observable and, when it completes, subscribe
    to the second one and emit all values from that as well. For this reason, there''s
    also the `concat()` operator:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 与`merge()`相反，有时我们可能想要合并两个Observable，但首先发出第一个Observable的所有值，当它完成时，订阅第二个Observable并发出其所有值。因此，也存在`concat()`操作符：
- en: '![The concat() operator](img/00020.jpeg)'
  id: totrans-106
  prefs: []
  type: TYPE_IMG
  zh: '![concat()操作符](img/00020.jpeg)'
- en: Marble diagram representing the concat() operator, from http://reactivex.io/rxjs/class/es6/Observable.js~Observable.html#instance-method-concat
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 表示concat()操作符的宝石图，来自http://reactivex.io/rxjs/class/es6/Observable.js~Observable.html#instance-method-concat
- en: 'We can take the same example as we made for `merge()` and just switch the `merge()`
    operator to `concat()`:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以拿与`merge()`相同的例子，只需将`merge()`操作符切换为`concat()`：
- en: '[PRE20]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Since `concat()` should subscribe to the source and concatenated Observables
    one after another we should expect to receive first all values from the source
    Observable and, when it completes, all values from `$concat` Observable.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`concat()`应该订阅源Observable并依次连接其他Observable，因此我们预期首先接收到源Observable的所有值，当它完成时，再接收到`$concat`
    Observable的所有值。
- en: '[PRE21]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Even though the concatenated Observable emits values faster than the source
    Observable, its values follow after all the values from source.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 即使连接的Observable比源Observable更快地发出值，但其值仍然跟在源Observable的所有值之后。
- en: The concatMap() and flatMap() operators
  id: totrans-113
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: concatMap()和flatMap()操作符
- en: Both the `merge()` and `concat()` operators have their `*map()` variants. In
    particular these are `flatMap()` and `concatMap()`. These operators combine the
    functionality of `merge()`/`concat()` with the `map()` operator. If we look at
    both examples we made a moment ago, we'll see that we need to know the inner Observable
    beforehand. This means the inner Observable is passed to `concat()`/`merge()`
    once when creating the Observable chain.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '`merge()`和`concat()`操作符都有它们的`*map()`变体。特别是这些是`flatMap()`和`concatMap()`。这些操作符结合了`merge()`/`concat()`和`map()`操作符的功能。如果我们看看我们刚才做的两个例子，我们会看到我们需要事先知道内部Observable。这意味着内部Observable在创建Observable链时被传递给`concat()`/`merge()`一次。'
- en: We'll pick one of the two operators and explain its benefits in an example.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将选择两个操作符中的一个，并通过一个示例来解释其优点。
- en: 'Let''s imagine we want to make three HTTP requests one after another. This
    looks like an ideal use case for the `concat()` operator. However, each request
    is going to be dependent on the result from the previous one, so we need to use
    `concatMap()` instead because its callable takes the current value from the source
    Observable as a parameter and returns an Observable that''ll be concatenated to
    the chain:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们假设我们想要依次进行三个HTTP请求。这看起来像是`concat()`操作符的理想用例。然而，每个请求都将依赖于前一个请求的结果，因此我们需要使用`concatMap()`，因为它的可调用参数是源Observable的当前值，并返回一个将被连接到链中的Observable：
- en: '[PRE22]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: We're using the [http://httpbin.org/get](http://httpbin.org/get) web service
    that serves as a test server and returns the request we sent as a JSON string.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 我们正在使用[http://httpbin.org/get](http://httpbin.org/get)网络服务，它作为测试服务器，并将我们发送的请求作为JSON字符串返回。
- en: We used `Observable::emptyObservable()` to create an empty Observable that completes
    immediately, and chain it with one `concat()` and two `concatMap()` operators.
    Each `concatMap()` then decodes the JSON from the previous requests, takes its
    `num` parameter multiplied by 2 and resends the HTTP request.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`Observable::emptyObservable()`创建一个立即完成的空Observable，并将其与一个`concat()`和两个`concatMap()`操作符连接起来。然后，每个`concatMap()`解码前一个请求的JSON，将其`num`参数乘以2，并重新发送HTTP请求。
- en: 'Then, from the console output, we can see the requests are called in order
    and the random `num` parameter created in the `concat()` operator call is multiplied
    by 2 with every request:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，从控制台输出中，我们可以看到请求是按顺序调用的，并且在`concat()`操作符调用中创建的随机`num`参数在每次请求中都会乘以2：
- en: '[PRE23]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: With `flatMap()` the example would be the same. However, since PHP isn't asynchronous
    like JavaScript, `flatMap()` operator isn't as useful in this particular use case.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`flatMap()`，例子将是相同的。然而，由于PHP不像JavaScript那样是异步的，`flatMap()`操作符在这个特定用例中并不那么有用。
- en: We'll have a look at more operators that combine multiple Observables in [Chapter
    6](part0050_split_000.html#1FLS41-bd355a22cf10407cb10df27e65585b8d "Chapter 6. PHP
    Streams API and Higher-Order Observables"), *PHP Streams API and Higher-Order
    Observables*.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在[第6章](part0050_split_000.html#1FLS41-bd355a22cf10407cb10df27e65585b8d "第6章。PHP
    Streams API和Higher-Order Observables")中查看更多结合多个Observables的操作符，*PHP Streams API和Higher-Order
    Observables*。
- en: Writing a reactive event dispatcher
  id: totrans-124
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编写响应式事件派发器
- en: The Symfony `EventDispatcher` component is a PHP library for exchanging messages
    between objects. It's based on the Mediator design pattern ( [https://en.wikipedia.org/wiki/Mediator_pattern](https://en.wikipedia.org/wiki/Mediator_pattern)
    ), and its implementation is relatively simple.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: Symfony的`EventDispatcher`组件是一个用于在对象之间交换消息的PHP库。它基于中介者设计模式（[https://en.wikipedia.org/wiki/Mediator_pattern](https://en.wikipedia.org/wiki/Mediator_pattern)），其实现相对简单。
- en: A very common scenario is when we have an application that we want to make extendable
    via plugins. In this case, we'd create a single instance of `EventDispatcher`
    and let plugins listen to various events. Each event is an object that can hold
    references to other objects as well. This is what the Symfony3 framework does
    extensively.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 一个非常常见的场景是我们有一个想要通过插件扩展的应用程序。在这种情况下，我们会创建一个`EventDispatcher`的单例实例，并让插件监听各种事件。每个事件都是一个对象，它可以持有对其他对象的引用。这正是Symfony3框架所广泛使用的。
- en: A quick introduction to EventDispatcher
  id: totrans-127
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 事件派发器快速入门
- en: 'If you haven''t done so already, install the Event Dispatcher component via
    `composer`:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你还没有这样做，请通过`composer`安装事件派发器组件：
- en: '[PRE24]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: First, we're going to have a look at how the default implementation is used
    in practice, so we can later compare it to our reactive implementation, and check
    that both work the same from a developer's perspective while the internal implementation
    is different.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将查看默认实现的实际使用方法，这样我们就可以稍后将其与我们的响应式实现进行比较，并检查从开发者的角度来看，两者是否都能正常工作，尽管内部实现不同。
- en: Working with event listeners
  id: totrans-131
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 与事件监听器一起工作
- en: 'In the most basic situation, we just want to set up a couple of listeners and
    dispatch events:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 在最基本的情况下，我们只想设置几个监听器并派发事件：
- en: '[PRE25]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: We created three event listeners to two different events, `my_action` and `other_action`.
    Then, with `$dispatcher->dispatch()`, we tell the event dispatcher to notify all
    event listeners that the event called `my_action` occurred.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 我们为两个不同的事件`my_action`和`other_action`创建了三个事件监听器。然后，通过`$dispatcher->dispatch()`，我们告诉事件派发器通知所有事件监听器，事件`my_action`已经发生。
- en: 'The output in the console should be obvious:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 控制台中的输出应该是明显的：
- en: '[PRE26]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: The `dispatch()` method takes an optional second argument with an instance of
    `Event` class that can contain further information about the event. Event listeners
    can also modify event data if necessary. Also, all callables receive exactly one
    argument with the event object, which comes from the initial call to the `dispatch()`
    method. Since we didn't provide any event object, our callables don't need to
    accept any parameter.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: '`dispatch()`方法接受一个可选的第二个参数，该参数是一个`Event`类的实例，它可以包含有关事件的更多信息。如果需要，事件监听器也可以修改事件数据。此外，所有可调用对象都恰好接受一个事件对象作为参数，该参数来自对`dispatch()`方法的初始调用。由于我们没有提供任何事件对象，我们的可调用对象不需要接受任何参数。'
- en: 'Note that the event dispatcher doesn''t need to know what events it supports,
    as they are created on the fly. This also means you can accidentally try to dispatch
    a non-existent event:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，事件派发器不需要知道它支持哪些事件，因为它们是即时创建的。这也意味着你可能会意外地尝试派发一个不存在的事件：
- en: '[PRE27]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: This won't throw an error, but no event will be dispatched.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 这不会引发错误，但不会派发任何事件。
- en: 'The `EventDispatcher` class supports two important features:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: '`EventDispatcher`类支持两个重要的特性：'
- en: '**Priority**: By default, listeners are executed in the order they subscribe
    to the event dispatcher. We can alter this behavior by supplying a third argument
    to the `addListener()` method with priority for this particular listener (it''s
    0 by default). Listeners with higher priority are executed first. If more listeners
    have the same priority, then the order they were added matters.'
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**优先级**：默认情况下，监听器按照它们订阅事件派发器的顺序执行。我们可以通过向`addListener()`方法提供一个带有特定监听器优先级的第三个参数来改变这种行为（默认为0）。优先级较高的监听器会先执行。如果多个监听器具有相同的优先级，那么它们的添加顺序就很重要了。'
- en: '**Stopping event propagation**: In some scenarios, it''s important to be able
    to stop propagating a particular event to subsequent listeners. For this reason,
    the `Event` class has a method called `stopPropagation()`. The event dispatcher
    is then responsible for not propagating this event further.'
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**停止事件传播**：在某些场景中，能够停止将特定事件传播给后续监听器是很重要的。因此，`Event`类有一个名为`stopPropagation()`的方法。然后事件派发器负责不再传播此事件。'
- en: 'These two features can be used in a situation such as the following:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个特性可以用于以下情况：
- en: '[PRE28]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: The first event listener should be called after the second one because it has
    higher priority, but it stops further propagation of this event using `$event->stopPropagation()`,
    so it's never invoked.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个事件监听器应该在第二个监听器之后被调用，因为它具有更高的优先级，但它使用 `$event->stopPropagation()` 停止进一步传播此事件，所以它永远不会被调用。
- en: 'The console output is then very short:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 控制台输出非常简短：
- en: '[PRE29]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Working with event subscribers
  id: totrans-149
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 与事件订阅者一起工作
- en: While `addListener()` subscribes to a single event listener, there's also the `addSubscriber()`
    method, which accepts an instance of a class implementing  `EventSubscriberInterface`
    and subscribes to multiple events at once. In fact, `addSubscriber()` uses `addListener()`
    internally to add listeners. Sometimes it's just easier to wrap all listeners
    into a single class than add them one by one.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然 `addListener()` 订阅单个事件监听器，但还有一个 `addSubscriber()` 方法，它接受一个实现 `EventSubscriberInterface`
    的类的实例，并一次性订阅多个事件。实际上，`addSubscriber()` 使用 `addListener()` 内部添加监听器。有时将所有监听器包装到一个类中比逐个添加它们要简单得多。
- en: Throughout this and upcoming examples in this chapter, we're also going to use
    a custom `Event` class in order to properly test that both the default and our
    reactive implementations work the same.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的整个内容和即将到来的示例中，我们还将使用一个自定义的 `Event` 类，以便正确测试默认和我们的响应式实现是否工作相同。
- en: 'First, let''s declare our event class:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们声明我们的事件类：
- en: '[PRE30]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: It's a pretty simple class. We'll use the `inc()` method to see that all the
    listeners work with the same instance of `MyEvent`. We also use the `__toString()`
    magic method so we can convert this class to string just by typecasting it.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个相当简单的类。我们将使用 `inc()` 方法来验证所有监听器都使用相同的 `MyEvent` 实例。我们还使用了 `__toString()`
    魔法方法，这样我们就可以通过类型转换将这个类转换为字符串。
- en: 'Now, for demonstration purposes, we''ll declare a `MyEventSubscriber` class
    with three event listeners:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，为了演示目的，我们将声明一个具有三个事件监听器的 `MyEventSubscriber` 类：
- en: '[PRE31]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: The interface `EventSubscriberInterface` requires only the static method `getSubscribedEvents()`,
    which returns an associative array of event names and their appropriate callables.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: '`EventSubscriberInterface` 接口只需要一个静态方法 `getSubscribedEvents()`，它返回一个包含事件名称及其相应可调用对象的关联数组。'
- en: This example class declares two listeners for the `my_action` event (where the
    second one has higher priority than the first) and one listener for the `other_action`
    event.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 这个示例类声明了两个监听器用于 `my_action` 事件（第二个监听器的优先级高于第一个）和一个监听器用于 `other_action` 事件。
- en: 'Subscribing to this class works the same way as subscribing to listeners:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 订阅到这个类的方式与订阅监听器的方式相同：
- en: '[PRE32]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'This time, the example also prints a string representation of the event:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 这次，示例还打印了事件的字符串表示：
- en: '[PRE33]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: This is yet another thing we need to handle, because we want to allow defining
    event Observables in an event subscriber class.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们需要处理的另一件事，因为我们希望允许在事件订阅者类中定义事件观察者。
- en: Now we know how the default `EventDispatcher` class can be used and what use
    cases it's supposed to fulfill. Our goal will be to write our own implementation
    based on RxPHP and reactive programming.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们知道了默认的 `EventDispatcher` 类如何使用以及它应该满足哪些用例。我们的目标将是基于 RxPHP 和响应式编程编写我们自己的实现。
- en: Writing ReactiveEventDispatcher with RxPHP
  id: totrans-165
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 RxPHP 编写 ReactiveEventDispatcher
- en: Event dispatchers need to implement an `EventDispatcherInterface` interface
    that defines all the methods we've seen previously, and we'll also add a few more.
    Luckily for us, we can reuse a large part of the default `EventDispatcher` class.
    For example, the `removeListener()` or `removeSubscriber()` methods will work
    without any modification.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 事件调度器需要实现一个 `EventDispatcherInterface` 接口，该接口定义了我们之前看到的所有方法，我们还将添加一些更多。幸运的是，我们可以重用默认
    `EventDispatcher` 类的大部分内容。例如，`removeListener()` 或 `removeSubscriber()` 方法将无需任何修改即可工作。
- en: Internal representation of event listeners as observers
  id: totrans-167
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 事件监听器作为观察者的内部表示
- en: 'The original `EventDispatcher` had a very easy task. On the `dispatch()` call,
    it just sorted the array of listeners for that particular event by their priority
    and evaluated them one by one, in a loop:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 原始的 `EventDispatcher` 有一个非常简单的任务。在 `dispatch()` 调用中，它只是根据优先级对特定事件的监听器数组进行排序，并逐个评估它们，在一个循环中：
- en: '[PRE34]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: In our case, we're going to represent all event listeners as observers. In fact,
    when we add a new event listener, we'll transform its callable into an observer.
    Then, when calling `dispatch()`, we'll create a chain of Observables where all
    observers are already subscribed at specific points. Of course, we also need to
    handle the  `isPropagationStopped()` condition by ourselves.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, let''s consider the simplest usage of the event dispatcher, as
    shown previously:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'We have to turn these two event listeners into a chain of Observables while
    making sure that, before each event listener is executed, we check that the event
    object hasn''t got the stop propagation flag set:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'We''re using Subject here for the same reason as we explained earlier in the
    chapter when we talked about the `retryWhen()` operator. Still, let''s explain
    this code in more detail:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
- en: The `$subject` variable holds a reference to the "head" of the chain of Observables
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `$tail` variable always holds a reference to the last Observable in the
    chain. This is where we further chain more Observables, and where we append the `filter()`
    operator that checks for stopped events.
  id: totrans-177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When we want to dispatch an event, we just need to call `$subject->onNext()`.
  id: totrans-178
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'To be extra clear what the current chain of Observables looks like, we can
    represent it as a tree structure:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
- en: '![Internal representation of event listeners as observers](img/00021.jpeg)'
  id: totrans-180
  prefs: []
  type: TYPE_IMG
- en: Now we just need to turn all this into a real PHP class.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
- en: Writing a ReactiveEventDispatcher class
  id: totrans-182
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The good thing is that we can actually reuse a lot of the logic already written
    in `EventDispatcher` and just overload certain methods that need to work differently.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we''ll just write a class stub to see what''s waiting ahead of us, and
    talk a little about each method:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Only the methods `dispatch()`, `addListener()`, and `addSubscriber()` from `EventDispatcher`
    need to be overwritten; the rest can remain as they are. We also added three more
    methods to help us deal with Observables.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s see what the purpose of each component is:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
- en: '`$subjects`: An associative array that holds references to all heads of Observable
    chains (their Subjects).'
  id: totrans-188
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`addListener()`: We already know this method from previous examples. However,
    now the method also accepts observers as event listeners.'
  id: totrans-189
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`addObservable()`: This is a method that lets us append an Observable to a
    specific point in the chain of Observables generated by `getSubject()`.'
  id: totrans-190
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`addSubscriber()`: This subscribes to multiple events with the subscription
    class. It uses the `addObserver()` method.'
  id: totrans-191
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`dispatch()`: This method takes the instance of `Subject` for this particular
    event and calls `onNext()`, with the event object as a parameter.'
  id: totrans-192
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`observerFromListener()`: A helper method that transforms any listener into
    an observer. Basically, this just wraps every callable with a `CallbackObserver`
    object.'
  id: totrans-193
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`getSubject()`: Our event dispatcher is going to work with Subjects. This method
    internally sorts an array of listeners by their priority and constructs a chain
    of Observables from them. It''ll also keep Subjects in the `$subjects` associative
    array, to be easily reused without necessarily creating the Observable chain all
    over again on every `dispatch()` call.'
  id: totrans-194
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: So, we have a pretty good picture of how this event dispatcher is going to work,
    and we can start implementing each method.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
- en: Adding event listeners
  id: totrans-196
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The first two methods are going to be `addListener()` and `observerFromListener()`.
    The first one is dependent on the second one, so we''ll write both of them at
    the same time:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Note
  id: totrans-199
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In the rest of the examples in this chapter, we're also going to include doc
    blocks and type hints for each method to clarify what arguments it accepts.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
- en: The `observerFromListener()` method checks the runtime type of `$listener` and
    always turns it into an instance of observer.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
- en: The method `addListener()` uses `observerFromListener()` internally, and then
    calls its parent's `addListener()` with the observer as an argument, even though
    it originally accepted only callables. The parent method stores the listener in
    a nested associative array by event name and priority. Since the parent's code
    is pretty universal, we don't need to make any changes to it and will leave it
    as is.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
- en: Note that, after we call the parent `addListener()`, we remove a Subject from
    the `$subjects` array for this particular event. This is because we modified the
    Observable chain for this event and it needs to be created from scratch. This
    happens later, when calling the `dispatch()` method.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
- en: Adding Observables
  id: totrans-204
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Speaking of listeners, we can now also implement `addObservable()`, which is
    a slightly modified version of `addListener()`. This method is going to be used
    differently than `addListener()`, so it deserves special attention:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: We create an instance of `Subject` and call `asObservable()` to let the user-defined
    callable append its operators to it. Then we call `addListener()` with the `$subject` variable
    that we explained a moment ago. Again, this is the same technique we described
    with the `retryWhen()` operator.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
- en: 'This method is interesting, because it lets us add a "sub-chain" of Observables
    as a listener. Consider the following code:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'If we represent this code as a tree structure as we did before, inside the
    `$dispatcher`, it will look like the following (this structure is generated later
    inside the `getSubject()` method):'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
- en: '![Adding Observables](img/00022.jpeg)'
  id: totrans-211
  prefs: []
  type: TYPE_IMG
- en: Event "my_action" with two event listeners
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
- en: So, this event listener appends a series of operators in its callable and then
    subscribes to it. In the `addObservable()` method, we pass only the `$subject`
    itself to the `addListener()`, which is later appended to the `filter()` operator,
    when calling `dispatch()`. This works thanks to the fact that Subjects work as
    observers as well and can subscribe to Observables.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
- en: This is the major benefit of writing our custom `ReactiveEventDispatcher`. We're
    using reactive programming to easily manipulate events that interest us in a very
    straightforward way. If we used the default event dispatcher, we'd have to put
    all the listener-specific conditions inside the callable.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
- en: Adding event subscribers
  id: totrans-215
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Similar to the original `EventDispatcher`, we want to be able to subscribe multiple
    listeners to multiple events at once, using a subscriber class. However, we're
    also going to support adding listeners as Observables, just like we did with `addObservable()`.
    This is not going to work without overloading the parent's `addSubscriber()` method
    and handling Observables in a special way.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
- en: 'Basically, we need to call `addObservable()` instead of the `addListener()`
    method:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
- en: 'First, let''s define an interface that we can use to recognize an event subscriber
    class that also defines Observables as listeners:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Now, `addSubscriber()` can check whether the class is an instance of this interface
    and, if it is, process all its listeners as if they were Observables:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: The array of event listeners can be defined as an array, with a key as the event
    name and its value as a callable. However, our implementation also supports using
    array values as another array defining the callable and priority (that's the second
    nested `foreach` loop).
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
- en: At the beginning of this method, we also call its parent because we want to
    allow the default functionality as well.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
- en: 'For demonstration purposes, we''re going to extend the `MyEventSubscriber`
    class we defined earlier and implement the `getSubscribedEventsObservables()`
    method, which is going to return two event listeners:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: We defined three event listeners for two different events, where the first one
    for `my_action` event has priority `10` and the second the default, `0`.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
- en: Creating the Observable chain for an event
  id: totrans-227
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The method `getSubject()` is the place where Observable chains are being generated.
    This method is then called only when dispatching an event:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: If the Subject for this event doesn't exist, we create a new one and then call
    `getListeners()`. This method is defined in the parent `EventDispatcher` class
    and returns a sorted array of listeners (or observers, in our case). Then we iterate
    the array and add a `filter()` operator followed by subscribing the observer or
    Subject, depending on whether we used `addListener()` or `addObservable()`.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-231
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Note that operators (such as `filter()`, in this example) always return a new
    Observable, while calling `subscribe()` returns a disposable object.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
- en: We don't need to create the `$subject` every time we call this method, because
    it doesn't change until we add new listeners, so we can keep a reference to it
    in the `$subjects` array.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
- en: Comparing filter() to takeWhile()
  id: totrans-234
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In the previous [Chapter 3](part0033_split_000.html#VF2I2-bd355a22cf10407cb10df27e65585b8d
    "Chapter 3. Writing a Reddit Reader with RxPHP"), *Writing a Reddit Reader with
    RxPHP*, we mentioned an operator that might work well instead of `filter()`. We
    used `takeWhile()`, which also takes a predicate callable as a parameter and can
    stop propagating values down the Observable chain.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
- en: The important distinction is that the `filter()` operator decides whether or
    not it internally calls `onNext()` on its associated observer. On the other hand, 
    `takeWhile()` decides whether or not it calls `onComplete()`. Calling `onComplete()`
    would lead to invoking disposables, which would unsubscribe the observers, and
    this is definitely not what we want. If we did unsubscribe, we'd have to create
    the Subject for each event on every `dispatch()` call.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-237
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In [Chapter 8](part0061_split_000.html#1Q5IA1-bd355a22cf10407cb10df27e65585b8d
    "Chapter 8. Multicasting in RxPHP and PHP7 pthreads Extension"), *Multicasting
    in RxPHP and PHP7 pthreads Extension*, we'll talk more about what unexpected consequences
    calling `onComplete` on a `Subject` might have.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
- en: Dispatching events
  id: totrans-239
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Finally, dispatching events is very simple:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: Dispatching an event in our reactive dispatcher means taking the Subject for
    this particular event and calling its `onNext()` method, with the event as an
    argument. The event then gets propagated unless its `stopPropagation()` method
    is called, because we check its state before calling every observer with the `filter()`
    operator.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
- en: We also return the event from the method, to stay compatible with the default
    `EventDispatcher` implementation.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
- en: And that's it. Our `ReactiveEventDispatcher` is complete and we can run a few
    test scenarios.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
- en: Practical example of ReactiveEventDispatcher
  id: totrans-245
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We dedicated the first part of this chapter to explaining how the default `EventDispatcher`
    that comes out of the box with the Symfony `EventDispatcher` component works,
    and what use cases we expect it to deal with.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
- en: Now we need to make sure the same applies to `ReactiveEventDispatcher` as well.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
- en: Working with event listeners
  id: totrans-248
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We know that our overridden `addListener()` method now accepts both callables
    and observers, so we can test both use cases in one example:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'This example calls the second listener and then the first listener, because
    the second one has a higher priority:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Now, let''s test event subscribers with the same `MyEventSubscriber` class
    we used in the preceding example. The usage and the output are exactly the same,
    so we don''t need to print the output here again:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'A slightly modified example, which dispatches multiple events, uses Observables
    and fiddles with conditional stopping event propagation, could look like the following:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Its output is obvious. When the event''s `getCounter()` method returns a number
    divisible by 2, the event is stopped and never reaches the first event listener
    added using `addListener()`:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: Working with event subscribers
  id: totrans-259
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Let''s also test that the event subscriber `MyObservableEventSubscriber` we
    defined earlier works as expected:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Remember that we extended the original `MyEventSubscriber` and added two more
    listeners, so the event dispatcher first adds listeners returned from  `getSubscribedEvents()`,
    and then adds those from  `getSubscribedEventsObservables()`:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: The listener with the highest priority is called first. In our case, it's the
    first Observable listener with priority 10, then `onMyActionAgain()` is called,
    with priority 1, and then the two remaining listeners are called in the order
    they were added.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-265
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter has focused mainly on the practical usage of RxPHP in combination
    with typical non-reactive code, and presented a different approach to existing
    event-based solutions.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
- en: Specifically, we stumbled across Error handling in Observable chains with `retry()`,
    `RetryWhen()`, and `catch()` operators. We combined Observables with the `concat()`,
    `merge()`, and `concatMap()` operator. We used Subjects to dynamically create
    Observable chains and manually emit values. You were also given an introduction
    to the Symfony `EventDispatcher` component, with a series of examples presenting
    how the default `EventDispatcher` class that comes out of the box can be used.
    We extended and partially rewrote the `EventDispatcher` class and created `ReactiveEventDispatcher`,
    which adds support for Observables. And lastly, we reused examples for `EventDispatcher`
    with `ReactiveEventDispatcher` to demonstrate that our implementation can work
    as a drop-in replacement.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
- en: The Symfony `EventDispatcher` component serves as an easily implementable solution
    to a common problem in larger applications, which is communication between object
    and extendability. We wrote `ReactiveEventDispatcher` to add capabilities to also
    use observers as event listeners.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we'll learn how to write unit tests to test Observables,
    operators, and observers. We'll also have a better look at Schedulers and see
    how important are they in testing RxPHP code.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
