- en: Chapter 4. Reactive versus a Typical Event-Driven Approach
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第4章。响应式与典型的事件驱动方法
- en: So far, we've been focused mainly on CLI applications. In this chapter, we'll
    apply what we've already learned to a typical component of all web frameworks,
    and add a little on top of that. We're going to use the Symfony `EventDispatcher`
    component, which is an independent library that can be used in any framework.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们主要关注CLI应用程序。在本章中，我们将把我们已经学到的知识应用到所有Web框架的典型组件中，并在此基础上增加一些内容。我们将使用Symfony的`EventDispatcher`组件，这是一个可以在任何框架中使用的独立库。
- en: Its main purpose is dispatching events during an application's lifetime, and
    easy extendability. Most notably, it's a core building block of the Symfony3 framework
    and the Silex micro-framework.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 它的主要目的是在应用程序的生命周期中派发事件，并且易于扩展。最值得注意的是，它是Symfony3框架和Silex微框架的核心构建块。
- en: 'In this chapter, we''re going to do the following:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将做以下事情：
- en: Have a look at error handling in RxPHP and explain the `retry()`, `retryWhen()`,
    and `catchError()` operators. We'll see how these three relate to what we've talked
    about in the previous chapter.
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 查看RxPHP中的错误处理，并解释`retry()`、`retryWhen()`和`catchError()`操作符。我们将看到这三个操作符如何与我们之前章节中讨论的内容相关联。
- en: We'll see how to combine two Observables using `concat()` and `merge()` operators.
    Then we'll also have a look at `concatMap()` and its very common use-case with
    ordered HTTP requests.
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们将看到如何使用`concat()`和`merge()`操作符组合两个Observables。然后我们还将看看`concatMap()`及其与有序HTTP请求的非常常见的用例。
- en: Have a quick introduction to `EventDispatcher` component using examples.
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用示例快速介绍`EventDispatcher`组件。
- en: Write a drop-in replacement for the default `EventDispatcher` class called `ReactiveEventDispatcher`
    that's built on the top of the default `EventDispatcher`, with a reactive approach
    using RxPHP.
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写一个默认`EventDispatcher`类的替代品，称为`ReactiveEventDispatcher`，它基于默认的`EventDispatcher`，并使用RxPHP的响应式方法。
- en: See how we can use Subjects to construct Observable chains on the fly.
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 看看我们如何使用Subjects动态构建Observable链。
- en: Enhance our event dispatcher implementation using Observables instead of closures
    as event listeners.
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Observables而不是闭包作为事件监听器来增强我们的事件派发器实现。
- en: Test our event-dispatcher implementation on the same examples we used when introducing
    the default `EventDispatcher`.
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在介绍默认`EventDispatcher`时使用的相同示例上测试我们的事件派发器实现。
- en: Before we jump into the `EventDispatcher` component, we should also talk about
    how to handle error states in operator chains.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们深入探讨`EventDispatcher`组件之前，我们也应该谈谈如何在操作符链中处理错误状态。
- en: We've worked with `onError` handlers already in  [Chapter 2](part0024_split_000.html#MSDG2-bd355a22cf10407cb10df27e65585b8d
    "Chapter 2. Reactive Programming with RxPHP") , *Reactive Programming with RxPHP*,
    with `CURLObservable`, for example. However, we haven't seen how to gracefully
    recover from errors and what unexpected implications these might have.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经在[第2章](part0024_split_000.html#MSDG2-bd355a22cf10407cb10df27e65585b8d "第2章。使用RxPHP进行响应式编程")，*使用RxPHP进行响应式编程*中与`onError`处理程序一起工作过，例如。然而，我们还没有看到如何优雅地恢复错误以及这些可能带来的意外影响。
- en: Handling error states in operator chains
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在操作符链中处理错误状态
- en: If we go back to [Chapter 2](part0024_split_000.html#MSDG2-bd355a22cf10407cb10df27e65585b8d
    "Chapter 2. Reactive Programming with RxPHP") , *Reactive Programming with RxPHP*,
    and `CURLObservable`, we know that it emits `onError` when it wasn't able to download
    any data. The question is, what if we want to try downloading the URL again? And
    even more interestingly, repeat the failed attempt every few seconds.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们回到[第2章](part0024_split_000.html#MSDG2-bd355a22cf10407cb10df27e65585b8d "第2章。使用RxPHP进行响应式编程")，*使用RxPHP进行响应式编程*和`CURLObservable`，我们知道当它无法下载任何数据时会发出`onError`。问题是，如果我们想再次尝试下载URL怎么办？甚至更有趣的是，每隔几秒重复失败的尝试。
- en: 'Subscribing only to `onError` signals is simple with the second parameter to
    the `subscribeCallback()` method:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`subscribeCallback()`方法的第二个参数仅订阅`onError`信号非常简单：
- en: '[PRE0]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: It's obvious that nesting another `CURLObservable` into `onError` handler is
    probably not an option. This is exactly what the `retry()` operator is designed
    for.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，将另一个`CURLObservable`嵌套到`onError`处理程序中可能不是一个选择。这正是`retry()`操作符的设计目的。
- en: The retry() operator
  id: totrans-18
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: retry()操作符
- en: When the `retry()` operator receives an `onError` signal, it captures it and
    tries to resubscribe to its source Observable. It takes as an argument the number
    of times it tries to resubscribe until it passes the error signal down the operator
    chain.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 当 `retry()` 操作符收到 `onError` 信号时，它会捕获它并尝试重新订阅其源 Observable。它将尝试重新订阅的次数作为参数，直到它将错误信号传递到操作符链。
- en: 'Let''s rewrite the preceding example with the `retry()` operator:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们用 `retry()` 操作符重写前面的例子：
- en: '[PRE1]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: This tries to resubscribe to the `CURLObservable` three times, until `DebugSubject`
    receives the `onError` signal. By default, the `retry()` operator takes no parameters
    and tries to resubscribe infinitely.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 这尝试重新订阅 `CURLObservable` 三次，直到 `DebugSubject` 收到 `onError` 信号。默认情况下，`retry()`
    操作符不接收任何参数，并无限尝试重新订阅。
- en: Well, testing error states on third-party web services isn't very convenient,
    because we can't force it to return error states. For this reason, we're better
    off using the `map()` operator to trigger `onError` signals from now on.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，在第三方网络服务上测试错误状态并不方便，因为我们无法强制它返回错误状态。因此，从现在开始，我们最好使用 `map()` 操作符来触发 `onError`
    信号。
- en: 'To our advantage, the `map()` operator calls its callable wrapped inside a
    `try...catch` block, so any exception thrown will be turned into an `onError`
    signal:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 优势在于，`map()` 操作符在其 `try...catch` 块中调用其可调用包装器，因此任何抛出的异常都将转换为 `onError` 信号：
- en: '[PRE2]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Consider the following code, which is supposed to print numbers from `1` to `6`,
    but fails every time on number `3`:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下代码，它本应打印从 `1` 到 `6` 的数字，但每次在数字 `3` 处都会失败：
- en: '[PRE3]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Now, try to guess what happens before looking at the actual output, and keep
    in mind what we talked about in [Chapter 03](part0033_split_000.html#VF2I2-bd355a22cf10407cb10df27e65585b8d
    "Chapter 3. Writing a Reddit Reader with RxPHP") , *Writing a Reddit Reader with
    RxPHP*, in the section called *A closer look at Operator chains* and *A closer
    look on subscribing to Observables*:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在查看实际输出之前，试着猜测会发生什么，并记住我们在 [第 03 章](part0033_split_000.html#VF2I2-bd355a22cf10407cb10df27e65585b8d
    "第 3 章。使用 RxPHP 编写 Reddit 阅读器")，*使用 RxPHP 编写 Reddit 阅读器*，在名为 *操作符链的深入探讨* 和 *观察者订阅的深入探讨*
    的部分中讨论的内容：
- en: '[PRE4]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: It prints only the numbers `1` and `2` three times and then ends with `onError`.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 它只打印数字 `1` 和 `2` 三次，然后以 `onError` 结束。
- en: What might be confusing at first is that common sense tells us to expect this
    code to print the numbers `1`, `2`, `4`, `5`, and `6`. Number `3` throws an exception,
    but thanks to the `retry()` operator it continues with the next value.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 起初可能会让人困惑的是，常识告诉我们预期这段代码会打印出数字 `1`、`2`、`4`、`5` 和 `6`。数字 `3` 抛出异常，但多亏了 `retry()`
    操作符，它继续下一个值。
- en: However, this is not what happens, due to the fact that `retry()` resubscribes
    to its source Observable, and emitting an `onError` signal always makes the chain
    stop propagating further values. In  [Chapter 03](part0033_split_000.html#VF2I2-bd355a22cf10407cb10df27e65585b8d
    "Chapter 3. Writing a Reddit Reader with RxPHP") , *Writing a Reddit Reader with
    RxPHP*, we saw that subscribing to an Observable triggers generation of the entire
    chain of Observables that subscribe to each other in the order they were defined.
    At the end, it subscribes to the source Observable that starts emitting values.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，情况并非如此，因为 `retry()` 重新订阅其源 Observable，并且发出 `onError` 信号总是会使链停止传播更多值。在 [第
    03 章](part0033_split_000.html#VF2I2-bd355a22cf10407cb10df27e65585b8d "第 3 章。使用
    RxPHP 编写 Reddit 阅读器")，*使用 RxPHP 编写 Reddit 阅读器* 中，我们看到了订阅一个 Observable 会触发生成整个
    Observable 链，这些 Observable 按照它们定义的顺序相互订阅。最后，它订阅了开始发出值的源 Observable。
- en: We've encountered the exact same situation here. When the `map()` operator signals `onError`,
    it's immediately resubscribed thanks to the `retry()` operator, which in turn
    resubscribes to `RangeObservable` and starts emitting values from the beginning.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里遇到了完全相同的情况。当 `map()` 操作符发出 `onError` 信号时，由于 `retry()` 操作符的存在，它会立即重新订阅，然后
    `retry()` 操作符会重新订阅到 `RangeObservable` 并从开始处开始发出值。
- en: 'This is nicely demonstrated by the following marble diagram for this operator
    (note the red and yellow marbles):'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 这通过以下操作符的宝石图得到了很好的展示（注意红色和黄色的宝石）：
- en: '![The retry() operator](img/00017.jpeg)'
  id: totrans-35
  prefs: []
  type: TYPE_IMG
  zh: '![retry() 操作符](img/00017.jpeg)'
- en: Marble diagram representing the retry() operator, from http://reactivex.io/documentation/operators/retry.html
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 表示 retry() 操作符的宝石图，来自 http://reactivex.io/documentation/operators/retry.html
- en: 'If we wanted to simulate a situation where we get numbers from 1 to 6 except
    number 3, we could make an external variable, `$count`, and increment it, instead
    of relying on values coming from `RangeObservable`. To stop emitting values, we
    can use `takeWhile()`, which calls `onCompleted` when its callable returns `false`:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想要模拟一个从 1 到 6 的数字（除了数字 3）的情况，我们可以创建一个外部变量 `$count` 并递增它，而不是依赖于来自 `RangeObservable`
    的值。为了停止发出值，我们可以使用 `takeWhile()`，当其可调用返回 `false` 时，它会调用 `onCompleted`：
- en: '[PRE5]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The output is then as we expected:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 输出结果正如我们所预期的：
- en: '[PRE6]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: CURLObservable and the retry() operator
  id: totrans-41
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: CURLObservable 和 retry() 操作符
- en: 'We can make a simple test scenario that is closer to a real world application.
    We''ll take our CURLObservable and try to repeat an HTTP request three times.
    We''ll choose any non-existing URL to be sure it fails every time to see how the
    error is propagated through the operator chain when using `retry()`:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以创建一个更接近真实世界应用的简单测试场景。我们将使用我们的 CURLObservable 并尝试重复进行三次 HTTP 请求。我们将选择任何不存在的
    URL 以确保每次都失败，以便查看在使用 `retry()` 时错误是如何通过操作符链传播的：
- en: '[PRE7]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: We've already seen the `Observable::defer()` static method in [Chapter 3](part0033_split_000.html#VF2I2-bd355a22cf10407cb10df27e65585b8d
    "Chapter 3. Writing a Reddit Reader with RxPHP"), *Writing a Reddit Reader with
    RxPHP*. We're using it here to show that the `retry()` operator causes resubscription
    to the source Observable.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经在 [第 3 章](part0033_split_000.html#VF2I2-bd355a22cf10407cb10df27e65585b8d
    "第 3 章。使用 RxPHP 编写 Reddit 读者") 中看到了 `Observable::defer()` 静态方法，*使用 RxPHP 编写 Reddit
    读者*。我们在这里使用它来显示 `retry()` 操作符会导致重新订阅到源 Observable。
- en: 'This example prints to the console the following output:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 此示例将以下输出打印到控制台：
- en: '[PRE8]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: We can see that it took three iterations before the error (in fact an exception)
    reached `DebugSubject`.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到错误（实际上是一个异常）在达到 `DebugSubject` 之前经过了三次迭代。
- en: The retryWhen() operator
  id: totrans-48
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: retryWhen() 操作符
- en: Similar to `retry()`, there's also an operator called `retryWhen()`, which in
    contrast to `retry()`, doesn't re-subscribe immediately. Operator `retryWhen()`
    takes as an argument a callable that returns another Observable. This Observable
    is then used when the `onError` signal occurs, to schedule resubscription.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 与 `retry()` 类似，还有一个名为 `retryWhen()` 的操作符，与 `retry()` 不同的是，它不会立即重新订阅。操作符 `retryWhen()`
    将一个可调用参数作为参数，该参数返回另一个 Observable。然后，当发生 `onError` 信号时，使用此 Observable 来安排重新订阅。
- en: '![The retryWhen() operator](img/00018.jpeg)'
  id: totrans-50
  prefs: []
  type: TYPE_IMG
  zh: '![retryWhen() 操作符](img/00018.jpeg)'
- en: Marble diagram representing the retryWhen() operator, from http://reactivex.io/rxjs/class/es6/Observable.js~Observable.html#instance-method-retryWhen
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 表示 retryWhen() 操作符的宝石图，来自 http://reactivex.io/rxjs/class/es6/Observable.js~Observable.html#instance-method-retryWhen
- en: CURLObservable and the retryWhen() operator
  id: totrans-52
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: CURLObservable 和 retryWhen() 操作符
- en: 'For example, we can consider our `CURLObservable` once more and imagine we
    want to repeat the failed request after a one-second delay. Since the functionality
    of `retryWhen()` is a little more complicated, we''ll start with an example:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，我们可以再次考虑我们的 `CURLObservable` 并想象我们希望在延迟一秒后重复失败的请求。由于 `retryWhen()` 的功能稍微复杂一些，我们将从一个示例开始：
- en: '[PRE9]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Note
  id: totrans-55
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: We need to use an event loop to schedule the `delay()` operator.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要使用事件循环来安排 `delay()` 操作符。
- en: 'The callable to `retryWhen()` takes an Observable as an argument and has to
    return an Observable. Then, when an error signal occurs, it''s pushed to `$errObs`
    as `onNext` so we can decide based on the type of error what we want to do. Depending
    on the emissions from the returned `$notificationObs` we can control what happens
    next:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 传递给 `retryWhen()` 的可调用参数是一个 Observable，并且必须返回一个 Observable。然后，当发生错误信号时，它作为 `onNext`
    推送到 `$errObs`，这样我们就可以根据错误的类型决定我们想要做什么。根据返回的 `$notificationObs` 的发射，我们可以控制接下来会发生什么：
- en: '`onNext`: When `$notificationObs` emits the `onNext` signal, the `retryWhen()`
    operator resubscribes to its source Observable. Note that the value emitted is
    not important.'
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`onNext`：当 `$notificationObs` 发出 `onNext` 信号时，`retryWhen()` 操作符会重新订阅到其源 Observable。请注意，发出的值并不重要。'
- en: '`onError`: The error is propagated further down the operator chain.'
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`onError`：错误会进一步传播到操作符链。'
- en: '`onComplete`: The `onComplete` signal is propagated further down the operator
    chain.'
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`onComplete`：`onComplete` 信号会进一步传播到操作符链。'
- en: 'What the preceding example does should be obvious. When `CURLObservable` fails
    (emits `onError`), the `retryWhen()` operator waits one second, thanks to the `delay()`
    operator, and then resubscribes, which will make CURLObservable try to download
    the URL again indefinitely. The output from this example looks like the following:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的例子所做的事情应该是显而易见的。当 `CURLObservable` 失败（发出 `onError`）时，`retryWhen()` 操作符会等待一秒钟，多亏了
    `delay()` 操作符，然后重新订阅，这将使 CURLObservable 无限期地再次尝试下载 URL。此示例的输出如下所示：
- en: '[PRE10]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Since the `retryWhen()` operator is slightly more complicated, we can have
    a look into its internals to understand why it works the way it works:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 `retryWhen()` 操作符稍微复杂一些，我们可以查看其内部结构来理解它为什么能按这种方式工作：
- en: It creates an instance of `Subject` and stores its reference in a variable called `$errors`.
    Subjects work as both Observables and observers. It needs to use Subject, because
    it's important to be able to manually trigger signals such as `onNext`, which
    is not possible with just an Observable.
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它创建了一个 `Subject` 实例并将其引用存储在一个名为 `$errors` 的变量中。Subjects 同时作为 Observables 和观察者工作。它需要使用
    Subject，因为它很重要，能够手动触发信号，如 `onNext`，而仅仅使用 Observables 是不可能的。
- en: When the operator calls its callable, it passes along the `$errors->asObservable()`
    and expects to receive an Observable, which is stored in another variable, called `$when`.
    The method `asObservable()` wraps Subject with an `AnonymousObservable`, and thus
    hides that it is, in fact, an instance of `Subject`.
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当操作符调用其可调用函数时，它会传递 `$errors->asObservable()` 并期望接收一个 Observables，该 Observables
    存储在另一个变量中，称为 `$when`。`asObservable()` 方法用 `AnonymousObservable` 包装 Subject，因此隐藏了它实际上是一个
    `Subject` 实例的事实。
- en: Then, `CallbackObserver` is subscribed to `$when`, which can later resubscribe
    to the source Observable of this operator.
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 然后，`CallbackObserver` 订阅了 `$when`，它稍后可以重新订阅此操作符的源 Observables。
- en: This means that we have the "head" and "tail" of the chain of Observables in
    variables `$errors` and `$when`, respectively.
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这意味着我们有 Observables 链的“头部”和“尾部”分别存储在变量 `$errors` 和 `$when` 中。
- en: Later on, when an `onError` signal is received, the operator calls `$errors->onNext()`,
    which sends the value through the chain of Observables. In our case, it goes through
    the `delay()` operator.
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 之后，当接收到 `onError` 信号时，操作符会调用 `$errors->onNext()`，这会将值通过 Observables 的链式传递。在我们的例子中，它通过
    `delay()` 操作符。
- en: 'If we rewrote the preceding points into an actual heavily simplified code it
    would look like the following:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们将前面的点重写为实际的、高度简化的代码，它看起来会像以下这样：
- en: '[PRE11]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: This operator doesn't care about `onNext` or `onComplete`, and passes them right
    into `$observer`. The only signal it needs to handle is `onError`, which calls `$errors->onNext()`,
    and therefore triggers the chain of Observables, eventually resulting in resubscribing
    to the source Observable inside the `$when->subscribe()` callable.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 这个操作符不关心 `onNext` 或 `onComplete`，而是直接将它们传递给 `$observer`。它需要处理的唯一信号是 `onError`，该信号会调用
    `$errors->onNext()`，从而触发 Observables 的链式调用，最终在 `$when->subscribe()` 可调用内部重新订阅源
    Observables。
- en: This technique of using an instance of `Subject` to be able to manually trigger
    signals and at the same time subscribe observers to it is very useful. We're going
    to use it in a moment, when we implement our event dispatcher.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `Subject` 实例来手动触发信号并同时订阅观察者的这种技术非常有用。我们将在实现事件分发器时使用它。
- en: CURLObservable and controlled number of retries
  id: totrans-73
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: CURLObservable 和受控的重试次数
- en: When talking about the `retry()` operator, we made a demo where we tried to
    download a URL three times and then failed. The number of retries was fixed to
    3.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 当讨论 `retry()` 操作符时，我们做了一个演示，尝试下载一个 URL 三次，然后失败。重试次数被固定为 3。
- en: 'We can create the same example with the `retryWhen()` operator while having
    more control if and when we want to retry the HTTP request. Consider the following
    example where we make three attempts to download a URL and then propagate the
    error further:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用 `retryWhen()` 操作符创建相同的示例，同时如果我们想要重试 HTTP 请求，我们可以有更多的控制。考虑以下示例，我们尝试下载一个
    URL 三次，然后进一步传播错误：
- en: '[PRE12]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: In this example, we make three attempts where each is delayed by one second
    and then re-throw the exception, which is caught by the `map()` operator and passed
    as an `onError` signal. Since `$notificationObs` sends the `onError` signal, the
    `retryWhen()` operator passes this error further as explained previously. We also
    print the string `retryWhen` to prove that the callable is called just once even
    when there're multiple retries.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们尝试了三次，每次延迟一秒然后重新抛出异常，该异常被 `map()` 操作符捕获并作为 `onError` 信号传递。由于 `$notificationObs`
    发送了 `onError` 信号，`retryWhen()` 操作符将此错误进一步传递，正如之前解释的那样。我们还打印了字符串 `retryWhen` 来证明即使有多次重试，可调用函数也只被调用一次。
- en: 'The output from this example is the following:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 这个示例的输出如下：
- en: '[PRE13]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: What's interesting about this demo is that it doesn't need to end with the error
    at all. We could use `$notificationObs` to signal `onComplete` instead.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 这个演示有趣的地方在于它根本不需要以错误结束。我们可以使用 `$notificationObs` 来发出 `onComplete` 信号。
- en: 'The inner callable could look, for example, like the following code:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 内部可调用函数可能看起来像以下代码：
- en: '[PRE14]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'In contrast to the previous example we''re not re-throwing the exception, and
    just emitting `onComplete` instead:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 与前一个示例相比，我们不是重新抛出异常，而是只发出 `onComplete`：
- en: '[PRE15]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: This might be useful in situations where even multiple failed retries don't
    necessarily mean an error state.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能在即使多次失败重试也不一定意味着错误状态的情况下很有用。
- en: The catchError() operator
  id: totrans-86
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: catchError() 操作符
- en: The operator `catchError()` also handles only error signals. When it receives
    an `onError`, it calls a callable that returns an Observable, which is then used
    to continue the Observable sequence instead of the source Observable.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 操作符 `catchError()` 也只处理错误信号。当它收到一个 `onError` 时，它会调用一个返回 Observable 的可调用函数，然后使用该
    Observable 来继续 Observable 序列，而不是源 Observable。
- en: 'Consider the following example:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下示例：
- en: '[PRE16]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'In this example, the `onError` signal is captured by `catchError()` and, instead
    of ending the entire Observable sequence, it continues with a single value, thanks
    to `Observable::just()`, and then ends with `onComplete`:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，`onError` 信号被 `catchError()` 捕获，并且由于 `Observable::just()`，它继续以单个值结束整个
    Observable 序列，然后以 `onComplete` 结束：
- en: '[PRE17]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The concat() and merge() operators
  id: totrans-92
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: concat() 和 merge() 操作符
- en: With `retry()` and `retryWhen()` we've stumbled upon operators that take as
    parameters other Observables and work with their emissions. Combining multiple
    Observables into a single chain is a common practice mostly in RxJS due to the
    asynchronous nature of JavaScript by design. In RxPHP we don't use them as often,
    but it's worth having a quick look at them.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `retry()` 和 `retryWhen()`，我们遇到了一些接受其他 Observables 作为参数并处理它们的发射的算子。将多个 Observables
    合并成一个单一的链是 RxJS 中的常见做法，这主要是由于 JavaScript 设计上的异步性质。在 RxPHP 中，我们并不经常使用它们，但快速看一下它们是值得的。
- en: The merge() operator
  id: totrans-94
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: merge() 操作符
- en: In order to merge two Observables into a single one that emits all values from
    both of them (including `onError` signals) we can use the `merge()` operator.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 为了将两个 Observables 合并成一个单一的 Observable，该 Observable 发射来自它们的所有值（包括 `onError` 信号），我们可以使用
    `merge()` 操作符。
- en: '![The merge() operator](img/00019.jpeg)'
  id: totrans-96
  prefs: []
  type: TYPE_IMG
  zh: '![merge() 操作符](img/00019.jpeg)'
- en: Marble diagram representing the merge() operator, from http://reactivex.io/rxjs/class/es6/Observable.js~Observable.html#static-method-merge
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 来自 http://reactivex.io/rxjs/class/es6/Observable.js~Observable.html#static-method-merge
    的 merge() 操作符的宝石图
- en: As we can see from the marble diagram, this operator reemits values from source
    and the merged Observables. This means it subscribes to both of them and emits
    values as they arrive.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们从宝石图中可以看到，这个操作符重新发射来自源和合并的 Observables 的值。这意味着它订阅了它们两个，并且随着它们的到达而发射值。
- en: 'To better understand how it works, we can make a simple example with two interval
    Observables where each emits three values with different delays:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更好地理解它是如何工作的，我们可以用一个简单的示例来演示，其中包含两个间隔 Observables，每个间隔以不同的延迟发射三个值：
- en: '[PRE18]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The `$merge` Observable emits its values faster than `$source`. We also prefix
    each value to mark where it came from so the output from this example is the following:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '`$merge` Observable 发射其值的速度比 `$source` 快。我们还为每个值添加前缀以标记其来源，所以这个示例的输出如下：'
- en: '[PRE19]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: We can see that the values are mixed together. However, there's only one `onComplete`
    signal when both Observables complete, so overall it behaves like a single Observable.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到值被混合在一起。然而，当两个 Observables 都完成时，只有一个 `onComplete` 信号，所以整体上它表现得像一个单一的 Observable。
- en: The concat() operator
  id: totrans-104
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: concat() 操作符
- en: 'In contrast to `merge()` sometimes we might want to combine two Observables
    but first emit all values from the first Observable and, when it completes, subscribe
    to the second one and emit all values from that as well. For this reason, there''s
    also the `concat()` operator:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 与`merge()`相反，有时我们可能想要合并两个Observable，但首先发出第一个Observable的所有值，当它完成时，订阅第二个Observable并发出其所有值。因此，也存在`concat()`操作符：
- en: '![The concat() operator](img/00020.jpeg)'
  id: totrans-106
  prefs: []
  type: TYPE_IMG
  zh: '![concat()操作符](img/00020.jpeg)'
- en: Marble diagram representing the concat() operator, from http://reactivex.io/rxjs/class/es6/Observable.js~Observable.html#instance-method-concat
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 表示concat()操作符的宝石图，来自http://reactivex.io/rxjs/class/es6/Observable.js~Observable.html#instance-method-concat
- en: 'We can take the same example as we made for `merge()` and just switch the `merge()`
    operator to `concat()`:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以拿与`merge()`相同的例子，只需将`merge()`操作符切换为`concat()`：
- en: '[PRE20]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Since `concat()` should subscribe to the source and concatenated Observables
    one after another we should expect to receive first all values from the source
    Observable and, when it completes, all values from `$concat` Observable.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`concat()`应该订阅源Observable并依次连接其他Observable，因此我们预期首先接收到源Observable的所有值，当它完成时，再接收到`$concat`
    Observable的所有值。
- en: '[PRE21]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Even though the concatenated Observable emits values faster than the source
    Observable, its values follow after all the values from source.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 即使连接的Observable比源Observable更快地发出值，但其值仍然跟在源Observable的所有值之后。
- en: The concatMap() and flatMap() operators
  id: totrans-113
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: concatMap()和flatMap()操作符
- en: Both the `merge()` and `concat()` operators have their `*map()` variants. In
    particular these are `flatMap()` and `concatMap()`. These operators combine the
    functionality of `merge()`/`concat()` with the `map()` operator. If we look at
    both examples we made a moment ago, we'll see that we need to know the inner Observable
    beforehand. This means the inner Observable is passed to `concat()`/`merge()`
    once when creating the Observable chain.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '`merge()`和`concat()`操作符都有它们的`*map()`变体。特别是这些是`flatMap()`和`concatMap()`。这些操作符结合了`merge()`/`concat()`和`map()`操作符的功能。如果我们看看我们刚才做的两个例子，我们会看到我们需要事先知道内部Observable。这意味着内部Observable在创建Observable链时被传递给`concat()`/`merge()`一次。'
- en: We'll pick one of the two operators and explain its benefits in an example.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将选择两个操作符中的一个，并通过一个示例来解释其优点。
- en: 'Let''s imagine we want to make three HTTP requests one after another. This
    looks like an ideal use case for the `concat()` operator. However, each request
    is going to be dependent on the result from the previous one, so we need to use
    `concatMap()` instead because its callable takes the current value from the source
    Observable as a parameter and returns an Observable that''ll be concatenated to
    the chain:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们假设我们想要依次进行三个HTTP请求。这看起来像是`concat()`操作符的理想用例。然而，每个请求都将依赖于前一个请求的结果，因此我们需要使用`concatMap()`，因为它的可调用参数是源Observable的当前值，并返回一个将被连接到链中的Observable：
- en: '[PRE22]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: We're using the [http://httpbin.org/get](http://httpbin.org/get) web service
    that serves as a test server and returns the request we sent as a JSON string.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 我们正在使用[http://httpbin.org/get](http://httpbin.org/get)网络服务，它作为测试服务器，并将我们发送的请求作为JSON字符串返回。
- en: We used `Observable::emptyObservable()` to create an empty Observable that completes
    immediately, and chain it with one `concat()` and two `concatMap()` operators.
    Each `concatMap()` then decodes the JSON from the previous requests, takes its
    `num` parameter multiplied by 2 and resends the HTTP request.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`Observable::emptyObservable()`创建一个立即完成的空Observable，并将其与一个`concat()`和两个`concatMap()`操作符连接起来。然后，每个`concatMap()`解码前一个请求的JSON，将其`num`参数乘以2，并重新发送HTTP请求。
- en: 'Then, from the console output, we can see the requests are called in order
    and the random `num` parameter created in the `concat()` operator call is multiplied
    by 2 with every request:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，从控制台输出中，我们可以看到请求是按顺序调用的，并且在`concat()`操作符调用中创建的随机`num`参数在每次请求中都会乘以2：
- en: '[PRE23]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: With `flatMap()` the example would be the same. However, since PHP isn't asynchronous
    like JavaScript, `flatMap()` operator isn't as useful in this particular use case.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`flatMap()`，例子将是相同的。然而，由于PHP不像JavaScript那样是异步的，`flatMap()`操作符在这个特定用例中并不那么有用。
- en: We'll have a look at more operators that combine multiple Observables in [Chapter
    6](part0050_split_000.html#1FLS41-bd355a22cf10407cb10df27e65585b8d "Chapter 6. PHP
    Streams API and Higher-Order Observables"), *PHP Streams API and Higher-Order
    Observables*.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在[第6章](part0050_split_000.html#1FLS41-bd355a22cf10407cb10df27e65585b8d "第6章。PHP
    Streams API和Higher-Order Observables")中查看更多结合多个Observables的操作符，*PHP Streams API和Higher-Order
    Observables*。
- en: Writing a reactive event dispatcher
  id: totrans-124
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编写响应式事件派发器
- en: The Symfony `EventDispatcher` component is a PHP library for exchanging messages
    between objects. It's based on the Mediator design pattern ( [https://en.wikipedia.org/wiki/Mediator_pattern](https://en.wikipedia.org/wiki/Mediator_pattern)
    ), and its implementation is relatively simple.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: Symfony的`EventDispatcher`组件是一个用于在对象之间交换消息的PHP库。它基于中介者设计模式（[https://en.wikipedia.org/wiki/Mediator_pattern](https://en.wikipedia.org/wiki/Mediator_pattern)），其实现相对简单。
- en: A very common scenario is when we have an application that we want to make extendable
    via plugins. In this case, we'd create a single instance of `EventDispatcher`
    and let plugins listen to various events. Each event is an object that can hold
    references to other objects as well. This is what the Symfony3 framework does
    extensively.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 一个非常常见的场景是我们有一个想要通过插件扩展的应用程序。在这种情况下，我们会创建一个`EventDispatcher`的单例实例，并让插件监听各种事件。每个事件都是一个对象，它可以持有对其他对象的引用。这正是Symfony3框架所广泛使用的。
- en: A quick introduction to EventDispatcher
  id: totrans-127
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 事件派发器快速入门
- en: 'If you haven''t done so already, install the Event Dispatcher component via
    `composer`:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你还没有这样做，请通过`composer`安装事件派发器组件：
- en: '[PRE24]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: First, we're going to have a look at how the default implementation is used
    in practice, so we can later compare it to our reactive implementation, and check
    that both work the same from a developer's perspective while the internal implementation
    is different.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将查看默认实现的实际使用方法，这样我们就可以稍后将其与我们的响应式实现进行比较，并检查从开发者的角度来看，两者是否都能正常工作，尽管内部实现不同。
- en: Working with event listeners
  id: totrans-131
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 与事件监听器一起工作
- en: 'In the most basic situation, we just want to set up a couple of listeners and
    dispatch events:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 在最基本的情况下，我们只想设置几个监听器并派发事件：
- en: '[PRE25]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: We created three event listeners to two different events, `my_action` and `other_action`.
    Then, with `$dispatcher->dispatch()`, we tell the event dispatcher to notify all
    event listeners that the event called `my_action` occurred.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 我们为两个不同的事件`my_action`和`other_action`创建了三个事件监听器。然后，通过`$dispatcher->dispatch()`，我们告诉事件派发器通知所有事件监听器，事件`my_action`已经发生。
- en: 'The output in the console should be obvious:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 控制台中的输出应该是明显的：
- en: '[PRE26]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: The `dispatch()` method takes an optional second argument with an instance of
    `Event` class that can contain further information about the event. Event listeners
    can also modify event data if necessary. Also, all callables receive exactly one
    argument with the event object, which comes from the initial call to the `dispatch()`
    method. Since we didn't provide any event object, our callables don't need to
    accept any parameter.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: '`dispatch()`方法接受一个可选的第二个参数，该参数是一个`Event`类的实例，它可以包含有关事件的更多信息。如果需要，事件监听器也可以修改事件数据。此外，所有可调用对象都恰好接受一个事件对象作为参数，该参数来自对`dispatch()`方法的初始调用。由于我们没有提供任何事件对象，我们的可调用对象不需要接受任何参数。'
- en: 'Note that the event dispatcher doesn''t need to know what events it supports,
    as they are created on the fly. This also means you can accidentally try to dispatch
    a non-existent event:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，事件派发器不需要知道它支持哪些事件，因为它们是即时创建的。这也意味着你可能会意外地尝试派发一个不存在的事件：
- en: '[PRE27]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: This won't throw an error, but no event will be dispatched.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 这不会引发错误，但不会派发任何事件。
- en: 'The `EventDispatcher` class supports two important features:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: '`EventDispatcher`类支持两个重要的特性：'
- en: '**Priority**: By default, listeners are executed in the order they subscribe
    to the event dispatcher. We can alter this behavior by supplying a third argument
    to the `addListener()` method with priority for this particular listener (it''s
    0 by default). Listeners with higher priority are executed first. If more listeners
    have the same priority, then the order they were added matters.'
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**优先级**：默认情况下，监听器按照它们订阅事件派发器的顺序执行。我们可以通过向`addListener()`方法提供一个带有特定监听器优先级的第三个参数来改变这种行为（默认为0）。优先级较高的监听器会先执行。如果多个监听器具有相同的优先级，那么它们的添加顺序就很重要了。'
- en: '**Stopping event propagation**: In some scenarios, it''s important to be able
    to stop propagating a particular event to subsequent listeners. For this reason,
    the `Event` class has a method called `stopPropagation()`. The event dispatcher
    is then responsible for not propagating this event further.'
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**停止事件传播**：在某些场景中，能够停止将特定事件传播给后续监听器是很重要的。因此，`Event`类有一个名为`stopPropagation()`的方法。然后事件派发器负责不再传播此事件。'
- en: 'These two features can be used in a situation such as the following:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个特性可以用于以下情况：
- en: '[PRE28]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: The first event listener should be called after the second one because it has
    higher priority, but it stops further propagation of this event using `$event->stopPropagation()`,
    so it's never invoked.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个事件监听器应该在第二个监听器之后被调用，因为它具有更高的优先级，但它使用 `$event->stopPropagation()` 停止进一步传播此事件，所以它永远不会被调用。
- en: 'The console output is then very short:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 控制台输出非常简短：
- en: '[PRE29]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Working with event subscribers
  id: totrans-149
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 与事件订阅者一起工作
- en: While `addListener()` subscribes to a single event listener, there's also the `addSubscriber()`
    method, which accepts an instance of a class implementing  `EventSubscriberInterface`
    and subscribes to multiple events at once. In fact, `addSubscriber()` uses `addListener()`
    internally to add listeners. Sometimes it's just easier to wrap all listeners
    into a single class than add them one by one.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然 `addListener()` 订阅单个事件监听器，但还有一个 `addSubscriber()` 方法，它接受一个实现 `EventSubscriberInterface`
    的类的实例，并一次性订阅多个事件。实际上，`addSubscriber()` 使用 `addListener()` 内部添加监听器。有时将所有监听器包装到一个类中比逐个添加它们要简单得多。
- en: Throughout this and upcoming examples in this chapter, we're also going to use
    a custom `Event` class in order to properly test that both the default and our
    reactive implementations work the same.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的整个内容和即将到来的示例中，我们还将使用一个自定义的 `Event` 类，以便正确测试默认和我们的响应式实现是否工作相同。
- en: 'First, let''s declare our event class:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们声明我们的事件类：
- en: '[PRE30]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: It's a pretty simple class. We'll use the `inc()` method to see that all the
    listeners work with the same instance of `MyEvent`. We also use the `__toString()`
    magic method so we can convert this class to string just by typecasting it.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个相当简单的类。我们将使用 `inc()` 方法来验证所有监听器都使用相同的 `MyEvent` 实例。我们还使用了 `__toString()`
    魔法方法，这样我们就可以通过类型转换将这个类转换为字符串。
- en: 'Now, for demonstration purposes, we''ll declare a `MyEventSubscriber` class
    with three event listeners:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，为了演示目的，我们将声明一个具有三个事件监听器的 `MyEventSubscriber` 类：
- en: '[PRE31]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: The interface `EventSubscriberInterface` requires only the static method `getSubscribedEvents()`,
    which returns an associative array of event names and their appropriate callables.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: '`EventSubscriberInterface` 接口只需要一个静态方法 `getSubscribedEvents()`，它返回一个包含事件名称及其相应可调用对象的关联数组。'
- en: This example class declares two listeners for the `my_action` event (where the
    second one has higher priority than the first) and one listener for the `other_action`
    event.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 这个示例类声明了两个监听器用于 `my_action` 事件（第二个监听器的优先级高于第一个）和一个监听器用于 `other_action` 事件。
- en: 'Subscribing to this class works the same way as subscribing to listeners:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 订阅到这个类的方式与订阅监听器的方式相同：
- en: '[PRE32]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'This time, the example also prints a string representation of the event:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 这次，示例还打印了事件的字符串表示：
- en: '[PRE33]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: This is yet another thing we need to handle, because we want to allow defining
    event Observables in an event subscriber class.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们需要处理的另一件事，因为我们希望允许在事件订阅者类中定义事件观察者。
- en: Now we know how the default `EventDispatcher` class can be used and what use
    cases it's supposed to fulfill. Our goal will be to write our own implementation
    based on RxPHP and reactive programming.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们知道了默认的 `EventDispatcher` 类如何使用以及它应该满足哪些用例。我们的目标将是基于 RxPHP 和响应式编程编写我们自己的实现。
- en: Writing ReactiveEventDispatcher with RxPHP
  id: totrans-165
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 RxPHP 编写 ReactiveEventDispatcher
- en: Event dispatchers need to implement an `EventDispatcherInterface` interface
    that defines all the methods we've seen previously, and we'll also add a few more.
    Luckily for us, we can reuse a large part of the default `EventDispatcher` class.
    For example, the `removeListener()` or `removeSubscriber()` methods will work
    without any modification.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 事件调度器需要实现一个 `EventDispatcherInterface` 接口，该接口定义了我们之前看到的所有方法，我们还将添加一些更多。幸运的是，我们可以重用默认
    `EventDispatcher` 类的大部分内容。例如，`removeListener()` 或 `removeSubscriber()` 方法将无需任何修改即可工作。
- en: Internal representation of event listeners as observers
  id: totrans-167
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 事件监听器作为观察者的内部表示
- en: 'The original `EventDispatcher` had a very easy task. On the `dispatch()` call,
    it just sorted the array of listeners for that particular event by their priority
    and evaluated them one by one, in a loop:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 原始的 `EventDispatcher` 有一个非常简单的任务。在 `dispatch()` 调用中，它只是根据优先级对特定事件的监听器数组进行排序，并逐个评估它们，在一个循环中：
- en: '[PRE34]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: In our case, we're going to represent all event listeners as observers. In fact,
    when we add a new event listener, we'll transform its callable into an observer.
    Then, when calling `dispatch()`, we'll create a chain of Observables where all
    observers are already subscribed at specific points. Of course, we also need to
    handle the  `isPropagationStopped()` condition by ourselves.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的例子中，我们将所有事件监听器表示为观察者。实际上，当我们添加一个新的事件监听器时，我们会将其可调用对象转换为观察者。然后，在调用 `dispatch()`
    时，我们将创建一个包含所有观察者的可观察对象链，这些观察者已经订阅在特定的点上。当然，我们还需要自己处理 `isPropagationStopped()`
    条件。
- en: 'For example, let''s consider the simplest usage of the event dispatcher, as
    shown previously:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，让我们考虑事件分发器的最简单用法，如之前所示：
- en: '[PRE35]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'We have to turn these two event listeners into a chain of Observables while
    making sure that, before each event listener is executed, we check that the event
    object hasn''t got the stop propagation flag set:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 我们必须将这些两个事件监听器转换成一个可观察对象链，同时确保在执行每个事件监听器之前，检查事件对象是否设置了停止传播标志：
- en: '[PRE36]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'We''re using Subject here for the same reason as we explained earlier in the
    chapter when we talked about the `retryWhen()` operator. Still, let''s explain
    this code in more detail:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里使用 Subject 的原因与我们在本章前面解释 `retryWhen()` 操作符时相同。不过，让我们更详细地解释这段代码：
- en: The `$subject` variable holds a reference to the "head" of the chain of Observables
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`$subject` 变量持有对 "链头" 的可观察对象链的引用'
- en: The `$tail` variable always holds a reference to the last Observable in the
    chain. This is where we further chain more Observables, and where we append the `filter()`
    operator that checks for stopped events.
  id: totrans-177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`$tail` 变量始终持有对链中最后一个可观察对象的引用。这是我们进一步链式连接更多可观察对象的地方，也是我们附加 `filter()` 操作符以检查停止事件的地方。'
- en: When we want to dispatch an event, we just need to call `$subject->onNext()`.
  id: totrans-178
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当我们想要分发一个事件时，我们只需调用 `$subject->onNext()`。
- en: 'To be extra clear what the current chain of Observables looks like, we can
    represent it as a tree structure:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更清楚地表示当前的可观察对象链，我们可以将其表示为一个树结构：
- en: '![Internal representation of event listeners as observers](img/00021.jpeg)'
  id: totrans-180
  prefs: []
  type: TYPE_IMG
  zh: '![事件监听器作为观察者的内部表示](img/00021.jpeg)'
- en: Now we just need to turn all this into a real PHP class.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们只需要将这些内容转换成一个真正的 PHP 类。
- en: Writing a ReactiveEventDispatcher class
  id: totrans-182
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编写 ReactiveEventDispatcher 类
- en: The good thing is that we can actually reuse a lot of the logic already written
    in `EventDispatcher` and just overload certain methods that need to work differently.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 好事是，我们可以实际重用 `EventDispatcher` 中已经编写的大量逻辑，只需覆盖需要以不同方式工作的某些方法。
- en: 'First, we''ll just write a class stub to see what''s waiting ahead of us, and
    talk a little about each method:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将简单地写一个类占位符来看看前方等待着我们的是什么，并对每个方法进行简要说明：
- en: '[PRE37]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Only the methods `dispatch()`, `addListener()`, and `addSubscriber()` from `EventDispatcher`
    need to be overwritten; the rest can remain as they are. We also added three more
    methods to help us deal with Observables.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 只有 `EventDispatcher` 中的 `dispatch()`、`addListener()` 和 `addSubscriber()` 方法需要重写；其余的可以保持原样。我们还添加了三个额外的方法来帮助我们处理可观察对象。
- en: 'Let''s see what the purpose of each component is:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看每个组件的作用：
- en: '`$subjects`: An associative array that holds references to all heads of Observable
    chains (their Subjects).'
  id: totrans-188
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`$subjects`: 一个关联数组，持有对所有可观察对象链头（它们的主题）的引用。'
- en: '`addListener()`: We already know this method from previous examples. However,
    now the method also accepts observers as event listeners.'
  id: totrans-189
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`addListener()`: 我们已经从之前的例子中知道了这个方法。然而，现在这个方法也接受观察者作为事件监听器。'
- en: '`addObservable()`: This is a method that lets us append an Observable to a
    specific point in the chain of Observables generated by `getSubject()`.'
  id: totrans-190
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`addObservable()`: 这是一个方法，允许我们将一个可观察对象追加到由 `getSubject()` 生成的可观察对象链的特定点上。'
- en: '`addSubscriber()`: This subscribes to multiple events with the subscription
    class. It uses the `addObserver()` method.'
  id: totrans-191
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`addSubscriber()`: 这个方法使用订阅类订阅多个事件。它使用 `addObserver()` 方法。'
- en: '`dispatch()`: This method takes the instance of `Subject` for this particular
    event and calls `onNext()`, with the event object as a parameter.'
  id: totrans-192
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`dispatch()`: 这个方法接受特定事件的 `Subject` 实例，并使用事件对象作为参数调用 `onNext()`。'
- en: '`observerFromListener()`: A helper method that transforms any listener into
    an observer. Basically, this just wraps every callable with a `CallbackObserver`
    object.'
  id: totrans-193
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`observerFromListener()`: 一个辅助方法，将任何监听器转换为观察者。基本上，这只是在每个可调用对象上包装一个 `CallbackObserver`
    对象。'
- en: '`getSubject()`: Our event dispatcher is going to work with Subjects. This method
    internally sorts an array of listeners by their priority and constructs a chain
    of Observables from them. It''ll also keep Subjects in the `$subjects` associative
    array, to be easily reused without necessarily creating the Observable chain all
    over again on every `dispatch()` call.'
  id: totrans-194
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`getSubject()`：我们的事件调度器将使用Subjects。这个方法内部按优先级对监听器数组进行排序，并从它们构建一个Observables链。它还会在`$subjects`关联数组中保留Subjects，以便可以轻松重用，而无需在每次`dispatch()`调用时重新创建Observable链。'
- en: So, we have a pretty good picture of how this event dispatcher is going to work,
    and we can start implementing each method.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们对这个事件调度器的工作方式有了相当清晰的了解，我们可以开始实现每个方法。
- en: Adding event listeners
  id: totrans-196
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 添加事件监听器
- en: 'The first two methods are going to be `addListener()` and `observerFromListener()`.
    The first one is dependent on the second one, so we''ll write both of them at
    the same time:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 前两个方法将是`addListener()`和`observerFromListener()`。第一个方法依赖于第二个，所以我们将同时编写这两个方法：
- en: '[PRE38]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Note
  id: totrans-199
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: In the rest of the examples in this chapter, we're also going to include doc
    blocks and type hints for each method to clarify what arguments it accepts.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的其余示例中，我们还将包括每个方法的doc blocks和类型提示，以明确它接受的参数。
- en: The `observerFromListener()` method checks the runtime type of `$listener` and
    always turns it into an instance of observer.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: '`observerFromListener()`方法检查`$listener`的运行时类型，并将其始终转换为观察者实例。'
- en: The method `addListener()` uses `observerFromListener()` internally, and then
    calls its parent's `addListener()` with the observer as an argument, even though
    it originally accepted only callables. The parent method stores the listener in
    a nested associative array by event name and priority. Since the parent's code
    is pretty universal, we don't need to make any changes to it and will leave it
    as is.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: '`addListener()`方法内部使用`observerFromListener()`，然后以观察者的形式调用其父`addListener()`，尽管它最初只接受可调用对象。父方法通过事件名称和优先级将监听器存储在一个嵌套的关联数组中。由于父代码相当通用，我们不需要对其进行任何修改，因此我们将保持原样。'
- en: Note that, after we call the parent `addListener()`, we remove a Subject from
    the `$subjects` array for this particular event. This is because we modified the
    Observable chain for this event and it needs to be created from scratch. This
    happens later, when calling the `dispatch()` method.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，在我们调用父`addListener()`之后，我们将一个Subject从特定的`$subjects`数组中移除。这是因为我们修改了这个事件的Observable链，它需要从头开始创建。这发生在稍后调用`dispatch()`方法时。
- en: Adding Observables
  id: totrans-204
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 添加Observables
- en: 'Speaking of listeners, we can now also implement `addObservable()`, which is
    a slightly modified version of `addListener()`. This method is going to be used
    differently than `addListener()`, so it deserves special attention:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 说到监听器，我们现在也可以实现`addObservable()`，这是`addListener()`的一个稍微修改过的版本。这个方法将不同于`addListener()`的使用方式，因此它值得特别注意：
- en: '[PRE39]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: We create an instance of `Subject` and call `asObservable()` to let the user-defined
    callable append its operators to it. Then we call `addListener()` with the `$subject` variable
    that we explained a moment ago. Again, this is the same technique we described
    with the `retryWhen()` operator.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建了一个`Subject`实例并调用`asObservable()`，以便用户定义的可调用对象将其操作符附加到它上。然后我们使用之前解释过的`$subject`变量调用`addListener()`。这同样是我们之前用`retryWhen()`操作符描述过的相同技术。
- en: 'This method is interesting, because it lets us add a "sub-chain" of Observables
    as a listener. Consider the following code:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 这个方法很有趣，因为它允许我们添加一个“子链”的Observables作为监听器。考虑以下代码：
- en: '[PRE40]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'If we represent this code as a tree structure as we did before, inside the
    `$dispatcher`, it will look like the following (this structure is generated later
    inside the `getSubject()` method):'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们像之前那样将这段代码表示为一个树状结构，在`$dispatcher`内部，它将看起来如下（这个结构是在`getSubject()`方法中稍后生成的）：
- en: '![Adding Observables](img/00022.jpeg)'
  id: totrans-211
  prefs: []
  type: TYPE_IMG
  zh: '![添加Observables](img/00022.jpeg)'
- en: Event "my_action" with two event listeners
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 事件“my_action”有两个事件监听器
- en: So, this event listener appends a series of operators in its callable and then
    subscribes to it. In the `addObservable()` method, we pass only the `$subject`
    itself to the `addListener()`, which is later appended to the `filter()` operator,
    when calling `dispatch()`. This works thanks to the fact that Subjects work as
    observers as well and can subscribe to Observables.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，这个事件监听器在其可调用对象中附加了一系列操作符，然后订阅它。在`addObservable()`方法中，我们只传递`$subject`本身到`addListener()`，当调用`dispatch()`时，它将被附加到`filter()`操作符上。这要归功于Subjects同时作为观察者工作并可以订阅Observables的事实。
- en: This is the major benefit of writing our custom `ReactiveEventDispatcher`. We're
    using reactive programming to easily manipulate events that interest us in a very
    straightforward way. If we used the default event dispatcher, we'd have to put
    all the listener-specific conditions inside the callable.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是编写我们自定义的 `ReactiveEventDispatcher` 的主要好处。我们使用响应式编程以非常直接的方式轻松地操作我们感兴趣的事件。如果我们使用默认的事件派发器，我们就必须在可调用的内部放置所有与监听器相关的特定条件。
- en: Adding event subscribers
  id: totrans-215
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 添加事件订阅者
- en: Similar to the original `EventDispatcher`, we want to be able to subscribe multiple
    listeners to multiple events at once, using a subscriber class. However, we're
    also going to support adding listeners as Observables, just like we did with `addObservable()`.
    This is not going to work without overloading the parent's `addSubscriber()` method
    and handling Observables in a special way.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 与原始的 `EventDispatcher` 类似，我们希望能够一次订阅多个监听器到多个事件，使用一个订阅者类。然而，我们还将支持将监听器作为可观察的添加，就像我们在
    `addObservable()` 中做的那样。如果没有重载父类的 `addSubscriber()` 方法并以特殊方式处理可观察的，这是无法实现的。
- en: 'Basically, we need to call `addObservable()` instead of the `addListener()`
    method:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 基本上，我们需要调用 `addObservable()` 而不是 `addListener()` 方法：
- en: 'First, let''s define an interface that we can use to recognize an event subscriber
    class that also defines Observables as listeners:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们定义一个接口，我们可以用它来识别一个同时定义了可观察作为监听器的事件订阅者类：
- en: '[PRE41]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Now, `addSubscriber()` can check whether the class is an instance of this interface
    and, if it is, process all its listeners as if they were Observables:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，`addSubscriber()` 可以检查类是否是这个接口的实例，如果是，就将其所有监听器处理成好像它们都是可观察的：
- en: '[PRE42]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: The array of event listeners can be defined as an array, with a key as the event
    name and its value as a callable. However, our implementation also supports using
    array values as another array defining the callable and priority (that's the second
    nested `foreach` loop).
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 事件监听器的数组可以定义为一个键为事件名称，值为可调用的数组。然而，我们的实现也支持使用数组值作为另一个数组，定义可调用和优先级（这就是第二个嵌套的 `foreach`
    循环）。
- en: At the beginning of this method, we also call its parent because we want to
    allow the default functionality as well.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个方法的开头，我们也调用了其父类，因为我们想允许默认的功能。
- en: 'For demonstration purposes, we''re going to extend the `MyEventSubscriber`
    class we defined earlier and implement the `getSubscribedEventsObservables()`
    method, which is going to return two event listeners:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 为了演示目的，我们将扩展我们之前定义的 `MyEventSubscriber` 类，并实现 `getSubscribedEventsObservables()`
    方法，该方法将返回两个事件监听器：
- en: '[PRE43]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: We defined three event listeners for two different events, where the first one
    for `my_action` event has priority `10` and the second the default, `0`.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 我们为两个不同的事件定义了三个事件监听器，其中第一个 `my_action` 事件的优先级为 `10`，第二个为默认的 `0`。
- en: Creating the Observable chain for an event
  id: totrans-227
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 为事件创建可观察链
- en: 'The method `getSubject()` is the place where Observable chains are being generated.
    This method is then called only when dispatching an event:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: '`getSubject()` 方法是生成可观察链的地方。这个方法仅在派发事件时被调用：'
- en: '[PRE44]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: If the Subject for this event doesn't exist, we create a new one and then call
    `getListeners()`. This method is defined in the parent `EventDispatcher` class
    and returns a sorted array of listeners (or observers, in our case). Then we iterate
    the array and add a `filter()` operator followed by subscribing the observer or
    Subject, depending on whether we used `addListener()` or `addObservable()`.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 如果这个事件的 Subject 不存在，我们创建一个新的，然后调用 `getListeners()`。这个方法定义在父类 `EventDispatcher`
    中，并返回一个按顺序排列的监听器（或观察者，在我们的例子中）数组。然后我们遍历这个数组，添加一个 `filter()` 操作符，然后根据我们是否使用了 `addListener()`
    或 `addObservable()` 来订阅观察者或 Subject。
- en: Note
  id: totrans-231
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Note that operators (such as `filter()`, in this example) always return a new
    Observable, while calling `subscribe()` returns a disposable object.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，操作符（如本例中的 `filter()`）总是返回一个新的可观察对象，而调用 `subscribe()` 则返回一个可丢弃的对象。
- en: We don't need to create the `$subject` every time we call this method, because
    it doesn't change until we add new listeners, so we can keep a reference to it
    in the `$subjects` array.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不需要每次调用这个方法时都创建 `$subject`，因为它在我们添加新的监听器之前不会改变，所以我们可以将其引用保存在 `$subjects` 数组中。
- en: Comparing filter() to takeWhile()
  id: totrans-234
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 比较 filter() 和 takeWhile()
- en: In the previous [Chapter 3](part0033_split_000.html#VF2I2-bd355a22cf10407cb10df27e65585b8d
    "Chapter 3. Writing a Reddit Reader with RxPHP"), *Writing a Reddit Reader with
    RxPHP*, we mentioned an operator that might work well instead of `filter()`. We
    used `takeWhile()`, which also takes a predicate callable as a parameter and can
    stop propagating values down the Observable chain.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的[第3章](part0033_split_000.html#VF2I2-bd355a22cf10407cb10df27e65585b8d "第3章。使用RxPHP编写Reddit阅读器")*使用RxPHP编写Reddit阅读器*中，我们提到了一个可能比`filter()`更好的操作符。我们使用了`takeWhile()`，它也接受一个谓词可调用参数，并且可以在Observable链中停止传播值。
- en: The important distinction is that the `filter()` operator decides whether or
    not it internally calls `onNext()` on its associated observer. On the other hand, 
    `takeWhile()` decides whether or not it calls `onComplete()`. Calling `onComplete()`
    would lead to invoking disposables, which would unsubscribe the observers, and
    this is definitely not what we want. If we did unsubscribe, we'd have to create
    the Subject for each event on every `dispatch()` call.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的区别是`filter()`操作符决定是否在其关联的观察者上内部调用`onNext()`。另一方面，`takeWhile()`决定是否调用`onComplete()`。调用`onComplete()`会导致调用可丢弃对象，这将取消订阅观察者，这绝对不是我们想要的。如果我们取消订阅，我们就必须在每次`dispatch()`调用时为每个事件创建Subject。
- en: Note
  id: totrans-237
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: In [Chapter 8](part0061_split_000.html#1Q5IA1-bd355a22cf10407cb10df27e65585b8d
    "Chapter 8. Multicasting in RxPHP and PHP7 pthreads Extension"), *Multicasting
    in RxPHP and PHP7 pthreads Extension*, we'll talk more about what unexpected consequences
    calling `onComplete` on a `Subject` might have.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第8章](part0061_split_000.html#1Q5IA1-bd355a22cf10407cb10df27e65585b8d "第8章。RxPHP和PHP7
    pthreads扩展中的多播")*RxPHP和PHP7 pthreads扩展中的多播*中，我们将更详细地讨论在`Subject`上调用`onComplete`可能产生的意外后果。
- en: Dispatching events
  id: totrans-239
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 分发事件
- en: 'Finally, dispatching events is very simple:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，分发事件非常简单：
- en: '[PRE45]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: Dispatching an event in our reactive dispatcher means taking the Subject for
    this particular event and calling its `onNext()` method, with the event as an
    argument. The event then gets propagated unless its `stopPropagation()` method
    is called, because we check its state before calling every observer with the `filter()`
    operator.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的反应式分发器中分发一个事件意味着获取该特定事件的Subject并调用其`onNext()`方法，将事件作为参数。除非调用`stopPropagation()`方法，否则事件会继续传播，因为我们会在调用每个观察者之前使用`filter()`操作符检查其状态。
- en: We also return the event from the method, to stay compatible with the default
    `EventDispatcher` implementation.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还从方法中返回事件，以保持与默认`EventDispatcher`实现的兼容性。
- en: And that's it. Our `ReactiveEventDispatcher` is complete and we can run a few
    test scenarios.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 就这样。我们的`ReactiveEventDispatcher`就完成了，我们可以运行几个测试场景。
- en: Practical example of ReactiveEventDispatcher
  id: totrans-245
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: ReactiveEventDispatcher的实际示例
- en: We dedicated the first part of this chapter to explaining how the default `EventDispatcher`
    that comes out of the box with the Symfony `EventDispatcher` component works,
    and what use cases we expect it to deal with.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在本章的第一部分专门解释了默认的`EventDispatcher`是如何与Symfony的`EventDispatcher`组件一起工作的，以及我们期望它处理的用例。
- en: Now we need to make sure the same applies to `ReactiveEventDispatcher` as well.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们需要确保`ReactiveEventDispatcher`也适用同样的规则。
- en: Working with event listeners
  id: totrans-248
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 与事件监听器一起工作
- en: 'We know that our overridden `addListener()` method now accepts both callables
    and observers, so we can test both use cases in one example:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 我们知道我们的重写`addListener()`方法现在接受可调用和观察者，因此我们可以在一个示例中测试这两种用例：
- en: '[PRE46]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'This example calls the second listener and then the first listener, because
    the second one has a higher priority:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 此示例首先调用第二个监听器，然后调用第一个监听器，因为第二个监听器的优先级更高：
- en: '[PRE47]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Now, let''s test event subscribers with the same `MyEventSubscriber` class
    we used in the preceding example. The usage and the output are exactly the same,
    so we don''t need to print the output here again:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们使用与前面示例中相同的`MyEventSubscriber`类来测试事件订阅者。使用方式和输出完全相同，因此我们不需要再次打印输出：
- en: '[PRE48]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'A slightly modified example, which dispatches multiple events, uses Observables
    and fiddles with conditional stopping event propagation, could look like the following:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 一个稍微修改的例子，它分发多个事件，使用Observables并玩弄条件停止事件传播，可能看起来像以下这样：
- en: '[PRE49]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Its output is obvious. When the event''s `getCounter()` method returns a number
    divisible by 2, the event is stopped and never reaches the first event listener
    added using `addListener()`:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 其输出是显而易见的。当事件的`getCounter()`方法返回一个可以被2整除的数字时，事件会被停止，并且永远不会达到使用`addListener()`添加的第一个事件监听器：
- en: '[PRE50]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: Working with event subscribers
  id: totrans-259
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 与事件订阅者一起工作
- en: 'Let''s also test that the event subscriber `MyObservableEventSubscriber` we
    defined earlier works as expected:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们也测试一下之前定义的事件订阅者`MyObservableEventSubscriber`是否按预期工作：
- en: '[PRE51]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Remember that we extended the original `MyEventSubscriber` and added two more
    listeners, so the event dispatcher first adds listeners returned from  `getSubscribedEvents()`,
    and then adds those from  `getSubscribedEventsObservables()`:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，我们扩展了原始的`MyEventSubscriber`并添加了两个额外的监听器，因此事件分发器首先添加从`getSubscribedEvents()`返回的监听器，然后添加从`getSubscribedEventsObservables()`返回的监听器：
- en: '[PRE52]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: The listener with the highest priority is called first. In our case, it's the
    first Observable listener with priority 10, then `onMyActionAgain()` is called,
    with priority 1, and then the two remaining listeners are called in the order
    they were added.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 优先级最高的监听器首先被调用。在我们的例子中，是优先级为10的第一个Observable监听器，然后调用`onMyActionAgain()`，优先级为1，然后按照添加的顺序调用剩下的两个监听器。
- en: Summary
  id: totrans-265
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: This chapter has focused mainly on the practical usage of RxPHP in combination
    with typical non-reactive code, and presented a different approach to existing
    event-based solutions.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 本章主要关注RxPHP与典型非响应式代码的实用结合，并提出了对现有基于事件解决方案的不同方法。
- en: Specifically, we stumbled across Error handling in Observable chains with `retry()`,
    `RetryWhen()`, and `catch()` operators. We combined Observables with the `concat()`,
    `merge()`, and `concatMap()` operator. We used Subjects to dynamically create
    Observable chains and manually emit values. You were also given an introduction
    to the Symfony `EventDispatcher` component, with a series of examples presenting
    how the default `EventDispatcher` class that comes out of the box can be used.
    We extended and partially rewrote the `EventDispatcher` class and created `ReactiveEventDispatcher`,
    which adds support for Observables. And lastly, we reused examples for `EventDispatcher`
    with `ReactiveEventDispatcher` to demonstrate that our implementation can work
    as a drop-in replacement.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 具体来说，我们遇到了在Observable链中使用`retry()`、`RetryWhen()`和`catch()`操作符进行错误处理的问题。我们将Observables与`concat()`、`merge()`和`concatMap()`操作符相结合。我们使用Subjects动态创建Observable链并手动发出值。我们还介绍了Symfony的`EventDispatcher`组件，通过一系列示例展示了默认的`EventDispatcher`类如何使用。我们扩展并部分重写了`EventDispatcher`类，创建了`ReactiveEventDispatcher`，它增加了对Observables的支持。最后，我们使用`ReactiveEventDispatcher`重用了`EventDispatcher`的示例，以证明我们的实现可以作为即插即用的替代品。
- en: The Symfony `EventDispatcher` component serves as an easily implementable solution
    to a common problem in larger applications, which is communication between object
    and extendability. We wrote `ReactiveEventDispatcher` to add capabilities to also
    use observers as event listeners.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: Symfony的`EventDispatcher`组件为解决大型应用程序中常见的通信问题和可扩展性问题提供了一个易于实现的解决方案。我们编写了`ReactiveEventDispatcher`来添加使用观察者作为事件监听器的功能。
- en: In the next chapter, we'll learn how to write unit tests to test Observables,
    operators, and observers. We'll also have a better look at Schedulers and see
    how important are they in testing RxPHP code.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将学习如何编写单元测试来测试Observables、操作符和观察者。我们还将更深入地了解调度器，并了解它们在测试RxPHP代码中的重要性。
