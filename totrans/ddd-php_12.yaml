- en: Integrating Bounded Contexts
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Every enterprise application is typically composed of several areas in which
    the company operates. Areas such as *billing*, *inventory*, *shipping management*,
    *catalog*, and so on are common examples. The easiest manner in which to manage
    all these concerns may seem to lean toward a **monolithic system**. But, you might
    wonder, does it have to be this way? What if any friction garnered between teams
    working on these separate areas could be reduced by splitting this big monolithic
    application into smaller, independent chunks? In this chapter, we'll explore how
    to do this, so be prepared for insights and heuristics around **strategical design**.
  prefs: []
  type: TYPE_NORMAL
- en: Dealing with Distributed Systems
  prefs: []
  type: TYPE_NORMAL
- en: 'Dealing with distributed systems is **hard**. Breaking a system into independent
    autonomous parts has its benefits, but it also increases complexity. For example,
    the coordination and synchronization of distributed systems is not trivial, and
    as a result, should be considered carefully. As Martin Fowler said in the [PoEAA](https://www.martinfowler.com/books/eaa.html) book,
    the first law of distributed systems is always: **Don''t distribute**.'
  prefs: []
  type: TYPE_NORMAL
- en: Integration Through the Data Store
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One of the most commonly used techniques to integrate different parts of an
    application has always been to share the same data store, along with the same
    code base. This is usually known as a monolithic application, and it often ends
    up with a single data store that hosts the data related to all the concerns within
    the application.
  prefs: []
  type: TYPE_NORMAL
- en: Consider an e-commerce application. A shared data store would contain all concerns
    (Example: tables within a relational database) surrounding the catalog, billing,
    inventory, and so on. There's nothing wrong with this approach per se—for example,
    in small linear applications where the complexity is not too high. However, within
    complex Domains, some issues can arise. If you share data across many tables touching
    multiple application concerns, transactions will have a big impact on performance.
  prefs: []
  type: TYPE_NORMAL
- en: Another less technical problem that could develop is in regard to the Ubiquitous
    Language. The main advantage of the separation of Bounded Contexts is having **a
    single Ubiquitous Language for each one**. In doing so, models will be separated
    into their own Contexts. Mixing all models together within the same Context can
    lead to ambiguity and confusion.
  prefs: []
  type: TYPE_NORMAL
- en: Going back to the e-commerce system, imagine we want to introduce the concept
    of a t-shirt. Within the catalogue Context, a t-shirt would be a *product* with
    properties like *color*, *size*, *material*, and maybe some fancy *pictures*.
    In the *inventory* system, however, we don't really want to concern ourselves
    with these things. Here, a *product* has a different meaning, where we care about
    different properties like *weight*, *location in the warehouse*, or *dimensions*.
    Mixing both Contexts together will tangle concepts and complicate the design.
    In Domain-Driven Design terms, mixing concepts in this manner is what is called
    a Shared Kernel.
  prefs: []
  type: TYPE_NORMAL
- en: Shared Kernel
  prefs: []
  type: TYPE_NORMAL
- en: 'Designate some subset of the domain model that the teams agree to share. Of
    course this includes, along with this subset of the model, the subset of code
    or of the database design associated with that part of the model. This explicitly
    shared stuff has special status, and shouldn''t be changed without consultation
    with the other team. Integrate a functional system frequently, but somewhat less
    often than the pace of CONTINUOUS INTEGRATION within the teams. At these integrations,
    run the tests of both teams.  Eric Evans - [Domain-Driven Design: Tackling Complexity
    in the Heart of Software](https://www.amazon.com/Domain-Driven-Design-Tackling-Complexity-Software/dp/0321125215)'
  prefs: []
  type: TYPE_NORMAL
- en: We don't recommend using a Shared Kernel, as multiple teams can collide within
    the development of it, which not only results in maintenance issues but also becomes
    a point of friction. However, if you opt to use a Shared Kernel, changes should
    be agreed upon beforehand and between all parties involved. Conceptually, this
    approach has other problems, such as people seeing it as a bag to place *stuff* that
    doesn't belong anywhere else, and this grows indefinitely. A better way of dealing
    with the ever-growing complexity of the monolith is to break it up in different
    autonomous pieces, such as communicating through REST, RPC, or messaging systems.
    This requires drawing clear boundaries, with each Context likely ending up with
    its own Infrastructure—data stores, servers, messaging middleware, and so on —
    and even its own team.
  prefs: []
  type: TYPE_NORMAL
- en: As you might imagine, this could lead to some degree of duplication, but that's
    a tradeoff that we're willing to make in order to reduce complexity. In Domain-Driven
    Design, we call these independent pieces **Bounded Contexts**.
  prefs: []
  type: TYPE_NORMAL
- en: Integration Relationships
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Customer - Supplier
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When there's a unidirectional integration between two Bounded Contexts, where
    one acts as a provider (**upstream**) and the other as a client (**downstream**),
    we'll end up with **Customer - Supplier Development Teams**.
  prefs: []
  type: TYPE_NORMAL
- en: 'Establish a clear customer/supplier relationship between the two teams. In
    planning sessions, make the downstream team play the customer role to the upstream
    team. Negotiate and budget tasks for downstream requirements so that everyone
    understands the commitment and schedule. Jointly develop automated acceptance
    tests that will validate the interface expected. Add these tests to the upstream
    team''s test suite, to be run as part of its'' continuous integration. This testing
    will free the upstream team to make changes without fear of side effects downstream.
    Eric Evans - [Domain-Driven Design: Tackling Complexity in the Heart of Software](https://www.amazon.com/Domain-Driven-Design-Tackling-Complexity-Software/dp/0321125215).'
  prefs: []
  type: TYPE_NORMAL
- en: Customer - Supplier Development Teams are the most common way of integrating
    Bounded Contexts and usually represent a win-win situation when teams work closely.
  prefs: []
  type: TYPE_NORMAL
- en: Separate Ways
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Continuing with the e-commerce example, think about reporting revenue to an
    old legacy retailer financial system. The integration could be incredibly expensive,
    resulting in it not being worth the effort to implement. In Domain-Driven Design
    strategic terms, this is known as **Separate Ways**.
  prefs: []
  type: TYPE_NORMAL
- en: Integration is always expensive. Sometimes the benefit is small. So Declare
    a BOUNDED CONTEXT to have no connection to the others at all, allowing developers
    to find simple, specialized solutions within this small scope. Eric Evans - *Domain-Driven
    Design:* [Tackling Complexity in the Heart of Software](https://www.amazon.com/Domain-Driven-Design-Tackling-Complexity-Software/dp/0321125215).
  prefs: []
  type: TYPE_NORMAL
- en: Conformist
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Consider again the e-commerce example and integration with a third-party shipping
    service. Both Domains differ in models, teams, and Infrastructure. The team responsible
    for maintaining the third-party shipping service will not participate in your
    product planning or provide any solutions to the e-commerce system. These teams
    don't have a close relationship. We could choose to accept and *conform* to their
    Domain Model. In strategic design, this is what we call a **Conformist Integration**.
  prefs: []
  type: TYPE_NORMAL
- en: Eliminate the complexity of translation between BOUNDED CONTEXTS by slavishly
    adhering to the model of the upstream team. Although this cramps the style of
    the downstream designers and probably does not yield the ideal model for the application,
    choosing CONFORMITY enormously simplifies integration. Also, you will share a
    UBIQUITOUS LANGUAGE with your supplier team. The supplier is in the driver's seat,
    so it is good to make communication easy for them. Altruism may be sufficient
    to get them to share information with you. Eric Evans - *Domain-Driven Design:*
    [Tackling Complexity in the Heart of Software](https://www.amazon.com/Domain-Driven-Design-Tackling-Complexity-Software/dp/0321125215).
  prefs: []
  type: TYPE_NORMAL
- en: Implementing Bounded Context Integrations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To make things easier, we'll assume Bounded Contexts have a Customer - Supplier
    relationship.
  prefs: []
  type: TYPE_NORMAL
- en: Modern RPC
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: With modern RPC, we refer to RPC through RESTful resources. A Bounded Context
    reveals a clear interface to interact with to the outside world. It exposes resources
    that could be manipulated through HTTP verbs. We could say that the Bounded Context
    offers a set of services and operations. In strategical terms, this is what is
    called an **Open Host Service**.
  prefs: []
  type: TYPE_NORMAL
- en: Open Host Service
  prefs: []
  type: TYPE_NORMAL
- en: Define a protocol that gives access to your subsystem as a set of SERVICES.
    Open the protocol so that all who need to integrate with you can use it. Enhance
    and expand the protocol to handle new integration requirements, except when a
    single team has idiosyncratic needs. Then, use a one-off translator to augment
    the protocol for that special case so that the shared protocol can stay simple
    and coherent. Eric Evans - *Domain-Driven Design:* [Tackling Complexity in the
    Heart of Software](https://www.amazon.com/Domain-Driven-Design-Tackling-Complexity-Software/dp/0321125215)*.*
  prefs: []
  type: TYPE_NORMAL
- en: Let's explore an example provided within the [Last Wishes application](https://github.com/dddinphp/last-wishes)
    that comes with this book's GitHub organization.
  prefs: []
  type: TYPE_NORMAL
- en: 'The application is a web platform with the purpose of letting people save their
    last wills before they die. There are two Contexts: one responsible for handling
    wills—the Will Bounded Context—and one in charge of giving points to the users
    of the system—the [Gamification Context](https://github.com/dddinphp/last-wishes-gamify).
    In the Will Context, the user could have badges related to the number of points
    the user made on the Gamification Context. This means that we need to integrate
    both Contexts together in order to show the badges a user has on the Will Context.'
  prefs: []
  type: TYPE_NORMAL
- en: The Gamification Context is a full-fledged event-driven application powered
    by a custom event sourcing engine. It's a full-stack Symfony application that
    uses [FOSRestBundle](http://symfony.com/doc/current/bundles/FOSRestBundle/index.html),
    [BazingaHateoasBundle](https://github.com/willdurand/BazingaHateoasBundle), [JMSSerializerBundle](https://github.com/schmittjoh/JMSSerializerBundle),
    [NelmioApiDocBundle](https://github.com/schmittjoh/JMSSerializerBundle), and [OngrElasticsearchBundle](https://github.com/schmittjoh/JMSSerializerBundle) to
    provide a level 3 and up REST API (commonly known as the Glory of REST), according
    to the [Richardson Maturity *Mo*del](https://martinfowler.com/articles/richardsonMaturityModel.html).
    All the Events triggered within this Context are projected against an Elasticsearch
    server, in order to produce the data needed for the views. We'll expose the number
    of points made for a given user through an endpoint like `http://gamification.context.host/api/users/{id}`.
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ll also fetch the user projection from Elasticsearch and serialize it to
    a format previously negotiated with the client:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: As we explained in the [Chapter 2](d29cc2f8-a8a4-4c83-9322-3f346397de30.xhtml),
    *Architectural Styles* reads are treated as an Infrastructure concern, so there's
    no need to wrap them inside a Command / Command Handler flow.
  prefs: []
  type: TYPE_NORMAL
- en: 'The resulting JSON+HAL representation of a user will be like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Now we're in a good position to integrate both Contexts. We just need to write
    the client in the Will Context for consuming the endpoint we've just created.
    Should we mix both Domain Models? Digesting the Gamification Context directly
    will mean adapting the Will Context to the Gamification one, resulting in a **Conformist**
    integration. However, separating these concerns seems worth the effort. We need
    a layer for guaranteeing the integrity and the consistency of the Domain Model
    within the Will Context, and we need to translate *points* (Gamification) to *badges*
    (Will). In Domain-Driven Design, this translation mechanism is what's called an
    **Anti-Corruption layer**.
  prefs: []
  type: TYPE_NORMAL
- en: Anti-Corruption Layer
  prefs: []
  type: TYPE_NORMAL
- en: Create an isolating layer to provide clients with functionality in terms of
    their own domain model. The layer talks to the other system through its existing
    interface, requiring little or no modification to the other system. Internally,
    the layer translates in both directions as necessary between the two models. Eric
    Evans - *Domain-Driven Design:* [Tackling Complexity in the Heart of Software.](https://www.amazon.com/Domain-Driven-Design-Tackling-Complexity-Software/dp/0321125215)
  prefs: []
  type: TYPE_NORMAL
- en: So, what does the Anti-Corruption layer look like? Most of the time, Services
    will be interacting with a combination of Adapters and Facades. The Services encapsulate
    and hide the low-level complexities behind these transformations. Facades aid
    in hiding and encapsulating access details required for fetching data from the
    Gamification model. Adapters translate between models, often using specialized
    Translators.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s see how to define a User Service within the Will''s model that will
    be responsible for retrieving the badges earned by a given user:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Now let''s look at the implementation on the Infrastructure side. We''ll use
    an adapter for the transformation process:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'And here''s the HTTP implementation for the `UserAdapter`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, the Adapter acts as a **Facade to the Gamification Context**
    too. We did it this way, as fetching the User resource on the Gamification side
    is pretty straightforward. The Adapter uses the `UserTranslator` to perform the
    translation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: The Translator specializes in transforming the points coming from the Gamification
    Context into badges.
  prefs: []
  type: TYPE_NORMAL
- en: We've shown how to integrate two Bounded Contexts where respective teams share
    a **Customer-Supplier** relationship. The Gamification Context exposes the integration
    through an **Open Host Service** implemented by a RESTful protocol. On the other
    side, the Will Context consumes the service through an **Anti-Corruption layer**
    responsible for translating the model from one Domain to the other, ensuring the
    Will Context's integrity.
  prefs: []
  type: TYPE_NORMAL
- en: Message Queues
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: RESTful resources aren't the only way of enabling integrations between Bounded
    Contexts. As we'll see, messaging middleware enables decoupled integrations between
    different Contexts.
  prefs: []
  type: TYPE_NORMAL
- en: 'Continuing with the Last Wishes application, we''ve just implemented a unidirectional
    relationship between two teams to manage points and badges within their respective
    Contexts. However, we left an important functionality out of scope on purpose:
    **rewarding the user every time they make a wish**.'
  prefs: []
  type: TYPE_NORMAL
- en: We could go for another Open Host Service with a pull strategy. The Will Context
    will be pulling the Gamification Context periodically to get badges on sync (Example: through
    an scheduler like Cron). This solution will impact the user's experience, and
    it'll waste a lot of unnecessary resources.
  prefs: []
  type: TYPE_NORMAL
- en: A better approach is to use a **messaging middleware**. With this solution,
    Contexts could push messages to a middleware (often a message queue). Interested
    parties will be able to subscribe, inspect, and consume information on demand
    in a decoupled fashion. In order to do this, we need a **specialized, shared,
    and common communication language**, so all the parties can understand the information
    transmitted. This is what's called the **Published Language**.
  prefs: []
  type: TYPE_NORMAL
- en: Published Language
  prefs: []
  type: TYPE_NORMAL
- en: Use a well-documented shared language that can express the necessary domain
    information as a common medium of communication, translating as necessary into
    and out of that language.  Eric Evans - *Domain-Driven Design:* [Tackling Complexity
    in the Heart of Software](https://www.amazon.com/Domain-Driven-Design-Tackling-Complexity-Software/dp/0321125215).
  prefs: []
  type: TYPE_NORMAL
- en: 'In thinking about the format of these messages and looking closer at our Domain
    Model, we realize we already have what we need: [Chapter 6](607255c5-e619-4398-94bb-484c008472b7.xhtml), *Domain-Events*.
    It''s not necessary to define a new way of communicating between Bounded Contexts.
    Instead, we can just use Domain Events to define a common language across Contexts.
    The definition of *something that Domain Experts care about that just happened* fits
    perfectly with what we''re looking for: a formal Published Language.'
  prefs: []
  type: TYPE_NORMAL
- en: In our example, we could use RabbitMQ as a messaging middleware. This is probably
    one of the most reliable and robust messaging [AMQP](https://www.amqp.org/) protocols
    out there. We'll also incorporate the widely used PHP libraries [php-amqplib](https://github.com/php-amqplib/php-amqplib) and
    [RabbitMQBundle](https://github.com/php-amqplib/RabbitMqBundle).
  prefs: []
  type: TYPE_NORMAL
- en: Let's start with the Will Context, as it's the one that triggers Events when
    the user signs up or when making a wish. As we've already seen in the [Chapter 6](607255c5-e619-4398-94bb-484c008472b7.xhtml), *Domain-Events*,
    **it's a good idea to store Domain Events into a persistent mechanism**, so we'll
    assume that's what was done. We need a message publisher to fetch and publish
    stored Domain Events from the Event store to the messaging middleware. We already
    did the integration with RabbitMQ in the [Chapter 6](607255c5-e619-4398-94bb-484c008472b7.xhtml), *Domain-Events*,
    so we just need to implement the code in the Gamification Context. We'll listen
    for Events triggered by the Will Context. As we're using the Symfony Framework,
    we take advantage of a Symfony package called RabbitMQBundle.
  prefs: []
  type: TYPE_NORMAL
- en: 'We define two message consumers for the *User Registered* and *Wish Was Made*
    events:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that in this case, we''re only processing messages with the type of `Lw\Domain\Model\User\UserRegistered`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Again, we're only interested in tracking `Lw\Domain\Model\Wish\WishWasMade events`.
  prefs: []
  type: TYPE_NORMAL
- en: In both cases, we use a Command Bus, which we discussed in the Chapter, Application.
    However, we can summarize it as a highway that decouples the Command and Receiver.
    The **when** and **how** a Command is executed is independent from **who** triggered
    it.
  prefs: []
  type: TYPE_NORMAL
- en: The Gamification Context uses [Tactician](http://tactician.thephpleague.com/) (and
    [TacticianBundle](https://github.com/thephpleague/tactician-bundle)), a simple
    Command Bus that can be extended and adapted to your system. So now we're almost
    ready to start consuming Events from the Will Context.
  prefs: []
  type: TYPE_NORMAL
- en: 'The only thing we still need to do is define the RabbitMQBundle configuration
    in Symfony''s `config.yml` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: The most convenient RabbitMQ configuration is probably the [[Publish / Subscribe](https://www.rabbitmq.com/tutorials/tutorial-three-php.html)] pattern.
    All messages published by the Will Context will be delivered to all connected
    consumers. This is called **fanout** in the RabbitMQ exchange configuration.
  prefs: []
  type: TYPE_NORMAL
- en: 'The exchange consists of an agent being in charge of delivering messages to
    the corresponding queues:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: With those two commands, Symfony will execute both consumers and they'll start
    listening for Domain Events. We've specified a limit of 1,000 messages to consume,
    as PHP isn't the best platform for executing long-running processes. It also might
    be a good idea to use something like [Supervisor](http://supervisord.org/) to
    monitor and restart processes periodically.
  prefs: []
  type: TYPE_NORMAL
- en: Wrap-Up
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Although we've only seen a small part of it, strategical design is at the heart
    and soul of Domain-Driven Design. It's an essential part that aids in developing
    better and more semantic models. We recommend using messaging middleware to integrate
    Bounded Contexts, as this naturally leads to simpler, decoupled, and Event-driven
    architectures.
  prefs: []
  type: TYPE_NORMAL
