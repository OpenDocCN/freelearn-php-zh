- en: Integrating Bounded Contexts
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 集成边界上下文
- en: Every enterprise application is typically composed of several areas in which
    the company operates. Areas such as *billing*, *inventory*, *shipping management*,
    *catalog*, and so on are common examples. The easiest manner in which to manage
    all these concerns may seem to lean toward a **monolithic system**. But, you might
    wonder, does it have to be this way? What if any friction garnered between teams
    working on these separate areas could be reduced by splitting this big monolithic
    application into smaller, independent chunks? In this chapter, we'll explore how
    to do this, so be prepared for insights and heuristics around **strategical design**.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 每个企业级应用程序通常由公司运营的几个区域组成。例如，*计费*、*库存*、*运输管理*、*目录*等区域是常见的例子。管理所有这些关注点的最简单方法可能倾向于采用**单体系统**。但是，你可能想知道，这必须是这样吗？如果通过将这个大单体应用程序拆分成更小、更独立的块来减少在这些不同区域工作的团队之间的摩擦，会怎么样呢？在本章中，我们将探讨如何做到这一点，因此请准备好了解关于**战略设计**的见解和启发式方法。
- en: Dealing with Distributed Systems
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 处理分布式系统
- en: 'Dealing with distributed systems is **hard**. Breaking a system into independent
    autonomous parts has its benefits, but it also increases complexity. For example,
    the coordination and synchronization of distributed systems is not trivial, and
    as a result, should be considered carefully. As Martin Fowler said in the [PoEAA](https://www.martinfowler.com/books/eaa.html) book,
    the first law of distributed systems is always: **Don''t distribute**.'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 处理分布式系统是**困难的**。将系统分解成独立的自主部分有其好处，但它也增加了复杂性。例如，分布式系统的协调和同步不是微不足道的，因此应该仔细考虑。正如马丁·福勒在[PoEAA](https://www.martinfowler.com/books/eaa.html)一书中所说，分布式系统的第一定律始终是：**不要分布式**。
- en: Integration Through the Data Store
  id: totrans-4
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通过数据存储进行集成
- en: One of the most commonly used techniques to integrate different parts of an
    application has always been to share the same data store, along with the same
    code base. This is usually known as a monolithic application, and it often ends
    up with a single data store that hosts the data related to all the concerns within
    the application.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 集成应用程序不同部分的最常用技术之一始终是共享相同的数据存储库和相同的代码库。这通常被称为单体应用，并且通常最终会形成一个单一的数据存储库，它托管着与应用程序中所有相关关注点相关的数据。
- en: Consider an e-commerce application. A shared data store would contain all concerns
    (Example: tables within a relational database) surrounding the catalog, billing,
    inventory, and so on. There's nothing wrong with this approach per se—for example,
    in small linear applications where the complexity is not too high. However, within
    complex Domains, some issues can arise. If you share data across many tables touching
    multiple application concerns, transactions will have a big impact on performance.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑一个电子商务应用程序。共享的数据存储库将包含所有关注点（例如：关系型数据库中的表）周围的相关内容，如目录、计费、库存等。这种方法本身并没有问题——例如，在小型线性应用程序中，复杂性不是太高。然而，在复杂的领域内，可能会出现一些问题。如果你在多个涉及多个应用程序关注点的表中共享数据，事务将对性能产生重大影响。
- en: Another less technical problem that could develop is in regard to the Ubiquitous
    Language. The main advantage of the separation of Bounded Contexts is having **a
    single Ubiquitous Language for each one**. In doing so, models will be separated
    into their own Contexts. Mixing all models together within the same Context can
    lead to ambiguity and confusion.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个可能出现的非技术问题与通用语言有关。边界上下文分离的主要优势是每个边界上下文都有**一个单一的通用语言**。通过这样做，模型将被分离到它们自己的上下文中。在同一个上下文中混合所有模型可能会导致歧义和混淆。
- en: Going back to the e-commerce system, imagine we want to introduce the concept
    of a t-shirt. Within the catalogue Context, a t-shirt would be a *product* with
    properties like *color*, *size*, *material*, and maybe some fancy *pictures*.
    In the *inventory* system, however, we don't really want to concern ourselves
    with these things. Here, a *product* has a different meaning, where we care about
    different properties like *weight*, *location in the warehouse*, or *dimensions*.
    Mixing both Contexts together will tangle concepts and complicate the design.
    In Domain-Driven Design terms, mixing concepts in this manner is what is called
    a Shared Kernel.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 回到电子商务系统，假设我们想要引入T恤的概念。在目录上下文中，T恤将是一个具有如*颜色*、*尺寸*、*材质*和可能的一些花哨的*图片*等属性的*产品*。然而，在*库存*系统中，我们并不真正关心这些事情。在这里，*产品*有不同的含义，我们关注的是不同的属性，如*重量*、*仓库中的位置*或*尺寸*。将这两个上下文混合在一起会混淆概念并复杂化设计。在领域驱动设计的术语中，以这种方式混合概念被称为共享内核。
- en: Shared Kernel
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 共享内核
- en: 'Designate some subset of the domain model that the teams agree to share. Of
    course this includes, along with this subset of the model, the subset of code
    or of the database design associated with that part of the model. This explicitly
    shared stuff has special status, and shouldn''t be changed without consultation
    with the other team. Integrate a functional system frequently, but somewhat less
    often than the pace of CONTINUOUS INTEGRATION within the teams. At these integrations,
    run the tests of both teams.  Eric Evans - [Domain-Driven Design: Tackling Complexity
    in the Heart of Software](https://www.amazon.com/Domain-Driven-Design-Tackling-Complexity-Software/dp/0321125215)'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 指定一些领域模型子集，让团队达成共识并共享。当然，这包括与该模型部分相关的代码子集或数据库设计子集。这些明确共享的内容具有特殊地位，并且未经与其他团队协商不应更改。频繁地集成功能系统，但频率略低于团队内部持续集成的步伐。在这些集成中，运行两个团队的测试。埃里克·埃文斯
    - [领域驱动设计：软件核心的复杂性处理](https://www.amazon.com/Domain-Driven-Design-Tackling-Complexity-Software/dp/0321125215)
- en: We don't recommend using a Shared Kernel, as multiple teams can collide within
    the development of it, which not only results in maintenance issues but also becomes
    a point of friction. However, if you opt to use a Shared Kernel, changes should
    be agreed upon beforehand and between all parties involved. Conceptually, this
    approach has other problems, such as people seeing it as a bag to place *stuff* that
    doesn't belong anywhere else, and this grows indefinitely. A better way of dealing
    with the ever-growing complexity of the monolith is to break it up in different
    autonomous pieces, such as communicating through REST, RPC, or messaging systems.
    This requires drawing clear boundaries, with each Context likely ending up with
    its own Infrastructure—data stores, servers, messaging middleware, and so on —
    and even its own team.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不建议使用共享内核，因为多个团队在开发过程中可能会发生冲突，这不仅会导致维护问题，还可能成为摩擦的焦点。然而，如果您选择使用共享内核，应在所有相关方之间事先达成一致。从概念上讲，这种方法还有其他问题，比如人们将其视为一个可以放置不属于其他任何地方的*东西*的袋子，并且这种东西会无限增长。处理单体不断增长的复杂性的更好方法是将它拆分成不同的自主部分，例如通过REST、RPC或消息系统进行通信。这需要绘制清晰的边界，每个上下文可能最终都会拥有自己的基础设施——数据存储、服务器、消息中间件等等——甚至自己的团队。
- en: As you might imagine, this could lead to some degree of duplication, but that's
    a tradeoff that we're willing to make in order to reduce complexity. In Domain-Driven
    Design, we call these independent pieces **Bounded Contexts**.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所想，这可能会导致一定程度的重叠，但这是我们为了减少复杂性而愿意做出的权衡。在领域驱动设计中，我们称这些独立部分为**边界上下文**。
- en: Integration Relationships
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 集成关系
- en: Customer - Supplier
  id: totrans-14
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 客户 - 供应商
- en: When there's a unidirectional integration between two Bounded Contexts, where
    one acts as a provider (**upstream**) and the other as a client (**downstream**),
    we'll end up with **Customer - Supplier Development Teams**.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 当两个边界上下文之间存在单向集成时，其中一个充当提供者（**上游**），另一个充当客户端（**下游**），我们将得到**客户 - 供应商开发团队**。
- en: 'Establish a clear customer/supplier relationship between the two teams. In
    planning sessions, make the downstream team play the customer role to the upstream
    team. Negotiate and budget tasks for downstream requirements so that everyone
    understands the commitment and schedule. Jointly develop automated acceptance
    tests that will validate the interface expected. Add these tests to the upstream
    team''s test suite, to be run as part of its'' continuous integration. This testing
    will free the upstream team to make changes without fear of side effects downstream.
    Eric Evans - [Domain-Driven Design: Tackling Complexity in the Heart of Software](https://www.amazon.com/Domain-Driven-Design-Tackling-Complexity-Software/dp/0321125215).'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在两个团队之间建立清晰的客户/供应商关系。在规划会议中，让下游团队扮演上游团队的客户角色。协商并预算下游团队的需求任务，以便每个人都能理解承诺和进度。共同开发将验证预期接口的自动化验收测试。将这些测试添加到上游团队的测试套件中，作为其持续集成的一部分。这种测试将使上游团队在没有下游副作用恐惧的情况下进行更改。埃里克·埃文斯
    - [领域驱动设计：软件核心的复杂性处理](https://www.amazon.com/Domain-Driven-Design-Tackling-Complexity-Software/dp/0321125215)。
- en: Customer - Supplier Development Teams are the most common way of integrating
    Bounded Contexts and usually represent a win-win situation when teams work closely.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 客户-供应商开发团队是有界上下文集成最常见的方式，并且当团队紧密合作时通常代表双赢的局面。
- en: Separate Ways
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 分道扬镳
- en: Continuing with the e-commerce example, think about reporting revenue to an
    old legacy retailer financial system. The integration could be incredibly expensive,
    resulting in it not being worth the effort to implement. In Domain-Driven Design
    strategic terms, this is known as **Separate Ways**.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 继续以电子商务为例，考虑向一个旧的遗留零售商财务系统报告收入。这种集成可能非常昂贵，以至于不值得投入精力去实施。在领域驱动设计的战略术语中，这被称为**分道扬镳**。
- en: Integration is always expensive. Sometimes the benefit is small. So Declare
    a BOUNDED CONTEXT to have no connection to the others at all, allowing developers
    to find simple, specialized solutions within this small scope. Eric Evans - *Domain-Driven
    Design:* [Tackling Complexity in the Heart of Software](https://www.amazon.com/Domain-Driven-Design-Tackling-Complexity-Software/dp/0321125215).
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 集成总是昂贵的。有时好处很小。因此，宣布一个有界上下文与其它上下文没有任何联系，允许开发者在这样一个小范围内找到简单、专业的解决方案。埃里克·埃文斯 -
    *领域驱动设计:* [软件核心的复杂性处理](https://www.amazon.com/Domain-Driven-Design-Tackling-Complexity-Software/dp/0321125215)。
- en: Conformist
  id: totrans-21
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 顺从者
- en: Consider again the e-commerce example and integration with a third-party shipping
    service. Both Domains differ in models, teams, and Infrastructure. The team responsible
    for maintaining the third-party shipping service will not participate in your
    product planning or provide any solutions to the e-commerce system. These teams
    don't have a close relationship. We could choose to accept and *conform* to their
    Domain Model. In strategic design, this is what we call a **Conformist Integration**.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 再次考虑电子商务示例和与第三方物流服务的集成。这两个领域在模型、团队和基础设施方面都存在差异。负责维护第三方物流服务的团队不会参与你的产品规划或为电子商务系统提供任何解决方案。这些团队之间没有紧密的关系。我们可以选择接受并**顺从**他们的领域模型。在战略设计中，我们称之为**顺从集成**。
- en: Eliminate the complexity of translation between BOUNDED CONTEXTS by slavishly
    adhering to the model of the upstream team. Although this cramps the style of
    the downstream designers and probably does not yield the ideal model for the application,
    choosing CONFORMITY enormously simplifies integration. Also, you will share a
    UBIQUITOUS LANGUAGE with your supplier team. The supplier is in the driver's seat,
    so it is good to make communication easy for them. Altruism may be sufficient
    to get them to share information with you. Eric Evans - *Domain-Driven Design:*
    [Tackling Complexity in the Heart of Software](https://www.amazon.com/Domain-Driven-Design-Tackling-Complexity-Software/dp/0321125215).
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 通过盲目遵循上游团队的模型来消除有界上下文之间翻译的复杂性。尽管这可能会限制下游设计师的风格，并且可能不会产生理想的应用模型，但选择一致性可以极大地简化集成。此外，你将与供应商团队共享一个**无处不在的语言**。供应商处于主导地位，因此让他们的沟通变得容易是好事。利他主义可能足以让他们与你分享信息。埃里克·埃文斯
    - *领域驱动设计:* [软件核心的复杂性处理](https://www.amazon.com/Domain-Driven-Design-Tackling-Complexity-Software/dp/0321125215)。
- en: Implementing Bounded Context Integrations
  id: totrans-24
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实施有界上下文集成
- en: To make things easier, we'll assume Bounded Contexts have a Customer - Supplier
    relationship.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 为了简化事情，我们将假设有界上下文有一个客户-供应商关系。
- en: Modern RPC
  id: totrans-26
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 现代RPC
- en: With modern RPC, we refer to RPC through RESTful resources. A Bounded Context
    reveals a clear interface to interact with to the outside world. It exposes resources
    that could be manipulated through HTTP verbs. We could say that the Bounded Context
    offers a set of services and operations. In strategical terms, this is what is
    called an **Open Host Service**.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 在现代RPC中，我们通过RESTful资源来指代RPC。一个有界上下文揭示了一个清晰的接口，用于与外界交互。它暴露了可以通过HTTP动词进行操作的资源。我们可以这样说，有界上下文提供了一套服务和操作。从战略的角度来看，这被称为**开放主机服务**。
- en: Open Host Service
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 开放主机服务
- en: Define a protocol that gives access to your subsystem as a set of SERVICES.
    Open the protocol so that all who need to integrate with you can use it. Enhance
    and expand the protocol to handle new integration requirements, except when a
    single team has idiosyncratic needs. Then, use a one-off translator to augment
    the protocol for that special case so that the shared protocol can stay simple
    and coherent. Eric Evans - *Domain-Driven Design:* [Tackling Complexity in the
    Heart of Software](https://www.amazon.com/Domain-Driven-Design-Tackling-Complexity-Software/dp/0321125215)*.*
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 定义一个协议，该协议将您的子系统作为一组服务提供访问。开放协议，以便所有需要与您集成的人都可以使用它。增强和扩展协议以处理新的集成需求，除非单个团队有特殊需求。然后，使用一次性翻译器来增强该特殊情况的协议，以便共享协议可以保持简单和一致。埃里克·埃文斯
    - *领域驱动设计：* [在软件核心处理复杂性](https://www.amazon.com/Domain-Driven-Design-Tackling-Complexity-Software/dp/0321125215)*.*
- en: Let's explore an example provided within the [Last Wishes application](https://github.com/dddinphp/last-wishes)
    that comes with this book's GitHub organization.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们探索这本书的GitHub组织提供的[最后愿望应用程序](https://github.com/dddinphp/last-wishes)中的示例。
- en: 'The application is a web platform with the purpose of letting people save their
    last wills before they die. There are two Contexts: one responsible for handling
    wills—the Will Bounded Context—and one in charge of giving points to the users
    of the system—the [Gamification Context](https://github.com/dddinphp/last-wishes-gamify).
    In the Will Context, the user could have badges related to the number of points
    the user made on the Gamification Context. This means that we need to integrate
    both Contexts together in order to show the badges a user has on the Will Context.'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 该应用程序是一个旨在让人们在他们去世之前保存他们的遗嘱的Web平台。有两个上下文：一个负责处理遗嘱的有界上下文（Will Bounded Context），另一个负责给系统用户评分的[游戏化上下文](https://github.com/dddinphp/last-wishes-gamify)。在遗嘱上下文中，用户可能会有与他们在游戏化上下文中获得的积分相关的徽章。这意味着我们需要将这两个上下文集成在一起，以便显示用户在遗嘱上下文中的徽章。
- en: The Gamification Context is a full-fledged event-driven application powered
    by a custom event sourcing engine. It's a full-stack Symfony application that
    uses [FOSRestBundle](http://symfony.com/doc/current/bundles/FOSRestBundle/index.html),
    [BazingaHateoasBundle](https://github.com/willdurand/BazingaHateoasBundle), [JMSSerializerBundle](https://github.com/schmittjoh/JMSSerializerBundle),
    [NelmioApiDocBundle](https://github.com/schmittjoh/JMSSerializerBundle), and [OngrElasticsearchBundle](https://github.com/schmittjoh/JMSSerializerBundle) to
    provide a level 3 and up REST API (commonly known as the Glory of REST), according
    to the [Richardson Maturity *Mo*del](https://martinfowler.com/articles/richardsonMaturityModel.html).
    All the Events triggered within this Context are projected against an Elasticsearch
    server, in order to produce the data needed for the views. We'll expose the number
    of points made for a given user through an endpoint like `http://gamification.context.host/api/users/{id}`.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 游戏化上下文是一个完整的事件驱动应用程序，由一个定制的事件源引擎提供支持。它是一个全栈Symfony应用程序，使用[FOSRestBundle](http://symfony.com/doc/current/bundles/FOSRestBundle/index.html)、[BazingaHateoasBundle](https://github.com/willdurand/BazingaHateoasBundle)、[JMSSerializerBundle](https://github.com/schmittjoh/JMSSerializerBundle)、[NelmioApiDocBundle](https://github.com/schmittjoh/JMSSerializerBundle)和[OngrElasticsearchBundle](https://github.com/schmittjoh/JMSSerializerBundle)来提供3级及以上REST
    API（通常称为REST的荣耀），根据[理查森成熟度*模型](https://martinfowler.com/articles/richardsonMaturityModel.html)。在这个上下文中触发的事件都会投影到一个Elasticsearch服务器上，以产生视图所需的数据。我们将通过类似`http://gamification.context.host/api/users/{id}`的端点公开特定用户的积分数量。
- en: 'We''ll also fetch the user projection from Elasticsearch and serialize it to
    a format previously negotiated with the client:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将从Elasticsearch获取用户投影，并将其序列化为与客户端先前协商的格式：
- en: '[PRE0]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: As we explained in the [Chapter 2](d29cc2f8-a8a4-4c83-9322-3f346397de30.xhtml),
    *Architectural Styles* reads are treated as an Infrastructure concern, so there's
    no need to wrap them inside a Command / Command Handler flow.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在[第2章](d29cc2f8-a8a4-4c83-9322-3f346397de30.xhtml)中解释的，*架构风格*的读取被视为基础设施关注点，因此不需要将它们包裹在命令/命令处理流程中。
- en: 'The resulting JSON+HAL representation of a user will be like this:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 用户的结果JSON+HAL表示形式如下：
- en: '[PRE1]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Now we're in a good position to integrate both Contexts. We just need to write
    the client in the Will Context for consuming the endpoint we've just created.
    Should we mix both Domain Models? Digesting the Gamification Context directly
    will mean adapting the Will Context to the Gamification one, resulting in a **Conformist**
    integration. However, separating these concerns seems worth the effort. We need
    a layer for guaranteeing the integrity and the consistency of the Domain Model
    within the Will Context, and we need to translate *points* (Gamification) to *badges*
    (Will). In Domain-Driven Design, this translation mechanism is what's called an
    **Anti-Corruption layer**.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们处于整合两个上下文的好位置。我们只需要在Will上下文中编写客户端来消费我们刚刚创建的端点。我们应该混合这两个领域模型吗？直接消化游戏化上下文将意味着将Will上下文调整为游戏化上下文，从而导致**同质化**的集成。然而，分离这些关注点似乎值得付出努力。我们需要一个层来保证领域模型在Will上下文中的完整性和一致性，并且我们需要将*分数*（游戏化）转换为*徽章*（Will）。在领域驱动设计中，这种转换机制被称为**反腐败层**。
- en: Anti-Corruption Layer
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 反腐败层
- en: Create an isolating layer to provide clients with functionality in terms of
    their own domain model. The layer talks to the other system through its existing
    interface, requiring little or no modification to the other system. Internally,
    the layer translates in both directions as necessary between the two models. Eric
    Evans - *Domain-Driven Design:* [Tackling Complexity in the Heart of Software.](https://www.amazon.com/Domain-Driven-Design-Tackling-Complexity-Software/dp/0321125215)
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个隔离层，为客户端提供其自身领域模型的功能。该层通过其现有接口与其他系统通信，对其他系统几乎没有或不需要进行修改。内部，该层在两个模型之间按需进行双向转换。埃里克·埃文斯
    - *领域驱动设计*：[在软件核心解决复杂性。](https://www.amazon.com/Domain-Driven-Design-Tackling-Complexity-Software/dp/0321125215)
- en: So, what does the Anti-Corruption layer look like? Most of the time, Services
    will be interacting with a combination of Adapters and Facades. The Services encapsulate
    and hide the low-level complexities behind these transformations. Facades aid
    in hiding and encapsulating access details required for fetching data from the
    Gamification model. Adapters translate between models, often using specialized
    Translators.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，反腐败层看起来是什么样子？大多数时候，服务将与适配器和外观的组合进行交互。服务封装并隐藏了这些转换背后的低级复杂性。外观有助于隐藏和封装从游戏化模型获取数据所需的访问细节。适配器在模型之间进行转换，通常使用专门的翻译器。
- en: 'Let''s see how to define a User Service within the Will''s model that will
    be responsible for retrieving the badges earned by a given user:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何在Will模型中定义一个用户服务，该服务将负责检索给定用户获得的徽章：
- en: '[PRE2]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Now let''s look at the implementation on the Infrastructure side. We''ll use
    an adapter for the transformation process:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看基础设施方面的实现。我们将使用适配器来完成转换过程：
- en: '[PRE3]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'And here''s the HTTP implementation for the `UserAdapter`:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是`UserAdapter`的HTTP实现：
- en: '[PRE4]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'As you can see, the Adapter acts as a **Facade to the Gamification Context**
    too. We did it this way, as fetching the User resource on the Gamification side
    is pretty straightforward. The Adapter uses the `UserTranslator` to perform the
    translation:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，适配器也充当了**游戏化上下文的外观**。我们这样做是因为在游戏化侧获取用户资源相当直接。适配器使用`UserTranslator`来执行转换：
- en: '[PRE5]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The Translator specializes in transforming the points coming from the Gamification
    Context into badges.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 翻译器专门负责将来自游戏化上下文的分数转换为徽章。
- en: We've shown how to integrate two Bounded Contexts where respective teams share
    a **Customer-Supplier** relationship. The Gamification Context exposes the integration
    through an **Open Host Service** implemented by a RESTful protocol. On the other
    side, the Will Context consumes the service through an **Anti-Corruption layer**
    responsible for translating the model from one Domain to the other, ensuring the
    Will Context's integrity.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经展示了如何集成两个边界上下文，其中相应的团队共享**客户-供应商**关系。游戏化上下文通过一个由RESTful协议实现的**开放主机服务**公开集成。另一方面，Will上下文通过一个**反腐败层**消费服务，该层负责将一个领域模型转换为另一个领域模型，确保Will上下文的完整性。
- en: Message Queues
  id: totrans-52
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 消息队列
- en: RESTful resources aren't the only way of enabling integrations between Bounded
    Contexts. As we'll see, messaging middleware enables decoupled integrations between
    different Contexts.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: RESTful 资源并不是实现边界上下文之间集成的唯一方式。正如我们将看到的，消息中间件使得不同上下文之间的解耦集成成为可能。
- en: 'Continuing with the Last Wishes application, we''ve just implemented a unidirectional
    relationship between two teams to manage points and badges within their respective
    Contexts. However, we left an important functionality out of scope on purpose:
    **rewarding the user every time they make a wish**.'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续使用 Last Wishes 应用程序的过程中，我们刚刚实现了两支团队之间的单向关系，以管理各自上下文中的积分和徽章。然而，我们故意将一个重要的功能排除在范围之外：**每次用户许愿时都给予奖励**。
- en: We could go for another Open Host Service with a pull strategy. The Will Context
    will be pulling the Gamification Context periodically to get badges on sync (Example: through
    an scheduler like Cron). This solution will impact the user's experience, and
    it'll waste a lot of unnecessary resources.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以考虑采用另一种具有拉取策略的开放主机服务。Will Context 将会定期拉取 Gamification Context 以同步徽章（例如：通过像
    Cron 这样的调度器）。这种解决方案将影响用户体验，并且会浪费大量不必要的资源。
- en: A better approach is to use a **messaging middleware**. With this solution,
    Contexts could push messages to a middleware (often a message queue). Interested
    parties will be able to subscribe, inspect, and consume information on demand
    in a decoupled fashion. In order to do this, we need a **specialized, shared,
    and common communication language**, so all the parties can understand the information
    transmitted. This is what's called the **Published Language**.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 更好的方法是使用**消息中间件**。使用这种解决方案，上下文可以将消息推送到中间件（通常是消息队列）。感兴趣的各方将能够订阅、检查和按需以解耦的方式消费信息。为了做到这一点，我们需要一种**专业、共享和通用的通信语言**，以便所有各方都能理解传输的信息。这就是所谓的**发布语言**。
- en: Published Language
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 发布语言
- en: Use a well-documented shared language that can express the necessary domain
    information as a common medium of communication, translating as necessary into
    and out of that language.  Eric Evans - *Domain-Driven Design:* [Tackling Complexity
    in the Heart of Software](https://www.amazon.com/Domain-Driven-Design-Tackling-Complexity-Software/dp/0321125215).
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 使用一个经过良好文档化的共享语言，该语言可以表达必要的领域信息，作为通用的通信媒介，并在必要时将其翻译成和从该语言中翻译出来。 埃里克·埃文斯 - *领域驱动设计：*
    [软件核心的复杂性处理](https://www.amazon.com/Domain-Driven-Design-Tackling-Complexity-Software/dp/0321125215)。
- en: 'In thinking about the format of these messages and looking closer at our Domain
    Model, we realize we already have what we need: [Chapter 6](607255c5-e619-4398-94bb-484c008472b7.xhtml), *Domain-Events*.
    It''s not necessary to define a new way of communicating between Bounded Contexts.
    Instead, we can just use Domain Events to define a common language across Contexts.
    The definition of *something that Domain Experts care about that just happened* fits
    perfectly with what we''re looking for: a formal Published Language.'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 在思考这些消息的格式并更仔细地审视我们的领域模型时，我们意识到我们已经有我们所需要的东西：[第6章](607255c5-e619-4398-94bb-484c008472b7.xhtml)，*领域事件*。没有必要定义一种新的在边界上下文之间进行通信的方式。相反，我们可以直接使用领域事件来定义上下文之间的通用语言。*领域专家关心刚刚发生的事情*的定义与我们正在寻找的完美契合：一种正式的发布语言。
- en: In our example, we could use RabbitMQ as a messaging middleware. This is probably
    one of the most reliable and robust messaging [AMQP](https://www.amqp.org/) protocols
    out there. We'll also incorporate the widely used PHP libraries [php-amqplib](https://github.com/php-amqplib/php-amqplib) and
    [RabbitMQBundle](https://github.com/php-amqplib/RabbitMqBundle).
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的示例中，我们可以使用 RabbitMQ 作为消息中间件。这可能是最可靠和最健壮的消息 [AMQP](https://www.amqp.org/)
    协议之一。我们还将整合广泛使用的 PHP 库 [php-amqplib](https://github.com/php-amqplib/php-amqplib)
    和 [RabbitMQBundle](https://github.com/php-amqplib/RabbitMqBundle)。
- en: Let's start with the Will Context, as it's the one that triggers Events when
    the user signs up or when making a wish. As we've already seen in the [Chapter 6](607255c5-e619-4398-94bb-484c008472b7.xhtml), *Domain-Events*,
    **it's a good idea to store Domain Events into a persistent mechanism**, so we'll
    assume that's what was done. We need a message publisher to fetch and publish
    stored Domain Events from the Event store to the messaging middleware. We already
    did the integration with RabbitMQ in the [Chapter 6](607255c5-e619-4398-94bb-484c008472b7.xhtml), *Domain-Events*,
    so we just need to implement the code in the Gamification Context. We'll listen
    for Events triggered by the Will Context. As we're using the Symfony Framework,
    we take advantage of a Symfony package called RabbitMQBundle.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从 Will Context 开始，因为它是当用户注册或许愿时触发事件的那个。正如我们在 [第 6 章](607255c5-e619-4398-94bb-484c008472b7.xhtml)
    中看到的，*领域事件*，**将领域事件存储到持久机制中是一个好主意**，所以我们假设这就是所做的工作。我们需要一个消息发布者来从事件存储中检索并发布存储的领域事件到消息中间件。我们已经在
    [第 6 章](607255c5-e619-4398-94bb-484c008472b7.xhtml) 的 *领域事件* 中完成了与 RabbitMQ 的集成，所以我们只需要在
    Gamification Context 中实现代码。我们将监听 Will Context 触发的事件。由于我们使用的是 Symfony 框架，我们利用一个名为
    RabbitMQBundle 的 Symfony 包。
- en: 'We define two message consumers for the *User Registered* and *Wish Was Made*
    events:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 我们为 *用户注册* 和 *愿望已创建* 事件定义了两个消息消费者：
- en: '[PRE6]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Note that in this case, we''re only processing messages with the type of `Lw\Domain\Model\User\UserRegistered`:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，在这种情况下，我们只处理类型为 `Lw\Domain\Model\User\UserRegistered` 的消息：
- en: '[PRE7]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Again, we're only interested in tracking `Lw\Domain\Model\Wish\WishWasMade events`.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调，我们只对跟踪 `Lw\Domain\Model\Wish\WishWasMade` 事件感兴趣。
- en: In both cases, we use a Command Bus, which we discussed in the Chapter, Application.
    However, we can summarize it as a highway that decouples the Command and Receiver.
    The **when** and **how** a Command is executed is independent from **who** triggered
    it.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 在这两种情况下，我们使用命令总线，这在应用章节中已经讨论过。然而，我们可以将其总结为一个解耦命令和接收者的高速公路。命令的 **何时** 和 **如何**
    执行与 **谁** 触发它是独立的。
- en: The Gamification Context uses [Tactician](http://tactician.thephpleague.com/) (and
    [TacticianBundle](https://github.com/thephpleague/tactician-bundle)), a simple
    Command Bus that can be extended and adapted to your system. So now we're almost
    ready to start consuming Events from the Will Context.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: Gamification Context 使用 [Tactician](http://tactician.thephpleague.com/)（以及 [TacticianBundle](https://github.com/thephpleague/tactician-bundle)），这是一个简单的命令总线，可以扩展和适应您的系统。因此，我们现在几乎准备好从
    Will Context 消费事件了。
- en: 'The only thing we still need to do is define the RabbitMQBundle configuration
    in Symfony''s `config.yml` file:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要做的一件事是在 Symfony 的 `config.yml` 文件中定义 RabbitMQBundle 配置：
- en: '[PRE8]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The most convenient RabbitMQ configuration is probably the [[Publish / Subscribe](https://www.rabbitmq.com/tutorials/tutorial-three-php.html)] pattern.
    All messages published by the Will Context will be delivered to all connected
    consumers. This is called **fanout** in the RabbitMQ exchange configuration.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 最方便的 RabbitMQ 配置可能是 [[发布/订阅](https://www.rabbitmq.com/tutorials/tutorial-three-php.html)]
    模式。Will Context 发布的所有消息都将被发送到所有连接的消费者。这在 RabbitMQ 交换配置中被称为 **fanout**。
- en: 'The exchange consists of an agent being in charge of delivering messages to
    the corresponding queues:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 交换由一个负责将消息发送到相应队列的代理组成：
- en: '[PRE9]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: With those two commands, Symfony will execute both consumers and they'll start
    listening for Domain Events. We've specified a limit of 1,000 messages to consume,
    as PHP isn't the best platform for executing long-running processes. It also might
    be a good idea to use something like [Supervisor](http://supervisord.org/) to
    monitor and restart processes periodically.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这两个命令，Symfony 将执行两个消费者，它们将开始监听领域事件。我们指定了消费消息的限制为 1,000 条，因为 PHP 不是执行长时间运行进程的最佳平台。使用类似
    [Supervisor](http://supervisord.org/) 的工具定期监控和重启进程可能也是一个好主意。
- en: Wrap-Up
  id: totrans-75
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: Although we've only seen a small part of it, strategical design is at the heart
    and soul of Domain-Driven Design. It's an essential part that aids in developing
    better and more semantic models. We recommend using messaging middleware to integrate
    Bounded Contexts, as this naturally leads to simpler, decoupled, and Event-driven
    architectures.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管我们只看到了其中的一小部分，但战略设计是领域驱动设计的核心和灵魂。它是开发更好、更语义化模型的一个基本部分。我们建议使用消息中间件来集成边界上下文，因为这自然会引导出更简单、解耦和事件驱动的架构。
