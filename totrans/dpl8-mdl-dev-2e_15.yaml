- en: Views
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 视图
- en: Views has always been a staple module for any Drupal site. It was so popular
    and needed that it ended up being incorporated into Drupal 8 core. So now, each
    new Drupal site ships with Views out of the box, fully integrated with the rest
    of the system and powering a great number of core features.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 视图一直是任何Drupal网站的标准模块。它如此受欢迎且必需，以至于最终被纳入Drupal 8核心。因此，每个新的Drupal网站都自带视图，完全集成到系统中，并支持大量核心功能。
- en: Essentially, Views is a tool for creating and displaying lists of data. This
    data can be almost anything, but we mostly use Drupal entities as they are now
    so robust. It provides the architecture to build and manipulate complex queries
    through the UI as well as many different ways of outputting the resulting data.
    From a module developer's point of View (yes, pun intended), much of this power
    has been broken down into multiple layers of building blocks, abstracted as plugins.
    Moreover, in keeping with tradition, there are also a multitude of hooks that
    are fired at different stages with which we can programmatically contribute to,
    or influence, Views.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 实质上，视图是一个用于创建和显示数据列表的工具。这些数据可以是几乎任何东西，但我们主要使用Drupal实体，因为它们现在非常健壮。它提供了通过UI构建和操纵复杂查询的架构，以及许多不同的输出结果数据的方式。从模块开发者的角度来看（是的，这里有一个双关语），大部分这种力量已经被分解成多个构建块层，抽象为插件。此外，按照传统，还有许多钩子在各个阶段被触发，我们可以通过编程方式对其进行贡献或影响视图。
- en: In this chapter, we will look at the Views ecosystem from a module developer's
    perspective. As such, we won't be spending that much time with its site-building
    capabilities as you can easily argue an entire book could be dedicated just to
    that. Instead, we will focus on what we, as module developers, can do to empower
    site builders to have even more capabilities at their finger-tips, as well as
    manipulating Views to behave the way our functionality needs them to.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将从模块开发者的角度来审视视图生态系统。因此，我们不会花太多时间在其网站构建功能上，因为你可以很容易地认为整本书都可以只针对这一点。相反，我们将专注于我们作为模块开发者可以做些什么来赋予网站构建者更多能力，以及如何操纵视图以符合我们功能的需求。
- en: So, what will we actually do in this chapter? We will first start with integrating
    our Product entity type with Views. The entity system and Views can work very
    closely together, and all we need to do is point them to one another. Then, we
    will switch gears and expose our own custom player and team data (from [Chapter
    8](c20b297a-3a37-46ff-a80c-bf83a21bbd5d.xhtml), *The Database API*) to Views so
    our site builders can build Views that list this information, complete with filters,
    sorts, arguments, and the *whole shebang*. From there, we will look at how we
    can also alter data that has been exposed to Views by other modules, like entity
    data such as Nodes.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，我们实际上在本章中会做什么呢？我们首先将开始将我们的产品实体类型与视图集成。实体系统和视图可以非常紧密地协同工作，我们只需要将它们指向对方。然后，我们将转换方向，将我们自己的自定义玩家和团队数据（来自[第8章](c20b297a-3a37-46ff-a80c-bf83a21bbd5d.xhtml)，*数据库API*）暴露给视图，以便我们的网站构建者可以构建列出这些信息的视图，包括过滤器、排序、参数和*所有一切*。从那里，我们将探讨如何修改其他模块暴露给视图的数据，如实体数据，例如节点。
- en: Next, we will learn how to create your own `ViewsField`, `ViewsFilter`, and
    `ViewsArgument` plugins to account for those occasional requirements for which
    the existing ones are a bit lacking. Finally, we will talk a little bit about
    theming Views and the main components that play a role in this, just to get you
    going in the right direction, and applying the lessons from [Chapter 4](feada4d1-f255-4dd6-83b5-8d66bab5f852.xhtml),
    *Theming*.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将学习如何创建自己的`ViewsField`、`ViewsFilter`和`ViewsArgument`插件，以应对那些现有插件略显不足的偶尔需求。最后，我们将简要讨论主题化视图及其在其中的主要组件，以便你能够正确地开始，并应用[第4章](feada4d1-f255-4dd6-83b5-8d66bab5f852.xhtml)，*主题化*中的教训。
- en: By the end of this chapter, you will get a pretty good understanding of how
    to leverage Views on top of your own data, as well as modifying or contributing
    to how other modules leverage it. You should also get a pretty good understanding
    of the Views plugin ecosystem, even if quite a bit of work will have to be done
    on your own, studying the available plugins of all types.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，你将很好地理解如何利用视图来处理自己的数据，以及修改或贡献其他模块如何利用它。你还应该对视图插件生态系统有一个相当好的理解，即使你将不得不自己做一些工作，研究所有类型的可用插件。
- en: So, let's get to it.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，让我们开始吧。
- en: Entities in Views
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 视图中的实体
- en: Even in Drupal 7, Views had a pretty good integration with the entity system.
    But seeing as there was no robust entity API to speak of, this integration was
    not so organic. It required more contributed modules and some custom code to make
    an entity type work with Views.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 即使在Drupal 7中，视图与实体系统的集成也相当不错。但由于当时没有强大的实体API，这种集成并不那么自然。它需要更多的贡献模块和一些自定义代码才能使实体类型与视图协同工作。
- en: 'In Drupal 8, however, the two are very closely linked and it''s a breeze to
    expose new content entities to Views. If you''ve followed along with [Chapter
    7](392cdb70-e52a-42d1-b782-28d6eb726810.xhtml), *Your Own Custom Entity and Plugin
    Types*, and have the Product entity type set up, you''ll notice that if you try
    to create a View, you will have no option to make it based on products. That is
    because, in the entity type definition, we did not specify that it should be exposed
    to Views. That''s all there is to it, actually. We just have to reference a new
    handler:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在Drupal 8中，两者非常紧密地联系在一起，将新的内容实体暴露给视图变得非常容易。如果你已经跟随了[第7章](392cdb70-e52a-42d1-b782-28d6eb726810.xhtml)，“你自己的自定义实体和插件类型”，并且已经设置了产品实体类型，你会注意到，如果你尝试创建一个视图，你将没有选项基于产品创建它。这是因为，在实体类型定义中，我们没有指定它应该被暴露给视图。实际上就是这样。我们只需要引用一个新的处理器：
- en: '[PRE0]'
  id: totrans-11
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: That's it. Clearing the cache, we are now able to create Views with products
    that can show any of the fields, can filter and sort by them, and can even render
    them using view modes. All of these work consistently with the other entity types
    (at least fundamentally, as we will see in a moment).
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 就这些。清除缓存后，我们现在能够创建可以显示任何字段、可以按其过滤和排序、甚至可以使用视图模式渲染产品的视图。所有这些都与其他实体类型（至少在基本层面上，我们将在下一刻看到）保持一致。
- en: You'll notice that we referenced the `EntityViewsData` data handler which ensures
    basic logic for entities of all types. If we want to, we can extend this class
    and add some of our own specificities to the data that is being exposed to Views
    (or alter the existing ones). This is done inside the `getViewsData()` method,
    and we will see an example later on. But if you already want to see an example,
    check out the `NodeViewsData` handler for the Node entity type, as it has quite
    a lot of extra stuff in there. Much of it probably won't make a lot of sense quite
    yet, so let's slowly get into how Views works by exposing our own custom data
    to it.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 你会注意到我们引用了`EntityViewsData`数据处理器，它确保了所有类型实体的基本逻辑。如果我们想，我们可以扩展这个类，并为暴露给视图的数据添加一些我们自己的特定性（或者改变现有的）。这是在`getViewsData()`方法中完成的，我们将在稍后看到示例。但如果你已经想看到示例，可以查看`NodeViewsData`处理器，因为对于节点实体类型，它里面有很多额外的东西。其中很多可能现在还没有太多意义，所以让我们通过将我们自己的自定义数据暴露给视图来慢慢了解视图是如何工作的。
- en: Exposing custom data to Views
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将自定义数据暴露给视图
- en: To get a better understanding of how Views works, we are going to look at an
    example of totally custom data and how we can expose it to Views. Based on that,
    we will begin to understand the role of various plugins and can begin to create
    our own. Additionally, we'll be able to expand on our product entity type data
    to enrich its Views interaction.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更好地理解视图是如何工作的，我们将查看一个完全自定义的数据示例以及我们如何将其暴露给视图。基于这一点，我们将开始理解各种插件的作用，并开始创建我们自己的。此外，我们还将能够扩展我们的产品实体类型数据，以丰富其视图交互。
- en: To exemplify all of this, we are going to revisit our sports module in which
    we declared the `players` and `teams` tables of data and which we will now be
    exposing to Views. The goal is to allow site builders to create dynamic listings
    of this data as they see fit. The lessons learned from this example can be applied
    to other data sources as well, even things such as remote APIs (with some extra
    work).
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 为了说明这一切，我们将重新访问我们的运动模块，其中我们声明了`players`和`teams`数据表，并且我们现在将它们暴露给视图。目标是允许网站构建者创建符合他们需求的动态数据列表。从这个例子中学到的经验可以应用于其他数据源，甚至是一些远程API（需要一些额外的工作）。
- en: Views data
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 查看数据
- en: Whenever we want to expose data to Views, we need to define this data in a way
    Views can understand it. That is actually what `EntityViewsData::getViewsData()`
    does for content entities. However, since we are dealing with something custom,
    we can do so by implementing `hook_views_data()`. A lot can go into it, but we'll
    start things simple.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 每当我们想要将数据暴露给视图时，我们需要以视图可以理解的方式定义这些数据。这正是`EntityViewsData::getViewsData()`对内容实体所做的事情。然而，由于我们正在处理一些自定义的，我们可以通过实现`hook_views_data()`来实现这一点。它可以包含很多东西，但我们将从简单开始。
- en: Let's implement this hook and simply describe our first table (that of the players)
    and only one field, namely, the player ID, to start with.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们实现这个钩子，并简单地描述我们的第一个表（玩家的表）以及仅一个字段，即玩家ID，作为开始。
- en: In Views lingo, the term `field` does not have to relate necessarily to entity
    fields or anything like that, but rather to an individual piece of data from a
    data source (real or not). A typical example to consider is a column in a table,
    but it can also be something like a property from a remote API resource. Moreover,
    the same term is used to describe the *responsibility* of that piece of data of
    being somehow output. Other such responsibilities it can have are `filter`, `sort`,
    `relationship`, and more. Each of these responsibilities are handled by a specific
    type of Views plugin (also known as a handler in older versions of Views).
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 在视图术语中，术语`field`不必必然与实体字段或类似的东西相关，而是与数据源（真实或非真实）中的单个数据片段相关。一个典型的例子是表中的一列，但它也可以是远程API资源中的属性。此外，相同的术语也用来描述该数据片段的*责任*，即以某种方式输出。它还可以有的其他责任包括`filter`、`sort`、`relationship`等。每个这些责任都由特定类型的视图插件（在视图的旧版本中也称为处理器）处理。
- en: 'So, the basic implementation can look like this:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，基本实现可以看起来像这样：
- en: '[PRE1]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: This hook needs to return a multi-dimensional associative array that describes
    various things, the most important being the table and its fields. The table doesn't
    have to be an actual database table, but can also mean something similar to an
    external resource. Of course, Views already knows how to query the database table,
    which makes things easy for us. Otherwise, we'd also have to create the logic
    for querying that external resource (by implementing a `ViewsQuery` plugin).
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 这个钩子需要返回一个多维关联数组，描述各种事物，其中最重要的是表及其字段。表不必是实际的数据库表，也可以指类似外部资源的东西。当然，视图已经知道如何查询数据库表，这使得事情对我们来说变得容易。否则，我们还需要创建查询该外部资源的逻辑（通过实现一个`ViewsQuery`插件）。
- en: 'So, we start by defining the `players` table, which goes into the `Sports`
    group. This label can be found in the Views admin as the prefix to the fields
    we want to add. Next, we define our first *base* table called `players` (mapping
    to the actual database table with the same name). The *base* table is the one
    used for *basing* a View on when creating it. In other words, whatever you select
    in the following screen text:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们首先定义`players`表，它属于`Sports`组。这个标签可以在视图管理员的字段前缀中找到，我们想要添加的字段的前缀。接下来，我们定义我们的第一个*基础*表，称为`players`（映射到具有相同名称的实际数据库表）。*基础*表是在创建视图时用于*基于*的表。换句话说，在以下屏幕文本中你选择的任何内容：
- en: '![](img/71b2315c-ca88-4d4f-b8f9-c22fd1515a5c.png)'
  id: totrans-25
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/71b2315c-ca88-4d4f-b8f9-c22fd1515a5c.png)'
- en: The base table definition contains some information, such as the `field` that
    refers to the column that contains the unique identifier for the records. `title`
    and `help`, both mandatory, are used in the UI. Moreover, it can also contain
    `query_id`, which references the plugin ID of a `ViewsQuery` plugin responsible
    for returning the data from the source in an intelligible way. Since, in our case,
    we are using the database (hence SQL), omitting this property will make it default
    to the `views_query` plugin (the `Sql` class if you want to check it out).
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 基础表定义包含一些信息，例如`field`，它指的是包含记录唯一标识符的列。`title`和`help`都是必填项，在UI中使用。此外，它还可以包含`query_id`，它引用负责以可理解的方式从源返回数据的`ViewsQuery`插件的插件ID。由于在我们的案例中，我们使用的是数据库（因此是SQL），省略此属性将使其默认为`views_query`插件（如果你想查看，是`Sql`类）。
- en: Views fields
  id: totrans-27
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 视图字段
- en: 'But in order to actually use this table, we need to define one or more fields
    that can output some of its data. So, we start with a simple one: the player IDs.
    Anything that comes under the `$data[''table_name'']` array (that is not keyed
    by `table`, as we''ve seen) is responsible for defining Views fields. The keys
    are their machine names. `title` and `help` are there again and are used in the
    UI when we try to add the respective fields:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 但为了实际使用这个表，我们需要定义一个或多个可以输出其部分数据的字段。因此，我们从简单的一个开始：玩家ID。任何在`$data['table_name']`数组中（如我们所见，不是以`table`为键）的内容都负责定义视图字段。键是它们的机器名。`title`和`help`再次出现，并在我们尝试添加相应字段时在UI中使用：
- en: '![](img/5e0b696c-6a4e-41f7-9d72-c938fd9c46c8.png)'
  id: totrans-29
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/5e0b696c-6a4e-41f7-9d72-c938fd9c46c8.png)'
- en: The most important part of this definition, however, is the `field` key, which
    basically says that, for this piece of data, we want a Views field that uses the
    `ViewsField` plugin with the ID `numeric` (`NumericField`). So, we don't actually
    have to write our own plugin because Views already has a good one for us and it
    will treat our IDs according to the type of data they are. Of course, when defining
    Views fields (or any other types of data responsibilities, that is, plugins or
    handlers), we can have more options than just the ID of the plugin to use.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这个定义中最重要的部分是`field`键，它基本上表示，对于这块数据，我们想要一个使用`ViewsField`插件且ID为`numeric`（`NumericField`）的视图字段。因此，我们实际上不需要编写自己的插件，因为视图已经为我们提供了一个很好的插件，并且它会根据数据的类型来处理我们的ID。当然，在定义视图字段（或任何其他类型的数据责任，即插件或处理器）时，我们可以有比仅使用插件ID更多的选项。
- en: You can check out all of the existing Views plugins defined by the module itself
    (which are quite a lot and fit many many use cases) by looking at the `Drupal\views\Plugin\views`
    namespace. There are many plugin types that handle different responsibilities,
    but it's good to know where you can look because, more often than not, one will
    already exist for your needs.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过查看模块本身定义的所有现有视图插件（这些插件相当多，适用于许多用例）来检查`Drupal\views\Plugin\views`命名空间。有许多插件类型处理不同的责任，但了解你可以查找的地方是很好的，因为很多时候，一个插件已经存在来满足你的需求。
- en: 'With this, we are done. Clearing the cache, we can now go into the Views UI
    and create our first View that shows player data. To it, we can add the ID field,
    which will then naturally just show a list of IDs. Not more, as we haven''t defined
    anything else. So, let''s go ahead and expose the player name in the same way:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这种方式，我们就完成了。清除缓存后，我们现在可以进入视图UI并创建我们的第一个显示球员数据的视图。我们可以向其中添加ID字段，然后它将自然地只显示ID列表。没有更多，因为我们没有定义其他任何内容。所以，让我们继续以同样的方式公开球员名字：
- en: '[PRE2]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: This time, we are using the `standard` plugin, which is the simplest one we
    can use. It essentially just outputs the data as it is found in the data source
    (with the proper sanitization in place). In the case of our player names, that
    is enough. Now we can add this new field to the View as well.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 这次，我们使用的是`standard`插件，这是我们可以使用的最简单的插件。它本质上只是将数据以它在数据源中的形式输出（并实施适当的清理）。在我们的球员名字的情况下，这已经足够了。现在我们可以将这个新字段添加到视图中。
- en: If you remember, the other column on our `players` table is one that can store
    arbitrary data in a serialized way. Obviously, this cannot be used for filtering
    or sorting, but we can still output some of that data as a field. There are two
    ways we can go about doing this, depending on our data and what we want accomplished.
    First, we can use the existing `Serialized` plugin which allows us to display
    the serialized data or even a given key from the resulting array (depending on
    the field configuration). But for more complex situations (especially when the
    data is arbitrary), we can write our own field plugin.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你记得，我们`players`表中的另一列可以以序列化的方式存储任意数据。显然，这不能用于过滤或排序，但我们仍然可以将其中的一些数据作为字段输出。根据我们的数据和想要实现的目标，我们可以有两种方法来做这件事。首先，我们可以使用现有的`Serialized`插件，它允许我们显示序列化的数据或结果数组中的给定键（取决于字段配置）。但对于更复杂的情况（尤其是当数据是任意的时候），我们可以编写自己的字段插件。
- en: 'Let''s start by creating a simple `data` field that can output a printed version
    of our serialized data since we cannot rely on the actual data being stored:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先创建一个简单的`data`字段，它可以输出序列化数据的打印版本，因为我们不能依赖于实际存储的数据：
- en: '[PRE3]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'In the field configuration, we then have these options to choose from:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 在字段配置中，我们有以下选项可供选择：
- en: '![](img/d30290d1-da25-41b8-bc8c-9dafcbe365bc.png)'
  id: totrans-39
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/d30290d1-da25-41b8-bc8c-9dafcbe365bc.png)'
- en: With this, you should already get a picture of how to define fields for output
    in Views. Let's now see how we can bring our teams into the loop and show some
    data about the teams the players belong to.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这种方式，你应该已经对如何在视图中定义输出字段有了大致的了解。现在让我们看看如何将我们的团队纳入循环，并展示一些关于球员所属团队的资料。
- en: Views relationships
  id: totrans-41
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 视图关系
- en: 'The data about the teams our players belong to is stored in a different table.
    This means that, at a database level, a join will have to be created to pull them
    together. In Views lingo this is a *relationship* in the sense that one table
    relates to another and the way these are declared is directional from a field
    to another from the joined table. So, let''s see how we can define the `team_id`
    field from the `players` table to join with the `teams` table on its `id` field:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 我们玩家所属的团队信息存储在不同的表中。这意味着，在数据库级别，必须创建一个连接来将它们拉在一起。在 Views 术语中，这是一个 `relationship`，意味着一个表与另一个表相关联，并且这些声明是从连接表中的一个字段指向另一个字段的。所以，让我们看看我们如何定义
    `players` 表中的 `team_id` 字段，以便与 `teams` 表的 `id` 字段连接：
- en: '[PRE4]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'First of all, we define it to Views as a field. Then, because we also might
    want to display the team ID, we can define it as a `field` as well using the `numeric`
    plugin, the same way we defined the ID of the player records themselves. But here
    comes another *responsibility* of this field in the form of a `relationship`,
    which requires four pieces of information:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将它定义为视图中的一个字段。然后，因为我们可能还想显示团队 ID，我们可以使用 `numeric` 插件将其定义为 `field`，就像我们定义玩家记录的
    ID 一样。但这里这个字段在形式上又多了一个 `relationship` 的责任，这需要四条信息：
- en: '`base`: The name of the table we are joining'
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`base`: 我们要连接的表名'
- en: '`base field`: The name of the field on the table we are joining that will be
    used to join'
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`base field`: 我们要连接的表上用于连接的字段名称'
- en: '`id`: The `ViewsRelationship` plugin ID to use for the relationship'
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`id`: 用于关系的 `ViewsRelationship` 插件 ID'
- en: '`label`: How this relationship will be labeled in the UI'
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`label`: 这个关系在 UI 中的标签'
- en: Usually, the `standard` relationship plugin will suffice, but we can always
    create one ourselves if we need to. It's doubtful you will ever need to though.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，`standard` 关系插件就足够了，但如果我们需要，我们总是可以自己创建一个。不过，你几乎不需要这么做。
- en: 'This definition now allows us to add a relationship to the `teams` table in
    Views. However, even if the database engine joins the two tables, we haven''t
    achieved anything as we also want to output some fields from the new table. So
    for that, we first have to define the table itself, as we did for the players:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 这个定义现在允许我们在 Views 中添加一个到 `teams` 表的关系。然而，即使数据库引擎连接了两个表，我们也没有达到目的，因为我们还想要输出新表的一些字段。所以，为了这个，我们首先必须定义这个表本身，就像我们为玩家所做的那样：
- en: '[PRE5]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Note that it is not mandatory to define it as a `base` table if we don''t want
    to create Views that are basing themselves on this table. In our case, it can
    be secondary to player information. Then, just as we did before, we can define
    a couple of team fields:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，如果我们不想创建基于这个表的视图，就不必将其定义为 `base` 表。在我们的情况下，它可以作为玩家信息的辅助。然后，就像我们之前所做的那样，我们可以定义几个团队字段：
- en: '[PRE6]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: There is nothing new here, just the basic data output for our two columns. But
    now, we can go to the View in the UI, add a relationship to the teams table and
    then include the name and description of the teams our players belong to. Neat.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 这里没有什么新的内容，只是我们两个列的基本数据输出。但现在，我们可以进入 UI 中的视图，将一个关系添加到团队表中，然后包括我们玩家所属的团队名称和描述。真不错。
- en: Views sorts and filters
  id: totrans-55
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 视图排序和筛选
- en: 'Let''s go ahead and enrich the *responsibilities* of the team name field by
    making our list of players filterable and sortable by it; for example, to only
    show the players of a given team or sort the players alphabetically by the team
    name. It could not be easier. We just have to add these to the team name field
    definition (like we added the `relationship` to the players'' `team_id` field):'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续丰富团队名称字段的 `responsibilities`，通过使我们的玩家列表可按团队名称筛选和排序；例如，只显示特定团队的玩家或按团队名称字母顺序排序玩家。这简直太简单了。我们只需将这些添加到团队名称字段定义中（就像我们添加到玩家的
    `team_id` 字段中的 `relationship` 一样）：
- en: '[PRE7]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: So basically, we are using the `Standard` sort plugin for sorting (which basically
    defaults to whatever MySQL can do). As for the filter, we are using the `StringFilter`
    plugin, which is quite configurable from the Views UI. It even allows us various
    filtering possibilities like partial matching. With this, we can now sort and
    filter by the team name.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 所以基本上，我们使用 `Standard` 排序插件进行排序（这基本上默认为 MySQL 可以做的任何事情）。至于筛选，我们使用 `StringFilter`
    插件，它可以从 Views UI 中进行相当多的配置。它甚至允许我们各种筛选可能性，如部分匹配。有了这个，我们现在可以按团队名称进行排序和筛选。
- en: Views arguments
  id: totrans-59
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 视图参数
- en: 'The last type of *responsibility* a View field can have is to be used as an
    argument (or a contextual filter for Drupal veterans). In other words, configuring
    the View to be filterable by a parameter that is dynamically passed to it. Let''s
    face it; most of the time, if we want to filter by a team, we won''t rely on the
    actual string name as that can change. Instead, we tie everything to the record
    (by its ID). So that means we''ll add the `argument` key to the `team_id` field
    of the `players` table (which also means that the query won''t require a join
    so it will be more performant):'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 视图字段可以拥有的最后一种责任是作为参数（或Drupal老手的上下文过滤器）使用。换句话说，配置视图以便可以通过动态传递给它的参数进行过滤。让我们面对现实；大多数时候，如果我们想按团队过滤，我们不会依赖于实际的字符串名称，因为这可能会改变。相反，我们将一切与记录（通过其ID）联系起来。这意味着我们将向`players`表的`team_id`字段添加`argument`键（这也意味着查询不需要连接，因此性能会更好）：
- en: '[PRE8]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: In this case, we use the `NumericArgument` plugin which does pretty much all
    we need for our data type—it filters by what is expected to be a numerical data
    type. And we are finished with that as well. We can now dynamically filter our
    players view by the ID of the teams they belong to.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们使用`NumericArgument`插件，它几乎为我们所需的数据类型做了所有事情——它通过预期的数值数据类型进行过滤。这样我们就完成了。现在我们可以通过球员所属的团队ID动态过滤我们的球员视图。
- en: Altering Views data
  id: totrans-63
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 修改视图数据
- en: We saw how we can expose to Views our own data that is totally custom. However,
    we can also alter existing data definitions provided by Drupal core or other modules
    by implementing `hook_views_data_alter()`. The `$data` parameter passed by reference
    will contain everything that has been defined and can be changed as needed.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 我们看到了如何将我们自己的完全定制的数据暴露给视图。然而，我们也可以通过实现`hook_views_data_alter()`来修改由Drupal核心或其他模块提供的现有数据定义。通过引用传递的`$data`参数将包含所有已定义的内容，可以根据需要进行更改。
- en: Moreover, we can also use this implementation to create some new Views fields
    or filters on other tables that do not "belong" to us. This is actually more common
    than exposing totally custom tables or other kinds of resources. For example,
    we may want to create a new Views field that shows something related to the Node
    in the results. So, let's look at an example.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们还可以使用这种实现来创建一些新的视图字段或过滤器，这些字段或过滤器位于不属于我们的其他表上。这实际上比暴露完全定制的表或其他类型的资源更常见。例如，我们可能想创建一个新的视图字段，显示与节点相关的某些内容。所以，让我们看看一个例子。
- en: Do you remember in [Chapter 6](77cab458-5612-468c-8010-12385708eb81.xhtml),
    *Data Modeling and Storage*, we saw how to create a *pseudo field,* which outputs
    a disclaimer message at the bottom of each Node? If our View is configured to
    render Node entities, that will work. However, if it's using fields, it cannot
    do that. So, let's see how we could expose this message also as a Views field.
    We won't include this in the final code, but let's just see how we could get it
    done if we wanted to.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 你还记得在[第6章](77cab458-5612-468c-8010-12385708eb81.xhtml)“数据建模和存储”中，我们是如何创建一个*伪字段*，在节点的底部输出免责声明消息的吗？如果我们的视图配置为渲染节点实体，那么这将有效。然而，如果它使用字段，则无法做到这一点。所以，让我们看看我们如何将此消息也暴露为视图字段。我们不会将其包含在最终代码中，但让我们看看如果我们想完成它，我们应该怎么做。
- en: 'First, we''d need to implement `hook_views_data_alter()` and define a new field
    on the Node entity type data table:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要实现`hook_views_data_alter()`并在节点实体类型数据表上定义一个新的字段：
- en: '[PRE9]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'In this example, we are adding our new Views field onto the Node data table
    (`node_field_data`). But then, we have a choice as to what plugin to use to render
    our message. We can, of course, create one ourselves (as we will do in the next
    section). This is actually very simple, especially since it doesn''t even need
    to use any of the information from the resulting Nodes. However, if that''s the
    case, we might as well use the existing `Custom` plugin, which has two main advantages.
    For one, we don''t have to write any more code. Second, it allows the site builder
    to specify (and modify as needed) the disclaimer message through the UI. Because
    basically, this plugin exposes a configuration form that we can use to add the
    text we want displayed for each row:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们将我们的新视图字段添加到节点数据表（`node_field_data`）上。但是，我们有一个选择，即使用哪个插件来渲染我们的消息。我们当然可以自己创建一个（正如我们将在下一节中做的那样）。这实际上非常简单，尤其是因为它甚至不需要使用任何来自结果节点的信息。然而，如果是这样的话，我们不妨使用现有的`Custom`插件，它有两个主要优点。一方面，我们不需要再写任何代码。第二，它允许网站构建者通过UI指定（并根据需要修改）免责声明消息。因为基本上，这个插件暴露了一个配置表单，我们可以用它来添加我们想要显示的每行的文本：
- en: '![](img/534627ad-2050-42b1-a076-6e32678a6d64.png)'
  id: totrans-70
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/534627ad-2050-42b1-a076-6e32678a6d64.png)'
- en: Of course, there are some drawbacks to this approach as well. If we wanted to
    ensure consistency between the message here and the one we used in the pseudo
    field, we would probably want to write our own plugin and get the message from
    this unique place. The same applies if we wanted the message to be strictly in
    code, especially if we needed some sort of data from the Node in the View results.
    So, the choice depends on the actual use case, but it's good to look into the
    existing Views plugins and see what already exists before creating your own.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，这种方法也有一些缺点。如果我们想确保这里的信息和我们在伪字段中使用的信息之间的一致性，我们可能需要编写自己的插件并从这个独特的地方获取信息。同样，如果我们想确保信息严格在代码中，特别是如果我们需要从视图结果中的节点获取某种数据时，这也适用。因此，选择取决于实际用例，但在创建自己的插件之前，查看现有的视图插件并了解它们已经存在的内容是很好的。
- en: Custom Views field
  id: totrans-72
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 自定义视图字段
- en: Now that we have seen how data is exposed to Views, we can start understanding
    the `NodeViewsData` handler I mentioned earlier (even if not quite everything)
    a bit better. But this also provides a good segue back to our `Product` entity
    type's `views_data` handler, where we can now see what the responsibility of `getViewsData()`
    is. It needs to return the definition for all of the tables and fields, as well
    as what they can do. Luckily for us, the base class already provides everything
    we need to turn our product data into Views fields, filters, sorts, arguments,
    and potentially relationships, all out of the box.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经看到了数据是如何暴露给视图的，我们可以开始更好地理解我之前提到的`NodeViewsData`处理器（即使不是全部）。但这同时也提供了一个很好的过渡，回到我们的`Product`实体类型的`views_data`处理器，我们现在可以看看`getViewsData()`方法的职责是什么。它需要返回所有表和字段的定义，以及它们能做什么。幸运的是，基类已经为我们提供了将我们的产品数据转换为视图字段、过滤器、排序、参数以及可能的关系所需的一切，一切现成。
- en: But let's say we want to add some more Views fields that make sense to us in
    the context of our product-related functionality. For example, each product has
    a `source` field that is populated by the Importer entity from its own `source`
    field. This is just to keep track of where they come from. So we may want to create
    a Views field that simply renders the name of the Importer that has imported the
    product.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 但假设我们想在产品相关功能上下文中添加一些对我们有意义的更多视图字段。例如，每个产品都有一个`source`字段，该字段由导入实体从其自身的`source`字段填充。这只是为了跟踪它们来自哪里。因此，我们可能想要创建一个视图字段，它简单地渲染导入产品的导入者名称。
- en: 'You''ll be quick to ask: *But hey, that is not a column on the products table!
    What gives?* As we will see, we can define Views fields that render whatever data
    we want (that can relate to the record or not). Of course, this also means that
    the resulting data cannot be used inside a sort or filter because MySQL doesn''t
    have access to it when building the query. So we are a bit less flexible there,
    but it makes sense.'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能会问：*但是，那不是产品表上的一个列！怎么回事？*正如我们将看到的，我们可以定义渲染我们想要的任何数据的视图字段（无论这些数据是否与记录相关）。当然，这也意味着，由于MySQL在构建查询时无法访问这些数据，因此结果数据不能用于排序或过滤。因此，我们在这一点上灵活性略低，但这是有道理的。
- en: 'In this section, you will learn two things. First, we''ll see how to create
    our own `views_data` handler for our Product entity type. By now, you should be
    quite familiar with this process. More importantly though, we''ll use this handler
    to create a new Views field for our products that renders something no existing
    `ViewsField` plugin can offer: the name of the related Importer entity. That means
    our own custom plugin. How exciting, so let''s get going!'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，您将学习两件事。首先，我们将看到如何为我们的产品实体类型创建自己的`views_data`处理器。到目前为止，您应该对这个过程相当熟悉。更重要的是，我们将使用这个处理器为我们的产品创建一个新的视图字段，该字段渲染现有`ViewsField`插件无法提供的功能：相关导入实体名称。这意味着我们的自定义插件。多么令人兴奋，让我们开始吧！
- en: 'There are two quick steps to create our own `views_data` handler. First, we
    need the class:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 创建我们自己的`views_data`处理器有两个快速步骤。首先，我们需要这个类：
- en: '[PRE10]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: As you can see, we are extending the base `EntityViewsData` class we had been
    referencing in the Product entity type annotation before. Inside, we are overriding
    the `getViewsData()` method to add our own definitions (which will go where you
    can see the comment).
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，我们正在扩展之前在产品实体类型注解中引用的基`EntityViewsData`类。在内部，我们正在重写`getViewsData()`方法以添加我们自己的定义（这些定义将放在您可以看到注释的地方）。
- en: 'Second, we need to change the handler reference to this new class in the entity
    type annotation:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 第二，我们需要在实体类型注解中更改处理器引用到这个新类：
- en: '[PRE11]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'That''s it. We can now define our own custom fields and we can start with the
    views data definition:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 就这些了。我们现在可以定义自己的自定义字段，并且我们可以从视图数据定义开始：
- en: '[PRE12]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Simple stuff, like we did with the players. Except in this case, we are adding
    it to the `product` table and we are using a `ViewsField` plugin that doesn't
    exist. Yet. So, let's create it.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 简单的事情，就像我们处理玩家时做的那样。只不过在这个案例中，我们要将它添加到`product`表中，并且我们正在使用一个还不存在的`ViewsField`插件。所以，让我们创建它。
- en: 'As you may have noticed if you checked some of the existing ones, Views plugins
    go in the `Plugin\views\[plugin_type]` namespace of the modules, where `[plugin_type]`
    in this case is `field`, as we are creating a `ViewsField` plugin. So, we can
    start with the plugin class scaffolding:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你可能注意到的，如果你检查了一些现有的，Views插件位于模块的`Plugin\views\[plugin_type]`命名空间中，其中`[plugin_type]`在这个案例中是`field`，因为我们正在创建一个`ViewsField`插件。所以，我们可以从插件类脚手架开始：
- en: '[PRE13]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Just like any other field plugin, we are extending the `FieldPluginBase` class
    which provides all the common defaults and base functionalities the fields need.
    Of course, you notice the admittedly small annotation, which simply contains the
    plugin ID. Our main job is to work in the `render()` method and output something,
    preferably using the `$values` object that contains all the data in the respective
    row.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 就像任何其他字段插件一样，我们正在扩展`FieldPluginBase`类，它提供了字段所需的所有常见默认值和基本功能。当然，你注意到的一个不可否认的小注释，它只包含插件ID。我们的主要工作是工作在`render()`方法中并输出一些内容，最好使用包含所有数据的相应行的`$values`对象。
- en: Inside the `ResultRow` object, we can find the values from the Views row which
    can contain multiple fields. In case it's a View that lists entities, we also
    have an `_entity` key that references the entity object itself.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 在`ResultRow`对象内部，我们可以找到来自Views行的值，这些值可能包含多个字段。如果是一个列出实体的视图，我们还有一个`_entity`键，它引用实体对象本身。
- en: 'Clearing the cache, we will now be able to add the new *Product Importer* field
    to a View for products. But if we do, we will notice an error. Views is trying
    to add to the query the `product_importer` field we defined but which doesn''t
    actually exist on the table. That isn''t right! This happens because, even though
    Views can be made to work with any data source, it still has a preference for
    the SQL database, so we can encounter these issues every once in a while. Not
    to worry though, as we can simply tell our plugin not to include the field in
    any query—it will show totally custom data. We do so by overriding the `query()`
    method:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 清除缓存后，我们现在能够将新的*产品导入器*字段添加到产品视图。但如果我们这样做，我们会注意到一个错误。Views试图将我们定义的`product_importer`字段添加到查询中，但实际上这个字段并不存在于表中。这是不正确的！这是因为，尽管Views可以与任何数据源一起工作，但它仍然偏好SQL数据库，所以我们有时会遇到这些问题。不过不用担心，因为我们可以简单地告诉我们的插件不要在查询中包含该字段——它将显示完全定制的数据。我们通过覆盖`query()`方法来实现这一点：
- en: '[PRE14]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'That''s it. Now, our field is going to render an empty string:`''''`. Let''s
    change it to look for the related Importer entity and show its label. But in order
    to do that, we''ll need the `EntityTypeManager` service to use for querying. Let''s
    inject it:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 就这些了。现在，我们的字段将渲染一个空字符串：`''`。让我们将其改为查找相关的导入实体并显示其标签。但为了做到这一点，我们需要使用`EntityTypeManager`服务进行查询。让我们注入它：
- en: '[PRE15]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Since we are operating inside a plugin, we need to make sure we are implementing
    the `ContainerFactoryPluginInterface` in order to make use of the `create()` method.
    But luckily, a parent class does so already, namely `Drupal\views\Plugin\views\PluginBase`,
    so we're good.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们正在插件内部操作，我们需要确保我们实现了`ContainerFactoryPluginInterface`，以便使用`create()`方法。但幸运的是，一个父类已经这样做了，即`Drupal\views\Plugin\views\PluginBase`，所以我们没问题。
- en: 'We do, however, have to also add the new *use* statements at the top:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，我们确实需要在顶部添加新的*use*语句：
- en: '[PRE16]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'We can now proceed with the `render()` method:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以继续使用`render()`方法：
- en: '[PRE17]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: We simply get the Product entity of the current row and then query for the Importer
    configuration entities that have the source referenced on the product. We assume
    there is only one (even if we did not do a proper job ensuring this is the case
    to save some space) and simply return its label. We also pass it through the helper
    `sanitizeValue()` method which takes care of ensuring that the output is safe
    against XSS attacks and such. So now our products View can show, for each product,
    the name of the Importer that brought them into application.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 我们简单地获取当前行的产品实体，然后查询具有在产品上引用的源的产品导入器配置实体。我们假设只有一个（即使我们没有做好确保这一点的工作以节省空间），然后简单地返回其标签。我们还通过
    `sanitizeValue()` 辅助方法传递它，该方法负责确保输出对XSS攻击等安全。因此，现在我们的产品视图可以显示每个产品的导入器名称，该导入器将它们引入应用程序。
- en: If we take a step back and try to understand what is going on, a word of caution
    becomes evident. Views performs one big query that returns a list of product entities
    and some data. But then, when that data is output, we perform a query for the
    Importer entity corresponding to each product in the result set (and we load those
    entities). So if we have 100 products returned, that means 100 more queries. Try
    to keep this in mind when creating custom fields to ensure you are not getting
    a huge performance hit, which might often not even be worth it.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们退后一步，试图理解正在发生的事情，一个警告变得明显。视图执行了一个大查询，返回了一个产品实体列表和一些数据。但是，当这些数据输出时，我们对结果集中的每个产品对应的导入器实体执行查询（并加载这些实体）。所以如果我们返回了100个产品，这意味着还有100个额外的查询。在创建自定义字段时，请记住这一点，以确保您不会得到巨大的性能损失，这往往甚至不值得。
- en: Field configuration
  id: totrans-100
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 字段配置
- en: We got our field working, but let's say we want to make it a bit more dynamic.
    At the moment it's called *Product Importer* and we are showing the title of the
    Importer entity. But let's make it configurable so that we can choose which title
    to show—that of the entity or that of the actual Importer plugin—in the UI.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经让字段工作正常了，但假设我们想要让它更加动态。目前它被称为 *产品导入器*，我们正在显示导入器实体的标题。但让我们使其可配置，以便我们可以在UI中选择要显示的标题——实体的标题或实际的导入器插件的标题。
- en: There are a few simple steps for making the field plugin configurable. These
    work similarly to other Views plugin types. They are also quite similar in concept
    to what we did in [Chapter 9](f58fb5b9-3f39-4575-872d-c2ab9985828d.xhtml), *Custom
    Fields*, when we made the entity fields configurable.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 使字段插件可配置有几个简单的步骤。它们与其他视图插件类型的工作方式类似。在概念上，它们也与我们在[第9章](f58fb5b9-3f39-4575-872d-c2ab9985828d.xhtml)，“自定义字段”中做的类似，当时我们使实体字段可配置。
- en: 'First, we need to define some default options by overriding a method:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要通过覆盖方法来定义一些默认选项：
- en: '[PRE18]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: As you can see, we are adding to the options defined by the parent class (which
    are quite a few) our own `importer` one. And we set its default to the string
    `entity`. Our choice.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，我们向父类定义的选项（相当多）中添加了自己的 `importer` 选项。并将其默认值设置为字符串 `entity`。这是我们的选择。
- en: 'Second, we need to define the form element for our new option and we can do
    this with another method override:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 其次，我们需要为新选项定义表单元素，我们可以通过另一个方法覆盖来实现：
- en: '[PRE19]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'And the *use* statement:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 以及 *use* 语句：
- en: '[PRE20]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Nothing special here; we are simply defining a select list form element on the
    main options form. We can see that the `$options` class property contains all
    the plugin options and there we can check for the default value of our `importer`
    one. Finally, we of course add to the form all the other elements from the parent
    definition.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 这里没有特别之处；我们只是在主选项表单上定义了一个选择列表表单元素。我们可以看到 `$options` 类属性包含所有插件选项，在那里我们可以检查我们
    `importer` 的默认值。最后，我们当然将父定义中的所有其他元素添加到表单中。
- en: 'Next, inside the `render()` method, once we get our hands on the importer entity,
    we can make a change to this effect:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，在 `render()` 方法内部，一旦我们掌握了导入器实体，我们可以进行以下更改：
- en: '[PRE21]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Pretty simple. We either show the entity label or that of the plugin. But of
    course—and we skipped this—the Importer plugin manager also needs to be injected
    into the class. I'll let you handle that on your own as you already know how to
    do this.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 非常简单。我们要么显示实体标签，要么显示插件的标签。但当然——我们跳过了这一点——导入器插件管理器也需要注入到类中。我将让您自己处理这个问题，因为您已经知道如何做到这一点。
- en: 'Finally, one last thing we need to do is define the configuration schema. Since
    our View (which is a configuration entity) is now being saved with an extra option,
    we need to define the schema for the latter. We can do this inside a new `products.schema.yml`
    file (in the `config/schema` folder of our module):'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们还需要做的一件事是定义配置模式。由于我们的视图（它是一个配置实体）现在正带着一个额外的选项被保存，我们需要定义后者的模式。我们可以在一个新文件`products.schema.yml`（位于我们模块的`config/schema`文件夹中）内完成这项工作：
- en: '[PRE22]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'This should already be familiar to you, including the dynamic nature of defining
    configuration schemas. We pretty much did the same in [Chapter 9](f58fb5b9-3f39-4575-872d-c2ab9985828d.xhtml),
    *Custom Fields*, for the options on our field type, widget, and formatter plugins.
    This time, though, the type is `views_field`, from which we basically inherit
    a bunch of definitions and to which we add our own (the `importer` string). That''s
    it. If we configure our new Views field, we should see this new option:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 这应该已经让你很熟悉了，包括定义配置模式的动态性。我们在[第9章](f58fb5b9-3f39-4575-872d-c2ab9985828d.xhtml)，*自定义字段*中，为我们的字段类型、小部件和格式化插件上的选项做了同样的事情。不过，这次类型是`views_field`，我们从其中基本继承了大量的定义，并添加了我们自己的（`importer`字符串）。就是这样。如果我们配置我们的新视图字段，我们应该会看到这个新选项：
- en: '![](img/8fd7a929-eeb1-45bf-8714-cc9fdebcab72.png)'
  id: totrans-117
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/8fd7a929-eeb1-45bf-8714-cc9fdebcab72.png)'
- en: Custom Views filter
  id: totrans-118
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 自定义视图过滤器
- en: In a previous section we exposed our `players` and `teams` tables to Views,
    as well as made the team name a possible string filter to limit the resulting
    players by team. But this was not the best way we could have accomplished this
    because site builders may not necessarily know all the teams that are in the database,
    nor their exact names. So we can create our own `ViewsFilter` to turn it into
    a selection of teams the user can choose from. Kind of like a taxonomy term filter.
    So let's see how it's done.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的部分中，我们将我们的`players`和`teams`表暴露给了视图，以及将团队名称作为一个可能的字符串过滤器来限制通过团队筛选出的球员。但这并不是我们能达到的最佳方式，因为站点构建者可能不一定知道数据库中所有的团队，也不知道它们的准确名称。因此，我们可以创建自己的`ViewsFilter`，将其转换为用户可以选择的团队选择。有点像分类术语过滤器。那么，让我们看看它是如何实现的。
- en: 'First, we need to alter our data definition for the team name field to change
    the plugin ID that will be used for the filtering (inside `hook_views_data()`):'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要修改团队名称字段的定义，以更改用于过滤的插件ID（在`hook_views_data()`内部）：
- en: '[PRE23]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Now we just have to create that plugin. And naturally, it goes in the `Plugin/views/filter`
    namespace of our module:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们只需要创建那个插件。自然地，它位于我们模块的`Plugin/views/filter`命名空间中：
- en: '[PRE24]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: First and foremost, we see the annotation is in place to make this a plugin.
    Similar to the Views fields. Then, we use dependency injection to get our hands
    on the database connection service. Nothing new so far. However, you will notice
    that we extend from the `InOperator` class which provides the base functionality
    for a Views filter that allows an `IN` type of filter. For example, `... WHERE
    name IN(name1, name2)`. So we extend from there to inherit much of this logic
    that applies to Views.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们看到注释已经到位，使其成为一个插件。类似于视图字段。然后，我们使用依赖注入来获取数据库连接服务。到目前为止没有什么新东西。然而，你会注意到我们扩展了`InOperator`类，它为允许`IN`类型过滤的视图过滤器提供了基本功能。例如，`...
    WHERE name IN(name1, name2)`。所以我们从那里扩展以继承适用于视图的大部分逻辑。
- en: Then, we override the `init()` method (which initializes the plugin) in order
    to set the available values that site builders can choose from (the team names)
    and a title for the resulting form element. But we do so by specifying an `options
    callback` that will be used to retrieve the options at the right moment. This
    callback is a method on our class called `getTeams()` which returns an array of
    all the team names. This array needs to be keyed by the value to use in the query
    filter. And that is pretty much it. We don't need to worry about the options form
    or anything like that. The base class does it all for us.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们覆盖了`init()`方法（该方法用于初始化插件），以便设置站点构建者可以选择的可用值（团队名称）以及结果表单元素的标题。但我们通过指定一个`options
    callback`来实现，该回调将在正确的时间点检索选项。这个回调是我们类上的一个方法，名为`getTeams()`，它返回所有团队名称的数组。这个数组需要根据查询过滤器中使用的值进行键控。就是这样。我们不需要担心选项表单或类似的东西。基类为我们处理了一切。
- en: 'Now, site builders can add this filter and choose a team (or more) to filter
    by, in an inclusive way. For example, to show the players that belong to a respective
    team:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，站点构建者可以添加这个过滤器，并选择一个团队（或多个）进行过滤，以包容性的方式。例如，要显示属于相应团队的球员：
- en: '![](img/f2a78867-c57d-4de7-ae88-a618a1760539.png)'
  id: totrans-127
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/f2a78867-c57d-4de7-ae88-a618a1760539.png)'
- en: Instead of using the `options callback`, we could have also directly overridden
    the `getValueOptions()` method of the parent (which in fact calls the options
    callback itself). The only caution here is that to prevent performance leaks,
    the values should be stored in the local `valueOptions` class property. Like this,
    they can be read multiple times.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 而不是使用`options callback`，我们也可以直接覆盖父类的`getValueOptions()`方法（实际上它会调用选项回调）。这里的唯一注意事项是，为了防止性能泄漏，值应该存储在局部的`valueOptions`类属性中。这样，它们可以被多次读取。
- en: 'Even if it''s not that obvious, one last thing we need to do is define the
    configuration schema for our filter. You may be wondering why we are not creating
    any custom options. The answer is that when the user adds the filter and chooses
    a team to filter by, Drupal doesn''t know what data type that value is. So, we
    need to tell it that it''s a string. Inside our `sports.schema.yml` file, we can
    have this:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 即使这不是那么明显，我们还需要做的一件事是为我们的过滤器定义配置模式。你可能想知道为什么我们不创建任何自定义选项。答案是，当用户添加过滤器并选择一个团队进行过滤时，Drupal不知道该值的数据类型。因此，我们需要告诉它它是一个字符串。在我们的`sports.schema.yml`文件中，我们可以有如下内容：
- en: '[PRE25]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Similar to the Views field, we have a dynamic schema definition for the filter,
    of the type `views_filter`. In the mapping we override the `value` field (which
    has already been defined by the `views_filter` data type). In our case, this is
    a sequence (an array with unimportant keys) whose individual values are strings.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 与视图字段类似，我们有一个动态的`views_filter`类型模式定义。在映射中，我们覆盖了`value`字段（该字段已经被`views_filter`数据类型定义）。在我们的情况下，这是一个序列（一个带有不重要键的数组），其个别值是字符串。
- en: 'Another way we can achieve the same (or similar) is like this:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种实现相同（或类似）效果的方法是这样的：
- en: '[PRE26]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: This is because, in the definition of the `value` key found in the `views_filter`
    schema, the type is set to `views.filter_value.[%parent.plugin_id]`. This means
    that we can simply define the `views.filter_value.team_filter` data type ourselves
    for it to use. If you remember, this is very similar to what we did ourselves
    in [Chapter 12](ca6e92fc-24fa-41b4-bd57-c3884f9d16b1.xhtml), *JavaScript and Ajax
    API*. So, we can just define that missing bit as our sequence, rather than overriding
    the entire thing to change one small bit.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 这是因为，在`views_filter`模式中找到的`value`键的定义中，类型被设置为`views.filter_value.[%parent.plugin_id]`。这意味着我们可以简单地为自己定义`views.filter_value.team_filter`数据类型，以便它可以使用。如果你还记得，这与我们在[第12章](ca6e92fc-24fa-41b4-bd57-c3884f9d16b1.xhtml)中自己做的非常相似，即*JavaScript和Ajax
    API*。因此，我们只需定义那缺失的部分作为我们的序列，而不是覆盖整个结构来改变一小部分。
- en: The existing Views filter classes provide a great deal of capability for either
    using them directly for custom data or extending to complement our own specificities.
    So I recommend you check out all the existent filter plugins. However, the main
    concept of a filter is the alteration of the query being run by Views, which can
    be done inside the `query()` method of the plugin class. There, we can add extra
    conditions to the query based on what we need. You can check out this method on
    the `FilterPluginBase` class which simply adds a condition (using the `addWhere()`
    method on the query object) based on the configured value and operator.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 现有的视图过滤器类提供了大量的能力，既可以直接用于自定义数据，也可以扩展以补充我们自己的特定需求。因此，我建议你查看所有现有的过滤器插件。然而，过滤器的主要概念是改变视图执行的查询，这可以在插件类的`query()`方法中完成。在那里，我们可以根据需要向查询添加额外的条件。你可以在`FilterPluginBase`类上查看这个方法，它简单地根据配置的值和操作符使用查询对象的`addWhere()`方法添加一个条件。
- en: Custom Views argument
  id: totrans-136
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 自定义视图参数
- en: When we first exposed the player and team data to Views, we used an argument
    plugin so that we could have a contextual filter on the team ID a player belongs
    to. To do this, we used the existing `numeric` plugin on the actual `team_id`
    field of the `players` table. But what if we wanted an argument that works on
    more levels? For example, we don't exactly know what kind of data we'll receive,
    but we want to be able to handle nicely both a numeric one (team ID) and a textual
    one (team name). All in one argument. To achieve this, we can create a simple
    `ViewsArgument` plugin to handle this for us.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们最初将玩家和团队数据暴露给视图时，我们使用了一个参数插件，这样我们就可以对玩家所属的团队ID进行上下文过滤。为此，我们使用了现有的`numeric`插件在`players`表的`team_id`实际字段上。但如果我们想要一个在更多层面上工作的参数呢？例如，我们并不确切知道我们会收到什么类型的数据，但我们希望能够很好地处理一个数值型（团队ID）和一个文本型（团队名称）。全部在一个参数中。为了实现这一点，我们可以创建一个简单的`ViewsArgument`插件来为我们处理这个问题。
- en: 'First thing, like always, is to define this field. We don''t want to mess with
    the `team_id` field onto which we added the earlier argument as that can still
    be used. Instead, we''ll create a new field, this time on the `teams` table, which
    we will simply call `team`:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，就像往常一样，是定义这个字段。我们不希望干扰我们之前添加了参数的`team_id`字段，因为这个仍然可以使用。相反，我们将创建一个新的字段，这次是在`teams`表上，我们将简单地称之为`team`：
- en: '[PRE27]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: This time, though, we don't create a *field* for it as we don't need this to
    display anything. Rather, we stick just to the `argument` responsibility, which
    will be handled by our new `team` plugin. You may also note that the `team` column
    doesn't actually exist in the database table.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 这次，我们不会为它创建一个*字段*，因为我们不需要显示任何内容。相反，我们只坚持`argument`责任，这将由我们新的`team`插件处理。你也许也会注意到，`team`列实际上并不存在于数据库表中。
- en: 'So, let''s see the plugin:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，让我们看看这个插件：
- en: '[PRE28]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: As usual, we are extending from the base plugin class of its type and adding
    the proper annotation. Inside, we only deal with the `query()` method, which we
    override. Arguments are very similar to filters in the sense that they aim to
    restrict the result set via the query. The main difference is the actual value
    used to filter, which, in this case, is dynamic and can be found on the `$argument`
    property of the (parent) class. And what we do is simply add a query condition
    to the right field on the `teams` table (since that is the base table), depending
    on the type of data we are dealing with. But before we do that, we call the `ensureMyTable()`
    method which simply ensures that the table our plugin needs is included in the
    query by Views.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: '如同往常，我们扩展了其类型的基插件类并添加了适当的注解。在内部，我们只处理`query()`方法，我们重写了它。参数与过滤器在意义上非常相似，因为它们旨在通过查询来限制结果集。主要区别在于实际用于过滤的值，在这种情况下，它是动态的，可以在（父）类的`$argument`属性中找到。我们所做的是简单地给`teams`表（因为那是基表）的相应字段添加一个查询条件，这取决于我们处理的数据类型。但在我们这样做之前，我们调用`ensureMyTable()`方法，这个方法简单地确保我们的插件需要的表被Views查询包含。 '
- en: That's it. We can now add our newly created argument to the View and, regardless
    of what we passed as a contextual filter (ID or name), it will filter accordingly.
    Of course, we can also have options like most other Views plugin types, but I'll
    let you explore those on your own. There are also a lot more we can override from
    the parent class in order to integrate with Views. But that's a bit more advanced
    and it's unlikely you'll need to deal with that for a good while. I definitely
    recommend exploring the code behind it.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 就这些了。我们现在可以将我们新创建的参数添加到视图中，无论我们传递了什么上下文过滤器（ID或名称），它都会相应地过滤。当然，我们也可以像大多数其他Views插件类型一样有选项，但我会让你自己探索那些。我们还可以从父类中重写更多内容以与Views集成。但这有点更高级，而且你不太可能需要处理很长时间。我确实建议探索其背后的代码。
- en: Views theming
  id: totrans-145
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 视图主题
- en: Frontend developers felt a lot of pain in Drupal 7 and much of it was also related
    to theming Views output. Luckily, Drupal 8 has made things much easier to handle.
    We will look at a bit of that here in order to nudge you in the right direction
    when applying what you learned in [Chapter 4](feada4d1-f255-4dd6-83b5-8d66bab5f852.xhtml),
    *Theming*.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 前端开发者曾在Drupal 7中感到很多痛苦，其中很大一部分也与视图主题有关。幸运的是，Drupal 8使事情处理起来容易得多。我们将在这里看看一些内容，以便在你应用在[第4章](feada4d1-f255-4dd6-83b5-8d66bab5f852.xhtml)，*主题化*中学到的知识时，能给你正确的方向。
- en: Views is very complex and is made up of many pluggable layers. A View has a
    *display* (such as a Page or Block), which can render its content using a given
    *style* (such as an Unformatted list or Table). Styles can decide whether to control
    the rendering of a given result item (row) themselves or delegate this to a *row*
    plugin (such as Fields or Entity). Most, in fact, do the latter. The two most
    common scenarios for using *row* plugins is either using the `EntityRow` one,
    which renders the resulting entities using a specified view mode, or the `Fields`
    plugin, which uses individual `ViewField` plugins to render each field that is
    added to the View.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: Views非常复杂，由许多可插拔层组成。一个视图有一个*显示*（如页面或块），可以使用给定的*样式*（如无格式列表或表格）来渲染其内容。样式可以决定是否控制给定结果项（行）的渲染，或者委托给*行*插件（如字段或实体）。实际上，大多数都这样做。使用*行*插件的最常见场景是使用`EntityRow`，它使用指定的视图模式渲染结果实体，或者使用`Fields`插件，它使用单个`ViewField`插件来渲染添加到视图中的每个字段。
- en: If we wanted to theme a View, there are all these points we can look at. Want
    the View to output a slideshow? Perhaps create a new *style* plugin. Want to do
    something crazy with each entity in the result set? Maybe create a new *row* plugin,
    or even just create a new *field* plugin (as we did) to render one piece of data
    in any way you want. These techniques are more oriented toward module developers
    taking control over Views. But we also have the theming aspects we can play with.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想要为主题化视图，我们可以查看所有这些点。想要视图输出幻灯片吗？也许创建一个新的*样式*插件。想要对结果集中的每个实体进行疯狂的操作？也许创建一个新的*行*插件，或者甚至只创建一个新的*字段*插件（就像我们做的那样）以以任何你想要的方式渲染一块数据。这些技术更多地面向模块开发者对视图的控制。但我们也有可以玩转的主题方面。
- en: 'Again, from the top, *style* plugins are nothing more than glorified wrappers
    over a theme hook. For example, the *Unformatted list* plugin uses the `views_view_unformatted`
    theme hook, which means a few things: it can be overridden by a theme (or even
    module) and it can be preprocessed by a theme or module. Take a look at the default
    `template_preprocess_views_view_unformatted()` preprocessor and `views-view-unformatted.html.twig`
    template file for more information. Don''t forget about the theme hook suggestions,
    as Views defines quite a lot of them. All you need to do is enable theme (Twig)
    debugging and you''ll see for each View *layer* which template is being used.'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 再次从顶部开始，*样式*插件不过是主题钩子的美化包装。例如，*未格式化列表*插件使用`views_view_unformatted`主题钩子，这意味着几件事情：它可以被主题（甚至模块）覆盖，并且可以被主题或模块预处理。查看默认的`template_preprocess_views_view_unformatted()`预处理程序和`views-view-unformatted.html.twig`模板文件以获取更多信息。不要忘记主题钩子建议，因为视图定义了相当多的它们。你所需要做的就是启用主题（Twig）调试，你将看到每个视图*层*正在使用哪个模板。
- en: The *style* theme, however, only gets us to the wrapper around all the results.
    To go a bit deeper, we need to know what kind of *row* plugin it uses. If entities
    are being rendered, it's the same thing as controlling how entities are built.
    See [Chapter 6](77cab458-5612-468c-8010-12385708eb81.xhtml), *Data Modeling and
    Storage*, for a refresher on that. If the *row* plugin uses *field* plugins, we
    have some options. First of all, this is also a wrapper over a theme hook, namely
    `views_view_fields`, which renders together all the *field* plugins added to the
    View.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，*样式*主题只能让我们到达所有结果的包装层。要深入一点，我们需要知道它使用的是哪种*行*插件。如果实体正在渲染，那么这与控制实体构建的方式相同。参见[第6章](77cab458-5612-468c-8010-12385708eb81.xhtml)，*数据建模与存储*，以复习相关内容。如果*行*插件使用*字段*插件，我们有一些选项。首先，这同样是一个主题钩子的包装，即`views_view_fields`，它渲染了添加到视图中的所有*字段*插件。
- en: So we can override that using the already known theming methods. But we can
    also override the default theme hook for each `field` plugin itself, namely `views_view_field`,
    responsible for wrapping the output of the plugin. This takes us to the *field*
    plugins themselves and whatever they end up rendering, which can differ from one
    plugin to another. So, make sure you check that.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们可以使用已知的主题方法来覆盖它。但我们也可以覆盖每个`字段`插件的默认主题钩子，即`views_view_field`，它负责包装插件的输出。这带我们到*字段*插件本身以及它们最终渲染的内容，这可能会因插件而异。所以，请确保检查这一点。
- en: Views hooks
  id: totrans-152
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 视图钩子
- en: Views also comes with a lot of hooks. We've already seen an important one that
    allowed us to expose our own data to Views. But there are many more, and you should
    check out the `views.api.php` file for more information.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 视图还附带了许多钩子。我们已经看到了一个重要的钩子，它允许我们将自己的数据暴露给视图。但还有更多，你应该查看`views.api.php`文件以获取更多信息。
- en: Quite a few exist for altering plugin information for all sorts of plugin types.
    But there are also some important ones that deal with Views execution at runtime.
    The most notable of these is `hook_views_query_alter()` which allows us to make
    alterations to the final query that is going to be run. There is also `hook_views_post_render()`
    and `hook_views_pre_render()`, which allow us to make alterations to the View
    results. For example, to change the order of the items or something like that.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 许多用于更改各种插件类型的插件信息。但也有一些重要的钩子，它们在运行时处理视图的执行。其中最值得注意的是`hook_views_query_alter()`，它允许我们对即将运行的最终查询进行修改。还有`hook_views_post_render()`和`hook_views_pre_render()`，它们允许我们对视图结果进行修改。例如，更改项目顺序或类似的事情。
- en: I recommend you check out their respective documentation and make yourself aware
    of what you can do with these hooks. At times they can be helpful, even if, with
    Drupal 8, most of the action happens in plugins and you can easily now write your
    own to handle your specific requirements. This is why we won't be going into great
    detail about these.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 我建议您查看他们各自的文档，并了解您可以使用这些钩子做什么。有时它们可能会有所帮助，尽管在Drupal 8中，大部分动作都发生在插件中，您现在可以轻松地编写自己的插件来处理您的特定需求。这就是为什么我们不会对这些内容进行详细说明。
- en: Summary
  id: totrans-156
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we looked at Views from all sorts of module developer-oriented
    angles. We saw how we can expose our product entity type to Views. That was a
    breeze. But then, we also saw how our custom player and team data from [Chapter
    8](c20b297a-3a37-46ff-a80c-bf83a21bbd5d.xhtml), *The Database API*, can be exposed
    to Views. Even if we did have to write some code for that, much of it was quite
    boilerplate, as we were able to leverage the existing Views plugin ecosystem for
    almost everything we wanted. However, since these are all plugins, we also saw
    how we can create our own field, filter, and argument plugins to handle those
    exceptional cases in which what exists may not be enough.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们从各种面向模块开发者的角度探讨了视图。我们看到了如何将我们的产品实体类型暴露给视图。这很简单。但是，我们也看到了如何将来自第8章[《数据库API》](c20b297a-3a37-46ff-a80c-bf83a21bbd5d.xhtml)的定制播放器和团队数据暴露给视图。即使我们必须为此编写一些代码，其中大部分都是相当模板化的，因为我们能够利用现有的视图插件生态系统来处理我们想要的几乎所有事情。然而，由于这些都是插件，我们也看到了如何创建我们自己的字段、筛选和参数插件来处理那些现有内容可能不足以应对的异常情况。
- en: Closely tied to this, we also talked a bit about altering the way other modules
    expose their data to Views. The most notable example here was the ability to easily
    add more fields (and plugins) to entity-based Views in order to enrich them with
    custom functionalities.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 与此密切相关，我们还简要讨论了如何更改其他模块向视图暴露数据的方式。这里最显著的例子是能够轻松地向基于实体的视图中添加更多字段（和插件），以丰富其自定义功能。
- en: Finally, we talked a bit about how we can approach the theming aspect of Views.
    We saw the different layers that make one up, starting from the display all the
    way down to the *field*. We closed the chapter with a shout-out to the existing
    hooks the Views module invokes at various times, and via which we can also make
    changes to its normal operation.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们简要讨论了如何处理视图的主题方面。我们看到了构成视图的不同层次，从显示层一直到*字段*。我们以对视图模块在各个时间点调用的现有钩子的提及来结束本章，通过这些钩子我们也可以对其正常操作进行更改。
- en: In the next chapter, we are going to see how we can work with files and images
    in Drupal 8.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将看到如何在Drupal 8中处理文件和图像。
