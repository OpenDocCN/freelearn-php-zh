["```php\n<?php \n\n// This non existing method throws a couple of Exception, which  \n// is a PDOException, BadMethodCallException and probably more.\ntry {\n  $object->executeMe();\n} catch(PDOException $e) {\n  // We catch the most specific Exception first, as this is an \n  // Exception that has to do with a database query that went wrong\n} catch(BadMethodCallException $e) {\n  // Next up this one, as this tells us that we have done \n  // something wrong when calling this method, maybe we forgot \n  // some arguments, or the method might not exist?\n} catch(Exception $e) {\n  // We don't know what is going wrong, but we know something did \n  // go wrong. Perhaps we just want to log this, or handle it on \n  // another way?\n}\n```", "```php\n<?php\n  use Zend\\Mvc\\Application;\n  use Zend\\Mvc\\MvcEvent;\n\n  // We'll skip the beginning of the file as it has no \n  // effect on us\nclass Module\n{\n  // We want to add/create the onBootstrap method to put \n  // our event attachment in\n  public function onBootstrap(MvcEvent $e)\n  {\n    // Get the event manager from the application\n    $eventManager = $e->getApplication()\n                      ->getEventManager();\n\n    // Make sure our module router listens to our event \n    // manager as well\n    $moduleRouteListener = new ModuleRouteListener();\n    $moduleRouteListener->attach($eventManager);\n\n    // Get the service manager for later use\n    $serviceManager = $e->getApplication()\n                        ->getServiceManager();\n\n    // Attach our handler to the events  \n    $eventManager->attach(\n        // What events do we want to attach to\n        array(\n          MvcEvent::EVENT_DISPATCH_ERROR,\n          MvcEvent::EVENT_RENDER_ERROR,\n        ),  \n\n        // What class and method do we want to trigger\n        array($this, 'handleException')\n    ); \n  }\n\n  // This is the method we use to handle the exception\n  public function handleException(MvcEvent $event) \n  {\n    // Make sure the error is an exception, otherwise \n    // it might be some other parameter in the event\n       if ($event->getError() === Application::ERROR_EXCEPTION) {\n      // Now get the exception from the event\n      $exception = $event->getParam('exception');\n\n      // Do whatever with this exception \n    }\n  }\n\n  // Again, we are not bothered by the rest of the \n  // Module class\n}\n```", "```php\n\"firephp/firephp-core\" : \"dev-master\"\n```", "```php\nreturn array( \n  // We want to put our logger in the service manager\n  'service_manager' => array(\n    'factories' => array(\n      // We will call our logger 'log' so we can find it \n      // easily back in our application\n      'log' => function () {\n        // Instantiate our logger\n        $log = new Zend\\Log\\Logger();\n\n        // Add the writer to our logger (don't forget to  \n        // make the data directory writable)\n        $log->addWriter(new Zend\\Log\\Writer\\Stream(\n            getcwd(). '/data/application.log'\n        ));\n\n        // Return our logger now\n        return $log;\n      },\n    ),\n  ),\n);\n```", "```php\n<?php\n\nnamespace Application\\Controller;\n\nuse Zend\\Mvc\\Controller\\AbstractActionController;\nuse Zend\\View\\Model\\ViewModel;\n\nclass IndexController extends AbstractActionController \n{\n  public function indexAction() \n  {\n    $this->getServiceLocator()\n         ->get('log')\n         ->debug(\"A Debug Log Message\");\n  }\n}\n```", "```php\n// As we can see we can just change (or add if \n// we want more loggers) the log writer to FirePHP.\n$log->addWriter(new Zend\\Log\\Writer\\FirePhp());\n```", "```php\n2013-03-04T13:58:38+02:00 DEBUG (7): A Debug Log Message\n```", "```php\n/**\n * @const int defined from the BSD Syslog message severities\n * @link http://tools.ietf.org/html/rfc3164\n */\nconst EMERG  = 0;\nconst ALERT  = 1;\nconst CRIT   = 2;\nconst ERR    = 3;\nconst WARN   = 4;\nconst NOTICE = 5;\nconst INFO   = 6;\nconst DEBUG  = 7;\n```", "```php\n{\n  \"require-dev\": {\n    \"phpunit/phpunit\": \"3.7.*\"\n  }\n}\n```", "```php\n$ php composer.phar update\n```", "```php\npublic function testIsAdult()\n{\n  // Initialize our Person\n  $person = new Person();\n\n  // Our first fail test that makes sure that when no \n  // parameters are given the test will result in false\n  assertFalse($person->isAdult());\n}\n```", "```php\nPHPUnit 3.7.9 by Sebastian Bergmann.\n\nF\n\nFAILURES!\nTests: 1, Assertions: 1, Failures: 3.\n\n```", "```php\npublic function isAdult()\n{\n  // If the return value is set, return that, otherwise\n  // return false; which will always happen at this \n  // point\n  return isset($retval) ? $retval : false;\n}\n```", "```php\nPHPUnit 3.7.9 by Sebastian Bergmann.\n\n.\n\nOK (1 test, 1 assertion)\n\n```", "```php\npublic function testIsAdult()\n{\n  // Initialize our Person\n  $person = new Person();\n\n  // Our first fail test that makes sure that when no \n  // parameters are given the test will result in false\n  assertFalse($person->isAdult());\n\n  // Ok, that works now, let's now parse in an integer \n  // parameter so that we get result true back\n  assertTrue($person->isAdult(21)); \n}\n```", "```php\npublic function isAdult($age)\n{\n  // Check if $age is an integer, and if so,  \n  // make sure the person is above 18\n  if (isset($age) && is_int($age) && $age >= 18) {\n      $retval = true;\n  }\n\n  // If the return value is set, return that, otherwise   \n  // return false; which will always happen at this \n  // point\n  return isset($retval) ? $retval : false;\n```", "```php\n{\n  \"require-dev\": {\n    \"phpunit/phpunit\": \"3.7.*\"\n  }\n}\n```", "```php\n$ php composer.phar update\n```", "```php\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n\n<!-- we want to bootstrap with the Bootstrap.php file, and we want tooutput in pretty colors. -->\n<phpunit bootstrap=\"Bootstrap.php\" colors=\"true\">\n  <testsuites>\n    <!-- we can just give this a name for our own \n         identification -->\n    <testsuite name=\"Application Module Tests\">\n      <!-- this is the directory we want to use for \n           testing -->\n      <directory>./Application</directory>\n    </testsuite>\n  </testsuites>\n</phpunit>\n```", "```php\n<?php\n\n// Just as the normal configuration we simply return the \n// array\nreturn array(\n  // These are the modules we need to test our module. \n  // Normally this only the current module, but if \n  // this module has dependencies we need to add them \n  // here as well.\n  'modules' => array(\n    'Application',\n  ),\n\n  // Here we define our default module listener options, \n  // nothing special to note here.\n  'module_listener_options' => array(\n    'module_paths' => array(\n      'module',\n      'vendor',\n    ),\n  ),\n);\n```", "```php\n<?php\n// The namespace needs to reflect the namespace of the \n// module we want to test.\nnamespace Application; \n\n// The following imports are needed for our class\nuse Zend\\Loader\\AutoloaderFactory;\nuse Zend\\Mvc\\Service\\ServiceManagerConfig;\nuse Zend\\ServiceManager\\ServiceManager;\nuse Zend\\Stdlib\\ArrayUtils;\nuse RuntimeException;\n\n// We want to put the error reporting on, so that we see \n// if there is something going wrong\nerror_reporting(E_ALL | E_STRICT);\n\n// Our current directory is going to be our root \n// directory\nchdir(__DIR__);\n\n// Begin our bootstrap class here\nclass Bootstrap\n{\n  // Here we will define our ServiceManager in\n  protected static $serviceManager;\n\n  // The merged configuration of our application will be \n  // put in this property\n  protected static $config;\n\n  // This property isn't used, but we copied it for \n  // originality sake any way\n  protected static $bootstrap;\n```", "```php\n  public static function init()\n  {\n    // Read our created TestConfig file, and if it \n    // doesn't exist try the TestConfig.php.dist, but \n    // that won't exist in our environment\n    if (is_readable(__DIR__ . '/TestConfig.php')) {\n      $testConfig = include __DIR__ . '/TestConfig.php';\n    } else {\n      $testConfig = include __DIR__ . '/TestConfig.php.dist';\n    }\n\n    $zf2ModulePaths = array();\n\n    // Now we will load in all the module paths from the \n    // configuration (if set). \n    if (isset($testConfig['module_listener_options']['module_paths'])) \n    {\n      // Get the module path from the configuration\n      $modulePaths = $testConfig['module_listener_options']['module_paths'];\n\n      // Now loop through the module paths and find out \n      // what the parent path is of the module\n      foreach ($modulePaths as $modulePath) {\n        // This method is defined later in the class\n        if ($path = static::findParentPath($modulePath)) {\n          $zf2ModulePaths[] = $path;\n        }\n      }\n    }\n\n    // Now make a concatenated string with all the \n    // module paths separated by a colon.\n    $zf2ModulePaths = implode(\n        PATH_SEPARATOR, $zf2ModulePaths\n    ) . PATH_SEPARATOR;\n\n    // See if we defined some module paths outside this \n    // class or configuration and add them to the \n    // existing module paths\n    $zf2ModulePaths .= getenv('ZF2_MODULES_TEST_PATHS') \n                ?: (defined('ZF2_MODULES_TEST_PATHS') \n                ? ZF2_MODULES_TEST_PATHS : '');\n\n    // Make sure that we initiate auto loading so we \n    // don't have to worry about that (this method is \n    // defined later in the class)\n    static::initAutoloader();\n\n    // Now create a new configuration array so that we \n    // can merge it with the loaded configuration.\n    $baseConfig = array(\n        'module_listener_options' => array(\n        'module_paths' => explode(\n            PATH_SEPARATOR, $zf2ModulePaths\n        ),\n      ),\n    );\n\n    // Merge our configuration with the base \n    // configuration that we just generated.\n    $config = ArrayUtils::merge(\n        $baseConfig, $testConfig\n    );\n```", "```php\n    // Let's create a new service manager\n    $serviceManager = new ServiceManager(\n        new ServiceManagerConfig()\n    );\n\n    // Set the service manager to load the configuration \n    // so that the ModuleManager can use it to load up \n    // the modules and dependencies\n    $serviceManager->setService(\n        'ApplicationConfig', $config\n    );\n\n    // Now get the module manager, and load up the \n    // modules plus dependencies\n    $serviceManager->get('ModuleManager')\n                   ->loadModules();\n\n    // Make the service manager and configuration \n    // available as a static in the bootstrap class\n    static::$serviceManager = $serviceManager;\n    static::$config = $config;\n  }\n```", "```php\n  // Not completely unimportant, this is a getter for \n  // our servicemanager property.\n  public static function getServiceManager()\n  {\n    return static::$serviceManager;\n  }\n\n  // A simple getter for our static configuration.\n  public static function getConfig()\n  {\n    return static::$config;\n  }\n\n  protected static function initAutoloader()\n  {\n    // Get the parent path of the ZF2 library (this \n    // method is defined later on)\n    $vendorPath = static::findParentPath('vendor');\n\n    // Now make sure the ZF2 path is ready to go\n    if (is_readable($vendorPath . '/autoload.php')) {\n      $loader = include $vendorPath . '/autoload.php';\n    } else {\n      // The vendor path isn't in the configuration, try \n      // to find it ourselves.\n      $zf2Path = getenv('ZF2_PATH') \n               ?: (defined('ZF2_PATH') ? ZF2_PATH \n               : (is_dir($vendorPath . '/ZF2/library') \n               ? $vendorPath . '/ZF2/library' : false));\n\n      // If the path is not defined, we cannot continue\n      if (!$zf2Path) {\n        throw new RuntimeException(\n            'Unable to load ZF2.'\n        );\n      }\n\n      // Include our autoloader from ZF2\n      include $zf2Path. '/Zend/Loader/AutoloaderFactory.php'; \n    }\n\n    // If we come here that means we have a valid ZF2 \n    // path, and can safely initialize our Autoloader.      \n    AutoloaderFactory::factory(array(\n      'Zend\\Loader\\StandardAutoloader' => array(\n        'autoregister_zf' => true,\n        'namespaces' => array(\n          __NAMESPACE__ => __DIR__ . '/' . __NAMESPACE__,\n        ),\n      ),\n    ));\n  }\n\n  // This method finds the parent path of a given path. \n  protected static function findParentPath($path)\n  {\n    $dir = __DIR__;\n    $previousDir = '.';\n\n    while (!is_dir($dir . '/' . $path)) {\n      $dir = dirname($dir);\n\n    if ($previousDir === $dir) return false;\n      $previousDir = $dir;\n    }\n\n    return $dir . '/' . $path;\n  }\n}\n\n// And finally, initialize the application bootstrap\nBootstrap::init();\n```", "```php\n<?php\n\nnamespace Application\\Model;\n\nclass Company\n{\n  public function hasEmployees() {}\n}\n```", "```php\n<?php\n// Define the namespace like a boss\nnamespace ApplicationTest\\Model;\n\n// We want to use this model for testing\nuse Application\\Model\\Company;\n\n// Begin our test class, which needs to be extended from \n// the PHPUnit framework test case.\nclass CompanyTest extends \\PHPUnit_Framework_TestCase\n{\n  /**\n   * Test some method.\n   * @covers Application\\Model\\Company::hasEmployees\n   */\n  public function testHasEmployees()\n  {\n    $this->markTestIncomplete();\n  }\n}\n```", "```php\npublic function testHasEmployees()\n{\n  // Instantiate our model (remember the use statement \n  // in the top of the file).\n  $object = new Company();\n\n  // Make sure the method returns true\n  $this->assertTrue($object->hasEmployees());\n}\n```", "```php\npublic function hasEmployees()\n{\n  return true;\n}\n```"]