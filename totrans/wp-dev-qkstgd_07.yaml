- en: Managing Custom Post Types and Processing Forms
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In web development, we use Model-View-Controller architecture to separate different
    aspects of the sites into their own layers. The Model layer is intended to manage
    the data and the business logic of the application. In WordPress development,
    it's difficult to use such architecture in its original form. However, modeling
    data and logic is important for any kind of a website. So, we use built-in custom
    post types, and custom forms to manage the data capturing process in WordPress.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we are going to explore the importance and use of custom post
    type features in custom development tasks. We will be building a new custom post
    type to handle the properties in a real estate listing website, while using the
    most important features such as taxonomies, custom fields, and template loading.
    By default, custom post types features are enabled in the backend, and hence we
    explore the process of using custom forms in the frontend for data management.
    Finally, we look at the advantages and disadvantages of custom post types and
    custom forms in development.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Introduction to custom post types
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Building object-oriented plugins
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Building custom post types for properties
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction to form management
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Building and using custom forms
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Choosing between custom post types and custom forms
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using form management plugins
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By the end of this chapter, you will have the ability to develop with custom
    post types and custom forms, as well as know the pros and cons of the two techniques
    in different scenarios.
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You will be required to have WordPress 4.9.8 installed to follow this procedure.
    Even if you
  prefs: []
  type: TYPE_NORMAL
- en: have a later version of WordPress, the described examples should work with no
    significant problems.
  prefs: []
  type: TYPE_NORMAL
- en: 'The code files of this chapter can be found on GitHub:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://github.com/PacktPublishing/WordPress-Development-Quick-Start-Guide/tree/master/Chapter07](https://github.com/PacktPublishing/WordPress-Development-Quick-Start-Guide/tree/master/Chapter07)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Check out the following video to see the code in action:'
  prefs: []
  type: TYPE_NORMAL
- en: '[http://bit.ly/2AyINar](http://bit.ly/2AyINar)'
  prefs: []
  type: TYPE_NORMAL
- en: Introduction to custom post types
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Custom post types were introduced in WordPress 3.0 as a solution for managing
    different content needs beyond the default posts. However, the name *custom post
    types* is ambiguous as we may grasp it as a different type of normal posts. Ideally,
    we should consider it as a custom content type, as it provides features flexible
    enough to handle complex content types such as products, properties, and events.
    Custom post types are stored in the `wp_posts` table by default. Prior to the
    introduction of custom post types, we had to use a considerable amount of filters
    and conditions in code to keep different post types separate from each other.
    This might have been a nightmare for many developers when managing a number of
    different content types in the same site.
  prefs: []
  type: TYPE_NORMAL
- en: 'Introduction of custom post types has dramatically expanded the capabilities
    of WordPress as a framework for developing sites with advanced data requirements
    and logic. Modern themes and plugins have utilized these features to its maximum
    potential. Let’s take a look at some of the popular plugins that run based on
    custom post types:'
  prefs: []
  type: TYPE_NORMAL
- en: '**WooCommerce**: We already looked at the functionality of this plugin in [Chapter
    5](40208ac9-c023-42b1-b48e-a368761b37a6.xhtml), *Extending Plugins with Addons,
    Filters and Actions*. WooCommerce is used as an eCommerce solution for selling
    products. This plugin uses five built-in custom post types for handling **products**,
    **product variations**, **orders**, **refunds**, and **coupons**. Also, we get
    a product specific template design in the frontend for the custom post type. You
    can use this plugin as one of the best examples for understanding the use of custom
    post types.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**The Events Calendar**: This is a plugin that provides a calendar to create
    and manage your event-related details with built-in custom post types for **events**,
    **organizers**, and **venues**.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**bbPress**: This is one of the most popular forum management plugins with
    built-in custom post types for **forums**, **topics**, and **replies**.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As you can see, many popular plugins use multiple custom post types to build
    the plugin features. Using custom post types considerably simplifies the process,
    as well as makes plugins compatible with WordPress core features.
  prefs: []
  type: TYPE_NORMAL
- en: Why do we use custom post types for modeling data?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The custom post type was a great addition to WordPress. But, we need to understand
    how it became so popular in such a short time span. The main reason is the ability
    to capture, store, and display advanced data needs without requiring considerable
    development effort. Let''s take a look at the main features offered by custom
    post types to reduce the development time. In less than twenty lines of code,
    we can get a fully functional custom post type with all the following features:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Creating and updating data**: Once a new custom post type is added, we get
    a screen for adding and editing data, similar to the normal post screens. The
    main content details are saved automatically with a click of a button, and hence
    we can avoid the need for building our own custom screens with forms. Consider
    the following screenshot, highlighting the built-in features:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](img/93f48a31-5122-45e9-8506-66bfab7fdc4e.png)'
  prefs: []
  type: TYPE_IMG
- en: '**Flexible data list**: Usually, building a data list with pagination requires
    considerable development time. With custom post types, we get a built-in list
    for each custom post type with pagination, search, filter, and delete capabilities.
    Also, we can easily change the database query to filter and display the default
    data list. Apart from these features, we also get a dropdown called Bulk Actions,
    where we can execute built-in functionality on multiple records of a single custom
    post type. The most important feature is the ability to add our own actions and
    execute them on multiple records with a minimum custom code. Consider the following
    screenshot, highlighting the built-in features:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](img/684b7bda-8494-42fd-8a61-be06a6c068fb.png)'
  prefs: []
  type: TYPE_IMG
- en: '**Built-in URL structure**: We get a default URL structure for managing all
    screens of each custom post type. We can easily change the built-in URL structure
    while creating the custom post type. So, we can avoid the time needed for setting
    up our own URL structure and conditionally managing different screens.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Custom field management**: We can use the default custom fields feature of
    WordPress posts, where we can define a key and a value for each field. When we
    want more control over the custom fields, metaboxes can be used to add and manage
    custom fields in less development effort, compared to developing custom fields
    from scratch.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Data categorization**: Custom post types provides built-in taxonomy support
    for categorizing records of each post type. We have the ability to categorize
    new custom post type data as hierarchical categories or flat type tags based on
    the requirements. Apart from filtering, we also get default templates for these
    categorization pages. So, the data categorization process is extremely simple
    compared to usual custom development.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Built-in templates**: Building templates and displaying the data requires
    a considerable development effort. By default, custom post types use the built-in
    templates of the theme, and hence we don’t require any effort to display the data
    in basic form. Even with advanced requirements, we can just duplicate the default
    template and adjust it with minimum effort to include our design elements or custom
    data.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These reasons may give you an idea about how custom post types became such a
    valuable feature in WordPress. Now, it's time to understand the process of using
    and developing custom solutions with these features.
  prefs: []
  type: TYPE_NORMAL
- en: Building an object-oriented plugin
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Up to this point, we created several plugins in previous chapters. However,
    we used the procedural approach, where we define the necessary hooks and functions
    directly inside the main plugin file or sub-files. As the website or application
    gets complex, we will have a hard time managing the development with the procedural method.
    So, we need a way to use best development practices and modularize the code into
    necessary classes. In this section, we are going to look at the basic structure
    for creating a plugin with object-oriented concepts. Let''s consider the following
    code for the OOP-based plugin structure:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: WordPress doesn't provide a recommended method or boilerplate to build the plugins
    using the object oriented method. So, it's the choice of the developers to use
    a technique that better suits them. The preceding structure is used by some of
    the exciting plugins, and it's also my personal preference as well. So, you can
    use it as a guide and build a better solution that suits your style.
  prefs: []
  type: TYPE_NORMAL
- en: We begin by checking the availability of the main plugin class and define the
    main class for the plugin. We will be using the main class to handle all other
    files as well as classes. Then, we define a variable to hold the instance of the
    class and use the `instance` function to generate an object from this class. This
    `static` function and the private `instance` variables make sure that we only
    have one instance of our plugin class. The `instance` function acts as the initialization
    point of our plugin, and hence we can include the necessary function calls, class
    initialization, and hooks inside this function.
  prefs: []
  type: TYPE_NORMAL
- en: We have two function calls to the `setup_constants` and `includes` functions,
    inside the `instance` function. These functions respectively define the constants
    required for the plugin features and add the plugin files using the PHP `require_once`
    function. As we develop complex plugins, we can have many such functions to separate
    these kinds of basic configurations for the plugin. Then, we can define all the
    `action` and `filter` hooks intended to be used throughout the plugin for configuration
    purposes. Here, we have used two actions for including the scripts and styles
    on the frontend and the backend of the website.
  prefs: []
  type: TYPE_NORMAL
- en: The next section should consist of the object creation for the main classes
    of the plugin. In this scenario, we only have one class, even though we will need
    many classes in advanced plugin development. We need to use the `self::$instance`
    object as we are within the `static` function. Finally, we return the instance
    of the main class.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is the base structure for an object oriented type plugin. We can include
    all the main configurations and generic features within this class and use other
    classes to handle the business logic. Now, we need to initialize the main class
    by using the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: We execute a callback function on the `plugins_loaded` action to make sure that
    all the plugins are loaded before we initialize the main class of our plugin.
    Also, this will be the location used to check the dependencies between other plugins
    when we are doing integrations or building addons. We call the `instance` function
    of the main `WPQuick_CPT` class and define the resulted instance as a `global`
    object. As you can see, now our plugin is simplified and well-structured compared
    to previous plugins, and only includes the generic things. The site-specific implementations
    will be handled by the other classes. Now, we are ready to develop the plugin
    to handle custom post type features.
  prefs: []
  type: TYPE_NORMAL
- en: Building custom post types for properties
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We can use custom post types to model any data in a wide range of business categories.
    In this chapter, we are going to build a property custom post type for real estate
    listing websites, to illustrate the use of custom post type features. In this
    section, we will develop features for creating custom post types, assigning custom
    taxonomies, and using custom fields.
  prefs: []
  type: TYPE_NORMAL
- en: Creating property custom post types
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'First, we need to create a separate class for handing property-related features
    as we are using an object oriented plugin. So, create a new directory called **classes**
    inside the main plugin directory, and add a new file called `class-wqcpt-property.php`.
    Then, we need to include this file in our plugin and create an object to initialize
    the features. We need to add the following line inside the `includes` function
    of the `WPQuick_CPT` class to include the file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we need to create an object of this class by using the following line
    of code inside the `instance` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we have the ability to add the functionality into this class. WordPress
    provides a function called `register_post_type` to create new custom post types.
    This function takes a wide range of parameters to configure the post type for
    different requirements. This function should be called within the `init` action
    to prevent any unnecessary conflicts. Let''s add the following lines of code to
    the constructor of the `WQCPT_Model_Property` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'In the first line, we add the post type key into a class variable to be reused
    inside all functions. Then, we use the `init` action to call the `create_property_post_type`
    function for creating a new post type. Since we are using a class, we need to
    call the function on a class object by using the `$this` instance. Now, we can
    take a look at the implementation of the `create_property_post_type` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'We begin the function by defining the necessary variables for post type and
    labels. The next part of the code contains the labels array. We need to define
    each label, as WordPress will use the **Post** as the default label for all entries.
    It''s not ideal to show the **Post** in messages when we are actually working
    with **Properties**. The next code section contains list of arguments for creating
    the post type. Let''s discuss the most important settings and their role:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Hierarchical**: Defines whether the new post type will act as a page or post.
    WordPress pages provides hierarchical capabilities where we can define parent
    pages, whereas posts has no hierarchy.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Supports**: This setting defines the allowed fields and features for the
    new post type. We have enabled post title and content for properties. We can also
    use values such as author, thumbnail, excerpt, trackbacks, custom-fields, comments,
    revisions, page-attributes, and post-formats for different features.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Public**: Defines how the new post type is visible to content creators and
    visitors. We can use `true` or `false` as values. Depending on the value for this
    setting, we will see changes in other settings such as `show_in_menu`, `show_ui`,
    and `exclude_from_search`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Rewrite**: Defines the rewrite rules status or settings for the post type.
    By default, it uses `$post_type` as a slug. We can modify it by using a custom
    slug.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: More details about the available settings and their role in different combinations
    can be identified by using the documentation at [https://codex.wordpress.org/Function_Reference/register_post_type.](https://codex.wordpress.org/Function_Reference/register_post_type)
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we call the `register_post_type` function to create the post type by
    passing post type slug and the list of arguments. Now, the property post type
    is registered with WordPress and you will see a new section called Properties
    in the main WordPress menu. You can create a property and view it on the frontend
    using the property link. However, you will get a WordPress 404 page instead of
    the property details page. The reason is WordPress is not aware of the new URL
    structure of newly registered custom post types until we flush the rewrite rules.
    As we discussed in [Chapter 6](e452b581-f38d-4c95-8a41-0c9a54b26a57.xhtml), *Practical
    Usage of WordPress APIs*, we need to either manually update the rewrite rules
    by visiting the WordPress Settings | Permalinks section, or by flushing rewrite
    rules on plugin activation.  You can implement the activation handler for this
    plugin using the technique we discussed in previous chapter. Once rewrite rules
    are flushed, you will be able to see the property details page on the frontend
    with the layout of default posts.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the property types taxonomy
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'WordPress **taxonomies** are a way of grouping posts or custom post types.
    We already looked at taxonomies while discussing database tables and templates
    in previous chapters. In this section, we are going to look at how taxonomies
    fit into custom post types and their implementation. In this scenario, we are
    building a property listing site. We can use taxonomies to group properties based
    on the property type. Let''s begin by adding the following action to the constructor
    of the `WQCPT_Model_Property` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'As with custom post types, we have to use the `init` action to register taxonomies
    for WordPress. Let''s consider the implementation of the `create_property_custom_taxonomies`
    function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'We start the function by defining the taxonomy and the necessary labels, similar
    to the custom post types. Then, we can call the `register_taxonomy` function with
    the necessary parameters to create the taxonomy for property types. Let''s take
    a look at the parameters in detail:'
  prefs: []
  type: TYPE_NORMAL
- en: '`taxonomy`: This is the first parameter, where we have to pass the name for
    the taxonomy. We can only use lowercase letters and characters. We have specified
    it as `wqcpt_property_type`, with a prefix to make it unique from other plugins.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`object type`: This is the second parameter, where we have to assign the post
    types that will use this taxonomy. In this scenario, we have specified `wqcpt_property`
    as the post type. We can use an array in scenarios where we have multiple post
    types. However, using a taxonomy in multiple post types makes archive pages as
    a mix of different post type entries. It might be difficult to handle archive
    pages with multiple post types due to different designs and data. So, it''s ideal
    to use separate taxonomies for each post type, unless all post types contain similar
    design and data in archive pages.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`arguments`: This is the third parameter where we can pass different settings
    from the list of available options. In this scenario, we have used the **labels**
    for property listing types and **hierarchical** options. The **hierarchical**
    setting defines whether the taxonomy should act as a **tag** or **category**.
    The default value is `false`, making it act as a **tag**. We have used it as a
    **category** by setting it to **true**. There are many other settings similar
    to the custom post type registration process. You can view more details about
    all the available arguments at [https://codex.wordpress.org/Function_Reference/register_taxonomy](https://codex.wordpress.org/Function_Reference/register_taxonomy).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The choice of category against tag for taxonomies depends on your requirements.
    Generally, we use categories when we want to have different sub-levels as well
    as when have a fixed set of primary options. Tags don't provide sub-levels and
    usually use a dynamic set of values to explain the data. In this scenario, property
    listing types have predefined options such as Sale, Rent, and Mortgage. Therefore,
    we choose category over tags for property listing types.
  prefs: []
  type: TYPE_NORMAL
- en: Once this code is used, you will see a new taxonomy added to the Property menu.
    You can create properties and assign property listing types to categorize the
    properties based on your needs. In real-world requirements, you have to match
    the taxonomy needs of each custom post type with categories or tags depending
    on the functionality.
  prefs: []
  type: TYPE_NORMAL
- en: Managing custom fields for custom post types
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In normal posts, we rarely use custom fields as the primary feature is displaying
    content in the WordPress editor along with featured images, tags, and categories.
    However, custom post type implementations require a considerable amount of data
    beyond the content in the WordPress editor. So, we need a way to handle the custom
    data for each custom post type. We can use the default post custom fields feature
    to store the data in the `wp_postmeta` table. Let''s consider the custom field
    requirements of a property listing site:'
  prefs: []
  type: TYPE_NORMAL
- en: The property listing sites require a large amount of custom data, along with
    the property title and the main property content through the WordPress editor.
    We can match some of the property data such as property listing type as categories.
    However, the majority of the data needs to be handled using custom fields. Such
    data includes fields such as city, property type, area, price, year, property
    plans, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this section, we are going to add some custom property fields to understand
    the process of adding and using custom fields in custom post types. Let''s start
    by adding a metabox to define custom fields similar to the technique we used in
    the *post attachments* plugin. We need to update the constructor of `WQCPT_Model_Property`
    with the following action:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we have to define the metabox and implement the function for displaying
    the content of the metabox using the following code inside the `WQCPT_Model_Property`
    class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: We already discussed the use of the `add_meta_box` function in the post attachments
    plugin and how to use a callback function to generate the content. In the post
    attachments plugin, we used HTML within PHP variables to generate the output.
    This is not ideal in large projects as it's hard to manage the output within quotes
    as well as provide extendable capabilities for templates. In the MVC pattern,
    we use a separate layer for the template called **Views**.
  prefs: []
  type: TYPE_NORMAL
- en: '**Model–view–controller** also known as **MVC** is an architectural pattern
    commonly used for developing user interfaces that divides an application into
    three interconnected parts. The MVC design pattern decouples these major components,
    allowing for efficient code reuse and parallel development.'
  prefs: []
  type: TYPE_NORMAL
- en: '– Source : [https://en.wikipedia.org/wiki/Model-view-controller](https://en.wikipedia.org/wiki/Model-view-controller)'
  prefs: []
  type: TYPE_NORMAL
- en: Similarly, we have to separate the template code as much as possible to allow
    the possibility of future enhancements.
  prefs: []
  type: TYPE_NORMAL
- en: So, we define a global variable called `$template_data` to keep the necessary
    data for the template used in this function. Then, we assign the post type, nonce
    value, and the property data to the `$template_data` array. We use the `wp_postmeta`
    table to store the custom field details for properties. Therefore, we can use
    the `get_user_meta` function to get the existing property values to be passed
    to the template. Initially, these functions will return empty strings until we
    save the data for the first time. Then, we have to use a template loader to load
    the template for property custom fields.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we have used our own template loader. You can refer to the
    `classes/class-wqcpt-template-loader.php` file inside the source code directory
    of our plugin for the implementation. This class is included in the main file
    of our plugin and the object is created within the `instance` function. The basic
    functionality of this class is to include PHP files from the templates directory
    of our plugin. Those developers who are familiar with using Template Engines such
    **Twig**, **Smarty**, **Mustache** in pure PHP projects may think of this as a
    similar technique. However, this is just basic PHP file inclusion with template
    code, and hence doesn't provide any advantages provided by Template Engines.
  prefs: []
  type: TYPE_NORMAL
- en: We can use PHP Template Engines in WordPress plugins with bit of additional
    development work. However, most plugins including the popular plugins don't use
    Template Engines and are restricted to template loading as PHP files.
  prefs: []
  type: TYPE_NORMAL
- en: In this function, we have called the `ob_start` function to start the template
    loading process. This function is used to switch on output buffering, allowing
    us only to send the necessary content to the browser. Next, we access the object
    of the template loader class by using the global `$wqcpt` instance of our plugin,
    and call the `get_template_part` function. We have passed two strings called `property`
    and `meta` to this function. So, we need to have a template file called `property-meta.php`
    inside the templates directory of our plugin. Then, we use the `ob_get_clean`
    function to get the template and clean the output buffer. Finally, we use the
    `echo` statement to send the content to the browser. The next step in the process
    is to build the template and use the data specified for the template.
  prefs: []
  type: TYPE_NORMAL
- en: Building the property fields template
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We need to begin the process by creating a new directory called `templates`
    inside the plugin and a new file called `property-meta.php` inside the directory.
    This file should produce the custom fields to capture property data while keeping
    the amount of PHP code and logic to a minimum. Let''s take a look at the implementation
    of the template for property custom fields:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s understand the implementation of the property fields template using
    the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: We begin the template by using the global `$template_data` array and extracting
    the values passed as template data.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Then, we have to add the HTML fields for keeping the nonce value and property
    data. In the preceding code, we have limited the fields to city and property type
    for explanation purposes.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Next, we have to use the data passed from `WQCPT_Model_Property` to load the
    existing values for these fields.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now, our template is ready. You can create or edit a property to see the property
    custom fields, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/aef3ed3c-d210-49ee-9810-cc788749a7a0.png)'
  prefs: []
  type: TYPE_IMG
- en: We can use this technique to group all the property fields in a single metabox
    or use multiple metaboxes to hold related fields. Also, we can change the location
    and priority of the metabox in the property screen.
  prefs: []
  type: TYPE_NORMAL
- en: Saving property custom fields
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We set up a property as a custom post type and hence the main property details
    will be saved automatically on property publication or update events. However,
    custom field data will not be saved in this process, and hence we need a custom
    implementation to store these data. We have chosen to store the custom field data
    in the `wp_postmeta` table. Let''s look at the process of saving custom fields
    using the WordPress `save_post` action. First, we need to add the following line
    of code to the constructor of the `WQCPT_Model_Property` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'This action is triggered whenever we create or update a post or custom post
    type. Now, we have to implement the callback function with the following implementation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: We begin the function by verifying the nonce value assigned to the template.
    We can just return the post ID on verification failures. Next, we have to apply
    another validation for checking the autosave. WordPress autosave features periodically
    save the post content automatically. We don't need to update the custom field
    values on each autosave. So, the validation only allows the function to process
    when the user is manually saving the post. The next validation is the most important
    one since this action is executed on all post types in WordPress.
  prefs: []
  type: TYPE_NORMAL
- en: We have to make sure we use the action only in necessary post types to avoid
    unnecessary conflicts. So, we check if a property is being saved and the current
    user has the permission to save properties by using the `current_user_can` function.
    We didn't assign property-specific capabilities in custom post type registration.
    Therefore, we have to check for the default post edit permission. Once all the
    validations are completed, we can retrieve and sanitize the values from the POST
    request. Finally, we use the `update_post_meta` function to save each property
    field to the `wp_postmeta` table.
  prefs: []
  type: TYPE_NORMAL
- en: We have the completed the functionality of managing properties from the backend.
    Now, you should be able to create properties with custom field data and display
    that data in edit property screens. Once created, you can view the properties
    from the frontend by using the property link.
  prefs: []
  type: TYPE_NORMAL
- en: The theme will use the default `single.php` template to display the property.
    Since we need to display additional property-related fields, we can create a template
    inside the theme or use our plugin to load a template for handling a single property
    page.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this scenario, we used two property fields with basic field types. In real
    applications, you will have to use more complex fields such as dates, maps, searchable
    dropdowns, color pickers, and so on. So, manually building custom fields may become
    an issue for most startup sites with lower development time frames. In such scenarios,
    we can use custom post type plugins that act as a framework for managing custom
    fields without the need for manual coding. Let''s take a look at some of the custom
    post type plugins that offer wide range of custom field types:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Toolset Types**: This plugin lets you manage custom post types, custom taxonomies,
    and custom fields without needing any coding. This plugin offers over 20 built-in
    custom field types. Built-in interfaces allow you to manage custom fields by providing
    the necessary settings. More details about the features can be viewed from the
    plugin page at [https://wordpress.org/plugins/types/](https://wordpress.org/plugins/types/).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Pods**: This plugin also offers the same set of features, along with the
    ability to connect multiple custom post types. This plugin offers around 10 custom
    field types to manage the fields of each custom post type using existing screens. More
    details about the features can be viewed from the plugin page at [https://wordpress.org/plugins/pods/](https://wordpress.org/plugins/pods/).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Metabox**: Compared to the other two plugins, this one mainly focuses on
    managing custom fields by allowing you to add them to metaboxes in the post creation
    screen. This plugin provides over 40 built-in field types covering a wide range
    of areas. More details about the features can be viewed from the plugin page at [https://wordpress.org/plugins/types/.](https://wordpress.org/plugins/types/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These plugins are useful for sites that require rapid development process and
    gives less priority for flexibility and the extendability of the features.
  prefs: []
  type: TYPE_NORMAL
- en: Limitations of storing data as meta values
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We use the post meta table in most occasions to store custom data related to
    different custom post types. However, as the meta tables gets larger, it will
    be difficult to manage all the meta values. The site will get slower, creating
    major performance issues. So, we have to consider this limitation when planning
    the site in the initial stages. Once the posts meta table is used, it's difficult
    to migrate to a custom solution in later stages, especially when we decide to
    use custom post type plugins to manage the custom fields.
  prefs: []
  type: TYPE_NORMAL
- en: So, using the post meta table to store custom field data is ideal for small-
    to medium-scale sites where the posts and post meta tables won't get overloaded
    with data. In advanced applications, we should consider using a custom table for
    the custom fields, while using the posts table for the main details of a custom
    post type item.
  prefs: []
  type: TYPE_NORMAL
- en: Introduction to form management
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The majority of WordPress sites consist a of few pages about the site, services,
    or products while having a blog. Among the rest, a high percentage of sites focus
    on capturing, processing, and displaying user data. So, form management becomes
    an important aspect in WordPress development. The forms are mostly used as a data
    capturing method on the frontend, as we use custom post types to capture data
    in the backend. We can develop our own custom forms in the frontend, or we can
    automate the process of managing forms by using an existing form management plugin.
    The choice between custom forms and form plugins depends on the requirements of
    the site. Let's take a look at the advantages and disadvantages of using these
    two methods.
  prefs: []
  type: TYPE_NORMAL
- en: '**Development time**: Form plugins provide a rapid development process with
    drag-and-drop form creation, while handling all the form field features through
    configurations. On the other hand, custom forms require considerable development
    effort and the changes to existing fields require modifications in code.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Database usage**: Each existing forms plugin is restricted to using the `wp_postmeta`
    table or a single custom table, whereas custom forms can be developed to use either
    technique according to our preference, while keeping different form data in different
    tables.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Extendability**: Building custom forms enables the possibility of keeping
    the features open for future enhancements. On the other hand, we will have to
    work with the limitations of forms plugins when considering the future enhancements
    of advanced sites.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Consistency in design**: We can create our own custom form designs to match
    the styles of the theme. However, existing plugins may not provide 100% flexibility
    in modifying the design to match the theme styles.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Due to these reasons, we should carefully choose the development method for
    custom forms depending on the requirements of each site. Once we complete the
    upcoming sections on form management, you will have a better idea about the process
    for making correct decisions.
  prefs: []
  type: TYPE_NORMAL
- en: Building custom forms in the frontend
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We have several ways of adding forms to the frontend of a WordPress website.
    In this section, we are going to discuss two methods used by popular plugins to
    add forms:'
  prefs: []
  type: TYPE_NORMAL
- en: Adding forms using shortcodes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Loading forms using custom URLs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We will be implementing both techniques, starting with the shortcode method.
  prefs: []
  type: TYPE_NORMAL
- en: Adding forms using a shortcode
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This is one of the most popular methods used by many popular plugins to add
    data capturing forms to a site. In this method, we use a shortcode to generate
    the HTML for the form. Then, we add the shortcode to a WordPress post or page
    and let users access it through the post or page. This is the ideal technique
    for basic to intermediate level features, where the use of the form doesn't play
    a critical part in the functionality of the site.
  prefs: []
  type: TYPE_NORMAL
- en: Using shortcode is one of the simplest methods to add a form. However, shortcodes
    are added to post or page and hence administrators can accidentally delete the
    page or break the shortcode by mistake. Therefore, it should not be used for advanced
    sites where the functionality of shortcode is critical. For example, consider
    a registration form in a basic social network site. The unavailability of the
    registration page for a limited time is not a major issue since the people register
    for free to share their activities. However, consider a registration form in a
    support forum of a site that provides a time-critical service. In such sites,
    unavailability of registration for even few hours is not acceptable and affects
    the user. So, we shouldn't use shortcode-based forms in such sites, or prevent
    modification access to the pages with shortcodes .
  prefs: []
  type: TYPE_NORMAL
- en: 'In the previous section, we used custom post types to manage the property details
    in the backend. Now, we need to add the property creation capabilities to the
    frontend. Let''s use the following line of code inside the constructor of the
    `WQCPT_Model_Property` class to define a shortcode for the property form:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we need to implement the callback function to display a property creation
    form in the frontend. Let''s consider the implementation of the `display_property_form`
    function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'The implementation of this function is similar to the `display_property_meta_boxes`
    function we used in the backend custom post types. In this scenario, this form
    is only used for property creation and hence we don''t have to pass the existing
    data as template variables. We use a different template called `property-form.php`
    for the frontend custom form. Now, we can have a look at the implementation of
    the `property-form.php` template:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'The structure of the template is exactly same as the previous scenario on backend.
    However, we have two additional fields for property title and content, along with
    a form and a submit button. In custom post types, we had the title and content
    as built-in fields. We also used the built-in post form and the Publish or Update
    buttons. On the frontend, we don''t have any built-in features, and hence we have
    to add them manually. Once the shortcode is added to a page, the property creation
    form will look similar to the following screen:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/7063ec2e-ca14-4360-bad5-53269c77972c.png)'
  prefs: []
  type: TYPE_IMG
- en: Now, we come to the final part where we create the property on the submission
    of the form.
  prefs: []
  type: TYPE_NORMAL
- en: Creating properties using custom forms
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In backend custom post types, we were only coding the custom field saving part,
    and hence we were able to use the `save_post` action to handle the process. In
    the frontend, we have to build the process from scratch and hence the `init` action
    is the ideal hook for the implementation. Let''s add the following line of code
    to the constructor of our `WQCPT_Model_Property` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we can take a look at the implementation of the `save_property_form`
    function, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: We begin the function by using an `if` condition to check the availability of
    the Submit button in the frontend post creation request, to make sure our code
    is executed only for the frontend property creation form. Next, we use another
    conditional check for the nonce value and property creation permissions. In the
    custom post types section, we executed the permission check by passing the post
    ID, as we were only saving the custom fields for an already-created property.
    In this scenario, we are creating a property from scratch, and hence we don't
    have a post ID yet. So, we can only check for general post editing permissions.
  prefs: []
  type: TYPE_NORMAL
- en: Once permission errors are generated, we can assign the error messages to a
    class variable and use it inside the shortcode function to display them.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once validations are completed, we can retrieve the property data from the
    `POST` request and sanitize it before assigning to necessary variables. Here,
    we have used a function called `wp_kses_post` on the property content. This function
    sanitizes the content to only keep the allowed tags in WordPress post content
    by default. Next, we have to validate the data retrieved from the `POST` request
    and generate the errors to be displayed inside the shortcode. Now, we can take
    a look at the rest of the code for this function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: After validating all the property data, we use the `wp_insert_post` function
    to create the property on the `wp_posts` table. We can pass all the necessary
    settings as an array to this function. Here, we have used author as the current
    logged-in user. Then, we assign the property title and content to the respective
    settings while generating the URL for the post using the `sanitize_title` function.
    Finally, we set the correct post type and status as publish. This is a built-in
    function that creates posts while executing all the necessary filters and actions
    inside WordPress core. In case we use our own query to save the properties, we
    have to check and execute all the necessary filters and actions to make our feature
    compatible with other plugins. This function will return `true` or WordPress error
    based on the status of the execution. Next, we can check the errors and use the
    `update_post_meta` function to save the property custom fields to the `wp_postmeta`
    table.
  prefs: []
  type: TYPE_NORMAL
- en: We can easily use frontend forms to store custom field data on custom database
    tables for additional flexibility. In such cases, we just have to replace the
    `wp_insert_post` function with a custom query and necessary data.
  prefs: []
  type: TYPE_NORMAL
- en: Now, we have completed the process of adding data using frontend forms, and
    you should be able to test the process by assiging the shortcode to a post or
    page and submitting the form with necessary data.
  prefs: []
  type: TYPE_NORMAL
- en: Loading forms using custom URLs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We already discussed the concept behind this technique in [Chapter 6](e452b581-f38d-4c95-8a41-0c9a54b26a57.xhtml),
    *Practical Usage of WordPress APIs*, *Rewrite API* section. The shortcode method
    is not highly reliable for advanced web sites. So, we create our own URL structures
    and handle the forms using those custom URLs instead of using post, page, or custom
    post type. Since we already discussed this technique, we are going to go through
    the code without major explanations. Let''s start by adding a new rewrite rule
    and a query parameter to handle frontend property creation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'This code adds new rewrite rule accessible through [http://www.example.com/property-listing/add](http://www.example.com/property-listing/add)
    for creating properties from frontend custom forms. We also use a tag called `wpquick_property_actions`
    to identify the functionality for properties. Ideally, we need to include this
    code within the main class of our plugin to keep the object oriented nature of
    our plugin. However, we discussed the need to flush rewrite rules on activation.
    So, there is a conflict since our plugin is initialized on the `plugins_loaded`
    action, and the activation handler is executed before that action. Therefore,
    we have to use the preceding code outside the main class of the plugin, along
    with the activation handler. The following code contains the activation handler
    for this plugin:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'As we did in [Chapter 6](e452b581-f38d-4c95-8a41-0c9a54b26a57.xhtml), *Practical
    Usage of WordPress APIs*, we register the rewrite rules on the activation handler,
    just before calling the `flush_rewrite_rules` function. Next, we need to filter
    the URL and load the custom form for creating properties. We use the built-in
    `template_redirect` action for this functionality, and we can include the action
    inside the `WQCPT_Model_Property` class, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: First, we receive the value of `wpquick_property_actions` using WordPress query
    variables. Then, we use a `switch` statement to filter different actions for properties.
    In this scenario, we have only used `add` as a filter. In complete implementation,
    we will have to include `edit`, `delete`, and `list` actions at a minimum. Inside
    the `add` case, we load the same template we used for the shortcode process. Then,
    we include it between the header and footer of the site to display the frontend
    form. Now, you should be able to access and create properties by visiting `www.example.com/property-listing/add`
    in the browser URL.
  prefs: []
  type: TYPE_NORMAL
- en: Choosing between custom post types and custom forms
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We looked at the features and process of both custom post types and custom forms
    in the previous sections. We started this chapter by discussing the custom post
    type features that have changed the way we develop with WordPress. Now, we can
    compare them with custom forms, and identify the advantages and disadvantages.
    Let's start by looking at the advantages of custom post types.
  prefs: []
  type: TYPE_NORMAL
- en: 'You may have already noticed the amount of coding we needed to get to display
    a custom form and use it for capturing data. We didn’t spent even half of the
    time doing the same thing with custom post types. Let''s summarize the additional
    things we had to do in custom form development, compared to custom post types:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Creating fields for title and content**: We had a built-in title field and
    content field with Rich Text Editor in custom post types, whereas we had to create
    two new fields to handle them in custom forms.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Adding a form and submit button**: We didn''t need to add a form or submit
    button in custom post types as we were using the built-in post functions of WordPress.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Saving the property**: We didn''t have to create the property and save the
    main details in custom post types as it was done automatically by the WordPress
    core process.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Handing property validations**: In custom post types, all the necessary validation
    on main property data is handled by core features. However, we need to check the
    existence of the property, URL, and make sure to sanitize the property content
    manually.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Post editing and listing**: We have the ability to edit, list, or delete
    a post as soon as we create one using backend custom post types. However, we only
    built the create form using the custom form, and hence we have to develop edit,
    list, and delete features from scratch using more custom forms.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'So, in this perspective, built-in custom post types offer a lot more advantages
    over custom forms. Here are the advantages of using custom forms over custom post
    types:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Frontend interfaces**: Custom post types doesn''t offer the data capturing
    features on the frontend and hence users need to be redirected to the backend.
    So, we can''t match the forms with the styles of themes, whereas custom forms
    allow us to create any type of design. This also means we will have to manage
    the permission to other menu items in the backend.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Mix of frontend and backend**: When using custom forms, we can let users
    use the other site features as well as data submissions within the frontend, allowing
    users to have a consistent set of screens. However, using custom post types means
    that the user will have to switch between the frontend and backend of the site,
    creating unnecessary complexity.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Flexibility in validations**: WordPress automatically saves custom post types
    using the autosave feature and hence we can’t wait for the custom post creation,
    until custom validations are completed. So, we have to use some workarounds to
    validate custom fields and display the error messages, while keeping the post
    type record inaccessible. In custom forms, we can have the complete freedom for
    data validation before we actually create the record on the `wp_posts` table.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Flexibility in using database tables**: In backend custom post types, the
    newly created post always saves to the `wp_posts` table. However, in custom forms
    we can decide whether to use existing tables or use our own custom tables for
    managing data.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By considering the advantages and disadvantages of each technique, we can come
    to a conclusion that backend custom post types are mostly suitable for sites with
    low budget and require a rapid development process. Also, we can consider custom
    post types when basic functionality is more important than flexibility. On the
    other hand, custom forms can be used for advanced sites, where performance is
    crucial and requires flexibility for future enhancements.
  prefs: []
  type: TYPE_NORMAL
- en: Using a form management plugin
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We looked at the use of custom post types and custom forms for capturing and
    displaying the data needed for WordPress sites. However, many startup sites don''t
    have the budget or time to develop a custom solution specific for their sites.
    So, developers will have to use existing solutions and build the features on top
    of them. In such cases, WordPress form plugins become the ideal solution. There
    are some popular form plugins developed to cater a specific area, such as contact
    forms. We can also find forms plugins such as Gravity Forms, Ninja Forms developed
    to cater any purpose. Let''s understand the features expected from a quality forms
    plugin:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Drag and drop builder**: This is the feature that accelerates the development
    of custom forms with existing plugins. Instead of writing own HTML for each field,
    we should be able to drag and drop existing custom fields and build fully working
    custom forms in minutes.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Ajax-based form submission**: This is a very important feature in modern
    websites as developers don''t use the normal post submissions for many features.
    So, the forms plugin should have the ability use normal form submission as well
    as AJAX-based submissions.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Different field types**: In this plugin, we only used basic text and dropdown
    fields. However, we need many field types such as dates, google maps, and searchable
    dropdowns in advanced websites. So, the ability to handle such advanced requirements
    with the built-in fields in forms plugins is definitely a huge advantage.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Form field validations**: Usually, we had to validate each field by applying
    the necessary validation rules. In a quality forms plugin, we should have the
    ability to select from an existing set of rules and validate the fields without
    writing a single line of code.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Conditional logic**: In custom forms, we develop each form for specific requirements
    and hence we can manually apply conditions before loading certain fields. In forms
    plugins, we add the fields dynamically to a form, and hence we should have the
    ability to define the conditions before making each field visible on the site.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Displaying and exporting data**: We should have the ability to display submitted
    data in the frontend and export it to common file types when necessary.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Saving form data to a custom database table**: Usually, many forms plugins
    save the data to the `wp_postmeta` table or use the same custom table to save
    the data of all forms to a single custom table. We should at least have the ability
    to choose between existing tables or a custom table.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'These are some of the features we expect from quality form plugins. Let''s
    take a look at the following screen for the form-creating interface of one of
    the most popular forms plugins:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/6bf02239-3d3e-4fbf-a5dd-ccfee4eba423.png)'
  prefs: []
  type: TYPE_IMG
- en: The preceding screenshot previews some of the features we discussed in the previous
    section. However, it will be difficult to find a forms plugins that provides all
    these features in a way that we expect to use them. Also, almost all the forms
    plugin don't provide a frontend interface to let the user edit the submitted data
    or list them. So, forms plugins are best-suited for scenarios where we want to
    use one-time forms to capture the user data. Popular examples include registration
    forms, contact forms, payment forms, and surveys. We should always use custom
    forms or custom post types to manage forms that requires the user to submit data,
    update it, and list all the submitted data.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The process of managing the data is one of the most important aspect of a website
    or application. WordPress custom post types allow us to model different content
    types in a standard way, and use built-in features for rapid development. We began
    the chapter by understanding the importance of custom post types and the features
    that made it a popular choice in plugin development. Then, we looked at the process
    of creating custom post types, while understanding the use of taxonomies and custom
    fields with custom post types. Next, we moved to the process and techniques of
    developing custom forms for the frontend of a website. Finally, we looked at the
    need for using forms plugins, and compared the advantages and disadvantages of
    custom post types and custom forms.
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 8](f84651b7-727e-4336-845c-14fc12ae10ab.xhtml), *Discovering Key
    Modules in Development*, we will be exploring the development of key modules in
    modern web sites, such as UI component integration, improving usability, and customizing
    core admin features.
  prefs: []
  type: TYPE_NORMAL
