<html><head></head><body>
        <section>

                            <header>
                    <h1 class="header-title">The Entity API</h1>
                </header>
            
            <article>
                
<p>In this chapter, we will explore the Entity API to create custom entities and see how they are handled and cover the following recipes:</p>
<ul>
<li>Creating a configuration entity type</li>
<li>Creating a content entity type</li>
<li>Creating a bundle for a content entity type</li>
<li>Implementing custom access control for an entity</li>
<li>Providing a custom storage handler</li>
<li>Creating a route provider</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Introduction</h1>
                </header>
            
            <article>
                
<p>In Drupal, entities are a representation of data that has a specific structure. There are specific entity types, which have different bundles and fields attached to those bundles. Bundles are implementations of entities that can have fields attached to themselves. In terms of programming, you can consider an entity that supports bundles as an abstract class and each bundle as a class that extends that abstract class. The fields are added to bundles. This is part of the reasoning for the terminology: an entity type can contain a <em>bundle</em> of fields.</p>
<p>An entity is an instance of an entity type defined in Drupal. Drupal 8 provides two entity types: <kbd>configuration</kbd> and <kbd>content</kbd>. Configuration entities are not fieldable and represent a configuration within a site. Content entities are fieldable and can have bundles. Bundles are, most commonly, controlled through configuration entities.</p>
<p>In Drupal 8, there is an <strong>Entity API</strong> module. It was created in Drupal 7 to expand the entity subsystem; most of its functionalities from Drupal 7 are now in its core. The goal of the module is to develop improvements for the developer experience around entities by merging more functionalities into the Drupal core during each minor release cycle (8.1.x, 8.2.x, and so on). There will be a <em>There's more...</em> section in <span>each recipe</span> that relates to how the Entity API module can simplify the recipe.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Creating a configuration entity type</h1>
                </header>
            
            <article>
                
<p>Drupal 8 harnesses the entity API for configuration to provide configuration validation and extended functionality. Using the underlying entity structure, the configuration has a proper <strong>Create</strong>, <strong>Read</strong>, <strong>Update</strong>, and <strong>Delete</strong> (<strong>CRUD</strong>) process that can be managed. Configuration entities are not fieldable. All the attributes of a configuration entity are defined in its configuration schema definition.</p>
<p>Most common configuration entities interact with Drupal core's <kbd>config_object</kbd> type, as discussed in <a href="a634af62-2148-4382-9121-b8500df169ed.xhtml"><em><span class="ChapterrefPACKT">Chapter 4</span></em></a>, <em>Extending Drupal</em>, and <a href="b2659986-a8dc-4503-a043-6071ab7b6722.xhtml"><em><span class="ChapterrefPACKT">Chapter 9</span></em></a>, <em>Configuration Management - Deploying in Drupal 8</em>, to store and manage a site's configuration. There are other uses of configuration entities, such as menus, view displays, form displays, and contact forms, which are all configuration entities.</p>
<p>In this recipe, we will create a new configuration entity type called <kbd>SiteAnnouncement</kbd>. This will provide a simple configuration entity that allows you to create, edit, and delete simple messages that can be displayed on the site for important announcements.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Getting ready</h1>
                </header>
            
            <article>
                
<p>You will need a custom module to place code into to implement a configuration entity type. Let's create an <kbd>src</kbd> directory for your classes. Refer to the <em>Creating a module</em> recipe of <a href="a634af62-2148-4382-9121-b8500df169ed.xhtml"><em>Chapter 4</em></a>, <em>Extending Drupal</em>, for information on creating a custom module.</p>
<p>Do not use a module that is currently installed, otherwise Drupal will not install your new entity type.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<ol>
<li>In our module's base directory, let's create a <kbd>config</kbd> directory with a <kbd>schema</kbd> subdirectory. In the subdirectory, create a file named <kbd>mymodule.schema.yml</kbd> that will hold your configuration entity's schema:</li>
</ol>
<div class="packt_figure CDPAlignCenter CDPAlign"><img class=" image-border" src="assets/7f681496-40ae-46eb-adbe-0b7fbcfa1c68.png"/></div>
<ol start="2">
<li>In our <kbd>mymodule.schema.yml</kbd>, add a definition to <kbd>mymodule.announcement.*:</kbd> to provide our label and message storage:</li>
</ol>
<pre style="padding-left: 60px"># Schema for the configuration files of the Site Announcement. 
 
mymodule.announcement.*: 
  type: config_entity 
  label: 'Site announcement' 
  mapping: 
    id: 
      type: string 
      label: 'ID' 
    label: 
      type: label 
      label: 'Label' 
    message: 
      type: text 
      label: 'Text' </pre>
<p style="padding-left: 60px">We will define the configuration entity's namespace as an announcement, which we will provide to Drupal in the entity's annotation block. We will then tell Drupal that this is a <kbd>config_entity</kbd> and provide a label for the schema.</p>
<p style="padding-left: 60px">Using the mapping array, we will provide the attributes that make up our entity and the data that will be stored.</p>
<ol start="3">
<li>Create an <kbd>Entity</kbd> directory in our module's <kbd>src</kbd> folder. First, we will create an interface for our entity by creating a <kbd>SiteAnnouncementInterface.php</kbd> file. The <kbd>SiteAnnouncementInterface</kbd> interface will extend the <kbd>\Drupal\Core\Config\Entity\ConfigEntityInterface</kbd>:</li>
</ol>
<pre style="padding-left: 60px">&lt;?php 
 
namespace Drupal\mymodule\Entity; 
 
use Drupal\Core\Config\Entity\ConfigEntityInterface; 
 
interface SiteAnnouncementInterface extends ConfigEntityInterface { 
 
  /** 
   * Gets the message value. 
   * 
   * @return string 
   */ 
  public function getMessage(); 
 
} </pre>
<p style="padding-left: 60px">This will be implemented by our entity, and will provide the method requirements. It is best practice to provide an interface for entities. This allows you to provide the required methods if another developer extends your entity or if you are doing advanced testing and need to mock an object. We also provide a method to return our custom attribute.</p>
<ol start="4">
<li>Let's create <kbd>SiteAnnouncement.php</kbd> in our <kbd>src/<span>Entity</span></kbd> directory. This file will contain the <kbd>SiteAnnouncement</kbd> class, which extends <kbd>\Drupal\Core\Config\Entity\ConfigEntityBase</kbd> and implements our entity's interface:</li>
</ol>
<pre style="padding-left: 60px">&lt;?php 
 
namespace Drupal\mymodule\Entity; 
 
use Drupal\Core\Config\Entity\ConfigEntityBase; 
 
class SiteAnnouncement extends ConfigEntityBase implements SiteAnnouncementInterface { 
 
  /** 
   * The announcement's message. 
   * 
   * @var string 
   */ 
  protected $message; 
 
  /** 
   * {@inheritdoc} 
   */ 
  public function getMessage() { 
    return $this-&gt;message; 
  } 
 
} </pre>
<p style="padding-left: 60px">In the preceding code, we added the <kbd>message</kbd> property defined in our schema as a class property. Our method defined in the entity's interface is used to return that value and interact with our configuration entity.</p>
<ol start="5">
<li>Entities use annotation documentation blocks. We will start our annotation block by providing the entity's ID, label, configuration prefix, and configuration export key names:</li>
</ol>
<pre style="padding-left: 60px">&lt;?php 
 
namespace Drupal\mymodule\Entity; 
 
use Drupal\Core\Config\Entity\ConfigEntityBase; 
 
/** 
 * @ConfigEntityType( 
 *   id ="announcement", 
 *   label = @Translation("Site Announcement"), 
 *   config_prefix = "announcement", 
 *   entity_keys = { 
 *     "id" = "id", 
 *     "label" = "label" 
 *   }, 
 *   config_export = { 
 *     "id", 
 *     "label", 
 *     "message", 
 *   } 
 * ) 
 */ 
class SiteAnnouncement extends ConfigEntityBase implements SiteAnnouncementInterface { 
 
  /** 
   * The announcement's message. 
   * 
   * @var string 
   */ 
  protected $message; 
 
  /** 
   * {@inheritdoc} 
   */ 
  public function getMessage() { 
    return $this-&gt;message; 
  } 
 
} </pre>
<p style="padding-left: 60px">The annotation document block tells Drupal that this is an instance of the <kbd>ConfigEntityType</kbd> plugin. The <kbd>id</kbd> is the internal machine name identifier for the entity type, and the <kbd>label</kbd> is its human-readable version. The <kbd>config_prefix</kbd> matches how we defined our schema with <kbd>mymodule.announcement</kbd>. The entity keys definition tells Drupal the attributes that represent our identifiers and labels.</p>
<p style="padding-left: 60px">When specifying <kbd>config_export</kbd>, we are telling the configuration management system what properties are exportable when exporting our entity.</p>
<ol start="6">
<li>Next, we will add <kbd>handlers</kbd> to our entity's annotation. We will define the class that will display the available entity entries and forms to work with our entity:</li>
</ol>
<pre style="padding-left: 60px">/** 
 * @ConfigEntityType( 
 *   id ="announcement", 
 *   label = @Translation("Site Announcement"), 
<strong> *   handlers = { 
 *     "list_builder" = "Drupal\mymodule\SiteAnnouncementListBuilder", 
 *     "form" = { 
 *       "default" = "Drupal\mymodule\SiteAnnouncementForm", 
 *       "add" = "Drupal\mymodule\SiteAnnouncementForm", 
 *       "edit" = "Drupal\mymodule\SiteAnnouncementForm", 
 *       "delete" = "Drupal\Core\Entity\EntityDeleteForm" 
 *     } 
 *   },</strong> 
 *   config_prefix = "announcement", 
 *   entity_keys = { 
 *     "id" = "id", 
 *     "label" = "label" 
 *   }, 
 *   config_export = { 
 *     "id", 
 *     "label", 
 *     "message", 
 *   } 
 * ) 
 */ </pre>
<p style="padding-left: 60px">The <kbd>handlers</kbd> array specifies classes that provide the interaction functionality with our entity. The <kbd>list_builder</kbd> class will be created to show you a table of our entities. The <kbd>form</kbd> array provides classes for forms to be used when creating, editing, or deleting our configuration entity.</p>
<ol start="7">
<li>Lastly, for our entity's annotation, we will need to define routes for our <kbd>delete</kbd>, <kbd>edit</kbd>, and <kbd>collection</kbd> (list) pages. Drupal will automatically build the routes based on our annotation:</li>
</ol>
<pre style="padding-left: 60px">/** 
 * @ConfigEntityType( 
 *   id ="announcement", 
 *   label = @Translation("Site Announcement"), 
 *   handlers = { 
 *     "list_builder" = "Drupal\mymodule\SiteAnnouncementListBuilder", 
 *     "form" = { 
 *       "default" = "Drupal\mymodule\SiteAnnouncementForm", 
 *       "add" = "Drupal\mymodule\SiteAnnouncementForm", 
 *       "edit" = "Drupal\mymodule\SiteAnnouncementForm", 
 *       "delete" = "Drupal\Core\Entity\EntityDeleteForm" 
 *     } 
 *   }, 
 *   config_prefix = "announcement", 
 *   entity_keys = { 
 *     "id" = "id", 
 *     "label" = "label" 
 *   }, 
<strong> *   links = { 
 *     "delete-form" = "/admin/config/system/site-announcements/manage/{announcement}/delete", 
 *     "edit-form" = "/admin/config/system/site-announcements/manage/{announcement}", 
 *     "collection" = "/admin/config/system/site-announcements", 
 *   },</strong> 
 *   config_export = { 
 *     "id", 
 *     "label", 
 *     "message", 
 *   } 
 * ) 
 */ </pre>
<p style="padding-left: 60px">There is a routing service for entities that will automatically provide Drupal a route with the proper controllers based on this annotation.</p>
<ol start="8">
<li>Create the <kbd>SiteAnnouncementListBuilder</kbd> class defined in our <kbd>list_builder</kbd> handler by creating a <kbd>SiteAnnouncementListBuilder.php</kbd> file in the module's <kbd>src</kbd> directory and extending the<br/>
<kbd>\Drupal\Core\Config\Entity\ConfigEntityListBuilder</kbd>:</li>
</ol>
<pre style="padding-left: 60px">&lt;?php 
 
namespace Drupal\mymodule; 
 
use Drupal\Core\Config\Entity\ConfigEntityListBuilder; 
use Drupal\mymodule\Entity\SiteAnnouncementInterface; 
 
class SiteAnnouncementListBuilder extends ConfigEntityListBuilder { 
 
  /** 
   * {@inheritdoc} 
   */ 
  public function buildHeader() { 
    $header['label'] = t('Label'); 
    return $header + parent::buildHeader(); 
  } 
 
  /** 
   * {@inheritdoc} 
   */ 
  public function buildRow(SiteAnnouncementInterface $entity) { 
    $row['label'] = $entity-&gt;label(); 
    return $row + parent::buildRow($entity); 
  } 
} </pre>
<p style="padding-left: 60px">In our list builder handler, we override the <kbd>buildHeader</kbd> and <kbd>builderRow</kbd> methods so that we can add our configuration entity's properties to the table.</p>
<ol start="9">
<li>Now, we will need to create an entity form, as defined in our form handler array, to handle our add and edit functionalities. Create <kbd>SiteAnnouncementForm.php</kbd> in the <kbd>src</kbd> directory to provide the <kbd>SiteAnnouncementForm</kbd> class that extends the <kbd>\Drupal\Core\Entity\EntityForm</kbd> class:</li>
</ol>
<pre style="padding-left: 60px">&lt;?php 
 
namespace Drupal\mymodule; 
 
use Drupal\Component\Utility\Unicode; 
use Drupal\Core\Entity\EntityForm; 
use Drupal\Core\Form\FormStateInterface; 
use Drupal\Core\Language\LanguageInterface; 
 
class SiteAnnouncementForm extends EntityForm { 
  /** 
   * {@inheritdoc} 
   */ 
  public function form(array $form, FormStateInterface $form_state) { 
    $form = parent::form($form, $form_state); 
 
    $form['label'] = [ 
      '#type' =&gt; 'textfield', 
      '#title' =&gt; t('Label'), 
      '#required' =&gt; TRUE, 
      '#default_value' =&gt; $entity-&gt;label(), 
    ]; 
    $form['message'] = [ 
      '#type' =&gt; 'textarea', 
      '#title' =&gt; t('Message'), 
      '#required' =&gt; TRUE, 
      '#default_value' =&gt; $entity-&gt;getMessage(), 
    ]; 
 
    return $form; 
  } 
 
  /** 
   * {@inheritdoc} 
   */ 
  public function save(array $form, FormStateInterface $form_state) { 
    $entity = $this-&gt;entity; 
    $is_new = !$entity-&gt;getOriginalId(); 
 
    if ($is_new) { 
      // Configuration entities need an ID manually set. 
      $machine_name = \Drupal::transliteration() 
        -&gt;transliterate($entity-&gt;label(), LanguageInterface::LANGCODE_DEFAULT, '_'); 
      $entity-&gt;set('id', Unicode::strtolower($machine_name)); 
 
      drupal_set_message(t('The %label announcement has been created.', array('%label' =&gt; $entity-&gt;label()))); 
    } 
    else { 
      drupal_set_message(t('Updated the %label announcement.', array('%label' =&gt; $entity-&gt;label()))); 
    } 
 
    $entity-&gt;save(); 
 
    // Redirect to edit form so we can populate colors. 
    $form_state-&gt;setRedirectUrl($this-&gt;entity-&gt;toUrl('collection')); 
  } 
} </pre>
<p style="padding-left: 60px">We override the <kbd>form</kbd> method to add Form API elements to our <kbd>label</kbd> and <kbd>message</kbd> properties. We also override the <kbd>save</kbd> method to provide user messages about the changes that are made. We utilize the entity's <kbd>toUrl</kbd> method to redirect it to the <kbd>collection</kbd> (list) page. We use the transliteration service to generate a machine name based on the label for our entity's identifier.</p>
<ol start="10">
<li>Next, we will create a <kbd>mymodule.links.action.yml</kbd> file in our module's directory. This will allow us to define action links on a route. We will be adding an <kbd>Add announcement</kbd> link to our entity's add form on its collection route:</li>
</ol>
<pre style="padding-left: 60px">announcement.add: 
  route_name: entity.announcement.add_form 
  title: 'Add announcement' 
  appears_on: 
    - entity.announcement.collection </pre>
<p style="padding-left: 60px">This will instruct Drupal to render the <kbd>entity.announcement.add_form</kbd> link on the specified routes in the <kbd>appears_on</kbd> value.</p>
<ol start="11">
<li>To have our site announcement's accessible from the main administrative pages, we will need to create a <kbd>mymodule.links.menu.yml</kbd> file in our module's directory:</li>
</ol>
<pre style="padding-left: 60px">mymodule.site_announcements:<br/>  title: 'Site announcements'<br/>  parent: system.admin_config_system<br/>  description: 'Manage site announcements.'<br/>  route_name: entity.announcement.collection</pre>
<ol start="12">
<li>Our module structure should look like the following screenshot:</li>
</ol>
<div class="packt_figure CDPAlignCenter CDPAlign"><img height="219" width="252" class="image-border" src="assets/14dc493f-5880-49e2-9275-efc5dfe455c3.png"/></div>
<ol start="13">
<li>Install the module and check out the <span class="packt_screen">Configuration</span> page. You can now manage the <kbd>Site Announcement</kbd> entries from the <span class="packt_screen">Site Announcement</span> link.</li>
</ol>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How it works...</h1>
                </header>
            
            <article>
                
<p>When creating a configuration schema definition, one of the first properties used for the configuration namespace is <kbd>type</kbd>. This value can be <kbd>config_object</kbd> or <kbd>config_entity</kbd>. When the type is <kbd>config_entity</kbd>, the definition will be used to create a database table rather than to structure the serialized data for the <kbd>config</kbd> table.</p>
<p>Entities are powered by the plugin system in Drupal, which means that there is a plugin manager. The default <kbd>\Drupal\Core\Entity\EntityTypeManager</kbd> provides discovery and handling of entities. The <kbd>ConfigEntityType</kbd> class for the entity type's plugin class will force the setting of the <kbd>uuid</kbd> and <kbd>langcode</kbd> in the <kbd>entity_keys</kbd> definition. The storage handler for configuration entities defaults to <kbd>\Drupal\Core\Config\Entity\ConfigEntityStorage</kbd>. The <kbd>ConfigEntityStorage</kbd> class interacts with the configuration management system to load, save, and delete custom configuration entities.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">There's more...</h1>
                </header>
            
            <article>
                
<p>Drupal 8 introduces a typed data system that configuration entities and fields use.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Available data types for schema definitions</h1>
                </header>
            
            <article>
                
<p>Drupal core provides its own configuration information. There is a <kbd>core.data_types.schema.yml</kbd> file located at <kbd>core/config/schema</kbd>. These are the base types of data that the core provides and can be used when making configuration schema. The file contains YAML definitions of data types and the class that represents them:</p>
<pre>boolean: 
  label: 'Boolean' 
  class: '\Drupal\Core\TypedData\Plugin\DataType\BooleanData' 
email: 
  label: 'Email' 
  class: '\Drupal\Core\TypedData\Plugin\DataType\Email' 
string: 
  label: 'String' 
  class: '\Drupal\Core\TypedData\Plugin\DataType\StringData' </pre>
<p>When a configuration schema definition specifies an attribute that has an email for its type, that value is then handled by the <kbd>\Drupal\Core\TypedData\Plugin\DataType\Email</kbd> class. Data types are a form of plugins, and each plugin's annotation specifies constraints for validation. This is built around the Symfony <strong>Validator</strong> component.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">See also</h1>
                </header>
            
            <article>
                
<ul>
<li><span class="ChapterrefPACKT"><span>Refer to</span> <a href="18026cd1-b8f0-48c0-9626-568ffd225eb5.xhtml"><em>Chapter 6</em></a></span><em><span class="ChapterrefPACKT">, Creating Forms with the Form API</span></em></li>
<li><span>Refer to</span> <em><span class="ChapterrefPACKT"><a href="a634af62-2148-4382-9121-b8500df169ed.xhtml">Chapter 4</a>, Extending Drupal</span></em></li>
<li><span>Refer to</span> <em><span class="ChapterrefPACKT"><a href="b2659986-a8dc-4503-a043-6071ab7b6722.xhtml">Chapter 9</a>, Confiuration Management - Deploying in Drupal 8</span></em></li>
<li>Refer to configuration schema/metadata at <a href="https://www.drupal.org/node/1905070"><span class="URLPACKT">https://www.drupal.org/node/1905070</span></a></li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Creating a content entity type</h1>
                </header>
            
            <article>
                
<p>Content entities provide base field definitions and configurable fields through the Field module. There is also support for revisions and translations with content entities. Display modes, both form and view, are available for content entities to control how the fields are edited and displayed. When an entity does not specify bundles, there is automatically one bundle instance with the same name as the entity.</p>
<p>In this recipe, we will create a custom content entity that does not specify a bundle. We will create a <kbd>Message</kbd> entity that can serve as a content entity for generic messages.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Getting ready</h1>
                </header>
            
            <article>
                
<p>You will need a custom module to place code into to implement a configuration entity type. Create an <kbd>src</kbd> directory for your classes. Refer to the <span><em>Creating a module</em> recipe of</span> <a href="a634af62-2148-4382-9121-b8500df169ed.xhtml"><em>Chapter 4</em></a>, <em>Extending Drupal</em>, for information on creating a custom module.</p>
<p>Do not use a module which is currently installed, otherwise Drupal will not install your new entity type.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<ol>
<li>Let's create an <kbd>Entity</kbd> directory in our module's <kbd>src</kbd> folder. First, we will create an interface for our entity by creating a <kbd>MessageInterface.php</kbd> file:</li>
</ol>
<div class="packt_figure CDPAlignCenter CDPAlign"><img height="148" width="332" class=" image-border" src="assets/9dc5892d-f44c-44b7-a872-1c2ec9110aae.png"/></div>
<ol start="2">
<li>The <kbd>MessageInterface</kbd> will extend <kbd>\Drupal\Core\Entity\ContentEntityInterface</kbd>:</li>
</ol>
<pre style="padding-left: 60px">&lt;?php 
 
namespace Drupal\mymodule\Entity; 
 
use Drupal\Core\Entity\ContentEntityInterface; 
 
interface MessageInterface extends ContentEntityInterface { 
 
  /** 
   * Gets the message value. 
   * 
   * @return string 
   */ 
  public function getMessage(); 
 
} 
 </pre>
<p style="padding-left: 60px">This will be implemented by our entity and will provide the method requirements. It is best practice to provide an interface for entities. This allows you to provide required methods if another developer extends your entity or if you are doing advanced testing and need to mock an object. We also provide a method to return our main base field definition (to be defined).</p>
<ol start="3">
<li>Then, let's create <kbd>Message.php</kbd> in our <kbd>Entity</kbd> directory in <kbd>src</kbd>. This file will contain the <kbd>Message</kbd> class, which extends <kbd>\Drupal\Core\Entity\ContentEntityBase</kbd> and implements our entity's interface:</li>
</ol>
<pre style="padding-left: 60px">&lt;?php 
 
namespace Drupal\mymodule\Entity; 
 
use Drupal\Core\Entity\ContentEntityBase; 
 
class Message extends ContentEntityBase implements MessageInterface { 
 
} </pre>
<ol start="4">
<li>We will need to create an annotation document block on our class to provide information about our entity, such as its <kbd>id</kbd>, <kbd>label</kbd>, and <kbd>entity</kbd> keys:</li>
</ol>
<pre style="padding-left: 60px">&lt;?php 
 
namespace Drupal\mymodule\Entity; 
 
use Drupal\Core\Entity\ContentEntityBase; 
 
/** 
 * Defines the message entity class. 
 * 
 * @ContentEntityType( 
 *   id = "message", 
 *   label = @Translation("Message"), 
 *   base_table = "message", 
 *   fieldable = TRUE, 
 *   entity_keys = { 
 *     "id" = "message_id", 
 *     "label" = "title", 
 *     "langcode" = "langcode", 
 *     "uuid" = "uuid" 
 *   }, 
 * ) 
 */ 
class Message extends ContentEntityBase implements MessageInterface { 
 
} </pre>
<p style="padding-left: 60px">The <kbd>id</kbd> is the internal machine name identifier for the entity type, and the <kbd>label</kbd> is its human-readable version. The entity keys definition tells Drupal the attributes that represent our identifier and label.</p>
<p style="padding-left: 60px">The <kbd>base_table</kbd> defines the database table in which the entity will be stored, and <kbd>fieldable</kbd> allows custom fields to be configured through the Field UI module.</p>
<ol start="5">
<li>Next, we will add <kbd>handlers</kbd> to our entity. We will use the default handlers provided by Drupal:</li>
</ol>
<pre style="padding-left: 60px">/** 
 * Defines the message entity class. 
 * 
 * @ContentEntityType( 
 *   id = "message", 
 *   label = @Translation("Message"), 
<strong> *   handlers = { 
 *     "list_builder" = "Drupal\mymodule\MessageListBuilder", 
 *     "form" = { 
 *       "default" = "Drupal\Core\Entity\EntityForm", 
 *       "add" = "Drupal\Core\Entity\EntityForm", 
 *       "edit" = "Drupal\Core\Entity\EntityForm", 
 *       "delete" = "Drupal\Core\Entity\ContentEntityDeleteForm", 
 *     }, 
 *   },</strong> 
 *   base_table = "message", 
 *   fieldable = TRUE, 
 *   entity_keys = { 
 *     "id" = "message_id", 
 *     "label" = "title", 
 *     "langcode" = "langcode", 
 *     "uuid" = "uuid" 
 *   }, 
 * ) 
 */ </pre>
<p style="padding-left: 60px">The <kbd>handlers</kbd> array specifies classes that provide the interaction functionality with our entity. The list builder class will be created to show you a table of our entities. The form array provides classes for forms to be used when creating, editing, or deleting our content entity.</p>
<ol start="6">
<li>An additional <kbd>handler</kbd>, the <kbd>route_provider</kbd>, <span>can be added</span> to dynamically generate our canonical (view), <kbd>edit</kbd>, <kbd>add</kbd>, <kbd>delete</kbd>, and <kbd>collection</kbd> (list) routes:</li>
</ol>
<pre style="padding-left: 60px">/** 
 * Defines the message entity class. 
 * 
 * @ContentEntityType( 
 *   id = "message", 
 *   label = @Translation("Message"), 
 *   handlers = { 
 *     "list_builder" = "Drupal\mymodule\MessageListBuilder", 
 *     "form" = { 
 *       "default" = "Drupal\Core\Entity\EntityForm", 
 *       "add" = "Drupal\Core\Entity\EntityForm", 
 *       "edit" = "Drupal\Core\Entity\EntityForm", 
 *       "delete" = "Drupal\Core\Entity\ContentEntityDeleteForm", 
 *     }, 
<strong> *     "route_provider" = { 
 *       "html" = "Drupal\Core\Entity\Routing\DefaultHtmlRouteProvider", 
 *     },</strong> 
 *   }, 
 *   base_table = "message", 
 *   fieldable = TRUE, 
 *   entity_keys = { 
 *     "id" = "message_id", 
 *     "label" = "title", 
 *     "langcode" = "langcode", 
 *     "uuid" = "uuid" 
 *   }, 
 *  links = { 
 *    "canonical" = "/messages/{message}", 
 *    "edit-form" = "/messages/{message}/edit", 
 *    "delete-form" = "/messages/{message}/delete", 
 *    "collection" = "/admin/content/messages" 
 *   }, 
 * ) 
 */ </pre>
<p style="padding-left: 60px">There is a routing service for entities that will automatically provide Drupal a route with the proper controllers based on this annotation.</p>
<ol start="7">
<li>We will then define an administration permission property in our entity's annotation, which the system checks, by default, for all create, update, and delete operations:</li>
</ol>
<pre style="padding-left: 60px">/** 
 * Defines the message entity class. 
 * 
 * @ContentEntityType( 
 *   id = "message", 
 *   label = @Translation("Message"), 
 *   handlers = { 
 *     "list_builder" = "Drupal\mymodule\MessageListBuilder", 
 *     "form" = { 
 *       "default" = "Drupal\Core\Entity\EntityForm", 
 *       "add" = "Drupal\Core\Entity\EntityForm", 
 *       "edit" = "Drupal\Core\Entity\EntityForm", 
 *       "delete" = "Drupal\Core\Entity\ContentEntityDeleteForm", 
 *     }, 
 *     "route_provider" = { 
 *       "html" = "Drupal\Core\Entity\Routing\DefaultHtmlRouteProvider", 
 *     }, 
 *   }, <br/><strong> *   admin_permission = "administer message",</strong>
 *   base_table = "message", 
 *   fieldable = TRUE, 
 *   entity_keys = { 
 *     "id" = "message_id", 
 *     "label" = "title", 
 *     "langcode" = "langcode", 
 *     "uuid" = "uuid" 
 *   }, 
 *  links = { 
 *    "canonical" = "/messages/{message}",<br/> *    "add-form" = "/messages/add",
 *    "edit-form" = "/messages/{message}/edit", 
 *    "delete-form" = "/messages/{message}/delete", 
 *    "collection" = "/admin/content/messages" 
 *   }, 
 * ) 
 */</pre>
<ol start="8">
<li>We will need to implement the <kbd>baseFieldDefinitions</kbd> method to satisfy the <kbd>FieldableEntityInterface</kbd> interface, which will provide our field definitions to the entity's base table. Add the following method to your class:</li>
</ol>
<pre style="padding-left: 60px">  /** 
   * {@inheritdoc} 
   */ 
  public static function baseFieldDefinitions(EntityTypeInterface $entity_type) { 
    $fields = parent::baseFieldDefinitions($entity_type); 
 
    $fields['title'] = BaseFieldDefinition::create('string') 
      -&gt;setLabel(t('Title')) 
      -&gt;setRequired(TRUE) 
      -&gt;setTranslatable(TRUE) 
      -&gt;setRevisionable(TRUE) 
      -&gt;setSetting('max_length', 255) 
      -&gt;setDisplayOptions('view', array( 
        'label' =&gt; 'hidden', 
        'type' =&gt; 'string', 
        'weight' =&gt; -5, 
      )) 
      -&gt;setDisplayOptions('form', array( 
        'type' =&gt; 'string_textfield', 
        'weight' =&gt; -5, 
      )) 
      -&gt;setDisplayConfigurable('form', TRUE); 
 
    $fields['content'] = BaseFieldDefinition::create('text_long') 
      -&gt;setLabel(t('Content')) 
      -&gt;setDescription(t('Content of the message')) 
      -&gt;setTranslatable(TRUE) 
      -&gt;setDisplayOptions('view', array( 
        'label' =&gt; 'hidden', 
        'type' =&gt; 'text_default', 
        'weight' =&gt; 0, 
      )) 
      -&gt;setDisplayConfigurable('view', TRUE) 
      -&gt;setDisplayOptions('form', array( 
        'type' =&gt; 'text_textfield', 
        'weight' =&gt; 0, 
      )) 
      -&gt;setDisplayConfigurable('form', TRUE); 
 
    return $fields; 
  } 
 
 </pre>
<p style="padding-left: 60px">The <kbd>FieldableEntityInterface</kbd> is implemented by the <kbd>ContentEntityBase</kbd> class using the <kbd>ContentEntityInterface</kbd>. The method needs to return an array of <kbd>BaseFieldDefinitions</kbd> for typed data definitions. The parent class provides field definitions for most of the <kbd>entity_keys</kbd> value in our entity's annotation. We must provide the label field and any specific fields for our implementation.</p>
<p style="padding-left: 60px">The <kbd>content</kbd> base field definition will hold the actual text of the message.</p>
<ol start="9">
<li>Next, we will implement the <kbd>getMessage</kbd> method in our class to satisfy our interface and provide a means to retrieve our message's text value:</li>
</ol>
<pre style="padding-left: 60px">/** 
 * {@inheritdoc} 
 */ 
public function getMessage() { 
  return $this-&gt;get('content')-&gt;value; 
} </pre>
<p style="padding-left: 60px">This method provides a wrapper around the defined base field's value and returns it.</p>
<ol start="10">
<li>Create the <kbd>MessageListBuilder</kbd> class defined in our <kbd>list_builder</kbd> handler by creating a <kbd>MessageListBuilder.php</kbd> file and extending <kbd>\Drupal\Core\Entity\EntityListBuilder</kbd>. We will need to override the default implementation to display our base field definitions:</li>
</ol>
<pre style="padding-left: 60px">&lt;?php 
 
namespace Drupal\mymodule; 
 
use Drupal\Core\Entity\EntityInterface; 
use Drupal\Core\Entity\EntityListBuilder; 
 
class MessageListBuilder extends EntityListBuilder { 
  public function buildHeader() { 
    $header['title'] = t('Title'); 
    return $header + parent::buildHeader(); 
  } 
 
  public function buildRow(EntityInterface $entity) { 
    $row['title'] = $entity-&gt;label(); 
    return $row + parent::buildRow($entity); 
  } 
 
} </pre>
<p style="padding-left: 60px">In our list builder handler, we override the <kbd>buildHeader</kbd> and <kbd>builderRow</kbd> methods so that we can add our configuration entity's properties to the table.</p>
<ol start="11">
<li>Before we move on, we must create a <kbd>mymodule.permissions.yml</kbd> file in the module's root directory. We will need to provide the permission definition for <kbd>administer message</kbd>, as provided in our annotation:</li>
</ol>
<pre style="padding-left: 60px">administer message:<br/>    title: 'Administer messages'</pre>
<ol start="12">
<li>Our module's structure should resemble the following screenshot:</li>
</ol>
<div class="CDPAlignCenter CDPAlign"><img style="font-family: 'Times New Roman', times, serif;font-size: 10pt;text-align: center" height="151" width="265" class="image-border" src="assets/6d41126a-ca11-4dc5-b575-1e586a49e447.png"/></div>
<ol start="13">
<li>Install the module. Go to <kbd>/messages/add</kbd> to create our first custom content entity entry and then view it on <kbd>/admin/content/messages</kbd>:</li>
</ol>
<div class="packt_figure CDPAlignCenter CDPAlign"><img height="210" width="647" class=" image-border" src="assets/6e08b985-9f9f-41c1-9351-a2edf7cf6930.png"/></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How it works...</h1>
                </header>
            
            <article>
                
<p>Content entities are a version of the <kbd>EntityType</kbd> plugin. When you define a content entity type, the annotation block begins with <kbd>@ContentEntityType</kbd>. This declaration and the properties in it represent the definition to initiate an instance of the <kbd>\Drupal\Core\Entity\ContentEntityType</kbd>, class just like all other plugin annotations. The <kbd>ContentEntityType</kbd> plugin class implements a constructor to provide default <kbd>storage</kbd> and <kbd>view_builder</kbd> handlers, forcing us to implement the <kbd>list_builder</kbd> and <kbd>form</kbd> handler arrays.</p>
<p>The plugin manager for entity types lives under the <kbd>entity_type.manager</kbd> service name and is provided through <kbd>\Drupal\Core\Entity\EntityTypeManager</kbd> by default. However, while the annotation defines the plugin information, our <kbd>Message</kbd> class that extends <kbd>ContentEntityBase</kbd> provides a means to manipulate the data it represents.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">There's more...</h1>
                </header>
            
            <article>
                
<p>We will discuss how to add an additional functionality to your entity and use the Entity module to simplify the developer expedience.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Using the AdminHtmlRouteProvider provider</h1>
                </header>
            
            <article>
                
<p>Our <kbd>Message</kbd> entity type implements the <kbd>DefaultHtmlRouteProvider</kbd> class. There is also the <kbd>\Drupal\Core\Entity\Routing\AdminHtmlRouteProvider</kbd> class. This overrides the <kbd>getEditFormRoute</kbd> and <kbd>getDeleteFormRoute</kbd> and marks them with <kbd>_admin_route</kbd>. This will cause these forms to be rendered in the administration theme.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Making the collection route a local task tab</h1>
                </header>
            
            <article>
                
<p>In this recipe, we specified the message collection route as <kbd>/admin/content/messages</kbd>. Without implementing this route as a local task under the <kbd>/admin/content</kbd> route, it will not show up as a tab. This can be done by creating a <kbd>links.task.yml</kbd> file for the module.</p>
<p>In <kbd>mymodule.links.task.yml</kbd>, add the following YAML content:</p>
<pre>entity.message.collection_tab: 
  route_name: entity.message.collection 
  base_route: system.admin_content 
  title: 'Messages' </pre>
<p>This instructs Drupal to use the <kbd>entity.message.collection</kbd> route, defined in our <kbd>routing.yml</kbd> file, to be based under the <kbd>system.admin_content</kbd> route:</p>
<div class="packt_figure CDPAlignCenter CDPAlign"><img height="249" width="606" class=" image-border" src="assets/c97ca917-6934-431a-90f8-3578a3f7fc01.png"/></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">See also</h1>
                </header>
            
            <article>
                
<ul>
<li>Refer to <a href="a634af62-2148-4382-9121-b8500df169ed.xhtml"><em><span class="ChapterrefPACKT">Chapter 4</span></em></a>, <em><span class="ChapterrefPACKT">Extending Drupal</span></em></li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Creating a bundle for a content entity type</h1>
                </header>
            
            <article>
                
<p>Bundles allow you to have different variations of a content entity. All bundles share the same base field definitions but not configured fields. This allows each bundle to have its own custom fields. Display modes are also dependent on a specific bundle. This allows each bundle to have its own configuration for the form mode and view mode.</p>
<p>Using the custom entity from the preceding recipe, we will add a configuration entity to act as the bundle. This will allow you to have different message types for multiple custom field configurations.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Getting ready</h1>
                </header>
            
            <article>
                
<p>We will need a custom module to place the code into to implement a configuration entity type. Create an <kbd>src</kbd> directory for your classes. We need a custom content entity type to be implemented, such as the one in the <em>Creating a content entity type</em> recipe of this chapter.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<ol>
<li>Since content entity bundles are configuration entities, we will need to define our configuration entity schema. Create a <kbd>config/schema</kbd> directory and <kbd>mymodule.schema.yml</kbd> file that will contain the configuration entity's schema:</li>
</ol>
<pre style="padding-left: 60px">mymodule.message_type.*: 
  type: config_entity 
  label: 'Message type settings' 
  mapping: 
    id: 
      type: string 
      label: 'Machine-readable name' 
    uuid: 
      type: string 
      label: 'UUID' 
    label: 
      type: label 
      label: 'Label' 
    langcode: 
      type: string 
      label: 'Default language' </pre>
<p style="padding-left: 60px">We will define the configuration entity's config prefix as <kbd>message_type</kbd>, which we will provide to Drupal in the entity's annotation block. We will tell Drupal that this is a <kbd>config_entity</kbd> and provide a label for the schema.</p>
<p style="padding-left: 60px">With the mapping array, we provide the attributes that make up our entity and the data that will be stored.</p>
<ol start="2">
<li>In our module's <kbd>src/Entity</kbd> directory, let's create an interface for our bundle by creating a <kbd>MessageTypeInterface.php</kbd> file. The <kbd>MessageTypeInterface</kbd> will extend the <kbd>\Drupal\Core\Config\Entity\ConfigEntityInterface</kbd>:</li>
</ol>
<pre style="padding-left: 60px">&lt;?php 
 
namespace Drupal\mymodule\Entity; 
 
use Drupal\Core\Config\Entity\ConfigEntityInterface; 
 
interface MessageTypeInterface extends ConfigEntityInterface { 
  // Empty for future enhancements. 
} </pre>
<p style="padding-left: 60px">This will be implemented by our entity and will provide the method requirements. It is best practice to provide an interface for entities. This allows you to provide required methods if another developer extends your entity or if you are doing advanced testing and need to mock an object.</p>
<p style="padding-left: 60px">We will be implementing a very basic bundle. It is still wise to provide an interface in the event of future enhancements and mocking ability in tests.</p>
<ol start="3">
<li>Create a <kbd>MessageType.php</kbd> file in <kbd>src/Entity</kbd>. This will hold the <kbd>MessageType</kbd> class, which will extend <kbd>\Drupal\Core\Config\Entity\ConfigEntityBundleBase</kbd> and implement our bundle's interface:</li>
</ol>
<pre style="padding-left: 60px">&lt;?php 
 
namespace Drupal\mymodule\Entity; 
 
use Drupal\Core\Config\Entity\ConfigEntityBundleBase; 
 
class MessageType extends ConfigEntityBundleBase implements MessageTypeInterface { 
 
} </pre>
<p style="padding-left: 60px">In most use cases, the bundle entity class can be an empty class that does not provide any properties or methods. If a bundle provides additional attributes in its schema definition, they would also be provided here, like any other configuration entity.</p>
<ol start="4">
<li>Entities need to be annotated. Create a base annotation for the <kbd>id</kbd>, <kbd>label</kbd>, <kbd>entity</kbd> keys, and <kbd>config_export</kbd> keys:</li>
</ol>
<pre style="padding-left: 60px">&lt;?php 
 
namespace Drupal\mymodule\Entity; 
 
use Drupal\Core\Config\Entity\ConfigEntityBundleBase; 
 
/** 
 * Defines the message type entity class. 
 * 
 * @ConfigEntityType( 
 *   id = "message_type", 
 *   label = @Translation("Message type"), 
 *   config_prefix = "message_type", 
 *   bundle_of = "message", 
 *   entity_keys = { 
 *     "id" = "id", 
 *     "label" = "label" 
 *   }, 
 *   config_export = { 
 *     "id", 
 *     "label", 
 *   }, 
 * ) 
 */ 
class MessageType extends ConfigEntityBundleBase implements MessageTypeInterface { 
 
} </pre>
<p style="padding-left: 60px">The annotation document block tells Drupal that this is an instance of the <kbd>ConfigEntityType</kbd> plugin. The <kbd>id</kbd> is the internal machine name identifier for the entity type and the <kbd>label</kbd> is its human-readable version. The <kbd>config_prefix</kbd> matches how we defined our schema using <kbd>mymodule.message_type</kbd>. The entity keys definition tells Drupal which attributes represent our identifiers and labels.</p>
<p style="padding-left: 60px">When specifying <kbd>config_export</kbd>, we are telling the configuration management system what properties are to be exported when exporting our entity.</p>
<ol start="5">
<li>We will then add handlers, which will interact with our entity:</li>
</ol>
<pre style="padding-left: 60px">/** 
 * Defines the message type entity class. 
 * 
 * @ConfigEntityType( 
 *   id = "message_type", 
 *   label = @Translation("Message type"), 
<strong> *   handlers = { 
 *     "list_builder" = "Drupal\mymodule\MessageTypeListBuilder", 
 *     "form" = { 
 *       "default" = "Drupal\Core\Entity\EntityForm", 
 *       "add" = "Drupal\Core\Entity\EntityForm", 
 *       "edit" = "Drupal\Core\Entity\EntityForm", 
 *       "delete" = "Drupal\Core\Entity\EntityDeleteForm" 
 *     }, 
 *   },</strong> 
 *   config_prefix = "message_type", 
 *   bundle_of = "message", 
 *   entity_keys = { 
 *     "id" = "id", 
 *     "label" = "label" 
 *   }, 
 *   config_export = { 
 *     "id", 
 *     "label", 
 *   }, 
 * ) 
 */ </pre>
<p style="padding-left: 60px">The <kbd>handlers</kbd> array specifies classes that provide the interaction functionality with our entity. The list builder class will be created to show you a table of our entities. The form array provides classes for forms to be used when creating, editing, or deleting our configuration entity.</p>
<ol start="6">
<li>An additional handler, the <kbd>route_provider</kbd>, <span>can be added</span> to dynamically generate our canonical (view), <kbd>edit</kbd>, <kbd>delete</kbd>, and <kbd>collection</kbd> (list) routes:</li>
</ol>
<pre style="padding-left: 60px">/** 
 * Defines the message type entity class. 
 * 
 * @ConfigEntityType( 
 *   id = "message_type", 
 *   label = @Translation("Message type"), 
 *   handlers = { 
 *     "list_builder" = "Drupal\mymodule\MessageTypeListBuilder", 
 *     "form" = { 
 *       "default" = "Drupal\Core\Entity\EntityForm", 
 *       "add" = "Drupal\Core\Entity\EntityForm", 
 *       "edit" = "Drupal\Core\Entity\EntityForm", 
 *       "delete" = "Drupal\Core\Entity\EntityDeleteForm" 
 *     }, 
<strong> *     "route_provider" = { 
 *       "html" = "Drupal\Core\Entity\Routing\DefaultHtmlRouteProvider", 
 *     },</strong> 
 *   }, 
 *   config_prefix = "message_type", 
 *   bundle_of = "message", 
 *   entity_keys = { 
 *     "id" = "id", 
 *     "label" = "label" 
 *   }, 
 *   config_export = { 
 *     "id", 
 *     "label", 
 *   }, 
 *   links = { 
 *     "add-form" = "/admin/structure/message-types/add", 
 *     "delete-form" = "/admin/structure/message-types/{message_type}/delete", 
 *     "edit-form" = "/admin/structure/message-types/{message_type}", 
 *     "admin-form" = "/admin/structure/message-types/{message_type}", 
 *     "collection" = "/admin/structure/message-types" 
 *   } 
 * ) 
 */ </pre>
<p style="padding-left: 60px">There is a routing service for entities that will automatically provide Drupal a route with the proper controllers based on this annotation. The add form route is not yet supported and needs to be manually added.</p>
<ol start="7">
<li>We will need to modify our content entity to use the bundle configuration entity that we defined. Edit the <kbd>src/Entity/Message.php</kbd> file and adjust the entity annotation:</li>
</ol>
<pre style="padding-left: 60px">/** 
 * Defines the message entity class. 
 * 
 * @ContentEntityType( 
 *   id = "message", 
 *   label = @Translation("Message"), 
 *   handlers = {...}, 
 *   base_table = "message", 
 *   fieldable = TRUE, 
<strong> *   bundle_entity_type = "message_type",</strong> 
 *   field_ui_base_route = "entity.message_type.edit_form", 
 *   entity_keys = { 
 *     "id" = "message_id", 
 *     "label" = "title", 
 *     "langcode" = "langcode", 
<strong> *     "bundle" = "type",</strong> 
 *     "uuid" = "uuid" 
 *   }, 
 *   links = {...}, 
 * ) 
 */ 
 </pre>
<p style="padding-left: 60px">The <kbd>bundle_entity_type</kbd> key specifies the entity type used as the bundle. The plugin validates this as an actual entity type and marks it for configuration dependencies. With the <kbd>field_ui_base_route</kbd> key pointed to the bundle's main edit form, it will generate the <kbd>Manage Fields</kbd>, <kbd>Manage Form Display</kbd>, and <kbd>Manage Display</kbd> tabs on the bundles. Finally, the <kbd>bundle</kbd> entity key instructs Drupal on the field definition to be used to identify the entity's bundle, which is created in the next step.</p>
<p style="padding-left: 60px">With the <kbd>bundle</kbd> entity key added, the <kbd>ContentEntityBase</kbd> class will automatically add an entity reference base field called <kbd>type</kbd> to our entity, referencing the bundle configuration entity type.</p>
<ol start="8">
<li>Create the <kbd>MessageTypeListBuilder</kbd> class defined in our <kbd>list_builder</kbd> handler in a <kbd>MessageTypeListBuilder.php</kbd> file and extend <kbd>\Drupal\Core\Config\Entity\ConfigEntityListBuilder</kbd>. We will need to override the default implementation to display our configuration entity properties:</li>
</ol>
<pre style="padding-left: 60px">&lt;?php 
 
namespace Drupal\mymodule; 
 
use Drupal\Core\Entity\EntityInterface; 
use Drupal\Core\Config\Entity\ConfigEntityListBuilder; 
 
class MessageTypeListBuilder extends EntityListBuilder { 
  public function buildHeader() { 
    $header['label'] = t('Label'); 
    return $header + parent::buildHeader(); 
  } 
 
  public function buildRow(EntityInterface $entity) { 
    $row['label'] = $entity-&gt;label(); 
    return $row + parent::buildRow($entity); 
  } 
 
} </pre>
<ol start="9">
<li>In our list builder handler, we will override the <kbd>buildHeader</kbd> and <kbd>builderRow</kbd> methods so that we can add our configuration entity's properties to the table:</li>
</ol>
<div class="packt_figure CDPAlignCenter CDPAlign"><img height="187" width="511" class=" image-border" src="assets/e30411a0-e45d-4be6-b57e-cea480150d15.png"/></div>
<ol start="10">
<li>Our module's structure should resemble the following screenshot:</li>
</ol>
<div class="packt_figure CDPAlignCenter CDPAlign"><img height="224" width="289" class="image-border" src="assets/caa1aee5-905e-4814-9524-4bfb9b2c81ef.png"/></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How it works...</h1>
                </header>
            
            <article>
                
<p>Bundles are most utilized in the configured field levels via the <kbd>Field</kbd> and <kbd>Field UI</kbd> modules. When you create a new field, it has a base storage item for its global settings. Once a field is added to a bundle, there is a new field configuration that is created and assigned to the bundle. Fields can then have their own settings for a specific bundle along with form and view display configurations.</p>
<p>Content entity bundles work just like any other configuration entity implementation, but they extend the usability of the Field API for your content entity types.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">There's more...</h1>
                </header>
            
            <article>
                
<p>We will discuss how to add additional functionality to our entity bundle and use the Entity module to simplify the developer expedience.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Provide action links for adding new bundles</h1>
                </header>
            
            <article>
                
<p>There are special links called <strong>action links</strong> in Drupal. These appear at the top of the page and are generally used for links that allow the creation of an item by creating a <kbd>links.action.yml</kbd> file.</p>
<p>In your <kbd>mymodule.links.action.yml</kbd>, each action link defines the route it will link to, titles, and the routes it appears on:</p>
<pre>message_type_add: 
  route_name: entity.message_type.add_form 
  title: 'Add message type' 
  appears_on: 
    - entity.message_type.collection </pre>
<p>The <kbd>appears_on</kbd> key accepts multiple values that will allow this route link to appear on multiple pages:</p>
<div class="packt_figure CDPAlignCenter CDPAlign"><img height="221" width="434" class=" image-border" src="assets/be9b8b23-4d9a-4cbe-bbaa-231140a75855.png"/></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">See also</h1>
                </header>
            
            <article>
                
<ul>
<li><span>Refer to</span> <a href="a634af62-2148-4382-9121-b8500df169ed.xhtml"><em><span class="ChapterrefPACKT">Chapter 4</span></em></a>, <em><span class="ChapterrefPACKT">Extending Drupal</span></em></li>
<li><span>Refer to</span> <a href="b2659986-a8dc-4503-a043-6071ab7b6722.xhtml"><em><span class="ChapterrefPACKT">Chapter 9</span></em></a>, <em><span class="ChapterrefPACKT">Configuration Management - Deploying in Drupal 8</span></em></li>
<li>Refer to the <em>Creating a Configuration Entity type</em> recipe in <em><span class="ChapterrefPACKT"><a href="2f5fe169-0ba6-4746-9586-896f00f0bb28.xhtml">Chapter 10</a></span></em>, <em><span class="ChapterrefPACKT">The Entity API</span></em></li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Implementing custom access control for an entity</h1>
                </header>
            
            <article>
                
<p>All entities have a set of handlers that control specific pieces of functionalities. One handler handles access control. When the access handler is not specified, the base <kbd>\Drupal\Core\Entity\EntityType</kbd> module will implement <kbd>\Drupal\Core\Entity\EntityAccessControlHandler</kbd> as the access handler. By default, this will check whether any modules have implemented <kbd>hook_entity_create_access</kbd> or <kbd>hook_entity_type_create_access</kbd> and use their opinions. Otherwise, it defaults to the admin permission for the entity type, if implemented.</p>
<p>In this recipe, we will provide an admin permission for our entity and implement the access handler and permission provider available through the Entity API module. We will base this on an entity called <strong>Message</strong>.</p>
<div class="packt_infobox">This recipe specifically uses the functionality from the Entity API module because it has been tested and thoroughly reviewed and reduces boilerplate code. Ideally, this will be part of an upcoming minor release of Drupal core.</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Getting ready</h1>
                </header>
            
            <article>
                
<p>We will need a custom module to place the code into to implement a configuration entity type. Let's create an <kbd>src</kbd> directory for our PSR-4 style classes. We will need to implement a custom content entity type, such as the one in the <em>Creating a content entity type</em> recipe of this chapter.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<ol>
<li>First, we will need to define an administration permission for the entity. This is done by ensuring that the <kbd>admin_permission</kbd> key is <span>present</span> in the entity's annotation document block:</li>
</ol>
<pre style="padding-left: 60px">/** 
 * Defines the message entity class. 
 * 
 * @ContentEntityType( 
 *   id = "message", 
 *   label = @Translation("Message"), 
 *   handlers = {...}, 
 *   base_table = "message", 
 *   fieldable = TRUE, 
<strong> *   admin_permission = "administer messages",</strong> 
 *   entity_keys = { 
 *     "id" = "message_id", 
 *     "label" = "title", 
 *     "langcode" = "langcode", 
 *     "uuid" = "uuid" 
 *   }, 
 *   links = {...}, 
 * ) 
 */ </pre>
<p style="padding-left: 60px">The entity access handler provided by the core will check whether entities implement this option. If it is provided, it will be used as the basis for access checks.</p>
<ol start="2">
<li>Next, we will want to specify permissions that are granular per bundle:</li>
</ol>
<pre style="padding-left: 60px">/** 
 * Defines the message entity class. 
 * 
 * @ContentEntityType( 
 *   id = "message", 
 *   label = @Translation("Message"), 
 *   handlers = {...}, 
 *   base_table = "message", 
 *   fieldable = TRUE, 
 *   admin_permission = "administer messages", 
<strong> *   permission_granularity = "bundle",</strong> 
 *   bundle_entity_type = "message_type", 
 *   field_ui_base_route = "entity.message_type.edit_form", 
 *   entity_keys = { 
 *     "id" = "message_id", 
 *     "label" = "title", 
 *     "langcode" = "langcode", 
 *     "bundle" = "type", 
 *     "uuid" = "uuid" 
 *   }, 
 *  links = {...}, 
 * ) 
 */ 
 </pre>
<p style="padding-left: 60px">The <kbd>permission_granularity</kbd> key will tell the system what permissions should be generated and how the access should be checked. This way, one user could create <em>Announcement</em> messages but not <em>Bulletin</em> messages.</p>
<ol start="3">
<li>Then, we define the <kbd>permission_provider</kbd> handler, which will generate our permissions:</li>
</ol>
<pre style="padding-left: 60px">/** 
 * Defines the message entity class. 
 * 
 * @ContentEntityType( 
 *   id = "message", 
 *   label = @Translation("Message"), 
 *   handlers = { 
 *     "list_builder" = "Drupal\mymodule\MessageListBuilder", 
<strong> *     "permission_provider" = "\Drupal\entity\EntityPermissionProvider",</strong> 
 *     "form" = {...}, 
 *     "route_provider" = {...}, 
 *   }, 
 *   base_table = "message", 
 *   fieldable = TRUE, 
 *   admin_permission = "administer messages", 
 *   permission_granularity = "bundle", 
 *   bundle_entity_type = "message_type", 
 *   field_ui_base_route = "entity.message_type.edit_form", 
 *   entity_keys = {...}, 
 *  links = {...}, 
 * ) 
 */ 
 </pre>
<ol start="4">
<li>The final adjustment to our entity annotation is to change the default access handler:</li>
</ol>
<pre style="padding-left: 60px">/** 
 * Defines the message entity class. 
 * 
 * @ContentEntityType( 
 *   id = "message", 
 *   label = @Translation("Message"), 
 *   handlers = { 
 *     "list_builder" = "Drupal\mymodule\MessageListBuilder", 
<strong> *     "access" = "\Drupal\entity\EntityAccessControlHandler",</strong> 
 *     "permission_provider" = "\Drupal\entity\EntityPermissionProvider", 
 *     "form" = {...}, 
 *     "route_provider" = {...}, 
 *   }, 
 *   base_table = "message", 
 *   fieldable = TRUE, 
 *   admin_permission = "administer messages", 
 *   permission_granularity = "bundle", 
 *   bundle_entity_type = "message_type", 
 *   field_ui_base_route = "entity.message_type.edit_form", 
 *   entity_keys = {...}, 
 *  links = {...}, 
 * ) 
 */ 
 </pre>
<ol start="5">
<li>Rebuild Drupal's caches, or install the module if it is not yet installed.</li>
</ol>
<p> </p>
<ol start="6">
<li>Verify that the permissions are available on the permission's overview page:</li>
</ol>
<div class="packt_figure CDPAlignCenter CDPAlign"><img height="284" width="612" class=" image-border" src="assets/42a5048e-fff5-4531-b45e-275aa72498c5.png"/></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How it works...</h1>
                </header>
            
            <article>
                
<p>Entities are powered by the plugin system in Drupal, which means that there is a plugin manager. The default <kbd>\Drupal\Core\Entity\EntityTypeManager</kbd> provides the discovery and handling of entities. Both the <kbd>ContentEntityType</kbd> and <kbd>ConfigEntityType</kbd> entity types and classes extend the base <kbd>\Drupal\Core\Entity\EntityType</kbd> class.</p>
<p>The <kbd>EntityType</kbd> class constructor provides a default <kbd>access</kbd> handler if it is not provided through the <kbd>\Drupal\Core\Entity\EntityAccessControlHandler</kbd> class. Every core module that provides an entity type implements this to override at least <kbd>checkAccess</kbd> and <kbd>checkCreateAccess</kbd>. Meanwhile, the Entity API access handler extends this to support bundle granular permissions and owner-based permissions if an entity implements <kbd>EntityOwnerInterface</kbd> in a reusable fashion.</p>
<p>The <kbd>\Drupal\Core\Access\AccessibleInterface</kbd> defines an <kbd>access</kbd> method, and all the entities inherit this interface. The default implementation in <kbd>\Drupal\Core\Entity\Entity</kbd> will invoke <kbd>checkCreateAccess</kbd> if the operation is <kbd>create</kbd>; otherwise, it invokes the generic <kbd>access</kbd> method of the access controller, which will invoke entity access hooks and the class' <kbd>checkAccess</kbd> method.</p>
<p>When Drupal generates available permissions, the Entity API module finds entity definitions that define the <kbd>permission_provider</kbd> handler and then invokes that class to generate permissions.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">There's more...</h1>
                </header>
            
            <article>
                
<p>We will discuss how to implement custom access control for an entity and use the Entity to simplify the controlling access.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Controlling access to entity fields</h1>
                </header>
            
            <article>
                
<p>The <kbd>checkFieldAccess</kbd> method in the core's entity access control handler can be overridden to control access to specific entity fields when modifying an entity. Without being overridden by a child class, the <kbd>\Drupal\Core\Entity\EntityAccessControlHandler::checkFieldAccess</kbd> will always return an allowed access result. The method receives the following parameters:</p>
<ul>
<li>The view and edit operations</li>
<li>The current field's definition</li>
<li>The user session to check access against</li>
<li>A possible list of field item values</li>
</ul>
<p>Entity types can implement their own access control handlers and override this method to provide granular control over the modification of their base fields. A good example would be the <kbd>User</kbd> module and its <kbd>\Drupal\user\UserAccessControlHandler</kbd>.</p>
<p>User entities have a <kbd>pass</kbd> field that is used for the user's current password. There is also a <kbd>created</kbd> field that records when the user was added to the site.</p>
<p>For the <kbd>pass</kbd> field, it returns <kbd>denied</kbd> if the operation is <kbd>view</kbd>, but allows access if the operation is <kbd>edit</kbd>:</p>
<pre>case 'pass': 
  // Allow editing the password, but not viewing it. 
  return ($operation == 'edit') ? AccessResult::allowed() : AccessResult::forbidden(); </pre>
<p>The <kbd>created</kbd> field uses the opposite logic. When a user logs in, the site can be viewed but cannot be edited:</p>
<pre>case 'created': 
  // Allow viewing the created date, but not editing it. 
  return ($operation == 'view') ? AccessResult::allowed() : AccessResult::forbidden(); </pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">See also</h1>
                </header>
            
            <article>
                
<ul>
<li><span class="ChapterrefPACKT">Refer to <a href="a634af62-2148-4382-9121-b8500df169ed.xhtml"><em>Chapter 4</em></a>, <em>Extending Drupal</em></span></li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Providing a custom storage handler</h1>
                </header>
            
            <article>
                
<p>Storage handlers control the loading, saving, and deleting of an entity. The <kbd>\Drupal\Core\Entity\ContentEntityType</kbd> provides the base entity type definition for all content entity types. If it is not specified, then the default storage handler is <kbd>\Drupal\Core\Entity\Sql\SqlContentEntityStorage</kbd>. This class can be extended to implement alternative <kbd>load</kbd> methods or adjustments on saving.</p>
<p>In this recipe, we will implement a method that supports loading an entity by a specific property instead of having to write a specific <kbd>loadByProperties</kbd> method call.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Getting ready</h1>
                </header>
            
            <article>
                
<p>You will need a custom module to place the code into to implement a configuration entity type. Create an <kbd>src</kbd> directory for your PSR-4 style classes. A custom content entity type needs to be implemented, such as the one in the <em>Creating a content entity type</em> recipe of this chapter.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<ol>
<li>Create a <kbd>MessageStorage</kbd> class in the module's <kbd>src</kbd> directory. This class will extend the default <kbd>\Drupal\Core\Entity\Sql\SqlContentEntityStorage</kbd> class:</li>
</ol>
<pre style="padding-left: 60px">&lt;?php 
 
namespace Drupal\mymodule; 
 
use Drupal\Core\Entity\Sql\SqlContentEntityStorage; 
 
/** 
 * Defines the entity storage for messages. 
 */ 
class MessageStorage extends SqlContentEntityStorage { 
 
} </pre>
<p style="padding-left: 60px">By extending the default storage class for our entity type, we can simply add new methods that are relevant to our requirements rather than implementing the extra business logic.</p>
<ol start="2">
<li>Create a <kbd>loadMultipleByType</kbd> method; using this method, we will provide a simple way to load all messages of a specific bundle:</li>
</ol>
<pre style="padding-left: 60px">  /** 
   * Load multiple messages by bundle type. 
   * 
   * @param string $message_type 
   *   The message type. 
   * 
   * @return array|\Drupal\Core\Entity\EntityInterface[] 
   *   An array of loaded message entities. 
   */ 
  public function loadMultipleByType($message_type) { 
    return $this-&gt;loadByProperties([ 
      'type' =&gt; $message_type, 
    ]); 
  } 
  </pre>
<p style="padding-left: 60px">We pass the <kbd>type</kbd> property so that we can query it based on the message bundle and return all matching message entities.</p>
<ol start="3">
<li>Update the entity's annotation block to have the new storage handler defined:</li>
</ol>
<pre style="padding-left: 60px">handlers = { 
  "list_builder" = "Drupal\mymodule\MessageListBuilder", 
  "access" = "\Drupal\entity\EntityAccessControlHandler", 
  "permission_provider" = "\Drupal\entity\EntityPermissionProvider", 
<strong>  "storage" = "Drupal\mymodule\MessageStorage",</strong> 
  "form" = { 
    "default" = "Drupal\Core\Entity\EntityForm", 
    "add" = "Drupal\Core\Entity\EntityForm", 
    "edit" = "Drupal\Core\Entity\EntityForm", 
    "delete" = "Drupal\Core\Entity\EntityDeleteForm" 
  }, 
  "route_provider" = { 
    "html" = "Drupal\Core\Entity\Routing\DefaultHtmlRouteProvider", 
  }, 
}, </pre>
<ol start="4">
<li>You can now programmatically interact with your message entities using the following code:</li>
</ol>
<pre style="padding-left: 60px">// Get the entity type manager from the container. 
\Drupal::entityTypeManager() 
 
// Access the storage handler. 
-&gt;getStorage('message') 
 
// Invoke the new method on custom storage class. 
-&gt;loadMultipleByType('message'); </pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How it works...</h1>
                </header>
            
            <article>
                
<p>When defining a content entity type, the annotation block begins with <kbd>@ContentEntityType</kbd>. This declaration, and the properties in it represents the definition to initiate an instance of the<br/>
<kbd>\Drupal\Core\Entity\ContentEntityType</kbd> class just like all other plugin annotations.</p>
<p>In the class constructor, there is a merge to provide default handlers for the <kbd>storage</kbd> handler if it is not provided. This will always default to <kbd>\Drupal\Core\Entity\Sql\SqlContentEntityStorage</kbd>, as it provides methods and logic to help its parent class, <kbd>ContentEntityStorageBase</kbd>, interact with the SQL-based storage.</p>
<div class="packt_infobox">Configuration entities can have their default <kbd>\Drupal\Core\Config\Entity\ConfigEntityStorage</kbd> as well. However, for configuration entities, the configuration management utilizes the <kbd>\Drupal\Core\Config\StorageInterface</kbd> implementations for storage rather than classes, which extend <kbd>ConfigEntityStorage</kbd>. This logic resides in the configuration factory service.</div>
<p>Extending <kbd>SqlContentEntityStorage</kbd> reuses methods required for default Drupal implementations and provides an easy method to create custom methods to interact with loading, saving, and so on.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">There's more...</h1>
                </header>
            
            <article>
                
<p>We will discuss the custom storage handler and utilization of different storage backends.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Utilizing a different storage backend for an entity</h1>
                </header>
            
            <article>
                
<p>Drupal provides mechanisms to support different database storage backends that are not provided by the Drupal core, such as MongoDB. Although it is not stable for Drupal 8 at the time of writing this book, there is a MongoDB module that provides storage interaction.</p>
<p>The module provides <kbd>\Drupal\mongodb\Entity\ContentEntityStorage</kbd>, which extends <kbd>\Drupal\Core\Entity\ContentEntityStorageBase</kbd>. This class overrides the methods used to create, save, and delete, to write them to a MongoDB collection.</p>
<p>The project can be found at <a href="https://www.drupal.org/project/mongodb">https://www.drupal.org/project/mongodb</a>.</p>
<p>While there are much more steps to provide a custom storage backend for content entities and their fields, this serves as an example for how you can choose to place a custom entity in different storage backends.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">See also</h1>
                </header>
            
            <article>
                
<ul>
<li>Refer to <a href="a634af62-2148-4382-9121-b8500df169ed.xhtml"><em><span class="ChapterrefPACKT">Chapter 4</span></em></a>, <em><span class="ChapterrefPACKT">Extending Drupal</span></em></li>
<li><span>Refer to</span> <a href="3994173f-3d31-4f01-b808-99e01368564b.xhtml"><em><span class="ChapterrefPACKT">Chapter 7</span></em></a>, <em><span class="ChapterrefPACKT">Plug and Play with Plugins</span></em></li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Creating a route provider</h1>
                </header>
            
            <article>
                
<p>Entities can implement a route provider that will create the route definitions for the entity's canonical (view), edit, delete, and collection (list) routes. As of Drupal 8.3.0, all the normally required routes are generated (this was not the case in 8.0.0). The provider takes the path for a specific link definition and turns that into a route and accessible path.</p>
<p>In this recipe, we will extend the default <kbd>\Drupal\Core\Entity\Routing\DefaultHtmlRouteProvider</kbd> and override the canonical route to be the same as the edit route, because we assume that messages will always be embedded.</p>
<div class="packt_infobox">This is related to a bug that is fixed in 8.4, where the Content Translation module caused errors by assuming that all entities have a canonical link, when they may only support edit--refer to <span class="URLPACKT"><a href="https://www.drupal.org/node/2479377">https://www.drupal.org/node/2479377</a></span>.</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Getting ready</h1>
                </header>
            
            <article>
                
<p>You will need a custom module to place the code into to implement a configuration entity type. Create an <kbd>src</kbd> directory for your classes. A custom content entity type needs to be implemented, such as the one in the <em>Creating a content entity type</em> recipe of this chapter.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<ol>
<li>Create a <kbd>MessageHtmlRouteProvider</kbd> class in the <kbd>src</kbd> directory that extends<br/>
<kbd>\Drupal\Core\Entity\Routing\DefaultHtmlRouteProvider</kbd>:</li>
</ol>
<pre style="padding-left: 60px">&lt;?php 
 
namespace Drupal\mymodule; 
 
use Drupal\Core\Entity\Routing\DefaultHtmlRouteProvider; 
 
/** 
 * Provides HTML routes for the message entity type. 
 */ 
class MessageHtmlRouteProvider extends DefaultHtmlRouteProvider { 
 
}</pre>
<ol start="2">
<li>Override the provided <kbd>getCanonicalRoute</kbd> method and return the value from <kbd>getEditFormRoute</kbd>:</li>
</ol>
<pre style="padding-left: 60px">&lt;?php 
 
namespace Drupal\mymodule; 
 
use Drupal\Core\Entity\EntityTypeInterface; 
use Drupal\Core\Entity\Routing\DefaultHtmlRouteProvider; 
 
/** 
 * Provides HTML routes for the message entity type. 
 */ 
class MessageHtmlRouteProvider extends DefaultHtmlRouteProvider { 
 
  /** 
   * {@inheritdoc} 
   */ 
  protected function getCanonicalRoute(EntityTypeInterface $entity_type) { 
    // Messages use the edit-form route as the canonical route. 
    // @todo Remove this when #2479377 gets fixed. 
    return $this-&gt;getEditFormRoute($entity_type); 
  } 
 
} </pre>
<ol start="3">
<li>Rebuild Drupal's caches for the change to take effect and routes to be rebuilt.</li>
</ol>
<ol start="4">
<li>Navigating to <kbd>/message/{message}</kbd> will now load the edit form, just as <kbd>/message/{message}/edit</kbd>.</li>
</ol>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How it works...</h1>
                </header>
            
            <article>
                
<p>Entities are powered by the plugin system in Drupal, which means that there is a plugin manager. The default <kbd>\Drupal\Core\Entity\EntityTypeManager</kbd> provides discovery and handling of entities. The <kbd>\Drupal\Core\Entity\EntityTypeManagerInterface</kbd> specifies a <kbd>getRouteProviders</kbd> method that is expected to return an array of strings that provide the fully qualified class name of an implementation of the <kbd>\Drupal\Core\Entity\Routing\EntityRouteProviderInterface</kbd> interface.</p>
<p>There is an event subscriber defined in <kbd>core.services.yml</kbd> called the <kbd>entity_route_subscriber</kbd>. This service subscribes to the dynamic route event. When this happens, it uses the entity type manager to retrieve all entity type implementations, which provide route subscribers. It then aggregates all the <kbd>\Symfony\Component\Routing\RouteCollection</kbd> instances received and merges them into the main route collection for the system.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">There's more...</h1>
                </header>
            
            <article>
                
<p>Drupal 8 introduces router types and provide the add routes for our entity.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The Entity API module provides additional providers</h1>
                </header>
            
            <article>
                
<p>The Entity module provides two new route providers aimed specifically for entities that support revisions and a bulk delete form option.</p>
<p>If you have an entity that implements the <kbd>RevisionLogInterface</kbd> interface, the revision route provider generates a user interface for managing revisions. You then add a <kbd>revision</kbd> entry for the <kbd>router_providers</kbd> array pointing to the new route provider:</p>
<pre> *     "route_provider" = { 
 *       "html" = "Drupal\Core\Entity\Routing\DefaultHtmlRouteProvider", 
 *       "revision" = "Drupal\entity\Routing\RevisionRouteProvider", 
 *     }, </pre>
<p>Then, you just need to define additional items in your entity's <kbd>links</kbd> definition:</p>
<pre>*   links = { 
*     "revision" = "/messages/{message}/revisions/{message_revision}/view",<br/> *     "revision-revert-form" = "/messages/{message_enhanced}/revisions/{message_revision}/revert",<br/> *     "version-history" = "/messages/{message}/revisions", 
*    "canonical" = "/messages/{message}", 
 *    "edit-form" = "/messages/{message}/edit", 
 *    "delete-form" = "/messages/{message}/delete", 
 *    "collection" = "/admin/content/messages" 
 *   } </pre>
<p>This reduces the amount of boilerplate code required to implement an <kbd>Entity</kbd>. For an implementation example, refer to the <kbd>EnhancedEntity</kbd> class in the Entity API's test module <kbd>entity_module_test</kbd>.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">See also</h1>
                </header>
            
            <article>
                
<ul>
<li>Refer to <em><span class="ChapterrefPACKT"><a href="a634af62-2148-4382-9121-b8500df169ed.xhtml">Chapter 4</a></span></em>, <em><span class="ChapterrefPACKT">Extending Drupal</span></em></li>
<li>Refer to the routing system in Drupal 8 at <a href="https://www.drupal.org/developing/api/8/routing"><span class="URLPACKT">https://www.drupal.org/developing/api/8/routing</span></a></li>
</ul>


            </article>

            
        </section>
    </body></html>