- en: Chapter 2. Managing the Environment
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Throughout this chapter, we will look into setting up our development and production
    environments. The idea is to have a fully automated development environment, which
    can be initiated with a single console command. For a production environment,
    we will turn our focus to one of the available cloud services, and see how easy
    it is to set up Magento for simpler production projects. We will not be covering
    any robust environment setups like auto-scaling, caching servers, content delivery
    networks, and similar. These are really jobs for *System Administrator or DevOps*
    roles. Our attention here is the bare minimum needed to get our Magento store
    up and running; a milestone we will achieve throughout the following sections
    would be:'
  prefs: []
  type: TYPE_NORMAL
- en: Setting up a development environment
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: VirtualBox
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Vagrant
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Vagrant project
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Provisioning PHP
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Provisioning MySQL
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Provisioning Apache
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Provisioning Magento installation
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Setting up a production environment
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction to **Amazon Web Services** (**AWS**)
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Setting up access for S3 usage
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating IAM users
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating IAM groups
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Setting up S3 for database and media files backup
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Bash script for automated EC2 setup
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Setting up EC2
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Setting up Elastic IP and DNS
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Setting up a development environment
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will build a development environment using **VirtualBox**
    and **Vagrant**.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Magento official requirements call for Apache 2.2 or 2.4, PHP 5.6.x or 5.5.x
    (PHP 5.4 is not supported), and MySQL 5.6.x. We need to keep this in mind during
    the environment setup.
  prefs: []
  type: TYPE_NORMAL
- en: VirtualBox
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**VirtualBox** is powerful and feature-rich x86 and AMD64/Intel64 virtualization
    software. It is free, runs on a large number of platforms, and supports a large
    number of guest operating systems. If we are using Windows, Linux, or OS X in
    our daily development, we can use VirtualBox to spin up a virtual machine with
    an isolated guest operating system in which we can install our server software
    needed to run Magento. This means using MySQL, Apache, and a few other things.'
  prefs: []
  type: TYPE_NORMAL
- en: Vagrant
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Vagrant** is a high-level software wrapper used for virtualization software
    management. We can use it to create and configure development environments. Vagrant
    supports several types of virtualization software such as VirtualBox, **VMware,
    Kernel-based Virtual Machine** (**KVM**), **Linux Containers** (**LXC**), and
    others. It even supports server environments like Amazon EC2.'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Before we start, we need to make sure we have VirtualBox and Vagrant installed
    already. We can download them and install the following instructions from their
    official websites: [https://www.virtualbox.org](https://www.virtualbox.org) and
    [https://www.vagrantup.com](https://www.vagrantup.com).'
  prefs: []
  type: TYPE_NORMAL
- en: Vagrant project
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We start by manually creating an empty directory somewhere within our host operating
    system, let's say `/Users/branko/www/B05032-Magento-Box/`. This is the directory
    we will pull in Magento code. We want Magento source code to be external to Vagrant
    box, so we can easily work with it in our favorite IDE.
  prefs: []
  type: TYPE_NORMAL
- en: We then create a Vagrant project directory, let's say `/Users/branko/www/magento-box/`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Within the `magento-box` directory, we run the console command `vagrant init`.
    This results in an output as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'The `Vagrantfile` is actually a Ruby language source file. If we strip away
    the comments, its original content looks like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: If we were to run `vagrant up` now within the `magento-box` directory, this
    would start the VirtualBox in headless (no GUI) mode and run the base operating
    system. However, let's hold off running that command just now.
  prefs: []
  type: TYPE_NORMAL
- en: The idea is to create a more robust `Vagrantfile` that covers everything required
    for running Magento, from Apache, MySQL, PHP, PHPUnit, composer, and full Magento
    installation with performance fixture data.
  prefs: []
  type: TYPE_NORMAL
- en: Though Vagrant does not have a separate configuration file on its own, we will
    create one, as we want to store configuration data like a MySQL user and password
    in it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s go ahead and create the `Vagrantfile.config.yml` file, alongside a `Vagrantfile`
    in the same directory, with content as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: There is no Vagrant-imposed structure here. This can be any valid YAML file.
    The values presented are merely examples of what we can put in.
  prefs: []
  type: TYPE_NORMAL
- en: Magento enables us to generate a pair of 32-character authentication tokens
    that can use to access the Git repository. This is done by logging in to Magento
    Connect with a user name and password, then going to **My Account** | **Developers**
    | **Secure Keys**. The Public Key and Private Key then become our username and
    password for accessing Magento GitHub repository.
  prefs: []
  type: TYPE_NORMAL
- en: Having a separate configuration file means we can commit `Vagrantfile` to version
    control with our project, while leaving the `Vagrantfile.config.yml` out of version
    control.
  prefs: []
  type: TYPE_NORMAL
- en: 'We now edit the `Vagrantfile` by replacing its content with the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code first includes the `yaml` library, and then reads the content
    of the `Vagrantfile.config.yml` file into a `vagrantConfig` variable. Then we
    have a `config` block, within which we define the box type, fixed IP address,
    shared folder between our host and guest operating system, and a few VirtualBox
    specific details such as CPU and memory allocated.
  prefs: []
  type: TYPE_NORMAL
- en: We are using the `ubuntu/vivid64` box that stands for the server edition of
    Ubuntu 15.04 (Vivid Vervet). The reason is that this Ubuntu version gives us the
    MySQL 5.6.x and PHP 5.6.x, which stand as requirements for Magento installation,
    among other things.
  prefs: []
  type: TYPE_NORMAL
- en: 'We further have a configuration entry assigning a fixed IP to our virtual machine.
    Let''s go ahead and add an entry in the *hosts* file of our host operating system
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The reason why we are assigning the fixed IP address to our box is that we can
    directly open a URL like `http://magento.box` within our host operating system,
    and then access Apache served page within our guest operating system.
  prefs: []
  type: TYPE_NORMAL
- en: Another important part of the preceding code is the one where we defined `synced_folder`.
    Besides source and destination paths, the crucial parts here are `owner`, group,
    and `mount_options`. We set those to the vagrant user the `www-data` user group,
    and `774` and `664` for directory and file permissions that play nicely with Magento.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s continue editing our `Vagrantfile` adding several provisioners to it,
    one below the other. We do so by replacing the `# <provisioner here>` from the
    preceding example, with content as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Here we are instructing Vagrant to pass our `.gitconfig` file from the host
    to the guest operating system. This is so we inherit the host operating system
    Git setup to the guest operating system Git. We then call for `apt-get update`
    in order to update the guest operating system.
  prefs: []
  type: TYPE_NORMAL
- en: Provisioning PHP
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Further adding to `Vagrantfile`, we run several provisioners that will install
    PHP, required PHP modules, and PHPUnit, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: There is one thing worth pointing out here – the line where we are writing `xdebug.max_nesting_level=200`
    into the `php.ini` file. This is done to exclude the possibility that Magento
    would not start throwing a **Maximum Functions Nesting Level of '100' reached...**
    error.
  prefs: []
  type: TYPE_NORMAL
- en: Provisioning MySQL
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Further adding to `Vagrantfile`, we run provisioners that will install the
    MySQL server, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: What is interesting with the MySQL installation is that it requires a password
    and a password confirmation to be provided during installation. This makes it
    a troubling part of the provisioning process that expects shell commands to simply
    execute without asking for input. To bypass this, we use `debconf-set-selections`
    to store the parameters for input. We read the password from the `Vagrantfile.config.yml`
    file and pass it onto `debconf-set-selections`.
  prefs: []
  type: TYPE_NORMAL
- en: Once installed, `update-rc.d mysql` defaults will add MySQL to the operating
    system boot process, thus making sure MySQL is running when we reboot the box.
  prefs: []
  type: TYPE_NORMAL
- en: Provisioning Apache
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Further adding to `Vagrantfile`, we run the Apache provisioner as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code installs Apache, adds it to the boot sequence, starts it,
    and turns on the rewrite module. We then have an update to the Apache configuration
    file, as we want to replace `AllowOverride None` with `AllowOverride All`, or
    else our Magento won't work. Once the changes are done, we stop Apache due to
    the later processes.
  prefs: []
  type: TYPE_NORMAL
- en: Provisioning Magento installation
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Further adding to `Vagrantfile`, we now turn our attention to Magento installation,
    which we split into several steps. First, we link our host folder, `/vagrant-B05032-Magento-Box/`,
    with the guest, `/var/www/html`, using Vagrant''s synced folder feature:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'We then use the `composer create-project` command to pull the Magento 2 files
    from the official `repo.magento.com` source into the `/var/www/html/` director:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'We then create a database in which Magento will be installed later on:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'We then run the Magento installation from the command line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code shows we are installing the fixtures data as well.
  prefs: []
  type: TYPE_NORMAL
- en: 'We need to be careful during the `Vagrantfile.config.yml` file configuration.
    Magento installation is quite sensible around provided data. We need to make sure
    we provide valid data for fields like mail and password or else the installation
    will fail showing errors similar to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: With this, we conclude our `Vagrantfile` content.
  prefs: []
  type: TYPE_NORMAL
- en: Running the `vagrant up` command now within the same directory as `Vagrantfile`
    triggers the box creation process. During this process, all of the previously
    listed commands will get executed. The process alone takes up to an hour or so.
  prefs: []
  type: TYPE_NORMAL
- en: Once vagrant up is complete, we can issue another console command, `vagrant
    ssh`, to log in to the box.
  prefs: []
  type: TYPE_NORMAL
- en: At the same time, if we open a URL like `http://magento.box` in our browser,
    we should see the Magento storefront loading.
  prefs: []
  type: TYPE_NORMAL
- en: The preceding `Vagrantfile` simply pulls from the official Magento Git repository
    and installs Magento from the ground up. `Vagrantfile` and `Vagrantfile.config.yml`
    can be further extended and tailored to suit our individual project needs, like
    pulling the code from the private Git repository, restoring the database from
    the shared drive, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: This makes for a simple yet powerful scripting process by which we can prepare
    fully ready per-project machines for other developers in a team to be able to
    quickly spin up.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up a production environment
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A production environment is the client-facing environment that focuses on good
    performance and availability. Setting up production environments is not really
    something we developers tend to do, especially if there are robust requirements
    around scaling, load balancing, high availability, and similar. Sometimes, however,
    we need to set up a simple production environment. There are various cloud providers
    that offer quick and simple solutions to this. For the purpose of this section,
    we will turn to Amazon Web Services.
  prefs: []
  type: TYPE_NORMAL
- en: Introduction to Amazon Web Services
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Amazon Web Services** (**AWS**) is a collection of remote computing services
    frequently referred to as web services. AWS provides on-demand computing resources
    and services in the cloud, with *pay-as-you-go* pricing. Amazon gives a nice comparison
    of its AWS resources, saying that using AWS resources instead of your own is like
    purchasing electricity from a power company instead of running your own generator.'
  prefs: []
  type: TYPE_NORMAL
- en: If we stop and think about it for a minute, this makes it interesting to not
    only system operation roles but also for developers like us. We (developers) are
    now able to spin various databases, web application servers, and even complex
    infrastructures in a matter of minutes and a few mouse clicks. We can run these
    services for a few minutes, hours, or days then shut them down. Meanwhile, we
    only pay for the actual usage, not the full monthly or yearly price as we do with
    most of the hosting services. Although the overall AWS pricing for certain services
    might not be the cheapest out there, it certainly provides a level of commodity
    and usability unlike many other services. Commodity comes from things like auto-scaling
    resources, a feature that often offers significant cost savings compared to the
    equivalent on-premises infrastructure.
  prefs: []
  type: TYPE_NORMAL
- en: Quality training and a certification program is another important aspect of
    the AWS ecosystem. Certifications are available for **Solutions Architect**, **Developer**,
    and **SysOps Administrator**, across associate and professional levels. Though
    the certification is not mandatory, if we deal with AWS on a regular basis, we
    are encouraged to take one. Earning the certification puts the seal on our expertise
    to design, deploy, and operate highly available, cost-effective, and secure applications
    on the AWS platform.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can manage our AWS through a simple and intuitive web-based user interface
    called AWS management console, which is available at [https://aws.amazon.com/console](https://aws.amazon.com/console).
    Signing into AWS, we should be able to see a screen similar to the following one:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Introduction to Amazon Web Services](img/00002.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'The preceding image shows how the AWS management console groups the AWS services
    visually into several major groups, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Compute**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Developer Tools**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Mobile Services**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Storage & Content Delivery**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Management Tools**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Application Services**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Database**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Security & Identity**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Networking**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Analytics**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Enterprise Applications**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As part of this chapter, we will be taking a look at the **EC2** service found
    under the **Compute** group and the **S3** service found under the **Storage &
    Content Delivery** group.
  prefs: []
  type: TYPE_NORMAL
- en: '**Amazon Elastic Compute Cloud** (**Amazon EC2**) is a web service that provides
    a re-sizable compute capacity in the cloud. We can think of it as a virtual computer
    machine in the cloud that we can turn on and off at any time, within minutes.
    We can further commission one, hundreds, or even thousands of these machine instances
    simultaneously. This makes for the *re-sizable* compute capacity.'
  prefs: []
  type: TYPE_NORMAL
- en: S3 provides secure, durable, and highly scalable object storage. It is designed
    to provide durability of 99.99% of objects. The service provides a web service
    interface to store and retrieve any amount of data from anywhere on the web. S3
    is charged only per storage that is actually used. S3 can be used alone or together
    with other AWS services such as EC2.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up access for S3 usage
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As part of our production environment, it is good to have reliable storage where
    we can archive database and media files. Amazon S3 stands out as a possible solution.
  prefs: []
  type: TYPE_NORMAL
- en: In order to properly set access to the S3 scalable storage service, we need
    to take a quick look into AWS **Identity and Access Management** (**IAM** for
    short). IAM is a web service that helps us securely control access to AWS resources
    for our users. We can use IAM to control authentication (who can use our AWS resources)
    and authorization (what resources they can use and in what ways). More specifically,
    as we will soon see, we are interested in **Users** and **Groups**.
  prefs: []
  type: TYPE_NORMAL
- en: Creating IAM users
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This section describes how to create IAM users. An IAM user is an entity that
    we create in AWS to represent the person or service using it when interacting
    with AWS.
  prefs: []
  type: TYPE_NORMAL
- en: Log in to the AWS console.
  prefs: []
  type: TYPE_NORMAL
- en: 'Under the user menu, click on **Security Credentials** as shown in the following
    screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating IAM users](img/00003.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: This opens up the security dashboard page.
  prefs: []
  type: TYPE_NORMAL
- en: 'Clicking on the **Users** menu should open a screen like the following one:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating IAM users](img/00004.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'On the **Users** menu, we click on **Create New User**, which opens a page
    like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating IAM users](img/00005.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Here, we fill in the desired username for one or more users, something like
    `foggy_s3_user1`, and then click on the **Create** button.
  prefs: []
  type: TYPE_NORMAL
- en: 'We should now see a screen like the following one:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating IAM users](img/00006.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Here, we can click on **Download Credentials** to initiate the CSV format file
    download or copy and paste our credentials manually.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Access Key ID** and **Secret Access Key** are the two pieces of information
    we will be using to access S3 storage.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Clicking the close link takes us back to the **Users** menu, showing our newly
    created user listed as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating IAM users](img/00007.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Creating IAM groups
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'This section describes how to create IAM groups. Groups are collections of
    IAM users that we can manage as a single unit. So let''s begin:'
  prefs: []
  type: TYPE_NORMAL
- en: Log in to the AWS console.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Under the user menu, click on **Security Credentials** as shown in the following
    screenshot:![Creating IAM groups](img/00008.jpeg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: This opens up the security dashboard page. Clicking on the **Groups** menu should
    open a screen like the following one:![Creating IAM groups](img/00009.jpeg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: On the **Groups** menu, we click on **Create New Group**, which opens a page
    like the following:![Creating IAM groups](img/00010.jpeg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Here, we fill in the desired group name, something like `FoggyS3Test`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We should now see a screen like the following one, where we need to select the
    group **Policy Type** and click the **Next Step** button:![Creating IAM groups](img/00011.jpeg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We select the **AmazonS3FullAccess** policy type and click the **Next Step**
    button. The **Review** screen is now shown, asking us to review the provided information:![Creating
    IAM groups](img/00012.jpeg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If the provided information is correct, we confirm it by clicking the **Create
    Group** button. We should now be able to see our group under the **Groups** menu
    as shown in the following screenshot:![Creating IAM groups](img/00013.jpeg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Mark the checkbox to the left of **Group Name**, click the **Group Actions**
    dropdown, and then select **Add Users to Group** as shown in the following screenshot:![Creating
    IAM groups](img/00014.jpeg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: This opens the **Add Users to Group** page as shown in the following screenshot:![Creating
    IAM groups](img/00015.jpeg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Mark the checkbox to the left of **User Name** and click on the **Add Users**
    button. This should add the selected user to the group and throw us back to the
    **Groups** listing.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The result of this user and group creation process is a user with **Access Key
    Id**, **Secret Access Key**, and assigned user group with the **AmazonS3FullAccess**
    policy. We will use this information later on when we demonstrate backing up the
    database to S3.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up S3 for database and media files backup
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: S3 consists of buckets. We can think of a bucket as the first level directory
    within our S3 account. We then set the permissions and other options on that directory
    (bucket). In this section, we are going to create our own bucket, with two empty
    folders called `database` and `media`. We will use these folders later on during
    our environment setup in order to back up our MySQL database and our media files.
  prefs: []
  type: TYPE_NORMAL
- en: We start by logging in to the AWS management console.
  prefs: []
  type: TYPE_NORMAL
- en: 'Under the **Storage & Content Delivery** group, we click on **S3**. This opens
    a screen similar to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Setting up S3 for database and media files backup](img/00016.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Click on the **Create Bucket** button. This opens a popup like the one shown
    in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Setting up S3 for database and media files backup](img/00017.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Let's provide a unique **Bucket Name**, preferably something identifying the
    project for which we will be backing up the `database` and `media` file, and click
    the **Create** button. For the purpose of this chapter, let's imagine we selected
    something like `foggy-project-dhj6`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Our bucket should now be visible under the **All Buckets** list. If we click
    on it, a new screen opens like the one shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Setting up S3 for database and media files backup](img/00018.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Here, we click on the **Create Folder** button and add the necessary `database`
    and `media` folders.
  prefs: []
  type: TYPE_NORMAL
- en: 'While still within the root bucket directory, click on the **Properties** button
    and fill in the **Permissions** section as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Setting up S3 for database and media files backup](img/00019.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Here, we are basically assigning all permissions to **Authenticated Users**.
  prefs: []
  type: TYPE_NORMAL
- en: We should now have an S3 bucket to which we can potentially store our database
    and media backups using the `s3cmd` console tool that we will soon reference.
  prefs: []
  type: TYPE_NORMAL
- en: Bash script for automated EC2 setup
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Similar to the `Vagrantfile` shell provisioners, let's go ahead and create a
    sequence of bash shell commands we can use for a production setup.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first block of commands goes as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Here, start with the `#!/bin/bash` expression. This specifies the type of script
    we are executing. Then we have a system update and `s3cmd` tool installation.
    The `s3cmd` is a free command-line tool and client for uploading, retrieving,
    and managing data in Amazon S3\. We can use it later on for database and media
    file backups and restores.
  prefs: []
  type: TYPE_NORMAL
- en: We then install the `postfix` mail server, using the following commands. Since
    the postfix installation triggers a graphical interface in the console, asking
    for `mailname` and `main_mailer_type`, we bypass those using `sudo debconf-set-selections`.
    Once installed, we reload `postfix`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Using mail server directly on the EC2 box is fine for smaller production sites,
    where we do not expect high traffic or a large number of customers. For more intensive
    production sites, we need to pay attention to Amazon, possibly putting a throttle
    on port `25`, thus resulting in outgoing e-mail timeouts. In which case we can
    either ask Amazon to remove the limitation on our account, or move on to more
    robust services like **Amazon Simple Email Service**.
  prefs: []
  type: TYPE_NORMAL
- en: 'We then install all things related to PHP. Notice how we even install `xdebug`,
    though immediately turning it off. This might come in handy for those very rare
    moments when we really need to debug the live site, then we can turn it off and
    play with remote debugging. We further download and set composer to the user path:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: We then move on to MySQL installation. Here, we are also using `debconf-set-selections`
    to automate the console part of providing input parameters to the installation.
    Once installed, MySQL is started and added to the boot process.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Alongside MySQL, another major component is Apache. We install it using the
    following commands. With Apache, we need to pay attention to its `apache2.conf`
    file. We need to change `AllowOverride None` to `AllowOverride All` for the Magento
    directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Now that we have MySQL and Apache installed, we move on to getting the source
    code files in place. Next, we are pulling from the official Magento Git repository.
    This is not the same as `repo.magento.com` we used when setting up the vagrant.
    Though in this case the Magento Git repository is public, the idea is to be able
    to pull the code from the private GitHub repository. Based on the production environment
    we tend to set up, we can easily replace the next part with pulling from any other
    private Git repository.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To pull the code from a private git repository, we can use a command of the
    following form, Git clone: `https://<user>:<OAuthToken>@github.com/<user>/<repo>.git`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `PUBLIC_HOSTNAME` variable stores the response of the `wget` command that
    calls the `http://instance-data/latest/meta-data/public-hostname` URL. This URL
    is a feature of AWS that allows us to get the current EC2 instance metadata. We
    then use the `PUBLIC_HOSTNAME` variable during Magento installation, passing it
    as the `--base-url` parameter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: The preceding command takes a lot of *per project* specific configuration values,
    so we need to be sure to paste in our own information here appropriately before
    simply copying and pasting it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we make sure the Magento mode is set to production, and cache is turned
    on and flushed, so it regenerates fresh:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we reset the permissions on the `/var/www/html` directory in order
    for our Magento to function properly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: We need to take caution with the preceding Git and Magento installation example.
    The idea here was to show how we could automatically set Git pull from the public
    or private repository. The Magento installation part is a little bonus for this
    specific case, not something we would actually do on our production machine. The
    whole purpose of this script would be to serve as a blueprint for powering up
    new AMI images. So ideally what we would usually do once the code is pulled, is
    to restore the database from some private storage like S3 and then attach it to
    our installation. Thus making for a complete restore of files, database, and media
    once the script is finished.
  prefs: []
  type: TYPE_NORMAL
- en: 'Putting that thought aside, let''s get back to our script, further adding the
    daily database backup using the set of command as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Here, we are adding the 2:30 AM **cron job** for backing up the database into
    the home directory file named `database.sql.gz`. Then we are adding another cron
    job that executes at 3:30 AM, which pushes the database backup to S3 storage.
  prefs: []
  type: TYPE_NORMAL
- en: 'Similar to the database backup, we can add media backup instructions to our
    script using the set of command as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: The preceding commands have several pieces of information coded in them. We
    need to make sure to paste in our access key, secret key, and S3 bucket name accordingly.
    For simplicity sake, we are not addressing security implications such as hardcoding
    the access tokens into the cron jobs. Amazon provides an extensive *AWS Security
    Best Practices* guide that can be downloaded via the official AWS website.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have some understanding of what the bash script for automated EC2
    setup could look like, let's proceed to setting up the EC2 instance.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up EC2
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Follow these steps to get the setting done:'
  prefs: []
  type: TYPE_NORMAL
- en: Log in to the AWS console
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Under the **Compute** group, click on **EC2**, which should open a screen like
    the following:![Setting up EC2](img/00020.jpeg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on the **Launch Instance** button, which should open a screen like the
    following:![Setting up EC2](img/00021.jpeg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on the **Community AMIs** tab to the left, and type in `Ubuntu Vivid`
    into the search field, as shown in the following screenshot:![Setting up EC2](img/00022.jpeg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: The Ubuntu 15.x (Vivid Vervet) server by default supports MySQL 5.6.x and PHP
    5.6.x, which makes it a good candidate for Magento installation.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'We should now see a screen like the following:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Setting up EC2](img/00023.jpeg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: 'Choose an instance type and click the **Next: Configure Instance Details**
    button. We should now see a screen like the following:![Setting up EC2](img/00024.jpeg)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: We won't be getting into the details of each of these options. Suffice to say
    that if we are working on smaller production sites, chances are we can leave most
    of these options with their default values.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Make sure **Shutdown behavior** is set to **Stop**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'While still on the **Step 3: Configure Instance Details** screen, scroll down
    to the bottom **Advanced Details** area and expand it. We should see a screen
    like the following:![Setting up EC2](img/00025.jpeg)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The **User Data** input is where we will copy and paste the `auto-setup bash`
    script described in the previous section, as shown in the following screenshot:![Setting
    up EC2](img/00026.jpeg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Once we copy and paste in the **User Data**, click on the **Next: Add Storage**
    button. This should bring up the screen as shown in the following screenshot:![Setting
    up EC2](img/00027.jpeg)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Within **Step 4: Add Storage**, we can select one or more volumes to attach
    to our EC2 instance. Preferably, we should select the SSD type of storage for
    faster performance. Once the volume is set, click on **Next: Tag Instance**. We
    should now see a screen like the following:![Setting up EC2](img/00028.jpeg)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The **Tag Instance** screen allows us to assign tags. Tags enable us to categorize
    our AWS resource by purpose, owner, environment, or some other way. Once we have
    assigned one or more tags, we click on the **Next: Configure Security Group**
    button. We should now see a screen like the following:![Setting up EC2](img/00029.jpeg)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The **Configure Security Group** screen allows us to set rules for inbound and
    outbound traffic. We want to be able to access SSH, HTTP, HTTPs, and SMTP services
    on the box. Once we add the rules we want, click on the **Review and Launch**
    button. This opens a screen like the following:![Setting up EC2](img/00030.jpeg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The **Review Instance Launch** screen is where we can view the summary of the
    box we configured up to this point. If needed, we can go back and edit individual
    settings. Once we are satisfied with the summary, we click on the **Launch** button.
    This opens a popup like the following:![Setting up EC2](img/00031.jpeg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Here, we get to choose an existing security key, or create a new one. Keys are
    provided in PEM format. Once we select the key, we click on the **Launch Instance**
    button.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We should now see the **Launch Status** screen like the following:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Setting up EC2](img/00032.jpeg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: Clicking on the instance name link should throw us back at the **EC2 Dashboard**
    like shown in the following screenshot:![Setting up EC2](img/00033.jpeg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'With regard to the preceding image, we should now be able to connect to our
    EC2 box with either one of the following console commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'It might take some time for our EC2 box to execute all of the shell commands
    passed to it. We can conveniently SSH into the box and then execute the following
    command to get an overview of current progress:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: With this, we conclude our instance launch process.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up Elastic IP and DNS
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Now that we have an EC2 box in place, let's go ahead and create the so-called
    Elastic IP for it. The **Elastic IP address** is a static IP address designed
    for dynamic cloud computing. It is tied to the AWS account, and not some specific
    instance. This makes it convenient to easily re-map it from one instance to another.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s go ahead and create an Elastic IP as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Log in to the AWS console.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Under the **Compute** group, click on **EC2**, which should get us to the **EC2
    Dashboard**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Under the **EC2 Dashboard**, in the left area under Network and Security grouping,
    click on Elastic IPs. This should open a screen like the following:![Setting up
    Elastic IP and DNS](img/00034.jpeg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on the **Allocate New Address** button, which should open a popup like
    the following:![Setting up Elastic IP and DNS](img/00035.jpeg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on the **Yes, Allocate** button, which should open another popup like
    the following:![Setting up Elastic IP and DNS](img/00036.jpeg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now that the Elastic IP address is created, right-clicking on it within the
    table listing should bring up the options menu as shown in the following screenshot:![Setting
    up Elastic IP and DNS](img/00037.jpeg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on the **Associate Address** link. This should open a popup like the following:![Setting
    up Elastic IP and DNS](img/00038.jpeg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: On the **Associate Address** popup, we select the **Instance** to which we want
    to assign the Elastic IP address and click on the **Associate** button.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: At this point, our EC2 box has a static (Elastic IP) address assigned. We can
    now log in to our domain registrar and point the A-record of our DNS to the Elastic
    IP we just created.
  prefs: []
  type: TYPE_NORMAL
- en: 'Until we wait for the DNS change to kick in, there is one more thing we need
    to address. We need to SSH into our box and execute the following set of commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: This will update the Magento URL, so we can access it via a web browser once
    the DNS change kicks in. With a little bit of upfront planning, we could have
    easily made this bit a part of the user data for our EC2 instance, simply by providing
    the right `--base-url` parameter value in the first place.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Throughout this chapter, we focused on two main things: setting up development
    and production environments.'
  prefs: []
  type: TYPE_NORMAL
- en: As part of the development environment, we embraced free software such as VirtualBox
    and Vagrant to manage our environment setup. The setup alone came down to a single
    `Vagrantfile` script that contained the necessary set of commands to install everything
    from the Ubuntu server, PHP, Apache, MySQL, and even Magento itself. We should
    by no means look at this script as final and only as a valid script to set up
    our development environment. Investing time in making the development environment
    closer to the project-specific requirements pays off in terms of team productivity.
  prefs: []
  type: TYPE_NORMAL
- en: We then moved on to the production environment. Here, we looked into Amazon
    Web Services, utilizing S3 and EC2 along the way. The production environment also
    came with its own scripted installation process that sets most of the things.
    Similarly, this script is by no means final and is only a valid way to set things
    up; it's more of a base example of how to do it.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will take a closer look at some of programming concepts
    and conventions.
  prefs: []
  type: TYPE_NORMAL
