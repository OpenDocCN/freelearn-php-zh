- en: Chapter 8. Building an API for the CMS
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Throughout this book, we've covered the development of view-oriented applications—applications
    that the user can interact with directly. Our view-oriented approach, however,
    doesn't allow us to easily integrate with other services or provide functionalities
    for native applications. This view-oriented approach often leaves us with hardcoded
    functionality and makes integrations significantly more difficult. The Yii framework,
    however, is extremely adaptable and enables us to build API-driven applications
    rather than view-driven applications. An API reduces the amount of code we have
    to maintain; if executed properly, it reduces the amount of code that needs to
    change when we want to add a feature. Ultimately, this allows us to work faster
    and be more adaptable to changes.
  prefs: []
  type: TYPE_NORMAL
- en: Building an API-driven application also enables us to easily develop both web
    and native clients that work with our API, thus completely separating view-oriented
    logic from our application. In this chapter, we'll go over what we'll need to
    do in order to build an API-driven module for our content-management system that
    we created earlier. By fostering an ecosystem around our application, we can provide
    value to both developers and users, and increase the value of our application.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is the demonstration:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Building an API for the CMS](img/7734OS_08_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In this chapter, we'll go over what we'll need to do to build an API-driven
    module for our content management system that we created earlier.
  prefs: []
  type: TYPE_NORMAL
- en: Prerequisites
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Since we'll be expanding upon the work we did in [Chapter 7](ch07.html "Chapter 7. Creating
    a Management Module for the CMS"), *Creating a Management Module for the CMS*,
    we'll need the completed source code from the previous chapter. You can either
    build the project yourself, or you can use the completed source code available
    in the project resources folder in the previous chapter. We'll also need a URL
    request client that will allow us to send `GET`, `POST`, and `DELETE` requests
    with JSON-encoded data to our application. You can either use cURL, or you can
    download a Google Chrome extension called **RESTClient** available at [https://chrome.google.com/webstore/detail/rest-console/cokgbflfommojglbmbpenpphppikmonn?hl=en](https://chrome.google.com/webstore/detail/rest-console/cokgbflfommojglbmbpenpphppikmonn?hl=en).
    The examples throughout this chapter will use RESTClient.
  prefs: []
  type: TYPE_NORMAL
- en: Describing the project
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we''ll be building an API module for our content-management
    system. The development of this module can be broken down into several pieces:'
  prefs: []
  type: TYPE_NORMAL
- en: Configuring the module
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Extending Yii to "RESTfully" render JSON or XML instead of a view file
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Handling data input
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Handling user authentication
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Handling exceptions and errors
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Specifying what data will be returned with each response
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing authentication, deauthentication, and basic CRUD actions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Configuring the module
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The first component of this project will consist of creating and configuring
    our module so that it integrates with our main application. Since we added the
    functionality that seamlessly integrates modules into our application in the previous
    chapter, the only work required for this section will be to clear out our module
    cache, initialize the module, and add in the necessary routes.
  prefs: []
  type: TYPE_NORMAL
- en: Extending Yii to render JSON or XML in a RESTful way
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Since the Yii framework is designed to work with view files, we'll need to extend
    several components of the Yii framework in order to get it to output and render
    JSON or XML documentations. We'll also need to make several different changes
    to Yii so that it knows how to handle `GET`, `POST`, and `DELETE` actions independently
    of one another. To accomplish this, we'll create a new controller that will extend
    `CMSController`, which we created in the previous chapters. This will overload
    several key methods from `CController`, namely `runAction()`, `filterAccessControl()`,
    `createAction()`, and `beforeAction()`. We'll also extend several other classes—`CInlineAction`,
    `CAccessControlFilter`, and `CAccessRule`—to implement all the functionality we
    need. Finally, we'll also change the way the renderer works so that we can return
    data from our actions and have our base controller handle the output, thus reducing
    the amount of echoing we need to perform in each controller.
  prefs: []
  type: TYPE_NORMAL
- en: Handling data input
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For any request that modifies data in our application, we'll need to handle
    the acceptance of that data to the RESTful endpoint. To keep things simple, we'll
    accept JSON-encoded data, or we'll accept data encoded with `application/x-www-form-urlencoded`
    or HTML form fields for our convenience. In our application, we'll turn either
    of these data sources into usable attributes that we can modify and work from
    in order to complete tasks.
  prefs: []
  type: TYPE_NORMAL
- en: Authenticating users to the API
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In Yii, user authentication and identification are typically handled by our
    `UserIdentity` class and cookies. By convention, RESTful API's don't send or accept
    any cookies, which means that we'll have to change the way we perform authentication
    within our application. For this, we'll create a custom `AccessControlFilter`
    that will initially authenticate our users using their username and password.
    If a user successfully authenticates against our API, we'll return to them a unique
    token that the user will use for all future requests that require authentication.
    This token, and the user's email address will be sent via two custom headers,
    `X-Auth-Token` and `X-Auth-Email`, and will allow us to identify the user in our
    API without requiring them to resend their password information. This token will
    be stored alongside our user in the `user_metadata` table we created in the previous
    chapters.
  prefs: []
  type: TYPE_NORMAL
- en: Handling API exceptions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The next components we'll need to handle are errors and exceptions. These will
    range from errors that Yii will encounter naturally, such as 404 errors when an
    action isn't found, to exceptions that we throw within our application to notify
    clients interacting with our API of either an unexpected error or a warning that
    something has happened. Since we'll be changing the way rendering works within
    our application, we'll simply reroute our errors the same way we would for the
    response of any action.
  prefs: []
  type: TYPE_NORMAL
- en: Handling data responses
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'With every request, we''ll return the HTTP status code, a message if an error
    occurred, and a mixed content response attribute that will contain all the information
    that we want to return to the client for consumption. The response will look as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: We'll also have our actions return a method that will allow us to define what
    attributes should be returned with each request. This will allow us to return
    only a limited amount of information, preventing accidental information disclosure,
    and will enable us to protect private information such as passwords or credentials.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing actions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The last big part that we''ll handle is the implementation of all of our controller
    actions. This will include our authentication endpoint, all the user actions such
    as registering and resetting their password, and the management of our three core
    data models: Users, Categories, and Content.'
  prefs: []
  type: TYPE_NORMAL
- en: Initializing the project
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'For this project, we''ll be starting where we left off in [Chapter 7](ch07.html
    "Chapter 7. Creating a Management Module for the CMS"), *Creating a Management
    Module for the CMS*. The steps are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: For your convenience, a skeleton project has been included in the project resources
    folder for this chapter that contains the foundation that we'll be starting with.
    Begin by copying the source code to a new folder, and make sure that it is available
    at a different URL from the one we used in the previous chapter. In this chapter,
    I'll be using `http://chapter8.example.com` as our example URL.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'After importing the database and updating the database configuration using
    the instructions provided in the previous chapter, create a new folder called
    `api` in `protected/modules` and also create the following directory structure:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, create the `ApiModule` class, `ApiModule.php`, in `protected/modules/api/`,
    which will bootstrap our module:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, create `routes.php` in `protected/modules/api/config/`, and populate
    it with the following information:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Finally, remove `modules.config.php` in the `protected/runtime/` directory,
    and the contents of the `protected/runtime/cache` directory, to clear the modules
    cache that we implemented in the previous chapter. This will ensure that Yii recognizes
    and caches our new module. The next time we access Yii, this file will be regenerated
    and will contain the appropriate module configuration for our application.
  prefs: []
  type: TYPE_NORMAL
- en: Extending Yii to return data
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are two approaches to having Yii render the JSON or XML data. The first
    and the easiest approach is to create a JSON or XML view file and, from every
    action, call `$this->render('json')`. While this is simple, it forces us to store
    a lot of information and explicitly call the `render()` method in each action.
    If we're extending a class that modifies the `render()` method, this can be extremely
    problematic if we want to make changes later. Another issue with this approach
    is that it treats errors as separate response types. When throwing an error with
    this approach, Yii will want to render the error as HTML rather than JSON. Depending
    upon our logging and debug level, this can cause our API to return the wrong data
    to our client.
  prefs: []
  type: TYPE_NORMAL
- en: A more preferable approach is to simply return the data that we want to present
    to the client in each action and have our parent controller class handle the rendering
    and output. This approach makes it easier to identify what data is being presented
    from each action and ensures that our API consistently returns the right data
    format even when exceptions or errors happen.
  prefs: []
  type: TYPE_NORMAL
- en: To get this working, however, we need to extend a few classes from the Yii framework
    and modify them so that they return data instead of outputting it. The first class
    we need to extend is `CInlineAction`. `CInlineAction`. It represents the actual
    action method within our controllers and is called by the `runAction()` controller
    method. To make our API return data instead of outputting it, we first need to
    intercept the response of our actions by modifying the `CInlineAction` `runWithParamsInternal()`
    method, which we'll then return to the `runAction()` method in the parent controller.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We''ll do this by creating a new class called `ApiInlineAction` that extends
    `CInlineAction` and overloads the `runWithParamsInternal()` method. For our convenience,
    we''ll put this code in `ApiInlineAction.php`, located at `protected/modules/api/components/`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, we''ll need to create a base controller class that all of our API controllers
    will extend from. This parent class will be what ultimately class `runWithParamsInternal`.
    Begin by creating a new class in `protected/modules/api/components` called `ApiController.php`
    with the following definition:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Throughout this class, we''ll be referencing the private `$_action` variable,
    which we''ll need to redefine from the parent class. We''ll define the status
    and message variables at this time as well. These variables will hold the HTTP
    status code as well as any error messages that we want to present to the client:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We''ll then overload our `runAction()` method to call our output method instead
    of Yii''s rendering methods:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: Have questions about `CInlineAction`? Be sure to check out the class documentation
    at [http://www.yiiframework.com/doc/api/1.1/CInlineAction](http://www.yiiframework.com/doc/api/1.1/CInlineAction).
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Rendering data
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The next part in outputting our data is to create the `renderOutput()` method
    that we called earlier:'
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ll begin by defining the method. In order to make it as adaptable as possible,
    we''ll want the ability to manually call this method with the status and message
    that we want to present:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'At this time, we''ll define several response headers that will allow web clients
    to talk to our API and get the same-origin policy settings that modern web browsers
    have in place in order to protect users. Without these cross-origin resource-sharing
    headers (CORS, for short), web clients won''t be able to talk to our API. This
    will also allow web browsers to send our API custom authentication headers that
    we''ll define later:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We''ll then define our base data response:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then, we''ll determine the data format in which we want to return our data
    from a `GET` parameter called `format` and render the data appropriately:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'To render JSON data, we''ll simply take the data response that we built in
    the previous steps and output it with `CJSON::encode()`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Rendering the XML data is slightly more involved but can easily be done with
    the following recursive method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: Have questions about the methods we're extending from `CController`? Be sure
    to take a look at the guide for this class at [http://www.yiiframework.com/doc/api/1.1/CController](http://www.yiiframework.com/doc/api/1.1/CController).
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Calling actions in a RESTful way
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In a RESTful API, a single endpoint might respond differently to different kinds
    of HTTP requests. For instance, the `/api/user/index` endpoint might return a
    list of users or a particular user if a `GET` request is called with an ID parameter.
    However, if a `POST` request is called, a new user will either be created or modified.
    If a `DELETE` request was called to that endpoint with an ID, it would delete
    a user from the system.
  prefs: []
  type: TYPE_NORMAL
- en: 'To emulate this behavior in Yii, we need to overload the `createAction()` method
    of our `ApiController` so that it calls the correct action. In our controllers,
    this will allow us to separate functionality by the request type. Internally,
    our API will be calling actions in the format of `action<Name><Method>`, with
    the default `GET` action hitting the raw action method (for example, `actionIndex()`,
    `actionIndexPost()` and `actionIndexDelete()`). This method will also call the
    `ApiInlineAction` class that we defined earlier instead of `CInlineAction`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Authenticating users
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Since RESTful APIs don''t pass the cookie information between the API and the
    client, we need to make several modifications to our controller in order to separate
    authenticated users from unauthenticated users. For this, we''ll overload `CAccessControlFilter`
    so that it operates against the user information that we''ll populate in our controller:'
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ll begin by adding a few more public properties to our `ApiController`.
    The `xauth` attributes will store the `X-Auth-Token` and `X-Auth-Email` headers
    that we''ll send for authentication, and the `user` property will store the raw
    user model for the authenticated user. We''ll pass this information down to the
    child controllers for authentication and also to our overloaded `CAccessControlFilter`
    class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, we''ll load our `accessControl` filter. We''ll also define another filter
    called `CHttpCacheFilter` that will tell clients not to cache the responses our
    API returns:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We''ll then define our base `accessRules()`that will deny access to any method
    other than our error action:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, we''ll need to handle the authentication in our controller before passing
    it to `CInlineActionFilter`. We''ll begin by overloading the `filterAccessControl()`
    method in our `ApiController`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We''ll then retrieve the `X-Auth-Token` and `X-Auth-Email` headers:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now we''ll validate these against our database. For this, we''ll look up a
    user in our database with the `X-Auth-Email` address; if this is found, we''ll
    then check for the API token that we''ll generate later on in the `user_metadata`
    table. If an API token is found, we''ll populate `$this->user` with the raw user
    model:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Finally, we''ll call our custom `CAccessControlFilter` class, pass the user
    to it, set rules, and call the filter:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Overloading CAccessControlFilter
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We need to create a new class called the `ApiAccessControl` filter within `protected/modules/api/components/`
    so that we can continue using the `accessRules` array in our controllers. This
    class will operate on the `user` object we passed to it from our controller and
    will make our `accessRules` array work with our new user object:'
  prefs: []
  type: TYPE_NORMAL
- en: 'After creating the `ApiAccessControlFilter.php` file, define it as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We''ll then need to add the `user` attribute to store the user as passed from
    our controller and redefine the `private $_rules` property that the parent class
    operates on:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Since the `$_rules` array in the parent class is private, we''ll need to redefine
    the getter and setter for the rules array as well as the `preFilter()` method
    that uses the private property. We''ll start with the `preFilter()` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We''ll then create both a getter and setter for our `rules` array:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'At this time, we''ll also want to redefine the `accessDenied` behavior that
    gets called when a user doesn''t have access to a particular action. Here, we''ll
    simply call the `renderOutput()` method of `ApiController`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'To follow the same convention as Yii, we will also add a second class, `ApiAccessRule`,
    that extends `CAccessRule` inside the same file. This is just a simple modification
    that ensures that our information is loaded instead of the information that is
    passed to `CAccessRule`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: Want to learn more about `CAccessControlFilter`? Take a look at the class documentation
    at [http://www.yiiframework.com/doc/api/1.1/CAccessControlFilter](http://www.yiiframework.com/doc/api/1.1/CAccessControlFilter).
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Processing the incoming data
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Since our RESTful API will be returning JSON, it's only appropriate that it
    should accept JSON as well. For convenience, we'll configure our API to accept
    `application/x-www-form-urlencoded` from the data (data sent from a form), so
    that our web clients can simply POST directly to our API without having to perform
    data conversion.
  prefs: []
  type: TYPE_NORMAL
- en: 'To make our API accept this data, we''ll overload the `beforeAction()` method
    in order to take the raw JSON body, if supplied, and populate it into our `$_POST`
    data if it is a valid JSON request. If invalid JSON is sent, we''ll return an
    HTTP 400 error, indicating that something was wrong with the request. The error
    will hit our `actionError()` method and bubble up to our `runAction()` method,
    which will finally display the error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Handling errors
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Before moving on to creating controllers, we need to make sure that our parent
    class can handle any errors that get sent to it. There are two types of errors
    we'll want to handle—the first being errors that Yii encounters either internally,
    or through exceptions we call, and the second being errors that we want to present
    to the user but that we don't want to send through an exception.
  prefs: []
  type: TYPE_NORMAL
- en: Exception handling
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To handle exceptions that either we throw or that Yii throws internally, we''ll
    define the base `actionError()` method as follows. The data set here will simply
    populate the `runAction()` method that we overloaded earlier and will ensure that
    the appropriate error is displayed in the correct format:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: Custom error handling
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Within our controllers, there will be situations that we''ll want to return
    an error to the user without triggering an exception. A great example of this
    is a model validation error. We want to inform the user that something went wrong,
    but we want to return from the error gracefully without stalling our application.
    For this, we''ll create a `returnError()` method that we''ll call from our controller
    that will populate back up to the `runAction()` method we defined earlier:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: Testing whether everything works
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Before we start creating other controllers and actions, let''s create a very
    simple controller in order to verify that our API is working the way we want it
    to. For this, let''s create a class called `DefaultController` in `protected/modules/api/controllers`
    with the following setup:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'If your API is set up correctly, you should be able to open your browser to
    `http://chapter8.example.com/api` and see the following displayed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, whatever data we returned from our action is now in the response
    attribute of our JSON object. Additionally, if we want to render XML instead of
    JSON, we can add the `format=xml GET` parameter to the `http://chapter8.example.com/api?format=xml`
    URL as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Most load balancers and health-check services verify that endpoints return a
    `200` status. For this reason, it's recommended that you simply return true from
    this default method if you're going to add a health check to your API.
  prefs: []
  type: TYPE_NORMAL
- en: Authenticating users
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now that our API is functional, let''s add the ability for users to be authenticated
    against our API. For this, we''re going to create an endpoint that accepts the
    following JSON request body:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'With this information, the API will be authenticated using `LoginForm`, which
    we worked on in previous chapters. If the user is valid, we''ll generate a new
    API token that will be stored in the `user_metadata` table. This token will be
    returned to the client who is making the request and will be used to authenticate
    for all future requests:'
  prefs: []
  type: TYPE_NORMAL
- en: 'To get started, create a new controller in `protected/modules/api/controllers/`
    called `UserController.php` with the following definition:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, we''ll need to define a default set of access rules so as to allow our
    authentication method to be used without authentication:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Since this is a `POST` endpoint, we''ll define our new method as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We''ll then instantiate a new instance of `LoginForm` and retrieve our e-mail
    address and password from the JSON body. Remember that, in our `ApiController`
    class, we transformed the raw JSON body directly into our `$_POST` parameters
    in order to make things easier to work with:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'After retrieving this information, we''ll attempt to log in:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'If successful, we''ll load the user information:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Try to either update an existing API token, or generate a new one:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'If we are able to save the token to the database, we''ll return it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Outside our `if ($model->login())` condition, we''ll simply return an error
    to the user, indicating that something went wrong. Since this is an authentication
    method, we don''t want to give away too much information in order to prevent people
    from attempting to brute-force our API endpoint:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Testing the authentication
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Before proceeding, let''s make sure that our authentication endpoint works.
    To test this, we''ll be using a Google Chrome extension called **RestConsole**
    and that can be downloaded from the Chrome App Store at [https://chrome.google.com/webstore/detail/rest-console/cokgbflfommojglbmbpenpphppikmonn?hl=en](https://chrome.google.com/webstore/detail/rest-console/cokgbflfommojglbmbpenpphppikmonn?hl=en).
    If you do not already have Google Chrome installed, you can download it from [https://www.google.com/intl/en-US/chrome/browser/](https://www.google.com/intl/en-US/chrome/browser/).
    After installing, navigate to the RestConsole download page and install the plugin.
    Once it''s installed, you can click on the **Launch App** button in the Chrome
    App Store to load RestConsole. Once it''s loaded, you''ll see several different
    sections:'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A tool such as RestConsole will allow us to quickly test our API endpoints from
    a nice GUI interface. If you prefer, you can test the endpoints directly from
    your command line using the cURL utility, available through most package managers.
  prefs: []
  type: TYPE_NORMAL
- en: In the **Target** section, fill out the form as shown in the following screenshot.
    Be sure to adjust to your local environment. The key detail in this section is
    the **Request URI** field.![Testing the authentication](img/7734OS_08_02.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Then, scroll down to the **Body** section, and fill out the section as follows:![Testing
    the authentication](img/7734OS_08_03.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: The key part of this section is the **Request Payload** section. This is where
    you'll add the raw JSON body that will be sent to the server. In this example,
    we're using the credentials that we established in [Chapter 7](ch07.html "Chapter 7. Creating
    a Management Module for the CMS"), *Creating a Management Module for the CMS*.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: If you've changed these credentials since then, be sure to change them in your
    JSON body.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Finally, click on the **Post** button at the bottom of the page. This will send
    the request to the server. If successful, you'll receive an HTTP 200 status code
    in response with your API token in the response body:![Testing the authentication](img/7734OS_08_04.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: Your response body will differ slightly as the API token is randomly generated
    on each authentication request.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Sending authenticated requests
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now that we can authenticate against our API, let''s make sure that we can
    send authenticated requests. For this, we''ll be creating an API endpoint in order
    to deauthenticate our user. This will accept the user''s credentials and then
    delete the API token from the database in order to prevent future use:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Creating this endpoint consists of two parts. First, we need to add an item
    to our `accessRules` array that allows authenticated users to send a `DELETE`
    request to the token endpoint. We''ll do this by adding the following to our `accessRules`
    array:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then we''ll add the delete method for our token endpoint that will be available
    over the HTTP `DELETE` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now that are endpoint is set up, return to RestConsole, remove the request
    body, and add the following custom headers to the **Custom Headers** section below
    the request body, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: '![Sending authenticated requests](img/7734OS_08_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Then, hit the **Delete** button at the bottom of the page to send a `DELETE`
    request. You should receive the following response:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'We''ve now successfully tested user authentication and added the ability to
    deauthenticate from our API. Notice that, if you try to submit a `DELETE` request
    again, our `acccessRules` array will kick in and will block the request for us,
    thus returning the following response:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: Implementing CRUD actions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we can authenticate and work with our API, we can work on implementing
    the four basic CRUD actions in a RESTful manner. The RESTful actions boil down
    to three main HTTP request types—`GET`, `POST`, and `DELETE`. We'll implement
    each one for our users.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first method we need to implement is our `loadModel()` method. This method
    will be loaded in our User model and will throw the appropriate errors if something
    goes wrong:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: Deleting users
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The first method that we''ll implement is our `DELETE` method. Remember that,
    for each method, we''ll be hitting a single endpoint, `/api/user/index` , with
    different HTTP request types:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The first change that we need to make is to our `accessRules`. We want only
    administrators to have the ability to delete a user. We''ll do this by setting
    up an expression that checks whether the user is an admin:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then, we''ll implement the delete action. We want to make sure that users are
    not able to delete themselves:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Sending a `DELETE` request to `/api/user/index/id/<user_id>` will now delete
    a user with the given ID.
  prefs: []
  type: TYPE_NORMAL
- en: Retrieving users
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The second method that we''ll implement is a `GET` method that will either
    retrieve a single user if an ID is provided, or multiple users if a user is an
    administrator. In either case, we''ll want to make sure that a user is authenticated:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The first change, once again, will be to our `accessRules` array. We''ll check
    to see whether a user is an admin, or whether the given ID belongs to the currently
    authenticated users:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We''ll then set up a `GET` method in our controller. Remember, we set up our
    `createAction()` method in our `ApiController` class so that `GET` requests don''t
    require the HTTP verb at the end of the method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then, if an ID was provided, we''ll simply load the requested user. If the
    user is not an admin and they requested another user, we''ll throw an exception;
    otherwise, we''ll return the appropriate data:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: If you recall, we made changes to our `CMSActiveRecord` model in order to add
    a `getApiAttributes()` method. Calling this method now allows us to exclude certain
    elements that we don't want to send in the request, such as the user password.
    This also allows us to return metadata about the user, such as the role and any
    metadata associated with the user.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Carrying on, if an ID was not specified, we''ll make sure that the user is
    an admin:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'If so, we''ll load up a search instance of our model. This extends our endpoint
    to allow for dynamic searching:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'To allow for pagination, we''ll instance a copy of `CActiveDataProvider` from
    the `$model->search()` method and set the page variable to the `GET` parameter
    page. This will allow us to paginate through our users rather than dumping all
    of them in a single request:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'To handle pagination, we''ll simply continue to display results until no results
    are found. When no results are found, we''ll throw an HTTP 404 error. This will
    allow for infinite scrolling on the client side and will let our clients know
    when to stop asking for data:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We''ll then iterate through our `dataProvider` using the `getData()` method
    and generate an array of all the user objects in the current page:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Finally, we''ll return the entire response:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Now, make a few requests to the API endpoint in order to test everything out.
    You should be able to log in as an admin and view all users or any user. You should
    also be able to log in as a regular user and only retrieve information about yourself.
  prefs: []
  type: TYPE_NORMAL
- en: Creating and updating users
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The last endpoint we''ll need to implement is a `POST` method that will serve
    as an endpoint to both creating and updating existing users:'
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ll begin by updating the `accessRules` array that we defined in the previous
    section in order to include `indexPost`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We''ll then create a `POST` endpoint that will branch off into two separate
    methods—one that creates users and one that modifies users:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Since all the information for creating users will be coming from a normal `POST`
    response, all we need to do to create a new user is verify that they are an admin,
    instantiate a new User model, validate it, and save it. If, for any reason, we
    encounter an error (such as an invalidate attribute), we''ll simply return the
    errors from `$model->getErrors()` in the JSON response:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'As it turns out, updating users is as simple as loading an existing User model
    and doing the same thing as creating a new user. The only difference in this endpoint
    is that we need to make sure that the user is either an admin, or that they are
    trying to modify their own data:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: At this point, go ahead and verify that you can create new users as an admin
    and that existing users can modify their own data.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing other controller actions from the main application
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: At this point, we've created the basic CRUD interface for our User data model.
    While this takes care of a lot of the administrative tasks, there are a couple
    of other methods that we can move from the frontend of our application to our
    API. These methods include actions such as registration, account verification,
    and password reset requests. Moving these methods from our frontend and into our
    API immediately makes this functionality available to any consumer of our API,
    which makes our API more valuable to both web and native clients.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, we can easily adapt our registration action from our frontend
    to our API by simply replacing the render actions with either a Boolean value
    indicating that the registration was successful, or a list of errors generated
    by the model. Because all of our validation rules and verification checks are
    performed in the model, adapting the action is fairly simple, as shown:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: Go ahead and try implementing the other actions from our frontend controller,
    such as `actionVerifyPost`, `actionActivate`, `actionForgotPost`, and `actionResetPasswordPost`.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing categories and content API controllers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Our CMS is made up of more than user-related actions—we also have to manage
    content and categories. Once again, moving this functionality from our dashboard
    controllers to our API is fairly simple. We simply strip out the view-related
    functionality and return either Boolean values, or errors generated from the model.
    In the case of our `GET` method, we simply add in some pagination using the already
    provided pagination functionality of `CActiveDataProvider` and return the relevant
    results. Both of these controllers will look nearly identical to our `UserController`,
    as they work in the same way except with different data models. Go ahead and try
    to complete these controllers on your own.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Remember that a fully completed application is included with the project resources.
    If you get stuck, take a look at the resources folder.
  prefs: []
  type: TYPE_NORMAL
- en: Documenting our API
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: While our API can be fun to work with and easy to integrate with, it means nothing
    to developers who want to work with our API if the available endpoints, details,
    and examples aren't documented clearly. Before sharing your API with the world,
    be sure to document what endpoints clients can access. It's also a good idea to
    thoroughly document what users need to do in order to authenticate against the
    API. Generally, this is done by providing detailed example requests and detailed
    example responses.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As shown throughout this book, the Yii framework is an extremely powerful, flexible,
    and easy PHP framework to work with. In this chapter, we completely overhauled
    how the Yii framework handles user authentication through JSON requests and adapts
    it to return both JSON and XML document types for an API that can be consumed
    by both web and native applications. In this chapter, we also covered what changes
    we needed to make in order to migrate functionality that was previously designed
    to be rendered directly to the client to our API to be rendered as JSON or XML.
    Finally, we adapted our API to respond to different types of HTTP requests on
    the same endpoint, allowing us to make a RESTful JSON API that is well documented.
  prefs: []
  type: TYPE_NORMAL
- en: Thank you for reading this book. Throughout this book, we've shown countless
    examples of how powerful and flexible Yii is. From working with third-party APIs
    to performing database-agnostic migrations and all the way to developing feature-complete
    applications complete with an API, the Yii framework enables us to quickly work,
    develop, and adapt our code to meet our objectives and end goals in a timely manner.
    I hope that you found the information contained within this book informative,
    useful, and fun. I also hope that you've learned how to use the Yii framework
    to do more than just create simple web applications.
  prefs: []
  type: TYPE_NORMAL
- en: On the about page of the Yii framework, Yii is described as an acronym for "Yes
    It Is" that answers some of the most basic questions asked about Yii. Is Yii fast?
    Is Yii secure? Is Yii professional? Is Yii right for your next project? I hope
    this book has shown you that the answer to those questions is a simple "Yes, it
    is".
  prefs: []
  type: TYPE_NORMAL
