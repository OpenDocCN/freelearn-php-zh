- en: Chapter 5. Creating a Microblogging Platform
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第5章。创建一个微博平台
- en: For our next project, we will be developing a scalable microblogging platform
    similar to Twitter. This platform will allow users to share content with others,
    mention other users in their share, and view a timeline of their shares. Additionally,
    users will be able to register, manage, and change certain account details such
    as their e-mail address and password. Finally, our platform will enable users
    to share content with other external social networks such as Twitter.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的下一个项目，我们将开发一个类似于Twitter的可扩展微博平台。这个平台将允许用户与他人分享内容，在他们的分享中提及其他用户，并查看他们分享的时间线。此外，用户将能够注册、管理和更改某些账户详情，例如他们的电子邮件地址和密码。最后，我们的平台将允许用户与其他外部社交网络，如Twitter，分享内容。
- en: 'By the end of this chapter, we''ll have a social network that will allow us
    to share content and manage our accounts, as shown in the following screenshot:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，我们将拥有一个社交网络，允许我们分享内容并管理我们的账户，如下面的截图所示：
- en: '![Creating a Microblogging Platform](img/7734OS_05_01.jpg)'
  id: totrans-3
  prefs: []
  type: TYPE_IMG
  zh: '![创建微博平台](img/7734OS_05_01.jpg)'
- en: 'Our users will also have the ability to directly reply to and share individual
    posts that they make, as shown in the following screenshot:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的用户还将能够直接回复和分享他们发布的单个帖子，如下面的截图所示：
- en: '![Creating a Microblogging Platform](img/7734OS_05_02.jpg)'
  id: totrans-5
  prefs: []
  type: TYPE_IMG
  zh: '![创建微博平台](img/7734OS_05_02.jpg)'
- en: Prerequisites
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 前提条件
- en: 'Before we get started, there are a couple of things that we''ll need to set
    up and have working:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始之前，有一些事情我们需要设置并确保它们能正常工作：
- en: Since we'll be sending and receiving e-mails from our application, we're going
    to need a registered and active domain name. If you do not already have a working
    domain name, you can purchase one from a domain registrar such as [https://www.namecheap.com](https://www.namecheap.com),
    [www.name.com](http://www.name.com), or [www.gandi.net](http://www.gandi.net).
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由于我们将从我们的应用程序发送和接收电子邮件，我们需要一个注册并活跃的域名。如果您还没有一个正在工作的域名，您可以从域名注册商那里购买一个，例如 [https://www.namecheap.com](https://www.namecheap.com)，[www.name.com](http://www.name.com)，或
    [www.gandi.net](http://www.gandi.net)。
- en: Next, you'll need to have a web server with a public-facing IP address. This
    will allow e-mails to be sent to our application. Many cloud **Virtual Private
    Server** (**VPS**) providers are available for use for low monthly or hourly prices.
    Such services include [https://www.digitalocean.com](https://www.digitalocean.com),
    [https://www.linode.com](https://www.linode.com), and [www.rackspace.com/cloud/servers](http://www.rackspace.com/cloud/servers).
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 接下来，您需要一个具有公开IP地址的Web服务器。这将允许将电子邮件发送到我们的应用程序。许多云**虚拟专用服务器**（**VPS**）提供商以低月费或时费提供此类服务。这些服务包括
    [https://www.digitalocean.com](https://www.digitalocean.com)，[https://www.linode.com](https://www.linode.com)，和
    [www.rackspace.com/cloud/servers](http://www.rackspace.com/cloud/servers)。
- en: In order to send e-mails in our application, we'll once again be utilizing a
    free SendGrid Developer Account, which can be set up at [https://www.sendgrid.com/developers](https://www.sendgrid.com/developers).
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为了在我们的应用程序中发送电子邮件，我们还将利用免费的SendGrid开发者账户，该账户可以在 [https://www.sendgrid.com/developers](https://www.sendgrid.com/developers)
    上设置。
- en: In this chapter, we'll once again be using the latest version of MySQL (at the
    time of writing this, it is MySQL 5.6). Make sure that your MySQL server is set
    up and running on your server.
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在本章中，我们还将再次使用MySQL的最新版本（在撰写本文时，它是MySQL 5.6）。请确保您的MySQL服务器已在您的服务器上设置并运行。
- en: For this project, we'll once again be managing our dependencies through Composer,
    which you can download and install from [https://getcomposer.org/](https://getcomposer.org/).
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于这个项目，我们还将通过Composer管理我们的依赖项，您可以从 [https://getcomposer.org/](https://getcomposer.org/)
    下载并安装它。
- en: Finally, you'll need a Twitter Developer account, which can be obtained from
    [https://dev.twitter.com/](https://dev.twitter.com/). This account will allow
    us to enable the sharing of our content to Twitter as the logged-in user via Twitter's
    OAuth API.
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后，您需要一个Twitter开发者账户，您可以从 [https://dev.twitter.com/](https://dev.twitter.com/)
    获取。这个账户将允许我们通过Twitter的OAuth API以登录用户身份分享我们的内容。
- en: Once you have acquired the listed items, create a subdomain on the domain name
    you are using and point it to your server. In this chapter, I'll be using `chapter5.example.com`
    to refer to this subdomain. After everything is set up and your server is responding
    to that domain name, we can get started.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦您获得了列出的项目，在您使用的域名上创建一个子域名并将其指向您的服务器。在本章中，我将使用 `chapter5.example.com` 来指代这个子域名。一旦一切设置完毕，并且您的服务器对该域名做出响应，我们就可以开始了。
- en: Describing the project
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 描述项目
- en: 'Our microblogging platform can be broken down into two big components:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的微博平台可以分为两个主要组件：
- en: Users who will be following other users and creating, sharing, and liking content
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将关注其他用户并创建、分享和点赞内容的用户
- en: Text-based shares that will be created by the users
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户创建的基于文本的分享
- en: Users
  id: totrans-19
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 用户
- en: The first component of our application is the set of users who will be performing
    all the tasks in our application. For this application, we're going to be largely
    reusing the user database and authentication system that we expanded upon in [Chapter
    4](ch04.html "Chapter 4. Developing an Issue-tracking Application"), *Developing
    an Issue-tracking Application*. In this chapter, we'll be expanding upon the `users`
    database table, and adding several new relations such as followers and likes.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 我们应用程序的第一个组件是执行我们应用程序中所有任务的用户集。对于这个应用程序，我们将主要重用我们在[第4章](ch04.html "第4章。开发问题跟踪应用程序")中扩展的用户数据库和身份验证系统，即*开发问题跟踪应用程序*。在本章中，我们将扩展`users`数据库表，并添加几个新的关系，如粉丝和点赞。
- en: Followers
  id: totrans-21
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 粉丝
- en: 'In this application, users will be able to follow and be followed by other
    users. This relationship will allow users to stay up-to-date with other users
    by showing content that other users have recently created. Moreover, it will allow
    them to know how many people are following them and see how much of an influence
    they have over their network. For this application, our `followers` table will
    just contain the primary keys of users who are either following or being followed
    by another user. Our database table will look as follows:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个应用程序中，用户将能够关注其他用户并被其他用户关注。这种关系将使用户能够通过显示其他用户最近创建的内容来保持与其他用户的同步。此外，它将使用户知道有多少人关注他们，并了解他们对网络的影响程度。对于这个应用程序，我们的`followers`表将只包含那些正在关注或被其他用户关注的用户的键。我们的数据库表将如下所示：
- en: '[PRE0]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Likes
  id: totrans-24
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 点赞
- en: 'In this application, users will also be able to indicate that they like a particular
    share. Similar to our `followers` table, the `likes` table will only contain the
    primary keys of the `users` and the `shares` table. Our database table will look
    as follows:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个应用程序中，用户还可以表示他们喜欢某个特定的分享。类似于我们的`followers`表，`likes`表将只包含`users`和`shares`表的键。我们的数据库表将如下所示：
- en: '[PRE1]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Shares
  id: totrans-27
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 分享
- en: 'The second component of our application will be the shares that users create.
    For our purposes, we will define a share as a piece of text that can contain unique
    markers such as the `@` sign for mentioning other users, and the `#` character
    for tagging a share. Shares can also be in reply to another share, which will
    allow them to be viewed on the share''s view page. Finally, shares can be reshared
    users who wish to share another user''s share with their network. Our database
    table will look as follows:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 我们应用程序的第二个组件将是用户创建的分享。为了我们的目的，我们将定义分享为可以包含独特标记的文本片段，例如用于提及其他用户的`@`符号，以及用于标记分享的`#`字符。分享也可以是对另一个分享的回复，这将允许它们在分享的查看页面上查看。最后，分享可以被重新分享，用户可以将其他用户的分享分享给他们的网络。我们的数据库表将如下所示：
- en: '[PRE2]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Initializing the project
  id: totrans-30
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 初始化项目
- en: 'By now, you should be comfortable with creating projects from scratch. To provide
    us with a common starting ground, a skeleton project has been included with the
    project resources for this chapter. Included with this skeleton project are the
    necessary migrations, data files, controllers, and views that we need to get started.
    The login system that we''ll be using for authentication throughout this chapter
    is also included. Copy the skeleton project from the project resources folder
    to your web server and configure it so that it responds to `chapter5.example.com`
    as outlined at the beginning of the chapter, and then perform the following steps
    to make sure everything is set up:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 到现在为止，您应该已经熟悉了从头创建项目。为了提供一个共同的起点，本章的项目资源中包含了一个骨架项目。这个骨架项目包括我们开始所需的必要迁移、数据文件、控制器和视图。我们将在本章中使用该登录系统进行身份验证。将骨架项目从项目资源文件夹复制到您的Web服务器，并按照本章开头概述的配置，使其响应`chapter5.example.com`，然后执行以下步骤以确保一切设置正确：
- en: Adjust the permissions on the `assets` and `protected/runtime` folders so that
    they are writable by your web server.
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 调整`assets`和`protected/runtime`文件夹的权限，以便您的Web服务器可以写入。
- en: 'Next, create the MySQL user and database table that our application will use.
    If you don''t want to alter the provided main configuration file, the following
    MySQL commands will create the database and user for you:'
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，创建我们的应用程序将使用的MySQL用户和数据库表。如果你不想修改提供的主配置文件，以下MySQL命令将为你创建数据库和用户：
- en: '[PRE3]'
  id: totrans-34
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Next, we''ll need to run the initial migrations and then import the sample
    data that is provided in the `protected/data` folder. This sample data will allow
    us to immediately log in to our application and start using it once the application
    is running. Navigate to the root of the project, and then run the following commands:'
  id: totrans-35
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们需要运行初始迁移，然后导入位于`protected/data`文件夹中的示例数据。这些示例数据将使我们能够在应用程序运行后立即登录并开始使用它。导航到项目根目录，然后运行以下命令：
- en: '[PRE4]'
  id: totrans-36
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Then, we will need to update `params.php` located at `protected/config/` with
    our SendGrid information. Your username and password will correspond to your SendGrid
    username and password. Keeping in line with our example domain, set the `from`
    address to `socialii@chapter5.example.com`.
  id: totrans-37
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们需要更新位于`protected/config/`的`params.php`文件，并添加我们的SendGrid信息。你的用户名和密码将与你的SendGrid用户名和密码相对应。按照我们的示例域名，将`from`地址设置为`socialii@chapter5.example.com`。
- en: 'Finally, we will need to install the necessary Composer dependencies:'
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们需要安装必要的Composer依赖项：
- en: '[PRE5]'
  id: totrans-39
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'At this point, you should be able to open `http://chapter5.example.com` in
    your browser and see the following page:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，你应该能够在浏览器中打开`http://chapter5.example.com`并看到以下页面：
- en: '![Initializing the project](img/7734OS_05_03.jpg)'
  id: totrans-41
  prefs: []
  type: TYPE_IMG
  zh: '![初始化项目](img/7734OS_05_03.jpg)'
- en: Making a better Yii bootstrap file
  id: totrans-42
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 制作更好的Yii引导文件
- en: 'One thing you may have noticed was that we didn''t have to declare where the
    Yii framework was located for our site to work. That''s because we included Yii
    framework as a dependency in our `composer.json` file, as follows:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能注意到的一件事是，我们不必声明Yii框架的位置，我们的网站才能工作。这是因为我们在`composer.json`文件中将Yii框架作为依赖项包含在内，如下所示：
- en: '[PRE6]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'There are several benefits to including Yii as a dependency in our project
    rather than hardcoding it in our bootstrapper, which are as follows:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 将Yii作为依赖项包含在我们的项目中而不是在引导程序中硬编码，有以下几个好处：
- en: Including it in our bootstrapper as a Composer dependency means that we don't
    have to bother installing Yii framework on our server before we push our code
    to it
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将其作为Composer依赖项包含在我们的引导程序中意味着我们不必在将代码推送到服务器之前在服务器上安装Yii框架
- en: We can now automate our deployment process, and be certain that the dependencies
    in our development environment match those of our production environment
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们现在可以自动化我们的部署流程，并确保我们的开发环境中的依赖项与生产环境中的依赖项相匹配
- en: The code used for this project is now separate from other projects that might
    also use Yii framework
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 本项目使用的代码现在与其他可能也使用Yii框架的项目分开
- en: Finally, this separation allows us to upgrade Yii or use a different fork of
    Yii without having to worry about how we're going to deploy Yii framework to our
    server—Composer will simply take care of the installation for us
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后，这种分离使我们能够在不担心如何将Yii框架部署到我们的服务器的情况下升级Yii或使用Yii的不同分支
- en: 'We''ve also made a few improvements and changes to our Bootstrap file to make
    developing and debugging easier for us. Let''s take a look at the changes in our
    `index.php` file:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还对Bootstrap文件进行了一些改进和更改，以便于我们开发和调试。让我们看看`index.php`文件中的更改：
- en: 'First, we include our configuration file:'
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们包含我们的配置文件：
- en: '[PRE7]'
  id: totrans-52
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Next, we''re going to set `YII_DEBUG` and `YII_TRACE` to variables that are
    defined in our `main.php` file at `protected/config/`. This will allow us to toggle
    the debug mode and the trace level without having to alter the code in `index.php`:'
  id: totrans-53
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将把`YII_DEBUG`和`YII_TRACE`设置为在`protected/config/main.php`文件中定义的变量。这将允许我们切换调试模式和跟踪级别，而无需修改`index.php`中的代码：
- en: '[PRE8]'
  id: totrans-54
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'In our `main.php` file at `protected/config/`, we can toggle these variables
    by setting `params[debug]` and `params[trace]`:'
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`protected/config/main.php`文件中，我们可以通过设置`params[debug]`和`params[trace]`来切换这些变量：
- en: '[PRE9]'
  id: totrans-56
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Then, we''re going to load our Composer dependencies. Depending on whether
    `YII_DEBUG` is set or not, load `yii.php` or `yiilite.php`. For most configurations,
    and when coupled with APC Cache or Zend OPcache, `yiilite.php` should improve
    the performance of your application:'
  id: totrans-57
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们将加载我们的Composer依赖项。根据`YII_DEBUG`是否设置，加载`yii.php`或`yiilite.php`。对于大多数配置，以及与APC
    Cache或Zend OPcache结合使用时，`yiilite.php`应该可以提高你应用程序的性能：
- en: '[PRE10]'
  id: totrans-58
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Note
  id: totrans-59
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: If you want to learn more about yiilite, take a look at the official Yii documentation
    at [http://www.yiiframework.com/doc/guide/1.1/en/topics.performance#using-x-9x](http://www.yiiframework.com/doc/guide/1.1/en/topics.performance#using-x-9x).
  id: totrans-60
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果您想了解更多关于 yiilite 的信息，请查看官方 Yii 文档[http://www.yiiframework.com/doc/guide/1.1/en/topics.performance#using-x-9x](http://www.yiiframework.com/doc/guide/1.1/en/topics.performance#using-x-9x)。
- en: 'Next, we''re going to automatically enable logging, and turn error reporting
    to its maximum value when we''re in the debug mode. This will allow us to easily
    view full stack traces when an error occurs and get detailed log messages about
    what''s going on in our application. This option will help with development and
    won''t be loaded when we are running in a production environment:'
  id: totrans-61
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将自动启用日志记录，并在调试模式下将错误报告设置为最大值。这将使我们能够轻松地查看错误发生时的完整堆栈跟踪，并获得有关应用程序中发生情况的详细日志消息。此选项将有助于开发，而不会在生产环境中加载：
- en: '[PRE11]'
  id: totrans-62
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'For the preceding step to work, we then need to define a logging method that
    we want to use. In our development environment, it makes sense to use `CWebLogRoute`
    so that we can see our log messages in our browser. To enable this route, we''ll
    add the following to the components section of our `main.php` file located at
    `protected/config/`:'
  id: totrans-63
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了使前面的步骤生效，我们需要定义一个我们想要使用的日志记录方法。在我们的开发环境中，使用 `CWebLogRoute` 是合理的，这样我们就可以在我们的浏览器中看到我们的日志消息。为了启用此路由，我们将在位于
    `protected/config/` 的 `main.php` 文件中的组件部分添加以下内容：
- en: '[PRE12]'
  id: totrans-64
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Note
  id: totrans-65
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Yii provides several different logging methods that you can use in both production
    and development environments. To learn more about logging, take a look at the
    official Yii documentation at [http://www.yiiframework.com/doc/guide/1.1/en/topics.logging](http://www.yiiframework.com/doc/guide/1.1/en/topics.logging).
  id: totrans-66
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: Yii 提供了多种不同的日志记录方法，您可以在生产环境和开发环境中使用。要了解更多关于日志记录的信息，请查看官方 Yii 文档[http://www.yiiframework.com/doc/guide/1.1/en/topics.logging](http://www.yiiframework.com/doc/guide/1.1/en/topics.logging)。
- en: 'Finally, we''re going to bootstrap our application:'
  id: totrans-67
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们将引导我们的应用程序：
- en: '[PRE13]'
  id: totrans-68
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Enabling users to manage their information
  id: totrans-69
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 允许用户管理他们的信息
- en: In the previous chapters, our users haven't been able to do much besides interacting
    with content. In this chapter, we'll be expanding upon the base User model so
    that they can register with our application, securely activate their accounts,
    reset their passwords if they forget them, and change their e-mail address.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的章节中，我们的用户除了与内容互动之外，几乎无法做任何事情。在本章中，我们将扩展基础用户模型，使他们能够注册我们的应用程序，安全地激活他们的账户，如果他们忘记密码，可以重置密码，以及更改他们的电子邮件地址。
- en: Upgrading our UserIdentity class
  id: totrans-71
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 升级我们的 UserIdentity 类
- en: 'Before implementing the previously mentioned functionality, we need to make
    sure that we can address our users appropriately without having to ask our database
    for some basic information about the currently logged-in user. To do this, we''re
    going to add some information to our `UserIdentity.php` file located at `protected/components/`
    as shown next in the highlighted sections of our `authenticate()` method. Additionally,
    we''re going to enhance this class so that if `YII_DEBUG` is enabled, we can get
    more information about what is going on if authentication fails:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 在实现之前提到的功能之前，我们需要确保我们能够适当地处理我们的用户，而无需向我们的数据库请求有关当前登录用户的一些基本信息。为此，我们将在位于 `protected/components/`
    的 `UserIdentity.php` 文件中添加一些信息，如下所示，在 `authenticate()` 方法的突出部分中：
- en: '[PRE14]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Defining user relations
  id: totrans-74
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 定义用户关系
- en: 'Next, we''ll want to make sure that our relations are set up so that we can
    tell which data is associated with our users. This includes shares, followers,
    and followees. Within our `protected/models/User.php` file, make sure the following
    is set to our `relations()` method:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们想要确保我们的关系设置正确，以便我们可以知道哪些数据与我们的用户相关联。这包括分享、关注者和被关注者。在我们的 `protected/models/User.php`
    文件中，确保以下内容设置到我们的 `relations()` 方法中：
- en: '[PRE15]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'We''re also going to add a new relational type to our `relations()` method
    so that we can quickly retrieve the number of shares, followers, and followees
    a user has. This relation type is called `STAT`, and behaves the same as a `HAS_MANY`
    relation, except that it performs a count at the database level and returns a
    number rather than returning an array of objects:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将在 `relations()` 方法中添加一个新的关系类型，以便我们可以快速检索用户拥有的分享数、关注者和被关注者的数量。这种关系类型称为 `STAT`，其行为与
    `HAS_MANY` 关系相同，但它在数据库级别执行计数并返回一个数字，而不是返回对象数组：
- en: '[PRE16]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: By using the `STAT` relation, we can reduce the strain on our database when
    we want to know how many followers a user has. In a small database with a few
    users, a `HAS_MANY` relationship isn't very significant; however, when dealing
    with thousands of users, repeatedly running a `HAS_MANY` query will result in
    a large number of results to be returned, which can result in our application
    running out of memory and crashing.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用`STAT`关系，当我们想知道一个用户有多少关注者时，可以减少对数据库的压力。在一个用户数量较少的小型数据库中，`HAS_MANY`关系并不十分显著；然而，当处理数千个用户时，反复执行`HAS_MANY`查询会导致返回大量结果，这可能导致我们的应用程序耗尽内存并崩溃。
- en: Determining whether a user is following another user
  id: totrans-80
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 确定一个用户是否关注另一个用户
- en: 'The last change we need to make to our model for our relations is to add a
    quick method that will allow us to determine whether the currently logged-in user
    is following another user. We''ll use this information later on to adjust what''s
    displayed in our views. Add the following method to your `User.php` file located
    at `protected/models/`:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要对模型中的关系进行的最后一个更改是添加一个快速方法，以便我们能够确定当前登录的用户是否关注另一个用户。我们将在稍后使用此信息来调整视图中的显示内容。将以下方法添加到位于`protected/models/`的`User.php`文件中：
- en: '[PRE17]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Implementing a secure registration process
  id: totrans-83
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现安全的注册过程
- en: One of the more difficult parts of creating a secure web application is ensuring
    that the users who register on our site are really the users they claim to be.
    Often, this is accomplished by sending an e-mail to the user with a unique single-use
    token. If the user is able to visit our site with that secure token, we can assume
    that they are real users, and that they have access to the e-mail address. By
    employing this method of validation, we can ensure that the users who register
    on our site are who they claim to be, and that they choose to engage with our
    application.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 创建安全Web应用的一个更困难的部分是确保在我们网站上注册的用户确实是他们声称的用户。通常，这是通过向用户发送包含唯一一次性令牌的电子邮件来完成的。如果用户能够使用这个安全令牌访问我们的网站，我们可以假设他们是真实的用户，并且他们有权访问电子邮件地址。通过采用这种验证方法，我们可以确保在我们网站上注册的用户是他们所声称的用户，并且他们选择与我们应用程序互动。
- en: While we could handle the majority of this functionality directly within our
    controller and bloat our User model with unnecessary methods, our tool of choice
    for this task will be `CFormModel`. In this book, we've only utilized `CFormModel`
    for our `LoginForm` model, which we've been using for logging users in. Before
    moving forward, let's take a deeper look into what `CFormModel` is and explore
    how we can use it.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管我们可以在控制器中直接处理大部分此功能，并使用户模型因不必要的函数而膨胀，但我们将选择`CFormModel`作为此任务的工具。在这本书中，我们只使用了`CFormModel`来处理`LoginForm`模型，这是我们用来登录用户的。在继续前进之前，让我们深入了解`CFormModel`是什么，并探讨我们如何使用它。
- en: '`CFormModel` is very similar to `CActiveRecord`, in that it extends `CModel`
    and inherits many of the methods that `CActiveRecord` has, such as `attributeLabels`,
    `attributes`, and `rules`. The primary difference between `CFormModel` and `CActiveRecord`
    is that `CFormModel` is used to collect information from an HTML form, and the
    data submitted to `CFormModel` is acted upon rather than stored and manipulated
    in a database. By taking advantage of the methods inherited from `CModel`, we
    can cleanly and easily use `CFormModel` to validate input and reduce the amount
    of code clutter in our controllers and models.'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '`CFormModel`与`CActiveRecord`非常相似，因为它扩展了`CModel`并继承了`CActiveRecord`的许多方法，如`attributeLabels`、`attributes`和`rules`。`CFormModel`与`CActiveRecord`的主要区别在于`CFormModel`用于从HTML表单收集信息，提交给`CFormModel`的数据是被处理的，而不是存储和操纵在数据库中。通过利用从`CModel`继承的方法，我们可以干净且容易地使用`CFormModel`来验证输入，并减少控制器和模型中的代码杂乱。'
- en: Note
  id: totrans-87
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: To learn more about `CFormModel`, check out the official Yii documentation at
    [http://www.yiiframework.com/doc/api/1.1/CFormModel](http://www.yiiframework.com/doc/api/1.1/CFormModel).
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解更多关于`CFormModel`的信息，请查看官方Yii文档[http://www.yiiframework.com/doc/api/1.1/CFormModel](http://www.yiiframework.com/doc/api/1.1/CFormModel)。
- en: 'To get started, create a new file in `protected/models/RegistrationForm.php`
    and add the following to it:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始，在`protected/models/RegistrationForm.php`中创建一个新文件，并将其添加以下内容：
- en: '[PRE18]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The next steps are as follows:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步如下：
- en: 'The first item we''ll be placing in this class is our attributes. These model
    attributes are publicly exposed, and can be set from our controllers:'
  id: totrans-92
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将在类中放置的第一个项目是我们的属性。这些模型属性是公开的，可以从我们的控制器中设置：
- en: '[PRE19]'
  id: totrans-93
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Next, we''ll define our attribute labels for these attributes:'
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将定义这些属性的标签：
- en: '[PRE20]'
  id: totrans-95
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Then, we''ll want to set up our validation rules. For new users, we want to
    verify that all attributes are set, the e-mail address is a valid one, the password
    is at least `8` characters long, and the username the user''s trying to register
    with is not already taken:'
  id: totrans-96
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们需要设置我们的验证规则。对于新用户，我们希望验证所有属性都已设置，电子邮件地址是有效的，密码至少有 `8` 个字符长，并且用户尝试注册的用户名尚未被占用：
- en: '[PRE21]'
  id: totrans-97
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Since Yii doesn''t provide a native validator for usernames, we will then need
    to define our own `validateUsername()` method, which will do a simple existence
    check against our database:'
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于 Yii 没有提供原生的用户名验证器，因此我们需要定义自己的 `validateUsername()` 方法，该方法将对我们的数据库进行简单的存在性检查：
- en: '[PRE22]'
  id: totrans-99
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'We''ll also want to define a validator to ensure that our e-mail address is
    not already taken:'
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们还希望定义一个验证器来确保我们的电子邮件地址尚未被占用：
- en: '[PRE23]'
  id: totrans-101
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Note
  id: totrans-102
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'Notice that when validation fails, we''re not only returning false but also
    adding an error to our model. We''re doing this for three reasons: to enhance
    the user experience and ensure that the user knows what went wrong, to ensure
    that the `validate()` method of `CModel` fails when an error is thrown (it will
    return true unless `$this->addError()` is called), and to ensure that we can run
    these validators independently of the form.'
  id: totrans-103
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意到当验证失败时，我们不仅返回了 false，还向我们的模型添加了一个错误。我们这样做有三个原因：为了增强用户体验并确保用户知道出了什么问题，为了确保当抛出错误时
    `CModel` 的 `validate()` 方法失败（除非调用 `$this->addError()`，否则它将返回 true），以及为了确保我们可以独立于表单运行这些验证器。
- en: 'Out of preference, the last method we''ll be creating is a `save()` method,
    which will perform the validation, send a verification e-mail to the user, and
    insert the new record into our database. To achieve this, start by creating a
    new method called `save()`:'
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 根据优先级，我们将创建的最后一个方法是 `save()` 方法，它将执行验证，向用户发送验证电子邮件，并将新记录插入到我们的数据库中。为了实现这一点，首先创建一个名为
    `save()` 的新方法：
- en: '[PRE24]'
  id: totrans-105
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Then, within the method, first perform the validation:'
  id: totrans-106
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 然后，在方法内部，首先执行验证：
- en: '[PRE25]'
  id: totrans-107
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Then, create a new `User` object:'
  id: totrans-108
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 然后，创建一个新的 `User` 对象：
- en: '[PRE26]'
  id: totrans-109
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Then, attempt to save the user and send that user an e-mail address with the
    activation details:'
  id: totrans-110
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 然后，尝试保存用户并发送包含激活详情的电子邮件地址给该用户：
- en: '[PRE27]'
  id: totrans-111
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Next, we''ll want to update our User models so that the activation key is set
    when the user is first created. To generate the activation key, we''ll be using
    a library that was included in our `composer.json` file that securely generates
    strings:'
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们需要更新我们的用户模型，以便在用户首次创建时设置激活密钥。为了生成激活密钥，我们将使用包含在我们的 `composer.json` 文件中的库，该库可以安全地生成字符串：
- en: '[PRE28]'
  id: totrans-113
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Now, we can add a register action to our `UserController.php` file located
    at `protected/controllers/` that will allow the user to register with our site.
    Since majority of the work has already been done in our form, all we have to do
    is collect the data from the `$_POST` request, apply it to the model, and call
    the `save()` method on the model. To provide a better user experience, we can
    also attempt to automatically log the user in using their new credentials:'
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们可以在 `protected/controllers/` 目录下的 `UserController.php` 文件中添加一个注册动作，允许用户使用我们的网站注册。由于大部分工作已经在我们的表单中完成，我们只需要从
    `$_POST` 请求中收集数据，将其应用于模型，并在模型上调用 `save()` 方法。为了提供更好的用户体验，我们还可以尝试使用用户的新凭据自动登录：
- en: '[PRE29]'
  id: totrans-115
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Then, from the project resources folder, copy the following view files into
    your project: `protected/views/user/register.php`, `protected/views/email/activate.php`,
    and `protected/views/site/index.php`. Now, either from the `site/index` or `user/register`
    route, you can register a new account in your site.'
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，从项目资源文件夹中，将以下视图文件复制到您的项目中：`protected/views/user/register.php`、`protected/views/email/activate.php`
    和 `protected/views/site/index.php`。现在，您可以从 `site/index` 或 `user/register` 路由注册一个新的账户到您的网站。
- en: 'Finally, create a new method in your `UserController.php` file located at `protected/controllers/`
    called `actionActivate()` that will actually activate our user. To do so, we''re
    simply going to verify that the ID parameter sent to us in the route matches with
    what we have on file for the user:'
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，在 `protected/controllers/` 目录下的 `UserController.php` 文件中创建一个新的方法 `actionActivate()`，该方法将实际激活我们的用户。为此，我们将简单地验证发送给我们的路由中的
    ID 参数是否与文件中记录的用户匹配：
- en: '[PRE30]'
  id: totrans-118
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'We can also reuse the form we just created on our home page to allow users
    to log in or register a new account from there. Since we''ve already copied the
    view over, we simply need to adjust the `SiteController` `actionIndex()` method:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以在我们的主页上重用我们刚刚创建的表单，允许用户从那里登录或注册新账户。由于我们已经复制了视图，我们只需要调整`SiteController`的`actionIndex()`方法：
- en: '[PRE31]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Handling forgotten passwords
  id: totrans-121
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 处理忘记密码的情况
- en: As previously shown, using `CFormModel` to handle input from an HTML form makes
    it very easy to validate submitted information and act upon it while keeping our
    models and controllers very clear. We can once again use `CFormModel` to handle
    forgotten password requests from a user.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所示，使用`CFormModel`处理来自HTML表单的输入使得验证提交的信息并采取行动变得非常容易，同时保持我们的模型和控制器非常清晰。我们还可以再次使用`CFormModel`来处理用户的忘记密码请求。
- en: 'To handle forgotten passwords, we''re going to request that the user provides
    us with the e-mail address they used to register their account. Next, we''ll verify
    that we have an e-mail address on file, and then send the user an e-mail with
    a single use token that will allow them to securely reset their password. To start,
    create a new file called `ForgotForm.php` in `protected/models` and add the following
    to it:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 为了处理忘记密码的情况，我们将要求用户提供他们用于注册账户的电子邮件地址。接下来，我们将验证我们是否有存档的电子邮件地址，然后发送一个包含一次性令牌的电子邮件给用户，该令牌将允许他们安全地重置密码。首先，在`protected/models`中创建一个名为`ForgotForm.php`的新文件，并将其添加以下内容：
- en: '[PRE32]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'The next steps are as follows:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步如下：
- en: 'Begin by declaring the public attributes of our form:'
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，声明我们表单的公共属性：
- en: '[PRE33]'
  id: totrans-127
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'We''re also going to declare a private property for our User model that we''ll
    be reusing throughout this model:'
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们还将为我们的用户模型声明一个私有属性，我们将在整个模型中重用它：
- en: '[PRE34]'
  id: totrans-129
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Next, we''ll declare our validation rules and custom validator:'
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将声明我们的验证规则和自定义验证器：
- en: '[PRE35]'
  id: totrans-131
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Then, we will declare our `save()` method that will send the user the e-mail
    and indicate that they have asked for their password to be reset:'
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们将声明我们的`save()`方法，该方法将向用户发送电子邮件并指示他们已请求重置密码：
- en: '[PRE36]'
  id: totrans-133
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Then, create an action in `protected/controllers/UserController.php` to handle
    the form submission:'
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，在`protected/controllers/UserController.php`中创建一个操作来处理表单提交：
- en: '[PRE37]'
  id: totrans-135
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Finally, copy `protected/views/user/forgot.php`, `protected/views/user/forgot_success.php`
    and `protected/views/email/forgot.php` from the project resources folder into
    your application.
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，从项目资源文件夹中复制`protected/views/user/forgot.php`、`protected/views/user/forgot_success.php`和`protected/views/email/forgot.php`到您的应用程序中。
- en: Resetting a forgotten password
  id: totrans-137
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 重置忘记的密码
- en: 'Once the user has the single-use token we sent them, we can then allow the
    user to securely change their password to whatever they want. Start by creating
    a new file in `protected/models` called `PasswordResetform.php` with the following:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦用户获得了我们发送给他们的一次性令牌，我们就可以允许用户安全地将他们的密码更改为他们想要的任何内容。首先，在`protected/models`中创建一个名为`PasswordResetform.php`的新文件，并添加以下内容：
- en: '[PRE38]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'The next steps are as follows:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步如下：
- en: 'Begin by declaring the public attributes for this form:'
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，声明此表单的公共属性：
- en: '[PRE39]'
  id: totrans-142
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Then, add the validation rules. The user''s new password should have the same
    requirements as when the user registered. Since we''re requesting the password
    twice, we''ll want to compare the two passwords using the compare validator. This
    validator validates the first attribute against the `attribute_repeat` attribute:'
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，添加验证规则。用户的新密码应该与注册时相同的要求。由于我们要求输入两次密码，我们将使用比较验证器来比较这两个密码。此验证器将第一个属性与`attribute_repeat`属性进行比较：
- en: '[PRE40]'
  id: totrans-144
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Then, add the `save()` method to reset the user''s password:'
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，添加用于重置用户密码的`save()`方法：
- en: '[PRE41]'
  id: totrans-146
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Then, create our controller action:'
  id: totrans-147
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，创建我们的控制器操作：
- en: '[PRE42]'
  id: totrans-148
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Finally, copy `protected/views/user/resetpassword.php` and `protected/views/user/resetpassword_success.php`
    from the project resources folder into your application.
  id: totrans-149
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，从项目资源文件夹中复制`protected/views/user/resetpassword.php`和`protected/views/user/resetpassword_success.php`到您的应用程序中。
- en: Enabling users to manage their details
  id: totrans-150
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 允许用户管理他们的详细信息
- en: 'At this point, we can now log in, register an account, and reset our passwords
    if we forgot them. Now, let''s work on allowing users to manage their own details.
    This includes allowing them to change their password, e-mail address, and the
    other pieces of information that we collect during the registration process. The
    steps are as follows:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们现在可以登录，注册账户，如果我们忘记了密码，还可以重置密码。现在，让我们着手允许用户管理他们自己的详细信息。这包括允许他们更改密码、电子邮件地址以及我们在注册过程中收集的其他信息。步骤如下：
- en: 'We''ll start by once again creating a new `CFormModel` in `protected/models`
    called `ProfileForm.php`:'
  id: totrans-152
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将首先在 `protected/models` 中再次创建一个新的 `CFormModel`，名为 `ProfileForm.php`：
- en: '[PRE43]'
  id: totrans-153
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Then, we''ll add our attributes and labels:'
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们将添加我们的属性和标签：
- en: '[PRE44]'
  id: totrans-155
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'We''ll then add our basic validation rules:'
  id: totrans-156
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们将添加我们的基本验证规则：
- en: '[PRE45]'
  id: totrans-157
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Before allowing the user to change any of their information (including their
    password and e-mail address), we''re going to require them to enter their current
    password. This will validate that they have control over the account:'
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在允许用户更改任何信息（包括他们的密码和电子邮件地址）之前，我们将要求他们输入他们的当前密码。这将验证他们是否控制着账户：
- en: '[PRE46]'
  id: totrans-159
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'We''ll then add our `save()` method that will update the user''s information:'
  id: totrans-160
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们将添加我们的 `save()` 方法，该方法将更新用户的信息：
- en: '[PRE47]'
  id: totrans-161
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'In the `save()` method, we declared two new methods: `sendPasswordChangeNotification()`
    and `sendEmailChangeNotification()`. These two methods will send e-mails to the
    user when the event occurs:'
  id: totrans-162
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `save()` 方法中，我们声明了两个新方法：`sendPasswordChangeNotification()` 和 `sendEmailChangeNotification()`。这两个方法将在事件发生时向用户发送电子邮件：
- en: '[PRE48]'
  id: totrans-163
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'The second method, `sendEmailChangeNotification()` sends an e-mail to the user
    when the user''s e-mail address changes. This allows us to verify their new e-mail
    address before we start using it in our application:'
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 第二种方法，`sendEmailChangeNotification()` 当用户的电子邮件地址发生变化时向用户发送电子邮件。这允许我们在开始在我们的应用程序中使用它之前验证他们的新电子邮件地址：
- en: '[PRE49]'
  id: totrans-165
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Then, within our `UserController`, we''ll define our `actionIndex()` method
    that will collect this information:'
  id: totrans-166
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，在我们的 `UserController` 中，我们将定义我们的 `actionIndex()` 方法，该方法将收集这些信息：
- en: '[PRE50]'
  id: totrans-167
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE50]'
- en: Finally, we need to copy `protected/views/user/index.php`, `protected/view/email/passwordchange.php`
    and `protected/views/email/verify.php` from our project resources folder into
    our project.
  id: totrans-168
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们需要将 `protected/views/user/index.php`、`protected/view/email/passwordchange.php`
    和 `protected/views/email/verify.php` 从我们的项目资源文件夹复制到我们的项目中。
- en: Verifying a new e-mail address
  id: totrans-169
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 验证新的电子邮件地址
- en: Now, our users can change their own information without having to go through
    us. Before we close `UserController`, there are a couple of more methods that
    we need to implement.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们的用户可以更改自己的信息，而无需通过我们。在我们关闭 `UserController` 之前，还有一些其他方法需要实现。
- en: 'One secure way of changing a user''s e-mail address is to store the new e-mail
    address in a temporary table or column in our database and then send to that e-mail
    address a verification e-mail (this is what we implemented in our `ProfileForm`
    class). This allows us to indicate that we''re aware that the user wants to change
    their password, but we require them to prove that they have access to the new
    e-mail address. The e-mail that we sent them contains a secure activation token
    and a link to the `actionVerify()` method, which will verify that the token belongs
    to the user, and then move the new e-mail address to the main e-mail address field
    in our database. We can implement the `actionVerify()` method as follows:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 更改用户电子邮件地址的一种安全方式是将新电子邮件地址存储在我们的数据库中的一个临时表或列中，然后向该电子邮件地址发送一个验证电子邮件（这是我们已经在 `ProfileForm`
    类中实现的）。这允许我们表明我们知道用户想要更改密码，但我们要求他们证明他们可以访问新的电子邮件地址。我们发送给他们的电子邮件包含一个安全的激活令牌和一个链接到
    `actionVerify()` 方法，该方法将验证令牌是否属于用户，然后将新的电子邮件地址移动到我们数据库中的主要电子邮件地址字段。我们可以按照以下方式实现
    `actionVerify()` 方法：
- en: '[PRE51]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'The last actions we''ll implement for this controller will allow a user to
    follow and unfollow another user. We''ll use these actions in our views later
    in the chapter. For now, implement the actions as follows:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将为这个控制器实现的最后操作将允许用户关注和取消关注另一个用户。我们将在本章后面的视图中使用这些操作。现在，按照以下方式实现这些操作：
- en: '[PRE52]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Before closing this controller, verify that the `accessRules()` method is set
    up correctly:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 在关闭此控制器之前，请确保 `accessRules()` 方法设置正确：
- en: '[PRE53]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: Viewing a timeline of shares
  id: totrans-177
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 查看分享的时间线
- en: 'The easiest way to display new content is to simply list it so that the newest
    items are shown first. On our timeline page, we want to provide the user with
    the ability to share something, view information about the user they are viewing
    (such as the number of shares, followers, and followees), and view things that
    the user has recently shared. To do this, we''re going to take advantage of `CListView`
    loaded asynchronously from our main timeline view. This will allow us to reuse
    this view later on by simply making a `GET` request to an endpoint that we''ll
    create later. In our `TimelineController.php` file located at `protected/controllers/`,
    implement the `actionIndex()` method:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 显示新内容最简单的方法就是简单地列出它，以便显示最新的项目。在我们的时间线页面上，我们希望为用户提供分享东西、查看他们正在查看的用户的信息（例如共享数量、关注者和被关注者）以及查看用户最近分享的内容的能力。为此，我们将利用从我们的主时间线视图异步加载的`CListView`。这将允许我们稍后通过简单地向我们将要创建的端点发出`GET`请求来重用此视图。在我们的`TimelineController.php`文件中，位于`protected/controllers/`，实现`actionIndex()`方法：
- en: '[PRE54]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: All that we're doing in this action is retrieving the user ID (in this case,
    the username of the user) from the route and then passing some information down
    to our view. From the project resources folder, copy the `index.php` file located
    at `protected/views/timeline/` into your project. Let's take a look at some of
    the more interesting parts of this file.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个动作中，我们所做的一切就是从路由中检索用户ID（在这种情况下，用户的用户名），然后将一些信息传递到我们的视图中。从项目资源文件夹中，将位于`protected/views/timeline/`的`index.php`文件复制到您的项目中。让我们看看这个文件中一些更有趣的部分。
- en: The first thing to notice in this file is that we're simply using `CActiveForm`
    to display the new share container. Moreover, at the bottom of this file, we've
    implemented some JavaScript to do some rudimentary form validation checking, to
    clear the text field upon asynchronous submission, to adjust the number of shares
    we have, and finally, to prepend the new share to the top of our shares list.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个文件中，首先要注意的是我们只是简单地使用`CActiveForm`来显示新的共享容器。此外，在这个文件的底部，我们实现了一些JavaScript来进行一些基本的表单验证检查，以便在异步提交时清除文本字段，调整我们拥有的共享数量，最后将新的共享添加到我们的共享列表顶部。
- en: 'The second thing to notice is that we''ve implemented conditional follow and
    unfollow button links to allow our users to simply click on a link to follow or
    unfollow a particular user:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个要注意的是，我们实现了条件关注和取消关注按钮链接，允许我们的用户简单地点击一个链接来关注或取消关注特定用户：
- en: '[PRE55]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'The last thing to notice in this file is our use of the count relations we
    set up earlier in our User model:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个文件中最后要注意的是我们使用我们在用户模型中之前设置的计数关系：
- en: '[PRE56]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'Finally, we''re loading our shares for this user by registering an asynchronous
    callback to fetch the appropriate shares, regardless of which user we are viewing
    the share for:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们通过注册一个异步回调来获取适当的共享来加载此用户的共享，无论我们正在查看哪个用户的共享：
- en: '[PRE57]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: Retrieving shares
  id: totrans-188
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 获取共享
- en: 'Now, let''s implement our action that will display our shares. This action
    will have slightly different behaviors depending on whether we''re viewing our
    timeline or a timeline of another user. Within our `ShareController.php` file
    located at `protected/controllers/`, implement `actionGetShares`, as follows:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们实现我们的动作，该动作将显示我们的共享。这个动作的行为将根据我们是在查看我们的时间线还是另一个用户的时间线而略有不同。在我们的`ShareController.php`文件中，位于`protected/controllers/`，实现`actionGetShares`，如下所示：
- en: '[PRE58]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'The next steps are as follows:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步如下：
- en: 'Since this is an asynchronous callback, we don''t want to render anything from
    our layout:'
  id: totrans-192
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于这是一个异步回调，我们不希望从我们的布局中渲染任何内容：
- en: '[PRE59]'
  id: totrans-193
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'Next, we''re going to either throw an error if a user wasn''t provided and
    we''re not logged in, or set the user to ourselves if we are logged in and an
    ID was given to us:'
  id: totrans-194
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将抛出一个错误，如果未提供用户并且我们没有登录，或者如果我们登录并且有人给了我们一个ID，我们将用户设置为 ourselves：
- en: '[PRE60]'
  id: totrans-195
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'Then we''re going to implement `CListView`, which will retrieve data from our
    `GET` parameters:'
  id: totrans-196
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们将实现`CListView`，它将从我们的`GET`参数中检索数据：
- en: '[PRE61]'
  id: totrans-197
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'When viewing another user''s timeline, we only care about the shares that they
    have shared with the world. However, when we''re viewing our timeline, we want
    to view both our shares and the shares of the user we are following. We can implement
    the controller portion of this as follows:'
  id: totrans-198
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当查看另一个用户的时间线时，我们只关心他们与世界共享的共享。然而，当我们查看我们的时间线时，我们希望查看我们的共享以及我们正在关注的用户的共享。我们可以这样实现控制器部分：
- en: '[PRE62]'
  id: totrans-199
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'Then, we''ll need to implement our `getshares.php` view file at `protected/views/shares/`
    as `CListView`. Notice that we''re passing down `$myFollowers` as a custom parameter
    to our Share model''s `search()` method:'
  id: totrans-200
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们需要在`protected/views/shares/`中实现我们的`getshares.php`视图文件，作为`CListView`。注意，我们正在将`$myFollowers`作为自定义参数传递给Share模型的`search()`方法：
- en: '[PRE63]'
  id: totrans-201
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'Then, within our model, we''re going to adjust our `search()` method so that
    it conditionally loads the appropriate data:'
  id: totrans-202
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，在我们的模型中，我们将调整我们的`search()`方法，以便它有条件地加载适当的数据：
- en: '[PRE64]'
  id: totrans-203
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE64]'
- en: Finally, we can implement our individual share view by copying `protected/views/share/share.php`
    from our project resources folder into our project.
  id: totrans-204
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们可以通过将项目资源文件夹中的`protected/views/share/share.php`复制到我们的项目中来实现我们的单个分享视图。
- en: 'Within this file, we''re going to implement some custom logic so that hashtags
    (#) and @ mentions are displayed as links. This will allow us to store unformatted
    text in our database, which in turns means we could adjust the way our views work
    without having to modify our data. We''re also going to render our text in Markdown
    to allow our users to add links or other custom formatting, but prevent them from
    attempting XSS injection:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个文件中，我们将实现一些自定义逻辑，以便将哈希标签（#）和@提及显示为链接。这将使我们能够在数据库中存储未格式化的文本，这意味着我们可以调整视图的工作方式，而无需修改我们的数据。我们还将以Markdown格式渲染我们的文本，以便我们的用户可以添加链接或其他自定义格式，但防止他们尝试XSS注入：
- en: '[PRE65]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: Sharing new content
  id: totrans-207
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 分享新内容
- en: 'At this point, if we had shares in our database, we''d be able to see them.
    So let''s work on sharing new content! From within our controller, the action
    to handle sharing is simply going to be loading a new Share model and populating
    it. Have a look at the following code:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，如果我们数据库中有分享，我们就能看到它们。所以让我们专注于分享新内容！从我们的控制器中，处理分享的动作只是简单地加载一个新的Share模型并填充它。看看以下代码：
- en: '[PRE66]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'Though, the real power behind sharing content happens in the `beforeSave()`
    method of our Share model. From here, we handle all the mentioning that may occur
    within our model, and send an e-mail to everyone who was mentioning in the share.
    The code is as follows:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，分享内容的真正力量在于我们的Share模型中的`beforeSave()`方法。从这里，我们处理模型中可能发生的所有提及，并向所有在分享中被提及的人发送电子邮件。代码如下：
- en: '[PRE67]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: Resharing
  id: totrans-212
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 重新分享
- en: Since everything in our model is already implemented, we can easily implement
    resharing now as a new controller action within `protected/controllers/ShareController.php`.
    Resharing allows a user to share something another user shared, while still giving
    that user credit for the original share. In our controller, what we're going to
    do is load the share we want to reshare with our network, change the author to
    us, and then indicate that this is a reshare of another share.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们的模型中已经实现了所有内容，我们可以轻松地现在作为一个新的控制器行为在`protected/controllers/ShareController.php`中实现重新分享。重新分享允许用户分享另一个用户分享的内容，同时仍然给予原始分享的用户应有的信用。在我们的控制器中，我们将加载我们想要重新分享的分享，将其作者更改为我们，然后指出这是另一个分享的重新分享。
- en: 'First, let''s create a `loadModel()` utility method:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们创建一个`loadModel()`实用方法：
- en: '[PRE68]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'Then, we''ll implement the resharing ability as described in the *Describing
    the project* section:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将实现如*描述项目*部分所述的重新分享功能：
- en: '[PRE69]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: Liking and unliking shares
  id: totrans-218
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 点赞和取消点赞分享
- en: Next, we'll implement the actions and methods necessary for a user to like and
    unlike a given share. The only restriction on likes should be that a user can't
    like a share more than once.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将实现用户对特定分享进行点赞和取消点赞所需的行为和方法。点赞的唯一限制是用户不能对同一个分享点赞超过一次。
- en: 'We can implement the action for liking in `ShareController` as follows:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在`ShareController`中实现点赞的动作如下：
- en: '[PRE70]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'Then, within our Share model, we''ll implement the method necessary to check
    whether an action has already been liked by a user or not:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在我们的Share模型中，我们将实现检查用户是否已经点赞某个行为的方法：
- en: '[PRE71]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'Then, we will implement the `like()` method:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将实现`like()`方法：
- en: '[PRE72]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'Finally, we will implement the `unlike()` method:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将实现`unlike()`方法：
- en: '[PRE73]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: Viewing shares
  id: totrans-228
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 查看分享
- en: 'At this point, we can do everything with a share except dive into one and view
    all the replies to a share. Let''s implement the `actionView()` method so that
    our users can view a particular share. In `ShareController`, we''ll implement
    this as follows:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们可以对分享做任何事情，除了深入查看一个分享并查看分享的所有回复。让我们实现`actionView()`方法，以便我们的用户可以查看特定的分享。在`ShareController`中，我们将实现如下：
- en: '[PRE74]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: Then, we will copy `protected/views/share/view.php` from our project resources
    folder into the project. Within our view, we can now share something and click
    on the eye icon on the share in order to view it in more detail.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将从我们的项目资源文件夹中复制 `protected/views/share/view.php` 到项目中。在我们的视图中，我们现在可以分享一些内容并点击分享上的眼睛图标以查看更多详细信息。
- en: Searching for shares
  id: totrans-232
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 搜索分享
- en: 'One of the most important parts of any application is the ability to search
    for and discover new content. For this application, we''ll be implementing a search
    method that will allow users to search for content and users. To do this, we''ll
    check whether the query string in our search method contains the `@` character.
    If it does, we''ll perform a second search for that user and display information
    about that user in our view. We''ll implement that method as follows:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 任何应用程序最重要的部分之一是能够搜索和发现新的内容。对于这个应用程序，我们将实现一个搜索方法，允许用户搜索内容和用户。为此，我们将检查我们的搜索方法中的查询字符串是否包含
    `@` 字符。如果包含，我们将对该用户执行第二次搜索，并在视图中显示该用户的信息。我们将按以下方式实现该方法：
- en: 'We''ll start by implementing `actionSearch()` as follows:'
  id: totrans-234
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将首先实现 `actionSearch()` 如下：
- en: '[PRE75]'
  id: totrans-235
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'We''ll then retrieve the query string from our `$_GET` parameters and define
    the scope for our models:'
  id: totrans-236
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们将从我们的 `$_GET` 参数中检索查询字符串并定义我们模型的作用域：
- en: '[PRE76]'
  id: totrans-237
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'Then, as long as there is a query to run against, we''ll create two `CDbCriteria`
    objects; one for users and the other for shares:'
  id: totrans-238
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，只要存在要运行的查询，我们将创建两个 `CDbCriteria` 对象；一个用于用户，另一个用于分享：
- en: '[PRE77]'
  id: totrans-239
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE77]'
- en: 'Within this `if` bracket, we''ll first check whether there were any mentions
    in our query string, by using `preg_match_all`:'
  id: totrans-240
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这个 `if` 括号内，我们将首先检查查询字符串中是否有任何提及，通过使用 `preg_match_all`：
- en: '[PRE78]'
  id: totrans-241
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE78]'
- en: 'If there are any results, we''ll build a query to find all the users who were
    mentioned in the query, and then, we''ll remove that criteria from our query string:'
  id: totrans-242
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果有任何结果，我们将构建一个查询以找到查询中提到的所有用户，然后，我们将从我们的查询字符串中删除该标准：
- en: '[PRE79]'
  id: totrans-243
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE79]'
- en: 'Then, we''ll perform a `LIKE` query search against the `text` field of our
    Share model:'
  id: totrans-244
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们将对 Share 模型的 `text` 字段执行 `LIKE` 查询：
- en: '[PRE80]'
  id: totrans-245
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE80]'
- en: 'Then, we''ll render our view:'
  id: totrans-246
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们将渲染我们的视图：
- en: '[PRE81]'
  id: totrans-247
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE81]'
- en: Finally, we'll need to copy our view file from `protected/views/timeline/search.php`
    into our project folder.
  id: totrans-248
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们需要将我们的视图文件从 `protected/views/timeline/search.php` 复制到我们的项目文件夹中。
- en: Sharing on Twitter with HybridAuth
  id: totrans-249
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 HybridAuth 在 Twitter 上分享
- en: Since our application doesn't have a large following yet, it's important to
    enable our users to share content that they generate on our site to other places.
    A great way to spread the word about a particular site or service is to take advantage
    of Twitter. One way to integrate with Twitter is by utilizing their OAuth API.
    This will allow us to authenticate as a given user and post content on their behalf,
    at just a click of a button.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们的应用程序还没有大量的追随者，因此允许我们的用户在他们网站上生成的内容分享到其他地方是很重要的。传播特定网站或服务的一个好方法是利用 Twitter。与
    Twitter 集成的一种方法是通过利用他们的 OAuth API。这将允许我们以特定用户身份进行身份验证并在点击按钮时代表他们发布内容。
- en: To do this, we'll be taking advantage of **HybridAuth**. HybridAuth is an open
    source library that allows developers to integrate with multiple third-party social
    networks, and enables developers to make their application more social. For our
    purposes, we're going to utilize HybridAuth to impersonate a given user (with
    their permission, of course) and submit content on their behalf upon their request.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 为了做到这一点，我们将利用 **HybridAuth**。HybridAuth 是一个开源库，允许开发者与多个第三方社交网络集成，并使开发者能够使他们的应用程序更加社交。就我们的目的而言，我们将利用
    HybridAuth 来代表一个特定的用户（当然是在他们的许可下）并在他们请求时代表他们提交内容。
- en: Note
  id: totrans-252
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: If you want to learn more about HybridAuth, check out the official documentation
    at [http://hybridauth.sourceforge.net/](http://hybridauth.sourceforge.net/).
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想了解更多关于 HybridAuth 的信息，请查看官方文档：[http://hybridauth.sourceforge.net/](http://hybridauth.sourceforge.net/)。
- en: Setting up a Twitter application
  id: totrans-254
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设置 Twitter 应用程序
- en: 'Before we start using HybridAuth though, we first need to set up a Twitter
    application and obtain our OAuth credentials. These credentials will allow our
    application to communicate securely with Twitter, and enable us to sign in and
    post as our users. The steps are as follows:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始使用 HybridAuth 之前，我们首先需要设置一个 Twitter 应用程序并获取我们的 OAuth 凭证。这些凭证将允许我们的应用程序安全地与
    Twitter 通信，并使我们能够登录并代表我们的用户进行发布。步骤如下：
- en: Note
  id: totrans-256
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: What is OAuth? OAuth is an open standard for authentication, and provides client
    applications such as the one we are building in this application, secure delegated
    access to server resources on behalf of that owner, in this case, Twitter. By
    using OAuth, we can communicate securely with a server without having to transmit
    our user's credentials to our application. In our application, we'll be using
    HybridAuth to take care of most of the leg work when dealing with Twitter's OAuth
    endpoint. Check out [http://oauth.net/about/](http://oauth.net/about/) for more
    information about what OAuth is and how it works.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 什么是OAuth？OAuth是一个开放标准，用于身份验证，并为客户端应用程序（例如我们在本应用程序中构建的应用程序）提供对服务器资源的安全委托访问，代表该所有者，在这种情况下，是Twitter。通过使用OAuth，我们可以安全地与服务器通信，而无需将我们的用户凭据传输到我们的应用程序。在我们的应用程序中，我们将使用HybridAuth来处理与Twitter
    OAuth端点交互的大部分工作。有关OAuth是什么以及它是如何工作的更多信息，请查看[http://oauth.net/about/](http://oauth.net/about/)。
- en: To begin, open up your web browser, navigate to [https://apps.twitter.com/](https://apps.twitter.com/),
    and sign in using your Twitter credentials.
  id: totrans-258
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，打开您的网络浏览器，导航到[https://apps.twitter.com/](https://apps.twitter.com/)，并使用您的Twitter凭据登录。
- en: Once authenticated, click on the **Create New App** button in the top-right
    corner of the page body.
  id: totrans-259
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦完成认证，点击页面右上角的**创建新应用**按钮。
- en: On this page, fill out the fields as shown in the next screenshot. Adjust the
    website URL and **Callback URL** to match what you are using in your application.
    Note that the endpoint you provide to Twitter must be publicly accessible.![Setting
    up a Twitter application](img/7734OS_05_04.jpg)
  id: totrans-260
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在此页面上，填写下一张截图所示的字段。调整网站URL和**回调URL**以匹配您在应用程序中使用的设置。请注意，您提供给Twitter的端点必须是公开可访问的。![设置Twitter应用](img/7734OS_05_04.jpg)
- en: On the next page, click on the **Settings** tab, check the **Allow this application
    to be used to sign into Twitter** checkbox, and click on the **Update Settings**
    button at the bottom of the page.
  id: totrans-261
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在下一页上，点击**设置**选项卡，勾选**允许此应用程序用于登录Twitter**复选框，然后点击页面底部的**更新设置**按钮。
- en: Then, click on the **Permissions** tab and change the access level to **Read
    and Write** and save the form.
  id: totrans-262
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，点击**权限**选项卡，将访问级别更改为**读取和写入**并保存表单。
- en: Configuring HybridAuth
  id: totrans-263
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 配置HybridAuth
- en: 'With our Twitter application configured, we now need to install and configure
    HybridAuth. Fortunately, HybridAuth is available as a Composer dependency, so
    we can include its source code into our project by adding the following to the
    require section of our `composer.json` file:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 配置好我们的Twitter应用程序后，我们现在需要安装和配置HybridAuth。幸运的是，HybridAuth可以作为Composer依赖项使用，因此我们可以通过将以下内容添加到`composer.json`文件的require部分来将它的源代码包含到我们的项目中：
- en: '[PRE82]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: 'The next steps are as follows:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步如下：
- en: 'Run the `composer update` command from your command line:'
  id: totrans-267
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从您的命令行运行`composer update`命令：
- en: '[PRE83]'
  id: totrans-268
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE83]'
- en: 'You should see something similar to the following output:'
  id: totrans-269
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您应该看到以下类似的输出：
- en: '[PRE84]'
  id: totrans-270
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE84]'
- en: 'Next, we''ll configure HybridAuth so that it knows what information to use.
    Open up `protected/config/params.php`, and add the following after our SendGrid
    information:'
  id: totrans-271
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将配置HybridAuth，使其知道使用哪些信息。打开`protected/config/params.php`，并在我们的SendGrid信息之后添加以下内容：
- en: '[PRE85]'
  id: totrans-272
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE85]'
- en: 'Then, retrieve your Twitter API key and Twitter Secret key from the **API Keys**
    tab of our Twitter application, as shown in the next screenshot, and replace `<twitter_key>`
    and `<twitter_secret>` with them in your configuration file:'
  id: totrans-273
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，从我们的Twitter应用程序的**API密钥**选项卡中检索您的Twitter API密钥和Twitter密钥，如下一张截图所示，并在您的配置文件中将`<twitter_key>`和`<twitter_secret>`替换为它们：
- en: Note
  id: totrans-274
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Your Twitter OAuth Key and Secret are confidential pieces of information and
    should be kept out of your DCVS provider. If you ever suspect that your OAuth
    credentials have been compromised, you should immediately regenerate your API
    keys. This will prevent potential attacks from gaining the ability to sign on
    and tweet as your users.
  id: totrans-275
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 您的Twitter OAuth密钥和密钥是机密信息，应将其从您的DCVS提供者中移除。如果您怀疑您的OAuth凭据已被泄露，应立即重新生成您的API密钥。这将防止潜在的攻击者获得登录和代表您的用户发推的能力。
- en: '![Configuring HybridAuth](img/7734OS_05_05.jpg)'
  id: totrans-276
  prefs: []
  type: TYPE_IMG
  zh: '![配置HybridAuth](img/7734OS_05_05.jpg)'
- en: Note
  id: totrans-277
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: HybridAuth can be configured with several different options. Be sure to look
    at a few of the examples if you're interested in implementing social sharing for
    other providers at [http://hybridauth.sourceforge.net/userguide/Configuration.html](http://hybridauth.sourceforge.net/userguide/Configuration.html).
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: HybridAuth可以使用几个不同的选项进行配置。如果您对在[http://hybridauth.sourceforge.net/userguide/Configuration.html](http://hybridauth.sourceforge.net/userguide/Configuration.html)实现其他提供者的社交分享感兴趣，请务必查看一些示例。
- en: Implementing HybridAuth social sign-on and sharing
  id: totrans-279
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现HybridAuth社交登录和分享
- en: 'Now that our application has Twitter''s OAuth credentials, we can implement
    the social sign-on and sharing features:'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们应用程序已经有了Twitter的OAuth凭证，我们可以实现社交登录和分享功能：
- en: 'Begin by adjusting our `accessRules()` method to only allow authenticated users
    to share content on Twitter:'
  id: totrans-281
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，调整我们的`accessRules()`方法，仅允许经过身份验证的用户在Twitter上分享内容：
- en: '[PRE86]'
  id: totrans-282
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE86]'
- en: 'Then, implement the `actionHybrid()` method:'
  id: totrans-283
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，实现`actionHybrid()`方法：
- en: '[PRE87]'
  id: totrans-284
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE87]'
- en: 'We''ll start this action by looking for some specific HybridAuth `$_GET` parameters,
    and calling `Hybrid_Endpoint::process()` if either of the two are detected:'
  id: totrans-285
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将首先查找一些特定的HybridAuth `$_GET`参数，并在检测到这两个参数中的任何一个时调用`Hybrid_Endpoint::process()`：
- en: '[PRE88]'
  id: totrans-286
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE88]'
- en: 'We''ll then wrap the next section in a `try`/`catch` block to catch any errors
    that HybridAuth may throw if it encounters an error:'
  id: totrans-287
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们将下一部分包裹在一个`try`/`catch`块中，以捕获HybridAuth在遇到错误时可能抛出的任何错误：
- en: '[PRE89]'
  id: totrans-288
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE89]'
- en: 'Within our `try`/`catch` block, we''ll then load our configuration we set in
    our `params.php` file, and set the base URL for HybridAuth to use internally within
    our application. This base URL should correspond to the location from where HybridAuth
    will be called:'
  id: totrans-289
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在我们的`try`/`catch`块中，我们将加载我们在`params.php`文件中设置的配置，并设置HybridAuth在我们应用程序内部使用的基URL。这个基URL应该对应于HybridAuth将被调用的位置：
- en: '[PRE90]'
  id: totrans-290
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE90]'
- en: 'We''ll initialize HybridAuth with our configuration:'
  id: totrans-291
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将使用我们的配置初始化HybridAuth：
- en: '[PRE91]'
  id: totrans-292
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE91]'
- en: 'Then, we''ll create a HybridAuth adapter for us to talk to Twitter:'
  id: totrans-293
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们将创建一个HybridAuth适配器，以便我们与Twitter进行通信：
- en: '[PRE92]'
  id: totrans-294
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE92]'
- en: 'Next, we should check whether the `adapter` is connected to Twitter:'
  id: totrans-295
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们应该检查`adapter`是否已连接到Twitter：
- en: '[PRE93]'
  id: totrans-296
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE93]'
- en: 'Within this `if` block, we should load the share we want to share on Twitter:'
  id: totrans-297
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这个`if`块中，我们应该加载我们想要在Twitter上分享的分享内容：
- en: '[PRE94]'
  id: totrans-298
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE94]'
- en: 'Then, share our content on Twitter:'
  id: totrans-299
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，在Twitter上分享我们的内容：
- en: '[PRE95]'
  id: totrans-300
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE95]'
- en: 'Now, if you share something on our site, then click on the Twitter icon for
    that share; you''ll be redirected to Twitter to sign in, as shown in the following
    screenshot:'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果您在我们的网站上分享某些内容，然后点击该分享的Twitter图标；您将被重定向到Twitter进行登录，如下面的截图所示：
- en: '![Implementing HybridAuth social sign-on and sharing](img/7734OS_05_06.jpg)'
  id: totrans-302
  prefs: []
  type: TYPE_IMG
  zh: '![实现HybridAuth社交登录和分享](img/7734OS_05_06.jpg)'
- en: 'After signing in, you''ll need to authorize our application to update our Twitter
    profile, as shown in the following screenshot:'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 登录后，您需要授权我们的应用程序更新我们的Twitter个人资料，如下面的截图所示：
- en: '![Implementing HybridAuth social sign-on and sharing](img/7734OS_05_07.jpg)'
  id: totrans-304
  prefs: []
  type: TYPE_IMG
  zh: '![实现HybridAuth社交登录和分享](img/7734OS_05_07.jpg)'
- en: Then, our content will be shared on Twitter on our behalf, as shown in the next
    screenshot. Moreover, if we click on the Twitter button again within our application,
    our content will be automatically shared on Twitter for us, without us having
    to reauthenticate against Twitter.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们的内容将代表我们在Twitter上分享，如下一个截图所示。此外，如果我们再次在我们的应用程序中点击Twitter按钮，我们的内容将自动为我们分享到Twitter，而无需我们再次对Twitter进行身份验证。
- en: '![Implementing HybridAuth social sign-on and sharing](img/7734OS_05_08.jpg)'
  id: totrans-306
  prefs: []
  type: TYPE_IMG
  zh: '![实现HybridAuth社交登录和分享](img/7734OS_05_08.jpg)'
- en: Summary
  id: totrans-307
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: Wow, we covered quite a bit in this chapter! We expanded upon our user authentication
    and management to include secure activation and password resets if a user forgets
    their password, and enabled our users to securely and safely change both their
    own e-mail address and password with proper verification and notifications. Moreover,
    we implemented all of these actions using `CFormModel`, which enabled us to cleanly
    isolate the logic for handling these actions in forms rather than in our controllers.
    Finally, we implemented an asynchronous `CListViews` and utilized HybridAuth to
    share on Twitter using our OAuth credentials.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 哇，我们在本章中涵盖了相当多的内容！我们扩展了用户身份验证和管理，包括如果用户忘记密码时的安全激活和密码重置，并允许我们的用户通过适当的验证和通知安全地更改他们的电子邮件地址和密码。此外，我们使用`CFormModel`实现了所有这些操作，这使得我们能够干净地将处理这些操作的逻辑隔离在表单中而不是控制器中。最后，我们实现了异步的`CListViews`，并利用HybridAuth使用我们的OAuth凭证在Twitter上分享。
- en: The user components that we developed in this chapter can easily be used and
    adapted for almost any application that will require user authentication and management.
    In the next chapter, we'll be utilizing these components to build a full-scale
    content management system that will allow us to upload content and photos and
    also allow us to share this content with others. The CMS that we'll be building
    will also be SEO-optimized and will include dynamic content slugs and a sitemap
    feature that can be submitted to the search engines. Before proceeding to the
    next chapter, be sure to review the Yii Class Reference at [http://www.yiiframework.com/doc/api/](http://www.yiiframework.com/doc/api/)
    and review all the classes that we used in this chapter. Then, when you're ready,
    head over to the next chapter where you'll build a CMS!
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中我们开发的用户组件可以轻松用于和适应几乎任何需要用户认证和管理的应用。在下一章中，我们将利用这些组件构建一个全规模的内容管理系统，这将使我们能够上传内容和照片，并允许我们与他人共享这些内容。我们将构建的CMS也将是SEO优化的，并包括可以提交给搜索引擎的动态内容别名和网站地图功能。在进入下一章之前，请务必查阅[http://www.yiiframework.com/doc/api/](http://www.yiiframework.com/doc/api/)上的Yii类参考，并回顾本章中我们使用的所有类。然后，当你准备好时，前往下一章，在那里你将构建一个CMS！
