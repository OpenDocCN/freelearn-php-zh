<html><head></head><body><div class="chapter" title="Chapter&#xA0;5.&#xA0;Releasing to the World: PEAR Channels"><div class="titlepage"><div><div><h1 class="title"><a id="ch05"/>Chapter 5. Releasing to the World: PEAR Channels</h1></div></div></div><p>One of the premier features of PEAR version 1.4.0 and newer versions is the ability to publicly distribute your own applications for installation with the PEAR installer. Although this was feasible with PEAR 1.3.6 and earlier versions, it was far more difficult, and so was rarely attempted. PEAR version 1.4.0+ adds ease to distributing packages by the use of a new distribution medium called<span class="strong"><strong> channels</strong></span>. Each PEAR channel provides a unique set of packages that can be installed quite easily using the PEAR installer. For instance, to install a package from the<code class="literal"> pear.chiaraquartet.net</code> channel, one need only type:<a id="id273" class="indexterm"/>
</p><div class="informalexample"><pre class="programlisting"><span class="strong"><strong>$ pear channel-discover pear.chiaraquartet.net
$ pear install chiara/Chiara_PEAR_Server
</strong></span>
</pre></div><p>In the past, this was simply not possible. A non-intuitive set of keystrokes would be needed to install a package from<code class="literal"> pear.chiaraquartet.net:</code>
</p><div class="informalexample"><pre class="programlisting"><span class="strong"><strong>$ pear config-set master_server pear.chiaraquartet.net
$ pear install Chiara_PEAR_Server
$ pear config-set master_server pear.php.net
</strong></span>
</pre></div><p>The complexity is confounded by cross-channel dependencies. The<code class="literal"> pear.chiaraquartet.net/Chiara_PEAR_Server</code> package depends on<code class="literal"> pear.php.net/HTML_QuickForm</code>, and so the sequence would in fact need to be:<a id="id274" class="indexterm"/>
</p><div class="informalexample"><pre class="programlisting"><span class="strong"><strong>$ pear install HTML_QuickForm
$ pear config-set master_server pear.chiaraquartet.net
$ pear install Chiara_PEAR_Server
$ pear config-set master_server pear.php.net
</strong></span>
</pre></div><p>The same process would need to be repeated upon upgrading, introducing both painful memory requirements ("Where did I get this Chiara_PEAR_Server from again?") and the chance for error. What if<code class="literal"> pear.chiaraquartet.net</code> happened to provide a package named<code class="literal"> LogXML</code> and<code class="literal"> pear.php.net</code> introduced one? If you were to accidentally type:<a id="id275" class="indexterm"/>
</p><div class="informalexample"><pre class="programlisting"><span class="strong"><strong>$ pear upgrade LogXML
</strong></span>
</pre></div><p>Without the necessary:</p><div class="informalexample"><pre class="programlisting"><span class="strong"><strong>$ pear config-set master_server pear.chiaraquartet.net
$ pear upgrade LogXML
$ pear config-set master_server pear.php.net
</strong></span>
</pre></div><p>You could unknowingly upgrade to the wrong package! Channels remove all of these troubles, and do so with rigorous security.<a id="id276" class="indexterm"/>
</p><p>So how do you set up your own channel? This chapter will investigate the steps needed to install Chiara_PEAR_Server, and the structure of a channel definition file used to document your channel's unique features.</p><p>In addition, we will learn how to distribute customized PEAR applications per-user, even for pay-for-use applications. We'll discover the<span class="strong"><strong> Crtx_PEAR_Channel_Frontend</strong></span> package used to provide a public front door for users browsing the web, and finally, we will talk about security issues.</p><div class="section" title="Distributing a package.xml-Based Package"><div class="titlepage"><div><div><h1 class="title"><a id="ch05lvl1sec01"/>Distributing a package.xml-Based Package</h1></div></div></div><p>There are two ways of distributing packages (either of which can be used):<a id="id277" class="indexterm"/>
</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Channel server</li><li class="listitem" style="list-style-type: disc">Static tarball</li></ul></div><p>You will learn about both approaches in this section.</p><p>Before the release of PEAR 1.4.0, the user typed:<a id="id278" class="indexterm"/>
</p><div class="informalexample"><pre class="programlisting"><span class="strong"><strong>$ pear remote-list
</strong></span>
</pre></div><p>The PEAR installer would then use XML-RPC to send a request for the<code class="literal"> package.listAll</code> method to  <a class="ulink" href="http://pear.php.net/xmlrpc.php">http://pear.php.net/xmlrpc.php</a>. Meanwhile, at<code class="literal"> pear.php.net</code>, the database of all packages, releases, and dependencies would be queried for data (or a server-side cache accessed), and then it would be dynamically encoded into an XML-RPC response, decoded at the user end, and converted into a PHP array containing a list of all packages and their releases. This would then be formatted into a pretty list of package names and spewed out on to the screen.<a id="id279" class="indexterm"/>
</p><div class="note" title="Note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="tip37"/>Tip</h3><p>
<span class="strong"><strong>XML-RPC</strong></span> stands for<span class="strong"><strong> XML Remote Procedure Call</strong></span>, and is a protocol that allows a program to call a function on a remote server as if it were implemented on the local machine.</p><p>
<span class="strong"><strong>SOAP</strong></span> (until recently it was <span class="strong"><strong> Simple Object Access Protocol</strong></span>, but now just "SOAP", because the developers realized there was nothing simple about it and it was a confusing name as well) is a more complex implementation of the same idea.</p></div><p>From the end user's perspective, there are two ways of installing a remote package using the PEAR installer. The first way is to install an abstraction, as in:<a id="id280" class="indexterm"/>
</p><div class="informalexample"><pre class="programlisting"><span class="strong"><strong>$ pear install PEAR
$ pear install PEAR-stable
$ pear install PEAR-1.4.3
$ pear install channel://pear/PEAR
$ pear install channel://pear.php.net/PEAR-1.4.3
</strong></span>
</pre></div><p>Each of these examples takes the information passed in by the user and converts it into an actual, existing URL for retrieving a file from the channel server (<code class="literal">pear.php.net</code> in this case), and then downloads that package for installation. In fact, at the time of writing this chapter, each of these examples essentially converts into this:</p><div class="informalexample"><pre class="programlisting"><span class="strong"><strong>$ pear install http://pear.php.net/get/PEAR-1.4.3.tgz
</strong></span>
</pre></div><p>The second way of installing a package is to directly specify a URL to install, as above.</p><p>These two approaches appear to be the same to the end user. However, behind the scenes they differ significantly. When downloading and installing a package via an abstract package like<code class="literal"> PEAR</code> or<code class="literal"> PEAR-stable</code>, it is possible to validate all dependencies prior to downloading a single file, saving considerable time in the slowest part of installation — downloading. When installing a static URL ( <a class="ulink" href="http://pear.php.net/get/PEAR-1.4.3.tgz">http://pear.php.net/get/PEAR-1.4.3.tgz</a>), it is necessary to download the entire package before any dependency validation can occur, possibly resulting in wasted bandwidth.<a id="id281" class="indexterm"/>
</p><p>In order to convert abstract-package requests into actual physical URLs, a small amount of information is retrieved from the remote channel server. This information is used to validate dependencies prior to downloading a full package, and also to determine the correct version of a package to be downloaded based on the user's requirements.<a id="id282" class="indexterm"/>
</p><p>For example, the following call first retrieves a list of all releases of PEAR organized by version number and stability:</p><div class="informalexample"><pre class="programlisting"><span class="strong"><strong>$ pear upgrade PEAR-stable
</strong></span>
</pre></div><p>Assume the server returns a list like this:<a id="id283" class="indexterm"/>
</p><div class="informaltable"><table border="1"><colgroup><col style="text-align: left"/><col style="text-align: left"/></colgroup><thead><tr><th style="text-align: left" valign="bottom">
<p>Version</p>
</th><th style="text-align: left" valign="bottom">
<p>Stability</p>
</th></tr></thead><tbody><tr><td style="text-align: left" valign="top">
<p>1.5.0a1</p>
</td><td style="text-align: left" valign="top">
<p>alpha</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>1.4.3</p>
</td><td style="text-align: left" valign="top">
<p>stable</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>1.4.2</p>
</td><td style="text-align: left" valign="top">
<p>stable</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>1.4.1</p>
</td><td style="text-align: left" valign="top">
<p>stable</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>1.4.0</p>
</td><td style="text-align: left" valign="top">
<p>stable</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>1.4.0RC1</p>
</td><td style="text-align: left" valign="top">
<p>beta</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>1.4.0a14</p>
</td><td style="text-align: left" valign="top">
<p>alpha</p>
</td></tr></tbody></table></div><p>The PEAR installer will examine version 1.5.0a1, the newest version available, and will determine it is not stable enough to install. Next, it will examine version 1.4.3 and (assuming the installed version is 1.4.2 or older) determine that this is the version that should be downloaded. Next, it will query the server and retrieve the list of dependencies for version 1.4.3, which is something like this:<a id="id284" class="indexterm"/>
</p><div class="informaltable"><table border="1"><colgroup><col style="text-align: left"/><col style="text-align: left"/><col style="text-align: left"/></colgroup><thead><tr><th style="text-align: left" valign="bottom">
<p>Dependency type</p>
</th><th style="text-align: left" valign="bottom">
<p>Dependency name (if any)</p>
</th><th style="text-align: left" valign="bottom">
<p>Dependency version requirements</p>
</th></tr></thead><tbody><tr><td style="text-align: left" valign="top">
<p>PHP</p>
</td><td style="text-align: left" valign="top"> </td><td style="text-align: left" valign="top">
<p>4.2.0 or newer</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>PEAR installer</p>
</td><td style="text-align: left" valign="top"> </td><td style="text-align: left" valign="top">
<p>1.3.3 1.3.6, 1.4.0a12 or newer</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>Package</p>
</td><td style="text-align: left" valign="top">
<p>Archive_Tar</p>
</td><td style="text-align: left" valign="top">
<p>1.3.1 or newer (1.3.1 recommended)</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>Package</p>
</td><td style="text-align: left" valign="top">
<p>Console_Getopt</p>
</td><td style="text-align: left" valign="top">
<p>1.2 or newer (1.2 recommended)</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>Package</p>
</td><td style="text-align: left" valign="top">
<p>XML_RPC</p>
</td><td style="text-align: left" valign="top">
<p>1.4.3 or newer (1.4.3 recommended)</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>Conflicting package</p>
</td><td style="text-align: left" valign="top">
<p>PEAR_Frontend_Web</p>
</td><td style="text-align: left" valign="top">
<p>0.4 or older</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>Conflicting package</p>
</td><td style="text-align: left" valign="top">
<p>PEAR_Frontend_Gtk</p>
</td><td style="text-align: left" valign="top">
<p>0.3 or older</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>Remote installer group</p>
</td><td style="text-align: left" valign="top">
<p>PEAR_RemoteInstaller</p>
</td><td style="text-align: left" valign="top">
<p>0.1.0 or newer</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>Web installer group</p>
</td><td style="text-align: left" valign="top">
<p>PEAR_Frontend_Web</p>
</td><td style="text-align: left" valign="top">
<p>0.5.0 or newer</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>Gtk installer group</p>
</td><td style="text-align: left" valign="top">
<p>PEAR_Frontend_Gtk</p>
</td><td style="text-align: left" valign="top">
<p>0.4.0 or newer</p>
</td></tr></tbody></table></div><p>Before downloading PEAR 1.4.3 to install it, the PEAR installer will use this information to determine whether the package is compatible with existing installed packages, and the running version of PHP and the PEAR installer. Only if all checks pass, will the PEAR installer continue with the downloading/installation.<a id="id285" class="indexterm"/>
</p><p>In addition, because PEAR 1.4.3 has a<code class="literal"> package.xml</code> version 2.0, when upgrading from PEAR 1.4.0 or newer, the list of required dependencies will also be automatically downloaded and installed.</p><p>How, you might be asking yourself, can I distribute my applications and libraries to take advantage of the power and elegance built into the PEAR installer? The answer turns out to be quite simple, as evidenced by the small explosion of channel servers since the release of PEAR version 1.4.0, like eZ components (http://www.ez.no), and the popular pearified channel ( <a class="ulink" href="http://www.pearified.com">http://www.pearified.com</a>). The<span class="strong"><strong> Chiara_PEAR_Server</strong></span> package is a fully functional PEAR channel server available for installation from the<code class="literal"> pear.chiaraquartet.net</code> channel server.<a id="id286" class="indexterm"/>
</p><div class="note" title="Note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="tip38"/>Tip</h3><p>Originally, Chiara_PEAR_Server was named PEAR_Server. The intention was to propose a package named "PEAR_Server" or "PEAR_Channel_Server" to the<code class="literal"> pear.php.net</code> repository when the code is stable enough. Until that point, however, there are potential naming conflicts (PEAR is generally reserved for packages that originate from<code class="literal"> pear.php.net)</code>, and the package will be named Chiara_PEAR_Server as long as it is distributed from<code class="literal"> pear.chiaraquartet.net</code>
</p></div><p>Once you have Chiara_PEAR_Server up and running (prerequisites include a working PEAR installation and a MySQL server, plus PHP 5.0.0 or newer with the mysql or mysqli extensions), you might also consider installing Davey Shafik's public front end,<span class="strong"><strong> Crtx_Channel_PEAR_Server_Frontend</strong></span>, available from the<code class="literal"> crtx.org</code> channel. This is discussed later on in this chapter, in the section entitled<span class="emphasis"><em> Configuring the Server; Obtaining a Front End for End Users</em></span>.</p></div></div>
<div class="section" title="Distributing Packages through a Channel Server"><div class="titlepage"><div><div><h1 class="title"><a id="ch05lvl1sec02"/>Distributing Packages through a Channel Server</h1></div></div></div><p>When distributing packages through a channel server, there are a few things that the PEAR installer needs in order to determine which packages to install. Most important is how to communicate with the channel server. Does the server expect an incoming XML-RPC request, or is REST supported? Which XML-RPC functions are implemented, and which REST information is provided? Are there any mirrors available? What, if any, are the custom-package validation requirements?<a id="id287" class="indexterm"/>
</p><p>All of these questions are answered by the simple<code class="literal"> channel.xml</code> structure. Before installing Chiara_PEAR_Server, it is important to understand the underpinnings of the package, as it will make it possible to get up and run very quickly.</p><div class="section" title="The channel.xml File"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec01"/>The channel.xml File</h2></div></div></div><p>The first thing a channel needs in order to exist is a<code class="literal"> channel.xml</code> file. The official definition of<code class="literal"> channel.xml</code> in XSchema format is found at  <a class="ulink" href="http://pear.php.net/dtd/channel-1.0.xsd"> http://pear.php.net/dtd/channel-1.0.xsd</a>. The<code class="literal"> channel.xml</code> file<span class="emphasis"><em> must</em></span> be named<code class="literal"> channel.xml</code> and must be located in the root directory of your channel; otherwise the PEAR installer's auto-discovery mechanism will not work. For instance, the channel definition file for<code class="literal"> pear.php.net</code> is located at <a class="ulink" href="http://pear.php.net/channel.xml"> http://pear.php.net/channel.xml</a>, and the channel definition file for<code class="literal"> pear.chiaraquartet.net</code> is located at  <a class="ulink" href="http://pear.chiaraquartet.net/channel.xml"> http://pear.chiaraquartet.net/channel.xml</a>.<a id="id288" class="indexterm"/>
</p><p>This file allows the PEAR installer to quickly and efficiently determine the capabilities offered by a channel server without wasting any bandwidth. A<code class="literal"> channel.xml</code> file must define the channel name (its server hostname and path), a brief summary of the channel's purpose, and then metadata used to retrieve package information for installation purposes. In addition, the<code class="literal"> channel.xml</code> file allows explicit definition of channel mirrors, for the first time making it possible to mirror a channel repository.<a id="id289" class="indexterm"/>
</p><p>Here is an example<code class="literal"> channel.xml</code> file containing every possible tag:<a id="id290" class="indexterm"/>
</p><div class="informalexample"><pre class="programlisting">&lt;?xml version="1.0" encoding="ISO-8859-1"?&gt;
&lt;channel version="1.0" 

xsi:schemaLocation="http://pear.php.net/channel-1.0
http://pear.php.net/dtd/channel-1.0.xsd"&gt;
&lt;name&gt;pear.example.com&lt;/name&gt;
&lt;summary&gt;Example channel&lt;/summary&gt;
&lt;suggestedalias&gt;example&lt;/suggestedalias&gt;
&lt;validatepackage version="1.0"&gt;
Example_Validate_Package&lt;/validatepackage&gt;
&lt;servers&gt;
&lt;primary ssl="yes" port="81"&gt;
&lt;xmlrpc path="myxmlrpc.php"&gt;
&lt;function version="1.0"&gt;logintest&lt;/function&gt;
&lt;function version="1.0"&gt;package.listLatestReleases&lt;/function&gt;
&lt;function version="1.0"&gt;package.listAll&lt;/function&gt;
&lt;function version="1.0"&gt;package.info&lt;/function&gt;
&lt;function version="1.0"&gt;package.getDownloadURL&lt;/function&gt;
&lt;function version="1.1"&gt;package.getDownloadURL&lt;/function&gt;
&lt;function version="1.0"&gt;package.getDepDownloadURL&lt;/function&gt;
&lt;function version="1.1"&gt;package.getDepDownloadURL&lt;/function&gt;
&lt;function version="1.0"&gt;package.search&lt;/function&gt;
&lt;function version="1.0"&gt;channel.listAll&lt;/function&gt;
&lt;/xmlrpc&gt;
&lt;soap path="soap.pl"&gt;
&lt;function version="1.0"&gt;customSoapFunction&lt;/function&gt;
&lt;/soap&gt;
&lt;rest&gt;
&lt;baseurl type="REST1.0"&gt;http://pear.example.com/rest/&lt;/baseurl&gt;
&lt;baseurl type="REST1.1"&gt;http://pear.example.com/rest/&lt;/baseurl&gt;
&lt;/rest&gt;
&lt;/primary&gt;
&lt;mirror host="poor.example.com" port="80" ssl="no"&gt;
&lt;xmlrpc&gt;
&lt;function version="1.0"&gt;logintest&lt;/function&gt;
&lt;function version="1.0"&gt;package.listLatestReleases&lt;/function&gt;
&lt;function version="1.0"&gt;package.listAll&lt;/function&gt;
&lt;function version="1.0"&gt;package.info&lt;/function&gt;
&lt;function version="1.0"&gt;package.getDownloadURL&lt;/function&gt;
&lt;function version="1.1"&gt;package.getDownloadURL&lt;/function&gt;
&lt;function version="1.0"&gt;package.getDepDownloadURL&lt;/function&gt;
&lt;function version="1.1"&gt;package.getDepDownloadURL&lt;/function&gt;
&lt;function version="1.0"&gt;package.search&lt;/function&gt;
&lt;function version="1.0"&gt;channel.listAll&lt;/function&gt;
&lt;/xmlrpc&gt;
&lt;soap path="soap.php"&gt;
&lt;function version="1.0"&gt;customSoapFunction&lt;/function&gt;
&lt;/soap&gt;
&lt;rest&gt;
&lt;baseurl type="REST1.0"&gt;http://poor.example.com/rest/&lt;/baseurl&gt;
&lt;baseurl type="REST1.1"&gt;http://poor.example.com/rest/&lt;/baseurl&gt;
&lt;/rest&gt;
&lt;/mirror&gt;
&lt;/servers&gt;
&lt;/channel&gt;
<a id="id291" class="indexterm"/>
</pre></div><p>A quick glance over the<code class="literal"> channel.xml</code> file reveals a large amount of information contained in a very simple format. With this file, we tell the PEAR installer whether to use a secure connection or not, how to access the package metadata (with XML-RPC, SOAP, or REST), and how the user can access/use the channel (suggested alias, validation package).</p><div class="note" title="Note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="tip39"/>Tip</h3><p><span class="strong"><strong>Does PEAR Installer Support SOAP?</strong></span></p><p>No. Sorry to burst your bubble, but SOAP is not necessary for the relatively simple remote communication needed by the PEAR installer; so no, SOAP is not implemented. However, should the need arise in the future, or should a channel wish to advertise custom SOAP methods implemented, the<code class="literal"> channel.xml</code> spec supports SOAP.</p><p>However, this should only be used to inform the client that a<span class="strong"><strong> WSDL</strong></span> (<span class="strong"><strong>Web Services Description Language</strong></span>) file is present, as this format is much richer than<code class="literal"> channel.xml</code>.</p></div><p>A channel may be located at a hostname's root directory (<span class="strong"><strong>pear.example.com</strong></span>), or at a subdirectory (pear.example.com/subdirectory). Note that<code class="literal"> pear.example.com</code> is a different channel from<code class="literal"> pear.example.com/subdirectory</code>. Users would install packages from the<code class="literal"> pear.example.com/subdirectory</code> channel as follows:<a id="id292" class="indexterm"/>
</p><div class="informalexample"><pre class="programlisting"><span class="strong"><strong>$ pear install pear.example.com/subdirectory/Packagename
</strong></span>
</pre></div><p>Other packages would depend on packages from the<code class="literal"> pear.example.com/subdirectory</code> channel with a<code class="literal"> package.xml</code> tag like this:</p><div class="informalexample"><pre class="programlisting">&lt;dependencies&gt;
&lt;required&gt;
...
&lt;package&gt;
&lt;name&gt;Packagename&lt;/name&gt;
&lt;channel&gt;pear.example.com/subdirectory&lt;/channel&gt;
&lt;/package&gt;
&lt;/required&gt;
&lt;/dependencies&gt;
</pre></div></div><div class="section" title="channel.xml Tag Summary"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec02"/>channel.xml Tag Summary</h2></div></div></div><p>A channel's<code class="literal">&lt;summary&gt;</code> should be a one-line description of the channel, such as "The PHP Extension and Application Repository".<a id="id293" class="indexterm"/>
</p><p>The<code class="literal">&lt;suggestedalias&gt;</code> of a channel is the short name that a user can use on the command line.</p><p>For instance, the<code class="literal"> pear.php.net</code> channel's suggested alias is<code class="literal"> pear</code>, the<code class="literal"> pecl.php.net</code> channel's suggested alias is<code class="literal"> pecl</code>, and the<code class="literal"> pear.chiaraquartet.net</code> channel's suggested alias is<code class="literal"> chiara</code>. These aliases can be used to install packages quickly, such as:</p><div class="informalexample"><pre class="programlisting"><span class="strong"><strong>$ pear install pear/DB
$ pear install chiara/Chiara_PEAR_Server
</strong></span>
</pre></div><p>The alias is a suggested alias because the end user has the option to redefine the alias via the<code class="literal"> channel-alias</code> command:</p><div class="informalexample"><pre class="programlisting"><span class="strong"><strong>$ pear channel-alias pear.chiaraquartet.net c
</strong></span>
</pre></div><p>This would allow the quick installation of packages with:</p><div class="informalexample"><pre class="programlisting"><span class="strong"><strong>$ pear install c/Chiara_PEAR_Server
</strong></span>
</pre></div><div class="note" title="Note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="tip40"/>Tip</h3><p>You cannot use a channel's suggested alias in the dependencies section of a<code class="literal"> package.xml</code> file. You must use the full name of channel.</p></div><p>A channel's validation package (controlled by the<code class="literal">&lt;validatepackage&gt;</code> tag) is used by the installer to perform customized validation specific to the channel. The default validation (found in the<code class="literal"> PEAR/Validate.php</code> file of the PEAR package) is quite strict in terms of versioning and package naming, and attempts to implement coding standards that are specific to<code class="literal"> pear.php.net-based</code> packages. These rules are stricter than the rules implemented by the<code class="literal"> pecl.php.net</code> channel, and so<code class="literal"> pecl.php.net</code> packages are validated using the custom channel validator found in the<code class="literal"> PEAR/Validate/PECL.php</code> file of the PEAR package.<a id="id294" class="indexterm"/>
</p><p>Most channels external to<code class="literal"> pear.php.net</code> will want to copy the<code class="literal"> channel.xml</code> file for the<code class="literal"> pecl.php.net</code> channel, and use the<code class="literal"> PEAR_Validate_PECL</code> validation package.</p><p>A custom channel validator must provide a class that matches the path (PEAR/Validate/PECL.php provides the<code class="literal"> PEAR_Validate_PECL</code> class), and the package name must be identical to the class name. In addition, the class must extend<code class="literal"> PEAR_Validate</code>, and implement validation with the<code class="literal"> validate*()</code> methods (such as<code class="literal"> validateVersion(), validatePackage(), validateSummary()</code>, and so on). In addition, the class<span class="emphasis"><em> must</em></span> be a package distributed from the channel itself, unless the class is already loaded in memory.<a id="id295" class="indexterm"/>
</p><div class="note" title="Note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="tip41"/>Tip</h3><p>The default validation class<code class="literal"> PEAR_Validate</code> and the PECL validation class<code class="literal"> PEAR_Validate_PECL</code> will always be available for use by channels as custom validation packages.</p><p>To use the<code class="literal"> PEAR_Validate_PECL</code> class, simply add this line to<code class="literal"> channel.xml:</code>
</p><p>
<code class="literal">&lt;validatepackage version="1.0"&gt; PEAR_Validate_PECL&lt;/validatepackage&gt;</code>
</p></div><p>The most important part of the<code class="literal"> channel.xml</code> channel definition file is the<code class="literal">&lt;servers&gt;</code> tag. This is where the PEAR installer determines how to connect to a channel (via REST or XML-RPC) and whether any mirrors are available.</p><p>The protocols supported by the primary channel server (which must be the same as the channel name) are defined in the<code class="literal">&lt;primary&gt;</code> tag. Mirrors are (logically) defined by the<code class="literal">&lt;mirror&gt;</code> tag, which is described at the end of this section. The<code class="literal">&lt;primary&gt;</code> tag has a few optional attributes:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>ssl</strong></span> —  legal values are<span class="emphasis"><em> yes</em></span> and<span class="emphasis"><em> no</em></span>. By default,<code class="literal"> ssl</code> is set to<span class="emphasis"><em> no</em></span>. If set to<span class="emphasis"><em> yes</em></span>, then the channel server will be contacted through a secure socket.</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>port</strong></span> —  legal values are any positive integer. By default,<code class="literal"> port</code> is set to<span class="emphasis"><em> 80</em></span>, the default HTTP port for contacting a remote web server. All data from channels are transported via HTTP, and so this is a natural choice.<a id="id296" class="indexterm"/><div class="note" title="Note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="tip42"/>Tip</h3><p>REST, although very new, has several significant advantages over XML-RPC. First of all, REST content (as implemented in the PEAR channel standard) is all static files. This means that a lightweight server like thttpd can be used for high-volume sites to serve the content. In addition, channel aggregators like <a class="ulink" href="http://www.pearified.com"> http://www.pearified.com</a> and <a class="ulink" href="http://www.pearadise.com"> http://www.pearadise.com</a> can crawl through your channel and provide a searchable index of the packages.</p><p>Mirroring of REST-based channels is straightforward because of the same design principles, and can be done with a simple web crawler script.</p><p>In addition, as of PEAR 1.4.3, XML-RPC support is optional in the PEAR installer, so not all users will support XML-RPC on the client-side.</p></div></li></ul></div><p>There are only a few protocols recognized by the PEAR Installer. For XML-RPC, the functions recognized are:<a id="id297" class="indexterm"/>
</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">logintest(1.0)</code> : This simply returns true</li><li class="listitem" style="list-style-type: disc"><code class="literal">package.listLatestReleases(1.0)</code> : This returns an array indexed by package name containing the file size, version, state, and dependencies of its latest release, if any.</li><li class="listitem" style="list-style-type: disc"><code class="literal">package.listAll(1.0)</code> : This returns an array of packages with extreme details about their releases.</li><li class="listitem" style="list-style-type: disc"><code class="literal">package.info(1.0)</code> : This returns an array of detailed information about a single package.</li><li class="listitem" style="list-style-type: disc"><code class="literal">package.getDownloadURL(1.0)</code> : This returns an array with simple information about a release and a precise URL from which to download a specific release.</li><li class="listitem" style="list-style-type: disc"><code class="literal">package.getDownloadURL(1.1)</code> : Like version 1.0, this returns an array with simple information about a release and a precise URL. In addition, this accepts as a parameter the currently installed version of a package to narrow down the search.</li><li class="listitem" style="list-style-type: disc"><code class="literal">package.getDepDownloadURL(1.0)</code> : Like<code class="literal"> package.getDownloadURL</code>, this returns information about a release and a precise URL to download the release from. However, as input, it accepts a dependency as parsed from<code class="literal"> package.xml</code>.</li><li class="listitem" style="list-style-type: disc"><code class="literal">package.getDepDownloadURL (1.1)</code>: Like<code class="literal"> package.getDepDownloadURL</code>, this returns information about a release and a precise URL to download the release from. It also accepts the currently installed version of the dependency as a parameter.</li><li class="listitem" style="list-style-type: disc"><code class="literal">package.search(1.0)</code>: Like<code class="literal"> package.listAll</code>, this returns a list of packages with detailed information. However, this function limits the search of information based on input parameters.</li><li class="listitem" style="list-style-type: disc"><code class="literal">channel.listAll(1.0)</code>: This function returns a simple list of channels known by the current channel.<a id="id298" class="indexterm"/></li></ul></div><p>This detail is provided for informational purposes only, as XML-RPC support is deprecated for all channels.</p><p>Instead, your channel should support REST-based static files conveying information about the categories, maintainers, packages, and releases available through the channel. There are two protocols supported by the PEAR installer at the time of writing this chapter. The first is collectively known as<span class="strong"><strong> REST1.0</strong></span>, and is defined by a set of path-related assumptions the installer makes and several XSchema files.<a id="id299" class="indexterm"/>
</p><p>Inside<code class="literal"> channel.xml</code>, REST is declared using a<code class="literal">&lt;baseurl&gt;</code> tag much like this one:</p><div class="informalexample"><pre class="programlisting">&lt;baseurl type="REST1.0"&gt;http://pear.php.net/rest/&lt;/baseurl&gt;
</pre></div><p>This is in fact all that the installer needs in order to fully implement REST. From this information, the installer is able to build any necessary query to determine remote information. Astute readers may have noticed a familiar word from their work with databases  —  query  —  querying is exactly what the PEAR installer does; accessing data directly rather than through an API wrapper like SOAP or XML-RPC. Unlike the procedural protocol used by XML-RPC and by RPC-based SOAP, REST is based on the principle of providing hyperlinked data, or resources, with a unique URL for each resource.</p><p>PEAR is an unusual REST interface in that it is strictly read-only, but this is an even better reason to use REST. Not only can the installer grab any data it wants without relying upon an intrinsically limited API, we can also take advantage of some of the more powerful features of the HTTP protocol itself, and implement a client-side HTTP cache, saving a tremendous amount of bandwidth and time that would otherwise be spent downloading redundant information.</p><p>This also provides an inherent security benefit to both the client and the server. The client is simply working with static XML files, and the server is not required to accept any input from the client whatsoever. In short, REST is simply the best choice from all ends.</p><p>The path structure expected by the PEAR installer when accessing REST1.0 is the following one:<a id="id300" class="indexterm"/>
</p><div class="informalexample"><pre class="programlisting">c/ <span class="strong"><strong>[Categories]
</strong></span>
CategoryName1/
info.xml <span class="strong"><strong>[information on the "CategoryName1" category]
</strong></span>
packages.xml <span class="strong"><strong>[list of packages in the CategoryName1 category]
</strong></span>
CategoryName2/
info.xml <span class="strong"><strong>[information on the "CategoryName2" category]
</strong></span>
packages.xml <span class="strong"><strong>[list of packages in the CategoryName2 category]
</strong></span>
m/ <span class="strong"><strong>[Maintainers]
</strong></span>
joe/
info.xml <span class="strong"><strong>[information about maintainer "joe"]
</strong></span>
frank/
info.xml <span class="strong"><strong>[information about maintainer "frank"]
</strong></span>
amy/
info.xml <span class="strong"><strong>[information about maintainer "amy"]</strong></span>
p/ <span class="strong"><strong>[Packages]</strong></span>
packages.xml <span class="strong"><strong>[A list of all packages in this channel]
</strong></span>
PackageName1/
info.xml <span class="strong"><strong>[information on "PackageName1" package]
</strong></span>
maintainers.xml <span class="strong"><strong>[list of maintainers of this package]
</strong></span>
PackageName2/
info.xml <span class="strong"><strong>[information on "PackageName2" package]
</strong></span>
maintainers.xml <span class="strong"><strong>[list of maintainers of this package]
</strong></span>
PackageName3/
info.xml <span class="strong"><strong>[information on "PackageName3" package]
</strong></span>
maintainers.xml <span class="strong"><strong>[list of maintainers of this package]
</strong></span>
r/ <span class="strong"><strong>[Releases]</strong></span>
PackageName1/ <span class="strong"><strong>[Releases of package PackageName1]
</strong></span>
allreleases.xml <span class="strong"><strong>[A brief list of all releases available]</strong></span>
1.0.0.xml <span class="strong"><strong>[summary information about version 1.0.0]
</strong></span>
package.1.0.0.xml <span class="strong"><strong>[the complete package.xml of this release]
</strong></span>
deps.1.0.0.txt <span class="strong"><strong>[PHP-serialized dependencies of version 1.0.0]
</strong></span>
0.9.0.xml <span class="strong"><strong>[summary information about version 0.9.0]
</strong></span>
deps.0.9.0.txt <span class="strong"><strong>[PHP-serialized dependencies of version 0.9.0]
</strong></span>
package.0.9.0.xml <span class="strong"><strong>[the complete package.xml of this release]
</strong></span>
...
...
latest.txt <span class="strong"><strong>[the latest version number, in text format]
</strong></span>
stable.txt <span class="strong"><strong>[the latest stable version number, in text format]
</strong></span>
beta.txt <span class="strong"><strong>[the latest beta version number, in text format]
</strong></span>
PackageName2/ <span class="strong"><strong>[Releases of package PackageName2]
</strong></span>
allreleases.xml <span class="strong"><strong>[A brief list of all releases available]
</strong></span>
1.1.0.xml <span class="strong"><strong>[summary information about version 1.1.0]
</strong></span>
deps.1.1.0.txt<span class="strong"><strong>[PHP-serialized dependencies of version 1.1.0]
</strong></span>
package.1.1.0.xml <span class="strong"><strong>[the complete package.xml of this release]
</strong></span>
1.0.4.xml <span class="strong"><strong>[summary information about version 1.0.4]
</strong></span>
deps.1.0.4.txt<span class="strong"><strong>[PHP-serialized dependencies of version 1.0.4]
</strong></span>
package.1.0.4.xml <span class="strong"><strong>[the complete package.xml of this release]
</strong></span>
...
...
latest.txt <span class="strong"><strong>[the latest version number, in text format]
</strong></span>
stable.txt [<span class="strong"><strong>the latest stable version number, in text format]
</strong></span>
beta.txt <span class="strong"><strong>[the latest beta version number, in text format]
</strong></span>
alpha.txt <span class="strong"><strong>[the latest alpha version number, in text format]
</strong></span>
devel.txt <span class="strong"><strong>[the latest devel version number, in text format]
</strong></span>
</pre></div><p>Note that PackageName3 has no releases, and so has no REST entry.</p><p>REST1.1 adds these files to the structure:</p><div class="informalexample"><pre class="programlisting">c/
categories.xml <span class="strong"><strong>[list of all categories]</strong></span>
CategoryName1/
<span class="strong"><strong>packagesinfo.xml [consolidated package/release info for the entire
category]</strong></span>
CategoryName2/
<span class="strong"><strong>packagesinfo.xml [consolidated package/release info for the entire
category]</strong></span>
m/
allmaintainers.xml <span class="strong"><strong>[list of all maintainers]</strong></span>
p/
r/
</pre></div><p>The primary purpose of REST1.1 is to enable spidering of a channel without requiring that old-fashioned directory crawling to be allowed, eliminating the potential security vulnerability intrinsic to all web servers.<a id="id302" class="indexterm"/>
</p><p>A channel server mirror is defined by the<code class="literal">&lt;mirror&gt;</code> tag. This tag is identical to the<code class="literal">&lt;primary&gt;</code> tag except that it requires an additional attribute,<code class="literal"> host</code>. The<code class="literal"> host</code> attribute defines the URL that should be used to contact the mirror.</p></div><div class="section" title="Obtaining Chiara_PEAR_Server"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec03"/>Obtaining Chiara_PEAR_Server</h2></div></div></div><p>The Chiara_PEAR_Server package is easily obtained. First, you need to meet a few prerequisites. The Chiara_PEAR_Server package requires:<a id="id303" class="indexterm"/>
</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">PHP 5.0.0 or newer; PHP 5.1.0 or newer is recommended</li><li class="listitem" style="list-style-type: disc">A MySQL database server</li><li class="listitem" style="list-style-type: disc">The mysql or mysqli PHP extension</li><li class="listitem" style="list-style-type: disc">A working web server such as Apache</li><li class="listitem" style="list-style-type: disc">PEAR version 1.4.3 or newer</li></ul></div><p>To obtain PEAR version 1.4.3 or newer, if you have PHP version 5.1.0, all you need to do on UNIX is:</p><div class="informalexample"><pre class="programlisting"><span class="strong"><strong>$ cd php-5.1.0
$ ./buildconf
$ ./configure
$ make cli
$ make install-pear
</strong></span>
</pre></div><p>This will install and configure PEAR automatically. Note that the<code class="literal"> configure</code> command accepts a large number of options, and it is easy to learn about them through<code class="literal"> ./configure --help</code>.<a id="id304" class="indexterm"/>
</p><p>Note that installing PHP in a web server is more complicated, and is necessary to install the Chiara_PEAR_Server package. If you are using Apache, all you need to do is pass in the<code class="literal"> --with-apache</code> or<code class="literal"> --with-apache2</code> directives to<code class="literal"> configure</code>, and you will be up and running.</p><p>On Windows, for all PHP versions prior to version 5.2.0, you need to download the<code class="literal"> .zip</code> version of PHP,<span class="emphasis"><em> not</em></span> the<code class="literal"> .msi</code> version. Then change to the directory you uncompressed PHP into and type:</p><div class="informalexample"><pre class="programlisting"><span class="strong"><strong>go-pear
</strong></span>
</pre></div><p>Answer the prompts and choose installation locations. In both cases, after installing, be sure to upgrade:</p><div class="informalexample"><pre class="programlisting"><span class="strong"><strong>pear upgrade PEAR
</strong></span>
</pre></div><p>This will ensure that you have the latest stable version of PEAR.</p><p>Installing the mysql or mysqli PHP extensions is documented at <a class="ulink" href="http://www.php.net/mysql"> http://www.php.net/mysql</a>.</p><p>After everything is ready, you can obtain the Chiara_PEAR_Server package via these simple steps:</p><div class="informalexample"><pre class="programlisting"><span class="strong"><strong>$ pear channel-discover pear.chiaraquartet.net
$ pear up Chiara_PEAR_Server-alpha
</strong></span>
</pre></div><p>That's it! Note that Chiara_PEAR_Server currently requires<code class="literal"> pear.php.net</code> packages DB_DataObject and HTML_QuickForm, so be sure that you either have a working internet connection or have installed these packages prior to attempting to install Chiara_PEAR_Server.<a id="id305" class="indexterm"/>
</p><p>Configuring the server requires running a post-installation script, which we cover in the following section.</p></div><div class="section" title="Configuring the Server; Obtaining a Front End for End Users"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec04"/>Configuring the Server; Obtaining a Front End for End Users</h2></div></div></div><p>Before we run the post-installation script, it is important to understand what it will need in order to function properly.<a id="id306" class="indexterm"/>
</p><p>First, we need to create a MySQL user that will be used by the post-installation script to initialize the database and create tables. As such, this user needs to have<code class="literal"> create</code> and<code class="literal"> alter</code> permissions (use the<code class="literal"> GRANT</code> command from within MySQL to do this). As this will be the database user used by public web scripts, for security reasons, it is best to remove<code class="literal"> create/alter</code> permissions once the database has been properly initialized. The only permissions needed for everyday operations by the Chiara_PEAR_Server administrative back end are<code class="literal"> insert/delete/update</code>. Note that, when upgrading Chiara_PEAR_Server,<code class="literal"> create/alter</code> permissions should be re-granted again temporarily, just in case there are modifications or additions to the database.</p><p>Running the Chiara_PEAR_Server post-installation script is a simple task in PEAR, all you need to do is type:</p><div class="informalexample"><pre class="programlisting"><span class="strong"><strong>$ pear run-scripts chiara/Chiara_PEAR_Server
</strong></span>
</pre></div><p>The PEAR installer will walk you through several questions. After you are finished with them, and if there are no errors, the channel server will be ready for operation.<a id="id307" class="indexterm"/>
</p><div class="mediaobject"><img src="graphics/1904811191_5_01.jpg" alt="Configuring the Server; Obtaining a Front End for End Users"/></div><p>The first set of questions will ask for database-connection information, and for the<code class="literal"> Handle</code> of the primary-channel administrator (you) and the name of the channel. Your<code class="literal"> Handle</code> is the same as your handle or username in a<code class="literal"> package.xml</code> file, and should be a single lower-cased word. For examples of choices of handles, you might browse the list of maintainers at <a class="ulink" href="http://pear.php.net/accounts.php"> http://pear.php.net/accounts.php</a>. Your channel name must be the same as the server. So, for instance, if you are setting up a test server at localhost, your channel must be named<code class="literal"> localhost</code>.</p><div class="mediaobject"><img src="graphics/1904811191_5_02.jpg" alt="Configuring the Server; Obtaining a Front End for End Users"/></div><p>The next set of questions you will need to answer relates to the basics of your channel. It is at this time that you should have a server name in mind. Generally speaking, it is easier for users to remember a channel name if there is a direct connection to the content it serves. For instance, if your channel serves financial software, perhaps a channel name like<span class="emphasis"><em> software.companyname.com</em></span> would be good, with an alias like<span class="emphasis"><em> companysoftware</em></span>.<a id="id308" class="indexterm"/>
</p><p>After this, information will be requested about the primary-channel administrator. Finally, information will be asked about the document root of your web server.</p><p>This section is the most important, as it will be used to create both the administrative front end used to maintain packages and upload releases, and the REST files used to support the REST protocols needed by the PEAR installer in order to function. In general, the default values provided in parentheses should be acceptable. However, it is helpful to understand the purpose of the different prompts.</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>PEAR Configuration File Location:</strong></span> This specifies the location of the file that should be used to retrieve channel information. The Chiara_PEAR_Server channel simply will not function at all unless it can retrieve information about its own channel, so this value needs to be right.</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Path to document root of web server for localhost:</strong></span> This should be the full path on your local file system to the base of your web server. If your web server reads<code class="literal"> /var/lib/web/htdocs/servername/index.php</code> when a user requests <a class="ulink" href="http://servername/index.php"> http://servername/index.php</a>, then your document root is<code class="literal"> /var/lib/web/htdocs/servername</code>.</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>name of frontend.php HTML admin frontend file:</strong></span> This is the filename of your administrative front-end file. Choosing a unique file name will help prevent annoying or prevent malicious people from unwanted attempts to access the channel administrative interface.<a id="id309" class="indexterm"/></li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>temporary path to save release uploads in:</strong></span> This should be a web server-writeable location in which you initially save uploaded releases.</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>port clients should connect to (443 is SSI, 80 is regular HTTP):</strong></span> Follow the instructions. If you have a typical configuration, 80 is normal for<code class="literal"> http://</code> and 443 is typical for<code class="literal"> https://</code>.</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>protocol clients should use to connect (http or https):</strong></span> Again, choose one of the two options.</li></ul></div></div><div class="section" title="Adding a Package and Releasing Packages"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec05"/>Adding a Package and Releasing Packages</h2></div></div></div><p>Once you have completed the post-installation script, navigate to the administrative front-end file, whose name you specified in the<span class="strong"><strong> name of frontend.php HTML admin frontend file</strong></span> section. For instance, if your front-end file is named<code class="literal"> foo.php</code>, and your  channel is localhost, navigate to  <code class="literal">http://localhost/foo.php</code>. You should see
something like this:<a id="id310" class="indexterm"/>
</p><div class="mediaobject"><img src="graphics/1904811191_5_03.jpg" alt="Adding a Package and Releasing Packages"/></div><p>To log in as the administrator, enter the handle and password that you specified for the administrator in the post-installation script. After logging in, prior to uploading a release, you first need to create the package on the server, and then add maintainers.<a id="id311" class="indexterm"/>
</p><p>When you log in, you will see a screen similar to this one:</p><div class="mediaobject"><img src="graphics/1904811191_5_04.jpg" alt="Adding a Package and Releasing Packages"/></div><p>Links for configuring the channel are on the left side of the screen. To get started, you may also want to create some categories for the software you are releasing, such as "Database" or "XML Processing." For examples of categories, see <a class="ulink" href="http://pear.php.net/packages.php"> http://pear.php.net/packages.php</a>.<a id="id312" class="indexterm"/>
</p><p>After you have created categories, you will want to add maintainers and create packages. Creating a package is straightforward. First, click<span class="strong"><strong> Create a Package</strong></span>, and you will see a screen like the following:<a id="id313" class="indexterm"/>
</p><div class="mediaobject"><img src="graphics/1904811191_5_05.jpg" alt="Adding a Package and Releasing Packages"/></div><p>Fill in the required fields (marked by a red asterisk), and then click<span class="strong"><strong> Save Changes</strong></span>. The next step is very important: before you can upload a release, you will need to create maintainers and add them as maintainers to the package. To do this, click on the<span class="strong"><strong> (Maintainers)</strong></span> link next to your newly created package seen at the left side of the screen:<a id="id314" class="indexterm"/>
</p><div class="mediaobject"><img src="graphics/1904811191_5_06.jpg" alt="Adding a Package and Releasing Packages"/></div><p>Once you have chosen the maintainer, and the role, and whether the maintainer is active, click<span class="strong"><strong> Add Maintainer</strong></span>, and the maintainer will show up on the list of package maintainers.<a id="id315" class="indexterm"/>
</p><div class="note" title="Note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="tip43"/>Tip</h3><p><span class="strong"><strong>Who can Upload Releases?</strong></span></p><p>The channel administrator can upload a release for any package on the channel, and also package maintainers who are listed as a lead at the channel can upload packages. Note that a maintainer listed as lead in the<code class="literal"> package.xml</code> file but not at the channel's administrative front end will<span class="emphasis"><em> not</em></span> be able to upload a release for security reasons.</p></div></div><div class="section" title="Installing a Public Channel Front End"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec06"/>Installing a Public Channel Front End</h2></div></div></div><p>After Chiara_PEAR_Server is configured and running, you may wish to install Davey Shafik's<span class="strong"><strong> Crtx_PEAR_Channel_Frontend</strong></span> package from channel<code class="literal"> pear.crtx.org</code>. The Crtx_PEAR_Channel_Frontend package provides a browsable website that allows developers to look at the packages your channel offers and how to acquire them. In addition, it has a support for linking to a bug tracker, online revision control browser, and other features. Crtx_PEAR_Channel_Frontend is to Chiara_PEAR_Server as <a class="ulink" href="http://pear.php.net"> http://pear.php.net</a> is to the installer data provided at <a class="ulink" href="http://pear.php.net/rest"> http://pear.php.net/rest</a>.<a id="id316" class="indexterm"/>
</p><p>Acquiring Crtx_PEAR_Channel_Frontend can be done via these steps:<a id="id317" class="indexterm"/>
</p><div class="informalexample"><pre class="programlisting"><span class="strong"><strong>$ pear channel-discover pear.crtx.org
$ pear upgrade crtx/Crtx_PEAR_Channel_Frontend
</strong></span>
</pre></div><p>Once you have installed the package, there are some minor configurations to be performed (this may be automated by a post-installation script in future releases). First, you need to locate the<code class="literal"> pear_frontend.css</code> file, which is installed into<code class="literal"> data_dir/Crtx_PEAR_Channel_Frontend/data/pear_frontend.css</code>.<a id="id318" class="indexterm"/>
</p><p>
<code class="literal">data_dir</code> is the path to data (normally<code class="literal"> /usr/local/lib/php/data</code> on UNIX, and<code class="literal"> C:\php5\PEAR\data</code> or<code class="literal"> C:\php4\PEAR\data</code> on Windows) as defined by the PEAR<code class="literal"> data_dir</code> configuration variable. Once the file is located, copy this to the document root of your channel.</p><p>After copying the<code class="literal"> pear_frontend.css</code> file, you need to create the public front-end PHP file. A sample front end follows:</p><div class="informalexample"><pre class="programlisting">&lt;?php
/**
* An example of Crtx_PEAR_Channel_Frontend Usage
*
* @copyright Copyright © David Shafik and Synaptic Media 2004.
*All rights reserved.
* @author Davey Shafik &lt;davey@synapticmedia.net&gt;
* @link http://www.synapticmedia.net Synaptic Media
* @version $Id: $
* @package
* @category Crtx
*/
/**
* Crtx_PEAR_Channel_Frontend Class
*/
require_once 'Crtx/PEAR/Channel/Frontend.php';
$frontend = new Crtx_PEAR_Channel_Frontend('localhost',
array('database' =&gt; 'mysqli://user:pass@localhost/pearserver',
'index' =&gt; 'index.php', 'admin' =&gt; 'admin_myfront.php'));
?&gt;
&lt;html&gt;
&lt;head&gt;
&lt;title&gt;localhost Channel Server&lt;/title&gt;
&lt;link rel="stylesheet" type="text/css"
href="pear_frontend.css" /&gt;
&lt;?php
$frontend-&gt;showLinks();
?&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;div id="top"&gt;
&lt;h1&gt;&lt;a href="index.php"&gt;localhost Channel Server&lt;/a&gt;&lt;/h1&gt;
&lt;/div&gt;
&lt;div id="menu"&gt;
&lt;?php
$frontend-&gt;showMenu();
?&gt;
&lt;div id="releases"&gt;
&lt;?php
$frontend-&gt;showLatestReleases();
?&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div id="content"&gt;
&lt;?php
if (!$frontend-&gt;run()) {
$frontend-&gt;welcome();
}
?&gt;
&lt;/div&gt;
&lt;/body&gt;
&lt;/html&gt;
</pre></div><p>This file, if saved as<code class="literal"> index.php</code> in the document root of the<code class="literal"> localhost</code> web server, will provide an attractive screen similar to the following:<a id="id320" class="indexterm"/>
</p><div class="mediaobject"><img src="graphics/1904811191_5_07.jpg" alt="Installing a Public Channel Front End"/></div><p>There are several nice features built into this package, including RSS feeds and the ability to email maintainers. In addition, customization of the look and feel is straightforward, accomplished through elementary modification of the<code class="literal"> pear_frontend.css</code> file and the<code class="literal"> index.php</code> front end. With very little work, a very attractive front end can be created. Examples of the diversity of possibilities include <a class="ulink" href="http://pear.crtx.org"> http://pear.crtx.org</a> and <a class="ulink" href="http://pear.php-tools.net"> http://pear.php-tools.net</a>.<a id="id321" class="indexterm"/>
</p></div></div>
<div class="section" title="Distributing Pay-For-Use PHP Applications through a Channel"><div class="titlepage"><div><div><h1 class="title"><a id="ch05lvl1sec03"/>Distributing Pay-For-Use PHP Applications through a Channel</h1></div></div></div><p>One of the more common questions posed about channels is: "Can my business distribute pay-for-use PHP applications through a channel, and restrict access?" The answer is a resounding yes.</p><p>The PEAR installer implements HTTP authentication through the use of the<code class="literal"> pear login</code> command. To distribute your non-free applications, it is best to rely upon the strengths of web servers like Apache. For instance, by making "get" a file and using the<code class="literal"> ForceType</code> directive in<code class="literal"> httpd.conf</code> like the following:<a id="id322" class="indexterm"/>
</p><div class="informalexample"><pre class="programlisting">&lt;Location /get&gt;
ForceType application/x-httpd-php
&lt;/Location&gt;
</pre></div><p>You can use a file named<code class="literal"> get</code> that contains PHP code to process the login/password supplied by a user and direct them to a restricted package customized for their login. In fact, normal users could be directed to a trial version of the software, without any change to their installation process.</p><p>Note that the PEAR Installer only supports HTTP Basic authentication, and for a truly secure connection, SSL (HTTPS) should be used, otherwise anyone can glean the restricted passwords. Here is a sample script for the<code class="literal"> get</code> file:<a id="id323" class="indexterm"/>
</p><div class="informalexample"><pre class="programlisting">&lt;?php
/**
* Example restricted access file
*
*
* This example requires Apache, PHP 4.3+, the mysqli extension, and
* this code to be added to httpd.conf/.htaccess:
* &lt;pre&gt;
* &lt;Location "/get"&gt;
* ForceType application/x-httpd-php
* &lt;/Location&gt;
* &lt;/pre&gt;
*
* In addition, it assumes that a mysql database is set up with users
* who have purchased the packages, and that database connection
* info is set in php.ini
* @package download
*/
// shut up or we risk getting corrupted tgz files
error_reporting(0);
function error($message)
{
header('HTTP/1.0 404 Not Found');
echo $message;
exit;
}
/**
* Downloader class, handles authentication and actual downloading
* @package download
*/
class Download
{
var $user = false;
var $passwd = false;
/**
* A list of purchased versions that the current user may
*download
*
* @var array
*/
var $purchased = array();
/**
* MySQL database connection
*
* @var resource mysqli resource
*/
var $db;
/**
* Full path to offline location of package releases
*
* @var string
*/
var $path = '/path/to/releases/';
/**
* Hash of package names to demo versions
*
* This probably should be constructed from a database,
* but for our simple example it will be hard-coded
*
* @var array
*/
var $demo_versions = array(
'Foo' =&gt; array('1.0demo'),
'Bar' =&gt; array('1.1demo', '2.0demo'),
);
/**
* Hash of package names to full versions
*
* This probably should be constructed from a database,
* but for our simple example it will be hard-coded
*
* @var array
*/
var $full_versions = array(
'Foo' =&gt; array('1.0'),
'Bar' =&gt; array('1.1', '2.0'),
);
/**
* Connect to the database, authenticate the user,
* and grab the list
* of purchased packages for this user
*/
function Download()
{
// assume we have specified connection details in php.ini
$this-&gt;db = mysqli_connect();
if ($this-&gt;db) {
// on database connect failure,
// we can still download demos,
// so fail silently
if (isset($_SERVER['PHP_AUTH_USER']) &amp;&amp;
isset($_SERVER['PHP_AUTH_PASSWD'])) {
$this-&gt;user = $_SERVER['PHP_AUTH_USER'];
$this-&gt;passwd = $_SERVER['PHP_AUTH_PASSWD'];
// construct a list of purchased packages
// for this user/pass combination
if ($res = mysqli_query($this-&gt;db, '
SELECT purchased_package FROM regusers
WHERE user = "' .
mysqli_real_escape_string($this-&gt;db,
$this-&gt;user) . '", AND pass = "' .
mysqli_real_escape_string($this-&gt;db,
$this-&gt;passwd) . '"')) {
while ($row = mysqli_fetch_row($res)) {
$this-&gt;purchased[$row[0]] = true;
}
}
}
}
}
/**
* Feed the file to the user, or display an error
*
* @param string $path
*/
function downloadPackage($path)
{
// note that we assume the case is correct
// (the PEAR Installer always gets
// this correct, only manual downloads will fail)
if (!preg_match('/^([a-zA-Z0-9_]+)-(.+)\.(tar|tgz)$/',
$path, $matches)) {
error('invalid package/version: "' . $path . '"');
}
list(, $package, $version, $ext) = $matches;
// sanity check #1: does the release exist on the disk?
if (!file_exists($this-&gt;path . $package . '-' . $version .
'.' . $ext)) {
error('unknown package/release: "' . $path . '"');
}
// sanity check #2: do we know anything about this version?
if (!isset($this-&gt;demo_versions[$package]) &amp;&amp;
!isset($this-&gt;full_versions[$package])) {
error('unknown package: "' . $package . '"');
}
// check to see if it is a demo version, and return right
// away if so
// if you have more purchaser downloads than demos,
// put this after
// purchased check for slight speed increase
if (isset($this-&gt;demo_versions[$package]) &amp;&amp;
in_array($version, $this-&gt;demo_versions[$package],
true)) {
$this-&gt;_doDownload($package, $version, $ext);
}
if (isset($this-&gt;full_versions[$package]) &amp;&amp;
in_array($version, $this-&gt;full_versions[$package],
true)) {
if (isset($this-&gt;purchased[$package])) {
$this-&gt;_doDownload($package, $version, $ext);
}
// if we get here, the user has not purchased this
// version
error('version "' . $version . '" is restricted and
must be purchased. ' .
'Use "pear login" to set purchase key first');
}
// fall-through: this line of code should be unreachable
error('internal error, please report attempt to download "
' . $path . '" failed');
}
/**
* Do the actual downloading.
*
* @param string $package
* @param string $version
* @param string $ext this is either "tar" or "tgz"
* @access private
*/
function _doDownload($package, $version, $ext)
{
// construct local path to the downloadable object
$path = $this-&gt;path . $package . '-' . $version . '.' . $ext;
header('Last-modified: ' .
gmdate('D, d M Y H:i:s \G\M\T', filemtime($path)));
header('Content-type: application/octet-stream');
header('Content-disposition: attachment; filename="' .
$path . '"');
header('Content-length: ' . filesize($path));
readfile($path);
exit;
}
}
if (!isset($_SERVER['PATH_INFO']) || $_SERVER['PATH_INFO'] == '/') {
error('no package selected');
}
$info = explode('/', $_SERVER['PATH_INFO']);
switch (count($info)) {
case 2:
$dl = new Download;
$dl-&gt;downloadPackage($info[1]);
break;
default:
error('no package selected');
}
?&gt;
</pre></div><p>The above example shows how easily even complex version validation can be accomplished. However, this approach does not scale very efficiently  —  every download is funneled through the PHP interpreter, which is considerably slower than fetching a static file. Another option, which will only work with PEAR versions 1.4.9 or newer, is to send a redirect header (402), and allow Apache to handle the actual file download. However, the savings are minimal enough over using<code class="literal"> readfile()</code> that it may not be worth requiring users to upgrade.</p><p>Another option is to simply restrict access to files using HTTP Basic authentication in<code class="literal"> .htaccess</code> files for individual tarballs. This is most likely to be scalable.</p><p>Then, instruct users to take these steps when first setting their login/password:</p><div class="informalexample"><pre class="programlisting"><span class="strong"><strong>$ pear -d "default_channel=your.channel.com" login
Logging into your.channel.com
Username: myuser
Password: mypassword
</strong></span>
</pre></div><p>The user/password will only be sent when the user requests a package from<code class="literal"> your.channel.com</code>, taking advantage of per-channel configuration.</p><p>It is highly recommended to use SSL for your channel, so that username/password pairs are never sent in plaintext.</p><p>That's all that is necessary!</p></div>
<div class="section" title="Distributing Packages through Static tarballs for Single-Client Installations"><div class="titlepage"><div><div><h1 class="title"><a id="ch05lvl1sec04"/>Distributing Packages through Static tarballs for Single-Client Installations</h1></div></div></div><p>In addition to distributing packages via a channel, it is also possible to distribute a single release and post it to the Web.<a id="id328" class="indexterm"/>
</p><div class="note" title="Note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="tip44"/>Tip</h3><p><span class="strong"><strong>PEAR 1.4.10 is needed to Install Static Releases with Dependencies</strong></span></p><p>A bug in the PEAR installer prevents installing static tarballs; use version 1.4.10 or newer to get the fix for this problem.</p></div><p>This basically involves packaging up a release via<code class="literal"> pear package</code> and then uploading it to a website, where it can then be downloaded, or installed directly via:</p><div class="informalexample"><pre class="programlisting"><span class="strong"><strong>$ pear install http://www.example.com/Package-1.0.0.tgz
</strong></span>
</pre></div><p>This is nothing new: the earliest versions of the PEAR installer supported this syntax. What is new is the ability to depend on these<span class="strong"><strong> static tarballs</strong></span> in other package releases.</p><div class="section" title="Who Needs this Feature?"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec07"/>Who Needs this Feature?</h2></div></div></div><p>In some cases, it is not necessary to set up a channel server. In general, it is better to set up a channel server and distribute packages in that manner. However, a common real-world situation is a PHP consultant who is providing services to multiple clients, and also maintaining their websites for them. Although every site is unique, it is very helpful to have a set of utility packages that can be used by each specific site. To provide a channel for these packages only introduces unneeded complexity.<a id="id329" class="indexterm"/>
</p><p>By installing your client's website as a PEAR package, it becomes possible for you as the software consultant to easily maintain the site and regulate its content in a much stricter manner than channels allow.</p></div><div class="section" title="Differences in package.xml and Dependencies"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec08"/>Differences in package.xml and Dependencies</h2></div></div></div><p>In order to prevent name collisions between channels and static tarballs, a static tarball's<code class="literal"> package.xml</code> file cannot use the <a class="ulink" href="http://&lt;channel&gt;">&lt;channel&gt;</a> tag, and must instead use the<code class="literal">&lt;uri&gt;</code> tag. In addition, the<code class="literal">&lt;uri&gt;</code> tag must contain the actual location of the tarball on the Internet. If the static tarball is located at <a class="ulink" href="http://www.example.com/tarballs/Package-1.0.0.tgz"> http://www.example.com/tarballs/Package-1.0.0.tgz</a>, the<code class="literal"> package.xml</code> file should begin with something like this:<a id="id330" class="indexterm"/>
</p><div class="informalexample"><pre class="programlisting">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;package packagerversion="1.4.3" version="2.0"



xsi:schemaLocation="http://pear.php.net/dtd/tasks-1.0
http://pear.php.net/dtd/tasks-1.0.xsd
http://pear.php.net/dtd/package-2.0
http://pear.php.net/dtd/package-2.0.xsd"&gt;
&lt;name&gt;Package&lt;/name&gt;
&lt;uri&gt;http://www.example.com/tarballs/Package-1.0.0&lt;/uri&gt;
</pre></div><p>It is very important to notice that the<code class="literal"> uri</code> has the file extension,<code class="literal"> .tgz</code>, removed. This is because when providing a static tarball, it is expected that you will also provide an uncompressed<code class="literal"> .tar</code> for users who do not have the zlib extension enabled.</p><p>To depend on this static tarball, a dependency tag like the following should be used:</p><div class="informalexample"><pre class="programlisting">&lt;package&gt;
&lt;name&gt;Package&lt;/name&gt;
&lt;uri&gt;http://www.example.com/tarballs/Package-1.0.0&lt;/uri&gt;
&lt;/package&gt;
</pre></div><p>Versioning has no meaning when working with static tarballs as dependencies, and so none of the normal versioning tags (<code class="literal">&lt;min&gt;,&lt;max&gt;, &lt;recommended&gt;</code>) are allowed. However, it is possible to upgrade static tarballs.</p><p>Each static tarball package has an implied<code class="literal">&lt;channel&gt;__uri&lt;/channel&gt;</code> tag  —  all static tarballs are installed/upgraded/uninstalled as if in the pseudo-channel<code class="literal"> __uri</code>. This channel is treated just like other channels except that it cannot be modified via the<code class="literal"> channel-update</code> command, deleted via the<code class="literal"> channel-delete</code> command, and it does not contain a server, and so will never attempt to contact the Internet to query a remote channel server. Running<code class="literal"> pear channel-info __uri</code> results in:</p><div class="informalexample"><pre class="programlisting"><span class="strong"><strong>CHANNEL __URI INFORMATION:
==========================
Name and Server __uri
Summary Pseudo-channel for static packages
Validation Package Name PEAR_Validate
Validation Package default
Version
SERVER CAPABILITIES
===================
TYPE VERSION/REST TYPE FUNCTION NAME/REST BASE
No supported protocols
</strong></span>
</pre></div><p>In addition to demonstrating the qualities of the<code class="literal"> __uri</code> pseudo-channel, it tells us that static tarball packages are validated with the same strictness that<code class="literal"> pear.php.net</code> channel packages are validated (using<code class="literal"> PEAR_Validate</code>). If you need flexibility of validation, it is necessary to use a channel instead of distributing your software as a static tarball.<a id="id331" class="indexterm"/>
</p><p>However, this also means that after installing our static package via:</p><div class="informalexample"><pre class="programlisting"><span class="strong"><strong>$ pear install http://www.example.com/tarballs/Package-1.0.0.tgz
</strong></span>
</pre></div><p>It is possible to upgrade this package, should a new version be released, via:</p><div class="informalexample"><pre class="programlisting"><span class="strong"><strong>$ pear upgrade http://www.example.com/tarballs/Package-1.0.1.tgz
</strong></span>
</pre></div><p>In addition, it is possible to uninstall the package via the simple:</p><div class="informalexample"><pre class="programlisting"><span class="strong"><strong>$ pear uninstall __uri/Package
</strong></span>
</pre></div><p>If you wish to see a list of all static tarball packages installed, simply run the<code class="literal"> list</code> command with the -c option:</p><div class="informalexample"><pre class="programlisting"><span class="strong"><strong>$ pear list -c __uri
</strong></span>
</pre></div><p>Beware the simplicity of static tarballs! If there is any chance your end user will install static tarballs from any other source, you must distribute your packages from a channel. Otherwise, the user could run into a name collision between two different packages, as illustrated by these two hypothetical install commands:</p><div class="informalexample"><pre class="programlisting"><span class="strong"><strong>$ pear install http://www.example.com/tarballs/Foo-1.0.0.tgz
$ pear upgrade http://www.notexample.com/Foo-1.2.3.tgz
</strong></span>
</pre></div><p>In this case, the package named<code class="literal"> Foo</code> distributed from<code class="literal"> www.example.com/tarballs</code> is not the same code-base as the package named<code class="literal"> Foo</code> distributed from<code class="literal"> www.notexample.com</code>, but the PEAR installer treats them both as if you had typed:</p><div class="informalexample"><pre class="programlisting"><span class="strong"><strong>$ pear install __uri/Foo
$ pear upgrade __uri/Foo
</strong></span>
</pre></div><p>In this situation, the chance of subtle to severe breakage is immediate and difficult to debug. Don't push your luck; use a channel if there is any chance that this situation could occur.</p></div><div class="section" title="Releasing Equals Uploading"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec09"/>Releasing Equals Uploading</h2></div></div></div><p>As stated earlier, the biggest advantage to using a static tarball instead of a channel is that releasing a new package simply involves uploading both a<code class="literal"> .tgz</code> and a<code class="literal"> .tar</code> of the release as created by the commands:<a id="id332" class="indexterm"/>
</p><div class="informalexample"><pre class="programlisting"><span class="strong"><strong>$ pear package
$ pear package -Z
</strong></span>
</pre></div><p>It doesn't get any easier than this!</p></div></div>
<div class="section" title="Security Issues Inherent in Remote Installation"><div class="titlepage"><div><div><h1 class="title"><a id="ch05lvl1sec05"/>Security Issues Inherent in Remote Installation</h1></div></div></div><p>As evidenced by the advent of internet worms taking advantage of vulnerabilities in phpBB, MySpace.com, and XML_RPC, security holes are no laughing matter, and it is critical that you are aware of the potential risks involved in installing software you have not written yourself.<a id="id333" class="indexterm"/>
</p><p>Fortunately, the PEAR-installer model provides both ease of upgrading to obtain needed security fixes and intrinsic security to ensure you won't become a victim of malicious hackers just by using the PEAR installer.</p><p>Although the PEAR developers have taken every step to ensure the safety of your code without restricting its usefulness, it is still very important that you understand some basics of security, as PEAR will not be able to protect you from yourself, should you choose to use or write insecure code. There are several excellent references written recently on PHP security and on internet security in general. Both Ilia Alshanetsky's<span class="emphasis"><em> php|architect's Guide to PHP Security</em></span> and Chris Shiflett's<span class="emphasis"><em> Essential PHP Security</em></span> guide are a good place to start if you are unfamiliar with concepts such as escaping output, filtering input, or terms like XSS, arbitrary code execution, security through obscurity, and so on.</p><div class="note" title="Note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="tip45"/>Tip</h3><p>Many developers mistakenly develop and operate under the old golden rule: "Do unto others as you would have them do unto you." This approach is fatally flawed when you are developing code that has a component of internet connectivity. If it is possible for anyone other than you to access the PHP application you have written, then you need to assume that they have only the worst intentions.</p><p>As you design a feature, think to yourself: "How could I use this feature to modify the environment of the machine it is running on? Can I use it to perform unexpected actions?"</p><p>If the answer is "yes" or even "maybe" then the feature is intrinsically insecure and must be restricted until the answer is "no" or "only in extreme circumstances that would render it useless by other safeguards that are in place".</p></div><div class="section" title="How do PEAR Installer and Chiara_PEAR_Server Provide Security?"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec10"/>How do PEAR Installer and Chiara_PEAR_Server Provide Security?</h2></div></div></div><p>The PEAR installer has taken a number of important steps to provide security. However, at its essence, the PEAR installer is ultimately designed to install arbitrary PHP code  —  this is its raison d'être, so the first rule of security with PEAR must be:<a id="id334" class="indexterm"/>
</p><div class="note" title="Note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="tip46"/>Tip</h3><p>
<span class="emphasis"><em>Never</em></span> install a package on a live, production site without first looking at the code it provides on a development server.</p></div><div class="section" title="Extra Security beyond what PEAR Provides"><div class="titlepage"><div><div><h3 class="title"><a id="ch05lvl3sec01"/>Extra Security beyond what PEAR Provides</h3></div></div></div><p>Although most basic actions taken by the PEAR installer have a reasonable expectation of security, there are a few that should be avoided.</p><p>This means, for instance, that<code class="literal"> upgrade-all</code> should be avoided at all costs on production servers. This command upgrades all existing packages to the latest version, which intrinsically removes your ability to control upgrades. This command is best used on a development server when testing newer versions of packages prior to upgrading them individually on the production server.</p><p>In addition, if you are installing a package distributed by a channel other than those hosted at<code class="literal"> php.net</code> (<code class="literal">pear.php.net</code> and <code class="literal"> pecl.php.net</code> at the time of writing this chapter), first download the package and run two commands on the package to learn more about it:</p><div class="informalexample"><pre class="programlisting"><span class="strong"><strong>$ pear info Packagename-1.0.0.tgz
$ pear list-files Packagename-1.0.0.tgz
</strong></span>
</pre></div><p>The first will tell you dependencies that the package has. If you don't recognize those dependencies, then you will need to perform the same steps on them.</p><p>The<code class="literal"> list-files</code> command lists all files in the archive. Look for files installed into the<code class="literal"> PEAR/</code> subdirectory. Unless the package is providing a custom file role, custom file task, or a custom command, a package generally has no business installing files into this location, as this is the directory used by the PEAR Installer. Any files installed into this directory could be attempting to maliciously affect the way the installer works.</p><p>The most obvious exceptions to this rule are packages whose names contain PEAR such as<code class="literal"> PEAR_PackageFileManager</code>. If a package is installing files into locations that don't appear to have much to do with the stated purpose, you should immediately be suspicious. Contact the package maintainer, and ask why the package needs to install files there.<a id="id335" class="indexterm"/>
</p><p>If you do not receive a satisfactory response, notify the PEAR developer's mailing list immediately at <code class="email">&lt;<a class="email" href="mailto:pear-dev@lists.php.net">pear-dev@lists.php.net</a>&gt;</code>. Any channel that attempts to provide malicious packages will be blacklisted by the PEAR installer.</p><p>Even more importantly, if there is only one thing that you remember from this book, let it be this one:<a id="id336" class="indexterm"/>
</p><div class="note" title="Note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="tip47"/>Tip</h3><p>
<span class="emphasis"><em>Never</em></span> run post-installation scripts without looking over the PHP source of the post-installation script.</p></div><p>Post-installation scripts are by definition arbitrary PHP code. Anything that can be done in PHP can be done by a post-installation script. This includes actions like installing spyware, erasing your hard disk, and other things you probably don't intend when running the<code class="literal"> pear run-scripts</code> command. It is never worth risking your entire system for the minor convenience of not looking at a script.</p><p>Ultimately, the chance of a malicious package being distributed by a channel is extremely low, due to the extreme ease of tracing a malicious package to the source, as well as requiring explicit user installation of the package. Both of these factors will not be enough to discourage evildoers out there unless you also are vigilant about installing packages from unknown sources, so that they are caught before any significant damage is done.</p><p>In addition, it is crucial that you upgrade the PEAR installer to version 1.4.3 or newer, and continually upgrade as new versions of the installer are released. Bugs, security issues, and minor fixes are sure to be addressed in newer versions.</p></div><div class="section" title="Specific Security Principles Applied in Designing the PEAR Installer and Chiara_PEAR_Server"><div class="titlepage"><div><div><h3 class="title"><a id="ch05lvl3sec02"/>Specific Security Principles Applied in Designing the PEAR Installer and Chiara_PEAR_Server</h3></div></div></div><p>When designing and implementing the latest versions of the PEAR installer, one of the primary concerns was preventing unanticipated modifications of the user environment. By opening up the installer to take advantage of sources other than<code class="literal"> pear.php.net/pecl.php.net</code> for packages, and adding features like post-installation scripts, custom file roles, and custom file tasks, there is an element of risk. Every new feature balances openness to legitimate activity with restriction of dangerous activity.<a id="id337" class="indexterm"/>
</p><p>For instance, channels are defined by their server name. This means that you cannot automatically and secretly change the source of packages distributed by<code class="literal"> pear.php.net</code>. In addition, when a user runs:</p><div class="informalexample"><pre class="programlisting"><span class="strong"><strong>$ pear channel-update mychannel.example.com
</strong></span>
</pre></div><p>The PEAR installer attempts to retrieve <a class="ulink" href="http://mychannel.example.com/channel.xml"> http://mychannel.example.com/channel.xml</a>. A clever and evil channel administrator could in fact serve a<code class="literal"> channel.xml</code> file that did not define<code class="literal"> mychannel.example.com</code>. This kind of mischief is immediately detected by the installer, and is disallowed.</p><p>The addition of channel mirrors also introduces an element of risk. By defining these mirrors in<code class="literal"> channel.xml</code>, it is not possible to subvert the installer into believing another channel is a legitimate mirror of a channel.<a id="id338" class="indexterm"/>
</p><p>When downloading a package from a channel, strict verification of the<code class="literal"> package.xml</code> is performed. If a package is downloaded from channel<code class="literal"> foo.example.com</code> and its<code class="literal"> package.xml</code> claims to be from<code class="literal"> pear.php.net</code>, the PEAR installer refuses to install or upgrade the package, as this would be a blatant security exploit.</p><p>In addition, if the requested package name is not the same as the package name in<code class="literal"> package.xml</code>, the PEAR installer will refuse to install or upgrade the package. Otherwise, it would be possible to distribute a package claiming to be<code class="literal"> foo.example.com/Foo</code> and actually distributing<code class="literal"> pear.php.net/PEAR</code>. The same mechanism prevents dependencies on malicious packages. A package downloaded from a channel/package must be that channel/package, period. The same is true for static tarballs. A package depended on using a static-tarball package dependency cannot distribute a channel-based package.</p><p>The most potentially dangerous features implemented in the PEAR installer are post-installation scripts and custom file tasks. Both of these features automatically execute arbitrary code when invoked. PEAR provides a layer of security by making it extremely difficult to accidentally execute malicious code. A user must:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Explicitly install a malicious file task</li><li class="listitem" style="list-style-type: disc">Explicitly install a package that uses the malicious file task</li></ul></div><p>For post-installation scripts, the end user must:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Explicitly install a package containing malicious post-installation scripts</li><li class="listitem" style="list-style-type: disc">Explicitly type pear<code class="literal"> run-scripts maliciouschannel/maliciouspackage</code> for the malicious package</li></ul></div><p>These extra steps allow the PEAR installer to make it very difficult to accidentally compromise a system, and also to provide extreme visibility to the fact that an unusual circumstance is being executed.</p><p>It is important to note that until PEAR version 1.4.3, the PEAR installer had two security vulnerabilities. Both require a user to install a publicly distributed malicious package. Both were caused by improper implementation of the command pattern.</p><p>The command pattern is a method of providing extensibility based on loading files in a special subdirectory. The PEAR installer has been using this pattern since version 1.0 to load the actual commands shown when you type:<a id="id339" class="indexterm"/>
</p><div class="informalexample"><pre class="programlisting"><span class="strong"><strong>$ pear help
</strong></span>
</pre></div><p>The files implementing this pattern are located in<code class="literal"> PEAR/Command/*.php</code> (PEAR/Command/Auth.php,<code class="literal"> PEAR/Command/Install.php</code>, etc.), and in PEAR versions 1.4.2 and older, these files were loaded up every time the user used the<code class="literal"> pear</code> command.</p><p>This ultimately provides a vector for a malicious package to execute arbitrary PHP code in an uncontrolled situation. PEAR 1.4.3 and newer versions fix this through the implementation of an XML format describing commands. No actual PHP code is loaded unless the user explicitly requests a command other than<code class="literal"> help</code>.</p><p>The command pattern is also used for custom file roles, first introduced in PEAR 1.4.x. All files<code class="literal"> PEAR/Installer/Role/*.php</code> were loaded up every time the<code class="literal"> pear</code> command was executed in order to construct the list of custom configuration variables. The same solution that fixed the arbitrary code execution vulnerability in commands is implemented to fix this vulnerability.</p></div></div></div>
<div class="section" title="Summary"><div class="titlepage"><div><div><h1 class="title"><a id="ch05lvl1sec06"/>Summary</h1></div></div></div><p>This chapter showed us that channels are designed to make it easy to install packages from any location, but difficult to compromise your system in the process, following a basic security principle: always make the easiest way to do things the most secure way.</p><p>Channels open up<code class="literal"> pear.php.net's</code> monopoly over the PEAR installer to the entire Internet. Custom-built packages distributed through your channel can even be sold and made available to specific users while co-existing peacefully with publicly available open source-packages.</p></div></body></html>