<html><head></head><body>
        <section>

                            <header>
                    <h1 class="header-title">Managing Custom Post Types and Processing Forms</h1>
                </header>
            
            <article>
                
<p>In web development, we use Model-View-Controller architecture to separate different aspects of the sites into their own layers. The Model layer is intended to manage the data and the business logic of the application. In WordPress development, it's difficult to use such architecture in its original form. However, modeling data and logic is important for any kind of a website. So, we use built-in custom post types, and custom forms to manage the data capturing process in WordPress. </p>
<p>In this chapter, we are going to explore the importance and use of custom post type features in custom development tasks. We will be building a new custom post type to handle the properties in a real estate listing website, while using the most important features such as taxonomies, custom fields, and template loading. By default, custom post types features are enabled in the backend, and hence we explore the process of using custom forms in the frontend for data management. Finally, we look at the advantages and disadvantages of custom post types and custom forms in development.</p>
<p>In this chapter, we will cover the following topics:</p>
<ul>
<li>Introduction to custom post types</li>
<li>Building object-oriented plugins</li>
<li>Building custom post types for properties</li>
<li>Introduction to form management</li>
<li>Building and using custom forms</li>
<li>Choosing between custom post types and custom forms</li>
<li>Using form management plugins</li>
</ul>
<p>By the end of this chapter, you will have the ability to develop with custom post types and custom forms, as well as know the pros and cons of the two techniques in different scenarios.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Technical requirements</h1>
                </header>
            
            <article>
                
<p>You will be required to have WordPress 4.9.8 installed to follow this procedure. Even if you<br/>
have a later version of WordPress, the described examples should work with no significant problems.</p>
<p class="mce-root">The code files of this chapter can be found on GitHub:<br/>
<a href="https://github.com/PacktPublishing/WordPress-Development-Quick-Start-Guide/tree/master/Chapter07">https://github.com/PacktPublishing/WordPress-Development-Quick-Start-Guide/tree/master/Chapter07</a></p>
<p class="mce-root">Check out the following video to see the code in action:<br/>
<a href="http://bit.ly/2AyINar" target="_blank">http://bit.ly/2AyINar</a></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Introduction to custom post types</h1>
                </header>
            
            <article>
                
<p>Custom post types were introduced in WordPress 3.0 as a solution for managing different content needs beyond the default posts. However, the name <em>custom post types</em> is ambiguous as we may grasp it as a different type of normal posts. Ideally, we should consider it as a custom content type, as it provides features flexible enough to handle complex content types such as products, properties, and events. Custom post types are stored in the <kbd>wp_posts</kbd> table by default. Prior to the introduction of custom post types, we had to use a considerable amount of filters and conditions in code to keep different post types separate from each other. This might have been a nightmare for many developers when managing a number of different content types in the same site.</p>
<p>Introduction of custom post types has dramatically expanded the capabilities of WordPress as a framework for developing sites with advanced data requirements and logic. Modern themes and plugins have utilized these features to its maximum potential. Let’s take a look at some of the popular plugins that run based on custom post types:</p>
<ul>
<li><strong>WooCommerce</strong>: We already looked at the functionality of this plugin in <a href="40208ac9-c023-42b1-b48e-a368761b37a6.xhtml" target="_blank">Chapter 5</a>, <em>Extending Plugins with Addons, Filters and Actions</em>. WooCommerce is used as an eCommerce solution for selling products. This plugin uses five built-in custom post types for handling <strong>products</strong>, <strong>product variations</strong>, <strong>orders</strong>, <strong>refunds</strong>, and <strong>coupons</strong>. Also, we get a product specific template design in the frontend for the custom post type. You can use this plugin as one of the best examples for understanding the use of custom post types.</li>
<li><strong>The Events Calendar</strong>: This is a plugin that provides a calendar to create and manage your event-related details with built-in custom post types for <strong>events</strong>, <strong>organizers</strong>, and <strong>venues</strong>.</li>
<li><strong>bbPress</strong>: This is one of the most popular forum management plugins with built-in custom post types for <strong>forums</strong>, <strong>topics</strong>, and <strong>replies</strong>.</li>
</ul>
<p>As you can see, many popular plugins use multiple custom post types to build the plugin features. Using custom post types considerably simplifies the process, as well as makes plugins compatible with WordPress core features.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Why do we use custom post types for modeling data?</h1>
                </header>
            
            <article>
                
<p>The custom post type was a great addition to WordPress. But, we need to understand how it became so popular in such a short time span. The main reason is the ability to capture, store, and display advanced data needs without requiring considerable development effort. Let's take a look at the main features offered by custom post types to reduce the development time. In less than twenty lines of code, we can get a fully functional custom post type with all the following features:</p>
<ul>
<li><strong>Creating and updating data</strong>: Once a new custom post type is added, we get a screen for adding and editing data, similar to the normal post screens. The main content details are saved automatically with a click of a button, and hence we can avoid the need for building our own custom screens with forms. Consider the following screenshot, highlighting the built-in features:</li>
</ul>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-257 image-border" src="assets/93f48a31-5122-45e9-8506-66bfab7fdc4e.png" style="width:43.42em;height:23.58em;"/></p>
<ul>
<li class="CDPAlignLeft CDPAlign"><strong><span>F</span>lexible data list</strong>: Usually, building a data list with pagination requires considerable development time. With custom post types, we get a built-in list for each custom post type with pagination, search, filter, and delete capabilities. Also, we can easily change the database query to filter and display the default data list. Apart from these features, we also get a dropdown called <span class="packt_screen">Bulk Actions</span>, where we can execute built-in functionality on multiple records of a single custom post type. The most important feature is the ability to add our own actions and execute them on multiple records with a minimum custom code. <span>Consider the following screenshot, highlighting the built-in features:<br/></span></li>
</ul>
<p class="CDPAlignCenter CDPAlign"><span><img src="assets/684b7bda-8494-42fd-8a61-be06a6c068fb.png" style="width:44.67em;height:16.67em;"/></span></p>
<ul>
<li><strong>Built-in URL structure</strong>: We get a default URL structure for managing all screens of each custom post type. We can easily change the built-in URL structure while creating the custom post type. So, we can avoid the time needed for setting up our own URL structure and conditionally managing different screens.</li>
<li><strong>Custom field management</strong>: We can use the default custom fields feature of WordPress posts, where we can define a key and a value for each field. When we want more control over the custom fields, metaboxes can be used to add and manage custom fields in less development effort, compared to developing custom fields from scratch.</li>
<li><strong>Data categorization</strong>: Custom post types provides built-in taxonomy support for categorizing records of each post type. We have the ability to categorize new custom post type data as hierarchical categories or flat type tags based on the requirements. Apart from filtering, we also get default templates for these categorization pages. So, the data categorization process is extremely simple compared to usual custom development.</li>
<li><strong>Built-in templates</strong>: Building templates and displaying the data requires a considerable development effort. By default, custom post types use the built-in templates of the theme, and hence we don’t require any effort to display the data in basic form. Even with advanced requirements, we can just duplicate the default template and adjust it with minimum effort to include our design elements or custom data.</li>
</ul>
<p>These reasons may give you an idea about how custom post types became such a valuable feature in WordPress. Now, it's time to understand the process of using and developing custom solutions with these features.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Building an object-oriented plugin</h1>
                </header>
            
            <article>
                
<p>Up to this point, we created several plugins in previous chapters. However, we used the procedural approach, where we define the necessary hooks and functions directly inside the main plugin file or sub-files. As the website or application gets complex, we will have a hard time managing the development with the <span>procedural </span>method. So, we need a way to use best development practices and modularize the code into necessary classes. In this section, we are going to look at the basic structure for creating a plugin with object-oriented concepts. Let's consider the following code for the OOP-based plugin structure:</p>
<pre>if( !class_exists( 'WPQuick_CPT' ) ) {   <br/>  class WPQuick_CPT{   <br/>    private static $instance;<br/>    public static function instance() { <br/>      if ( ! isset( self::$instance ) &amp;&amp; ! ( self::$instance instanceof WPQuick_CPT ) ) {<br/>        self::$instance = new WPQuick_CPT();<br/>        self::$instance-&gt;setup_constants();<br/>        self::$instance-&gt;includes();<br/><br/>        add_action( 'admin_enqueue_scripts',array( self::$instance, 'load_admin_scripts' ),9);                <br/>        add_action( 'wp_enqueue_scripts',array( self::$instance,'load_scripts' ),9);                <br/>         <br/>        self::$instance-&gt;model_property= new WQCPT_Model_Property(); <br/>      }<br/>      return self::$instance;<br/>    }<br/>        <br/>    public function setup_constants() {<br/>      if ( ! defined( 'WQCPT_PLUGIN_DIR' ) ) {<br/>        define( 'WQCPT_PLUGIN_DIR', plugin_dir_path( __FILE__ ) );<br/>      }<br/>    }       <br/>    public function load_scripts(){ }   <br/>    public function load_admin_scripts(){ }  <br/>    private function includes() { <br/>      require_once WQCPT_PLUGIN_DIR . 'classes/class-wqcpt-model-property.php';<br/>    }<br/>  }<br/>}</pre>
<p>WordPress doesn't provide a recommended method or boilerplate to build the plugins using the object oriented method. So, it's the choice of the developers to use a technique that better suits them. The preceding structure is used by some of the exciting plugins, and it's also my personal preference as well. So, you can use it as a guide and build a better solution that suits your style.</p>
<p>We begin by checking the availability of the main plugin class and define the main class for the plugin. We will be using the main class to handle all other files as well as classes. Then, we define a variable to hold the instance of the class and use the <kbd>instance</kbd> function to generate an object from this class. This <kbd>static</kbd> function and the private <kbd>instance</kbd> variables make sure that we only have one instance of our plugin class. The <kbd>instance</kbd> function acts as the initialization point of our plugin, and hence we can include the necessary function calls, class initialization, and hooks inside this function.</p>
<p>We have two function calls to the <kbd>setup_constants</kbd> and <kbd>includes</kbd> functions, inside the <kbd>instance</kbd> function. These functions respectively define the constants required for the plugin features and add the plugin files using the PHP <kbd>require_once</kbd> function. As we develop complex plugins, we can have many such functions to separate these kinds of basic configurations for the plugin. Then, we can define all the <kbd>action</kbd> and <kbd>filter</kbd> hooks intended to be used throughout the plugin for configuration purposes. Here, we have used two actions for including the scripts and styles on the frontend and the backend of the website.</p>
<p>The next section should consist of the object creation for the main classes of the plugin. In this scenario, we only have one class, even though we will need many classes in advanced plugin development. We need to use the <kbd>self::$instance</kbd> object as we are within the <kbd>static</kbd> function. Finally, we return the instance of the main class.</p>
<p>This is the base structure for an object oriented type plugin. We can include all the main configurations and generic features within this class and use other classes to handle the business logic. Now, we need to initialize the main class by using the following code:</p>
<pre>add_action( 'plugins_loaded', 'wqcpt_plugin_init' );<br/>function wqcpt_plugin_init(){<br/>  global $wqcpt;<br/>  $wqcpt = WPQuick_CPT::instance();<br/>}</pre>
<p>We execute a callback function on the <kbd>plugins_loaded</kbd> action to make sure that all the plugins are loaded before we initialize the main class of our plugin. Also, this will be the location used to check the dependencies between other plugins when we are doing integrations or building addons. We call the <kbd>instance</kbd> function of the main <kbd>WPQuick_CPT</kbd> class and define the resulted instance as a <kbd>global</kbd> object. As you can see, now our plugin is simplified and well-structured compared to previous plugins, and only includes the generic things. The site-specific implementations will be handled by the other classes. Now, we are ready to develop the plugin to handle custom post type features.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Building custom post types for properties</h1>
                </header>
            
            <article>
                
<p>We can use custom post types to model any data in a wide range of business categories. In this chapter, we are going to build a property custom post type for real estate listing websites, to illustrate the use of custom post type features. In this section, we will develop features for creating custom post types, assigning custom taxonomies, and using custom fields. </p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Creating property custom post types</h1>
                </header>
            
            <article>
                
<p>First, we need to create a separate class for handing property-related features as we are using an object oriented plugin. So, create a new directory called <strong>classes</strong> inside the main plugin directory, and add a new file called <kbd>class-wqcpt-property.php</kbd>. Then, we need to include this file in our plugin and create an object to initialize the features. We need to add the following line inside the <kbd>includes</kbd> function of the <kbd>WPQuick_CPT</kbd> class to include the file:</p>
<pre>require_once WQCPT_PLUGIN_DIR . 'classes/class-wqcpt-model-property.php';</pre>
<p>Next, we need to create an object of this class by using the following line of code inside the <kbd>instance</kbd> function:</p>
<pre>self::$instance-&gt;model_property  = new WQCPT_Model_Property();</pre>
<p>Now, we have the ability to add the functionality into this class. WordPress provides a function called <kbd>register_post_type</kbd> to create new custom post types. This function takes a wide range of parameters to configure the post type for different requirements. This function should be called within the <kbd>init</kbd> action to prevent any unnecessary conflicts. Let's add the following lines of code to the constructor of the <kbd>WQCPT_Model_Property</kbd> class:</p>
<pre>$this-&gt;post_type   =  'wqcpt_property';<br/>add_action( 'init', array( $this, 'create_property_post_type' ) );</pre>
<p>In the first line, we add the post type key into a class variable to be reused inside all functions. Then, we use the <kbd>init</kbd> action to call the <kbd>create_property_post_type</kbd> function for creating a new post type. Since we are using a class, we need to call the function on a class object by using the <kbd>$this</kbd> instance. Now, we can take a look at the implementation of the <kbd>create_property_post_type</kbd> function:</p>
<pre>public function create_property_post_type() {<br/>  global $wqcpt; <br/>  $post_type = $this-&gt;post_type;<br/>  $singular_post_name = __( 'Property','wqcpt' );<br/>  $plural_post_name = __( 'Properties','wqcpt' );<br/><br/>  $labels = array(<br/>    'name' =&gt; sprintf( __( '%s', 'wqcpt' ), $plural_post_name),<br/>    'singular_name' =&gt; sprintf( __( '%s', 'wqcpt' ), $singular_post_name),<br/>    'add_new' =&gt; __( 'Add New', 'wqcpt' ),<br/>    'add_new_item' =&gt; sprintf( __( 'Add New %s ', 'wqcpt' ), $singular_post_name),<br/>  );<br/><br/>  $args = array(<br/>    'labels' =&gt; $labels,<br/>    'hierarchical' =&gt; true,<br/>    'description' =&gt; __( 'Property Description', 'wqcpt' ),<br/>    'supports' =&gt; array( 'title', 'editor' ),<br/>    'public' =&gt; true,<br/>    'show_ui' =&gt; true,<br/>    'show_in_menu' =&gt; true,<br/>    'show_in_nav_menus' =&gt; true,<br/>    'publicly_queryable' =&gt; true,<br/>    'exclude_from_search' =&gt; false,<br/>    'has_archive' =&gt; true,<br/>    'query_var' =&gt; true,<br/>    'can_export' =&gt; true,<br/>    'rewrite' =&gt; true<br/>  );<br/>  register_post_type( $post_type, $args );<br/>}</pre>
<p>We begin the function by defining the necessary variables for post type and labels. The next part of the code contains the labels array. We need to define each label, as WordPress will use the <strong>Post</strong> as the default label for all entries. It's not ideal to show the <strong>Post</strong> in messages when we are actually working with <strong>Properties</strong>. The next code section contains list of arguments for creating the post type. Let's discuss the most important settings and their role:</p>
<ul>
<li><strong>Hierarchical</strong>: Defines whether the new post type will act as a page or post. WordPress pages provides hierarchical capabilities where we can define parent pages, whereas posts has no hierarchy.</li>
<li><strong>Supports</strong>: This setting defines the allowed fields and features for the new post type. We have enabled post title and content for properties. We can also use values such as author, thumbnail, excerpt, trackbacks, custom-fields, comments, revisions, page-attributes, and post-formats for different features.</li>
<li><strong>Public</strong>: Defines how the new post type is visible to content creators and visitors. We can use <kbd>true</kbd> or <kbd>false</kbd> as values. Depending on the value for this setting, we will see changes in other settings such as <kbd>show_in_menu</kbd>, <span><kbd>show_ui</kbd>, and</span> <kbd>exclude_from_search</kbd>.</li>
<li><strong>Rewrite</strong>: Defines the rewrite rules status or settings for the post type. By default, it uses <kbd>$post_type</kbd> <span>as a slug. We can modify it by using a custom slug.</span></li>
</ul>
<div class="packt_infobox">More details about the available settings and their role in different combinations can be identified by using the documentation at <a href="https://codex.wordpress.org/Function_Reference/register_post_type">https://codex.wordpress.org/Function_Reference/register_post_type.</a></div>
<p>Finally, we call the <kbd>register_post_type</kbd> function to create the post type by passing post type slug and the list of arguments. Now, the property post type is registered with WordPress and you will see a new section called <span class="packt_screen">Properties</span> in the main WordPress menu. You can create a property and view it on the frontend using the property link. However, you will get a WordPress 404 page instead of the property details page. The reason is WordPress is not aware of the new URL structure of newly registered custom post types until we flush the rewrite rules. As we discussed in <a href="e452b581-f38d-4c95-8a41-0c9a54b26a57.xhtml" target="_blank">Chapter 6</a>, <em>Practical Usage of WordPress APIs</em>, we need to either manually update the rewrite rules by visiting the WordPress <span class="packt_screen">Settings</span> | <span class="packt_screen">Permalinks</span> section, or by flushing rewrite rules on plugin activation.  You can implement the activation handler for this plugin using the technique we discussed in previous chapter. Once rewrite rules are flushed, you will be able to see the property details page on the frontend with the layout of default posts.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Creating the property types taxonomy</h1>
                </header>
            
            <article>
                
<p>WordPress <strong>taxonomies</strong> are a way of grouping posts or custom post types. We already looked at taxonomies while discussing database tables and templates in previous chapters. In this section, we are going to look at how taxonomies fit into custom post types and their implementation. In this scenario, we are building a property listing site. We can use taxonomies to group properties based on the property type. Let's begin by adding the following action to the constructor of the <kbd>WQCPT_Model_Property</kbd> class:</p>
<pre>$this-&gt;property_category_taxonomy  = 'wqcpt_property_listing_type';<br/>add_action( 'init', array( $this, 'create_property_custom_taxonomies' ) );</pre>
<p>As with custom post types, we have to use the <kbd>init</kbd> action to register taxonomies for WordPress. Let's consider the implementation of the <kbd>create_property_custom_taxonomies</kbd> function:</p>
<pre>public function create_property_custom_taxonomies() {<br/>  $category_taxonomy = $this-&gt;property_category_taxonomy;<br/>  $singular_name = __('Property Listing Type','wqcpt');<br/>  $plural_name = __('Property Listing Types','wqcpt');<br/><br/>  register_taxonomy(<br/>    $category_taxonomy,<br/>    $this-&gt;post_type,<br/>    array(<br/>      'labels' =&gt; array(<br/>      'name' =&gt; sprintf( __( '%s ', 'wqcpt' ) , $singular_name),<br/>      'singular_name' =&gt; sprintf( __( '%s ', 'wqcpt' ) , $singular_name),<br/>      'search_items' =&gt; sprintf( __( 'Search %s ', 'wqcpt' ) , $singular_name),<br/>    ),<br/>    'hierarchical' =&gt; true,<br/>  )<br/> );<br/>}</pre>
<p>We start the function by defining the taxonomy and the necessary labels, similar to the custom post types. Then, we can call the <kbd>register_taxonomy</kbd> function with the necessary parameters to create the taxonomy for property types. Let's take a look at the parameters in detail:</p>
<ul>
<li><kbd>taxonomy</kbd>: This is the first parameter, where we have to pass the name for the taxonomy. We can only use lowercase letters and characters. We have specified it as <kbd>wqcpt_property_type</kbd>, with a prefix to make it unique from other plugins.</li>
<li><kbd>object type</kbd>: This is the second parameter, where we have to assign the post types that will use this taxonomy. In this scenario, we have specified <kbd>wqcpt_property</kbd> as the post type. We can use an array in scenarios where we have multiple post types. However, using a taxonomy in multiple post types makes archive pages as a mix of different post type entries. It might be difficult to handle archive pages with multiple post types due to different designs and data. So, it's ideal to use separate taxonomies for each post type, unless all post types contain similar design and data in archive pages.</li>
<li><kbd>arguments</kbd>: This is the third parameter where we can pass different settings from the list of available options. In this scenario, we have used the <strong>labels</strong> for property listing types and <strong>hierarchical</strong> options. The <strong>hierarchical</strong> setting defines whether the taxonomy should act as a <strong>tag</strong> or <strong>category</strong>. The default value is <kbd>false</kbd>, making it act as a <strong>tag</strong>. We have used it as a <strong>category</strong> by setting it to <strong>true</strong>. There are many other settings similar to the custom post type registration process. You can view more details about all the available arguments at <a href="https://codex.wordpress.org/Function_Reference/register_taxonomy">https://codex.wordpress.org/Function_Reference/register_taxonomy</a>.</li>
</ul>
<div class="packt_tip">The choice of category against tag for taxonomies depends on your requirements. Generally, we use categories when we want to have different sub-levels as well as when have a fixed set of primary options. Tags don't provide sub-levels and usually use a dynamic set of values to explain the data. In this scenario, property listing types have predefined options such as Sale, Rent, and Mortgage. Therefore, we choose category over tags for property listing types.</div>
<p>Once this code is used, you will see a new taxonomy added to the <span class="packt_screen">Property</span> menu. You can create properties and assign property listing types to categorize the properties based on your needs. In real-world requirements, you have to match the taxonomy needs of each custom post type with categories or tags depending on the functionality.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Managing custom fields for custom post types</h1>
                </header>
            
            <article>
                
<p>In normal posts, we rarely use custom fields as the primary feature is displaying content in the WordPress editor along with featured images, tags, and categories. However, custom post type implementations require a considerable amount of data beyond the content in the WordPress editor. So, we need a way to handle the custom data for each custom post type. We can use the default post custom fields feature to store the data in the <kbd>wp_postmeta</kbd> table. Let's consider the custom field requirements of a property listing site:</p>
<div class="packt_quote">The property listing sites require a large amount of custom data, along with the property title and the main property content through the WordPress editor. We can match some of the property data such as property listing type as categories. However, the majority of the data needs to be handled using custom fields. Such data includes fields such as city, property type, area, price, year, property plans, and so on.</div>
<p>In this section, we are going to add some custom property fields to understand the process of adding and using custom fields in custom post types. Let's start by adding a metabox to define custom fields similar to the technique we used in the <em>post attachments</em> plugin. We need to update the constructor of <kbd>WQCPT_Model_Property</kbd> with the following action:</p>
<pre>add_action( 'add_meta_boxes', array( $this, 'add_property_meta_boxes' ) );</pre>
<p>Now, we have to define the metabox and implement the function for displaying the content of the metabox using the following code inside the <kbd>WQCPT_Model_Property</kbd> class:</p>
<pre>public function add_property_meta_boxes() {<br/>  add_meta_box( 'wqcpt-property-meta', __('Property Details','wqcpt' ), array( $this, 'display_property_meta_boxes' ), $this-&gt;post_type );<br/>}<br/><br/>public function display_property_meta_boxes( $property ) {<br/>  global $wqcpt,$template_data;<br/><br/>  $template_data['property_post_type'] = $this-&gt;post_type;<br/>  $template_data['property_nonce'] = wp_create_nonce('wqcpt-property-meta');<br/>  $template_data['wqcpt_pr_type'] = get_post_meta( $property-&gt;ID, '_wqcpt_pr_type', true );<br/>  $template_data['wqcpt_pr_city'] = get_post_meta( $property-&gt;ID, '_wqcpt_pr_city', true );<br/> <br/>  ob_start();<br/>  $wqcpt-&gt;template_loader-&gt;get_template_part( 'property','meta');<br/>  $display = ob_get_clean();<br/>  echo $display;<br/>}</pre>
<p>We already discussed the use of the <kbd>add_meta_box</kbd> function in the post attachments plugin and how to use a callback function to generate the content. In the post attachments plugin, we used HTML within PHP variables to generate the output. This is not ideal in large projects as it's hard to manage the output within quotes as well as provide extendable capabilities for templates. In the MVC pattern, we use a separate layer for the template called <strong>Views</strong>.</p>
<div class="mce-root packt_quote"><strong>Model–view–controller</strong> also known as <strong>MVC</strong> is an architectural pattern commonly used for developing user interfaces that divides an application into three interconnected parts. The MVC design pattern decouples these major components, allowing for efficient code reuse and parallel development.</div>
<div class="mce-root packt_quote CDPAlignRight CDPAlign">– Source : <a href="https://en.wikipedia.org/wiki/Model-view-controller">https://en.wikipedia.org/wiki/Model-view-controller</a></div>
<p>Similarly, we have to separate the template code as much as possible to allow the possibility of future enhancements.</p>
<p>So, we define a global variable called <kbd>$template_data</kbd> to keep the necessary data for the template used in this function. Then, we assign the post type, nonce value, and the property data to the <kbd>$template_data</kbd> array. We use the <kbd>wp_postmeta</kbd> table to store the custom field details for properties. Therefore, we can use the <kbd>get_user_meta</kbd> function to get the existing property values to be passed to the template. Initially, these functions will return empty strings until we save the data for the first time. Then, we have to use a template loader to load the template for property custom fields.</p>
<p>In this section, we have used our own template loader. You can refer to the <kbd>classes/class-wqcpt-template-loader.php</kbd> file inside the source code directory of our plugin for the implementation. This class is included in the main file of our plugin and the object is created within the <kbd>instance</kbd> function. The basic functionality of this class is to include PHP files from the templates directory of our plugin. Those developers who are familiar with using Template Engines such <strong>Twig</strong>, <strong>Smarty</strong>, <strong>Mustache</strong> in pure PHP projects may think of this as a similar technique. However, this is just basic PHP file inclusion with template code, and hence doesn't provide any advantages provided by Template Engines.</p>
<div class="packt_infobox">We can use PHP Template Engines in WordPress plugins with bit of additional development work. However, most plugins including the popular plugins don't use Template Engines and are restricted to template loading as PHP files.</div>
<p>In this function, we have called the <kbd>ob_start</kbd> function to start the template loading process. This function is used to switch on output buffering, allowing us only to send the necessary content to the browser. Next, we access the object of the template loader class by using the global <kbd>$wqcpt</kbd> instance of our plugin, and call the <kbd>get_template_part</kbd> function. We have passed two strings called <kbd>property</kbd> and <kbd>meta</kbd> to this function. So, we need to have a template file called <kbd>property-meta.php</kbd> inside the templates directory of our plugin. Then, we use the <kbd>ob_get_clean</kbd> function to get the template and clean the output buffer. Finally, we use the <kbd>echo</kbd> statement to send the content to the browser. The next step in the process is to build the template and use the data specified for the template.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Building the property fields template</h1>
                </header>
            
            <article>
                
<p>We need to begin the process by creating a new directory called <kbd>templates</kbd> inside the plugin and a new file called <kbd>property-meta.php</kbd> inside the directory. This file should produce the custom fields to capture property data while keeping the amount of PHP code and logic to a minimum. Let's take a look at the implementation of the template for property custom fields:</p>
<pre>&lt;?php<br/>  global $template_data;<br/>  extract($template_data);<br/>?&gt;<br/><br/>&lt;input type="hidden" name="property_nonce" value="&lt;?php echo $property_nonce; ?&gt;" /&gt;<br/>&lt;table class="form-table"&gt;<br/>  &lt;tr&gt;<br/>    &lt;th style=''&gt;&lt;label&gt;&lt;?php _e('Status','wqcpt'); ?&gt;*&lt;/label&gt;&lt;/th&gt;<br/>    &lt;td&gt;&lt;select class='widefat' name="wqcpt_pr_type" id="wqcpt_pr_type"&gt;<br/>      &lt;option &lt;?php selected( $wqcpt_pr_type, '0' ); ?&gt; value='0' &gt;&lt;?php _e('Please Select','wqcpt'); ?&gt;&lt;/option&gt;<br/>      &lt;option &lt;?php selected( $wqcpt_pr_type, 'house' ); ?&gt; value='house' &gt;&lt;?php _e('House','wqcpt'); ?&gt;&lt;/option&gt;<br/>      &lt;option &lt;?php selected( $wqcpt_pr_type, 'office' ); ?&gt; value='office' &gt;&lt;?php _e('Office','wqcpt'); ?&gt;&lt;/option&gt;<br/>         &lt;/select&gt;&lt;/td&gt;<br/>  &lt;/tr&gt;<br/>  &lt;tr&gt;<br/>    &lt;th style=''&gt;&lt;label&gt;&lt;?php _e('City','wqcpt'); ?&gt;&lt;/label&gt;&lt;/th&gt;<br/>    &lt;td&gt;&lt;input class='widefat' name='wqcpt_pr_city' id='wqcpt_pr_city' type='text' value='&lt;?php echo $wqcpt_pr_city; ?&gt;' /&gt;&lt;/td&gt;<br/>  &lt;/tr&gt; <br/>&lt;/table&gt;</pre>
<p><span>Let's understand the implementation of the property fields template using the following steps:</span></p>
<ol>
<li>We begin the template by using the global <kbd>$template_data</kbd> array and extracting the values passed as template data.</li>
<li>Then, we have to add the HTML fields for keeping the nonce value and property data. In the preceding code, we have limited the fields to city and property type for explanation purposes.</li>
<li>Next, we have to use the data passed from <kbd>WQCPT_Model_Property</kbd> to load the existing values for these fields.</li>
</ol>
<p>Now, our template is ready. You can create or edit a property to see the property custom fields, as shown in the following screenshot:</p>
<p class="mce-root CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-262 image-border" src="assets/aef3ed3c-d210-49ee-9810-cc788749a7a0.png" style="width:46.17em;height:25.00em;"/></p>
<p>We can use this technique to group all the property fields in a single metabox or use multiple metaboxes to hold related fields. Also, we can change the location and priority of the metabox in the property screen.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Saving property custom fields</h1>
                </header>
            
            <article>
                
<p>We set up a property as a custom post type and hence the main property details will be saved automatically on property publication or update events. However, custom field data will not be saved in this process, and hence we need a custom implementation to store these data. We have chosen to store the custom field data in the <kbd>wp_postmeta</kbd> table. Let's look at the process of saving custom fields using the WordPress <kbd>save_post</kbd> action. First, we need to add the following line of code to the constructor of the <kbd>WQCPT_Model_Property</kbd> class:</p>
<pre>add_action( 'save_post', array( $this, 'save_property_meta_data' ) );</pre>
<p>This action is triggered whenever we create or update a post or custom post type. Now, we have to implement the callback function with the following implementation:</p>
<pre>public function save_property_meta_data( $post_id ) {<br/>  global $post,$wqcpt;<br/>  if (   isset($_POST['property_nonce']) &amp;&amp;  ! wp_verify_nonce($_POST['property_nonce'], 'wqcpt-property-meta')){<br/>    return $post_id;<br/>  }<br/>  if ( defined('DOING_AUTOSAVE') &amp;&amp; DOING_AUTOSAVE ) {<br/>    return $post_id;<br/>  }<br/><br/>  if (  isset($_POST['post_type']) &amp;&amp;  $this-&gt;post_type == $_POST['post_type'] &amp;&amp; current_user_can( 'edit_post', $post-&gt;ID ) ) {<br/><br/>    $wqcpt_pr_type = isset( $_POST['wqcpt_pr_type'] ) ? sanitize_text_field( trim($_POST['wqcpt_pr_type']) ) : '';<br/>    $wqcpt_pr_city = isset( $_POST['wqcpt_pr_city'] ) ? sanitize_text_field( trim($_POST['wqcpt_pr_city']) ) : ''; <br/>    update_post_meta( $post_id, '_wqcpt_pr_type', $wqcpt_pr_type );<br/>    update_post_meta( $post_id, '_wqcpt_pr_city', $wqcpt_pr_city );<br/>  } else {<br/>    return $post_id;<br/>  }<br/>}</pre>
<p>We begin the function by verifying the nonce value assigned to the template. We can just return the post ID on verification failures. Next, we have to apply another validation for checking the autosave. WordPress autosave features periodically save the post content automatically. We don't need to update the custom field values on each autosave. So, the validation only allows the function to process when the user is manually saving the post. The next validation is the most important one since this action is executed on all post types in WordPress.</p>
<p>We have to make sure we use the action only in necessary post types to avoid unnecessary conflicts. So, we check if a property is being saved and the current user has the permission to save properties by using the <kbd>current_user_can</kbd> function. We didn't assign property-specific capabilities in custom post type registration. Therefore, we have to check for the default post edit permission. Once all the validations are completed, we can retrieve and sanitize the values from the POST request. Finally, we use the <kbd>update_post_meta</kbd> function to save each property field to the <kbd>wp_postmeta</kbd> table.</p>
<p>We have the completed the functionality of managing properties from the backend. Now, you should be able to create properties with custom field data and display that data in edit property screens. Once created, you can view the properties from the frontend by using the property link.</p>
<div class="packt_infobox">The theme will use the default <kbd>single.php</kbd> template to display the property. Since we need to display additional property-related fields, we can create a template inside the theme or use our plugin to load a template for handling a single property page.</div>
<p>In this scenario, we used two property fields with basic field types. In real applications, you will have to use more complex fields such as dates, maps, searchable dropdowns, color pickers, and so on. So, manually building custom fields may become an issue for most startup sites with lower development time frames. In such scenarios, we can use custom post type plugins that act as a framework for managing custom fields without the need for manual coding. Let's take a look at some of the custom post type plugins that offer wide range of custom field types:</p>
<ul>
<li><strong>Toolset Types</strong><span>: This plugin lets you manage custom post types, custom taxonomies, and custom fields without needing any coding. This plugin offers over 20 built-in custom field types. Built-in interfaces allow you to manage custom fields by providing the necessary settings. More details about the features can be viewed from the plugin page at </span><a href="https://wordpress.org/plugins/types/">https://wordpress.org/plugins/types/</a>.<a href="https://wordpress.org/plugins/types/"/></li>
<li><strong>Pods</strong><span>: This plugin also offers the same set of features, along with the ability to connect multiple custom post types. This plugin offers around 10 custom field types to manage the fields of each custom post type using existing screens. </span><span>More details about the features can be viewed from the plugin page at <a href="https://wordpress.org/plugins/pods/">https://wordpress.org/plugins/pods/</a>.</span></li>
<li><strong>Metabox</strong><span>: Compared to the other two plugins, this one mainly focuses on managing custom fields by allowing you to add them to metaboxes in the post creation screen. This plugin provides over 40 built-in field types covering a wide range of areas. </span><span>More details about the features can be viewed from the plugin page at </span><span><a href="https://wordpress.org/plugins/types/">https://wordpress.org/plugins/types/.</a></span></li>
</ul>
<p>These plugins are useful for sites that require rapid development process and gives less priority for flexibility and the extendability of the features.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Limitations of storing data as meta values</h1>
                </header>
            
            <article>
                
<p>We use the post meta table in most occasions to store custom data related to different custom post types. However, as the meta tables gets larger, it will be difficult to manage all the meta values. The site will get slower, creating major performance issues. So, we have to consider this limitation when planning the site in the initial stages. Once the posts meta table is used, it's difficult to migrate to a custom solution in later stages, especially when we decide to use custom post type plugins to manage the custom fields.</p>
<p>So, using the post meta table to store custom field data is ideal for small- to medium-scale sites where the posts and post meta tables won't get overloaded with data. In advanced applications, we should consider using a custom table for the custom fields, while using the posts table for the main details of a custom post type item.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Introduction to form management</h1>
                </header>
            
            <article>
                
<p>The majority of WordPress sites consist a of few pages about the site, services, or products while having a blog. Among the rest, a high percentage of sites focus on capturing, processing, and displaying user data. So, form management becomes an important aspect in WordPress development. The forms are mostly used as a data capturing method on the frontend, as we use custom post types to capture data in the backend. We can develop our own custom forms in the frontend, or we can automate the process of managing forms by using an existing form management plugin. The choice between custom forms and form plugins depends on the requirements of the site. Let's take a look at the advantages and disadvantages of using these two methods.</p>
<ul>
<li><strong>Development time</strong>: Form plugins provide a rapid development process with drag-and-drop form creation, while handling all the form field features through configurations. On the other hand, custom forms require considerable development effort and the changes to existing fields require modifications in code.</li>
<li><strong>Database usage</strong>: Each existing forms plugin is restricted to using the <kbd>wp_postmeta</kbd> table or a single custom table, whereas custom forms can be developed to use either technique according to our preference, while keeping different form data in different tables.</li>
<li><strong>Extendability</strong>: Building custom forms enables the possibility of keeping the features open for future enhancements. On the other hand, we will have to work with the limitations of forms plugins when considering the future enhancements of advanced sites.</li>
<li><strong>Consistency in design</strong>: We can create our own custom form designs to match the styles of the theme. However, existing plugins may not provide 100% flexibility in modifying the design to match the theme styles.</li>
</ul>
<p>Due to these reasons, we should carefully choose the development method for custom forms depending on the requirements of each site. Once we complete the upcoming sections on form management, you will have a better idea about the process for making correct decisions. </p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Building custom forms in the frontend</h1>
                </header>
            
            <article>
                
<p>We have several ways of adding forms to the frontend of a WordPress website. In this section, we are going to discuss two methods used by popular plugins to add forms:</p>
<ul>
<li>Adding forms using shortcodes</li>
<li>Loading forms using custom URLs</li>
</ul>
<p>We will be implementing both techniques, starting with the shortcode method.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Adding forms using a shortcode</h1>
                </header>
            
            <article>
                
<p>This is one of the most popular methods used by many popular plugins to add data capturing forms to a site. In this method, we use a shortcode to generate the HTML for the form. Then, we add the shortcode to a WordPress post or page and let users access it through the post or page. This is the ideal technique for basic to intermediate level features, where the use of the form doesn't play a critical part in the functionality of the site.</p>
<div class="packt_tip">Using shortcode is one of the simplest methods to add a form. However, shortcodes are added to post or page and hence administrators can accidentally delete the page or break the shortcode by mistake. Therefore, it should not be used for advanced sites where the functionality of shortcode is critical. For example, consider a registration form in a basic social network site. The unavailability of the registration page for a limited time is not a major issue since the people register for free to share their activities. However, consider a registration form in a support forum of a site that provides a time-critical service. In such sites, unavailability of registration for even few hours is not acceptable and affects the user. So, we shouldn't use shortcode-based forms in such sites, or prevent modification access to the pages with shortcodes .</div>
<p>In the previous section, we used custom post types to manage the property details in the backend. Now, we need to add the property creation capabilities to the frontend. Let's use the following line of code inside the constructor of the <kbd>WQCPT_Model_Property</kbd> class to define a shortcode for the property form:</p>
<pre>add_shortcode( 'wqcpt_property_form', array( $this, 'display_property_form' ) );</pre>
<p>Next, we need to implement the callback function to display a property creation form in the frontend. Let's consider the implementation of the <kbd>display_property_form</kbd> function:</p>
<pre>public function display_property_form( $atts, $content ){<br/>  global $wqcpt,$template_data;<br/>  $template_data['property_nonce'] = wp_create_nonce('wqcpt-property-meta');<br/><br/>  ob_start();<br/>  $wqcpt-&gt;template_loader-&gt;get_template_part( 'property','form');<br/>  $display = ob_get_clean();<br/>  return $display;<br/>}</pre>
<p>The implementation of this function is similar to the <kbd>display_property_meta_boxes</kbd> function we used in the backend custom post types. In this scenario, this form is only used for property creation and hence we don't have to pass the existing data as template variables. We use a different template called <kbd>property-form.php</kbd> for the frontend custom form. Now, we can have a look at the implementation of the <kbd>property-form.php</kbd> template:</p>
<pre>&lt;?php<br/>  global $template_data;<br/>  extract($template_data); ?&gt;<br/>&lt;form action="" method="POST" &gt;<br/>  &lt;input type="hidden" name="property_nonce" value="&lt;?php echo $property_nonce; ?&gt;" /&gt;<br/>  &lt;table class="form-table"&gt;<br/>    &lt;tr&gt;<br/>      &lt;th&gt;&lt;label&gt;&lt;?php _e('Property Title','wqcpt'); ?&gt;*&lt;/label&gt;&lt;/th&gt;<br/>      &lt;td&gt;&lt;input type="text" name="wqcpt_prfr_title" id="wqcpt_prfr_title" value="" /&gt;&lt;/td&gt;<br/>    &lt;/tr&gt;<br/>    &lt;tr&gt;<br/>      &lt;th&gt;&lt;label&gt;&lt;?php _e('Property Content','wqcpt'); ?&gt;*&lt;/label&gt;&lt;/th&gt;<br/>      &lt;td&gt;&lt;textarea name="wqcpt_prfr_content" id="wqcpt_prfr_content" &gt;&lt;/textarea&gt;&lt;/td&gt;<br/>    &lt;/tr&gt;<br/>    &lt;!—HTML for other custom fields --&gt;<br/>    &lt;tr&gt;<br/>      &lt;th&gt;&amp;&lt;/th&gt;<br/>      &lt;td&gt;&lt;input name="wqcpt_prfr_submit" id="wqcpt_prfr_submit" type="submit" value="&lt;?php _e('Add Property','wqcpt'); ?&gt;" /&gt;&lt;/td&gt;<br/>    &lt;/tr&gt;<br/>  &lt;/table&gt;<br/>&lt;/form&gt;</pre>
<p>The structure of the template is exactly same as the previous scenario on backend. However, we have two additional fields for property title and content, along with a form and a submit button. In custom post types, we had the title and content as built-in fields. We also used the built-in post form and the <span class="packt_screen">Publish</span> or <span class="packt_screen">Update</span> buttons. On the frontend, we don't have any built-in features, and hence we have to add them manually. Once the shortcode is added to a page, the property creation form will look similar to the following screen:</p>
<div class="packt_figref CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-261 image-border" src="assets/7063ec2e-ca14-4360-bad5-53269c77972c.png" style="width:31.00em;height:18.50em;"/></div>
<p>Now, we come to the final part where we create the property on the submission of the form.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Creating properties using custom forms</h1>
                </header>
            
            <article>
                
<p>In backend custom post types, we were only coding the custom field saving part, and hence we were able to use the <kbd>save_post</kbd> action to handle the process. In the frontend, we have to build the process from scratch and hence the <kbd>init</kbd> action is the ideal hook for the implementation. Let's add the following line of code to the constructor of our <kbd>WQCPT_Model_Property</kbd> class:</p>
<pre>add_action( 'init', array( $this, 'save_property_form' ) );</pre>
<p>Next, we can take a look at the implementation of the <kbd>save_property_form</kbd> function, as shown in the following code:</p>
<pre>public function save_property_form() {<br/>  global $post,$wqcpt;<br/>  if( ! isset( $_POST['wqcpt_prfr_submit'] ) ){<br/>    return;<br/>  }<br/><br/>  if ( !wp_verify_nonce($_POST['property_nonce'], 'wqcpt-property-meta' ) || ! current_user_can( 'edit_post' ) ) {<br/>    // Handle error<br/>  }<br/><br/>   $wqcpt_prfr_title = isset( $_POST['wqcpt_prfr_title'] ) ? sanitize_text_field( trim($_POST['wqcpt_prfr_title']) ) : '';<br/>   $wqcpt_prfr_content = isset( $_POST['wqcpt_prfr_content'] ) ? wp_kses_post( trim($_POST['wqcpt_prfr_content']) ) : '';<br/>   $wqcpt_pr_type = isset( $_POST['wqcpt_prfr_type'] ) ? sanitize_text_field( trim($_POST['wqcpt_prfr_type']) ) : '';<br/>   $wqcpt_pr_city = isset( $_POST['wqcpt_prfr_city'] ) ? sanitize_text_field( trim($_POST['wqcpt_prfr_city']) ) : '';<br/><br/> // Validations and generate errors<br/> // post fields and existence of a post<br/> // Rest of the code for saving data<br/>}</pre>
<p>We begin the function by using an <kbd>if</kbd> condition to check the availability of the <span class="packt_screen">Submit</span> button in the frontend post creation request, to make sure our code is executed only for the frontend property creation form. Next, we use another conditional check for the nonce value and property creation permissions. In the custom post types section, we executed the permission check by passing the post ID, as we were only saving the custom fields for an already-created property. In this scenario, we are creating a property from scratch, and hence we don't have a post ID yet. So, we can only check for general post editing permissions.</p>
<div class="packt_tip">Once permission errors are generated, we can assign the error messages to a class variable and use it inside the shortcode function to display them.</div>
<p>Once validations are completed, we can retrieve the property data from the <kbd>POST</kbd> request and sanitize it before assigning to necessary variables. Here, we have used a function called <kbd>wp_kses_post</kbd> on the property content. This function sanitizes the content to only keep the allowed tags in WordPress post content by default. Next, we have to validate the data retrieved from the <kbd>POST</kbd> request and generate the errors to be displayed inside the shortcode. Now, we can take a look at the rest of the code for this function:</p>
<pre>$post_id = wp_insert_post(<br/>             array(<br/>               'post_author' =&gt; get_current_user_id() ,<br/>               'post_name' =&gt; sanitize_title( $wqcpt_prfr_titley ),<br/>               'post_title' =&gt; $wqcpt_prfr_title,<br/>               'post_status' =&gt; 'publish',<br/>               'post_content' =&gt; $wqcpt_prfr_content,<br/>               'post_type' =&gt; $this-&gt;post_type<br/>             )<br/>         );<br/><br/>if ( !is_wp_error( $post_id ) ) {<br/>  update_post_meta( $post_id, '_wqcpt_pr_type', $wqcpt_pr_type );<br/>  update_post_meta( $post_id, '_wqcpt_pr_city', $wqcpt_pr_city );<br/>} else {<br/> // Handle errors<br/>}</pre>
<p>After validating all the property data, we use the <kbd>wp_insert_post</kbd> function to create the property on the <kbd>wp_posts</kbd> table. We can pass all the necessary settings as an array to this function. Here, we have used author as the current logged-in user. Then, we assign the property title and content to the respective settings while generating the URL for the post using the <kbd>sanitize_title</kbd> function. Finally, we set the correct post type and status as publish. This is a built-in function that creates posts while executing all the necessary filters and actions inside WordPress core. In case we use our own query to save the properties, we have to check and execute all the necessary filters and actions to make our feature compatible with other plugins. This function will return <kbd>true</kbd> or WordPress error based on the status of the execution. Next, we can check the errors and use the <kbd>update_post_meta</kbd> function to save the property custom fields to the <kbd>wp_postmeta</kbd> table.</p>
<div class="packt_tip">We can easily use frontend forms to store custom field data on custom database tables for additional flexibility. In such cases, we just have to replace the <kbd>wp_insert_post</kbd> function with a custom query and necessary data.</div>
<p>Now, we have completed the process of adding data using frontend forms, and you should be able to test the process by assiging the shortcode to a post or page and submitting the form with necessary data.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Loading forms using custom URLs</h1>
                </header>
            
            <article>
                
<p>We already discussed the concept behind this technique in <a href="e452b581-f38d-4c95-8a41-0c9a54b26a57.xhtml" target="_blank">Chapter 6</a>, <em>Practical Usage of WordPress APIs</em>, <em>Rewrite API</em> section. The shortcode method is not highly reliable for advanced web sites. So, we create our own URL structures and handle the forms using those custom URLs instead of using post, page, or custom post type. Since we already discussed this technique, we are going to go through the code without major explanations. Let's start by adding a new rewrite rule and a query parameter to handle frontend property creation:</p>
<pre>add_action( 'init', 'wqcpt _manage_property_routes' );<br/>function wqcpt_manage_property_routes() {<br/>  add_rewrite_rule( '^property-listing/([^/]+)/?', 'index.php?wpquick_property_actions=$matches[1]', 'top' );<br/>  add_rewrite_tag('%wpquick_property_actions%', '([^&amp;]+)');<br/>}</pre>
<p>This code adds new rewrite rule accessible through <a href="http://www.example.com/property-listing/add">http://www.example.com/property-listing/add</a> for creating properties from frontend custom forms. We also use a tag called <kbd>wpquick_property_actions</kbd> to identify the functionality for properties. Ideally, we need to include this code within the main class of our plugin to keep the object oriented nature of our plugin. However, we discussed the need to flush rewrite rules on activation. So, there is a conflict since our plugin is initialized on the <kbd>plugins_loaded</kbd> action, and the activation handler is executed before that action. Therefore, we have to use the preceding code outside the main class of the plugin, along with the activation handler. The following code contains the activation handler for this plugin:</p>
<pre>register_activation_hook( __FILE__, 'wqcpt_activate' );<br/>function wqcpt_activate(){<br/>  wqcpt_manage_property_routes();<br/>  flush_rewrite_rules(); <br/>}</pre>
<p>As we did in <a href="e452b581-f38d-4c95-8a41-0c9a54b26a57.xhtml" target="_blank">Chapter 6</a>, <em>Practical Usage of WordPress APIs</em>, we register the rewrite rules on the activation handler, just before calling the <kbd>flush_rewrite_rules</kbd> function. Next, we need to filter the URL and load the custom form for creating properties. We use the built-in <kbd>template_redirect</kbd> action for this functionality, and we can include the action inside the <kbd>WQCPT_Model_Property</kbd> class, as shown in the following code:</p>
<pre>public function property_controller() {<br/>  global $wp_query,$wqcpt,$template_data;<br/>  $wpquick_actions = isset ( $wp_query-&gt;query_vars['wpquick_property_actions'] ) ? $wp_query-&gt;query_vars['wpquick_property_actions'] : '';<br/><br/>  switch ( $wpquick_actions ) {<br/>    case 'add':<br/>      $template_data['property_nonce'] = wp_create_nonce('wqcpt-property-meta');<br/><br/>      ob_start();<br/>      $wqcpt-&gt;template_loader-&gt;get_template_part( 'property','form' );<br/>      $display = ob_get_clean();<br/>      echo get_header();<br/>      echo $display;<br/>      echo get_footer();<br/>      exit;<br/>      break;<br/>  }<br/>}</pre>
<p>First, we receive the value of <kbd>wpquick_property_actions</kbd> using WordPress query variables. Then, we use a <kbd>switch</kbd> statement to filter different actions for properties. In this scenario, we have only used <kbd>add</kbd> as a filter. In complete implementation, we will have to include <kbd>edit</kbd>, <kbd>delete</kbd>, and <kbd>list</kbd> actions at a minimum. Inside the <kbd>add</kbd> case, we load the same template we used for the shortcode process. Then, we include it between the header and footer of the site to display the frontend form. Now, you should be able to access and create properties by visiting <kbd>www.example.com/property-listing/add</kbd> in the browser URL.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Choosing between custom post types and custom forms</h1>
                </header>
            
            <article>
                
<p>We looked at the features and process of both custom post types and custom forms in the previous sections. We started this chapter by discussing the custom post type features that have changed the way we develop with WordPress. Now, we can compare them with custom forms, and identify the advantages and disadvantages. Let's start by looking at the advantages of custom post types.</p>
<p>You may have already noticed the amount of coding we needed to get to display a custom form and use it for capturing data. We didn’t spent even half of the time doing the same thing with custom post types. Let's summarize the additional things we had to do in custom form development, compared to custom post types:</p>
<ul>
<li><strong>Creating fields for title and content</strong>: We had a built-in title field and content field with Rich Text Editor in custom post types, whereas we had to create two new fields to handle them in custom forms.</li>
<li><strong>Adding a form and submit button</strong>: We didn't need to add a form or submit button in custom post types as we were using the built-in post functions of WordPress.</li>
<li><strong>Saving the property</strong>: We didn't have to create the property and save the main details in custom post types as it was done automatically by the WordPress core process.</li>
<li><strong>Handing property validations</strong>: In custom post types, all the necessary validation on main property data is handled by core features. However, we need to check the existence of the property, URL, and make sure to sanitize the property content manually.</li>
<li><strong>Post editing and listing</strong>: We have the ability to edit, list, or delete a post as soon as we create one using backend custom post types. However, we only built the create form using the custom form, and hence we have to develop edit, list, and delete features from scratch using more custom forms.</li>
</ul>
<p>So, in this perspective, built-in custom post types offer a lot more advantages over custom forms. <span>Here are the advantages of using custom forms over custom post types</span>:</p>
<ul>
<li><strong>Frontend interfaces</strong>: Custom post types doesn't offer the data capturing features on the frontend and hence users need to be redirected to the backend. So, we can't match the forms with the styles of themes, whereas custom forms allow us to create any type of design. This also means we will have to manage the permission to other menu items in the backend.</li>
<li><strong>Mix of frontend and backend</strong>: When using custom forms, we can let users use the other site features as well as data submissions within the frontend, allowing users to have a consistent set of screens. However, using custom post types means that the user will have to switch between the frontend and backend of the site, creating unnecessary complexity.</li>
<li><strong>Flexibility in validations</strong>: WordPress automatically saves custom post types using the autosave feature and hence we can’t wait for the custom post creation, until custom validations are completed. So, we have to use some workarounds to validate custom fields and display the error messages, while keeping the post type record inaccessible. In custom forms, we can have the complete freedom for data validation before we actually create the record on the <kbd>wp_posts</kbd> table.</li>
<li><strong>Flexibility in using database tables</strong>: In backend custom post types, the newly created post always saves to the <kbd>wp_posts</kbd> table. However, in custom forms we can decide whether to use existing tables or use our own custom tables for managing data.</li>
</ul>
<p>By considering the advantages and disadvantages of each technique, we can come to a conclusion that backend custom post types are mostly suitable for sites with low budget and require a rapid development process. Also, we can consider custom post types when basic functionality is more important than flexibility. On the other hand, custom forms can be used for advanced sites, where performance is crucial and requires flexibility for future enhancements.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Using a form management plugin</h1>
                </header>
            
            <article>
                
<p>We looked at the use of custom post types and custom forms for capturing and displaying the data needed for WordPress sites. However, many startup sites don't have the budget or time to develop a custom solution specific for their sites. So, developers will have to use existing solutions and build the features on top of them. In such cases, WordPress form plugins become the ideal solution. There are some popular form plugins developed to cater a specific area, such as contact forms. We can also find forms plugins such as Gravity Forms, Ninja Forms developed to cater any purpose. Let's understand the features expected from a quality forms plugin:</p>
<ul>
<li><strong>Drag and drop builder</strong>: This is the feature that accelerates the development of custom forms with existing plugins. Instead of writing own HTML for each field, we should be able to drag and drop existing custom fields and build fully working custom forms in minutes.</li>
<li><strong>Ajax-based form submission</strong>: This is a very important feature in modern websites as developers don't use the normal post submissions for many features. So, the forms plugin should have the ability use normal form submission as well as AJAX-based submissions.</li>
<li><strong>Different field types</strong>: In this plugin, we only used basic text and dropdown fields. However, we need many field types such as dates, google maps, and searchable dropdowns in advanced websites. So, the ability to handle such advanced requirements with the built-in fields in forms plugins is definitely a huge advantage.</li>
<li><strong>Form field validations</strong>: Usually, we had to validate each field by applying the necessary validation rules. In a quality forms plugin, we should have the ability to select from an existing set of rules and validate the fields without writing a single line of code.</li>
<li><strong>Conditional logic</strong>: In custom forms, we develop each form for specific requirements and hence we can manually apply conditions before loading certain fields. In forms plugins, we add the fields dynamically to a form, and hence we should have the ability to define the conditions before making each field visible on the site.</li>
<li><strong>Displaying and exporting data</strong>: We should have the ability to display submitted data in the frontend and export it to common file types when necessary.</li>
<li><strong>Saving form data to a custom database table</strong>: Usually, many forms plugins save the data to the <kbd>wp_postmeta</kbd> table or use the same custom table to save the data of all forms to a single custom table. We should at least have the ability to choose between existing tables or a custom table.</li>
</ul>
<p>These are some of the features we expect from quality form plugins. Let's take a look at the following screen for the form-creating interface of one of the most popular forms plugins:</p>
<div class="packt_figref CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-260 image-border" src="assets/6bf02239-3d3e-4fbf-a5dd-ccfee4eba423.png" style="width:46.08em;height:32.33em;"/></div>
<p>The preceding screenshot previews some of the features we discussed in the previous section. However, it will be difficult to find a forms plugins that provides all these features in a way that we expect to use them. Also, almost all the forms plugin don't provide a frontend interface to let the user edit the submitted data or list them. So, forms plugins are best-suited for scenarios where we want to use one-time forms to capture the user data. Popular examples include registration forms, contact forms, payment forms, and surveys. We should always use custom forms or custom post types to manage forms that requires the user to submit data, update it, and list all the submitted data.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Summary</h1>
                </header>
            
            <article>
                
<p>The process of managing the data is one of the most important aspect of a website or application. WordPress custom post types allow us to model different content types in a standard way, and use built-in features for rapid development. We began the chapter by understanding the importance of custom post types and the features that made it a popular choice in plugin development. Then, we looked at the process of creating custom post types, while understanding the use of taxonomies and custom fields with custom post types. Next, we moved to the process and techniques of developing custom forms for the frontend of a website. Finally, we looked at the need for using forms plugins, and compared the advantages and disadvantages of custom post types and custom forms.</p>
<p>In <a href="f84651b7-727e-4336-845c-14fc12ae10ab.xhtml" target="_blank">Chapter 8</a>, <em>Discovering Key Modules in Development</em>, we will be exploring the development of key modules in modern web sites, such as UI component integration, improving usability, and customizing core admin features.</p>


            </article>

            
        </section>
    </body></html>