- en: Chapter 12. RESTful Web Services in Drupal
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '*One of the major new developer features of Drupal 8 is built-in support for
    REST. In this chapter, we will explore and configure built-in support for REST.
    Then we will extend it by installing the RESTful module. Finally, we will develop
    a custom Recipe AngularJS app that will consume the REST API of our recipe website.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will learn these topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Introduction to web services
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction to REST
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What is Headless Drupal?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When and why to decouple Drupal?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: RESTful web services in Drupal
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to create RESTful APIs in Drupal
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a basic Angular website that will consume the REST API of our recipe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction to web services
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A web service can be defined as a communication bridge between two applications
    over a network. The W3C defines a web service generally as:'
  prefs: []
  type: TYPE_NORMAL
- en: '*"A software system designed to support interoperable machine-to-machine interaction
    over a network."*'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Web services innovation speaks to a vital route for organizations to correspond
    with one another and with customers also. Not at all like customary customer/server
    models, for example, a web server or web page framework, web administrations don't
    furnish the client with a GUI. Rather, they offer business rationale, information,
    and procedures through an automatic interface over a system. The applications
    interface with one another, not with the clients. Engineers can then add the web
    administration to a GUI (for example, a web page or an executable system), to
    offer particular usefulness to clients.
  prefs: []
  type: TYPE_NORMAL
- en: Let's look into the example that we will be following in this chapter. Our Drupal
    website holds recipe contents, and they have data about different recipes. We
    want other applications and websites to be able to use these contents and data
    to show in their respective applications. Now, as they would like to show the
    data according to their needs, they will try to get the raw values of the data
    and display them as per their requirements.
  prefs: []
  type: TYPE_NORMAL
- en: In doing so, we need to take care of the authentication of the applications
    trying to fetch data from our Drupal application so that there is no third-party
    attack on our data.
  prefs: []
  type: TYPE_NORMAL
- en: The whole scenario of providing the data and other parties consuming it is achieved
    using web services, which acts as a bridge between our Drupal application and
    the outer world.
  prefs: []
  type: TYPE_NORMAL
- en: Numerous associations utilize various programming frameworks for administration.
    Distinctive programming frameworks regularly need to trade information with one
    another, and a web service is a strategy for correspondence that permits two product
    frameworks to trade this information over the Web. The product framework that
    demands information is known as a **Service Requester**, which is an Angular web
    page in this chapter, though the product framework that would prepare the solicitation
    and give the information is known as a service provider, which is Drupal in our
    case.
  prefs: []
  type: TYPE_NORMAL
- en: In a nutshell, web services make it possible for outside applications and devices
    to communicate with our application (for this situation, our Drupal) to execute
    **CRUD** operations (short for **Create**, **Read**, **Update**, and **Delete**).
  prefs: []
  type: TYPE_NORMAL
- en: Introduction to REST
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**REST** is the acronym for **Representational State Transfer**, which is one
    of the most popular ways of creating web services.'
  prefs: []
  type: TYPE_NORMAL
- en: REST is one of the architectural designs for service-oriented architecture,
    which uses simple HTTP calls to interact with machines for all CRUD operations.
    REST has risen in the last couple of years alone as a dominating web services
    design model, dislodging most of the SOAP- and WSDL-based services, because of
    its simplicity.
  prefs: []
  type: TYPE_NORMAL
- en: 'The four basic design principles of REST are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Use HTTP methods explicitly**: REST follows pure HTTP methods and encourages
    developers to utilize it clearly, which is steady with the protocol definition.
    This kind of basic REST design theory establishes a one-to-one mapping between
    CRUD functions and HTTP methods, matching to this mapping:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`POST`: Create a resource'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`GET`: Retrieve a resource'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`PUT`: Update a resource'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`DELETE`: Delete a resource'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Be stateless**: A stateless web service creates a response that links to
    another page in the set and lets the client perform what it needs to in order
    to maintain this value around. This kind of facet of RESTful web services design
    can be divided into two units of tasks:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Server**: This generates responses that incorporate links to other assets,
    allowing applications to get around between related resources. The server also
    includes Cache-Control and Last-Modified systems to determine what data to cache
    to reduce the load on the server.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Client**: This uses the Cache-Control and Last-Modified systems to determine
    whether or not to keep a local copy and cache the resource.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: This kind of collaboration between the client app and service is vital to being
    stateless in RESTful web services. It boosts performance simply by saving bandwidth
    and reducing the server-side application state.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Introduction to REST](img/4659_12_01.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: '**Expose directory structure-like URLs**: Another RESTful web service attribute
    is all about URLs. REST web service URLs need to be intuitive to the point where
    they are simple to guess. Think of a URL as a sort of self-documenting interface
    that requires very little, if any, explanation or perhaps reference for any developer
    to understand what it takes into account also to obtain related resources. For
    example, in our recipe services, we will have URIs in a structure like this:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`http://www.headless.dev/api/recipes/snacks/{recipe_name}`, which exposes the
    details of a particular recipe'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`http://www.headless.dev/api/recipes/{recipe_type}`, which gives the recipes
    associated with the recipe type'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: URIs should also be static so that when the resource changes or the implementation
    of the service changes, the link stays the same
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Transfer XML, JavaScript Object Notation (JSON), or both**: A representational
    format is necessary for clients to consume the web service and display them on
    their presentation layer. The very last set of constraints that goes to a RESTful
    World Wide Web service design has to do with the structure in the data that the
    application and service exchange in the request/response payload or in the HTTP
    body. This is exactly where it really pays to keep things simple, human-readable,
    and connected. To provide client applications with the capability to request a
    particular article''s type that''s perfect to get them, construct your services
    in order that it makes using the built-in HTTP Recognize header, where the benefit
    from the header is a MIME type. Some prevalent MIME types utilized by RESTful
    services are shown here:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '| MIME type | Content type |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| --- | --- |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| **JSON** | `application/json` |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| **XML** | `application/xml` |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| **XHTML** | `application/xhtml+xml` |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: Headless Drupal
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The term "Headless Drupal" was coined to refer to the decoupling of the backend
    and frontend of a Drupal application. In Headless Drupal, a visitor to the website
    will not interact with Drupal directly.
  prefs: []
  type: TYPE_NORMAL
- en: 'From the website visitor''s point of view, the user is not directly connecting
    to Drupal but to a frontend JavaScript framework such as KnockoutJS or AngularJS.
    So, the website visitor does not see a generated Drupal theme (the head), this
    is not used: *headless*.'
  prefs: []
  type: TYPE_NORMAL
- en: In this case, Drupal is only used as a backend content management system, which
    is read by a frontend JavaScript framework, a mobile app or another third-party
    application. So, the Drupal backend is exactly as you know it, but the frontend
    is entirely non-Drupal.
  prefs: []
  type: TYPE_NORMAL
- en: Data exchange almost always takes place through JSON.
  prefs: []
  type: TYPE_NORMAL
- en: 'A manifesto about the future of Drupal has been laid with four goals:'
  prefs: []
  type: TYPE_NORMAL
- en: We want Drupal to be the *preferred* backend content management system for designers
    and frontend developers.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We believe that Drupal's main strengths lie in the power and flexibility of
    its backend; its primary value to users is its ability to architect and display
    complex content models.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We believe that client-side frontend frameworks are the future of the Web.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It is critically important for Drupal to be service-oriented first—not HTML-oriented
    first—or risk becoming irrelevant.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'A diagrammatical representation of a Headless Drupal site explains a lot that
    is built by Pantheon:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Headless Drupal](img/4659_12_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Headless Drupal will be served with the web services concept using the REST
    server to create APIs, which will be consumed by other applications or a single
    application to serve on the frontend.
  prefs: []
  type: TYPE_NORMAL
- en: Building a Headless site prior to Drupal 8 was possible using modules such as
    services and RESTWS, but Drupal 8 comes packed with REST APIs in the core, which
    serves the purpose well.
  prefs: []
  type: TYPE_NORMAL
- en: When to decouple Drupal or when to use Headless Drupal
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As discussed, Headless Drupal will be decoupling the backend architecture and
    frontend architecture so that the frontend has the flexibility to display the
    content as per the requirements. But when should you use this method? We use it
    especially when Drupal has a strong theming layer of its own.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s look at some of the pros and cons of using Headless Drupal:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Pros**:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Clean APIs for all as it is uniform and can be used by any application to represent
    data.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Upgrading the frontend will require any changes in the backend and similarly
    upgrading the backend will not touch the frontend. However, you will need to be
    extremely careful while designing the content APIs.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Less reliance of Drupal expertise as the frontend is detached from Drupal.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Cons**:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A decoupled structure's engineering is more mind-boggling to comprehend and
    troubleshoot. Making sense of why something is broken is very difficult to debug.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Drupal's out-of-the-box functionalities need to be built from scratch. For example,
    the Facebook plugin, which provides Facebook access and login, is strong and stable.
    But to use in a decoupled environment, the whole functionality needs to be rebuilt.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The minimum team size required for efficient development is larger as the backend
    team is separated from the frontend.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: So why is Headless Drupal making us happy?
  prefs: []
  type: TYPE_NORMAL
- en: The Drupal installation is easier to maintain
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The scalability of the system becomes easier
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It becomes easier to work with and for different teams
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The performance is improved
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It makes the project future-proof
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Since the initiation of Drupal, it has grown from just being a blogging platform
    to a strong content management system, and the concept of Headless Drupal just
    strengthens its capabilities of managing contents. But you need to have a clear
    understanding of the project before jumping into decoupling Drupal. Though it
    looks tempting and has great advantages, it also has downsides.
  prefs: []
  type: TYPE_NORMAL
- en: RESTful web services in Drupal
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As discussed previously, prior to Drupal 8, RESTful web services could be implemented
    in Drupal 7 using the Services module or RESTWS module, which (using the REST
    server) can be used to build powerful Headless Drupal websites. But with the evolution
    of Drupal 8, this functionality has been attached to the core of the Drupal 8
    default bundle, along with other contributed features and modules that are pushed
    to the core, such as Views, Link, WYSIWYG editors, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: 'Drupal 8 achieves the full functionality to set a basic web services environment
    to provide APIs using four modules in the core. They are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**RESTful web services (REST)**: This exposes entities and other resources
    via a RESTful web API. It depends on the Serialization module for serialization
    of data that is sent to and from the API.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Serialization**: This provides a service for serialization of data to and
    from formats such as JSON and XML.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Hypertext Application Language (HAL)**: This serializes entities using Hypertext
    Application Language. Drupal core currently uses this format, which adds two keywords:
    `_link` for linked relation and `_embedded` for embeded media.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**HTTP Basic Authentication (basic_auth)**: This module implements basic user
    authentication using the HTTP Basic Authentication provider, which uses the username
    and password for authentication to make API calls.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: RESTful APIs in Drupal
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Creating RESTful APIs in Drupal is a fairly easy task, now that the whole power
    of web services has been moved to the core. To create the APIs, we will be using
    the Recipe content type that we have built for this book.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will go through creating three basic APIs; these will give us the following
    information:'
  prefs: []
  type: TYPE_NORMAL
- en: Get all the recipe types
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Get all the recipes under a recipe type
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Time for action – getting all the recipe types
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This is the list of recipe types I have in my local development server running
    in Vagrant (`http://www.headless.dev`):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Time for action – getting all the recipe types](img/4659_12_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'We will create an API URL structured as `http://www.headless.dev/recipes`,
    which will give the list of recipes in my site. Let''s get started:'
  prefs: []
  type: TYPE_NORMAL
- en: We need to enable the Web Services module from the modules page.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on **Manage** in the administration menu bar and then click on **Extend**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Once you are on the **Modules** page, search for **RESTful Web Services** and
    **Serialization**. Enable both these modules:![Time for action – getting all the
    recipe types](img/4659_12_04.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Next, we will need to create a REST export views for our recipe types. Views
    now comes in the core of Drupal 8, which uses the REST export mode to create web
    services APIs.![Time for action – getting all the recipe types](img/4659_12_05.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Then click on **Views**:![Time for action – getting all the recipe types](img/4659_12_06.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You will be greeted by the **Views** landing page, where you can manage, configure,
    and add new Views. Drupal 8 uses Views extensively to display different data and
    contents on the site. The **Web Services** module however does not provide any
    views by default.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Moving forward, click on **Add new view** in the **Views** landing page:![Time
    for action – getting all the recipe types](img/4659_12_07.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the views configuration page, fill out the form as given in the next screenshot.
    We have selected **Show** as **Taxonomy terms** and **of type** as **Recipe Type**
    to create a web service API to show the Recipe Types in the site.![Time for action
    – getting all the recipe types](img/4659_12_08.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: After filling out the form, we need to select the REST export display to export
    or expose the API by a URL.![Time for action – getting all the recipe types](img/4659_12_09.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on **Save and edit** to configure the view.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now, by default, the view will give full entity information about the taxonomy
    terms.![Time for action – getting all the recipe types](img/4659_12_10.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The result of the views preview is very messy and hard to read. It is shown
    as a flat list.![Time for action – getting all the recipe types](img/4659_12_11.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: To make it more readable, you need to install a Google plugin called **JSONview**,
    which renders the JSON object in a more readable manner.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Once the plugin is installed, you can view the response in the browser by hitting
    this URL: `http://www.headless.dev/api/recipes`.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: As it gives all information about the terms, we need to filter out unnecessary
    fields from the response and make it more readable and consumable.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: We will be exposing the title, tid, and description about the recipe type to
    be consumed. In the **Views** settings, under **FORMAT**, select the **Show**
    property and select **Fields** instead of **Entity**.![Time for action – getting
    all the recipe types](img/4659_12_12.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select **Fields** from the options provided so that you can add fields to your
    REST export:![Time for action – getting all the recipe types](img/4659_12_13.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select **Apply**, and in the next screen, it will ask if you need alias the
    field label. But it is fine to keep it as name.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Next, we need to add the rest of the fields under the **FIELDS** settings. Select
    **Add** under **FIELDS** and add in the `tid` and `description` fields:![Time
    for action – getting all the recipe types](img/4659_12_14.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Select the **Taxonomy term: Term ID** field to get the term ID in your REST
    export.![Time for action – getting all the recipe types](img/4659_12_15.jpg)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'And then select the **Taxonomy term: Description** field from the fields list:![Time
    for action – getting all the recipe types](img/4659_12_16.jpg)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Apply the settings and save the fields as default unless you need to something
    more special with the fields.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Next, we will rearrange the fields so that the order of the fields is tid, name,
    and description.![Time for action – getting all the recipe types](img/4659_12_17.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now if we visit `http://www.headless.dev/api/recipes` in our browser, we will
    get a more precise and easy-to-read JSON object ready to be consumed by any app.![Time
    for action – getting all the recipe types](img/4659_12_18.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*What just happened?*'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We created an API using the Drupal REST service module and REST views export,
    which gives us a JSON of the available Recipe types in our Drupal site, ready
    to be consumed.
  prefs: []
  type: TYPE_NORMAL
- en: Time for action – creating an API to get all the recipes under a recipe type
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now we will create our next API, which is for exposing all the recipes under
    a recipe type:'
  prefs: []
  type: TYPE_NORMAL
- en: We will have a new view created in the same manner, but instead of selecting
    Taxonomy terms, we will be choosing contents of all type recipes.![Time for action
    – creating an API to get all the recipes under a recipe type](img/4659_12_19.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the REST export settings, give the URL as `api/recipes/%`. The `%` sign acts
    as the wildcard, which will recipe type tid as the argument.![Time for action
    – creating an API to get all the recipes under a recipe type](img/4659_12_20.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In the views settings page, we configure the view just like we did it for the
    recipe type. The fields that we will be showing are:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Node ID**'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Title**'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Publishing status**'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Recipe Type**'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Recipe Image**'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**PrepTime**'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**CookTime**'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**TotalTime**'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Body**'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Ingredients**'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Instructions**'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Yield**'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Review**'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: To get the recipes associated with a particular recipe, we will use the fields
    Recipe Type in the recipe content, which is referenced to the Recipe Type vocabulary.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the advanced section of the views configuration page, under **CONTEXTUAL
    FILTERS**, click on **Add** to add in the Recipe Type tid as an argument:![Time
    for action – creating an API to get all the recipes under a recipe type](img/4659_12_21.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the contextual filter form, search for `recipe type` and select the field
    to configure it:![Time for action – creating an API to get all the recipes under
    a recipe type](img/4659_12_22.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the contextual filter configuration form, select the **Provide default value**
    radio button and choose **Taxonomy term ID from URL** from the argument **Type**
    dropdown:![Time for action – creating an API to get all the recipes under a recipe
    type](img/4659_12_23.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The JSON object will give the indexes as the machine name of the fields. So
    we will alias the fields to make the indexes' names relevant.![Time for action
    – creating an API to get all the recipes under a recipe type](img/4659_12_24.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now if you check the result in the browser by hitting the URL `http://www.headless.dev/api/recipes/6`,
    you will get the JSON object of the nodes associated with term ID `6`, which is
    for the Snack recipe type:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '*What just happened?*'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We created an API that that gives us all recipe types and another API that gives
    out all the recipe types under a particular recipe type. Now we will see how we
    can use AngularJS to consume this REST exports JSON output and display on a web
    page.
  prefs: []
  type: TYPE_NORMAL
- en: Time for action – consuming RESTful web services using AngularJS
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now that we have an API that is providing us the services with the JSON data
    of the recipes, recipe types, and individual recipes, let us look at how we can
    use this data to display in a page using HTML and AngularJS:'
  prefs: []
  type: TYPE_NORMAL
- en: Since it is targeted towards a Drupal audience, we will not be looking deep
    into the consumption of services.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: So for starters, let us create a directory named `recipes` inside the Drupal
    root directory. In the directory, we will have two files, `recipe.js` and `index.html`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `recipe.js` file will hold the code to call the API URL and parse the data
    object for consumption. The `index.html` file will hold the AngularJS code and
    HTML to read the parsed data and display it on the page.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The folder structure should be similar to this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Let''s look into the `recipe.js` file, which is the AngularJS controller. As
    said, it will hold the JavaScript code to create an Angular Controller Module
    to fetch the JSON object from the API URL and parse it to provide raw content
    from the JSON object:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The preceding code is a controller in Angular, which a JavaScript function.
    This function used two variables, `$http` and `$scope`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`$http` calls the REST API URL using the `get` method'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`$scope` holds the JSON returned from the API and passes it on to the HTML
    DOM of the page in an element array `recipe`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Now that we have an AngularJS controller, we will create the HTML page that
    will load the controller into the web browser:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The first script tag loads the minified AngularJS library (`angular.min.js`)
    from a **content delivery network** (**CDN**) so that we don't have to download
    AngularJS and place it in the project.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The second script loads the controller code (`recipe.js`) from the application's
    path.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'AngularJS interacts with the HTML DOM with two attributes:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `ng-app` attribute to indicate that this page is an AngularJS application
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The `ng-controller` attribute to define which controller to use
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The placeholders reference the `recipe_name` and `summary` properties of the
    recipe model object, which will be set upon successfully consuming the REST service:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`<h1>{{recipes.recipe_name}}</h1>`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`<p>{{recipes.summary}}</p>`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'To run the client, all you need to do is open the directory in the web browser.
    Since our Angular application is inside the Drupal root directory, we can run
    it by opening this URL: `http://www.headless.dev/api/recipes/6/recipes`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'This will show the result as:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Time for action – consuming RESTful web services using AngularJS](img/4659_12_25.jpg)'
  prefs: []
  type: TYPE_IMG
- en: So, this is a simple way on how to consume RESTful APIs with Angular JS.
  prefs: []
  type: TYPE_NORMAL
- en: 'A point to remember: since the Angular application is within the Drupal root
    folder, there are no cross-origin issues in running the Angular application. But
    if the Angular application is on a different server than the server hosting the
    web services, then CORS (cross-origin resource sharing) has to be enabled in the
    server hosting the web services. This allows the restricted resources to be displayed
    in the Angular application server.'
  prefs: []
  type: TYPE_NORMAL
- en: '*What just happened?*'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We created an AngularJS app that consumes the JSON result from the REST export
    created from the Drupal instance. This JSON response is used by the Angular app
    to display the result provided by the Angular app to an HTML page. This helps
    us to display the data in a faster way and we have control over the display and
    design of the page.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So we now have a Drupal website that is used for data storage. The Drupal site
    will be used to generate contents and data. This data will be represented in JSON
    format using Drupal's built-in web services modules and views to create RESTful
    JSON exports, which can be used by the app to consume this JSON output and display
    it on the app.
  prefs: []
  type: TYPE_NORMAL
