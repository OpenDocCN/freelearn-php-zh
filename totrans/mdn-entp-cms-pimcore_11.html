<html><head></head><body>
		<div id="_idContainer175">
			<h1 id="_idParaDest-200"><em class="italic"><a id="_idTextAnchor201"/>Chapter 11</em>: Finalizing the Website</h1>
			<p>In the last chapter, we finalized the building of our blog using Pimcore. Thanks to the capabilities of CMS and the data management engine, we were able to achieve complex goals such as creating custom unstructured content (the website's pages) and structured content (blog articles). It was a pleasant journey that makes us autonomous regarding the implementation of any kind of website or portal. Moreover, there are many additional steps that we may need to take to make our work reusable, extensible, and easy to deploy. As the title states, in this chapter we will learn how to finalize our website.</p>
			<p>The points that we will cover will be the following:</p>
			<ul>
				<li>Making a Multisite in Pimcore</li>
				<li>Making the bundle installable</li>
				<li>Using a multi-environment configuration</li>
				<li>Using environment variables </li>
			</ul>
			<h1 id="_idParaDest-201"><a id="_idTextAnchor202"/>Technical requirements</h1>
			<p>As for the previous chapters, there is a demo in our GitHub repository that you can find here: https://github.com/PacktPublishing/Modernizing-Enterprise-CMS-using-Pimcore.</p>
			<p>All you need to do to run the demo connected with this chapter is to clone it and navigate to the <strong class="source-inline">Full Demo</strong> folder to start the Docker environment.</p>
			<p>To do so, just follow these instructions:</p>
			<ol>
				<li>Run Docker with the following command:<p class="source-code"><strong class="bold">docker-compose up</strong></p></li>
				<li>Then, to restore all the settings on your local machine, type the following:<p class="source-code"><strong class="bold">docker-compose exec php bash restore.sh</strong></p></li>
				<li>Navigate to <a href="http://localhost/admin">http://localhost/admin</a> and log in with your admin/pimcore credentials.</li>
			</ol>
			<h1 id="_idParaDest-202"><a id="_idTextAnchor203"/>Making a Multisite in Pimcore</h1>
			<p>Each time you create a website, you need to take time to create the environment, install plugins, and configure all the other Pimcore settings. Moreover, we also need a hosting space, which means extra costs<a id="_idIndexMarker719"/>. This is an activity that we have to do each time we are going to create a website, but we would reduce the impact of this activity on each website creation.</p>
			<p>For example, think about a scenario where a customer has 10 websites, maybe one for each brand of the company. With the digital exposure that each company has nowadays, it is a plausible use case. Even if we can create a bundle that can be used to port the common components<a id="_idIndexMarker720"/> between websites, having separate websites still involves overhead. From the user's point of view, having 10 different websites to admin is very hard to manage.</p>
			<p>The solution for this common situation is still Pimcore itself. The <strong class="bold">Multisite</strong> feature lets us manage multiple websites in the same instance, reducing hosting costs and using the same resources (themes, bricks, custom code) in all the websites. With the power of scaling that the cloud provides, we do not expect server load problems, and we can follow this method without side effects. </p>
			<p>To cover all the possible scenarios you may have with a real-world website, we will implement a test case where we will transform a branch of a website tree in a standalone website. This will allow users to reach the web pages as if they were browsing an independent website. This is the basic tenet that will let you manage multiple websites in the same Pimcore instance (for example, <strong class="source-inline">product1.mywebsite.com</strong> and <strong class="source-inline">product2.mywebsite.com</strong>) and website alias (for example, <strong class="source-inline">www.mywebsite.com</strong> and <strong class="source-inline">mywebsite.com</strong>).</p>
			<p>In the next example, we will create a generic subsite called <strong class="bold">subsite1</strong>, and we will make it available using a different domain than the default. Moreover, we will use different kinds of domain mapping to cover all the most common scenarios (addresses, aliases, and wildcards):</p>
			<ol>
				<li value="1">Add a document to the page<a id="_idIndexMarker721"/> tree. Call it <strong class="bold">subsite1</strong>. The name of the page doesn't affect the behavior of the site. In our case, we used our full demo<a id="_idIndexMarker722"/> setup, and we have got a web page like the one shown in the following screenshot:<div id="_idContainer165" class="IMG---Figure"><img src="image/B17073_11_01.jpg" alt="Figure 11.1: The page used for the test &#13;&#10;"/></div><p class="figure-caption">Figure 11.1: The page used for the test </p></li>
				<li>Navigate through the tree menu and right-click on the <strong class="bold">subsite1</strong> item. Then click on <strong class="bold">Use as site</strong>:<div id="_idContainer166" class="IMG---Figure"><img src="image/B17073_11_02.jpg" alt="Figure 11.2: The menu used to convert a web page into a website &#13;&#10;"/></div><p class="figure-caption">Figure 11.2: The menu used to convert a web page into a website </p><p>If you<a id="_idIndexMarker723"/> click on the <strong class="bold">Use as site</strong> button<a id="_idIndexMarker724"/>, a popup appears:</p><div id="_idContainer167" class="IMG---Figure"><img src="image/B17073_11_03.jpg" alt="Figure 11.3: The form for configuring a website&#13;&#10;"/></div><p class="figure-caption">Figure 11.3: The form for configuring a website</p></li>
				<li>Fill in the form with the following information:<ul><li><strong class="bold">Main Domain</strong>: <strong class="source-inline">subsite1.local</strong>.</li><li><strong class="bold">Additional Domains</strong>: <strong class="source-inline">subsite1-alternative.local</strong> and <strong class="source-inline">*.subsite1.local</strong>. These values have to be put on two different lines. This setting applies to the item<a id="_idIndexMarker725"/> that we have selected and all its children<a id="_idIndexMarker726"/>. This configuration tells Pimcore to serve requests using the pages under the one that we have promoted to a site in <em class="italic">step 2.</em> This means that if you navigate to one of the added domains, the pages under this page will be served. So, if you navigate to <strong class="source-inline">subsite1.local</strong> and <strong class="source-inline">subsite1-alternative.local</strong>, you will see the converted page; if you look for a path inside the domain (such as <strong class="source-inline">subsite1.local/xxx</strong>), a page with the same relative path under the page site will be served. The same goes for all the third-level domains of <strong class="source-inline">subsite1.local</strong>, such as <strong class="source-inline">mysubsite.subsite1.local</strong>, because we entered a wildcard address.</li></ul></li>
				<li>Edit your hosts file to reach<a id="_idIndexMarker727"/> these fake URLs. Open the hosts file and add the following lines:<p class="source-code">127.0.0.1 subsite1.local</p><p class="source-code">127.0.0.1 subsite1-alternative.local</p><p class="source-code">127.0.0.1 test.subsite1.local</p></li>
				<li>Go to these URLs: <a href="http://subsite1.local">http://subsite1.local</a>, http://subiste1-alternative.local, and <a href="http://test.subsite1.local">http://test.subsite1.local</a>. You will always get the same results, which proves that the multisite is well configured.</li>
			</ol>
			<p>In this section, we learned how to transform<a id="_idIndexMarker728"/> a part of the page tree into a standalone website. This is very useful for hosting multiple websites and reusing themes and components from the same code base. This is a big help for reusable code that can work in conjunction with bundling and sharing the source code. In the next section, we will learn how to create installation processes for creating data and settings during our bundle's installation.</p>
			<h1 id="_idParaDest-203"><a id="_idTextAnchor204"/>Making the bundles installable</h1>
			<p>In <a href="B17073_10_ePub_RK.xhtml#_idTextAnchor188"><em class="italic">Chapter 10</em></a><em class="italic">, Creating Pimcore Bricks</em>, we created all the assets in a single bundle to make them self-contained and portable. The opportunity to start our next Pimcore project by installing a bundle<a id="_idIndexMarker729"/> means we don't have to redo certain tasks, making this an attractive option. Anyway, there are some steps that we have done manually through the user interface that have to be replicated. Think back to the class generation in <a href="B17073_09_ePub_RK.xhtml#_idTextAnchor166"><em class="italic">Chapter 9</em></a><em class="italic">, Rendering Data</em>â€”they were created manually, but you do not want to replicate this step in every new blog you will create. Even if you only take a few minutes creating them, there is always the risk of entering the wrong field name or making a mistake; they will transform your 5-minute task into a small nightmare.</p>
			<p>But never fear! The Pimcore installation system lets you add a special class that can manage the installation process<a id="_idIndexMarker730"/>. Some common use cases are as follows:</p>
			<ul>
				<li>Creating or updating the class definition</li>
				<li>Entering seed data (such as standard categories)</li>
				<li>Updating the database schema (add tables, columns, indexes, and so on)</li>
				<li>Importing translations</li>
			</ul>
			<p>Installers are, in fact, classes that are used by Pimcore when a bundle is installed.</p>
			<p>This topic is covered by two different approaches:</p>
			<ul>
				<li><strong class="bold">Installer</strong>: A class <a id="_idIndexMarker731"/>that manages the installation process that gives you the power to customize all the phases (installation and uninstallation).</li>
				<li><strong class="bold">Migrations</strong>: This part is<a id="_idIndexMarker732"/> designed for managing the database changes and supporting both upgrade and downgrade options. </li>
			</ul>
			<p>Let's examine the two options in the next sections.</p>
			<h2 id="_idParaDest-204"><a id="_idTextAnchor205"/>Installers</h2>
			<p>While the installer<a id="_idIndexMarker733"/> takes care of the initial configuration, migrations keep the database updated. When you install the bundle, an installation process<a id="_idIndexMarker734"/> will be run. Then, on each bundle update, you can apply some changes to the database to implement a data migration.</p>
			<p>An installer class can inherit <strong class="source-inline">AbstractInstaller</strong> and has the following anatomy:</p>
			<p class="source-code">class MyInstaller extends AbstractInstaller</p>
			<p class="source-code">{Â Â Â Â </p>
			<p class="source-code">Â Â Â Â public function install()Â Â Â Â {}</p>
			<p class="source-code">Â Â Â Â public function uninstall()Â Â {}</p>
			<p class="source-code">Â Â Â Â public function isInstalled(){</p>
			<p class="source-code">Â Â Â Â Â Â Â Â return true;</p>
			<p class="source-code">Â Â Â Â }</p>
			<p class="source-code">Â Â Â Â public function canBeInstalled(){</p>
			<p class="source-code">Â Â Â Â Â Â Â Â return false;</p>
			<p class="source-code">Â Â Â Â }</p>
			<p class="source-code">Â Â Â Â public function canBeUninstalled(){</p>
			<p class="source-code">Â Â Â Â Â Â Â Â return false;</p>
			<p class="source-code">Â Â Â Â }</p>
			<p class="source-code">Â Â Â Â public function needsReloadAfterInstall() {</p>
			<p class="source-code">Â Â Â Â Â Â Â Â return false;</p>
			<p class="source-code">Â Â Â Â }</p>
			<p><strong class="source-inline">AbstractInstaller</strong> has an instance of <strong class="source-inline">BufferedOutput</strong> that integrates with the console tool and the web UI. That means that if you use it to write logs, the logs will be prompted to the user. The <strong class="source-inline">BufferedOutput</strong> instance can be accessed by the <strong class="source-inline">getOutput()</strong> method.</p>
			<p>Now we will create<a id="_idIndexMarker735"/> an installer that automatically installs<a id="_idIndexMarker736"/> the classes related to our project. This is very easy, and we just need to complete the following steps:</p>
			<ol>
				<li value="1">Create a class definition with one or two fields. Call it <strong class="source-inline">test</strong>. To keep it simple, the class complexity is not relevant for our goal. If you have any doubts about how to create classes, just look at <a href="B17073_05_ePub_RK.xhtml#_idTextAnchor093"><em class="italic">Chapter 5</em></a><em class="italic">, Exploring Classes and Objects</em>, where this topic is covered. </li>
				<li>Download the class definition by clicking the <strong class="bold">Export</strong> button on the class definition page:<div id="_idContainer168" class="IMG---Figure"><img src="image/B17073_11_04.jpg" alt="Figure 11.4: Menu bar for class export&#13;&#10;"/></div><p class="figure-caption">Figure 11.4: Menu bar for class export</p></li>
				<li>Now create a folder named <strong class="source-inline">class_sources</strong> inside <strong class="source-inline">/bundles/BlogBundle/Resources/install/</strong>, making the final path <strong class="source-inline">/bundles/BlogBundle/Resources/install/class_sources</strong>. </li>
				<li>Copy the JSON file you exported into this folder.</li>
				<li>Create a folder called<a id="_idIndexMarker737"/> <strong class="source-inline">Setup</strong> in your bundle and add the <strong class="source-inline">BlogInstaller</strong> class inside<a id="_idIndexMarker738"/> it. The content should include the following:<p class="source-code">&lt;?php</p><p class="source-code">namespace BlogBundle\Setup;</p><p class="source-code">... usages</p><p class="source-code">class BlogInstallerÂ Â extends AbstractInstaller</p><p class="source-code">{Â Â Â Â </p><p class="source-code">}</p></li>
				<li>Now we have to register the installer class to make it available for dependency injection. Add the following configuration to the <strong class="source-inline">service.yml</strong> file:<p class="source-code">services:</p><p class="source-code">Â Â Â Â BlogBundle\Setup\BlogInstaller:</p><p class="source-code">Â Â Â Â Â Â Â Â public: true</p><p class="source-code">Â Â Â Â Â Â Â Â autowire: true</p><p>Now the dependency injection knows your installer and can create instances of it.</p></li>
				<li>Open the <strong class="source-inline">BlogBundle.php</strong> bundle file and add the following method:<p class="source-code">public function getInstaller() {Â Â Â Â Â Â Â Â </p><p class="source-code">Â Â Â Â Â return $this-&gt;container-&gt;get(</p><p class="source-code">Â Â Â Â Â BlogInstaller::class);Â Â Â Â Â Â </p><p class="source-code">}Â Â Â Â Â Â Â </p><p>This function will tell Pimcore that your bundle has its installer and will use it. What happens when you install your bundle is that the event of your installer will be triggered, and you will be able to do all the stuff you need. In the next steps, we will implement the initial configuration.</p></li>
				<li>The next snippet of code<a id="_idIndexMarker739"/> implements the class restore<a id="_idIndexMarker740"/>, so add this function (logs and output messages are omitted for brevity):<p class="source-code">public function install(){Â Â Â Â Â Â Â </p><p class="source-code">Â Â Â Â Â $files = $this-&gt;getClassesToInstall();</p><p class="source-code">Â Â Â Â Â foreach ($files as $file) {</p><p class="source-code">Â Â Â Â Â Â Â Â Â Â $data = file_get_contents($file);</p><p class="source-code">Â Â Â Â Â Â Â Â Â Â $json= json_decode($data);</p><p class="source-code">Â Â Â Â Â Â Â Â Â Â $name= $json-&gt;id;</p><p class="source-code">Â Â Â Â Â Â Â Â Â Â $class = ClassDefinition::getById($name);</p><p class="source-code">Â Â Â Â Â Â Â Â Â Â if($class) continue; // do not overwrite</p><p class="source-code">Â Â Â Â Â Â Â Â Â Â $class = new ClassDefinition();</p><p class="source-code">Â Â Â Â Â Â Â Â Â Â $class-&gt;setName($json-&gt;id);</p><p class="source-code">Â Â Â Â Â Â Â Â Â Â $class-&gt;setId($json-&gt;id);</p><p class="source-code">Service::importClassDefinitionFromJson($class, $data, false, true);</p><p class="source-code">Â Â Â Â Â }</p><p class="source-code">}</p><p>The installation procedure is composed of a few simple steps. First of all, we read the filesystem and fetch all the files in the <strong class="source-inline">classes</strong> folder (<strong class="source-inline">files = $this-&gt;getClassesToInstall();</strong>). Then, for each one, we check whether the class exists; if it doesn't exist, we create and import the class. If the class exists and we override it with a different definition, we may experience data loss and we do not want that.</p></li>
				<li>The next snippet<a id="_idIndexMarker741"/> contains the <strong class="source-inline">getClassesToInstall</strong> procedure. Copy it to the installer class:<p class="source-code">protected function getClassesToInstall()</p><p class="source-code">{Â Â Â Â Â Â Â Â </p><p class="source-code">Â Â Â Â Â $realpath = realpath(__DIR__."/../</p><p class="source-code">Â Â Â Â Â Resources/install/class_sources/");</p><p class="source-code">Â Â Â Â Â $files=glob($realpath.'/*.json');Â Â Â Â Â Â Â Â Â Â Â </p><p class="source-code">Â Â Â Â Â return $files;</p><p class="source-code">}</p><p>The preceding piece of code reads all <strong class="source-inline">*.json</strong> files in the <strong class="source-inline">class_sources</strong> folder and returns them to the caller to be installed.</p></li>
				<li>Now it's time to test the bundle. To make a rigorous test, we should create a new environment, move the bundle to the environment, and test it. However, this way requires time and effort, and it is not relevant for this explanation, so we will use a shortcut.<p>Because we do not have any database migrations or unreversible activities, we will use the current installation. The first operation is to delete the classes you have exported. That is mandatory<a id="_idIndexMarker742"/> because our procedure will otherwise skip the creation (see <em class="italic">step 7</em>). You can do that by right-clicking on the class name and then hitting <strong class="bold">Delete</strong>, as shown in the next figure:</p><div id="_idContainer169" class="IMG---Figure"><img src="image/B17073_11_05.jpg" alt="Figure 11.5: How to delete a class&#13;&#10;"/></div><p class="figure-caption">Figure 11.5: How to delete a class</p></li>
				<li>Now we have to trick Pimcore by telling it that our bundle is installable. To do this, implement<a id="_idIndexMarker743"/> the <strong class="source-inline">canBeInstalled</strong> method in the installer<a id="_idIndexMarker744"/> class, returning <strong class="source-inline">true</strong> (which means "yes, it can be installed!"). Copy the following piece of code and paste it to your file:<p class="source-code">public function canBeInstalled(){</p><p class="source-code">Â Â Â Â Â Â Â Â return true;</p><p class="source-code">Â Â Â Â } </p><p>The next screenshot shows the change before and after the method is implemented:</p><div id="_idContainer170" class="IMG---Figure"><img src="image/B17073_11_06.jpg" alt="Figure 11.6: Comparing bundle settings before and after changing the flag&#13;&#10;"/></div><p class="figure-caption">Figure 11.6: Comparing bundle settings before and after changing the flag</p><p>The previous screenshot shows how the installation status changes as we alter the <strong class="source-inline">canBeInstalled</strong> method. The first flag matrix is the output of the <strong class="source-inline">pimcore:bundle:list</strong> command, and you can see that the bundle is marked as not installable. After the change in the installer class, the installable flag becomes active and Pimcore<a id="_idIndexMarker745"/> will let us install the bundle again.</p></li>
				<li>Finally, it's time to test the bundle's installer<a id="_idIndexMarker746"/>. Go to the <strong class="bold">Admin UI</strong>, navigate to <strong class="bold">Tools </strong>| <strong class="bold">Bundles</strong>, and then click the green plus icon, or run <strong class="source-inline">bin/console pimcore:bundle:install BlogBundle</strong> from the command line:<div id="_idContainer171" class="IMG---Figure"><img src="image/B17073_11_07.jpg" alt="Figure 11.7: The extension panel now lets you install the bundle again&#13;&#10;"/></div><p class="figure-caption">Figure 11.7: The extension panel now lets you install the bundle again</p><p>As you can see in the previous screenshot, the options available in the UI reflect the information gathered from the console. </p></li>
				<li>Navigate to the class list. You will find the <strong class="source-inline">test</strong> class that you deleted on the menu again because it was recreated by the install process:</li>
			</ol>
			<div>
				<div id="_idContainer172" class="IMG---Figure">
					<img src="image/B17073_11_08.jpg" alt="Figure 11.8: The created class&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 11.8: The created class</p>
			<p>In this section, we covered how the installation process works. In the next section, we will take care of the schema update and data seeding using migrations.</p>
			<h2 id="_idParaDest-205"><a id="_idTextAnchor206"/>Migrations</h2>
			<p>The purpose of migrations<a id="_idIndexMarker747"/> is to manage data migration and schema updates. This is very useful if you are working with a custom database structure. The basic concept of migration<a id="_idIndexMarker748"/> is that it starts with an existing version that can be incremented by applying a delta of changes. The migration can be reversed by implementing a rollback function. To be more concrete, a migration in Pimcore is a class implementation that has two methods: up (to apply changes) and down (to revert changes).</p>
			<p>The migration process is explained in the<a id="_idIndexMarker749"/> following diagram:</p>
			<div>
				<div id="_idContainer173" class="IMG---Figure">
					<img src="image/B17073_11_09.jpg" alt="Figure 11.9: The migration process&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 11.9: The migration process</p>
			<p>As you can see in the previous figure, after an update, version 1.0 is updated to 1.1, but if there is a rollback, the down method brings it back to the initial version. </p>
			<p>The first step of adding the ability to manage migrations to your application is to map a folder for the migration files to your namespace. To do so, just open the <strong class="source-inline">/config/config.yml</strong> file and add the following snippet:</p>
			<p class="source-code">doctrine_migrations:</p>
			<p class="source-code">Â Â Â Â Â Â migrations_paths:</p>
			<p class="source-code">Â Â Â Â Â Â Â Â Â Â 'App\Migrations': 'src/Migrations'</p>
			<p>The previous piece of code maps your namespace with the related folder.</p>
			<p>For creating a migration class, the best method is to invoke the <strong class="source-inline">console</strong> command:</p>
			<p class="source-code">bin/console doctrine:migrations:generate --namespace=App\\Migrations</p>
			<p>The preceding command creates a <a id="_idIndexMarker750"/>file inside the migration folder of the main application. Each version has a generated name, such as <strong class="source-inline">/src/Migrations/Version20210227065641.php</strong>, where the <strong class="source-inline">Version</strong> prefix of the filename is followed by a timestamp.</p>
			<p>The created file will look<a id="_idIndexMarker751"/> something like the following:</p>
			<p class="source-code">&lt;?php</p>
			<p class="source-code">namespace App\Migrations;</p>
			<p class="source-code">â€¦ uses</p>
			<p class="source-code">class Version20210227065641 extends AbstractMigration</p>
			<p class="source-code">{</p>
			<p class="source-code">Â Â Â Â public function up(Schema $schema)Â Â Â Â {</p>
			<p class="source-code">Â Â Â Â Â Â Â Â Â Â //do things here</p>
			<p class="source-code">Â Â Â Â }</p>
			<p class="source-code">Â Â Â Â public function down(Schema $schema)Â Â Â Â {</p>
			<p class="source-code">Â Â Â Â Â Â Â Â Â Â //do things here</p>
			<p class="source-code">Â Â Â Â }</p>
			<p class="source-code">} </p>
			<p>The <strong class="source-inline">Schema</strong> object is a doctrine element that lets you manipulate the database structure. The following examples show the most important use cases, such as creating a table, adding fields, and dropping them:</p>
			<p class="source-code">Â Â Â Â Â Â Â Â $table = $schema-&gt;createTable('foo');</p>
			<p class="source-code">Â Â Â Â Â Â Â Â $table-&gt;addColumn('title', 'string');</p>
			<p class="source-code">Â Â Â Â Â Â Â Â $table-&gt;addColumn('description', 'string');</p>
			<p class="source-code">Â Â Â Â Â Â Â Â $schema-&gt;dropTable('foo');</p>
			<p class="callout-heading">Important Note</p>
			<p class="callout">For a complete overview of the Schema object's capabilities<a id="_idIndexMarker752"/>, take a look at the Symfony documentation: <a href="https://www.doctrine-project.org/projects/doctrine-dbal/en/latest/reference/schema-representation.ht">https://www.doctrine-project.org/projects/doctrine-dbal/en/latest/reference/schema-representation.html</a>.</p>
			<p>In this section, we learned<a id="_idIndexMarker753"/> how to create an installer to manage the setup <a id="_idIndexMarker754"/>of a bundle and manage data migration. This topic is very useful when you want to create a portable bundle or product based on Pimcore. Think, for example, of a bundle with all the bricks and utilities that you can use as the basis for your projects. In the next section, we will cover another important topic when we work with multiple environments in the same code base.</p>
			<h1 id="_idParaDest-206"><a id="_idTextAnchor207"/>Using a multi-environment configuration</h1>
			<p>In any modern deployment workflow, we have four environments: <strong class="source-inline">local</strong>, <strong class="source-inline">dev</strong>, <strong class="source-inline">test</strong>, and <strong class="source-inline">production</strong>. Each of these environments may have different configurations and tunings. Your production environment will probably have to face tons of users and a heavy load in a clustered<a id="_idIndexMarker755"/> system, while your local environment will just need to fight with the amount of RAM. What we see is that each environment has different needs, and consequently, needs different configurations. The approach that we want to follow is to keep all the data in a single code base and keep all the settings in the same place. If you are thinking that you'll need to manage a lot of files and complicated logic to switch them, you are wrong. </p>
			<p>Fortunately, Pimcore is based on Symfony and extends its very powerful configuration system. Pimcore manages <strong class="source-inline">dev</strong>, <strong class="source-inline">test</strong>, and <strong class="source-inline">prod</strong> environments natively (while others can be added with an additional configuration). To switch the environment, you have to specify the <strong class="source-inline">PIMCORE_ENVIRONMENT</strong> environment variable. Because our Pimcore instance runs in a container, this setting doesn't have any impact on our PC, as the configuration is limited to the container.</p>
			<p>Once the variable is set, Pimcore<a id="_idIndexMarker756"/> will load the files following this order:</p>
			<ol>
				<li value="1"><strong class="source-inline">config/pimcore/system_{env}.yml</strong></li>
				<li><strong class="source-inline">var/config/system_{env}.yml</strong></li>
				<li><strong class="source-inline">config/pimcore/system.yml</strong></li>
				<li><strong class="source-inline">var/config/system.yml</strong></li>
			</ol>
			<p>The configuration files can include other configuration files and inherit properties. The default setup that comes with a fresh Pimcore installation has an incremental configuration from <strong class="source-inline">dev</strong> to <strong class="source-inline">prod</strong> of the <strong class="source-inline">config.yml</strong> file (<strong class="source-inline">prod</strong> includes <strong class="source-inline">test</strong>, which includes <strong class="source-inline">dev</strong>). This mechanism is very useful for sharing settings and overriding them when needed.</p>
			<p>If you omit <strong class="source-inline">PIMCORE_ENVIRONMENT</strong>, the base files will be taken following the next escalation:</p>
			<ol>
				<li value="1"><strong class="source-inline">config/pimcore/system.yml</strong></li>
				<li><strong class="source-inline">var/config/system.yml</strong></li>
			</ol>
			<p>When you are running Pimcore from the console, you can pass the environment as an argument, like in the following example:</p>
			<p class="source-code">./bin/console --env=dev ...</p>
			<p>In a Pimcore environment, it is very important to have different configurations of Pimcore to match the different specifications of the environments where we will work. By the way, not all the configurations can be saved into the settings files for security reasons. In the next section, we will learn how to manage sensitive data, such as passwords and API keys, safely with Pimcore. </p>
			<h1 id="_idParaDest-207"><a id="_idTextAnchor208"/>Using Environment variables</h1>
			<p>The modern approach of using containers makes heavy use of environment variables for injecting values into applications. This approach is very convenient because it makes your application agnostic to the environment in which it will be deployed. This process implies that some part of the configuration is pulled from outside the application code.</p>
			<p>Moving all the configuration<a id="_idIndexMarker757"/> outside the application makes developers unaware of everything going on internally, and this creates misunderstandings between the developer and operations teams when problems occur. You have your local code and you can see it working, but you will have no idea what can happen in the production environment when other settings will be applied. Often, those who manage the operations don't know much about the meaning behind configurations because they are not experts on the applications and usually are not developers. Developers know how the application works and are aware of the impact of settings changes but know little about the infrastructure and cannot make tests to fix the problems that the application may have (they don't have access to the production environment).</p>
			<p>What we are going to explain in this section is a solution that can keep production settings safe, share configurations between developers and operations, and is easy to implement with Pimcore. A good compromise is to keep all the configuration in the source code but remove sensitive information that is injected during the deployment. Keeping the sensitive information separate from the configuration lets us share settings with the entire team and makes everybody aware of the configuration chosen but does not open us to security issues. This approach creates a clean division of responsibility and makes our repository safer. In that way, the developers are aware of the configuration in each environment, and operations can manage system settings independently.</p>
			<p>This solution has the positive side effect that the developers can test different configurations on their local PCs (but without accessing the production system) and the result is more predictable. But how is it possible to configure Pimcore to separate configurations from sensitive data? In the next example, we will create a configuration that will work in all environments but without adding sensitive data to the source code files. </p>
			<h2 id="_idParaDest-208"><a id="_idTextAnchor209"/>Using environment variables for managing database connections</h2>
			<p>We aim to have a Pimcore instance<a id="_idIndexMarker758"/> with the same configuration for the local, test, and production environments. The configuration will all be stored in the <strong class="bold">YAML</strong> files, but the right settings will be injected using an environment variable that will change based on the stage (<strong class="source-inline">dev</strong>, <strong class="source-inline">test</strong>, <strong class="source-inline">prod</strong>). The piece of configuration that we want to manage in that way is the configuration string<a id="_idIndexMarker759"/>. We will remove the hardcoded connection string of Pimcore, making it parametric. This data is usually set in the  <strong class="source-inline">config/local/database.yml</strong> file, and it is generated by Pimcore at the first installation; it is not usually committed. As we are using a Dockerized environment, all the developers that download the source code work locally in a separate environment, so there isn't any problem with sharing this information.</p>
			<p>We can now start work in these settings:</p>
			<ol>
				<li value="1">Delete or rename the <strong class="source-inline">database.yml</strong> file (we won't need it anymore).</li>
				<li>Add the following code to <strong class="source-inline">docker-compose.yml</strong>. This configuration will add the settings as <strong class="source-inline">environment</strong> variables:<p class="source-code">services:</p><p class="source-code"> â€¦</p><p class="source-code">Â Â php:</p><p class="source-code">Â Â Â â€¦</p><p class="source-code">Â Â Â environment: </p><p class="source-code">Â Â Â Â - PIMCORE_ENVIRONMENT=dev</p><p class="source-code">Â Â Â Â - PIMCORE_HOST=db</p><p class="source-code">Â Â Â Â - PIMCORE_DB=pimcore</p><p class="source-code">Â Â Â Â - PIMCORE_USERNAME=pimcore</p><p class="source-code">Â Â Â Â - PIMCORE_PASSWORD=pimcore</p><p class="source-code">Â Â Â Â - PIMCORE_PORT=3306 </p><p>The next figure shows a bare copy of the MySQL settings on the same file:</p><div id="_idContainer174" class="IMG---Figure"><img src="image/B17073_11_10.jpg" alt="Figure 11.10: Field mapping between containers&#13;&#10;"/></div><p class="figure-caption">Figure 11.10: Field mapping between containers</p></li>
				<li>Now we have to tell Pimcore<a id="_idIndexMarker760"/> to use this variable's configuration. The chain of dependencies is that <strong class="source-inline">config_prod.yml</strong> includes <strong class="source-inline">config_test.yml</strong> and  <strong class="source-inline">config_dev.yml</strong> includes <strong class="source-inline">config.yml</strong>. So, adding the proper configuration to the <strong class="source-inline">config</strong> or <strong class="source-inline">config_dev</strong> file will make it available for all the environments.</li>
				<li>Open <strong class="source-inline">config.yml</strong>. The first<a id="_idIndexMarker761"/> change to make is to disable the import of the database configuration. Just comment out the following line:<p class="source-code"># - { resource: 'local/' } removed... it users environments now!</p><p>The import of the <strong class="source-inline">local</strong> resource set is disabled (otherwise, you can just drop the <strong class="source-inline">database.yml</strong> file).</p></li>
				<li>Then add the following configuration to the file:<p class="source-code">doctrine:</p><p class="source-code">Â Â Â Â dbal:</p><p class="source-code">Â Â Â Â Â Â Â Â connections:</p><p class="source-code">Â Â Â Â Â Â Â Â Â Â Â Â default:Â Â Â Â Â Â Â Â Â Â Â Â Â Â </p><p class="source-code">Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â host: '%PIMCORE_HOST%'</p><p class="source-code">Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â port: '%PIMCORE_PORT%'</p><p class="source-code">Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â dbname: '%PIMCORE_DB%'</p><p class="source-code">Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â user: '%PIMCORE_USERNAME%' </p><p class="source-code">Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â password: '%PIMCORE_PASSWORD%'</p><p class="source-code">parameters:</p><p class="source-code">Â Â Â Â PIMCORE_ENVIRONMENT: '%env(PIMCORE_ENVIRONMENT)%'</p><p class="source-code">Â Â Â Â PIMCORE_HOST:Â Â '%env(PIMCORE_HOST)%'</p><p class="source-code">Â Â Â Â PIMCORE_DB:Â Â '%env(PIMCORE_DB)%'</p><p class="source-code">Â Â Â Â PIMCORE_USERNAME:Â Â '%env(PIMCORE_USERNAME)%'</p><p class="source-code">Â Â Â Â PIMCORE_PASSWORD:Â Â '%env(PIMCORE_PASSWORD)%'</p><p class="source-code">Â Â Â Â PIMCORE_PORT: '%env(PIMCORE_PORT)%'</p><p>The configuration is the same as <strong class="source-inline">database.yml</strong> but parametric. We define internal parameters<a id="_idIndexMarker762"/> that import the environment variable from the container. We used a 1:1 map, reusing the same name of the environment variables for the parameters. This makes<a id="_idIndexMarker763"/> the configuration easier to read. </p><p>Then we use the parameter in the <strong class="source-inline">doctrine\dbal\connection\default</strong> section of the file. This makes sure that Pimcore will activate a connection with this configuration, using the parameters that get values to form the host environment (the <strong class="source-inline">docker-compose</strong> file in our case).</p><p>After this step, we fully decouple the configuration from the data so we can set them separately. You can commit any configuration (<strong class="source-inline">dev</strong>, <strong class="source-inline">test</strong>, <strong class="source-inline">prod</strong>) without the fear that someone will steal sensitive data, and during the deployment, the right values will be injected into the environment (virtual machine or container).</p></li>
				<li>Open Pimcore and check whether you can log in. Because our changes are about the connection to the database, if we are able to log in, our new settings have been successful.</li>
			</ol>
			<p>In this section, we learned how to manage sensitive<a id="_idIndexMarker764"/> information in the Pimcore configuration and how to make variables without<a id="_idIndexMarker765"/> replicating the settings. Using containers is a useful solution because the container can be deployed as a standalone virtual machine, PC, or cloud service, meaning the solution covers most use cases. Moreover, having all the configurations on the source code makes it available to the developers, sharing a deeper awareness of how the platform will work in production. All the configurations can be easily tested locally and then committed. </p>
			<h1 id="_idParaDest-209"><a id="_idTextAnchor210"/>Summary</h1>
			<p>In this chapter, we learned some details of the Pimcore developer that are very important for finalizing our website.</p>
			<p>The multisite configuration allows us to use only one Pimcore instance to manage all the company's websites. This is a very interesting feature for saving time and money, using only one Pimcore installation to manage all the company websites.</p>
			<p>The installers give us the power to execute installation steps to recreate the configuration needed by our bundle. We can create data assets and perform updates on them. This means that we can take our bundle, install it on another Pimcore instance, and add all the classes and data that the bundle needs to work on. We also learned that we can manage the database changes at a low level.</p>
			<p>The multi-environment feature lets UX specify different configurations based on the environment we are using. This is very useful for keeping all the features in one code base. Moreover, we discovered how the powerful inheritance system of the configuration works.</p>
			<p>Environment variables can help make the configuration agnostic from the environment, and we learned how to remove sensitive data from files.</p>
			<p>Now our journey with the CMS part is almost completed, and we can move to the enterprise solutions that Pimcore has out of the box. In the next chapter, we will learn how to properly collect and store products in Pimcore and spread the information to all other applications. This is very important in enabling a company to use Pimcore as a PIM solution.</p>
		</div>
	</body></html>