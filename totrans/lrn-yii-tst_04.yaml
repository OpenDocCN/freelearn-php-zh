- en: Chapter 4. Isolated Component Testing with PHPUnit
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第4章：使用PHPUnit进行隔离组件测试
- en: In this chapter, we will take a closer look at **PHPUnit** and how it is handled
    by Codeception.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将更深入地探讨 **PHPUnit** 以及它是如何被Codeception处理的。
- en: We will start with a brief introduction of the changes that we need to perform
    before getting into the actual tests, and from there, go through the red, green,
    and refactor phases to implement the tests and our code and refactor where needed.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将简要介绍在开始实际测试之前需要进行的更改，然后从那里开始，通过红色、绿色和重构阶段来实现测试和我们的代码，并在需要时进行重构。
- en: We will introduce basic topics such as testing in isolation, integration tests
    of the components, and more advanced topics such as **data providers**.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将介绍基本主题，如隔离测试、组件的集成测试，以及更高级的主题，如 **数据提供者**。
- en: 'The following topics are covered in this chapter:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖了以下主题：
- en: Understanding the work to be done
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解需要完成的工作
- en: Using the `User` model
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `User` 模型
- en: Implementing the first unit test
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现第一个单元测试
- en: Component testing of the model
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模型的组件测试
- en: Implementing the `ActiveRecord` class and its methods
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现 `ActiveRecord` 类及其方法
- en: Seeing test passing
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 看到测试通过
- en: Understanding the work to be done
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解需要完成的工作
- en: In the scope of our work, we're going to introduce PHPUnit by first discussing
    the `User` model, how the authentication method works in Yii, and how it's going
    to be used in our specific case.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的工作范围内，我们将首先讨论 `User` 模型，如何在Yii中实现认证方法，以及它将如何在我们特定的案例中使用。
- en: After that, we will sketch our tests to cover all possible uses of the `User`
    class, refactor the model, and then aim to get the test passed.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将绘制测试草图以涵盖 `User` 类的所有可能用途，重构模型，然后努力通过测试。
- en: The current state of the framework that we have installed is not good enough
    for the features we want to implement.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 我们安装的框架当前状态不足以实现我们想要的功能。
- en: As underlined in the previous chapters, we're going to follow a TDD approach
    for this first part.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 如前几章所述，我们将遵循TDD方法进行这一部分。
- en: Using the User model
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 `User` 模型
- en: Let's start by having a look at how the `User` model is used in Yii.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先看看 `User` 模型在Yii中的使用方式。
- en: You can open the file located at `/models/User.php`.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以打开位于 `/models/User.php` 的文件。
- en: 'The first thing to notice is that the `User` class extends from a generic Yii
    `Object` class and implements `IdentityInterface`:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 首先要注意的是，`User` 类继承自通用的Yii `Object` 类并实现了 `IdentityInterface`：
- en: '[PRE0]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The `yii\base\Object` class is the parent class of all classes, which implements
    the concept of virtual attributes, with the use of dynamically invoked getters
    and setters, while `yii\web\IdentityInterface` provides the signature for methods
    we need to implement in our class to provide the authentication mechanism.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: '`yii\base\Object` 类是所有类的父类，它实现了虚拟属性的概念，通过动态调用的getter和setter来实现，而 `yii\web\IdentityInterface`
    提供了我们需要在我们的类中实现的方法签名，以提供认证机制。'
- en: You will also notice by the private property `$users` that the model does not
    connect to a database; instead, it holds all the authentication data within the
    class itself. This has been done on purpose by the Yii developers, in order to
    have everything working without additional effort. This not only alleviates the
    problem of massive refactors in case you're not using any authentication in your
    app, but it's also a good starting point if you need to learn how the authentication
    works.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 你也会注意到通过私有属性 `$users`，该模型并没有连接到数据库；相反，它将所有认证数据都存储在类本身中。这是Yii开发者有意为之，以便无需额外努力就能使一切正常工作。这不仅减轻了如果你在应用程序中未使用任何认证时的大规模重构问题，而且如果你需要学习认证的工作原理，这也是一个好的起点。
- en: Authentication in Yii is not particularly straightforward, and a lot of the
    mechanism for authenticating a user is kept hidden from us; so, unless you need
    to implement some level of robustness in your application, you don't normally
    have to worry too much.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: Yii中的认证并不特别直接，认证用户的大部分机制对我们来说是隐藏的；所以，除非你需要在你应用程序中实现某种程度的健壮性，否则你通常不必过于担心。
- en: 'Instead, what is important to notice is that the authentication information
    is kept in an object, separate from the `User` model. This mechanism provides
    a separate and clean layer of security. From here, the authentication status is
    kept into a dynamically loaded class of the `\yii\web\User` type, which is accessible
    throughout the whole life of the application via `Yii::$app->user`. For instance,
    to check whether the user is logged in, we can do the following:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，重要的是要注意，认证信息被保存在一个对象中，与`User`模型分开。这种机制提供了一个独立且干净的安保层。从这里，认证状态被保存在一个动态加载的`\yii\web\User`类型的类中，整个应用程序的生命周期内都可以通过`Yii::$app->user`访问。例如，要检查用户是否已登录，我们可以执行以下操作：
- en: '[PRE1]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: This is actually used in several views, and it's clearly similar to what was
    happening before in Yii 1.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 这实际上在几个视图中都有使用，并且显然与Yii 1中的情况相似。
- en: Having both static and private properties, as is the case with the `$users`
    variable in the `User` class, could make the job of testing our class quite hard,
    if not impossible, at times.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 类似于`User`类中的`$users`变量，既有静态又有私有属性，可能会使测试我们的类变得非常困难，有时甚至不可能。
- en: This is another reason why we need to modify the way it's defined entirely,
    and instead, the `User` class is extended from the `ActiveRecord` class and deals
    directly with the database. With this, we can make use of the fixtures that we
    can control without having to hardcode configuration settings or parameters in
    our tests, which could lead to unmaintainable tests, if not pointless ones.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们需要完全修改其定义方式的原因之一，因此`User`类从`ActiveRecord`类扩展，并直接与数据库交互。这样，我们可以利用我们可以控制的固定值，而无需在我们的测试中硬编码配置设置或参数，这可能导致测试难以维护，甚至毫无意义。
- en: Implementing the first unit test
  id: totrans-29
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现第一个单元测试
- en: Yii provides an empty `UserTest` class for us, so we're going to start working
    from there. Head over to `tests/codeception/unit/models/` and open the `UserTest.php`
    file.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: Yii为我们提供了一个空的`UserTest`类，因此我们将从这里开始工作。前往`tests/codeception/unit/models/`并打开`UserTest.php`文件。
- en: 'So now our question is: what are we going to implement at this point? Well,
    the answer will be quite simple, once we''ve understood what the aim of the unit
    tests is.'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们现在的问题是：我们在这个阶段要实现什么？好吧，一旦我们理解了单元测试的目标，答案将会非常简单。
- en: 'Unit tests, as well as functional and acceptance tests, are a black box testing
    system: The tests will simply use the interface provided by the object and will
    make sure that the outputs are as expected. Since the implementation doesn''t
    count if this changes slightly, or even radically, the tests should still pass
    assuming the interface remained the same.'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 单元测试，以及功能测试和验收测试，是一个黑盒测试系统：测试将简单地使用对象提供的接口，并确保输出符合预期。由于实现细节的微小变化或根本性的变化并不影响接口，因此只要接口保持不变，测试仍然应该通过。
- en: White box testing, which is provided by code coverage, will instead ensure that
    we have covered all the possible branches of our code. We will discuss this further
    in [Chapter 8](ch08.html "Chapter 8. Analyzing Testing Information"), *Analyzing
    Testing Information*.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 白盒测试，通过代码覆盖率提供，将确保我们覆盖了代码的所有可能分支。我们将在[第8章](ch08.html "第8章。分析测试信息")*分析测试信息*中进一步讨论这一点。
- en: Tip
  id: totrans-34
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: Unit tests also provide support for use cases that will document effectively
    the use of your interfaces to anyone in or outside your team.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 单元测试还提供了对用例的支持，这可以有效地记录你的接口的使用，无论是团队内部还是外部的人。
- en: 'So, whether we''re starting from scratch, adding new tests, or refactoring
    some existing ones, we have a few rules to help us achieve as much coverage as
    possible:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，无论我们是从头开始，添加新的测试，还是重构一些现有的测试，我们有一些规则可以帮助我们尽可能多地覆盖测试。
- en: Fix the existing broken tests (and raise relevant tickets if not related to
    our code or if the work ends up being *out of scope*).
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 修复现有的损坏测试（如果不涉及我们的代码或工作最终超出了范围，则提出相关票据）。
- en: Implement tests for the new smallest possible unit of code.
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为新的最小代码单元实现测试。
- en: Make tests independent from each other.
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使测试相互独立。
- en: Name tests properly. I've started using long names to understand with accuracy
    what could be wrong depending on which tests were failing, for example, `testMyMethodThrowsAnExceptionWhenInvokedWithNoParameters()`;
    you can clearly use any other naming standards, for instance, using `_` as a word
    separator instead of the camel case; the idea is to keep things readable and maintainable.
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 正确命名测试。我开始使用长名称来准确理解可能出错的地方，例如，`testMyMethodThrowsAnExceptionWhenInvokedWithNoParameters()`；你可以清楚地使用任何其他命名标准，例如，使用`_`作为单词分隔符而不是驼峰式；目的是保持可读性和可维护性。
- en: 'We also want to have a few basic rules that could guarantee a 360 degree usage
    overview so that we can see how to use our component and spot immediately if any
    of its uses are forbidden, useless, or anything else. These rules are as follows:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还希望有一些基本规则，可以保证360度的使用概述，这样我们就可以看到如何使用我们的组件，并立即发现其使用是否被禁止、无用或其他情况。这些规则如下：
- en: Cover normal usage of the class/method/whatever (positive test).
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 覆盖类/方法/什么的正常使用（正面测试）。
- en: Cover the extraordinary functionality of whatever you're testing, for example,
    when it returns the exception (in other words, when it should fail) (negative
    test).
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 覆盖你正在测试的任何异常功能，例如，当它返回异常时（换句话说，当它应该失败时）（负面测试）。
- en: This might be a bit off-putting, and this first step is possibly the most difficult
    that I've witnessed, on myself and on my colleagues. Countless times I've seen
    negative tests missing, creating a huge gap of potential vulnerabilities and fragility
    in the test.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能有点令人却步，而且这个第一步可能是我所见证的最困难的一步，无论是对我自己还是对我的同事。无数次的我看到负面测试缺失，造成潜在漏洞和脆弱性的巨大差距。
- en: Don't let yourself down; the reward, as we've seen in [Chapter 1](ch01.html
    "Chapter 1. The Testing Mindset"), *The Testing Mindset*, is priceless.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 不要让自己失望；正如我们在[第1章](ch01.html "第1章. 测试心态")《测试心态》中看到的，奖励是无价的。
- en: As soon as you start, consider yourself a tester, which is the first and most
    important step for ensuring the quality of the code that you ship, you can see
    what you've achieved with an improved sense of confidence in your code.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦开始，就把自己当作测试人员，这是确保你发布的代码质量的第一步和最重要的一步，你可以通过提高你对代码的信心来看到你所取得的成就。
- en: How much to care for other people's code
  id: totrans-47
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 对他人代码的关心程度
- en: Not all the code you're going to test will be the product of your effort.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 你将要测试的所有代码并不都是你努力的结果。
- en: When working with Yii, we will start testing code or integrations with code
    that comes from Yii itself, or most likely as in a real-world project, from someone
    else internally or externally from your team.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 当与Yii一起工作时，我们将开始测试来自Yii本身的代码或集成，或者更有可能的是，在现实世界的项目中，来自团队内部或外部的人。
- en: Sometimes, it's safe to say that you don't need to test anything that is outside
    your scope, for many reasons. But, it's also important to understand what the
    implied risk of not testing these features is.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候，可以说你不需要测试超出你范围的东西，有很多原因。但是，了解不测试这些功能所隐含的风险也很重要。
- en: 'Think, for instance, about the password verification of the `User` model, which
    we will be addressing a few pages further on: the possibility of being unable
    to verify a saved password is something we need to avoid, as its risk could compromise
    the overall functionality of our application and have as a consequence the inability
    of the user to log into our application.'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，考虑一下`User`模型的密码验证，我们将在几页后讨论：无法验证保存的密码的可能性是我们需要避免的，因为其风险可能会损害我们应用程序的整体功能，并导致用户无法登录我们的应用程序。
- en: Note
  id: totrans-52
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: As explained in [Chapter 1](ch01.html "Chapter 1. The Testing Mindset"), *The
    Testing Mindset*, and in [Chapter 2](ch02.html "Chapter 2. Tooling up for Testing"),
    *Tooling up for Testing*, **Attributes-Components-Capabilities** (**ACC**) might
    be something you should be starting to look into if you need this understanding
    of the risks related to the piece of functionality that you're building.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 如在第1章《测试心态》和第2章《为测试做准备》中所述，**属性-组件-能力**（**ACC**）可能是如果你需要了解你构建的功能相关的风险，你应该开始了解的东西。
- en: 'In our specific case, our tests will be concentrating on bits of functionality
    provided by the parent class and the interface, such as the following:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们具体的情况下，我们的测试将集中在父类和接口提供的功能片段上，例如以下内容：
- en: Validating the `User` model (this is clearly needed as it's a functionality
    that is also triggered immediately by the `save()` method).
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Saving the `User` model in the database.
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Covering the basic usage for the functions we will have to implement from the
    interface.
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It should suffice to say that in some cases, this might fall out of scope. If
    we were taking into consideration the higher level of abstraction from a BDD point
    of view, the kind of tests we would be interested in would be the interaction
    with the `User` class, as in reading it from the database and how it will be used
    by other components.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
- en: Component testing of the model
  id: totrans-59
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Testing the validation of a model and any further data manipulation, until it
    reaches the database and comes back, is the basic step in Yii to ensure that the
    model has clear and well-defined validation rules implemented. This is effectively
    useful when it comes down to preventing clients from being able to pass additional
    or wrong data, when interacting with the system.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
- en: If you care about security, this is something you might need to investigate
    a bit further, if you haven't done it already.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  id: totrans-62
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'I''d like to stress the position we''ve taken in the previous statement: We''re
    taking the consumer/client perspective. At this particular moment, we don''t know
    how things are going to be implemented, so it''s better to focus on the usage
    of the model.'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
- en: 'So, let''s get back to `/tests/codeception/unit/ models/UserTest.php`: The
    file should already be there, and it''s more or less what you would get by running
    the following command:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Right now, if you were to run this command, you would end up with a test that
    you would need to slightly change, so that we could use the Yii infrastructure.
    In particular, you would need to change the class your test was extending from
    with the following:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: In other words, we need to use the provided `\yii\codeception\TestCase` class,
    instead of the PHPUnit default `\PHPUnit_Framework_TestCase` class.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
- en: 'So, let''s first sketch down a few tests within our `tests\codeception\unit\models\UserTest`
    class:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: As you can see, knowing what to test requires insight on how Yii works. So,
    it might be completely fine to actually get the first test sketches completely
    wrong, if you don't know how things are intended to work.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
- en: In the preceding code snippet, we've defined two tests; the first is what we've
    called the *negative* and the second is the *positive* one.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  id: totrans-73
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Please note that passing the second parameter to the various assert commands
    will help you debug the tests in case they're failing. Writing a descriptive and
    meaningful message could save time.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-75
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In the code snippets of this book, the second parameter of the various assert
    methods will not be passed, in order to keep the code snippets more compact.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
- en: What's testing for PHPUnit
  id: totrans-77
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Before we continue with the rest of our tests, let''s review what we''ve got
    up until here: The test file is a class with a name in the `<Component>Test` format,
    which collects all tests relating to the component we want to test; each method
    of the class is a test of a specific feature, either positive or negative.'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们继续进行其他测试之前，让我们回顾一下到目前为止我们所拥有的内容：测试文件是一个以 `<Component>Test` 格式命名的类，它收集了我们想要测试的组件的所有测试；类的每个方法是对特定功能的测试，无论是正面还是负面。
- en: Each method/test in the class should have at least one assertion, and PHPUnit
    provides a long list of assertion statements that you can trigger to assert that
    an actual value matches an expected value, together with methods to expect for
    a specific exception.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 类中的每个方法/测试至少应包含一个断言，PHPUnit 提供了一系列断言语句，你可以触发它们来断言实际值与预期值匹配，以及用于期望特定异常的方法。
- en: These methods are provided by the parent class `TestCase`. You can get the full
    list at [https://phpunit.de/manual/current/en/appendixes.assertions.html](https://phpunit.de/manual/current/en/appendixes.assertions.html).
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 这些方法由父类 `TestCase` 提供。你可以在 [https://phpunit.de/manual/current/en/appendixes.assertions.html](https://phpunit.de/manual/current/en/appendixes.assertions.html)
    获取完整的列表。
- en: 'Some basic assertions are as follows:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 一些基本的断言如下：
- en: '`assertTrue(actualValue)` and its opposite `assertFalse(...)`'
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`assertTrue(actualValue)` 和其对立面 `assertFalse(...)`'
- en: '`assertEquals(expectedValue, actualValue)` and its opposite `assertNotEquals(...)`'
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`assertEquals(expectedValue, actualValue)` 和其对立面 `assertNotEquals(...)`'
- en: '`assertNull(actualValue)`'
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`assertNull(actualValue)`'
- en: The result of your test is based on the output of these methods. You should
    also try to avoid wrapping some assertions within one or more conditions. Think
    carefully about what you're trying to achieve and what you're actually testing.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 你的测试结果基于这些方法的输出。你也应尽量避免将一些断言包裹在一个或多个条件中。仔细思考你试图实现的目标以及你实际上在测试的内容。
- en: 'As for exceptions, you need to use some documentation annotation:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 对于异常，你需要使用一些文档注释：
- en: Note
  id: totrans-87
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: PHPUnit uses documentation annotations extensively to cover what's not normally
    doable with in-test assertions.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: PHPUnit 广泛使用文档注释来覆盖通常无法通过测试断言实现的功能。
- en: On top of what we will see, there's plenty of other functionalities, such as
    testing dependencies with `@depends`, `@before`, and `@after` or grouping with
    `@group`.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 除了我们将要看到的内容之外，还有很多其他功能，例如使用 `@depends`、`@before` 和 `@after` 测试依赖项或使用 `@group`
    进行分组。
- en: For a full list of annotations you can use, head over to [https://phpunit.de/manual/current/en/appendixes.annotations.html](https://phpunit.de/manual/current/en/appendixes.annotations.html).
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用 [https://phpunit.de/manual/current/en/appendixes.annotations.html](https://phpunit.de/manual/current/en/appendixes.annotations.html)
    查看你可以使用的完整注释列表。
- en: 'Consider the following example:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下示例：
- en: '[PRE5]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: On top of `@expectedException`, you can also use `@expectedExceptionCode` and
    `@expectedExceptionMessage`, in case you need to ensure that the content of the
    exception is what you are expecting it to be.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 除了 `@expectedException` 之外，你还可以使用 `@expectedExceptionCode` 和 `@expectedExceptionMessage`，以防你需要确保异常的内容是你期望的。
- en: Another way to do this is to use the `setExpectedException()` method, which
    might provide a higher level of flexibility when you have more complex exception
    cases to deal with.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种实现方式是使用 `setExpectedException()` 方法，当需要处理更复杂的异常情况时，这可能会提供更高层次的可灵活性。
- en: Tip
  id: totrans-95
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: Although very generic, we can also expect language-specific errors when passing
    a different type to a method with a typed formal parameter, or when trying to
    include a non-existing file by using `@expectedException PHPUnit_Framework_Error`.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然非常通用，但在将不同类型传递给具有类型形式参数的方法或尝试使用 `@expectedException PHPUnit_Framework_Error`
    包含一个不存在的文件时，我们也可以期望出现特定于语言的错误。
- en: Assertion testing in PHPUnit is quite straightforward once you've got a grip
    on how your class, model, and method are going to be used.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦掌握了你的类、模型和方法的使用方式，PHPUnit 中的断言测试就相当直接。
- en: On top of this, PHPUnit provides some clever functionality to help us speed
    up testing and solve some intricacies. Data providers, fixtures, stubs, and mocks
    will be covered later on and in [Chapter 5](ch05.html "Chapter 5. Summoning the
    Test Doubles"), *Summoning the Test Doubles*.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，PHPUnit 还提供了一些巧妙的功能来帮助我们加快测试速度并解决一些复杂性。数据提供者、固定值、存根和模拟将在后续章节和 [第5章](ch05.html
    "第5章。召唤测试替身") 中介绍，*召唤测试替身*。
- en: Testing the methods inherited by IdentityInterface
  id: totrans-99
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 测试继承自 IdentityInterface 的方法
- en: Now that we know everything we need to in order to start, we would normally
    decide to implement the rules to make the `testValidateReturnsTrueIfParametersAreSet()`
    and `testValidateReturnsTrueIfParametersAreNotSet()`tests pass, although at this
    occasion, it seems much easier to just continue sketching the remaining methods
    that we would need to implement later on, such as `getId()`, `getAuthKey()`, `validateAuthKey()`,
    `findIdentity()`, and `findIdentityByAccessToken()`, plus two more methods that
    have been implemented and used already, namely `validatePassword()` and `findByUsername()`,
    both used by the `LoginForm` model.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们知道了启动所需的一切，我们通常会决定实现规则，使 `testValidateReturnsTrueIfParametersAreSet()` 和
    `testValidateReturnsTrueIfParametersAreNotSet()` 测试通过，尽管在这个场合，似乎继续草拟我们稍后需要实现的其他方法要容易得多，例如
    `getId()`、`getAuthKey()`、`validateAuthKey()`、`findIdentity()` 和 `findIdentityByAccessToken()`，以及两个已经实现并使用的方法，即
    `validatePassword()` 和 `findByUsername()`，这两个方法都由 `LoginForm` 模型使用。
- en: 'We can immediately decide to get rid of the simplest methods to cover. We''re
    not going to make any use of the access token, and normally, if we weren''t forced
    to implement the method by the interface, we could have just avoided this bit.
    In this case, instead, we need to get it sorted and the best way to document this
    missing functionality is to raise `NotSupportedException` from the method and
    expect such an exception:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以立即决定去除最简单的方法来覆盖。我们不会使用访问令牌，并且通常，如果我们不是被迫通过接口实现该方法，我们就可以避免这部分。在这种情况下，相反，我们需要整理并最好通过从方法中抛出
    `NotSupportedException` 并期望这种异常来记录缺失的功能：
- en: '[PRE6]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Following this method, we test `getId()`:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 按照这种方法，我们测试 `getId()`：
- en: '[PRE7]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: We can use the exact same logic to test `$user->getAuthkey()`.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用完全相同的逻辑来测试 `$user->getAuthkey()`。
- en: 'While for `findIdentity()`, we can do the following:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 `findIdentity()`，我们可以做以下操作：
- en: '[PRE8]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'With `findIdentity()`, we want to make sure the object returned is the one
    we were expecting, so our assertions ensure that:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `findIdentity()`，我们想确保返回的对象是我们期望的，因此我们的断言确保：
- en: there's a record retrieved
  id: totrans-109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 已检索到一条记录
- en: it's of the right class (`IdentityInterface` is what most of the methods interacting
    with the user at authentication time will expect it to be)
  id: totrans-110
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 它属于正确的类别（`IdentityInterface` 是在认证时与用户交互的大多数方法期望它成为的类型）
- en: it contains what we've passed when creating it
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 它包含我们在创建时传递的内容
- en: Using data providers for more flexibility
  id: totrans-112
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用数据提供者以获得更多灵活性
- en: 'The negative test for `findIdentity()` is quite straightforward:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: '`findIdentity()` 的负面测试相当直接：'
- en: '[PRE9]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Implementing a test like this might raise some eyebrows, as we've hardcoded
    a value, `-1`, which might not be representative of any actual real-world case.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 实现这样的测试可能会引起一些疑问，因为我们硬编码了一个值 `-1`，这可能不代表任何实际的真实世界案例。
- en: 'The best way would be to use a **data provider**, which can feed our test with
    a list of values that should make the test pass. This is quite convenient as we
    can tailor edge cases when it comes down to doing some regression testing on the
    existing features:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 最好的方法就是使用 **数据提供者**，它可以为我们提供一系列值，这些值应该能让测试通过。这非常方便，因为我们可以在进行回归测试现有功能时定制边缘情况：
- en: '[PRE10]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: In a data provider, each second-level array is a call to the function requesting
    it and the content of these arrays is the ordered list of the actual parameters
    of the method.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 在数据提供者中，每个二级数组是对请求函数的调用，这些数组的内容是方法的实际参数的有序列表。
- en: So, in our preceding case, the test will receive `-1`, `null`, and `30` in consecutive
    invocations.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在我们的前一个例子中，测试将连续调用时接收到 `-1`、`null` 和 `30`。
- en: If we were to use a data provider for our initial test `testFindIdentityReturnsTheExpectedObject()`,
    we could test whether the username contains UTF-8 or invalid characters, for instance.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们要为我们的初始测试 `testFindIdentityReturnsTheExpectedObject()` 使用数据提供者，我们可以测试用户名是否包含
    UTF-8 或无效字符，例如。
- en: So, using data providers is a good thing! It gives us the ability to use a single
    test to check more complex situations that require a certain level of flexibility.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，使用数据提供者是一件好事！它赋予我们使用单个测试来检查更复杂情况的能力，这些情况需要一定程度的灵活性。
- en: 'But here comes the problem: The database that is used during all tests (with
    `$user->save()`) will continue to grow, as there is no instruction to tell it
    to do otherwise.'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 但问题来了：在所有测试中使用的数据库（使用 `$user->save()`）将继续增长，因为没有指令告诉它这样做。
- en: 'As a result, we can add the following to the `setUp()` function:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们可以在 `setUp()` 函数中添加以下内容：
- en: '[PRE11]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Remember to clean up after yourself: You might be impacting someone else''s
    test. For now, with this call to `deleteAll()` in place, we are fine.'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 记得清理自己的工作：您可能会影响其他人的测试。目前，由于 `deleteAll()` 调用的存在，我们一切正常。
- en: 'The `setUp()` function is called at the beginning before every single test
    contained in the class. PHPUnit provides several layers of methods for setting
    things up before one or more tests, and unsetting them after. The sequence of
    calls can be summed up with the following:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: '`setUp()` 函数在每个测试开始之前被调用。PHPUnit 提供了多层方法来在单个或多个测试之前设置一些东西，并在测试之后撤销它们。调用顺序可以用以下内容总结：'
- en: '[PRE12]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Here, `setUpBeforeClass()` is the most external call possible that is run before
    the class is instantiated. Please also note that `_before` and `_after` are Codeception
    `TestCase` methods, while the rest are standard PHPUnit methods.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`setUpBeforeClass()` 是在类实例化之前可能的最外层调用。请注意，`_before` 和 `_after` 是 Codeception
    `TestCase` 方法，而其余的是标准的 PHPUnit 方法。
- en: 'Since we are here, we could also add a test-wide `User` class that will be
    instantiated before each test; it can be used by any of our tests. For this to
    happen, we need to add a private variable and add the related statement, where
    needed:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们在这里，我们也可以添加一个测试范围的 `User` 类，它将在每个测试之前实例化；它可以被我们的任何测试使用。为了实现这一点，我们需要添加一个私有变量，并在需要的地方添加相关语句：
- en: '[PRE13]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Now, we just need to amend the relevant tests to use `$this->_user` when needed.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们只需要修改相关的测试，在需要时使用 `$this->_user`。
- en: Tip
  id: totrans-132
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: Try to keep private variables and methods clearly visible; this could also help
    you avoid naming conflicts, as we will see when introducing fixtures.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 尽量使私有变量和方法清晰可见；这也有助于您避免命名冲突，正如我们在介绍固定配置时将看到的。
- en: Using fixtures to prepare the database
  id: totrans-134
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用固定配置准备数据库
- en: As we've seen, the data provider solution helps you run the same test with a
    different dataset each time, which ends up being extremely useful. Another and
    possibly complimentary solution is to use fixtures that let you preload some well-defined
    data and keep tests even more simple. This would mean being able to test methods
    such as `User::findIdentity()` without having to rely on `$user->save()`, which
    is not a part of the test itself.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所看到的，数据提供者解决方案可以帮助您每次运行相同的测试时使用不同的数据集，这最终变得极其有用。另一个可能互补的解决方案是使用固定配置，让您预加载一些定义良好的数据，并使测试更加简单。这意味着您可以在不依赖于
    `$user->save()`（这不是测试本身的一部分）的情况下测试 `User::findIdentity()` 方法。
- en: Fixtures are used to set the database at a fixed/known state so that your tests
    can run in a controlled environment. In doing this, we will also eliminate the
    need to delete all users in the `setUp` function or rely on static values that
    might be influenced by other previously run tests.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 固定配置用于将数据库设置在固定/已知的状态，以便您的测试可以在受控环境中运行。在这个过程中，我们也将消除在 `setUp` 函数中删除所有用户或依赖于可能受先前运行测试影响的静态值的需求。
- en: The fixture is just a class that is dynamically loaded in the `setUp()` method,
    and you're left with only the task of creating the fixture class and the actual
    content for the database.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 固定配置只是一个在 `setUp()` 方法中动态加载的类，您只需创建固定配置类和数据库的实际内容即可。
- en: 'Let''s start by creating the fixture class:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从创建固定配置类开始：
- en: '[PRE14]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: In this case, we're extending from `ActiveFixture` as it will provide some additional
    functionality that might be useful, so the only thing we need to do is to define
    the model it will mimic. The alternative, as for login forms or other custom-made
    models, is to extend from `yii\test\Fixture`, where you have to define the table
    name by using the public property `$tableName`. With `ActiveFixture`, by just
    defining `$className`, the fixture will figure out the table name by itself.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们扩展了 `ActiveFixture`，因为它将提供一些可能有用的附加功能，所以我们唯一需要做的是定义它将模拟的模型。对于登录表单或其他自定义模型，另一种选择是扩展
    `yii\test\Fixture`，在那里您必须使用公共属性 `$tableName` 定义表名。使用 `ActiveFixture`，只需定义 `$className`，固定配置就会自己确定表名。
- en: 'The next step is to define the actual fixture that will define the content
    we want to fill into our database. By default, Yii will try to look for a file
    named `<table_name>.php` within the `fixtures/data/` folder. The fixture is just
    a return statement of an array, such as the following:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是定义实际要填充到数据库中的内容所对应的固定配置。默认情况下，Yii 将尝试在 `fixtures/data/` 文件夹中查找名为 `<table_name>.php`
    的文件。固定配置只是一个返回数组的语句，例如以下内容：
- en: '[PRE15]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Each entry of the fixture can be key-indexed to quickly reference it in our
    tests. You don't also normally need to specify the primary key as they will be
    automatically created, as in the case of `ActiveRecord`.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 固定装置的每个条目都可以被键索引，以便在测试中快速引用。你通常也不需要指定主键，因为它们将自动创建，就像在`ActiveRecord`的情况下。
- en: 'As a last step, we need to implement the `fixtures()` method to define which
    fixtures we want to use in our tests. To do so, we can use the following code:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 作为最后一步，我们需要实现`fixtures()`方法来定义我们想要在测试中使用的固定装置。为此，我们可以使用以下代码：
- en: '[PRE16]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'By doing this, our `setUp()` method will initialize the database with the content
    of the fixture we''ve just defined. If we were in need to use more than one fixture
    for the same fixture class, then we could have specified which fixture to load
    in the current test by also returning a `dataFile` key that specified the path
    of the fixture, as in the following example:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这样做，我们的`setUp()`方法将使用我们刚刚定义的固定装置的内容初始化数据库。如果我们需要为同一个固定装置类使用多个固定装置，那么我们可以在当前测试中指定要加载哪个固定装置，同时返回一个`dataFile`键，指定固定装置的路径，如下例所示：
- en: '[PRE17]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Now that we have the fixture defined and ready to be used, we can access its
    content via the `$this->user` variable (and now you can see why it's better to
    keep private and public variables well defined and separate). You can normally
    use it as an array and access the index or key you need, or let it return an `ActiveRecord`
    object as with `$this->user('admin')`.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经定义了固定装置并准备好使用，我们可以通过`$this->user`变量（现在你可以看到为什么最好将私有和公共变量定义得很好并分开）来访问其内容。你可以通常将其用作数组并访问所需的索引或键，或者让它返回一个`ActiveRecord`对象，就像`$this->user('admin')`。
- en: 'Now, we can see it in action by refactoring our previously implemented test:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以通过重构我们之前实现的测试来看到它的实际效果：
- en: '[PRE18]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: This way, we can carry on with our tests without worrying about calling `save()`
    every time we need to ensure that a record is in the database.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，我们就可以继续我们的测试，而不用担心每次需要确保记录在数据库中时都要调用`save()`。
- en: 'This also means that we won''t need to clean up the database, as the fixture
    will do so for us:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 这也意味着我们不需要清理数据库，因为固定装置会为我们完成这项工作：
- en: '[PRE19]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Following what we just said, it should be quite straightforward to implement
    tests for `findByUsername()` in the same way as we did for `findIdentity()`. So,
    I'll leave this for you as an exercise.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 根据我们刚才说的，实现`findByUsername()`的测试应该相当简单，就像我们为`findIdentity()`做的那样。所以，我将把它留给你作为练习。
- en: Adding the remaining tests
  id: totrans-155
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 添加剩余的测试
- en: By now, we should have almost all the tests created, apart from the ones covering
    `validateAuthKey()`, which you should be able to implement without any particular
    problem, and `validatePassword()`, which we will take a closer look at in [Chapter
    5](ch05.html "Chapter 5. Summoning the Test Doubles"), *Summoning the Test Doubles*.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们应该已经创建了几乎所有测试，除了覆盖`validateAuthKey()`的测试，你应该能够没有特别的问题实现它，以及`validatePassword()`，我们将在[第5章](ch05.html
    "第5章。召唤测试替身")中更详细地探讨，*召唤测试替身*。
- en: Implementing the ActiveRecord class and its methods
  id: totrans-157
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现ActiveRecord类及其方法
- en: 'Now, we can try the tests and see them not passing before we go through the
    implementation of the class. So, just run the following command, as we learned
    in the previous chapter:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以在通过类的实现之前尝试测试，并看到它们没有通过。所以，只需运行以下命令，就像我们在上一章中学到的那样：
- en: '[PRE20]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'It''s very probable that the preceding command will fail with the following
    error:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 很可能，前面的命令会失败，并出现以下错误：
- en: '[PRE21]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: This is because our class has not yet been regenerated as `ActiveRecord`.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 这是因为我们的类尚未被重新生成为`ActiveRecord`。
- en: In the next section, we will start the work of making our tests pass by starting
    with the migrations to move some information into the database and progress from
    there.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将开始使测试通过的工作，从迁移开始，将一些信息移动到数据库中，并从这里继续前进。
- en: Dealing with migrations
  id: totrans-164
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 处理迁移
- en: So, the best step forward is to define a user table in the database, fill it
    with the data we would need, and then implement the user model on top of it with
    the required methods from the interface.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，最好的下一步是定义一个用户表，填充我们所需的数据，然后在上面实现用户模型，并使用接口中所需的方法。
- en: Note
  id: totrans-166
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: There is more to be said about migrations and the documentation about it is
    being improved and expanded every day. Be sure to head over and have a read for
    yourself at [http://www.yiiframework.com/doc-2.0/guide-db-migrations.html](http://www.yiiframework.com/doc-2.0/guide-db-migrations.html).
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 关于迁移还有很多要说的，关于它的文档正在不断改进和扩展。请确保前往并亲自阅读[http://www.yiiframework.com/doc-2.0/guide-db-migrations.html](http://www.yiiframework.com/doc-2.0/guide-db-migrations.html)。
- en: 'Let''s start by creating the migration:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从创建迁移开始：
- en: '[PRE22]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Now that we have the migration, let''s implement the `up()` and `down()` methods
    as needed:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了迁移，让我们根据需要实现`up()`和`down()`方法：
- en: '[PRE23]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: We use the Security component provided by Yii to create the password. There
    are many other functions that are quite handy and avoid the need to reinvent the
    wheel.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用Yii提供的Security组件来创建密码。还有很多其他相当方便的功能，可以避免重新发明轮子。
- en: Please note that it's important to implement the `down()` method correctly and
    test it before pushing your changes, as it will be fundamental if you need to
    revert to a previous state of the application, also called a **roll back**.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，正确实现`down()`方法并在推送更改之前进行测试非常重要，因为如果你需要回滚到应用程序的先前状态，即所谓的**回滚**，它将是基础。
- en: Tip
  id: totrans-174
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: In addition to `up()` and `down()`, you can use `safeUp()` and `safeDown()`,
    which will allow you to run the migration up or down using transactions, which
    in turn means that in the case of an error, all prior operations will be rolled
    back automatically.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 除了`up()`和`down()`之外，你还可以使用`safeUp()`和`safeDown()`，这将允许你使用事务来运行迁移上下文，这意味着在出现错误的情况下，所有先前的操作将自动回滚。
- en: 'The migrations are implemented and used in the same way as in the case of Yii
    1, and if you''ve never used them before, they''re a great tool as they give you
    the ability to define specific steps that can be easily missed when deploying
    your application. The syntax used should also be quite straightforward to understand
    and the methods self-explanatory: `createTable()`, `renameColumn()`, `addForeignKey()`,
    and so on.'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 迁移的实现和使用方式与Yii 1的情况相同，如果你以前从未使用过它们，它们是伟大的工具，因为它们让你能够定义在部署应用程序时容易错过的特定步骤。所使用的语法也应该相当直观易懂，方法也是自我解释的：`createTable()`、`renameColumn()`、`addForeignKey()`等等。
- en: 'Now that we have our migration in place, it''s time to apply it by running
    the following command:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经设置了迁移，是时候通过运行以下命令来应用它：
- en: '[PRE24]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Now that we have the structure and the data in the database, we can start refactoring
    the model accordingly.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经在数据库中有了结构和数据，我们可以开始根据需要重构模型。
- en: The Gii code generation tool
  id: totrans-180
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Gii代码生成工具
- en: Yii continues to provide and improve its system of code generation tools, particularly
    **Gii**. Gii is a code generator that helps you create the basic code structure
    for models, controllers, CRUD, modules, and so forth, so that you don't have to
    think too much about what needs to be done and instead, get to the implementation
    part as quickly as possible.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: Yii持续提供并改进其代码生成工具系统，特别是**Gii**。Gii是一个代码生成器，它可以帮助你创建模型、控制器、CRUD、模块等的基本代码结构，这样你就不必过多考虑需要做什么，而是尽可能快地进入实现部分。
- en: 'The basic application that we''re using comes with Gii (and it''s defined as
    a `require-dev` package). And, since in our case we''re running the tests in a
    (virtual) hosted environment, we need to adjust the configuration a little bit;
    we need to allow our client IP to access the tool:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 我们所使用的基本应用程序包含Gii（并且它被定义为`require-dev`包）。由于在我们的情况下我们在（虚拟）托管环境中运行测试，我们需要稍微调整一下配置；我们需要允许我们的客户端IP访问该工具：
- en: '[PRE25]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: '`192.168.56.*` should be the default case if you''re using VirtualBox.'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用VirtualBox，则`192.168.56.*`应该是默认情况。
- en: 'Now that we have made this change, we can head our browsers to `http://basic.yii2.sandbox/gii`.
    From there, we can click on the **Model Generator** section, where we can create
    the new model, as shown in the following screenshot:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经做出了这个改变，我们可以将浏览器导航到`http://basic.yii2.sandbox/gii`。从那里，我们可以点击**模型生成器**部分，在那里我们可以创建新的模型，如下面的截图所示：
- en: '![The Gii code generation tool](img/B03646_04_01.jpg)'
  id: totrans-186
  prefs: []
  type: TYPE_IMG
  zh: '![Gii代码生成工具](img/B03646_04_01.jpg)'
- en: The model generator interface
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 模型生成器接口
- en: When clicking on the **Preview** button, Gii will first check whether the file(s)
    to be generated already exist and give us the opportunity to see the difference
    and decide whether we want to override the file(s) before we actually hit the
    **Generate** button.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 当点击 **预览** 按钮时，Gii 会首先检查要生成的文件是否已经存在，并给我们机会在真正点击 **生成** 按钮之前查看差异并决定是否要覆盖文件。
- en: Since our `User` model is so thin at the moment, we won't have any problems
    in overwriting it and re-implementing the needed methods ourselves. Just remember
    to tick the **Overwrite** check box and click on **Generate**. Otherwise, you
    can just adjust it accordingly with the hints given in the following paragraphs.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们的 `User` 模型目前非常简单，我们不会在覆盖它并重新实现所需的方法时遇到任何问题。只需记住勾选 **覆盖** 复选框并点击 **生成**。否则，你可以根据以下段落中给出的提示相应地调整它。
- en: After clicking on **Generate**, you should be able to see the **The code has
    been generated successfully** notice at the end of the page.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 点击 **生成** 后，你应该能够在页面底部看到 **代码已成功生成** 的提示。
- en: Now let's head back to our `User.php` class and see what's been changed, and
    refine the implementation.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们回到我们的 `User.php` 类，看看有什么变化，并完善实现。
- en: 'First of all, we will notice that the class now extends from the `ActiveRecord`
    class; this is the default class for database-facing models. There is a series
    of default methods already implemented, which we won''t need to change. What we
    would need instead is to make the class implement `IdentityInterface`, as follows:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们会注意到该类现在继承自 `ActiveRecord` 类；这是面向数据库的模型的默认类。已经实现了一系列默认方法，我们不需要修改。我们真正需要的是使该类实现
    `IdentityInterface`，如下所示：
- en: '[PRE26]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Now, implement the five required methods from `IdentityInterface` at the end
    of the class:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在类的末尾实现 `IdentityInterface` 的五个必需方法：
- en: '[PRE27]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: As we can see, the way to find a record in the database is quite straightforward,
    as `ActiveRecord` exposes some very nifty and easy-to-understand methods to interact
    with the database. We will be seeing plenty of these use cases across the upcoming
    pages.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，在数据库中查找记录的方式非常直接，因为 `ActiveRecord` 提供了一些非常巧妙且易于理解的方法来与数据库交互。我们将在接下来的几页中看到许多这样的用例。
- en: It's probably worth noticing that `findIdentity()` returns an `IdentityInterface`
    object. The previous implementation that we overwrote invoked `new static()`,
    which, in turn, triggered the magic method `__construct()` from the `yii\base\Object`
    class.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 值得注意的是，`findIdentity()` 返回一个 `IdentityInterface` 对象。我们之前覆盖的实现调用了 `new static()`，这反过来触发了来自
    `yii\base\Object` 类的魔法方法 `__construct()`。
- en: Note
  id: totrans-198
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The `new static()` method has been available since PHP 5.3 and provides a way
    to instantiate a child class statically from a parent, which wasn't possible earlier.
    This methodology is called **Late Static Binding**.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: '`new static()` 方法自 PHP 5.3 起就可用，提供了一种从父类静态实例化子类的方法，这在之前是不可能的。这种方法被称为 **后期静态绑定**。'
- en: More information can be found in the PHP manual at [http://php.net/manual/en/language.oop5.late-static-bindings.php](http://php.net/manual/en/language.oop5.late-static-bindings.php).
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 更多信息可以在 PHP 手册中找到，链接为 [http://php.net/manual/en/language.oop5.late-static-bindings.php](http://php.net/manual/en/language.oop5.late-static-bindings.php)。
- en: 'As mentioned earlier, `findIdentityByAccessToken` is not needed as `accessToken`
    will not be used anywhere in our code, so let''s implement it:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，`findIdentityByAccessToken` 不需要，因为 `accessToken` 在我们的代码中不会用到，所以让我们来实现它：
- en: '[PRE28]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'The remaining three methods from the interface should be straightforward to
    implement and understand, and to do so, we can use the following code:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 接口中的剩余三个方法应该很容易实现和理解，为此，我们可以使用以下代码：
- en: '[PRE29]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Left out from the obvious methods from the interface are a couple of methods
    that are used in `LoginForm.php`; one of them is `findByUsername`, which is as
    follows:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 接口中没有包含的明显方法中，有几个在 `LoginForm.php` 中使用；其中一个是 `findByUsername`，具体如下：
- en: '[PRE30]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Another is `validatePassword`, which is as follows:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个方法是 `validatePassword`，具体如下：
- en: '[PRE31]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Here, we again use the `validatePassword()` method from the Security component,
    which makes the use of cryptography and any additional level of security that
    we want to add transparent to the user.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们再次使用来自安全组件的 `validatePassword()` 方法，这使得使用加密和任何我们想要添加的额外安全级别对用户来说变得透明。
- en: Seeing tests pass
  id: totrans-210
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 看到测试通过
- en: 'As you might have guessed, it''s again time to run Codeception against our
    `UserTest` class:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所猜，又是时候运行 Codeception 对我们的 `UserTest` 类进行测试了：
- en: '[PRE32]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: You should have all tests passing without problems, and you should also be able
    to fix them in case an error is raised.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该能够通过所有测试而没有任何问题，并且你应该也能够在出现错误时修复它们。
- en: 'If we decide to run all the tests, including those that were already there,
    we might see that some tests are not passing anymore. Don''t worry, this is quite
    normal as we''ve changed the way the `User` model works and behaves internally.
    In particular, the error I''m getting is the following regarding `LoginFormTest`,
    but Codeception/PHPUnit is quite prompt in informing us what''s wrong:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们决定运行所有测试，包括那些已经存在的测试，我们可能会看到一些测试不再通过。不用担心，这是很正常的，因为我们已经改变了 `User` 模型的工作方式和内部行为。特别是，我得到的错误是关于
    `LoginFormTest` 的，但 Codeception/PHPUnit 在告诉我们出了什么问题方面非常迅速：
- en: '[PRE33]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: As I've underlined previously, it's quite important to fix any tests that do
    not work well. This will make us understand if we've touched anything that wasn't
    meant to break or that can potentially break when committing our changes.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我之前强调的，修复任何表现不佳的测试非常重要。这将使我们了解是否触及了不应该破坏或在我们提交更改时可能破坏的内容。
- en: Using global fixtures
  id: totrans-217
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用全局固定文件
- en: 'In this case, it''s quite clear that our tests have impacted the state of the
    database: The solution will be able to create a new fixture with the expected
    data for the admin user, which replicates what the migration is doing, and to
    update `LoginFormTest` and `UserTest`.'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，很明显我们的测试已经影响了数据库的状态：解决方案将能够创建一个新的固定文件，其中包含管理员用户的预期数据，这复制了迁移所做的工作，并更新
    `LoginFormTest` 和 `UserTest`。
- en: 'We will now use the default fixture `user.php` as the global fixture with the
    admin user, as follows:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在将使用默认的固定文件 `user.php` 作为具有管理员用户的全局固定文件，如下所示：
- en: '[PRE34]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'The previous fixture will be renamed as `userModels.php`; it contains additional
    users that we might end up adding to our application in the future. The code for
    doing so is as follows:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的固定文件将被重命名为 `userModels.php`；它包含我们可能最终添加到应用程序中的额外用户。执行此操作的代码如下：
- en: '[PRE35]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: We could have fallen into the trap of just amending the initial fixture to contain
    the admin user, which would have solved the problem but would have made multiple
    tests rely on fixtures that were designed for specific tests. So, let's try to
    keep things as separate and independent as possible.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 我们本可以陷入仅仅修改初始固定文件以包含管理员用户的陷阱，这会解决问题但会使多个测试依赖于为特定测试设计的固定文件。所以，让我们尽量保持事物尽可能分离和独立。
- en: 'Now, we can load the previously mentioned fixture in `LoginFormTest` as a global
    fixture, as follows:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以在 `LoginFormTest` 中将之前提到的固定文件作为全局固定文件加载，如下所示：
- en: '[PRE36]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Furthermore, we can amend the previously implemented methods to load the fixtures
    in the `UserTest`, as follows:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们可以修改之前实现的方法，在 `UserTest` 中加载固定文件，如下所示：
- en: '[PRE37]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Our new `fixtures()` implementation will need to expand on the parameters passed
    and define both `class` and `dataFile`; otherwise, it won't load it properly.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 我们新的 `fixtures()` 实现需要扩展传递的参数并定义 `class` 和 `dataFile`；否则，它将无法正确加载。
- en: The `globalFixtures()` method is run before the `fixtures()` method, which means
    that the `$this->user` variable will only contain the latest fixtures and not
    the admin.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: '`globalFixtures()` 方法在 `fixtures()` 方法之前运行，这意味着 `$this->user` 变量将只包含最新的固定文件，而不是管理员。'
- en: Summary
  id: totrans-230
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: We've discussed a wide variety of things concerning PHPUnit such as assertions,
    data providers, and fixtures. We've seen how to make tests pass and how to preventively
    catch errors that might cause bigger problems.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 我们讨论了许多关于 PHPUnit 的事情，例如断言、数据提供者和固定文件。我们看到了如何使测试通过以及如何预防性地捕获可能导致更大问题的错误。
- en: There are many more things you can discover on both Codeception unit tests and
    PHPUnit, but what we've seen up until now should be enough to give you the confidence
    required to start creating tests with clarity.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在 Codeception 单元测试和 PHPUnit 中发现更多东西，但到目前为止我们所看到的应该足以给你开始创建清晰测试所需的信心。
- en: In the next chapter, we'll see how to test components that rely on external
    code and classes, in order to get the best controlled environment needed by using
    stubs and mocks.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将看到如何测试依赖于外部代码和类的组件，以便使用存根和模拟来获得最佳控制环境。
