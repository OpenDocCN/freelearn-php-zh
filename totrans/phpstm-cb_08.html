<html><head></head><body><div class="chapter" title="Chapter&#xA0;8.&#xA0;Cooking Library Plugins"><div class="titlepage"><div><div><h1 class="title"><a id="ch08"/>Chapter 8. Cooking Library Plugins</h1></div></div></div><p>In this chapter, we will cover the following topics:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Creating a library plugin</li><li class="listitem" style="list-style-type: disc">Refining the plugin</li><li class="listitem" style="list-style-type: disc">Configuring the plugin with PhpStorm</li><li class="listitem" style="list-style-type: disc">Code hinting for the plugin</li></ul></div><div class="section" title="Introduction"><div class="titlepage"><div><div><h1 class="title"><a id="ch08lvl1sec93"/>Introduction</h1></div></div></div><p>Imagine a world where programmers such as you just enjoy writing code. That world seems enjoyable, perfect, and highly suitable for you in the first place. However, it isn't. What makes a programmer happier and satisfied more than anything in the world is the scenario in which the application reaches the end user. However, if programmers just enjoyed writing their code, who would ensure delivery of the code to the end user?</p><p>The end user can be anyone—a naive user, a professional user or even another programmer. So, regardless of the case, scenario, or end user, you, as a programmer, must be careful and concerned to make sure that whatever you code is (re)usable. Throughout your software-engineering life, you were told and you would be told not to reinvent the wheel. If you want this <span class="emphasis"><em>dry</em></span> principle to be alive, you must make your code usable and reusable.</p><p>Another use case! Suppose you are asked to develop an application programming interface (API) in PHP. So, your task at hand is to write code. But another (untold) task for you is to ensure that the code you write can be included with minimum hassle. One quick solution to achieve this feat is to wrap up your application in an archive such that the archive itself can be included wherever required. Kindly read again! You need to have a bundle-like entity that you can pass on to the testing team to validate and verify. A wise programmer would advise the use of Phing to build the files together. However, the catch in this situation is that Phing will do what you ask it to do. However, do you actually know what to do?</p><p>You read it right that you need to create an archive. This time, we make use of a PHP<a id="id502" class="indexterm"/> archive, or phar, as they call it in the industry (<a class="ulink" href="http://www.php.net/manual/en/book.phar.php">http://www.php.net/manual/en/book.phar.php</a>). Phar should not be alien to you. You must have used phar a number of times during your software engineering career. A PhpStorm cookbook author might have instructed you at some point in time as to how to get phar and include it in the PhpStorm library path. Can you recall how easy you used to find the task to have a PHP functionality in your project? If yes, it is the time to switch roles—from a phar user to a phar creator. If no, the time is ripe to learn how to create phars.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note33"/>Note</h3><p>Phar<a id="id503" class="indexterm"/> is an archive file created in PHP. Like other archives, phars also contain a number of files and directories. To be able to use phar in your application code, you just need to include or require phar in your code. That's it! Phar would behave as if you included (or required) a regular PHP class. You will be able to use the classes, corresponding methods, and member variables that are declared inside phar (of course, the access specifiers will be respected).</p><p>However, having PhpStorm at your disposal helps you a lot. You can also include phar in the include path for the project so that a particular project is able to use the functionality provided by phar. If you need to make the PHP functionality available to all projects across your development machine, consider adding phar to the global include path.</p></div></div><p>PHP programming has always been fun. However, since you are an experienced member of your team, it is highly encouraged that you love your work while still taking care of the utility of the work.</p></div></div>
<div class="section" title="Creating a library plugin"><div class="titlepage"><div><div><h1 class="title"><a id="ch08lvl1sec94"/>Creating a library plugin</h1></div></div></div><p>Have you ever thought about what makes up a library? A library <a id="id504" class="indexterm"/>is a collection of useful methods just as a book library is a collection of useful books. So is the case with an application library contains numerous useful methods and elements. The emphasis is on the word <span class="emphasis"><em>useful</em></span> to stress the importance of not having redundant methods and elements in the library. A redundant piece of code requires documentation. When the company spends resources (essentially money), it will never want to have entities that have less usage. What is the reason for this? The principles of economics—the primary objective of any company is to maximize profit. No matter what!</p><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec219"/>Getting ready</h2></div></div></div><p>However, not to worry, you do not<a id="id505" class="indexterm"/> need to be a Nobel Prize winner in Economics to stop putting redundant elements in the library. Just stay calm and stay wise. Cooking a plugin involves a number of<a id="id506" class="indexterm"/> engineering decisions to be made. Some of the decisions can be:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Decide what is that which makes you write a library</strong></span>: You will not have the task of creating libraries too often. A library is a collection of a number of methods that you require a bit too often. So, to decide which methods are required, involves maturity.</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Plan in advance</strong></span>: Since a library is something that is used again and again without much modification, you will not get to release versions very often. Since the versions are released once in a while, if an incorrect plan creeps in while creating the library, it will be discovered very late that you do not have a big margin for error.</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Make/reuse decision</strong></span>: You have to decide whether the required library can be built by reusing another's or even your code that you created for another project in the past. Remember, you need to have a sharp memory for that. The other option to decide on is whether to create a library from scratch.</li></ul></div><p>So, in essence, all the rules are to facilitate the creation of <span class="emphasis"><em>phar</em></span> containing PHP code. Get ready for the ride!</p></div><div class="section" title="How to do it…"><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec220"/>How to do it…</h2></div></div></div><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Choose a directory containing the code you want to include for the plugin. Since you have been attempting to cook pizza, you can assume a use case where an end user needs an algorithm to cook pizza. There, you have the requirements!</li><li class="listitem">Create a directory with the name <code class="literal">src</code>, which will contain the source PHP scripts. This will serve as the source for the library.</li><li class="listitem">Create a directory with the name <code class="literal">build</code>, which will contain the target library, as shown in the following screenshot. This is the library you were longing for.<div class="mediaobject"><img src="graphics/3878OT_08_00.jpg" alt="How to do it…"/></div></li><li class="listitem">There is a change <a id="id507" class="indexterm"/>that you need to make inside the <code class="literal">php.ini</code> file. To find out which <code class="literal">php.ini</code> your system uses, you can type <code class="literal">php-ini</code> inside PhpStorm (do you remember the command window available by the keyboard shortcut <span class="emphasis"><em>Ctrl</em></span> + <span class="emphasis"><em>Shift</em></span> + <span class="emphasis"><em>X</em></span>). You need to add the line <code class="literal">phar.readonly=0</code> to enable creating phars with PHP.</li><li class="listitem">You will need to define an entry point for the library. What's the reason for this? This is the way phars behave. There has to be an <code class="literal">index.php</code> file by default. You need to put it at the top level in the <code class="literal">src</code> (or sources) directory. At the minimum, it needs to include a file that will provide access to the required class in the library (of course, you can change the name of <code class="literal">index.php</code> to another <code class="literal">file.php</code> and make it act as the entry point).<p>In the current scenario, you need to include the file <code class="literal">PizzaDish.php</code> so that you are able to cook pizza again—this time by the library. So, considering PHP code, you will write something like the following:</p><div class="informalexample"><pre class="programlisting">&lt;?php
require_once "PizzaDish.php";
?&gt;</pre></div></li><li class="listitem">Since phar is a PHP functionality, you need to write code to create a phar package. You will write something like the following:<div class="informalexample"><pre class="programlisting">&lt;?php
$srcRoot = "src";
$buildRoot = "build";
$phar = new Phar ($buildRoot. "/pizza.phar", FilesystemIterator::CURRENT_AS_FILEINFO | FilesystemIterator::KEY_AS_FILENAME, "pizza.phar");
$phar-&gt;startBuffering ();
$phar-&gt;buildFromDirectory ($srcRoot);
$phar-&gt;stopBuffering ();
?&gt;</pre></div></li></ol></div><p>With that done, you can sit back and feel happy having created a new plugin that you can easily pass on to the testing and the quality assurance teams.</p></div><div class="section" title="How it works…"><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec221"/>How it works…</h2></div></div></div><p>It's time for the nuts and <a id="id508" class="indexterm"/>bolts and grease and dirty workshop clothes!</p><p>You can see that you did nothing extraordinary: you just wrote very simple and native PHP code to generate an archive that will be available to be used as a plugin. You created directories to contain the source files and the build file(s) separately. This step was not a mandatory step, but it ensured that your working area remained clean.</p><p>The <code class="literal">index.php</code> file serves as the entry point for phar. Thus, when you include a functionality, you need to involve the reference to that functionality. This is what you do when you <span class="emphasis"><em>include</em></span> <code class="literal">PizzaDish.php</code>:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$phar = new Phar($buildRoot . "/pizza.phar", FilesystemIterator::CURRENT_AS_FILEINFO | FilesystemIterator::KEY_AS_FILENAME, "pizza.phar");</strong></span>
</pre></div><p>When you write this, you are initializing the phar-creating facility, which takes in the name of the expected plugin (the first argument), flags to pass to the parent class <code class="literal">RecursiveDirectoryIterator</code> (the second argument), and the name of the archive that will serve as its calling name. Thus, you will create a library that will have the filename <code class="literal">pizza.phar</code> and will be known as <code class="literal">pizza.phar</code> when you access it through the <code class="literal">phar://</code> stream.</p><p>You need to start buffering to initiate the process of creating the archive. Buffering is the process of writing to the disk until the time the buffering is stopped. It is done by <code class="literal">$phar-&gt;startBuffering();</code>.</p><p>The source files inside a directory are included in the plugin that you created when you write the following:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$phar-&gt;buildFromDirectory($srcRoot);</strong></span>
</pre></div><p>The process of including files to the archive continues until you stop the buffering of the output. You need to stop buffering to finish the process of writing the changes to disk. The archive that you wrote will not be visible until you stop buffering. This is done by <code class="literal">$phar-&gt;stopBuffering();</code>.</p><p>Once you stop the buffering of <a id="id509" class="indexterm"/>the output, the output (which was the archive file) will be displayed to you. How? In the form of the archive itself! Simple, isn't it?</p></div></div>
<div class="section" title="Refining the plugin"><div class="titlepage"><div><div><h1 class="title"><a id="ch08lvl1sec95"/>Refining the plugin</h1></div></div></div><p>Having a plugin by your side <a id="id510" class="indexterm"/>definitely encourages you. However, this encouragement can lead to some dire consequences if the software engineering principles are not applied to the plugin at hand. The plugin at hand can then lead you to become an engineer at bay!</p><p>Software engineering is the entity that does not let you forget it easily in whatever you do. You need to validate that the product you created (here, the plugin) is working correctly. Now, this <span class="emphasis"><em>correctly</em></span> has a very broad meaning. Simply put, you just need to check that the plugin you created performs the intended action. Another aspect is verification. Having checked the intended actions, you need to check whether the action performed is correct or not. This is especially useful because the actual testing is done on the plugin according to this phenomenon.</p><div class="section" title="How to do it…"><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec222"/>How to do it…</h2></div></div></div><p>You need to take two actions. Both are mandatory. The first is the validation part. You need to validate if the pizza-cooking plugin works or not. To do that, you need to:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Create a new PHP file.</li><li class="listitem">Include (or require) the plugin you created in it.</li><li class="listitem">Run this file, as shown in the following screenshot.<p>If the run process gets completed as shown, it means your pizza is being cooked.</p><div class="mediaobject"><img src="graphics/3878OT_08_01.jpg" alt="How to do it…"/></div></li></ol></div><p>Now comes the verification part. You<a id="id511" class="indexterm"/> might need to verify that the dish you are cooking is actually pizza, else you might end up destroying your taste buds. To verify this is rather a vague sequence of steps, and it is not impossible to have different versions. The steps can be:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Check whether the classes in the plugin are accessible freely. You will need to create a new instance of the object. Thus, something like <code class="literal">$pizza = new PizzaDish('Mushroom', 'Dish')</code> should not produce an error. You should be able to use the object and the members in some external class in just the same way as you use a locally created class. Also, something like <code class="literal">echo $pizza-&gt;getDishName()</code> should not create an error about the unavailability of this function and should perform the intended activity correctly.</li><li class="listitem">If a problem occurs in the plugin that you think is not in accordance with business requirements, you need to (obviously) fix it (quickly). So, you might need to again follow a few steps:<div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">In the <code class="literal">src</code> directory, locate the file (here <code class="literal">PizzaDish.php</code>).</li><li class="listitem">Identify the error-creating (or misbehaving) line(s).</li><li class="listitem">Make the appropriate changes.</li><li class="listitem">Create phar afresh with the changed source code. You might want to revisit the <span class="emphasis"><em>Creating a library plugin</em></span> recipe.</li></ol></div></li><li class="listitem">Repeat steps 1-3 until the plugin starts behaving in the way it was expected to behave.</li></ol></div><p>Whatever you do, you just need to have a refined version of the plugin.</p></div><div class="section" title="How it works…"><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec223"/>How it works…</h2></div></div></div><p>The working of the validation process is quite straightforward to understand. The validation of a product checks whether the plugin that you created is actually working as a plugin. Thus, you check for possible errors and problems in the process of using the plugin as a system. This is like saying, "Dude, check whether the plugin is working". Can you imagine who says this? A programmer says this to his fellow programmer!</p><p>The verification process needs to<a id="id512" class="indexterm"/> be understood. When you create a plugin, you don't know which agent will use it—it could be a command-line user, an IDE, or another bigger plugin. So, you need to ensure that the plugin you wrote is usable. Thus, when you create a new object, you check whether the classes that you intended to provide in the plugin are present. When you call a method, you check whether the method defined inside the plugin is accessible, and that too, no improper access specifier is restricting you from using the method.</p><p>The process of verification of the plugin is rather cyclic. Since it is your responsibility to ensure a proper functioning plugin, you need to repeat the verification steps until the quality assurance team is fully satisfied with the plugin. In the process, if you detect errors, you would have to go back to the source code to fix the problems and rebuild the entire plugin again.</p><p>So, the process continues for you. You write code. The code gets tested. You correct code. The code gets tested. The code gets tested. You create a plugin. The plugin gets tested. You go back to the correct code, and the process continues from that point. Cyclic, isn't it?</p></div></div>
<div class="section" title="Configuring the plugin with PhpStorm"><div class="titlepage"><div><div><h1 class="title"><a id="ch08lvl1sec96"/>Configuring the plugin with PhpStorm</h1></div></div></div><p>When it comes to saying that<a id="id513" class="indexterm"/> there is a plugin, it is to be assumed that<a id="id514" class="indexterm"/> there has to be a user of that plugin. Since you are a PhpStorm lover, you can safely assume that PhpStorm can be (one of the) possible users of the plugin. So, you need to act as a pseudo recipient of the library plugin and make an attempt to use the library. By configuring, it is to be understood as making the necessary adjustments in the project structure so that the library can be used to add functionality to the project. The age-old practice of reusability is at work, you see.</p><p>The main advantage that is associated with a library plugin is the ease of inclusion in a project. You just have to make use of this advantage.</p><div class="section" title="How to do it…"><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec224"/>How to do it…</h2></div></div></div><p>To configure the plugin with PhpStorm, the steps to be followed are as follows:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Obtain phar from whichever source you wish.</li><li class="listitem">Create a directory inside your project with a proper and descriptive name.</li><li class="listitem">The plugin can be used very easily via <code class="literal">require(_once) 'phar://name-of-phar.phar';</code></li></ol></div><p>All done! So simple—quite unlike what it appeared to be. This is the power of PHP unleashed.</p></div><div class="section" title="There's more..."><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec225"/>There's more...</h2></div></div></div><p>However, if you <a id="id515" class="indexterm"/>think that you want to do more with the <a id="id516" class="indexterm"/>library and are more interested in doing development by tinkering with the internal classes and/or packages, you might need to select certain classes in particular. This is done as <code class="literal">require_once 'phar://pizza.phar/Dish.php';</code>.</p></div><div class="section" title="How it works…"><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec226"/>How it works…</h2></div></div></div><p>The creation of a directory to hold the library plugin is not rocket science. It just facilitates obeying software engineering conventions. You as a developer or the plugin user is being referenced here. Thus, when you create a new directory, the code base of the project you are working on remains compartmentalised. So, when you need to change this library, you know where you have to go. Also, when you need to delete this library from your code base, you know where you have to go. If you are asked a question as to when you need to add a similar functioning library or some dependency, do you know where to go?</p><p>The way you use the library is dependent on the scenario. Recall that the library plugin contains two files: <code class="literal">PizzaDish.php</code> and <code class="literal">Dish.php</code>. If you want to use the basic functionality—cook pizza by adding some simple toppings and ingredients—requiring phar as a whole will serve the purpose. If you want selected functionality, specifying the name of the file relative to phar (inside phar) serves the purpose.</p><p>Since phar is said to behave in the same way as a PHP file does, when you included phar, the hinting also starts. Thus, when you write <code class="literal">phar://pizza.phar/</code> and press <span class="emphasis"><em>Ctrl</em></span> + <span class="emphasis"><em>Space</em></span>, there is a list of all the files contained inside phar shown to you. You can select one from the list in just the same way you used to do for regular PHP files.</p></div></div>
<div class="section" title="Code hinting for the plugin"><div class="titlepage"><div><div><h1 class="title"><a id="ch08lvl1sec97"/>Code hinting for the plugin</h1></div></div></div><p>Here comes the actual utility of <a id="id517" class="indexterm"/>using an IDE for the plugin you created. It is a very common <a id="id518" class="indexterm"/>article of faith among developers that IDEs provide the autocompletion feature no matter what. However, at the same time, it is very uncommon amongst the same set of developers to know exactly how it is possible that the IDE provides autocompletion. Grandma always used to say <span class="emphasis"><em>Ignorance never pays</em></span>. Exactly! Ignorance never pays (pun intended).</p><p>A question could be popping up in your mind. Why on the earth do you need to use the <span class="strong"><strong>autocomplete</strong></span> feature? The answer <a id="id519" class="indexterm"/>to this might not be a diplomatic one, but it is true. In most cases, developers are ignorant enough not to write documentation for their code. Thus, autocompletion and / or code hinting serve as the saviors for the users of the code you provided. Since you are a programmer yourself, you can very easily understand the ease of using the code-hinting feature.</p><p>In the current context, you need to have similar settings so that PhpStorm is able to show you the documentation, method usage, and necessary information that is essential for a potential plugin user.</p><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec227"/>Getting ready</h2></div></div></div><p>Enabling code hinting for a plugin is a one-liner. If you really want to configure code hinting for PhpStorm, you need to update the include path that PhpStorm respects. Updating the include path is done by opening the Project view and adding the location of phar to the list of libraries for the project.</p></div><div class="section" title="How to do it…"><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec228"/>How to do it…</h2></div></div></div><p>The steps are as follows:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Select the Project view (<span class="emphasis"><em>Alt</em></span> + <span class="emphasis"><em>1</em></span>).</li><li class="listitem">Find the <code class="literal">External Libraries</code> directory.</li><li class="listitem">Press <span class="emphasis"><em>F4</em></span>.</li><li class="listitem">Provide the location of the directory where you have the plugin located.</li><li class="listitem">Click on <span class="strong"><strong>Apply</strong></span> and press <span class="strong"><strong>OK</strong></span>.</li></ol></div><p>Done! Take a deep breath and press <span class="emphasis"><em>Ctrl</em></span> + <span class="emphasis"><em>Space</em></span> whenever you need code-hinting activation for this plugin. PhpStorm is again at your disposal!</p></div><div class="section" title="How it works…"><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec229"/>How it works…</h2></div></div></div><p>PhpStorm makes a lookup in the include paths that are available for the project and provides the list of classes and methods available in the current context. The system-wide include paths (<code class="literal">/usr/share/php</code>, <code class="literal">/usr/share/pear</code>, and so on.) are also looked up. Thus, when you add the phar to the include path, PhpStorm gets an additional path to look up.</p><p>So, the methods and classes<a id="id520" class="indexterm"/> available in phar (which you included in <code class="literal">index.php</code>) become<a id="id521" class="indexterm"/> available for code hinting. The code-hinting process covers the documentation, member methods, member variables, and every other thing that you designed to be available for use.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note34"/>Note</h3><p>It is worth noting that when you add the library plugin to the include path, you start getting hints in just the same way as other methods available in the classes and libraries declared in the include path, but there is a difference to be noted. When you add the library location in the include path, PhpStorm is able to provide you with <span class="emphasis"><em>only</em></span> the code hints. If you want to use the methods, you will not be able to do that. Another aspect is that when you need to use the plugin, and you <code class="literal">require</code> (<code class="literal">_once</code>) it, the code hinting is available then too, but this time <span class="emphasis"><em>only</em></span> to the current script.</p><p>What is the difference, then? The difference is in the usage and availability of the plugin and its methods.</p><p>To sum it up, if you wish to use the plugin, you need to use <code class="literal">include(_once)</code> or <code class="literal">require(_once)</code>, and when you need the code hinting to be available across the project, you need to add the location of the plugin to the PhpStorm include path.</p></div></div></div></div></body></html>