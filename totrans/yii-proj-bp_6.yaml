- en: Chapter 6. Building a Content Management System
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For our next project, we will develop a scalable, multiuser content management
    system that will allow our users to create and update blog posts and enable them
    to comment on these blog posts. In addition to reutilizing many of the features
    we've developed for previous applications, this system will be optimized for optimal
    placement in search engines. Moreover, this system will feature a social sign-on
    feature that will allow users to register and log in from a third-party social
    network provider. We'll also explore the use of themes within our application,
    which will enable us to change the presentation layer of our application with
    minimal effort.
  prefs: []
  type: TYPE_NORMAL
- en: 'When we''re finished, our CMS will look as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Building a Content Management System](img/7734OS_06_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Prerequisites
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Before we get started, there are a couple of things that we''ll need to have
    set up and working:'
  prefs: []
  type: TYPE_NORMAL
- en: Once again, we'll need to have a web server with a public-facing IP address.
    This will allow e-mails to be sent to our application. Many cloud Virtual Private
    Server (VPS) providers are available to use for low month or hourly prices. Such
    services include [https://www.digitalocean.com](https://www.digitalocean.com),
    [www.linode.com](http://www.linode.com), and [www.rackspace.com/cloud/servers](http://www.rackspace.com/cloud/servers).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In order to send e-mails in our application, we'll once again utilize a free
    SendGrid Developer Account, which can be set up at [https://www.sendgrid.com/developers](https://www.sendgrid.com/developers).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In this chapter, we'll once again use the latest version of MySQL (at the time
    of this writing, MySQL 5.6). Make sure that your MySQL server is set up and running
    on your server.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: Do you want to try something more challenging? After completing this project,
    try to figure out what changes you need to make to this application to make it
    work with Postgres rather than MySQL.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: For this project, we'll once again manage our dependencies through Composer,
    which you can download and install from [https://getcomposer.org/](https://getcomposer.org/).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We'll also be using **Disqus**, a third-party commenting system that we will
    integrate with to display comments on our site. For this project, you'll need
    to register an account with [https://www.disqus.com](https://www.disqus.com).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Finally, you'll need a Twitter Developer account, obtained from [https://dev.twitter.com/](https://dev.twitter.com/).
    This account will allow us to enable the social sign-on feature of our application
    through Twitter's OAuth API.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Once you have acquired the listed prerequisites, create a subdomain on the domain
    name you are using and point it to your server. In this chapter, I'll use `chapter6.example.com`
    to refer to this subdomain. After everything is set up and your server is responding
    to that domain name, we can get started.
  prefs: []
  type: TYPE_NORMAL
- en: Describing the project
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Our CMS can be broken down into several different components:'
  prefs: []
  type: TYPE_NORMAL
- en: Users who will be responsible for viewing and managing the content
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Content to be managed
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Categories for our content to be placed into
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Metadata to help us further define our content and users
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Search engine optimizations
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Users
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The first component of our application is the users who will perform all the
    tasks in our application. For this application, we're going to largely reuse the
    `user` database and authentication system we expanded upon in [Chapter 5](ch05.html
    "Chapter 5. Creating a Microblogging Platform"), *Creating a Microblogging Platform*.
    In this chapter, we'll enhance this functionality by allowing social authentication.
    Our CMS will allow users to register new accounts from the data provided by Twitter;
    after they have registered, the CMS will allow them to sign-in to our application
    by signing in to Twitter.
  prefs: []
  type: TYPE_NORMAL
- en: 'To enable us to know if a user is a socially authenticated user, we have to
    make several changes to both our database and our authentication scheme. First,
    we''re going to need a way to indicate whether a user is a socially authenticated
    user. Rather than hardcoding a `isAuthenticatedViaTwitter` column in our database,
    we''ll create a new database table called `user_metadata`, which will be a simple
    table that contains the user''s ID, a unique key, and a value. This will allow
    us to store additional information about our users without having to explicitly
    change our user''s database table every time we want to make a change:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: We'll also need to modify our `UserIdentity` class to allow socially authenticated
    users to sign in. To do this, we'll be expanding upon this class to create a `RemoteUserIdentity`
    class that will work off the OAuth codes that Twitter (or any other third-party
    source that works with HybridAuth) provides to us rather than authenticating against
    a username and password.
  prefs: []
  type: TYPE_NORMAL
- en: Content
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'At the core of our CMS is our content that we''ll manage. For this project,
    we''ll manage simple blog posts that can have additional metadata associated with
    them. Each post will have a title, a body, an author, a category, a unique URI
    or slug, and an indication whether it has been published or not. Our database
    structure for this table will look as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Each post will also have one or many metadata columns that will further describe
    the posts we''ll be creating. We can use this table (we''ll call it `content_metadata`)
    to have our system store information about each post automatically for us, or
    add information to our posts ourselves, thereby eliminating the need to constantly
    migrate our database every time we want to add a new attribute to our content:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Categories
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Each post will be associated with a category in our system. These categories
    will help us further refine our posts. As with our content, each category will
    have its own slug. Before either a post or a category is saved, we''ll need to
    verify that the slug is not already in use. Our table structure will look as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Search engine optimizations
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The last core component of our application is optimization for search engines
    so that our content can be indexed quickly. SEO is important because it increases
    our discoverability and availability both on search engines and on other marketing
    materials. In our application, there are a couple of things we''ll perform to
    improve our SEO:'
  prefs: []
  type: TYPE_NORMAL
- en: The first SEO enhancement we'll add is a `sitemap.xml` file, which we can submit
    to popular search engines to index. Rather than crawl our content, search engines
    can very quickly index our `sitemap.xml` file, which means that our content will
    show up in search engines faster.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The second enhancement we''ll be adding is the slugs that we discussed earlier.
    Slugs allow us to indicate what a particular post is about directly from a URL.
    So rather than have a URL that looks like `http://chapter6.example.com/content/post/id/5`,
    we can have URL''s that look like: `http://chapter6.example.com/my-awesome-article`.
    These types of URLs allow search engines and our users to know what our content
    is about without even looking at the content itself, such as when a user is browsing
    through their bookmarks or browsing a search engine.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Initializing the project
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To provide us with a common starting ground, a skeleton project has been included
    with the project resources for this chapter. Included with this skeleton project
    are the necessary migrations, data files, controllers, and views to get us started
    with developing. Also included in this skeleton project are the user authentication
    classes we worked on in [Chapter 5](ch05.html "Chapter 5. Creating a Microblogging
    Platform"), *Creating a Microblogging Platform*. Copy this skeleton project to
    your web server, configure it so that it responds to `chapter6.example.com` as
    outlined at the beginning of the chapter, and then perform the following steps
    to make sure everything is set up:'
  prefs: []
  type: TYPE_NORMAL
- en: Adjust the permissions on the `assets` and `protected/runtime` folders so that
    they are writable by your web server.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In this chapter, we'll once again use the latest version of MySQL (at the time
    of writing MySQL 5.6). Make sure that your MySQL server is set up and running
    on your server. Then, create a username, password, and database for our project
    to use, and update your `protected/config/main.php` file accordingly. For simplicity,
    you can use `ch6_cms` for each value.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Install our Composer dependencies:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Run the `migrate` command and install our mock data:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Finally, add your SendGrid credentials to your `protected/config/params.php`
    file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'If everything is loaded correctly, you should see a 404 page similar to the
    following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Initializing the project](img/7734OS_06_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Exploring the skeleton project
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are actually a lot of different things going on in the background to make
    this work even if this is just a 404 error. Before we start doing any development,
    let's take a look at a few of the classes that have been provided in our skeleton
    project in the `protected/components` folder.
  prefs: []
  type: TYPE_NORMAL
- en: Extending models from a common class
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The first class that has been provided to us is an ActiveRecord extension called
    `CMSActiveRecord` that all of our models will stem from. This class allows us
    to reduce the amount of code that we have to write in each class. For now, we''ll
    simply add `CTimestampBehavior` and the `afterFind()` method we''ve used in previous
    chapters to store the old attributes for the time the need arises to compare the
    changed attributes with the new attributes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Creating a custom validator for slugs
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Since both `Content` and `Category` classes have slugs, we''ll need to add
    a custom validator to each class that will enable us to ensure that the slug is
    not already in use by either a post or a category. To do this, we have another
    class called `CMSSlugActiveRecord` that extends `CMSActiveRecord` with a `validateSlug()`
    method that we''ll implement as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: This implementation simply checks the database for any item that has that slug.
    If nothing is found, or if the current item is the item that is being modified,
    then the validator will return true. Otherwise, it will add an error to the `slug`
    attribute and return false. Both our Content model and Category model will extend
    from this class.
  prefs: []
  type: TYPE_NORMAL
- en: View management with themes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'One of the largest challenges of working with larger applications is changing
    their appearance without locking functionality into our views. One way to further
    separate our business logic from our presentation logic is to use themes. Using
    themes in Yii, we can dynamically change the presentation layer of our application
    simply by utilizing the `Yii::app()->setTheme(''themename)` method. Once this
    method is called, Yii will look for view files in `themes/themename/views` rather
    than `protected/views`. Throughout the rest of the chapter, we''ll be adding views
    to a custom theme called `main`, which is located in the `themes` folder. To set
    this theme globally, we''ll be creating a custom class called `CMSController`,
    which all of our controllers will extend from. For now, our theme name will be
    hardcoded within our application. This value could easily be retrieved from a
    database though, allowing us to dynamically change themes from a cached or database
    value rather than changing it in our controller. Have a look at the following
    lines of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Alternatively, you can use the `theme` attribute from within the `protected/config/main.php`
    file as outlined in the official documentation [http://www.yiiframework.com/doc/guide/1.1/en/topics.theming](http://www.yiiframework.com/doc/guide/1.1/en/topics.theming).
    While manipulating the theme there is simple, it requires our end user to have
    knowledge of how to manipulate PHP arrays. If you intend on allowing your end
    users to manipulate the theme of their site, it is recommended that you do so
    programmatically via `Yii::app()->setTheme` from a cached or database value. Be
    sure to check out the documentation for more information about using themes.
  prefs: []
  type: TYPE_NORMAL
- en: Truly dynamic routing
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In our previous applications, we had long, boring URLs that had lots of IDs
    and parameters in them. These URLs provided a terrible user experience and prevented
    search engines and users from knowing what the content was about at a glance,
    which in turn would hurt our SEO rankings on many search engines. To get around
    this, we're going to heavily modify our `UrlManager` class to allow truly dynamic
    routing, which means that, every time we create or update a post or a category,
    our URL rules will be updated.
  prefs: []
  type: TYPE_NORMAL
- en: Telling Yii to use our custom UrlManager
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Before we can start working on our controllers, we need to create a custom
    `UrlManager` to handle routing of our content so that we can access our content
    by its slug. The steps are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The first change we need to make to allow for this routing is to update the
    `components` section of our `protected/config/main.php` file. This will tell Yii
    what class to use for the `UrlManager` component:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, within our `protected/components` folder, we need to create `CMSUrlManager.php`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`CUrlManager` works by populating a rules array. When Yii is bootstrapped,
    it will trigger the `processRules()` method to determine which route should be
    executed. We can overload this method to inject our own rules, which will ensure
    that the action that we want to be executed is executed.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'To get started, let''s first define a set of default routes that we want loaded.
    The routes defined in the following code snippet will allow for pagination on
    our search and home page, enable a static path for our `sitemap.xml` file, and
    provide a route for HybridAuth to use for social authentication:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then, we''ll implement our `processRules()` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`CUrlManager` already has a public property that we can interface to modify
    the rules, so we''ll inject our own rules into this. The `rules` property is the
    same property that can be accessed from within our config file. Since `processRules()`
    gets called on every page load, we''ll also utilize caching so that our rules
    don''t have to be generated every time. We''ll start by trying to load any of
    our pregenerated rules from our cache, depending upon whether we are in debug
    mode or not:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'If the rules we get back are already set up, we''ll simple return them; otherwise,
    we''ll generate the rules, put them into our cache, and then append our basic
    URL rules that we''ve used throughout the previous chapters:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'For abstraction purposes, within our `processRules()` method, we''ve utilized
    two methods we''ll need to create: `generateClientRules`, which will generate
    the rules for content and categories, and `addRSSRules`, which will generate the
    RSS routes for each category.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The first method, `generateClientRules()`, simply loads our default rules that
    we defined earlier with the rules generated from our content and categories, which
    are populated by the `generateRules()` method:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The `generateRules()` method, that we just defined, actually calls the methods
    that build our routes. Each route is a key-value pair that will take the following
    form:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Content rules will consist of an entry that is published. Have a look at the
    following code:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Our category rules will consist of all categories in our database. Have a look
    at the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Finally, we''ll add our RSS rules that will allow RSS readers to read all content
    for the entire site or for a particular category, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '`CUrlManager` has many different components. If you have questions, be sure
    to reference the Yii Class Reference for this class at [http://www.yiiframework.com/doc/api/1.1/CUrlManager](http://www.yiiframework.com/doc/api/1.1/CUrlManager).'
  prefs: []
  type: TYPE_NORMAL
- en: Displaying and managing content
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now that Yii knows how to route our content, we can begin work on displaying
    and managing it. Begin by creating a new controller called `ContentController`
    in `protected/controllers` that extends `CMSController`. Have a look at the following
    line of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'To start with, we''ll define our `accessRules()` method and the default layout
    that we''re going to use. Here''s how:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Rendering the sitemap
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The first method we''ll be implementing is our sitemap action. In our `ContentController`,
    create a new method called `actionSitemap()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'The steps to be performed are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Since sitemaps come in XML formatting, we''ll start by disabling `WebLogRoute`
    defined in our `protected/config/main.php` file. This will ensure that our XML
    validates when search engines attempt to index it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We''ll then send the appropriate XML headers, disable the rendering of the
    layout, and flush any content that may have been queued to be sent to the browser:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then, we''ll load all the published entries and categories and send them to
    our sitemap view:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Finally, we have two options to render this view. We can either make it a part
    of our theme in `themes/main/views/content/sitemap.php`, or we can place it in
    `protected/views/content/sitemap.php`. Since a sitemap''s structure is unlikely
    to change, let''s put it in the `protected/views` folder:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: Even though we've told Yii to look for view files within a theme, it's still
    going to look in the `protected/views` folder if it cannot find the view file
    within the `themes` folder. This feature allows us to separate views that shouldn't
    change (such as sitemaps and RSS feeds) from views that will actually be presented
    to a user.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: You can now load `http://chapter6.example.com/sitemap.xml` in your browser to
    see the sitemap. Before you make your site live, be sure to submit this file to
    search engines for them to index.
  prefs: []
  type: TYPE_NORMAL
- en: Displaying a list view of content
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Next, we''ll implement the actions necessary to display all of our content
    and a particular post. We''ll start by providing a paginated view of our posts.
    Since `CListView` and the Content model''s `search()` method already provide this
    functionality, we can utilize those classes to generate and display this data:'
  prefs: []
  type: TYPE_NORMAL
- en: To begin with, open `protected/models/Content.php` and modify the return value
    of the `search()` method as follows. This will ensure that Yii's pagination uses
    the correct variable in our `CListView`, and tells Yii how many results to load
    per page.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, implement the `actionIndex()` method with the `$page` parameter. We''ve
    already told our `UrlManager` how to handle this, which means that we''ll get
    pretty URI''s for pagination (for example, `/blog`, `/blog/2`, `/blog/3`, and
    so on):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then we''ll create a view in `themes/main/views/content/all.php`; this will
    display the data within our `dataProvider`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Finally, copy `themes/main/views/content/all.php` from the project resources
    folder so that our views can render.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Since our database has already been populated with some sample data, you can
    start playing around with the results right away, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Displaying a list view of content](img/7734OS_06_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Displaying content by ID
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Since our routing rules are already set up, displaying our content is extremely
    simple. All that we have to do is search for a published model with the ID passed
    to the view action and render it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: After copying `themes/main/views/content/view.php` from the project resources
    folder into your project, you'll be able to click into a particular post from
    the home page. In its present form, this action has introduced an interesting
    side effect that could negatively impact our SEO rankings on search engines—the
    same entry can now be accessed from two URI's. For example, `http://chapter6.example.com/content/view/id/1`
    and `http://chapter6.example.com/quis-condimentum-tortor` now bring up the same
    post. Fortunately, correcting this bug is fairly easy. Since the goal of our slugs
    is to provide more descriptive URIs, we'll simply block access to the view if
    a user tries to access it from the non-slugged URI.
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ll do this by creating a new method called `beforeViewAction()` that takes
    the entry ID as a parameter and gets called right after the `actionView()` method
    is called. This private method will simply check the URI from `CHttpRequest` to
    determine how `actionView` was accessed and return a 404 if it''s not through
    our beautiful slugs:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, right after our `actionView` starts, we can simultaneously set the correct
    return URL and block access to the content if it wasn''t accessed through the
    slug as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: Adding comments to our CMS with Disqus
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Presently, our content is only informative in nature—we have no way for our
    users to communicate with us what they thought about our entry. To encourage engagement,
    we can add a commenting system to our CMS to further engage with our readers.
    Rather than writing our own commenting system, we can leverage comment through
    Disqus, a free, third-party commenting system. Even through Disqus, comments are
    implemented in JavaScript and we can create a custom widget wrapper for it to
    display comments on our site. The steps are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: To begin with, log in to the Disqus account you created at the beginning of
    this chapter as outlined in the prerequisites section. Then, navigate to [http://disqus.com/admin/create/](http://disqus.com/admin/create/)
    and fill out the form fields as prompted and as shown in the following screenshot:![Adding
    comments to our CMS with Disqus](img/7734OS_06_04.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Then, add a `disqus` section to your `protected/config/params.php` file with
    your site `shortname`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, create a new widget in `protected/components` called `DisqusWidget.php`.
    This widget will be loaded within our view and will be populated by our Content
    model:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Begin by specifying the public properties that our view will be able to inject
    into as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then, overload the `init()` method to load the Disqus JavaScript callback and
    to populate the JavaScript variables with those populated to the widget as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Finally, within our `themes/main/views/content/view.php` file, load the widget
    as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Now, when you load any given post, Disqus comments will also be loaded with
    that post. Go ahead and give it a try!
  prefs: []
  type: TYPE_NORMAL
- en: '![Adding comments to our CMS with Disqus](img/7734OS_06_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The greatest benefit of using Disqus as a service provider is that it enables
    us to focus solely on the integration of a product rather than raw implementation.
    By not having to reinvent the wheel each time we need a service, we can save a
    lot of time and money. When relying on a third party, however, be cognizant of
    the fact that the service provider may not exist the next day. While unlikely,
    a large service provider can go out of business overnight, so be prepared to have
    a plan in place to replace or substitute any third-party service you integrate
    into your application.
  prefs: []
  type: TYPE_NORMAL
- en: Searching for content
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Next, we''ll implement a search method so that our users can search for posts.
    To do this, we''ll implement an instance of `CActiveDataProvider` and pass that
    data to our `themes/main/views/content/all.php` view to be rendered and paginated:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: Since our view file already exists, we can now search for content in our CMS.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In previous chapters, we would have simply queried the `$_POST` array for our
    search parameter. A more Yii way of retrieving these variables is to use the `Yii::app()->request->getParam()`
    method from the `CHttpRequest` class. Be warned, however, that this method operates
    on both `$_GET` and `$_POST` parameters. If the same parameter is sent via both
    HTTP methods (you should avoid doing this when possible), only the `$_GET` method
    will be returned. Be sure to read the `CHttpRequest` Class Reference page for
    more information at [http://www.yiiframework.com/doc/api/1.1/CHttpRequest](http://www.yiiframework.com/doc/api/1.1/CHttpRequest).
  prefs: []
  type: TYPE_NORMAL
- en: Managing content
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Next, we''ll implement a basic set of management tools that will allow us to
    create, update, and delete entries:'
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ll start by defining our `loadModel()` method and the `actionDelete()`
    method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, we can implement our admin view, which will allow us to view all the
    content in our system and to create new entries. Be sure to copy the `themes/main/views/content/admin.php`
    file from the project resources folder into your project before using this view:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Finally, we''ll implement a save view to create and update entries. Saving
    content will simply pass it through our content model''s validation rules. The
    only override we''ll be adding is ensuring that the author is assigned to the
    user editing the entry. Before using this view, be sure to copy the `themes/main/views/content/save.php`
    file from the project resources folder into your project:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'At this point, you can now log in to the system using the credentials provided
    in the following table and start managing entries:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Username | Password |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `user1@example.com` | `test` |'
  prefs: []
  type: TYPE_TB
- en: '| `user2@example.com` | `test` |'
  prefs: []
  type: TYPE_TB
- en: Viewing and managing categories
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now, let''s move to viewing and managing categories. As outlined previously,
    each category will be accessible via a dedicated route and will only display content
    within that category. We''ll start by defining our default access rules and layout
    name in `protected/controllers/CategoryController.php`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: Viewing entries in a category
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Displaying entries in each category will be nearly identical to displaying all
    entries, so we can implement our index action as follows. Note that the parameters
    passed to this method are simply passed from the routes we generated earlier.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: Viewing an RSS feed for categories
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'An alternative way of viewing entries in a particular category is through an
    RSS feed. RSS feeds are a very popular medium that allows your users to subscribe
    to your content and be regularly notified of updates without having to visit each
    site individually. Our action to display our category entries in an RSS feed look
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, add the following to your `protected/views/category/rss.php` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: Now, if you navigate to `3`, you can view an RSS feed of all uncategorized entries.
    Each category will have its own RSS feed, allowing users to subscribe to the content
    they are interested in rather than all the content on your site.
  prefs: []
  type: TYPE_NORMAL
- en: Managing categories
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Next, we need to implement management of our categories:'
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ll start with our `loadModel()` and `actionDelete()` methods:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then, we''ll implement the admin action. Be sure to copy the `themes/main/views/category/admin.php`
    file from the project resources folder. Have a look at the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Finally, we''ll implement the `save()` method. Be sure to copy the `themes/main/views/category/save.php`
    file from the project resources folder. Have a look at the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We've now finished the core of our content management system. The structure
    that we've built for our CMS, while being extremely simple, provides a lot of
    flexibility for us to expand upon with very minimal effort.
  prefs: []
  type: TYPE_NORMAL
- en: Social authentication with HybridAuth
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapter, [Chapter 5](ch05.html "Chapter 5. Creating a Microblogging
    Platform"), *Creating a Microblogging Platform*, we used HybridAuth to sign in
    as a user to, and share content with, Twitter. In this chapter, we use HybridAuth
    to register accounts in our CMS and to sign in to our CMS without having to enter
    a username and password. To achieve this, we'll create three new forms, a new
    `UserIdentity` class, and a control that will enable us to take advantage of all
    the providers that HybridAuth has to offer.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before we get started with any coding, however, we need to first create a new
    Twitter application similar to the one we created in [Chapter 5](ch05.html "Chapter 5. Creating
    a Microblogging Platform"), *Creating a Microblogging Platform*. This will allow
    us to focus on development rather than configuration once we start writing code.
    Once your Twitter application has been created and permissions have been set,
    add a `hybridauth` section to your `protected/config/params.php` file, containing
    your OAuth secret token and key:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When we're done, you'll be able to add any of the supported HybridAuth providers
    listed in the HybridAuth documentation at [http://hybridauth.sourceforge.net/userguide.html](http://hybridauth.sourceforge.net/userguide.html).
  prefs: []
  type: TYPE_NORMAL
- en: Validating remote identities
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For our application, we need to register users from a social network, authenticate
    users from a social network to users in our database, and link existing users
    to a social identity. We're also going to authenticate users into our system.
    To achieve this, we're going to create three separate forms, `RemoteRegistrationForm`,
    `RemoteLinkAccountForm`, and `RemoteIdentityForm`, which will serve as our `LoginForm`
    for remote users. We'll also create a `RemoteUserIdentity` class that we'll use
    to authenticate users into our system. Let's get started.
  prefs: []
  type: TYPE_NORMAL
- en: Remote registrations
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The first class we''ll need to create is `RemoteRegistrationForm`. This form
    will allow us to register users using information from their social identity.
    The steps are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'To get started, create a new class in `protected/models` called `RemoteRegistrationForm.php`
    with the following definition. To keep things simple, we''re going to be reusing
    much of the functionality already available from our `RegistrationForm` class.
    Have a look at the following line of code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We''ll then specify two additional attributes, the HybridAuth adapter that
    we''ll provide from the controller we''ll create later on and the provider name
    that we''re authenticating with. We''ll also set up validators for these attributes
    to ensure that they are set. Notice that we''re using the `mergeArray()` method
    from the `CMap` class to take advantage of the validation rules that are already
    in place:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Finally, we''ll overload our `save()` method so that the provider name and
    OAuth token are written to our database. We''ll take advantage of this metadata
    when we create our `RemoteIdentityForm` class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Linking a social identity to an existing account
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To assist in linking a social identity to an existing account in our system,
    we''re going to create a new class called `RemoteLinkAccountForm`. This form will
    prompt an already logged-in user for their password to verify their identity and
    then bind the OAuth token provided by HybridAuth to that user, so that they can
    log in using their social identity in the future. The steps are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'To get started, create a new class in `protected/models` called `RemoteLinkAccountForm.php`
    with the following definition:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We''ll then define the public attributes we''ll want to collect and create
    a validator for them. We''ll also define a private attribute to store the user
    information of the user we want to link our social identity to. Have a look at
    the following lines of code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'For security reasons, we only want the authenticated user to be able to link
    a social identity to their account. To verify that we are dealing with the account
    owner, we''ll prompt the user for their password. To validate their password,
    we''ll create a custom validator called `validateUserPassword`. Have a look at
    the following lines of code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Finally, we create a `save()` method that will save the social identity information
    to our `user_metdata` table provided that the user is able to verify their identity:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Authenticating with a social identity
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To authenticate with a social identity, we''ll need to create a form similar
    to our `LoginForm`; however, instead of taking a username and password as inputs,
    it will take the provider name and the HybridAuth adapter we''re working with.
    The steps are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Begin by creating a new form in `protected/models` called `RemoteIdentityForm.php`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'As stated previously, we''ll collect the provider name and the HybridAuth adapter
    instead of a username and password, so let''s declare those properties. We''ll
    also declare properties to store our user''s information if they exist and the
    `RemoteUserIdentity` class, which we''ll ultimately authenticate with:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We''ll then define our validation rules and create a custom validator that
    will retrieve the appropriate user from within our system. This will prevent unauthorized
    users from authenticating into our CMS without being able to first authenticate
    with the social network that the user''s account is linked to:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then we''ll create an `authenticate()` method that will behave in the same
    manner as the `authenticate()` method of our `LoginForm`; however, it will use
    the `RemoteUserIdentity` class as opposed to the `UserIdentity` class. Have a
    look at the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Finally, we''ll create a `login()` method that will actually log our user in
    to our CMS:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Creating a Yii CWebUser object from a remote identity
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The last class we''ll need to create before linking everything together is
    a `RemoteUserIdentity` class. This class will retrieve all the information from
    our forms; if validated, it will log the user in to our CMS in the same way that
    our `UserIdentity` class does. The steps are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: To get started, create a new class in `protected/components` called `RemoteUserIdentity.php`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then, define the attributes that we''ll be collecting from our constructor
    as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We should also define a way to retrieve the user''s ID as stored in our system.
    We''ll follow the pattern laid out in our `UserIdentity` class to keep things
    consistent:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Finally, we''ll create an `authenticate()` method that will set our `CWebUser`
    states. As we need to check that the data is available to us, the information
    provided to us should already be validated:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Putting it all together
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'With all of the necessary components in place, we can now create our controller
    that will handle the authentication component with HybridAuth. The steps are as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'To begin with, create a new controller in `protected/controllers` called `HybridController.php`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, we''ll create three properties to hold the HybridAuth adapter, the provider
    name, and the user profile that we''ll get back from Twitter:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We''ll also create custom getter and setter methods to set the adapter as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then we''ll add in a block to retrieve the user''s profile information from
    the social network they are signing in from:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then, to get and set the provider''s name that will be provided from the URI,
    the following code needs to be used:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'By referencing the HybridAuth documentation ([http://hybridauth.sourceforge.net/userguide/Configuration.html](http://hybridauth.sourceforge.net/userguide/Configuration.html)),
    we can determine what variables HybridAuth will require to initialize correctly.
    Rather than hardcoding all of this information in our configuration file, we can
    dynamically populate it from within our controller. This method will ensure that
    our base URLs will always be set correctly, and that logging information will
    be sent to the correct place. It has the additional benefit of only logging when
    we enable `YII_DEBUG`, which means we only have to make one change to our configuration
    file when debugging rather than multiple changes. Have a look at the following
    code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, we''ll define our `actionIndex()`. This action will serve both as the
    initialization URL for HybridAuth and our callback URL for our social networks
    to authenticate against. Within this action, we''ll set the provider and start
    the HybridAuth process:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: Internally, HybridAuth will throw an exception whenever it encounters an error
    while dealing with the remote network. To prevent our application from exposing
    too much information, we can simply inform the user that an error occurred.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Then, we''ll define the `hybridauth()` method we started to use earlier. We''ll
    start by initializing the HybridAuth object and setting the adapter if it is not
    already set:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: We've declared a custom getter and setter for our adapter so that we only load
    it once during our flow. This will prevent us from hitting the rate limits of
    the Twitter API during a single request.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'At this point, HybridAuth is going to perform several different redirects to
    authenticate our user against their system. When the request is returned to us,
    we''ll be able to verify that a user is connected to our adapter. If one isn''t,
    it''s safe to throw an exception. Have a look at the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Within our `if` statement, we''ll try to authenticate the user using our `RemoteIdentityForm`
    class that we created earlier. We''ll display a flash message and redirect the
    user to the home page if we''re able to. If we''re not able to authenticate the
    user, we''ll either display the `LinkAccountForm` class if the user is authenticated
    in our system but not socially, or the `RemoteRegistrationForm` class so that
    the user can register a new account in our CMS:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Our `authenticate()` method will simply return the result of the `RemoteIdentityForm`
    `login()` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'If a user is already authenticated in our CMS but hasn''t been authenticated
    with this provider, we''ll assume that they want to link their social network
    identity to their login information; thus, we''ll present `RemoteLinkAccountForm`
    and prompt them for their password. Then, be sure to copy over `themes/main/views/users/linkaccount.php`
    from the project resources folder into your project:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Finally, if a user is not logged in to our CMS, we''ll display our `RemoteRegisterForm`
    and reutilize the view from `themes/main/views/user/register.php`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now that we have everything in place, we can test our social authentication.
    For our first test, log out of our CMS, navigate to `http://chapter6.example.com/site/login`,
    and click on the **sign in with Twitter** link at the bottom. Click on the link,
    and enter your Twitter credentials. Upon being redirected, you should see a registration
    form where you can enter your information for a new account, as shown in the following
    screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Putting it all together](img/7734OS_06_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Enter your new user's information and then click on **Register**. If successful,
    you'll be logged in to the CMS as the user you just created, and the activation
    e-mail we created in the previous chapter will be sent to that e-mail address.
    Now, if you log out of the CMS and log in using the **Login with Twitter** link,
    you'll be automatically logged in to the CMS without having to enter your username
    and password.
  prefs: []
  type: TYPE_NORMAL
- en: 'After verifying that registering with a social identity works, log out of the
    CMS and then log in as `user1@example.com` using the credentials previously provided.
    Log out of Twitter and then navigate to `http://chapter6.example.com/hybrid/twitter`.
    After signing in to Twitter with a different account from the one you previous
    signed in with, you''ll be prompted to enter your current password as shown in
    the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Putting it all together](img/7734OS_06_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: After entering your password, your social identity will be linked to your account,
    and you'll be able to login via Twitter rather than having to enter your username
    and password.
  prefs: []
  type: TYPE_NORMAL
- en: Exploring other HybridAuth providers
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Due to the way we implemented our controller, we can easily and seamlessly add
    additional providers to the `hybridauth` section of our `protected/config/params.php`
    file without having to modify any other code in our system. Be sure to check out
    the HybridAuth user guide located at [http://hybridauth.sourceforge.net/userguide.html#index](http://hybridauth.sourceforge.net/userguide.html#index)
    for more information on how to integrate with other third-party providers, such
    as Google+ and Facebook, and give it a try!
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Wow, we really did implement a lot in this chapter. In this chapter, we created
    a very robust and reusable content management system that featured both content
    and categories. We also dug deeper into Yii framework by manipulating our `CUrlManager`
    class to generate completely dynamic and clean URIs. We also covered the use of
    Yii's built-in theming to dynamically change the frontend appearance of our site
    by simply changing a configuration value. Finally, we learned how to integrate
    with third-party social networks to provide a social sign-on functionality that
    seamlessly integrates without our application.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we'll be reusing much of the code built in this chapter
    to further separate the management functionality of our application from the presentation
    logic. We'll also dig deeper into Yii framework by learning how to create modules.
    Before continuing to the next chapter, be sure to go over the Yii Class Reference
    at [http://www.yiiframework.com/doc/api/](http://www.yiiframework.com/doc/api/)
    and review all the classes that we used in this chapter. Then, when you're ready,
    head over to the next chapter, and let's build a custom dashboard module for our
    CMS!
  prefs: []
  type: TYPE_NORMAL
