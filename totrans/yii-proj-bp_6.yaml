- en: Chapter 6. Building a Content Management System
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 6 章. 构建内容管理系统
- en: For our next project, we will develop a scalable, multiuser content management
    system that will allow our users to create and update blog posts and enable them
    to comment on these blog posts. In addition to reutilizing many of the features
    we've developed for previous applications, this system will be optimized for optimal
    placement in search engines. Moreover, this system will feature a social sign-on
    feature that will allow users to register and log in from a third-party social
    network provider. We'll also explore the use of themes within our application,
    which will enable us to change the presentation layer of our application with
    minimal effort.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的下一个项目，我们将开发一个可扩展的多用户内容管理系统，这将允许我们的用户创建和更新博客文章，并使他们能够对这些博客文章进行评论。除了重新利用我们在以前的应用程序中开发的一些功能外，这个系统还将针对搜索引擎的最佳定位进行优化。此外，这个系统将具有社交登录功能，允许用户从第三方社交网络提供商注册和登录。我们还将探索在我们的应用程序中使用主题，这将使我们能够以最小的努力更改应用程序的表现层。
- en: 'When we''re finished, our CMS will look as follows:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们完成时，我们的 CMS 将如下所示：
- en: '![Building a Content Management System](img/7734OS_06_01.jpg)'
  id: totrans-3
  prefs: []
  type: TYPE_IMG
  zh: '![构建内容管理系统](img/7734OS_06_01.jpg)'
- en: Prerequisites
  id: totrans-4
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 前提条件
- en: 'Before we get started, there are a couple of things that we''ll need to have
    set up and working:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始之前，有一些事情我们需要设置并使其工作：
- en: Once again, we'll need to have a web server with a public-facing IP address.
    This will allow e-mails to be sent to our application. Many cloud Virtual Private
    Server (VPS) providers are available to use for low month or hourly prices. Such
    services include [https://www.digitalocean.com](https://www.digitalocean.com),
    [www.linode.com](http://www.linode.com), and [www.rackspace.com/cloud/servers](http://www.rackspace.com/cloud/servers).
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 再次强调，我们需要一个具有公开 IP 地址的 Web 服务器。这将允许将电子邮件发送到我们的应用程序。许多云虚拟专用服务器 (VPS) 提供商都提供低月费或按小时计费的服务。这些服务包括
    [https://www.digitalocean.com](https://www.digitalocean.com)、[www.linode.com](http://www.linode.com)
    和 [www.rackspace.com/cloud/servers](http://www.rackspace.com/cloud/servers)。
- en: In order to send e-mails in our application, we'll once again utilize a free
    SendGrid Developer Account, which can be set up at [https://www.sendgrid.com/developers](https://www.sendgrid.com/developers).
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为了在我们的应用程序中发送电子邮件，我们再次将利用一个免费的 SendGrid 开发者账户，该账户可以在 [https://www.sendgrid.com/developers](https://www.sendgrid.com/developers)
    上设置。
- en: In this chapter, we'll once again use the latest version of MySQL (at the time
    of this writing, MySQL 5.6). Make sure that your MySQL server is set up and running
    on your server.
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在本章中，我们再次将使用最新的 MySQL 版本（在撰写本文时为 MySQL 5.6）。请确保你的 MySQL 服务器已经设置并运行在你的服务器上。
- en: Note
  id: totrans-9
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Do you want to try something more challenging? After completing this project,
    try to figure out what changes you need to make to this application to make it
    work with Postgres rather than MySQL.
  id: totrans-10
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 你想尝试更具挑战性的内容吗？完成这个项目后，尝试找出你需要对这个应用程序进行哪些更改才能使其与 Postgres 而不是 MySQL 兼容。
- en: For this project, we'll once again manage our dependencies through Composer,
    which you can download and install from [https://getcomposer.org/](https://getcomposer.org/).
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于这个项目，我们再次将通过 Composer 管理我们的依赖项，你可以从 [https://getcomposer.org/](https://getcomposer.org/)
    下载和安装它。
- en: We'll also be using **Disqus**, a third-party commenting system that we will
    integrate with to display comments on our site. For this project, you'll need
    to register an account with [https://www.disqus.com](https://www.disqus.com).
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们还将使用 **Disqus**，这是一个第三方评论系统，我们将将其集成以在我们的网站上显示评论。对于这个项目，你需要注册一个 [https://www.disqus.com](https://www.disqus.com)
    的账户。
- en: Finally, you'll need a Twitter Developer account, obtained from [https://dev.twitter.com/](https://dev.twitter.com/).
    This account will allow us to enable the social sign-on feature of our application
    through Twitter's OAuth API.
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后，你需要一个 Twitter 开发者账户，可以从 [https://dev.twitter.com/](https://dev.twitter.com/)
    获取。这个账户将允许我们通过 Twitter 的 OAuth API 启用我们应用程序的社交登录功能。
- en: Once you have acquired the listed prerequisites, create a subdomain on the domain
    name you are using and point it to your server. In this chapter, I'll use `chapter6.example.com`
    to refer to this subdomain. After everything is set up and your server is responding
    to that domain name, we can get started.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你获得了列出的前提条件，在你的域名上创建一个子域名并将其指向你的服务器。在本章中，我将使用 `chapter6.example.com` 来指代这个子域名。在一切设置完毕并且你的服务器对该域名做出响应后，我们就可以开始了。
- en: Describing the project
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 描述项目
- en: 'Our CMS can be broken down into several different components:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的 CMS 可以分解为几个不同的组件：
- en: Users who will be responsible for viewing and managing the content
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 负责查看和管理内容的用户
- en: Content to be managed
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要管理的内客
- en: Categories for our content to be placed into
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们内容要放入的类别
- en: Metadata to help us further define our content and users
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 元数据帮助我们进一步定义我们的内容和用户
- en: Search engine optimizations
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 搜索引擎优化
- en: Users
  id: totrans-22
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 用户
- en: The first component of our application is the users who will perform all the
    tasks in our application. For this application, we're going to largely reuse the
    `user` database and authentication system we expanded upon in [Chapter 5](ch05.html
    "Chapter 5. Creating a Microblogging Platform"), *Creating a Microblogging Platform*.
    In this chapter, we'll enhance this functionality by allowing social authentication.
    Our CMS will allow users to register new accounts from the data provided by Twitter;
    after they have registered, the CMS will allow them to sign-in to our application
    by signing in to Twitter.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 我们应用程序的第一个组成部分是用户，他们将执行我们应用程序中的所有任务。对于这个应用程序，我们将大量重用我们在[第5章](ch05.html "第5章。创建一个微博平台")“创建一个微博平台”中扩展的`user`数据库和认证系统。在本章中，我们将通过允许社交认证来增强这一功能。我们的CMS将允许用户通过在Twitter上注册来注册新账户；注册后，CMS将允许他们通过在Twitter上登录来登录我们的应用程序。
- en: 'To enable us to know if a user is a socially authenticated user, we have to
    make several changes to both our database and our authentication scheme. First,
    we''re going to need a way to indicate whether a user is a socially authenticated
    user. Rather than hardcoding a `isAuthenticatedViaTwitter` column in our database,
    we''ll create a new database table called `user_metadata`, which will be a simple
    table that contains the user''s ID, a unique key, and a value. This will allow
    us to store additional information about our users without having to explicitly
    change our user''s database table every time we want to make a change:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 为了让我们能够知道一个用户是否是社交认证用户，我们必须对我们的数据库和认证方案进行一些修改。首先，我们需要一种方式来指示用户是否是社交认证用户。而不是在我们的数据库中硬编码一个`isAuthenticatedViaTwitter`列，我们将创建一个新的数据库表，称为`user_metadata`，它将是一个简单的表，包含用户的ID、一个唯一键和一个值。这将允许我们存储有关我们用户的其他信息，而无需每次我们想要进行更改时都明确更改我们的用户数据库表：
- en: '[PRE0]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: We'll also need to modify our `UserIdentity` class to allow socially authenticated
    users to sign in. To do this, we'll be expanding upon this class to create a `RemoteUserIdentity`
    class that will work off the OAuth codes that Twitter (or any other third-party
    source that works with HybridAuth) provides to us rather than authenticating against
    a username and password.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要修改我们的`UserIdentity`类，以允许社交认证用户登录。为此，我们将扩展这个类来创建一个`RemoteUserIdentity`类，它将使用Twitter（或任何其他与HybridAuth合作的第三方来源）提供给我们的OAuth代码，而不是通过用户名和密码进行认证。
- en: Content
  id: totrans-27
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 内容
- en: 'At the core of our CMS is our content that we''ll manage. For this project,
    we''ll manage simple blog posts that can have additional metadata associated with
    them. Each post will have a title, a body, an author, a category, a unique URI
    or slug, and an indication whether it has been published or not. Our database
    structure for this table will look as follows:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 我们CMS的核心是我们将管理的内客。对于这个项目，我们将管理可以附加额外元数据的简单博客帖子。每个帖子将有一个标题、正文、作者、类别、唯一的URI或缩略名，以及一个指示它是否已发布的标志。我们这个表的数据库结构将如下所示：
- en: '[PRE1]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Each post will also have one or many metadata columns that will further describe
    the posts we''ll be creating. We can use this table (we''ll call it `content_metadata`)
    to have our system store information about each post automatically for us, or
    add information to our posts ourselves, thereby eliminating the need to constantly
    migrate our database every time we want to add a new attribute to our content:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 每个帖子还将有一个或多个元数据列，将进一步描述我们将创建的帖子。我们可以使用这个表（我们将称之为`content_metadata`）来让我们的系统自动为我们存储有关每个帖子的信息，或者我们自己添加信息到我们的帖子中，从而消除每次我们想要向内容添加新属性时都需要不断迁移数据库的需求：
- en: '[PRE2]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Categories
  id: totrans-32
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 类别
- en: 'Each post will be associated with a category in our system. These categories
    will help us further refine our posts. As with our content, each category will
    have its own slug. Before either a post or a category is saved, we''ll need to
    verify that the slug is not already in use. Our table structure will look as follows:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 每个帖子都将与我们的系统中的一个类别相关联。这些类别将帮助我们进一步细化我们的帖子。就像我们的内容一样，每个类别都将有自己的缩略名。在保存帖子或类别之前，我们需要验证缩略名是否已被使用。我们的表结构将如下所示：
- en: '[PRE3]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Search engine optimizations
  id: totrans-35
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 搜索引擎优化
- en: 'The last core component of our application is optimization for search engines
    so that our content can be indexed quickly. SEO is important because it increases
    our discoverability and availability both on search engines and on other marketing
    materials. In our application, there are a couple of things we''ll perform to
    improve our SEO:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 我们应用程序的最后一个核心组件是对搜索引擎的优化，以便我们的内容可以快速索引。SEO很重要，因为它增加了我们在搜索引擎和其他营销材料上的可发现性和可用性。在我们的应用程序中，我们将执行一些操作来提高我们的SEO：
- en: The first SEO enhancement we'll add is a `sitemap.xml` file, which we can submit
    to popular search engines to index. Rather than crawl our content, search engines
    can very quickly index our `sitemap.xml` file, which means that our content will
    show up in search engines faster.
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们将添加的第一个SEO增强功能是一个`sitemap.xml`文件，我们可以将其提交给流行的搜索引擎以进行索引。搜索引擎可以非常快速地索引我们的`sitemap.xml`文件，这意味着我们的内容将更快地出现在搜索引擎中。
- en: 'The second enhancement we''ll be adding is the slugs that we discussed earlier.
    Slugs allow us to indicate what a particular post is about directly from a URL.
    So rather than have a URL that looks like `http://chapter6.example.com/content/post/id/5`,
    we can have URL''s that look like: `http://chapter6.example.com/my-awesome-article`.
    These types of URLs allow search engines and our users to know what our content
    is about without even looking at the content itself, such as when a user is browsing
    through their bookmarks or browsing a search engine.'
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们将添加的第二个增强功能是我们之前讨论过的slugs。Slugs允许我们从URL直接指示特定帖子是关于什么的。因此，我们不必有像`http://chapter6.example.com/content/post/id/5`这样的URL，我们可以有像`http://chapter6.example.com/my-awesome-article`这样的URL。这类URL允许搜索引擎和我们的用户在甚至不看内容本身的情况下了解我们的内容，例如当用户在浏览他们的书签或浏览搜索引擎时。
- en: Initializing the project
  id: totrans-39
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 初始化项目
- en: 'To provide us with a common starting ground, a skeleton project has been included
    with the project resources for this chapter. Included with this skeleton project
    are the necessary migrations, data files, controllers, and views to get us started
    with developing. Also included in this skeleton project are the user authentication
    classes we worked on in [Chapter 5](ch05.html "Chapter 5. Creating a Microblogging
    Platform"), *Creating a Microblogging Platform*. Copy this skeleton project to
    your web server, configure it so that it responds to `chapter6.example.com` as
    outlined at the beginning of the chapter, and then perform the following steps
    to make sure everything is set up:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 为了给我们提供一个共同的起点，本章的项目资源中包含了一个骨架项目。这个骨架项目中包含了必要的迁移、数据文件、控制器和视图，以便我们开始开发。此外，骨架项目中还包含了我们在[第5章](ch05.html
    "第5章。创建一个微博平台")“创建一个微博平台”中工作的用户认证类。将这个骨架项目复制到您的Web服务器上，按照本章开头概述的配置，使其响应`chapter6.example.com`，然后执行以下步骤以确保一切设置正确：
- en: Adjust the permissions on the `assets` and `protected/runtime` folders so that
    they are writable by your web server.
  id: totrans-41
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 调整`assets`和`protected/runtime`文件夹的权限，以便它们可以被您的Web服务器写入。
- en: In this chapter, we'll once again use the latest version of MySQL (at the time
    of writing MySQL 5.6). Make sure that your MySQL server is set up and running
    on your server. Then, create a username, password, and database for our project
    to use, and update your `protected/config/main.php` file accordingly. For simplicity,
    you can use `ch6_cms` for each value.
  id: totrans-42
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在本章中，我们将再次使用MySQL的最新版本（在撰写本文时为MySQL 5.6）。请确保您的MySQL服务器已在您的服务器上设置并运行。然后，为我们的项目创建一个用户名、密码和数据库名，并相应地更新您的`protected/config/main.php`文件。为了简单起见，您可以使用`ch6_cms`作为每个值。
- en: 'Install our Composer dependencies:'
  id: totrans-43
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 安装我们的Composer依赖项：
- en: '[PRE4]'
  id: totrans-44
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Run the `migrate` command and install our mock data:'
  id: totrans-45
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行`migrate`命令并安装我们的模拟数据：
- en: '[PRE5]'
  id: totrans-46
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Finally, add your SendGrid credentials to your `protected/config/params.php`
    file:'
  id: totrans-47
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，将您的SendGrid凭据添加到`protected/config/params.php`文件中：
- en: '[PRE6]'
  id: totrans-48
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'If everything is loaded correctly, you should see a 404 page similar to the
    following:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一切加载正确，你应该会看到一个类似于以下内容的404页面：
- en: '![Initializing the project](img/7734OS_06_02.jpg)'
  id: totrans-50
  prefs: []
  type: TYPE_IMG
  zh: '![初始化项目](img/7734OS_06_02.jpg)'
- en: Exploring the skeleton project
  id: totrans-51
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 探索骨架项目
- en: There are actually a lot of different things going on in the background to make
    this work even if this is just a 404 error. Before we start doing any development,
    let's take a look at a few of the classes that have been provided in our skeleton
    project in the `protected/components` folder.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，在后台有很多不同的操作来使这个工作即使这是一个404错误。在我们开始任何开发之前，让我们看看在`protected/components`文件夹中提供的几个类。
- en: Extending models from a common class
  id: totrans-53
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 从通用类扩展模型
- en: 'The first class that has been provided to us is an ActiveRecord extension called
    `CMSActiveRecord` that all of our models will stem from. This class allows us
    to reduce the amount of code that we have to write in each class. For now, we''ll
    simply add `CTimestampBehavior` and the `afterFind()` method we''ve used in previous
    chapters to store the old attributes for the time the need arises to compare the
    changed attributes with the new attributes:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 我们提供的第一类是一个名为`CMSActiveRecord`的ActiveRecord扩展，所有我们的模型都将从此类派生。此类允许我们减少每个类中需要编写的代码量。目前，我们将简单地添加`CTimestampBehavior`和我们在前几章中使用的`afterFind()`方法，以存储在需要比较更改属性与新属性时所需的老属性：
- en: '[PRE7]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Creating a custom validator for slugs
  id: totrans-56
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 为别名创建自定义验证器
- en: 'Since both `Content` and `Category` classes have slugs, we''ll need to add
    a custom validator to each class that will enable us to ensure that the slug is
    not already in use by either a post or a category. To do this, we have another
    class called `CMSSlugActiveRecord` that extends `CMSActiveRecord` with a `validateSlug()`
    method that we''ll implement as follows:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`Content`和`Category`类都有别名，我们需要为每个类添加一个自定义验证器，以确保别名没有被帖子或类别使用。为此，我们有一个名为`CMSSlugActiveRecord`的类，它扩展了`CMSActiveRecord`并具有一个`validateSlug()`方法，我们将按以下方式实现它：
- en: '[PRE8]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: This implementation simply checks the database for any item that has that slug.
    If nothing is found, or if the current item is the item that is being modified,
    then the validator will return true. Otherwise, it will add an error to the `slug`
    attribute and return false. Both our Content model and Category model will extend
    from this class.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 此实现仅检查数据库中是否存在具有该别名的任何项。如果没有找到，或者当前项是正在修改的项，则验证器将返回true。否则，它将在`slug`属性中添加一个错误并返回false。我们的内容模型和类别模型都将从此类扩展。
- en: View management with themes
  id: totrans-60
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用主题进行视图管理
- en: 'One of the largest challenges of working with larger applications is changing
    their appearance without locking functionality into our views. One way to further
    separate our business logic from our presentation logic is to use themes. Using
    themes in Yii, we can dynamically change the presentation layer of our application
    simply by utilizing the `Yii::app()->setTheme(''themename)` method. Once this
    method is called, Yii will look for view files in `themes/themename/views` rather
    than `protected/views`. Throughout the rest of the chapter, we''ll be adding views
    to a custom theme called `main`, which is located in the `themes` folder. To set
    this theme globally, we''ll be creating a custom class called `CMSController`,
    which all of our controllers will extend from. For now, our theme name will be
    hardcoded within our application. This value could easily be retrieved from a
    database though, allowing us to dynamically change themes from a cached or database
    value rather than changing it in our controller. Have a look at the following
    lines of code:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 与大型应用程序一起工作的最大挑战之一是在不锁定功能到我们的视图中的情况下更改其外观。进一步将我们的业务逻辑与我们的展示逻辑分离的一种方法就是使用主题。在Yii中使用主题，我们可以通过利用`Yii::app()->setTheme('themename')`方法简单地动态更改应用程序的展示层。一旦调用此方法，Yii将查找`themes/themename/views`目录中的视图文件，而不是`protected/views`目录。在本章的其余部分，我们将向位于`themes`文件夹中的自定义主题`main`添加视图。为了全局设置此主题，我们将创建一个名为`CMSController`的自定义类，所有我们的控制器都将从此类扩展。目前，我们的主题名称将硬编码在我们的应用程序中。然而，这个值可以很容易地从数据库中检索，这样我们就可以通过缓存或数据库值动态更改主题，而不是在控制器中更改它。请查看以下代码行：
- en: '[PRE9]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Note
  id: totrans-63
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Alternatively, you can use the `theme` attribute from within the `protected/config/main.php`
    file as outlined in the official documentation [http://www.yiiframework.com/doc/guide/1.1/en/topics.theming](http://www.yiiframework.com/doc/guide/1.1/en/topics.theming).
    While manipulating the theme there is simple, it requires our end user to have
    knowledge of how to manipulate PHP arrays. If you intend on allowing your end
    users to manipulate the theme of their site, it is recommended that you do so
    programmatically via `Yii::app()->setTheme` from a cached or database value. Be
    sure to check out the documentation for more information about using themes.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，您可以使用官方文档中概述的`protected/config/main.php`文件中的`theme`属性[http://www.yiiframework.com/doc/guide/1.1/en/topics.theming](http://www.yiiframework.com/doc/guide/1.1/en/topics.theming)。虽然在那里操作主题很简单，但它要求我们的最终用户了解如何操作PHP数组。如果您打算允许您的最终用户操作他们网站的主题，建议您通过`Yii::app()->setTheme`从缓存或数据库值以编程方式操作。确保查看文档以获取有关使用主题的更多信息。
- en: Truly dynamic routing
  id: totrans-65
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 真正的动态路由
- en: In our previous applications, we had long, boring URLs that had lots of IDs
    and parameters in them. These URLs provided a terrible user experience and prevented
    search engines and users from knowing what the content was about at a glance,
    which in turn would hurt our SEO rankings on many search engines. To get around
    this, we're going to heavily modify our `UrlManager` class to allow truly dynamic
    routing, which means that, every time we create or update a post or a category,
    our URL rules will be updated.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们之前的应用程序中，我们有许多长而无聊的URL，其中包含大量的ID和参数。这些URL提供了糟糕的用户体验，并阻止搜索引擎和用户一眼就能知道内容是什么，这反过来又会损害我们在许多搜索引擎上的SEO排名。为了解决这个问题，我们将对我们的`UrlManager`类进行重大修改，以允许真正的动态路由，这意味着每次我们创建或更新一篇帖子或一个类别时，我们的URL规则都将被更新。
- en: Telling Yii to use our custom UrlManager
  id: totrans-67
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 告诉Yii使用我们的自定义UrlManager
- en: 'Before we can start working on our controllers, we need to create a custom
    `UrlManager` to handle routing of our content so that we can access our content
    by its slug. The steps are as follows:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们可以开始处理我们的控制器之前，我们需要创建一个自定义的`UrlManager`来处理我们内容的路由，这样我们就可以通过其别名来访问我们的内容。步骤如下：
- en: 'The first change we need to make to allow for this routing is to update the
    `components` section of our `protected/config/main.php` file. This will tell Yii
    what class to use for the `UrlManager` component:'
  id: totrans-69
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要做的第一个更改是更新我们的`protected/config/main.php`文件中的`components`部分。这将告诉Yii使用哪个类作为`UrlManager`组件：
- en: '[PRE10]'
  id: totrans-70
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Next, within our `protected/components` folder, we need to create `CMSUrlManager.php`:'
  id: totrans-71
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，在我们的`protected/components`文件夹中，我们需要创建`CMSUrlManager.php`：
- en: '[PRE11]'
  id: totrans-72
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '`CUrlManager` works by populating a rules array. When Yii is bootstrapped,
    it will trigger the `processRules()` method to determine which route should be
    executed. We can overload this method to inject our own rules, which will ensure
    that the action that we want to be executed is executed.'
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`CUrlManager` 通过填充一个规则数组来工作。当Yii启动时，它将触发`processRules()`方法来确定应该执行哪个路由。我们可以重载这个方法来注入我们自己的规则，这将确保我们想要执行的操作被执行。'
- en: 'To get started, let''s first define a set of default routes that we want loaded.
    The routes defined in the following code snippet will allow for pagination on
    our search and home page, enable a static path for our `sitemap.xml` file, and
    provide a route for HybridAuth to use for social authentication:'
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要开始，让我们首先定义一组我们想要加载的默认路由。以下代码片段中定义的路由将允许我们在搜索和主页上进行分页，为我们的`sitemap.xml`文件提供一个静态路径，并为HybridAuth提供用于社交认证的路由：
- en: '[PRE12]'
  id: totrans-75
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Then, we''ll implement our `processRules()` method:'
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们将实现我们的`processRules()`方法：
- en: '[PRE13]'
  id: totrans-77
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '`CUrlManager` already has a public property that we can interface to modify
    the rules, so we''ll inject our own rules into this. The `rules` property is the
    same property that can be accessed from within our config file. Since `processRules()`
    gets called on every page load, we''ll also utilize caching so that our rules
    don''t have to be generated every time. We''ll start by trying to load any of
    our pregenerated rules from our cache, depending upon whether we are in debug
    mode or not:'
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`CUrlManager`已经有一个公开属性，我们可以通过它来修改规则，所以我们将把我们的规则注入到这个属性中。`rules`属性是可以在我们的配置文件中访问的相同属性。由于`processRules()`在每次页面加载时都会被调用，我们还将利用缓存，这样我们的规则就不需要每次都生成。我们将首先尝试从我们的缓存中加载任何预先生成的规则，这取决于我们是否处于调试模式：'
- en: '[PRE14]'
  id: totrans-79
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'If the rules we get back are already set up, we''ll simple return them; otherwise,
    we''ll generate the rules, put them into our cache, and then append our basic
    URL rules that we''ve used throughout the previous chapters:'
  id: totrans-80
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果我们获取的规则已经设置好了，我们将直接返回它们；否则，我们将生成规则，将它们放入我们的缓存中，然后附加我们在前几章中使用的基准URL规则：
- en: '[PRE15]'
  id: totrans-81
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'For abstraction purposes, within our `processRules()` method, we''ve utilized
    two methods we''ll need to create: `generateClientRules`, which will generate
    the rules for content and categories, and `addRSSRules`, which will generate the
    RSS routes for each category.'
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了抽象起见，在我们的`processRules()`方法中，我们使用了两个我们需要创建的方法：`generateClientRules`，它将生成内容和类别的规则，以及`addRSSRules`，它将为每个类别生成RSS路由。
- en: 'The first method, `generateClientRules()`, simply loads our default rules that
    we defined earlier with the rules generated from our content and categories, which
    are populated by the `generateRules()` method:'
  id: totrans-83
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 第一个方法`generateClientRules()`只是加载我们之前定义的默认规则，以及从我们的内容和类别生成的规则，这些规则由`generateRules()`方法填充：
- en: '[PRE16]'
  id: totrans-84
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The `generateRules()` method, that we just defined, actually calls the methods
    that build our routes. Each route is a key-value pair that will take the following
    form:'
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们刚刚定义的 `generateRules()` 方法实际上调用了构建我们路由的方法。每个路由都是一个键值对，其形式如下：
- en: '[PRE17]'
  id: totrans-86
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Content rules will consist of an entry that is published. Have a look at the
    following code:'
  id: totrans-87
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 内容规则将包括一个已发布的条目。请看以下代码：
- en: '[PRE18]'
  id: totrans-88
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Our category rules will consist of all categories in our database. Have a look
    at the following code:'
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们的分类规则将包括我们数据库中的所有分类。请看以下代码：
- en: '[PRE19]'
  id: totrans-90
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Finally, we''ll add our RSS rules that will allow RSS readers to read all content
    for the entire site or for a particular category, as follows:'
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们将添加允许 RSS 阅读器读取整个网站或特定分类的所有内容的 RSS 规则，如下所示：
- en: '[PRE20]'
  id: totrans-92
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Note
  id: totrans-93
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '`CUrlManager` has many different components. If you have questions, be sure
    to reference the Yii Class Reference for this class at [http://www.yiiframework.com/doc/api/1.1/CUrlManager](http://www.yiiframework.com/doc/api/1.1/CUrlManager).'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '`CUrlManager` 有许多不同的组件。如果您有任何问题，请确保参考 [http://www.yiiframework.com/doc/api/1.1/CUrlManager](http://www.yiiframework.com/doc/api/1.1/CUrlManager)
    中的 Yii 类参考。'
- en: Displaying and managing content
  id: totrans-95
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 显示和管理内容
- en: 'Now that Yii knows how to route our content, we can begin work on displaying
    and managing it. Begin by creating a new controller called `ContentController`
    in `protected/controllers` that extends `CMSController`. Have a look at the following
    line of code:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，Yii 已经知道如何路由我们的内容，我们可以开始工作，显示和管理它。首先，在 `protected/controllers` 中创建一个新的控制器，命名为
    `ContentController`，它继承自 `CMSController`。请看以下代码行：
- en: '[PRE21]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'To start with, we''ll define our `accessRules()` method and the default layout
    that we''re going to use. Here''s how:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将定义我们的 `accessRules()` 方法和我们将要使用的默认布局。以下是方法：
- en: '[PRE22]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Rendering the sitemap
  id: totrans-100
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 渲染网站地图
- en: 'The first method we''ll be implementing is our sitemap action. In our `ContentController`,
    create a new method called `actionSitemap()`:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要实现的第一种方法是我们的网站地图行为。在 `ContentController` 中创建一个新的方法，命名为 `actionSitemap()`：
- en: '[PRE23]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'The steps to be performed are as follows:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 需要执行的步骤如下：
- en: 'Since sitemaps come in XML formatting, we''ll start by disabling `WebLogRoute`
    defined in our `protected/config/main.php` file. This will ensure that our XML
    validates when search engines attempt to index it:'
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于网站地图以 XML 格式提供，我们将首先在 `protected/config/main.php` 文件中禁用 `WebLogRoute`。这将确保当搜索引擎尝试索引它时，我们的
    XML 能够通过验证：
- en: '[PRE24]'
  id: totrans-105
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'We''ll then send the appropriate XML headers, disable the rendering of the
    layout, and flush any content that may have been queued to be sent to the browser:'
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们将发送适当的 XML 头部，禁用布局的渲染，并刷新任何可能被排入队列发送到浏览器的所有内容：
- en: '[PRE25]'
  id: totrans-107
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Then, we''ll load all the published entries and categories and send them to
    our sitemap view:'
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将加载所有已发布的条目和分类，并将它们发送到我们的网站地图视图：
- en: '[PRE26]'
  id: totrans-109
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Finally, we have two options to render this view. We can either make it a part
    of our theme in `themes/main/views/content/sitemap.php`, or we can place it in
    `protected/views/content/sitemap.php`. Since a sitemap''s structure is unlikely
    to change, let''s put it in the `protected/views` folder:'
  id: totrans-110
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们有两种渲染此视图的方法。我们既可以将其作为主题的一部分放在 `themes/main/views/content/sitemap.php` 中，也可以将其放在
    `protected/views/content/sitemap.php` 中。由于网站地图的结构不太可能改变，让我们将其放在 `protected/views`
    文件夹中：
- en: '[PRE27]'
  id: totrans-111
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Note
  id: totrans-112
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Even though we've told Yii to look for view files within a theme, it's still
    going to look in the `protected/views` folder if it cannot find the view file
    within the `themes` folder. This feature allows us to separate views that shouldn't
    change (such as sitemaps and RSS feeds) from views that will actually be presented
    to a user.
  id: totrans-113
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 尽管我们已经告诉 Yii 在主题内查找视图文件，但如果它无法在 `themes` 文件夹内找到视图文件，它仍然会在 `protected/views`
    文件夹中查找。这个特性允许我们将不会改变的观点（如网站地图和 RSS 源）与将实际呈现给用户的观点分开。
- en: You can now load `http://chapter6.example.com/sitemap.xml` in your browser to
    see the sitemap. Before you make your site live, be sure to submit this file to
    search engines for them to index.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 您现在可以在浏览器中加载 `http://chapter6.example.com/sitemap.xml` 来查看网站地图。在您的网站上线之前，请确保将此文件提交给搜索引擎以便它们进行索引。
- en: Displaying a list view of content
  id: totrans-115
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 显示内容列表视图
- en: 'Next, we''ll implement the actions necessary to display all of our content
    and a particular post. We''ll start by providing a paginated view of our posts.
    Since `CListView` and the Content model''s `search()` method already provide this
    functionality, we can utilize those classes to generate and display this data:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将实现显示所有内容和一个特定帖子所需的行为。我们将首先提供我们帖子的分页视图。由于 `CListView` 和内容模型的 `search()`
    方法已经提供了这个功能，我们可以利用这些类来生成和显示这些数据：
- en: To begin with, open `protected/models/Content.php` and modify the return value
    of the `search()` method as follows. This will ensure that Yii's pagination uses
    the correct variable in our `CListView`, and tells Yii how many results to load
    per page.
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，打开`protected/models/Content.php`并修改`search()`方法的返回值，如下所示。这将确保Yii的分页在我们的`CListView`中使用正确的变量，并告诉Yii每页要加载多少结果。
- en: '[PRE28]'
  id: totrans-118
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Next, implement the `actionIndex()` method with the `$page` parameter. We''ve
    already told our `UrlManager` how to handle this, which means that we''ll get
    pretty URI''s for pagination (for example, `/blog`, `/blog/2`, `/blog/3`, and
    so on):'
  id: totrans-119
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，实现带有`$page`参数的`actionIndex()`方法。我们之前已经告诉了我们的`UrlManager`如何处理这个问题，这意味着我们将获得用于分页的相当不错的URI（例如，`/blog`、`/blog/2`、`/blog/3`等等）：
- en: '[PRE29]'
  id: totrans-120
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Then we''ll create a view in `themes/main/views/content/all.php`; this will
    display the data within our `dataProvider`:'
  id: totrans-121
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，在`themes/main/views/content/all.php`中创建一个视图；这将显示`dataProvider`内的数据：
- en: '[PRE30]'
  id: totrans-122
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Finally, copy `themes/main/views/content/all.php` from the project resources
    folder so that our views can render.
  id: totrans-123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，从项目资源文件夹中复制`themes/main/views/content/all.php`，以便我们的视图可以渲染。
- en: 'Since our database has already been populated with some sample data, you can
    start playing around with the results right away, as shown in the following screenshot:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们的数据库已经填充了一些示例数据，你可以立即开始尝试结果，如下面的截图所示：
- en: '![Displaying a list view of content](img/7734OS_06_03.jpg)'
  id: totrans-125
  prefs: []
  type: TYPE_IMG
  zh: '![显示内容列表视图](img/7734OS_06_03.jpg)'
- en: Displaying content by ID
  id: totrans-126
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 通过ID显示内容
- en: 'Since our routing rules are already set up, displaying our content is extremely
    simple. All that we have to do is search for a published model with the ID passed
    to the view action and render it:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们的路由规则已经设置，显示我们的内容非常简单。我们只需要搜索一个传递给视图动作的已发布的模型并渲染它：
- en: '[PRE31]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: After copying `themes/main/views/content/view.php` from the project resources
    folder into your project, you'll be able to click into a particular post from
    the home page. In its present form, this action has introduced an interesting
    side effect that could negatively impact our SEO rankings on search engines—the
    same entry can now be accessed from two URI's. For example, `http://chapter6.example.com/content/view/id/1`
    and `http://chapter6.example.com/quis-condimentum-tortor` now bring up the same
    post. Fortunately, correcting this bug is fairly easy. Since the goal of our slugs
    is to provide more descriptive URIs, we'll simply block access to the view if
    a user tries to access it from the non-slugged URI.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 在将`themes/main/views/content/view.php`从项目资源文件夹复制到你的项目中后，你将能够从主页点击进入特定的帖子。在其当前形式下，这个动作引入了一个有趣的副作用，可能会对我们的搜索引擎优化排名产生负面影响——相同的条目现在可以从两个URI访问。例如，`http://chapter6.example.com/content/view/id/1`和`http://chapter6.example.com/quis-condimentum-tortor`现在都会显示相同的帖子。幸运的是，修复这个错误相当简单。由于我们的slugs的目的是提供更具描述性的URI，我们将简单地阻止用户从非slugged
    URI访问视图：
- en: 'We''ll do this by creating a new method called `beforeViewAction()` that takes
    the entry ID as a parameter and gets called right after the `actionView()` method
    is called. This private method will simply check the URI from `CHttpRequest` to
    determine how `actionView` was accessed and return a 404 if it''s not through
    our beautiful slugs:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将通过创建一个名为`beforeViewAction()`的新方法来实现这一点，该方法接受条目ID作为参数，并在调用`actionView()`方法后立即被调用。这个私有方法将简单地检查`CHttpRequest`中的URI以确定`actionView`是如何被访问的，如果它不是通过我们漂亮的slugs，则返回404：
- en: '[PRE32]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Then, right after our `actionView` starts, we can simultaneously set the correct
    return URL and block access to the content if it wasn''t accessed through the
    slug as follows:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在我们的`actionView`开始之后，我们可以同时设置正确的返回URL，并阻止未通过slug访问的内容，如下所示：
- en: '[PRE33]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Adding comments to our CMS with Disqus
  id: totrans-134
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用Disqus在我们的CMS中添加评论
- en: 'Presently, our content is only informative in nature—we have no way for our
    users to communicate with us what they thought about our entry. To encourage engagement,
    we can add a commenting system to our CMS to further engage with our readers.
    Rather than writing our own commenting system, we can leverage comment through
    Disqus, a free, third-party commenting system. Even through Disqus, comments are
    implemented in JavaScript and we can create a custom widget wrapper for it to
    display comments on our site. The steps are as follows:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，我们的内容仅具有信息性质——我们无法让我们的用户与我们交流他们对条目的看法。为了鼓励参与，我们可以在我们的CMS中添加一个评论系统，以进一步与读者互动。我们不必编写自己的评论系统，可以利用Disqus提供的评论，Disqus是一个免费的三方评论系统。即使通过Disqus，评论也是通过JavaScript实现的，我们可以为它创建一个自定义的小部件包装器，以便在我们的网站上显示评论。步骤如下：
- en: To begin with, log in to the Disqus account you created at the beginning of
    this chapter as outlined in the prerequisites section. Then, navigate to [http://disqus.com/admin/create/](http://disqus.com/admin/create/)
    and fill out the form fields as prompted and as shown in the following screenshot:![Adding
    comments to our CMS with Disqus](img/7734OS_06_04.jpg)
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，按照前言部分概述的先决条件登录您在本章开头创建的Disqus账户。然后，导航到[http://disqus.com/admin/create/](http://disqus.com/admin/create/)并填写表单字段，如提示和以下截图所示：![使用Disqus添加我们的CMS评论](img/7734OS_06_04.jpg)
- en: 'Then, add a `disqus` section to your `protected/config/params.php` file with
    your site `shortname`:'
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，在`protected/config/params.php`文件中添加一个`disqus`部分，包含您的网站`shortname`：
- en: '[PRE34]'
  id: totrans-138
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Next, create a new widget in `protected/components` called `DisqusWidget.php`.
    This widget will be loaded within our view and will be populated by our Content
    model:'
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，在`protected/components`中创建一个新的小部件`DisqusWidget.php`。这个小部件将在我们的视图中加载，并由我们的内容模型填充：
- en: '[PRE35]'
  id: totrans-140
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Begin by specifying the public properties that our view will be able to inject
    into as follows:'
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，指定我们的视图将能够注入的公共属性，如下所示：
- en: '[PRE36]'
  id: totrans-142
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Then, overload the `init()` method to load the Disqus JavaScript callback and
    to populate the JavaScript variables with those populated to the widget as follows:'
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，重载`init()`方法以加载Disqus JavaScript回调，并将JavaScript变量填充到小部件中，如下所示：
- en: '[PRE37]'
  id: totrans-144
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Finally, within our `themes/main/views/content/view.php` file, load the widget
    as follows:'
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，在我们的`themes/main/views/content/view.php`文件中，按照以下方式加载小部件：
- en: '[PRE38]'
  id: totrans-146
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Now, when you load any given post, Disqus comments will also be loaded with
    that post. Go ahead and give it a try!
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当您加载任何给定帖子时，Disqus评论也将与该帖子一起加载。试试看吧！
- en: '![Adding comments to our CMS with Disqus](img/7734OS_06_07.jpg)'
  id: totrans-148
  prefs: []
  type: TYPE_IMG
  zh: '![使用Disqus添加我们的CMS评论](img/7734OS_06_07.jpg)'
- en: Note
  id: totrans-149
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The greatest benefit of using Disqus as a service provider is that it enables
    us to focus solely on the integration of a product rather than raw implementation.
    By not having to reinvent the wheel each time we need a service, we can save a
    lot of time and money. When relying on a third party, however, be cognizant of
    the fact that the service provider may not exist the next day. While unlikely,
    a large service provider can go out of business overnight, so be prepared to have
    a plan in place to replace or substitute any third-party service you integrate
    into your application.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Disqus作为服务提供商的最大好处是，它使我们能够专注于产品的集成，而不是原始实现。通过每次需要服务时不必重新发明轮子，我们可以节省大量时间和金钱。然而，当依赖第三方时，请注意，服务提供商可能第二天就不存在了。虽然不太可能，但大型服务提供商可能一夜之间就会倒闭，因此请准备好制定计划以替换或替代您集成到应用程序中的任何第三方服务。
- en: Searching for content
  id: totrans-151
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 搜索内容
- en: 'Next, we''ll implement a search method so that our users can search for posts.
    To do this, we''ll implement an instance of `CActiveDataProvider` and pass that
    data to our `themes/main/views/content/all.php` view to be rendered and paginated:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将实现一个搜索方法，以便我们的用户可以搜索帖子。为此，我们将实现`CActiveDataProvider`的一个实例，并将该数据传递到我们的`themes/main/views/content/all.php`视图以进行渲染和分页：
- en: '[PRE39]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Since our view file already exists, we can now search for content in our CMS.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们的视图文件已经存在，我们现在可以在我们的CMS中搜索内容。
- en: Note
  id: totrans-155
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: In previous chapters, we would have simply queried the `$_POST` array for our
    search parameter. A more Yii way of retrieving these variables is to use the `Yii::app()->request->getParam()`
    method from the `CHttpRequest` class. Be warned, however, that this method operates
    on both `$_GET` and `$_POST` parameters. If the same parameter is sent via both
    HTTP methods (you should avoid doing this when possible), only the `$_GET` method
    will be returned. Be sure to read the `CHttpRequest` Class Reference page for
    more information at [http://www.yiiframework.com/doc/api/1.1/CHttpRequest](http://www.yiiframework.com/doc/api/1.1/CHttpRequest).
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的章节中，我们可能会简单地查询`$_POST`数组以获取我们的搜索参数。使用`Yii::app()->request->getParam()`方法从`CHttpRequest`类检索这些变量的更Yii的方式是。但是，请注意，此方法同时操作`$_GET`和`$_POST`参数。如果相同的参数通过两种HTTP方法发送（在可能的情况下应避免这样做），则仅返回`$_GET`方法。确保阅读[http://www.yiiframework.com/doc/api/1.1/CHttpRequest](http://www.yiiframework.com/doc/api/1.1/CHttpRequest)的`CHttpRequest`类参考页面以获取更多信息。
- en: Managing content
  id: totrans-157
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 管理内容
- en: 'Next, we''ll implement a basic set of management tools that will allow us to
    create, update, and delete entries:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将实现一组基本的管理工具，这将使我们能够创建、更新和删除条目：
- en: 'We''ll start by defining our `loadModel()` method and the `actionDelete()`
    method:'
  id: totrans-159
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将首先定义我们的`loadModel()`方法和`actionDelete()`方法：
- en: '[PRE40]'
  id: totrans-160
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Next, we can implement our admin view, which will allow us to view all the
    content in our system and to create new entries. Be sure to copy the `themes/main/views/content/admin.php`
    file from the project resources folder into your project before using this view:'
  id: totrans-161
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  id: totrans-162
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Finally, we''ll implement a save view to create and update entries. Saving
    content will simply pass it through our content model''s validation rules. The
    only override we''ll be adding is ensuring that the author is assigned to the
    user editing the entry. Before using this view, be sure to copy the `themes/main/views/content/save.php`
    file from the project resources folder into your project:'
  id: totrans-163
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  id: totrans-164
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'At this point, you can now log in to the system using the credentials provided
    in the following table and start managing entries:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
- en: '| Username | Password |'
  id: totrans-166
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  id: totrans-167
  prefs: []
  type: TYPE_TB
- en: '| `user1@example.com` | `test` |'
  id: totrans-168
  prefs: []
  type: TYPE_TB
- en: '| `user2@example.com` | `test` |'
  id: totrans-169
  prefs: []
  type: TYPE_TB
- en: Viewing and managing categories
  id: totrans-170
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now, let''s move to viewing and managing categories. As outlined previously,
    each category will be accessible via a dedicated route and will only display content
    within that category. We''ll start by defining our default access rules and layout
    name in `protected/controllers/CategoryController.php`:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: Viewing entries in a category
  id: totrans-173
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Displaying entries in each category will be nearly identical to displaying all
    entries, so we can implement our index action as follows. Note that the parameters
    passed to this method are simply passed from the routes we generated earlier.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Viewing an RSS feed for categories
  id: totrans-176
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'An alternative way of viewing entries in a particular category is through an
    RSS feed. RSS feeds are a very popular medium that allows your users to subscribe
    to your content and be regularly notified of updates without having to visit each
    site individually. Our action to display our category entries in an RSS feed look
    as follows:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Then, add the following to your `protected/views/category/rss.php` file:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: Now, if you navigate to `3`, you can view an RSS feed of all uncategorized entries.
    Each category will have its own RSS feed, allowing users to subscribe to the content
    they are interested in rather than all the content on your site.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
- en: Managing categories
  id: totrans-182
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Next, we need to implement management of our categories:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ll start with our `loadModel()` and `actionDelete()` methods:'
  id: totrans-184
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE47]'
  id: totrans-185
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Then, we''ll implement the admin action. Be sure to copy the `themes/main/views/category/admin.php`
    file from the project resources folder. Have a look at the following code:'
  id: totrans-186
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE48]'
  id: totrans-187
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Finally, we''ll implement the `save()` method. Be sure to copy the `themes/main/views/category/save.php`
    file from the project resources folder. Have a look at the following code:'
  id: totrans-188
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE49]'
  id: totrans-189
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE49]'
- en: We've now finished the core of our content management system. The structure
    that we've built for our CMS, while being extremely simple, provides a lot of
    flexibility for us to expand upon with very minimal effort.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
- en: Social authentication with HybridAuth
  id: totrans-191
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapter, [Chapter 5](ch05.html "Chapter 5. Creating a Microblogging
    Platform"), *Creating a Microblogging Platform*, we used HybridAuth to sign in
    as a user to, and share content with, Twitter. In this chapter, we use HybridAuth
    to register accounts in our CMS and to sign in to our CMS without having to enter
    a username and password. To achieve this, we'll create three new forms, a new
    `UserIdentity` class, and a control that will enable us to take advantage of all
    the providers that HybridAuth has to offer.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
- en: 'Before we get started with any coding, however, we need to first create a new
    Twitter application similar to the one we created in [Chapter 5](ch05.html "Chapter 5. Creating
    a Microblogging Platform"), *Creating a Microblogging Platform*. This will allow
    us to focus on development rather than configuration once we start writing code.
    Once your Twitter application has been created and permissions have been set,
    add a `hybridauth` section to your `protected/config/params.php` file, containing
    your OAuth secret token and key:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: Note
  id: totrans-195
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When we're done, you'll be able to add any of the supported HybridAuth providers
    listed in the HybridAuth documentation at [http://hybridauth.sourceforge.net/userguide.html](http://hybridauth.sourceforge.net/userguide.html).
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
- en: Validating remote identities
  id: totrans-197
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For our application, we need to register users from a social network, authenticate
    users from a social network to users in our database, and link existing users
    to a social identity. We're also going to authenticate users into our system.
    To achieve this, we're going to create three separate forms, `RemoteRegistrationForm`,
    `RemoteLinkAccountForm`, and `RemoteIdentityForm`, which will serve as our `LoginForm`
    for remote users. We'll also create a `RemoteUserIdentity` class that we'll use
    to authenticate users into our system. Let's get started.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
- en: Remote registrations
  id: totrans-199
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The first class we''ll need to create is `RemoteRegistrationForm`. This form
    will allow us to register users using information from their social identity.
    The steps are as follows:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
- en: 'To get started, create a new class in `protected/models` called `RemoteRegistrationForm.php`
    with the following definition. To keep things simple, we''re going to be reusing
    much of the functionality already available from our `RegistrationForm` class.
    Have a look at the following line of code:'
  id: totrans-201
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE51]'
  id: totrans-202
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'We''ll then specify two additional attributes, the HybridAuth adapter that
    we''ll provide from the controller we''ll create later on and the provider name
    that we''re authenticating with. We''ll also set up validators for these attributes
    to ensure that they are set. Notice that we''re using the `mergeArray()` method
    from the `CMap` class to take advantage of the validation rules that are already
    in place:'
  id: totrans-203
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE52]'
  id: totrans-204
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Finally, we''ll overload our `save()` method so that the provider name and
    OAuth token are written to our database. We''ll take advantage of this metadata
    when we create our `RemoteIdentityForm` class:'
  id: totrans-205
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE53]'
  id: totrans-206
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE53]'
- en: Linking a social identity to an existing account
  id: totrans-207
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 将社交身份链接到现有账户
- en: 'To assist in linking a social identity to an existing account in our system,
    we''re going to create a new class called `RemoteLinkAccountForm`. This form will
    prompt an already logged-in user for their password to verify their identity and
    then bind the OAuth token provided by HybridAuth to that user, so that they can
    log in using their social identity in the future. The steps are as follows:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 为了帮助将社交身份链接到我们系统中的现有账户，我们将创建一个新的类，称为`RemoteLinkAccountForm`。此表单将提示已登录用户输入他们的密码以验证其身份，然后将HybridAuth提供的OAuth令牌绑定到该用户，以便他们将来可以使用社交身份登录。步骤如下：
- en: 'To get started, create a new class in `protected/models` called `RemoteLinkAccountForm.php`
    with the following definition:'
  id: totrans-209
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要开始，请在`protected/models`中创建一个新的类，名为`RemoteLinkAccountForm.php`，其定义如下：
- en: '[PRE54]'
  id: totrans-210
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'We''ll then define the public attributes we''ll want to collect and create
    a validator for them. We''ll also define a private attribute to store the user
    information of the user we want to link our social identity to. Have a look at
    the following lines of code:'
  id: totrans-211
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们将定义我们想要收集的公共属性并为其创建验证器。我们还将定义一个私有属性以存储我们想要将我们的社交身份链接到的用户信息。请查看以下代码行：
- en: '[PRE55]'
  id: totrans-212
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'For security reasons, we only want the authenticated user to be able to link
    a social identity to their account. To verify that we are dealing with the account
    owner, we''ll prompt the user for their password. To validate their password,
    we''ll create a custom validator called `validateUserPassword`. Have a look at
    the following lines of code:'
  id: totrans-213
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于安全原因，我们只想让经过认证的用户能够将社交身份链接到他们的账户。为了验证我们正在处理账户所有者，我们将提示用户输入他们的密码。为了验证他们的密码，我们将创建一个自定义验证器，称为`validateUserPassword`。请查看以下代码行：
- en: '[PRE56]'
  id: totrans-214
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'Finally, we create a `save()` method that will save the social identity information
    to our `user_metdata` table provided that the user is able to verify their identity:'
  id: totrans-215
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们创建一个`save()`方法，将社交身份信息保存到我们的`user_metdata`表中，前提是用户能够验证他们的身份：
- en: '[PRE57]'
  id: totrans-216
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE57]'
- en: Authenticating with a social identity
  id: totrans-217
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用社交身份进行认证
- en: 'To authenticate with a social identity, we''ll need to create a form similar
    to our `LoginForm`; however, instead of taking a username and password as inputs,
    it will take the provider name and the HybridAuth adapter we''re working with.
    The steps are as follows:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用社交身份进行认证，我们需要创建一个类似于我们的`LoginForm`的表单；然而，它将接受提供者名称和我们在其中工作的HybridAuth适配器作为输入，而不是用户名和密码。步骤如下：
- en: 'Begin by creating a new form in `protected/models` called `RemoteIdentityForm.php`:'
  id: totrans-219
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，在`protected/models`中创建一个新的表单，名为`RemoteIdentityForm.php`：
- en: '[PRE58]'
  id: totrans-220
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'As stated previously, we''ll collect the provider name and the HybridAuth adapter
    instead of a username and password, so let''s declare those properties. We''ll
    also declare properties to store our user''s information if they exist and the
    `RemoteUserIdentity` class, which we''ll ultimately authenticate with:'
  id: totrans-221
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如前所述，我们将收集提供者名称和HybridAuth适配器，而不是用户名和密码，因此让我们声明这些属性。我们还将声明属性以存储用户信息（如果存在）以及`RemoteUserIdentity`类，我们将最终使用该类进行身份验证：
- en: '[PRE59]'
  id: totrans-222
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'We''ll then define our validation rules and create a custom validator that
    will retrieve the appropriate user from within our system. This will prevent unauthorized
    users from authenticating into our CMS without being able to first authenticate
    with the social network that the user''s account is linked to:'
  id: totrans-223
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们将定义我们的验证规则并创建一个自定义验证器，它将检索我们系统中的适当用户。这将防止未经授权的用户在没有首先通过与用户账户链接的社交网络进行身份验证的情况下认证到我们的CMS：
- en: '[PRE60]'
  id: totrans-224
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'Then we''ll create an `authenticate()` method that will behave in the same
    manner as the `authenticate()` method of our `LoginForm`; however, it will use
    the `RemoteUserIdentity` class as opposed to the `UserIdentity` class. Have a
    look at the following code:'
  id: totrans-225
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们将创建一个`authenticate()`方法，其行为将与我们的`LoginForm`中的`authenticate()`方法相同；然而，它将使用`RemoteUserIdentity`类而不是`UserIdentity`类。请查看以下代码：
- en: '[PRE61]'
  id: totrans-226
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'Finally, we''ll create a `login()` method that will actually log our user in
    to our CMS:'
  id: totrans-227
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们将创建一个`login()`方法，实际上将我们的用户登录到我们的CMS：
- en: '[PRE62]'
  id: totrans-228
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE62]'
- en: Creating a Yii CWebUser object from a remote identity
  id: totrans-229
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 从远程身份创建Yii CWebUser对象
- en: 'The last class we''ll need to create before linking everything together is
    a `RemoteUserIdentity` class. This class will retrieve all the information from
    our forms; if validated, it will log the user in to our CMS in the same way that
    our `UserIdentity` class does. The steps are as follows:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 在将所有内容链接在一起之前，我们还需要创建一个`RemoteUserIdentity`类。此类将检索我们表单中的所有信息；如果经过验证，它将以与我们的`UserIdentity`类相同的方式将用户登录到我们的CMS。步骤如下：
- en: To get started, create a new class in `protected/components` called `RemoteUserIdentity.php`.
  id: totrans-231
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要开始，请在`protected/components`目录中创建一个名为`RemoteUserIdentity.php`的新类。
- en: '[PRE63]'
  id: totrans-232
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'Then, define the attributes that we''ll be collecting from our constructor
    as follows:'
  id: totrans-233
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，定义我们从构造函数中收集的属性，如下所示：
- en: '[PRE64]'
  id: totrans-234
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'We should also define a way to retrieve the user''s ID as stored in our system.
    We''ll follow the pattern laid out in our `UserIdentity` class to keep things
    consistent:'
  id: totrans-235
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们还应该定义一种方法来检索存储在我们系统中的用户ID。我们将遵循`UserIdentity`类中设定的模式以保持一致性：
- en: '[PRE65]'
  id: totrans-236
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'Finally, we''ll create an `authenticate()` method that will set our `CWebUser`
    states. As we need to check that the data is available to us, the information
    provided to us should already be validated:'
  id: totrans-237
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们将创建一个`authenticate()`方法来设置我们的`CWebUser`状态。由于我们需要检查数据是否可供我们使用，因此提供给我们的信息应该已经过验证：
- en: '[PRE66]'
  id: totrans-238
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE66]'
- en: Putting it all together
  id: totrans-239
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 整合所有内容
- en: 'With all of the necessary components in place, we can now create our controller
    that will handle the authentication component with HybridAuth. The steps are as
    follows:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 在所有必要的组件就绪后，我们现在可以创建我们的控制器，该控制器将使用HybridAuth处理身份验证组件。步骤如下：
- en: 'To begin with, create a new controller in `protected/controllers` called `HybridController.php`:'
  id: totrans-241
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，在`protected/controllers`目录中创建一个名为`HybridController.php`的新控制器：
- en: '[PRE67]'
  id: totrans-242
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'Next, we''ll create three properties to hold the HybridAuth adapter, the provider
    name, and the user profile that we''ll get back from Twitter:'
  id: totrans-243
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将创建三个属性来保存HybridAuth适配器、提供者名称以及我们从Twitter获取的用户个人资料：
- en: '[PRE68]'
  id: totrans-244
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'We''ll also create custom getter and setter methods to set the adapter as follows:'
  id: totrans-245
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们还将创建自定义的获取器和设置器方法来设置适配器，如下所示：
- en: '[PRE69]'
  id: totrans-246
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'Then we''ll add in a block to retrieve the user''s profile information from
    the social network they are signing in from:'
  id: totrans-247
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们将添加一个块来从用户登录的社交网络中检索用户的个人资料信息：
- en: '[PRE70]'
  id: totrans-248
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'Then, to get and set the provider''s name that will be provided from the URI,
    the following code needs to be used:'
  id: totrans-249
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，为了从URI获取并设置提供者的名称，需要使用以下代码：
- en: '[PRE71]'
  id: totrans-250
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'By referencing the HybridAuth documentation ([http://hybridauth.sourceforge.net/userguide/Configuration.html](http://hybridauth.sourceforge.net/userguide/Configuration.html)),
    we can determine what variables HybridAuth will require to initialize correctly.
    Rather than hardcoding all of this information in our configuration file, we can
    dynamically populate it from within our controller. This method will ensure that
    our base URLs will always be set correctly, and that logging information will
    be sent to the correct place. It has the additional benefit of only logging when
    we enable `YII_DEBUG`, which means we only have to make one change to our configuration
    file when debugging rather than multiple changes. Have a look at the following
    code:'
  id: totrans-251
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过参考HybridAuth文档（[http://hybridauth.sourceforge.net/userguide/Configuration.html](http://hybridauth.sourceforge.net/userguide/Configuration.html)），我们可以确定HybridAuth初始化时所需的变量。我们可以在控制器内部动态填充这些信息，而不是在配置文件中硬编码所有这些信息。这种方法将确保我们的基本URL始终设置正确，并且将日志信息发送到正确的位置。它还有一个额外的好处，即只有在启用`YII_DEBUG`时才记录日志，这意味着在调试时我们只需更改配置文件一次，而不是多次更改。请看以下代码：
- en: '[PRE72]'
  id: totrans-252
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'Next, we''ll define our `actionIndex()`. This action will serve both as the
    initialization URL for HybridAuth and our callback URL for our social networks
    to authenticate against. Within this action, we''ll set the provider and start
    the HybridAuth process:'
  id: totrans-253
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将定义我们的`actionIndex()`。此操作将作为HybridAuth的初始化URL和我们的社交网络的回调URL。在此操作中，我们将设置提供者并启动HybridAuth过程：
- en: '[PRE73]'
  id: totrans-254
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE73]'
- en: Note
  id: totrans-255
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Internally, HybridAuth will throw an exception whenever it encounters an error
    while dealing with the remote network. To prevent our application from exposing
    too much information, we can simply inform the user that an error occurred.
  id: totrans-256
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在内部，每当HybridAuth在处理远程网络时遇到错误时，它都会抛出一个异常。为了防止我们的应用程序泄露过多信息，我们可以简单地通知用户发生了错误。
- en: 'Then, we''ll define the `hybridauth()` method we started to use earlier. We''ll
    start by initializing the HybridAuth object and setting the adapter if it is not
    already set:'
  id: totrans-257
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们将定义我们之前开始使用的`hybridauth()`方法。我们首先初始化HybridAuth对象，并设置适配器（如果尚未设置）：
- en: '[PRE74]'
  id: totrans-258
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE74]'
- en: Note
  id: totrans-259
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: We've declared a custom getter and setter for our adapter so that we only load
    it once during our flow. This will prevent us from hitting the rate limits of
    the Twitter API during a single request.
  id: totrans-260
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们为我们的适配器声明了一个自定义的getter和setter，这样我们就可以在我们的流程中只加载它一次。这将防止我们在单个请求中达到Twitter API的速率限制。
- en: 'At this point, HybridAuth is going to perform several different redirects to
    authenticate our user against their system. When the request is returned to us,
    we''ll be able to verify that a user is connected to our adapter. If one isn''t,
    it''s safe to throw an exception. Have a look at the following code:'
  id: totrans-261
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这一点上，HybridAuth将执行几个不同的重定向，以验证用户是否对其系统进行了认证。当请求返回给我们时，我们将能够验证用户是否连接到我们的适配器。如果没有，可以安全地抛出异常。请看以下代码：
- en: '[PRE75]'
  id: totrans-262
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'Within our `if` statement, we''ll try to authenticate the user using our `RemoteIdentityForm`
    class that we created earlier. We''ll display a flash message and redirect the
    user to the home page if we''re able to. If we''re not able to authenticate the
    user, we''ll either display the `LinkAccountForm` class if the user is authenticated
    in our system but not socially, or the `RemoteRegistrationForm` class so that
    the user can register a new account in our CMS:'
  id: totrans-263
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在我们的`if`语句中，我们将尝试使用我们之前创建的`RemoteIdentityForm`类来认证用户。如果我们能够认证用户，我们将显示一个闪存消息并将用户重定向到主页。如果我们不能认证用户，我们将显示`LinkAccountForm`类（如果用户在我们的系统中进行了认证但未进行社交认证），或者显示`RemoteRegistrationForm`类，以便用户可以在我们的CMS中注册新账户：
- en: '[PRE76]'
  id: totrans-264
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'Our `authenticate()` method will simply return the result of the `RemoteIdentityForm`
    `login()` method:'
  id: totrans-265
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们的`authenticate()`方法将简单地返回`RemoteIdentityForm` `login()`方法的调用结果：
- en: '[PRE77]'
  id: totrans-266
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE77]'
- en: 'If a user is already authenticated in our CMS but hasn''t been authenticated
    with this provider, we''ll assume that they want to link their social network
    identity to their login information; thus, we''ll present `RemoteLinkAccountForm`
    and prompt them for their password. Then, be sure to copy over `themes/main/views/users/linkaccount.php`
    from the project resources folder into your project:'
  id: totrans-267
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果用户已经在我们的CMS中进行了认证但尚未使用此提供者进行认证，我们假设他们想要将他们的社交网络身份链接到他们的登录信息；因此，我们将展示`RemoteLinkAccountForm`并提示他们输入密码。然后，请确保将`themes/main/views/users/linkaccount.php`从项目资源文件夹复制到您的项目中：
- en: '[PRE78]'
  id: totrans-268
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE78]'
- en: 'Finally, if a user is not logged in to our CMS, we''ll display our `RemoteRegisterForm`
    and reutilize the view from `themes/main/views/user/register.php`:'
  id: totrans-269
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，如果用户未登录到我们的CMS，我们将显示我们的`RemoteRegisterForm`并重新利用`themes/main/views/user/register.php`视图：
- en: '[PRE79]'
  id: totrans-270
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE79]'
- en: 'Now that we have everything in place, we can test our social authentication.
    For our first test, log out of our CMS, navigate to `http://chapter6.example.com/site/login`,
    and click on the **sign in with Twitter** link at the bottom. Click on the link,
    and enter your Twitter credentials. Upon being redirected, you should see a registration
    form where you can enter your information for a new account, as shown in the following
    screenshot:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经一切准备就绪，我们可以测试我们的社交认证。对于第一次测试，请从我们的CMS登出，导航到`http://chapter6.example.com/site/login`，然后点击底部的**使用Twitter登录**链接。点击链接，并输入您的Twitter凭据。在重定向后，您应该会看到一个注册表单，您可以在此输入您的新账户信息，如下面的截图所示：
- en: '![Putting it all together](img/7734OS_06_05.jpg)'
  id: totrans-272
  prefs: []
  type: TYPE_IMG
  zh: '![整合一切](img/7734OS_06_05.jpg)'
- en: Enter your new user's information and then click on **Register**. If successful,
    you'll be logged in to the CMS as the user you just created, and the activation
    e-mail we created in the previous chapter will be sent to that e-mail address.
    Now, if you log out of the CMS and log in using the **Login with Twitter** link,
    you'll be automatically logged in to the CMS without having to enter your username
    and password.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 输入您的新用户信息，然后点击**注册**。如果成功，您将以您刚刚创建的用户身份登录到CMS，并且我们在上一章中创建的激活电子邮件将发送到该电子邮件地址。现在，如果您从CMS登出并使用**登录Twitter**链接登录，您将自动登录到CMS，而无需输入用户名和密码。
- en: 'After verifying that registering with a social identity works, log out of the
    CMS and then log in as `user1@example.com` using the credentials previously provided.
    Log out of Twitter and then navigate to `http://chapter6.example.com/hybrid/twitter`.
    After signing in to Twitter with a different account from the one you previous
    signed in with, you''ll be prompted to enter your current password as shown in
    the following screenshot:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 在验证使用社交身份注册有效后，请从CMS登出，然后使用之前提供的凭据以`user1@example.com`的身份登录。登出Twitter后，导航至`http://chapter6.example.com/hybrid/twitter`。使用与之前登录不同的账户登录Twitter后，系统会提示您输入当前密码，如下面的截图所示：
- en: '![Putting it all together](img/7734OS_06_06.jpg)'
  id: totrans-275
  prefs: []
  type: TYPE_IMG
  zh: '![整合一切](img/7734OS_06_06.jpg)'
- en: After entering your password, your social identity will be linked to your account,
    and you'll be able to login via Twitter rather than having to enter your username
    and password.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 输入密码后，您的社交身份将与您的账户关联，您将能够通过Twitter登录，而无需输入用户名和密码。
- en: Exploring other HybridAuth providers
  id: totrans-277
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 探索其他HybridAuth提供者
- en: Due to the way we implemented our controller, we can easily and seamlessly add
    additional providers to the `hybridauth` section of our `protected/config/params.php`
    file without having to modify any other code in our system. Be sure to check out
    the HybridAuth user guide located at [http://hybridauth.sourceforge.net/userguide.html#index](http://hybridauth.sourceforge.net/userguide.html#index)
    for more information on how to integrate with other third-party providers, such
    as Google+ and Facebook, and give it a try!
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们实现了我们的控制器，我们可以轻松且无缝地向我们的`protected/config/params.php`文件中的`hybridauth`部分添加额外的提供者，而无需修改系统中任何其他代码。请务必查看位于[http://hybridauth.sourceforge.net/userguide.html#index](http://hybridauth.sourceforge.net/userguide.html#index)的HybridAuth用户指南，以获取有关如何与其他第三方提供者（如Google+和Facebook）集成的更多信息，并尝试一下！
- en: Summary
  id: totrans-279
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: Wow, we really did implement a lot in this chapter. In this chapter, we created
    a very robust and reusable content management system that featured both content
    and categories. We also dug deeper into Yii framework by manipulating our `CUrlManager`
    class to generate completely dynamic and clean URIs. We also covered the use of
    Yii's built-in theming to dynamically change the frontend appearance of our site
    by simply changing a configuration value. Finally, we learned how to integrate
    with third-party social networks to provide a social sign-on functionality that
    seamlessly integrates without our application.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 哇，我们确实在本章中实现了很多功能。在本章中，我们创建了一个非常健壮且可重用的内容管理系统，它具有内容和类别功能。我们还通过操作我们的`CUrlManager`类来生成完全动态和干净的URI，进一步深入研究了Yii框架。我们还介绍了使用Yii内置的主题，通过简单地更改配置值来动态更改网站的前端外观。最后，我们学习了如何与第三方社交网络集成，以提供无缝集成的社交登录功能。
- en: In the next chapter, we'll be reusing much of the code built in this chapter
    to further separate the management functionality of our application from the presentation
    logic. We'll also dig deeper into Yii framework by learning how to create modules.
    Before continuing to the next chapter, be sure to go over the Yii Class Reference
    at [http://www.yiiframework.com/doc/api/](http://www.yiiframework.com/doc/api/)
    and review all the classes that we used in this chapter. Then, when you're ready,
    head over to the next chapter, and let's build a custom dashboard module for our
    CMS!
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将重用本章构建的大量代码，以进一步将应用程序的管理功能与表示逻辑分离。我们还将通过学习如何创建模块来深入了解Yii框架。在继续下一章之前，请务必查阅位于[http://www.yiiframework.com/doc/api/](http://www.yiiframework.com/doc/api/)的Yii类参考，并回顾本章中使用的所有类。然后，当您准备好时，前往下一章，让我们为我们的CMS构建一个自定义仪表板模块！
