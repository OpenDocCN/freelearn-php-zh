<html><head></head><body>
<div id="page" style="height:0pt"/><div class="book" title="Chapter&#xA0;4.&#xA0;Models and Collections"><div class="book" id="QMFO2-818f5224668745eb9070ddf1d85e6bfa"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch04" class="calibre1"/>Chapter 4. Models and Collections</h1></div></div></div><p class="calibre7">Like most modern frameworks and platforms, these days Magento embraces an <span class="strong"><strong class="calibre8">Object Relational Mapping</strong></span> (<span class="strong"><strong class="calibre8">ORM</strong></span>) approach over raw SQL queries. Though the underlying mechanism <a id="id139" class="calibre1"/>still comes down to SQL, we are now dealing strictly with objects. This makes our application code more readable, manageable, and isolated from vendor-specific SQL differences. Model, resource, and collection are three types of classes working together to allow us full entity data management, from loading, saving, deleting, and listing entities. The majority of our data access and management will be done via PHP classes called Magento models. Models themselves don't contain any code for communicating with the database.</p><p class="calibre7">The database communication part is decoupled into its own PHP class called resource class. Each model is then assigned a resource class. Calling <code class="email">load</code>, <code class="email">save</code>, or <code class="email">delete</code> methods on models get delegated to resource classes, as they are the ones to actually read, write, and delete data from the database. Theoretically, with enough knowledge, it is possible to write new resource classes for various database vendors.</p><p class="calibre7">Next to the model and resource classes, we have collection classes. We can think of a collection as an array of individual model instances. On a base level, collections extend from the <code class="email">\Magento\Framework\Data\Collection</code> class, which implements <code class="email">\IteratorAggregate</code> and <code class="email">\Countable</code> from <span class="strong"><strong class="calibre8">Standard PHP Library</strong></span> (<span class="strong"><strong class="calibre8">SPL</strong></span>) and a few other Magento-specific classes.</p><p class="calibre7">More often than not, we look at model and resource as a single unified thing, thus simply calling it a model. Magento deals with two types of models, which we might categorize as <a id="id140" class="calibre1"/>simple and EAV models.</p><p class="calibre7">In this chapter, we will cover the following topics:</p><div class="book"><ul class="itemizedlist"><li class="listitem">Creating a miniature module</li><li class="listitem">Creating a simple model</li><li class="listitem">The EAV model</li><li class="listitem">Understanding the flow of schema and data scripts</li><li class="listitem">Creating an install schema script (<code class="email">InstallSchema.php</code>)</li><li class="listitem">Creating an upgrade schema script (<code class="email">UpgradeSchema.php</code>)</li><li class="listitem">Creating an install data script (<code class="email">InstallData.php</code>)</li><li class="listitem">Creating an upgrade data script (<code class="email">UpgradeData.php</code>)</li><li class="listitem">Entity CRUD actions</li><li class="listitem">Managing collections</li></ul></div></div>

<div class="book" title="Chapter&#xA0;4.&#xA0;Models and Collections">
<div class="book" title="Creating a miniature module"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_1"><a id="ch04lvl1sec22" class="calibre1"/>Creating a miniature module</h1></div></div></div><p class="calibre7">For<a id="id141" class="calibre1"/> the purpose of this chapter, we will create a miniature module called <code class="email">Foggyline_Office</code>.</p><p class="calibre7">The module will have two entities defined as follows:</p><div class="book"><ul class="itemizedlist"><li class="listitem"><code class="email">Department</code>: a simple model with the following fields:<div class="book"><ul class="itemizedlist1"><li class="listitem"><code class="email">entity_id</code>: primary key</li><li class="listitem"><code class="email">name</code>: name of department, string value</li></ul></div></li><li class="listitem"><code class="email">Employee</code>: an EAV model with the following fields and attributes:<div class="book"><ul class="itemizedlist1"><li class="listitem"><span class="strong"><strong class="calibre8">Fields:</strong></span><div class="book"><ul class="itemizedlist2"><li class="listitem"><code class="email">entity_id</code>: primary key</li><li class="listitem"><code class="email">department_id</code>: foreign key, pointing to <code class="email">Department.entity_id</code></li><li class="listitem"><code class="email">email</code>: unique e-mail of an employee, string value</li><li class="listitem"><code class="email">first_name</code>: first name of an employee, string value</li><li class="listitem"><code class="email">last_name</code>: last name of an employee, string value</li></ul></div></li><li class="listitem"><span class="strong"><strong class="calibre8">Attributes:</strong></span><div class="book"><ul class="itemizedlist2"><li class="listitem"><code class="email">service_years</code>: employee's years of service, integer value</li><li class="listitem"><code class="email">dob</code>: employee's date of birth, date-time value</li><li class="listitem"><code class="email">salary</code> – monthly salary, decimal value</li><li class="listitem"><code class="email">vat_number</code>: VAT number, (short) string value</li><li class="listitem"><code class="email">note</code>: possible note on employee, (long) string value</li></ul></div></li></ul></div></li></ul></div><p class="calibre7">Every module starts with the <code class="email">registration.php</code> and <code class="email">module.xml</code> files. For the purpose of our chapter module, let's create the <code class="email">app/code/Foggyline/Office/registration.php</code> file with content as follows:</p><div class="informalexample"><pre class="programlisting">&lt;?php
\Magento\Framework\Component\ComponentRegistrar::register(
    \Magento\Framework\Component\ComponentRegistrar::MODULE,
    'Foggyline_Office',
    __DIR__
);</pre></div><p class="calibre7">The <code class="email">registration.php</code> file is sort of an entry point to our module.</p><p class="calibre7">Now <a id="id142" class="calibre1"/>let's create the <code class="email">app/code/Foggyline/Office/etc/module.xml</code> file with the following content:</p><div class="informalexample"><pre class="programlisting">&lt;config  xsi:noNamespaceSchemaLocation="urn:magento:framework:Module/ etc/module.xsd"&gt;
    &lt;module name="Foggyline_Office" setup_version="1.0.0"&gt;
        &lt;sequence&gt;
            &lt;module name="Magento_Eav"/&gt;
        &lt;/sequence&gt;
    &lt;/module&gt;
&lt;/config&gt;</pre></div><p class="calibre7">We will get into more details about the structure of the <code class="email">module.xml</code> file in later chapters. Right now, we will only focus on the <code class="email">setup_version</code> attribute and <code class="email">module</code> element within <code class="email">sequence</code>.</p><p class="calibre7">The value of <code class="email">setup_version</code> is important because we might use it within our schema install script (<code class="email">InstallSchema.php</code>) files, effectively turning the install script into an update script, as we will show soon.</p><p class="calibre7">The <code class="email">sequence</code> element is Magento's way of setting dependencies for our module. Given that our module will make use of EAV entities, we list <code class="email">Magento_Eav</code> as a dependency.</p></div></div>

<div class="book" title="Chapter&#xA0;4.&#xA0;Models and Collections">
<div class="book" title="Creating a miniature module">
<div class="book" title="Creating a simple model"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_2"><a id="ch04lvl2sec15" class="calibre1"/>Creating a simple model</h2></div></div></div><p class="calibre7">The <code class="email">Department</code> entity, as per requirements, is modeled as a simple model. We previously<a id="id143" class="calibre1"/> mentioned that whenever we talk about models, we implicitly think of <code class="email">model</code> class, <code class="email">resource</code> class, and <code class="email">collection</code> class forming one unit.</p><p class="calibre7">Let's start by first creating a <code class="email">model</code> class, (partially) defined under the <code class="email">app/code/Foggyline/Office/Model/Department.php</code> file as follows:</p><div class="informalexample"><pre class="programlisting">namespace Foggyline\Office\Model;

class Department extends \Magento\Framework\Model\AbstractModel
{
    protected function _construct()
    {
        $this-&gt; _init('Foggyline\Office\Model \ResourceModel\Department');
    }
}</pre></div><p class="calibre7">All that is<a id="id144" class="calibre1"/> happening here is that we are extending from the <code class="email">\Magento\Framework\Model\AbstractModel</code> class, and triggering the <code class="email">$this-&gt;_init</code> method within <code class="email">_construct</code> passing it our <code class="email">resource</code> class.</p><p class="calibre7">The <code class="email">AbstractModel</code> further extends <code class="email">\Magento\Framework\Object</code>. The fact that our <code class="email">model</code> class ultimately extends from <code class="email">Object</code> means that we do not have to define a property name on our <code class="email">model</code> class. What <code class="email">Object</code> does for us is that it enables us to get, set, unset, and check for a value existence on properties magically. To give a more robust example than <code class="email">name</code>, imagine our entity has a property called <code class="email">employee_average_salary </code>in the following code:</p><div class="informalexample"><pre class="programlisting">$department-&gt;getData('employee_average_salary');
$department-&gt;getEmployeeAverageSalary();

$department-&gt;setData('employee_average_salary', 'theValue');
$department-&gt;setEmployeeAverageSalary('theValue');

$department-&gt;unsetData('employee_average_salary');
$department-&gt;unsEmployeeAverageSalary();

$department-&gt;hasData('employee_average_salary');
$department-&gt;hasEmployeeAverageSalary();</pre></div><p class="calibre7">The reason why this works is due to <code class="email">Object</code> implementing the <code class="email">setData</code>, <code class="email">unsetData</code>, <code class="email">getData</code>, and magic <code class="email">__call</code> methods. The beauty of the magic <code class="email">__call</code> method implementation is that it understands method calls like <code class="email">getEmployeeAverageSalary</code>, <code class="email">setEmployeeAverageSalary</code>, <code class="email">unsEmployeeAverageSalary</code>, and <code class="email">hasEmployeeAverageSalary</code> even if they do not exist on the <code class="email">Model</code> class. However, if we choose to implement some of these methods within our <code class="email">Model</code> class, we are free to do so and Magento will pick it up when we call it.</p><p class="calibre7">This is an important aspect of Magento, sometimes confusing to newcomers.</p><p class="calibre7">Once we have a <code class="email">model</code> class in place, we create a model <code class="email">resource</code> class, (partially) defined under the <code class="email">app/code/Foggyline/Office/Model/ResourceModel/Department.php</code> file as follows:</p><div class="informalexample"><pre class="programlisting">namespace Foggyline\Office\Model\ResourceModel;

class Department extends \Magento\Framework\Model\ResourceModel\Db\AbstractDb
{
    protected function _construct()
    {
        $this-&gt;_init('foggyline_office_department', 'entity_id');
    }
}</pre></div><p class="calibre7">Our <a id="id145" class="calibre1"/>resource class that extends from <code class="email">\Magento\Framework\Model\ResourceModel\Db\AbstractDb</code> triggers the <code class="email">$this-&gt;_init</code> method call within <code class="email">_construct</code>. <code class="email">$this-&gt;_init</code> accepts two parameters. The first parameter is the table name <code class="email">foggyline_office_department</code>, where our model will persist its data. The second parameter is the primary column name <code class="email">entity_id</code> within that table.</p><p class="calibre7"><code class="email">AbstractDb</code> further extends <code class="email">Magento\Framework\Model\ResourceModel\AbstractResource</code>.</p><div class="informalexample" title="Note"><h3 class="title2"><a id="note09" class="calibre1"/>Note</h3><p class="calibre7">The resource class is the key to communicating to the database. All it takes is for us to name the table and its primary key and our models can save, delete, and update entities.</p></div><p class="calibre7">Finally, we create our <code class="email">collection</code> class, (partially) defined under the <code class="email">app/code/Foggyline/Office/Model/ResourceModel/Department/Collection.php</code> file as follows:</p><div class="informalexample"><pre class="programlisting">namespace Foggyline\Office\Model\ResourceModel\Department;

class Collection extends \Magento\Framework\Model\ResourceModel \Db\Collection\AbstractCollection
{
    protected function _construct()
    {
        $this-&gt;_init(
            'Foggyline\Office\Model\Department',
            'Foggyline\Office\Model\ResourceModel\Department'
        );
    }
}</pre></div><p class="calibre7">The <code class="email">collection</code> class extends from <code class="email">\Magento\Framework\Model\ResourceModel\Db\Collection\AbstractCollection</code> and, similar to the <code class="email">model</code> and <code class="email">resource</code> classes, does a <code class="email">$this-&gt;_init</code> method call within <code class="email">_construct</code>. This time, <code class="email">_init</code> accepts two parameters. The first parameter is the full <code class="email">model</code> class name <code class="email">Foggyline\Office\Model\Department</code>, and the second parameter is the full resource class name <code class="email">Foggyline\Office\Model\ResourceModel\Department</code>.</p><p class="calibre7"><code class="email">AbstractCollection</code> implements <code class="email">Magento\Framework\App\ResourceConnection\SourceProviderInterface</code>, and extends <code class="email">\Magento\Framework\Data\Collection\AbstractDb</code>. <code class="email">AbstractDb</code> further extends <code class="email">\Magento\Framework\Data\Collection</code>.</p><p class="calibre7">It is <a id="id146" class="calibre1"/>worth taking some time to study the inners of these <code class="email">collection</code> classes, as this is our go-to place for whenever we need to deal with fetching a list of entities that match certain search criteria.</p></div></div></div>

<div class="book" title="Chapter&#xA0;4.&#xA0;Models and Collections">
<div class="book" title="Creating a miniature module">
<div class="book" title="Creating an EAV model"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_3"><a id="ch04lvl2sec16" class="calibre1"/>Creating an EAV model</h2></div></div></div><p class="calibre7">The <code class="email">Employee</code> entity, as per requirements, is modeled as an EAV model.</p><p class="calibre7">Let's<a id="id147" class="calibre1"/> start by first creating an EAV <code class="email">model</code> class, (partially) defined under the <code class="email">app/code/Foggyline/Office/Model/Employee.php</code> file as follows:</p><div class="informalexample"><pre class="programlisting">namespace Foggyline\Office\Model;

class Employee extends \Magento\Framework\Model\AbstractModel
{
    const ENTITY = 'foggyline_office_employee';

    public function _construct()
    {
        $this-&gt; _init('Foggyline\Office \Model \ResourceModel\Employee');
    }
}</pre></div><p class="calibre7">Here, we are extending from the <code class="email">\Magento\Framework\Model\AbstractModel</code> class, which is the same as with the simple model previously described. The only difference here is that we have an <code class="email">ENTITY</code> constant defined, but this is merely syntactical sugar for later on; it bears no meaning for the actual <code class="email">model</code> class.</p><p class="calibre7">Next, we create an EAV model <code class="email">resource</code> class, (partially) defined under the <code class="email">app/code/Foggyline/Office/Model/ResourceModel/Employee.php</code> file as follows:</p><div class="informalexample"><pre class="programlisting">namespace Foggyline\Office\Model\ResourceModel;

class Employee extends \Magento\Eav\Model\Entity\AbstractEntity
{

    protected function _construct()
    {
        $this-&gt;_read = 'foggyline_office_employee_read';
        $this-&gt;_write = 'foggyline_office_employee_write';
    }

    public function getEntityType()
    {
        if (empty($this-&gt;_type)) {
            $this-&gt;setType(\Foggyline\Office\Model \Employee::ENTITY);
        }
        return parent::getEntityType();
    }
}</pre></div><p class="calibre7">Our <code class="email">resource</code> class extends from <code class="email">\Magento\Eav\Model\Entity\AbstractEntity</code>, and sets<a id="id148" class="calibre1"/> the <code class="email">$this-&gt;_read</code>, <code class="email">$this-&gt;_write</code> class properties through <code class="email">_construct</code>. These are freely assigned to whatever value we want, preferably following the naming pattern of our module. The read and write connections need to be named or else Magento produces an error when using our entities.</p><p class="calibre7">The <code class="email">getEntityType</code> method internally sets the <code class="email">_type</code> value to <code class="email">\Foggyline\Office\Model\Employee::ENTITY</code>, which is the string <code class="email">foggyline_office_employee</code>. This same value is what's stored in the <code class="email">entity_type_code</code> column within the <code class="email">eav_entity_type</code> table. At this point, there is no such entry in the <code class="email">eav_entity_type</code> table. This is because the install schema script will be creating one, as we will be demonstrating soon.</p><p class="calibre7">Finally, we create our <code class="email">collection</code> class, (partially) defined under the <code class="email">app/code/Foggyline/Office/Model/ResourceModel/Employee/Collection.php</code> file as follows:</p><div class="informalexample"><pre class="programlisting">namespace Foggyline\Office\Model\ResourceModel\Employee;

class Collection extends \Magento\Eav\Model\Entity\Collection\AbstractCollection
{
    protected function _construct()
    {
        $this-&gt;_init('Foggyline\Office\Model\Employee', 'Foggyline\Office\Model\ResourceModel\Employee');
    }
}</pre></div><p class="calibre7">The <code class="email">collection</code> class extends from <code class="email">\Magento\Eav\Model\Entity\Collection\AbstractCollection</code> and, similar to the model class, does a <code class="email">$this-&gt;_init</code> method call within <code class="email">_construct</code>. <code class="email">_init</code> accepts two parameters: the full model class name <code class="email">Foggyline\Office\Model\Employee</code>, and the full resource class name <code class="email">Foggyline\Office\Model\ResourceModel\Employee</code>.</p><p class="calibre7"><code class="email">AbstractCollection</code> has the same parent tree as the simple model collection class, but on its <a id="id149" class="calibre1"/>own it implements a lot of EAV collection-specific methods like <code class="email">addAttributeToFilter</code>, <code class="email">addAttributeToSelect</code>, <code class="email">addAttributeToSort</code>, and so on.</p><div class="informalexample" title="Note"><h3 class="title2"><a id="note10" class="calibre1"/>Note</h3><p class="calibre7">As we can see, EAV models look a lot like simple models. The difference lies mostly in the <code class="email">resource</code> class and <code class="email">collection</code> class implementations and their first level parent classes. However, we need to keep in mind that the example given here is the simplest one possible. If we look at the <code class="email">eav_entity_type</code> table in the database, we can see that other entity types make use of <code class="email">attribute_model</code>, <code class="email">entity_attribute_collection</code>, <code class="email">increment_model</code>, and so on. These are all advanced properties we can define alongside our EAV model making it closer to the implementation of the <code class="email">catalog_product</code> entity type, which is probably the most robust one in Magento. This type of advanced EAV usage is out of the scope of this book as it is probably worth a book on its own.</p></div><p class="calibre7">Now that we have simple and EAV models in place, it is time to look into installing the necessary database schema and possibly pre-fill it with some data. This is done through schema and data scripts.</p></div></div></div>
<div class="book" title="Understanding the flow of schema and data scripts" id="RL0A1-818f5224668745eb9070ddf1d85e6bfa"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch04lvl1sec23" class="calibre1"/>Understanding the flow of schema and data scripts</h1></div></div></div><p class="calibre7">Simply <a id="id150" class="calibre1"/>put, the role of the schema scripts is to create a database<a id="id151" class="calibre1"/> structure supporting your module logic. For example, creating a table where our entities would persist their data. The role of the data scripts is to manage the data within existing tables, usually in the form of adding some sample data during module installation.</p><p class="calibre7">If we look a few steps back, we can notice how <code class="email">schema_version</code> and <code class="email">data_version</code> from the database match the <code class="email">setup_version</code> number from our <code class="email">module.xml</code> file. They all imply the same thing. If we were to now change the <code class="email">setup_version</code> number in our <code class="email">module.xml</code> file and run the <code class="email">php bin/magento setup:upgrade</code> console command again, our database <code class="email">schema_version</code> and <code class="email">data_version</code> would get updated to this new version number.</p><p class="calibre7">This is done through module's <code class="email">install</code> and <code class="email">upgrade</code> scripts. If we take a quick look at the <code class="email">setup/src/Magento/Setup/Model/Installer.php</code> file, we can see a function, <code class="email">getSchemaDataHandler</code>, with<a id="id152" class="calibre1"/> content as follows:</p><div class="informalexample"><pre class="programlisting">private function getSchemaDataHandler($moduleName, $type)
{
    $className = str_replace('_', '\\', $moduleName) . '\Setup';
    switch ($type) {
        case 'schema-install':
            $className .= '\InstallSchema';
            $interface = self::SCHEMA_INSTALL;
            break;
        case 'schema-upgrade':
            $className .= '\UpgradeSchema';
            $interface = self::SCHEMA_UPGRADE;
            break;
        case 'schema-recurring':
            $className .= '\Recurring';
            $interface = self::SCHEMA_INSTALL;
            break;
        case 'data-install':
            $className .= '\InstallData';
            $interface = self::DATA_INSTALL;
            break;
        case 'data-upgrade':
            $className .= '\UpgradeData';
            $interface = self::DATA_UPGRADE;
            break;
        default:
            throw new \Magento\Setup\Exception("$className does not exist");
    }

    return $this-&gt;createSchemaDataHandler($className, $interface);
}</pre></div><p class="calibre7">This is<a id="id153" class="calibre1"/> what tells Magento which classes to pick up and run from the individual module <code class="email">Setup</code> directory. We will ignore the Recurring case for the moment, as only the <code class="email">Magento_Indexer</code> module uses it.</p><p class="calibre7">For the first time, we run <code class="email">php bin/magento setup:upgrade</code> against our module; while it still has no entries under the <code class="email">setup_module</code> table, Magento will execute the files within the module <code class="email">Setup</code> folder in following order:</p><div class="book"><ul class="itemizedlist"><li class="listitem"><code class="email">InstallSchema.php</code></li><li class="listitem"><code class="email">UpgradeSchema.php</code></li><li class="listitem"><code class="email">InstallData.php</code></li><li class="listitem"><code class="email">UpgradeData.php</code></li></ul></div><p class="calibre7">Notice that this is the same order, top to bottom, as in the <code class="email">getSchemaDataHandler</code> method.</p><p class="calibre7">Every<a id="id154" class="calibre1"/> subsequent upper module version number change, followed <a id="id155" class="calibre1"/>by the console <code class="email">php bin/magento setup:upgrade</code> command, would result in the following files being run in the order as listed:</p><div class="book"><ul class="itemizedlist"><li class="listitem"><code class="email">UpgradeSchema.php</code></li><li class="listitem"><code class="email">UpgradeData.php</code></li></ul></div><p class="calibre7">Additionally, Magento would record the upped version number under the <code class="email">setup_module</code> database. Magento will only trigger install or upgrade scripts when the version number in the database is less than the version number in the <code class="email">module.xml</code> file.</p><div class="informalexample" title="Note"><h3 class="title2"><a id="tip04" class="calibre1"/>Tip</h3><p class="calibre7">We are not required to always provide these install or upgrade scripts, if ever. They are only needed when we need to add or edit existing tables or entries in a database.</p></div><p class="calibre7">If we look carefully at the implementation of the <code class="email">install</code> and <code class="email">update</code> methods within the appropriate scripts, we can see they both accept <code class="email">ModuleContextInterface $context</code> as a second parameter. Since upgrade scripts are the ones triggering on every upped version number, we can use <code class="email">$context-&gt;getVersion()</code> to target changes specific to the module version.</p></div>
<div class="book" title="Creating an install schema script (InstallSchema.php)"><div class="book" id="SJGS2-818f5224668745eb9070ddf1d85e6bfa"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch04lvl1sec24" class="calibre1"/>Creating an install schema script (InstallSchema.php)</h1></div></div></div><p class="calibre7">Now <a id="id156" class="calibre1"/>that we understand the flow of schema and data scripts and their relation to the module version number, let us go ahead and start assembling our <code class="email">InstallSchema</code>. We start by defining the <code class="email">app/code/Foggyline/Office/Setup/InstallSchema.php</code> file with (partial) content as follows:</p><div class="informalexample"><pre class="programlisting">namespace Foggyline\Office\Setup;

use Magento\Framework\Setup\InstallSchemaInterface;
use Magento\Framework\Setup\ModuleContextInterface;
use Magento\Framework\Setup\SchemaSetupInterface;

class InstallSchema implements InstallSchemaInterface
{
    public function install(SchemaSetupInterface $setup, ModuleContextInterface $context)
    {
        $setup-&gt;startSetup();
        /* #snippet1 */
        $setup-&gt;endSetup();
    }
}</pre></div><p class="calibre7"><code class="email">InstallSchema</code> conforms to <code class="email">InstallSchemaInterface</code>, which requires the implementation<a id="id157" class="calibre1"/> of the <code class="email">install</code> method that accepts two parameters of type <code class="email">SchemaSetupInterface</code> and <code class="email">ModuleContextInterface</code>.</p><p class="calibre7">The install method is all that is required here. Within this method, we would add any relevant code we might have to create the tables and columns we need.</p><p class="calibre7">Looking through the code base, we can see that <code class="email">Magento\Setup\Module\Setup</code> is the one extending <code class="email">\Magento\Framework\Module\Setup</code> and implementing <code class="email">SchemaSetupInterface</code>. The two methods seen in the preceding code, <code class="email">startSetup</code> and <code class="email">endSetup</code>, are used to run additional environment setup before and after our code.</p><p class="calibre7">Going further, let's replace the <code class="email">/* #snippet1 */</code> bit with code that will create our <code class="email">Department</code> model entity table as follows:</p><div class="informalexample"><pre class="programlisting">$table = $setup-&gt;getConnection()
    -&gt;newTable($setup-&gt;getTable('foggyline_office_department'))
    -&gt;addColumn(
        'entity_id',
        \Magento\Framework\DB\Ddl\Table::TYPE_INTEGER,
        null,
        ['identity' =&gt; true, 'unsigned' =&gt; true, 'nullable' =&gt; false, 'primary' =&gt; true],
        'Entity ID'
    )
    -&gt;addColumn(
        'name',
        \Magento\Framework\DB\Ddl\Table::TYPE_TEXT,
        64,
        [],
        'Name'
    )
    -&gt;setComment('Foggyline Office Department Table');
$setup-&gt;getConnection()-&gt;createTable($table);
/* #snippet2 */</pre></div><p class="calibre7">Here, we are instructing Magento to create a table named <code class="email">foggyline_office_department</code>, add <code class="email">entity_id</code> and <code class="email">name</code> columns to it, and set the comment on the table. Assuming we are using the MySQL server, when code executes, the <a id="id158" class="calibre1"/>following SQL gets executed in the database:</p><div class="informalexample"><pre class="programlisting">CREATE TABLE 'foggyline_office_department' (
  'entity_id' int(10) unsigned NOT NULL AUTO_INCREMENT COMMENT 'Entity ID',
  'name' varchar(64) DEFAULT NULL COMMENT 'Name',
  PRIMARY KEY ('entity_id')
) ENGINE=InnoDB AUTO_INCREMENT=3 DEFAULT CHARSET=utf8 COMMENT='Foggyline Office Department Table';</pre></div><p class="calibre7">The <code class="email">addColumn</code> method is the most interesting one here. It takes five parameters, from column name, column data type, column length, array of additional options, and column description. However, only column name and column data type are mandatory! Accepted column data types can be found under the <code class="email">Magento\Framework\DB\Ddl\Table</code> class, and go as follows:</p><div class="informalexample"><pre class="programlisting">boolean     smallint    integer     bigint
float       numeric     decimal     date
timestamp   datetime    text        blob
varbinary</pre></div><p class="calibre7">An additional options array might contain some of the following keys: <code class="email">unsigned</code>, <code class="email">precision</code>, <code class="email">scale</code>, <code class="email">unsigned</code>, <code class="email">default</code>, <code class="email">nullable</code>, <code class="email">primary</code>, <code class="email">identity</code>, <code class="email">auto_increment</code>.</p><p class="calibre7">Having gained insight into the <code class="email">addColumn</code> method, let's go ahead and create the <code class="email">foggyline_office_employee_entity</code> table for the <code class="email">Employee</code> entity as well. We do so by replacing the <code class="email">/* #snippet2 */</code> bit from the preceding code with the following code:</p><div class="informalexample"><pre class="programlisting">$employeeEntity = \Foggyline\Office\Model\Employee::ENTITY;
$table = $setup-&gt;getConnection()
    -&gt;newTable($setup-&gt;getTable($employeeEntity . '_entity'))
    -&gt;addColumn(
        'entity_id',
        \Magento\Framework\DB\Ddl\Table::TYPE_INTEGER,
        null,
        ['identity' =&gt; true, 'unsigned' =&gt; true, 'nullable' =&gt; false, 'primary' =&gt; true],
        'Entity ID'
    )
    -&gt;addColumn(
        'department_id',
        \Magento\Framework\DB\Ddl\Table::TYPE_INTEGER,
        null,
        ['unsigned' =&gt; true, 'nullable' =&gt; false],
        'Department Id'
    )
    -&gt;addColumn(
        'email',
        \Magento\Framework\DB\Ddl\Table::TYPE_TEXT,
        64,
        [],
        'Email'
    )
    -&gt;addColumn(
        'first_name',
        \Magento\Framework\DB\Ddl\Table::TYPE_TEXT,
        64,
        [],
        'First Name'
    )
    -&gt;addColumn(
        'last_name',
        \Magento\Framework\DB\Ddl\Table::TYPE_TEXT,
        64,
        [],
        'Last Name'
    )
    -&gt;setComment('Foggyline Office Employee Table');
$setup-&gt;getConnection()-&gt;createTable($table);
/* #snippet3 */</pre></div><p class="calibre7">Following <a id="id159" class="calibre1"/>good database design practices, we might notice one thing here. If we agree that every employee can be assigned a single department, we should add a foreign key to this table's <code class="email">department_id</code> column. For the moment, we will purposely skip this bit, as we want to demonstrate this through the update schema script later on.</p><p class="calibre7">EAV models scatter their data across several tables, three at a minimum. The table <code class="email">foggyline_office_employee_entity</code> that we just created is one of them. The other one is the core Magento <code class="email">eav_attribute</code> table. The third table is not a single table, rather a list of multiple tables; one for each EAV type. These tables are the result of our install script.</p><p class="calibre7">Information stored within the core Magento <code class="email">eav_attribute</code> table is not the value of an attribute or anything like it; information stored there is an attribute's metadata. So how does Magento know about our <code class="email">Employee</code> attributes (<code class="email">service_years</code>, <code class="email">dob</code>, <code class="email">salary</code>, <code class="email">vat_number</code>, <code class="email">note</code>)? It does not; not yet. We need to add the attributes into that table ourselves. We will do so later on, as we demonstrate the <code class="email">InstallData</code>.</p><p class="calibre7">Depending <a id="id160" class="calibre1"/>on the EAV attribute data type, we need to create the following tables:</p><div class="book"><ul class="itemizedlist"><li class="listitem"><code class="email">foggyline_office_employee_entity_datetime</code></li><li class="listitem"><code class="email">foggyline_office_employee_entity_decimal</code></li><li class="listitem"><code class="email">foggyline_office_employee_entity_int</code></li><li class="listitem"><code class="email">foggyline_office_employee_entity_text</code></li><li class="listitem"><code class="email">foggyline_office_employee_entity_varchar</code></li></ul></div><p class="calibre7">The names of these attribute value tables come from a simple formula, which says <span class="strong"><em class="calibre9">{name of the entity table}+{_}+{eav_attribute.backend_type value}</em></span>. If we look at the salary attribute, we need it to be a decimal value, thus it will get stored in <code class="email">foggyline_office_employee_entity_decimal</code>.</p><p class="calibre7">Given the chunkiness of code behind defining attribute value tables, we will focus only on a single, decimal type table. We define it by replacing <code class="email">/* #snippet3 */</code> from the preceding code with the following bit:</p><div class="informalexample"><pre class="programlisting">$table = $setup-&gt;getConnection()
    -&gt;newTable($setup-&gt;getTable($employeeEntity . '_entity_decimal'))
    -&gt;addColumn(
        'value_id',
        \Magento\Framework\DB\Ddl\Table::TYPE_INTEGER,
        null,
        ['identity' =&gt; true, 'nullable' =&gt; false, 'primary' =&gt; true],
        'Value ID'
    )
    -&gt;addColumn(
        'attribute_id',
        \Magento\Framework\DB\Ddl\Table::TYPE_SMALLINT,
        null,
        ['unsigned' =&gt; true, 'nullable' =&gt; false, 'default' =&gt; '0'],
        'Attribute ID'
    )
    -&gt;addColumn(
        'store_id',
        \Magento\Framework\DB\Ddl\Table::TYPE_SMALLINT,
        null,
        ['unsigned' =&gt; true, 'nullable' =&gt; false, 'default' =&gt; '0'],
        'Store ID'
    )
    -&gt;addColumn(
        'entity_id',
        \Magento\Framework\DB\Ddl\Table::TYPE_INTEGER,
        null,
        ['unsigned' =&gt; true, 'nullable' =&gt; false, 'default' =&gt; '0'],
        'Entity ID'
    )
    -&gt;addColumn(
        'value',
        \Magento\Framework\DB\Ddl\Table::TYPE_DECIMAL,
        '12,4',
        [],
        'Value'
    )
    //-&gt;addIndex
    //-&gt;addForeignKey
    -&gt;setComment('Employee Decimal Attribute Backend Table');
$setup-&gt;getConnection()-&gt;createTable($table);</pre></div><p class="calibre7">Notice<a id="id161" class="calibre1"/> the <code class="email">//-&gt;addIndex</code> part within code above. Lets replace it with the following bit.</p><div class="informalexample"><pre class="programlisting">-&gt;addIndex(
    $setup-&gt;getIdxName(
        $employeeEntity . '_entity_decimal',
        ['entity_id', 'attribute_id', 'store_id'],
        \Magento\Framework\DB\Adapter\AdapterInterface::INDEX_TYPE_UNIQUE
    ),
    ['entity_id', 'attribute_id', 'store_id'],
    ['type' =&gt; \Magento\Framework\DB\Adapter\AdapterInterface::INDEX_TYPE_UNIQUE]
)
-&gt;addIndex(
    $setup-&gt;getIdxName($employeeEntity . '_entity_decimal', ['store_id']),
    ['store_id']
)
-&gt;addIndex(
    $setup-&gt;getIdxName($employeeEntity . '_entity_decimal', ['attribute_id']),
    ['attribute_id']
)</pre></div><p class="calibre7">The preceding code adds three indexes on the <code class="email">foggyline_office_employee_entity_decimal</code> table, resulting in a SQL as follows:</p><div class="book"><ul class="itemizedlist"><li class="listitem"><code class="email">UNIQUE KEY 'FOGGYLINE_OFFICE_EMPLOYEE_ENTT_DEC_ENTT_ID_ATTR_ID_STORE_ID' ('entity_id','attribute_id','store_id')</code></li><li class="listitem"><code class="email">KEY 'FOGGYLINE_OFFICE_EMPLOYEE_ENTITY_DECIMAL_STORE_ID' ('store_id')</code></li><li class="listitem"><code class="email">KEY 'FOGGYLINE_OFFICE_EMPLOYEE_ENTITY_DECIMAL_ATTRIBUTE_ID' ('attribute_id')</code></li></ul></div><p class="calibre7">Similarly, we<a id="id162" class="calibre1"/> replace the <code class="email">//-&gt;addForeignKey</code> part from the preceding code with the following bit:</p><div class="informalexample"><pre class="programlisting">-&gt;addForeignKey(
    $setup-&gt;getFkName(
        $employeeEntity . '_entity_decimal',
        'attribute_id',
        'eav_attribute',
        'attribute_id'
    ),
    'attribute_id',
    $setup-&gt;getTable('eav_attribute'),
    'attribute_id',
    \Magento\Framework\DB\Ddl\Table::ACTION_CASCADE
)
-&gt;addForeignKey(
    $setup-&gt;getFkName(
        $employeeEntity . '_entity_decimal',
        'entity_id',
        $employeeEntity . '_entity',
        'entity_id'
    ),
    'entity_id',
    $setup-&gt;getTable($employeeEntity . '_entity'),
    'entity_id',
    \Magento\Framework\DB\Ddl\Table::ACTION_CASCADE
)
-&gt;addForeignKey(
    $setup-&gt;getFkName($employeeEntity . '_entity_decimal', 'store_id', 'store', 'store_id'),
    'store_id',
    $setup-&gt;getTable('store'),
    'store_id',
    \Magento\Framework\DB\Ddl\Table::ACTION_CASCADE
)</pre></div><p class="calibre7">The preceding code adds foreign key relations into the <code class="email">foggyline_office_employee_entity_decimal</code> table, resulting in a SQL as follows:</p><div class="book"><ul class="itemizedlist"><li class="listitem"><code class="email">CONSTRAINT 'FK_D17982EDA1846BAA1F40E30694993801' FOREIGN KEY ('entity_id') REFERENCES 'foggyline_office_employee_entity' ('entity_id') ON DELETE CASCADE,</code></li><li class="listitem"><code class="email">CONSTRAINT 'FOGGYLINE_OFFICE_EMPLOYEE_ENTITY_DECIMAL_STORE_ID_STORE_STORE_ID' FOREIGN KEY ('store_id') REFERENCES 'store' ('store_id') ON DELETE CASCADE,</code></li><li class="listitem"><code class="email">CONSTRAINT 'FOGGYLINE_OFFICE_EMPLOYEE_ENTT_DEC_ATTR_ID_EAV_ATTR_ATTR_ID' FOREIGN KEY ('attribute_id') REFERENCES 'eav_attribute' ('attribute_id') ON DELETE CASCADE</code></li></ul></div><p class="calibre7">Notice <a id="id163" class="calibre1"/>how we added the <code class="email">store_id</code> column to our EAV attribute value tables. Though our examples won't find use of it, it is a good practice to use <code class="email">store_id</code> with your EAV entities to scope the data for a possible multi-store setup. To clarify further, imagine we had a multi-store setup, and with EAV attribute tables set up like the preceding one, we would be able to store a different attribute value for each store, since the unique entry in the table is defined as a combination of <code class="email">entity_id</code>, <code class="email">attribute_id</code>, and <code class="email">store_id</code> columns.</p><div class="informalexample" title="Note"><h3 class="title2"><a id="tip05" class="calibre1"/>Tip</h3><p class="calibre7">For the reasons of performance and data integrity, it is important to define indexes and foreign key as per good database design practice. We can do so within <code class="email">InstallSchema</code> when defining new tables.</p></div></div>
<div class="book" title="Creating an upgrade schema script (UpgradeSchema.php)" id="TI1E1-818f5224668745eb9070ddf1d85e6bfa"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch04lvl1sec25" class="calibre1"/>Creating an upgrade schema script (UpgradeSchema.php)</h1></div></div></div><p class="calibre7">During <a id="id164" class="calibre1"/>the first-time module install, an upgrade schema is what gets run immediately after an install schema. We define upgrade schema within the <code class="email">app/code/Foggyline/Office/Setup/UpgradeSchema.php</code> file with (partial) content as follows:</p><div class="informalexample"><pre class="programlisting">namespace Foggyline\Office\Setup;

use Magento\Framework\Setup\UpgradeSchemaInterface;
use Magento\Framework\Setup\ModuleContextInterface;
use Magento\Framework\Setup\SchemaSetupInterface;

class UpgradeSchema implements UpgradeSchemaInterface
{
    public function upgrade(SchemaSetupInterface $setup, ModuleContextInterface $context)
    {
        $setup-&gt;startSetup();
          /* #snippet1 */
        $setup-&gt;endSetup();
    }
}</pre></div><p class="calibre7"><code class="email">UpgradeSchema</code> conforms to <code class="email">UpgradeSchemaInterface</code>, which requires the implementation <a id="id165" class="calibre1"/>of the <code class="email">upgrade</code> method that accepts two parameters of type <code class="email">SchemaSetupInterface</code> and <code class="email">ModuleContextInterface</code>.</p><p class="calibre7">This is quite similar to <code class="email">InstallSchemaInterface</code>, except the method name. The <code class="email">update</code> method is run when this schema gets triggered. Within this method, we would add any relevant code we might want to execute.</p><p class="calibre7">Going further, let's replace the <code class="email">/* #snippet1 */</code> part from the preceding code with the following code:</p><div class="informalexample"><pre class="programlisting">$employeeEntityTable = \Foggyline\Office\Model\Employee::ENTITY. '_entity';
$departmentEntityTable = 'foggyline_office_department';

$setup-&gt;getConnection()
    -&gt;addForeignKey(
        $setup-&gt;getFkName($employeeEntityTable, 'department_id', $departmentEntityTable, 'entity_id'),
        $setup-&gt;getTable($employeeEntityTable),
        'department_id',
        $setup-&gt;getTable($departmentEntityTable),
        'entity_id',
        \Magento\Framework\DB\Ddl\Table::ACTION_CASCADE
    );</pre></div><p class="calibre7">Here, we are instructing Magento to create a foreign key on the <code class="email">foggyline_office_employee_entity</code> table, more precisely on its <code class="email">department_id</code> column, pointing to the <code class="email">foggyline_office_department</code> table and its <code class="email">entity_id</code> column.</p></div>
<div class="book" title="Creating an install data script (InstallData.php)"><div class="book" id="UGI02-818f5224668745eb9070ddf1d85e6bfa"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch04lvl1sec26" class="calibre1"/>Creating an install data script (InstallData.php)</h1></div></div></div><p class="calibre7">An install <a id="id166" class="calibre1"/>data script is what gets run immediately after upgrade schema. We define install data schema within the <code class="email">app/code/Foggyline/Office/Setup/InstallData.php</code> file with (partial) content as follows:</p><div class="informalexample"><pre class="programlisting">namespace Foggyline\Office\Setup;

use Magento\Framework\Setup\InstallDataInterface;
use Magento\Framework\Setup\ModuleContextInterface;
use Magento\Framework\Setup\ModuleDataSetupInterface;

class InstallData implements InstallDataInterface
{
    private $employeeSetupFactory;

    public function __construct(
        \Foggyline\Office\Setup\EmployeeSetupFactory $employeeSetupFactory
    )
    {
        $this-&gt;employeeSetupFactory = $employeeSetupFactory;
    }

    public function install(ModuleDataSetupInterface $setup, ModuleContextInterface $context)
    {
        $setup-&gt;startSetup();
        /* #snippet1 */
        $setup-&gt;endSetup();
    }
}</pre></div><p class="calibre7"><code class="email">InstallData</code> conforms to <code class="email">InstallDataInterface</code>, which requires the implementation of the<a id="id167" class="calibre1"/> <code class="email">install</code> method that accepts two parameters of type <code class="email">ModuleDataSetupInterface</code> and <code class="email">ModuleContextInterface</code>.</p><p class="calibre7">The <code class="email">install</code> method is run when this script gets triggered. Within this method, we would add any relevant code we might want to execute.</p><p class="calibre7">Going further, let's replace the <code class="email">/* #snippet1 */</code> part from the preceding code with the following code:</p><div class="informalexample"><pre class="programlisting">$employeeEntity = \Foggyline\Office\Model\Employee::ENTITY;

$employeeSetup = $this-&gt;employeeSetupFactory-&gt;create(['setup' =&gt; $setup]);

$employeeSetup-&gt;installEntities();

$employeeSetup-&gt;addAttribute(
    $employeeEntity, 'service_years', ['type' =&gt; 'int']
);

$employeeSetup-&gt;addAttribute(
    $employeeEntity, 'dob', ['type' =&gt; 'datetime']
);

$employeeSetup-&gt;addAttribute(
    $employeeEntity, 'salary', ['type' =&gt; 'decimal']
);

$employeeSetup-&gt;addAttribute(
    $employeeEntity, 'vat_number', ['type' =&gt; 'varchar']
);

$employeeSetup-&gt;addAttribute(
    $employeeEntity, 'note', ['type' =&gt; 'text']
);</pre></div><p class="calibre7">Using <a id="id168" class="calibre1"/>the <code class="email">addAttribute</code> method on the instance of <code class="email">\Foggyline\Office\Setup\EmployeeSetupFactory</code>, we are instructing Magento to add a number of attributes (<code class="email">service_years</code>, <code class="email">dob</code>, <code class="email">salary</code>, <code class="email">vat_number</code>, <code class="email">note</code>) to its entity.</p><p class="calibre7">We will soon get to the inners of <code class="email">EmployeeSetupFactory</code>, but right now notice the call to the <code class="email">addAttribute</code> method. Within this method, there is a call to the <code class="email">$this-&gt;attributeMapper-&gt;map($attr, $entityTypeId)</code> method. <code class="email">attributeMapper</code> conforms to <code class="email">Magento\Eav\Model\Entity\Setup\PropertyMapperInterface</code>, which looking at <code class="email">vendor/magento/module-eav/etc/di.xml</code> has a preference for the <code class="email">Magento\Eav\Model\Entity\Setup\PropertyMapper\Composite</code> class, which further initializes the following mapper classes:</p><div class="book"><ul class="itemizedlist"><li class="listitem"><code class="email">Magento\Eav\Model\Entity\Setup\PropertyMapper</code></li><li class="listitem"><code class="email">Magento\Customer\Model\ResourceModel\Setup\PropertyMapper</code></li><li class="listitem"><code class="email">Magento\Catalog\Model\ResourceModel\Setup\PropertyMapper</code></li><li class="listitem"><code class="email">Magento\ConfigurableProduct\Model\ResourceModel\Setup\PropertyMapper</code></li></ul></div><p class="calibre7">Since we are defining our own entity types, the mapper class we are mostly interested in is <code class="email">Magento\Eav\Model\Entity\Setup\PropertyMapper</code>. A quick look inside of it reveals the following mapping array in the <code class="email">map</code> method:</p><div class="informalexample"><pre class="programlisting">[
    'backend_model' =&gt; 'backend',
    'backend_type' =&gt; 'type',
    'backend_table' =&gt; 'table',
    'frontend_model' =&gt; 'frontend',
    'frontend_input' =&gt; 'input',
    'frontend_label' =&gt; 'label',
    'frontend_class' =&gt; 'frontend_class',
    'source_model' =&gt; 'source',
    'is_required' =&gt; 'required',
    'is_user_defined' =&gt; 'user_defined',
    'default_value' =&gt; 'default',
    'is_unique' =&gt; 'unique',
    'note' =&gt; 'note'
    'is_global' =&gt; 'global'
]</pre></div><p class="calibre7">Looking<a id="id169" class="calibre1"/> at the preceding array keys and value strings gives us a clue as to what is happening. The key strings match the column names in the <code class="email">eav_attribute</code> table, while the value strings match the keys of our array passed to the <code class="email">addAttribute</code> method within <code class="email">InstallData.php</code>.</p><p class="calibre7">Let's take a look at the <code class="email">EmployeeSetupFactory</code> class within the <code class="email">app/code/Foggyline/Office/Setup/EmployeeSetup.php</code> file, (partially) defined as follows:</p><div class="informalexample"><pre class="programlisting">namespace Foggyline\Office\Setup;
use Magento\Eav\Setup\EavSetup;

class EmployeeSetup extends EavSetup
{
    public function getDefaultEntities()
    {
        /* #snippet1 */
    }
}</pre></div><p class="calibre7">What's happening here is that we are extending from the Magento\Eav\Setup\EavSetup class, thus effectively telling Magento we are about to create our own entity. We do so by overriding <code class="email">getDefaultEntities</code>, replacing <code class="email">/* #snippet1 */</code> with content as follows:</p><div class="informalexample"><pre class="programlisting">$employeeEntity = \Foggyline\Office\Model\Employee::ENTITY;
$entities = [
    $employeeEntity =&gt; [
        'entity_model' =&gt; 'Foggyline\Office\Model\ResourceModel\Employee',
        'table' =&gt; $employeeEntity . '_entity',
        'attributes' =&gt; [
            'department_id' =&gt; [
                'type' =&gt; 'static',
            ],
            'email' =&gt; [
                'type' =&gt; 'static',
            ],

            'first_name' =&gt; [
                'type' =&gt; 'static',
            ],
            'last_name' =&gt; [
                'type' =&gt; 'static',
            ],
        ],
    ],
];
return $entities;</pre></div><p class="calibre7">The <code class="email">getDefaultEntities</code> method returns an array of entities we want to register with Magento. Within <a id="id170" class="calibre1"/>our <code class="email">$entities</code> array, the key <code class="email">$employeeEntity</code> becomes an entry in the <code class="email">eav_entity_type</code> table. Given that our <code class="email">$employeeEntity</code> has a value of <code class="email">foggyline_office_employee</code>, running the following SQL query should yield a result:</p><div class="informalexample"><pre class="programlisting">SELECT * FROM eav_entity_type WHERE entity_type_code = "foggyline_office_employee";</pre></div><p class="calibre7">Only a handful of metadata values are required to make our new entity type functional. The <code class="email">entity_model</code> value should point to our EAV model <code class="email">resource</code> class, not the <code class="email">model</code> class. The table value should equal the name of our EAV entity table in the database. Finally, the attributes array should list any attribute we want created on this entity. Attributes and their metadata get created in the <code class="email">eav_attribute</code> table.</p><p class="calibre7">If we look back at all those <code class="email">foggyline_office_employee_entity_*</code> attribute value tables we created, they are not the ones that actually create attributes or register a new entity type in Magento. What creates attributes and a new entity type is the array we just defined under the <code class="email">getDefaultEntities</code> method. Once Magento creates the attributes and registers a new entity type, it simply routes the entity save process to proper attribute value tables depending on the type of attribute.</p></div>
<div class="book" title="Creating an upgrade data script (UpgradeData.php)" id="VF2I1-818f5224668745eb9070ddf1d85e6bfa"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch04lvl1sec27" class="calibre1"/>Creating an upgrade data script (UpgradeData.php)</h1></div></div></div><p class="calibre7">The <a id="id171" class="calibre1"/>upgrade data script is the last one to execute. We will use it to demonstrate the example of creating the sample entries for our <code class="email">Department</code> and <code class="email">Employee</code> entities.</p><p class="calibre7">We start by creating the <code class="email">app/code/Foggyline/Office/Setup/UpgradeData.php</code> file with (partial) content as follows:</p><div class="informalexample"><pre class="programlisting">namespace Foggyline\Office\Setup;

use Magento\Framework\Setup\UpgradeDataInterface;
use Magento\Framework\Setup\ModuleContextInterface;
use Magento\Framework\Setup\ModuleDataSetupInterface;

class UpgradeData implements UpgradeDataInterface
{
    protected $departmentFactory;
    protected $employeeFactory;

    public function __construct(
        \Foggyline\Office\Model\DepartmentFactory $departmentFactory,
        \Foggyline\Office\Model\EmployeeFactory $employeeFactory
    )
    {
        $this-&gt;departmentFactory = $departmentFactory;
        $this-&gt;employeeFactory = $employeeFactory;
    }

    public function upgrade(ModuleDataSetupInterface $setup, ModuleContextInterface $context)
    {
        $setup-&gt;startSetup();
        /* #snippet1 */
        $setup-&gt;endSetup();
    }
}</pre></div><p class="calibre7"><code class="email">UpgradeData</code> conforms to <code class="email">UpgradeDataInterface</code>, which requires the implementation of the <a id="id172" class="calibre1"/>upgrade method that accepts two parameters of type <code class="email">ModuleDataSetupInterface</code> and <code class="email">ModuleContextInterface</code>. We are further adding our own <code class="email">__construct</code> method to which we are passing <code class="email">DepartmentFactory</code> and <code class="email">EmployeeFactory</code>, as we will be using them within the upgrade method as shown next, by replacing <code class="email">/* #snippet1 */</code> with the following code:</p><div class="informalexample"><pre class="programlisting">$salesDepartment = $this-&gt;departmentFactory-&gt;create();
$salesDepartment-&gt;setName('Sales');
$salesDepartment-&gt;save();

$employee = $this-&gt;employeeFactory-&gt;create();
$employee-&gt;setDepartmentId($salesDepartment-&gt;getId());
$employee-&gt;setEmail('john@sales.loc');
$employee-&gt;setFirstName('John');
$employee-&gt;setLastName('Doe');
$employee-&gt;setServiceYears(3);
$employee-&gt;setDob('1983-03-28');
$employee-&gt;setSalary(3800.00);
$employee-&gt;setVatNumber('GB123456789');
$employee-&gt;setNote('Just some notes about John');
$employee-&gt;save();</pre></div><p class="calibre7">The <a id="id173" class="calibre1"/>preceding code creates an instance of the department entity and then saves it. An instance of employee is then created and saved, passing it the newly created department ID and other attributes.</p><div class="informalexample" title="Note"><h3 class="title2"><a id="tip06" class="calibre1"/>Tip</h3><p class="calibre7">A more convenient and professional-looking approach for saving an entity could be given as follows:</p><div class="informalexample"><pre class="programlisting">$employee-&gt;setDob('1983-03-28')
    -&gt;setSalary(3800.00)
    -&gt;setVatNumber('GB123456789')
    -&gt;save();</pre></div><p class="calibre7">Here, we are utilizing the fact that each of the entity setter methods returns <code class="email">$this</code> (an instance of the entity object itself), so we can chain the method calls.</p></div></div>
<div class="book" title="Entity CRUD actions" id="10DJ41-818f5224668745eb9070ddf1d85e6bfa"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch04lvl1sec28" class="calibre1"/>Entity CRUD actions</h1></div></div></div><p class="calibre7">Up to this <a id="id174" class="calibre1"/>point, we have learned how to create a simple model, an EAV model, and install and upgrade types of schema and data script. Now, let us see how we can create, read, update and delete our entities, operations that are commonly referred to as CRUD.</p><p class="calibre7">Though this chapter is about models, collections, and related things, for the purpose of demonstration, let's make a tiny detour into routes and controllers. The idea is to create a simple <code class="email">Test</code> controller with the <code class="email">Crud</code> action we can trigger in the browser via a URL. Within this <code class="email">Crud</code> action, we will then dump our CRUD-related code.</p><p class="calibre7">To make Magento respond to the URL we punch into the browser, we need to define the route. We do so by creating the <code class="email">app/code/Foggyline/Office/etc/frontend/routes.xml</code> file with the following content:</p><div class="informalexample"><pre class="programlisting">&lt;config  xsi:noNamespaceSchemaLocation="urn:magento:framework:App/ etc/routes.xsd"&gt;
    &lt;router id="standard"&gt;
        &lt;route id="foggyline_office" frontName="foggyline_office"&gt;
            &lt;module name="Foggyline_Office"/&gt;
        &lt;/route&gt;
    &lt;/router&gt;
&lt;/config&gt;</pre></div><p class="calibre7">Route definition requires a unique ID and <code class="email">frontName</code> attribute values, which in our case both equal <code class="email">foggyline_office</code>. The <code class="email">frontName</code> attribute value becomes the part of our URL structure. Simply <a id="id175" class="calibre1"/>put, the URL formula for hitting the <code class="email">Crud</code> action goes like <span class="strong"><em class="calibre9">{magento-base-url}/index.php/{route frontName}/{controller name}/{action name}</em></span>.</p><div class="informalexample" title="Note"><h3 class="title2"><a id="note11" class="calibre1"/>Note</h3><p class="calibre7">For example, if our base URL were <code class="email">http://shop.loc/</code>, the full URL would be <code class="email">http://shop.loc/index.php/foggyline_office/test/crud/</code>. If we have URL rewrites turned on, we could omit the <code class="email">index.php</code> part.</p></div><p class="calibre7">Once the <a id="id176" class="calibre1"/>route has been defined, we can go ahead and create the <code class="email">Test</code> controller, defined in the <code class="email">app/code/Foggyline/Office/Controller/Test.php</code> file with (partial) code as follows:</p><div class="informalexample"><pre class="programlisting">namespace Foggyline\Office\Controller;

abstract class Test extends \Magento\Framework\App\Action\Action
{
}</pre></div><p class="calibre7">This really is the simplest controller we could have defined. The only thing worth noting here is that the controller class needs to be defined as abstract and extend the <code class="email">\Magento\Framework\App\Action\Action</code> class. Controller actions live outside of the controller itself and can be found under the subdirectory on the same level and named as controller. Since our controller is called <code class="email">Test</code>, we place our <code class="email">Crud</code> action under the <code class="email">app/code/Foggyline/Office/Controller/Test/Crud.php</code> file with content as follows:</p><div class="informalexample"><pre class="programlisting">namespace Foggyline\Office\Controller\Test;

class Crud extends \Foggyline\Office\Controller\Test
{
    protected $employeeFactory;
    protected $departmentFactory;

    public function __construct(
        \Magento\Framework\App\Action\Context $context,
        \Foggyline\Office\Model\EmployeeFactory $employeeFactory,
        \Foggyline\Office\Model\DepartmentFactory $departmentFactory
    )
    {
        $this-&gt;employeeFactory = $employeeFactory;
        $this-&gt;departmentFactory = $departmentFactory;
        return parent::__construct($context);
    }

    public function execute()
    {
        /* CRUD Code Here */
    }
}</pre></div><p class="calibre7">The <a id="id177" class="calibre1"/>
<code class="email">Controller</code> action class is basically just an extension of the controller defining the <code class="email">execute</code> method. Code within the execute method is what gets run when we hit the URL in the browser. Additionally, we have a <code class="email">__construct</code> method to which we are passing the <code class="email">EmployeeFactory</code> and <code class="email">DepartmentFactory</code> classes, which we will soon use for our CRUD examples. Note that <code class="email">EmployeeFactory</code> and <code class="email">DepartmentFactory</code> are not classes created by us. Magento will autogenerate them under the <code class="email">DepartmentFactory.php</code> and <code class="email">EmployeeFactory.php</code> files within the <code class="email">var/generation/Foggyline/Office/Model</code> folder. These are factory classes for our <code class="email">Employee</code> and <code class="email">Department</code> model classes, generated when requested.</p><p class="calibre7">With this, we finish our little detour and focus back on our entities.</p></div>

<div id="page" style="height:0pt"/><div class="book" title="Creating new entities" id="11C3M1-818f5224668745eb9070ddf1d85e6bfa"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch04lvl1sec29" class="calibre1"/>Creating new entities</h1></div></div></div><p class="calibre7">There<a id="id178" class="calibre1"/> are three different flavors, if we might call them that, by which we can set property (field and attribute) values on our entity. They all lead to the same result. The following few code snippets can be copied and pasted into our <code class="email">Crud</code> class <code class="email">execute</code> method for testing, simply by replacing <code class="email">/* CRUD Code Here */</code> with one of the following code snippets:</p><div class="informalexample"><pre class="programlisting">//Simple model, creating new entities, flavour #1
$department1 = $this-&gt;departmentFactory-&gt;create();
$department1-&gt;setName('Finance');
$department1-&gt;save();
//Simple model, creating new entities, flavour #2
$department2 = $this-&gt;departmentFactory-&gt;create();
$department2-&gt;setData('name', 'Research');
$department2-&gt;save();
//Simple model, creating new entities, flavour #3
$department3 = $this-&gt;departmentFactory-&gt;create();
$department3-&gt;setData(['name' =&gt; 'Support']);
$department3-&gt;save();</pre></div><p class="calibre7">The <code class="email">flavour #1</code> approach from the preceding code is probably the preferred way of setting properties, as it is using the magic method approach we mentioned previously. Both <code class="email">flavour #2</code> and <code class="email">flavour #3</code> use the <code class="email">setData</code> method, just in a slightly different manner. All three examples should yield the same result once the <code class="email">save</code> method is called on an <a id="id179" class="calibre1"/>
<code class="email">object</code> instance.</p><p class="calibre7">Now that we know how to save the simple model, let's take a quick look at doing the same with the EAV model. The following are analogous code snippets:</p><div class="informalexample"><pre class="programlisting">//EAV model, creating new entities, flavour #1
$employee1 = $this-&gt;employeeFactory-&gt;create();
$employee1-&gt;setDepartment_id($department1-&gt;getId());
$employee1-&gt;setEmail('goran@mail.loc');
$employee1-&gt;setFirstName('Goran');
$employee1-&gt;setLastName('Gorvat');
$employee1-&gt;setServiceYears(3);
$employee1-&gt;setDob('1984-04-18');
$employee1-&gt;setSalary(3800.00);
$employee1-&gt;setVatNumber('GB123451234');
$employee1-&gt;setNote('Note #1');
$employee1-&gt;save();

//EAV model, creating new entities, flavour #2
$employee2 = $this-&gt;employeeFactory-&gt;create();
$employee2-&gt;setData('department_id', $department2-&gt;getId());
$employee2-&gt;setData('email', 'marko@mail.loc');
$employee2-&gt;setData('first_name', 'Marko');
$employee2-&gt;setData('last_name', 'Tunukovic');
$employee2-&gt;setData('service_years', 3);
$employee2-&gt;setData('dob', '1984-04-18');
$employee2-&gt;setData('salary', 3800.00);
$employee2-&gt;setData('vat_number', 'GB123451234');
$employee2-&gt;setData('note', 'Note #2');
$employee2-&gt;save();

//EAV model, creating new entities, flavour #3
$employee3 = $this-&gt;employeeFactory-&gt;create();
$employee3-&gt;setData([
    'department_id' =&gt; $department3-&gt;getId(),
    'email' =&gt; 'ivan@mail.loc',
    'first_name' =&gt; 'Ivan',
    'last_name' =&gt; 'Telebar',
    'service_years' =&gt; 2,
    'dob' =&gt; '1986-08-22',
    'salary' =&gt; 2400.00,
    'vat_number' =&gt; 'GB123454321',
    'note' =&gt; 'Note #3'
]);
$employee3-&gt;save();</pre></div><p class="calibre7">As we can see, the EAV code for persisting the data is identical to the simple model. There is<a id="id180" class="calibre1"/> one thing here worth noting. The <code class="email">Employee</code> entity has a relation defined toward department. Forgetting to specify <code class="email">department_id</code> on a new <code class="email">employee</code> entity save would result in an error message similar to the following:</p><div class="informalexample"><pre class="programlisting">SQLSTATE[23000]: Integrity constraint violation: 1452 Cannot add or update a child row: a foreign key constraint fails ('magento'.'foggyline_office_employee_entity', CONSTRAINT 'FK_E2AEE8BF21518DFA8F02B4E95DC9F5AD' FOREIGN KEY ('department_id') REFERENCES 'foggyline_office_department' ('entity_id') ON), query was: INSERT INTO 'foggyline_office_employee_entity' ('email', 'first_name', 'last_name', 'entity_id') VALUES (?, ?, ?, ?)</pre></div><p class="calibre7">Magento saves these types of errors under its <code class="email">var/report</code> directory.</p></div>

<div class="book" title="Creating new entities" id="11C3M1-818f5224668745eb9070ddf1d85e6bfa">
<div class="book" title="Reading existing entities"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_1"><a id="ch04lvl2sec17" class="calibre1"/>Reading existing entities</h2></div></div></div><p class="calibre7">Reading <a id="id181" class="calibre1"/>an entity based on a provided entity ID value comes down to instantiating the entity and using the load method to which we pass the entity ID as shown next:</p><div class="informalexample"><pre class="programlisting">//Simple model, reading existing entities
$department = $this-&gt;departmentFactory-&gt;create();
$department-&gt;load(28);

/*
    \Zend_Debug::dump($department-&gt;toArray());

    array(2) {
      ["entity_id"] =&gt; string(2) "28"
      ["name"] =&gt; string(8) "Research"
    }
 */</pre></div><p class="calibre7">There is no real difference between loading the simple model or EAV model, as shown in the following EAV model example:</p><div class="informalexample"><pre class="programlisting">//EAV model, reading existing entities
$employee = $this-&gt;employeeFactory-&gt;create();
$employee-&gt;load(25);

/*
    \Zend_Debug::dump($employee-&gt;toArray());

    array(10) {
      ["entity_id"] =&gt; string(2) "25"
      ["department_id"] =&gt; string(2) "28"
      ["email"] =&gt; string(14) "marko@mail.loc"
      ["first_name"] =&gt; string(5) "Marko"
      ["last_name"] =&gt; string(9) "Tunukovic"
      ["dob"] =&gt; string(19) "1984-04-18 00:00:00"
      ["note"] =&gt; string(7) "Note #2"
      ["salary"] =&gt; string(9) "3800.0000"
      ["service_years"] =&gt; string(1) "3"
      ["vat_number"] =&gt; string(11) "GB123451234"
    }
 */</pre></div><p class="calibre7">Notice<a id="id182" class="calibre1"/> how the EAV entity loads all of its field and attribute values, which is not always the case when we obtain the entity through EAV collection, as we will show later on.</p></div></div>

<div class="book" title="Creating new entities" id="11C3M1-818f5224668745eb9070ddf1d85e6bfa">
<div class="book" title="Updating existing entities"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_2"><a id="ch04lvl2sec18" class="calibre1"/>Updating existing entities</h2></div></div></div><p class="calibre7">Updating <a id="id183" class="calibre1"/>entities comes down to using the <code class="email">load</code> method to read an existing entity, reset its value, and calling the <code class="email">save</code> method in the end, like shown in the following example:</p><div class="informalexample"><pre class="programlisting">$department = $this-&gt;departmentFactory-&gt;create();
$department-&gt;load(28);
$department-&gt;setName('Finance #2');
$department-&gt;save();</pre></div><p class="calibre7">Regardless of the entity being the simple model or an EAV, the code is the same.</p></div></div>

<div class="book" title="Creating new entities" id="11C3M1-818f5224668745eb9070ddf1d85e6bfa">
<div class="book" title="Deleting existing entities"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_3"><a id="ch04lvl2sec19" class="calibre1"/>Deleting existing entities</h2></div></div></div><p class="calibre7">Calling<a id="id184" class="calibre1"/> the <code class="email">delete</code> method on a loaded entity will delete the entity from the database or throw <code class="email">Exception</code> if it fails. Code to delete the entity looks as follows:</p><div class="informalexample"><pre class="programlisting">$employee = $this-&gt;employeeFactory-&gt;create();
$employee-&gt;load(25);
$employee-&gt;delete();</pre></div><p class="calibre7">There is no difference in deleting the simple and EAV entities. We should always use try/catch blocks when deleting or saving our entities.</p></div></div>

<div id="page" style="height:0pt"/><div class="book" title="Managing collections"><div class="book" id="12AK82-818f5224668745eb9070ddf1d85e6bfa"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch04lvl1sec30" class="calibre1"/>Managing collections</h1></div></div></div><p class="calibre7">Let's start <a id="id185" class="calibre1"/>with EAV model collections. We can instantiate the collection either through the entity <code class="email">factory</code> class like follows:</p><div class="informalexample"><pre class="programlisting">$collection = $this-&gt;employeeFactory-&gt;create()
                   -&gt;getCollection();</pre></div><p class="calibre7">Or we can use object manager to instantiate the collection as shown next:</p><div class="informalexample"><pre class="programlisting">$collection = $this-&gt;_objectManager-&gt;create(
    'Foggyline\Office\Model\ResourceModel\Employee\Collection's
);</pre></div><p class="calibre7">There is also a third way, which might be the preferred one, but it requires us to define APIs so we will skip that one for the moment.</p><p class="calibre7">Once we instantiate the collection object, we can loop through it and do some variable dumps to see the content on individual <code class="email">$employee</code> entities, like shown next:</p><div class="informalexample"><pre class="programlisting">foreach ($collection as $employee) {
    \Zend_Debug::dump($employee-&gt;toArray(), '$employee');
}</pre></div><p class="calibre7">The preceding would yield results like the following:</p><div class="informalexample"><pre class="programlisting">$employee array(5) {
  ["entity_id"] =&gt; string(2) "24"
  ["department_id"] =&gt; string(2) "27"
  ["email"] =&gt; string(14) "goran@mail.loc"
  ["first_name"] =&gt; string(5) "Goran"
  ["last_name"] =&gt; string(6) "Gorvat"
}</pre></div><p class="calibre7">Notice how the individual <code class="email">$employee</code> only has fields on it, not the attributes. Let's see what happens when we want to extend our collection by using <code class="email">addAttributeToSelect</code> to specify the individual attributes to add to it, like shown next:</p><div class="informalexample"><pre class="programlisting">$collection-&gt;addAttributeToSelect('salary')
           -&gt;addAttributeToSelect('vat_number');</pre></div><p class="calibre7">The preceding would yield results like the following:</p><div class="informalexample"><pre class="programlisting">$employee array(7) {
  ["entity_id"] =&gt; string(2) "24"
  ["department_id"] =&gt; string(2) "27"
  ["email"] =&gt; string(14) "goran@mail.loc"
  ["first_name"] =&gt; string(5) "Goran"
  ["last_name"] =&gt; string(6) "Gorvat"
  ["salary"] =&gt; string(9) "3800.0000"
  ["vat_number"] =&gt; string(11) "GB123451234"
}</pre></div><p class="calibre7">Though we are making progress, imagine if we had tens of attributes, and we want each and every one to be included into collection. Using <code class="email">addAttributeToSelect</code> numerous times would <a id="id186" class="calibre1"/>make for cluttered code. What we can do is pass <code class="email">'*'</code> as a parameter to <code class="email">addAttributeToSelect</code> and have collection pick up every attribute, as shown next:</p><div class="informalexample"><pre class="programlisting">$collection-&gt;addAttributeToSelect('*');</pre></div><p class="calibre7">This would yield results like the following:</p><div class="informalexample"><pre class="programlisting">$employee array(10) {
    ["entity_id"] =&gt; string(2) "24"
    ["department_id"] =&gt; string(2) "27"
    ["email"] =&gt; string(14) "goran@mail.loc"
    ["first_name"] =&gt; string(5) "Goran"
    ["last_name"] =&gt; string(6) "Gorvat"
    ["dob"] =&gt; string(19) "1984-04-18 00:00:00"
    ["note"] =&gt; string(7) "Note #1"
    ["salary"] =&gt; string(9) "3800.0000"
    ["service_years"] =&gt; string(1) "3"
    ["vat_number"] =&gt; string(11) "GB123451234"
}</pre></div><p class="calibre7">Though the PHP part of the code looks seemingly simple, what's happening in the background on the SQL layer is relatively complex. Though Magento executes several SQL queries prior to fetching the final collection result, let's focus on the last three queries as shown next:</p><div class="informalexample"><pre class="programlisting">SELECT COUNT(*) FROM 'foggyline_office_employee_entity' AS 'e'

SELECT 'e'.* FROM 'foggyline_office_employee_entity' AS 'e'

SELECT
  'foggyline_office_employee_entity_datetime'.'entity_id',
  'foggyline_office_employee_entity_datetime'.'attribute_id',
  'foggyline_office_employee_entity_datetime'.'value'
FROM 'foggyline_office_employee_entity_datetime'
WHERE (entity_id IN (24, 25, 26)) AND (attribute_id IN ('349'))
UNION ALL SELECT
            'foggyline_office_employee_entity_text'.'entity_id',
            'foggyline_office_employee_entity_text'.' attribute_id',
            'foggyline_office_employee_entity_text'.'value'
          FROM 'foggyline_office_employee_entity_text'
          WHERE (entity_id IN (24, 25, 26)) AND (attribute_id IN ('352'))
UNION ALL SELECT
            'foggyline_office_employee_entity_decimal'.' entity_id',
            'foggyline_office_employee_entity_decimal'.' attribute_id',
            'foggyline_office_employee_entity_decimal'.'value'
          FROM 'foggyline_office_employee_entity_decimal'
          WHERE (entity_id IN (24, 25, 26)) AND (attribute_id IN ('350'))
UNION ALL SELECT
            'foggyline_office_employee_entity_int'.'entity_id',
            'foggyline_office_employee_entity_int'.'attribute_id',
            'foggyline_office_employee_entity_int'.'value'
          FROM 'foggyline_office_employee_entity_int'
          WHERE (entity_id IN (24, 25, 26)) AND (attribute_id IN ('348'))
UNION ALL SELECT
            'foggyline_office_employee_entity_varchar'.' entity_id',
            'foggyline_office_employee_entity_varchar'.' attribute_id',
            'foggyline_office_employee_entity_varchar'.'value'
          FROM 'foggyline_office_employee_entity_varchar'
          WHERE (entity_id IN (24, 25, 26)) AND (attribute_id IN ('351'))</pre></div><div class="informalexample" title="Note"><h3 class="title2"><a id="note12" class="calibre1"/>Note</h3><p class="calibre7">Before we proceed any further, it is important to know that these queries are not copy and paste applicable. The reason is that the <code class="email">attribute_id</code> values will for sure differ from installation to installation. Queries given here are for us to gain a high-level understanding of what is happening in the backend on the SQL layer when we use Magento collections on the PHP application level.</p></div><p class="calibre7">The first<a id="id187" class="calibre1"/> query select simply counts the number of entries in the entity table, and then passes that info to the application layer. The second select fetches all entries from <code class="email">foggyline_office_employee_entity</code>, then passes that info to the application layer to use it to pass entity IDs in the third query as part of <code class="email">entity_id IN (24, 25, 26)</code>. Second and third queries here can be pretty resource intense if we have a large amount of entries in our entity and EAV tables. To prevent possible performance bottlenecks, we should always use the <code class="email">setPageSize</code> and <code class="email">setCurPage</code> methods on collection, like shown next:</p><div class="informalexample"><pre class="programlisting">$collection-&gt;addAttributeToSelect('*')
           -&gt;setPageSize(25)
           -&gt;setCurPage(5);</pre></div><p class="calibre7">This would result in the first <code class="email">COUNT</code> query still being the same, but the second query would now look like the following:</p><div class="informalexample"><pre class="programlisting">SELECT 'e'.* FROM 'foggyline_office_employee_entity' AS 'e' LIMIT 25 OFFSET 4</pre></div><p class="calibre7">This makes<a id="id188" class="calibre1"/> for a much smaller, thus performance-lighter dataset if we have thousands or tens of thousands of entries. The point here is to always use <code class="email">setPageSize</code> and <code class="email">setCurPage</code>. If we need to work with a really large set, then we need to page through it, or walk through it.</p><p class="calibre7">Now we know how to limit the size of the result set and fetch the proper page, let's see how we can further filter the set to avoid overusing PHP loops for the same purpose. Thus effectively passing the filtering to the database and not the application layer. To filter the EAV collection, we use its <code class="email">addAttributeToFilter</code> method.</p><p class="calibre7">Let's instantiate a clean new collection like shown next:</p><div class="informalexample"><pre class="programlisting">$collection = $this-&gt;_objectManager-&gt;create(
    'Foggyline\Office\Model\ResourceModel\Employee\Collection'
);

$collection-&gt;addAttributeToSelect('*')
           -&gt;setPageSize(25)
           -&gt;setCurPage(1);

$collection-&gt;addAttributeToFilter('email', array('like'=&gt;'%mail.loc%'))
           -&gt;addAttributeToFilter('vat_number', array('like'=&gt;'GB%'))
           -&gt;addAttributeToFilter('salary', array('gt'=&gt;2400))
           -&gt;addAttributeToFilter('service_years', array('lt'=&gt;10));</pre></div><p class="calibre7">Notice that we are now using the <code class="email">addAttributeToSelect</code> and <code class="email">addAttributeToFilter</code> methods on collection. We have already seen the database impact of <code class="email">addAttributeToSelect</code> on a SQL query. What <code class="email">addAttributeToFilter</code> does is something completely different.</p><p class="calibre7">With the <code class="email">addAttributeToFilter</code> method, the count query now gets transformed into the following SQL query:</p><div class="informalexample"><pre class="programlisting">SELECT COUNT(*)
FROM 'foggyline_office_employee_entity' AS 'e'
  INNER JOIN 'foggyline_office_employee_entity_varchar' AS 'at_vat_number'
    ON ('at_vat_number'.'entity_id' = 'e'.'entity_id') AND ('at_vat_number'.'attribute_id' = '351')
  INNER JOIN 'foggyline_office_employee_entity_decimal' AS 'at_salary'
    ON ('at_salary'.'entity_id' = 'e'.'entity_id') AND ('at_salary'.'attribute_id' = '350')
  INNER JOIN 'foggyline_office_employee_entity_int' AS 'at_service_years'
    ON ('at_service_years'.'entity_id' = 'e'.'entity_id') AND ('at_service_years'.'attribute_id' = '348')
WHERE ('e'.'email' LIKE '%mail.loc%') AND (at_vat_number.value LIKE 'GB%') AND (at_salary.value &gt; 2400) AND
      (at_service_years.value &lt; 10)</pre></div><p class="calibre7">We can <a id="id189" class="calibre1"/>see that this is much more complex than the previous count query, now we have <code class="email">INNER JOIN</code> stepping in. Notice how we have four <code class="email">addAttributeToFilter</code> method calls but only three <code class="email">INNER JOIN</code>. This is because one of those four calls is for e-mail, which is not an attribute but a field within the <code class="email">foggyline_office_employee_entity</code> table. That is why there is no need for <code class="email">INNER JOIN</code> as the field is already there. The three <code class="email">INNER JOIN</code> then simply merge the required info into the query in order to get the select.</p><p class="calibre7">The second query also becomes more robust, as shown next:</p><div class="informalexample"><pre class="programlisting">SELECT
  'e'.*,
  'at_vat_number'.'value'    AS 'vat_number',
  'at_salary'.'value'        AS 'salary',
  'at_service_years'.'value' AS 'service_years'
FROM 'foggyline_office_employee_entity' AS 'e'
  INNER JOIN 'foggyline_office_employee_entity_varchar' AS 'at_vat_number'
    ON ('at_vat_number'.'entity_id' = 'e'.'entity_id') AND ('at_vat_number'.'attribute_id' = '351')
  INNER JOIN 'foggyline_office_employee_entity_decimal' AS 'at_salary'
    ON ('at_salary'.'entity_id' = 'e'.'entity_id') AND ('at_salary'.'attribute_id' = '350')
  INNER JOIN 'foggyline_office_employee_entity_int' AS 'at_service_years'
    ON ('at_service_years'.'entity_id' = 'e'.'entity_id') AND ('at_service_years'.'attribute_id' = '348')
WHERE ('e'.'email' LIKE '%mail.loc%') AND (at_vat_number.value LIKE 'GB%') AND (at_salary.value &gt; 2400) AND
      (at_service_years.value &lt; 10)
LIMIT 25</pre></div><p class="calibre7">Here, we also see the usage of <code class="email">INNER JOIN</code>. We also have three and not four <code class="email">INNER JOIN</code>, because one of the conditions is done against <code class="email">email</code>, which is a field. The result of the query is a flattened piece of rows where the attributes <code class="email">vat_number</code>, <code class="email">salary</code>, and <code class="email">service_years</code> are present. We can imagine the performance impact if we haven't used <code class="email">setPageSize</code> to limit the result set.</p><p class="calibre7">Finally, the third query is also affected and now looks similar to the following:</p><div class="informalexample"><pre class="programlisting">SELECT
  'foggyline_office_employee_entity_datetime'.'entity_id',
  'foggyline_office_employee_entity_datetime'.'attribute_id',
  'foggyline_office_employee_entity_datetime'.'value'
FROM 'foggyline_office_employee_entity_datetime'
WHERE (entity_id IN (24, 25)) AND (attribute_id IN ('349'))
UNION ALL SELECT
            'foggyline_office_employee_entity_text'.'entity_id',
            'foggyline_office_employee_entity_text'.' attribute_id',
            'foggyline_office_employee_entity_text'.'value'
          FROM 'foggyline_office_employee_entity_text'
          WHERE (entity_id IN (24, 25)) AND (attribute_id IN ('352'))</pre></div><p class="calibre7">Notice<a id="id190" class="calibre1"/> here how <code class="email">UNION ALL</code> has been reduced to a single occurrence now, thus effectively making for two selects. This is because we have a total of five attributes (<code class="email">service_years</code>, <code class="email">dob</code>, <code class="email">salary</code>, <code class="email">vat_number</code>, <code class="email">note</code>), and three of them have been pulled in through second query. Out of the preceding three queries demonstrated, Magento basically pulls the collection data from second and third query. This seems like a pretty optimized and scalable solution, though we should really give it some thought on the proper use of <code class="email">setPageSize</code>, <code class="email">addAttributeToSelect</code>, and <code class="email">addAttributeToFilter</code> methods when creating collection.</p><p class="calibre7">During development, if working with collections that have lot of attributes, filters, and possibly a future large dataset, we might want to use SQL logging to record actual SQL queries hitting the database server. This might help us spot possible performance bottlenecks and react on time, either by adding more limiting values to <code class="email">setPageSize</code> or <code class="email">addAttributeToSelect</code>, or both.</p><p class="calibre7">In the preceding examples, the use of <code class="email">addAttributeToSelect</code> results in <code class="email">AND</code> conditions on the SQL layer. What if we want to filter collection using <code class="email">OR</code> conditions? <code class="email">addAttributeToSelect</code> can also result in SQL <code class="email">OR</code> conditions if the <code class="email">$attribute</code> parameter is used in the following way:</p><div class="informalexample"><pre class="programlisting">$collection-&gt;addAttributeToFilter([
    ['attribute'=&gt;'salary', 'gt'=&gt;2400],
    ['attribute'=&gt;'vat_number', 'like'=&gt;'GB%']
]);</pre></div><p class="calibre7">Without going into the details of actual SQL queries this time, it is suffice to say that they are near identical to the previous example with the <code class="email">AND</code> condition use of <code class="email">addAttributeToFilter</code>.</p><p class="calibre7">Using collection methods like <code class="email">addExpressionAttributeToSelect</code>, <code class="email">groupByAttribute</code>, and <code class="email">addAttributeToSort</code>, collections offer further gradient filtering and even shift some calculations from the PHP application layer to the SQL layer. Getting into the ins and outs of those and other collection methods is beyond the scope of this <a id="id191" class="calibre1"/>chapter, and would probably require a book on its own.</p></div>

<div class="book" title="Managing collections">
<div class="book" title="Collection filters"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_1"><a id="ch04lvl2sec20" class="calibre1"/>Collection filters</h2></div></div></div><p class="calibre7">Looking<a id="id192" class="calibre1"/> back at the preceding <code class="email">addAttributeToFilter</code> method call examples, questions pop out as to where can we see the list of all available collection filters. If we take a quick look inside the <code class="email">vendor/magento/framework/DB/Adapter/Pdo/Mysql.php</code> file, we can see the method called <code class="email">prepareSqlCondition</code> (partially) defined as follows:</p><div class="informalexample"><pre class="programlisting">public function prepareSqlCondition($fieldName, $condition)
{
    $conditionKeyMap = [
        'eq'            =&gt; "{{fieldName}} = ?",
        'neq'           =&gt; "{{fieldName}} != ?",
        'like'          =&gt; "{{fieldName}} LIKE ?",
        'nlike'         =&gt; "{{fieldName}} NOT LIKE ?",
        'in'            =&gt; "{{fieldName}} IN(?)",
        'nin'           =&gt; "{{fieldName}} NOT IN(?)",
        'is'            =&gt; "{{fieldName}} IS ?",
        'notnull'       =&gt; "{{fieldName}} IS NOT NULL",
        'null'          =&gt; "{{fieldName}} IS NULL",
        'gt'            =&gt; "{{fieldName}} &gt; ?",
        'lt'            =&gt; "{{fieldName}} /* AJZELE */ &lt; ?",
        'gteq'          =&gt; "{{fieldName}} &gt;= ?",
        'lteq'          =&gt; "{{fieldName}} &lt;= ?",
        'finset'        =&gt; "FIND_IN_SET(?, {{fieldName}})",
        'regexp'        =&gt; "{{fieldName}} REGEXP ?",
        'from'          =&gt; "{{fieldName}} &gt;= ?",
        'to'            =&gt; "{{fieldName}} &lt;= ?",
        'seq'           =&gt; null,
        'sneq'          =&gt; null,
        'ntoa'          =&gt; "INET_NTOA({{fieldName}}) LIKE ?",
    ];

    $query = '';
    if (is_array($condition)) {
        $key = key(array_intersect_key($condition, $conditionKeyMap));

    ...
}</pre></div><p class="calibre7">This method is what eventually gets called at some point during SQL query construction. The <code class="email">$condition</code> <a id="id193" class="calibre1"/>parameter is expected to have one of the following (partially listed) forms:</p><div class="book"><ul class="itemizedlist"><li class="listitem"><code class="email">array("from" =&gt; $fromValue, "to" =&gt; $toValue)</code></li><li class="listitem"><code class="email">array("eq" =&gt; $equalValue)</code></li><li class="listitem"><code class="email">array("neq" =&gt; $notEqualValue)</code></li><li class="listitem"><code class="email">array("like" =&gt; $likeValue)</code></li><li class="listitem"><code class="email">array("in" =&gt; array($inValues))</code></li><li class="listitem"><code class="email">array("nin" =&gt; array($notInValues))</code></li><li class="listitem"><code class="email">array("notnull" =&gt; $valueIsNotNull)</code></li><li class="listitem"><code class="email">array("null" =&gt; $valueIsNull)</code></li><li class="listitem"><code class="email">array("gt" =&gt; $greaterValue)</code></li><li class="listitem"><code class="email">array("lt" =&gt; $lessValue)</code></li><li class="listitem"><code class="email">array("gteq" =&gt; $greaterOrEqualValue)</code></li><li class="listitem"><code class="email">array("lteq" =&gt; $lessOrEqualValue)</code></li><li class="listitem"><code class="email">array("finset" =&gt; $valueInSet)</code></li><li class="listitem"><code class="email">array("regexp" =&gt; $regularExpression)</code></li><li class="listitem"><code class="email">array("seq" =&gt; $stringValue)</code></li><li class="listitem"><code class="email">array("sneq" =&gt; $stringValue)</code></li></ul></div><p class="calibre7">If <code class="email">$condition</code> is passed as an integer or string, then the exact value will be filtered (<code class="email">'eq'</code> condition). If none of the conditions is matched, then a sequential array is expected as a parameter and <code class="email">OR</code> conditions will be built using the preceding structure.</p><p class="calibre7">The preceding examples covered EAV model collections, as they are slightly more complex. Though the approach to filtering more or less applies to simple model collections as well, the most notable difference is that there are no <code class="email">addAttributeToFilter</code>, <code class="email">addAttributeToSelect</code>, and <code class="email">addExpressionAttributeToSelect</code> methods. The simple model collections make use of <code class="email">addFieldToFilter</code>, <code class="email">addFieldToSelect</code>, and <code class="email">addExpressionFieldToSelect</code>, among other subtle differences.</p></div></div>
<div class="book" title="Summary" id="1394Q1-818f5224668745eb9070ddf1d85e6bfa"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch04lvl1sec31" class="calibre1"/>Summary</h1></div></div></div><p class="calibre7">In this chapter, we first learned how to create simple model, its resource, and collection class. Then we did the same for an EAV model. Once we had the required model, resource, and collection classes in place, we took a detailed look at the type and flow of schema and data scripts. Going hands-on, we covered <code class="email">InstallSchema</code>, <code class="email">UpgradeSchema</code>, <code class="email">InstallData</code>, and <code class="email">UpgradeData</code> scripts. Once the scripts were run, the database ended up having the required tables and sample data upon which we based our entity CRUD examples. Finally, we took a quick but focused look at collection management, mostly comprising filtering collection to get the desired result set.</p><p class="calibre7">The full module code can be downloaded from <a class="calibre1" href="https://github.com/ajzele/B05032-Foggyline_Office">https://github.com/ajzele/B05032-Foggyline_Office</a>.</p></div></body></html>