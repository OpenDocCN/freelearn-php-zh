- en: Chapter 2. PHP Development
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Creating a PHP project using Composer
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating an empty project
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Reusing an existing project
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a new PHP class
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a new PHP method
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding the getter/setter methods
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating delegate methods
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Surrounding code with control structures
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Finding the matching brace
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Commenting out a section of code and PHPDoc
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a working set
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating TODO tasks
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that you have your headlights turned on, you can have that "come what may"
    attitude and set out to drive your favorite car—PHP. Go ahead and give it your
    best shot now that you have your beloved tool ready—PhpStorm. PhpStorm will take
    care of eliminating the distractions from your life and will let you concentrate
    on programming.
  prefs: []
  type: TYPE_NORMAL
- en: You can think of any aspect in solving a problem using PHP, and PhpStorm will
    be there to assist you.
  prefs: []
  type: TYPE_NORMAL
- en: Do you have an imminent problem to solve, some problem that appears daunting
    to you, or some problem that has challenged your existence as a software engineer?
    If you stick to the software engineering principles, PhpStorm will leverage your
    capacity and let you do wonders while solving the problems at hand. PhpStorm lets
    you focus on designing your business logic by offloading you from the worries
    of remembering the finer details, such as the exact method signature and the list
    of parameters.
  prefs: []
  type: TYPE_NORMAL
- en: Imagine that you have been called by your manager to discuss some new feature
    for the business that has to be developed in, as usual, no time at all. You are
    again in a fix. That decision to choose between the devil and the deep blue sea
    again looms large.
  prefs: []
  type: TYPE_NORMAL
- en: PhpStorm users need not worry. They have a third option—to board a helicopter
    and reach their destination from the current scenario.
  prefs: []
  type: TYPE_NORMAL
- en: You were brave enough to gather the requirements from the business end. Which
    way do you chose now? Decide whether you want to go right or left. If you go to
    the right, you will take the route to create a new project. If you go to the left,
    you will take the route to reuse an existing project and make modifications in
    it.
  prefs: []
  type: TYPE_NORMAL
- en: Wherever you go and whichever road you take, you have to reach the same destination.
    In the end, you have to report to your manager what you did to achieve the target.
    Not only do you have to decide quickly, but you also have to act swiftly.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a PHP project using Composer
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Welcome to those who have taken the route to the right! Fasten your seatbelts,
    and get ready to create a new project in PHP.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Creating a new project in itself is a very mature decision, so you should always
    decide maturely and strategically. There might be situations in which, out of
    sheer enthusiasm, you opted to create a new project, and within a few days, you
    realize that much of the functionality you are planning to create has already
    been developed. You will end up doing a lot of copy-pasting work.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The principles of software engineering always teach students that a design should
    be high on coupling and low on cohesion. This means that an application program
    should use other programs but not depend on it. Composer in PHP is a system that
    helps you to adopt this methodology. Composer is a dependency manager for PHP,
    which allows other packages written in PHP to be included in other projects.
  prefs: []
  type: TYPE_NORMAL
- en: 'PhpStorm enables you to create projects that adhere to this principle. To create
    a new Composer project, you need to select the **Composer Project** option in
    the dropdown provided from the **File** | **New Project** menu item. The next
    question asked of you is to select the path of `composer.phar`—from the local
    disk or from the website: [http://www.getcomposer.org](http://www.getcomposer.org)'
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Don''t scratch your head out of utter confusion—more knowledge surely means
    more confusion, but that never means you should target zero knowledge to have
    no confusion at all! An executable, `composer.phar`, causes this magic of handling
    the packages to occur. You must be thinking what exactly is it inside Composer
    that makes it such a buzzword these days—everyone seems to be talking about it.
    Perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Go to [https://getcomposer.org/download/](https://getcomposer.org/download/),
    and you will see that there is the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: If you have already installed composer prior to coming to cook with PhpStorm,
    you should specify `/path/to/composer.phar`, the path to where composer has been
    installed.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You can then select from the list of available packages in the left-hand side
    panel. On the right, you can see the corresponding description of the package
    selected. You can select the version of the package to be installed, and then
    click on **OK**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Downloading the example code**'
  prefs: []
  type: TYPE_NORMAL
- en: You can download the example code files for all Packt books you have purchased
    from your account at [http://www.packtpub.com](http://www.packtpub.com). If you
    purchased this book elsewhere, you can visit [http://www.packtpub.com/support](http://www.packtpub.com/support)
    and register to have the files e-mailed directly to you.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The command is actually a concatenation of two commands that get the contents
    of the installer script and execute that via the PHP command line. If you happen
    to open the specified link inside a web browser, you will see the entire PHP code
    behind Composer. Are you able to breathe freely (pun intended)? Back to work,
    the intention of the second part of the command is to execute the PHP content
    via the PHP command line.
  prefs: []
  type: TYPE_NORMAL
- en: 'Backtracking to the original topic, you were trying to select the right type
    of `composer.phar`. Have a look at the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How it works...](img/3878OT_02_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: PhpStorm takes care of the remaining tasks in installing *your-selected-package*.
  prefs: []
  type: TYPE_NORMAL
- en: 'The Composer system generates a `json` file with the name `composer.json`,
    which contains the details about the requirements. The following is the `composer.json`
    file for a project that has been created from scratch:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'It is quite apparent that the json file conveys a lot of information to the
    reader. `"name":` is the name of the package downloaded. `"description":` is the
    description of the package downloaded. If you have a good memory, you will remember
    that there was a description in the right-hand panel of the package selection
    window. This description is exactly the same. `"require":` is the name of the
    packages that this downloaded package depends upon. The json file specifies the
    name of the project as the key and the corresponding version number as the value.
    `"authors":` is the author of the downloaded package. It includes the name and
    e-mail address of the author. `"autoload":` is the coding standard, any of PSR-0,
    PSR-1, PSR-2, PSR-3, PSR-4, and the namespace mapping to the actual directory.
    The hierarchy goes like this: the coding-standard contains the value of the namespace
    mapping. Namespace mapping means the name as the key and the directory (relative
    to the project root) as the value.'
  prefs: []
  type: TYPE_NORMAL
- en: 'PhpStorm and the Composer combination work wonders. When you order PhpStorm
    to download and arrange the packages, it will automatically arrange for you the
    include paths for the projects. No more warnings or errors relating to missing
    files will present a hindrance to your work now. Consider the following sreenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How it works...](img/3878OT_02_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Suppose you have already added a few packages in your project and you now realize
    that you need to have more of the packages. Not to worry says PhpStorm, as it
    provides you an option to add more packages in the form of **Add dependency**.
    Doing this is extremely easy. In the open project, you need to go to **Tools**
    | **Composer** | **Add dependency**. There will be a familiar pop up that will
    ask you to select a package name and proceed to install. The remainder of the
    tasks will, as usual, be taken care of by PhpStorm. The result you will see will
    be in the form of some downloaded files and folders besides a change in your `composer.json`
    file for this particular project. One such `composer.json` file is as shown in
    the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The symbols have the usual meaning. The external dependencies have been added
    to the list according to the `json` notation and are denoted by the single key
    required, where the value is the actual list of the dependencies having the key
    as their name and the corresponding versions as the value.
  prefs: []
  type: TYPE_NORMAL
- en: Creating an empty project
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The feeling that you get when you find some support in times of trouble can
    be said to have an analogy with that feeling of finding cold water to drink in
    times of thirst. This statement's analogy with the current scenario is that until
    this point in time, you were unable to find the exact project type to create,
    but now you have found a way out.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You need to create an empty PHP project when you are convinced enough to need
    to create a new project and achieve a new feat by fulfilling your manager's business
    demand.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A new empty project is the easiest to create:'
  prefs: []
  type: TYPE_NORMAL
- en: You need to specify a name for your new project. Don't worry even if there are
    spelling mistakes in the name itself because PhpStorm doesn't check the name you
    specify against the dictionary.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A project name should only contain valid characters that a directory name should
    contain under an operating system.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Creating an empty project is easy to understand. You need to specify the `/path/to/files/and/folders/`
    if you already have some basic framework to start from. See *Integrating Frameworks*,
    else PhpStorm will manage that for you by setting the default path (`~/PhpstormProjects/<name-of-your-project>`).
  prefs: []
  type: TYPE_NORMAL
- en: Reusing an existing project
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Those who planned to take the route on the right-hand side have rightly chosen
    to do so. At times, reinventing the wheel is not a wise action to perform.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If you reuse, you will be able to avoid spending time and resources on something
    that has already been created. PhpStorm allows you to reuse existing projects
    and lets you move forward. To reuse an existing project, you need to have the
    project on the disk.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To open an existing project, perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: You need to go to **File** | **Open**. There will be a pop-up dialog from PhpStorm.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You need to tell PhpStorm the path of the directory where your project is saved,
    and PhpStorm will obediently open the project for you.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: Once a directory has been opened as a project in PhpStorm, you will be able
    to distinguish it the next time because PhpStorm puts its logo next to this directory.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: You can now concentrate on gathering your technical requirements. You are strongly
    advised to plan well in advance before actually jumping to code because although
    a perfect software engineering plan does not exist yet, you can be optimistic
    and create a good enough plan that is flexible enough to be modified in case of
    need.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a new PHP class
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Having come to the kitchen, you should be prepared to get your hands dirty while
    cooking. You will have to face the class spills, member variable splashes, and
    literal wetness of sweat when you try to bake the data structures; they might
    be too hot to handle. You might end up causing a burning sensation inside you
    (out of control *acidity*; pun intended). You must be prepared to have mistakenly
    added less (syntactic) sugar, thought of incorrect salt handling algorithm. All
    sorts of cooking issues would be there to trouble you, which might make you leave
    cooking altogether and run away... scary? Maybe yes... but you will not tire,
    you will not falter, and you will not fail dear friends, Romans and countrymen!
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Some fundamentals... some programmers always talk **class**. In fact, all should.
    If you have always wondered what exactly a class is, you need to understand a
    datatype first. You must now have started feeling nostalgic, recalling your school
    days when teachers continued to haunt you with all those alien words. Come back
    and try to understand what a datatype is.
  prefs: []
  type: TYPE_NORMAL
- en: A **datatype** is a classification of data based on its type (some would like
    to call this its attribute) and the operations (some prefer calling this its behavior).
    So what is the relation between class and datatype? The answer is that a class
    is a custom datatype. Puzzled? Please do not be. If you attempt to create a class,
    what do you do? You plan a number of member variables… STOP.
  prefs: []
  type: TYPE_NORMAL
- en: 'What is a variable defined as? There is the connection. So, the complete statement
    now becomes: you plan a number of member variables, methods (functions, as some
    prefer saying) to pack inside a class.'
  prefs: []
  type: TYPE_NORMAL
- en: A class can be inherited from another class, can implement an interface, or
    be designed to be inherited. You can think of any permutation from the set {simple,
    abstract, inherited, super, and sub}, and you will observe that most of the permutations
    will be valid. How do you attack a problem? Simple common sense would suggest
    attacking the easiest part of the problem. So, here is how you can create a simple
    PHP class using PhpStorm.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To be about to create a new class, you might have already created a project.
    Inside that project, you can create a new class by selecting the target folder
    and accessing the right-click context menu.
  prefs: []
  type: TYPE_NORMAL
- en: 'PhpStorm is a curious machine. No sooner do you ask it to do something for
    you than it starts asking you a number of questions related to it. Here, when
    you ask PhpStorm to create a new class for you, it will ask you the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Name**: This is quite self explanatory and is a mandatory field. You need
    to tell PhpStorm the name of the class you want to be created. You should be careful
    while naming your class, as this has to be in sync with your project engineering
    plan.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Namespace**: This is a handle-with-care option. You need to specify the namespace
    in order to explicitly tell the interpreter which version of the function to use.
    This is an optional but important field—if you do not specify it, nothing bad
    will happen and you will not suffer any illness.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Filename**: This is an option you need to be careful while using. By default,
    this assumes the same value as the name of the class. If you mishandle this option
    by providing some other name, any product that you create will be solely owned
    by destiny, and no engineering principle will be able to maintain your product
    with ease.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Directory**: Here, you can set the location where you wish your class to
    physically reside on the disk. By default, it assumes the location where you created
    your project—project root to be precise.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Kind**: Now, this is something you have to decide based on the type of engineering
    plan that you have made prior to selecting this project. If you had a plan according
    to which you will be able to decide the functionality at a later stage, you can
    set the type of file as an interface; or for all other cases, you need to select
    the type as class. This interface is required in those conditions in which you
    will add the salt to the recipe later (pun intended). A trait is something that
    has a philosophy of "me too". You can safely ignore it for now.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**File extension**: This is an option that you are not advised to unnecessarily
    change. At the heart of all PHP files lies only one extension—the `.php` file.
    PhpStorm knows this. Please allow it to proceed.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The add class option is available via two menu items. One has already been
    discussed, and for the other, perform the following step:'
  prefs: []
  type: TYPE_NORMAL
- en: Go to **File** | **New**:![How to do it...](img/3878OT_02_03.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A simple sample class would look like the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Creating an interface in PhpStorm is not difficult either. On telling PhpStorm
    to create an interface, the output will be similar to a class except that there
    will be the keyword interface that will replace the keyword class. It will look
    like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If you want to differentiate class and interface, then you just need common
    sense in terms of PHP. A `Class` keyword is used for class and `interface` for
    creating interfaces in PHP.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a new PHP method
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If classes that represent real-world entities are nouns, they do not have any
    existence without verbs—the actions to be performed. To be able to maximize the
    technical profit for the manager you work for, you must be ready to use functions
    for all the verbs that exist in your use case.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Say for example, you have a pizza cooking task at hand. The recipe would consist
    of a (bare minimum) pizza bread (a noun), cheese (a noun), some salt (a noun).
    If you ponder over your problem, you will realize that you need to apply cheese
    to your pizza bread and add salt according to taste. If you look at this scenario
    from a technical perspective, you would most probably decide that there would
    be a `PizzaDish` class with functions such as `applyCheese(pizzaBread)`, `addSalt(cheese)`,
    and so on.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Creating a method in PhpStorm is easy. Suppose you have your `PizzaDish` class.
    Your pizza dish is a `Dish` so your `PizzaDish` would extend `Dish`. Your class
    would look like the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Your `PizzaDish` class can look like the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Coding in PhpStorm is eased heavily by the use of code hinting or code completion.
    You just need to type a few characters as a hint, and PhpStorm is ready to suggest
    what could be next. You type `fun` and press *Ctrl* + *Space*, and there will
    be a number of hints about what your function can be. If you want to do more with
    your pizza creation recipe, as in adding some more ingredients, such as capsicum
    or mushroom, you can have a general function, `add($ingredient, $dishname)`. You
    can do that in your `PizzaDish` class. You can make use of code completion for
    the access modifier. You have to manually take care of the other actions.
  prefs: []
  type: TYPE_NORMAL
- en: To convert the method `addSalt()` to `add()`, you need to rename the `addSalt`
    method. This is done in PhpStorm by the refactor option.
  prefs: []
  type: TYPE_NORMAL
- en: To refactor an item (here, the `addSalt` method), access the right-click context
    menu | **Refactor** | **Rename** or **Refactor** | **Change Signature**.
  prefs: []
  type: TYPE_NORMAL
- en: 'The **Rename** submenu, as shown in the following screenshot, will only change
    the name of the method:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How to do it...](img/3878OT_02_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The **Change Signature** option is a more detailed refactoring facility in
    which you can change the complete signature of a method, as shown in the following
    screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How to do it...](img/3878OT_02_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'So, your new add function becomes like the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'A similar change has occurred in the parent `Dish` class as well, where the
    method `addSalt` has been renamed to `add`, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'You can make use of the `PizzaDish` class and its methods by firing the code
    shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The working of the code ecosystem is quite simple. You instantiated the `PizzaDish`
    class normally. You invoked the `add` function. But, when you actually invoked
    the `add` function, what exactly happened? The `add` function called the `add`
    function defined in its parent class (remember extends added to the beginning
    of `PizzaDish`) using a special word—`parent`. So, you called the `add` method
    thinking that `PizzaDish` would do your work, but in reality, `Dish` did your
    work! No, no, this is not cheating. This is inheritance, as explained by the principles
    of software engineering.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The keyboard shortcuts are *Ctrl* + *F6* and *Shift* + *F6* to change the signature
    and rename respectively.
  prefs: []
  type: TYPE_NORMAL
- en: Adding the getter/setter methods
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Adding `getter` and `setter` methods in PhpStorm is equally easy. All you need
    to do is have a member variable of the class. In the `PizzaDish` example, it was
    `dishName`.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To create getters and setters for `dishName`, PhpStorm provides that if you
    need to. Access the right-click context menu for the target variable, click on
    **Generate** and select **Getters** and **Setters** from the pop up. PhpStorm
    will create the desired getters and setters for the selected member.
  prefs: []
  type: TYPE_NORMAL
- en: 'Your `PizzaDish` class will now look like the following piece of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The process of adding salt, cheese, and capsicum is still the same.
  prefs: []
  type: TYPE_NORMAL
- en: 'You have to send the following lines to your PHP engine in order to create
    a new pizza dish and add some ingredients to it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Earlier, when you had to access `$dishName`, you did it directly. This initiated
    a number of poor engineering practices, such as exposing the representation of
    the member variables. Actually, the list is endless. All you need to do is ensure
    that you must use getters and setters to be a good software engineer. So, in the
    code provided to you, you just have to call the `getter` method (such as `getDishName`)
    and the `setter` method (such as `setDishName`).
  prefs: []
  type: TYPE_NORMAL
- en: Are you still feeling uncomfortable? Have patience. Welcome to the real software
    engineering world.
  prefs: []
  type: TYPE_NORMAL
- en: Creating delegate methods
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Delegation is an important design pattern in software engineering. It enhances
    code reusability.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In PHP, delegate methods can be created in accordance with the principle of
    delegation. While calling delegate functions, you need not know the name of the
    actual function in advance—the PHP engine can find it out at runtime for you.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: PHP provides two factory methods for the purpose. However, you can create your
    own delegate methods using the principles of **object-oriented programming**.
  prefs: []
  type: TYPE_NORMAL
- en: 'The factory methods provided by PHP are `call_user_func()` and `call_user_func_array()`.
    While the usage of the two methods is out of the scope of this text, the creation
    and usage of the delegate methods is better explained by the same scenario of
    cooking `PizzaDish`, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'The usage of the delegate method is almost the same, but not the same:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'And the `Dish` class now looks like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Surprised? What is happening here is that when you invoke the `PizzaDish` class
    and pass the name of the `Dish` class in the constructor, the value of `$instance`
    is a newly created object of the `Dish` class. The rest, as it goes, is the usual
    method call via a class object. You can take a deep breath now, as you have just
    delegated the `add` function in `PizzaDish` to use the `add` function of `Dish`.
    It appears that the `PizzaDish` class is performing the task, but the actual task
    is done by the `Dish` class.
  prefs: []
  type: TYPE_NORMAL
- en: Surrounding code with control structures
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Whatever algorithm you think of, whichever tool you use to design the functional
    requirements, and whichever planet you go to and use whatever hardware as your
    development platform, there is this fact that is omnipresent and ubiquitous: loops
    will follow you everywhere. Control structures are the building blocks of any
    code you think of. Not convinced? Your `PizzaDish` use case itself will be able
    to prove it to you.'
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You need a computer in the first place to make calculations and decisions and
    solve complex problems in a diligent manner. Does a computer stop by solving just
    one problem? No. It is programmed to continue for all possible number of times
    it has been instructed. How does a program achieve this diligence? You said it
    right. A bit louder please. Yes, control loops. Even though this explanation might
    appear trivial to all you big guns, yet it is right that you cannot proceed to
    code without control structures.
  prefs: []
  type: TYPE_NORMAL
- en: PhpStorm lets you write code. It lets you concentrate on the actual business
    logic. You can write the lines of code that you think would be the atomic part.
    When you are convinced that the logic fits, you can use PhpStorm's **Surround**
    with feature to surround this code in your desired control structure.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'If you wish to add ingredients to your `PizzaDish`, you can make use of loops.
    There are multiple ways to express a single statement:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Using `foreach`, the `PizzaDish` class is invoked as follows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: You had to write `$pizzaDish->add($ingredient)` while keeping the cursor on
    this line.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Invoke Surround by going to **Code** | **Surround with**, and selecting the
    `foreach` option did the trick for you. However, you had to specify the variables
    inside the loop structure. You can also use the keyboard shortcut *Ctrl* + *Alt*
    + *T*.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'You can perform a similar action for the `for` loop. This change will allow
    you to invoke your code. Have a look at the following code snippet:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'A similar action is performed by surrounding the code with a `while` control
    structure. Your `PizzaDish` gets invoked by the following code snippet:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'A careful observation will reveal that the `while` loop behavior is exactly
    the same as the `for` loop behavior. Why have two features to achieve the same
    functionality, then? The human mind feels happy on having more choices. A piece
    of (pseudo) code explains this better:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The two control structures explained here have much in common. In a single
    term, they can be termed as entry-controlled structures because they follow the
    **first-decide-then-do** principle. They were not designed to make you lament
    your actions (pun intended). There is a gunslinger control structure that lives
    by the gun and dies by it, the `do-while` loop. It can cause you to lament your
    decision if you do not pay proper attention while using it. In the same terminology,
    it is an exit-controlled structure and will execute the task at least once. While
    this can seem required in some scenarios, you are advised to refrain from using
    `do-while`. Take a look at the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: So, in essence, the statement `$pizzaDish->add($ingredients[$ingredientCount])`
    gets executed at least once, increments the value of `$ingredientCount` by one,
    and then checks if the value is within limit. To use `do-while`, you need to place
    the cursor on the target statement and select the `do-while` option that appears
    in the **Select** dialog on going to **Code** | **Surround with**.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: To make your application program responsible enough, you need to implement exception
    handling denoted by a **try-catch** block. A simple use case to demonstrate the
    usage of exception handling will be shown in this recipe. You are attempting to
    prepare your `PizzaDish`. You plan to put salt and cheese as usual and capsicum
    as toppings to make it WOW. While cooking, you discovered that there was no capsicum
    in the fridge! But you are hungry enough not to let anything come between you
    and your `PizzaDish`. You will add tomato in that case. So, where is the responsibility
    in this code? It is that during preparation in your code to handle an *exceptional*
    situation there was a topping missing, but the code took the responsibility and
    handled this exceptional situation by adding tomato in place of capsicum.
  prefs: []
  type: TYPE_NORMAL
- en: 'Your `PizzaDish` continued to cook in the following way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: The following screenshot shows you how the which-control-to-surround looks.
    And it is worth noting that you should know which control structure you are going
    to use.
  prefs: []
  type: TYPE_NORMAL
- en: '![How it works...](img/3878OT_02_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Finding the matching brace
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '*If you embrace the brace, you will never be embarrassed.*'
  prefs: []
  type: TYPE_NORMAL
- en: '*Some PhpStorm Cookbook writer*'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Braces are an important element in programming. They not only define the boundary
    for the programmer, but also the interpreter. Both of you get to know the construct
    or from where to where the variable ranges. The PHP interpreter just needs to
    have a closing brace for every opening brace to proceed irrespective of how the
    code has been written. But the PHP interpreter is not powerful enough to write
    code for you—you have to do it yourself.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If you are provided with a small piece of code that is less than 100 lines long,
    you can somehow manage to read and maintain the code. If the line numbers exceed
    100, code formatting comes to your rescue.
  prefs: []
  type: TYPE_NORMAL
- en: PhpStorm enables you to format all or some of the selected lines by simple mouse
    clicks or a single keyboard shortcut. To format code, you need to select **Code**
    | **Reformat Code**, and your code will be formatted like a charm.
  prefs: []
  type: TYPE_NORMAL
- en: The keyboard shortcut for this is *Ctrl* + *Alt* + *L*.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'After PhpStorm has formatted the code, life becomes easier for you. You can
    very easily find the matching brace by putting the cursor on the brace. The paired
    braces get highlighted automatically. This highlighting feature can be customized
    as well. You need to go to **File** | **Settings** | **Editor** | **Highlight
    on caret movement** and check or uncheck the **Highlight matched brace** checkbox
    to turn highlighting matching braces on or off. You can change the brace color,
    the background color of the brace, and so on. You can make your braces look bold
    or italic. In order to customize this behavior, you need to set up a new scheme.
    To start off, you need to go to **File** | **Settings** | **Editor** | **Colors
    & Fonts** | **Language Defaults** | **Brackets**, select one of the default themes,
    and do a **Save As** in order to make a copy, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How it works...](img/3878OT_02_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The color scheme you just saved was saved as an XML document with the extension
    `.icls` under the `~/.WebIdeXX/config/colors` directory. The name of this document
    is the same as the name you provided while copying the color scheme.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let us now look at how to format a long string.
  prefs: []
  type: TYPE_NORMAL
- en: Wrapping string
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Another important aspect of code formatting gains importance when you have written
    some really long strings or some really long statements. You might end up in trouble
    trying to read those long lines. Even if you managed to read it, you might end
    up being confused about the start and end of those long, unhandleable lines.
  prefs: []
  type: TYPE_NORMAL
- en: PhpStorm enables you to wrap long lines and statements according to a fixed
    width. You can ask PhpStorm to remember some limits for you by visiting the **File**
    | **Settings** | **Editor** | **Virtual Space** pane.
  prefs: []
  type: TYPE_NORMAL
- en: You can wrap the long lines in the editor by selecting the checkbox against
    the **Use Soft wraps in editor** option. Long lines don't torment you only in
    the editor. They can also create a usage torture sometimes when you use the PhpStorm
    terminal to execute command-line PHP. If you check the **Use Soft wraps in console**
    option, you can avoid this problem once and for all. PhpStorm makes a provision
    for you to set the indent level for the wrap in the console. If you select this
    checkbox, the wrapped long line will continue into the next line, but with the
    specified number of spaces. Now, you cannot complain that you are not sure which
    one is your wrapped line and which one is your original line!
  prefs: []
  type: TYPE_NORMAL
- en: Commenting out a section of code and PHPDoc
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**PHPDoc** is a facility provided by PHP, which is meant to document the complex
    code that you toiled very hard to build. The importance of documenting code and
    properly documented code need not be explained to those of you who have taken
    care of someone else''s code at some point in their lives. For all others, and
    for those who know, yet are hungry for knowledge, here are a few points that might
    explain why you should always document your code—no matter what and how. Stay
    tuned for some interesting use cases.'
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You planned to cook `PizzaDish`. How did you proceed? You created an entity
    called `Dish`, designed some functions in it that will assist you in adding some
    ingredients, and created a special case of the general case `Dish`. You named
    this particular case `PizzaDish`. In order to cook your pizza, you invoked `PizzaDish`
    and enjoyed eating your favorite pizza. Things went smoothly. But how many times
    does it happen that you do not cook other things? Can you spend your life just
    eating pizza? Don't you think that you have other tasks to perform? Here's the
    analogy. How many times does it happen that you need nothing other than your written
    code? Can you be a good programmer by just using your own class or code? Will
    you create algorithms for each and every task that you perform?
  prefs: []
  type: TYPE_NORMAL
- en: In short, do you believe in reinventing the wheel?
  prefs: []
  type: TYPE_NORMAL
- en: Normal people would answer no. For them, how do you use classes written by another
    fellow programmer? How did you discover that the function `Engine::start('car')`
    will turn the ignition on? This is where documentation comes in. It is the medium
    by which you were able to discover that a start method in the `Engine` class was
    meant to turn on the engine ignition.
  prefs: []
  type: TYPE_NORMAL
- en: Writing clean code is the first key to documentation. You should always think
    of names that explain a lot. You should always think of descriptive names. If
    you think you are running out of names, you can make use of PHP namespaces.
  prefs: []
  type: TYPE_NORMAL
- en: To start thinking about how to write clean code, you are requested to read this
    book thoroughly. To start writing clean code, you are requested to start writing
    code.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'If you were careful enough and have a sharp memory, you would have already
    read the `Dish` and the `PizzaDish` classes. Looking at the way the variables
    were defined and the methods were declared, did you feel the need for other documentation?
    They say it and they say it right: *Good code in itself is good documentation*.
    But if you are unable to think of descriptive names in your code, here comes your
    savior—PHPDoc.'
  prefs: []
  type: TYPE_NORMAL
- en: 'You have three ways to add comments to your code:'
  prefs: []
  type: TYPE_NORMAL
- en: Single line
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Multiline or block comment
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Documentation comment
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In order to learn, you have to perform .In order to perform, you have to start.
    So let's start. Add comments to the `PizzaDish` class itself for clarity.
  prefs: []
  type: TYPE_NORMAL
- en: 'A single-line comment is the simplest and the easiest form of writing comments
    in PHP code. A single-line comment begins with `//`, and whatever follows in a
    single line is treated by the PHP engine as a single-line comment. In the `PizzaDish`
    class, a single-line comment has been added next to the list (php array) of ingredients,
    which looks like the following line of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: In order to write a single-line comment in PhpStorm, you need to take care of
    the location of the comment.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You can write the comment without the need to begin it with `//`. When you are
    done with your sentence, you can use the shortcut *Ctrl* + */*, and PhpStorm will
    happily convert the statement to a single-line comment.
  prefs: []
  type: TYPE_NORMAL
- en: Can your life be restricted to write a single line of comment? What if you want
    to have a number of single-line comments? Multiline or block comments will be
    required.
  prefs: []
  type: TYPE_NORMAL
- en: All you need to do is to identify the precious code extent, and add `/*` at
    the beginning and `*/` at the end of the code. There are people in this world
    who do not have an idea of what *precious* is. All good software engineers will
    ignore such people and move on. In the `PizzaDish` class discussed, you can see
    that the last few lines were commented out. This is a block comment. In the current
    scenario, your taste buds were the business end, people!
  prefs: []
  type: TYPE_NORMAL
- en: Documentation comments start with `/**` and end with `*/`. Does it not look
    like the block comment? A more careful examination would tell you the difference.
  prefs: []
  type: TYPE_NORMAL
- en: While a block comment just needs a comment starting symbol and an ending symbol,
    a documentation comment requires a `*` symbol before the start of every line.
    While the PHP engine skips the contents inside the block (and the single-line)
    comments, the PHP engine (actually, the documentation engine) "peeps" into the
    documentation lines when generating the actual beautiful comments. Where do you
    get to see the documents? Dear, when you press *Ctrl* + *Q* over any method declaration,
    what do you see? Yes, it is a document that is the same as generated by the documentation
    engine. Magic? PhpStorm's magic.
  prefs: []
  type: TYPE_NORMAL
- en: 'Fireworks! Too long? Didn''t read? A step-by-step explanation follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This is probably the first documentation comment you are looking into. You
    will be surprised to know that the HTML tags you write here are actually processed
    by the PHP documentation engine. The output of the documentation comment appears
    when you put the cursor over the target member and go to **View | Quick Documentation**:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How it works...](img/3878OT_02_08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: A picture is worth a thousand words. You can easily see how the HTML tags were
    processed to give proper formatting to the document.
  prefs: []
  type: TYPE_NORMAL
- en: 'Similarly, you can add documentation to your methods as well (the same class
    and the same method, but this time, it''s `setDishName` with added documentation).
    The documentation lines would be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'You just used the HTML strong tag to emphasize the type of the method `setDishName`.
    You were also able to emphasize that software engineering principles advise the
    use of setter methods. The comment for this method takes the following form:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How it works...](img/3878OT_02_09.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In order to use the keyboard shortcut *Ctrl* + *Q*, you need not necessarily
    place your cursor under the method name. This works for the documentation comment
    region as well. PhpStorm is smart, so it understands that and shows you the same
    documentation.
  prefs: []
  type: TYPE_NORMAL
- en: PhpStorm never disappoints you. There is a facility in PhpStorm in which you
    can customize the way your documentation comment should look. To do that, you
    need to go to **File** | **Settings** | **Code Style** | **PHP** | **PHPDoc**,
    as shown in the following screenshot. The options are quite descriptive.
  prefs: []
  type: TYPE_NORMAL
- en: '![How it works...](img/3878OT_02_10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Creating a working set
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You would have felt a number of times that different PHP projects have different
    priorities. You got it right. A website development project, for example, would
    require a running web server configuration, and it might not require command-line
    PHP.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A simple PHP project, on the other hand, would require command-line PHP, without
    a web server, and the list of directories could be limited to some folders in
    a hierarchy. The point here is that there are different projects with different
    dependencies and settings. Having a working set makes PhpStorm behave appropriately
    for the project currently open.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'If you monitor the **Settings** pane closely, you will notice that there are
    two major sections. One is the project-settings section, where you make settings
    according to your project. This helps a great deal. PhpStorm builds an index for
    every project. If you create a proper working set for your project, you will help
    PhpStorm to build a more precise index, and the project processing will be much
    faster. Some of the important settings are:'
  prefs: []
  type: TYPE_NORMAL
- en: '**PHP Specific Settings**: Making settings to execute the application you plan
    to create is quite handy. You need not to worry about how to execute and test
    your application. You just need to choose from a list of options that PhpStorm
    will put up before you.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Interpreter**: You could be required to implement some offline tasks on your
    web hosting service, which could probably do an update, a check, log cleaning
    tasks, and so on. You might configure command-line PHP for such files so that
    you can access them by a direct keyboard shortcut.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Webserver**: Most of the time, you need to have a web server to run your
    PHP web application code. For this, you can specify the settings for the web server
    in PhpStorm.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Debugger**: Life without a debugger for a web developer is like life for
    a doctor without a stethoscope. When you don''t know what is going on inside,
    how can you find out what is actually going on? You require a debugger for sure.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Directories**: PhpStorm builds indexes of the files and folders that are
    there in the project. A longer index list means more memory consumption. Exclude
    unwanted *directory(ies)* from indexing, and PhpStorm will be grateful to you.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Inspections**: PhpStorm acts as an inspector for the code you write. By default,
    there are a number of inspections that are on, and in most probability, you would
    not require all of them at all times.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Version Control**: If you are working in a team, having a versioning system
    is the need of the hour. You can set the details of the versioning system, such
    as the URL, the username, the password, and all the necessary details that will
    make your life easier when downloading (checking out) or uploading (committing)
    in the project that a team is working on.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The other one is the IDE-specific settings section. This provides you with control
    over the configurations that are universally true for all projects under PhpStorm.
    The description is beyond the scope of this topic.
  prefs: []
  type: TYPE_NORMAL
- en: Creating TODO tasks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Suppose it is the end of day, you have to *hurry home* (no pun intended), there
    are fantastic ideas overflowing in your mind, and you are quite sure that you
    will not be able to regenerate those ideas. You can ask TODO to come to your assistance
    in those cases.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A **TODO** tag, when added to some PHP code, makes it visible under the TODO
    view. You can also refer to the TODO section of this chapter for a refresher.
  prefs: []
  type: TYPE_NORMAL
- en: Considering the same `Dish` and the `PizzaDish` scenario, suppose you thought
    of having some system to check whether the dish is cooked, you can put a flag
    there and then. This flag will keep reminding you about this.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To do a TODO, all you need to do is write TODO, followed by the reminder text,
    and press *Ctrl* + */* (that is comment the code). From what you have learned
    already, you can now document your `Dish` class. Probably, it would look something
    like the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: You managed to keep the functionality intact; you just added documentation comments
    for the class and the member methods. Everything else is as usual; the only alien
    item is the TODO. So, as you can see, a simple TODO was added. People might argue
    the usage of TODO. They are right and wrong in saying that life can be managed
    without TODO. They are right only in the case of tiny projects, where there is
    not much code and simple comments are visible and easily remembered. They are
    absolutely wrong in all other (and real-world) cases, where there are uncountable
    lines of code and you could actually face a nightmare in trying to figure out
    where you placed a comment related to some suggestion. PhpStorm is able to extract
    all the TODOs from your project and show them accurately in the TODO view.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Besides reminding you of some tasks-be-done-in-future, there can be some **FIXME**
    tags as well. As the name suggests, FIXME tags can be used to denote some feature
    that has produced errors or is prone to producing errors. You just need to use
    the FIXME keyword, followed by the description, which is then followed using *Ctrl*
    + */* (commenting). PhpStorm will start showing it in the TODO section, as shown
    in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: The fixme (or FIXME) tag will start indicating that there is something that
    has to be fixed.
  prefs: []
  type: TYPE_NORMAL
- en: However, the game's not over with TODO. If there are a number of fellow programmers
    in your development team, you can add flags for an individual teammate. How? PhpStorm
    provides you with filters. This is available at **File** | **Settings** | **TODO**.
  prefs: []
  type: TYPE_NORMAL
- en: 'You need to add a new pattern and a new filter to make it available in the
    filters section in the TODO view. On adding it, you will be able to set the flag
    for a particular fellow programmer. The code with this new flag looks like the
    following snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: The filters and the patterns are case-insensitive by default because a programmer's
    life already has a number of issues to handle. Keep this in mind!
  prefs: []
  type: TYPE_NORMAL
- en: Will you able to do the TODO?
  prefs: []
  type: TYPE_NORMAL
- en: '![How it works...](img/3878OT_02_11.jpg)'
  prefs: []
  type: TYPE_IMG
