<html><head></head><body>
<div class="book" title="Chapter&#xA0;7.&#xA0;Implementing Socket IPC and WebSocket Server/Client"><div class="book" id="1JFUC2-bd355a22cf10407cb10df27e65585b8d"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch07" class="calibre1"/>Chapter 7. Implementing Socket IPC and WebSocket Server/Client</h1></div></div></div><p class="calibre8">In the previous chapter, we had a sneak peek at the application we're about to build in this chapter. We already know that we'll use the PHP Streams API for interprocess communication. We'll also write WebSocket servers and, later, a simple WebSocket client. We also emphasized the importance of understanding how event loops work in an asynchronous and non-blocking application, and this will apply for both server and client applications in this chapter.</p><p class="calibre8">This chapter will also be very source code-intensive, so we'll split it into three smaller sections covering three different applications:</p><div class="book"><ul class="itemizedlist"><li class="listitem"><span class="strong"><strong class="calibre17">Server Manager application</strong></span>: This is the application we'll run when testing this whole project. It'll spawn subprocesses and communicate with them via Unix socket streams (wrapped with the PHP Streams API). Each subprocess represents a single WebSocket server that listens to a specific port.</li><li class="listitem"><span class="strong"><strong class="calibre17">WebSocket Server application</strong></span>: This is a single instance of the WebSocket server that allows multiple clients to be connected at the same time, enabling them to chat. This means we'll have to distribute each message to all clients in real time. We'll also keep a history of a few most recent messages that'll be populated to each new client. This application will communicate with the Server Manager via the Unix socket and provide its current status (the number of clients currently connected and the number of messages in the chat history).</li><li class="listitem"><span class="strong"><strong class="calibre17">WebSocket Client application</strong></span>: This is our test client that'll connect to  WebSocket servers and listen to the user input that'll be sent to the server.</li></ul></div><p class="calibre8">Before we start working on the Server Manager application, we should talk about one more concept that arises mostly in an RxJS environment, but which is also very relevant to this chapter.</p></div>

<div class="book" title="Chapter&#xA0;7.&#xA0;Implementing Socket IPC and WebSocket Server/Client">
<div class="book" title="Backpressure in Reactive Extensions"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_1"><a id="ch07lvl1sec46" class="calibre1"/>Backpressure in Reactive Extensions</h1></div></div></div><p class="calibre8">We usually think of Observables as streams of data that are produced by the source Observable on one end and consumed by an observer at the other end. While this is still correct, we're not aware of situations where the Observable is emitting values so fast that the consumer (the observer) is not able to handle them.</p><p class="calibre8">This could lead to significant memory or CPU usage, which we definitely want to avoid.</p><p class="calibre8">There're two groups of operators suitable for backpressure, although most of them aren't available in RxPHP and are related mostly to RxJS:</p><div class="book"><ul class="itemizedlist"><li class="listitem"><span class="strong"><strong class="calibre17">Lossy</strong></span>: In this group, some values are discarded and never arrive at the observers. For example, this could be the mouse position sampled over a certain timespan. We're usually interested in the current mouse position right now; we don't care about position in the past, and so this can be completely ignored.</li><li class="listitem"><span class="strong"><strong class="calibre17">Loss-less</strong></span>: In this group, values are stacked in operators and are typically emitted in batches. We don't want to lose any data, so a typical inner implementation of a loss-less operator is a buffer.</li></ul></div><p class="calibre8">As we said, backpressure is more typical for RxJS than RxPHP, but let's have a look at examples of both of these types in RxPHP.</p></div></div>

<div class="book" title="Chapter&#xA0;7.&#xA0;Implementing Socket IPC and WebSocket Server/Client">
<div class="book" title="Backpressure in Reactive Extensions">
<div class="book" title="Lossy backpressure"><div class="book"><div class="book"><div class="book"><h2 class="title2" id="calibre_pb_2"><a id="ch07lvl2sec63" class="calibre1"/>Lossy backpressure</h2></div></div></div><p class="calibre8">In the previous chapter, we used the <code class="literal">switchLatest()</code> operator to work with higher-order Observables. This automatically subscribed only to the latest Observable emitted from the source Observable and unsubscribed from the previous source. This is, in fact, a lossy operator because we know we're not guaranteed to receive all values.</p><p class="calibre8">In practice, we usually deal with use cases similar to the RxJS operator <code class="literal">throttleTime()</code>. This operator takes the timespan as a parameter, which defines how long after emitting a value it'll ignore all subsequent emissions from the source Observable.</p><p class="calibre8">We can have a look at its marble diagram to be clear as to what it does:</p><p class="calibre8">
</p><div class="mediaobject"><img src="../images/00027.jpeg" alt="Lossy backpressure" class="calibre19"/></div><p class="calibre20"> </p><p class="calibre8">
</p><p class="calibre8">This operator is already implemented in RxPHP, but we can implement it ourselves using just <code class="literal">filter()</code>, or even better, by creating a custom operator to see how this and similar functionality can be implemented internally.</p><div class="book" title="Implementing throttleTime() with the filter() operator"><div class="book"><div class="book"><div class="book"><h3 class="title1"><a id="ch07lvl3sec24" class="calibre1"/>Implementing throttleTime() with the filter() operator</h3></div></div></div><p class="calibre8">We can simulate a hot source Observable with the <code class="literal">IntervalObservable</code> class, which periodically emits values, and we'll filter out everything that arrives less than a second after the previous emission.
</p><p class="calibre8">
The following example simulates a similar functionality as the 
<code class="literal">
throttleTime()
</code>
 operator:</p><pre class="programlisting">// filter_01.php 
$loop = new StreamSelectLoop(); 
$scheduler = new EventLoopScheduler($loop); 
$lastTimestamp = 0; 
 
Observable::interval(150, $scheduler) 
    -&gt;filter(function() use (&amp;$lastTimestamp) { 
        if ($lastTimestamp + 1 &lt;= microtime(true)) { 
            $lastTimestamp = microtime(true); 
            return true; 
        } else { 
            return false; 
        } 
    }) 
    -&gt;subscribe(new DebugSubject());
 
$loop-&gt;run(); 
</pre><div class="informaltable" title="Note"><h3 class="title1"><a id="note38" class="calibre1"/>Note</h3><p class="calibre8">From now on in this book we won't include the <code class="literal">use</code> statements for classes we've been using so far to keep the examples as short as possible.</p></div><p class="calibre8">If we run this example, we'll see that it does what we need:</p><pre class="programlisting">
<span class="strong"><strong class="calibre17">$ php filter_01.php </strong></span>
<span class="strong"><strong class="calibre17">14:51:01 [] onNext: 0 (integer)</strong></span>
<span class="strong"><strong class="calibre17">14:51:02 [] onNext: 7 (integer)</strong></span>
<span class="strong"><strong class="calibre17">14:51:03 [] onNext: 14 (integer)</strong></span>
<span class="strong"><strong class="calibre17">14:51:04 [] onNext: 21 (integer)</strong></span>
<span class="strong"><strong class="calibre17">...</strong></span>
</pre><p class="calibre8">As we can see, the <code class="literal">IntervalObservable</code> class emits ever-increasing counter values, where most of them are ignored. However, this is not a very systematic approach. We have to keep the last timestamp in a variable, which is what we usually want to avoid with Rx.</p><p class="calibre8">Note that our callable for <code class="literal">filter()</code> doesn't take any arguments (the current value) because it doesn't matter to us.</p><p class="calibre8">So let's reimplement this into a standalone <code class="literal">ThrottleTimeOperator</code> class:</p><pre class="programlisting">// ThrottleTimeOperator.php 
class ThrottleTimeOperator implements OperatorInterface { 
  private $duration; 
  private $lastTimestamp = 0; 
 
  public function __construct($duration) { 
    $this-&gt;duration = $duration; 
  } 
 
  public function __invoke($observable, $observer, $sched=null) { 
    $disposable = $observable-&gt;filter(function() use ($observer) { 
      $now = microtime(true) * 1000; 
      if ($this-&gt;lastTimestamp + $this-&gt;duration &lt;= $now) { 
        $this-&gt;lastTimestamp = $now; 
        return true; 
      } else { 
        return false; 
      } 
    })-&gt;subscribe($observer); 
 
    return $disposable; 
  } 
} 
</pre><p class="calibre8">As we saw multiple times in previous chapters, when implementing custom operators we need to be aware of correctly propagating not only <code class="literal">onNext</code> signals, but also <code class="literal">onError</code> and <code class="literal">onComplete</code>. We can delegate all this responsibility by reusing already existing operators, which is in fact a recommended way of implementing new operators to Rx. This means that our operator just sets up a <code class="literal">filter()</code> operator that takes care of everything for us.</p><p class="calibre8">Using this operator is simple with the <code class="literal">lift()</code> method:</p><pre class="programlisting">// throttle_time_01.php 
$loop = new StreamSelectLoop(); 
$scheduler = new EventLoopScheduler($loop); 
$lastTimestamp = 0; 
 
Observable::interval(150, $scheduler) 
    -&gt;lift(function()  { 
        return new ThrottleTimeOperator(1000); 
    }) 
    -&gt;subscribe(new DebugSubject()); 
 
$loop-&gt;run(); 
</pre><p class="calibre8">The result printed to the console is exactly the same as we saw in the preceding code, so we don't need to list it here again.</p><p class="calibre8">So this is a lossy operator. All values that don't pass the predicate function to <code class="literal">filter()</code> are lost forever.</p><p class="calibre8">In RxJS 5, typical lossy operators are <code class="literal">audit()</code>, <code class="literal">auditTime()</code>, <code class="literal">throttle()</code>, <code class="literal">throttleTime()</code>, <code class="literal">debounce()</code>, <code class="literal">debounceTime()</code>, <code class="literal">sample()</code>, and <code class="literal">sampleTime()</code>. In RxJS 4, we also have the <code class="literal">pause()</code> operator.</p></div></div></div></div>

<div class="book" title="Chapter&#xA0;7.&#xA0;Implementing Socket IPC and WebSocket Server/Client">
<div class="book" title="Backpressure in Reactive Extensions">
<div class="book" title="Loss-less backpressure"><div class="book"><div class="book"><div class="book"><h2 class="title2" id="calibre_pb_3"><a id="ch07lvl2sec64" class="calibre1"/>Loss-less backpressure</h2></div></div></div><p class="calibre8">Loss-less operators are those that don't discard any values. Values are just stacked and sent to observers in batches.</p><p class="calibre8">In RxPHP, we can use the <code class="literal">bufferWithCount()</code> operator that takes as an argument the number of items stored in the buffer before emitting them to the observers. Optionally, we can also specify the number of items from the beginning of the previous buffer we want to skip.</p><p class="calibre8">The marble diagram explains this very well (this operator is available in RxJS 5 as <code class="literal">bufferCount()</code>):</p><p class="calibre8">
</p><p class="calibre8">
</p><div class="mediaobject"><img src="../images/00028.jpeg" alt="Loss-less backpressure" class="calibre19"/></div><p class="calibre20"> </p><p class="calibre8">
</p><p class="calibre8">
</p><p class="calibre8">As you can see, using the <code class="literal">bufferWithCount()</code> operator is very simple. We'll use the same example as shown previously and just switch operators:</p><pre class="programlisting">// buffer_with_count_01.php 
$loop = new StreamSelectLoop(); 
$scheduler = new EventLoopScheduler($loop); 
$lastTimestamp = 0; 
 
Observable::interval(500, $scheduler) 
    -&gt;bufferWithCount(4) 
    -&gt;subscribe(new DebugSubject()); 
 
$loop-&gt;run(); 
</pre><p class="calibre8">We're always buffering four values, so when the source <code class="literal">IntervalObservable</code> class emits a value every 500 ms, the observer will receive a value every two seconds:</p><pre class="programlisting">
<span class="strong"><strong class="calibre17">$ php buffer_with_count_01.php </strong></span>
<span class="strong"><strong class="calibre17">15:24:24 [] onNext: [0,1,2,3] (array)</strong></span>
<span class="strong"><strong class="calibre17">15:24:26 [] onNext: [4,5,6,7] (array)</strong></span>
<span class="strong"><strong class="calibre17">15:24:28 [] onNext: [8,9,10,11] (array)</strong></span>
<span class="strong"><strong class="calibre17">15:24:30 [] onNext: [12,13,14,15] (array)</strong></span>
</pre><p class="calibre8">RxJS 5 has five different buffer operator variants.</p><p class="calibre8">Both lossy and loss-less operators are useful, and we'll use the <code class="literal">throttleTime()</code> operator in a moment when implementing the Server Manager application.</p></div></div></div>
<div class="book" title="Implementing ProcessObservable" id="1KEEU1-bd355a22cf10407cb10df27e65585b8d"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch07lvl1sec47" class="calibre1"/>Implementing ProcessObservable</h1></div></div></div><p class="calibre8">The application in this chapter is going to spawn subprocesses a lot so it makes sense to wrap this functionality into a self-sufficient Observable. This Observable will spawn a new subprocess, emit its output with <code class="literal">onNext</code> and also properly handle <code class="literal">onError</code> and <code class="literal">onComplete</code> notifications:</p><pre class="programlisting">// ProcessObservable.php 
class ProcessObservable extends Observable { 
  private $cmd; 
  private $pidFile; 
 
  public function __construct($cmd, $pidFile = null) { 
    $this-&gt;cmd = $cmd; 
    $this-&gt;pidFile = $pidFile; 
  } 
 
  public function subscribe($observer, $scheduler = null) { 
    $process = new Process($this-&gt;cmd); 
    $process-&gt;start(); 
 
    $pid = $process-&gt;getPid(); 
    if ($this-&gt;pidFile) { 
      file_put_contents($this-&gt;pidFile, $pid); 
    } 
 
    $disposable = new CompositeDisposable(); 
    $autoObs = new AutoDetachObserver($observer); 
    $autoObs-&gt;setDisposable($disposable); 
 
    $cancelDisp = $scheduler→schedulePeriodic(function() 
          use ($autoObs, $process, $pid, &amp;$cancelDisp) { 
      if ($process-&gt;isRunning()) { 
        $output = $process-&gt;getIncrementalOutput(); 
        if ($output) { 
          $autoObs-&gt;onNext($output); 
        } 
      } elseif ($process-&gt;getExitCode() === 0) { 
        $output = $process-&gt;getIncrementalOutput(); 
        if ($output) { 
          $autoObs-&gt;onNext($output); 
        } 
        $autoObs-&gt;onCompleted(); 
      } else { 
        $e = new Exception($process-&gt;getExitCodeText()); 
        $autoObs-&gt;onError($e); 
      } 
    }, 0, 200); 
 
    $disposable-&gt;add($cancelDisp); 
    $disposable-&gt;add(new CallbackDisposable( 
          function() use ($process) { 
 
      $process-&gt;stop(1, SIGTERM); 
      if ($this-&gt;pidFile) { 
        unlink($this-&gt;pidFile); 
      } 
    })); 
 
    return $disposable; 
  } 
} 
</pre><p class="calibre8">This Observable internally uses the <code class="literal">Symfony\Component\Process\Process</code> class from Symfony3 components, which makes working with subprocesses easier.</p><p class="calibre8">It periodically checks for any available output from the subprocess and emits it. When the process terminates, we send proper <code class="literal">onError</code> or <code class="literal">onComplete</code> notifications. We can also optionally create a file with the process PID if we need to.</p><p class="calibre8">Notice that we used the <code class="literal">AutoDetachObserver</code> class to wrap the original observer and assigned it the <code class="literal">$disposable</code> object. For now it's just important to know that this class automatically calls <code class="literal">dispose()</code> on the disposable we passed it when it receives <code class="literal">onError</code> or <code class="literal">onComplete</code> notification.</p><p class="calibre8">We'll explain the <code class="literal">AutoDetachObserver</code> class in more detail in <a class="calibre1" title="Chapter 10. Using Advanced Operators and Techniques in RxPHP" href="part0070_split_000.html#22O7C1-bd355a22cf10407cb10df27e65585b8d">Chapter 10</a>, <span class="strong"><em class="calibre18">Using Advanced Operators and Techniques in RxPHP</em></span>.</p><p class="calibre8">We can test this Observable with a small script simulating a long-running process:</p><pre class="programlisting">// sleep.php 
$name = $argv[1]; 
$time = intval($argv[2]); 
$elapsed = 0; 
 
while ($elapsed &lt; $time) { 
    sleep(1); 
    $elapsed++; 
    printf("$name: $elapsed\n"); 
} 
</pre><p class="calibre8">Then we use the <code class="literal">ProcessObservable</code> to spawn this process and re-emit all its output:</p><pre class="programlisting">// process_observable_01.php 
$loop = new React\EventLoop\StreamSelectLoop(); 
$scheduler = new Rx\Scheduler\EventLoopScheduler($loop); 
 
$pid = tempnam(sys_get_temp_dir(), 'pid_proc1'); 
$obs = new ProcessObservable('php sleep.php proc1 3', $pid); 
$obs-&gt;subscribe(new DebugSubject(), $scheduler); 
 
$loop-&gt;run(); 
</pre><p class="calibre8">This will just print one line every second and then end:</p><pre class="programlisting">
<span class="strong"><strong class="calibre17">$ php process_observable_01.php</strong></span>
<span class="strong"><strong class="calibre17">11:59:05 [] onNext: proc1: 1</strong></span>
<span class="strong"><strong class="calibre17"> (string)</strong></span>
<span class="strong"><strong class="calibre17">11:59:06 [] onNext: proc1: 2</strong></span>
<span class="strong"><strong class="calibre17"> (string)</strong></span>
<span class="strong"><strong class="calibre17">11:59:07 [] onNext: proc1: 3</strong></span>
<span class="strong"><strong class="calibre17"> (string)</strong></span>
<span class="strong"><strong class="calibre17">11:59:07 [] onCompleted</strong></span>
</pre><p class="calibre8">Now let's start with the main application for this chapter.</p></div>

<div class="book" title="Server Manager application"><div class="book" id="1LCVG2-bd355a22cf10407cb10df27e65585b8d"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch07lvl1sec48" class="calibre1"/>Server Manager application</h1></div></div></div><p class="calibre8">Finally, we can start writing the largest application so far. The Server Manager is going to be a CLI application that will be responsible for spawning WebSocket servers, where each server is a standalone application itself, with its own clients and chat history.</p><p class="calibre8">A typical use-case could be a Unix server that manages multiple instances of some game server. Each server needs to be isolated. If any of them crashed, we don't want all games servers on this machine to crash as well. At the same time, we want to be able to collect some status information from servers and monitor them in real time with the Server Manager.</p><p class="calibre8">We can describe the structure of this entire application and what role the Server Manager has with the following diagram:</p><p class="calibre8">
</p><div class="mediaobject"><img src="../images/00029.jpeg" alt="Server Manager application" class="calibre19"/></div><p class="calibre20"> </p><p class="calibre8">
</p><p class="calibre8">In this diagram, we can see the <span class="strong"><strong class="calibre17">Server Manager</strong></span> application on the right. It communicates via Unix sockets with a single instance of <span class="strong"><strong class="calibre17">Game Server</strong></span>. This instance of <span class="strong"><strong class="calibre17">Game Server</strong></span> has two clients connected to it via WebSockets.</p><p class="calibre8">Communication between the <span class="strong"><strong class="calibre17">Server Manager</strong></span> and the <span class="strong"><strong class="calibre17">Game Server</strong></span> is only one way; the <span class="strong"><strong class="calibre17">Game Server</strong></span> will actively send its status to the <span class="strong"><strong class="calibre17">Server Manager</strong></span> itself. Communication between the <span class="strong"><strong class="calibre17">Game Server</strong></span> and all its clients has to be two-way. When a user sends a message, we need to resend it to all other clients connected to the same <span class="strong"><strong class="calibre17">Game Server</strong></span>.</p><p class="calibre8">We'll start with just creating a basic class stub that listens to user input via <code class="literal">stdin</code>, and, based on that, calls some action:</p><pre class="programlisting">// ServerManager.php 
class ServerManagerCommand extends Command { 
  private $scheduler; 
  private $loop; 
  private $unixSocketFile; 
  private $output; 
  private $commands = [ 
    'n' =&gt; 'spawnNewServer', 
    'q' =&gt; 'quit', 
  ]; 
 
  protected function configure() { 
    $this-&gt;setName('manager'); 
    $this-&gt;addArgument('socket_file',InputOption::VALUE_REQUIRED); 
  } 
 
  protected function execute($input, $output) { 
    $this-&gt;output = $output; 
    $this-&gt;unixSocketFile = $input-&gt;getArgument('socket_file'); 
    @mkdir(dirname($this-&gt;unixSocketFile), 0766, true); 
 
    $loop = new React\EventLoop\StreamSelectLoop(); 
    $this-&gt;loop = $loop; 
    $this-&gt;scheduler = new EventLoopScheduler($this-&gt;loop); 
 
    $subject = new Subject(); 
    $stdin = $subject-&gt;asObservable(); 
 
    $stdinRes = fopen('php://stdin', 'r'); 
    $loop-&gt;addReadStream($stdinRes, function($s) use ($subject) { 
      $str = trim(fgets($s, 1024)); 
      $subject-&gt;onNext($str); 
    }); 
 
    foreach ($this-&gt;commands as $pattern =&gt; $method) { 
      $stdin 
        -&gt;filter(function($string) use ($pattern) { 
          return $pattern == $string; 
        }) 
        -&gt;subscribeCallback(function($value) use ($method) { 
          $this-&gt;$method($value); 
        }); 
    } 
 
    // ... We'll continue here later 
 
    $this-&gt;loop-&gt;run(); 
  } 
} 
 
$command = new ServerManagerCommand(); 
$application = new Application(); 
$application-&gt;add($command); 
$application-&gt;setDefaultCommand($command-&gt;getName()); 
$application-&gt;run(); 
</pre><p class="calibre8">We created a stream from <code class="literal">php://stdin</code> and added it to the event loop. This is exactly what we've seen in the previous chapter when talking about the PHP Streams API. To make adding new commands easy, we created a <code class="literal">Subject</code> instance where we call <code class="literal">onNext()</code> on any user input.</p><p class="calibre8">We don't subscribe to the <code class="literal">Subject</code> instance directly, but rather to an Observable returned from its <code class="literal">asObservable()</code> method. Of course, we could subscribe directly to the <code class="literal">Subject</code> instance since it acts as an Observable and an observer at the same time. However, if anyone had access to the <code class="literal">Subject</code> instance, then we can't be sure that somebody won't call its <code class="literal">onNext()</code> or <code class="literal">onComplete()</code> by mistake, which might cause unpredictable behavior. For this reason, it's good practice to hide the fact that we're using <code class="literal">Subject</code> internally and expose only Observables using <code class="literal">asObservable()</code>.</p><p class="calibre8">We have two commands at this moment:</p><div class="book"><ul class="itemizedlist"><li class="listitem"><code class="literal">n</code>: This command spawns a new subprocess using <code class="literal">ProcessObservable</code> and adds its disposable to the list of running processes. We'll use these disposables to unsubscribe later. Each subprocess will be assigned a unique port number. This port will be used by the Game Server to start the WebSocket server.</li><li class="listitem"><code class="literal">q</code>: This command is used to quit this application. This means we need to call <code class="literal">dispose()</code> on all disposables from the array of active processes, close all Unix socket connections, and then stop the event loop.</li></ul></div><p class="calibre8">We'll now implement creating new subprocesses and quitting the application. To quit the application, we'll need the array of all socket connections (<code class="literal">$processes</code> private property) that we don't have yet.</p></div>

<div class="book" title="Server Manager application">
<div class="book" title="Creating new subprocesses with ProcessObservable"><div class="book"><div class="book"><div class="book"><h2 class="title2" id="calibre_pb_1"><a id="ch07lvl2sec65" class="calibre1"/>Creating new subprocesses with ProcessObservable</h2></div></div></div><p class="calibre8">We don't need anything special to create a new subprocess, because we'll use the <code class="literal">ProcessObservable</code> class that we created previously. Each subprocess will have its own port number assigned, where it'll run its WebSocket server:</p><pre class="programlisting">class ServerManager extends Command { 
  /** @var DisposableInterface[] */ 
  private $processes = []; 
 
  // ... 
 
  private function spawnNewServer() { 
    $port = $this-&gt;startPort++; 
    $cmd = 'php GameServer.php game-server ' 
      . $this-&gt;unixSocketFile . ' ' . $port; 
    $cmd = escapeshellcmd($cmd); 
    $process = new ProcessObservable($cmd); 
    $this-&gt;output-&gt;writeln('Spawning process on port '.$port); 
 
    $this-&gt;processes[$port] = $process-&gt;subscribeCallback( 
      null, 
      function($e) use ($port) { 
        $msg = sprintf('%d: Error "%s"', $port, $e); 
        $this-&gt;output-&gt;writeln($msg); 
      }, 
      function() use ($port) { 
        $this-&gt;output-&gt;writeln(sprintf('%d: Ended', $port)); 
      }, $this-&gt;scheduler 
    ); 
  } 
 
  private function quit() { 
    foreach ($this-&gt;servers as $server) { 
      $server-&gt;close(); 
    } 
    foreach ($this-&gt;processes as $process) { 
      $process-&gt;dispose(); 
    } 
    $this-&gt;loop-&gt;stop(); 
  } 
} 
</pre><p class="calibre8">We spawn a new subprocess and then subscribe to it to read its output. We're not, in fact, expecting to receive any output; we're doing this just in case the subprocess crashed and we want to see what happened.</p><p class="calibre8">Note that we're also passing the single instance of Scheduler to <code class="literal">subscribeCallback()</code> using <code class="literal">$this-&gt;scheduler</code>. We need to do this because <code class="literal">ProcessObservable</code> adds its own periodic timer to check for output from the subprocess. This is one of the cases where we need to be sure to use just a single event loop, as we were talking about in the previous chapter.</p><p class="calibre8">All disposables will be stored in the <code class="literal">$processes</code> array organized by their port numbers. It's important to keep references to all disposables so that we can end all subprocesses gently by just disposing them (<code class="literal">ProcessObservable</code> will send a <code class="literal">SIGTERM</code> signal).</p></div></div>

<div class="book" title="Server Manager application">
<div class="book" title="Game Server application"><div class="book"><div class="book"><div class="book"><h2 class="title2" id="calibre_pb_2"><a id="ch07lvl2sec66" class="calibre1"/>Game Server application</h2></div></div></div><p class="calibre8">We'll switch for a moment to the Game Server application. We'll only make the most essential part of it, the one that connects to the Unix socket server and periodically sends a value from <code class="literal">IntervalObservable</code>.</p><p class="calibre8">We want to do this to be able to test that the Server Manager receives and displays statuses correctly. This is the part where we'll use <code class="literal">switchMap()</code> and <code class="literal">combineLatest()</code> operators to work with higher-order Observables.</p><p class="calibre8">We won't bother with WebSocket implementation right now - that'll come later:</p><pre class="programlisting">// GameServer.php 
class GameServer extends Command { 
  /** @var StreamObservable */ 
  private $streamObservable; 
 
  protected function configure() { 
    $this-&gt;setName('game-server'); 
    $this-&gt;addArgument('socket_file',InputOption::VALUE_REQUIRED); 
    $this-&gt;addArgument('port', InputOption::VALUE_REQUIRED); 
  } 
 
  protected function execute($input, $output) { 
    $file = $input-&gt;getArgument('socket_file'); 
    $port = $input-&gt;getArgument('port'); 
 
    $client = stream_socket_client("unix://".$file, $errno, $err); 
    stream_set_blocking($client, 0); 
 
    $loop = new React\EventLoop\StreamSelectLoop(); 
    $this-&gt;streamObservable = new StreamObservable($client,$loop); 
    $this-&gt;streamObservable-&gt;send('init', ['port' =&gt; $port]); 
    $this-&gt;streamObservable-&gt;send('status', 'ready'); 
    $scheduler = new EventLoopScheduler($loop); 
 
    Observable::interval(500, $scheduler) 
      -&gt;subscribeCallback(function($counter) { 
        $this-&gt;streamObservable-&gt;send('status', $counter); 
      }); 
 
    $loop-&gt;run(); 
    // WebSocket server will go here... 
  } 
} 
</pre><p class="calibre8">Using the <code class="literal">stream_socket_client()</code> function, we connect to the Unix socket server.</p><p class="calibre8">Note that right after the connection is established we send two messages to the Server Manager. The first one is indicating that the subprocess is running with <code class="literal">init</code>, and it also indicates which port it's using (the port for the WebSocket server). The second message is <code class="literal">status</code> with just a string, <code class="literal">ready</code>". This is what we'll display in the Server Manager. Then we create <code class="literal">IntervalObservable</code>, which sends a status via the Unix socket stream every 500 ms.</p><p class="calibre8">We're using some mystery <code class="literal">StreamObservable</code> class that we haven't implemented yet. The Unix socket stream is, in fact, a two-way channel, so it makes sense to wrap its connection with an Observable for convenience. When it receives data, it calls <code class="literal">onNext()</code>, and when we close the connection, it calls <code class="literal">onComplete()</code>.</p><p class="calibre8">This Observable also sends data, so it might look like a <code class="literal">Subject</code> instance could better fit this purpose. Although it sends data via the <code class="literal">send()</code> method, it, in fact, writes directly to the stream with <code class="literal">fwrite()</code>. Subjects are designed to send data to observers, which is not our case.</p><p class="calibre8">The <code class="literal">StreamObservable</code> class is then a relatively simple Observable that adds its stream to the event loop and emits all the data it receives:</p><pre class="programlisting">//  StreamObservable.php 
class StreamObservable extends Observable { 
  protected $stream; 
  protected $subject; 
  protected $loop; 
 
  public function __construct($stream, LoopInterface $loop) { 
    $this-&gt;stream = $stream; 
    $this-&gt;loop = $loop; 
    $this-&gt;subject = new Subject(); 
 
    $this-&gt;loop-&gt;addReadStream($this-&gt;stream, function ($stream) { 
      $data = trim(fgets($stream)); 
      $this-&gt;subject-&gt;onNext($data); 
    }); 
  } 
 
  public function subscribe($observer, $scheduler = null) { 
    return $this-&gt;subject-&gt;subscribe($observer); 
  } 
 
  public function send($type, $data) { 
    $message = ['type' =&gt; $type, 'data' =&gt; $data]; 
    fwrite($this-&gt;stream, json_encode($message) . "\n"); 
  } 
 
  public function close() { 
    $this-&gt;loop-&gt;removeReadStream($this-&gt;stream); 
    fclose($this-&gt;stream); 
    $this-&gt;subject-&gt;onCompleted(); 
  } 
} 
</pre><p class="calibre8">Now it should be obvious how the <code class="literal">GameServer</code> class works. After we implement the WebSocket server, we'll use the <code class="literal">send()</code> method on <code class="literal">StreamObservable</code> to report its status to the Server Manager. However, instead of using <code class="literal">IntervalObservable</code> and its incrementing counter, we'll send the number of clients connected and the number of messages in the chat history.</p><p class="calibre8">Let's go back to the Server Manager and implement the Unix socket server that is required to establish the connection between the Game Server and Server Manager.</p></div></div>

<div class="book" title="Server Manager and the Unix socket server"><div class="book" id="1MBG22-bd355a22cf10407cb10df27e65585b8d"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch07lvl1sec49" class="calibre1"/>Server Manager and the Unix socket server</h1></div></div></div><p class="calibre8">In order to be able to use <code class="literal">stream_socket_client()</code> to connect to a socket server, we need to first create the server with <code class="literal">stream_socket_server()</code>. The principle is identical to what we saw in the previous chapter when explaining the example with a simple HTTP server, made just using <code class="literal">stream_socket_server()</code>, <code class="literal">stream_socket_accept()</code>, and <code class="literal">StreamSelectLoop</code>:</p><pre class="programlisting">class ServerManager extends Command { 
  // ... 
  private $statusSubject; 
  private $servers = []; 
 
  protected function execute($input, $output) { 
    // ... 
    @unlink($this-&gt;unixSocketFile); 
    $address = "unix://" . $this-&gt;unixSocketFile; 
    $server = stream_socket_server($address, $errno, $errMsg); 
    stream_set_blocking($server, 0); 
 
    $this-&gt;loop-&gt;addReadStream($server, function() use ($server) { 
      $client = stream_socket_accept($server); 
      $server = new GameServerStreamEndpoint($client,$this-&gt;loop); 
 
      $server-&gt;onInit()-&gt;then(function($port) use ($server) { 
        $msg = sprintf('Sub-process %d initialized', $port); 
        $this-&gt;output-&gt;writeln($msg); 
        $this-&gt;addServer($port, $server); 
      }); 
    }); 
 
    $this-&gt;statusSubject = new Subject(); 
    // ... We'll continue here later 
  } 
 
  private function addServer($port, $server) { 
    $this-&gt;servers[$port] = $server; 
    $this-&gt;statusSubject-&gt;onNext(null); 
  } 
} 
</pre><p class="calibre8">Accepting new connections via Unix sockets is analogous to TCP connections. In the <code class="literal">GameServer</code> class, we saw that the first status call it always makes after establishing the connection is "init", along with its port number to tell the Server Manager which Game Server is initialized and ready to start receiving WebSocket clients. We also said that we need to keep track of all active connections in order to be able to close them when we want to quit the application. Collecting statuses from each subprocess requires us to be able to distinguish which socket connection belongs to which subprocess (and which port we assigned to it).</p><p class="calibre8">This is why, when we accept a new connection, we wrap it with the <code class="literal">GameServerStreamEndpoint</code> class that has an <code class="literal">onInit()</code> method returning an instance of the <code class="literal">Promise</code> class. This <code class="literal">Promise</code> class is then resolved with the subprocess port number (see <code class="literal">GameServer</code> class) when the new connection sends its <code class="literal">init</code> status. After this, we finally add the connection into the array of connections (with port numbers as keys) using the <code class="literal">addServer()</code> method.</p><p class="calibre8">Note that we're keeping one array for processes (the <code class="literal">$processes</code> property) and another array for stream connections wrapped with <code class="literal">GameServerStreamEndpoint</code> (the <code class="literal">$servers</code> property).</p><p class="calibre8">Also note that at the end of the <code class="literal">addServer()</code> method, we call <code class="literal">$statusSubject-&gt;onNext(null)</code>. This will trigger an update to the collection of subscriptions to subprocess statuses. We'll come to this in a moment.</p></div>

<div class="book" title="Server Manager and the Unix socket server">
<div class="book" title="Implementing the GameServerStreamEndpoint class"><div class="book"><div class="book"><div class="book"><h2 class="title2" id="calibre_pb_1"><a id="ch07lvl2sec67" class="calibre1"/>Implementing the GameServerStreamEndpoint class</h2></div></div></div><p class="calibre8">This class is going to combine the <code class="literal">StreamObservable</code> that we created a moment ago, Promises, the <code class="literal">Deferred</code> class, and Observables. This way, we can completely hide its internals where we decode the JSON strings received from the stream, and filter messages by their type:</p><pre class="programlisting">// GameServerStreamEndpoint.php 
class GameServerStreamEndpoint { 
  private $stream; 
  private $initDeferred; 
  private $status; 
 
  public function __construct($stream, LoopInterface $loop) { 
    $this-&gt;stream = new StreamObservable($stream, $loop); 
    $this-&gt;initDeferred = new Deferred(); 
 
    $decodedMessage = $this-&gt;stream 
      -&gt;lift(function() { 
        return new JSONDecodeOperator(); 
      }); 
 
    $unsubscribe = $decodedMessage 
      -&gt;filter(function($message) { 
        return $message['type'] == 'init'; 
      }) 
      -&gt;pluck('data') 
      -&gt;subscribeCallback(function($data) use (&amp;$unsubscribe) { 
        $this-&gt;initDeferred-&gt;resolve($data['port']); 
        $unsubscribe-&gt;dispose(); 
      }); 
 
    $this-&gt;status = $decodedMessage 
      -&gt;filter(function($message) { 
        return $message['type'] == 'status'; 
      }) 
      -&gt;pluck('data') 
      -&gt;multicast(new ReplaySubject(1)); 
    $this-&gt;status-&gt;connect(); 
  } 
 
  public function getStatus() { 
    return $this-&gt;status; 
  } 
 
  public function onInit() { 
    return $this-&gt;initDeferred-&gt;promise(); 
  } 
 
  public function close() { 
    return $this-&gt;stream-&gt;close(); 
  } 
} 
</pre><p class="calibre8">We subscribe to the <code class="literal">StreamObservable</code> instance to decode any incoming messages (the <code class="literal">$decodedMessage</code> variable). Then, with <code class="literal">filter()</code> operators, we pass through only messages of particular types.</p><p class="calibre8">If the message type is <code class="literal">init,</code> we resolve the <code class="literal">Promise</code> object returned from <code class="literal">onInit()</code>. We know there should never be multiple <code class="literal">init</code> calls, so we can unsubscribe right after that.</p><p class="calibre8">A slightly more complicated situation is when we receive the <code class="literal">status</code> message. We chain <code class="literal">$decodedMessage</code> with the <code class="literal">multicast()</code> operator. This is an operator we haven't met yet, and we'll look into it in more detail in the next chapter. For now, we just need to know that this operator subscribes to its source Observable using an instance of <code class="literal">Subject</code> that we provided, which in this case is <code class="literal">ReplaySubject</code>. Then, it returns a <code class="literal">ConnectableObservable</code> (see <a class="calibre1" title="Chapter 3. Writing a Reddit Reader with RxPHP" href="part0033_split_000.html#VF2I2-bd355a22cf10407cb10df27e65585b8d">
Chapter 3
</a>, <span class="strong"><em class="calibre18">Writing a Reddit Reader with RxPHP</em></span>).</p><p class="calibre8">The important thing with <code class="literal">multicast()</code> is that it creates a single subscription to its source Observable. We're using <code class="literal">ReplaySubject</code> purposely because it remembers the last value it emitted, so if we subscribe to the Observable returned from <code class="literal">getStatus()</code> multiple times, we'll always receive the most recent value immediately.</p><p class="calibre8">There're multiple variants of the <code class="literal">multicast()</code> operator, each with a slightly different purpose, but more on that in <a class="calibre1" title="Chapter 8. Multicasting in RxPHP and PHP7 pthreads Extension" href="part0061_split_000.html#1Q5IA1-bd355a22cf10407cb10df27e65585b8d">Chapter 8</a>, <span class="strong"><em class="calibre18">Multicasting in RxPHP and PHP7 pthreads Extension</em></span>.</p></div></div>

<div class="book" title="Server Manager and the Unix socket server">
<div class="book" title="Displaying real-time statuses from subprocesses"><div class="book"><div class="book"><div class="book"><h2 class="title2" id="calibre_pb_2"><a id="ch07lvl2sec68" class="calibre1"/>Displaying real-time statuses from subprocesses</h2></div></div></div><p class="calibre8">In order to display the status of a single <code class="literal">GameServerStreamEndpoint</code>, we can subscribe to the Observable returned from <code class="literal">getStatus()</code>, which is, in fact, a <code class="literal">ConnectableObservable</code>.</p><p class="calibre8">However, our use-case isn't that simple. What if we spawn a new subprocess and want to subscribe to it as well? For <span class="strong"><em class="calibre18">N</em></span> subprocesses, we need <span class="strong"><em class="calibre18">N</em></span> subscriptions. Also, our requirement is to monitor all statuses in real time, so this looks like we could use the <code class="literal">combineLatest()</code> operator with an array of Observables (an array of Observables emitting statuses). The problem is that we don't know how many Observables we'll have because we're going to add them on the go by spawning new subprocesses.</p><p class="calibre8">One solution could be using <code class="literal">combineLatest()</code> to subscribe to all current status Observables and, when a new subprocess is created, unsubscribing and creating a new array of status Observables for the <code class="literal">combineLatest()</code> operator. This is, of course, doable, but there's a better and more elegant solution using the <code class="literal">switchLatest()</code> operator and higher-order Observables from <a class="calibre1" title="Chapter 6. PHP Streams API and Higher-Order Observables" href="part0050_split_000.html#1FLS41-bd355a22cf10407cb10df27e65585b8d">Chapter 6</a>, <span class="strong"><em class="calibre18">PHP Streams API and Higher-Order Observables</em></span>.</p><p class="calibre8">We'll first demonstrate the principle on a separate example and then apply it to the <code class="literal">ServerManager</code> class.</p><div class="book" title="Combining the switchLatest() and combineLatest() operators"><div class="book"><div class="book"><div class="book"><h3 class="title1"><a id="ch07lvl3sec25" class="calibre1"/>Combining the switchLatest() and combineLatest() operators</h3></div></div></div><p class="calibre8">Let's say we add a new server every 1000 ms, but one of the existing servers updates its status every 600 ms. This means we need to recreate a new Observable with <code class="literal">combineLatest()</code> every second from the current array of servers.</p><p class="calibre8">Consider the following example where we simulate this situation using two <code class="literal">IntervalObservables</code>:</p><pre class="programlisting">// switch_latest_01.php  
$range = [1]; 
$loop = new StreamSelectLoop(); 
$scheduler = new EventLoopScheduler($loop); 
 
$newServerTrigger = Observable::interval(1000, $scheduler); 
$statusUpdate = Observable::interval(600, $scheduler)-&gt;publish(); 
$statusUpdate-&gt;connect(); // Make it hot Observable 
 
$newServerTrigger 
    -&gt;map(function() use (&amp;$range, $statusUpdate) { 
        $range[] = count($range) + 1; 
        $observables = array_map(function($val) { 
            return Observable::just($val); 
        }, $range); 
 
        return $statusUpdate 
            -&gt;combineLatest($observables, function() { 
                $values = func_get_args(); 
                array_shift($values); 
                return $values; 
            }); 
    }) 
    -&gt;switchLatest() 
    -&gt;take(8) 
    -&gt;doOnCompleted(function() use ($loop) { 
        $loop-&gt;stop(); 
    }) 
    -&gt;subscribe(new DebugSubject()); 
 
$loop-&gt;run(); 
</pre><p class="calibre8">Instead of the array of servers, we use a <code class="literal">$range</code> variable that we're constantly expanding, and instead of real statuses, we just wrap values with <code class="literal">Observable::just()</code>.</p><p class="calibre8">The Observable <code class="literal">$statusUpdate</code> emits independently on the <code class="literal">$statusUpdate</code> Observable, which makes the <code class="literal">combineLatest()</code> operator sometimes re-emit the same values without any change, while being subscribed to the same array of Observables.</p><p class="calibre8">The core parts of this Observable chain are obviously <code class="literal">combineLatest()</code> and <code class="literal">switchLatest()</code>. Since <code class="literal">$newServerTrigger</code> represents adding a new server, we need to provide <code class="literal">combineLatest()</code> with a fresh array of Observables that we want to subscribe to. Then <code class="literal">switchLatest()</code> unsubscribes from the previous Observable returned by <code class="literal">combineLatest()</code> and subscribes to the new one.</p><p class="calibre8">You might wonder why we're using <code class="literal">func_get_args()</code> and <code class="literal">array_shift()</code> to get the values passed to the callable. The Operator <code class="literal">combineLatest()</code> passes values for each source Observable unpacked (<span class="strong"><em class="calibre18">N</em></span> source Observables result in <span class="strong"><em class="calibre18">N</em></span> function parameters), but we don't know how many source Observables we're going to have. That's why we take all arguments as a single array and then remove the first item. The first item is a value from <code class="literal">$statusUpdate</code> that is also included by <code class="literal">combineLatest()</code> as a source Observable, but for us it has no purpose, so we won't re-emit it.</p><div class="informaltable" title="Note"><h3 class="title1"><a id="note39" class="calibre1"/>Note</h3><p class="calibre8">Note that the selector function for the <code class="literal">combineLatest()</code> is optional. If we don't provide it, the operator will just pass all values from all source Observables in a single array.</p></div><p class="calibre8">The output in the console will look as follows:</p><pre class="programlisting">
<span class="strong"><strong class="calibre17">$ php switch_latest_01.php </strong></span>
<span class="strong"><strong class="calibre17">12:18:32 [] onNext: [1,2] (array)</strong></span>
<span class="strong"><strong class="calibre17">12:18:32 [] onNext: [1,2] (array)</strong></span>
<span class="strong"><strong class="calibre17">12:18:33 [] onNext: [1,2,3] (array)</strong></span>
<span class="strong"><strong class="calibre17">12:18:34 [] onNext: [1,2,3] (array)</strong></span>
<span class="strong"><strong class="calibre17">12:18:34 [] onNext: [1,2,3,4] (array)</strong></span>
<span class="strong"><strong class="calibre17">12:18:35 [] onNext: [1,2,3,4,5] (array)</strong></span>
<span class="strong"><strong class="calibre17">12:19:25 [] onNext: [1,2,3,4,5] (array)</strong></span>
<span class="strong"><strong class="calibre17">12:19:26 [] onNext: [1,2,3,4,5,6] (array)</strong></span>
<span class="strong"><strong class="calibre17">22:54:16 [] onCompleted</strong></span>
</pre><p class="calibre8">The following is the timestamped order of events in this example:</p><div class="book"><ul class="itemizedlist"><li class="listitem"><code class="literal">1000</code> ms: The <code class="literal">$newServerTrigger</code> Observable fires for the first time and appends the second item to the <code class="literal">$range</code> array. The operator <code class="literal">combineLatest()</code> is now subscribed to two Observables created with <code class="literal">Observable::just()</code>. Since these are both cold, the <code class="literal">combineLatest()</code> re-emits their values immediately because it already has a value for each of them.</li><li class="listitem"><code class="literal">1200</code> ms: The <code class="literal">$statusUpdate</code> Observable fires (it's a hot Observable thanks to <code class="literal">publish()</code> and <code class="literal">connect()</code>, so it was emitting the event even though we weren't subscribed to it). This makes <code class="literal">combineLatest()</code> fire again.</li><li class="listitem"><code class="literal">1800</code> ms: The <code class="literal">$statusUpdate</code> Observable fires yet again, which makes <code class="literal">combineLatest()</code> emit for the third time. We get the same result as before because there're still only two Observables at this moment.</li><li class="listitem"><code class="literal">2000</code> ms: The <code class="literal">$newServerTrigger</code> Observable fires and appends a new item to <code class="literal">$range</code>. Now the <code class="literal">combineLatest()</code> operator subscribes to three Observables.</li></ul></div><p class="calibre8">This goes on until we collect eight emissions in total (thanks to the <code class="literal">take(8)</code> operator). This was a really practical example of higher-order Observables in action.</p><p class="calibre8">We can reimplement it with the Server Manager application now:</p><pre class="programlisting">class ServerManager extends Command { 
  // ... 
  protected function execute($input, $output) { 
    // ... 
    $this-&gt;statusSubject 
      -&gt;map(function() { 
        $observables = array_map(function($server) { 
          /** @var GameServerStreamEndpoint $server */ 
          return $server-&gt;getStatus(); 
        }, $this-&gt;servers); 
 
        return Observable::just(true) 
          -&gt;combineLatest($observables, function($array) { 
            $values = func_get_args(); 
            array_shift($values); 
            return $values; 
          }); 
      }) 
      -&gt;switchLatest() 
      -&gt;map(function($statuses) { 
        $updatedStatuses = []; 
        $ports = array_keys($this-&gt;servers); 
        foreach ($statuses as $index =&gt; $status) { 
          $updatedStatuses[$ports[$index]] = $status; 
        } 
        return $updatedStatuses; 
      }) 
      -&gt;subscribeCallback(function($statuses) use ($output) { 
        $output-&gt;write(sprintf("\033\143")); // clean screen 
        foreach ($statuses as $port =&gt; $status) { 
          $str = sprintf("%d: %s", $port, $status); 
          $output-&gt;writeln($str); 
        } 
      }); 
 
    // ... 
  } 
} 
</pre><p class="calibre8">This is exactly the same chain of operators, just a little enhanced by adding port numbers for each status.</p><p class="calibre8">When we add a new server in the <code class="literal">addServer()</code> method, we trigger <code class="literal">$statusSubject</code>, which recreates the array of Observables with statuses. Then, when the status of any of the servers is updated, it triggers <code class="literal">combineLatest()</code> directly because that's the only subscriber for them.</p><p class="calibre8">Now it should also make sense why we used <code class="literal">ReplaySubject</code> when writing <code class="literal">GameServerStreamEndpoint</code>. When we resubscribe to already existing status Observables, we want to have at latest one value always available, so that <code class="literal">combineLatest()</code> doesn't have to wait until all of its source Observables emit a value. They already did thanks to <code class="literal">ReplaySubject</code>, which emits the latest value right on subscription.</p><p class="calibre8">We can test how this works by running the <code class="literal">ServerManager.php</code> script. The <code class="literal">GameServer</code> instances will periodically emit values with <code class="literal">IntervalObservable</code> now, so we should already be getting status updates.</p><p class="calibre8">So let's start the <code class="literal">ServerManager.php</code> application:</p><pre class="programlisting">
<span class="strong"><strong class="calibre17">$ php ServerManager.php manager ./var/server.sock</strong></span>
<span class="strong"><strong class="calibre17">Listening on socket ./var/server.sock</strong></span>
<span class="strong"><strong class="calibre17">Running ...</strong></span>
</pre><p class="calibre8">This command takes a path to the Unix socket file as an argument. It automatically passes this file path to all subprocesses so they know where they should try to connect. Now, we can press <span class="strong"><em class="calibre18">n</em></span> characters followed by the <span class="strong"><em class="calibre18">
<span class="strong"><strong class="calibre17">Enter</strong></span>
</em></span> key to spawn a couple of subprocesses. Each subprocess first sends the <code class="literal">ready</code> status and then starts emitting values from the <code class="literal">IntervalObservable</code> class.</p><p class="calibre8">The output could look like the following:</p><pre class="programlisting">
<span class="strong"><strong class="calibre17">8888: 28</strong></span>
<span class="strong"><strong class="calibre17">8889: 15</strong></span>
<span class="strong"><strong class="calibre17">8890: 14</strong></span>
<span class="strong"><strong class="calibre17">8891: ready</strong></span>
</pre><p class="calibre8">Then you can press <span class="strong"><em class="calibre18">
<span class="strong"><strong class="calibre17">Q</strong></span>
</em></span> followed by the <span class="strong"><em class="calibre18">
<span class="strong"><strong class="calibre17">Enter</strong></span>
</em></span> key to gracefully quit the application.</p><div class="informaltable" title="Note"><h3 class="title1"><a id="note40" class="calibre1"/>Note</h3><p class="calibre8">Notice that we used the operator chain <code class="literal">map(callback)-&gt;switchLatest()</code>. This combination of operators has a shortcut <code class="literal">flatMapLatest(callback)</code>. However, to make our code more explicit we'll typically use the longer and more obvious variant.</p></div><p class="calibre8">Finally, we can implement the WebSocket server and client.</p></div></div></div>
<div class="book" title="Implementing a WebSocket server" id="1NA0K1-bd355a22cf10407cb10df27e65585b8d"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch07lvl1sec50" class="calibre1"/>Implementing a WebSocket server</h1></div></div></div><p class="calibre8">To implement a WebSocket server, we'll use a library called <code class="literal">cboden/ratchet</code>:</p><pre class="programlisting">
<span class="strong"><strong class="calibre17">$ composer require cboden/ratchet</strong></span>
</pre><p class="calibre8">A WebSocket server is represented by a class implementing the <code class="literal">MessageComponentInterface</code> interface with four methods <code class="literal">onOpen()</code>, <code class="literal">onClose()</code>, <code class="literal">onError()</code>, and <code class="literal">onMessage()</code>. How this class behaves on each of the events is up to the developer. Usually in chat applications, we want to keep all active connections in an array of clients and read messages, with <code class="literal">onMessage()</code> to resend them to all clients.</p><p class="calibre8">We'll first implement only the required methods and then add some custom ones as well:</p><pre class="programlisting">// ChatServer.php 
use Ratchet\MessageComponentInterface; 
use Ratchet\ConnectionInterface; 
 
class ChatServer implements MessageComponentInterface { 
  private $connections; 
  private $history = []; 
  private $subject; 
 
  public function __construct() { 
    $this-&gt;subject = new Subject(); 
  } 
 
  public function onOpen(ConnectionInterface $conn) { 
    $this-&gt;connections[] = $conn; 
    foreach (array_slice($this-&gt;history, -5, 5) as $msg) { 
      $conn-&gt;send($msg); 
    } 
    $this-&gt;subject-&gt;onNext(null); 
  } 
 
  public function onMessage(ConnectionInterface $from, $msg) { 
    $this-&gt;history[] = $msg; 
    foreach ($this-&gt;connections as $conn) { 
      if ($from !== $conn) { 
        $conn-&gt;send($msg); 
      } 
    } 
    $this-&gt;subject-&gt;onNext(null); 
  } 
 
  public function onClose(ConnectionInterface $conn) { 
    foreach ($this-&gt;connections as $index =&gt; $client) { 
      if ($conn !== $client) { 
        unset($this-&gt;connections[$index]); 
      } 
    } 
    $this-&gt;subject-&gt;onNext(null); 
  } 
 
  public function onError(ConnectionInterface $conn, $e) { 
    $this-&gt;onClose($conn); 
  } 
} 
</pre><p class="calibre8">It should be obvious what this code does without any further explanation. Just note that we're using <code class="literal">$subject</code> to signal that its status has changed and needs to be sent to the Server Manager via Unix sockets.</p><p class="calibre8">Now we can add more methods. In particular, we'll need <code class="literal">getObservable()</code>, where we'll subscribe to be notified with the current statuses:</p><pre class="programlisting">class ChatServer implements MessageComponentInterface { 
  // ... 
  public function getObservable() { 
    return $this-&gt;subject 
      -&gt;map(function() { 
        return sprintf('clients: %d, messages: %d', 
          $this-&gt;getClientsCount(), 
          $this-&gt;getChatHistoryCount() 
        ); 
      }); 
  } 
 
  private function getClientsCount() { 
    return count($this-&gt;connections); 
  } 
 
  private function getChatHistoryCount() { 
    return count($this-&gt;history); 
  } 
} 
</pre><p class="calibre8">This class itself isn't enough to start a WebSocket server.</p><p class="calibre8">The WebSocket connection is first established as a normal HTTP connection, and then it's upgraded to a WebSocket connection.</p><p class="calibre8">Back in the <code class="literal">GameServer</code> class, we subscribe to the Observable returned from the <code class="literal">getObservable()</code> method to be notified when the status for this chat server changes and needs to be sent to the Server Manager. The status of the chat server is represented by the current number of clients and the total number of messages in the chat history:</p><pre class="programlisting">class GameServer extends Command { 
  // ... 
  protected function execute($input, $output) { 
    // ... 
    $webSocketServer = new ChatServer(); 
    $socket = new Reactor($loop); 
    $socket-&gt;listen($port, '0.0.0.0'); 
    $server = new IoServer( 
      new HttpServer(new WsServer($webSocketServer)), 
      $socket, 
      $loop 
    ); 
 
    $webSocketServer-&gt;getObservable() 
      -&gt;subscribeCallback(function($status) { 
        $this-&gt;streamObservable-&gt;send('status', $status); 
      }); 
 
    $server-&gt;run(); 
  } 
} 
</pre><p class="calibre8">When we're already in the <code class="literal">GameServer</code> class, we can see how to use backpressure in practice. With multiple Game Servers, where each is emitting values multiple times a second, we might want to use <code class="literal">ThrottleTimeOperator</code> to limit emissions via the Unix socket stream:</p><pre class="programlisting">Observable::interval(500, $scheduler) 
  -&gt;lift(function() { 
    return new ThrottleTimeOperator(2000); 
  }) 
  -&gt;subscribeCallback(function($counter) { 
    $this-&gt;streamObservable-&gt;send('status', $counter); 
  }); 
</pre><p class="calibre8">Now, each <code class="literal">GameServer</code> class will send its status at most once every two seconds. In a real-world application, we'll obviously not use <code class="literal">IntervalObservable</code>, and leave emitting statuses to <code class="literal">$webSocketServer-&gt;getObservable()</code>. Either way, the use of backpressure and <code class="literal">ThrottleTimeOperator</code> remains the same.</p></div>
<div class="book" title="Implementing a WebSocket client" id="1O8H61-bd355a22cf10407cb10df27e65585b8d"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch07lvl1sec51" class="calibre1"/>Implementing a WebSocket client</h1></div></div></div><p class="calibre8">To implement a WebSocket client, we're going to use another PHP library called <code class="literal">ratchet/pawl</code>:</p><pre class="programlisting">
<span class="strong"><strong class="calibre17">$ composer require ratchet/pawl 0.2.2
</strong></span>
</pre><p class="calibre8">The client will read input from <code class="literal">php://stdin</code> and send it via WebSocket to the server. It'll also watch for any incoming messages and print them to the console:</p><pre class="programlisting">// GameClient.php 
use function Ratchet\Client\connect; 
 
class GameClient extends Command { 
  protected function configure() { 
    $this-&gt;setName('chat-client'); 
    $this-&gt;addArgument('port', InputArgument::REQUIRED); 
    $this-&gt;addArgument('address', InputArgument::OPTIONAL, 
      '', '127.0.0.1'); 
  } 
 
  protected function execute($input, $output) { 
    $port = $input-&gt;getArgument('port'); 
    $address = $input-&gt;getArgument('address'); 
 
    $stdin = fopen('php://stdin', 'r'); 
    $loop = new StreamSelectLoop(); 
 
    connect('ws://' . $address . ':' . $port, [], [], $loop) 
      -&gt;then(function($conn) use ($loop, $stdin, $output) { 
        $loop-&gt;addReadStream($stdin,  
          function($stream) use ($conn, $output) { 
            $str = trim(fgets($stream, 1024)); 
            $conn-&gt;send($str); 
            $output-&gt;writeln("&gt; ${str}"); 
          }); 
 
          $conn-&gt;on('message', function($str) use ($conn,$output){ 
            $output-&gt;writeln("&lt; ${str}"); 
          }); 
        }, function ($e) use ($output) { 
            $msg = "Could not connect: {$e-&gt;getMessage()}"; 
            $output-&gt;writeln($msg); 
        }); 
  } 
} 
</pre><p class="calibre8">The WebSocket client is created using the <code class="literal">connect()</code> function, where, as a protocol, we use <code class="literal">ws</code>. This method returns a Promise that's resolved with the WebSocket connection object when the connection is established or otherwise rejected. This function also requires an event loop where we have to provide our single instance of <code class="literal">StreamSelectLoop</code>. The same event loop is used to read from the <code class="literal">fopen()</code> stream.</p><p class="calibre8">If we didn't provide the event loop directly, the <code class="literal">connect()</code> function would create its own instance internally. This loop would cause exactly what we described in the previous chapter, and the inner loop reading from the <code class="literal">php://stdin</code> stream would never run.</p><p class="calibre8">We also use this connection object to set up event listeners with the <code class="literal">on()</code> method and to send data to the server with the <code class="literal">send()</code> method. All sent messages are prefixed with <code class="literal">&gt;</code>, while all received messages are prefixed with <code class="literal">&lt;</code>.</p><p class="calibre8">Now we can use this client to test the real usage of the Server Manager. If we run three instances of <code class="literal">GameClient</code> and send some example messages, the output might look like the following:</p><pre class="programlisting">
<span class="strong"><strong class="calibre17">$ php GameClient.php chat-client 8890</strong></span>
<span class="strong"><strong class="calibre17">Hello, World!</strong></span>
<span class="strong"><strong class="calibre17">&gt; Hello, World!</strong></span>
<span class="strong"><strong class="calibre17">&lt; Test!</strong></span>
</pre><p class="calibre8">Then, monitoring real-time statuses might look like this:</p><pre class="programlisting">
<span class="strong"><strong class="calibre17">8888: ready</strong></span>
<span class="strong"><strong class="calibre17">8889: clients: 1, messages: 0</strong></span>
<span class="strong"><strong class="calibre17">8890: clients: 1, messages: 2</strong></span>
<span class="strong"><strong class="calibre17">8891: ready</strong></span>
</pre><p class="calibre8">Any new WebSocket client or any new message causes an immediate update to this overview.</p></div>
<div class="book" title="Summary" id="1P71O1-bd355a22cf10407cb10df27e65585b8d"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch07lvl1sec52" class="calibre1"/>Summary</h1></div></div></div><p class="calibre8">This chapter was really code intensive, with a lot of examples based on using Unix sockets and WebSockets. We also utilized a lot of what we've learned in this and the previous chapter, including higher-order Observables, with <code class="literal">swtichLatest()</code> and <code class="literal">combineLatest()</code>, backpressure and which operators we can use, using event loops with multiple streams, and using the <code class="literal">multicast()</code> operator to share a single subscription among multiple observers.</p><p class="calibre8">In the next chapter, we'll have a look at multicasting in Rx and start using the <code class="literal">pthreads</code> PHP extension to leverage true parallelism with threads that would normally be hardly achievable.</p></div></body></html>