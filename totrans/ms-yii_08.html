<html><head></head><body>
<div id="page" style="height:0pt"/><div class="book" title="Chapter&#xA0;8.&#xA0;Routing, Responses, and Events"><div class="book" id="1CQAE2-ad3e09b384df46aea690d9c8897d5fe7"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch08" class="calibre1"/>Chapter 8. Routing, Responses, and Events</h1></div></div></div><p class="calibre9">Like many modern web frameworks, Yii2 is built with a powerful router component, which we can utilize to handle a variety of URIs coming from both our end users and application. This functionality is further enhanced by Yii2's powerful request and response handlers, which we can use to manipulate request and response bodies. In this chapter, we'll cover the basics of how to manipulate Yii2's URL Manager to adjust routes, explore how to configure Yii2 to respond in different ways, and learn how to send and listen to events within our application.</p></div>

<div class="book" title="Chapter&#xA0;8.&#xA0;Routing, Responses, and Events">
<div class="book" title="Routing"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_1"><a id="ch08lvl1sec41" class="calibre1"/>Routing</h1></div></div></div><p class="calibre9">As mentioned in<a id="id410" class="calibre1"/> previous chapters, routing within Yii2 is managed by the UrlManager component defined in our application configuration. The router in Yii2 is responsible for determining where Yii2 routes external URI requests to internal controllers and actions. In <a class="calibre1" title="Chapter 5. Modules, Widgets, and Helpers" href="part0035_split_000.html#11C3M2-ad3e09b384df46aea690d9c8897d5fe7">Chapter 5</a>, <span class="strong"><em class="calibre13">Modules, Widgets, and Helpers</em></span>, we covered the basics of how to create and manipulate URL routes with the <code class="email">yii\helpers\Url</code> helper. In this section, we'll cover how Yii2 routes these requests inside our application by exploring Yii2's UrlManager in more detail.</p><p class="calibre9">Routing in Yii2 can be broken down into two basic steps. The first of these steps is to parse the incoming request and query parameters (which are stored in the <code class="email">GET</code> parameters of our request with the <code class="email">r</code> parameter by default but can be retrieved from the request URI if we have pretty URLs enabled). The second step is to create an instance of the corresponding controller action, which will ultimately handle the request.</p><p class="calibre9">By default, Yii2 will break the route down in the forward slashes of the URL to map it to the appropriate module, controller, and action pair. For instance, the site/login route will match the <code class="email">site</code> controller and the action named <code class="email">login</code> in the default module of the application instance. Internally, Yii2 will take the following steps to route the request:</p><div class="book"><ol class="orderedlist"><li class="listitem" value="1">By default, Yii2 will set the current module as the application.</li><li class="listitem" value="2">Examine the controller map of the application to see whether it contains the current route. If so, a controller instance will be created according to the controller<a id="id411" class="calibre1"/> map defined within the module, at which point, the action will be created according to the action map defined in step <span class="strong"><em class="calibre13">4</em></span>. By default, Yii2 will create a controller map based upon the controllers found within the <code class="email">@app/controllers</code> folder, but this may be customized within the module (or UrlManager):<div class="note"><pre class="programlisting">yii\base\Module::$controllerMap = [
  'account' =&gt; 'app\controllers\UserController',
  // Different syntax for the previous example
  //'account' =&gt; [
  //   'class' =&gt; 'app\controllers\AccountController'
  //],
]</pre></div></li><li class="listitem" value="3">If the controller map of the application module is found not within the application module, Yii2 will iterate through the module list in the <code class="email">module</code> property of the application module to see if a route matches there. If a module is found, Yii2 will instantiate the module using the provided configuration and then create the controller using the details outlined in the previous step.</li><li class="listitem" value="4">Yii2 will then look for the action within the action map defined in the module's configuration. If found, it will create an action according to that configuration; otherwise, it will attempt to create an inline action defined in the <code class="email">action</code> method corresponding to the given action.</li></ol><div class="calibre15"/></div><p class="calibre9">If an error occurs at any point during this process, Yii2 will throw <code class="email">yii\web\NotFoundHttpException</code>.</p></div></div>

<div class="book" title="Chapter&#xA0;8.&#xA0;Routing, Responses, and Events">
<div class="book" title="Routing">
<div class="book" title="Default and catch all routes"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_2"><a id="ch08lvl2sec87" class="calibre1"/>Default and catch all routes</h2></div></div></div><p class="calibre9">When<a id="id412" class="calibre1"/> Yii2 receives a request that is parsed into an empty route, the<a id="id413" class="calibre1"/> default route will be used instead. The default route is set to <code class="email">site/index</code>, which references the <code class="email">index</code> action of the <code class="email">site</code> controller. This behavior can be changed by setting the <code class="email">defaultRoute</code> property of the <code class="email">application</code> component, as follows:</p><div class="note"><pre class="programlisting">[
    // index action of main controller
    'defaultRoute' =&gt; 'main/index' 
]</pre></div><p class="calibre9">Additionally, Yii2 can be configured to forward all requests to a single route by setting the <code class="email">catchAll</code> property of <code class="email">yii\web\application</code>. This can be beneficial when you need to <a id="id414" class="calibre1"/>perform <a id="id415" class="calibre1"/>application maintenance.</p><div class="note"><pre class="programlisting">[
    // Display a maintenance message
    'catchAll' =&gt; 'site/maintenance'
]</pre></div></div></div></div>

<div class="book" title="Chapter&#xA0;8.&#xA0;Routing, Responses, and Events">
<div class="book" title="Routing">
<div class="book" title="Custom routes and URL rules"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_3"><a id="ch08lvl2sec88" class="calibre1"/>Custom routes and URL rules</h2></div></div></div><p class="calibre9">Rather<a id="id416" class="calibre1"/> than relying upon the default controller/action routes Yii2<a id="id417" class="calibre1"/> internally generates, custom URL rules can be written to define our own URL routes. URL routes in Yii2 are implemented by an instance of <code class="email">yii\web\UrlRule</code>, and they consist of a pattern used to patch the path information and query parameters of a given route. When using custom URL rules, Yii2 will route a request to the first matching rule for the accompanying request. Moreover, the matching rule determines how the request parameters are split up. Additionally, using the <code class="email">yii\helpers\Url</code> helper will also rely upon the list rules to internally route requests.</p><p class="calibre9">URL rules in Yii2 can be defined in our application configuration by setting the <code class="email">yii\web\UrlManager:$rules</code> property as an array, with a key containing the URL pattern to be matched and the value being the corresponding route. For example, supposing we had a controller to manage published content, we could write custom rules, as follows, to route <code class="email">posts</code> and <code class="email">post</code> to our content:</p><div class="note"><pre class="programlisting">[
    'posts' =&gt; 'content/index', 
    'post/&lt;id:\d+&gt;' =&gt; 'content/view',
]</pre></div><p class="calibre9">Now when navigating to the <code class="email">/posts</code> endpoint of our application, the content/index controller action pair will be triggered. As shown in the previous example, URL rules can extend beyond simple strings and can contain complex regular expressions, which we can use to conditionally route rules. In the previous example, a route to the <code class="email">/post</code> endpoint followed by an integer ID will route to the content/view controller action pair. Moreover, Yii2 will automatically pass the <code class="email">$id</code> parameter to the action:</p><div class="note"><pre class="programlisting">class ContentController extends yii\web\Controller
{
    // Responds to content/index and /posts
    public function actionIndex() {}

    // Responds to content/view/id/&lt;id&gt; or /post/&lt;id&gt;
    public function actionView($id) {}
}</pre></div><div class="note" title="Note"><h3 class="title2"><a id="tip134" class="calibre1"/>Tip</h3><p class="calibre9">Regular expressions can only be specified for parameters. However, as we'll see later in this section, we can parameterize our routes to make the controller and action more dynamic.</p></div><p class="calibre9">These<a id="id418" class="calibre1"/> regular expressions can be further customized to include more <a id="id419" class="calibre1"/>complex routes. For instance, adding the following to our URL routes would enable us to pass additional information to our content/index action, such as the year, month, and the day we want to show published entries for.</p><div class="note"><pre class="programlisting">// Creates a route that includes the year, month, and date of a post
// eg: https://www.example.com/posts/2015/09/01
[
'posts/&lt;year:\d{4}&gt;/&lt;month:\d{2}&gt;/&lt;day:\d{2}&gt;' =&gt; 'content/index',
]</pre></div><p class="calibre9">As you may expect from the expression, this route will only match four-digit years and two-digit months and days. Moreover, as mentioned previously, by adding this information to our URL rules, the <code class="email">yii\helper\Url</code> helper will understand any URL created with this pattern:</p><div class="note"><pre class="programlisting">// Routes to posts/2014/09/01
Url::to(['posts/index', 'year' =&gt; 2015, 'month' =&gt; 09, 'day' =&gt; 01]);</pre></div><p class="calibre9">URL routes can also be defined to route domain names and schemes. For instance, the following routes can be written to ensure that different domain names route to different parts of the site:</p><div class="note"><pre class="programlisting">[
    'https://dashboard.example.com/login' =&gt; 'dashboard/default/login',
    'https://www.example.com/login' =&gt; 'site/login'
]</pre></div><p class="calibre9">This is beneficial when handling multiple frontend applications within the same codebase.</p><div class="book" title="Parameterizing routes"><div class="book"><div class="book"><div class="book"><h3 class="title2"><a id="ch08lvl3sec44" class="calibre1"/>Parameterizing routes</h3></div></div></div><p class="calibre9">In addition<a id="id420" class="calibre1"/> to named parameters, as described in the previous section, parameters can also be embedded within the URL rule itself. This approach enables Yii2 to match a single rule to multiple routes, which can greatly reduce the number of URL rules and, consequently, the performance of your router. Take, for instance, the following route:</p><div class="note"><pre class="programlisting">[
    '&lt;controller:(content|comment)&gt;/&lt;id:\d+&gt;/&lt;action:(create|list|delete)&gt;' =&gt; '&lt;controller&gt;/&lt;action&gt;',
]</pre></div><p class="calibre9">This route will match both the content and comment controller with a given ID for the create, list, and delete actions and pass it to the appropriate action. In order for a route to match, however, all named parameters must be defined. If a given route does not contain the given parameters, Yii2 will fail to match the route, which will most likely result in the route hitting a 404 error. One way to get around this limitation is to provide default parameters for the routes, as shown in the following example:</p><div class="note"><pre class="programlisting">[
    // ...other rules...
    [
        // :\d+ is a regular expression for integers
        'pattern' =&gt; 'content/&lt;page:\d+&gt;/&lt;name&gt;',
        'route' =&gt; 'content/index',
        'defaults' =&gt; ['page' =&gt; 1, 'name' =&gt; NULL],
    ],
]</pre></div><p class="calibre9">In this example, <code class="email">page</code> will default to <code class="email">1</code>, and <code class="email">name</code> will default to <code class="email">NULL</code>. This URL rule can match multiple routes. In this specific instance, several routes will be matched:</p><div class="book"><ul class="itemizedlist"><li class="listitem"><code class="email">/content, page=1, name=NULL</code></li><li class="listitem"><code class="email">/content/215, page=215, name=NULL</code></li><li class="listitem"><code class="email">/content/215/foo, page=215, name=foo</code></li><li class="listitem"><code class="email">/content/foo, page=1, name=foo</code></li></ul></div></div><div class="book" title="URL suffixes"><div class="book"><div class="book"><div class="book"><h3 class="title2"><a id="ch08lvl3sec45" class="calibre1"/>URL suffixes</h3></div></div></div><p class="calibre9">As an<a id="id421" class="calibre1"/> alternative to declaring a key-value pair for a URL route, routes can be defined as an array of key-value pairs containing the pattern, route, and even a custom URL suffix to specifically respond to.</p><div class="note"><pre class="programlisting">[
    [
        'pattern' =&gt; 'posts',
        'route' =&gt; 'content/index',
        'suffix' =&gt; '.xml',
    ],
]</pre></div><p class="calibre9">These<a id="id422" class="calibre1"/> routes can be used to configure your application to respond to certain types of requests in different formats.</p><div class="note" title="Note"><h3 class="title2"><a id="tip135" class="calibre1"/>Tip</h3><p class="calibre9">By default, rules created this way will be created as an instance of <code class="email">yii\web\UrlRule</code>, but they can be changed by defining the <code class="email">class</code> parameter.</p></div></div><div class="book" title="HTTP method-specific URL rules"><div class="book"><div class="book"><div class="book"><h3 class="title2"><a id="ch08lvl3sec46" class="calibre1"/>HTTP method-specific URL rules</h3></div></div></div><p class="calibre9">At <a id="id423" class="calibre1"/>times, you may find it beneficial to route different types of HTTP methods to the same route but handle them in different actions. In Yii2, this can be achieved by prefixing the method types before the route key, as shown in the following example:</p><div class="note"><pre class="programlisting">[
    'PUT,POST users/&lt;id:\d+&gt;' =&gt; 'users/create',
    'DELETE users/&lt;id:\d+&gt;' =&gt; 'users/delete',
    'GET users/&lt;id:\d+&gt;' =&gt; 'users/view',
]</pre></div><p class="calibre9">From an API perspective, all requests will ultimately route to <code class="email">users/&lt;id&gt;</code>, but depending upon the HTTP method, a different action will be executed.</p><div class="note" title="Note"><h3 class="title2"><a id="tip136" class="calibre1"/>Tip</h3><p class="calibre9">URL rules with specified HTTP methods will only be used for routing purposes, and they won't be used to create URLs such as when using <code class="email">yii\helper\Url</code>.</p></div></div></div></div></div>

<div class="book" title="Chapter&#xA0;8.&#xA0;Routing, Responses, and Events">
<div class="book" title="Routing">
<div class="book" title="Custom URL rule classes"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_4"><a id="ch08lvl2sec89" class="calibre1"/>Custom URL rule classes</h2></div></div></div><p class="calibre9">While <code class="email">yii\web\Url</code> is<a id="id424" class="calibre1"/> extremely flexible, and it should cover the majority of use cases you need for a URL rule, often there are times when a custom URL may be required. For instance, a publisher may want to support a format to represent authors and books, such as <code class="email">/Author/Book</code>, where both <code class="email">Author</code> and <code class="email">Book</code> are data retrieved from the database. Custom URL rules in Yii2 can be created to solve this<a id="id425" class="calibre1"/> problem by extending <code class="email">yii\base\Object</code> and implementing <code class="email">yii\web\UrlRuleInterface</code>, as shown in the following example:</p><div class="note"><pre class="programlisting">&lt;?php

namespace app\components;

use yii\web\UrlRuleInterface;
use yii\base\Object;

class BookUrlRule extends Object implements UrlRuleInterface
{

    public function createUrl($manager, $route, $params)
    {
        if ($route === 'book/index')
        {
            if (isset($params['author'], $params['book']))
                return $params['author'] . '/' . $params['book'];
            else if (isset($params['author']))
                return $params['author'];
        }
        return false;
    }

    public function parseRequest($manager, $request)
    {
        $pathInfo = $request-&gt;getPathInfo();
        if (preg_match('%^(\w+)(/(\w+))?$%', $pathInfo, $matches))
        {
            // If the parameterized identified in $matches[] matches a database value
            // Set $params['author'] and $params['book'] to those attributes, then pass
            // those arguments to your route
            // return ['author/index', $params]
        }
        
        return false;
    }
}</pre></div><p class="calibre9">Our custom rule can then be implemented within our <code class="email">yii\web\UrlManager::$rules</code> section<a id="id426" class="calibre1"/> by declaring our desire to use that class:</p><div class="note"><pre class="programlisting">[
    // [...],
    [
        // Reuslts in URL's like https://www.example.com/charlesportwodii/mastering-yii
        'class' =&gt; 'app\components\BookUrlRule'
    ],
    // [...],
]</pre></div></div></div></div>

<div class="book" title="Chapter&#xA0;8.&#xA0;Routing, Responses, and Events">
<div class="book" title="Routing">
<div class="book" title="Dynamic rule generation"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_5"><a id="ch08lvl2sec90" class="calibre1"/>Dynamic rule generation</h2></div></div></div><p class="calibre9">Rules can be programmatically and dynamically added to your application in several different <a id="id427" class="calibre1"/>ways. Dynamic rule generation can take the form of a custom URL rule class, as outlined in the previous section, or a custom URL manager. The simplest way to add new URL rules dynamically, however, is to use the <code class="email">addRules()</code> method of the URL Manager. For rules to take effect, they need to occur early in the bootstrapping process of the application. For modules to dynamically add new rules, they should implement <code class="email">yii\base\BootstrapInterface</code> and add the custom URL rules in the <code class="email">bootstrap()</code> method, as shown in the following example:</p><div class="note"><pre class="programlisting">public function bootstrap($app)
{
    $app-&gt;getUrlManager()-&gt;addRules([
        // Add new rules here
    ], false);
}</pre></div><div class="note" title="Note"><h3 class="title2"><a id="tip137" class="calibre1"/>Tip</h3><p class="calibre9">In complex web applications, it's important to monitor how many URL rules you have. Adding many different rules can seriously degrade the performance of your application as Yii2 needs to iterate over each rule until it finds the first matching rule. Parameterized routes and reducing the number of URL rules can significantly improve the performance of your application.</p></div></div></div></div>

<div id="page" style="height:0pt"/><div class="book" title="Requests"><div class="book" id="1DOR02-ad3e09b384df46aea690d9c8897d5fe7"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch08lvl1sec42" class="calibre1"/>Requests</h1></div></div></div><p class="calibre9">After <a id="id428" class="calibre1"/>handling where we want our request to go, we will often need to write specific logic to handle the details of our HTTP request. To help facilitate this, Yii2 represents the HTTP request within the <code class="email">yii\web\Request</code> object, which can provide a variety of information about the HTTP request, such as the request body, <code class="email">GET</code> and <code class="email">POST</code> parameters, and headers. Each request in Yii2 can be accessed easily through the request application component, which is represented by <code class="email">Yii::$app-&gt;request</code> in our code.</p></div>

<div class="book" title="Requests">
<div class="book" title="Retrieving request parameters and data"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_1"><a id="ch08lvl2sec91" class="calibre1"/>Retrieving request parameters and data</h2></div></div></div><p class="calibre9">The <a id="id429" class="calibre1"/>most common task we'll perform when working with the request object is retrieving <code class="email">GET</code> and <code class="email">POST</code> parameters, which are implemented by <code class="email">yii\web\Request::get()</code> and <code class="email">yii\web\Request::post()</code> respectively. These methods enable us to consistently and safely access the <code class="email">$_GET</code> and <code class="email">$_POST</code> parameters of our application:</p><div class="note"><pre class="programlisting">$request = \Yii::$app-&gt;request;

// Retrieve all of the $_GET parameters
// similar to $get = $_GET
$get = $request-&gt;get();
// Retrieve all of the $_POST parameters
$post = $request-&gt;post();</pre></div><p class="calibre9">Unlike the native <code class="email">$_GET</code> and <code class="email">$_POST</code> PHP global variables, however, Yii2's request object allows us to safely access named parameters, as shown in the next example:</p><div class="note"><pre class="programlisting">// Retrieves the name $_GET parameter, $_GET['id']
// https://www.example.com/controller/action/id/5
// https://www.example.com/controller/action?id=5
$id = $request-&gt;get('id');

// Retrieves the named $_POST parameter
$name = $request-&gt;post('name');</pre></div><p class="calibre9">If the parameters are not defined, Yii2 will return <code class="email">NULL</code> by default. This behavior can be modified by setting the second parameter of both <code class="email">yii\web\Request::get()</code> and <code class="email">yii\web\Request::post()</code>:</p><div class="note"><pre class="programlisting">// Default to 1 if ID is not set
$id = $request-&gt;get('id', 1);

// Default to 'Guest' if name is not set
$name = $request-&gt;post('name', 'Guest');</pre></div><div class="note" title="Note"><h3 class="title2"><a id="tip138" class="calibre1"/>Tip</h3><p class="calibre9">In addition to providing safe access to the <code class="email">$_GET</code> and <code class="email">$_POST</code> data, the request object can also be easily mocked when running tests. We'll cover how to work with tests and mocking data in <a class="calibre1" title="Chapter 10. Testing with Codeception" href="part0060_split_000.html#1P71O1-ad3e09b384df46aea690d9c8897d5fe7">Chapter 10</a>, <span class="strong"><em class="calibre13">Testing with Codeception</em></span>.</p></div><p class="calibre9">As an<a id="id430" class="calibre1"/> added convenience, Yii2 provides us with the ability to determine the type of request we're working with, such as a <code class="email">GET</code>, <code class="email">POST</code>, or <code class="email">PUT</code> request. The easiest way to determine the request type is to query <code class="email">\Yii::$app-&gt;request-&gt;method</code>, which will return the HTTP method type (such as <code class="email">GET</code>, <code class="email">PUT</code>, <code class="email">POST</code>, <code class="email">DELETE</code>, and so on). Alternatively, we can conditionally check the request by querying<a id="id431" class="calibre1"/> one of the request objects of many Boolean options, as shown in the following table:</p><div class="note"><table border="1" class="calibre16"><colgroup class="calibre17"><col class="calibre18"/><col class="calibre18"/></colgroup><thead class="calibre19"><tr class="calibre20"><th valign="bottom" class="calibre21">
<p class="calibre22">Property</p>
</th><th valign="bottom" class="calibre21">
<p class="calibre22">Explanation</p>
</th></tr></thead><tbody class="calibre23"><tr class="calibre20"><td valign="top" class="calibre24">
<p class="calibre22">
<code class="literal">yii\web\Request::$isAjax</code>
</p>
</td><td valign="top" class="calibre24">
<p class="calibre22">If the request is an AJAX (<code class="literal">XMLHTTPRequest</code>) request</p>
</td></tr><tr class="calibre20"><td valign="top" class="calibre24">
<p class="calibre22">
<code class="literal">yii\web\Request::$isConsoleRequest</code>
</p>
</td><td valign="top" class="calibre24">
<p class="calibre22">If the request is being made from the console</p>
</td></tr><tr class="calibre20"><td valign="top" class="calibre24">
<p class="calibre22">
<code class="literal">yii\web\Request::$isDelete</code>
</p>
</td><td valign="top" class="calibre24">
<p class="calibre22">If the request is an <code class="literal">HTTP DELETE</code> request</p>
</td></tr><tr class="calibre20"><td valign="top" class="calibre24">
<p class="calibre22">
<code class="literal">yii\web\Request::$isFlash</code>
</p>
</td><td valign="top" class="calibre24">
<p class="calibre22">If the request originated from Adobe Flex or Adobe Flash.</p>
</td></tr><tr class="calibre20"><td valign="top" class="calibre24">
<p class="calibre22">
<code class="literal">yii\web\Request::$isGet</code>
</p>
</td><td valign="top" class="calibre24">
<p class="calibre22">If the request is an <code class="literal">HTTP GET</code> request</p>
</td></tr><tr class="calibre20"><td valign="top" class="calibre24">
<p class="calibre22">
<code class="literal">yii\web\Request::$isHead</code>
</p>
</td><td valign="top" class="calibre24">
<p class="calibre22">If the request is an <code class="literal">HTTP HEAD</code> request</p>
</td></tr><tr class="calibre20"><td valign="top" class="calibre24">
<p class="calibre22">
<code class="literal">yii\web\Request::$isOptions</code>
</p>
</td><td valign="top" class="calibre24">
<p class="calibre22">If the request is an <code class="literal">HTTP OPTIONS</code> request</p>
</td></tr><tr class="calibre20"><td valign="top" class="calibre24">
<p class="calibre22">
<code class="literal">yii\web\Request::$isPatch</code>
</p>
</td><td valign="top" class="calibre24">
<p class="calibre22">If the request is an <code class="literal">HTTP PATCH</code> request</p>
</td></tr><tr class="calibre20"><td valign="top" class="calibre24">
<p class="calibre22">
<code class="literal">yii\web\Request::$isPjax</code>
</p>
</td><td valign="top" class="calibre24">
<p class="calibre22">If the request is an <code class="literal">HTTP PJAX</code> request</p>
</td></tr><tr class="calibre20"><td valign="top" class="calibre24">
<p class="calibre22">
<code class="literal">yii\web\Request::$isPost</code>
</p>
</td><td valign="top" class="calibre24">
<p class="calibre22">If the request is an <code class="literal">HTTP POST</code> request</p>
</td></tr><tr class="calibre20"><td valign="top" class="calibre24">
<p class="calibre22">
<code class="literal">yii\web\Request::$isPut</code>
</p>
</td><td valign="top" class="calibre24">
<p class="calibre22">If the request is an <code class="literal">HTTP PUT</code> request</p>
</td></tr><tr class="calibre20"><td valign="top" class="calibre24">
<p class="calibre22">
<code class="literal">yii\web\Request::$isSecureConnection</code>
</p>
</td><td valign="top" class="calibre24">
<p class="calibre22">If the request was made over a secure (HTTPS) connection</p>
</td></tr></tbody></table></div><p class="calibre9">Unlike <code class="email">GET</code> and <code class="email">POST</code> requests sent as forms, many of these requests submit data directly in the<a id="id432" class="calibre1"/> request body. To access this data, we can use <code class="email">yii\web\Request::getBodyParam()</code> and <code class="email">yii\web\Request::getBodyParams()</code>, as shown:</p><div class="note"><pre class="programlisting">$request = Yii::$app-&gt;request;

$allParamns = $request-&gt;bodyParams;

$name = $request-&gt;getBodyParam('name');

$manyParams = $request-&gt;getBodyParams(['name', 'age', 'gender']); </pre></div></div></div>

<div class="book" title="Requests">
<div class="book" title="Request headers and cookies"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_2"><a id="ch08lvl2sec92" class="calibre1"/>Request headers and cookies</h2></div></div></div><p class="calibre9">In <a id="id433" class="calibre1"/>addition to the request body, Yii2's request object can also retrieve header and cookie information sent along with the request. The headers sent along with our request are ultimately represented by <code class="email">yii\web\HeaderCollection</code>, which provides several methods used to work with headers, namely <code class="email">yii\web\HeaderCollection::get()</code> and <code class="email">yii\web\HeaderCollection::has()</code>. In the following example, we're checking whether the <code class="email">X-Auth-Token</code> header is set and then assigning it to the <code class="email">$authToken</code> variable if it is set:</p><div class="note"><pre class="programlisting">// $headers is an object of yii\web\HeaderCollection 
$headers = Yii::$app-&gt;request-&gt;headers;

// If the header has 'X-Auth-Token', retrieve it.
if ($headers-&gt;has('X-Auth-Token'))
    $authToken = $headers-&gt;get('X-Auth-Token');</pre></div><div class="note" title="Note"><h3 class="title2"><a id="tip139" class="calibre1"/>Tip</h3><p class="calibre9">If a<a id="id434" class="calibre1"/> parameter is not provided to the <code class="email">yii\web\HeaderCollection::get()</code> method, an array of all headers will be returned. More details on <code class="email">yii\web\HeaderCollection</code> can be found at <a class="calibre1" href="http://www.yiiframework.com/doc-2.0/yii-web-headercollection.html">http://www.yiiframework.com/doc-2.0/yii-web-headercollection.html</a>.</p></div><p class="calibre9">The request object has several built-in defaults to access some commonly queried headers, namely:</p><div class="book"><ul class="itemizedlist"><li class="listitem"><code class="email">yii\web\Request::$userAgent</code> retrieves the user agent sent by the browser</li><li class="listitem"><code class="email">yii\web\Request::$contentType</code> can be used to determine the appropriate <a id="id435" class="calibre1"/>response type</li><li class="listitem"><code class="email">yii\web\Request::$acceptableContentTypes</code> returns all the acceptable content types that the client will accept</li><li class="listitem"><code class="email">yii\web\Request::$acceptableLanguages</code> can be used if our application is configured to support multiple languages</li></ul></div><div class="note" title="Note"><h3 class="title2"><a id="tip140" class="calibre1"/>Tip</h3><p class="calibre9">The request object can also tell us what the preferred language of the client is through <code class="email">yii\web\Request::getPreferedLanguage()</code>. We'll work more with this variable and general translation and localization in <a class="calibre1" title="Chapter 11. Internationalization and Localization" href="part0068_split_000.html#20R681-ad3e09b384df46aea690d9c8897d5fe7">Chapter 11</a>, <span class="strong"><em class="calibre13">Internationalization and Localization</em></span>.</p></div><p class="calibre9">Alongside our header information, we can also retrieve the cookie data sent with our request by querying <code class="email">Yii::$app-&gt;request-&gt;cookies</code>, which will return an instance of <code class="email">yii\web\CookieCollection</code>, which, as you may suspect, contains many of the same types of methods that <code class="email">yii\web\HeaderCollection</code> provides, such as <code class="email">get()</code> and <code class="email">has()</code>.</p><div class="note" title="Note"><h3 class="title2"><a id="tip141" class="calibre1"/>Tip</h3><p class="calibre9">The <a id="id436" class="calibre1"/>Yii2 API documentation provides a complete set of methods for <code class="email">yii\web\CookieCollection</code> at <a class="calibre1" href="http://www.yiiframework.com/doc-2.0/yii-web-cookiecollection.html">http://www.yiiframework.com/doc-2.0/yii-web-cookiecollection.html</a>.</p></div></div></div>

<div class="book" title="Requests">
<div class="book" title="Retrieving client and URL information"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_3"><a id="ch08lvl2sec93" class="calibre1"/>Retrieving client and URL information</h2></div></div></div><p class="calibre9">In addition<a id="id437" class="calibre1"/> to information about the request, the Yii2 request object can also be used to retrieve information about the client and our application state. For instance, client information such as their hostname or IP address can be accessed using <code class="email">yii\web\Request::$userHost</code> and <code class="email">yii\web\Request::$userIP</code>.</p><div class="note" title="Note"><h3 class="title2"><a id="tip142" class="calibre1"/>Tip</h3><p class="calibre9">The user's IP address may not be accurate if your request is being forwarded through a proxy or load balancer. Ensure that your web server is properly configured to pass along the original data.</p></div><p class="calibre9">Data about the application state can be inspected by referencing a variety of methods, which are<a id="id438" class="calibre1"/> more convenient than querying the <code class="email">$_SERVER</code> global variable. A few of the most common properties are shown in the<a id="id439" class="calibre1"/> following table:</p><div class="note"><table border="1" class="calibre16"><colgroup class="calibre17"><col class="calibre18"/><col class="calibre18"/></colgroup><thead class="calibre19"><tr class="calibre20"><th valign="bottom" class="calibre21">
<p class="calibre22">Property</p>
</th><th valign="bottom" class="calibre21">
<p class="calibre22">Explanation</p>
</th></tr></thead><tbody class="calibre23"><tr class="calibre20"><td valign="top" class="calibre24">
<p class="calibre22">
<code class="literal">yii\web\Request::$absoluteUrl</code>
</p>
</td><td valign="top" class="calibre24">
<p class="calibre22">This is the absolute URL, including the hostname and all the <code class="literal">GET</code> parameters (for example, <code class="literal">https://www.example.com/controller/action/?name=foo</code>)</p>
</td></tr><tr class="calibre20"><td valign="top" class="calibre24">
<p class="calibre22">
<code class="literal">yii\web\Request::$baseUrl</code>
</p>
</td><td valign="top" class="calibre24">
<p class="calibre22">This is the base URL used before the entry script.</p>
</td></tr><tr class="calibre20"><td valign="top" class="calibre24">
<p class="calibre22">
<code class="literal">yii\web\Request::$hostInfo</code>
</p>
</td><td valign="top" class="calibre24">
<p class="calibre22">These are the host details (for example, <code class="literal">https://www.example.com</code>)</p>
</td></tr><tr class="calibre20"><td valign="top" class="calibre24">
<p class="calibre22">
<code class="literal">yii\web\Request::$pathInfo</code>
</p>
</td><td valign="top" class="calibre24">
<p class="calibre22">This is the full path after the entry script (for example, <code class="literal">/controller/action</code>)</p>
</td></tr><tr class="calibre20"><td valign="top" class="calibre24">
<p class="calibre22">
<code class="literal">yii\web\Request::$queryString</code>
</p>
</td><td valign="top" class="calibre24">
<p class="calibre22">This is the <code class="literal">GET</code> query string (for example, <code class="literal">name=foo</code>)</p>
</td></tr><tr class="calibre20"><td valign="top" class="calibre24">
<p class="calibre22">
<code class="literal">yii\web\Request::$scriptUrl</code>
</p>
</td><td valign="top" class="calibre24">
<p class="calibre22">This is the URL without the path and query string (for example, <code class="literal">/index.php</code>)</p>
</td></tr><tr class="calibre20"><td valign="top" class="calibre24">
<p class="calibre22">
<code class="literal">yii\web\Request::$serverName</code>
</p>
</td><td valign="top" class="calibre24">
<p class="calibre22">This is the server name (for example, <code class="literal">example.com</code>)</p>
</td></tr><tr class="calibre20"><td valign="top" class="calibre24">
<p class="calibre22">
<code class="literal">yii\web\Request::$serverPort</code>
</p>
</td><td valign="top" class="calibre24">
<p class="calibre22">This is the port the server is running on (usually 80 or 443 for TLS connections)</p>
</td></tr><tr class="calibre20"><td valign="top" class="calibre24">
<p class="calibre22">
<code class="literal">yii\web\Request::$url</code>
</p>
</td><td valign="top" class="calibre24">
<p class="calibre22">This is the complete URL sans the host and scheme information (for example, <code class="literal">controller/action/?name=foo</code>).</p>
</td></tr></tbody></table></div><div class="note" title="Note"><h3 class="title2"><a id="tip143" class="calibre1"/>Tip</h3><p class="calibre9">The request object is capable of representing nearly every aspect of the HTTP request and the data that may be stored in the <code class="email">$_SERVER</code> global variable. For more information<a id="id440" class="calibre1"/> on the request object refer to the Yii2 API documentation at <a class="calibre1" href="http://www.yiiframework.com/doc-2.0/yii-web-request.html">http://www.yiiframework.com/doc-2.0/yii-web-request.html</a>.</p></div></div></div>

<div id="page" style="height:0pt"/><div class="book" title="Responses"><div class="book" id="1ENBI2-ad3e09b384df46aea690d9c8897d5fe7"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch08lvl1sec43" class="calibre1"/>Responses</h1></div></div></div><p class="calibre9">After<a id="id441" class="calibre1"/> finishing the processing of the request object, Yii2 then generates a response object, which is sent back to the client. The response contains a myriad of information, such as the HTTP status code, response body, and headers. In Yii2, the response object is implemented by <code class="email">yii\web\Response</code>, which is represented by the <code class="email">response</code> application component. In this section, we'll explore how to work with responses.</p></div>

<div class="book" title="Responses">
<div class="book" title="Setting status codes"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_1"><a id="ch08lvl2sec94" class="calibre1"/>Setting status codes</h2></div></div></div><p class="calibre9">In most<a id="id442" class="calibre1"/> cases, Yii2 is perfectly capable of setting the appropriate<a id="id443" class="calibre1"/> response code back to the end user; however, there may be situations that require us to explicitly define the HTTP response code for our application. To modify the HTTP status code within our application, we simply need to set <code class="email">yii\web\Response::$statusCode</code> to a valid HTTP status code:</p><div class="note"><pre class="programlisting">\Yii::$app-&gt;response-&gt;statusCode = 200;</pre></div><div class="book" title="Web exceptions"><div class="book"><div class="book"><div class="book"><h3 class="title2"><a id="ch08lvl3sec47" class="calibre1"/>Web exceptions</h3></div></div></div><p class="calibre9">By <a id="id444" class="calibre1"/>default, Yii2 will return an HTTP 200 status code for any successful request. If we want to adjust the status code without interrupting our flow of logic, we can simply define a new status code for <code class="email">yii\web\Response::$statusCode</code>. In other cases, it may be better to throw an exception to cause a short circuit in our application flow to prevent additional logic from being executed.</p><p class="calibre9">In general, web exceptions can be thrown by calling <code class="email">yii\web\HttpException</code> with a valid HTTP status code:</p><div class="note"><pre class="programlisting">throw new \yii\web\HttpException(409);</pre></div><p class="calibre9">For<a id="id445" class="calibre1"/> convenience, Yii2 provides several specific methods for a few different types of requests, as shown in the following table:</p><div class="note"><table border="1" class="calibre16"><colgroup class="calibre17"><col class="calibre18"/><col class="calibre18"/><col class="calibre18"/></colgroup><thead class="calibre19"><tr class="calibre20"><th valign="bottom" class="calibre21">
<p class="calibre22">Exception</p>
</th><th valign="bottom" class="calibre21">
<p class="calibre22">Status Code</p>
</th><th valign="bottom" class="calibre21">
<p class="calibre22">HTTP Error</p>
</th></tr></thead><tbody class="calibre23"><tr class="calibre20"><td valign="top" class="calibre24">
<p class="calibre22">
<code class="literal">yii\web\BadRequestHttpException</code>
</p>
</td><td valign="top" class="calibre24">
<p class="calibre22">400</p>
</td><td valign="top" class="calibre24">
<p class="calibre22">Bad request</p>
</td></tr><tr class="calibre20"><td valign="top" class="calibre24">
<p class="calibre22">
<code class="literal">yii\web\UnauthorizedHtpException</code>
</p>
</td><td valign="top" class="calibre24">
<p class="calibre22">401</p>
</td><td valign="top" class="calibre24">
<p class="calibre22">Unauthorized</p>
</td></tr><tr class="calibre20"><td valign="top" class="calibre24">
<p class="calibre22">
<code class="literal">yii\web\ForbiddenHttpException</code>
</p>
</td><td valign="top" class="calibre24">
<p class="calibre22">403</p>
</td><td valign="top" class="calibre24">
<p class="calibre22">Forbidden</p>
</td></tr><tr class="calibre20"><td valign="top" class="calibre24">
<p class="calibre22">
<code class="literal">yii\web\NotFoundHttpException</code>
</p>
</td><td valign="top" class="calibre24">
<p class="calibre22">404</p>
</td><td valign="top" class="calibre24">
<p class="calibre22">Not found</p>
</td></tr><tr class="calibre20"><td valign="top" class="calibre24">
<p class="calibre22">
<code class="literal">yii\web\MethodNotAllowedException</code>
</p>
</td><td valign="top" class="calibre24">
<p class="calibre22">405</p>
</td><td valign="top" class="calibre24">
<p class="calibre22">Method<a id="id446" class="indexterm"/> not allowed</p>
</td></tr><tr class="calibre20"><td valign="top" class="calibre24">
<p class="calibre22">
<code class="literal">yii\web\NotAcceptableHttpException</code>
</p>
</td><td valign="top" class="calibre24">
<p class="calibre22">406</p>
</td><td valign="top" class="calibre24">
<p class="calibre22">Not acceptable</p>
</td></tr><tr class="calibre20"><td valign="top" class="calibre24">
<p class="calibre22">
<code class="literal">yii\web\ConflictHttpException</code>
</p>
</td><td valign="top" class="calibre24">
<p class="calibre22">409</p>
</td><td valign="top" class="calibre24">
<p class="calibre22">Conflict</p>
</td></tr><tr class="calibre20"><td valign="top" class="calibre24">
<p class="calibre22">
<code class="literal">yii\web\GoneHttpException</code>
</p>
</td><td valign="top" class="calibre24">
<p class="calibre22">410</p>
</td><td valign="top" class="calibre24">
<p class="calibre22">Gone</p>
</td></tr><tr class="calibre20"><td valign="top" class="calibre24">
<p class="calibre22">
<code class="literal">yii\web\UnsupportedMediaTypeHttpException</code>
</p>
</td><td valign="top" class="calibre24">
<p class="calibre22">415</p>
</td><td valign="top" class="calibre24">
<p class="calibre22">Unsupported media type</p>
</td></tr><tr class="calibre20"><td valign="top" class="calibre24">
<p class="calibre22">
<code class="literal">yii\web\TooManyRequestsHttpException</code>
</p>
</td><td valign="top" class="calibre24">
<p class="calibre22">429</p>
</td><td valign="top" class="calibre24">
<p class="calibre22">Too many requests</p>
</td></tr><tr class="calibre20"><td valign="top" class="calibre24">
<p class="calibre22">
<code class="literal">yii\web\ServerErrorHttpException</code>
</p>
</td><td valign="top" class="calibre24">
<p class="calibre22">500</p>
</td><td valign="top" class="calibre24">
<p class="calibre22">Sever error</p>
</td></tr></tbody></table></div><div class="note" title="Note"><h3 class="title2"><a id="tip144" class="calibre1"/>Tip</h3><p class="calibre9">As<a id="id447" class="calibre1"/> an alternative to throwing an empty <code class="email">yii\web\HttpException</code> with a given status code, you can also extend <code class="email">yii\web\HttpException</code> to implement your own <code class="email">HttpException</code> exception.</p></div></div></div></div>

<div class="book" title="Responses">
<div class="book" title="Setting response headers"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_2"><a id="ch08lvl2sec95" class="calibre1"/>Setting response headers</h2></div></div></div><p class="calibre9">As with <a id="id448" class="calibre1"/>the <code class="email">yii\web\Request object</code>, we can manipulate the HTTP headers of our response using the <code class="email">add()</code> and <code class="email">remove()</code> methods from <code class="email">yii\web\HeaderCollection</code>, as shown in the following example:</p><div class="note"><pre class="programlisting">yii\web\HeaderCollection
$headers = Yii::$app-&gt;response-&gt;headers;

// Add two headers
$headers-&gt;add('X-Auth-Token', 'SADFLJKBQ43O7AGB28948QT');
$headers-&gt;add('Pragma', 'No-Cache');

// Remove a header
$headers-&gt;remove('Pragma');</pre></div><div class="note" title="Note"><h3 class="title2"><a id="tip145" class="calibre1"/>Tip</h3><p class="calibre9">Adding new headers will override any previously set headers with the same name. Moreover, all headers set through <code class="email">yii\web\HeaderCollection</code> are case insensitive. Removing a header will remove any header with the name that is currently sent.</p></div><p class="calibre9">Headers can be manipulated at any time during the response up until <code class="email">yii\web\Response::send()</code> is called, which, by default, is called right before the response<a id="id449" class="calibre1"/> body is sent out.</p></div></div>

<div class="book" title="Responses">
<div class="book" title="The response body"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_3"><a id="ch08lvl2sec96" class="calibre1"/>The response body</h2></div></div></div><p class="calibre9">Typically, the <a id="id450" class="calibre1"/>response body will be represented by an instance of <code class="email">yii\web\View</code>, which is usually displayed to the end user by returning a rendered view inside a controller action, as shown here. By default, Yii2 will return the response with a MIME type of text/HTML and will format the response using <code class="email">yii\web\HtmlResponseFormatter</code>:</p><div class="note"><pre class="programlisting">public function actionIndex()
{
    return $this-&gt;render('index');
}</pre></div><p class="calibre9">There may be situations, however, where a different response type may be required, such as when displaying JSON or XML data. Within our controller action, we can change the output format from the default by setting the <code class="email">yii\web\Response::$format</code> property and returning either an array or a string representing the data we want formatted, as shown in the following example:</p><div class="note"><pre class="programlisting">public function actionIndex()
{
    \Yii::$app-&gt;response-&gt;format = \yii\web\Response::FORMAT_JSON;
    return [
        'message' =&gt; 'Index Action',
        'code' =&gt; 200,
    ];
}</pre></div><p class="calibre9">The previous example will output the following JSON data to the client:</p><div class="note"><pre class="programlisting">{
    "message": "Index Action",
    "code": 200
}</pre></div><p class="calibre9">In addition to JSON formatting, <code class="email">yii\web\Response::$format</code> can also be set to JSONP, HTML, RAW, and <a id="id451" class="calibre1"/>XML using the details outlined in the following table:</p><div class="note"><table border="1" class="calibre16"><colgroup class="calibre17"><col class="calibre18"/><col class="calibre18"/><col class="calibre18"/></colgroup><thead class="calibre19"><tr class="calibre20"><th valign="bottom" class="calibre21">
<p class="calibre22">Type</p>
</th><th valign="bottom" class="calibre21">
<p class="calibre22">Formatter class</p>
</th><th valign="bottom" class="calibre21">
<p class="calibre22">Format value</p>
</th></tr></thead><tbody class="calibre23"><tr class="calibre20"><td valign="top" class="calibre24">
<p class="calibre22">HTML</p>
</td><td valign="top" class="calibre24">
<p class="calibre22">
<code class="literal">yii\web\HtmlResponseFormat</code>
</p>
</td><td valign="top" class="calibre24">
<p class="calibre22">
<code class="literal">FORMAT_HTML</code>
</p>
</td></tr><tr class="calibre20"><td valign="top" class="calibre24">
<p class="calibre22">RAW</p>
</td><td valign="top" class="calibre24"> </td><td valign="top" class="calibre24">
<p class="calibre22">
<code class="literal">FORMAT_RAW</code>
</p>
</td></tr><tr class="calibre20"><td valign="top" class="calibre24">
<p class="calibre22">XML</p>
</td><td valign="top" class="calibre24">
<p class="calibre22">
<code class="literal">yii\web\XmlResponseFormatter</code>
</p>
</td><td valign="top" class="calibre24">
<p class="calibre22">
<code class="literal">FORMAT_XML</code>
</p>
</td></tr><tr class="calibre20"><td valign="top" class="calibre24">
<p class="calibre22">JSON</p>
</td><td valign="top" class="calibre24">
<p class="calibre22">
<code class="literal">yii\web\JsonResponseFormatter</code>
</p>
</td><td valign="top" class="calibre24">
<p class="calibre22">
<code class="literal">FORMAT_JSON</code>
</p>
</td></tr><tr class="calibre20"><td valign="top" class="calibre24">
<p class="calibre22">JSONp</p>
</td><td valign="top" class="calibre24">
<p class="calibre22">
<code class="literal">yii\web\JsonResponseFormatter</code>
</p>
</td><td valign="top" class="calibre24">
<p class="calibre22">
<code class="literal">FORMAT_JSON</code>
</p>
</td></tr></tbody></table></div><div class="note" title="Note"><h3 class="title2"><a id="tip146" class="calibre1"/>Tip</h3><p class="calibre9">RAW data will be submitted to the client as is without any additional formatting being applied to it.</p></div><p class="calibre9">In<a id="id452" class="calibre1"/> addition to working with the default response object, in Yii2, you can also create new response objects to be sent to the end user, as shown in the following example:</p><div class="note"><pre class="programlisting">public function actionIndex()
{
    return \Yii::createObject([
        'class' =&gt; 'yii\web\Response',
        'format' =&gt; \yii\web\Response::FORMAT_JSON,
        'data' =&gt; [
            'message' =&gt; 'Index Action',
            'code' =&gt; 100,
        ],
    ]);
}</pre></div><div class="note" title="Note"><h3 class="title2"><a id="tip147" class="calibre1"/>Tip</h3><p class="calibre9">Any custom configuration set for the response application component will not be applied to any custom response objects that you instantiate.</p></div><p class="calibre9">While controller actions are the primary place where you will find yourself editing the response body, the response body can be modified from anywhere in Yii by directly manipulating <code class="email">\Yii::$app-&gt;response</code>. Any data that has been already formatted can be assigned directly to the response object by setting the <code class="email">yii\web\Response::$content</code> property. Moreover, if you want to have the data being passed through a response formatted <a id="id453" class="calibre1"/>before being sent to the user, you can set <code class="email">yii\web\Response::$content</code> and then set <code class="email">yii\web\Response::$data</code> with the data you want formatted:</p><div class="note"><pre class="programlisting">$response = \Yii::$app-&gt;response;
$response-&gt;format = yii\web\Response::FORMAT_JSON;
$response-&gt;data = [
    'message' =&gt; 'Index Action',
    'code' =&gt; 100
]; </pre></div></div></div>

<div class="book" title="Responses">
<div class="book" title="Redirection"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_4"><a id="ch08lvl2sec97" class="calibre1"/>Redirection</h2></div></div></div><p class="calibre9">In order<a id="id454" class="calibre1"/> to redirect a browser to a new page, the special header location must be set by the response. Yii2 provides special support for this through the <code class="email">yii\web\Response::redirect()</code> method, which can be called from within a controller action, as follows:</p><div class="note"><pre class="programlisting">public function actionIndex()
{
    return $this-&gt;redirect('https://www.example.com/index2');
}</pre></div><div class="note" title="Note"><h3 class="title2"><a id="tip148" class="calibre1"/>Tip</h3><p class="calibre9">By default, Yii2 will return a 302 status code, indicating that the redirect should be temporary. To notify the browser to permanently redirect the request, you can set the second parameter of <code class="email">yii\web\Response::redirect()</code> to 301, which is the HTTP status code for a permanent redirection.</p></div><p class="calibre9">Outside a controller action, a redirect can be called by calling the <code class="email">redirect()</code> method and then immediately sending the response, as shown in the following example:</p><div class="note"><pre class="programlisting">\Yii::$app-&gt;response-&gt;redirect('https://www.example.com/index2', 301)-&gt;send();</pre></div></div></div>

<div class="book" title="Responses">
<div class="book" title="The file output"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_5"><a id="ch08lvl2sec98" class="calibre1"/>The file output</h2></div></div></div><p class="calibre9">Similar to<a id="id455" class="calibre1"/> browser redirection, outputting a file to the client requests several custom headers to be set. To facilitate the transfer of files to the browser, Yii2 provides three distinct methods to output files:</p><div class="book"><ul class="itemizedlist"><li class="listitem"><code class="email">yii\web\Response::sendFile()</code> should be used when sending an existing file located on the disk</li><li class="listitem"><code class="email">yii\web\Response::sendContentAsFile()</code> sends a string of data as a file (such as a CSV file)</li><li class="listitem"><code class="email">yii\web\Response::sendStreamAsFile()</code> should be used for large files (typically, files larger than 100 MB), and it should be sent to the browser as it is more memory efficient. Within a controller, these methods can be called directly to send a file:<div class="note"><pre class="programlisting">public function actionReport()
{
    return \Yii::$app-&gt;response-&gt;sendFile('path/to/report.csv');
}</pre></div></li></ul></div><p class="calibre9">Similar to<a id="id456" class="calibre1"/> redirecting a browser, these methods can be called outside a controller action by manipulating the response object directly:</p><div class="note"><pre class="programlisting">\Yii::$app-&gt;response-&gt;sendFile('path/to/report.csv')-&gt;send();</pre></div><div class="note" title="Note"><h3 class="title2"><a id="tip149" class="calibre1"/>Tip</h3><p class="calibre9">More<a id="id457" class="calibre1"/> information on the response object can be found in the Yii2 documentation at <a class="calibre1" href="http://www.yiiframework.com/doc-2.0/yii-web-response.html">http://www.yiiframework.com/doc-2.0/yii-web-response.html</a>.</p></div></div></div>

<div id="page" style="height:0pt"/><div class="book" title="Events"><div class="book" id="1FLS42-ad3e09b384df46aea690d9c8897d5fe7"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch08lvl1sec44" class="calibre1"/>Events</h1></div></div></div><p class="calibre9">Often <a id="id458" class="calibre1"/>when working with complex code bases, we may implement hooks and handlers so that our application can call custom code outside our main application flow. In Yii2, these handlers are called events, which can be automatically executed when a given event is triggered. For example, in a blogging platform, we may create an event to indicate that a post was published, which will trigger some custom code to send out an email to users in a specific mailing list. In this section, we'll cover how to create event handlers, trigger events, and write our own custom events.</p></div>

<div class="book" title="Events">
<div class="book" title="Event handlers"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_1"><a id="ch08lvl2sec99" class="calibre1"/>Event handlers</h2></div></div></div><p class="calibre9">Events in<a id="id459" class="calibre1"/> Yii2 are implemented within the <code class="email">yii\base\Component</code> base class, which nearly every class in Yii2 extends from. By extending from this class, we can bind an event to nearly anywhere in our codebase. To begin working with events, we first need to create an event handler.</p><p class="calibre9">Event handlers in Yii2 can be bound by calling the <code class="email">yii\base\Component::on()</code> method, and they specify a callback that should be executed when the event is triggered. These callbacks can take several different forms, ranging from a global PHP function specified as a string to an anonymous function written inline on the event. For instance, if we want to call a global PHP function (such as the one we defined or a built-in function such as <code class="email">trim</code>), we can bind our event, as follows:</p><div class="note"><pre class="programlisting">$thing = new app\Thing;
$thing-&gt;on(Thing::EVENT_NAME, 'php_function_name');</pre></div><p class="calibre9">Events<a id="id460" class="calibre1"/> handlers can also be called on any PHP object: either the one that we already have an instance variable for or a namespaced class within our application:</p><div class="note"><pre class="programlisting">$thing-&gt;on(Thing::EVENT_NAME, [$object, 'method']);
$thing-&gt;on(Thing::EVENT_NAME, ['app\components\Thing ', 'doThing']);</pre></div><p class="calibre9">Moreover, event handlers can be written as an anonymous function:</p><div class="note"><pre class="programlisting">$thing-&gt;on(Thing::EVENT_NAME, function($event) {
    // Handle the event
});</pre></div><p class="calibre9">Additional data can be passed to event handlers by passing any data as the third parameter to the <code class="email">yii\base\Component::on()</code> method:</p><div class="note"><pre class="programlisting">$thing-&gt;on(Thing::EVENT_NAME, function($event) {
    echo $event-&gt;data['foo']; // bar
}, ['foo' =&gt; 'bar']);</pre></div><p class="calibre9">Furthermore, multiple event handlers can be bound to a single event. When a given event is triggered, each event will execute in the order in which it was bound to the event. If an event handler needs to stop the execution of the other events that follow, it can set the <code class="email">yii\base\Event::$handled</code> property of the <code class="email">$event</code> object to <code class="email">true</code>, which will prevent all the event handlers bound to the event from not executing:</p><div class="note"><pre class="programlisting">$thing-&gt;on(Thing::EVENT_NAME, function($event) {
    // Handle the event
    $event-&gt;handled = true;
}, $data);</pre></div><p class="calibre9">By default, the event handler in Yii2 is bound in the order in which it is called, which means that the last event handler bound to a given event will be called last. To prepend an event handler to the beginning of the event handler queue, you can set the <code class="email">$append</code> parameter of <code class="email">yii\base\Component::on()</code> to <code class="email">false</code>, which will override the default behavior and cause the event handler to be triggered first when the event is raised:</p><div class="note"><pre class="programlisting">$thing-&gt;on(Thing::EVENT_NAME, function($event) {
    // Handle the event
}, [], false);</pre></div><p class="calibre9">Event <a id="id461" class="calibre1"/>handlers can also be unbound from the event they're listening to by calling <code class="email">yii\base\Component::off()</code> using the same syntax used to attach the event listener to the event. Alternatively, all events handlers can be unbound from an event by calling <code class="email">yii\base\Component::off()</code> without any additional parameters, as shown in the following example:</p><div class="note"><pre class="programlisting">$thing-&gt;off(Thing::EVENT_NAME);</pre></div></div></div>

<div class="book" title="Events">
<div class="book" title="Triggering events"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_2"><a id="ch08lvl2sec100" class="calibre1"/>Triggering events</h2></div></div></div><p class="calibre9">Events<a id="id462" class="calibre1"/> in Yii2 are triggered by calling the <code class="email">yii\base\Component::trigger()</code> method, which takes the event name as the second parameter, and an optional instance of <code class="email">yii\base\Event</code> as the second parameter. For example, we can call <code class="email">Thing::EVENT_NAME</code> within our code, as follows:</p><div class="note"><pre class="programlisting">$this-&gt;trigger(Thing::EVENT_NAME);</pre></div><p class="calibre9">This event was previously bound with the following event:</p><div class="note"><pre class="programlisting">$thing-&gt;on(Thing::EVENT_NAME, ['app\components\Thing, 'doThing']);</pre></div><p class="calibre9">Now, the <code class="email">app\components\Thing::doThing()</code> method will be triggered. This code may look as follows for our imaginary component:</p><div class="note"><pre class="programlisting">&lt;?php
namespace app\components;

use yii\base\Component;
use yii\base\Event;

class Thing extends Component
{
    const EVENT_NAME = 'name';

    public function doThing()
    {
        // This is the event handler
    }
}</pre></div><div class="note" title="Note"><h3 class="title2"><a id="note18" class="calibre1"/>Note</h3><p class="calibre9">Yii2 considers it a best practice to store event names as constants within classes.</p></div><p class="calibre9">Additional information can be sent to our event handlers by extending <code class="email">yii\base\Event</code> and passing it<a id="id463" class="calibre1"/> as the second parameter of our trigger call, as shown in the following example:</p><div class="note"><pre class="programlisting">&lt;?php

namespace app\components;

use yii\base\Component;
use yii\base\Event;

class LogEvent extends Event
{
    public $message;
}

class Logger extends Component
{
    const EVENT_LOG = 'log_event';

    /**
     * Log with $message
     * @param string $message
     */
    public function log($message)
    {
        $event = new LogEvent;
        $event-&gt;message = $message;
        $this-&gt;trigger(self::EVENT_LOG, $event);
    }
}</pre></div><p class="calibre9">Due to the single-threaded nature of PHP, Yii2's events will occur synchronously rather than asynchronously, which will block all other application flows from occurring until all the events in the event handler queue are complete. Consequently, you should be careful when using many events as they may cause detrimental application performance.</p><div class="note" title="Note"><h3 class="title2"><a id="tip150" class="calibre1"/>Tip</h3><p class="calibre9">One way to use implemented asynchronous events (such as sending an email newsletter from a CMS) is to have your event handlers pass off the event to a third-party messaging queue, such as Gearman, Sidekiq, or Resque, and immediately return the event. The event can then be handled in a separate processing thread, which can be a Yii2 console command configured to read events from<a id="id464" class="calibre1"/> the messaging queue and process them separately from the main application.</p></div></div></div>

<div class="book" title="Events">
<div class="book" title="Class-level events"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_3"><a id="ch08lvl2sec101" class="calibre1"/>Class-level events</h2></div></div></div><p class="calibre9">The <a id="id465" class="calibre1"/>events described previously were bound at an instance level. In Yii2, events can be bound to every instance of a class rather than a specific instance, and they can also be bound to Yii2's global event handler.</p><p class="calibre9">Class-level events can be bound by attaching the event handler directly through <code class="email">yii\base\Event::on()</code>. For instance, Active Record will trigger an <code class="email">EVENT_AFTER_DELETE</code> event whenever a record is deleted from the database. We can log this information for every Active Record instance, as shown in the following example:</p><div class="note"><pre class="programlisting">&lt;?php

use Yii;
use yii\base\Event;
use yii\db\ActiveRecord;

Event::on(ActiveRecord::className(), ActiveRecord::EVENT_AFTER_DELETE, function ($event) {
    Yii::trace(get_class($event-&gt;sender) . ' deleted a record.');
});</pre></div><p class="calibre9">Whenever a trigger occurs, it will first call instance-level event handlers, then it will call class-level event handlers, and then it will call global event handlers. Class-level events can be explicitly called by calling <code class="email">yii\base\Event::trigger()</code> directly. Additionally, class-level event handlers can be removed through <code class="email">yii\base\Event::off()</code>.</p></div></div>

<div class="book" title="Events">
<div class="book" title="Global events"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_4"><a id="ch08lvl2sec102" class="calibre1"/>Global events</h2></div></div></div><p class="calibre9">Global <a id="id466" class="calibre1"/>events are supported in Yii2 by binding event handlers to the application singleton instance itself, as shown in the following example:</p><div class="note"><pre class="programlisting">&lt;?php
use Yii;
use yii\base\Event;
use app\components\Foo;

Yii::$app-&gt;on('thing', function ($event) {
    echo get_class($event-&gt;sender);
});

Yii::$app-&gt;trigger('thing', new Event(['sender' =&gt; new Thing]));</pre></div><div class="note" title="Note"><h3 class="title2"><a id="tip151" class="calibre1"/>Tip</h3><p class="calibre9">When using global events, be cautious as to not override Yii2's built-in global events. Any global event that you use should include some sort of prefix in order to avoid collision with Yii2's built-in events.</p></div></div></div>
<div class="book" title="Summary" id="1GKCM1-ad3e09b384df46aea690d9c8897d5fe7"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch08lvl1sec45" class="calibre1"/>Summary</h1></div></div></div><p class="calibre9">In this chapter, we covered the basics of how requests and responses are handled in Yii2. We first explored how Yii2 handles the routing of URL routes, and we learned how to manipulate and create our own custom URL rules. We then explored the <code class="email">yii\web\Request</code> and <code class="email">yii\web\Response</code> objects and gained a better understanding of how we can use these objects to manipulate the requests and responses coming to and from our application. Finally, we learned how events work in Yii2, and we also learned how to create our own events.</p><p class="calibre9">In the next chapter, we'll take the knowledge we've gained in this chapter to the next level by exploring how to implement RESTful APIs.</p></div></body></html>