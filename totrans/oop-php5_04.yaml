- en: Chapter 4. Design Patterns
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Object oriented programming was basically introduced to ease the development
    process as well as reduce the time of development by reducing amounts of code.
    If properly planned and designed, OOP can increase the performance of the program
    to a great extent. One of those magical performance cum code reduction issues
    is "Design Pattern" which was introduced by Eric Gamma and his three other friends
    in the book *Design Patterns* in 1972\. Because of four authors, the book was
    introduced as written by *Gang of Four* or simply *Goff*. In that legendary book,
    Gang of Four introduced several patterns to minimize the amount of code as well
    as to introduce effective coding practice. In this chapter we will learn some
    of those patterns to implement in PHP.
  prefs: []
  type: TYPE_NORMAL
- en: You Might have Done this Before…
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: While coding, many of us use these patterns without being aware that these techniques
    are actually known as patterns. Even in my early coding life, I used some coding
    techniques, which I later found out to be similar to some patterns. So don't be
    afraid about using patterns. They are daily coding tricks, which you may have
    always performed, but you may not have known.
  prefs: []
  type: TYPE_NORMAL
- en: While developing software, some problems are addressed on a regular basis. Almost
    every software development faces some of these problems. These problems are termed
    "design patterns" and are given some common solutions. So knowing design patterns
    saves a lot of time for developers in software development. Let's have a closer
    look at design patterns.
  prefs: []
  type: TYPE_NORMAL
- en: Strategy Pattern
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'One of the common problems we face whilst programming, is that we have to make
    decisions on different strategies. Strategy pattern is a common pattern helps
    us make decisions on different cases, more easily. To understand this better,
    let us use a scenario that you''re developing a notifier program. This notifier
    program will check the given options for a user. A user may want to be notified
    in many ways, like email, SMS, or fax. Your program has to check the available
    options to contact that user and then make a decision upon that. This case can
    easily be solved by Strategy pattern:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Strategy Pattern](img/2561_04_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In the above pattern we are using three classes called `SMSNotifier`, `EmailNotifier`,
    and `FaxNotifier`. All these classes implement the Notifier interface, which has
    a method named `notify`. Each of these classes implement that method on their
    own.
  prefs: []
  type: TYPE_NORMAL
- en: Let's create the interface first.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Now we will create different types of notifiers.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we will use this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: I'm sure you'll agree that this is pretty simple. I am also sure that you have
    already used such solutions in your existing codes on more than one occasion
  prefs: []
  type: TYPE_NORMAL
- en: Factory Pattern
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Another common design pattern is factory pattern. The main goal of this pattern
    is delivering an object by hiding all the complexities behind it. This may sound
    cryptic, so let's look at it using a real life scenario.
  prefs: []
  type: TYPE_NORMAL
- en: 'You are doing a project that works on a very complex system. For this example,
    you are creating an online document repository, which saves documents in temporary
    storage. For this you need support for PostgreSQL, MySQL, Oracle, and SQLite because
    users may deploy your application using any of these. So you create an object,
    which connects to MySQL and perform the necessary tasks. Your MySQL object is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Well, now you use this class like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'You can now see that before you started using your class, you needed to do
    a lot of things. Your PostgreSQL class also looks similar:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'And usage is also the same:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'But now usage could be a bit difficult when you merge them together:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Shortly after this you will find that as more database engines are added, the
    core code changes significantly and you have to hard code all these things in
    core classes. However, a very good practice of programming is loose coupling.
    Here you make a separate class called `DBManager`, which will perform all these
    things from a central place. Let''s make it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: '![Strategy patternexampleFactory Pattern](img/2561_04_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Now you can use it from a single place called `DBManager`. This makes the thing
    a whole lot easier than before.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: This is the real life example of a Factory design pattern. The `DBManager` now
    works as a Factory, which encapsulates all the complexities behind the scene and
    delivers two products. Factory simplifies programming by encapsulating the difficulties
    inside it.
  prefs: []
  type: TYPE_NORMAL
- en: Abstract Factory
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Abstract Factory is almost similar to Factory, the only difference is that all
    your concrete objects must extend a common abstract class. You may ask what is
    the benefit of doing so is. Well, as long as concrete objects are derived from
    a known abstract object, programming is simplified because they all come in the
    same standard.
  prefs: []
  type: TYPE_NORMAL
- en: Let's have a look at the previous example. We first create an abstract class
    and then extend that object to develop all concrete driver classes.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Now our MySQL will be derived from it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: '![Afactory patternexamplebstract Factory](img/2561_04_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Later we will use this `MySQLManager` class as usual in our `DBManager`. One
    major benefit is that we define all the necessary functions in a single place,
    which is present in all derived classes with the same standard. We can also encapsulate
    common functions/procedures in the abstract class.
  prefs: []
  type: TYPE_NORMAL
- en: Adapter Pattern
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Another interesting problem in OOP is solved by a design pattern named Adapter.
    So what is an Adapter pattern and what type of problems does it solve?
  prefs: []
  type: TYPE_NORMAL
- en: Adapter is actually an object that acts like an adapter in real life, in that
    it converts one thing to another. Using Adapter you can convert electric sources
    from higher to lower volts. Similarly in OOP, using Adapter pattern, one object
    can fit for the same methods of another object.
  prefs: []
  type: TYPE_NORMAL
- en: Let us discuss patterns in real life coding in more detail. Suppose you develop
    an online document repository, which exports written documents to popular online
    file storage services. You have developed one wrapper, which can store and retrieve
    documents from Writely using their native API. Well, soon after Google acquired
    Writely, you find that they are temporarily shut down and you have to use Google
    docs as the base of that repository. Now what will you do? You find open source
    solutions to use with Google docs but unfortunately you find that the methods
    of that Google doc object differ from the Writely object.
  prefs: []
  type: TYPE_NORMAL
- en: This is a very common scenario and it happens when classes are developed by
    different developers. You want to use this Google docs object but you don't want
    to change your core code, because then you will have to change it a lot then.
    On top of this there are chances that the code may break after these core changes.
  prefs: []
  type: TYPE_NORMAL
- en: In this scenario an Adapter pattern comes to save your life. You develop a common
    interface which a Writely object implements. Now all you have to do is develop
    another wrapper class, which implements the same interface that was implemented
    by Google Docs. So what will our wrapper class do? It wraps all the methods of
    Google docs class into those available in the interface. After successfully wrapping
    everything, you can use this object straight in your code. You may need to change
    a line or two, but the rest of the core code remains unchanged.
  prefs: []
  type: TYPE_NORMAL
- en: 'That''s what''s great about using Adapter pattern. You can keep your core code
    unchanged even when the code of third-party dependencies and external API changes.
    Let us have a closer look at it:'
  prefs: []
  type: TYPE_NORMAL
- en: '![AdAbstract Factoryexampleapter Pattern](img/2561_04_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Here comes our first version of a Writely object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is the `DocManager` interface:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Now the `GoogleDoc` object looks like something below:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: So how does it fit with our existing code?
  prefs: []
  type: TYPE_NORMAL
- en: To make it compatible with our existing code, we need to develop the wrapper
    object, which implements the same `DocManager` interface but uses the `GoogleDoc`
    object to perform the actual work.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Now we will just instantiate an instance of `GoogleDocsAdapter` and then use
    that instance in our core code. As it implements the same interface, there is
    no need to change the core code.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, there''s one more thing to note: what about the missing functions?
    For example your `WritelyDocs` object supports the `getFolders()` method, which
    is of no use in `GoogleDocs`. You must implement those methods more carefully.
    For example, if your core code requires some folder ID returned by this method,
    in `GoogleDocsAdapter` you can generate a random folder ID and return them (which
    has no use in `GoogleDocsAdapter)`. So your core code won''t break at all.'
  prefs: []
  type: TYPE_NORMAL
- en: Singleton Pattern
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One of the most used design patterns is Singleton. This pattern solves a very
    significant problem in object oriented programming and saves the lives of millions
    of programmers in practical programming.
  prefs: []
  type: TYPE_NORMAL
- en: The main purpose of the Singleton pattern is to deliver a single instance of
    object no matter how many times you instantiate it. That is, if an object is instantiated
    once, using the Singleton pattern you can deliver only that instance when you
    require it again in your code. This saves memory consumption by preventing the
    creation of multiple instances of an object. Thus Singleton pattern is used to
    improve the performance of your application.
  prefs: []
  type: TYPE_NORMAL
- en: '![SinAdapter patternexamplegleton Pattern](img/2561_04_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Let's take the `MySQLManager` class, which we created in the previous example.
    Now we are adding a single instance feature using Singleton pattern.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Now let us see how it actually works. If you execute the following script, you
    will be surprised to see the result.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Strange, isn't it? The `MySQLManager` class creates only a single instance at
    the very first call, after that it is using the same old object instead of creating
    a new object all the time. Let us see how we achieve it.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Our class has a static variable named `$instance`. At the constructor we check
    if the static variable actually contains anything. If it is empty, we instantiate
    the object itself and set the instance in this static variable. As it is static,
    it will remain available throughout the execution of this script.
  prefs: []
  type: TYPE_NORMAL
- en: Let us get back to the constructor. At the second call, we just check if the
    `$instance` variable contains anything. We find that the `$instance` variable
    is actually containing an instance of this object, and it is still preserved because
    it is a static variable. So in the second call, we actually return the instance
    of this object, which was created by the previous call.
  prefs: []
  type: TYPE_NORMAL
- en: Singleton is a very important pattern and you should understand properly what
    it actually does. You can optimize your application and increase its performance
    using this pattern properly.
  prefs: []
  type: TYPE_NORMAL
- en: Iterator Pattern
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Iterator is a common pattern, which helps you to manipulate a collection more
    easily. Almost every language has built-in support of Iterators. Even PHP5 has
    a built-in Iterator objects. Iterators are very useful to provide an easy interface
    to manipulate a collection sequentially.
  prefs: []
  type: TYPE_NORMAL
- en: Let us consider this scenario when the Iterator pattern can save the life if
    a developer is in complex applications. Let us imagine you are creating a blog,
    where users write their daily web logs. How can you display the different posts,
    one by one?
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following example you pass all the `post_id` made by an author in your
    template and the template designer writes the following code to display it properly
    in the template:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: In this example we do everything in the template; we fetch all post ids, then
    get authors, comments, content, and display it. We also fetch the comments list
    in the template code. The whole code is too hazy to read and manage and may crash
    successively at any core changes. But just think, if we turn the comments into
    a collection of comment object for that post and all the posts into a collection
    of post object for easier accessing, it will remove the burden of template designing
    as well as create manageable code.
  prefs: []
  type: TYPE_NORMAL
- en: Let us implement Iterator pattern for our comments and posts and see how effectively
    it turns your code into a readable piece of poem. After all, coding is poetry.
  prefs: []
  type: TYPE_NORMAL
- en: 'To use iteration effectively in PHP5 we can use `Iterator` interface. The interface
    is shown below:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: The `rewind()` function of Iterator sets the index to the start of collection.
    The `Current()` returns the current object. `key()` function returns the current
    key. The Function `next()` returns if there are more object ahead in the current
    loop counter. If the return is yes, this function returns true, otherwise it returns
    false. The `valid()` function returns the current object if it has any value in
    it. Let us create an Iterator for our post object.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will create a function named `getAllPosts()` that will return all posts
    from the DB. All these posts are returned as a `Post` object, which has methods
    like `getAuthor()`, `getTitle()`, `getDate()`, `getComments()`, etc. Now we will
    create the Iterator:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Now let's use the Iterator we just created.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: The code becomes much readable and maintainable now.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In PHP array, object implements this Iterator interface by default. But of course
    you can implement it to add many more user-defined functionalities to ease your
    development cycle.
  prefs: []
  type: TYPE_NORMAL
- en: Observer Pattern
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You might wonder how these events actually work and how they are raised. Well,
    if you are familiar with the Observer pattern, you can create event driven applications
    easier than ever.
  prefs: []
  type: TYPE_NORMAL
- en: An Observer pattern solves a common problem in OOP. For example, if you want
    some objects to be notified automatically when something happens (an event raised),
    you can solve that problem with this pattern. Let us take a closer look.
  prefs: []
  type: TYPE_NORMAL
- en: An Observer pattern consists of two types of objects; one is an observable object,
    which is observed by `observer` object. When the state of an observable object
    changes, it notifies all observers registered with it.
  prefs: []
  type: TYPE_NORMAL
- en: So where can it be used? Actually it is being used everywhere. Think about a
    logging application, which can log errors in different ways when an error occurs.
    Think about a messenger application, which pops up when the latest message arrives.
    Think about a web bulletin board where the latest messages display automatically
    whenever a new message is posted. Well, there are thousands more. Let us implement
    this pattern.
  prefs: []
  type: TYPE_NORMAL
- en: '![Observer Pattern](img/2561_01_01_200.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Our entire `observer` objects implement `observer` interface as shown below:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Now some `observer` objects, which we will notify when the state of an observable
    object changes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Another notifier:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Now we need to create our `observer`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Now let us use it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: Proxy Pattern or Lazy Loading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Another very important programming practice in OOP is lazy loading and loose
    coupling. The main idea is to decrease the concrete dependency among objects while
    coding. What is the benefit of such programming? One simple answer—it always increases
    the portability of your code.
  prefs: []
  type: TYPE_NORMAL
- en: Using the Proxy pattern you can create a local version of a remote object. It
    provides a common API for accessing methods of a remote object without knowing
    the things behind the scene. The best example of a Proxy pattern could be the
    XML RPC and SOAP client and server for PHP.
  prefs: []
  type: TYPE_NORMAL
- en: Let's take a look at the following code. Here we are creating a class, which
    can access any method of a remotely created object. The methods of a remote object
    are exposed via the XML RPC server and then they are accessed via XML RPC clients.
  prefs: []
  type: TYPE_NORMAL
- en: '![Proxy Pattern or Lazy Loading](img/2561_04_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'If you are wondering how it works, you will find that almost every blog engine
    supports three popular blogging API: i.e. Blogger, MetaWebLog, and MovableType.
    Using these methods you can remotely manage your blog. Which methods are supported,
    will depend on the blog engine.'
  prefs: []
  type: TYPE_NORMAL
- en: We will use Incutio PHP XML-RPC library to create a sample server and client
    object. Let us create a server first. You can download the XML-RPC Library from
    here:[http://scripts.incutio.com/xmlrpc/IXR_Library.inc.php.txt](http://scripts.incutio.com/xmlrpc/IXR_Library.inc.php.txt)
  prefs: []
  type: TYPE_NORMAL
- en: 'We are creating a time server from which we can get Greenwich Mean Time (GMT):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Well very simple. We just create some methods and then map them to the XML
    RPC server. Now let us see how we can code for clients:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'If you place the server in your web server (here `localhost`) document, the
    root in a folder named `proxy` and then access the client, you will get the following
    output:'
  prefs: []
  type: TYPE_NORMAL
- en: '**March, 28 2007 16:13:20**'
  prefs: []
  type: TYPE_NORMAL
- en: That's it! This is how Proxy pattern works and gives interface to remote objects
    for local applications.
  prefs: []
  type: TYPE_NORMAL
- en: Decorator Pattern
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Decorator pattern is an important problem-solving approach introduced by GoF
    in their legendary design pattern book. Using this pattern you can add additional
    functionalities in an existing object without extending an object. So you might
    ask what is the benefit of adding additional functionalities without inheritance.
  prefs: []
  type: TYPE_NORMAL
- en: Well, there certainly are some benefits. To extend an object, sometimes you
    need to know many inner things of that class. Sometimes it's not possible to extend
    the class without rewriting the existing functionalities. If you want to add the
    same functionalities to many types of objects, it is much better to add them using
    Decorator pattern instead of extending all of them individually. Otherwise it
    might lead you to a horrible maintenance nightmare.
  prefs: []
  type: TYPE_NORMAL
- en: '![Decorator Pattern](img/2561_04_08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Let us go for a common scenario. For example, imagine that you are building
    a blog or message board where all your posts and comments come as separate post
    and comment objects. Both of these objects have a common method `getContents()`
    which returns the filtered content of that post or comment.
  prefs: []
  type: TYPE_NORMAL
- en: Now your manager is asking to add functionalities to parse emoticon and BBCode
    of those posts and comments. The core code is complex and you don't want to touch
    it anymore. Here Decorator pattern comes to save your life.
  prefs: []
  type: TYPE_NORMAL
- en: Let us see our `Post` and `Comment` object first.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we create two Decorator objects, which can parse the BBCode and Emoticon
    respectively:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'And here comes the emoticon parser:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: These Decorator objects just add the BBCode and EmoticonCode parsing capability
    to the existing objects without touching them.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let us see how we can use that:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: This is how you can add additional functionalities to existing objects without
    even touching them. However, you saw that BBCodeParser and EmoticonParser accept
    any object, which means that if you supply an object, which doesn't have any method
    named `getContent()`, the code will crash. So you can implement a common interface
    in those objects, which you might want to decorate. Also in the Decorator object
    you can accept only those objects, which implement that or those interfaces.
  prefs: []
  type: TYPE_NORMAL
- en: Active Record Pattern
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This is another very important design pattern to simplify database manipulation.
    We will learn more about this pattern in Chapter 7\.
  prefs: []
  type: TYPE_NORMAL
- en: Facade Pattern
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So far we have learned many common problem-solving approaches using design patterns
    in OOP. Here comes another interesting pattern, which we often use unintentionally
    in our code without knowing that it is also a pattern. Let us learn about this
    common pattern named Facade pattern.
  prefs: []
  type: TYPE_NORMAL
- en: Facade provides a common interface to many objects. In other words, it just
    simplifies the programming providing a necessary interface, which actually uses
    a lot of other objects behind the scenes. Thus it minimizes the learning curve
    for developers. When a new developer joins the team, he suddenly gets introduced
    to a lot of objects with tons of methods and properties, among which he might
    need a few to accomplish his work. So why bother spending time learning them all?
    This is where Facade helps developers and saves a lot of their time. Let's look
    at some examples to understand it more clearly.
  prefs: []
  type: TYPE_NORMAL
- en: Suppose you are creating an apartment rental system, where you have three objects
    in your repository. One object performs the geocoding with the help of online
    geocoding services. Another object locates that place using a map service. Finally,
    another service searches all the apartments for sale in that area.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now you want to create an easier interface over these three so that any future
    developer can work with your library instead of studying them all together. The
    following picture shows us the code structure before there is a Facade:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Facade Pattern](img/2561_04_09.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Here is the code structure after using Facade:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Facade Pattern](img/2561_04_10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Now let us take a look at the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'These are our concrete classes. Now you want to develop a Facade using all
    of them and provide an easier interface for developers. See how easy it makes
    combining three of them:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'Anyone can now use the service of all three classes using only one single interface
    Facade:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: As I said before, in object oriented programming we have done this type of job
    several times in our times in our project, however we might not have known that
    the technique is defined as a design pattern named Facade.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Design patterns are an essential part of OOP. It makes your code more effective,
    better performing, and easier to maintain. Sometimes we implement these design
    patterns in our code without knowing that these solutions are defined as design
    patterns. There are many design patterns as well, which we cannot cover in this
    book, because it would then simply be a book on just design patterns. However,
    if you are interested in learning other design patterns, you can read *Head First
    Design Patterns* published by O'reilly and *Design Patterns Explained* by Addison-Wesley.
  prefs: []
  type: TYPE_NORMAL
- en: Don't think that you have to implement design pattern in your code. Use them
    only when you need them. Proper usage of correct patterns can make your code perform
    better; similarly using them improperly could make your code slow and less efficient.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter we will learn about another important section of OOP in
    PHP. That is Unit testing and Reflections. Until then, keep playing with the patterns
    and explore them.
  prefs: []
  type: TYPE_NORMAL
