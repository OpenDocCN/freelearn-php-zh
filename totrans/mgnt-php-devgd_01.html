<html><head></head><body><div class="chapter" title="Chapter&#xA0;1.&#xA0;Magento Fundamentals for Developers"><div class="titlepage"><div><div><h1 class="title"><a id="ch01"/>Chapter 1. Magento Fundamentals for Developers</h1></div></div></div><p>In this chapter, we will cover the fundamental concepts of working with Magento. We will learn how Magento is structured, and go over the source of Magento's flexibility, that is, its modular architecture.</p><p>Magento is a flexible and powerful system. Unfortunately, this adds some level of complexity as well. Currently, a clean installation of Magento has around 20,000 files and over 1.2 million lines of code.</p><p>With all that power and complexity, Magento can be daunting for new developers; but don't worry. This chapter is designed to give new developers all the fundamental concepts and tools they need to use and extend Magento, and in the next chapter, we will dive deep into Magento models and data collection.</p><div class="section" title="Zend Framework – the base of Magento"><div class="titlepage"><div><div><h1 class="title"><a id="ch01lvl1sec08"/>Zend Framework – the base of Magento</h1></div></div></div><p>As you <a id="id0" class="indexterm"/>probably know, Magento is the most powerful e-commerce platform <a id="id1" class="indexterm"/>in the market. What you might not know about Magento is that it is also an object-oriented (OO) PHP framework developed on top of <span class="strong"><strong>Zend Framework</strong></span>.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note02"/>Note</h3><p>Zend Framework 2 has been available since 2013, but Magento still relies on Zend Framework 1.11.</p></div></div><p>Here's how Zend's official site describes the framework:</p><div class="blockquote"><blockquote class="blockquote"><p><span class="emphasis"><em>"We designed Zend Framework with simplicity in mind. To provide a lightweight, loosely-coupled component library simplified to provide 4/5s of the functionality everyone needs and that lets you customize the other 20% to meet your specific business needs. By focusing on the most commonly needed functionality, we retain the simplified spirit of PHP programming, while dramatically lower the learning curve – and your training costs – so developers get up-to-speed quickly."</em></span></p><p><a class="ulink" href="http://files.zend.com/help/Zend-Server-5/zend_framework.htm">http://files.zend.com/help/Zend-Server-5/zend_framework.htm</a></p></blockquote></div><p>What exactly is <a id="id2" class="indexterm"/>Zend Framework? Zend Framework is an OO framework developed on PHP that implements the <a id="id3" class="indexterm"/>
<span class="strong"><strong>Model-View-Controller</strong></span> (MVC) paradigm. When<a id="id4" class="indexterm"/> <span class="strong"><strong>Varien</strong></span> (now Magento Inc.) started developing Magento, they decided to do it on top of Zend because of some components, some of which are as follows:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">Zend_Cache</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">Zend_Acl</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">Zend_Locale</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">Zend_DB</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">Zend_Pdf</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">Zend_Currency</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">Zend_Date</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">Zend_Soap</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">Zend_Http</code></li></ul></div><p>In total, Magento uses around 15 different Zend components. The Varien library extends several of the Zend components mentioned before directly. For example, <code class="literal">Varien_Cache_Core</code> extends from <code class="literal">Zend_Cache_Core</code>.</p><p>Using Zend Framework, Magento was built with the following principles in mind:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Maintainable</strong></span>: By <a id="id5" class="indexterm"/>using code pools to keep the core code separate from local customizations and third-party modules</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Upgradable</strong></span>: Magento <a id="id6" class="indexterm"/>modularity allows extensions and third-party modules to be updated independently from the rest of the system</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Flexible</strong></span>: Allows <a id="id7" class="indexterm"/>seamless customization and simplifies the development of new features</li></ul></div><p>Although experience of using Zend Framework or even understanding it are not requirements to develop Magento, having at least some basic understanding of the Zend components, usage, and interaction can be invaluable information as we start digging deeper into the core of Magento.</p><p>You can learn more about <a id="id8" class="indexterm"/>Zend Framework at <a class="ulink" href="http://framework.zend.com/">http://framework.zend.com/</a>.</p></div></div>
<div class="section" title="The Magento folder structure"><div class="titlepage"><div><div><h1 class="title"><a id="ch01lvl1sec09"/>The Magento folder structure</h1></div></div></div><p>The<a id="id9" class="indexterm"/> Magento folder structure is slightly different from other MVC applications. Let's take a look at the directory tree, and each directory and its functions:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">app</code>: This <a id="id10" class="indexterm"/>folder is the core of Magento and is subdivided into three important directories:<div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">code</code>: This contains all our application code divided into three code pools, namely core, community, and local</li><li class="listitem" style="list-style-type: disc"><code class="literal">design</code>: This contains all the templates and layouts for our application</li><li class="listitem" style="list-style-type: disc"><code class="literal">locale</code>: This contains all the translation and e-mail template files used for the store</li></ul></div></li><li class="listitem" style="list-style-type: disc"><code class="literal">js</code>: This <a id="id11" class="indexterm"/>contains all the JavaScript libraries that are used in Magento</li><li class="listitem" style="list-style-type: disc"><code class="literal">media</code>: This<a id="id12" class="indexterm"/> contains all the images and media files for our products and CMS pages, as well the product image cache</li><li class="listitem" style="list-style-type: disc"><code class="literal">lib</code>: This <a id="id13" class="indexterm"/>contains all the third-party libraries used in Magento (such as Zend and PEAR) as well as the custom libraries developed by Magento, which reside under the <code class="literal">Varien</code> and <code class="literal">Mage</code> directories</li><li class="listitem" style="list-style-type: disc"><code class="literal">skin</code>: This<a id="id14" class="indexterm"/> contains all CSS, images and JavaScript used by the corresponding theme</li><li class="listitem" style="list-style-type: disc"><code class="literal">var</code>: This<a id="id15" class="indexterm"/> contains our temporary data, such as the cache file, index lock files, sessions, import/export files, and in the case of the Enterprise edition, the full page cache folders</li></ul></div><p>Magento is a modular system. This means the application, including the core, is divided into smaller modules. For this reason, the folder structure plays a key role in the organization of each module. A typical Magento module folder structure would look something like this:</p><div class="mediaobject"><img src="graphics/4195OS_01_01.jpg" alt="The Magento folder structure"/></div><p>Let's review<a id="id16" class="indexterm"/> each folder further:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">Block</code>: In <a id="id17" class="indexterm"/>Magento, blocks form an additional layer of logic between the controllers and views</li><li class="listitem" style="list-style-type: disc"><code class="literal">controllers</code>: These<a id="id18" class="indexterm"/> are formed by actions that process webserver requests</li><li class="listitem" style="list-style-type: disc"><code class="literal">Controller</code>: Classes<a id="id19" class="indexterm"/> in this folder can be abstract classes and they can be extended by the <code class="literal">controller</code> class under the <code class="literal">controllers</code> folder</li><li class="listitem" style="list-style-type: disc"><code class="literal">etc</code>: In this <a id="id20" class="indexterm"/>we can find the module-specific configuration in the form of XML files such as <code class="literal">config.xml</code> and <code class="literal">system.xml</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">Helper</code>: This<a id="id21" class="indexterm"/> contains auxiliary classes that encapsulate a common module functionality and make them available to a class of the same module and to other modules classes as well</li><li class="listitem" style="list-style-type: disc"><code class="literal">Model</code>: This <a id="id22" class="indexterm"/>contains models that support the controllers in the module to interact with data</li><li class="listitem" style="list-style-type: disc"><code class="literal">sql</code>: These <a id="id23" class="indexterm"/>contain the installation and upgrade files for each specific module</li><li class="listitem" style="list-style-type: disc"><code class="literal">data</code>: This <a id="id24" class="indexterm"/>folder was introduced in Magento 1.6 CE and it is used in a manner similar to SQL scripts, but data scripts are only concerned about inserting data</li></ul></div><p>As we will see later in this chapter, Magento makes heavy use of factory names and factory methods. This is why the folder structure is so important.</p></div>
<div class="section" title="Modular architecture"><div class="titlepage"><div><div><h1 class="title"><a id="ch01lvl1sec10"/>Modular architecture</h1></div></div></div><p>Rather than<a id="id25" class="indexterm"/> being a large application, Magento is built by smaller modules, each adding specific functionality to Magento.</p><p>One of the advantages of this <a id="id26" class="indexterm"/>approach is the ability to enable and disable specific module functionality with ease as well as adding new functionality by adding new modules.</p><div class="section" title="Autoloader"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec08"/>Autoloader</h2></div></div></div><p>Magento <a id="id27" class="indexterm"/>is a huge framework composed by close to 20,000 files. Requiring every single file when the application starts would make it incredibly slow and resource intensive. Hence, Magento makes use of an autoloader class to require the files each time a factory method is called.</p><p>So what exactly is an autoloader? PHP5 includes a function called <code class="literal">__autoload()</code>. When instantiating a class, the <code class="literal">__autoload()</code> function is automatically called. Inside this function, the custom logic is defined to parse the class name and require the file.</p><p>Let's take a closer look at the Magento Bootstrap code located in <code class="literal">app/Mage.php</code>:</p><div class="informalexample"><pre class="programlisting">
<code class="literal">…</code> 
Mage::register('original_include_path', get_include_path());
if (defined('COMPILER_INCLUDE_PATH')) {
    $appPath = COMPILER_INCLUDE_PATH;
    set_include_path($appPath . PS . Mage::registry('original_include_path'));
    include_once "Mage_Core_functions.php";
    include_once "Varien_Autoload.php";
} else {
    /**
     * Set include path
     */
    $paths[] = BP . DS . 'app' . DS . 'code' . DS . 'local';
    $paths[] = BP . DS . 'app' . DS . 'code' . DS . 'community';
    $paths[] = BP . DS . 'app' . DS . 'code' . DS . 'core';
    $paths[] = BP . DS . 'lib';

    $appPath = implode(PS, $paths);
    set_include_path($appPath . PS . Mage::registry('original_include_path'));
    include_once "Mage/Core/functions.php";
    include_once "Varien/Autoload.php";
}

Varien_Autoload::register();</pre></div><p>The Bootstrap <a id="id28" class="indexterm"/>file takes care of defining the include paths and initializing the Varien autoloader, which will in turn define its own autoload function as the default function to call. Let's take a look under the hood and see what the Varien's autoload function is doing:</p><div class="informalexample"><pre class="programlisting">    /**
     * Load class source code
     *
     * @param string $class
     */
    public function autoload($class)
    {
        if ($this-&gt;_collectClasses) {
            $this-&gt;_arrLoadedClasses[self::$_scope][] = $class;
        }
        if ($this-&gt;_isIncludePathDefined) {
            $classFile =  COMPILER_INCLUDE_PATH . DIRECTORY_SEPARATOR . $class;
        } else {
            $classFile = str_replace(' ', DIRECTORY_SEPARATOR, ucwords(str_replace('_', ' ', $class)));
        }
        $classFile.= '.php';
        //echo $classFile;die();
        return include $classFile;
    }</pre></div><p>The <code class="literal">autoload</code> class takes a single parameter called <code class="literal">$class</code>, which is an alias provided by the factory method. This alias is processed to generate a matching class name that is then included.</p><p>As we mentioned <a id="id29" class="indexterm"/>before, Magento's directory structure is important due to the fact that Magento derives its class names from the directory structure. This convention is the core principle behind factory methods, which we will be reviewing later in this chapter.</p></div><div class="section" title="Code pools"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec09"/>Code pools</h2></div></div></div><p>As<a id="id30" class="indexterm"/> mentioned before, inside our <code class="literal">app/code</code> folder, we have our application code divided into the following three different directories known as code pools:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">core</code>: This is where the Magento Core modules that provide the base functionality reside. The golden rule among Magento developers is that you should never, under any circumstance, modify any files under the core code pool.</li><li class="listitem" style="list-style-type: disc"><code class="literal">community</code>: This is the location where third-party modules are placed. They are either provided by third parties or installed through Magento Connect.</li><li class="listitem" style="list-style-type: disc"><code class="literal">local</code>: This is where all the modules and code developed specifically for this instance of Magento reside.</li></ul></div><p>The code pools identify where the module came from and in which order they should be loaded. If we take another look at the <code class="literal">Mage.php</code> Bootstrap file, we can see the order in which code pools are loaded:</p><div class="informalexample"><pre class="programlisting">    $paths[] = BP . DS . 'app' . DS . 'code' . DS . 'local';
    $paths[] = BP . DS . 'app' . DS . 'code' . DS . 'community';
    $paths[] = BP . DS . 'app' . DS . 'code' . DS . 'core';
    $paths[] = BP . DS . 'lib';</pre></div><p>This means, for each class request, Magento will look in the <code class="literal">local</code> folder, then in the community and <code class="literal">core</code> folders, and finally inside the <code class="literal">lib</code> folder.</p><p>This also produces an interesting behavior that can easily be used to override core and community classes by just copying the directory structure and matching the class name.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip02"/>Tip</h3><p>Needless to say, this is a terrible practice, but it is still useful to know about, just in case someday you have to take care of a project that exploits this behavior.</p></div></div></div></div>
<div class="section" title="Routing and request flow"><div class="titlepage"><div><div><h1 class="title"><a id="ch01lvl1sec11"/>Routing and request flow</h1></div></div></div><p>Before going<a id="id31" class="indexterm"/> into more detail about the different components that form a part of Magento, it is important that we understand how these components interact together and how Magento processes requests coming from the web server.</p><p>As with any other PHP application, we have a single file as an entry point for every request. In the case of Magento, this file is <code class="literal">index.php</code>, which is in charge of loading the <code class="literal">Mage.php</code> Bootstrap class and starting the request cycle.</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">The web server receives the request and Magento is instantiated by calling the Bootstrap file <code class="literal">Mage.php</code>.</li><li class="listitem">The frontend controller is instantiated and initialized. During this controller initialization, Magento searches for the web routes and instantiates them.</li><li class="listitem">Magento then iterates through each of the routers and calls the match. The match method is responsible for processing the URL and generating the corresponding controller and action.</li><li class="listitem">Instantiates the matching controller and corresponding action.</li></ol></div><p>Routers are especially important in this process. Router objects are used by the frontend controller to match a requested URL (route) to a module controller and action. By default, Magento comes with the following routers:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">Mage_Core_Controller_Varien_Router_Admin</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">Mage_Core_Controller_Varien_Router_Standard</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">Mage_Core_Controller_Varien_Router_Cms</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">Mage_Core_Controller_Varien_Router_Default</code></li></ul></div><p>The action controller will then load and render the layout, which in turn will load the corresponding blocks, models, and templates.</p><p>Let's analyze how Magento will handle a request to a category page. We will use <code class="literal">http://localhost/catalog/category/view/id/10</code> as an example. The Magento URI comprises three parts, namely <code class="literal">FrontName/ControllerName/ActionName</code>.</p><p>Hence, for our example URL, the breakdown is as follows:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">FrontName</code>: This is a catalog</li><li class="listitem" style="list-style-type: disc"><code class="literal">ControllerName</code>: This is a category</li><li class="listitem" style="list-style-type: disc"><code class="literal">ActionName</code>: This is a view</li></ul></div><p>Let's take a look<a id="id32" class="indexterm"/> at the Magento router class <code class="literal">Mage_Core_Controller_Varien_Router_Standard</code> match function:</p><div class="informalexample"><pre class="programlisting">public function match(Zend_Controller_Request_Http $request)
{
  …
   $path = trim($request-&gt;getPathInfo(), '/');
            if ($path) {
                $p = explode('/', $path);
            } else {
                $p = explode('/', $this-&gt;_getDefaultPath());
            }
  …
}</pre></div><p>From the previous code, we can see that the first thing the router tries to do is parse the URI into an array. Based on our example URL, the corresponding array will be similar to the following code:</p><div class="informalexample"><pre class="programlisting">$p = Array
(
    [0] =&gt; catalog
    [1] =&gt; category
    [2] =&gt; view
)</pre></div><p>The next part of the function will first try to check if the request has the module name specified. If not, then it tries to determine the module name, based on the first element of our array. If a module name can't be provided, then the function will return false. Let's take a look at this part of the code:</p><div class="informalexample"><pre class="programlisting">      // get module name
        if ($request-&gt;getModuleName()) {
            $module = $request-&gt;getModuleName();
        } else {
            if (!empty($p[0])) {
                $module = $p[0];
            } else {
                $module = $this-&gt;getFront()-&gt;getDefault('module');
                $request-&gt;setAlias(Mage_Core_Model_Url_Rewrite::REWRITE_REQUEST_PATH_ALIAS, '');
            }
        }
        if (!$module) {
            if (Mage::app()-&gt;getStore()-&gt;isAdmin()) {
                $module = 'admin';
            } else {
                return false;
            }
        }</pre></div><p>Next, the <code class="literal">match</code> function<a id="id33" class="indexterm"/> will iterate through each of the available modules and try to match the controller and action using the following code:</p><div class="informalexample"><pre class="programlisting">…
        foreach ($modules as $realModule) {
            $request-&gt;setRouteName($this-&gt;getRouteByFrontName($module));

            // get controller name
            if ($request-&gt;getControllerName()) {
                $controller = $request-&gt;getControllerName();
            } else {
                if (!empty($p[1])) {
                    $controller = $p[1];
                } else {
                    $controller = $front-&gt;getDefault('controller');
                    $request-&gt;setAlias(
                        Mage_Core_Model_Url_Rewrite::REWRITE_REQUEST_PATH_ALIAS,
                        ltrim($request-&gt;getOriginalPathInfo(), '/')
                    );
                }
            }

            // get action name
            if (empty($action)) {
                if ($request-&gt;getActionName()) {
                    $action = $request-&gt;getActionName();
                } else {
                    $action = !empty($p[2]) ? $p[2] : $front-&gt;getDefault('action');
                }
            }

            //checking if this place should be secure
            $this-&gt;_checkShouldBeSecure($request, '/'.$module.'/'.$controller.'/'.$action);

            $controllerClassName = $this-&gt;_validateControllerClassName($realModule, $controller);
            if (!$controllerClassName) {
                continue;
            }

            // instantiate controller class
            $controllerInstance = Mage::getControllerInstance($controllerClassName, $request, $front-&gt;getResponse());

            if (!$controllerInstance-&gt;hasAction($action)) {
                continue;
            }

            $found = true;
            break;
        }
...</pre></div><p>Now that looks<a id="id34" class="indexterm"/> like an awful lot of code! Let's break it down further. The first part of the loop will check if the request has a controller name. If it is not set, it will check our parameter array's (<code class="literal">$p</code>) second value and try to determine the controller name. Then, it will try to do the same for the action name.</p><p>If we get this far in the loop, we should have a module name, a controller name, and an action name. Magento will now use these to try and get matched with the Controller class name by calling the following code:</p><div class="informalexample"><pre class="programlisting">$controllerClassName = $this-&gt;_validateControllerClassName($realModule, $controller);</pre></div><p>This function will not only generate a matching class name, but it will also validate its existence. In our example case, this function should return <code class="literal">Mage_Catalog_CategoryController</code>.</p><p>As we now have a valid class name, we can proceed to instantiate our controller object. You may probably notice that so far we haven't done anything with our action yet, and that's precisely the next step on our loop.</p><p>Now, our<a id="id35" class="indexterm"/> instantiated controller comes with a very handy function called <code class="literal">hasAction()</code>. In essence, all this function does is call a PHP function called <code class="literal">is_callable()</code>, which will check if our current controller has a public function matching the action name. In our case this will be <code class="literal">viewAction()</code>.</p><p>The reason behind this elaborate matching process and the use of a <code class="literal">foreach</code> loop is that it is possible for several modules to use the same <code class="literal">frontName</code>:</p><div class="mediaobject"><img src="graphics/4195OS_01_03.jpg" alt="Routing and request flow"/></div><p>Now, <code class="literal">http://localhost/catalog/category/view/id/10</code> is not a very user-friendly URL. Fortunately, Magento has its own URL rewrite system that allows us to use <code class="literal">http://localhost/books.html</code>.</p><p>Let's dig a little deeper into the URL rewrite system and see how Magento gets the controller and action names from our URL alias. Inside our <code class="literal">Varien/Front.php</code> controller dispatch function, Magento will call the following action:</p><div class="informalexample"><pre class="programlisting">Mage::getModel('core/url_rewrite')-&gt;rewrite();</pre></div><p>Before <a id="id36" class="indexterm"/>actually looking into the inner working of the rewrite function, let's take a look at the structure of the <code class="literal">core/url_rewrite</code> model:</p><div class="informalexample"><pre class="programlisting">Array (
  ["url_rewrite_id"] =&gt; "10"
  ["store_id"]       =&gt; "1"
  ["category_id"]    =&gt; "10"
  ["product_id"]     =&gt; NULL
  ["id_path"]        =&gt; "category/10"
  ["request_path"]   =&gt; "books.html"
  ["target_path"]    =&gt; "catalog/category/view/id/10"
  ["is_system"]      =&gt; "1"
  ["options"]        =&gt; NULL
  ["description"]    =&gt; NULL
)</pre></div><p>As we can see, the rewrite module comprises several properties, but only two of them are of particular interest to us, namely <code class="literal">request_path</code> and <code class="literal">target_path</code>. Simply put, the job of the rewrite module is to modify the request object path information with the matching values of <code class="literal">target_path</code>.</p></div>
<div class="section" title="The Magento version of MVC"><div class="titlepage"><div><div><h1 class="title"><a id="ch01lvl1sec12"/>The Magento version of MVC</h1></div></div></div><p>If you are <a id="id37" class="indexterm"/>familiar with traditional MVC implementations such as CakePHP or Symfony, you may know that the most common implementation is called a convention-based MVC. With a convention-based MVC to add a new Model, or let's say a Controller, you only need to create the file/class (following the framework conventions); the system will pick it up automatically.</p><p>Magento on the other hand uses a configuration-based MVC pattern, which means creating our file/class is not enough; we have to tell Magento explicitly that we have added a new class using configuration files written in XML.</p><p>Each Magento module has a <code class="literal">config.xml</code> file that is located under the module's <code class="literal">etc/</code> directory and contains all the relevant module configurations. For example, if we want to add a new module that includes a new model, we need to define a node in the configuration file that tells Magento where to find our model. Here's an example:</p><div class="informalexample"><pre class="programlisting">&lt;global&gt;
…
&lt;models&gt;
     &lt;group_classname&gt;
          &lt;class&gt;Namespace_Modulename_Model&lt;/class&gt;
     &lt;group_classname&gt;
&lt;/models&gt;
...
&lt;/global&gt;</pre></div><p>Although this <a id="id38" class="indexterm"/>might look like additional work, it also gives us a huge amount of flexibility and power. For example, we can rewrite another class by using the rewrite node:</p><div class="informalexample"><pre class="programlisting">&lt;global&gt;
…
&lt;models&gt;
     &lt;modulenamemodulename&gt;
      &lt;rewrite&gt;
             &lt;groupgroup_classname&gt;Namespace_Modulename_Model&lt;/groupgroup_classname&gt;
      &lt;/rewrite&gt;
     &lt;//modulename&gt;
&lt;/models&gt;
...
&lt;/global&gt;</pre></div><p>Magento will then load all the <code class="literal">config.xml</code> files and merge them at runtime, creating a single configuration tree.</p><p>Additionally, modules can also have a <code class="literal">system.xml</code> file that is used to specify configuration options in the Magento backend, which end users can in turn use to configure the module functionality. A snippet of a <code class="literal">system.xml</code> file will look like this:</p><div class="informalexample"><pre class="programlisting">&lt;config&gt;
  &lt;sections&gt;
    &lt;section_name translate="label"&gt;
      &lt;label&gt;Section Description&lt;/label&gt;
      &lt;tab&gt;general&lt;/tab&gt;
      &lt;frontend_type&gt;text&lt;/frontend_type&gt;
      &lt;sort_order&gt;1000&lt;/sort_order&gt;
      &lt;show_in_default&gt;1&lt;/show_in_default&gt;
      &lt;show_in_website&gt;1&lt;/show_in_website&gt;
      &lt;show_in_store&gt;1&lt;/show_in_store&gt;
      &lt;groups&gt;
       &lt;group_name translate="label"&gt;
         &lt;label&gt;Demo Of Config Fields&lt;/label&gt;
         &lt;frontend_type&gt;text&lt;/frontend_type&gt;
         &lt;sort_order&gt;1&lt;/sort_order&gt;
         &lt;show_in_default&gt;1&lt;/show_in_default&gt;
         &lt;show_in_website&gt;1&lt;/show_in_website&gt;
         &lt;show_in_store&gt;1&lt;/show_in_store&gt;  
   &lt;fields&gt;
          &lt;field_name translate="label comment"&gt;
             &lt;label&gt;Enabled&lt;/label&gt;
             &lt;comment&gt;
               &lt;![CDATA[Comments can contain &lt;strong&gt;HTML&lt;/strong&gt;]]&gt;
             &lt;/comment&gt;
             &lt;frontend_type&gt;select&lt;/frontend_type&gt;
             &lt;source_model&gt;adminhtml/system_config_source_yesno&lt;/source_model&gt;
             &lt;sort_order&gt;10&lt;/sort_order&gt;
             &lt;show_in_default&gt;1&lt;/show_in_default&gt;
             &lt;show_in_website&gt;1&lt;/show_in_website&gt;
             &lt;show_in_store&gt;1&lt;/show_in_store&gt;
          &lt;/field_name&gt;
         &lt;/fields&gt;
        &lt;/group_name&gt;
       &lt;/groups&gt;
    &lt;/section_name&gt;
  &lt;/sections&gt;
&lt;/config&gt;</pre></div><p>Let's break<a id="id39" class="indexterm"/> down each node function:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">section_name</code>: This is just an arbitrary name that we use to identify our configuration section. Inside this node, we will specify all the fields and groups for the configuration section.</li><li class="listitem" style="list-style-type: disc"><code class="literal">group</code>: Groups, as the name implies, are used to group configuration options and display them inside an accordion section.</li><li class="listitem" style="list-style-type: disc"><code class="literal">label</code>: This defines the title or label to be used on the field/section/group.</li><li class="listitem" style="list-style-type: disc"><code class="literal">tab</code>: This defines the tab on which the section should be displayed.</li><li class="listitem" style="list-style-type: disc"><code class="literal">frontend_type</code>: This node<a id="id40" class="indexterm"/> allows us to specify which renderer to use for our custom option field. Some of the available options are as follows:<div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Button</li><li class="listitem" style="list-style-type: disc">Checkboxes</li><li class="listitem" style="list-style-type: disc">Checkbox</li><li class="listitem" style="list-style-type: disc">Date</li><li class="listitem" style="list-style-type: disc">File</li><li class="listitem" style="list-style-type: disc">Hidden</li><li class="listitem" style="list-style-type: disc">Image</li><li class="listitem" style="list-style-type: disc">Label</li><li class="listitem" style="list-style-type: disc">Link</li><li class="listitem" style="list-style-type: disc">Multiline</li><li class="listitem" style="list-style-type: disc">Multiselect</li><li class="listitem" style="list-style-type: disc">Password</li><li class="listitem" style="list-style-type: disc">Radio</li><li class="listitem" style="list-style-type: disc">Radios</li><li class="listitem" style="list-style-type: disc">Select</li><li class="listitem" style="list-style-type: disc">Submit</li><li class="listitem" style="list-style-type: disc">Textarea</li><li class="listitem" style="list-style-type: disc">Text</li><li class="listitem" style="list-style-type: disc">Time</li></ul></div></li><li class="listitem" style="list-style-type: disc"><code class="literal">sort_order</code>: This specifies the position of the field, group, or section.</li><li class="listitem" style="list-style-type: disc"><code class="literal">source_model</code>: Certain type of fields, such as a select field, can take options from a source model. Magento already provides several useful classes under <code class="literal">Mage/Adminhtml/Model/System/Config/Source</code>. Some of the classes we can find are as follows:<div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">YesNo</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">Country</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">Currency</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">AllRegions</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">Category</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">Language</code></li></ul></div></li></ul></div><p>Just by using XML, we can build complex configuration options for our modules right on the Magento backend without having to worry about setting up templates, populating fields, or validating data. </p><p>Magento is also kind enough to <a id="id41" class="indexterm"/>provide a comprehensive amount of form field validation models that we can use with the <code class="literal">&lt;validate&gt;</code> tag. Among the field validators we have the following options:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">validate-email</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">validate-length</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">validate-url</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">validate-select</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">validate-password</code></li></ul></div><p>As with any other part of Magento, we can extend <code class="literal">source_models</code>, <code class="literal">frontend_types</code>, and validators, and even create new ones. We will be tackling this task in a later chapter, where we will create a new type of each. For now, we will explore the concepts of models, views, file layouts, and controllers.</p><div class="section" title="Models"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec10"/>Models</h2></div></div></div><p>Magento<a id="id42" class="indexterm"/> makes use of the ORM approach, although we can still use <code class="literal">Zend_Db</code> to access the database directly. We will be using models to access our<a id="id43" class="indexterm"/> data most of the time. For this type of task, Magento provides the following two types of models:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Simple models</strong></span>: These <a id="id44" class="indexterm"/>model implementations are a simple mapping of one object to one table, meaning our object attributes match each field and our table structure</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Entity Attribute Value (EAV) models</strong></span>: These<a id="id45" class="indexterm"/> type of models are used to describe entities with a dynamic number of attributes</li></ul></div><p>Magento splits the model layer in two parts: a model handling the business logic and a resource handling the database interaction. This design decision allows Magento to support multiple database platforms without having to change any of the logic inside the models.</p><p>Magento ORM<a id="id46" class="indexterm"/> uses one of PHP's magic class methods to provide dynamic access to object properties. In the next chapter, we will look into models, the Magento ORM, and the data collections in more detail.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note03"/>Note</h3><p>Magento models don't necessarily have to be related to any type table in the database or an EAV entity. Observers, which we will be reviewing later, are perfect examples of these type of Magento models.</p></div></div></div><div class="section" title="Views"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec11"/>Views</h2></div></div></div><p>The <a id="id47" class="indexterm"/>view layer is one of the areas where Magento truly sets itself apart from other MVC applications. Unlike traditional MVC systems, Magento's<a id="id48" class="indexterm"/> view layer is divided into three different components:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Layouts</strong></span>: These <a id="id49" class="indexterm"/>are XML files that define block structures and properties, such as name and which template file to use. Each Magento module has its own set of layout files.</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Blocks</strong></span>: These <a id="id50" class="indexterm"/>are used in Magento to reduce the burden on the controller by moving most of the logic into blocks.</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Templates</strong></span>: These<a id="id51" class="indexterm"/> are PHTML files that contain the HTML code and PHP tags required.</li></ul></div><p>Layouts give the Magento frontend an amazing amount of flexibility. Each module has its own layout XML files that tell Magento what to include and render on each page request. By using the layouts, we can move, add, or remove blocks from our store, without worrying about changing anything else other than our XML files.</p></div><div class="section" title="Dissecting a layout file"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec12"/>Dissecting a layout file</h2></div></div></div><p>Let's <a id="id52" class="indexterm"/>examine one of the Magento core layout files, in this case, the <code class="literal">catalog.xml</code> file:</p><div class="informalexample"><pre class="programlisting">&lt;layout version="0.1.0"&gt;
&lt;default&gt;
    &lt;reference name="left"&gt;
        &lt;block type="core/template" name="left.permanent.callout" template="callouts/left_col.phtml"&gt;
            &lt;action method="setImgSrc"&gt;&lt;src&gt;images/media/col_left_callout.jpg&lt;/src&gt;&lt;/action&gt;
            &lt;action method="setImgAlt" translate="alt" module="catalog"&gt;&lt;alt&gt;Our customer service is available 24/7.Call us at (555) 555-0123.&lt;/alt&gt;&lt;/action&gt;
            &lt;action method="setLinkUrl"&gt;&lt;url&gt;checkout/cart&lt;/url&gt;&lt;/action&gt;
        &lt;/block&gt;
    &lt;/reference&gt;
    &lt;reference name="right"&gt;
        &lt;block type="catalog/product_compare_sidebar" before="cart_sidebar" name="catalog.compare.sidebar" template="catalog/product/compare/sidebar.phtml"/&gt;
        &lt;block type="core/template" name="right.permanent.callout" template="callouts/right_col.phtml"&gt;
            &lt;action method="setImgSrc"&gt;&lt;src&gt;images/media/col_right_callout.jpg&lt;/src&gt;&lt;/action&gt;
            &lt;action method="setImgAlt" translate="alt" module="catalog"&gt;&lt;alt&gt;Visit our site and save A LOT!&lt;/alt&gt;&lt;/action&gt;
        &lt;/block&gt;
    &lt;/reference&gt;
    &lt;reference name="footer_links"&gt;
        &lt;action method="addLink" translate="label title" module="catalog" ifconfig="catalog/seo/site_map"&gt;&lt;label&gt;Site Map&lt;/label&gt;&lt;url helper="catalog/map/getCategoryUrl" /&gt;&lt;title&gt;Site Map&lt;/title&gt;&lt;/action&gt;
    &lt;/reference&gt;
    &lt;block type="catalog/product_price_template" name="catalog_product_price_template" /&gt;
&lt;/default&gt;</pre></div><p>Layout blocks<a id="id53" class="indexterm"/> comprise three main XML nodes:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Handle</strong></span>: Each <a id="id54" class="indexterm"/>page request will have several <a id="id55" class="indexterm"/>unique handles. The layout uses these handles to tell Magento which blocks to load and render on a per page basis. The most commonly used handles are the default handle and the <code class="literal">[frontname]_[controller]_[action]</code> handle.</li><li class="listitem" style="list-style-type: disc">The default handle is especially useful to set global blocks, for example, adding CSS or JavaScript to all pages on the header block.</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Reference</strong></span>: A <a id="id56" class="indexterm"/><code class="literal">&lt;reference&gt;</code> node<a id="id57" class="indexterm"/> is use to make references to a block. It is useful for the specification of nested blocks or modifying an already existing block. In our example, we can see how a new child blocks being specified inside <code class="literal">&lt;reference name="left"&gt;</code>.</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Block</strong></span>: The <a id="id58" class="indexterm"/><code class="literal">&lt;block&gt;</code> node<a id="id59" class="indexterm"/> is used to load our actual blocks. Each block node can have the following properties:<div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">type</code>: This is the identifier for the actual block class. For example, <code class="literal">catalog/product_list</code> makes reference to the <code class="literal">Mage_Catalog_Block_Product_List</code>.</li><li class="listitem" style="list-style-type: disc"><code class="literal">name</code>: This is the name used by other blocks to make a reference to this block.</li><li class="listitem" style="list-style-type: disc"><code class="literal">before/after</code>: These properties can be used to position the blocks relative to other block position. Both properties can use a hyphen as value to specify if the module should appear at the very top or the very bottom. </li><li class="listitem" style="list-style-type: disc"><code class="literal">template</code>: This property determines the <code class="literal">.phtml</code> template file that will be used to render the block.</li><li class="listitem" style="list-style-type: disc"><code class="literal">action</code>: Each block type has specific actions that affect the frontend functionality. For instance, the <code class="literal">page/html_head</code> block has actions to add CSS and <code class="literal">js</code> (<code class="literal">addJs</code> and <code class="literal">addCss</code>).</li><li class="listitem" style="list-style-type: disc"><code class="literal">as</code>: This is used to specify the unique identifier that we will be using to call the block from the template. For example, calling a child block by using <code class="literal">getChildHtml('block_name')</code>.</li></ul></div></li></ul></div><p>Blocks are a <a id="id60" class="indexterm"/>new concept that Magento implements in order to reduce the controller load. They are basically data resources that communicate directly with the models that manipulate the data if needed and then pass it to the views.</p><p>Finally, we have our <code class="literal">.phtml</code> files. Templates contain HTML and PHP tags and are in charge of formatting and displaying the data from our models. Let's take a look at a snippet from the product view template:</p><div class="informalexample"><pre class="programlisting">&lt;div class="product-view"&gt;
...
    &lt;div class="product-name"&gt;
        &lt;h1&gt;&lt;?php echo $_helper-&gt;productAttribute($_product, $_product-&gt;getName(), 'name') ?&gt;&lt;/h1&gt;
    &lt;/div&gt;
...           
    &lt;?php echo $this-&gt;getReviewsSummaryHtml($_product, false, true)?&gt;
    &lt;?php echo $this-&gt;getChildHtml('alert_urls') ?&gt;
    &lt;?php echo $this-&gt;getChildHtml('product_type_data') ?&gt;
    &lt;?php echo $this-&gt;getTierPriceHtml() ?&gt;
    &lt;?php echo $this-&gt;getChildHtml('extrahint') ?&gt;
...

    &lt;?php if ($_product-&gt;getShortDescription()):?&gt;
        &lt;div class="short-description"&gt;
            &lt;h2&gt;&lt;?php echo $this-&gt;__('Quick Overview') ?&gt;&lt;/h2&gt;
            &lt;div class="std"&gt;&lt;?php echo $_helper-&gt;productAttribute($_product, nl2br($_product-&gt;getShortDescription()), 'short_description') ?&gt;&lt;/div&gt;
        &lt;/div&gt;
    &lt;?php endif;?&gt;
...
&lt;/div&gt; </pre></div><p>The following<a id="id61" class="indexterm"/> is a diagram displaying the MVC model:</p><div class="mediaobject"><img src="graphics/4195OS_01_02.jpg" alt="Dissecting a layout file"/></div></div><div class="section" title="Controllers"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec13"/>Controllers</h2></div></div></div><p>The Magento MVC controllers<a id="id62" class="indexterm"/> are designed to be thin controllers. Thin controllers have little business logic and are mostly used to drive the application requests. A basic Magento controller action will just load and render the layout:</p><div class="informalexample"><pre class="programlisting">    public function viewAction()
    {
        $this-&gt;loadLayout();
        $this-&gt;renderLayout();
    }</pre></div><p>From here, it is the job of the blocks to handle the <span class="emphasis"><em>display logic</em></span> to get the data from our models, prepare the data, and send it to the views.</p></div></div>
<div class="section" title="Websites and store scopes"><div class="titlepage"><div><div><h1 class="title"><a id="ch01lvl1sec13"/>Websites and store scopes</h1></div></div></div><p>One of <a id="id63" class="indexterm"/>Magento's core features is the ability to handle multiple websites and stores with a single Magento installation. Internally, Magento refers to each of these instances as scopes.</p><div class="mediaobject"><img src="graphics/4195OS_01_06.jpg" alt="Websites and store scopes"/></div><p>Values for <a id="id64" class="indexterm"/>certain elements such as products, categories, attributes, and configuration are scope-specific and can differ on different scopes. This gives Magento tremendous flexibility. For example, a product can be set up on two different websites with different prices but still share the rest of the attribute configuration.</p><p>As developers, one of the areas where we will be using scopes the most is when working with configuration. The different <a id="id65" class="indexterm"/>configuration scopes available in Magento are as follows:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Global</strong></span>: As <a id="id66" class="indexterm"/>the name implies, this applies across all scopes.</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Website</strong></span>: These<a id="id67" class="indexterm"/> are defined by a domain name and are composed by one or more stores. Websites can be set up to share customer data or be completely isolated.</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Store</strong></span>: These<a id="id68" class="indexterm"/> are used to manage products and categories and to group store views. Stores also have a root category that allows us to have separated catalogs per store.</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Store view</strong></span>: By using <a id="id69" class="indexterm"/>store views, we can set up multiple languages on our store frontend.</li></ul></div><p>Configuration <a id="id70" class="indexterm"/>options in Magento can store values on three scopes (global, website, and store views). By default, all the values are set on the global scope. Using <code class="literal">system.xml</code> on our modules, we can specify the scopes on which the configuration options can be set. Let's revisit our previous <code class="literal">system.xml</code> file:</p><div class="informalexample"><pre class="programlisting">…
&lt;field_name translate="label comment"&gt;
    &lt;label&gt;Enabled&lt;/label&gt;
    &lt;comment&gt;
         &lt;![CDATA[Comments can contain &lt;strong&gt;HTML&lt;/strong&gt;]]&gt;
     &lt;/comment&gt;
     &lt;frontend_type&gt;select&lt;/frontend_type&gt;
     &lt;source_model&gt;adminhtml/system_config_source_yesno&lt;/source_model&gt;
     &lt;sort_order&gt;10&lt;/sort_order&gt;
     &lt;show_in_default&gt;1&lt;/show_in_default&gt;
     &lt;show_in_website&gt;1&lt;/show_in_website&gt;
     &lt;show_in_store&gt;1&lt;/show_in_store&gt;
&lt;/field_name&gt;
…</pre></div></div>
<div class="section" title="Factory names and functions"><div class="titlepage"><div><div><h1 class="title"><a id="ch01lvl1sec14"/>Factory names and functions</h1></div></div></div><p>Magento<a id="id71" class="indexterm"/> makes use of factory methods to instantiate models, helpers, and block classes. A factory method is a design pattern that allows us to instantiate an object <a id="id72" class="indexterm"/>without using the exact class name and using a class alias instead.</p><p>Magento implements the following factory methods:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">Mage::getModel()</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">Mage::getResourceModel()</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">Mage::helper()</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">Mage::getSingleton()</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">Mage::getResourceSingleton()</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">Mage::getResourceHelper()</code></li></ul></div><p>Each of these methods takes a class alias that is used to determine the real class name of the object<a id="id73" class="indexterm"/> that we are trying to instantiate. For example, if we want to instantiate a product object, we can do so by calling the <code class="literal">getModel()</code> method:</p><div class="informalexample"><pre class="programlisting">$product = Mage::getModel('catalog/product'); </pre></div><p>Notice that we are passing a factory name composed of <code class="literal">group_classname</code>/<code class="literal">model_name</code>. Magento will resolve this to the actual class name of <code class="literal">Mage_Catalog_Model_Product</code>. Let's take a closer look at the inner workings of <code class="literal">getModel()</code>:</p><div class="informalexample"><pre class="programlisting">public static function getModel($modelClass = '', $arguments = array())
    {
        return self::getConfig()-&gt;getModelInstance($modelClass, $arguments);
    }

getModel calls the getModelInstance from the Mage_Core_Model_Config class.

public function getModelInstance($modelClass='', $constructArguments=array())
{
    $className = $this-&gt;getModelClassName($modelClass);
    if (class_exists($className)) {
        Varien_Profiler::start('CORE::create_object_of::'.$className);
        $obj = new $className($constructArguments);
        Varien_Profiler::stop('CORE::create_object_of::'.$className);
        return $obj;
    } else {
        return false;
    }
}</pre></div><p>In return, <code class="literal">getModelInstance()</code> calls the <code class="literal">getModelClassName()</code> method that takes a class alias as a parameter. Then, it tries to validate the existence of the returned class, and if the class exists, it creates a new instance of that class and returns it to our <code class="literal">getModel()</code> method:</p><div class="informalexample"><pre class="programlisting">public function getModelClassName($modelClass)
{
    $modelClass = trim($modelClass);
    if (strpos($modelClass, '/')===false) {
        return $modelClass;
    }
    return $this-&gt;getGroupedClassName('model', $modelClass);
}</pre></div><p>The <code class="literal">getModelClassName()</code> method calls the <code class="literal">getGroupedClassName()</code> method, which is actually in charge of returning the real class name of our model.</p><p>The <code class="literal">getGroupedClassName()</code> method <a id="id74" class="indexterm"/>takes two parameters, namely <code class="literal">$groupType</code> and <code class="literal">$classId</code>. The <code class="literal">$groupType</code> parameter refers to the type of object that we are trying to instantiate. Currently, only models, blocks, and helpers are supported. The <code class="literal">$classId</code> that we are trying to instantiate is as follows:</p><div class="informalexample"><pre class="programlisting">public function getGroupedClassName($groupType, $classId, $groupRootNode=null)
{
    if (empty($groupRootNode)) {
        $groupRootNode = 'global/'.$groupType.'s';
    }
    $classArr = explode('/', trim($classId));
    $group = $classArr[0];
    $class = !empty($classArr[1]) ? $classArr[1] : null;

    if (isset($this-&gt;_classNameCache[$groupRootNode][$group][$class])) {
        return $this-&gt;_classNameCache[$groupRootNode][$group][$class];
    }
    $config = $this-&gt;_xml-&gt;global-&gt;{$groupType.'s'}-&gt;{$group};
    $className = null;
    if (isset($config-&gt;rewrite-&gt;$class)) {
        $className = (string)$config-&gt;rewrite-&gt;$class;
    } else {
        if ($config-&gt;deprecatedNode) {
            $deprecatedNode = $config-&gt;deprecatedNode;
            $configOld = $this-&gt;_xml-&gt;global-&gt;{$groupType.'s'}-&gt;$deprecatedNode;
            if (isset($configOld-&gt;rewrite-&gt;$class)) {
                $className = (string) $configOld-&gt;rewrite-&gt;$class;
            }
        }
    }
    if (empty($className)) {
        if (!empty($config)) {
            $className = $config-&gt;getClassName();
        }
        if (empty($className)) {
            $className = 'mage_'.$group.'_'.$groupType;
        }
        if (!empty($class)) {
            $className .= '_'.$class;
        }
        $className = uc_words($className);
    }
    $this-&gt;_classNameCache[$groupRootNode][$group][$class] = $className;
    return $className;
}</pre></div><p>As we<a id="id75" class="indexterm"/> can see, <code class="literal">getGroupedClassName()</code> is actually doing all the work. It grabs our class alias catalog/product and creates an array by exploding the string on the slash character.</p><p>Then, it loads an instance of <code class="literal">Varien_Simplexml_Element</code> and passes the first value in our array (<code class="literal">group_classname</code>). It also checks if the class has been rewritten, and if it has, we will use the corresponding group name.</p><p>Magento also uses a custom version of the <code class="literal">uc_words()</code> function that will capitalize the first letters and convert separators of the class alias if needed.</p><p>Finally, the function will return the real class name to the <code class="literal">getModelInstance()</code> function. In our example case, this will return <code class="literal">Mage_Catalog_Model_Product</code>:</p><div class="mediaobject"><img src="graphics/4195OS_01_04.jpg" alt="Factory names and functions"/></div></div>
<div class="section" title="Events and observers"><div class="titlepage"><div><div><h1 class="title"><a id="ch01lvl1sec15"/>Events and observers</h1></div></div></div><p>The <a id="id76" class="indexterm"/>event and observer pattern<a id="id77" class="indexterm"/> is probably one of Magento's more interesting features, as it allows developers to extend Magento in critical parts of the application flow.</p><p>In order to provide more flexibility and facilitate interaction between the different modules, Magento implements an <span class="strong"><strong>Event</strong></span>/<span class="strong"><strong>Observer</strong></span> pattern. This pattern allows modules to be loosely coupled.</p><p>There are two parts to this system, an <span class="strong"><strong>Event</strong></span> dispatch with the object and event information and an <span class="strong"><strong>Observer</strong></span> listening to a particular event:</p><div class="mediaobject"><img src="graphics/4195OS_01_05.jpg" alt="Events and observers"/></div><div class="section" title="Event dispatch"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec14"/>Event dispatch</h2></div></div></div><p>Events<a id="id78" class="indexterm"/> are created or dispatched using the <code class="literal">Mage::dispatchEvent()</code> function. The core team has already created several events on critical parts of the core. For example, the Model abstract class <code class="literal">Mage_Core_Model_Abstract</code> calls two protected functions every time a model is saved: <code class="literal">_beforeSave()</code> and <code class="literal">_afterSave()</code> on each of these methods two event are fired.</p><div class="informalexample"><pre class="programlisting">protected function _beforeSave()
{
    if (!$this-&gt;getId()) {
        $this-&gt;isObjectNew(true);
    }
    Mage::dispatchEvent('model_save_before', array('object'=&gt;$this));
    Mage::dispatchEvent($this-&gt;_eventPrefix.'_save_before', $this-&gt;_getEventData());
    return $this;
}

protected function _afterSave()
{
    $this-&gt;cleanModelCache();
    Mage::dispatchEvent('model_save_after', array('object'=&gt;$this));
    Mage::dispatchEvent($this-&gt;_eventPrefix.'_save_after', $this-&gt;_getEventData());
    return $this;
}</pre></div><p>Each function<a id="id79" class="indexterm"/> fires a generic <code class="literal">model_save_after</code> event, and then a dynamic version based on the type of object being saved. This gives us a wide range of possibilities to manipulate objects through observers.</p><p>The <code class="literal">Mage::dispatchEvent()</code> method takes two parameters, the first is the event name and the second is an array of data that is received by the observer. We can pass values or objects in this array. This comes in handy if we want to manipulate the objects.</p><p>In order to understand the details of the event system, let's take a look at the <code class="literal">dispatchEvent()</code> method:</p><div class="informalexample"><pre class="programlisting">public static function dispatchEvent($name, array $data = array())
{
    $result = self::app()-&gt;dispatchEvent($name, $data);
    return $result;
}</pre></div><p>This function is actually an alias to the <code class="literal">dispatchEvent()</code> function inside the App core class, located in <code class="literal">Mage_Core_Model_App</code>:</p><div class="informalexample"><pre class="programlisting">public function dispatchEvent($eventName, $args)
{
    foreach ($this-&gt;_events as $area=&gt;$events) {
        if (!isset($events[$eventName])) {
            $eventConfig = $this-&gt;getConfig()-&gt;getEventConfig($area, $eventName);
            if (!$eventConfig) {
                $this-&gt;_events[$area][$eventName] = false;
                continue;
            }
            $observers = array();
            foreach ($eventConfig-&gt;observers-&gt;children() as $obsName=&gt;$obsConfig) {
                $observers[$obsName] = array(
                    'type'  =&gt; (string)$obsConfig-&gt;type,
                    'model' =&gt; $obsConfig-&gt;class ? (string)$obsConfig-&gt;class : $obsConfig-&gt;getClassName(),
                    'method'=&gt; (string)$obsConfig-&gt;method,
                    'args'  =&gt; (array)$obsConfig-&gt;args,
                );
            }
            $events[$eventName]['observers'] = $observers;
            $this-&gt;_events[$area][$eventName]['observers'] = $observers;
        }
        if (false===$events[$eventName]) {
            continue;
        } else {
            $event = new Varien_Event($args);
            $event-&gt;setName($eventName);
            $observer = new Varien_Event_Observer();
        }

        foreach ($events[$eventName]['observers'] as $obsName=&gt;$obs) {
            $observer-&gt;setData(array('event'=&gt;$event));
            Varien_Profiler::start('OBSERVER: '.$obsName);
            switch ($obs['type']) {
                case 'disabled':
                    break;
                case 'object':
                case 'model':
                    $method = $obs['method'];
                    $observer-&gt;addData($args);
                    $object = Mage::getModel($obs['model']);
                    $this-&gt;_callObserverMethod($object, $method, $observer);
                    break;
                default:
                    $method = $obs['method'];
                    $observer-&gt;addData($args);
                    $object = Mage::getSingleton($obs['model']);
                    $this-&gt;_callObserverMethod($object, $method, $observer);
                    break;
            }
            Varien_Profiler::stop('OBSERVER: '.$obsName);
        }
    }
    return $this;
}</pre></div><p>The <code class="literal">dispatchEvent()</code> method actually <a id="id80" class="indexterm"/>does all the work on the <span class="strong"><strong>Event</strong></span>/<span class="strong"><strong>Observer</strong></span> model:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">It gets the Magento configuration object.</li><li class="listitem">Then, it walks through the observer's node children, checking if the defined observer is listening to the current event.</li><li class="listitem">For each of the available observers, the dispatch event tries to instantiate the observer object.</li><li class="listitem">Lastly, Magento tries to call the corresponding observer function mapped to this particular event.</li></ol></div></div><div class="section" title="Observer bindings"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec15"/>Observer bindings</h2></div></div></div><p>Now, dispatching<a id="id81" class="indexterm"/> an event is only part of the equation. We also need to tell Magento which observer is listening to each event. Not to our surprise, observers are specified through the <code class="literal">config.xml</code> file. As we saw before, the <code class="literal">dispatchEvent()</code> function queries the configuration object for available observers. Let's take a look at an example <code class="literal">config.xml</code> file:</p><div class="informalexample"><pre class="programlisting">&lt;events&gt;
    &lt;event_name&gt;
        &lt;observers&gt;
            &lt;observer_identifier&gt;
                &lt;class&gt;module_name/observer&lt;/class&gt;
                &lt;method&gt;function_name&lt;/method&gt;
            &lt;/observer_identifier&gt;
        &lt;/observers&gt;
    &lt;/event_name&gt;
&lt;/events&gt;</pre></div><p>The event node can be specified in each of the configuration sections (admin, global, frontend, and so on) and we can specify multiple <code class="literal">event_name</code> children nodes. The <code class="literal">event_name</code> node has to match the event name used in the <code class="literal">dispatchEvent()</code> function.</p><p>Inside each <code class="literal">event_name</code> node, we have a single observer node that can contain multiple observers, each with a unique identifier.</p><p>Observer nodes have two properties, <code class="literal">&lt;class&gt;</code>, which points to our observer model class, and <code class="literal">&lt;method&gt;</code>, which points to the actual method inside the observer class. Let's analyze an example observer class definition:</p><div class="informalexample"><pre class="programlisting">class Namespace_Modulename_Model_Observer
{
    public function methodName(Varien_Event_Observer $observer)
    {
        //some code
    }
}</pre></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note04"/>Note</h3><p>One interesting thing about observer models is that they don't extend to any other Magento class.</p></div></div></div></div>
<div class="section" title="Summary"><div class="titlepage"><div><div><h1 class="title"><a id="ch01lvl1sec16"/>Summary</h1></div></div></div><p>In this chapter, we covered many important and fundamental topics about Magento:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Architecture</li><li class="listitem" style="list-style-type: disc">Folder structure</li><li class="listitem" style="list-style-type: disc">Routing system</li><li class="listitem" style="list-style-type: disc">MVC patterns</li><li class="listitem" style="list-style-type: disc">Events and observers</li><li class="listitem" style="list-style-type: disc">Configuration scope</li></ul></div><p>While this may seem overwhelming at first sight, it is just the tip of the iceberg. There is a lot more to learn about each of these topics and Magento. The purpose of this chapter is to make developers aware of all the important components of the platform, from the configuration object to the way the event/object pattern is implemented.</p><p>Magento is a powerful and flexible system and much more than an e-commerce platform. The core team has put a lot of effort in making Magento a powerful framework.</p><p>In later chapters, we will not only review all these concepts in more detail, but we will also apply them in a practical manner by building our own extensions.</p></div></body></html>