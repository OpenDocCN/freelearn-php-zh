<html><head></head><body>
<div id="page" style="height:0pt"/><div class="book" title="Chapter&#xA0;2.&#xA0;Web Applications with PHP"><div class="book" id="I3QM2-edcc22b134104d5db0bf3aa086c86851"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch02" class="calibre1"/>Chapter 2. Web Applications with PHP</h1></div></div></div><p class="calibre8">Web applications are a common thing in our lives, and they are usually very user friendly; users do not need to understand how they work behind the scenes. As a developer, though, you need to understand how your application works internally.</p><p class="calibre8">In this chapter, you will learn about:</p><div class="book"><ul class="itemizedlist"><li class="listitem">HTTP and how web applications make use of it</li><li class="listitem">Web applications and how to build a simple one</li><li class="listitem">Web servers and how to launch your PHP built-in web server</li></ul></div></div>

<div class="book" title="Chapter&#xA0;2.&#xA0;Web Applications with PHP">
<div class="book" title="The HTTP protocol"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_1"><a id="ch02lvl1sec13" class="calibre1"/>The HTTP protocol</h1></div></div></div><p class="calibre8">If <a id="id40" class="calibre1"/>you check the<a id="id41" class="calibre1"/> RFC2068 standard at <a class="calibre1" href="https://tools.ietf.org/html/rfc2068">https://tools.ietf.org/html/rfc2068</a>, you will see that its description is almost endless. Luckily, what you need to know about this protocol, at least for starters, is way shorter.</p><p class="calibre8">
<span class="strong"><strong class="calibre2">HTTP</strong></span>
<a id="id42" class="calibre1"/> stands for <span class="strong"><strong class="calibre2">HyperText Transfer Protocol</strong></span>. As any other protocol, the goal is to allow two entities or nodes to communicate with each other. In order to achieve this, the messages need to be formatted in a way that they both understand, and the entities must follow some pre-established rules.</p></div></div>

<div class="book" title="Chapter&#xA0;2.&#xA0;Web Applications with PHP">
<div class="book" title="The HTTP protocol">
<div class="book" title="A simple example"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_2"><a id="ch02lvl2sec20" class="calibre1"/>A simple example</h2></div></div></div><p class="calibre8">The <a id="id43" class="calibre1"/>following diagram shows a very basic interchange of messages:</p><div class="mediaobject"><img src="../images/00013.jpeg" alt="A simple example" class="calibre9"/><div class="caption"><p class="calibre14">A simple GET request</p></div></div><p class="calibre10"> </p><p class="calibre8">Do not <a id="id44" class="calibre1"/>worry if you do not understand all the elements in this diagram; we will describe them shortly. In this representation, there are two entities: <span class="strong"><strong class="calibre2">sender</strong></span>
<a id="id45" class="calibre1"/> and <a id="id46" class="calibre1"/>
<span class="strong"><strong class="calibre2">receiver</strong></span>. The sender sends a message to the receiver. This message, which starts the communication, is called the request. In this case, the message is a GET request. The receiver receives the message, processes it, and generates a second message: the response. In this case, the response shows a 200 status code, meaning that the request was processed successfully.</p><p class="calibre8">HTTP is stateless; that is, it treats each request independently, unrelated to any previous one. This means that with this request and response sequence, the communication is finished. Any new requests will not be aware of this specific interchange of messages.</p></div></div></div>

<div class="book" title="Chapter&#xA0;2.&#xA0;Web Applications with PHP">
<div class="book" title="The HTTP protocol">
<div class="book" title="Parts of the message"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_3"><a id="ch02lvl2sec21" class="calibre1"/>Parts of the message</h2></div></div></div><p class="calibre8">An HTTP message<a id="id47" class="calibre1"/> contains several parts. We will define only the most important of them.</p><div class="book" title="URL"><div class="book"><div class="book"><div class="book"><h3 class="title2"><a id="ch02lvl3sec01" class="calibre1"/>URL</h3></div></div></div><p class="calibre8">The URL of the<a id="id48" class="calibre1"/> message is the destination of the message. The request will contain the receiver's URL, and the response will contain the sender's.</p><p class="calibre8">As you might know, the URL can contain extra parameters, known as a query string. This is used when the sender wants to add extra data. For example, consider this URL: <code class="email">http://myserver.com/greeting?name=Alex</code>. This URL contains one parameter: <code class="email">name</code> with the value <code class="email">Alex</code>. It could not be represented as part of the URL <code class="email">http://myserver.com/greeting</code>, so the sender chose to add it at the end of it. You will see later that this is not the<a id="id49" class="calibre1"/> only way that we can add extra information into a message.</p></div><div class="book" title="The HTTP method"><div class="book"><div class="book"><div class="book"><h3 class="title2"><a id="ch02lvl3sec02" class="calibre1"/>The HTTP method</h3></div></div></div><p class="calibre8">The <a id="id50" class="calibre1"/>HTTP method is the verb <a id="id51" class="calibre1"/>of the message. It identifies what kind of action the sender wants to perform with this message. The most common ones are GET and POST.</p><div class="book"><ul class="itemizedlist"><li class="listitem"><span class="strong"><strong class="calibre2">GET</strong></span>: This asks the <a id="id52" class="calibre1"/>receiver about something, and the receiver usually sends this information back. The most common example is asking for a web page, where the receiver will respond with the HTML code of the requested page.</li><li class="listitem"><span class="strong"><strong class="calibre2">POST</strong></span>: This means that<a id="id53" class="calibre1"/> the sender wants to perform an action that will update the data that the receiver is holding. For example, the sender can ask the receiver to update his profile name.</li></ul></div><p class="calibre8">There are other methods, such as <a id="id54" class="calibre1"/>
<span class="strong"><strong class="calibre2">PUT</strong></span>, <a id="id55" class="calibre1"/>
<span class="strong"><strong class="calibre2">DELETE</strong></span>, or <a id="id56" class="calibre1"/>
<span class="strong"><strong class="calibre2">OPTION</strong></span>, but they are less used in web development, although they play a crucial role in REST APIs, which will be explained in <a class="calibre1" title="Chapter 9. Building REST APIs" href="part0079_split_000.html#2BASE1-edcc22b134104d5db0bf3aa086c86851">Chapter 9</a>, <span class="strong"><em class="calibre12">Building REST APIs</em></span>.</p></div><div class="book" title="Body"><div class="book"><div class="book"><div class="book"><h3 class="title2"><a id="ch02lvl3sec03" class="calibre1"/>Body</h3></div></div></div><p class="calibre8">The body<a id="id57" class="calibre1"/> part is usually present in response messages even though a request message can contain it too. The body of the message contains the content of the message itself; for example, if the user requested a web page, the body of the response would consist of the HTML code that represents this page.</p><p class="calibre8">Soon, we will discuss how the request can also contain a body, which is used to send extra information as part of the request, such as form parameters.</p><p class="calibre8">The body can contain text in any format; it can be an HTML text that represents a web page, plain text, the content of an image, JSON, and so on.</p></div><div class="book" title="Headers"><div class="book"><div class="book"><div class="book"><h3 class="title2"><a id="ch02lvl3sec04" class="calibre1"/>Headers</h3></div></div></div><p class="calibre8">The headers<a id="id58" class="calibre1"/> on an HTTP message are the metadata that the receiver needs in order to understand the content of the message. There are a lot of headers, and you will see some of them in this book.</p><p class="calibre8">Headers consist of a map of key-value pairs. The following could be the headers of a request:</p><div class="informalexample"><pre class="programlisting">Accept: text/html
Cookie: name=Richard</pre></div><p class="calibre8">This request tells the<a id="id59" class="calibre1"/> receiver, which is a server, that it will accept text as HTML, which is the common way of representing a web page; and that it has a cookie named Richard.</p></div><div class="book" title="The status code"><div class="book"><div class="book"><div class="book"><h3 class="title2"><a id="ch02lvl3sec05" class="calibre1"/>The status code</h3></div></div></div><p class="calibre8">The status<a id="id60" class="calibre1"/> code is present in responses. It identifies the status of the request with a numeric code so that browsers and other tools know how to react. For example, if we try to access a URL that does not exist, the server should reply with a status code 404. In this way, the browser knows what happened without even looking at the content of the response.</p><p class="calibre8">Common status codes are:</p><div class="book"><ul class="itemizedlist"><li class="listitem"><span class="strong"><strong class="calibre2">200</strong></span>: The <a id="id61" class="calibre1"/>request was successful</li><li class="listitem"><span class="strong"><strong class="calibre2">401</strong></span>: Unauthorized; the <a id="id62" class="calibre1"/>user does not have permission to see this resource</li><li class="listitem"><span class="strong"><strong class="calibre2">404</strong></span>: Page <a id="id63" class="calibre1"/>not found</li><li class="listitem"><span class="strong"><strong class="calibre2">500</strong></span>: Internal<a id="id64" class="calibre1"/> server error; something wrong happened on the server side and it could not be recovered</li></ul></div></div></div></div></div>

<div class="book" title="Chapter&#xA0;2.&#xA0;Web Applications with PHP">
<div class="book" title="The HTTP protocol">
<div class="book" title="A more complex example"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_4"><a id="ch02lvl2sec22" class="calibre1"/>A more complex example</h2></div></div></div><p class="calibre8">The following <a id="id65" class="calibre1"/>diagram shows a POST request and its response:</p><div class="mediaobject"><img src="../images/00014.jpeg" alt="A more complex example" class="calibre9"/><div class="caption"><p class="calibre14">A more complex POST request</p></div></div><p class="calibre10"> </p><p class="calibre8">In this exchange<a id="id66" class="calibre1"/> of messages, we can see the other important method, POST, in action. In this case, the sender tries to send a request in order to update some entity's data. The message contains a cookie ID with the value <span class="strong"><strong class="calibre2">84</strong></span>, which may identify the entity to update. It also contains two parameters in the body: <code class="email">name</code> and <code class="email">age</code>. This is the data that the receiver has to update.</p><div class="informalexample" title="Note"><h3 class="title2"><a id="tip04" class="calibre1"/>Tip</h3><p class="calibre8">
<span class="strong"><strong class="calibre2">Submitting web forms</strong></span>
</p><p class="calibre8">Representing the <a id="id67" class="calibre1"/>parameters as part of the body is a common way to send information when submitting a form, but not the only one. You can add a query string to the URL, add JSON to the body of the message, and so on.</p></div><p class="calibre8">The response has a status code of 200, meaning that the request was processed successfully. In addition, the response also contains a body, this time formatted as JSON, which represents the new status of the updated entity.</p></div></div></div>

<div id="page" style="height:0pt"/><div class="book" title="Web applications" id="J2B81-edcc22b134104d5db0bf3aa086c86851"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch02lvl1sec14" class="calibre1"/>Web applications</h1></div></div></div><p class="calibre8">Maybe <a id="id68" class="calibre1"/>you have noticed that in the previous sections, I used the not very intuitive terms of sender and receiver as they do not represent any specific scenario that you might know but rather all of them in a generic way. The main reason for this choice of terminology is to try to separate HTTP from web applications. You will see at the end of the book that HTTP is used for more than just websites.</p><p class="calibre8">If you are reading this book, you already know what a web application is. Alternatively, maybe you know it by other terms, such as website or web page. Let's try to give some definitions.</p><p class="calibre8">A <span class="strong"><strong class="calibre2">web page</strong></span>
<a id="id69" class="calibre1"/> is a single document with content. It contains links that open other web pages with different content.</p><p class="calibre8">A <span class="strong"><strong class="calibre2">website</strong></span>
<a id="id70" class="calibre1"/> is the set of web pages that usually live in the same server and are related to each other.</p><p class="calibre8">A <span class="strong"><strong class="calibre2">web application</strong></span> is just a piece of software that runs on a client, which is usually a browser, and communicates with a <span class="strong"><em class="calibre12">server</em></span>. A server is a remote machine that receives requests from a client, processes them, and generates a response. This response will go back to the client, generally rendered by the browser in order to display it to the user.</p><p class="calibre8">Even though this is out of the scope of this book, you may be interested to know that not only browsers can act as clients, generating requests and sending them to the servers; even servers can be the ones taking the initiative of sending messages to the browsers.</p><p class="calibre8">So, what is the difference between a website and a web application? Well, the web application can be a small part of a bigger website with a specific functionality. Also, not all websites are web applications as a web application always does something but a website can just display information.</p></div>

<div class="book" title="Web applications" id="J2B81-edcc22b134104d5db0bf3aa086c86851">
<div class="book" title="HTML, CSS, and JavaScript"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_1"><a id="ch02lvl2sec23" class="calibre1"/>HTML, CSS, and JavaScript</h2></div></div></div><p class="calibre8">Web applications are rendered<a id="id71" class="calibre1"/> by the browser so that the user can see its content. To do this, the<a id="id72" class="calibre1"/> server needs to send the content of the page or document. The document <a id="id73" class="calibre1"/>uses HTML to describe its elements and how they are organized. Elements can be links, buttons, input fields, and so on. A simple example of a web page looks like this:</p><div class="informalexample"><pre class="programlisting">&lt;!DOCTYPE html&gt;
&lt;html lang="en"&gt;
&lt;head&gt;
  &lt;meta charset="UTF-8"&gt;
  &lt;title&gt;Your first app&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
<span class="strong"><strong class="calibre2">  &lt;a id="special" class="link" href="http://yourpage.com"&gt;Your page&lt;/a&gt;</strong></span>
<span class="strong"><strong class="calibre2">  &lt;a class="link" href="http://theirpage.com"&gt;Their page&lt;/a&gt;</strong></span>
<span class="strong"><strong class="calibre2">&lt;/body&gt;</strong></span>
&lt;/html&gt;</pre></div><p class="calibre8">Let's focus on the highlighted code. As you can see, we are describing two <code class="email">&lt;a&gt;</code> links with some properties. Both links have a class, a destination, and a text. The first one also contains an ID. Save this code into a file named <code class="email">index.html</code> and execute it. You will see how your default browser opens a very simple page with two links.</p><p class="calibre8">If we want to add some <a id="id74" class="calibre1"/>styles, or change the color, size, and position of the links, we<a id="id75" class="calibre1"/> need to add CSS. CSS describes how elements from the HTML <a id="id76" class="calibre1"/>are displayed. There are several ways to include CSS, but the best approach is to have it in a separated file and then reference it from the HTML. Let's update our <code class="email">&lt;head&gt;</code> section as shown in the following code:</p><div class="informalexample"><pre class="programlisting">&lt;head&gt;
  &lt;meta charset="UTF-8"&gt;
  &lt;title&gt;Your first app&lt;/title&gt;
<span class="strong"><strong class="calibre2">  &lt;link rel="stylesheet" type="text/css" href="mystyle.css"&gt;</strong></span>
&lt;/head&gt;</pre></div><p class="calibre8">Now, let's create a new <code class="email">mystyle.css</code> file in the same folder with the following content:</p><div class="informalexample"><pre class="programlisting">.link {
    color: green;
    font-weight: bold;
}

#special {
    font-size: 30px;
}</pre></div><p class="calibre8">This CSS file contains two style definitions: one for the <code class="email">link</code> class and one for the <code class="email">special</code> ID. The class style will be applied to both the links as they both define this class, and it sets them as green and bold. The ID style that increases the font of the link is only applied to the first link.</p><p class="calibre8">Finally, in order to add behavior to our web page, we need to add JS or JavaScript. JS is a programming language that would need an entire book for itself, and in fact, there are quite a lot of them. If you want to give it a chance, we recommend the free <a id="id77" class="calibre1"/>online book <span class="strong"><em class="calibre12">Eloquent JavaScript</em></span>, <span class="strong"><em class="calibre12">Marijn Haverbeke</em></span>, which you can find at <a class="calibre1" href="http://eloquentjavascript.net/">http://eloquentjavascript.net/</a>. As with CSS, the best approach would be to add a separate file and then reference it from our HTML. Update the <code class="email">&lt;body&gt;</code> section with the following highlighted code:</p><div class="informalexample"><pre class="programlisting">&lt;body&gt;
  &lt;a id="special" class="link" href="http://yourpage.com"&gt;Your page&lt;/a&gt;
  &lt;a class="link" href="http://theirpage.com"&gt;Their page&lt;/a&gt;
<span class="strong"><strong class="calibre2">  &lt;script src="myactions.js"&gt;&lt;/script&gt;</strong></span>
&lt;/body&gt;</pre></div><p class="calibre8">Now, create a <code class="email">myactions.js</code> file with the following content:</p><div class="informalexample"><pre class="programlisting">document.getElementById("special").onclick = function() {
    alert("You clicked me?");
}</pre></div><p class="calibre8">The JS file adds a function that will be called when the <code class="email">special</code> link is clicked on. This function just pops up an alert. You can save all your changes and refresh the browser to see how it looks now and how the links behave.</p><div class="informalexample" title="Note"><h3 class="title2"><a id="note02" class="calibre1"/>Note</h3><p class="calibre8">
<span class="strong"><strong class="calibre2">Different ways of including JS</strong></span>
</p><p class="calibre8">You might notice that we included the CSS file reference at the end of the <code class="email">&lt;head&gt;</code> section and JS at the end of <code class="email">&lt;body&gt;</code>. You can actually include JS in both the <code class="email">&lt;head&gt;</code> and the <code class="email">&lt;body&gt;</code>; just bear in mind that the script will be executed as soon as it is included. If your script references fields that are not yet defined or other JS files that will be included later, JS will fail.</p></div><p class="calibre8">Congratulations! You just wrote <a id="id78" class="calibre1"/>your very first web page. Not impressed? Well, then you are<a id="id79" class="calibre1"/> reading the correct book! You will have the chance to work with more<a id="id80" class="calibre1"/> HTML, CSS, and JS during the book, even though the book focuses especially on PHP.</p></div></div>

<div id="page" style="height:0pt"/><div class="book" title="Web servers" id="K0RQ1-edcc22b134104d5db0bf3aa086c86851"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch02lvl1sec15" class="calibre1"/>Web servers</h1></div></div></div><p class="calibre8">So, it is about time that you<a id="id81" class="calibre1"/> learn what those famous web servers are. A web server is no more than a piece of software running on a machine and listening to requests from a specific port. Usually, this port is <code class="email">80</code>, but it can be any other that is available.</p></div>

<div class="book" title="Web servers" id="K0RQ1-edcc22b134104d5db0bf3aa086c86851">
<div class="book" title="How they work"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_1"><a id="ch02lvl2sec24" class="calibre1"/>How they work</h2></div></div></div><p class="calibre8">The following diagram represents<a id="id82" class="calibre1"/> the flow of request-response on the server side:</p><div class="mediaobject"><img src="../images/00015.jpeg" alt="How they work" class="calibre9"/><div class="caption"><p class="calibre14">Request-response flow on the server side</p></div></div><p class="calibre10"> </p><p class="calibre8">The job of a web server is to route external requests to the correct application so that they can be processed. Once the application returns a response, the web server will send this response to the client. Let's <a id="id83" class="calibre1"/>take a close look at all the steps:</p><div class="book"><ol class="orderedlist"><li class="listitem" value="1">The client, which is a browser, sends a request. This can be of any type—GET or POST—and contain anything as long as it is valid.</li><li class="listitem" value="2">The server receives the request, which points to a port. If there is a web server listening on this port, the web server will then take control of the situation.</li><li class="listitem" value="3">The web server decides which web application—usually a file in the filesystem—needs to process the request. In order to decide, the web server usually considers the path of the URL; for example, <code class="email">http://myserver.com/app1/hi</code> would try to pass the request to the <code class="email">app1</code> application, wherever it is in the filesystem. However, another scenario would be <code class="email">http://app1.myserver.com/hi</code>, which would also go to the same application. The rules are very flexible, and it is up to both the web server and the user as to how to set them.</li><li class="listitem" value="4">The web application, after receiving a request from the web server, generates a response and sends it to the web server.</li><li class="listitem" value="5">The web server sends the response to the indicated port.</li><li class="listitem" value="6">The <a id="id84" class="calibre1"/>response finally arrives to the client.</li></ol><div class="calibre13"/></div></div></div>

<div class="book" title="Web servers" id="K0RQ1-edcc22b134104d5db0bf3aa086c86851">
<div class="book" title="The PHP built-in server"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_2"><a id="ch02lvl2sec25" class="calibre1"/>The PHP built-in server</h2></div></div></div><p class="calibre8">There<a id="id85" class="calibre1"/> are powerful web servers that support high loads of traffic, such as Apache or Nginx, which are fairly simple to install and manage. For the purpose of this book, though, we will use something even simpler: a PHP built-in server. The reason to use this is that you will not need extra package installations, configurations, and headaches as it comes with PHP. With just one command, you will have a web server running on your machine.</p><div class="informalexample" title="Note"><h3 class="title2"><a id="note03" class="calibre1"/>Note</h3><p class="calibre8">
<span class="strong"><strong class="calibre2">Production web servers</strong></span>
</p><p class="calibre8">Note<a id="id86" class="calibre1"/> that the PHP built-in web server is good for testing purposes, but it is highly recommended not to use it in production environments. If you have to set up a server that needs to be public and your application is written in PHP, I highly recommend you to choose either of the classics: Apache (<a class="calibre1" href="http://httpd.apache.org">http://httpd.apache.org</a>) or<a id="id87" class="calibre1"/> Nginx<a id="id88" class="calibre1"/> (<a class="calibre1" href="https://www.nginx.com">https://www.nginx.com</a>). Both can run almost on any server, are free and easy to install and configure, and, more importantly, have a huge community that will support you on virtually any problem you might encounter.</p></div><p class="calibre8">Finally, hands on! Let's try to create our very first web page using the built-in server. For this, create an <code class="email">index.php</code> file inside your <code class="email">workspace</code> directory—for example, <code class="email">Documents/workspace/index.php</code>. The content of this file should be:</p><div class="informalexample"><pre class="programlisting">&lt;?php
echo 'hello world';</pre></div><p class="calibre8">Now, open your command line, go to your <code class="email">workspace</code> directory, probably by running the <code class="email">cd Documents/workspace</code> command, and run the following command:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong class="calibre2">$ php -S localhost:8000</strong></span>
</pre></div><p class="calibre8">The command line will prompt you with some information, the most important one being what is listening, which should be <code class="email">localhost:8000</code> as specified, and how to stop it, usually by pressing <span class="strong"><em class="calibre12">Ctrl</em></span> + <span class="strong"><em class="calibre12">C</em></span>. Do not close the command line as it will stop the web server too.</p><p class="calibre8">Now, let's open a<a id="id89" class="calibre1"/> browser and go to <code class="email">http://localhost:8000</code>. You should see a <span class="strong"><strong class="calibre2">hello world</strong></span> message on a white page. Yay, success! If you are interested, you can check your command line, and you will see log entries of each request you are sending via your browser.</p><p class="calibre8">So, how does it really work? Well, if you check again in the previous diagram, the <code class="email">php -S</code> command started a web server—in our case, listening to port <code class="email">8000</code> instead of <code class="email">80</code>. Also, PHP knows that the web application code will be on the same directory that you started the web server: your <code class="email">workspace</code>. There are more specific options, but by default, PHP will try to execute the <code class="email">index.php</code> file in your <code class="email">workspace</code>.</p></div></div>

<div class="book" title="Web servers" id="K0RQ1-edcc22b134104d5db0bf3aa086c86851">
<div class="book" title="Putting things together"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_3"><a id="ch02lvl2sec26" class="calibre1"/>Putting things together</h2></div></div></div><p class="calibre8">Let's try to include our first project (<code class="email">index.html</code> with its CSS and JS files) as part of the built-in server. To do this, you just need to open the command line and go to the directory in which these files are and start the web server with <code class="email">php -S localhost:8000</code>. If you check <code class="email">localhost:8000</code> in your browser, you will see our two-link page, as is expected.</p><p class="calibre8">Let's now move our new <code class="email">index.php</code> file to the same directory. You do not need to restart your web server; PHP will know about the changes automatically. Go to your browser and refresh the page. You should now see the <span class="strong"><strong class="calibre2">hello world</strong></span> message instead of the links. What happened here?</p><p class="calibre8">If you do not change the default options, PHP will always try to find an <code class="email">index.php</code> file in the directory in which you started the web server. If this is not found, PHP will try to find an <code class="email">index.html</code> file. Previously, we only had the <code class="email">index.html</code> file, so PHP failed to find <code class="email">index.php</code>. Now that it can find its first option, <code class="email">index.php</code>, it will load it.</p><p class="calibre8">If we want to see our <code class="email">index.html</code> file from the browser, we can always specify it in the URL like <code class="email">http://localhost:8000/index.html</code>. If the web server notices that you are trying to access a specific file, it will try to load it instead of the default options.</p><p class="calibre8">Finally, if we try to access a file that is not on our filesystem, the web server will return a response with status code 404—that is, not found. We can see this code if we open the <span class="strong"><strong class="calibre2">Developer tools</strong></span> section of our browser and go to the <span class="strong"><strong class="calibre2">Network</strong></span> section.</p><div class="informalexample" title="Note"><h3 class="title2"><a id="tip05" class="calibre1"/>Tip</h3><p class="calibre8">
<span class="strong"><strong class="calibre2">Developer tools are your friends</strong></span>
</p><p class="calibre8">As a web developer, you will find very few tools more useful than the developer tools of your browser. It changes from browser to browser, but all of the big names, such as Chrome or Firefox, have it. It is very important that you get familiar with how to use it as it allows you to debug your applications from the client side.</p><p class="calibre8">I will introduce you to some of these tools during the course of this book.</p></div></div></div>
<div class="book" title="Summary" id="KVCC1-edcc22b134104d5db0bf3aa086c86851"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch02lvl1sec16" class="calibre1"/>Summary</h1></div></div></div><p class="calibre8">In this chapter, you learned what HTTP is and how web applications use it in order to interact with the server. You also now know how web servers work and how to launch a light built-in server with PHP. Finally, you took the first steps toward building your first web application. Congratulations!</p><p class="calibre8">In the next chapter, we will take a look at the basics of PHP so that you can start building simple applications.</p></div></body></html>