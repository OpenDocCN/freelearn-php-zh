<html><head></head><body>
<div class="book" title="Chapter&#xA0;9.&#xA0;Multithreaded and Distributed Computing with pthreads and Gearman"><div class="book" id="1UU542-bd355a22cf10407cb10df27e65585b8d"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch09" class="calibre1"/>Chapter 9. Multithreaded and Distributed Computing with pthreads and Gearman</h1></div></div></div><p class="calibre8">We've spent quite some time with pthreads in the previous chapter. However, we haven't seen them used in any practical applications. That's what we're going to do in this chapter where we'll wrap pthreads with RxPHP to hide their internal implementation details and to make thread pools easily reusable in any RxPHP application.</p><p class="calibre8">Apart from pthreads, we'll take a look at distributing jobs across multiple workers locally or on multiple machines. We'll use the Gearman framework and its PHP bindings to make the same application as we'll do with pthreads, just instead of running it in multiple threads we'll use multiple workers (independent processes).</p><p class="calibre8">In this chapter, we're going to write an extendable code quality tool to test various style checks in PHP scripts. For example, this can be not using assignments in conditions, or just variable names following certain coding standard. PHP projects tend to grow very large these days. If we wanted to analyze every file in a single thread, it would take a very long time, so we want to run the analyzer part in parallel if possible.</p><p class="calibre8">In particular, this chapter will cover the following topics:</p><div class="book"><ul class="itemizedlist"><li class="listitem">Quick introduction to the PHP Parser library and how can we wrap its parser with an RxPHP operator</li><li class="listitem">Wrap pthreads <code class="literal">Pool</code> class with our custom operator that'll receive <code class="literal">Thread</code> classes and run them in parallel automatically</li><li class="listitem">Write a <code class="literal">Thread</code> class that'll run PHP Parser in a separate thread</li><li class="listitem">Introduce the Gearman framework and write a very basic client and worker in PHP. We'll also see how to run clients and workers using just Gearman's CLI options</li><li class="listitem">Distribute PHP Parser tasks across multiple Gearman workers</li><li class="listitem">Compare single process multithreaded applications with a distributed Gearman application</li></ul></div><p class="calibre8">We'll go through the PHP Parser library very quickly because our main interest is mostly in pthreads and the Gearman framework.</p><p class="calibre8">However, we'll spend some time writing the <code class="literal">PHPParserOperator</code> class, which will combine many of the things we've learned in the previous chapters.</p></div>

<div class="book" title="Chapter&#xA0;9.&#xA0;Multithreaded and Distributed Computing with pthreads and Gearman">
<div class="book" title="Introduction to the PHP Parser library"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_1"><a id="ch09lvl1sec58" class="calibre1"/>Introduction to the PHP Parser library</h1></div></div></div><p class="calibre8">PHP Parser is a library that takes a source code written in PHP, passes it through a lexical analyzer, and creates its respective syntax tree. This is very useful for static code analysis, where we want to check our own code not only for syntactic errors but also for satisfying certain quality criteria.</p><p class="calibre8">In this chapter, we'll write an application that takes a directory, iterates all its files and subdirectories recursively, and runs each PHP file through the PHP Parser. We will check only for one specific pattern; that is enough for this demo.</p><p class="calibre8">We want to be able to find any statement where we use the assignment inside a condition. This could be any of the following examples (this time we're also including line numbers for clarity):</p><pre class="programlisting">// _test_source_code.php 
1. &lt;?php 
2. $a = 5; 
3. if ($a = 1) { 
4.     var_dump($a); 
5. } elseif ($b = 2) {} 
6. while ($c = 3) {} 
7. for (; $d = 4;) {} 
</pre><p class="calibre8">All this is of course a valid PHP syntax, but let's say we want to make our code easy to understand. When your application is not behaving as you'd expect and you don't know how you might spot any of the preceding examples, then you would not be able to say at first sight whether this is intentional or you're just missing one equals sign. Maybe you wanted to write a condition such as <code class="literal">if ($a == 1)</code> and you just forgot one <code class="literal">=</code>.</p><p class="calibre8">This can be easily spotted and reported by the static code analyzer.</p><p class="calibre8">So, let's start by first trying the PHP Parser library itself and then wrap it with the RxPHP operator.</p></div></div>

<div class="book" title="Chapter&#xA0;9.&#xA0;Multithreaded and Distributed Computing with pthreads and Gearman">
<div class="book" title="Introduction to the PHP Parser library">
<div class="book" title="Using the PHP Parser library"><div class="book"><div class="book"><div class="book"><h2 class="title2" id="calibre_pb_2"><a id="ch09lvl2sec84" class="calibre1"/>Using the PHP Parser library</h2></div></div></div><p class="calibre8">Before we start, we need to install the PHP Parser library. As usual, we'll use the <code class="literal">composer</code> for this:</p><pre class="programlisting">
<span class="strong"><strong class="calibre17">$ composer require nikic/php-parser</strong></span>
</pre><p class="calibre8">The easiest use case is just taking the source code we want to analyze and process it with the parser:</p><pre class="programlisting">// php_parser_01.php  
use PhpParser\ParserFactory; 
 
$syntax = ParserFactory::PREFER_PHP7; 
$parser = (new ParserFactory())-&gt;create($syntax); 
 
$code = file_get_contents('_test_source_code.php'); 
$stmts = $parser-&gt;parse($code); 
print_r($stmts); 
</pre><p class="calibre8">The output from this script is going to be a very long nested tree structure representing the code we passed to the parser:</p><pre class="programlisting">
<span class="strong"><strong class="calibre17">$ php php_parser_01.php </strong></span>
<span class="strong"><strong class="calibre17">...</strong></span>
<span class="strong"><strong class="calibre17">[2] =&gt; PhpParser\Node\Stmt\If_ Object</strong></span>
<span class="strong"><strong class="calibre17">  (</strong></span>
<span class="strong"><strong class="calibre17">    [cond] =&gt; PhpParser\Node\Expr\Assign Object (</strong></span>
<span class="strong"><strong class="calibre17">      [var] =&gt; PhpParser\Node\Expr\Variable Object (</strong></span>
<span class="strong"><strong class="calibre17">        [name] =&gt; a</strong></span>
<span class="strong"><strong class="calibre17">          [attributes:protected] =&gt; Array (</strong></span>
<span class="strong"><strong class="calibre17">            [startLine] =&gt; 4</strong></span>
<span class="strong"><strong class="calibre17">            [endLine] =&gt; 4</strong></span>
<span class="strong"><strong class="calibre17">          )</strong></span>
<span class="strong"><strong class="calibre17">        )</strong></span>
<span class="strong"><strong class="calibre17">      [expr] =&gt; PhpParser\Node\Scalar\LNumber Object (</strong></span>
<span class="strong"><strong class="calibre17">        [value] =&gt; 1</strong></span>
<span class="strong"><strong class="calibre17">        ...</strong></span>
</pre><p class="calibre8">We can see that the <code class="literal">if</code> statement has a property called <code class="literal">cond</code> that contains the parsed condition, which is an instance of <code class="literal">Expr\Assign</code>. In fact, all the statements we're going to test have the <code class="literal">cond</code> property, so testing whether they contain an assignment in condition is going to be relatively simple. The only exception is the <code class="literal">for</code> loop, where the condition might have multiple expressions separated by the comma <code class="literal">,</code> character.</p><p class="calibre8">Since the syntax tree is a nested structure, we'll need some way to iterate it recursively. Fortunately, this is supported by the library out of the box via the <code class="literal">NodeTraverser</code> class and by registering custom visitors. Visitors are classes with multiple callbacks that are called when the tree traverser starts/ends processing the entire tree or enters/leaves a single node.</p><p class="calibre8">We will make a very simple node visitor that checks for the node type and eventually the <code class="literal">cond</code> property. This is a way we can spot all the assignments inside conditions and print their respective line number from the source PHP script.</p><p class="calibre8">Consider the following code. This will also be part of the custom operator that we'll write later:</p><pre class="programlisting">// php_parser_02.php  
use PhpParser\NodeTraverser; 
use PhpParser\ParserFactory; 
use PhpParser\Node; 
use PhpParser\Node\Stmt; 
use PhpParser\Node\Expr; 
use PhpParser\NodeVisitorAbstract; 
 
class MyNodeVisitor extends NodeVisitorAbstract { 
  public function enterNode(Node $node) { 
    if (($node instanceof Stmt\If_ || 
          $node instanceof Stmt\ElseIf_ || 
          $node instanceof Stmt\While_ 
        ) &amp;&amp; $this-&gt;isAssign($node-&gt;cond)) { 
 
      echo $node-&gt;getLine() . "\n"; 
    } elseif ($node instanceof Stmt\For_) { 
      $conds = array_filter($node-&gt;cond, [$this, 'isAssign']); 
      foreach ($conds as $cond) { 
        echo $node-&gt;getLine() . "\n"; 
      } 
    } 
  } 
 
  private function isAssign($cond) { 
    return $cond instanceof Expr\Assign; 
  } 
} 
 
$syntax = ParserFactory::PREFER_PHP7; 
$parser = (new ParserFactory())-&gt;create($syntax); 
$code = file_get_contents('_test_source_code.php'); 
 
$traverser = new NodeTraverser(); 
$traverser-&gt;addVisitor(new MyNodeVisitor()); 
$stmts = $parser-&gt;parse($code); 
$traverser-&gt;traverse($stmts); 
</pre><p class="calibre8">As you can see, we're checking each node type with multiple <code class="literal">instanceof</code> statements and their respective <code class="literal">cond</code> properties. With the <code class="literal">for</code> statement, we need to check the array of the <code class="literal">cond</code> statements but the rest is analogous.</p><p class="calibre8">Every time we spot our tested style check, we just print the line number so that the preceding example will print the following:</p><pre class="programlisting">
<span class="strong"><strong class="calibre17">$ php php_parser_02.php </strong></span>
<span class="strong"><strong class="calibre17">3</strong></span>
<span class="strong"><strong class="calibre17">5</strong></span>
<span class="strong"><strong class="calibre17">6</strong></span>
<span class="strong"><strong class="calibre17">7</strong></span>
</pre><p class="calibre8">We can see that the line numbers really match the source file we presented earlier. This is all nice but not very helpful when we want to use it with RxPHP or, even more interestingly, with pthreads.</p></div></div></div>

<div class="book" title="Chapter&#xA0;9.&#xA0;Multithreaded and Distributed Computing with pthreads and Gearman">
<div class="book" title="Introduction to the PHP Parser library">
<div class="book" title="Implementing PHPParserOperator"><div class="book"><div class="book"><div class="book"><h2 class="title2" id="calibre_pb_3"><a id="ch09lvl2sec85" class="calibre1"/>Implementing PHPParserOperator</h2></div></div></div><p class="calibre8">If we wanted to process multiple files, we could just run the parser multiple times. But what if we wanted to have better control over what files are going in, or we wanted to make the preconfigured parser with our custom node visitor easily embeddable into any RxPHP application.</p><p class="calibre8">For example, let's assume we want to use the PHP Parser library in the following way:</p><pre class="programlisting">// php_parser_observer_01.php 
Observable::fromArray(['_test_source_code.php']) 
  -&gt;lift(function() { 
    $classes = [AssignmentInConditionNodeVisitor::class]; 
    return new PHPParserOperator($classes); 
  }) 
  -&gt;subscribe(new DebugSubject());   
</pre><p class="calibre8">We have a typical RxPHP chain of operators where we lifted <code class="literal">PHPParserOperator</code>. This class takes in its constructor an array of classes that will be added as node visitors to its internal <code class="literal">NodeTraverser</code>.</p><p class="calibre8">As an input, we're using a primitive array of filenames that'll be emitted by the source Observable. The observer will then receive just an array of code style violations reported by each of the visitor classes.</p><p class="calibre8">Before writing the operator itself, we should first take a look at how to modify the visitor class from the previous example. Since we want to be able to add any number of custom node visitors that can check anything they want, we need to be able to collect all their results and re-emit them as a single value by <code class="literal">PHPParserOperator</code>.</p><div class="book" title="Writing AssignmentInConditionNodeVisitor"><div class="book"><div class="book"><div class="book"><h3 class="title1"><a id="ch09lvl3sec30" class="calibre1"/>Writing AssignmentInConditionNodeVisitor</h3></div></div></div><p class="calibre8">We can start by defining an interface that all our node visitors have to implement:</p><pre class="programlisting">// ObservableNodeVisitorInterface.php 
interface ObservableNodeVisitorInterface { 
    public function asObservable(); 
} 
</pre><p class="calibre8">The one requirement for a node visitor is to return an Observable where it'll emit all code style violations:</p><pre class="programlisting">// AssignmentInConditionNodeVisitor.php 
use PhpParser\NodeVisitorAbstract as Visitor; 
use PhpParser\Node; 
// We're omitting the rest of use statements ... 
 
class AssignmentInConditionNodeVisitor 
    extends Visitor implements ObservableNodeVisitorInterface { 
  private $subject; 
  private $prettyPrinter; 
 
  public function __construct() { 
    $this-&gt;subject = new Subject(); 
    $this-&gt;prettyPrinter = new PrettyPrinter\Standard(); 
  } 
  public function enterNode(Node $node) { 
    // Remains the same as above just instead of echoing the 
    // line numbers we call $this-&gt;emitNext(...) method. 
  } 
  public function afterTraverse(array $nodes) { 
    $this-&gt;subject-&gt;onCompleted(); 
  } 
  public function asObservable() { 
    return $this-&gt;subject-&gt;asObservable(); 
  } 
  private function isAssign($cond) { 
    return $cond instanceof Expr\Assign; 
  } 
  private function emitNext(Node $node, Expr\Assign $cond) { 
    $this-&gt;subject-&gt;onNext([ 
      'line' =&gt; $node-&gt;getLine(), 
      'expr' =&gt; $this-&gt;prettyPrinter-&gt;prettyPrintExpr($cond), 
    ]); 
  } 
} 
</pre><p class="calibre8">This node visitor uses a Subject internally and in the <code class="literal">emitNext()</code> method it emits every code style violation as a single item. This item is an associative array itself that contains the line number and the well formatted expression that caused the violation (to make it obvious to the user why it's reported). The <code class="literal">PrettyPrinter</code> class is a part of the PHP Parser library.</p><p class="calibre8">This <code class="literal">Subject</code> class also needs to emit a <code class="literal">complete</code> signal when we're done with this syntax tree. That's in the <code class="literal">afterTraverse()</code> method. Calling the <code class="literal">complete</code> signal is very important to let other operators work with this <code class="literal">Subject</code> properly.</p><p class="calibre8">Since we need to expose this <code class="literal">Subject</code>, we need to be sure nobody else can manipulate with it so we wrap it using the <code class="literal">asObservable()</code> operator.</p></div><div class="book" title="Writing PHPParserOperator"><div class="book"><div class="book"><div class="book"><h3 class="title1"><a id="ch09lvl3sec31" class="calibre1"/>Writing PHPParserOperator</h3></div></div></div><p class="calibre8">This operator will hold a single reference to the PHP Parser that we'll invoke for every file that comes to this operator. This also means that we'll need to create a new instance of the <code class="literal">NodeTraverser</code> class for each file and add new instances of each custom node visitor to it.</p><p class="calibre8">From the operator's point of view, all node visitors are just Observables that emit style violations. The operator needs to collect all values from all of them and then reemit this collection as a single item.</p><p class="calibre8">We'll split this example into two smaller chunks. First, we'll have a look at the creation of the <code class="literal">NodeTraverser</code> instances filled with node visitors:</p><pre class="programlisting">// PHPParserOperator.php 
use Rx\ObservableInterface; 
use Rx\ObserverInterface; 
use Rx\SchedulerInterface; 
use Rx\Operator\OperatorInterface; 
use Rx\Observer\CallbackObserver; 
use PhpParser\NodeTraverser; 
use PhpParser\ParserFactory; 
 
class PHPParserOperator implements OperatorInterface { 
  private $parser; 
  private $traverserClasses; 
 
  public function __construct($traverserClasses = []) { 
    $syntax = ParserFactory::PREFER_PHP7; 
    $this-&gt;parser = (new ParserFactory())-&gt;create($syntax); 
    $this-&gt;traverserClasses = $traverserClasses; 
  } 
 
  private function createTraverser() { 
    $traverser = new NodeTraverser(); 
    $visitors = array_map(function($class) use ($traverser) { 
      /** @var ObservableNodeVisitorInterface $visitor */ 
      $visitor = new $class(); 
      $traverser-&gt;addVisitor($visitor); 
 
      return $visitor-&gt;asObservable() 
        -&gt;toArray() 
        -&gt;map(function($violations) use ($class) { 
          return [ 
            'violations' =&gt; $violations, 
            'class' =&gt; $class 
          ]; 
        }); 
      }, $this-&gt;traverserClasses); 
    return [$traverser, $visitors]; 
  } 
  // ... 
} 
</pre><p class="calibre8">We keep an array of class names for node visitors in the <code class="literal">$traverserClasses</code> property. When we want to create a new <code class="literal">NodeTraverser</code>, we iterate this array with the <code class="literal">array_map()</code> function and instantiate each class. Then we not only add it to the traverser but we also take its Observable (returned from the <code class="literal">asObservable()</code> method) and chain it with the <code class="literal">toArray()</code> and <code class="literal">map()</code> operators.</p><p class="calibre8">The <code class="literal">toArray()</code> operator collects all items emitted by the source Observable and re-emits them as a single array when the source completes. This is why we had to be sure we properly called complete in the <code class="literal">AssignmentInConditionNodeVisitor</code> class. We also used <code class="literal">map()</code> to emit the final collection of violations with the class name that generated them. This isn't necessary, but for practical reasons we want to be able to tell what node visitor generated these results (or, in other words, what style violations are in this collection).</p><p class="calibre8">The <code class="literal">createTraverser()</code> method returns two values: the <code class="literal">NodeTraverser</code> instance and an array of Observables returned from each node visitor.</p><p class="calibre8">The rest of <code class="literal">PHPParserOperator</code> is where the actual subscription happens:</p><pre class="programlisting">class PHPParserOperator implements OperatorInterface { 
  // ... 
  public function __invoke($observable, $observer, $sched=null) { 
    $onNext = function($filepath) use ($observer) { 
      $code = @file_get_contents($filepath); 
      if (!$code) { /* ... emit error message */ } 
 
      list($traverser, $visitors) = $this-&gt;createTraverser(); 
      (new ForkJoinObservable($visitors)) 
        -&gt;map(function($results) use ($filepath) { 
          // $results = all results from all node visitors. 
          $filtered = array_filter($results, function($result) { 
            return $result['violations']; 
          }); 
          return [ 
            'file' =&gt; $filepath, 
            'results' =&gt; $filtered, 
          ]; 
        }) 
        -&gt;subscribeCallback(function($result) use ($observer) { 
          $observer-&gt;onNext($result); 
        }); 
 
      $stmts = $this-&gt;parser-&gt;parse($code); 
      $traverser-&gt;traverse($stmts); 
    }; 
 
    $callbackObserver = new CallbackObserver( 
      $onNext, 
      [$observer, 'onError'], 
      [$observer, 'onCompleted'] 
    ); 
    return $observable-&gt;subscribe($callbackObserver, $sched); 
  } 
} 
</pre><p class="calibre8">First of all, we're using <code class="literal">CallbackObserver</code>, which just passes through all <code class="literal">error</code> and <code class="literal">complete</code> signals. The interesting things happen only in the anonymous function <code class="literal">$onNext</code>:</p><div class="book"><ol class="orderedlist"><li class="listitem" value="1">We're expecting each item to be a string representing a file path. We read the content of the file with the <code class="literal">file_get_contents()</code> function to get the source code we want to analyze.</li><li class="listitem" value="2">Then, we call <code class="literal">createTraverser()</code>, which returns a new instance of <code class="literal">NodeTraverser</code> and also an array of Observables, where we'll get all the style violations. These are already wrapped with <code class="literal">toArray()</code> and <code class="literal">map()</code> as we saw earlier.</li><li class="listitem" value="3">We're creating a new <code class="literal">ForkJoinObservable</code> and passing it the array of Observables from the previous call. We implemented this Observable in <a class="calibre1" title="Chapter 5. Testing RxPHP Code" href="part0043_split_000.html#190861-bd355a22cf10407cb10df27e65585b8d">
Chapter 5
</a>, <span class="strong"><em class="calibre18">Testing RxPHP Code</em></span>. The <code class="literal">ForkJoinObservable</code> class subscribes to all its source Observables and remembers only the latest value emitted by each one of them. When all the source Observables are complete, it reemits all the values as a single array. We know all the sources will emit just one value and then complete, thanks to the <code class="literal">toArray()</code> operator.</li><li class="listitem" value="4">We're not interested in node visitors that didn't emit any violations, so we remove them from the result in the <code class="literal">map()</code> operator.</li><li class="listitem" value="5">In the end, we just subscribe the observer itself to this chain. Note that we're purposely not using just <code class="literal">subscribe($observer)</code> because this would reemit everything including errors and complete signals. The Observable chain we created will complete immediately after emitting its single value thanks to <code class="literal">ForkJoinObservable</code>, which is what we don't want. Have a look at the previous chapter where we talked about sharing a single instance of Subject and what unexpected results it might produce. The same reasons apply here as well.</li></ol><div class="calibre22"/></div><p class="calibre8">After all this, we just run the <code class="literal">traverse()</code> method that analyzes the source code and, thanks to our custom node visitors with Observables, will emit all violations that'll be gathered in <code class="literal">ForkJoinObservable</code>.</p><p class="calibre8">This was a pretty complex operator with a sophisticated behavior. If we go back to the example where we showed how we want to use this operator, we can see that all this logic is effectively hidden from us.</p><p class="calibre8">When we run the original example that we used earlier, we'll get the following result:</p><pre class="programlisting">
<span class="strong"><strong class="calibre17">$ php php_parser_observer_01.php </strong></span>
<span class="strong"><strong class="calibre17">Array (</strong></span>
<span class="strong"><strong class="calibre17">  [file] =&gt; _test_source_code.php</strong></span>
<span class="strong"><strong class="calibre17">  [results] =&gt; Array (</strong></span>
<span class="strong"><strong class="calibre17">    [0] =&gt; Array (</strong></span>
<span class="strong"><strong class="calibre17">      [violations] =&gt; Array (</strong></span>
<span class="strong"><strong class="calibre17">        [0] =&gt; Array (</strong></span>
<span class="strong"><strong class="calibre17">          [line] =&gt; 3</strong></span>
<span class="strong"><strong class="calibre17">          [expr] =&gt; $a = 1</strong></span>
<span class="strong"><strong class="calibre17">        )</strong></span>
<span class="strong"><strong class="calibre17">        [1] =&gt; Array (</strong></span>
<span class="strong"><strong class="calibre17">          [line] =&gt; 5</strong></span>
<span class="strong"><strong class="calibre17">          [expr] =&gt; $b = 2</strong></span>
<span class="strong"><strong class="calibre17">        )</strong></span>
<span class="strong"><strong class="calibre17">        [2] =&gt; Array (</strong></span>
<span class="strong"><strong class="calibre17">          [line] =&gt; 6</strong></span>
<span class="strong"><strong class="calibre17">          [expr] =&gt; $c = 3</strong></span>
<span class="strong"><strong class="calibre17">        )</strong></span>
<span class="strong"><strong class="calibre17">        [3] =&gt; Array (</strong></span>
<span class="strong"><strong class="calibre17">          [line] =&gt; 7</strong></span>
<span class="strong"><strong class="calibre17">          [expr] =&gt; $d = 4</strong></span>
<span class="strong"><strong class="calibre17">        )</strong></span>
<span class="strong"><strong class="calibre17">      )</strong></span>
<span class="strong"><strong class="calibre17">      [class] =&gt; AssignmentInConditionNodeVisitor</strong></span>
<span class="strong"><strong class="calibre17">    )</strong></span>
<span class="strong"><strong class="calibre17">  )</strong></span>
<span class="strong"><strong class="calibre17">)</strong></span>
</pre><p class="calibre8">Each item coming from this operator is a series of nested arrays. We can see the filename we analyzed and the array of results, where each items is generated by one node visitor. Since we have just one result, we also have just one array here. Each result is marked by the node visitor class name and a list of violations. Each violation contains the line number and the exact expression where it occurred.</p><p class="calibre8">This is all nice but how long would it take to analyze a larger project such as the Symfony3 framework? Right now, Symfony3 (without third-party dependencies) has over 3200 files. If processing a single file would take just 1ms, then analyzing the entire project would take over 3s (in fact, processing would take much longer just because of so many filesystem operations).</p><p class="calibre8">So, this looks like a prime example where we could utilize our knowledge of multithreaded programming in PHP with pthreads.</p></div></div></div></div>

<div class="book" title="Implementing ThreadPoolOperator"><div class="book" id="1VSLM2-bd355a22cf10407cb10df27e65585b8d"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch09lvl1sec59" class="calibre1"/>Implementing ThreadPoolOperator</h1></div></div></div><p class="calibre8">We're going to write a universal operator that receives jobs represented by <code class="literal">Thread</code> class instances from its source Observable. Then, it'll submit them to an internal instance of the <code class="literal">Pool</code> class that we saw in the previous chapter.</p><p class="calibre8">In fact, this example with pthreads is going to be entirely built on all the things we've learned in the previous chapter, so we won't recap them here.</p><div class="informaltable" title="Note"><h3 class="title1"><a id="note44" class="calibre1"/>Note</h3><p class="calibre8">This example is also going to use PHP7 syntax in some situations since pthreads v3 works only with PHP7 anyway.</p></div><p class="calibre8">For this operator, well internally use an event loop. In RxPHP, this means we'll use the <code class="literal">StreamSelectLoop</code> class wrapped with a <code class="literal">Scheduler</code> class. Let's see the source code for <code class="literal">ThreadPoolOperator</code> and then talk about why it's implemented like this:</p><pre class="programlisting">// ThreadPoolOperator.php 
class ThreadPoolOperator implements OperatorInterface { 
  private $pool; 
 
  public function __construct($num = 4, 
      $workerClass = Worker::class, $workerArgs = []) { 
 
    $this-&gt;pool = new Pool($num, $workerClass, $workerArgs); 
  } 
 
  public function __invoke($observable, $observer, $sched=null) { 
    $callbackObserver = new CallbackObserver(function($task) { 
        /** @var AbstractRxThread $task */ 
        $this-&gt;pool-&gt;submit($task); 
      }, 
      [$observer, 'onError'], 
      [$observer, 'onCompleted'] 
    ); 
 
    $dis1 = $sched-&gt;schedulePeriodic(function() use ($observer) { 
      $this-&gt;pool-&gt;collect(function($task) use ($observer) { 
        /** @var AbstractRxThread $task */ 
        if ($task-&gt;isDone()) { 
          $observer-&gt;onNext($result); 
          return true; 
        } else { 
          return false; 
        } 
      }); 
    }, 0, 10); 
 
    $dis2 = $observable-&gt;subscribe($callbackObserver); 
    $disposable = new BinaryDisposable($dis1, $dis2); 
    return $disposable; 
  } 
} 
</pre><p class="calibre8">The constructor for <code class="literal">ThreadPoolOperator</code> takes the same arguments as the constructor for the <code class="literal">Pool</code> class that is created right away. The interesting things take place in the <code class="literal">__invoke()</code> method.</p><p class="calibre8">Every item that arrives to this operator is sent to the thread pool with the <code class="literal">submit()</code> method. This means that <code class="literal">ThreadPoolOperator</code> can only work with items represented by the <code class="literal">Thread</code> class from the pthreads extension (and of course all classes extending this class).</p><p class="calibre8">Internally, we use the <code class="literal">Scheduler</code> class to periodically call a callable that will check the thread pool for threads that have finished and are ready to be collected. This is the same <code class="literal">collect()</code> method we saw in the previous chapter. However, in this implementation we're making only a single check in every iteration of the callable. There's one very important reason why we want to use it this way. We know that we can use the <code class="literal">collect()</code> method in a loop that runs as long as there are tasks scheduled to be run.</p><p class="calibre8">The loop typically looks like this:</p><pre class="programlisting">$remaining = N; 
while ($remaining !== 0) { 
    $pool-&gt;collect(function(Thread $work) use (&amp;$remaining) { 
        $done = $work-&gt;isDone(); 
        if ($done) { 
            $remaining--; 
        } 
        return $done; 
    }); 
}  
</pre><p class="calibre8">This is of course correct. The only problem is that this call is blocking. The interpreter is stuck in this loop and doesn't let us do anything else. If we wanted to use such a loop and at the same time read data from a stream via <code class="literal">StreamSelectLoop</code> (see <a class="calibre1" title="Chapter 6. PHP Streams API and Higher-Order Observables" href="part0050_split_000.html#1FLS41-bd355a22cf10407cb10df27e65585b8d">
Chapter 6
</a>, <span class="strong"><em class="calibre18">PHP Streams API and Higher-Order Observables</em></span>), we wouldn't be able to receive anything as long as this loop is running. Another example that wouldn't work if we used just this <code class="literal">while</code> loop could be <code class="literal">IntervalObservable</code> , which needs to schedule timers itself. These wouldn't be triggered until this loop is ended.</p><p class="calibre8">That's why we're periodically scheduling a 10ms timer to run <code class="literal">collect()</code> just once and then let other timers or streams be handled. The finished threads are kept in the <code class="literal">Pool</code> class until we read and reemit their results.</p><p class="calibre8">This implementation has one very important behavior. Since it is running all tasks in parallel and completely independently of the rest of the Observable chain, we need to be aware when we send the <code class="literal">complete</code> signal.</p><p class="calibre8">Consider the following code:</p><pre class="programlisting">Observable::fromArray([1,2,3]) 
    -&gt;map(function($val) { 
        return new MyThread($val); 
    }) 
    -&gt;lift(function() { 
        return ThreadPoolOperator(...); 
    }) 
... 
</pre><p class="calibre8">In this example, the <code class="literal">ThreadPoolOperator</code> class receives three instances of <code class="literal">MyThread</code> that'll be submitted to the <code class="literal">Pool</code> instance, but it also receives a complete signal. This complete signal is immediately passed to its observer that unsubscribes before any of the threads are finished and emit any value.</p><p class="calibre8">At the same time, <code class="literal">ThreadPoolOperator</code> can't decide for itself when you want to send the <code class="literal">complete</code> signal. Sometimes when the thread pool is empty and there are no tasks running. Other times we might want to start threads based on PHP stream activity that can happen at any time.</p><p class="calibre8">That's why we don't send <code class="literal">complete</code> signals automatically.</p></div>

<div class="book" title="Implementing ThreadPoolOperator">
<div class="book" title="Implementing PHPParserThread"><div class="book"><div class="book"><div class="book"><h2 class="title2" id="calibre_pb_1"><a id="ch09lvl2sec86" class="calibre1"/>Implementing PHPParserThread</h2></div></div></div><p class="calibre8">Now we can take a look at how the actual parser task is going to be implemented. We already know that it needs to be represented by a class extending the default <code class="literal">Thread</code> class from the pthreads extension and we also know that we're going to process files using the PHP Parser, so we can reuse the <code class="literal">PHPParserOperator</code> class.</p><p class="calibre8">Before we do that, we should define some common behavior for all <code class="literal">Thread</code> objects:</p><pre class="programlisting">// AbstractRxThread.php 
abstract class AbstractRxThread extends Thread { 
    private $done = false; 
    protected $result; 
 
    public function getResult() { 
        return $this-&gt;result; 
    } 
    public function isDone() { 
        return $this-&gt;done; 
    } 
    protected function markDone() { 
        $this-&gt;done = true; 
    } 
} 
</pre><p class="calibre8">All tasks we want to run with <code class="literal">ThreadPoolOperator</code> need to extend this abstract class that defines some common methods.</p><p class="calibre8">Notice that we don't have a setter method for the <code class="literal">$result</code> property. This is intentional and we'll see why when we look at the implementation of <code class="literal">PHPParserThread</code> that we will use in this application:</p><pre class="programlisting">class PHPParserThread extends AbstractRxThread { 
  private $filenames; 
 
  public function __construct($filename) { 
    $this-&gt;filenames =  
        (array)(is_array($filename) ? $filename : [$filename]); 
    /** @var Volatile result */ 
    $this-&gt;result = []; 
  } 
 
  public function run() { 
    $last = 0; 
    Observable::fromArray($this-&gt;filenames) 
      -&gt;lift(function() { 
        $classes = ['AssignmentInConditionNodeVisitor']; 
        return new PHPParserOperator($classes); 
      }) 
      -&gt;subscribeCallback(function ($results) use (&amp;$last) { 
        $this-&gt;result[$last++] = (array)[ 
          'file' =&gt; $results['file'], 
          'results' =&gt; $results['results'], 
        ]; 
      }, null, function() { 
        $this-&gt;markDone(); 
      }); 
  } 
} 
</pre><p class="calibre8">As you can see, we're using typecasting for the exact same reasons as described in the previous chapter. Also notice that we're wrapping the input file with an array. Since we want to make this class reusable, we'll support both passing a single file and an array of files. We're initializing the <code class="literal">$result</code> property with an empty array that's automatically converted to a <code class="literal">Volatile</code> object by pthreads (again, for more information refer to the previous chapter). For this reason, we need to keep track of the number of items already persistent by ourselves with the <code class="literal">$last</code> variable. Also, notice that our result is always going to be an array, even when processing just a single file.</p><p class="calibre8">At this point, we need to be aware why not to use any setter method for <code class="literal">$result</code>. In the previous chapter, when talking about <code class="literal">Volatile</code> objects, we said that pthreads automatically convert arrays to <code class="literal">Volatile</code> when assigning to a property in any class extending the <code class="literal">Threaded</code> class. For this reason, we can't use a setter because we wouldn't be able to force typecasting to array with <code class="literal">(array)</code>. This automatic conversion happens on assignment, so we'd have to force all results in <code class="literal">AbstractRxThread</code> to be arrays or leave it to the automatic conversion, which is something we definitely don't want.</p><p class="calibre8">To be extra clear about this issue, let's consider the following setter method:</p><pre class="programlisting">public function setResult($result) { 
    $this-&gt;result = $result; 
} 
</pre><p class="calibre8">The assignment happens inside this function where we don't want to force using arrays with <code class="literal">(array)</code> typecast. We might want to use a simple string or an integer, for example.</p><p class="calibre8">So this was our <code class="literal">PHPParserThread</code> class that we'll use in this example. There's actually one more issue.</p><p class="calibre8">Creating a new thread with pthreads means we're internally creating a new PHP interpreter context. The only classes and functions this new context knows are those built into the PHP interpreter itself. This new context has no idea what <code class="literal">Observable</code> or <code class="literal">PHPParserOperator</code> classes are.</p><p class="calibre8">Just like we include the <code class="literal">autoload.php</code> Composer autoloader script when running any PHP application, we need to do this for every new thread we create. Since we don't want to do this every time we use <code class="literal">PHPParserThread</code>, we can make use of a custom worker that'll do it for us in its <code class="literal">run()</code> method. This <code class="literal">run()</code> method is called when spawning a new interpreter context and lets us initialize it by, for example, including the <code class="literal">autoload.php</code> script.</p></div></div>

<div class="book" title="Implementing ThreadPoolOperator">
<div class="book" title="Implementing PHPParserWorker"><div class="book"><div class="book"><div class="book"><h2 class="title2" id="calibre_pb_2"><a id="ch09lvl2sec87" class="calibre1"/>Implementing PHPParserWorker</h2></div></div></div><p class="calibre8">For the sake of simplicity, we're not defining our classes in namespaces and usually just including them with the <code class="literal">require_once</code> keyword, such as in the following example:</p><pre class="programlisting">require_once __DIR__ . '/../Chapter 02/DebugSubject.php'; 
</pre><p class="calibre8">For this reason, we need to tell the autoloader created inside each worker where to find such classes ideally without relying on the <code class="literal">require_once</code> statements.</p><p class="calibre8">Our worker will be a simple class (based on the official example on how to use Composer's autoloader with pthreads at <a class="calibre1" href="https://github.com/krakjoe/pthreads-autoloading-composer">
https://github.com/krakjoe/pthreads-autoloading-composer
</a>):</p><pre class="programlisting">// PHPParserWorker.php 
class PHPParserWorker extends \Worker { 
  protected $loader; 
   
  public function __construct($loader) { 
    $this-&gt;loader = $loader; 
  } 
 
  public function run() { 
    $classLoader = require_once($this-&gt;loader); 
    $dir = __DIR__; 
    $classLoader-&gt;addClassMap([ 
      'DebugSubject' =&gt; $dir . '/../Chapter 02/DebugSubject.php', 
      'ThreadWorkerOperator' =&gt; $dir.'/ThreadWorkerOperator.php', 
      'PHPParserThread' =&gt; $dir . '/PHPParserThread.php', 
      'PHPParserWorker' =&gt; $dir . '/PHPParserWorker.php', 
      'PHPParserOperator' =&gt; $dir . '/PHPParserOperator.php', 
    ]); 
  } 
 
  public function start(int $options = PTHREADS_INHERIT_ALL) { 
    return parent::start(PTHREADS_INHERIT_NONE); 
  } 
} 
</pre><p class="calibre8">This worker uses <code class="literal">require_once</code> to register the autoloader, where we add a few class paths. The initialized interpreter context will be used by all <code class="literal">Thread</code> instances ran by this worker.</p><p class="calibre8">Finally, we can put all this into a single Observable chain.</p></div></div>

<div class="book" title="Implementing ThreadPoolOperator">
<div class="book" title="Running PHP Parser in a multithreaded application"><div class="book"><div class="book"><div class="book"><h2 class="title2" id="calibre_pb_3"><a id="ch09lvl2sec88" class="calibre1"/>Running PHP Parser in a multithreaded application</h2></div></div></div><p class="calibre8">First, we will test all the classes we made right now on processing the same sample file as earlier and then move to recursively processing directories from the Symfony3 project:</p><pre class="programlisting">// threads_php_parser_01.php 
$loop = new StreamSelectLoop(); 
$scheduler = new EventLoopScheduler($loop); 
 
Observable::create(function(ObserverInterface $observer) { 
    $observer-&gt;onNext('_test_source_code.php'); 
  }) 
  -&gt;map(function($filename) { 
    return new PHPParserThread($filename); 
  }) 
  -&gt;lift(function() { 
    $args = [__DIR__ . '/../vendor/autoload.php']; 
    return new ThreadPoolOperator(2,PHPParserWorker::class,$args); 
  }) 
  -&gt;flatMap(function($result) { 
    return Observable::fromArray((array)$result); 
  }) 
  -&gt;take(1) 
  -&gt;subscribeCallback(function($result) { 
    print_r($result); 
  }, null, null, $scheduler); 
 
$loop-&gt;run(); 
</pre><p class="calibre8">This example is using all three classes for multithreading that we created in this chapter. Let's see what happens in this operator chain step by step:</p><div class="book"><ol class="orderedlist"><li class="listitem" value="1">We have a single source Observable that emits the filename as its value. Notice that we're purposely not sending the complete signal.</li><li class="listitem" value="2">Then we use map to turn all filenames to instances of the <code class="literal">PHPParserThread</code> class.</li><li class="listitem" value="3">The <code class="literal">ThreadPoolOperator</code> class is fed with tasks it has to run.</li><li class="listitem" value="4">We've mentioned already that all results from <code class="literal">ThreadPoolOperator</code> are returned as arrays even when we processed just a single file. For this reason, we use <code class="literal">flatMap()</code> to reemit its values and flatten the result. Also we need to typecast the result from <code class="literal">Volatile</code> to an array.</li><li class="listitem" value="5">We didn't send the <code class="literal">complete</code> signal from the source on purpose. However, we know that we processed only one file and therefore we're expecting only one item to be emitted. So we can use <code class="literal">take(1)</code> to send the <code class="literal">complete</code> signal for us and the observer will unsubscribe successfully, which will stop the event loop as well.</li></ol><div class="calibre22"/></div><p class="calibre8">We can run this example and see that it returned exactly the same result as the original version with just <code class="literal">PHPParserOperator</code>:</p><pre class="programlisting">
<span class="strong"><strong class="calibre17">$ php threads_php_parser_01.php </strong></span>
<span class="strong"><strong class="calibre17">Array (</strong></span>
<span class="strong"><strong class="calibre17">  [file] =&gt; _test_source_code.php</strong></span>
<span class="strong"><strong class="calibre17">  [results] =&gt; Array (</strong></span>
<span class="strong"><strong class="calibre17">    [0] =&gt; Array (</strong></span>
<span class="strong"><strong class="calibre17">      [violations] =&gt; Array (</strong></span>
<span class="strong"><strong class="calibre17">        ...</strong></span>
</pre><div class="informaltable" title="Note"><h3 class="title1"><a id="note45" class="calibre1"/>Note</h3><p class="calibre8">Although most of our CLI applications in this book are based on the Symfony Console component, this time we don't even need it since the entire application can be written as a single operator chain.</p></div><p class="calibre8">In this example, we spawned two workers even though we wanted to process just a single file.</p><p class="calibre8">The question is what will be the difference if we try to process multiple files in parallel. For this reason, we'll create a Symfony3 test project that contains literally thousands of PHP files we can test:</p><pre class="programlisting">
<span class="strong"><strong class="calibre17">$ composer create-project symfony/framework-standard-edition testdir</strong></span>
</pre><p class="calibre8">The following example will work just like the previous one. This time, however, we'll make a recursive iterator that walks through all subdirectories and emits all PHP files it finds. We can write this all as one large operator chain:</p><pre class="programlisting">// threads_php_parser_02.php 
const MAX_FILES = 500; 
Observable::create(function($observer) use ($loop) { 
    $start = microtime(true); 
    $src = __DIR__ . '/../symfony_template'; 
    $dirIter = new \RecursiveDirectoryIterator($src); 
    $iter = new \RecursiveIteratorIterator($dirIter);  
 
    while ($iter-&gt;valid()) { 
      /** @var SplFileInfo $file */ 
      $file = $iter-&gt;current(); 
      if ($file-&gt;getExtension() === 'php' &amp;&amp; $file-&gt;isReadable()){ 
        $observer-&gt;onNext($file-&gt;getRealPath()); 
      } 
      $iter-&gt;next(); 
    }  
 
    return new CallbackDisposable(function() use ($loop, $start) { 
      echo "duration: ".round(microtime(true) - $start, 2)."s\n"; 
      $loop-&gt;stop(); 
    }); 
  }) // End of Observable::create() 
  -&gt;bufferWithCount(20) 
  -&gt;map(function($filenames) { 
    return new PHPParserThread($filenames); 
  }) 
  -&gt;lift(function() { 
    $args = [__DIR__ . '/../vendor/autoload.php']; 
    return new ThreadPoolOperator(4,PHPParserWorker::class,$args); 
  }) 
  -&gt;flatMap(function($result) { 
    return Observable::fromArray((array)$result); 
  }) 
  -&gt;take(MAX_FILES) 
  -&gt;filter(function($result) { 
    return count($result['results']) &gt; 0; 
  }) 
  -&gt;subscribeCallback(function($result) { 
    print_r($result); 
  }, null, null, $scheduler); 
</pre><p class="calibre8">This is the longest operator chain we've written in this book. The main thing that has changed is the source emitting filenames that we want to analyze. We have two different iterators, where both of them return <code class="literal">SplFileInfo</code> objects. We know how many files we want to test in total, so we can avoid emitting redundant values with the <code class="literal">take()</code> operator.</p><p class="calibre8">When we spoke about backpressure in the previous chapters, we mentioned the <code class="literal">bufferWithCount()</code> operator that stacks values and then reemits them in a single array. This comes very handy now where we don't want to create a task on the thread pool for every single file and rather emit them in batches.</p><p class="calibre8">In the end, we also used <code class="literal">filter()</code> to ignore all the results that don't have any violations. Of course, we're interested only in files that have at least one violation.</p><p class="calibre8">An important part of this example is that it measures how long it took to run this entire application (from the initial subscription until disposing <code class="literal">CallbackDisposable</code>).</p><p class="calibre8">If we run this code, we'll see a large list that looks similar to the following:</p><pre class="programlisting">
<span class="strong"><strong class="calibre17">$ php threads_php_parser_02.php</strong></span>
<span class="strong"><strong class="calibre17">...</strong></span>
<span class="strong"><strong class="calibre17">Array (</strong></span>
<span class="strong"><strong class="calibre17">  [file] =&gt; ...vendor/symfony/src/Symfony/Bridge/Twig/AppVariable.php</strong></span>
<span class="strong"><strong class="calibre17">  [results] =&gt; Array (</strong></span>
<span class="strong"><strong class="calibre17">    [0] =&gt; Array (</strong></span>
<span class="strong"><strong class="calibre17">      [violations] =&gt; Array (</strong></span>
<span class="strong"><strong class="calibre17">        [0] =&gt; Array (</strong></span>
<span class="strong"><strong class="calibre17">          [line] =&gt; 101</strong></span>
<span class="strong"><strong class="calibre17">          [expr] =&gt; $request = $this-&gt;getRequest()</strong></span>
<span class="strong"><strong class="calibre17">        )</strong></span>
<span class="strong"><strong class="calibre17">      )</strong></span>
<span class="strong"><strong class="calibre17">      [class] =&gt; AssignmentInConditionNodeVisitor</strong></span>
<span class="strong"><strong class="calibre17">    )</strong></span>
<span class="strong"><strong class="calibre17">  )</strong></span>
<span class="strong"><strong class="calibre17">)</strong></span>
<span class="strong"><strong class="calibre17">...</strong></span>
</pre><p class="calibre8">The line reported contains the following code:</p><pre class="programlisting">if ($request = $this-&gt;getRequest()) { 
</pre><p class="calibre8">This is really a code style that we wanted to be able to report.</p><p class="calibre8">Now comes the important question, what is the effect of running the analyzer in multiple-threads? We can make a couple of reruns with settings such as <code class="literal">1</code>, <code class="literal">2</code>, <code class="literal">4</code>, and <code class="literal">6</code> threads. To get more relevant results, we can increase the number of files processed to 1,000 and also disable the <code class="literal">xdebug</code> extension that otherwise slows down the execution significantly. On average, the times were as follows:</p><pre class="programlisting">
<span class="strong"><strong class="calibre17">1 thread = 5.60s</strong></span>
<span class="strong"><strong class="calibre17">2 threads = 3.52s</strong></span>
<span class="strong"><strong class="calibre17">4 threads = 3.08s</strong></span>
<span class="strong"><strong class="calibre17">6 threads = 4.80s</strong></span>
</pre><p class="calibre8">As we can see, increasing the number of threads starts to be counterproductive. These times were measured on 2, 5 GHz Intel Core i5, which is a dual-core processor with an SSD hard drive. The result for a higher number of threads would probably be better with a non-SSD hard drive because each thread would have to spend more time loading file contents, which would allow other threads to execute in the meantime.</p><p class="calibre8">We almost reached half the time of running just a single thread, which is a realistic expectation. On a dual-core processor and with the overhead generated by RxPHP and PHP itself, this is an expected result.</p><p class="calibre8">We can have a look at the output of the <code class="literal">htop</code> command that shows the current CPU usage to prove that both cores are fully utilized:</p><p class="calibre8">
</p><div class="mediaobject"><img src="../images/00032.jpeg" alt="Running PHP Parser in a multithreaded application" class="calibre19"/></div><p class="calibre20"> </p><p class="calibre8">
</p><p class="calibre8">Current CPU usage when running threads_php_parser_02.php example</p><p class="calibre8">The <code class="literal">htop</code> tool is showing four cores because there are two hardware threads per core (it's in fact just a dual-core processor).</p><p class="calibre8">Running the parser in parallel in a single process by just utilizing pthreads is pretty efficient.</p><p class="calibre8">Our use case can be generalized as simply splitting a job among multiple workers. We don't really care what protocols we'll use or how the distribution is going to happen. We don't even care about what worker will process a particular batch. We just need to get the job done.</p><p class="calibre8">This is an ideal use case for Gearman.</p></div></div>

<div class="book" title="Introduction to Gearman"><div class="book" id="20R682-bd355a22cf10407cb10df27e65585b8d"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch09lvl1sec60" class="calibre1"/>Introduction to Gearman</h1></div></div></div><p class="calibre8">Gearman is a framework for distributing work among multiple processes and machines. Due to its functionality, it can serve as a manager, load balancer, or interface between different languages with no single point of failure.</p><p class="calibre8">Since this book is about Rx/reactive/asynchronous programming, we're going to cover Gearman fairly quickly. Needless to say, Gearman is very easy to set up and use.</p><p class="calibre8">The Gearman PHP extension is written in the C language, so we need to install it via PECL or a package manager relevant to your platform (refer to <a class="calibre1" href="http://gearman.org/download/">
http://gearman.org/download/
</a> for more information).</p><p class="calibre8">Gearman's name is an anagram of the word "Manager" and it pretty well captures its purpose. Gearman doesn't do the work itself. It just receives a task (also referred to simply as a job) from a client and delegates it to an available worker.</p><p class="calibre8">The structure of any Gearman application is easily understood from the following diagram:</p><p class="calibre8">
</p><div class="mediaobject"><img src="../images/00033.jpeg" alt="Introduction to Gearman" class="calibre19"/></div><p class="calibre20"> </p><p class="calibre8">
</p><p class="calibre8">Diagram from the official Gearman documentation (http://gearman.org/)</p><p class="calibre8">Every Gearman application has the following three main components:</p><div class="book"><ul class="itemizedlist"><li class="listitem"><span class="strong"><strong class="calibre17">Gearman Job Server</strong></span>: This is usually run as a daemon that accepts tasks from clients and delegates them to workers. It's written in C (originally in Perl) and doesn't do any work by itself. It's also able to keep the current tasks queue persisted in a database so it can be restored on failure.</li><li class="listitem"><span class="strong"><strong class="calibre17">Client</strong></span>: This is any application in any language that needs some job to be done. This can be a web application that needs to send an e-mail or a CLI application that needs to run static analysis on a couple of files. The client doesn't do the job by itself. It sends a message to the job server and either waits until it's done or just waits for confirmation from the job server that it was added to the queue.</li><li class="listitem"><span class="strong"><strong class="calibre17">Worker</strong></span>: This is the part that actually does the job delegated by the job server. It can be written in any language as well. It contains a list of functions that it's able to perform and based on that the job server assigns the work it needs to do.</li></ul></div><p class="calibre8">So in order to start using Gearman, we need to have the job server part installed and running on our system; it's usually called <span class="strong"><strong class="calibre17">gearman</strong></span> or <span class="strong"><strong class="calibre17">gearmand</strong></span>. You can find the instructions how to install and run Gearman for your platform at <a class="calibre1" href="http://gearman.org/download/">
http://gearman.org/download/
</a>.</p></div>

<div class="book" title="Introduction to Gearman">
<div class="book" title="String strlen client and worker"><div class="book"><div class="book"><div class="book"><h2 class="title2" id="calibre_pb_1"><a id="ch09lvl2sec89" class="calibre1"/>String strlen client and worker</h2></div></div></div><p class="calibre8">We can create a very simple application, where we'll have a worker that takes a string and returns its length. The client in this case will just send a string to the job server requesting to get the length back.</p><p class="calibre8">Our client is going to be pretty simple. It'll just request a job, <code class="literal">strlen</code>, to be done and then wait until it receives a response from the job server:</p><pre class="programlisting">// gearman_client_01.php 
$client = new GearmanClient(); 
$client-&gt;addServer('127.0.0.1'); 
$client-&gt;setTimeout(3000); 
 
$length = @$client-&gt;doNormal('strlen', 'Hello World!'); 
if (empty($length)) { 
    echo "timeout\n"; 
} else { 
    var_dump(intval($length)); 
} 
</pre><p class="calibre8">Our client connects to a single job server and sets a three-second timeout. If it doesn't receive a response within this time, then it continues executing the rest of the script. We're using a single server, but we can have multiple job servers running on different machines, and if any of them crash, clients will continue with the other ones. This makes the system fault tolerant. Also, notice that our client is blocking.</p><p class="calibre8">We're requesting a job to be done using the <code class="literal">doNormal()</code> method, where we need to specify the name of the job we want to do and all the data the worker needs in order to complete it. Apart from <code class="literal">doNormal()</code>, there are also methods such as <code class="literal">doLow()</code> and <code class="literal">doHigh()</code> that request the job with a different priority.</p><p class="calibre8">Typically, when we want to run a job, we want to know its result. For example, in this case, we wanted to wait to get the string length back. In some situations, we just want to schedule a job, but we're not interested in when it happens and what its result is. A typical use case is a web application where a user registers and we want to send them a confirmation e-mail. We don't want to slow down the page load by waiting until the e-mail is sent.</p><p class="calibre8">For this reason, the <code class="literal">Client</code> class also has the <code class="literal">doBackground()</code> method (with their higher and lower priority variants). This method sends the request to a job server and only waits for confirmation that it was received. The client is not interested in when it'll be executed and with what result. If we refer to the previous use case with a web application and sending confirmation e-mails, it doesn't matter whether the e-mail is sent right now or after 10 seconds.</p><p class="calibre8">The worker script will wait for jobs from the job server, execute them, and return the result:</p><pre class="programlisting">// gearman_worker_01.php 
$worker = new GearmanWorker(); 
$worker-&gt;addServer('127.0.0.1'); 
$worker-&gt;addFunction('strlen', function(GearmanJob $job) { 
    echo 'new job: ' . $job-&gt;workload() 
        . ' (' . $job-&gt;workloadSize() . ")\n"; 
    return strlen($job-&gt;workload()); 
}); 
 
while ($worker-&gt;work()) { } 
</pre><p class="calibre8">Usually, the worker runs in a loop and therefore is blocking as well. We connect to the same job server as the client and define a single function called <code class="literal">strlen</code>. This is the same name that the client specified when requesting a job. The value returned from the callable will be sent back to the client automatically.</p><p class="calibre8">Now, we can test this example. Before running either the client or the worker, we need to start the Gearman job server:</p><pre class="programlisting">
<span class="strong"><strong class="calibre17">$ gearmand --verbose DEBUG</strong></span>
</pre><p class="calibre8">We can use the <code class="literal">verbose</code> option to make the process more talkative. Without specifying any other options, the job server will listen on port <code class="literal">4730</code>, which is used by the PHP extension as well, so we don't need to configure anything.</p><p class="calibre8">Then, we'll run both the worker and the client. It doesn't matter which one we run first. Our client waits for three seconds before the timeout expires, so we can run it first and the pending job will be queued by the job server until there's at least one worker available to execute this job.</p><p class="calibre8">The console output after we run both the client and the worker will look like the following:</p><pre class="programlisting">
<span class="strong"><strong class="calibre17">$ php gearman_worker_01.php </strong></span>
<span class="strong"><strong class="calibre17">new job: Hello World! (12)</strong></span>
</pre><p class="calibre8">The worker is, in fact, running in a loop, so after processing this job, it'll wait for another one:</p><pre class="programlisting">
<span class="strong"><strong class="calibre17">$ php gearman_client_01.php </strong></span>
<span class="strong"><strong class="calibre17">int(12)</strong></span>
</pre><p class="calibre8">The client just receives the response and ends.</p><p class="calibre8">What's sometimes useful is that the Gearman CLI also contains a <code class="literal">gearman</code> application that can run as a client or worker. In our example, we didn't have to write a worker at all and could simply run the following command:</p><pre class="programlisting">
<span class="strong"><strong class="calibre17">$ gearman -w -f strlen -- wc -c</strong></span>
</pre><p class="calibre8">This command creates a worker that connects to its default settings (localhost on port <code class="literal">4730</code>). With <code class="literal">-w</code>, we told Gearman that we want to start a worker, and with <code class="literal">-f strlen</code>, we defined what function it handles. Then, when it receives a new job, it spawns a new subprocess and runs <code class="literal">wc -c</code>, where it feeds the workload as a standard input. So, this command is a drop-in replacement for our PHP worker.</p><p class="calibre8">Of course we can run multiple workers at the same time on the same machine. Each worker can handle multiple different functions. The job server is responsible for deciding what worker is going to process each job.</p></div></div>

<div class="book" title="Introduction to Gearman">
<div class="book" title="Running PHP Parser as a Gearman worker"><div class="book"><div class="book"><div class="book"><h2 class="title2" id="calibre_pb_2"><a id="ch09lvl2sec90" class="calibre1"/>Running PHP Parser as a Gearman worker</h2></div></div></div><p class="calibre8">We've already seen how to run our <code class="literal">PHPParserOperator</code> in multiple threads. We can, however, run it in multiple processes more easily than in threads by writing a Gearman worker that runs <code class="literal">PHPParserOperator</code> internally.</p><p class="calibre8">The worker will be very simple. It'll just receive the filename it needs to load and analyze, and then return the result:</p><pre class="programlisting">// gearman_worker_02.php 
 
$worker = new GearmanWorker(); 
$worker-&gt;addServer('127.0.0.1'); 
 
$worker-&gt;addFunction('phpparser', function(GearmanJob $job) { 
    Observable::just($job-&gt;workload()) 
        -&gt;lift(function() { 
            $classes = ['AssignmentInConditionNodeVisitor']; 
            return new PHPParserOperator($classes); 
        }) 
        -&gt;subscribeCallback(function($results) use ($job) { 
            $job-&gt;sendComplete(json_encode($results)); 
        }); 
}); 
while ($worker-&gt;work()) { } 
</pre><p class="calibre8">The main difference is that we're not using any return statement in the callable for the <code class="literal">phpparser</code> function. Since everything is asynchronous in RxPHP, we need to use the <code class="literal">sendComplete(...)</code> method to send the result to the client and mark the job as done.</p><p class="calibre8">When we run this worker, it won't print any output to the console:</p><pre class="programlisting">
<span class="strong"><strong class="calibre17">$ php gearman_worker_02.php</strong></span>
</pre><p class="calibre8">Then we can test it right away, without writing any client application, and just use the CLI command as a client:</p><pre class="programlisting">
<span class="strong"><strong class="calibre17">$ gearman -f phpparser -s "_test_source_code.php" | json_pp</strong></span>
<span class="strong"><strong class="calibre17">{</strong></span>
<span class="strong"><strong class="calibre17">   "results" : [</strong></span>
<span class="strong"><strong class="calibre17">      {</strong></span>
<span class="strong"><strong class="calibre17">         "violations" : [</strong></span>
<span class="strong"><strong class="calibre17">            {</strong></span>
<span class="strong"><strong class="calibre17">               "expr" : "$a = 1",</strong></span>
<span class="strong"><strong class="calibre17">               "line" : 3</strong></span>
<span class="strong"><strong class="calibre17">            },</strong></span>
<span class="strong"><strong class="calibre17">            ...</strong></span>
<span class="strong"><strong class="calibre17">         ],</strong></span>
<span class="strong"><strong class="calibre17">         "class" : "AssignmentInConditionNodeVisitor"</strong></span>
<span class="strong"><strong class="calibre17">      }</strong></span>
<span class="strong"><strong class="calibre17">   ],</strong></span>
<span class="strong"><strong class="calibre17">   "file" : "_test_source_code.php"</strong></span>
<span class="strong"><strong class="calibre17">}</strong></span>
</pre><p class="calibre8">We can see that the console output is the same as we saw previously when testing the <code class="literal">PHPParserOperator</code> operator.</p><p class="calibre8">The <code class="literal">-f phpparser</code> tells <code class="literal">gearman</code> what function we want to run, and with <code class="literal">-s</code> we can skip reading from the standard input and just pass the string as a workload. At the end, we used <code class="literal">json_pp</code> to pretty print the output to make it more readable.</p><p class="calibre8">Of course, we're running this example on the same machine and in the same directory, so we don't need to worry about correct file paths. In a real-world application, we'd probably send the file content instead.</p><p class="calibre8">This was a fairly quick introduction to Gearman. As we can see, using Gearman is very easy. Actually, in PHP it's much easier to use Gearman than using the pthreads extension to run jobs in parallel.</p><p class="calibre8">From our perspective, it's important to know that Gearman applications are usually blocking, so everything we mentioned about running multiple even loops in <a class="calibre1" title="Chapter 6. PHP Streams API and Higher-Order Observables" href="part0050_split_000.html#1FLS41-bd355a22cf10407cb10df27e65585b8d">
Chapter 6
</a>, <span class="strong"><em class="calibre18">PHP Streams API and Higher-Order Observables</em></span>, is very relevant here as well.</p><p class="calibre8">If you want to read more about Gearman, head over to their official documentation with examples at <a class="calibre1" href="http://gearman.org/manual/">
http://gearman.org/manual/
</a>.</p></div></div>

<div class="book" title="Introduction to Gearman">
<div class="book" title="Comparing pthreads and Gearman"><div class="book"><div class="book"><div class="book"><h2 class="title2" id="calibre_pb_3"><a id="ch09lvl2sec91" class="calibre1"/>Comparing pthreads and Gearman</h2></div></div></div><p class="calibre8">The main difference between using pthreads and Gearman is obviously whether we're running a single process with multiple threads or just one process multiple times.</p><p class="calibre8">The advantages and disadvantages of pthreads were partly covered in the previous chapter and also here. Having completely separated PHP interpreter contexts makes things a little non-intuitive (for example, using autoloaders and yet again sharing data between contexts) and definitely requires more debugging than the same single-threaded equivalent. However, if we're willing to spend the necessary time with it, the performance benefits are significant and at the end running a single process is always easier than taking care of multiple processes.</p><p class="calibre8">Gearman is designed to delegate work from clients to workers and send the results back to clients, if necessary. It's not supposed to be a general message exchanging framework. Thanks to this very specific focus, using Gearman is very easy. With workers, we don't care who, where, and sometimes not even when the work will be done. This is all up to the job server to decide.</p><p class="calibre8">In terms of scaling, threads are not a real option here. On the other hand, scaling with Gearman is simple. Just add more workers and Gearman will distribute the load evenly between them.</p><p class="calibre8">If we wanted to use some more adaptable frameworks, then RabbitMQ or ZMQ would be some good options. These are designed to be easily optimizable, for example by disabling acknowledge messages or using the publish/subscribe pattern, and overall provide more flexibility than Gearman. However, more effort is definitely required to implement these properly.</p></div></div>
<div class="book" title="Summary" id="21PMQ1-bd355a22cf10407cb10df27e65585b8d"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch09lvl1sec61" class="calibre1"/>Summary</h1></div></div></div><p class="calibre8">The purpose of this chapter was to use multithreaded and distributed computing on a practical example that also involves RxPHP.</p><p class="calibre8">We used PHP Parser library to make static code analysis of PHP scripts. We wrapped the parser with the RxPHP operator and ran it in parallel in multiple threads using the pthreads extension and in multiple workers with Gearman.</p><p class="calibre8">We also saw how we can make thread pools reusable in RxPHP by wrapping them with <code class="literal">ThreadPoolOperator</code>.</p><p class="calibre8">The next chapter will cover topics that didn't fit into any of the previous ones, and show some interesting and advanced use cases for RxPHP.</p></div></body></html>