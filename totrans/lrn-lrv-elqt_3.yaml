- en: Chapter 3. The Most Important Element – the Model!
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Finally, I can say it: things are getting really, really serious from this
    moment. In the previous chapters, you studied everything you needed to make a
    start. Maybe it was a little annoying, but you knew that you would need it. Now,
    stop talking about the past; it''s over. In this chapter, many amazing things
    await.'
  prefs: []
  type: TYPE_NORMAL
- en: 'As you can imagine by the title, this part is going to be about the most important
    and atomic Eloquent element: **the model**. We will analyze the *M* in **MVC**.
    Considering that you are reading a book about creating a data-based application,
    exactly, really important! However, I don''t want to bore you anymore. Let''s
    talk about what we are going to see in the next sections.'
  prefs: []
  type: TYPE_NORMAL
- en: Usually, there is a *standard* way to look at the Eloquent documentation. It's
    the same as you can see on the Laravel site. In my initial Laravel days, I used
    those pages but I felt a little *incomplete*. So, I changed things a little bit
    but in a more simplified way. If you have ever developed a web application in
    your life, I'm quite sure that you made a data-based application with tables and
    records. Right? Well...
  prefs: []
  type: TYPE_NORMAL
- en: If you think about it, you can do four basic operations on them. Whenever you
    develop an application, there's a very high possibility that you are going to
    implement some *create*, *read*, *update*, and *delete* logic for your items.
    This is exactly what we are going to see in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: First of all, we will introduce the simple, basic model. It will be a single
    line of code! Then, we will talk about CRUD (**create, read, update, and delete**)
    operations with Eloquent. After that point, you will have all the *basics* and
    an overview of the mechanism. We will also deal with the `where()` method and
    everything related, unscrambling everything about conditions and selections.
  prefs: []
  type: TYPE_NORMAL
- en: After that, we will go deep into the **Model** class, studying the mass assignment
    as another way to store and update our data. Then, we will discuss **timestamps**
    and **soft deletes**, and find out how Laravel and Eloquent deal with dates. After
    that, you will learn about query scopes and how to use them to improve your development
    process.
  prefs: []
  type: TYPE_NORMAL
- en: 'Also, we will take a look at many cool methods to transform our data in order
    to be shown (or stored) correctly: attributes casting, mutators, date mutators,
    and accessors. If that isn''t enough, we will explore all the Model-related events
    that you can use to introduce new behaviors in your code without breaking it.
    Also, Model observers will be analyzed when an event isn''t enough.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In the last part of this chapter, we will explore some useful methods and features
    of the Model class, diving directly into the basic Model class code! Not bad,
    huh? Let''s start! Here are the topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Creating a Model
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Create, read, update, and delete operations basics
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Where, aggregates, and other utilities
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Mass assignment – for the masses
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Query scopes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Attributes casting, accessors, and mutators
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Model events and observers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Descending in the code
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a Model
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: First of all, let's see how you can create a Model and how its basic structure
    is made.
  prefs: []
  type: TYPE_NORMAL
- en: 'The fastest way to create a Model is to use the following command, with a parameter
    that you can use to specify the model name:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'So, let''s imagine that you want to create a `Book` model. The steps are as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'All you have to do is use the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Of course, you can also create it manually; usually, Laravel puts Models in
    the `app` folder.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Once you have done this, let's open the `Book.php` file under `app` to see what's
    inside.![Creating a Model](img/3634_03_01.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Wait. What? An empty class? Seriously?
  prefs: []
  type: TYPE_NORMAL
- en: Yes.
  prefs: []
  type: TYPE_NORMAL
- en: Laravel is designed to create a great web application in very little time. Eloquent
    (and its models) are no exceptions. The class you can see here is ready to be
    used in your application; using it, you will be able to do everything related
    to your books.
  prefs: []
  type: TYPE_NORMAL
- en: Talking about SQL databases, you can think of a connection between every model
    and table. If you respect a certain *convention*, Laravel automatically guesses
    the table name starting from the model name. So, if I have a model by the name
    of `Book`, Laravel will search for a `books` table on the database, without the
    need for specifying it explicitly.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you need to bind a certain model with another table, you can specify the
    name adding it as a `$table` property, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Alright, nothing more to say here. Now, let's play with our new model.
  prefs: []
  type: TYPE_NORMAL
- en: Create, read, update, and delete operations basics
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Every single article I read about Eloquent usually starts with some reading
    operations. I don't like it. I will teach you how to create and insert new records,
    then we will fetch them with some reading operations.
  prefs: []
  type: TYPE_NORMAL
- en: No boring test inserts with some external administration tool.
  prefs: []
  type: TYPE_NORMAL
- en: Creating operations
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s create our first book! As a reference for the record *structure*, we
    will use the `books` table that we created in the previous chapter. The table
    has a very simple structure: a title, page count (`pages_count`), price, and description.'
  prefs: []
  type: TYPE_NORMAL
- en: The procedure is as easy as creating an object.
  prefs: []
  type: TYPE_NORMAL
- en: 'Well, actually it is exactly the same. Create a new `GET` route in `routes.php`
    file under `app/Http/`, named `book_create` and type this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: If you think about it, there is something strange here! After checking the Model
    file, you can see that there are no `title` or `pages_count` properties declared.
    Among other things, Eloquent heavily uses magic methods. When the final query
    is built Laravel will use the names of the properties as the table columns to
    fill. Big deal!
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, if you run this code and then check your table, you will not find any
    record yet. You must add a single final instruction: the `save()` method call.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Execute it. Now, your book is saved on the database.
  prefs: []
  type: TYPE_NORMAL
- en: If you want, you can access a specific record field even after you've saved
    it. Let's make another example.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: There is another little thing about Eloquent conventions; that is, every single
    table has an ID, autoincrementing a primary key.
  prefs: []
  type: TYPE_NORMAL
- en: Reading operations
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now that we've created some example records, why don't we try to read them?
    An example is better than a thousand words.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'With a single instruction, here we are returning all the table records. The
    output is going to be very similar to this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If you feel strange about this, don't worry. If you return, in a route (or in
    a controller method) the results of an Eloquent model query, the results will
    be automatically transformed in JSON. It is a very useful shortcut if you are
    thinking about building a RESTful API.
  prefs: []
  type: TYPE_NORMAL
- en: Let's create another book, to give our tests more elements.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'After this, again execute your code in the `book_get_all` route. The result
    will be like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'However, we can do more. In fact, another great method is the `find()` method.
    You can use it like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: This method takes the primary ID as a parameter and returns the single record
    as an instance of the model.
  prefs: []
  type: TYPE_NORMAL
- en: 'Have a look at its output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Note that this time you don't have an array but a single object. These *static*
    methods, of course, aren't all Eloquent has to offer. The cool part starts here.
  prefs: []
  type: TYPE_NORMAL
- en: 'Take a look at this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: You can use the `where()` method to filter your results. Then, after specifying
    your criteria, the `get()` method retrieves the results from the database. For
    a better understanding, imagine that the `where()` method is building a query.
    The `get()` method executes it. This last one is a *trigger* method.
  prefs: []
  type: TYPE_NORMAL
- en: If you just want to retrieve the first result instead of all of them, you can
    use the `first()` method instead of `get()`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Before we go any further, here's a little reminder that can save you a lot of
    time. Actually, when you use *trigger* methods such as `get()` or `first()`, you
    can get two different kinds of results.
  prefs: []
  type: TYPE_NORMAL
- en: When you use `first()`, you are selecting a single instance. So, you will receive
    as a result (if present) a single instance of a certain model. Otherwise, if you
    are using `all()`, or `get()`, you will get a collection of instances.
  prefs: []
  type: TYPE_NORMAL
- en: Getting back to our `where()`, you can chain as many calls as you wish.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'You can iterate through results in a very simple way: simple for each is enough.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: The `$results` object is countable, so you can also check if you have results
    or not.
  prefs: []
  type: TYPE_NORMAL
- en: 'Have a look at this line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'You probably already noted that you can access a single record field in the
    same way as you did for setting them: magic methods.'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If you like it, you can access record fields like an array.
  prefs: []
  type: TYPE_NORMAL
- en: Try to switch `$book->title` to `$book['title']` and see what happens.
  prefs: []
  type: TYPE_NORMAL
- en: Updating operations
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Updating a record is as easy as creating it. To be honest, it is exactly the
    same thing with a single change in the first instruction.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Instead of creating it, we are retrieving from the database the instance of
    the Model we desired. After that, using magic methods, we modified and then saved
    it. As happened for the insert procedure, the change you make becomes persistent
    after the `save()` call.
  prefs: []
  type: TYPE_NORMAL
- en: Deleting operations
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Deleting a record is the simplest thing.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Time to die, `Book`!
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Here's a key concept. When you use the `update()` and `delete()` methods, you
    are working on a Model instance, just like you did before while creating it.
  prefs: []
  type: TYPE_NORMAL
- en: So, if you run a `\App\Book::find(1)` instruction, you will get a `Book` class
    instance as a result. For some, it will be obvious, but many newcomers often have
    problems with this.
  prefs: []
  type: TYPE_NORMAL
- en: where, aggregates, and other utilities
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: No doubt that the `where()` method will be one of your best friends while building
    queries and selecting records in your work with Eloquent. Don't you think it would
    be worth taking a look at it in detail?
  prefs: []
  type: TYPE_NORMAL
- en: Let's recap what we already know.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can use the `where()` method to filter results. The correct syntax you
    have to use is this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: So, for example, you can filter all the books with less than 100 pages with
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Also, you can chain more `where` methods, one after another, to build more complex
    queries. Let's select all those books that have less than 100 pages, with a title
    that starts with an *M*.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Two chained conditions are equivalent to `condition1 AND condition2`.
  prefs: []
  type: TYPE_NORMAL
- en: Great!
  prefs: []
  type: TYPE_NORMAL
- en: where and orWhere
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'However, you know that this is not enough. Usually, in a real-world application,
    you may have more complex conditions. First of all, you may need to get results
    that respect a condition OR another condition. The `AND` condition is not a standard;
    so, here''s the solution: `orWhere()`.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: In this code, we are telling Eloquent to take all the books that have the word
    *Second* in the title or all the books with more than 140 pages.
  prefs: []
  type: TYPE_NORMAL
- en: Yeah, this is a little better than before.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now let''s try to imagine another more complex condition: we want to find all
    the books that have more than 120 pages and the word *Book* in the title, or all
    the books that have less than 200 pages and an empty description.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Instead of specifying three parameters for `where()` and `orWhere()` methods,
    you can use a single closure parameter that takes a `$query` argument. Starting
    from that `$query` object, you will be able to do every selection and filtering
    in the way you prefer.
  prefs: []
  type: TYPE_NORMAL
- en: 'Of course, you can nest many of them:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Alright, stop. I think that the concept is quite clear now. Let's see some other
    forms of `where`.
  prefs: []
  type: TYPE_NORMAL
- en: First of all, here's `whereBetween` that you can use to filter some fields using
    a range, not only a single value.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: With that, we just got all the books that have a page count between 100 and
    200.
  prefs: []
  type: TYPE_NORMAL
- en: You can also use `whereIn` to check if a specific field is in an array of other
    values.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Finally, you can use `whereNull` if you want to get all the records with a certain
    column equal to null.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Magic wheres
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Another great and cool feature is the *magic* `where`. You know that everything
    in Laravel has a little bit of magic here and there. Obviously, Eloquent isn't
    an exception.
  prefs: []
  type: TYPE_NORMAL
- en: In fact, you can use an alternative syntax for your `where` clause, a magic
    syntax that lets you define the interested field as the method name.
  prefs: []
  type: TYPE_NORMAL
- en: 'You already know this syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, you can get the same result with this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: Obviously, the `wherePagesCount` method doesn't exist but Laravel automatically
    creates a quick `where` clause using PHP magic methods. As you can see from the
    example (and as the syntax suggests), you cannot use this technique every time
    as it works only with the equal sign.
  prefs: []
  type: TYPE_NORMAL
- en: However, it's good to know a similar shortcut, right?
  prefs: []
  type: TYPE_NORMAL
- en: Aggregates
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Sometimes, you will need to use the aggregates functions. No problem! Here is
    how you can do it with Eloquent.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'This is an example of its practical use:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: Exactly as you saw before for `get()` and `first()` methods, you can use aggregate
    methods with `where` methods. Here, we are counting the number of the books with
    more than 140 pages.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: Obviously, `count()` is not the only aggregate. Let's see them with some other
    `where()` examples to do more practice. This time, we are searching for the minimum
    number of pages (but the books with more than 120 pages, at least).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'You can also do the same thing with `max()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s find the average price for all the books that have the *Book* word
    in the name:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: Finally, let's get the sum of all the page counts for all the books with more
    than 100 pages.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: Utility methods
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As you probably imagined, Eloquent has a lot of utilities and methods that can
    improve your life as a developer. Trying to cover every single method would be
    hard but besides the most common methods, there are a few other methods that deserve
    to be here.
  prefs: []
  type: TYPE_NORMAL
- en: First of all, the `skip()` and `take()` methods that are used to implement some
    pagination in your queries.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: We are telling Eloquent to take 10 records and skip 10 from the start. So, if
    `skip(0)->take(10)` will take records from 1 to 10, `skip(10)->take(10)` will
    take from 11 to 20, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: 'Of course, you can''t also miss the `orderBy`, `groupBy`, and `having` methods.
    If you know a little about SQL databases (and if you are here, I think you do)
    you won''t have any problem understanding this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: Mass assignment... for the masses
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You got the basics. Cool!
  prefs: []
  type: TYPE_NORMAL
- en: Now, you have to know about another couple of ways to insert a record with Eloquent.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first is the Model constructor. You can pass an associative array as a
    parameter of the constructor call, something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: Another is the `create()` method that you can call *statically* from the model
    itself.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: Similar to the constructor, this `create()` method takes an associative array
    as a parameter and every key in this array corresponds to a column on the table
    (and a `magic` property on the model). The returned value (the one that is stored
    in `$book`) is an instance of the `Book` class.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is called **mass assignment** and, until this point, everything is fine
    except for a serious security issue. In fact, sometimes you could pass the entire
    request input array as a parameter. Trust me: sooner or later, you will do it.'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `$request` object you are going to see in the following example is a request
    instance that you can use to deal with the current request data. I will use it
    to retrieve some hypothetical `POST` data from a form (with the `all()` method)
    we will use to create a new book.
  prefs: []
  type: TYPE_NORMAL
- en: 'Something like this can be used:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: Technically, you don't know exactly what's in `$request->all()` so it is not
    the best practice, right? However, you can resolve this issue quite easily by
    adding a single property to your model—`fillable` or `guarded`.
  prefs: []
  type: TYPE_NORMAL
- en: Let's take an example for a better understanding of the concept. Imagine that
    for some reason you specify other fields in the form you already use for a new
    book insert, maybe the current user ID for logging purposes.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, you just want to insert four single fields: `title`, `pages_count`,
    `price`, and `description`. Nothing else!'
  prefs: []
  type: TYPE_NORMAL
- en: 'The key property is `fillable`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'You can execute the code like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: From the moment you execute the code, the model will search for `title`, `pages_count`,
    `price`, and `description` items. Nothing more! If you also have a `user_id` field
    in your request data array, it will be ignored by the model.
  prefs: []
  type: TYPE_NORMAL
- en: Of course, be careful and check twice what you put in the `$fillable` array
    of your models. Sometimes, developers easily forget the rights fields, and they
    pass hours and hours after an empty database record.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, if you actually get a problem with an empty database record, remember:
    check your `fillable`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `guarded` property has a similar behavior but does the opposite thing:
    if `fillable` is a whitelist, then `guarded` is a blacklist. A mechanism like
    a blacklist can be extremely useful if you store some important and sensible information
    that you don''t want to get updated by the user in any way.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Also, sometimes you will need to guard every single attribute of your model.
    No problem, use `guarded` like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If you put a field both in the `fillable` and `guarded` arrays, the model behavior
    will give the precedence to `fillable` and the field will be filled in.
  prefs: []
  type: TYPE_NORMAL
- en: Also, use `fillable` and `guarded` wisely. Remember also, that if you are using
    the `guarded` array and you are passing a classic full request data array to your
    model, you could update some unwanted fields and get some really unwanted errors.
  prefs: []
  type: TYPE_NORMAL
- en: Boring errors! Avoid them.
  prefs: []
  type: TYPE_NORMAL
- en: Timestamps and soft deletes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Time to cover two awesome features of the Model class: timestamps and soft
    deletes. How many times have you had to manually handle the creation date of a
    record and its last update time? Model timestamps are here to help.'
  prefs: []
  type: TYPE_NORMAL
- en: Also, how many times have you had to create a delete feature while maintaining
    some information about your data, if not at all? Yeah, the soft deleting feature
    is here to help too.
  prefs: []
  type: TYPE_NORMAL
- en: Timestamps
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Do you remember the last method we called in our `books` table migrations? No?
  prefs: []
  type: TYPE_NORMAL
- en: 'Don''t worry, here it is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'Exactly, it is the `timestamps()` method. This special Schema Builder method
    is used to create two separate fields: `created_at` and `updated_at`, both MySQL
    `DATETIME` or equivalent. Eloquent automatically handles these two fields when
    you create or update a record.'
  prefs: []
  type: TYPE_NORMAL
- en: 'It can be extremely useful: how many times did you have to deal with some *last
    edit* data on a specific table? Also, imagine how much easier it could be with
    these two fields to handle some scheduled article posting.'
  prefs: []
  type: TYPE_NORMAL
- en: 'However, sometimes they are not so useful: you can disable them just by setting
    the `timestamps` property model to false.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Obviously, if you plan to disable timestamps you can delete the corresponding
    `timestamps()` Schema Builder call in your migration. You are not going to need
    it anymore.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can eventually *specify the format of your timestamps*, if needed. Here''s
    an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: All you have to do is to implement the `getDateFormat` method in your model
    and let it return a string that describes the desired format.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In the returned string, you can insert anything that is a valid format for the
    `date()` PHP function (you can find a complete reference at [http://php.net/manual/en/function.date.php](http://php.net/manual/en/function.date.php)).
  prefs: []
  type: TYPE_NORMAL
- en: Soft deleting
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The soft deleting feature is a really interesting feature that can be useful
    on many occasions.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you decide to activate soft deleting, you will never really delete a record:
    instead, a `deleted_at` column will be updated with the date of the operation,
    but nothing more. Eloquent will work exactly like before but you will never lose
    anything.'
  prefs: []
  type: TYPE_NORMAL
- en: It could be a perfect fit for an e-commerce database that handles orders. The
    customer could decide to *clear* his order history. However, in order to keep
    accounts perfect, the shop owner would continuously need every single order detail.
  prefs: []
  type: TYPE_NORMAL
- en: As you can easily imagine, from the previous chapter, in order to activate the
    soft deleting feature, you will have to make a call to `softDeletes()` Schema
    Builder method.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: After this, you will have to include the `SoftDeletes` trait in the model.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: Nothing more!
  prefs: []
  type: TYPE_NORMAL
- en: Also, working with soft deleted data is really easy. Let's implement a simple
    example based on the situation we described before (the customer order's details
    and shop owner's need).
  prefs: []
  type: TYPE_NORMAL
- en: 'First of all, here''s an example model:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: In his/her order history, a customer should see only his/her *existent* orders
    and not *deleted* orders. I used quotation marks because we are talking about
    records that always exist.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: Nothing really special!
  prefs: []
  type: TYPE_NORMAL
- en: 'What about the shop owner? The magical word is `withTrashed`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: The `withTrashed` method automatically includes every result that is actually
    present in the table, regardless of the `deleted_at` field value.
  prefs: []
  type: TYPE_NORMAL
- en: Also, if you need to see only the soft deleted fields, change `withTrashed`
    to `onlyTrashed`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: Finally, you can restore a record that has been deleted with the `restore` method.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: If you prefer, you can execute the restore operation using a query as a `filter`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'Alright, I know what you are thinking: this feature is cool but what if I want
    to really delete a field?'
  prefs: []
  type: TYPE_NORMAL
- en: No problem; just use `forceDelete`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: Query scopes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Query scopes are very funny and also powerful. I really like them because,
    like many programmers out there, I am absolutely and overwhelmingly lazy. I also
    have a great justification for my laziness: the **Don''t Repeat Yourself** (**DRY**)
    principle.'
  prefs: []
  type: TYPE_NORMAL
- en: In a few words, they let you reuse some logic in your queries. It is useful
    if you have similar queries in your application and you don't want to write them
    again and again every single time.
  prefs: []
  type: TYPE_NORMAL
- en: Let's take an example.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: What happened? I declared a `scopeCheaperButBig` method. The `scope` prefix
    is used to specify that this is going to be used as a scope.
  prefs: []
  type: TYPE_NORMAL
- en: Now, how can I use a scope?
  prefs: []
  type: TYPE_NORMAL
- en: 'Here it is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'It is a cool feature. If you also think that you can split your logic in a
    more intelligent way, you can do it as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: Use it accordingly, reducing repeated code.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: If you need it, you can also define dynamic scopes in order to pass parameters
    to your scopes. If you like it, calling a scope inside another is not a problem.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: Attributes casting, accessors, and mutators
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Eloquent has many ways to transform the model data into something more readable
    or usable (and vice versa). In this chapter, we are going to analyze three of
    them: attributes casting, accessors, and mutators.'
  prefs: []
  type: TYPE_NORMAL
- en: Attributes casting
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The easier way to transform your model attributes while accessing them is the
    attributes casting. In a few words, it lets you define what attribute you want
    to cast and what is going to be the *destination* type.
  prefs: []
  type: TYPE_NORMAL
- en: 'Suppose that you have another integer field in your `books` table: `is_rare`.
    If the book is rare, this will be equal to `1`, `0` otherwise. However, when you
    work with it, the best thing would logically be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: 'It will not be something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: Right? Good.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, all you have to do to fix this problem is to specify, in your model, the
    `casts` array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: From this moment, every time you call the `is_rare` attribute, it will be automatically
    converted to the Boolean corresponding value and returned.
  prefs: []
  type: TYPE_NORMAL
- en: 'The supported types for casting are: integer, real, float, double, string,
    Boolean, object, and array.'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As also the documentation suggests, the *array* casting type is useful when
    you have a JSON array stored in a specific table column and you want to work with
    it quickly.
  prefs: []
  type: TYPE_NORMAL
- en: Accessors and mutators
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Attributes casting is very useful but has some limitations. Sometimes, starting
    from a simple value stored in the database, you need to do more complex work on
    it. Accessors and mutators are here to help.
  prefs: []
  type: TYPE_NORMAL
- en: 'To be more specific, an accessor is a method that is executed when the user
    reads a specific attribute. The accessor works on the attribute stored in the
    database and returns it. A mutator works in the opposite way: when you store a
    value, the mutator works, does its job and then saves it in the table. Let''s
    say they are sorts of getters and setters.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Defining an accessor (or a mutator) is not so difficult: all you have to do
    is to follow a naming convention.'
  prefs: []
  type: TYPE_NORMAL
- en: Let's start with something simple. Imagine that every time that you access the
    price of your book, you want to put the dollar symbol *$* at the beginning of
    the string.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: 'The naming convention for an accessor is simple as shown:'
  prefs: []
  type: TYPE_NORMAL
- en: The method name starts with `get`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The middle part of the name is the attribute name, which is camel cased
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The method name ends with `Attribute`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Nothing more.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, have a look at this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: Every time you have the preceding code, the mutator is very similar. This time,
    we want to store a lowercase version of the title.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: 'The convention isn''t changed so much: the only difference is that the method
    name now starts with `set` and not `get`. It''s all about getters and setters,
    my friend.'
  prefs: []
  type: TYPE_NORMAL
- en: Another real common use of mutators is when the application stores the user's
    password. A mutator can be used to hash the chosen password and the result is
    then stored.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: Descending in the code
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous text, we analyzed many aspects of the Eloquent model. If you
    think about your path, in a few pages you learned everything you needed to do
    many operations with your data. Also, you saw many interesting ways to add behaviors
    (from accessors and mutators to model observers) in order to improve your code
    usability, readability, and maintainability.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this section you are going to read, I will go through the Model class and
    analyze it a little deeper than the usual. Nothing so advanced, so don''t worry:
    I will just use the class code to show you what you can do with your models.'
  prefs: []
  type: TYPE_NORMAL
- en: Take it as a *list* of useful tips and tricks.
  prefs: []
  type: TYPE_NORMAL
- en: A big file
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'At the moment I am writing this chapter, the `Model` class under `Illuminate\Database\Eloquent`
    counts 3361 lines of code, which is a big class with many methods and features.
    However, this length is acceptable considering that we can do the same thing in
    many different ways (just think about the `save()` method, the `::create()` method,
    and the possibility to specify an associative array in the model constructor:
    three ways to insert a new record).'
  prefs: []
  type: TYPE_NORMAL
- en: In the first part of the class you can see all the properties we saw before,
    set to their default values.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: Yes, by default every attribute is guarded. A *total blacklist* for maximum
    security!
  prefs: []
  type: TYPE_NORMAL
- en: Quick conversion to array or JSON
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Do you remember at the beginning of this chapter what I told you about the
    automatic conversion to JSON of your model attributes? If you take a look at the
    code into the model you will see two methods: `toArray` and `toJson`. These two
    methods are the ones that make the magic happen.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You can also see that the second method uses the first. If you don't fear big
    files, I suggest you to take a deeper look at all the methods in this class. You
    will see some awesome examples of code reusing and function writing. In this chapter,
    we are just scratching the surface.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can convert both single models and model collections to arrays or JSON:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: Obviously, for security reasons, you can choose to mark some specific fields
    as `hidden`. They will not be shown when the record is converted to array or JSON.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: In this case, with `hidden`, we specified a blacklist. You can also define a
    whitelist with the `visible` property.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: Imaginary attributes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Using accessors and a specific property of the model, `appends`, you can create
    some attributes even if they don't exist as table columns.
  prefs: []
  type: TYPE_NORMAL
- en: For example purposes, let's assume that we want to create a `complete_name`
    attribute, made with the two attributes `first_name` and `last_name`.
  prefs: []
  type: TYPE_NORMAL
- en: 'First of all, let''s create the appropriate accessor in the model:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: Then as the last step, we can include it in the `appends` array property.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: Nothing else!
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we can use our attribute like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Every attribute that you create with the `appends` array respects the rules
    you specify eventually in the `visible` and `hidden` arrays.
  prefs: []
  type: TYPE_NORMAL
- en: Route model binding
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Another little cool shortcut is **model binding**. In a few words, it lets you
    link a certain route parameter to an instance of a defined model.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s test it: first of all, go to `RouteServiceProvider` in `app/Providers`
    folder. Now follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Add this line to the `boot` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then go to your routes file and create a new route that uses this parameter:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'So, calling the `books/1` URL will output something like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: What happened? Laravel resolved and automatically instantiated in the `$book`
    variable the desired object, using the given parameter (`1`) as the search term
    based on the primary ID. Then, the instance was used to output the title.
  prefs: []
  type: TYPE_NORMAL
- en: It's a little trick but sometimes it could be useful.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also customize the resolution logic: here''s another example using
    the e-mail address instead.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: If the record with the specified primary ID doesn't exist, the application will
    return a `404 not found` error. Obviously, you can change this behavior by specifying
    a third parameter for the `model()` binding.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: Records chunking for memory optimization
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Sometimes, you will need to process thousand and thousand of records. You know
    that those operations are very heavy for your RAM, but Eloquent has a useful method
    to chunk query results in *blocks* to optimize your load.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: The first parameter defines the size of the block you want to use. In this case,
    we will load 200 results, process them, unload them, and repeat the same thing
    with the next 200.
  prefs: []
  type: TYPE_NORMAL
- en: 'The second parameter is a closure that defines what to do with that chunk:
    the `books` closure parameter is the returned collection of records.'
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Hey, we made it again! This first overview of Eloquent is completed and now
    you are able to make your first experiments on your own! Well actually you are
    able to do many experiments, not just the basics. We learned all about the CRUD,
    mass assignment, and many other interesting things.
  prefs: []
  type: TYPE_NORMAL
- en: If you feel overwhelmed by all this information, don't worry. Take your time
    to do many tests and get familiarized with all the mechanisms, including the conventions
    you found on your road. We are only at the third chapter!
  prefs: []
  type: TYPE_NORMAL
- en: 'In the next chapter, we will go deeper in one of the most amazing aspects of
    Eloquent: relations. You will experience the power of Eloquent and how it handles
    every kind of relationship between models, from the one-to-one to many-to-many,
    in all its beauty.'
  prefs: []
  type: TYPE_NORMAL
- en: Go, go, go, hero!
  prefs: []
  type: TYPE_NORMAL
