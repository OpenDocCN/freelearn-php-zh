- en: Chapter 3. The Most Important Element – the Model!
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 3 章。最重要的元素——模型！
- en: 'Finally, I can say it: things are getting really, really serious from this
    moment. In the previous chapters, you studied everything you needed to make a
    start. Maybe it was a little annoying, but you knew that you would need it. Now,
    stop talking about the past; it''s over. In this chapter, many amazing things
    await.'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我可以说：从现在开始，事情变得真的、真的严肃了。在前面的章节中，你学习了开始所需的一切。也许有点烦人，但你都知道你需要它。现在，别再谈论过去；它已经过去了。在这一章中，许多令人惊奇的事情等着你。
- en: 'As you can imagine by the title, this part is going to be about the most important
    and atomic Eloquent element: **the model**. We will analyze the *M* in **MVC**.
    Considering that you are reading a book about creating a data-based application,
    exactly, really important! However, I don''t want to bore you anymore. Let''s
    talk about what we are going to see in the next sections.'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 如标题所示，这部分将关于最重要的、原子的 Eloquent 元素：**模型**。我们将分析**MVC**中的*M*。考虑到你正在阅读一本关于创建基于数据的应用程序的书，这非常重要！然而，我不想再让你感到无聊了。让我们谈谈下一节我们将看到的内容。
- en: Usually, there is a *standard* way to look at the Eloquent documentation. It's
    the same as you can see on the Laravel site. In my initial Laravel days, I used
    those pages but I felt a little *incomplete*. So, I changed things a little bit
    but in a more simplified way. If you have ever developed a web application in
    your life, I'm quite sure that you made a data-based application with tables and
    records. Right? Well...
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，查看 Eloquent 文档有一种*标准*的方式。它和你在 Laravel 网站上看到的是一样的。在我最初的 Laravel 日子里，我使用过那些页面，但我感觉有点*不完整*。所以，我稍微改变了一下，但以一种更简化的方式。如果你一生中曾经开发过网络应用程序，我相当确信你曾经制作过一个基于数据的带有表格和记录的应用程序。对吧？嗯...
- en: If you think about it, you can do four basic operations on them. Whenever you
    develop an application, there's a very high possibility that you are going to
    implement some *create*, *read*, *update*, and *delete* logic for your items.
    This is exactly what we are going to see in this chapter.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你这么想，你可以在它们上执行四个基本操作。无论你开发什么应用程序，你都有很高的可能性将实现一些*创建*、*读取*、*更新*和*删除*逻辑。这正是我们将在本章中看到的内容。
- en: First of all, we will introduce the simple, basic model. It will be a single
    line of code! Then, we will talk about CRUD (**create, read, update, and delete**)
    operations with Eloquent. After that point, you will have all the *basics* and
    an overview of the mechanism. We will also deal with the `where()` method and
    everything related, unscrambling everything about conditions and selections.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将介绍一个简单的、基本的模型。它将是一行代码！然后，我们将讨论使用 Eloquent 的 CRUD（**创建、读取、更新和删除**）操作。从那时起，你将拥有所有*基础*和机制的概述。我们还将处理`where()`方法和所有相关内容，解开有关条件和选择的一切。
- en: After that, we will go deep into the **Model** class, studying the mass assignment
    as another way to store and update our data. Then, we will discuss **timestamps**
    and **soft deletes**, and find out how Laravel and Eloquent deal with dates. After
    that, you will learn about query scopes and how to use them to improve your development
    process.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，我们将深入探讨**模型**类，研究批量赋值作为存储和更新我们数据的一种方式。然后，我们将讨论**时间戳**和**软删除**，了解 Laravel
    和 Eloquent 如何处理日期。之后，你将了解查询范围以及如何使用它们来提高你的开发过程。
- en: 'Also, we will take a look at many cool methods to transform our data in order
    to be shown (or stored) correctly: attributes casting, mutators, date mutators,
    and accessors. If that isn''t enough, we will explore all the Model-related events
    that you can use to introduce new behaviors in your code without breaking it.
    Also, Model observers will be analyzed when an event isn''t enough.'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们还将查看许多酷炫的方法来转换我们的数据，以便正确显示（或存储）：属性转换、修改器、日期修改器和访问器。如果还不够，我们将探索所有与模型相关的你可以用来在不破坏代码的情况下引入新行为的事件。当事件不够时，我们还将分析模型观察者。
- en: 'In the last part of this chapter, we will explore some useful methods and features
    of the Model class, diving directly into the basic Model class code! Not bad,
    huh? Let''s start! Here are the topics:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的最后部分，我们将探索一些有用的方法和模型类的功能，直接深入基本模型类的代码！不错吧？让我们开始！以下是主题：
- en: Creating a Model
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建模型
- en: Create, read, update, and delete operations basics
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建、读取、更新和删除操作基础
- en: Where, aggregates, and other utilities
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 哪里，聚合和其他实用工具
- en: Mass assignment – for the masses
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 批量赋值——面向大众
- en: Query scopes
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 查询范围
- en: Attributes casting, accessors, and mutators
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 属性转换、访问器和修改器
- en: Model events and observers
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模型事件和观察者
- en: Descending in the code
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 代码深入
- en: Creating a Model
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建模型
- en: First of all, let's see how you can create a Model and how its basic structure
    is made.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们看看如何创建一个模型以及其基本结构是如何构成的。
- en: 'The fastest way to create a Model is to use the following command, with a parameter
    that you can use to specify the model name:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 创建模型最快的方式是使用以下命令，你可以使用参数来指定模型名称：
- en: '[PRE0]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'So, let''s imagine that you want to create a `Book` model. The steps are as
    follows:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，让我们想象一下，你想要创建一个 `Book` 模型。步骤如下：
- en: 'All you have to do is use the following command:'
  id: totrans-22
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你需要做的只是使用以下命令：
- en: '[PRE1]'
  id: totrans-23
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Of course, you can also create it manually; usually, Laravel puts Models in
    the `app` folder.
  id: totrans-24
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 当然，你也可以手动创建它；通常，Laravel 将模型放在 `app` 文件夹中。
- en: Once you have done this, let's open the `Book.php` file under `app` to see what's
    inside.![Creating a Model](img/3634_03_01.jpg)
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦你完成了这些，让我们打开 `app` 目录下的 `Book.php` 文件，看看里面有什么。![创建模型](img/3634_03_01.jpg)
- en: Wait. What? An empty class? Seriously?
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 等等。什么？一个空类？真的吗？
- en: Yes.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 是的。
- en: Laravel is designed to create a great web application in very little time. Eloquent
    (and its models) are no exceptions. The class you can see here is ready to be
    used in your application; using it, you will be able to do everything related
    to your books.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: Laravel 设计得非常快速地创建一个优秀的网络应用程序。Eloquent（及其模型）也不例外。你在这里看到的类已经准备好在你的应用程序中使用；使用它，你将能够完成与你的书籍相关的所有操作。
- en: Talking about SQL databases, you can think of a connection between every model
    and table. If you respect a certain *convention*, Laravel automatically guesses
    the table name starting from the model name. So, if I have a model by the name
    of `Book`, Laravel will search for a `books` table on the database, without the
    need for specifying it explicitly.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 谈到 SQL 数据库，你可以想到每个模型和表之间的连接。如果你遵守某种*约定*，Laravel 会自动根据模型名称猜测表名。所以，如果我有一个名为 `Book`
    的模型，Laravel 将会在数据库中搜索一个名为 `books` 的表，无需明确指定。
- en: 'If you need to bind a certain model with another table, you can specify the
    name adding it as a `$table` property, like this:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你需要将某个模型与另一个表绑定，你可以指定名称，将其作为 `$table` 属性添加，如下所示：
- en: '[PRE2]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Alright, nothing more to say here. Now, let's play with our new model.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，这里没有更多要说的了。现在，让我们来玩我们的新模型。
- en: Create, read, update, and delete operations basics
  id: totrans-33
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建、读取、更新和删除操作的基本知识
- en: Every single article I read about Eloquent usually starts with some reading
    operations. I don't like it. I will teach you how to create and insert new records,
    then we will fetch them with some reading operations.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 我读过的每一篇关于 Eloquent 的文章通常都以一些读取操作开始。我不喜欢这样。我将教你如何创建和插入新记录，然后我们将使用一些读取操作来检索它们。
- en: No boring test inserts with some external administration tool.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 没有使用外部管理工具的枯燥测试插入。
- en: Creating operations
  id: totrans-36
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建操作
- en: 'Let''s create our first book! As a reference for the record *structure*, we
    will use the `books` table that we created in the previous chapter. The table
    has a very simple structure: a title, page count (`pages_count`), price, and description.'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建我们的第一本书！作为记录*结构*的参考，我们将使用我们在上一章中创建的 `books` 表。该表结构非常简单：标题、页数（`pages_count`）、价格和描述。
- en: The procedure is as easy as creating an object.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 这个过程就像创建一个对象一样简单。
- en: 'Well, actually it is exactly the same. Create a new `GET` route in `routes.php`
    file under `app/Http/`, named `book_create` and type this:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 嗯，实际上完全一样。在 `app/Http/` 目录下的 `routes.php` 文件中创建一个新的 `GET` 路由，命名为 `book_create`
    并输入以下内容：
- en: '[PRE3]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: If you think about it, there is something strange here! After checking the Model
    file, you can see that there are no `title` or `pages_count` properties declared.
    Among other things, Eloquent heavily uses magic methods. When the final query
    is built Laravel will use the names of the properties as the table columns to
    fill. Big deal!
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你仔细想想，这里有一些奇怪的地方！在检查模型文件后，你可以看到没有声明 `title` 或 `pages_count` 属性。在其他方面，Eloquent
    大量使用魔法方法。当最终查询构建时，Laravel 将使用属性名称作为表列来填充。这很重要！
- en: 'Now, if you run this code and then check your table, you will not find any
    record yet. You must add a single final instruction: the `save()` method call.'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果你运行这段代码然后检查你的表，你将找不到任何记录。你必须添加一个单一的最终指令：调用 `save()` 方法。
- en: '[PRE4]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Execute it. Now, your book is saved on the database.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 执行它。现在，你的书已经保存在数据库中了。
- en: If you want, you can access a specific record field even after you've saved
    it. Let's make another example.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你愿意，你甚至可以在保存后访问特定记录的字段。让我们再举一个例子。
- en: '[PRE5]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Note
  id: totrans-47
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: There is another little thing about Eloquent conventions; that is, every single
    table has an ID, autoincrementing a primary key.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 关于Eloquent约定还有另一件小事；那就是，每个表都有一个ID，自动递增为主键。
- en: Reading operations
  id: totrans-49
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 读取操作
- en: Now that we've created some example records, why don't we try to read them?
    An example is better than a thousand words.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经创建了一些示例记录，为什么不尝试读取它们呢？一个例子胜过千言万语。
- en: '[PRE6]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'With a single instruction, here we are returning all the table records. The
    output is going to be very similar to this:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们用一条指令返回所有表记录。输出将非常类似于以下内容：
- en: '[PRE7]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Note
  id: totrans-54
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: If you feel strange about this, don't worry. If you return, in a route (or in
    a controller method) the results of an Eloquent model query, the results will
    be automatically transformed in JSON. It is a very useful shortcut if you are
    thinking about building a RESTful API.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您对此感到奇怪，请不要担心。如果您在一个路由（或控制器方法）中返回Eloquent模型查询的结果，结果将自动转换为JSON。如果您正在考虑构建RESTful
    API，这是一个非常有用的快捷方式。
- en: Let's create another book, to give our tests more elements.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们再创建一本书，给我们的测试增加更多元素。
- en: '[PRE8]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'After this, again execute your code in the `book_get_all` route. The result
    will be like this:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，再次在`book_get_all`路由中执行您的代码。结果将如下所示：
- en: '[PRE9]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'However, we can do more. In fact, another great method is the `find()` method.
    You can use it like this:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，我们可以做得更多。实际上，另一个很好的方法是`find()`方法。您可以使用它这样：
- en: '[PRE10]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: This method takes the primary ID as a parameter and returns the single record
    as an instance of the model.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法以主ID作为参数，并返回单个记录作为模型的实例。
- en: 'Have a look at its output:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 看看它的输出：
- en: '[PRE11]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Note that this time you don't have an array but a single object. These *static*
    methods, of course, aren't all Eloquent has to offer. The cool part starts here.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，这次您有一个单个对象而不是数组。当然，这些*静态*方法并不是Eloquent所能提供的一切。有趣的部分从这里开始。
- en: 'Take a look at this:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 看看这个：
- en: '[PRE12]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: You can use the `where()` method to filter your results. Then, after specifying
    your criteria, the `get()` method retrieves the results from the database. For
    a better understanding, imagine that the `where()` method is building a query.
    The `get()` method executes it. This last one is a *trigger* method.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用`where()`方法来过滤您的结果。然后，在指定您的标准后，`get()`方法从数据库中检索结果。为了更好地理解，想象一下`where()`方法正在构建一个查询。`get()`方法执行它。最后一个方法是*触发*方法。
- en: If you just want to retrieve the first result instead of all of them, you can
    use the `first()` method instead of `get()`.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您只想检索第一个结果而不是所有结果，您可以使用`first()`方法而不是`get()`。
- en: '[PRE13]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Tip
  id: totrans-71
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: Before we go any further, here's a little reminder that can save you a lot of
    time. Actually, when you use *trigger* methods such as `get()` or `first()`, you
    can get two different kinds of results.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们继续之前，这里有一个可以节省您很多时间的提醒。实际上，当您使用*触发*方法，如`get()`或`first()`时，您可以得到两种不同类型的结果。
- en: When you use `first()`, you are selecting a single instance. So, you will receive
    as a result (if present) a single instance of a certain model. Otherwise, if you
    are using `all()`, or `get()`, you will get a collection of instances.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 当您使用`first()`时，您正在选择一个单一实例。因此，您将作为结果（如果存在）收到某个模型的单个实例。否则，如果您使用`all()`或`get()`，您将获得实例的集合。
- en: Getting back to our `where()`, you can chain as many calls as you wish.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 回到我们的`where()`，您可以按需链式调用多个调用。
- en: '[PRE14]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'You can iterate through results in a very simple way: simple for each is enough.'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过非常简单的方式遍历结果：简单的for each就足够了。
- en: '[PRE15]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The `$results` object is countable, so you can also check if you have results
    or not.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '`$results`对象是可计数的，因此您也可以检查是否有结果。'
- en: 'Have a look at this line:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 看看这一行：
- en: '[PRE16]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'You probably already noted that you can access a single record field in the
    same way as you did for setting them: magic methods.'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能已经注意到，您可以用与设置它们相同的方式访问单个记录字段：魔法方法。
- en: Note
  id: totrans-82
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: If you like it, you can access record fields like an array.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您喜欢，您可以通过数组的方式访问记录字段。
- en: Try to switch `$book->title` to `$book['title']` and see what happens.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试将`$book->title`切换到`$book['title']`并看看会发生什么。
- en: Updating operations
  id: totrans-85
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更新操作
- en: Updating a record is as easy as creating it. To be honest, it is exactly the
    same thing with a single change in the first instruction.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 更新记录与创建它一样简单。说实话，这完全一样，只是在第一条指令中有一个小小的变化。
- en: '[PRE17]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Instead of creating it, we are retrieving from the database the instance of
    the Model we desired. After that, using magic methods, we modified and then saved
    it. As happened for the insert procedure, the change you make becomes persistent
    after the `save()` call.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不是在创建它，而是在数据库中检索我们想要的模型实例。之后，使用魔法方法，我们修改并保存了它。就像插入过程一样，你做的更改在`save()`调用后变得持久。
- en: Deleting operations
  id: totrans-89
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 删除操作
- en: Deleting a record is the simplest thing.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 删除记录是最简单的事情。
- en: '[PRE18]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Time to die, `Book`!
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 是时候让`Book`消亡了！
- en: Note
  id: totrans-93
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Here's a key concept. When you use the `update()` and `delete()` methods, you
    are working on a Model instance, just like you did before while creating it.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个关键概念。当你使用`update()`和`delete()`方法时，你正在对一个模型实例进行操作，就像你之前在创建它时做的那样。
- en: So, if you run a `\App\Book::find(1)` instruction, you will get a `Book` class
    instance as a result. For some, it will be obvious, but many newcomers often have
    problems with this.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，如果你运行`\App\Book::find(1)`指令，你将得到一个`Book`类实例作为结果。对于一些人来说，这很明显，但许多新来者经常会遇到这个问题。
- en: where, aggregates, and other utilities
  id: totrans-96
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 聚合、where和其他实用工具
- en: No doubt that the `where()` method will be one of your best friends while building
    queries and selecting records in your work with Eloquent. Don't you think it would
    be worth taking a look at it in detail?
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 毫无疑问，`where()`方法将在你使用Eloquent构建查询和选择记录时成为你的最佳拍档。你不认为详细了解一下它很有价值吗？
- en: Let's recap what we already know.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回顾一下我们已经知道的内容。
- en: 'You can use the `where()` method to filter results. The correct syntax you
    have to use is this:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用`where()`方法来过滤结果。你必须使用的正确语法是：
- en: '[PRE19]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: So, for example, you can filter all the books with less than 100 pages with
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，你可以使用以下方式过滤所有页数少于100页的书籍：
- en: '[PRE20]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Also, you can chain more `where` methods, one after another, to build more complex
    queries. Let's select all those books that have less than 100 pages, with a title
    that starts with an *M*.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以链式调用更多的`where`方法，一个接一个，来构建更复杂的查询。让我们选择所有那些页数少于100页，标题以*M*开头的书籍。
- en: '[PRE21]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Note
  id: totrans-105
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Two chained conditions are equivalent to `condition1 AND condition2`.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 两个链式条件等同于`condition1 AND condition2`。
- en: Great!
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 太棒了！
- en: where and orWhere
  id: totrans-108
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: where和orWhere
- en: 'However, you know that this is not enough. Usually, in a real-world application,
    you may have more complex conditions. First of all, you may need to get results
    that respect a condition OR another condition. The `AND` condition is not a standard;
    so, here''s the solution: `orWhere()`.'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，你知道这还不够。通常，在现实世界的应用中，你可能需要更复杂的条件。首先，你可能需要得到满足一个条件或另一个条件的查询结果。`AND`条件不是标准的；所以，这里有一个解决方案：`orWhere()`。
- en: '[PRE22]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: In this code, we are telling Eloquent to take all the books that have the word
    *Second* in the title or all the books with more than 140 pages.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 在这段代码中，我们告诉Eloquent获取所有标题中包含单词*Second*的书籍或所有页数超过140页的书籍。
- en: Yeah, this is a little better than before.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 是的，这比之前好多了。
- en: 'Now let''s try to imagine another more complex condition: we want to find all
    the books that have more than 120 pages and the word *Book* in the title, or all
    the books that have less than 200 pages and an empty description.'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们尝试想象一个更复杂的条件：我们想要找到所有页数超过120页且标题中包含单词*Book*的书籍，或者所有页数少于200页且描述为空的书籍。
- en: '[PRE23]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Instead of specifying three parameters for `where()` and `orWhere()` methods,
    you can use a single closure parameter that takes a `$query` argument. Starting
    from that `$query` object, you will be able to do every selection and filtering
    in the way you prefer.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 你不需要为`where()`和`orWhere()`方法指定三个参数，你可以使用一个接受`$query`参数的单个闭包参数。从那个`$query`对象开始，你将能够以你喜欢的任何方式执行选择和过滤。
- en: 'Of course, you can nest many of them:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，你可以嵌套很多这样的工具：
- en: '[PRE24]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Alright, stop. I think that the concept is quite clear now. Let's see some other
    forms of `where`.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，停下来。我认为这个概念现在已经很清晰了。让我们看看`where`的其他形式。
- en: First of all, here's `whereBetween` that you can use to filter some fields using
    a range, not only a single value.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，这里有`whereBetween`，你可以用它来使用范围而不是单个值来过滤某些字段。
- en: '[PRE25]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: With that, we just got all the books that have a page count between 100 and
    200.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 就这样，我们得到了所有页数在100到200之间的书籍。
- en: You can also use `whereIn` to check if a specific field is in an array of other
    values.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以使用`whereIn`来检查一个特定字段是否在其它值的数组中。
- en: '[PRE26]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Finally, you can use `whereNull` if you want to get all the records with a certain
    column equal to null.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，如果你想获取所有某个列等于null的记录，可以使用`whereNull`。
- en: '[PRE27]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Magic wheres
  id: totrans-126
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 魔法where
- en: Another great and cool feature is the *magic* `where`. You know that everything
    in Laravel has a little bit of magic here and there. Obviously, Eloquent isn't
    an exception.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个很棒且酷炫的特性是 *魔法* `where`。你知道 Laravel 中到处都有一些魔法。显然，Eloquent 也不例外。
- en: In fact, you can use an alternative syntax for your `where` clause, a magic
    syntax that lets you define the interested field as the method name.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，你可以为你的 `where` 子句使用一种替代语法，这是一种魔法语法，允许你将感兴趣的字段定义为方法名。
- en: 'You already know this syntax:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经知道了这种语法：
- en: '[PRE28]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Now, you can get the same result with this code:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你可以用这段代码得到相同的结果：
- en: '[PRE29]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Obviously, the `wherePagesCount` method doesn't exist but Laravel automatically
    creates a quick `where` clause using PHP magic methods. As you can see from the
    example (and as the syntax suggests), you cannot use this technique every time
    as it works only with the equal sign.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，`wherePagesCount` 方法不存在，但 Laravel 会自动使用 PHP 魔术方法创建一个快速的 `where` 子句。正如你从示例中看到的那样（以及语法所暗示的），你并不能每次都使用这种技术，因为它只适用于等号。
- en: However, it's good to know a similar shortcut, right?
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，了解一个类似的快捷方式是很好的，对吧？
- en: Aggregates
  id: totrans-135
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 聚合
- en: Sometimes, you will need to use the aggregates functions. No problem! Here is
    how you can do it with Eloquent.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候，你需要使用聚合函数。没问题！这是你如何使用 Eloquent 来做到这一点的示例。
- en: '[PRE30]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'This is an example of its practical use:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个其实际应用的例子：
- en: '[PRE31]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Exactly as you saw before for `get()` and `first()` methods, you can use aggregate
    methods with `where` methods. Here, we are counting the number of the books with
    more than 140 pages.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你之前在 `get()` 和 `first()` 方法中看到的，你可以使用聚合方法与 `where` 方法一起使用。在这里，我们正在计算页数超过140页的书籍数量。
- en: '[PRE32]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Obviously, `count()` is not the only aggregate. Let's see them with some other
    `where()` examples to do more practice. This time, we are searching for the minimum
    number of pages (but the books with more than 120 pages, at least).
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，`count()` 不是唯一的聚合。让我们通过一些其他的 `where()` 示例来看看它们，以便进行更多的练习。这次，我们正在寻找页数最少的书籍（但至少是超过120页的）。
- en: '[PRE33]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'You can also do the same thing with `max()`:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以用 `max()` 做同样的事情：
- en: '[PRE34]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Now, let''s find the average price for all the books that have the *Book* word
    in the name:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们找到所有书名中包含 *Book* 单词的书籍的平均价格：
- en: '[PRE35]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Finally, let's get the sum of all the page counts for all the books with more
    than 100 pages.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，让我们得到所有页数超过100页的书籍的总页数。
- en: '[PRE36]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Utility methods
  id: totrans-150
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实用方法
- en: As you probably imagined, Eloquent has a lot of utilities and methods that can
    improve your life as a developer. Trying to cover every single method would be
    hard but besides the most common methods, there are a few other methods that deserve
    to be here.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所想象的那样，Eloquent 有很多实用工具和方法可以提升你的开发者生活。试图涵盖每一个单独的方法可能会很困难，但除了最常见的方法之外，还有一些其他的方法值得在这里提及。
- en: First of all, the `skip()` and `take()` methods that are used to implement some
    pagination in your queries.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 首先是 `skip()` 和 `take()` 方法，这些方法用于在你的查询中实现分页。
- en: '[PRE37]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: We are telling Eloquent to take 10 records and skip 10 from the start. So, if
    `skip(0)->take(10)` will take records from 1 to 10, `skip(10)->take(10)` will
    take from 11 to 20, and so on.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 我们正在告诉 Eloquent 取前10条记录并跳过前10条。所以，如果 `skip(0)->take(10)` 会取第1到第10条记录，`skip(10)->take(10)`
    会取第11到第20条，以此类推。
- en: 'Of course, you can''t also miss the `orderBy`, `groupBy`, and `having` methods.
    If you know a little about SQL databases (and if you are here, I think you do)
    you won''t have any problem understanding this code:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，你也不能错过 `orderBy`、`groupBy` 和 `having` 方法。如果你对 SQL 数据库有些了解（而且如果你在这里，我想你确实了解），你不会对理解这段代码有任何问题：
- en: '[PRE38]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Mass assignment... for the masses
  id: totrans-157
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 大量赋值...针对大众
- en: You got the basics. Cool!
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经掌握了基础。太棒了！
- en: Now, you have to know about another couple of ways to insert a record with Eloquent.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你必须了解另一种将记录插入 Eloquent 的方法。
- en: 'The first is the Model constructor. You can pass an associative array as a
    parameter of the constructor call, something like this:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个就是模型构造函数。你可以将关联数组作为构造函数调用的参数传递，就像这样：
- en: '[PRE39]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Another is the `create()` method that you can call *statically* from the model
    itself.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个是 `create()` 方法，你可以从模型本身静态地调用它。
- en: '[PRE40]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Similar to the constructor, this `create()` method takes an associative array
    as a parameter and every key in this array corresponds to a column on the table
    (and a `magic` property on the model). The returned value (the one that is stored
    in `$book`) is an instance of the `Book` class.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 与构造函数类似，这个 `create()` 方法也接受一个关联数组作为参数，这个数组中的每个键都对应于表中的一个列（以及模型上的一个 `magic` 属性）。返回的值（存储在
    `$book` 中的那个）是 `Book` 类的一个实例。
- en: 'This is called **mass assignment** and, until this point, everything is fine
    except for a serious security issue. In fact, sometimes you could pass the entire
    request input array as a parameter. Trust me: sooner or later, you will do it.'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 这被称为**批量赋值**，直到目前为止，一切都很正常，除了一个严重的安全问题。事实上，有时你可以将整个请求输入数组作为参数传递。相信我：迟早你会这么做。
- en: Note
  id: totrans-166
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The `$request` object you are going to see in the following example is a request
    instance that you can use to deal with the current request data. I will use it
    to retrieve some hypothetical `POST` data from a form (with the `all()` method)
    we will use to create a new book.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下示例中，你将要看到的`$request`对象是一个请求实例，你可以用它来处理当前请求的数据。我将使用它从表单（使用`all()`方法）中检索一些假设的`POST`数据，我们将使用这些数据创建一本新书。
- en: 'Something like this can be used:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 类似这样的内容可以被使用：
- en: '[PRE41]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Technically, you don't know exactly what's in `$request->all()` so it is not
    the best practice, right? However, you can resolve this issue quite easily by
    adding a single property to your model—`fillable` or `guarded`.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 技术上，你不知道`$request->all()`中确切是什么，所以这不是最佳实践，对吧？然而，你可以通过向模型添加一个单一属性——`fillable`或`guarded`——来轻松解决这个问题。
- en: Let's take an example for a better understanding of the concept. Imagine that
    for some reason you specify other fields in the form you already use for a new
    book insert, maybe the current user ID for logging purposes.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们用一个例子来更好地理解这个概念。想象一下，由于某种原因，你在用于新书插入的表单中指定了其他字段，比如当前用户ID用于登录目的。
- en: 'However, you just want to insert four single fields: `title`, `pages_count`,
    `price`, and `description`. Nothing else!'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，你只需要插入四个单字段：`title`、`pages_count`、`price`和`description`。其他什么也不要！
- en: 'The key property is `fillable`:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 关键属性是`fillable`：
- en: '[PRE42]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'You can execute the code like this:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以像这样执行代码：
- en: '[PRE43]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: From the moment you execute the code, the model will search for `title`, `pages_count`,
    `price`, and `description` items. Nothing more! If you also have a `user_id` field
    in your request data array, it will be ignored by the model.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 从你执行代码的那一刻起，模型将搜索`title`、`pages_count`、`price`和`description`项。没有更多！如果你在请求数据数组中也有`user_id`字段，它将被模型忽略。
- en: Of course, be careful and check twice what you put in the `$fillable` array
    of your models. Sometimes, developers easily forget the rights fields, and they
    pass hours and hours after an empty database record.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，要小心，并仔细检查你放入模型`$fillable`数组中的内容。有时，开发者很容易忘记正确的字段，并在空数据库记录上花费数小时。
- en: 'So, if you actually get a problem with an empty database record, remember:
    check your `fillable`.'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，如果你实际上遇到了空数据库记录的问题，请记住：检查你的`fillable`。
- en: 'The `guarded` property has a similar behavior but does the opposite thing:
    if `fillable` is a whitelist, then `guarded` is a blacklist. A mechanism like
    a blacklist can be extremely useful if you store some important and sensible information
    that you don''t want to get updated by the user in any way.'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: '`guarded`属性有类似的行为，但做的是相反的事情：如果`fillable`是白名单，那么`guarded`就是黑名单。如果存储了一些重要且敏感的信息，你不想以任何方式让用户更新，那么黑名单机制可以非常有用。'
- en: 'Also, sometimes you will need to guard every single attribute of your model.
    No problem, use `guarded` like this:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，有时你需要保护模型中的每一个属性。没问题，使用`guarded`如下所示：
- en: '[PRE44]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Note
  id: totrans-183
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: If you put a field both in the `fillable` and `guarded` arrays, the model behavior
    will give the precedence to `fillable` and the field will be filled in.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你将一个字段同时放入`fillable`和`guarded`数组中，模型的行为将优先考虑`fillable`，该字段将被填充。
- en: Also, use `fillable` and `guarded` wisely. Remember also, that if you are using
    the `guarded` array and you are passing a classic full request data array to your
    model, you could update some unwanted fields and get some really unwanted errors.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，明智地使用`fillable`和`guarded`。记住，如果你正在使用`guarded`数组，并且将经典的全请求数据数组传递给模型，你可能会更新一些不希望更新的字段，并得到一些非常不希望出现的错误。
- en: Boring errors! Avoid them.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 无聊的错误！避免它们。
- en: Timestamps and soft deletes
  id: totrans-187
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 时间戳和软删除
- en: 'Time to cover two awesome features of the Model class: timestamps and soft
    deletes. How many times have you had to manually handle the creation date of a
    record and its last update time? Model timestamps are here to help.'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 现在来介绍模型类的两个酷炫特性：时间戳和软删除。你有多少次不得不手动处理记录的创建日期和最后更新时间？模型时间戳就是为了帮助解决这个问题。
- en: Also, how many times have you had to create a delete feature while maintaining
    some information about your data, if not at all? Yeah, the soft deleting feature
    is here to help too.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，你有多少次在维护数据的一些信息的同时创建删除功能，如果不是全部的话？是的，软删除功能也是为了帮助解决这个问题。
- en: Timestamps
  id: totrans-190
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 时间戳
- en: Do you remember the last method we called in our `books` table migrations? No?
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 你还记得我们在 `books` 表迁移中调用的最后一个方法吗？不记得了吗？
- en: 'Don''t worry, here it is:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 别担心，下面就是：
- en: '[PRE45]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Exactly, it is the `timestamps()` method. This special Schema Builder method
    is used to create two separate fields: `created_at` and `updated_at`, both MySQL
    `DATETIME` or equivalent. Eloquent automatically handles these two fields when
    you create or update a record.'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 正确，它是 `timestamps()` 方法。这个特殊的 Schema Builder 方法用于创建两个独立的字段：`created_at` 和 `updated_at`，两者都是
    MySQL 的 `DATETIME` 或等效类型。Eloquent 在你创建或更新记录时会自动处理这两个字段。
- en: 'It can be extremely useful: how many times did you have to deal with some *last
    edit* data on a specific table? Also, imagine how much easier it could be with
    these two fields to handle some scheduled article posting.'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 它可以非常实用：你有多少次不得不处理特定表上的某些*最后编辑*数据？想象一下，有了这两个字段处理一些计划发布的文章会容易多少。
- en: 'However, sometimes they are not so useful: you can disable them just by setting
    the `timestamps` property model to false.'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，有时它们并不那么有用：你只需将模型中的 `timestamps` 属性设置为 `false` 就可以禁用它们。
- en: '[PRE46]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: Note
  id: totrans-198
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Obviously, if you plan to disable timestamps you can delete the corresponding
    `timestamps()` Schema Builder call in your migration. You are not going to need
    it anymore.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，如果你打算禁用时间戳，你可以在迁移中删除相应的 `timestamps()` Schema Builder 调用。你将不再需要它。
- en: 'You can eventually *specify the format of your timestamps*, if needed. Here''s
    an example:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 如果需要，你可以最终*指定时间戳的格式*。这里有一个例子：
- en: '[PRE47]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: All you have to do is to implement the `getDateFormat` method in your model
    and let it return a string that describes the desired format.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 你所需要做的就是实现模型中的 `getDateFormat` 方法，并让它返回一个描述所需格式的字符串。
- en: Note
  id: totrans-203
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: In the returned string, you can insert anything that is a valid format for the
    `date()` PHP function (you can find a complete reference at [http://php.net/manual/en/function.date.php](http://php.net/manual/en/function.date.php)).
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 在返回的字符串中，你可以插入任何 `date()` PHP 函数的有效格式（你可以在 [http://php.net/manual/en/function.date.php](http://php.net/manual/en/function.date.php)
    找到完整的参考）。
- en: Soft deleting
  id: totrans-205
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 软删除
- en: The soft deleting feature is a really interesting feature that can be useful
    on many occasions.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 软删除功能是一个非常有趣的功能，在许多场合都可能很有用。
- en: 'If you decide to activate soft deleting, you will never really delete a record:
    instead, a `deleted_at` column will be updated with the date of the operation,
    but nothing more. Eloquent will work exactly like before but you will never lose
    anything.'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你决定激活软删除，你实际上永远不会删除一条记录：相反，`deleted_at` 列将被更新为操作日期，但仅此而已。Eloquent 将像以前一样工作，但你永远不会丢失任何东西。
- en: It could be a perfect fit for an e-commerce database that handles orders. The
    customer could decide to *clear* his order history. However, in order to keep
    accounts perfect, the shop owner would continuously need every single order detail.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 它非常适合处理订单的电子商务数据库。客户可以决定*清除*他的订单历史。然而，为了保持账户完美，店主会持续需要每个订单的详细信息。
- en: As you can easily imagine, from the previous chapter, in order to activate the
    soft deleting feature, you will have to make a call to `softDeletes()` Schema
    Builder method.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 如你很容易想象的，从上一章中，为了激活软删除功能，你必须调用 `softDeletes()` Schema Builder 方法。
- en: '[PRE48]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: After this, you will have to include the `SoftDeletes` trait in the model.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 在此之后，你必须将 `SoftDeletes` 特性包含在模型中。
- en: '[PRE49]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: Nothing more!
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 没有更多了！
- en: Also, working with soft deleted data is really easy. Let's implement a simple
    example based on the situation we described before (the customer order's details
    and shop owner's need).
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，处理软删除数据真的非常简单。让我们基于之前描述的情况（客户订单的详情和店主的需求）来实现一个简单的例子。
- en: 'First of all, here''s an example model:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，这里有一个示例模型：
- en: '[PRE50]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: In his/her order history, a customer should see only his/her *existent* orders
    and not *deleted* orders. I used quotation marks because we are talking about
    records that always exist.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 在他的/她的订单历史中，客户应该只能看到他/她的*存在*订单，而不是*已删除*订单。我之所以使用引号，是因为我们谈论的是始终存在的记录。
- en: '[PRE51]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: Nothing really special!
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 没有什么特别之处！
- en: 'What about the shop owner? The magical word is `withTrashed`:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 那店主怎么办呢？神奇的字眼是 `withTrashed`：
- en: '[PRE52]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: The `withTrashed` method automatically includes every result that is actually
    present in the table, regardless of the `deleted_at` field value.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: '`withTrashed` 方法自动包含表中实际存在的每个结果，无论 `deleted_at` 字段值如何。'
- en: Also, if you need to see only the soft deleted fields, change `withTrashed`
    to `onlyTrashed`.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，如果你只想看到软删除的字段，将 `withTrashed` 改为 `onlyTrashed`。
- en: '[PRE53]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: Finally, you can restore a record that has been deleted with the `restore` method.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，你可以使用`restore`方法恢复已被删除的记录。
- en: '[PRE54]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: If you prefer, you can execute the restore operation using a query as a `filter`.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你愿意，你可以使用查询作为`filter`来执行恢复操作。
- en: '[PRE55]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'Alright, I know what you are thinking: this feature is cool but what if I want
    to really delete a field?'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，我知道你在想什么：这个功能很酷，但如果我想真正删除一个字段怎么办？
- en: No problem; just use `forceDelete`.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 没问题；只需使用`forceDelete`。
- en: '[PRE56]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: Query scopes
  id: totrans-232
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 查询范围
- en: 'Query scopes are very funny and also powerful. I really like them because,
    like many programmers out there, I am absolutely and overwhelmingly lazy. I also
    have a great justification for my laziness: the **Don''t Repeat Yourself** (**DRY**)
    principle.'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 查询范围非常有趣且强大。我真的很喜欢它们，因为像许多程序员一样，我绝对且非常懒惰。我也有一个很好的理由来证明我的懒惰：**不要重复自己**（**DRY**）原则。
- en: In a few words, they let you reuse some logic in your queries. It is useful
    if you have similar queries in your application and you don't want to write them
    again and again every single time.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，它们允许你在查询中重用一些逻辑。如果你在应用程序中有类似的查询并且不想每次都重复编写它们，这很有用。
- en: Let's take an example.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们举一个例子。
- en: '[PRE57]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: What happened? I declared a `scopeCheaperButBig` method. The `scope` prefix
    is used to specify that this is going to be used as a scope.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 发生了什么？我声明了一个`scopeCheaperButBig`方法。`scope`前缀用于指定这将用作范围。
- en: Now, how can I use a scope?
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，我该如何使用范围？
- en: 'Here it is:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是示例：
- en: '[PRE58]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'It is a cool feature. If you also think that you can split your logic in a
    more intelligent way, you can do it as follows:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个很酷的功能。如果你也认为你可以以更智能的方式拆分你的逻辑，你可以这样做：
- en: '[PRE59]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: Use it accordingly, reducing repeated code.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 根据需要使用，减少重复代码。
- en: '[PRE60]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: If you need it, you can also define dynamic scopes in order to pass parameters
    to your scopes. If you like it, calling a scope inside another is not a problem.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 如果需要，你还可以定义动态范围，以便向范围传递参数。如果你喜欢，在另一个范围内调用范围不是问题。
- en: '[PRE61]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: Attributes casting, accessors, and mutators
  id: totrans-247
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 属性转换、访问器和修改器
- en: 'Eloquent has many ways to transform the model data into something more readable
    or usable (and vice versa). In this chapter, we are going to analyze three of
    them: attributes casting, accessors, and mutators.'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: Eloquent有多种方法将模型数据转换为更易读或易用的形式（反之亦然）。在本章中，我们将分析其中的三种：属性转换、访问器和修改器。
- en: Attributes casting
  id: totrans-249
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 属性转换
- en: The easier way to transform your model attributes while accessing them is the
    attributes casting. In a few words, it lets you define what attribute you want
    to cast and what is going to be the *destination* type.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 在访问模型属性的同时转换它们的最简单方法是属性转换。简而言之，它允许你定义你想要转换的属性以及它将变成的*目标*类型。
- en: 'Suppose that you have another integer field in your `books` table: `is_rare`.
    If the book is rare, this will be equal to `1`, `0` otherwise. However, when you
    work with it, the best thing would logically be as follows:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你在`books`表中还有一个整数字段：`is_rare`。如果这本书是罕见的，这将等于`1`，否则为`0`。然而，当你处理它时，从逻辑上讲最好的做法是如下所示：
- en: '[PRE62]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'It will not be something like this:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 它不会是这样的：
- en: '[PRE63]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: Right? Good.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 对吗？很好。
- en: 'So, all you have to do to fix this problem is to specify, in your model, the
    `casts` array:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，要解决这个问题，你只需在模型中指定`casts`数组：
- en: '[PRE64]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: From this moment, every time you call the `is_rare` attribute, it will be automatically
    converted to the Boolean corresponding value and returned.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 从此刻起，每次你调用`is_rare`属性时，它将自动转换为相应的布尔值并返回。
- en: 'The supported types for casting are: integer, real, float, double, string,
    Boolean, object, and array.'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 支持的转换类型有：整数、实数、浮点数、双精度浮点数、字符串、布尔值、对象和数组。
- en: Note
  id: totrans-260
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: As also the documentation suggests, the *array* casting type is useful when
    you have a JSON array stored in a specific table column and you want to work with
    it quickly.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 正如文档所述，当你在特定表列中存储了JSON数组并且想要快速处理它时，*数组*类型转换非常有用。
- en: Accessors and mutators
  id: totrans-262
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 访问器和修改器
- en: Attributes casting is very useful but has some limitations. Sometimes, starting
    from a simple value stored in the database, you need to do more complex work on
    it. Accessors and mutators are here to help.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 属性转换非常有用，但有一些限制。有时，从数据库中存储的简单值开始，你可能需要对它进行更复杂的工作。访问器和修改器就在这里帮助你。
- en: 'To be more specific, an accessor is a method that is executed when the user
    reads a specific attribute. The accessor works on the attribute stored in the
    database and returns it. A mutator works in the opposite way: when you store a
    value, the mutator works, does its job and then saves it in the table. Let''s
    say they are sorts of getters and setters.'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 更具体地说，访问器是一种在用户读取特定属性时执行的方法。访问器作用于存储在数据库中的属性，并返回它。相反，修改器以相反的方式工作：当你存储一个值时，修改器工作，完成其任务，然后将它保存在表中。让我们说它们是获取器和设置器的一种。
- en: 'Defining an accessor (or a mutator) is not so difficult: all you have to do
    is to follow a naming convention.'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 定义一个访问器（或修改器）并不难：你所要做的就是遵循一个命名规范。
- en: Let's start with something simple. Imagine that every time that you access the
    price of your book, you want to put the dollar symbol *$* at the beginning of
    the string.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从简单的东西开始。想象一下，每次你访问你书的定价时，你都想在字符串的开头加上美元符号*$*。
- en: '[PRE65]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'The naming convention for an accessor is simple as shown:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 访问器的命名规范很简单，如下所示：
- en: The method name starts with `get`
  id: totrans-269
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 方法名称以`get`开头
- en: The middle part of the name is the attribute name, which is camel cased
  id: totrans-270
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 名称的中间部分是属性名称，它是驼峰式命名的
- en: The method name ends with `Attribute`
  id: totrans-271
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 方法名称以`Attribute`结尾
- en: Nothing more.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 没有更多。
- en: 'Now, have a look at this:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，看看这个：
- en: '[PRE66]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: Every time you have the preceding code, the mutator is very similar. This time,
    we want to store a lowercase version of the title.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 每次你有前面的代码，修改器都非常相似。这次，我们想要存储标题的小写版本。
- en: '[PRE67]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'The convention isn''t changed so much: the only difference is that the method
    name now starts with `set` and not `get`. It''s all about getters and setters,
    my friend.'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 习惯用法并没有改变太多：唯一的区别是，现在方法名称以`set`开头，而不是`get`。这完全是关于获取器和设置器，我的朋友。
- en: Another real common use of mutators is when the application stores the user's
    password. A mutator can be used to hash the chosen password and the result is
    then stored.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 修改器的一个实际常见用途是在应用程序存储用户的密码时。可以使用修改器来散列选定的密码，然后将结果存储起来。
- en: '[PRE68]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: Descending in the code
  id: totrans-280
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在代码中向下深入
- en: In the previous text, we analyzed many aspects of the Eloquent model. If you
    think about your path, in a few pages you learned everything you needed to do
    many operations with your data. Also, you saw many interesting ways to add behaviors
    (from accessors and mutators to model observers) in order to improve your code
    usability, readability, and maintainability.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的文本中，我们分析了Eloquent模型许多方面。如果你想想你的路径，在几页之内，你学到了你需要做许多数据操作的所有东西。此外，你还看到了许多添加行为（从访问器和修改器到模型观察器）的有趣方式，以提高你的代码的可用性、可读性和可维护性。
- en: 'In this section you are going to read, I will go through the Model class and
    analyze it a little deeper than the usual. Nothing so advanced, so don''t worry:
    I will just use the class code to show you what you can do with your models.'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我将深入分析模型类，比通常更深入一些。没有什么太高级的，所以不用担心：我将只使用类代码来展示你可以用你的模型做什么。
- en: Take it as a *list* of useful tips and tricks.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 把它当作一个*有用的提示和技巧列表*。
- en: A big file
  id: totrans-284
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 一个大文件
- en: 'At the moment I am writing this chapter, the `Model` class under `Illuminate\Database\Eloquent`
    counts 3361 lines of code, which is a big class with many methods and features.
    However, this length is acceptable considering that we can do the same thing in
    many different ways (just think about the `save()` method, the `::create()` method,
    and the possibility to specify an associative array in the model constructor:
    three ways to insert a new record).'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 当我写这一章的时候，`Illuminate\Database\Eloquent`下的`Model`类有3361行代码，这是一个具有许多方法和功能的大家伙。然而，考虑到我们可以以许多不同的方式做同样的事情（想想`save()`方法，`::create()`方法，以及在模型构造函数中指定关联数组的可能性：三种插入新记录的方式），这个长度是可以接受的。
- en: In the first part of the class you can see all the properties we saw before,
    set to their default values.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 在类的第一部分，你可以看到我们之前看到的所有属性，都设置为它们的默认值。
- en: '[PRE69]'
  id: totrans-287
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: Yes, by default every attribute is guarded. A *total blacklist* for maximum
    security!
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 是的，默认情况下，每个属性都是受保护的。这是一个*完全黑名单*，以实现最大安全性！
- en: Quick conversion to array or JSON
  id: totrans-289
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 快速转换为数组或JSON
- en: 'Do you remember at the beginning of this chapter what I told you about the
    automatic conversion to JSON of your model attributes? If you take a look at the
    code into the model you will see two methods: `toArray` and `toJson`. These two
    methods are the ones that make the magic happen.'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 你还记得这一章开头我告诉你的关于模型属性自动转换为JSON的事情吗？如果你查看模型中的代码，你会看到两个方法：`toArray`和`toJson`。这两个方法就是让魔法发生的地方。
- en: '[PRE70]'
  id: totrans-291
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: Note
  id: totrans-292
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: You can also see that the second method uses the first. If you don't fear big
    files, I suggest you to take a deeper look at all the methods in this class. You
    will see some awesome examples of code reusing and function writing. In this chapter,
    we are just scratching the surface.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以看到第二个方法使用了第一个。如果你不怕大文件，我建议你深入了解一下这个类中的所有方法。你将看到一些代码重用和函数编写的精彩示例。在本章中，我们只是触及了表面。
- en: 'You can convert both single models and model collections to arrays or JSON:'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以将单个模型和模型集合都转换为数组或 JSON：
- en: '[PRE71]'
  id: totrans-295
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: Obviously, for security reasons, you can choose to mark some specific fields
    as `hidden`. They will not be shown when the record is converted to array or JSON.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，出于安全原因，你可以选择将一些特定字段标记为 `hidden`。当记录转换为数组或 JSON 时，它们将不会显示。
- en: '[PRE72]'
  id: totrans-297
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: In this case, with `hidden`, we specified a blacklist. You can also define a
    whitelist with the `visible` property.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们通过 `hidden` 指定了一个黑名单。你还可以使用 `visible` 属性定义一个白名单。
- en: '[PRE73]'
  id: totrans-299
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: Imaginary attributes
  id: totrans-300
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 虚拟属性
- en: Using accessors and a specific property of the model, `appends`, you can create
    some attributes even if they don't exist as table columns.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 使用访问器和模型的特定属性 `appends`，即使这些属性不是作为表列存在，你也能创建一些属性。
- en: For example purposes, let's assume that we want to create a `complete_name`
    attribute, made with the two attributes `first_name` and `last_name`.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 为了举例说明，让我们假设我们想要创建一个 `complete_name` 属性，由 `first_name` 和 `last_name` 这两个属性组成。
- en: 'First of all, let''s create the appropriate accessor in the model:'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们在模型中创建适当的访问器：
- en: '[PRE74]'
  id: totrans-304
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: Then as the last step, we can include it in the `appends` array property.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 然后作为最后一步，我们可以将其包含在 `appends` 数组属性中。
- en: '[PRE75]'
  id: totrans-306
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: Nothing else!
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 没有其他了！
- en: 'Now we can use our attribute like this:'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以像这样使用我们的属性：
- en: '[PRE76]'
  id: totrans-309
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: Note
  id: totrans-310
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Every attribute that you create with the `appends` array respects the rules
    you specify eventually in the `visible` and `hidden` arrays.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 你使用 `appends` 数组创建的每个属性都尊重你在 `visible` 和 `hidden` 数组中最终指定的规则。
- en: Route model binding
  id: totrans-312
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 路由模型绑定
- en: Another little cool shortcut is **model binding**. In a few words, it lets you
    link a certain route parameter to an instance of a defined model.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个很酷的快捷方式是 **模型绑定**。简单来说，它允许你将某个路由参数链接到定义的模型的一个实例。
- en: 'Let''s test it: first of all, go to `RouteServiceProvider` in `app/Providers`
    folder. Now follow these steps:'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来测试一下：首先，前往 `app/Providers` 文件夹中的 `RouteServiceProvider`。现在按照以下步骤操作：
- en: 'Add this line to the `boot` method:'
  id: totrans-315
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将此行添加到 `boot` 方法中：
- en: '[PRE77]'
  id: totrans-316
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE77]'
- en: 'Then go to your routes file and create a new route that uses this parameter:'
  id: totrans-317
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后前往你的路由文件，创建一个新的路由，使用这个参数：
- en: '[PRE78]'
  id: totrans-318
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE78]'
- en: 'So, calling the `books/1` URL will output something like this:'
  id: totrans-319
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 因此，调用 `books/1` URL 将输出类似的内容：
- en: '[PRE79]'
  id: totrans-320
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE79]'
- en: What happened? Laravel resolved and automatically instantiated in the `$book`
    variable the desired object, using the given parameter (`1`) as the search term
    based on the primary ID. Then, the instance was used to output the title.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 发生了什么？Laravel 解析并自动在 `$book` 变量中实例化了所需的对象，使用给定的参数（`1`）作为基于主键的搜索词。然后，使用该实例输出了标题。
- en: It's a little trick but sometimes it could be useful.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个小技巧，但有时可能很有用。
- en: 'You can also customize the resolution logic: here''s another example using
    the e-mail address instead.'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以自定义解析逻辑：这里有一个使用电子邮件地址的另一个示例。
- en: '[PRE80]'
  id: totrans-324
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: If the record with the specified primary ID doesn't exist, the application will
    return a `404 not found` error. Obviously, you can change this behavior by specifying
    a third parameter for the `model()` binding.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 如果指定的主键记录不存在，应用程序将返回 `404 not found` 错误。显然，你可以通过为 `model()` 绑定指定第三个参数来改变这种行为。
- en: '[PRE81]'
  id: totrans-326
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: Records chunking for memory optimization
  id: totrans-327
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 记录分块以优化内存
- en: Sometimes, you will need to process thousand and thousand of records. You know
    that those operations are very heavy for your RAM, but Eloquent has a useful method
    to chunk query results in *blocks* to optimize your load.
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候，你可能需要处理成千上万的记录。你知道这些操作对你的内存来说非常沉重，但 Eloquent 有一个有用的方法可以将查询结果分块在 *块* 中，以优化你的加载。
- en: '[PRE82]'
  id: totrans-329
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: The first parameter defines the size of the block you want to use. In this case,
    we will load 200 results, process them, unload them, and repeat the same thing
    with the next 200.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个参数定义了你想要使用的块的大小。在这种情况下，我们将加载 200 个结果，处理它们，卸载它们，然后对下一个 200 个重复同样的操作。
- en: 'The second parameter is a closure that defines what to do with that chunk:
    the `books` closure parameter is the returned collection of records.'
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个参数是一个闭包，它定义了如何处理这个块：`books` 闭包参数是返回的记录集合。
- en: Summary
  id: totrans-332
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: Hey, we made it again! This first overview of Eloquent is completed and now
    you are able to make your first experiments on your own! Well actually you are
    able to do many experiments, not just the basics. We learned all about the CRUD,
    mass assignment, and many other interesting things.
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 嘿，我们又做到了！Eloquent 的这个第一部分概述已经完成，现在你能够自己进行第一次实验了！实际上，你能够进行许多实验，而不仅仅是基础操作。我们学习了所有关于
    CRUD、批量赋值以及许多其他有趣的内容。
- en: If you feel overwhelmed by all this information, don't worry. Take your time
    to do many tests and get familiarized with all the mechanisms, including the conventions
    you found on your road. We are only at the third chapter!
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你觉得所有这些信息让你感到不知所措，别担心。花时间进行多次测试，熟悉所有机制，包括你在旅途中发现的约定。我们才刚刚进行到第三章！
- en: 'In the next chapter, we will go deeper in one of the most amazing aspects of
    Eloquent: relations. You will experience the power of Eloquent and how it handles
    every kind of relationship between models, from the one-to-one to many-to-many,
    in all its beauty.'
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将深入探讨 Eloquent 最令人惊叹的方面之一：关系。你将体验到 Eloquent 的力量以及它是如何处理模型之间各种关系的，从一对一关系到多对多关系，展现其全部的美丽。
- en: Go, go, go, hero!
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 加油，加油，英雄！
