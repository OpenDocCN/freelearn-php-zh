- en: Chapter 3. The Most Important Element – the Model!
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Finally, I can say it: things are getting really, really serious from this
    moment. In the previous chapters, you studied everything you needed to make a
    start. Maybe it was a little annoying, but you knew that you would need it. Now,
    stop talking about the past; it''s over. In this chapter, many amazing things
    await.'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
- en: 'As you can imagine by the title, this part is going to be about the most important
    and atomic Eloquent element: **the model**. We will analyze the *M* in **MVC**.
    Considering that you are reading a book about creating a data-based application,
    exactly, really important! However, I don''t want to bore you anymore. Let''s
    talk about what we are going to see in the next sections.'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
- en: Usually, there is a *standard* way to look at the Eloquent documentation. It's
    the same as you can see on the Laravel site. In my initial Laravel days, I used
    those pages but I felt a little *incomplete*. So, I changed things a little bit
    but in a more simplified way. If you have ever developed a web application in
    your life, I'm quite sure that you made a data-based application with tables and
    records. Right? Well...
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
- en: If you think about it, you can do four basic operations on them. Whenever you
    develop an application, there's a very high possibility that you are going to
    implement some *create*, *read*, *update*, and *delete* logic for your items.
    This is exactly what we are going to see in this chapter.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
- en: First of all, we will introduce the simple, basic model. It will be a single
    line of code! Then, we will talk about CRUD (**create, read, update, and delete**)
    operations with Eloquent. After that point, you will have all the *basics* and
    an overview of the mechanism. We will also deal with the `where()` method and
    everything related, unscrambling everything about conditions and selections.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
- en: After that, we will go deep into the **Model** class, studying the mass assignment
    as another way to store and update our data. Then, we will discuss **timestamps**
    and **soft deletes**, and find out how Laravel and Eloquent deal with dates. After
    that, you will learn about query scopes and how to use them to improve your development
    process.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
- en: 'Also, we will take a look at many cool methods to transform our data in order
    to be shown (or stored) correctly: attributes casting, mutators, date mutators,
    and accessors. If that isn''t enough, we will explore all the Model-related events
    that you can use to introduce new behaviors in your code without breaking it.
    Also, Model observers will be analyzed when an event isn''t enough.'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
- en: 'In the last part of this chapter, we will explore some useful methods and features
    of the Model class, diving directly into the basic Model class code! Not bad,
    huh? Let''s start! Here are the topics:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
- en: Creating a Model
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Create, read, update, and delete operations basics
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Where, aggregates, and other utilities
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Mass assignment – for the masses
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Query scopes
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Attributes casting, accessors, and mutators
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Model events and observers
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模型事件和观察者
- en: Descending in the code
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 代码深入
- en: Creating a Model
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建模型
- en: First of all, let's see how you can create a Model and how its basic structure
    is made.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们看看如何创建一个模型以及其基本结构是如何构成的。
- en: 'The fastest way to create a Model is to use the following command, with a parameter
    that you can use to specify the model name:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 创建模型最快的方式是使用以下命令，你可以使用参数来指定模型名称：
- en: '[PRE0]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'So, let''s imagine that you want to create a `Book` model. The steps are as
    follows:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，让我们想象一下，你想要创建一个 `Book` 模型。步骤如下：
- en: 'All you have to do is use the following command:'
  id: totrans-22
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你需要做的只是使用以下命令：
- en: '[PRE1]'
  id: totrans-23
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Of course, you can also create it manually; usually, Laravel puts Models in
    the `app` folder.
  id: totrans-24
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 当然，你也可以手动创建它；通常，Laravel 将模型放在 `app` 文件夹中。
- en: Once you have done this, let's open the `Book.php` file under `app` to see what's
    inside.![Creating a Model](img/3634_03_01.jpg)
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦你完成了这些，让我们打开 `app` 目录下的 `Book.php` 文件，看看里面有什么。![创建模型](img/3634_03_01.jpg)
- en: Wait. What? An empty class? Seriously?
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 等等。什么？一个空类？真的吗？
- en: Yes.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 是的。
- en: Laravel is designed to create a great web application in very little time. Eloquent
    (and its models) are no exceptions. The class you can see here is ready to be
    used in your application; using it, you will be able to do everything related
    to your books.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: Laravel 设计得非常快速地创建一个优秀的网络应用程序。Eloquent（及其模型）也不例外。你在这里看到的类已经准备好在你的应用程序中使用；使用它，你将能够完成与你的书籍相关的所有操作。
- en: Talking about SQL databases, you can think of a connection between every model
    and table. If you respect a certain *convention*, Laravel automatically guesses
    the table name starting from the model name. So, if I have a model by the name
    of `Book`, Laravel will search for a `books` table on the database, without the
    need for specifying it explicitly.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 谈到 SQL 数据库，你可以想到每个模型和表之间的连接。如果你遵守某种*约定*，Laravel 会自动根据模型名称猜测表名。所以，如果我有一个名为 `Book`
    的模型，Laravel 将会在数据库中搜索一个名为 `books` 的表，无需明确指定。
- en: 'If you need to bind a certain model with another table, you can specify the
    name adding it as a `$table` property, like this:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你需要将某个模型与另一个表绑定，你可以指定名称，将其作为 `$table` 属性添加，如下所示：
- en: '[PRE2]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Alright, nothing more to say here. Now, let's play with our new model.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，这里没有更多要说的了。现在，让我们来玩我们的新模型。
- en: Create, read, update, and delete operations basics
  id: totrans-33
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建、读取、更新和删除操作的基本知识
- en: Every single article I read about Eloquent usually starts with some reading
    operations. I don't like it. I will teach you how to create and insert new records,
    then we will fetch them with some reading operations.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 我读过的每一篇关于 Eloquent 的文章通常都以一些读取操作开始。我不喜欢这样。我将教你如何创建和插入新记录，然后我们将使用一些读取操作来检索它们。
- en: No boring test inserts with some external administration tool.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 没有使用外部管理工具的枯燥测试插入。
- en: Creating operations
  id: totrans-36
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建操作
- en: 'Let''s create our first book! As a reference for the record *structure*, we
    will use the `books` table that we created in the previous chapter. The table
    has a very simple structure: a title, page count (`pages_count`), price, and description.'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建我们的第一本书！作为记录*结构*的参考，我们将使用我们在上一章中创建的 `books` 表。该表结构非常简单：标题、页数（`pages_count`）、价格和描述。
- en: The procedure is as easy as creating an object.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 这个过程就像创建一个对象一样简单。
- en: 'Well, actually it is exactly the same. Create a new `GET` route in `routes.php`
    file under `app/Http/`, named `book_create` and type this:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 嗯，实际上完全一样。在 `app/Http/` 目录下的 `routes.php` 文件中创建一个新的 `GET` 路由，命名为 `book_create`
    并输入以下内容：
- en: '[PRE3]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: If you think about it, there is something strange here! After checking the Model
    file, you can see that there are no `title` or `pages_count` properties declared.
    Among other things, Eloquent heavily uses magic methods. When the final query
    is built Laravel will use the names of the properties as the table columns to
    fill. Big deal!
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你仔细想想，这里有一些奇怪的地方！在检查模型文件后，你可以看到没有声明 `title` 或 `pages_count` 属性。在其他方面，Eloquent
    大量使用魔法方法。当最终查询构建时，Laravel 将使用属性名称作为表列来填充。这很重要！
- en: 'Now, if you run this code and then check your table, you will not find any
    record yet. You must add a single final instruction: the `save()` method call.'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果你运行这段代码然后检查你的表，你将找不到任何记录。你必须添加一个单一的最终指令：调用 `save()` 方法。
- en: '[PRE4]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Execute it. Now, your book is saved on the database.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 执行它。现在，你的书已经保存在数据库中了。
- en: If you want, you can access a specific record field even after you've saved
    it. Let's make another example.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你愿意，你甚至可以在保存后访问特定记录的字段。让我们再举一个例子。
- en: '[PRE5]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Note
  id: totrans-47
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: There is another little thing about Eloquent conventions; that is, every single
    table has an ID, autoincrementing a primary key.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
- en: Reading operations
  id: totrans-49
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now that we've created some example records, why don't we try to read them?
    An example is better than a thousand words.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'With a single instruction, here we are returning all the table records. The
    output is going to be very similar to this:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Note
  id: totrans-54
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If you feel strange about this, don't worry. If you return, in a route (or in
    a controller method) the results of an Eloquent model query, the results will
    be automatically transformed in JSON. It is a very useful shortcut if you are
    thinking about building a RESTful API.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
- en: Let's create another book, to give our tests more elements.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'After this, again execute your code in the `book_get_all` route. The result
    will be like this:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'However, we can do more. In fact, another great method is the `find()` method.
    You can use it like this:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: This method takes the primary ID as a parameter and returns the single record
    as an instance of the model.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
- en: 'Have a look at its output:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Note that this time you don't have an array but a single object. These *static*
    methods, of course, aren't all Eloquent has to offer. The cool part starts here.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
- en: 'Take a look at this:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: You can use the `where()` method to filter your results. Then, after specifying
    your criteria, the `get()` method retrieves the results from the database. For
    a better understanding, imagine that the `where()` method is building a query.
    The `get()` method executes it. This last one is a *trigger* method.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
- en: If you just want to retrieve the first result instead of all of them, you can
    use the `first()` method instead of `get()`.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Tip
  id: totrans-71
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Before we go any further, here's a little reminder that can save you a lot of
    time. Actually, when you use *trigger* methods such as `get()` or `first()`, you
    can get two different kinds of results.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
- en: When you use `first()`, you are selecting a single instance. So, you will receive
    as a result (if present) a single instance of a certain model. Otherwise, if you
    are using `all()`, or `get()`, you will get a collection of instances.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
- en: Getting back to our `where()`, you can chain as many calls as you wish.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'You can iterate through results in a very simple way: simple for each is enough.'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The `$results` object is countable, so you can also check if you have results
    or not.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
- en: 'Have a look at this line:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'You probably already noted that you can access a single record field in the
    same way as you did for setting them: magic methods.'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-82
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If you like it, you can access record fields like an array.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
- en: Try to switch `$book->title` to `$book['title']` and see what happens.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
- en: Updating operations
  id: totrans-85
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Updating a record is as easy as creating it. To be honest, it is exactly the
    same thing with a single change in the first instruction.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Instead of creating it, we are retrieving from the database the instance of
    the Model we desired. After that, using magic methods, we modified and then saved
    it. As happened for the insert procedure, the change you make becomes persistent
    after the `save()` call.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
- en: Deleting operations
  id: totrans-89
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Deleting a record is the simplest thing.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Time to die, `Book`!
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-93
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Here's a key concept. When you use the `update()` and `delete()` methods, you
    are working on a Model instance, just like you did before while creating it.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
- en: So, if you run a `\App\Book::find(1)` instruction, you will get a `Book` class
    instance as a result. For some, it will be obvious, but many newcomers often have
    problems with this.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
- en: where, aggregates, and other utilities
  id: totrans-96
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: No doubt that the `where()` method will be one of your best friends while building
    queries and selecting records in your work with Eloquent. Don't you think it would
    be worth taking a look at it in detail?
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
- en: Let's recap what we already know.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
- en: 'You can use the `where()` method to filter results. The correct syntax you
    have to use is this:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: So, for example, you can filter all the books with less than 100 pages with
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Also, you can chain more `where` methods, one after another, to build more complex
    queries. Let's select all those books that have less than 100 pages, with a title
    that starts with an *M*.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Note
  id: totrans-105
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Two chained conditions are equivalent to `condition1 AND condition2`.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
- en: Great!
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
- en: where and orWhere
  id: totrans-108
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'However, you know that this is not enough. Usually, in a real-world application,
    you may have more complex conditions. First of all, you may need to get results
    that respect a condition OR another condition. The `AND` condition is not a standard;
    so, here''s the solution: `orWhere()`.'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: In this code, we are telling Eloquent to take all the books that have the word
    *Second* in the title or all the books with more than 140 pages.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
- en: Yeah, this is a little better than before.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
- en: 'Now let''s try to imagine another more complex condition: we want to find all
    the books that have more than 120 pages and the word *Book* in the title, or all
    the books that have less than 200 pages and an empty description.'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Instead of specifying three parameters for `where()` and `orWhere()` methods,
    you can use a single closure parameter that takes a `$query` argument. Starting
    from that `$query` object, you will be able to do every selection and filtering
    in the way you prefer.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
- en: 'Of course, you can nest many of them:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Alright, stop. I think that the concept is quite clear now. Let's see some other
    forms of `where`.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
- en: First of all, here's `whereBetween` that you can use to filter some fields using
    a range, not only a single value.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: With that, we just got all the books that have a page count between 100 and
    200.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
- en: You can also use `whereIn` to check if a specific field is in an array of other
    values.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Finally, you can use `whereNull` if you want to get all the records with a certain
    column equal to null.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Magic wheres
  id: totrans-126
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Another great and cool feature is the *magic* `where`. You know that everything
    in Laravel has a little bit of magic here and there. Obviously, Eloquent isn't
    an exception.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
- en: In fact, you can use an alternative syntax for your `where` clause, a magic
    syntax that lets you define the interested field as the method name.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
- en: 'You already know this syntax:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Now, you can get the same result with this code:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Obviously, the `wherePagesCount` method doesn't exist but Laravel automatically
    creates a quick `where` clause using PHP magic methods. As you can see from the
    example (and as the syntax suggests), you cannot use this technique every time
    as it works only with the equal sign.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
- en: However, it's good to know a similar shortcut, right?
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
- en: Aggregates
  id: totrans-135
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Sometimes, you will need to use the aggregates functions. No problem! Here is
    how you can do it with Eloquent.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'This is an example of its practical use:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Exactly as you saw before for `get()` and `first()` methods, you can use aggregate
    methods with `where` methods. Here, we are counting the number of the books with
    more than 140 pages.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Obviously, `count()` is not the only aggregate. Let's see them with some other
    `where()` examples to do more practice. This time, we are searching for the minimum
    number of pages (but the books with more than 120 pages, at least).
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'You can also do the same thing with `max()`:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Now, let''s find the average price for all the books that have the *Book* word
    in the name:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Finally, let's get the sum of all the page counts for all the books with more
    than 100 pages.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Utility methods
  id: totrans-150
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As you probably imagined, Eloquent has a lot of utilities and methods that can
    improve your life as a developer. Trying to cover every single method would be
    hard but besides the most common methods, there are a few other methods that deserve
    to be here.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
- en: First of all, the `skip()` and `take()` methods that are used to implement some
    pagination in your queries.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: We are telling Eloquent to take 10 records and skip 10 from the start. So, if
    `skip(0)->take(10)` will take records from 1 to 10, `skip(10)->take(10)` will
    take from 11 to 20, and so on.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
- en: 'Of course, you can''t also miss the `orderBy`, `groupBy`, and `having` methods.
    If you know a little about SQL databases (and if you are here, I think you do)
    you won''t have any problem understanding this code:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Mass assignment... for the masses
  id: totrans-157
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You got the basics. Cool!
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
- en: Now, you have to know about another couple of ways to insert a record with Eloquent.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
- en: 'The first is the Model constructor. You can pass an associative array as a
    parameter of the constructor call, something like this:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Another is the `create()` method that you can call *statically* from the model
    itself.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Similar to the constructor, this `create()` method takes an associative array
    as a parameter and every key in this array corresponds to a column on the table
    (and a `magic` property on the model). The returned value (the one that is stored
    in `$book`) is an instance of the `Book` class.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
- en: 'This is called **mass assignment** and, until this point, everything is fine
    except for a serious security issue. In fact, sometimes you could pass the entire
    request input array as a parameter. Trust me: sooner or later, you will do it.'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-166
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `$request` object you are going to see in the following example is a request
    instance that you can use to deal with the current request data. I will use it
    to retrieve some hypothetical `POST` data from a form (with the `all()` method)
    we will use to create a new book.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
- en: 'Something like this can be used:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Technically, you don't know exactly what's in `$request->all()` so it is not
    the best practice, right? However, you can resolve this issue quite easily by
    adding a single property to your model—`fillable` or `guarded`.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
- en: Let's take an example for a better understanding of the concept. Imagine that
    for some reason you specify other fields in the form you already use for a new
    book insert, maybe the current user ID for logging purposes.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
- en: 'However, you just want to insert four single fields: `title`, `pages_count`,
    `price`, and `description`. Nothing else!'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
- en: 'The key property is `fillable`:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'You can execute the code like this:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: From the moment you execute the code, the model will search for `title`, `pages_count`,
    `price`, and `description` items. Nothing more! If you also have a `user_id` field
    in your request data array, it will be ignored by the model.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
- en: Of course, be careful and check twice what you put in the `$fillable` array
    of your models. Sometimes, developers easily forget the rights fields, and they
    pass hours and hours after an empty database record.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
- en: 'So, if you actually get a problem with an empty database record, remember:
    check your `fillable`.'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
- en: 'The `guarded` property has a similar behavior but does the opposite thing:
    if `fillable` is a whitelist, then `guarded` is a blacklist. A mechanism like
    a blacklist can be extremely useful if you store some important and sensible information
    that you don''t want to get updated by the user in any way.'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
- en: 'Also, sometimes you will need to guard every single attribute of your model.
    No problem, use `guarded` like this:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Note
  id: totrans-183
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If you put a field both in the `fillable` and `guarded` arrays, the model behavior
    will give the precedence to `fillable` and the field will be filled in.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
- en: Also, use `fillable` and `guarded` wisely. Remember also, that if you are using
    the `guarded` array and you are passing a classic full request data array to your
    model, you could update some unwanted fields and get some really unwanted errors.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
- en: Boring errors! Avoid them.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
- en: Timestamps and soft deletes
  id: totrans-187
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Time to cover two awesome features of the Model class: timestamps and soft
    deletes. How many times have you had to manually handle the creation date of a
    record and its last update time? Model timestamps are here to help.'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
- en: Also, how many times have you had to create a delete feature while maintaining
    some information about your data, if not at all? Yeah, the soft deleting feature
    is here to help too.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
- en: Timestamps
  id: totrans-190
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Do you remember the last method we called in our `books` table migrations? No?
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 你还记得我们在 `books` 表迁移中调用的最后一个方法吗？不记得了吗？
- en: 'Don''t worry, here it is:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 别担心，下面就是：
- en: '[PRE45]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Exactly, it is the `timestamps()` method. This special Schema Builder method
    is used to create two separate fields: `created_at` and `updated_at`, both MySQL
    `DATETIME` or equivalent. Eloquent automatically handles these two fields when
    you create or update a record.'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 正确，它是 `timestamps()` 方法。这个特殊的 Schema Builder 方法用于创建两个独立的字段：`created_at` 和 `updated_at`，两者都是
    MySQL 的 `DATETIME` 或等效类型。Eloquent 在你创建或更新记录时会自动处理这两个字段。
- en: 'It can be extremely useful: how many times did you have to deal with some *last
    edit* data on a specific table? Also, imagine how much easier it could be with
    these two fields to handle some scheduled article posting.'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 它可以非常实用：你有多少次不得不处理特定表上的某些*最后编辑*数据？想象一下，有了这两个字段处理一些计划发布的文章会容易多少。
- en: 'However, sometimes they are not so useful: you can disable them just by setting
    the `timestamps` property model to false.'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，有时它们并不那么有用：你只需将模型中的 `timestamps` 属性设置为 `false` 就可以禁用它们。
- en: '[PRE46]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: Note
  id: totrans-198
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Obviously, if you plan to disable timestamps you can delete the corresponding
    `timestamps()` Schema Builder call in your migration. You are not going to need
    it anymore.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，如果你打算禁用时间戳，你可以在迁移中删除相应的 `timestamps()` Schema Builder 调用。你将不再需要它。
- en: 'You can eventually *specify the format of your timestamps*, if needed. Here''s
    an example:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 如果需要，你可以最终*指定时间戳的格式*。这里有一个例子：
- en: '[PRE47]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: All you have to do is to implement the `getDateFormat` method in your model
    and let it return a string that describes the desired format.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 你所需要做的就是实现模型中的 `getDateFormat` 方法，并让它返回一个描述所需格式的字符串。
- en: Note
  id: totrans-203
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: In the returned string, you can insert anything that is a valid format for the
    `date()` PHP function (you can find a complete reference at [http://php.net/manual/en/function.date.php](http://php.net/manual/en/function.date.php)).
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 在返回的字符串中，你可以插入任何 `date()` PHP 函数的有效格式（你可以在 [http://php.net/manual/en/function.date.php](http://php.net/manual/en/function.date.php)
    找到完整的参考）。
- en: Soft deleting
  id: totrans-205
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 软删除
- en: The soft deleting feature is a really interesting feature that can be useful
    on many occasions.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 软删除功能是一个非常有趣的功能，在许多场合都可能很有用。
- en: 'If you decide to activate soft deleting, you will never really delete a record:
    instead, a `deleted_at` column will be updated with the date of the operation,
    but nothing more. Eloquent will work exactly like before but you will never lose
    anything.'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你决定激活软删除，你实际上永远不会删除一条记录：相反，`deleted_at` 列将被更新为操作日期，但仅此而已。Eloquent 将像以前一样工作，但你永远不会丢失任何东西。
- en: It could be a perfect fit for an e-commerce database that handles orders. The
    customer could decide to *clear* his order history. However, in order to keep
    accounts perfect, the shop owner would continuously need every single order detail.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 它非常适合处理订单的电子商务数据库。客户可以决定*清除*他的订单历史。然而，为了保持账户完美，店主会持续需要每个订单的详细信息。
- en: As you can easily imagine, from the previous chapter, in order to activate the
    soft deleting feature, you will have to make a call to `softDeletes()` Schema
    Builder method.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 如你很容易想象的，从上一章中，为了激活软删除功能，你必须调用 `softDeletes()` Schema Builder 方法。
- en: '[PRE48]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: After this, you will have to include the `SoftDeletes` trait in the model.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 在此之后，你必须将 `SoftDeletes` 特性包含在模型中。
- en: '[PRE49]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: Nothing more!
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 没有更多了！
- en: Also, working with soft deleted data is really easy. Let's implement a simple
    example based on the situation we described before (the customer order's details
    and shop owner's need).
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，处理软删除数据真的非常简单。让我们基于之前描述的情况（客户订单的详情和店主的需求）来实现一个简单的例子。
- en: 'First of all, here''s an example model:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，这里有一个示例模型：
- en: '[PRE50]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: In his/her order history, a customer should see only his/her *existent* orders
    and not *deleted* orders. I used quotation marks because we are talking about
    records that always exist.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 在他的/她的订单历史中，客户应该只能看到他/她的*存在*订单，而不是*已删除*订单。我之所以使用引号，是因为我们谈论的是始终存在的记录。
- en: '[PRE51]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: Nothing really special!
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 没有什么特别之处！
- en: 'What about the shop owner? The magical word is `withTrashed`:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 那店主怎么办呢？神奇的字眼是 `withTrashed`：
- en: '[PRE52]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: The `withTrashed` method automatically includes every result that is actually
    present in the table, regardless of the `deleted_at` field value.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: '`withTrashed` 方法自动包含表中实际存在的每个结果，无论 `deleted_at` 字段值如何。'
- en: Also, if you need to see only the soft deleted fields, change `withTrashed`
    to `onlyTrashed`.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，如果你只想看到软删除的字段，将 `withTrashed` 改为 `onlyTrashed`。
- en: '[PRE53]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: Finally, you can restore a record that has been deleted with the `restore` method.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: If you prefer, you can execute the restore operation using a query as a `filter`.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'Alright, I know what you are thinking: this feature is cool but what if I want
    to really delete a field?'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
- en: No problem; just use `forceDelete`.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: Query scopes
  id: totrans-232
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Query scopes are very funny and also powerful. I really like them because,
    like many programmers out there, I am absolutely and overwhelmingly lazy. I also
    have a great justification for my laziness: the **Don''t Repeat Yourself** (**DRY**)
    principle.'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
- en: In a few words, they let you reuse some logic in your queries. It is useful
    if you have similar queries in your application and you don't want to write them
    again and again every single time.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
- en: Let's take an example.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: What happened? I declared a `scopeCheaperButBig` method. The `scope` prefix
    is used to specify that this is going to be used as a scope.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
- en: Now, how can I use a scope?
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
- en: 'Here it is:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'It is a cool feature. If you also think that you can split your logic in a
    more intelligent way, you can do it as follows:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: Use it accordingly, reducing repeated code.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: If you need it, you can also define dynamic scopes in order to pass parameters
    to your scopes. If you like it, calling a scope inside another is not a problem.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: Attributes casting, accessors, and mutators
  id: totrans-247
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Eloquent has many ways to transform the model data into something more readable
    or usable (and vice versa). In this chapter, we are going to analyze three of
    them: attributes casting, accessors, and mutators.'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
- en: Attributes casting
  id: totrans-249
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The easier way to transform your model attributes while accessing them is the
    attributes casting. In a few words, it lets you define what attribute you want
    to cast and what is going to be the *destination* type.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
- en: 'Suppose that you have another integer field in your `books` table: `is_rare`.
    If the book is rare, this will be equal to `1`, `0` otherwise. However, when you
    work with it, the best thing would logically be as follows:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'It will not be something like this:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: Right? Good.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
- en: 'So, all you have to do to fix this problem is to specify, in your model, the
    `casts` array:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: From this moment, every time you call the `is_rare` attribute, it will be automatically
    converted to the Boolean corresponding value and returned.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
- en: 'The supported types for casting are: integer, real, float, double, string,
    Boolean, object, and array.'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-260
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As also the documentation suggests, the *array* casting type is useful when
    you have a JSON array stored in a specific table column and you want to work with
    it quickly.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
- en: Accessors and mutators
  id: totrans-262
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Attributes casting is very useful but has some limitations. Sometimes, starting
    from a simple value stored in the database, you need to do more complex work on
    it. Accessors and mutators are here to help.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
- en: 'To be more specific, an accessor is a method that is executed when the user
    reads a specific attribute. The accessor works on the attribute stored in the
    database and returns it. A mutator works in the opposite way: when you store a
    value, the mutator works, does its job and then saves it in the table. Let''s
    say they are sorts of getters and setters.'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
- en: 'Defining an accessor (or a mutator) is not so difficult: all you have to do
    is to follow a naming convention.'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
- en: Let's start with something simple. Imagine that every time that you access the
    price of your book, you want to put the dollar symbol *$* at the beginning of
    the string.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'The naming convention for an accessor is simple as shown:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
- en: The method name starts with `get`
  id: totrans-269
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The middle part of the name is the attribute name, which is camel cased
  id: totrans-270
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The method name ends with `Attribute`
  id: totrans-271
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Nothing more.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, have a look at this:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: Every time you have the preceding code, the mutator is very similar. This time,
    we want to store a lowercase version of the title.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'The convention isn''t changed so much: the only difference is that the method
    name now starts with `set` and not `get`. It''s all about getters and setters,
    my friend.'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
- en: Another real common use of mutators is when the application stores the user's
    password. A mutator can be used to hash the chosen password and the result is
    then stored.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: Descending in the code
  id: totrans-280
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous text, we analyzed many aspects of the Eloquent model. If you
    think about your path, in a few pages you learned everything you needed to do
    many operations with your data. Also, you saw many interesting ways to add behaviors
    (from accessors and mutators to model observers) in order to improve your code
    usability, readability, and maintainability.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
- en: 'In this section you are going to read, I will go through the Model class and
    analyze it a little deeper than the usual. Nothing so advanced, so don''t worry:
    I will just use the class code to show you what you can do with your models.'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
- en: Take it as a *list* of useful tips and tricks.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
- en: A big file
  id: totrans-284
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'At the moment I am writing this chapter, the `Model` class under `Illuminate\Database\Eloquent`
    counts 3361 lines of code, which is a big class with many methods and features.
    However, this length is acceptable considering that we can do the same thing in
    many different ways (just think about the `save()` method, the `::create()` method,
    and the possibility to specify an associative array in the model constructor:
    three ways to insert a new record).'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
- en: In the first part of the class you can see all the properties we saw before,
    set to their default values.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  id: totrans-287
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: Yes, by default every attribute is guarded. A *total blacklist* for maximum
    security!
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
- en: Quick conversion to array or JSON
  id: totrans-289
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Do you remember at the beginning of this chapter what I told you about the
    automatic conversion to JSON of your model attributes? If you take a look at the
    code into the model you will see two methods: `toArray` and `toJson`. These two
    methods are the ones that make the magic happen.'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  id: totrans-291
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: Note
  id: totrans-292
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You can also see that the second method uses the first. If you don't fear big
    files, I suggest you to take a deeper look at all the methods in this class. You
    will see some awesome examples of code reusing and function writing. In this chapter,
    we are just scratching the surface.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
- en: 'You can convert both single models and model collections to arrays or JSON:'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  id: totrans-295
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: Obviously, for security reasons, you can choose to mark some specific fields
    as `hidden`. They will not be shown when the record is converted to array or JSON.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  id: totrans-297
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: In this case, with `hidden`, we specified a blacklist. You can also define a
    whitelist with the `visible` property.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  id: totrans-299
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: Imaginary attributes
  id: totrans-300
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Using accessors and a specific property of the model, `appends`, you can create
    some attributes even if they don't exist as table columns.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
- en: For example purposes, let's assume that we want to create a `complete_name`
    attribute, made with the two attributes `first_name` and `last_name`.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
- en: 'First of all, let''s create the appropriate accessor in the model:'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  id: totrans-304
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: Then as the last step, we can include it in the `appends` array property.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  id: totrans-306
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: Nothing else!
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we can use our attribute like this:'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  id: totrans-309
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: Note
  id: totrans-310
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Every attribute that you create with the `appends` array respects the rules
    you specify eventually in the `visible` and `hidden` arrays.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
- en: Route model binding
  id: totrans-312
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Another little cool shortcut is **model binding**. In a few words, it lets you
    link a certain route parameter to an instance of a defined model.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s test it: first of all, go to `RouteServiceProvider` in `app/Providers`
    folder. Now follow these steps:'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
- en: 'Add this line to the `boot` method:'
  id: totrans-315
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE77]'
  id: totrans-316
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE77]'
- en: 'Then go to your routes file and create a new route that uses this parameter:'
  id: totrans-317
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE78]'
  id: totrans-318
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE78]'
- en: 'So, calling the `books/1` URL will output something like this:'
  id: totrans-319
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE79]'
  id: totrans-320
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE79]'
- en: What happened? Laravel resolved and automatically instantiated in the `$book`
    variable the desired object, using the given parameter (`1`) as the search term
    based on the primary ID. Then, the instance was used to output the title.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
- en: It's a little trick but sometimes it could be useful.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also customize the resolution logic: here''s another example using
    the e-mail address instead.'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  id: totrans-324
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: If the record with the specified primary ID doesn't exist, the application will
    return a `404 not found` error. Obviously, you can change this behavior by specifying
    a third parameter for the `model()` binding.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  id: totrans-326
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: Records chunking for memory optimization
  id: totrans-327
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Sometimes, you will need to process thousand and thousand of records. You know
    that those operations are very heavy for your RAM, but Eloquent has a useful method
    to chunk query results in *blocks* to optimize your load.
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  id: totrans-329
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: The first parameter defines the size of the block you want to use. In this case,
    we will load 200 results, process them, unload them, and repeat the same thing
    with the next 200.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
- en: 'The second parameter is a closure that defines what to do with that chunk:
    the `books` closure parameter is the returned collection of records.'
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-332
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Hey, we made it again! This first overview of Eloquent is completed and now
    you are able to make your first experiments on your own! Well actually you are
    able to do many experiments, not just the basics. We learned all about the CRUD,
    mass assignment, and many other interesting things.
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
- en: If you feel overwhelmed by all this information, don't worry. Take your time
    to do many tests and get familiarized with all the mechanisms, including the conventions
    you found on your road. We are only at the third chapter!
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
- en: 'In the next chapter, we will go deeper in one of the most amazing aspects of
    Eloquent: relations. You will experience the power of Eloquent and how it handles
    every kind of relationship between models, from the one-to-one to many-to-many,
    in all its beauty.'
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
- en: Go, go, go, hero!
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
