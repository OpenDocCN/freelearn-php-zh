- en: '4'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '4'
- en: Building a Laravel Octane Application
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建Laravel Octane应用程序
- en: In the previous chapters, we focused on installing, configuring, and using some
    of the features provided by Laravel Octane. We looked at the difference between
    Swoole and RoadRunner, the two application servers supported by Laravel Octane.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在前几章中，我们专注于安装、配置和使用Laravel Octane提供的一些功能。我们探讨了Swoole和RoadRunner这两种由Laravel Octane支持的应用程序服务器之间的区别。
- en: In this chapter, we will focus on each feature of Laravel Octane to discover
    its potential and understand how it can be used individually.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将重点关注Laravel Octane的每个功能，以发现其潜力并了解如何单独使用它。
- en: The goal of this chapter is to analyze the functionality of Laravel Octane in
    a realistic context.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的目标是在现实环境中分析Laravel Octane的功能。
- en: To do that, we will build a sample dashboard application covering several aspects,
    such as configuring the application, creating the database table schema, and generating
    initial data.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 为了做到这一点，我们将构建一个示例仪表板应用程序，涵盖多个方面，例如配置应用程序、创建数据库表架构以及生成初始数据。
- en: Then, we will go on to implement specific routes for dashboard delivery and
    implement the data retrieval logic in the controller and the query in the model.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将继续实现仪表板交付的特定路由，并在控制器中实现数据检索逻辑以及在模型中的查询。
- en: Then we will create a page in the sample dashboard application, where we will
    collect information from multiple queries. When we have to implement queries for
    retrieving data, generally, we focus on the logic and the methods for filtering,
    sorting, and selecting data. In this chapter, however, we will keep the logic
    as simple as possible to allow you to focus on other aspects, such as loading
    data efficiently thanks to executing parallel tasks, and we will apply some strategies
    to reduce the response time as much as possible (running the tasks in parallel
    reduces the overall response execution time).
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将在示例仪表板应用程序中创建一个页面，我们将从多个查询中收集信息。当我们必须实现用于检索数据的查询时，通常我们关注逻辑和过滤、排序和选择数据的方法。然而，在本章中，我们将保持逻辑尽可能简单，以便您能够关注其他方面，例如通过执行并行任务来高效地加载数据，并且我们将应用一些策略以尽可能减少响应时间（并行运行任务减少了整体响应执行时间）。
- en: In designing the application architecture, we also need to consider the things
    that could go wrong.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在设计应用程序架构时，我们还需要考虑可能出错的事情。
- en: In the examples in the previous chapter, we analyzed each feature by considering
    what is called the **happy path**. The happy path is the default scenario that
    the user takes to achieve the desired result without encountering any errors.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在前一章的示例中，我们通过考虑所谓的**快乐路径**来分析每个功能。快乐路径是用户为了实现预期结果而采取的默认场景，不会遇到任何错误。
- en: In designing a real application, we must also think about all those cases that
    are not included in the happy path. For example, in the case of concurrent execution
    of heavy queries, we need to think about the case where the execution may return
    an unexpected result such as an empty result set, or when the execution of a query
    raises an exception. We need to consider that this single exception may also have
    an impact on other concurrent executions. This looks like a more real-life scenario
    (where things could go wrong because of some exceptions) and, in this chapter,
    we will try to also manage the errors.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在设计真实应用程序时，我们还必须考虑那些不包括在快乐路径中的所有情况。例如，在并发执行重查询的情况下，我们需要考虑执行可能返回意外结果的情况，例如空结果集，或者当查询执行引发异常时。我们需要考虑这个单个异常也可能对其他并发执行产生影响。这看起来更像是一个更真实的生活场景（由于某些异常而可能出错），在本章中，我们还将尝试管理错误。
- en: Therefore, we will try to simulate a typical data-consuming application, where
    users’ request response controllers must execute operations as fast as possible,
    even in the face of a high request load.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们将尝试模拟一个典型的数据消耗型应用程序，其中用户的请求响应控制器必须尽可能快地执行操作，即使在面对高请求负载的情况下。
- en: The primary objective of this chapter is to guide you through drastically reducing
    the response time of your application with the help of multiple queries, concurrent
    execution in rendering a dashboard page, and by trying to apply Octane features
    in the application. We will walk through the routing, controller, models, queries,
    migrations, seeding, and the view template. We will involve some mechanisms provided
    by Octane, such as Octane Routes, chunk data loads, parallel tasks (for queries
    and HTTP requests), error and exception management, and Octane Cache.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的主要目标是指导您通过使用多个查询、在渲染仪表板页面时的并发执行以及尝试在应用程序中应用Octane功能来大幅减少应用程序的响应时间。我们将逐步介绍路由、控制器、模型、查询、迁移、填充和视图模板。我们将涉及Octane提供的一些机制，例如Octane路由、分块数据加载、并行任务（用于查询和HTTP请求）、错误和异常管理以及Octane缓存。
- en: 'In this chapter, we will cover the following:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下内容：
- en: Installing and setting up the application
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 安装和设置应用程序
- en: Importing the initial data (and suggestions on how to make it efficiently)
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 导入初始数据（以及如何高效地完成它的建议）
- en: Querying multiple pieces of data from the database in parallel
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 并行从数据库查询多份数据
- en: Optimizing the routes
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 优化路由
- en: More examples of integrating third-party APIs
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更多集成第三方API的示例
- en: Improving speed with Octane Cache
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Octane Cache提高速度
- en: Technical requirements
  id: totrans-20
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: We are going to assume that you have PHP 8.0 or greater (8.1 or 8.2) and the
    Composer tool. If you want to use Laravel Sail ([https://laravel.com/docs/9.x/sail](https://laravel.com/docs/9.x/sail)),
    you need the Docker Desktop application ([https://www.docker.com/products/docker-desktop](https://www.docker.com/products/docker-desktop)).
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将假设您拥有PHP 8.0或更高版本（8.1或8.2）以及Composer工具。如果您想使用Laravel Sail ([https://laravel.com/docs/9.x/sail](https://laravel.com/docs/9.x/sail))，则需要Docker
    Desktop应用程序 ([https://www.docker.com/products/docker-desktop](https://www.docker.com/products/docker-desktop))。
- en: We will also quickly recap the setup of Octane for our practical example. So,
    we will install all tools needed.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将快速回顾Octane的设置，以便于我们的实际示例。因此，我们将安装所有需要的工具。
- en: 'The source code and the configuration files of the examples described in the
    current chapter are available here: [https://github.com/PacktPublishing/High-Performance-with-Laravel-Octane/tree/main/octane-ch04](https://github.com/PacktPublishing/High-Performance-with-Laravel-Octane/tree/main/octane-ch04)'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 当前章节中描述的示例的源代码和配置文件在此处可用：[https://github.com/PacktPublishing/High-Performance-with-Laravel-Octane/tree/main/octane-ch04](https://github.com/PacktPublishing/High-Performance-with-Laravel-Octane/tree/main/octane-ch04)
- en: Installing and setting up the dashboard application
  id: totrans-24
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安装和设置仪表板应用程序
- en: To demonstrate the power of Laravel Octane, we are going to build a dashboard
    page to show event data filtered in different ways. We will keep it as simple
    as possible to avoid focusing on business functionalities, and we will keep focusing
    on how to apply techniques for improving performance while keeping the application
    reliable and error-free.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 为了展示Laravel Octane的强大功能，我们将构建一个仪表板页面来以不同的方式显示过滤的事件数据。我们将尽可能保持简单，以避免关注业务功能，并且我们将继续关注如何在保持应用程序可靠和错误免费的同时应用提高性能的技术。
- en: Installing your Laravel application
  id: totrans-26
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 安装您的Laravel应用程序
- en: 'As shown in [*Chapter 1*](B17728_01.xhtml#_idTextAnchor015), *Understanding
    the Laravel Web Application Architecture*, you can install the Laravel application
    from scratch via the Laravel command, as follows:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 如[*第1章*](B17728_01.xhtml#_idTextAnchor015)中所示，*理解Laravel Web应用程序架构*，您可以通过以下Laravel命令从头开始安装Laravel应用程序：
- en: '[PRE0]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Once you have your Laravel command installed, you can create your application
    with the following command:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦安装了Laravel命令，您可以使用以下命令创建应用程序：
- en: '[PRE1]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The `laravel new` command creates the directory with your application, so the
    next step is to enter the new directory to start customizing the application:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '`laravel new`命令创建包含您的应用程序的目录，因此下一步是进入新目录以开始自定义应用程序：'
- en: '[PRE2]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Adding a database
  id: totrans-33
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 添加数据库
- en: 'Now that we have created the application, we have to install and set up the
    database because our example application will need a database to store and retrieve
    the example data. So, to install and set up the database, we are going to do the
    following:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经创建了应用程序，我们必须安装和设置数据库，因为我们的示例应用程序需要数据库来存储和检索示例数据。因此，为了安装和设置数据库，我们将执行以下操作：
- en: Install a MySQL database server
  id: totrans-35
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 安装MySQL数据库服务器
- en: Execute migrations in Laravel (to apply schema definitions to database tables)
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Laravel中执行迁移（将模式定义应用到数据库表中）
- en: Install an application to manage and check the tables and the data of the database
  id: totrans-37
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 安装一个应用程序来管理和检查数据库的表和数据
- en: Installing the database service
  id: totrans-38
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 安装数据库服务
- en: 'There are three ways to install the database server: via the official installer,
    via your local package manager, or via Docker/Laravel Sail.'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 安装数据库服务器有三种方式：通过官方安装程序、通过您的本地包管理器或通过 Docker/Laravel Sail。
- en: 'The first one is to use the official installer provided by MySQL. You can download
    and execute the installer from the official website for your specific operating
    system: [https://dev.mysql.com/downloads/installer/](https://dev.mysql.com/downloads/installer/).'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 第一种方法是使用 MySQL 提供的官方安装程序。您可以从官方网站下载并执行适用于您特定操作系统的安装程序：[https://dev.mysql.com/downloads/installer/](https://dev.mysql.com/downloads/installer/)。
- en: Once you have downloaded the installer, you can execute it.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 下载安装程序后，您可以执行它。
- en: 'Another way is to use your system package manager. If you have macOS, my suggestionis
    to use Homebrew (see [*Chapter 1*](B17728_01.xhtml#_idTextAnchor015), *Understanding
    the Laravel Web Application Architecture*) and execute the following command:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种方法是使用您的系统包管理器。如果您有 macOS，我的建议是使用 Homebrew（见 [*第 1 章*](B17728_01.xhtml#_idTextAnchor015)，*理解
    Laravel 网络应用程序架构*）并执行以下命令：
- en: '[PRE3]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'If you are using GNU/Linux, you can use the package manager provided by your
    GNU/Linux distribution. For example, for Ubuntu, you can execute the following:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您使用 GNU/Linux，您可以使用您的 GNU/Linux 发行版提供的包管理器。例如，对于 Ubuntu，您可以执行以下操作：
- en: '[PRE4]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: If you don’t want to install or add the MySQL server to your local operating
    system, you can use a Docker image running in a Docker container. For that, we
    can use the **Laravel Sail** tool. If you are familiar with Docker images, using
    a Docker image simplifies the installation of third-party software (such as the
    database). Laravel Sail simplifies the process of managing Docker images.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您不想在本地操作系统上安装或添加 MySQL 服务器，您可以使用在 Docker 容器中运行的 Docker 镜像。为此，我们可以使用 **Laravel
    Sail** 工具。如果您熟悉 Docker 镜像，使用 Docker 镜像可以简化第三方软件（如数据库）的安装。Laravel Sail 简化了管理 Docker
    镜像的过程。
- en: 'Make sure that Laravel Sail is added to your application. In the project directory,
    add the Laravel Sail package to your project:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 确保将 Laravel Sail 添加到您的应用程序中。在项目目录中，将 Laravel Sail 包添加到您的项目中：
- en: '[PRE5]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Then, execute the new command provided by Laravel Sail to add the Sail configuration
    for Docker:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，执行 Laravel Sail 提供的新命令以添加 Docker 的 Sail 配置：
- en: '[PRE6]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The execution of the preceding command will require you to select the services
    you need to activate via Laravel Sail. For now, the goal is to activate the MySQL
    service, so select the first option. On selecting the MySQL service, the MySQL
    Docker image will automatically be downloaded:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 执行前面的命令将需要您通过 Laravel Sail 选择要激活的服务。目前的目标是激活 MySQL 服务，因此选择第一个选项。选择 MySQL 服务后，MySQL
    Docker 镜像将自动下载：
- en: '![Figure 4.1: Installing Laravel Sail](img/Figure_4.01_B17728.jpg)'
  id: totrans-52
  prefs: []
  type: TYPE_IMG
  zh: '![图 4.1：安装 Laravel Sail](img/Figure_4.01_B17728.jpg)'
- en: 'Figure 4.1: Installing Laravel Sail'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.1：安装 Laravel Sail
- en: Installing Laravel Sail, as well as downloading the MySQL Docker image, will
    add the `docker-compose.yml` file to your project directory, and the PHPUnit configuration
    will be changed to use the new database instance. So, installing Laravel Sail
    helps you with the Docker configuration (creating the `docker-compose.yml` file
    with a preset configuration based on the choices provided as answers to the questions
    raised by the `sail:install` command), and with the configuration of PHPUnit (creating
    the right PHPUnit configuration to use the new database instance).
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 安装 Laravel Sail 以及下载 MySQL Docker 镜像，将 `docker-compose.yml` 文件添加到您的项目目录中，并将
    PHPUnit 配置更改为使用新的数据库实例。因此，安装 Laravel Sail 帮助您进行 Docker 配置（根据 `sail:install` 命令提出的问题的答案创建具有预设配置的
    `docker-compose.yml` 文件），以及 PHPUnit 的配置（创建正确的 PHPUnit 配置以使用新的数据库实例）。
- en: 'The `docker-compose.yml` file will contain the following:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '`docker-compose.yml` 文件将包含以下内容：'
- en: The main service to serve your web application
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为您的网络应用程序提供主要服务
- en: An additional service for the MySQL server
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为 MySQL 服务器提供附加服务
- en: The right configuration for the services to use the same environment variables
    from the `.``env` file
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为服务提供正确的配置，以便使用 `.env` 文件中的相同环境变量
- en: 'If you already have some services up and running on your local operating system
    and you want to avoid some conflicts (multiple services that use the same port),
    you can control some parameters used by Docker containers via `docker-compose.yml`,
    setting the following variables in the `.``env` file:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您已经在本地操作系统中运行了一些服务，并且想要避免一些冲突（使用相同端口的多个服务），您可以通过`docker-compose.yml`控制 Docker
    容器使用的某些参数，在`.env`文件中设置以下变量：
- en: '`VITE_PORT`: This is the port used by Vite to serve the frontend part (JavaScript
    and CSS). The default is `5173`; if you have Vite already up and running locally,
    you could use port `5174` to avoid conflicts.'
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`VITE_PORT`：这是 Vite 用于服务前端部分（JavaScript 和 CSS）的端口。默认值为`5173`；如果您已经在本地运行了 Vite，则可以使用端口`5174`以避免冲突。'
- en: '`APP_PORT`: This is the port used by the web server. By default, the port used
    by the local web server is port `80`, but if you already have a local web server
    up and running, you can use the `8080` settings (`APP_PORT=8080`) in the `.``env`
    file.'
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`APP_PORT`：这是 web 服务器使用的端口。默认情况下，本地 web 服务器使用的端口是端口 `80`，但如果您已经有一个本地 web 服务器正在运行，您可以在`.env`文件中使用`8080`设置（`APP_PORT=8080`）。'
- en: '`FORWARD_DB_PORT`: This is the port used by Laravel Sail to expose the MySQL
    service. By default, the port used by MySQL is `3306`, but if it is already in
    use, you can set the port via `FORWARD_DB_PORT=3307`.'
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`FORWARD_DB_PORT`：这是 Laravel Sail 用于公开 MySQL 服务的端口。默认情况下，MySQL 使用的端口是`3306`，但如果它已被占用，您可以通过`FORWARD_DB_PORT=3307`设置端口。'
- en: Once the `.env` configuration is good for you, you can start the Docker containers
    via Laravel Sail.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦`.env`配置对您来说良好，您就可以通过 Laravel Sail 启动 Docker 容器。
- en: 'To start Laravel Sail and launch the Docker container, use the following command:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 要启动 Laravel Sail 并启动 Docker 容器，请使用以下命令：
- en: '[PRE7]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The `-d` option allows you to execute Laravel Sail in the background, which
    is useful if you want to reuse the shell to launch other commands.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '`-d`选项允许您在后台执行 Laravel Sail，这在您想要重复使用 shell 来启动其他命令时非常有用。'
- en: 'To check that your database is up and running, you can execute the `php artisan
    db:show` command via `sail`:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 要检查您的数据库是否正常运行，您可以通过`sail`执行`php artisan db:show`命令：
- en: '[PRE8]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The first time you execute the `db:show` command, an additional package – the
    Doctrine `artisan` command. Once you run the `db:show` command, this is what you’ll
    see:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 第一次执行`db:show`命令时，会安装一个额外的包——Doctrine `artisan`命令。一旦您运行了`db:show`命令，您将看到以下内容：
- en: '![Figure 4.2: Executing the db:show command via Sail](img/Figure_4.02_B17728.jpg)'
  id: totrans-70
  prefs: []
  type: TYPE_IMG
  zh: '![图 4.2：通过 Sail 执行 db:show 命令](img/Figure_4.02_B17728.jpg)'
- en: 'Figure 4.2: Executing the db:show command via Sail'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.2：通过 Sail 执行 db:show 命令
- en: Now your database is up and running, so you can create your tables. We are going
    to execute migration to create the database tables. The database tables will contain
    your data – for example, the events.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您的数据库正在运行，因此您可以创建表。我们将执行迁移以创建数据库表。数据库表将包含您的数据——例如，事件。
- en: A migration file is a file where you can define the structure of your database
    table. In the migration file, you can list the columns of your table and define
    the type of the columns (string, integer, date, time, etc.).
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 迁移文件是一个您可以定义数据库表结构的文件。在迁移文件中，您可以列出表的列并定义列的类型（字符串、整数、日期、时间等）。
- en: Executing the migration
  id: totrans-74
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 执行迁移
- en: 'The Laravel framework provides out-of-the-box migrations specific to standard
    functionalities such as user and credential management. That’s why after installing
    the framework in the `database/migrations` directory you can find migration files
    already provided with the framework: the migrations to create a `users` table,
    a `password resets` table, a `failed jobs` table, and a `personal access` `tokens`
    table.'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: Laravel 框架提供了针对标准功能（如用户和凭证管理）的内置迁移。这就是为什么在将框架安装到`database/migrations`目录后，您可以在框架中找到已提供的迁移文件：创建`users`表、`password
    resets`表、`failed jobs`表和`personal access``tokens`表的迁移。
- en: The migration files are stored in the `database/migrations` directory.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 迁移文件存储在`database/migrations`目录中。
- en: 'To execute the migration in the Docker container, you can execute the `migrate`
    command via the command line:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 要在 Docker 容器中执行迁移，您可以通过命令行执行`migrate`命令：
- en: '[PRE9]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'This is what you’ll see:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是您会看到的：
- en: '![Figure 4.3: Executing migrations](img/Figure_4.03_B17728.jpg)'
  id: totrans-80
  prefs: []
  type: TYPE_IMG
  zh: '![图 4.3：执行迁移](img/Figure_4.03_B17728.jpg)'
- en: 'Figure 4.3: Executing migrations'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.3：执行迁移
- en: 'If you are not using Laravel Sail, and you are using the MySQL server installed
    in your local operating system (with Homebrew or your operating system packager
    or the MySQL server official installer), you can use `php artisan migrate` without
    the `sail` command:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你没有使用 Laravel Sail，并且你使用的是本地操作系统上安装的 MySQL 服务器（使用 Homebrew 或你的操作系统打包器或 MySQL
    服务器官方安装程序），你可以使用 `php artisan migrate` 命令而不需要 `sail` 命令：
- en: '[PRE10]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The schema of the database and the tables are created thanks to the migrations.
    Now we can install the MySQL client to access the database.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 数据库模式和表是通过迁移创建的。现在我们可以安装 MySQL 客户端来访问数据库。
- en: Installing MySQL client
  id: totrans-85
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 安装 MySQL 客户端
- en: To access the structure and the data of the database, it is recommended that
    you install a MySQL client. The MySQL client allows you to access the structure,
    the schema, and the data and allows you to execute SQL queries to extract data.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 要访问数据库的结构和数据，建议安装 MySQL 客户端。MySQL 客户端允许你访问结构、模式和数据，并允许你执行 SQL 查询以提取数据。
- en: 'You can choose one of the tools available; some are open source, and others
    are paid tools. The following shows some of the tools for managing MySQL structures
    and data:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以选择可用的工具之一；有些是开源工具，有些是付费工具。以下是一些用于管理 MySQL 结构和数据的工具：
- en: '**Sequel Ace** is open source, and is available for macOS: [https://github.com/Sequel-Ace/Sequel-Ace](https://github.com/Sequel-Ace/Sequel-Ace)'
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Sequel Ace** 是开源的，适用于 macOS：[https://github.com/Sequel-Ace/Sequel-Ace](https://github.com/Sequel-Ace/Sequel-Ace)'
- en: '**MySQL Workbench** is the official one and is available for all platforms:
    [https://www.mysql.com/products/workbench/](https://www.mysql.com/products/workbench/)'
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**MySQL Workbench** 是官方的，适用于所有平台：[https://www.mysql.com/products/workbench/](https://www.mysql.com/products/workbench/)'
- en: '**TablePlus** is available for Windows and macOS and supports a lot of databases:
    [https://tableplus.com/](https://tableplus.com/)'
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**TablePlus** 可用于 Windows 和 macOS，并支持许多数据库：[https://tableplus.com/](https://tableplus.com/)'
- en: If you select Sequel Ace or other tools, you have to set the right parameters
    during the initial connection, according to the `.``env` file.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你选择 Sequel Ace 或其他工具，你必须根据 `.env` 文件设置正确的参数进行初始连接。
- en: 'For example, the initial screen of Sequel Ace asks you for the hostname, the
    credential, the database name, and the port:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，Sequel Ace 的初始屏幕会要求你提供主机名、凭证、数据库名和端口号：
- en: '![Figure 4.4: The Sequel Ace login screen](img/Figure_4.04_B17728.jpg)'
  id: totrans-93
  prefs: []
  type: TYPE_IMG
  zh: '![图 4.4：Sequel Ace 登录界面](img/Figure_4.04_B17728.jpg)'
- en: 'Figure 4.4: The Sequel Ace login screen'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.4：Sequel Ace 登录界面
- en: 'As shown in *Figure 4**.4*, here are the values:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 如 *图 4**.4* 所示，以下是这些值：
- en: '`127.0.0.1`'
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`127.0.0.1`'
- en: '`DB_USERNAME` parameter in the `.``env` file'
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`.env` 文件中的 `DB_USERNAME` 参数'
- en: '`DB_PASSWORD` parameter in the `.``env` file'
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`.env` 文件中的 `DB_PASSWORD` 参数'
- en: '`DB_DATABASE` parameter in the `.``env` file'
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`.env` 文件中的 `DB_DATABASE` 参数'
- en: '`FORWARD_DB_PORT` parameter if you are using Laravel Sail, or `DB_PORT` if
    you are not using a local Docker container'
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你使用 Laravel Sail，则使用 `FORWARD_DB_PORT` 参数，如果不使用本地 Docker 容器，则使用 `DB_PORT`
    参数
- en: After installing the MySQL client, we’ll move on to talking about Sail versus
    the local tools.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 安装 MySQL 客户端后，我们将继续讨论 Sail 与本地工具的比较。
- en: Sail versus local tools
  id: totrans-102
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Sail 与本地工具的比较
- en: 'We looked at two methods for using PHP, services, and tools: using Docker containers
    (Laravel Sail) and using a local installation.'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 我们探讨了两种使用 PHP、服务和工具的方法：使用 Docker 容器（Laravel Sail）和使用本地安装。
- en: 'Once Sail is set up, if you want to launch commands via Sail, you have to prefix
    your command with `./vendor/bin/sail`. For example, if you want to list the PHP
    modules that are installed, the following command will list all PHP modules installed
    on your local operating system:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦设置好 Sail，如果你想通过 Sail 启动命令，你必须将你的命令前缀为 `./vendor/bin/sail`。例如，如果你想列出已安装的 PHP
    模块，以下命令将列出本地操作系统中安装的所有 PHP 模块：
- en: '[PRE11]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'If you use the `php -m` command with the `sail` tool, as shown in the following,
    the PHP modules installed in the Docker container will be shown:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用 `php -m` 命令与 `sail` 工具一起，如下所示，将显示 Docker 容器中安装的 PHP 模块：
- en: '[PRE12]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The Laravel Sail image provides you with the Swoole extension already installed
    and configured, so now you can add Octane to your application.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: Laravel Sail 镜像已经为你安装并配置了 Swoole 扩展，因此现在你可以将 Octane 添加到你的应用程序中。
- en: Adding Octane to your application
  id: totrans-109
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将 Octane 添加到你的应用程序中
- en: 'To add Laravel Octane to your application, you have to do the following:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 要将 Laravel Octane 添加到你的应用程序中，你必须执行以下操作：
- en: Add the Octane package
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加 Octane 包
- en: Create Octane configuration files
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建 Octane 配置文件
- en: Information
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 信息
- en: We already covered the Octane setup with Laravel Sail and Swoole in [*Chapter
    3*](B17728_03.xhtml#_idTextAnchor048), *Using the Swoole Application Server*.
    Let’s quickly recap all the steps for the Octane configuration needed by the example
    provided to you in the current chapter.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经在 [*第 3 章*](B17728_03.xhtml#_idTextAnchor048) 中介绍了使用 Laravel Sail 和 Swoole
    的 Octane 设置，即 *使用 Swoole 应用服务器*。现在让我们快速回顾一下当前章节提供的示例所需的 Octane 配置步骤。
- en: 'So, first of all, in the project directory, we are going to add the Laravel
    Octane package with the `composer` `require` command:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，首先，在项目目录中，我们将使用 `composer require` 命令添加 Laravel Octane 包：
- en: '[PRE13]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Then, we will create Octane configuration files with the `octane:install` command:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将使用 `octane:install` 命令创建 Octane 配置文件：
- en: '[PRE14]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Now that we have installed Laravel Octane, we have to configure Laravel to start
    the Swoole application server.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经安装了 Laravel Octane，我们必须配置 Laravel 以启动 Swoole 应用服务器。
- en: Activating Swoole as the application server
  id: totrans-120
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将 Swoole 作为应用服务器激活
- en: 'If you are using Laravel Sail, you have to activate Swoole to serve your Laravel
    application. The default Laravel Sail configuration launches the classical `php
    artisan serve` tool. So, the goal is to edit the configuration file where the
    `artisan serve` command is defined and replace it with the `octane:start` command.
    To do that, you have to copy the configuration file from the `vendor` directory
    to a directory where you can edit it. Laravel Sail provides you a publishing command
    to copy and generate the configuration file via the `sail:publish` command:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你正在使用 Laravel Sail，你必须激活 Swoole 来运行你的 Laravel 应用程序。默认的 Laravel Sail 配置启动了经典的
    `php artisan serve` 工具。因此，目标是编辑定义 `artisan serve` 命令的配置文件，并将其替换为 `octane:start`
    命令。为此，你需要将配置文件从 `vendor` 目录复制到一个你可以编辑它的目录。Laravel Sail 提供了一个发布命令，通过 `sail:publish`
    命令来复制并生成配置文件：
- en: '[PRE15]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The `publish` command generates the Docker directory and the `supervisord.conf`
    file. The `supervisord.conf` file has the responsibility of launching the web
    service to accept the HTTP request and generate the HTTP response. With Laravel
    Sail, the command that runs the web service is placed in the `supervisord.conf`
    file. Then, in the `docker/8.1/supervisord.conf` file (placed in the project directory),
    to launch Laravel Octane instead of the classical web server, replace the `artisan
    serve` command with `artisan octane:start` with all the correct parameters:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: '`publish` 命令生成 Docker 目录和 `supervisord.conf` 文件。`supervisord.conf` 文件负责启动网络服务以接受
    HTTP 请求并生成 HTTP 响应。在 Laravel Sail 中，运行网络服务的命令放置在 `supervisord.conf` 文件中。然后，在项目目录中的
    `docker/8.1/supervisord.conf` 文件（放置在项目目录中），为了启动 Laravel Octane 而不是经典的网络服务器，将 `artisan
    serve` 命令替换为带有所有正确参数的 `artisan octane:start`：'
- en: '[PRE16]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'With Laravel Sail, when you change any Docker configuration files, you must
    rebuild the images:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Laravel Sail，当你更改任何 Docker 配置文件时，你必须重新构建镜像：
- en: '[PRE17]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Then, restart Laravel Sail:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，重新启动 Laravel Sail：
- en: '[PRE18]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: If you open your browser to `http://127.0.0.1:8080/`, you will see your Laravel
    application served by Swoole.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你打开浏览器到 `http://127.0.0.1:8080/`，你会看到由 Swoole 运行的 Laravel 应用程序。
- en: Verifying your configuration
  id: totrans-130
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 验证你的配置
- en: Once you set up the tools and services, my suggestion is to be aware of the
    configuration used by the tools. With the PHP command, you have some options to
    check the installed module (useful to check whether a module is loaded correctly,
    for example, to check whether the Swoole module is loaded), and an option to see
    the current configuration of PHP.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦设置好工具和服务，我的建议是要注意工具使用的配置。使用 PHP 命令，你可以有一些选项来检查已安装的模块（例如，检查模块是否正确加载，例如检查 Swoole
    模块是否加载），以及查看 PHP 当前配置的选项。
- en: 'To check whether a module is installed or not, you can use the PHP command
    with the `-``m` option:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 要检查模块是否已安装，你可以使用带有 `-m` 选项的 PHP 命令：
- en: '[PRE19]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'To check whether Swoole is correctly loaded, you can filter just the lines
    with Swoole as the name (case-insensitive). To filter the lines, you can use the
    `grep` command. The `grep` command shows only the lines that match specific criteria:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 要检查 Swoole 是否正确加载，你可以过滤出以 Swoole 为名称的行（不区分大小写）。要过滤行，你可以使用 `grep` 命令。`grep` 命令只显示符合特定标准的行：
- en: '[PRE20]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'If you want to list all the PHP configurations, you can use the `-``i` option:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要列出所有 PHP 配置，你可以使用带有 `-i` 选项的 PHP 命令：
- en: '[PRE21]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'If you want to change something in your configuration, you might want to see
    where the configuration (`.ini`) files are located. To see where the `.ini` files
    are located, filter just the `ini` string:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要更改配置中的某些内容，你可能想查看配置（`.ini`）文件的位置。要查看 `.ini` 文件的位置，只需过滤 `ini` 字符串：
- en: '[PRE22]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'You will see something like this:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 你将看到类似以下内容：
- en: '[PRE23]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'With the `php -i` command, you can obtain information about where the `php.ini`
    file is located. If you are using Laravel Sail, you can execute the following
    command:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `php -i` 命令，你可以获取有关 `php.ini` 文件位置的详细信息。如果你使用 Laravel Sail，你可以执行以下命令：
- en: '[PRE24]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'You will see that there is a specific `.ini` file for Swoole:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 你将看到有一个特定的 `.ini` 文件用于 Swoole：
- en: '[PRE25]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'If you want to access that file to check it or edit it, you can jump into the
    running container via the `shell` command:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要访问该文件以检查或编辑它，你可以通过 `shell` 命令跳转到运行中的容器：
- en: '[PRE26]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'With this command, it will show the shell prompt of the running container,
    and you can show the content of the file there:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 使用此命令，它将显示运行容器的 shell 提示符，你可以在那里查看文件内容：
- en: '[PRE27]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'The command will show you the content of the `25-swoole.ini` configuration
    file. The content of the file is as follows:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 命令将显示 `25-swoole.ini` 配置文件的内容。文件内容如下：
- en: '[PRE28]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'If you want to disable Swoole, you can add the `;` character at the beginning
    of the `extension` directive, as follows:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要禁用 Swoole，你可以在 `extension` 指令的开头添加 `;` 字符，如下所示：
- en: '[PRE29]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: With the `;` character at the beginning, the extension is not loaded.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 在开头使用 `;` 字符，则扩展不会加载。
- en: Summarizing installation and setup
  id: totrans-155
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 总结安装和设置
- en: 'Before proceeding with implementation, let me summarize the previous steps:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续实施之前，让我总结一下之前的步骤：
- en: We installed our Laravel application.
  id: totrans-157
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们安装了我们的 Laravel 应用程序。
- en: We added a database service.
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们添加了一个数据库服务。
- en: We configured a MySQL client to access the MySQL server.
  id: totrans-159
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们配置了一个 MySQL 客户端以访问 MySQL 服务器。
- en: We added the Octane package and configuration.
  id: totrans-160
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们添加了 Octane 包和配置。
- en: We added Swoole as the application server.
  id: totrans-161
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们添加了 Swoole 作为应用程序服务器。
- en: We checked the configuration.
  id: totrans-162
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们检查了配置。
- en: So, now we can start using some Octane functionalities such as executing heavy
    tasks in a parallel and async way.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，现在我们可以开始使用一些 Octane 功能，例如以并行和异步的方式执行重任务。
- en: Creating a dashboard application
  id: totrans-164
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建仪表板应用程序
- en: In an application, you can have multiple kinds of data stored in multiple tables.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 在一个应用程序中，你可以在多个表中存储多种类型的数据。
- en: Typically, on the product list page, you have to retrieve a list of products
    by executing a query to retrieve products.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，在产品列表页面上，你必须执行一个查询来检索产品列表。
- en: Or, in a dashboard, maybe you could show multiple charts or tables to show some
    data from your database. If you want to show more charts on the same page, you
    have to perform more than one query on more than one table.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，在一个仪表板中，也许你可以显示多个图表或表格来显示数据库中的某些数据。如果你想在同一页面上显示更多图表，你必须对多个表执行多个查询。
- en: You might execute one query at a time; this means that the total time for retrieving
    all the useful information for composing the dashboard is the sum of the execution
    times of all the queries involved.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能一次执行一个查询；这意味着检索用于组成仪表板的所有有用信息的总时间是所有涉及查询的执行时间的总和。
- en: Running more than one query at the same time would reduce the total time to
    retrieve all the information.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 同时运行多个查询将减少检索所有信息的总时间。
- en: To demonstrate this, we will create an `events` table where we will store some
    events with a timestamp for the user.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 为了演示这一点，我们将创建一个 `events` 表，我们将存储一些带有用户时间戳的事件。
- en: Creating an events table
  id: totrans-171
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建一个事件表
- en: When you are creating a table in Laravel, you have to use a migration file.
    A migration file contains the logic to create the table and all fields. It contains
    all the instructions to define the structure of your table. To manage the logic
    for using the data stored in the table, you might need other things such as the
    `model` and `seeder` classes.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 当你在 Laravel 中创建一个表时，你必须使用迁移文件。迁移文件包含创建表和所有字段的逻辑。它包含定义你表结构的所有指令。为了管理使用存储在表中的数据的逻辑，你可能还需要其他一些东西，例如
    `model` 和 `seeder` 类。
- en: The `model` class allows the developer to access the data and provides some
    methods for saving, deleting, loading, and querying data.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: '`model` 类允许开发者访问数据，并提供了一些保存、删除、加载和查询数据的方法。'
- en: The `seeder` class is used to fill the table with initial values or sample values.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: '`seeder` 类用于用初始值或示例值填充表。'
- en: 'To create the `model` class, the `seeder` class, and the migration file, you
    can use the `make:model` command with the `m` (create a migration file) and `s`
    (create a `seeder` class) parameters:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建`model`类、`seeder`类和迁移文件，您可以使用带有`m`（创建迁移文件）和`s`（创建`seeder`类）参数的`make:model`命令：
- en: '[PRE30]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'With the `make:model` command and the `m` and `s` parameters, three files are
    created:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`make:model`命令和`m`以及`s`参数，将创建三个文件：
- en: The migration file is created in `database/migration/`, with the name consisting
    of the timestamp as the prefix and `create_events_table` as the suffix, for example,
    `2022_08_22_210043_create_events_table.php`
  id: totrans-178
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 迁移文件创建在`database/migration/`目录下，文件名以时间戳为前缀，以`create_events_table`为后缀，例如，`2022_08_22_210043_create_events_table.php`
- en: The `model` class in `app/Models/Event.php`
  id: totrans-179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`app/Models/Event.php`中的`model`类'
- en: The `seeder` class file in `app/database/seeders/EventSeeder.php`
  id: totrans-180
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`app/database/seeders/EventSeeder.php`中的`seeder`类文件'
- en: Customizing the migration file
  id: totrans-181
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 自定义迁移文件
- en: 'The `make:model` command creates a template file for creating the table with
    basic fields such as `id` and `timestamps`. The developer must add the fields
    specific to the application. In the dashboard application, we are going to add
    these fields:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: '`make:model`命令创建了一个用于创建表的模板文件，其中包含基本的字段，如`id`和`timestamps`。开发人员必须添加特定于应用程序的字段。在仪表板应用程序中，我们将添加以下字段：'
- en: '`user_id`: For the external reference with the `users` table, a user could
    be related to more events'
  id: totrans-183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`user_id`: 对于与`users`表的外部引用，一个用户可以关联到多个事件'
- en: '`type`: An event type could be `INFO`, `WARNING`, or `ALERT`'
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`type`: 事件类型可以是`INFO`、`WARNING`或`ALERT`'
- en: '`description`: Text containing the description of the event'
  id: totrans-185
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`description`: 事件描述文本'
- en: '`value`: An integer from `1` to `10`'
  id: totrans-186
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`value`: 从`1`到`10`的整数'
- en: '`date`: The event date and time'
  id: totrans-187
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`date`: 事件日期和时间'
- en: 'To create the table, an example of the migration file is as follows:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 创建表的迁移文件示例如下：
- en: '[PRE31]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: You can list the fields you want to add to the table in the `up()` method. In
    the code, we are adding the foreign ID for the user table, the type, the description,
    the value, and the date. The `down()` method typically is used to drop the table.
    The `up()` method is called when the developer wants to execute the migrations,
    and the `down()` method is called when the developer wants to roll back the migration.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在`up()`方法中列出您想要添加到表中的字段。在代码中，我们正在添加用户表的 foreign ID、类型、描述、值和日期。`down()`方法通常用于删除表。`up()`方法在开发人员想要执行迁移时调用，而`down()`方法在开发人员想要回滚迁移时调用。
- en: Seeding data
  id: totrans-191
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 播种数据
- en: With the `seeder` file, you can create the initial data to fill the table. For
    testing purposes, you can fill the table with fake data. Laravel provides you
    with a great helper, `fake()`, for creating fake data.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`seeder`文件，您可以创建初始数据以填充表。出于测试目的，您可以用假数据填充表。Laravel为您提供了创建假数据的出色辅助工具，`fake()`。
- en: The fake() helper
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: fake()辅助工具
- en: For generating fake data, the `fake()` helper uses the **Faker** library. The
    home page of the library is at [https://fakerphp.github.io/](https://fakerphp.github.io/).
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 对于生成假数据，`fake()`辅助工具使用**Faker**库。该库的首页在[https://fakerphp.github.io/](https://fakerphp.github.io/)。
- en: Now, we are going to create fake data for users and events.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将为用户和事件创建假数据。
- en: To create fake users, you can create the `app/database/seeders/UserSeeder.php`
    file.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建假用户，您可以创建`app/database/seeders/UserSeeder.php`文件。
- en: 'In the example, we will do the following:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 在示例中，我们将执行以下操作：
- en: Generate a random name via `fake()->firstName()`
  id: totrans-198
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过`fake()->firstName()`生成随机姓名
- en: Generate a random email via `fake()->email()`
  id: totrans-199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过`fake()->email()`生成随机电子邮件
- en: Generate a random hashed password with `Hash::make(fake()->password())`
  id: totrans-200
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`Hash::make(fake()->password())`生成随机散列密码
- en: We will generate 1,000 users, so we will use a `for` loop.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将生成1,000个用户，因此我们将使用`for`循环。
- en: 'You have to generate data and call `User::insert()` to generate data in the
    `run()` method of the `UserSeeder` class:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 您必须在`UserSeeder`类的`run()`方法中生成数据并调用`User::insert()`来生成数据：
- en: '[PRE32]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'With the `UserSeeder` class, we are going to create 1,000 users. Then, once
    we have the users in the `user` table, we are going to create 100,000 events:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`UserSeeder`类，我们将创建1,000个用户。然后，一旦我们在`user`表中有了用户，我们将创建100,000个事件：
- en: '[PRE33]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'To create fake events, we need to fill the event fields using the `fake()`
    helper. The fields filled for the `events` table are as follows:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建假事件，我们需要使用`fake()`辅助工具填写事件字段。为`events`表填写的字段如下：
- en: '`user_id`: We will generate a random number from `1` to `1000`'
  id: totrans-207
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`user_id`: 我们将从`1`到`1000`生成一个随机数'
- en: '`type`: We will use the `Arr:random()` helper from Laravel to select one of
    these values: `''ALERT''`, `''WARNING''`, or `''INFO''`'
  id: totrans-208
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`type`：我们将使用Laravel的`Arr:random()`辅助函数从以下值中选择一个：`''ALERT''`、`''WARNING''`或`''INFO''`'
- en: '`description`: A random text from the `fake()` helper'
  id: totrans-209
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`description`：来自`fake()`辅助函数的随机文本'
- en: '`value`: A random integer from `1` to `10`'
  id: totrans-210
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`value`：从`1`到`10`的随机整数'
- en: '`date`: A date function provided by a `fake()` helper for generating a day
    from the current year, `dateTimeThisYear()`'
  id: totrans-211
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`date`：由`fake()`辅助函数提供的日期函数，用于从当前年份生成一天，`dateTimeThisYear()`'
- en: Like we did for the `users` table, we are using the chunking approach to try
    to improve the speed of the execution of the data generator. For large arrays,
    the chunking approach allows the code to be more performant because it involves
    dividing the array into chunks and handling the chunks instead of each record
    individually. This reduces the number of insertions made to the database.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 就像我们对`users`表所做的那样，我们正在使用分块方法来尝试提高数据生成器的执行速度。对于大型数组，分块方法允许代码更高效，因为它涉及将数组分成块并处理这些块，而不是逐条记录。这减少了数据库中的插入次数。
- en: Improving the speed of the seed operation
  id: totrans-213
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 提高种子操作的速度
- en: Generating a lot of data requires thinking about the cost in terms of *time
    spent* on the operations.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 生成大量数据需要考虑操作的成本，即*花费的时间*。
- en: 'The two most expensive operations used for data seeding (via the `UserSeeder`
    class) during the creation of the initial user data are as follows:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建初始用户数据时，用于数据种子（通过`UserSeeder`类）的两个最昂贵的操作如下：
- en: '`Hash::make()` takes a fraction of a second because it is CPU-intensive. If
    you repeat this operation multiple times, in the end, it takes seconds to be executed.'
  id: totrans-216
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Hash::make()`只需要很短的时间，因为它非常占用CPU。如果你多次重复这个操作，最终它需要几秒钟才能执行。'
- en: '`array_chunk` can help you reduce the number of calls to the `insert()` method.
    Consider that the `insert()` method can accept an array of items (multiple rows
    to insert). Using `insert()` with an array as an argument is much faster in the
    execution than calling `insert()` for every single row. Each `insert()` execution
    under the hood (at the database level) has to prepare the transaction operation
    for the insert, insert the row in the table, adjust all indexes and all metadata
    for the table, and close the transaction. In other words, each `insert()` operation
    has some overhead time that you have to consider when you want to call it multiple
    times. That means each `insert()` operation has an additional overhead cost to
    ensure that the operation is self-consistent. Reducing the number of such operations
    reduces the total time of the additional operations.'
  id: totrans-217
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`array_chunk`可以帮助你减少对`insert()`方法的调用次数。考虑一下，`insert()`方法可以接受一个项目数组（插入多行）。使用数组作为参数调用`insert()`比逐行调用`insert()`要快得多。在底层（数据库级别）的每次`insert()`执行都需要为插入准备事务操作，将行插入表中，调整表的所有索引和所有元数据，并关闭事务。换句话说，每次`insert()`操作都有一些开销时间，当你想要多次调用它时必须考虑。这意味着每次`insert()`操作都有额外的开销成本来确保操作的一致性。减少这种操作的次数可以减少额外操作的总时间。'
- en: 'So, in order to improve the performance in data creation (seeding), we can
    make some assumptions and we can implement these approaches:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，为了提高数据创建（种子）的性能，我们可以做一些假设并实现以下方法：
- en: To create multiple users, it is fine to have the same password for all users.
    We don’t have to implement a sign-in process, we just need a list of users.
  id: totrans-219
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要创建多个用户，所有用户使用相同的密码是可以接受的。我们不需要实现一个登录过程，只需要一个用户列表。
- en: We can create an array of users, and then use the chunking approach for inserting
    chunks of data (for 1,000 users we insert 10 chunks of 100 users each).
  id: totrans-220
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以创建一个用户数组，然后使用分块方法来插入数据块（对于1,000个用户，我们插入10个包含100个用户的块）。
- en: 'So, in the previous snippet of code for creating users, we used these two kinds
    of optimizations: reducing the number of hash calls and using `array_chunk`.'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在创建用户的前一个代码片段中，我们使用了这两种优化方法：减少哈希调用次数和使用`array_chunk`。
- en: In some scenarios, you have to insert and load a huge amount of data into the
    database. In this case, my suggestion is to load data using some specific features
    provided by the database, instead of trying to optimize your code.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些场景中，你必须将大量数据插入和加载到数据库中。在这种情况下，我的建议是使用数据库提供的某些特定功能来加载数据，而不是尝试优化你的代码。
- en: For example, if you have a multitude of data to load and or transfer from another
    database, in the case of MySQL, there are two tools.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果你有大量数据要加载或从另一个数据库传输，在 MySQL 的情况下，有两种工具。
- en: 'The first option is using the `INTO` `OUTFILE` option:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个选项是使用 `INTO` `OUTFILE` 选项：
- en: '[PRE34]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Before doing that, you have to be sure that MySQL is allowing you to perform
    this operation.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 在做之前，你必须确保 MySQL 允许你执行此操作。
- en: Because we will export a huge quantity of data in a directory, we have to list
    this directory as permitted in the MySQL configuration.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 因为我们将在一个目录中导出大量数据，我们必须在 MySQL 配置中将此目录列为允许的。
- en: In the `my.cnf` file (the configuration file for MySQL), be sure that there
    is a `secure-file-priv` directive. The value of this directive would be a directory
    where you can export and import the file.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `my.cnf` 文件（MySQL 的配置文件）中，务必确保存在 `secure-file-priv` 指令。此指令的值将是一个你可以导出和导入文件的目录。
- en: 'If you are using Laravel Sail, `secure-file-priv` is already set to a directory:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用 Laravel Sail，`secure-file-priv` 已经设置为一个目录：
- en: '[PRE35]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'In the case of Homebrew, the configuration file is located in the following:
    `/opt/homebrew/etc/my.cnf`.'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Homebrew 的情况下，配置文件位于以下位置：`/opt/homebrew/etc/my.cnf`。
- en: 'For example, the `my.cnf` file could have this structure:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，`my.cnf` 文件可能有以下结构：
- en: '[PRE36]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'In this case, the directory for exporting data and files is `"/Users/roberto"`:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，导出数据和文件的目录是 `"/Users/roberto"`：
- en: '![Figure 4.5: The secure-file-priv directive of MySQL](img/Figure_4.05_B17728.jpg)'
  id: totrans-235
  prefs: []
  type: TYPE_IMG
  zh: '![图 4.5：MySQL 的 secure-file-priv 指令](img/Figure_4.05_B17728.jpg)'
- en: 'Figure 4.5: The secure-file-priv directive of MySQL'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.5：MySQL 的 secure-file-priv 指令
- en: This directive exists for security reasons, so before making this edit, make
    your evaluation. In the case of the production environment, I disable that directive
    (set as an empty string). In local development environments, this configuration
    could be acceptable, or at least activate this option only when you need it.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 这个指令存在是出于安全原因，所以在进行此编辑之前，请进行评估。在生产环境中，我禁用该指令（将其设置为空字符串）。在本地开发环境中，此配置可能是可接受的，或者至少只在需要时激活此选项。
- en: 'After this configuration change, you have to reload the MySQL server. In the
    case of Homebrew, use the following:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 在此配置更改后，你必须重新加载 MySQL 服务器。在 Homebrew 的情况下，使用以下命令：
- en: '[PRE37]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Now you can execute an `artisan` command (`php artisan db`) to access the database.
    You don’t need to specify the database name, username, or password because the
    command uses the Laravel configuration (the `DB_` parameters in `.env`):'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你可以执行一个 `artisan` 命令（`php artisan db`）来访问数据库。你不需要指定数据库名称、用户名或密码，因为该命令使用 Laravel
    配置（`.env` 中的 `DB_` 参数）：
- en: '[PRE38]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'In the MySQL prompt that is shown after you launched the `artisan db` command,
    you can, for example, export data using the `SELECT` syntax:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 在启动 `artisan db` 命令后显示的 MySQL 提示符中，你可以使用 `SELECT` 语法导出数据，例如：
- en: '[PRE39]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: You will see that exporting thousands and thousands of records will take just
    a few milliseconds.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 你会看到导出成千上万条记录只需几毫秒。
- en: 'If you are using Laravel Sail, as usual, you have to launch `php artisan` through
    the `sail` command:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用 Laravel Sail，像往常一样，你必须通过 `sail` 命令启动 `php artisan`：
- en: '[PRE40]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'In the MySQL Docker prompt use the following:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 在 MySQL Docker 提示符中使用以下命令：
- en: '[PRE41]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'If you want to load a file that previously exported my `SELECT` statement,
    you can use `LOAD DATA`:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要加载之前导出的 `SELECT` 语句的文件，你可以使用 `LOAD DATA`：
- en: '[PRE42]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Again, you will see that this command will take a few milliseconds to import
    thousands and thousands of records:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，你会看到这个命令将花费几毫秒来导入成千上万条记录：
- en: '![Figure 4.6: With LOAD DATA, you can boost the loading data process](img/Figure_4.06_B17728.jpg)'
  id: totrans-252
  prefs: []
  type: TYPE_IMG
  zh: '![图 4.6：使用 LOAD DATA 可以加速加载数据的过程](img/Figure_4.06_B17728.jpg)'
- en: 'Figure 4.6: With LOAD DATA, you can boost the loading data process'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.6：使用 LOAD DATA 可以加速加载数据的过程
- en: So, in the end, you have more than one way to boost the loading data process.
    I suggest using `LOAD DATA` when you have MySQL, and you can obtain data exported
    via `SELECT`. Another scenario is when, as a developer, you receive a huge data
    file from someone else, and you can agree with the file format. Or, if you already
    know that you will have to load huge amounts of data multiple times for testing
    purposes, you could evaluate creating a huge file once (for example, with the
    `fake()` helper) and then use the file every time you want to seed the MySQL database.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，最终你有多种方法可以提升加载数据的过程。我建议当你使用 MySQL 时使用 `LOAD DATA`，并且你可以通过 `SELECT` 获取导出的数据。另一种情况是，作为开发者，你从其他人那里收到一个巨大的数据文件，并且你可以同意文件格式。或者，如果你已经知道你将需要多次加载大量数据以进行测试，你可以评估一次性创建一个巨大的文件（例如，使用
    `fake()` 辅助函数），然后每次你想对 MySQL 数据库进行初始化时都使用该文件。
- en: Executing the migrations
  id: totrans-255
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 执行迁移
- en: Now, before implementing the query to retrieve data, we have to run the migration
    and the seeders.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在实现检索数据的查询之前，我们必须运行迁移和种子。
- en: So, in the previous sections, we covered how to create seeders and migration
    files.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在前面的章节中，我们介绍了如何创建种子文件和迁移文件。
- en: 'To control which seeder has to be loaded and executed, you have to list the
    seeders in the `database/seeders/DatabaseSeeder.php` file, in the `run()` method.
    You have to list the seeders in this way:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 要控制哪些种子需要被加载和执行，你必须在 `database/seeders/DatabaseSeeder.php` 文件中的 `run()` 方法中列出种子。你必须这样列出种子：
- en: '[PRE43]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'To create tables and load data with one command, use this:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用一条命令创建表和加载数据，请使用以下命令：
- en: '[PRE44]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'If you already executed the migration and you want to recreate them from scratch,
    you can use `migrate:refresh`:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你已经执行了迁移，并且想要从头开始重新创建它们，可以使用 `migrate:refresh`：
- en: '[PRE45]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Or you can use the `migrate:fresh` command, which drops tables instead of executing
    the rollback:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，你可以使用 `migrate:fresh` 命令，它删除表而不是执行回滚：
- en: '[PRE46]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: Note
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: The `migrate:refresh` command will execute all `down()` functions of your migrations.
    Usually, in the `down()` method, the `dropIfExists()` method (for dropping the
    table) is called, so your table will be cleaned and your data will be lost before
    being created again from scratch.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: '`migrate:refresh` 命令将执行你的迁移中的所有 `down()` 函数。通常，在 `down()` 方法中，会调用 `dropIfExists()`
    方法（用于删除表），因此你的表将在从头开始创建之前被清理，你的数据也将丢失。'
- en: Now that you have your tables and data created, we will load the data via a
    query from the controller. Let’s see how.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经创建了表和数据，我们将通过控制器中的查询来加载数据。让我们看看如何操作。
- en: The routing mechanism
  id: totrans-269
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 路由机制
- en: As a practical exercise, we want to build a dashboard. A dashboard collects
    some information from our `events` table. We have to run multiple queries to collect
    some data to render the dashboard blade view.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一项实际练习，我们想要构建一个仪表板。仪表板从我们的 `events` 表中收集一些信息。我们必须运行多个查询来收集一些数据以渲染仪表板视图。
- en: 'In the example, we will do the following:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 在示例中，我们将执行以下操作：
- en: Define two routes for `/dashboard` and `/dashboard-concurrent`. The first one
    is for sequential queries, and the second one is for concurrent queries.
  id: totrans-272
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定义两个路由，用于 `/dashboard` 和 `/dashboard-concurrent`。第一个用于顺序查询，第二个用于并发查询。
- en: Define a controller named `DashboardController` with two methods – `index()`
    (for the sequential queries) and `indexConcurrent()` (for the concurrent queries).
  id: totrans-273
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定义一个名为 `DashboardController` 的控制器，包含两个方法 - `index()`（用于顺序查询）和 `indexConcurrent()`（用于并发查询）。
- en: 'Define four queries: one for counting the rows in the `events` table, and three
    queries for retrieving the last five events that include a specific term in the
    description field (in the example we are looking for the strings that include
    the term `something`), for each event type (`''INFO''`, `''WARNING''`, and `''ALERT''`).'
  id: totrans-274
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定义四个查询：一个用于计算 `events` 表中的行数，以及三个查询用于检索描述字段中包含特定术语（在示例中我们寻找包含术语 `something`
    的字符串）的最后五个事件，对于每种事件类型（`'INFO'`、`'WARNING'` 和 `'ALERT'`）。
- en: Define a view to show the result of the queries.
  id: totrans-275
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定义一个视图来显示查询的结果。
- en: Using the Octane routes
  id: totrans-276
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用 Octane 路由
- en: Octane provides an implementation of a routing mechanism.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: Octane 提供了路由机制的实现。
- en: The routing mechanism provided by Octane (`Octane::route()`) is lighter than
    the classic Laravel routing mechanism (`Route::get()`). The Octane routing mechanism
    is faster because it skips all the full features provided by Laravel routes such
    as middleware. Middleware is a way of adding functionalities when a route is invoked,
    but it takes time to call and manage this software layer.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: Octane 提供的路由机制（`Octane::route()`）比经典 Laravel 路由机制（`Route::get()`）更轻量。Octane
    路由机制更快，因为它跳过了 Laravel 路由提供的所有完整功能，如中间件。中间件是在路由被调用时添加功能的一种方式，但它需要时间来调用和管理这个软件层。
- en: To call Octane routes, you can use the `Octane::route()` method. The `route()`
    method has three parameters. The first parameter is the HTTP method (for example
    `'GET'`, `'POST'`, etc.), the second parameter is the path (such as ‘`/dashboard`’),
    and the third parameter is a function that returns the `Response` object.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 要调用 Octane 路由，你可以使用 `Octane::route()` 方法。`route()` 方法有三个参数。第一个参数是 HTTP 方法（例如
    `'GET'`, `'POST'`, 等），第二个参数是路径（例如 ‘`/dashboard`’），第三个参数是一个返回 `Response` 对象的函数。
- en: 'Now that we understand the syntax differences between `Route::get()` and `Octane::route()`,
    we can modify the last code snippet by replacing `Route::get()` with `Octane::route()`:'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了 `Route::get()` 和 `Octane::route()` 之间的语法差异，我们可以通过将 `Route::get()`
    替换为 `Octane::route()` 来修改最后的代码片段：
- en: '[PRE47]'
  id: totrans-281
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'If you want to test how much faster the Octane routing mechanism is than the
    Laravel routing mechanism, create two routes: the first one served by Octane,
    and the second one served by the Laravel route. You will see that the response
    is very fast because the application inherits all the benefits that come from
    all the Octane framework loader mechanisms, and the `Octane::route` also optimizes
    the routing part. The code creates two routes, `/a` and `/b`. The `/a` route is
    managed via the Octane routing mechanism, and the `/b` route is managed via the
    classic routing mechanism:'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想测试 Octane 路由机制比 Laravel 路由机制快多少，创建两个路由：第一个由 Octane 服务，第二个由 Laravel 路由服务。你会看到响应非常快，因为应用程序继承了来自所有
    Octane 框架加载机制的所有好处，`Octane::route` 也优化了路由部分。代码创建了两个路由，`/a` 和 `/b`。`/a` 路由由 Octane
    路由机制管理，`/b` 路由由经典路由机制管理：
- en: '[PRE48]'
  id: totrans-283
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: If you compare the two requests by calling it via the browser and checking the
    response time, you will see that the `/a` route is faster than the `/b` route
    (on my local machine, it is 50% faster) because of `Octane::route()`.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你通过浏览器调用并检查响应时间来比较这两个请求，你会看到 `/a` 路由比 `/b` 路由快（在我的本地机器上，快 50%），这是因为 `Octane::route()`。
- en: Now that the routes are set up, we can focus on the controller.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 现在路由已经设置好了，我们可以专注于控制器。
- en: Creating the controller
  id: totrans-286
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建控制器
- en: 'Now we are going to create a controller, `DashboardController`, with two methods:
    `index()` and `indexConcurrent()`.'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将创建一个控制器，名为 `DashboardController`，包含两个方法：`index()` 和 `indexConcurrent()`。
- en: 'In the `app/Http/Controllers/` directory, create a `DashboardController.php`
    file with the following content:'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `app/Http/Controllers/` 目录下，创建一个 `DashboardController.php` 文件，内容如下：
- en: '[PRE49]'
  id: totrans-289
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: We just created the controller’s methods, so they are just loading the view.
    Now we are going to add some logic in the methods, creating a query in the model
    file and calling it from the controllers.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚刚创建了控制器的这些方法，所以它们只是加载视图。现在我们将在方法中添加一些逻辑，在模型文件中创建一个查询，并从控制器中调用它。
- en: Creating the query
  id: totrans-291
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建查询
- en: To allow the controller to load data, we are going to implement the `events`
    table. To do that, we are going to use the query scope mechanism provided by Laravel.
    The query scope allows you to define the logic in the model and reuse it in your
    application.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 为了允许控制器加载数据，我们将实现 `events` 表。为此，我们将使用 Laravel 提供的查询作用域机制。查询作用域允许你在模型中定义逻辑并在你的应用程序中重用它。
- en: 'The query scope we are going to implement will be placed in the `scopeOfType()`
    method in the `Event` model class. The `scopeOfType()` method allows you to extend
    the functionalities of the `Event` model and add a new method, `ofType()`:'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要实现的查询作用域将被放置在 `Event` 模型类中的 `scopeOfType()` 方法中。`scopeOfType()` 方法允许你扩展
    `Event` 模型的功能并添加一个新的方法，`ofType()`：
- en: '[PRE50]'
  id: totrans-294
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: The `Event` model file is located in the `app/Models` directory. The file is
    `Event.php`.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: '`Event` 模型文件位于 `app/Models` 目录下。文件名为 `Event.php`。'
- en: The query returns the event type defined as an argument (`$type`) and selects
    the rows where the description contains the word `something` (through the `'``LIKE'`
    operator).
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 查询返回定义为参数的事件类型（`$type`），并选择描述中包含单词 `something` 的行（通过 `'``LIKE'` 操作符）。
- en: In the end, we are going to sort the data by date (`orderBy`) and limit it to
    five records (`limit`).
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将按日期排序数据（`orderBy`）并限制为五条记录（`limit`）。
- en: In order to highlight the benefits of the optimizations we are going to implement,
    I am going to add a 1-second `sleep` function to simulate a time-consuming operation.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 为了突出我们即将实施的优化的好处，我将添加一个 1 秒的 `sleep` 函数来模拟耗时操作。
- en: The DashboardController file
  id: totrans-299
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '`DashboardController` 文件'
- en: 'Now we can open again the `DashboardController` file and implement the logic
    to call the four queries – the first one for counting the events:'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以再次打开 `DashboardController` 文件并实现调用四个查询的逻辑——第一个用于计算事件数量：
- en: '[PRE51]'
  id: totrans-301
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'The second one is for retrieving the events with the defined query via the
    `ofType` function for events with the `''``INFO''` type:'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个是使用 `ofType` 函数通过定义的查询检索具有 `'``INFO'` 类型的事件：
- en: '[PRE52]'
  id: totrans-303
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'The third one is for retrieving the `''``WARNING''` event:'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 第三个是用于检索 `'``WARNING'` 事件：
- en: '[PRE53]'
  id: totrans-305
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'The last one is for retrieving the `''``ALERT''` event:'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一个是用于检索 `'``ALERT'` 事件：
- en: '[PRE54]'
  id: totrans-307
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'Let’s put it all together in the controller `index()` method to call the queries
    sequentially:'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在控制器 `index()` 方法中将所有这些放在一起，以顺序调用查询：
- en: '[PRE55]'
  id: totrans-309
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: The `hrtime()` method is used for measuring the execution time of all four queries.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: '`hrtime()` 方法用于测量所有四个查询的执行时间。'
- en: Then, after all the queries are executed, the `dashboard.index` view is called.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在所有查询执行完毕后，调用 `dashboard.index` 视图。
- en: Now, in the same way, we will create the `indexConcurrent()` method, where the
    queries are executed in parallel via the `Octane::concurrently()` method.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，以同样的方式，我们将创建 `indexConcurrent()` 方法，其中查询通过 `Octane::concurrently()` 方法并行执行。
- en: The `Octane::concurrently()` method has two parameters. The first one is the
    array of tasks. A task is an anonymous function. The anonymous function can return
    a value. The `concurrently()` method returns an array of values (the returned
    values of the task array). The second parameter is the amount of time in milliseconds
    that `concurrently()` waits for the completion of the task. If a task takes more
    time than the second parameter (milliseconds), the `concurrently()` function will
    raise a `TaskTimeoutException` exception.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: '`Octane::concurrently()` 方法有两个参数。第一个是任务数组。一个任务是一个匿名函数。匿名函数可以返回一个值。`concurrently()`
    方法返回一个值数组（任务数组的返回值）。第二个参数是 `concurrently()` 等待任务完成的毫秒数。如果一个任务花费的时间超过第二个参数（毫秒），`concurrently()`
    函数将抛出 `TaskTimeoutException` 异常。'
- en: 'The implementation of the `indexConcurrent()` method is located in the `DashboardController`
    class:'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: '`indexConcurrent()` 方法的实现位于 `DashboardController` 类中：'
- en: '[PRE56]'
  id: totrans-315
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'To use `TaskTimeoutException` correctly, you have to import the class:'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 要正确使用 `TaskTimeoutException`，你必须导入该类：
- en: '[PRE57]'
  id: totrans-317
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: The last thing you have to implement to render the pages is the view.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，你需要实现以渲染页面的是视图。
- en: Rendering the view
  id: totrans-319
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 渲染视图
- en: 'In the controller, the last instruction of each method is returning the view:'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 在控制器中，每个方法的最后一条指令是返回视图：
- en: '[PRE58]'
  id: totrans-321
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: The `view()` function loads the `resources/views/dashboard/index.blade.php`
    file (`dashboard.index`). To share data from the controller to the view, we are
    going to send some arguments to the `view()` function, such as `$count`, `$eventsInfo`,
    `$eventsWarning`, `$eventsAlert`, and `$time`.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: '`view()` 函数加载 `resources/views/dashboard/index.blade.php` 文件（`dashboard.index`）。为了从控制器向视图共享数据，我们将向
    `view()` 函数发送一些参数，例如 `$count`、`$eventsInfo`、`$eventsWarning`、`$eventsAlert` 和
    `$time`。'
- en: 'The view is an HTML template that uses Blade syntax to show variables such
    as `$count`, `$eventsInfo`, `$eventsWarning`, `$eventsAlert`, and `$time`:'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 视图是一个使用 Blade 语法显示变量（如 `$count`、`$eventsInfo`、`$eventsWarning`、`$eventsAlert`
    和 `$time`）的 HTML 模板：
- en: '[PRE59]'
  id: totrans-324
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'The view inherits the layout (via the `x-layout` directive) so you can create
    the `resources/views/components/layout.blade.php` file:'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 视图继承布局（通过 `x-layout` 指令），因此你可以创建 `resources/views/components/layout.blade.php`
    文件：
- en: '[PRE60]'
  id: totrans-326
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: Now you have the data in your database, the query in the `model` class, and
    the controller that loads the data via the model and sends data to the view, and
    the view template file.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经拥有了数据库中的数据，`model` 类中的查询，以及通过模型加载数据并发送数据到视图的控制器，以及视图模板文件。
- en: 'We also have two routes: the first one is `/dashboard` with sequential queries,
    and the second one is `/dashboard-concurrent` with parallel queries.'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还有两个路由：第一个是 `/dashboard`，使用顺序查询，第二个是 `/dashboard-concurrent`，使用并行查询。
- en: Just for this example, the query is forced to take 1 second (in the model method).
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 仅以此为例，查询被强制设置为 1 秒（在模型方法中）。
- en: If you open your browser at `http://127.0.0.1:8000/dashboard`, you will see
    that each request takes more than 3 seconds (each query takes 1 second). This
    is the sum of all the execution times of each query.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你打开浏览器访问 `http://127.0.0.1:8000/dashboard`，你会看到每个请求需要超过3秒钟（每个查询需要1秒）。这是每个查询执行时间的总和。
- en: If you open your browser at `http://127.0.0.1:8000/dashboard-concurrent`, you
    will see that each request takes 1 second to be executed. This is the maximum
    execution time of the most expensive query.
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你打开浏览器访问 `http://127.0.0.1:8000/dashboard-concurrent`，你会看到每个请求需要1秒钟来执行。这是最昂贵的查询的最大执行时间。
- en: This means that you have to call multiple queries in your controller to retrieve
    data. To render the page, you can use the `Octane::concurrently()` method.
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着你必须在控制器中调用多个查询来检索数据。为了渲染页面，你可以使用 `Octane::concurrently()` 方法。
- en: The `Octane::concurrently()` method is also great in other scenarios (not just
    loading data from a database), such as making concurrent HTTP requests. So, in
    the next section, we are going to use the `Octane::concurrently()` method to retrieve
    data from HTTP calls (instead of retrieving data from a database). Let’s see how.
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: '`Octane::concurrently()` 方法在其他场景中也很有用（不仅仅是加载数据库中的数据），例如执行并发HTTP请求。因此，在下一节中，我们将使用
    `Octane::concurrently()` 方法从HTTP调用中检索数据（而不是从数据库中检索数据）。让我们看看如何操作。'
- en: Making parallel HTTP requests
  id: totrans-334
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 并行执行HTTP请求
- en: Think about the scenario in which you have to add a new web page in your application,
    and to render the web page, you have to call more than one API because you need
    multiple pieces of data from multiple sources (list of products, list of news,
    list of links, etc.) for the same page. In the scenario with one web page that
    needs data from multiple API calls, you could perform the HTTP requests simultaneously
    to reduce the response time of the page.
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下这样的场景：在你的应用程序中需要添加一个新的网页，为了渲染这个网页，你必须调用多个API，因为同一个页面需要从多个来源获取多个数据片段（产品列表、新闻列表、链接列表等）。在需要从多个API调用获取数据的单个网页场景中，你可以同时执行HTTP请求以减少页面的响应时间。
- en: For this example, to simplify the explanation, we will avoid using the controller
    and the view. We are going to collect JSON responses from APIs and then we will
    merge the responses into one JSON response. The important aspect to focus on is
    the mechanism of calling HTTP requests to third-party HTTP services because our
    goal is to understand how to make the HTTPS call concurrently.
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，为了简化说明，我们将避免使用控制器和视图。我们将从API收集JSON响应，然后我们将合并这些响应为一个JSON响应。我们需要关注的重要方面是调用第三方HTTP服务的HTTP请求机制，因为我们的目标是了解如何并发地执行HTTPS调用。
- en: 'To simulate the HTTP service, we are going to create two new routes:'
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 为了模拟HTTP服务，我们将创建两个新的路由：
- en: '`api/sentence`: An API endpoint that replies with a JSON with a random sentence'
  id: totrans-338
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`api/sentence`：一个API端点，回复包含随机句子的JSON'
- en: '`api/name`: An API endpoint that replies with a JSON with a random first name'
  id: totrans-339
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`api/name`：一个API端点，回复包含随机名字的JSON'
- en: Both endpoint APIs implement a `sleep()` function of 1 second to allow the client
    (who calls the endpoint) to wait for the answer. This is a way to simulate a slow
    API and see the benefit we can obtain from parallel HTTP requests.
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 两个端点API都实现了一个1秒的 `sleep()` 函数，以便客户端（调用端点的人）等待答案。这是一种模拟慢速API并查看我们可以从并行HTTP请求中获得的好处的方法。
- en: 'In the `routes/web.php` file, you can add the two routes that implement the
    APIs:'
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `routes/web.php` 文件中，你可以添加实现API的两个路由：
- en: '[PRE61]'
  id: totrans-342
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'Now, using the `Http::get()` method to perform HTTP requests, you can implement
    the logic to retrieve data from two APIs sequentially:'
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，使用 `Http::get()` 方法执行HTTP请求，你可以实现从两个API顺序检索数据的逻辑：
- en: '[PRE62]'
  id: totrans-344
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'Using `Octane::concurrently()`, you can now call the two `Http::get()` methods,
    using the HTTP request as `Closure` (anonymous function), as we did for the database
    queries:'
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `Octane::concurrently()`，你现在可以调用两个 `Http::get()` 方法，使用HTTP请求作为 `Closure`（匿名函数），就像我们为数据库查询所做的那样：
- en: '[PRE63]'
  id: totrans-346
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: If you open your browser to `http://127.0.0.1:8000/httpcall/sequence`, you will
    see that the response time is more than 2,000 milliseconds (the sum of the execution
    time of the two sleep functions, and some milliseconds for executing the HTTP
    connection).
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你打开浏览器访问 `http://127.0.0.1:8000/httpcall/sequence`，你会看到响应时间超过2,000毫秒（两个sleep函数的执行时间之和，以及一些用于执行HTTP连接的毫秒）。
- en: If you open your browser to `http://127.0.0.1:8000/httpcall/parallel`, you will
    see that the response takes more than 1,000 milliseconds (the two HTTP requests
    are performed in parallel).
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你打开你的浏览器到`http://127.0.0.1:8000/httpcall/parallel`，你会看到响应时间超过1,000毫秒（两个HTTP请求是并行执行的）。
- en: Using `Octane::concurrently()` could help you save some total response time
    when making these examples with database queries or fetching external resources.
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`Octane::concurrently()`可以帮助你在进行这些示例（如数据库查询或获取外部资源）时节省一些总响应时间。
- en: Managing HTTP errors
  id: totrans-350
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 管理HTTP错误
- en: While executing HTTP calls in parallel, you have to expect that, sometimes,
    the external service could answer with an error (for example, with an HTTP status
    code `500`). For better error management in the source code, we must also properly
    deal with the case where we get an empty response from the API, which typically
    results in a response with errors (for example the API returns a status code `500`).
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 在并行执行HTTP调用时，你必须预期有时外部服务可能会以错误（例如，HTTP状态码`500`）回答。为了在源代码中更好地管理错误，我们还必须正确处理从API获取空响应的情况，这通常会导致包含错误的响应（例如，API返回状态码`500`）。
- en: 'Here, we demonstrate that we are going to implement an API that returns `500`
    as an HTTP status code (an internal server error message):'
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们演示我们将实现一个返回`500`作为HTTP状态码（内部服务器错误消息）的API：
- en: '[PRE64]'
  id: totrans-353
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'Then, we can call the API error route in one of our concurrent HTTP calls.
    If we are not managing the error, we will receive an error such as this one:'
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以在我们的并发HTTP调用中的一个调用API错误路由。如果我们没有管理错误，我们将收到如下错误：
- en: '![Figure 4.7: The unmanaged error in the browser](img/Figure_4.07_B17728.jpg)'
  id: totrans-355
  prefs: []
  type: TYPE_IMG
  zh: '![图4.7：浏览器中的未管理错误](img/Figure_4.07_B17728.jpg)'
- en: 'Figure 4.7: The unmanaged error in the browser'
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.7：浏览器中的未管理错误
- en: 'So, we could improve our code by managing the following:'
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们可以通过管理以下内容来改进我们的代码：
- en: The exception that could come from the execution of concurrent HTTP calls
  id: totrans-358
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 来自并发HTTP调用执行的异常
- en: The empty response value with the `Null` coalescing operator
  id: totrans-359
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`Null`合并运算符的空响应值
- en: Initializing the arrays as an empty array
  id: totrans-360
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将数组初始化为空数组
- en: 'In the `routes/web.php` file, we can improve the API calls and make them more
    reliable:'
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 在`routes/web.php`文件中，我们可以改进API调用并使其更可靠：
- en: '[PRE65]'
  id: totrans-362
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: In this way, if an exception is raised or we receive an HTTP error as a response,
    our software will manage these scenarios.
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，如果抛出异常或我们收到HTTP错误作为响应，我们的软件将管理这些场景。
- en: The suggestion is that even if you are focusing on performance aspects, you
    don’t have to lose focus on the behavior of the application and managing the unhappy
    paths correctly.
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 建议，即使你专注于性能方面，你也不必忽视应用程序的行为和管理不愉快的路径。
- en: Now that we understand how to execute tasks in parallel, we can focus on caching
    the response to avoid calling external resources (database or web service) for
    every request.
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了如何并行执行任务，我们可以专注于缓存响应以避免在每次请求时调用外部资源（数据库或Web服务）。
- en: Understanding the caching mechanism
  id: totrans-366
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解缓存机制
- en: Laravel provides the developer with a strong mechanism for caching.
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: Laravel为开发者提供了一个强大的缓存机制。
- en: The caching mechanism can be used with a provider chosen from the database,
    Memcached, Redis, or DynamoDB.
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 缓存机制可以与数据库、Memcached、Redis或DynamoDB等提供者一起使用。
- en: Laravel’s caching mechanism allows data to be stored for later retrieval quickly
    and efficiently.
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: Laravel的缓存机制允许数据被快速高效地存储以供以后检索。
- en: This is very useful in cases where retrieving data from an external service
    with a database or web service can be a time-consuming operation. After information
    retrieval, storing the retrieved information in a cache mechanism is possible
    to make future information retrieval easier and faster.
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 在从数据库或Web服务检索数据可能是一个耗时操作的情况下，这非常有用。在信息检索后，将检索到的信息存储在缓存机制中，可以使未来的信息检索更容易和更快。
- en: 'So basically, a caching mechanism exposes two basic functionalities: caching
    of information and retrieval from the cache of information.'
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，基本上，缓存机制暴露了两个基本功能：信息的缓存和从缓存中检索信息。
- en: To properly retrieve information each time a cached item is used, it is appropriate
    to use a storage key. This way, it is possible to cache a lot of information identified
    by a specific key.
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在每次使用缓存项时正确检索信息，使用存储键是合适的。这样，就可以通过特定的键缓存大量信息。
- en: Laravel’s caching mechanism, through the special `remember()` function, allows
    retrieving a piece of information tied to a specific key. If this information
    has become obsolete because the storage time-to-live has been exceeded, or if
    the key is not cached, then the `remember()` method allows calling an anonymous
    function that has the task of getting the data from the external resource, which
    can be the database or a web service. Once the original data is retrieved, the
    `remember()` function automatically returns the data but, at the same time, also
    takes care of caching it with the user-defined key.
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: Laravel 的缓存机制通过特殊的 `remember()` 函数允许检索与特定键相关联的信息。如果由于存储时间超时或键未缓存，该信息已过时，那么 `remember()`
    方法允许调用一个匿名函数，该函数的任务是从外部资源获取数据，这可能是一个数据库或网络服务。一旦检索到原始数据，`remember()` 函数将自动返回数据，同时也会负责使用用户定义的键将其缓存。
- en: 'Here is an example of using the `remember()` function:'
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是使用 `remember()` 函数的一个示例：
- en: '[PRE66]'
  id: totrans-375
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'The `remember()` functionality applied to each HTTP request in the previous
    example can be implemented in an anonymous function:'
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 在前一个示例中应用于每个 HTTP 请求的 `remember()` 功能可以通过匿名函数实现：
- en: '[PRE67]'
  id: totrans-377
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'The anonymous function can then be invoked by the `Octane::concurrently()`
    function for each concurrent task:'
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，匿名函数可以被 `Octane::concurrently()` 函数为每个并发任务调用：
- en: '[PRE68]'
  id: totrans-379
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'So, the final code in a route in the `routes/web.php` file is as follows:'
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，`routes/web.php` 文件中路由的最终代码如下：
- en: '[PRE69]'
  id: totrans-381
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'The following are some considerations about the code:'
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一些关于代码的考虑：
- en: We used the Octane route (faster than Laravel routes).
  id: totrans-383
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们使用了比 Laravel 路由更快的 Octane 路由。
- en: The `$url` parameter of the anonymous function is used to create the cache key
    and to call the right API via `Http::get()`.
  id: totrans-384
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 匿名函数的 `$url` 参数用于创建缓存键，并通过 `Http::get()` 调用正确的 API。
- en: We used the cache with Octane as the driver, `Cache::store('octane')`.
  id: totrans-385
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们使用 Octane 作为驱动程序使用缓存，`Cache::store('octane')`。
- en: We used the `remember()` function for the cache.
  id: totrans-386
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们使用了 `remember()` 函数进行缓存。
- en: We set the time-to-live of the cache item at 20 seconds. It means that after
    20 seconds, the cache item is generated, and the code provided by the anonymous
    function will be called.
  id: totrans-387
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们将缓存项的生存时间设置为 20 秒。这意味着在 20 秒后，缓存项将被生成，匿名函数提供的代码将被调用。
- en: This code improves the response time dramatically thanks to the cache.
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码通过缓存显著提高了响应时间。
- en: However, the code could be more optimized.
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，代码可以更加优化。
- en: We cache the result from each HTTP request. But, we could cache the result provided
    by `Octane::concurrently`. So, instead of caching each HTTP request, we could
    cache the result that comes from `Octane::concurrently()`. This allows us to save
    more time by avoiding the execution of `Octane::concurrently()` if the value is
    cached.
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: 我们缓存了每个 HTTP 请求的结果。但是，我们也可以缓存由 `Octane::concurrently` 提供的结果。所以，我们不必缓存每个 HTTP
    请求，而是可以缓存来自 `Octane::concurrently()` 的结果。这使我们能够通过避免执行已缓存的 `Octane::concurrently()`
    来节省更多时间。
- en: 'In this case, we can move `Octane::concurrently()` in the body of the anonymous
    function called by `remember()`:'
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们可以将 `Octane::concurrently()` 移到由 `remember()` 调用的匿名函数体中：
- en: '[PRE70]'
  id: totrans-392
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'In this case, from the log of the requests, you can see that the APIs are only
    called the first time, then the data is retrieved from the cache, and the execution
    time is reduced:'
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，从请求日志中，你可以看到 API 只在第一次调用，然后从缓存中检索数据，执行时间减少：
- en: '[PRE71]'
  id: totrans-394
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: The first call to the caching route takes around 60 milliseconds; the subsequent
    requests are much faster (around 3 milliseconds)
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: 第一次调用缓存路由大约需要 60 毫秒；后续请求要快得多（大约 3 毫秒）
- en: If you try to do the same test by calling the HTTP requests sequentially and
    not using the cache, you will see higher values as response times. You will also
    see that the API will be called every time, making the speed and the reliability
    of your application dependent on a third-party system because the reliability
    and the speed depend on the way the third-party system (that provides the APIs)
    creates the response.
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你尝试通过按顺序调用 HTTP 请求而不使用缓存来进行相同的测试，你将看到更高的响应时间值。你还会看到 API 每次都会被调用，这使得应用程序的速度和可靠性依赖于第三方系统，因为可靠性和速度取决于第三方系统（提供
    API 的系统）创建响应的方式。
- en: 'For example, by calling HTTP requests sequentially, with no cache – even if
    the APIs are provided by Octane (so in a faster way) – you will obtain the following:'
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，通过按顺序调用 HTTP 请求，不使用缓存——即使 API 由 Octane 提供（因此速度更快）——你将获得以下结果：
- en: '[PRE72]'
  id: totrans-398
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: While you might think that this is not a great improvement or that these values
    are machine-dependent, a small improvement (our response time has gone from 10-15
    milliseconds to 2-3 milliseconds) for a single request could have a big impact,
    especially if, in a production environment, you have a huge number of simultaneous
    requests. The benefit of each small improvement for a single request is multiplied
    by the number of requests you might have in a production environment with many
    concurrent users.
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然你可能认为这并不是一个很大的改进，或者这些值是机器相关的，但对于单个请求的微小改进（我们的响应时间从10-15毫秒降低到2-3毫秒）可能产生重大影响，尤其是在生产环境中，如果你有大量的并发请求。单个请求的每次微小改进的好处，在具有许多并发用户的生产环境中，会通过请求的数量而倍增。
- en: Now that we understand a bit more about caching, we could refactor our dashboard
    by adding the cache for event retrieval.
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们对缓存有了更多了解，我们可以通过添加事件检索的缓存来重构仪表板。
- en: Refactoring the dashboard
  id: totrans-401
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 重构仪表板
- en: 'We are going to create a new route, `/dashboard-concurrent-cached`, with the
    Octane route and we are going to call a new `DashboardController` method, `indexConcurrentCached()`:'
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将创建一个新的路由，`/dashboard-concurrent-cached`，与 Octane 路由一起使用，并且我们将调用一个新的 `DashboardController`
    方法，`indexConcurrentCached()`：
- en: '[PRE73]'
  id: totrans-403
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'In the controller `app/Http/Controllers/DashboardController.php` file, you
    can add the new method:'
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: 在控制器 `app/Http/Controllers/DashboardController.php` 文件中，你可以添加新的方法：
- en: '[PRE74]'
  id: totrans-405
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'In the new method, we do the following:'
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: 在新方法中，我们执行以下操作：
- en: Call the `remember()` method to store the values in the cache
  id: totrans-407
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 调用 `remember()` 方法将值存储在缓存中
- en: Execute `Octane:concurrently` to parallelize the queries
  id: totrans-408
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 执行 `Octane:concurrently` 来并行化查询
- en: Use `'key-event-cache'` as the key name for the cache item
  id: totrans-409
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `'key-event-cache'` 作为缓存项的键名
- en: Use 20 seconds as the cache time-to-live (after 20 seconds, the queries will
    be executed and retrieve new values from the database)
  id: totrans-410
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用20秒作为缓存生存时间（20秒后，查询将被执行并从数据库检索新值）
- en: Use the same query of the `/dashboard` route and the same blade view (to make
    a good comparison)
  id: totrans-411
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用与 `/dashboard` 路由相同的查询和相同的 blade 视图（为了进行良好的比较）
- en: 'Now, you can restart your Octane worker with `php artisan octane:reload` if
    you are not using the automatic reloader (as explained in [*Chapter 2*](B17728_02.xhtml#_idTextAnchor036),
    *Configuring the RoadRunner Application Server*), and then access the following:'
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果你没有使用自动加载器（如[*第2章*](B17728_02.xhtml#_idTextAnchor036)，*配置 RoadRunner 应用程序服务器*）中解释的那样），你可以使用
    `php artisan octane:reload` 重新启动你的 Octane 工作进程，然后访问以下内容：
- en: '`http://127.0.0.1:8000/dashboard` to load the page with sequential queries
    and without a caching mechanism'
  id: totrans-413
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`http://127.0.0.1:8000/dashboard` 用于加载使用顺序查询且没有缓存机制的页面'
- en: '`http://127.0.0.1:8000/dashboard-concurrent-cached` to load the page with parallel
    queries and with a caching mechanism'
  id: totrans-414
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`http://127.0.0.1:8000/dashboard-concurrent-cached` 用于加载使用并行查询和缓存机制的页面'
- en: Now that we have implemented the logic and opened the pages, we are going to
    analyze the result.
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经实现了逻辑并打开了页面，我们将分析结果。
- en: The result
  id: totrans-416
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 结果
- en: The result that you can see is impressive as, from a response that took more
    than 200 milliseconds, you will now have a response that takes 3 or 4 milliseconds.
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到的结果是令人印象深刻的，因为从响应时间超过200毫秒，你现在将有一个响应时间仅为3或4毫秒。
- en: 'The longer response is from `/dashboard`, where sequential queries are implemented
    without a cache. The fastest responses come from `/dashboard-concurrent-cached`,
    which uses `Octane::concurrently()` to execute the queries, and the result is
    cached for 20 seconds:'
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
  zh: 较长的响应来自 `/dashboard`，其中实现了没有缓存的顺序查询。最快的响应来自 `/dashboard-concurrent-cached`，它使用
    `Octane::concurrently()` 来执行查询，并将结果缓存20秒：
- en: '[PRE75]'
  id: totrans-419
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: When you are caching data in Octane Cache, you should also be aware of the cache
    configuration. A wrong configuration could raise some errors in your application.
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
  zh: 当你在 Octane Cache 中缓存数据时，你也应该注意缓存配置。错误的配置可能会在你的应用程序中引发一些错误。
- en: The cache configuration
  id: totrans-421
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 缓存配置
- en: 'A typical exception that you might see when you start to use Octane Cache in
    a real scenario is something like this:'
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
  zh: 当你在实际场景中开始使用 Octane Cache 时可能会遇到的典型异常是这样的：
- en: '[PRE76]'
  id: totrans-423
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: The solution to the error message above is to change the cache configuration
    by increasing the number of bytes allocated for storing the cache values. In the
    `config/octane.php` file, you can configure the cache for the number of rows and
    the number of bytes allocated for the cache.
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
  zh: 解决上述错误信息的方法是更改缓存配置，通过增加用于存储缓存值的字节数。在 `config/octane.php` 文件中，您可以配置缓存用于行数和分配给缓存的字节数。
- en: 'By default, the configuration is as follows:'
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，配置如下：
- en: '[PRE77]'
  id: totrans-426
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: 'If you get the `Value is too large` exception in your browser, you might have
    to increase the number of bytes in the `config/octane.php` file:'
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在浏览器中遇到 `Value is too large` 异常，你可能需要增加 `config/octane.php` 文件中的字节数：
- en: '[PRE78]'
  id: totrans-428
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: So now, using Octane features, you can improve the response time and some aspects
    of your application.
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，使用 Octane 功能，您可以提高应用程序的响应时间以及一些方面。
- en: Summary
  id: totrans-430
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: 'In this chapter, we built a very simple application that allowed us to cover
    multiple aspects of building a Laravel application, such as importing the initial
    data, optimizing the routing mechanism, integrating third-party data via HTTP
    requests, and using a cache mechanism via Octane Cache. We also used some Laravel
    Octane features in order to reduce the page loading response time thanks to the
    following:'
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们构建了一个非常简单的应用程序，使我们能够涵盖构建 Laravel 应用程序的多方面内容，例如导入初始数据、优化路由机制、通过 HTTP 请求集成第三方数据，以及通过
    Octane Cache 使用缓存机制。我们还使用了 Laravel Octane 的一些功能，以减少页面加载响应时间，这得益于以下原因：
- en: '`Octane::route` for optimizing the routing resolution process'
  id: totrans-432
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Octane::route` 用于优化路由解析过程'
- en: '`Octane::concurrently` for optimizing and starting parallel tasks'
  id: totrans-433
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Octane::concurrently` 用于优化和启动并行任务'
- en: Octane Cache for adding a cache based on Swoole to our application
  id: totrans-434
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Octane Cache 用于向我们的应用程序添加基于 Swoole 的缓存
- en: We learned how to execute queries and API calls concurrently and use the cache
    mechanism for reusing the content across the requests.
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
  zh: 我们学习了如何并发执行查询和 API 调用，并使用缓存机制在请求间重用内容。
- en: In the next chapter, we will take a look at some other aspects of performance
    that are not strictly provided by Octane but can affect your Octane optimization
    process.
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将探讨一些其他方面，这些方面并非严格由 Octane 提供，但可能会影响你的 Octane 优化过程。
- en: We will also apply a different strategy for caching using the scheduled tasks
    provided by Octane and other optimizations.
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将应用不同的缓存策略，使用 Octane 提供的计划任务和其他优化。
