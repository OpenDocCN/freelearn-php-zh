<html><head></head><body><div class="chapter" title="Chapter&#xA0;3.&#xA0;Entering Codeception"><div class="titlepage"><div><div><h1 class="title"><a id="ch03"/>Chapter 3. Entering Codeception</h1></div></div></div><p>After the installation of Yii 2, as discussed in the previous chapter, in this chapter we will cover installation of the <a id="id138" class="indexterm"/>Codeception suite (<a class="ulink" href="http://codeception.com">http://codeception.com</a>) and go through the folder structure to describe how Codeception works, its extensions, modularization, syntax, and the jargon used.</p><p>We will need to have a good grasp of its concepts and details as Codeception will become the main tool we will use to interact with our tests throughout the rest of this book. In this chapter, we will be covering the following topics:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Getting started with Codeception</li><li class="listitem" style="list-style-type: disc">Installing Codeception in Yii 2</li><li class="listitem" style="list-style-type: disc">Finding your way around Codeception</li><li class="listitem" style="list-style-type: disc">Interacting with Codeception</li></ul></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note11"/>Note</h3><p>Please keep in mind that the folder structure of Yii 2 might change when it reaches a stable release (which might be after the release of this book) and together with it, the structure used to organize tests. Always try to take notes and understand what you're looking at, since the way Codeception works and interacts with Yii won't massively change, if not improve.</p></div></div><div class="section" title="Getting started with Codeception"><div class="titlepage"><div><div><h1 class="title"><a id="ch03lvl1sec20"/>Getting started with Codeception</h1></div></div></div><p>Not everyone has <a id="id139" class="indexterm"/>been exposed to testing. The ones who actually have are aware of the quirks and limitations of the testing tools they've used. Some might be more efficient than others, and in either case, you had to rely on the situation that was presented to you: legacy code, hard to test architectures, no automation, no support whatsoever on the tools, and other setup problems, just to name a few. Only certain companies, because they have either the right skillsets or the budget, invest in testing, but most of them don't have the capacity to see beyond the point that quality assurance is important. Getting the testing infrastructure and tools in place is the immediate step following getting developers to be responsible for their own code and to test it.</p><p>Even if testing is <a id="id140" class="indexterm"/>something not particularly new in the programming world, PHP always had a weak point regarding it. Its history is not the one of a pure-bred programming language done with all the nice little details, and only just recently has PHP found itself in a better position and started to become more appreciated.</p><p>Because of this, the only and most important tool that came out has been PHPUnit, which was released just 10 years ago, in 2004, thanks to the efforts of Sebastian Bergmann.</p><p>PHPUnit<a id="id141" class="indexterm"/> was and sometimes is still difficult to master and understand. It requires time and dedication, particularly if you are coming from a non-testing experience. PHPUnit simply provided a low-level framework to implement unit tests and, up to a certain point, integration tests, with the ability to create mocks and fakes when needed.</p><p>Although it still is the quickest way to discover bugs, given the limitations we've seen in the previous chapters, it didn't cover everything and using it to create large integration tests will end up being an almost impossible task.</p><p>On top of this, PHPUnit since version 3.7, when it switched to a different autoloading mechanism and moved away from PEAR, caused several headaches rendering most of the installations unusable.</p><p>Other tools developed since mostly come from other environments and requirements, programming languages, and frameworks. Some of these tools were incredibly strong and well-built, but they came with their own way of declaring tests and interacting with the application, set of rules, and configuration specifics.</p><div class="section" title="A modular framework rather than just another tool"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec20"/>A modular framework rather than just another tool</h2></div></div></div><p>Clearly, mastering <a id="id142" class="indexterm"/>all these tools required a bit of understanding, and the learning curve wasn't promised to be the same among all of them.</p><p>So, if this is the current panorama, why create another tool if you will end up in the same situation we were in before?</p><p>Well, one of the most important things to be understood about Codeception is that it's not just a tool, rather a full stack, as noted on the Codeception site, a suite of frameworks, or if you want to go meta, a framework for frameworks.</p><p>Codeception provides a uniform way to design different types of test by using as much as possible the<a id="id143" class="indexterm"/> same semantic and logic, a way to make the whole testing infrastructure more coherent and approachable.</p></div><div class="section" title="Outlining concepts behind Codeception"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec21"/>Outlining concepts behind Codeception</h2></div></div></div><p>Codeception has been created with the following <a id="id144" class="indexterm"/>basic concepts in mind:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Easy to read</strong></span>: By <a id="id145" class="indexterm"/>using a declarative syntax close to the natural language, tests can be read and interpreted quite easily, making them an ideal candidate to be used as documentation for the application. Any stakeholder and engineer close to the project can ensure that tests are written correctly and cover the required scenarios without knowing any special lingo. It can also generate BDD-style test scenarios from code test cases.</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Easy to write</strong></span>: As we <a id="id146" class="indexterm"/>already underlined, every testing framework uses its own syntax or language to write tests, resulting in some degree of difficulty when switching from one suite to the other, without taking into account the learning curve each one has. Codeception tries to bridge this gap of knowledge by using a common declarative language. Further, abstractions provide a comfortable environment that makes maintenance simple.</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Easy to debug</strong></span>: Codeception<a id="id147" class="indexterm"/> is born with the ability to see what's behind the scenes without messing around with the configuration files or doing random <code class="literal">print_r</code> around your code.</li></ul></div><p>On top of this all, Codeception has also been written with modularity and extensibility in mind, so that organizing your code is simple while also promoting code reuse throughout your tests.</p><p>But let's see what's provided by Codeception in more detail.</p></div><div class="section" title="Types of tests"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec22"/>Types of tests</h2></div></div></div><p>As we've seen, Codeception <a id="id148" class="indexterm"/>provides three basic<a id="id149" class="indexterm"/> types of test:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Unit<a id="id150" class="indexterm"/> tests</li><li class="listitem" style="list-style-type: disc">Functional <a id="id151" class="indexterm"/>tests</li><li class="listitem" style="list-style-type: disc">Acceptance tests</li></ul></div><p>Each one of<a id="id152" class="indexterm"/> them is self-contained in its own folder where you can find anything needed, from the configuration and the actual tests to any additional piece of information that is valuable, such as the fixtures, database snapshots, or specific data to be fed to your tests.</p><p>In order to <a id="id153" class="indexterm"/>start writing tests, you need to initialize all the required classes that will allow you to run your tests, and you can do this by invoking <code class="literal">codecept</code> with the <code class="literal">build</code> argument:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ cd tests</strong></span>
<span class="strong"><strong>$ ../vendor/bin/codecept build</strong></span>
<span class="strong"><strong>Building Actor classes for suites: functional, acceptance, unit</strong></span>
<span class="strong"><strong>\FunctionalTester includes modules: Filesystem, Yii2</strong></span>
<span class="strong"><strong>FunctionalTester.php generated successfully. 61 methods added</strong></span>
<span class="strong"><strong>\AcceptanceTester includes modules: PhpBrowser</strong></span>
<span class="strong"><strong>AcceptanceTester.php generated successfully. 47 methods added</strong></span>
<span class="strong"><strong>UnitTester includes modules:</strong></span>
<span class="strong"><strong>UnitTester.php generated successfully. 0 methods added</strong></span>
<span class="strong"><strong>$</strong></span>
</pre></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note12"/>Note</h3><p>The <code class="literal">codecept build</code> command<a id="id154" class="indexterm"/> needs to be run every time you modify any configuration file owned by Codeception when adding or removing any module, in other words, whenever you modify any of the <code class="literal">.suite.yml</code> files available in the <code class="literal">/tests</code> folder.</p></div></div><p>What you have probably already noticed in the preceding output is the presence of a very peculiar naming system for the test classes.</p><p>Codeception introduces the <span class="strong"><strong>Guys</strong></span> that have been renamed in Yii terminology as <span class="strong"><strong>Testers</strong></span>, and are as follows:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">AcceptanceTester</code>: This<a id="id155" class="indexterm"/> is used for acceptance tests</li><li class="listitem" style="list-style-type: disc"><code class="literal">FunctionalTester</code>: This <a id="id156" class="indexterm"/>is used for functional tests</li><li class="listitem" style="list-style-type: disc"><code class="literal">UnitTester</code>: This<a id="id157" class="indexterm"/> is used for unit tests</li></ul></div><p>These will become your main interaction points with (most of) the tests and we will see why. By using such nomenclature, Codeception shifts the point of attention from the code itself to the person that is meant to be <span class="emphasis"><em>acting</em></span> the tests you will be writing.</p><p>This way we will become more fluent in thinking in a more BDD-like mindset rather than trying to figure out all the possible solutions that could be covered, while losing the focus of what we're trying to achieve.</p><p>Once again, BDD is an improvement over TDD, because it declares in a more detailed way what needs to be tested and <span class="emphasis"><em>what doesn't</em></span>.</p><div class="section" title="AcceptanceTester"><div class="titlepage"><div><div><h3 class="title"><a id="ch03lvl3sec06"/>AcceptanceTester</h3></div></div></div><p>
<code class="literal">AcceptanceTester</code><a id="id158" class="indexterm"/> can be seen as a person who does not<a id="id159" class="indexterm"/> have any knowledge of the technologies used and tries to verify the acceptance criteria that have been defined at the beginning.</p><p>If we want to re-write our previously defined acceptance tests in a more standardized BDD way, we need to remember the structure of a so-called <span class="emphasis"><em>user story</em></span>. The story should have a clear title, a short introduction that specifies the <span class="emphasis"><em>role</em></span> that is involved in obtaining a certain <span class="emphasis"><em>result</em></span> or <span class="emphasis"><em>effect</em></span>, and the <span class="emphasis"><em>value</em></span> that this will reflect. Following this, we will then need to specify the various scenarios or <span class="emphasis"><em>acceptance criteria</em></span>, which are defined by outlining the initial <span class="emphasis"><em>scenario</em></span>, the <span class="emphasis"><em>trigger event</em></span>, and the <span class="emphasis"><em>expected outcome</em></span> in one or more clauses.</p><p>Let's discuss<a id="id160" class="indexterm"/> login using a modal window, which is one of the two features we are going to implement in our application.</p><p>
<span class="strong"><strong>Story title – successful user login</strong></span>
</p><p>I, as an acceptance tester, want to log in into the application from any page.</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Scenario 1</strong></span>: Log in from the homepage<div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">I am on the homepage.</li><li class="listitem">I click on the login link.</li><li class="listitem">I enter my username.</li><li class="listitem">I enter my password.</li><li class="listitem">I press submit.</li><li class="listitem">The login link now reads "logout (&lt;username&gt;)" and I'm still on the homepage.</li></ol></div></li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Scenario 2</strong></span>: Log in from a secondary page<div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">I am on a secondary page.</li><li class="listitem">I click on the login link.</li><li class="listitem">I enter my username.</li><li class="listitem">I enter my password.</li><li class="listitem">I press Submit.</li><li class="listitem">The login link now reads "logout (&lt;username&gt;)" and I'm still on the secondary page.</li></ol></div></li></ul></div><p>As you might<a id="id161" class="indexterm"/> have noticed I am limiting the preceding example to successful cases. There is more than this, and we will discuss in more detail all the relevant stories and scenarios before we implement the actual features further on in this book.</p><p>The preceding story can be immediately translated into something along the lines of the following code:</p><div class="informalexample"><pre class="programlisting">// SuccessfulLoginAcceptanceTest.php

$I = new AcceptanceTester($scenario);
$I-&gt;wantTo("login into the application from any page");

// scenario 1
$I-&gt;amOnPage("/");
$I-&gt;click("login");
$I-&gt;fillField("username", $username);
$I-&gt;fillField("password", $password);
$I-&gt;click("submit");
$I-&gt;canSee("logout (".$username.")");
$I-&gt;seeInCurrentUrl("/");

// scenario 2
$I-&gt;amOnPage("/");
$I-&gt;click("about");
$I-&gt;seeLink("login");
$I-&gt;click("login");
$I-&gt;fillField("username", $username);
$I-&gt;fillField("password", $password);
$I-&gt;click("submit");
$I-&gt;canSee("logout (".$username.")");
$I-&gt;amOnPage("about");</pre></div><p>As you can see this is totally straightforward and easy to read, to the point that anyone in the business should be able to write any case scenario (this is an overstatement, but you get the idea).</p><p>Clearly, the <a id="id162" class="indexterm"/>only thing that is needed to understand is what the <code class="literal">AcceptanceTester</code> is able to do: The class generated by the <code class="literal">codecept build</code> command can be found in <code class="literal">tests/codeception/acceptance/AcceptanceTester.php</code>, which contains all the available methods. You might want to skim through it if you need to understand how to assert a particular condition or perform an action on the page. The <a id="id163" class="indexterm"/>online documentation available at <a class="ulink" href="http://codeception.com/docs/04-AcceptanceTests">http://codeception.com/docs/04-AcceptanceTests</a> will also give you a more readable way to get this information.</p><p>Don't forget that at the end <code class="literal">AcceptanceTester</code> is just a name of a class, which is defined in the YAML file for the specific test type:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ grep class tests/codeception/acceptance.suite.yml</strong></span>
<span class="strong"><strong>class_name: AcceptanceTester</strong></span>
</pre></div><p>Acceptance tests are the topmost level of tests, as some sort of high-level user-oriented integration tests. Because of this, acceptance tests end up using an almost real environment, where no mocks or fakes are required. Clearly, we would need some sort of initial state that we can revert to, particularly if we're causing actions that modify the state of the database.</p><p>As per Codeception documentation, we could have used a snapshot of the database to be loaded at the beginning of each test. Unfortunately, I didn't have much luck in finding this feature working. So later on, we'll be forced to use the fixtures. Everything will then make more sense.</p><p>When we will write our acceptance tests, we will also explore the various modules that you can also use with it, such as PHPBrowser and Selenium WebDriver and their related configuration options.</p></div><div class="section" title="FunctionalTester"><div class="titlepage"><div><div><h3 class="title"><a id="ch03lvl3sec07"/>FunctionalTester</h3></div></div></div><p>As we said <a id="id164" class="indexterm"/>earlier, <code class="literal">FunctionalTester</code> represents our<a id="id165" class="indexterm"/> character when dealing with functional tests.</p><p>You might think of functional tests as a way to leverage on the correctness of the implementation from a higher standpoint.</p><p>The way to implement functional tests bears the same structure as that of acceptance tests, to the point that most of the time the code we've written for an acceptance test in Codeception can be easily swapped with that for a functional test, so you might ask yourself: "where are the differences?"</p><p>It must be <a id="id166" class="indexterm"/>noted that the concept of functional tests is something specific to Codeception and can be considered almost the same as that of integration tests for the mid-layer of your application.</p><p>The most important thing is that functional tests do not require a web server to run, and they're called<a id="id167" class="indexterm"/> <span class="strong"><strong>headless</strong></span>: For this reason, they are not only quicker than acceptance tests, but also less "real" with all the implications of running on a specific environment. And it's not the case that the acceptance tests provided by default by the basic application are, almost, the same as the functional tests.</p><p>Because of this, and as highlighted in <a class="link" href="ch02.html" title="Chapter 2. Tooling up for Testing">Chapter 2</a>, <span class="emphasis"><em>Tooling up for Testing</em></span>, we will end up having more functional tests that will cover more use cases for specific parts of our application.</p><p>
<code class="literal">FunctionalTester</code> is somehow setting the <code class="literal">$_GET</code>, <code class="literal">$_POST</code> and <code class="literal">$_REQUEST</code> variables and running the application from within a test. For this reason, Codeception ships with modules that let it interact with the underlying framework, be it Symfony2, Laravel4, Zend, or, in our case, Yii 2.</p><p>In the configuration file, you will notice the module for Yii 2 already enabled:</p><div class="informalexample"><pre class="programlisting"># tests/functional.suite.yml

class_name: FunctionalTester
modules:
    enabled:
      - Filesystem
      - Yii2
# ...</pre></div><p>
<code class="literal">FunctionalTester</code> has got a better understanding of the technologies used although he might not have the faintest idea of how the various features he's going to test have been implemented in detail; he just knows the specifications.</p><p>This makes a perfect case for the functional tests to be owned or written by the developers or anyone that is close to the knowledge of how the various features have been exposed for general consumption.</p><p>The base <a id="id168" class="indexterm"/>functionality of the REST application, exposed through the API, will also be heavily tested, and in this case, we will have the following scenarios:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">I can use POST to send correct authentication data and will receive a JSON containing the successful authentication</li><li class="listitem" style="list-style-type: disc">I can use POST to send bad authentication data and will receive a JSON containing the unsuccessful authentication</li><li class="listitem" style="list-style-type: disc">After a correct authentication, I can use GET to retrieve the user data</li><li class="listitem" style="list-style-type: disc">After a correct authentication, I will receive an error when doing a GET for a user stating that it's me</li><li class="listitem" style="list-style-type: disc">I can use POST to send my updated hashed password</li><li class="listitem" style="list-style-type: disc">Without a correct authentication, I cannot perform any of the preceding actions</li></ul></div><p>The most important thing to remember is that at the end of each test, it's your responsibility to keep the memory clean: The PHP application will not terminate after processing a request. All requests happening in the same memory container are not isolated.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip03"/>Tip</h3><p>If you see your tests failing for some unknown reason when they shouldn't, try to execute a single test separately.</p></div></div></div><div class="section" title="UnitTester"><div class="titlepage"><div><div><h3 class="title"><a id="ch03lvl3sec08"/>UnitTester</h3></div></div></div><p>I've left <a id="id169" class="indexterm"/>
<code class="literal">UnitTester</code> for<a id="id170" class="indexterm"/> the end as it's a very special guy. For all we know, until now, Codeception must have used some other framework to cover unit tests, and we're pretty much sure that PHPUnit is the only candidate to achieve this. If any of you have already worked with PHPUnit, you will remember the learning curve together with the initial problem of understanding its syntax and performing even the simplest of tasks.</p><p>I found that most developers have a love-and-hate relationship with PHPUnit: either you learn its syntax or you spend half of the time looking at the manual to get to a single point. And I won't blame you.</p><p>We will see <a id="id171" class="indexterm"/>that Codeception will come to our aid once again if we're struggling with tests: remember that these unit tests are the simplest and most atomic part of the work we're going to test. Together with them come the integration tests that cover the interaction of different components, most likely with the use of fake data and fixtures.</p><p>As we will see in <a class="link" href="ch04.html" title="Chapter 4. Isolated Component Testing with PHPUnit">Chapter 4</a>, <span class="emphasis"><em>Isolated Component Testing with PHPUnit</em></span>, if you're used to working with PHPUnit, you won't find any particular problems writing tests; otherwise, you can make use of <code class="literal">UnitTester</code> and implement the same tests by using the Verify and Specify syntax.</p><p>
<code class="literal">UnitTester</code> assumes a deep understanding of the signature and how the infrastructure and framework work, so these tests can be considered the cornerstone of testing.</p><p>They are super fast to run, compared to any other type of test, and they should also be relatively easy to write.</p><p>You can start with adequately simple assertions and move to data providers before needing to deal with fixtures. More of this is covered in the following chapter.</p></div></div><div class="section" title="Other features provided by Codeception"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec23"/>Other features provided by Codeception</h2></div></div></div><p>On <a id="id172" class="indexterm"/>top of the types of tests, Codeception provides some more aids to help you organize, modularize, and extend your test code.</p><p>As we've seen, functional and acceptance tests have a very plain and declarative structure, and all the code and the scenarios related to specific acceptance criteria are kept in the same file at the same level and these are executed linearly.</p><p>In most of the situations, as it is in our case, this is good enough, but when your code starts growing and the number of components and features become more and more complex, the list of scenarios and steps to perform an acceptance or functional test can be quite lengthy.</p><p>Further, some tests might end up depending on others, so you might want to start considering writing more compact scenarios and promote code reuse throughout your tests or split your test into two or more tests.</p><p>If you feel your code needs a better organization and structure, you might want to start generating <code class="literal">CEST</code> classes instead of normal tests, which are called <code class="literal">CEPT</code> instead.</p><p>A <code class="literal">CEST</code> class groups the scenarios all together as methods as highlighted in the following snippet:</p><div class="informalexample"><pre class="programlisting">&lt;?php
// SuccessfulLoginCest.php

class SuccessfulLoginCest
{
    public function _before(\Codeception\Event\TestEvent $event) {}

    Codeception\Event\TestEvent $event 

     public function _fail(Codeception\Event\TestEvent $event) {}

    // tests
    public function loginIntoTheApplicationTest(\AcceptanceTester $I)
    {
        $I-&gt;wantTo("login into the application from any page");
        $I-&gt;amOnPage("/");
        $I-&gt;click("login");
        $I-&gt;fillField("username", $username);
        $I-&gt;fillField("password", $password);
        $I-&gt;click("submit");
        $I-&gt;canSee("logout (".$username.")");
        $I-&gt;seeInCurrentUrl("/");
        // ...
    }
}
?&gt;</pre></div><p>Any<a id="id173" class="indexterm"/> method that is not preceded by the underscore is considered a test, and the reserved methods <code class="literal">_before</code> and <code class="literal">_after</code> are executed at the beginning and at the end of the list of tests contained in the test class, while the <code class="literal">_fail</code> method is used as a cleanup method in case of failure.</p><p>This alone might not be enough, and you can use document annotations to create reusable code to be run before and after the tests with the use of <code class="literal">@before &lt;methodName&gt;</code> and <code class="literal">@after &lt;methodName&gt;</code>.</p><p>You can also be stricter and require a specific test to pass before any other by using the document annotation <code class="literal">@depends &lt;methodName&gt;</code>.</p><p>We're going to use some of these document annotations, but before we start installing Codeception, I'd like to highlight two more features: <span class="strong"><strong>PageObjects</strong></span> and <span class="strong"><strong>StepObjects</strong></span>.</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The PageObject<a id="id174" class="indexterm"/> is a common pattern amongst test automation engineers. It represents a web page as a class, where its DOM elements are properties of the class, and methods instead provide some basic interactions with the page. The main reason for using PageObjects is to avoid hardcoding CSS and XPATH locators in your tests. Yii provides some example implementation of the PageObjects used in <code class="literal">/tests/codeception/_pages</code>.</li><li class="listitem" style="list-style-type: disc">StepObject is <a id="id175" class="indexterm"/>another way to promote code reuse in your tests: It will define some common actions that can be used in several tests. Together with PageObjects, StepObjects can become quite powerful. StepObject extends the <code class="literal">Tester</code> class and can be used to interact with the PageObject. This way your tests will become less dependent on a specific implementation and will save you the cost of refactoring when the markup and the way to interact with each component in the page changes.</li></ul></div><p>For future reference, you<a id="id176" class="indexterm"/> can find all of these in the Codeception documentation in the section regarding the advanced use at <a class="ulink" href="http://codeception.com/docs/07-AdvancedUsage">http://codeception.com/docs/07-AdvancedUsage</a> together with other features, like grouping and an interactive console that you can use to test your scenarios at runtime.</p></div></div></div>
<div class="section" title="Installing Codeception in Yii 2"><div class="titlepage"><div><div><h1 class="title"><a id="ch03lvl1sec21"/>Installing Codeception in Yii 2</h1></div></div></div><p>Now that <a id="id177" class="indexterm"/>we've seen what we can theoretically do with<a id="id178" class="indexterm"/> Codeception, let's move on and install it.</p><p>Yii comes with its own Codeception extension that provides a base class for unit tests (<code class="literal">yii\codeception\TestCase</code>), a class for tests that require database interaction (<code class="literal">yii\codeception\DbTestCase</code>), and a base class for Codeception page objects (<code class="literal">yii\codeception\BasePage</code>).</p><p>As usual, our preferred method is using Composer:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ composer require "codeception/codeception: 2.0.*" --prefer-dist --dev</strong></span>
</pre></div><p>There's <a id="id179" class="indexterm"/>a specific reason to use <code class="literal">–prefer-dist</code>; if you're using Git, you can get into a hairy situation with Git submodules (but again excluding the <code class="literal">/vendor</code> folder should solve most of these problems). To avoid repeating it every time we use Composer, just add the following to your <code class="literal">composer.json</code> file:</p><div class="informalexample"><pre class="programlisting">// composer.json

{
    "config": {
        "preferred-install": "dist"
    }
}</pre></div><p>Also, remember that using <code class="literal">composer install</code> will not work if you've added the component manually to your <code class="literal">composer.json</code> file as it would consider it a mismatch and raise an error. To install the package, you need to run <code class="literal">composer update</code> either for all the packages you have installed, or specifically with this:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ composer update codeception/codeception</strong></span>
</pre></div><p>As highlighted<a id="id180" class="indexterm"/> before, you might also be interested in two additional packages <code class="literal">codeception/specify</code> and <code class="literal">codeception/verify</code>. These two packages provide a further level of abstraction that allows you to write more human readable tests by using a business-oriented syntax, close to what BDD definitions will look like.</p><p>Your <code class="literal">composer.json</code> file will contain the following:</p><div class="informalexample"><pre class="programlisting">// composer.json

{
    "require-dev": {
        "yiisoft/yii2-codeception": "*",
        "yiisoft/yii2-debug": "*",
        "yiisoft/yii2-gii": "*",
        "codeception/codeception": "2.0.*",
        "codeception/specify": "*",
        "codeception/verify": "*"
    }
}</pre></div><div class="section" title="Finding your way around Codeception"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec24"/>Finding your way around Codeception</h2></div></div></div><p>All our tests <a id="id181" class="indexterm"/>are available within the <code class="literal">/tests/codeception</code> folder. In version 2.0 this folder contains directly all the suites and configuration files needed by them and Codeception as well. The following configuration steps are based on this structure.</p><p>By listing the content of the <code class="literal">/tests</code> folder, we will see the main Codeception configuration file, while each single suite has its own configuration file inside of the <code class="literal">/tests/codeception</code> folder, which we can modify accordingly to override or further configure our tests. Starting from our<a id="id182" class="indexterm"/> <code class="literal">/tests</code> folder, the following are the configuration files we will be dealing with:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">codeception.yml</code>: This is for all the suites and Codeception in general</li><li class="listitem" style="list-style-type: disc"><code class="literal">codeception/acceptance.suite.yml</code>: This is for the acceptance tests</li><li class="listitem" style="list-style-type: disc"><code class="literal">codeception/functional.suite.yml</code>: This is for the functional tests</li><li class="listitem" style="list-style-type: disc"><code class="literal">codeception/unit.suite.yml</code>: This is for the unit tests</li></ul></div><p>Together with these files, there are some additional configuration files that are mostly needed by Yii: <code class="literal">_bootstrap.php</code> and the content of the <code class="literal">config/</code> folder. The underscore prefixing some of these files just marks them in a way such that Codeception will ignore them. Keep this in mind in case you need to create new files in the various suite folders.</p><p>Within the <code class="literal">/tests/codeception</code> folder, you will find the folders containing the tests for each single testing suite, <code class="literal">unit/</code>, <code class="literal">functional/</code>, and <code class="literal">acceptance/</code>. Each of them will contain a <code class="literal">_bootstrap.php</code> file for the suite, the actual tests, and other folders for fixtures for example.</p><p>The few other folders contained in <code class="literal">/tests/codeception</code> are as follows:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">bin/</code>: It <a id="id183" class="indexterm"/>contains the test-bound <code class="literal">yii</code> CLI command, which we will use to run migrations against our test database.</li><li class="listitem" style="list-style-type: disc"><code class="literal">_data/</code>: It <a id="id184" class="indexterm"/>contains a snapshot of the database (<code class="literal">dump.sql</code>) normally used to bring it to an initial state for the acceptance tests, but it can contain anything, for instance, this folder will be used by Codeception in case you want it to generate (and publish) the various scenarios from the tests you've created in plain English (run the <code class="literal">codecept help generate:scenarios</code> command for more information).</li><li class="listitem" style="list-style-type: disc"><code class="literal">_output/</code>: This <a id="id185" class="indexterm"/>folder will become quite useful, as it will contain the output of the fetched pages when your acceptance or functional tests are failing, giving you another way to inspect and understand what's wrong.</li><li class="listitem" style="list-style-type: disc"><code class="literal">_pages/</code>: This is <a id="id186" class="indexterm"/>where Codeception page objects are stored. There are already three page objects provided by the basic application, namely <code class="literal">AboutPage.php</code>, <code class="literal">ContactPage.php</code>, and <code class="literal">LoginPage.php</code>. We will explore this part further down the line as they will prove to be extremely useful as they simplify our lives quite substantially and promote modularity and reuse of code.</li><li class="listitem" style="list-style-type: disc"><code class="literal">_support/</code>: This is <a id="id187" class="indexterm"/>used for additional support files, which currently hold the <code class="literal">FixtureHelper</code> class used to populate the database with the provided fixtures.</li></ul></div></div><div class="section" title="Configuring Codeception"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec25"/>Configuring Codeception</h2></div></div></div><p>Now, we <a id="id188" class="indexterm"/>should pretty much know where all the configuration files live, so we're going to review their content and adjust it before we can start interacting with Codeception and first run all the provided tests and then our own tests.</p><p>Let's start with the YAML configuration files for the different suites.</p><p>The acceptance tests are configured by default to use PHPBrowser. We will see how things need to be adjusted to use Selenium WebDriver, but generally speaking, both tools require at least a URL to access our application:</p><div class="informalexample"><pre class="programlisting"># tests/codeception/acceptance.suite.yml

class_name: AcceptanceTester
modules:
    enabled:
        - PhpBrowser
    config:
        PhpBrowser:
            <span class="strong"><strong>url: 'http://basic.yii2.sandbox'</strong></span>
</pre></div><p>The default URL is <code class="literal">http://localhost:8080</code>, which you won't need to change when, for instance, you're using Vagrant or the PHP built-in server. In the preceding example, I've set up a custom domain name; this is not required in order to run your tests as it might require additional configuration steps that won't be needed, unless you're in a larger environment and your configuration is a bit more complex (for instance in case your tests are being executed remotely). We'll see more of this in the final chapters.</p><p>Please also note that you don't need to specify the entry file, <code class="literal">index-test.php</code>, as you want Yii to resolve the routing for you.</p><p>The base URL for our application isn't needed for our functional tests, as I highlighted before. In fact what Codeception cares about for our functional tests is the entry script for the application: all the functionality is provided by the <code class="literal">yii2-codeception</code> package (which should come pre-installed in your application), so in the configuration file, you have just a reference pointing to the configuration of your test application:</p><div class="informalexample"><pre class="programlisting"># tests/codeception/functional.suite.yml
...
modules:
    config:
        Yii2:
            <span class="strong"><strong>configFile: 'codeception/config/functional.php'</strong></span>
</pre></div><p>Heading<a id="id189" class="indexterm"/> over to this file, we will find that at the very beginning we have a couple of <code class="literal">$_SERVER</code> variables set:</p><div class="informalexample"><pre class="programlisting">// tests/codeception/config/functional.php
...
// set correct script paths
$_SERVER['SCRIPT_FILENAME'] = <span class="strong"><strong>YII_TEST_ENTRY_FILE;</strong></span>
$_SERVER['SCRIPT_NAME'] = <span class="strong"><strong>YII_TEST_ENTRY_URL;</strong></span>
</pre></div><p>These two constants have been defined in the overall Yii bootstrap file:</p><div class="informalexample"><pre class="programlisting">// tests/codeception/_bootstrap.php


defined('YII_TEST_ENTRY_URL') or define('YII_TEST_ENTRY_URL', parse_url(\Codeception\Configuration::config()['config'][<span class="strong"><strong>'test_entry_url</strong></span>'], PHP_URL_PATH));

defined('YII_TEST_ENTRY_FILE') or define('TEST_TEST_ENTRY_FILE', dirname(__DIR__) . '<span class="strong"><strong>/web/index-test.php</strong></span>');</pre></div><p>In other words, the entry file is always the one found in <code class="literal">/web/index-test.php</code> while the URL can be configured in the main configuration file:</p><div class="informalexample"><pre class="programlisting">// tests/codeception.yml
...
config:
    test_entry_url: <span class="strong"><strong>https://basic.yii2.sandbox/index-test.php</strong></span>
</pre></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note13"/>Note</h3><p>Remember to adjust the hostname to the one you will use, or leave the default, which is <code class="literal">localhost:8080</code>.</p></div></div><p>For unit tests, <a id="id190" class="indexterm"/>there isn't much to be configured, as Codeception is just wrapping around PHPUnit, and the two packages, <span class="emphasis"><em>verify</em></span> and <span class="emphasis"><em>specify</em></span>, will work out of the box.</p><p>The only thing left to update is the configuration of the database: as we said earlier, currently, you can simply update the DSN in <code class="literal">/tests/codeception/config/config.php</code>, in the same way that the main Yii database configuration is defined.</p></div><div class="section" title="Tests available in Yii 2"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec26"/>Tests available in Yii 2</h2></div></div></div><p>Compared<a id="id191" class="indexterm"/> to what Yii 1 was offering, Yii 2 now comes <a id="id192" class="indexterm"/>with examples of working tests for any suite of tests available. This is a great thing as it would help us understand how to structure and implement our tests.</p><p>Once we've got the server running and all the configuration set up properly, we can just run the following command:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ cd tests</strong></span>
<span class="strong"><strong>$ ../vendor/bin/codecept run</strong></span>
</pre></div><p>This will run all the tests and see them passing. At the end, you will see a nice summary:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>...</strong></span>
<span class="strong"><strong>Time: 6.92 seconds, Memory: 35.75Mb</strong></span>

<span class="strong"><strong>OK (12 tests, 60 assertions)</strong></span>
<span class="strong"><strong>$</strong></span>
</pre></div><p>The tests provided for acceptance and functional tests are quite self-explanatory; they're basically ensuring the four pages, namely the homepage, the about page, the contact page and the login page, available in the basic application work as expected.</p><p>These tests <a id="id193" class="indexterm"/>are exactly the same, with the only difference that acceptance tests take into consideration the ability for you to run the tests via Selenium and include specific directives for it:</p><div class="informalexample"><pre class="programlisting">// tests/functional/ContactCept.php
...
if (method_exists($I, 'wait')) {
    $I-&gt;wait(3); // only for selenium
}
...</pre></div><p>This is just an example, and it shouldn't really matter to you right now, as we're going to see how Selenium WebDriver works in detail further down the line in <a class="link" href="ch07.html" title="Chapter 7. Having Fun Doing Browser Testing">Chapter 7</a>, <span class="emphasis"><em>Having Fun Doing Browser Testing</em></span>.</p><p>The unit tests shipped by Yii 2 are the ones that are unsurprisingly different; they mostly cover integration tests between various components, for instance, for the login form and the contact form, while they leave to us the burden of implementing any test for the user. We will get there, in the next chapter.</p><p>The only thing worth noticing in the unit tests is that they make use of <span class="emphasis"><em>Specify</em></span> for a more declarative way<a id="id194" class="indexterm"/> to write units, instead of the more common PHPUnit syntax. Again, this is just syntactic sugar and it might be easier for you to start with it.</p></div></div>
<div class="section" title="Interacting with Codeception"><div class="titlepage"><div><div><h1 class="title"><a id="ch03lvl1sec22"/>Interacting with Codeception</h1></div></div></div><p>So<a id="id195" class="indexterm"/> far, we've seen two arguments of the <code class="literal">codecept</code> command:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">build</code>: This is used for building the "testers" and any additional code when using any additional module</li><li class="listitem" style="list-style-type: disc"><code class="literal">run</code>: This is used to execute the tests</li></ul></div><p>There are a few parameters you can invoke <code class="literal">run</code> with that I'd like to bring to your attention, as these will come handy when running and debugging the tests. The syntax of the <code class="literal">run</code> command is as follows:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ vendor/bin/codecept run [options] [suite] [test]</strong></span>
</pre></div><p>First of all, you can run a specific suite, such as unit, acceptance, or functional, or be more specific and run a single test file, for example:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ ../vendor/bin/codecept run acceptance LoginCept.php</strong></span>
<span class="strong"><strong>…</strong></span>
<span class="strong"><strong>Time: 3.35 seconds, Memory: 13.75Mb</strong></span>

<span class="strong"><strong>OK (1 test, 5 assertions)</strong></span>
</pre></div><p>In the preceding <a id="id196" class="indexterm"/>command, you can also use the <code class="literal">--steps</code> option, which is a way to be more verbose showing all the single steps taken by your tests while running them.</p><p>Alternatively, you also have <code class="literal">--debug</code>, which will not only show the steps taken by your application, but also display what's happening behind the scenes, such as the POST request of data to a specific URL, the loading of a page, or the list of cookies set.</p><div class="section" title="Creating tests"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec27"/>Creating tests</h2></div></div></div><p>While<a id="id197" class="indexterm"/> running tests and seeing them passing will be all you care about once you've written your tests, you first need to write them.</p><p>Codeception helps us get started by providing a<a id="id198" class="indexterm"/> code generation argument on the command line:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">generate:cept</code>: This is used for generating CEPT tests</li><li class="listitem" style="list-style-type: disc"><code class="literal">generate:cest</code>: This is used for generating CEST tests</li><li class="listitem" style="list-style-type: disc"><code class="literal">generate:phpunit</code>: This is used for generating PHPUnit tests, without the Codeception additions</li><li class="listitem" style="list-style-type: disc"><code class="literal">generate:test</code>: This is used for generating unit tests</li></ul></div><p>All the preceding arguments will require as parameters the suite name and the name of the file to create:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ ../vendor/bin/codecept generate:cept acceptance ModalLoginCept</strong></span>
<span class="strong"><strong>Test was created in ModalLoginCept.php</strong></span>
</pre></div><p>You can review these and more commands by running <code class="literal">codecept</code> without arguments.</p></div><div class="section" title="Migrations on the test database"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec28"/>Migrations on the test database</h2></div></div></div><p>One of<a id="id199" class="indexterm"/> the things that I have found particularly handy and that we're going to use extensively is the ability to run the same migrations that we will create for our application on your test database.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note14"/>Note</h3><p>Migrations are a<a id="id200" class="indexterm"/> concept<a id="id201" class="indexterm"/> that is not exclusive to Yii, and you can read more about it in the documentation at <a class="ulink" href="http://www.yiiframework.com/doc-2.0/guide-db-migrations.html">http://www.yiiframework.com/doc-2.0/guide-db-migrations.html</a>.</p></div></div><p>In the <code class="literal">/tests/codeception/bin/</code> folder, you will find the <code class="literal">yii</code> CLI command line that you can use against the test database you've configured previously to run the migrations.</p><p>Assuming you're in the root of your project, the following sequence of commands will show you how to run the migrations:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ cd tests/codeception</strong></span>
<span class="strong"><strong>$ php bin/yii migrate/up</strong></span>
<span class="strong"><strong>Yii Migration Tool (based on Yii v2.0.0-dev)</strong></span>

<span class="strong"><strong>Creating migration history table "migration"...done.</strong></span>
<span class="strong"><strong>No new migration found. Your system is up-to-date.</strong></span>
</pre></div><p>The <code class="literal">yii</code> CLI is exactly the same as the main one residing in the root of your project, with the only difference that it will read the test configuration, particularly the one regarding the database.</p></div></div>
<div class="section" title="Summary"><div class="titlepage"><div><div><h1 class="title"><a id="ch03lvl1sec23"/>Summary</h1></div></div></div><p>In this chapter, we came to appreciate the breadth and the quality of Codeception.</p><p>We've seen the three types of tests, namely unit, functional, and acceptance, which we'll be using throughout the rest of the book. We've also touched some additional features provided by the tool and by the Yii 2 Codeception module. We've learned how to interact with it, generate tests, and deal with debugging and keeping the test databases in sync with the database of the main application.</p><p>In the next chapter, we're going to start refactoring our <code class="literal">User</code> class, adding our tests first and progressing through all the most important PHPUnit features.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip04"/>Tip</h3><p>
<span class="strong"><strong>Downloading the example code</strong></span>
</p><p>You can download the example code files from your account at <a class="ulink" href="http://www.packtpub.com">http://www.packtpub.com</a> for all the Packt Publishing books you have purchased. If you purchased this book elsewhere, you can visit <a class="ulink" href="http://www.packtpub.com/support">http://www.packtpub.com/support</a> and register to have the files e-mailed directly to you.</p></div></div></div></body></html>