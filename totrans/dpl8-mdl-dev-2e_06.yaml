- en: Data Modeling and Storage
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 数据建模和存储
- en: We have gone through five chapters already in this book, but we have yet to
    cover a topic that has to do with one of the main purposes of a CMS—data storage.
    Okay, we hinted at it in the previous chapter and also saw an example of a configuration
    object in the second one. However, we merely scratched the surface of what is
    possible. It's now time to go ahead and dive into everything related to how you
    can store data in Drupal 8.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这本书中已经完成了五个章节，但我们还没有涵盖与CMS主要目的之一——数据存储相关的话题。好吧，我们在上一章中提到了它，也在第二个示例中看到了配置对象的例子。然而，我们只是触及了可能性的表面。现在是时候深入探讨与如何在Drupal
    8中存储数据相关的所有内容了。
- en: In this and the next chapter, we will talk about a lot of things related to
    storage and data manipulation, and take a look at a lot of examples in the process.
    The focus of this chapter will, however, be more theoretical. There is a lot of
    ground to cover, as there are many APIs and concepts that you will need to understand.
    However, we will still see plenty of code examples to demonstrate in practice
    what we are talking about. In the next chapter, though, to make up for it, we
    will almost entirely work with code and build a few functionalities.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章和下一章中，我们将讨论许多与存储和数据操作相关的内容，并在过程中查看许多示例。然而，本章的重点将更加理论化。有许多内容需要覆盖，因为有许多API和概念你需要理解。不过，我们仍将看到许多代码示例，以展示在实践中我们讨论的内容。然而，在下一章中，为了弥补这一点，我们将几乎完全使用代码，并构建一些功能。
- en: More concretely, however, this chapter will be divided into three main logical
    parts (not necessarily represented by headings).
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，更具体地说，本章将分为三个主要逻辑部分（不一定由标题表示）。
- en: First, we will talk about your options for data storage. We will talk about
    the State system with its key/value store, tempstore, user data, configuration,
    and finally, entities—the big one. We will leave the cache out of this, because
    it will be covered in a separate chapter. We will see examples of all these options
    and go into the architectural details necessary to understand how they work.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将讨论你的数据存储选项。我们将讨论状态系统及其键/值存储、tempstore、用户数据、配置，最后是实体——这个大问题。我们将不讨论缓存，因为它将在单独的章节中介绍。我们将看到所有这些选项的示例，并深入了解理解它们如何工作的必要架构细节。
- en: Second, we will dive deep into the Drupal 8 Entity API to understand the architecture
    behind it—how data is stored and, more importantly, modeled. I am referring to
    the `TypedData` system here.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 第二，我们将深入探讨Drupal 8实体API，以了解其背后的架构——数据是如何存储的，更重要的是，是如何建模的。在这里，我指的是`TypedData`系统。
- en: Finally, we will look at how we can manipulate entities; in other words, how
    we can work with them and extract data—basically, the day-to-day working with
    entities. One of the main topics here will be, of course, querying and loading
    entities. Moreover, we will also cover the validation aspect of this process.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将探讨如何操作实体；换句话说，如何与它们一起工作并提取数据——基本上，是日常与实体的工作。这里的一个主要话题当然是查询和加载实体。此外，我们还将涵盖此过程的验证方面。
- en: 'By the end of this chapter, you should be able to understand a great deal about
    storage in Drupal 8 and make decisions on which options to choose for your requirements.
    You''ll know the differences and the reasons for using one over another. Moreover,
    you''ll get a good understanding of the Entity API, which, in turn, will allow
    you to more easily navigate through Drupal code and integrate with the entity
    system. Lastly, and probably, the most common thing Drupal developers do, you''ll
    be able to work with entities: perform CRUD operations, read and write field values,
    and more of this good stuff.'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，你应该能够对Drupal 8中的存储有很好的理解，并能够根据你的需求做出选择哪个选项的决定。你会了解不同选项之间的差异以及使用一个而不是另一个的原因。此外，你将对实体API有一个很好的理解，这将反过来让你更容易地导航Drupal代码并与实体系统集成。最后，可能是Drupal开发者最常做的事情之一，你将能够与实体一起工作：执行CRUD操作、读取和写入字段值以及更多类似的事情。
- en: So, let's begin.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，让我们开始吧。
- en: Different types of data storage
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 不同类型的数据存储
- en: Storing and using data are a critical part of any (web) application. Without
    somehow persisting data we wouldn't be able to build much of anything. However,
    different uses of data warrant different systems for storing and manipulating
    it. For the purposes of this chapter, I will use the word *data* to mean almost
    anything that has to be persisted somewhere, for any given period of time.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 存储和使用数据是任何（网络）应用的关键部分。如果没有某种方式持久化数据，我们就无法构建很多东西。然而，不同的数据用途需要不同的存储和操作系统。在本章的目的上，我将使用“数据”一词来表示几乎任何需要持久化到某个地方的东西，无论持续多长时间。
- en: If you've done development in Drupal 7, you already know a few ways of storing
    data. We had entities (primarily the Node entity type, but others could be defined
    as well); the `variables` table, which was a relatively simple key/value store;
    and an API to interact with the database and do whatever we fancied. This caused
    many problems, such as a lack of consistency between APIs and much too heavy a
    reliance on the database for configuration storage.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你已经在Drupal 7中进行了开发，你已经知道了几种存储数据的方法。我们有过实体（主要是节点实体类型，但也可以定义其他类型）；`variables`
    表，这是一个相对简单的键/值存储；以及一个与数据库交互并执行我们想要的任何操作的API。这导致了许多问题，如API之间缺乏一致性，以及过度依赖数据库进行配置存储。
- en: In Drupal 8, various layered APIs have been introduced to tackle common use
    cases for data storage. The strength of these new systems is mirrored in the fact
    that we rarely, if ever, need to even use the mother of all storage APIs, the
    database API. This is because everything has been abstracted into different layers
    that help us handle most of what we need. So, creating a custom table is most
    likely not something you should be doing for storing your data anymore, although
    it definitely was a common practice in Drupal 7.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在Drupal 8中，引入了各种分层API来处理数据存储的常见用例。这些新系统的优势体现在我们很少，如果有的话，甚至需要使用所有存储API的母亲——数据库API。这是因为一切都被抽象成不同的层，帮助我们处理我们需要的绝大多数事情。因此，创建一个自定义表可能不再是存储你的数据的正确做法，尽管在Drupal
    7中这确实是一种常见的做法。
- en: State API
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 状态API
- en: The State API is a key/value database storage and the simplest way you can store
    some data in Drupal 8\. One of its main purposes is to allow developers to store
    information that relates to the *state* of the system (hence the name). And because
    the *state* of the system can be interpreted in various ways, think of this as
    simple information related to the current environment (Drupal installation) that
    is not editorial (content). An example would be the timestamp of the last time
    the Cron ran or any flags or markers that the system sets to keep track of its
    tasks. It is different from caching in that it is not meant to be cleared as often,
    and only the code that sets it is responsible for updating it.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 状态API是一种键/值数据库存储，是你在Drupal 8中存储数据的简单方式之一。其主要目的是允许开发者存储与系统状态（因此得名）相关的信息。由于系统的状态可以有多种解释，可以将此视为与当前环境（Drupal安装）相关的简单信息，这些信息不是编辑性的（内容）。一个例子是Cron上次运行的时间戳或系统设置的任何标志或标记，以跟踪其任务。它与缓存不同，因为它不需要经常清除，并且只有设置它的代码负责更新它。
- en: One of the main characteristics of this system is the fact that it is not designed
    for human interaction. I mean this in the sense that it is the application itself
    that needs to make use of it. The option for humans is the configuration system
    that we will talk about in detail in a later section.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 这个系统的主要特点之一是它并不是为人类交互而设计的。我的意思是，应用程序本身需要利用它。人类的选择是我们在稍后章节中将详细讨论的配置系统。
- en: So now that we know about the State API, let's jump into the technicalities
    and see what it's made of and how we can use it.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们已经了解了状态API，让我们深入技术细节，看看它是由什么构成的以及我们如何使用它。
- en: The State system revolves around the `Drupal\Core\State\StateInterface`, which
    provides all the methods you need to interact with it. This interface is implemented
    by the `State` service, which we can inject into your classes or use statically
    via the `\Drupal::state()` shorthand. Once we have that, things could not be easier,
    as the interface tells us exactly what we can do.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 状态系统围绕着 `Drupal\Core\State\StateInterface`，它提供了你与之交互所需的所有方法。这个接口由 `State` 服务实现，我们可以将其注入到你的类中，或者通过
    `\Drupal::state()` 简写方式静态地使用。一旦我们有了这个接口，事情就变得非常简单，因为它会告诉我们确切可以做什么。
- en: 'We can set a value:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以设置一个值：
- en: '[PRE0]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Or we can get a value:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 或者我们可以获取一个值：
- en: '[PRE1]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'We can also set/get multiple values at once (how convenient!):'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以一次设置/获取多个值（多么方便！）：
- en: '[PRE2]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Isn''t that easy? We can also get rid of them:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 难道不是很容易吗？我们还可以消除它们：
- en: '[PRE3]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'There are a couple of things to note here:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有几个需要注意的地方：
- en: First, the key names you choose live in a single namespace, so it's recommended
    that you prefix them with your module name—`my_module.my_key`. That way you avoid
    collision.
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 首先，你选择的键名位于单个命名空间中，因此建议你在它们前面加上你的模块名称——`my_module.my_key`。这样你就可以避免冲突。
- en: Second, the values you store can also be more complex than simple strings. You
    can store any scalar value, but also objects as they get serialized and deserialized
    automatically. Be careful, though, about which objects you plan on storing.
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 其次，你存储的值也可以比简单的字符串更复杂。你可以存储任何标量值，也可以存储对象，因为它们会自动进行序列化和反序列化。不过，请注意你打算存储的对象。
- en: Ensure that any classed objects you dump in there serialize and deserialize
    properly.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 确保你放入那里的任何类化对象都能正确地进行序列化和反序列化。
- en: 'By now, you are probably wondering where these values end up. They go into
    the `key_value` table, namespaced under the `state` collection. Also, the latter
    is a nice segue into a talk about the underlying system that powers the State
    API: the key/value store.'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 到现在为止，你可能想知道这些值最终会去哪里。它们会进入 `key_value` 表，位于 `state` 集合的命名空间下。此外，这也很好地过渡到讨论支撑
    State API 的底层系统：键/值存储。
- en: Note that the State system is only one implementation of an underlying framework
    of key/value stores. If you look at the `State` service, you will note that it
    uses the `KeyValueFactoryInterface` (which by default is implemented by the `KeyValueDatabaseFactory`).
    This, in turn, creates a key/value storage instance (by default, the `DatabaseStorage`),
    which implements the public API to interact with the store. If you take a look
    at the `key_value` table in the database, you'll note other collections besides
    *state*. Those are other implementations specific to various subsystems, such
    as the Entity API and System schema. Guess what? You can easily write your own
    and customize it to your needs. However, the reason why the State API was created
    was so that module developers can use it. Also, valid uses of it cover much of
    the need for something such as a key/value store. So odds are that you won't have
    to implement your own.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，State 系统只是底层键/值存储框架的一个实现。如果你查看 `State` 服务，你会注意到它使用 `KeyValueFactoryInterface`（默认情况下由
    `KeyValueDatabaseFactory` 实现）。这反过来又创建了一个键/值存储实例（默认情况下是 `DatabaseStorage`），它实现了与存储进行交互的公共
    API。如果你查看数据库中的 `key_value` 表，你会注意到除了 *state* 之外还有其他集合。这些是针对各种子系统的特定实现，例如实体 API
    和系统模式。猜猜看？你可以轻松编写自己的并根据自己的需求进行定制。然而，State API 被创建的原因是让模块开发者可以使用它。此外，它的有效用途涵盖了像键/值存储这样的需求的大部分。所以，你很可能不需要自己实现。
- en: TempStore
  id: totrans-32
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: TempStore
- en: The next system we will look at is the *TempStore* (temporary store).
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 我们接下来要查看的系统是 *TempStore*（临时存储）。
- en: The tempstore is a key/value, session-like storage system for keeping temporary
    data across multiple requests. Imagine a multistep form or a wizard with multiple
    pages as great examples of tempstore use cases. You can even consider "work in
    progress", that is, not yet permanently saved somewhere but kept in the tempstore
    so that a certain user can keep working on it until it's finished. Another key
    feature of the tempstore is that entries can have an expiration date, at which
    point they get automatically cleared. So that user had better hurry up.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: TempStore 是一个键/值、会话类似的存储系统，用于在多个请求之间保持临时数据。想象一下多步骤表单或具有多个页面的向导，这些都是 tempstore
    使用案例的绝佳例子。你甚至可以考虑“工作进度”，即尚未永久保存但保存在 tempstore 中，以便某个用户可以继续工作直到完成。TempStore 的另一个关键特性是条目可以有一个过期日期，届时它们会自动清除。所以用户最好快点。
- en: 'There are two kinds of tempstore APIs: a private and a shared one. The difference
    between the two is that with the first one, entries strictly belong to a single
    user, whereas with the second one, they can be shared between users. For example,
    the process of filling in a multistep form is the domain of a single user, so
    the data related to that must be private to them. However, that form can also
    be open to multiple users, in which case the data can either be shared between
    the users (quite uncommon) or used to trigger a locking mechanism that blocks
    user B from making changes while user A is editing (much more common). So, there
    are many options, but we will see some examples soon.'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 存储API有两种类型：私有和共享。这两种之间的区别在于，第一种中条目严格属于单个用户，而第二种中它们可以在用户之间共享。例如，填写多步骤表单的过程属于单个用户，因此相关的数据必须对他们来说是私有的。然而，该表单也可以对多个用户开放，在这种情况下，数据可以在用户之间共享（相当不常见）或者用来触发一个锁定机制，阻止用户B在用户A编辑时进行更改（更常见）。所以，有很多选择，但我们很快就会看到一些示例。
- en: First, though, let's look at some of the key players in this system.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们看看这个系统中的一些关键参与者。
- en: We start with the `PrivateTempStore` class, which provides the API for dealing
    with the private tempstore. It is not a service, because in order to use it, we
    must instantiate it via the `PrivateTempStoreFactory`. So that is what we have
    to inject into our classes if we want to use it. The latter has a `get($collection)`
    method which takes a collection name that we decide upon and creates a new `PrivateTempStore`
    object for it. If you look closely, the storage it uses is based on the `KeyValueStoreExpirableInterface`,
    which is very similar to the `KeyValueStoreInterface` used by the State API. The
    only difference is that the former has an expiration date, which allows the automatic
    removal of old entries. By default, the storage used in Drupal 8 is the `DatabaseStorageExpirable`,
    which uses the `key_value_expire` table to store the entries.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从`PrivateTempStore`类开始，它提供了处理私有临时存储的API。它不是一个服务，因为为了使用它，我们必须通过`PrivateTempStoreFactory`来实例化它。因此，如果我们想使用它，我们必须将其注入到我们的类中。后者有一个`get($collection)`方法，它接受我们决定的集合名称，并为其创建一个新的`PrivateTempStore`对象。如果你仔细看，它使用的存储基于`KeyValueStoreExpirableInterface`，这与State
    API使用的`KeyValueStoreInterface`非常相似。唯一的区别是前者有一个过期日期，这允许自动删除旧条目。默认情况下，Drupal 8中使用的存储是`DatabaseStorageExpirable`，它使用`key_value_expire`表来存储条目。
- en: Up to this point, the `SharedTempStore` is strikingly similar to the private
    one. It is instantiated using the `SharedTempStoreFactory` service and uses the
    same underlying database storage by default. The main difference is the namespace
    occupied in the `key_value_expire` table, which is composed by `user.shared_tempstore.collection_name`
    as opposed to `user.private_tempstore.collection_name`.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，`SharedTempStore`与私有存储非常相似。它是通过`SharedTempStoreFactory`服务实例化的，默认使用相同的底层数据库存储。主要区别在于`key_value_expire`表中占用的命名空间，它由`user.shared_tempstore.collection_name`组成，而不是`user.private_tempstore.collection_name`。
- en: Additionally, when asking the factory for the `SharedTempStore`, we have the
    option of passing an owner to retrieve it for. Otherwise, it defaults to the current
    user (the logged-in user ID or the anonymous session ID). Also, the way we interact
    with it and its purpose, more than anything, differ.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，当请求工厂的`SharedTempStore`时，我们有传递一个所有者来检索它的选项。否则，它默认为当前用户（登录用户ID或匿名会话ID）。此外，我们与之交互的方式及其目的，与任何其他事物相比，都存在差异。
- en: So, let's take a look at how we can work with the private and the shared tempstores.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，让我们看看我们如何与私有和共享的临时存储一起工作。
- en: Private TempStore
  id: totrans-41
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 私有TempStore
- en: 'The following is a simple example of what we just talked about:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是我们刚才讨论的简单示例：
- en: '[PRE4]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: First, we get the `PrivateTempStoreFactory` service and ask it for the store
    identified by a collection name we choose. It's always a good idea to prefix it
    with your module name to avoid collisions. If another module names their own collection
    `my_collection`, it's not going to be pretty (even if the store is private).
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们获取`PrivateTempStoreFactory`服务，并请求它为我们选择的集合名称提供的存储。总是建议在前面加上你的模块名称以避免冲突。如果另一个模块将它们的集合命名为`my_collection`，那么这看起来可能不太美观（即使存储是私有的）。
- en: Next, we use very simple setters and getters to set values similar to how we
    did with the State API.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们使用非常简单的设置器和获取器来设置值，这与我们使用State API的方式相似。
- en: 'If you run this code as user 1 (the main admin user), you''ll note a new entry
    in the `key_value_expire` database table. The collection will be `user.private_tempstore.my_module.my_collection`,
    while the name will be `1:my_key`. This is the core principle of the private tempstore:
    each entry name is prefixed with the ID of the user who is logged in when the
    entry was created. Had you been an anonymous user, it would have been something
    like this: `4W2kLm0ovYlBneHMKPBUPdEM8GEpjQcU3_-B3X6nLh0:my_key`, where that long
    string is the session ID of the user.'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你以用户1（主要管理员用户）的身份运行此代码，你会在`key_value_expire`数据库表中注意到一个新的条目。集合将是`user.private_tempstore.my_module.my_collection`，而名称将是`1:my_key`。这是私有临时存储的核心原则：每个条目名称都以前缀形式包含创建条目时登录用户的ID。如果你是一个匿名用户，它可能看起来像这样：`4W2kLm0ovYlBneHMKPBUPdEM8GEpjQcU3_-B3X6nLh0:my_key`，其中那个长字符串是用户的会话ID。
- en: The entry value will be a bit more complex than with the State API. This time
    it will always be a serialized `stdClass` object, which contains the actual value
    we set (which itself can be any scalar value or object that can be properly serialized),
    the owner (the user or session ID), and the last updated timestamp.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 条目值将比使用状态API更复杂。这次它将始终是一个序列化的`stdClass`对象，它包含我们设置的实际值（这本身可以是任何可以正确序列化的标量值或对象），所有者（用户或会话ID），以及最后更新时间戳。
- en: Lastly, we have the `expire` column, which, by default, will be one week from
    the moment the entry was created. This is a "global" timeframe set as a parameter
    in the `user.services.yml` definition file and can be altered in your own services
    definition file if you want. However, it is still global.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们有`expire`列，默认情况下，将从条目创建的那一刻起持续一周。这是一个“全局”时间范围，作为参数设置在`user.services.yml`定义文件中，如果你想要的话，可以在你自己的服务定义文件中更改它。然而，它仍然是全局的。
- en: 'We can also delete entries like so:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以这样删除条目：
- en: '[PRE5]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'And we can also read the information I mentioned before about the entry (the
    last update date, owner):'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以读取关于条目的信息（最后更新日期，所有者）：
- en: '[PRE6]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: This returns the `stdClass` object that wraps the entry value, but without the
    actual value.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 这将返回包装条目值的`stdClass`对象，但不包含实际值。
- en: Shared TempStore
  id: totrans-54
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 共享TempStore
- en: 'Now that we''ve seen how the private tempstore works, let''s look at the shared
    one. The first thing we need to do in order to interact with it is to use the
    factory to create a new shared store:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经看到了私有临时存储的工作方式，让我们看看共享存储。为了与之交互，我们首先需要使用工厂创建一个新的共享存储：
- en: '[PRE7]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: However, unlike the private tempstore, we can pass a user identifier (ID or
    session ID) as a second parameter to the `get()` method to retrieve the shared
    store of a particular owner. If we don't, it defaults to the current user (logged
    in or anonymous).
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，与私有临时存储不同，我们可以将用户标识符（ID或会话ID）作为`get()`方法的第二个参数传递，以检索特定所有者的共享存储。如果我们不这样做，它默认为当前用户（登录或匿名）。
- en: 'Then, the simplest way we can store/read an entry is like before:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们存储/读取条目的最简单方法与之前相同：
- en: '[PRE8]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Now, if we quickly jump to the database, we can see that the value column is
    the same as before, but the collection reflects that this is the shared store
    and the key is no longer prefixed by the owner. This is because another user should
    be able to retrieve the entry if they like. And the original owner can still be
    determined by checking the metadata of the entry:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果我们快速跳转到数据库，我们可以看到值列与之前相同，但集合反映了这是一个共享存储，并且键不再以前缀形式包含所有者。这是因为其他用户如果愿意，也应该能够检索条目。并且原始所有者可以通过检查条目的元数据来确定：
- en: '[PRE9]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Also, we can delete it exactly as with the private store:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们可以像删除私有存储一样删除它：
- en: '[PRE10]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Okay. However, what else can we do with the shared store that we cannot do with
    the other one?
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 好的。然而，我们还能用共享存储做些什么，而其他存储做不到的呢？
- en: 'First, we have two extra ways we can set an entry. We can set it if it doesn''t
    already exist:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们有两种额外的方式可以设置一个条目。如果我们还没有设置它，我们可以设置它：
- en: '[PRE11]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Alternatively, we can set it if it doesn''t exist or it belongs to the current
    user (that is, the user owns it):'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，如果它不存在或属于当前用户（即用户拥有它），我们可以设置它：
- en: '[PRE12]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Both these methods will return a Boolean, indicating whether the operation was
    successful or not. And essentially, they are handy to check for collisions. For
    example, if you have like a big piece of configuration that multiple users can
    edit, you can create the entry that stores the work in progress only if it doesn't
    exist, or if it exists and the current user owns it (virtually overwriting their
    own previous work, which may be okay).
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 这两种方法都将返回一个布尔值，指示操作是否成功。本质上，它们很方便用于检查冲突。例如，如果你有一个多个用户都可以编辑的大块配置，你只能在它不存在的情况下创建存储正在进行的工作的条目，或者如果它存在且当前用户拥有它（虚拟地覆盖他们自己的先前工作，这可能是可以接受的）。
- en: Then, you also have the `getIfOwner()` and `deleteIfOwner()` methods that you
    can use to ensure that you only use or delete the entry if it belongs to the current
    user.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，你还有`getIfOwner()`和`deleteIfOwner()`方法，你可以使用这些方法来确保你只使用或删除属于当前用户的条目。
- en: All this fuss, and for what? Why not just use the private store? This is because,
    in many cases, a flow can only be worked by one person at the time. So, if somebody
    started working on it, you will need to know in order to prevent others from working
    on it, but even more than that, you can allow certain users to "kick out" the
    previous user from the flow if they "went home without finishing it". They can
    then continue or clear out all the changes. It all depends on your use case.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些麻烦，究竟是为了什么？为什么不直接使用私有存储呢？这是因为，在许多情况下，一个流程只能由一个人同时处理。所以，如果有人开始处理它，你需要知道这一点，以防止其他人同时处理，但更重要的是，你可以允许某些用户在“没有完成就回家”的情况下“踢出”先前的用户从流程中。然后他们可以继续或者清除所有更改。这一切都取决于你的使用场景。
- en: Also, as a final point, the shared tempstore also works with the same expiration
    system as the private one.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，作为一个最后的要点，共享的临时存储也使用与私有存储相同的过期系统。
- en: Tempstore conclusion
  id: totrans-73
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Tempstore结论
- en: So, there we have two different, albeit similar, tempstores that you can use
    for various cases. If you need to store session-like data available to the user
    across multiple requests but which is private to them, you can use the `PrivateTempStore`.
    Alternatively, if this data needs to be used by either multiple users at the same
    time or the opposite, preventing multiple users from working on something at the
    same time, you can use the `SharedTempStore`.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们有两种不同但相似的临时存储，你可以用于各种情况。如果你需要存储在多个请求中可供用户使用但对他们来说是私有的会话数据，你可以使用`PrivateTempStore`。或者，如果这些数据需要同时被多个用户使用，或者相反，防止多个用户同时工作，你可以使用`SharedTempStore`。
- en: Both of them have an easy-to-understand API with simple methods and you can
    be flexible in terms of creating your own collections for whichever use case you
    need.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 它们两者都有一个易于理解的API，具有简单的方法，你可以根据自己的需求灵活地创建自己的集合。
- en: UserData
  id: totrans-76
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: UserData
- en: Now, I want to briefly talk about another user-specific storage option, provided
    by the User module, called *UserData*.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我想简要地谈谈另一个由用户模块提供的特定用户存储选项，称为*UserData*。
- en: The purpose of the UserData API is to allow the storage of certain pieces of
    information related to a particular user. Its concept is similar to the State
    API in that the type of information stored is not configuration that should be
    exported. In other words, it is specific to the current environment (but belonging
    to a given user rather than a system or subsystem).
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: UserData API的目的在于允许存储与特定用户相关的某些信息片段。其概念与State API类似，即存储的信息类型不是应该导出的配置。换句话说，它是特定于当前环境的（但属于特定用户，而不是系统或子系统）。
- en: Users are content entities, who can have fields of various data types. These
    fields are typically used for structured information pertaining to the user, for
    example, a first and a last name. However, if you need to store something more
    irregular, such as user preferences or flag that a given user has done something,
    the UserData is a good place to do that. This is because the information is either
    not something structured or is not meant for the users themselves to manage. So,
    let's see how this works.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 用户是内容实体，可以具有各种数据类型的字段。这些字段通常用于与用户相关的结构化信息，例如，一个名字和一个姓氏。然而，如果你需要存储更不规则的东西，比如用户偏好或标记一个特定用户已经做了某事，UserData是一个很好的地方来存储这些信息。这是因为信息要么不是结构化的，要么不是打算由用户自己管理的。那么，让我们看看它是如何工作的。
- en: 'The UserData API is made up of two things—the `UserDataInterface`, which contains
    the methods we can use to interact with it (plus developer documentation), and
    the `UserData` service, which implements it and can be used by the client code
    (us):'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: UserData API由两部分组成——`UserDataInterface`，其中包含我们可以用来与之交互的方法（以及开发者文档），以及`UserData`服务，它实现了它并且可以被客户端代码（我们）使用：
- en: '[PRE13]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'We are now ready to use the three methods on the interface:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们已经准备好在界面上使用这三个方法：
- en: '`get()`'
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`get()`'
- en: '`set()`'
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`set()`'
- en: '`delete()`'
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`delete()`'
- en: 'The first three arguments of all these methods are the same:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些方法的第一个三个参数都是相同的：
- en: '`$module`: to store data in a namespace specific to our module name, thereby
    preventing collisions'
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`$module`: 在我们模块名称的特定命名空间中存储数据，从而防止冲突'
- en: '`$uid`: to tie data to a given user—it doesn''t have to be the current user'
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`$uid`: 将数据与特定用户关联——不一定是当前用户'
- en: '`$name`: the name of the entry being stored'
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`$name`: 正在存储的条目名称'
- en: Naturally, the `set()` method also has the `$value` argument, which is the data
    being stored, and this can be any scalar value or serializable object.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 自然地，`set()` 方法也有 `$value` 参数，这是要存储的数据，它可以是一个标量值或可序列化的对象。
- en: Together, all these arguments make for a very flexible storage system, a much
    improved one compared to the Drupal 7 option. We can essentially, for one module,
    store multiple entries for a given user and it doesn't stop there. Since that
    is possible, many of these parameters are optional. For example, we can get all
    the entries for a given module at once or all the entries for a given module and
    user combination at once. The same goes for deleting them. But where does all
    this data go?
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 这些参数共同构成了一个非常灵活的存储系统，与Drupal 7选项相比有了很大的改进。对于单个模块，我们可以为特定用户存储多个条目，而且这还远不止于此。由于这是可能的，许多这些参数都是可选的。例如，我们可以一次性获取特定模块的所有条目，或者一次性获取特定模块和用户组合的所有条目。删除条目也是如此。但所有这些数据都去哪里了呢？
- en: The user module defines the `users_data` database table whose columns pretty
    much map to the arguments of these methods. The extra `serialized` column is there
    to indicate whether the stored data is serialized. Also, in this table, multiple
    records for a given user can coexist.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 用户模块定义了 `users_data` 数据库表，其列基本上映射到这些方法的参数。额外的 `serialized` 列用于指示存储的数据是否已序列化。此外，在这个表中，可以为特定用户存在多个记录。
- en: That is all there is to say about the UserData API. Use it wisely. Now it's
    time to turn to the configuration API, one of the biggest subsystems in Drupal
    8.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 关于UserData API就这么多要说的。明智地使用它。现在，是时候转向配置API了，它是Drupal 8中最大的子系统之一。
- en: Configuration
  id: totrans-94
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 配置
- en: The configuration API is one of the most important topics a Drupal 8 developer
    needs to understand. There are many aspects to it that tie it into other subsystems,
    so it is critical to be able to both use and understand it properly.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 配置API是Drupal 8开发者需要理解的最重要的话题之一。它有许多方面与其他子系统相关联，因此能够正确地使用和理解它是至关重要的。
- en: In this sub-chapter, we will cover a lot about the configuration system. We
    start by understanding what configuration is and what it is typically used for.
    Then, we will go through the different options we have for managing configuration
    in Drupal 8, both as a site builder and a developer using the Drush commands.
    Next, we will talk about how configuration is stored, where it belongs, and how
    it is defined in the system. We will also cover a few ways in which configuration
    can be overridden at different levels. Finally, we look at how we can interact
    with a simple configuration programmatically. So, let's begin with an introduction.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一小节中，我们将详细介绍配置系统。我们首先了解什么是配置以及它通常用于什么。然后，我们将探讨在Drupal 8中管理配置的不同选项，无论是作为网站构建者还是使用Drush命令的开发者。接下来，我们将讨论配置是如何存储的、它属于哪里以及如何在系统中定义。我们还将介绍一些可以在不同级别覆盖配置的方法。最后，我们将探讨如何以编程方式与简单的配置进行交互。那么，让我们从简介开始。
- en: Introduction
  id: totrans-97
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简介
- en: Configuration is the data that the proper functioning of an application relies
    upon. It is those bits of information that describe how things need to behave
    and helps control what code does. In other words, it configures the system to
    behave in a certain way with the expectation that it could also configure it to
    behave in a different way. To this end, configuration can be as simple as a toggle
    (turning something on or off) or as complicated as containing hundreds of parameters
    that describe an entire process.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 配置是应用程序正常运行所依赖的数据。它是那些描述事物应该如何行为的信息片段，有助于控制代码的执行。换句话说，它配置系统以特定方式运行，同时期望它也可以以不同的方式运行。为此，配置可以简单到只是一个开关（打开或关闭某个功能），也可以复杂到包含数百个参数，描述整个流程。
- en: The Drupal 8 configuration system is nothing short of a revolution in the Drupal
    world. It is not an improvement—it is a brand new way of thinking about managing
    configuration. Previously, there was no configuration management to speak of.
    Everything was stored in the database in a way that made it impossible to properly
    and consistently deploy the many configuration options that Drupal is known for.
    Yes, there was the Features module and the Ctools exportables, but their very
    existence highlighted that lack of consistency and this meant many a headache
    for lots of Drupal developers.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: Drupal 8 的配置系统在 Drupal 世界中可以说是一场革命。这不仅仅是一个改进——这是一种全新的思考管理配置的方式。在此之前，几乎可以说没有配置管理可言。所有内容都以一种使得无法正确和一致地部署
    Drupal 所知的多项配置选项的方式存储在数据库中。是的，有 Features 模块和 Ctools 可导出功能，但它们的存在恰恰凸显了缺乏一致性，这也给许多
    Drupal 开发者带来了不少麻烦。
- en: In Drupal 8, the entire thing has been revamped into a well-defined and consistent
    subsystem, upon which any little thing that needs to be configured can depend.
    Far be it for me to call it perfect; it still has its shortcomings and there is
    work in progress on making it better and creating tools for dealing with specific
    configuration flows. However, it has made managing and deploying configuration
    so much easier.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Drupal 8 中，整个系统已经被彻底改造成一个定义明确且一致的子系统，任何需要配置的小事都可以依赖它。我绝不敢称它完美；它仍然有其不足之处，并且正在进行改进，以使其更好，并创建处理特定配置流程的工具。然而，它已经使得管理和部署配置变得容易得多。
- en: What is configuration used for?
  id: totrans-101
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 配置有什么用？
- en: Configuration is used in Drupal 8 for storing everything that has to be synchronized
    between the different environments (for example, moving from development to production).
    As such, it differs from the other types of data storage we have seen so far in
    that they were specific to one environment.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Drupal 8 中，配置用于存储需要在不同环境之间同步的所有内容（例如，从开发到生产）。因此，它与迄今为止我们所看到的其他类型的数据存储不同，它们是特定于一个环境的。
- en: Another way of looking at configuration is by examining the role of a traditional
    site builder. They typically navigate the UI and configure the site to behave
    in a certain way—show this title on the home page, use this logo, show this type
    of content on the home page, and so on. As we mentioned, the result of their interactions
    materializes into configuration that the site builder expects would travel easily
    to the acceptance environment where it could be reviewed, and finally, to production.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种看待配置的方式是通过考察传统网站构建者的角色。他们通常会导航用户界面并配置网站以特定方式运行——在主页上显示这个标题，使用这个标志，在主页上显示这种类型的内容，等等。正如我们提到的，他们交互的结果会转化为网站构建者期望能够轻松迁移到验收环境的配置，最终到达生产环境。
- en: Some configuration can actually be critical to the proper functioning of the
    application. Certain code might break without a parameter having a value it can
    use. For example, if there is no site-wide email address set, what email will
    the system use to send its automated mails to the user? For this reason, many
    of these configuration parameters come with sane defaults (upon installation).
    However, this also shows that configuration is a part of the application and just
    as important as the actual code is.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 一些配置实际上对应用程序的正确运行至关重要。某些代码在没有使用其值的参数的情况下可能会出错。例如，如果没有设置全局电子邮件地址，系统将使用什么电子邮件发送自动邮件给用户？因此，许多这些配置参数都带有合理的默认值（在安装时）。然而，这也表明配置是应用程序的一部分，与实际代码一样重要。
- en: Managing configuration
  id: totrans-105
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 管理配置
- en: As we will see in a bit, Drupal stores configuration data in the database (for
    performance reasons), but it makes it all exportable to YAML files. So, a typical
    flow for managing it will have you perform changes in the UI, export the configuration,
    add it into Git, and deploy the code upstream to the next environment. There,
    it's just a matter of importing what is in code.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们很快就会看到的，Drupal 为了性能原因将配置数据存储在数据库中，但它使所有数据都可以导出到 YAML 文件。因此，管理它的典型流程将包括您在
    UI 中进行更改，导出配置，将其添加到 Git 中，并将代码部署到下一个环境。在那里，只需导入代码中的内容即可。
- en: 'The import, export, and synchronization can be done both via Drush and through
    the UI at `admin/config/development/configuration`:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 导入、导出和同步可以通过 Drush 和 UI 中的 `admin/config/development/configuration` 进行：
- en: '![](img/4fda6b29-d07b-45cc-a14b-4e6d3e10d26b.png)'
  id: totrans-108
  prefs: []
  type: TYPE_IMG
  zh: '![](img/4fda6b29-d07b-45cc-a14b-4e6d3e10d26b.png)'
- en: The typical flow is for the active site configuration to be synchronized with
    the one in the YAML files. This means importing into the database all the configurations
    that are different in the YAML files from those in the database. These YAML files
    are inside the configuration `sync` folder, which should be committed to Git (you
    can configure in the `settings.php` file which directory should be the `sync`
    folder) and the opposite is to export the active configuration to the YAML files
    in order to commit them into code.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 典型的流程是将活动网站配置与 YAML 文件中的配置同步。这意味着将所有与数据库中配置不同的 YAML 文件中的配置导入到数据库中。这些 YAML 文件位于配置
    `sync` 文件夹中，应提交到 Git（您可以在 `settings.php` 文件中配置哪个目录应该是 `sync` 文件夹），相反，是将活动配置导出到
    YAML 文件中，以便将其提交到代码中。
- en: 'The UI allows only the first option (sync what''s in the YAML files with the
    database), but it provides you with a nice Diff interface to see what is different
    in YAML compared with the database:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: UI 只允许第一个选项（将 YAML 文件中的内容与数据库同步），但它提供了一个很好的 Diff 界面，以查看 YAML 与数据库相比有什么不同：
- en: '![](img/cd479d37-876d-4f0d-b607-e1e1e5c90fc1.png)'
  id: totrans-111
  prefs: []
  type: TYPE_IMG
  zh: '![](img/cd479d37-876d-4f0d-b607-e1e1e5c90fc1.png)'
- en: In this screenshot we can see that the YAML files contain a small change in
    the site name configuration. Clicking on Import all will bring the database in
    line with the YAML files.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 在此屏幕截图中，我们可以看到 YAML 文件包含站点名称配置的一小部分更改。点击“导入全部”将使数据库与 YAML 文件保持一致。
- en: 'The first time you install a Drupal 8 site, the configuration `sync` folder
    will be empty. It is up to you to do a manual export of all the active configuration
    and put it there. You can do so via the UI manual export or through Drush:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 第一次安装 Drupal 8 网站时，配置 `sync` 文件夹将是空的。您需要手动导出所有活动配置并将其放置在那里。您可以通过 UI 手动导出或通过
    Drush 来完成此操作：
- en: '[PRE14]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: You would perform this step every time you make configuration changes through
    the UI that you want exported into YAML files.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 每当您通过 UI 进行配置更改并希望将其导出到 YAML 文件时，您都会执行此步骤。
- en: 'Then, you can synchronize either in the UI as we''ve seen, or through Drush,
    with the following command:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，您可以在 UI 中同步，就像我们看到的，或者通过以下命令通过 Drush 进行同步：
- en: '[PRE15]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: As a Drupal developer, you will be mostly using these two Drush commands.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 作为 Drupal 开发者，您将主要使用这两个 Drush 命令。
- en: In addition to the entire set of configuration items, you can also import/export
    individual ones by copying and pasting. Be careful though, as some dependencies
    might not allow you to do so. However, this is useful if you want to quickly see
    something working in another environment, but the approach does not lend itself
    to a nice version control-based flow if you abuse it.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 除了整个配置项集之外，您还可以通过复制粘贴来导入/导出单个配置项。但请注意，某些依赖项可能不允许您这样做。然而，如果您想快速在其他环境中看到某些内容生效，这很有用，但如果滥用这种方法，它不会为基于版本控制的流程提供良好的解决方案。
- en: Different types of configuration
  id: totrans-120
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 不同的配置类型
- en: Drupal 8 comes with two distinct types of configuration—simple and configuration
    entities. Let's see what the difference is.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: Drupal 8 提供两种不同的配置类型——简单配置和配置实体。让我们看看它们之间的区别。
- en: Simple configuration is the type that stores basic data, typically represented
    by scalar values such as integers or strings. On the other hand, configuration
    entities are more complex and use the same CRUD API as the content entities.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 简单配置是存储基本数据的一种类型，通常由整数或字符串等标量值表示。另一方面，配置实体更复杂，并使用与内容实体相同的 CRUD API。
- en: Typically, simple configuration items are one of a kind. A module, for instance,
    may create and manage a configuration item that enables or disables one of its
    features. Most likely, this module needs this configuration to know what it should
    do about that feature. However, even if it doesn't, it is still a singular item
    that relates to that piece of functionality.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，简单的配置项是独一无二的。例如，一个模块可以创建和管理一个配置项，该配置项可以启用或禁用其功能之一。很可能，这个模块需要这个配置来知道它应该对这个功能做什么。然而，即使它不需要，它仍然是一个与该功能相关的单一项目。
- en: Configuration entities, on the other hand, are multiple instances of the same
    configuration type. For example, a View is a configuration entity and a given
    site can have an unlimited number of views. It can even have none. We will talk
    more about configuration entities when we cover entities in general.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 配置实体，另一方面，是同一配置类型的多个实例。例如，视图是一个配置实体，一个特定的站点可以有无限数量的视图。它甚至可以没有视图。当我们讨论一般实体时，我们将更详细地讨论配置实体。
- en: Configuration storage
  id: totrans-125
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 配置存储
- en: 'Configuration is essentially stored in two places:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 配置基本上存储在两个地方：
- en: The active storage (by default in the database)
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 默认情况下，活动存储（在数据库中）
- en: The sync storage (by default the YAML files)
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 同步存储（默认为YAML文件）
- en: 'Here is an example of a simple configuration YAML file:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是一个简单的配置YAML文件的示例：
- en: '[PRE16]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The name of this file is given by the ID you need to use with the configuration
    API to read this data.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 这个文件的名称是由你需要与配置API一起使用的ID给出的。
- en: 'In addition to the actual data, you can have a `dependencies` key under which
    you can list what this configuration item depends on:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 除了实际数据之外，你可以在`dependencies`键下列出这个配置项所依赖的内容：
- en: '[PRE17]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'There are three types of dependencies: modules, themes, and other configuration
    items.'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 有三种类型的依赖项：模块、主题和其他配置项。
- en: 'If you remember in [Chapter 2](601b4dd0-c521-459e-9342-2645a109642c.xhtml),
    *Creating Your First Module,* we created a configuration object with the `hello_world.custom_salutation`
    ID in which we stored a simple value:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你记得在[第2章](601b4dd0-c521-459e-9342-2645a109642c.xhtml)，*创建您的第一个模块*，我们创建了一个具有`hello_world.custom_salutation`
    ID的配置对象，并在其中存储了一个简单的值：
- en: '[PRE18]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: And we did so programmatically through our form and did not provide a YAML file.
    This meant that our code for displaying the salutation did not depend on this
    configuration item existing or having a value of some kind. Had it been mandatory
    for our code to work, we could have created it upon module installation. There
    are two ways this can be done.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过表单程序化地这样做，并没有提供YAML文件。这意味着我们用于显示问候语的代码不依赖于这个配置项的存在或具有某种类型的值。如果我们的代码必须工作，我们可以在模块安装时创建它。有两种方法可以实现这一点。
- en: The most common way is statically. Inside the `config/install` folder of a module,
    we can have YAML configuration files that get imported when the module is installed.
    However, if the values we need to set in this configuration are unknown (they
    need to be retrieved dynamically), we can do so in a `hook_install()` implementation
    (remember those from [Chapter 3](360802d2-dd46-4d08-b478-9351d56ed2a0.xhtml),
    *Logging and Mailing*?). There, we can try to get our value and create the configuration
    object containing it.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 最常见的方式是静态的。在一个模块的`config/install`文件夹中，我们可以有在模块安装时被导入的YAML配置文件。然而，如果我们需要设置的配置值是未知的（它们需要动态检索），我们可以在`hook_install()`实现中这样做（还记得[第3章](360802d2-dd46-4d08-b478-9351d56ed2a0.xhtml)，*日志和邮件*？）。在那里，我们可以尝试获取我们的值并创建包含它的配置对象。
- en: Note that configurations found inside the `config/install` folder of the module
    will not be imported when the module is installed if they have unmet dependencies; that
    is, if whatever they depend on does not exist in the system. As a matter of fact,
    the module itself would not install.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，如果模块的`config/install`文件夹中的配置存在未满足的依赖项，即它们所依赖的任何内容在系统中不存在，那么在安装模块时，这些配置将不会被导入；也就是说，模块本身将无法安装。
- en: As a bonus, you can also provide configuration files with the module that should
    only be imported if their dependencies are met. In other words, optional configuration.
    If dependencies of these configurations are not met, the module will install correctly
    but without those configurations. Moreover, if later on the dependencies are met,
    these optional configurations do get also imported automatically. Keep in mind,
    however, that optional configuration is reserved for configuration entities as
    it does not make sense with simple configurations.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 作为额外的好处，您还可以提供配置文件与模块一起，只有当它们的依赖项满足时才导入。换句话说，这是可选的配置。如果这些配置的依赖项未满足，模块将正确安装，但不会包含这些配置。此外，如果后来依赖项得到满足，这些可选配置也会自动导入。然而，请记住，可选配置仅限于配置实体，因为它与简单配置无关。
- en: Schema
  id: totrans-141
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 模式
- en: In order for various systems to properly interact with the configuration items,
    configuration schemas have been introduced. Schemas are a way to define the configuration
    items and specify what kind of data they store, be it strings, Booleans, integers,
    and so on. They are, of course, notated in YAML format and go inside the `config/schema`
    folder of a module.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 为了让各种系统能够正确地与配置项交互，引入了配置模式。模式是一种定义配置项并指定它们存储的数据类型的方式，无论是字符串、布尔值、整数等等。当然，它们以
    YAML 格式表示，并位于模块的 `config/schema` 文件夹中。
- en: 'There are three main reasons why configuration needs a schema definition:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 配置需要模式定义有三个主要原因：
- en: '**Multilingual support**: As we will see later, configuration is translatable
    in Drupal 8\. However, in order to know which parts of the configuration are needed
    to be, or can be, translated, the schema system has been brought in to provide
    this additional layer. This way, configuration items that ship with contributed
    modules can get their own translations on the [localize.drupal.org](https://localize.drupal.org/)
    website. Moreover, the schema identifies which configuration bits can be translated,
    and this allows users to provide translations for those in the UI.'
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**多语言支持**：正如我们稍后将要看到的，Drupal 8 中的配置是可翻译的。然而，为了知道配置的哪些部分需要或可以翻译，引入了模式系统以提供这一额外的层。这样，与贡献模块一起提供的配置项可以在
    [localize.drupal.org](https://localize.drupal.org/) 网站上获得自己的翻译。此外，模式识别哪些配置位可以翻译，这使用户能够在用户界面中提供翻译。'
- en: '**Configuration entities**: Configuration entities require schema definitions
    in order for the proper identification in the persistence layer of the data types
    that need to be exported with them. Moreover, schemas are used for the validation
    of configuration entities.'
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**配置实体**：配置实体需要模式定义，以便在持久化层中正确识别需要与其一起导出的数据类型。此外，模式也用于验证配置实体。'
- en: '**Typecasting**: Configuration schema ensures that the configuration API is
    able to always typecast properly the values to their right data types.'
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**类型转换**：配置模式确保配置 API 能够始终正确地将值转换为它们正确的数据类型。'
- en: 'Let''s look at a configuration example provided by Drupal core to see how the
    schema works, namely the `system.mail` configuration provided by the `System`
    module. Remember in [Chapter 3](360802d2-dd46-4d08-b478-9351d56ed2a0.xhtml), *Logging
    and Mailing,* we talked about how this configuration item controls the mail plugin
    used for sending out emails? Well, by default, this is what it looks like:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看 Drupal 核心提供的配置示例，以了解模式是如何工作的，即由 `System` 模块提供的 `system.mail` 配置。记住在 [第
    3 章](360802d2-dd46-4d08-b478-9351d56ed2a0.xhtml)，*日志和邮件*，我们讨论了如何控制用于发送电子邮件的邮件插件？默认情况下，它看起来是这样的：
- en: '[PRE19]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'It''s a very simple multidimensional array. So, if we now look in the `system.schema.yml`
    file for the schema definition, we will find the definitions for all the configuration
    items that come with the System module. The top-level line represents the name
    of the configuration item, so if we scroll down, we will find `system.mail`:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 它是一个非常简单的多维数组。因此，如果我们现在查看 `system.schema.yml` 文件中的模式定义，我们将找到与系统模块一起提供的所有配置项的定义。顶级行代表配置项的名称，因此如果我们向下滚动，我们将找到
    `system.mail`：
- en: '[PRE20]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: If we look past the irony of the schema being five times bigger than the actual
    configuration, we can get a pretty good understanding of what this configuration
    item is all about. And more importantly, Drupal itself can too.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们忽略模式比实际配置大五倍这一讽刺之处，我们可以很好地理解这个配置项的实质。更重要的是，Drupal 本身也能做到这一点。
- en: We can see that the `system.mail` configuration is of the `config_object` type.
    This is one of the two main types of configurations, the other being `config_entity`.
    The `label` key is used to indicate the human-readable name of this item, whereas
    the `mapping` key contains the definition of its individual elements. We can see
    the `interface` having the label "Interfaces" and the type `sequence`. The latter
    is a specific type that denotes an array in which the keys are not important.
    Whenever we want the keys to be taken into account, we will use `mapping` (as
    it's done at the top level of this schema definition). And since we are looking
    at a `sequence` type, the individual items inside it are also defined as a string
    type with their own label.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到 `system.mail` 配置是 `config_object` 类型。这是配置的两种主要类型之一，另一种是 `config_entity`。`label`
    键用于表示此项目的可读名称，而 `mapping` 键包含其单个元素的定义。我们可以看到 `interface` 有标签“接口”和类型 `sequence`。后者是一个特定的类型，表示一个数组，其中键不重要。每当我们要考虑键时，我们将使用
    `mapping`（如在此架构定义的最高级别所做的那样）。由于我们正在查看 `sequence` 类型，因此它内部的单个项目也被定义为具有自己标签的字符串类型。
- en: 'Let''s now write our own schema definition for the example configuration file
    we saw before:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们为之前看到的示例配置文件编写我们自己的架构定义：
- en: '[PRE21]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'If this configuration was found inside a file called `my_module.settings.yml`,
    this would be the corresponding schema definition:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 如果这个配置位于名为 `my_module.settings.yml` 的文件中，这将是对应的架构定义：
- en: '[PRE22]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'As a bonus piece of information, any `config_object`-typed configuration inherits
    the following property:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 作为额外信息，任何 `config_object` 类型的配置都继承了以下属性：
- en: '[PRE23]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: This helps with the multilingual system and invites us to add a `langcode` property
    to each configuration item.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 这有助于多语言系统，并邀请我们为每个配置项添加一个 `langcode` 属性。
- en: 'Most of the properties we''ve seen so far have been `type`, `label`, `mapping`,
    and `sequence`. There are two more that you should be aware of:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 我们迄今为止看到的大多数属性都是 `type`，`label`，`mapping` 和 `sequence`。还有两个你应该注意的：
- en: '`translatable` : very important as it indicates whether a type can be translated.
    By default, `text` and `label` types are already set to translatable, so you don''t
    need to do so yourself.'
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`translatable`：非常重要，因为它表示一个类型是否可以被翻译。默认情况下，`text` 和 `label` 类型已经设置为可翻译，所以你不需要自己进行设置。'
- en: '`nullable` : indicates whether the value can be left empty. If missing, it''s
    considered as being required.'
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`nullable`：表示值是否可以留空。如果缺失，则被视为必需。'
- en: 'Here are some types you can use to define configuration:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一些你可以用来定义配置的类型：
- en: 'Scalar types: `string`, `integer`, `boolean`, `email`, `float`, `uri`, `path`'
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 标量类型：`string`，`integer`，`boolean`，`email`，`float`，`uri`，`path`
- en: 'Lists: `mapping`, `sequence`'
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 列表：`mapping`，`sequence`
- en: 'Complex (extending scalar types): `label`, `path`, `text`, `date_format` and
    more.'
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 复杂（扩展标量类型）：`label`，`path`，`text`，`date_format` 等。
- en: Make sure you check out the `core.data_types.schema.yml` file where all  of
    these are defined.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 确保你查看 `core.data_types.schema.yml` 文件，其中定义了所有这些内容。
- en: 'Before we move on, let''s make sure we create the configuration schema for
    our configuration item we created programmatically in [Chapter 2](601b4dd0-c521-459e-9342-2645a109642c.xhtml),
    *Creating Your First Module*, namely the one storing the overridden salutation
    message. So, inside the `/config/schema` folder of the *Hello World* module, we
    can have the `hello_world.schema.yml` file with the following:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们继续之前，让我们确保我们为我们在[第2章](601b4dd0-c521-459e-9342-2645a109642c.xhtml)，“创建你的第一个模块”中程序化创建的配置项创建配置架构，即存储覆盖问候信息的那个。因此，在
    *Hello World* 模块的 `/config/schema` 文件夹中，我们可以有 `hello_world.schema.yml` 文件，内容如下：
- en: '[PRE24]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: That takes care of some technical debt we introduced back when we didn't know
    about configuration schemas.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 这解决了我们之前在不知道配置架构的情况下引入的一些技术债务。
- en: Overrides
  id: totrans-171
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 覆盖
- en: We saw that configuration exists in the but actually belongs in organized and
    well-described YAML files. In order for the configuration from the YAML files
    to be used, they need to be imported—either via synchronization or upon module
    installation for those provided by modules. So, this means that the database still
    holds the active configuration.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 我们看到配置存在于配置文件中，但实际上应该属于组织良好且描述清晰的 YAML 文件中。为了使 YAML 文件中的配置能够使用，它们需要被导入——无论是通过同步还是对于由模块提供的配置，在模块安装时进行导入。因此，这意味着数据库仍然保留着活动的配置。
- en: To make things more dynamic, the configuration API also provides an override
    system by which we can, at various levels, override the active configuration on
    the fly. In Drupal 7 that was done via the global `$conf` variable, but that was
    also a way to, unfortunately, leak the overrides into the actual configuration
    pool. This is no longer the case in Drupal 8, and we also have three different
    layers at which we can override configuration (global, module and language overrides).
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使事情更加动态，配置API还提供了一个覆盖系统，我们可以通过这个系统在各个级别上动态覆盖活动配置。在Drupal 7中，这是通过全局`$conf`变量完成的，但这也是不幸地将覆盖泄露到实际配置池中的方法。在Drupal
    8中，情况不再是这样，我们还可以在三个不同的层级上覆盖配置（全局、模块和语言覆盖）。
- en: The configuration API then takes into account these overrides in a way that
    prevents leaking them by accident into the active configuration. We will see examples
    when we talk about how to interact with the configuration API in general.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 配置API会考虑到这些覆盖，以防止它们意外地泄露到活动配置中。当我们讨论如何与配置API交互时，我们将看到示例。
- en: Global overrides
  id: totrans-175
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 全局覆盖
- en: 'In Drupal 8, we still have this possibility via a global variable, this time
    called `$config`. This variable is available in the `settings.php` file for site-wide
    overrides, but you can also use it inside your module (if you really have to!)
    in order to override a specific piece of configuration:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 在Drupal 8中，我们仍然可以通过全局变量来获得这种可能性，这次称为`$config`。这个变量在`settings.php`文件中可用于网站范围的覆盖，但你也可以在模块内部使用它（如果你真的需要的话！）以覆盖特定的配置：
- en: '[PRE25]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: In this example, we changed, on the fly, the message used for the site maintenance
    mode. Why you would want to do that is beside the point, but you may have some
    other configuration which would benefit from being overridable like this. In any
    case, you notice the array notation we use. The first key is the name of the configuration
    item (name of the file minus the `.yml` extension) and then we have the key of
    the individual element in the configuration file. If this were to be nested, we'd
    be traversing further down.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们动态地更改了用于网站维护模式的消息。你为什么要这样做并不重要，但你可能有一些其他配置可以从这种覆盖中受益。无论如何，你注意到了我们使用的数组表示法。第一个键是配置项的名称（文件名减去`.yml`扩展名），然后是我们配置文件中个别元素的键。如果它是嵌套的，我们将进一步遍历。
- en: Global config overrides are a great place where you can use environment-specific
    and/or sensitive data such as API keys. Things like this should never be exported
    to the sync storage. Instead, you can define a configuration object in the module
    and have it installed without a value. Then, using the global override, you provide
    the value specific to the relevant environment.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 全局配置覆盖是一个很好的地方，你可以使用特定环境或敏感数据，例如API密钥。这类信息绝不应该导出到同步存储中。相反，你可以在模块中定义一个配置对象，并在没有值的情况下安装它。然后，使用全局覆盖，你可以提供针对相关环境的特定值。
- en: Module overrides
  id: totrans-180
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 模块覆盖
- en: Although you can simply use the global `$config` array, that is not really the
    place where modules should be tinkering. First of all, because it's a global variable
    and it's never a good idea to change global variables, it should be left to the
    `settings.php` file. Second of all, because there is no way of controlling priority
    if multiple modules try to change it in the same way. Instead, we have the module
    override system that we can use.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然你可以简单地使用全局`$config`数组，但这并不是模块应该修改的地方。首先，因为它是一个全局变量，改变全局变量从来不是一个好主意，它应该留给`settings.php`文件。其次，因为没有办法控制多个模块以相同方式修改它的优先级。相反，我们有模块覆盖系统可以使用。
- en: 'Via the module overrides, we can create a service with the `config.factory.override`
    tag (remember what tagged services are?) and in this service, handle our overrides.
    To exemplify, let''s use this system to override the maintenance mode message.
    Inside our Hello World module, we can have the following service class:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 通过模块覆盖，我们可以创建一个带有`config.factory.override`标签的服务（记得标签化服务是什么吗？）在这个服务中处理我们的覆盖。为了举例，让我们使用这个系统来覆盖维护模式消息。在我们的Hello
    World模块中，我们可以有以下服务类：
- en: '[PRE26]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Here, we have to implement the `ConfigFactoryOverrideInterface` interface which
    comes with four methods:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们必须实现`ConfigFactoryOverrideInterface`接口，该接口包含四个方法：
- en: In `loadOverrides()` we provide our overridden configuration values.
  id: totrans-185
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在`loadOverrides()`中，我们提供我们的覆盖配置值。
- en: In `getCacheSuffix()` we return a simple string to be used in the static cache
    identifier of our overrides.
  id: totrans-186
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在`getCacheSuffix()`中，我们返回一个简单的字符串，用于我们覆盖的静态缓存标识符。
- en: In `createConfigObject()` we don't actually do anything but we could create
    a configuration API object that would be used during installation or synchronization.
  id: totrans-187
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 `createConfigObject()` 方法中，我们实际上并没有做任何事情，但我们可以创建一个配置 API 对象，该对象将在安装或同步过程中使用。
- en: In `getCacheableMetadata()` we return any cache metadata related to our override.
    We don't have any so we return an empty object.
  id: totrans-188
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 `getCacheableMetadata()` 方法中，我们返回与我们的覆盖相关的任何缓存元数据。我们没有这样的元数据，所以我们返回一个空对象。
- en: Since this is a service, we can inject dependencies and make use of them if
    we want to calculate the overrides. Depending on this calculation, it can become
    important to set some proper cache metadata as well, but we will cover caching
    in another chapter.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这是一个服务，我们可以注入依赖项并在需要计算覆盖时使用它们。根据这个计算，设置一些适当的缓存元数据可能变得很重要，但我们将另章介绍缓存。
- en: 'Next, we register this as a tagged service:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将此注册为带标签的服务：
- en: '[PRE27]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: We set the priority to 5 and, with this, we can control the order in which modules
    get their chance at overriding configuration. The higher priority will take precedence
    over the lower one.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将优先级设置为 5，这样我们就可以控制模块覆盖配置的顺序。优先级高的将优先于优先级低的。
- en: And that's it. Clearing the cache will register this service and alter our configuration.
    If you now put the site in maintenance mode, you will notice that the message
    is the one we set here. However, if you go to the maintenance mode administration
    page at `admin/config/development/maintenance`, you will still see the original
    message. This is so that administrators do not, by accident, save the override
    value into the configuration storage.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 就这些了。清除缓存将注册此服务并更改我们的配置。如果你现在将站点置于维护模式，你会注意到显示的消息就是我们在这里设置的。然而，如果你转到 `admin/config/development/maintenance`
    的维护模式管理页面，你仍然会看到原始消息。这是为了防止管理员意外地将覆盖值保存到配置存储中。
- en: Language overrides
  id: totrans-194
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 语言覆盖
- en: Although we will talk some more about the multilingual features of Drupal 8,
    let's briefly note the possibility of the language overrides.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管我们还会进一步讨论 Drupal 8 的多语言特性，但让我们简要地提一下语言覆盖的可能性。
- en: If we enable configuration translation and add some more languages to our site,
    we can translate configuration items that are translatable (as described by their
    schema). In doing so, we are overriding the default configuration for a particular
    language, an override that gets stored in the configuration storage and can be
    exported to YAML files. So this is an exportable type of override.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们启用配置翻译并添加更多语言到我们的站点，我们可以翻译可翻译的配置项（如它们的模式所描述）。在这样做的时候，我们正在覆盖特定语言的默认配置，这个覆盖将被存储在配置存储中，并可以导出为
    YAML 文件。所以这是一种可导出的覆盖类型。
- en: 'We can make use of this override programmatically, even if we are not in a
    specific language context. This is what the code would look like, assuming we
    have an override in French for our maintenance mode message and we want to use
    that:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 即使不在特定的语言环境中，我们也可以编程式地使用这个覆盖。以下是一个示例代码，假设我们有一个针对维护模式消息的法语覆盖，并且我们想使用它：
- en: '[PRE28]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: This looks a bit complicated, but it's not really. First, we load the language
    manager service and get the `Language` object for our language (the one we want
    to get the overridden value for). Then, we keep track of the original configuration
    override language (which is essentially the current language) but also set the
    French language as the one to be used going forward. Finally, we load the `system.maintenance`
    configuration object and read its message in French before restoring the original
    language on the language manager. This is a quick way to illustrate an approach
    by which we can temporarily switch language contexts for configuration overrides.
    And this will be the way to load configuration entities in a different language
    to the current one.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 这看起来有点复杂，但实际上并不复杂。首先，我们加载语言管理器服务并获取我们语言的 `Language` 对象（我们想要获取覆盖值的语言）。然后，我们跟踪原始配置覆盖语言（这基本上是当前语言），但同时也将法语设置为后续要使用的语言。最后，我们加载
    `system.maintenance` 配置对象，在语言管理器上恢复原始语言之前，读取其法语消息。这是一种快速展示我们可以通过临时切换语言环境来实现配置覆盖的方法。而且这将是我们以不同于当前语言的方式加载配置实体的方式。
- en: Priority
  id: totrans-200
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 优先级
- en: 'We have three layers for configuration overrides: global, modules, and languages.
    This is actually also the order of the actual priority they have. Global overrides
    take precedence over everything else, while module overrides take precedence over
    the language ones. This is why, if we have overridden the `system.maintenance`
    configuration in the module, we cannot use the language override in our code.
    So, keep this in mind.'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有三个配置覆盖层：全局、模块和语言。这实际上是它们实际优先级的顺序。全局覆盖优先于其他所有内容，而模块覆盖优先于语言覆盖。这就是为什么如果我们已经在模块中覆盖了`system.maintenance`配置，我们无法在我们的代码中使用语言覆盖。所以，请记住这一点。
- en: Interacting with simple configuration
  id: totrans-202
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 与简单配置交互
- en: Now that we have talked about what the Drupal 8 configuration API is, what is
    it used for, how is it managed and stored, and what are some of the options for
    overriding it, it's time to talk about the API itself and how we can interact
    with it. In this section, we will focus only on simple configuration as we will
    talk more about configuration entities when we cover all entities.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们已经讨论了Drupal 8配置API是什么，它用于什么，如何管理和存储它，以及一些覆盖它的选项，现在是时候讨论API本身以及我们如何与之交互了。在本节中，我们将仅关注简单配置，因为我们将在介绍所有实体时更多地讨论配置实体。
- en: In Chapter 2, *Creating Your First Module*, we already became somewhat exposed
    to the configuration API in our `SalutationConfigurationForm` where we stored
    and read a simple configuration value. Now it's time to go a bit deeper to understand
    the API and look at some more examples of how we can use it.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 在第2章“创建您的第一个模块”中，我们已经通过`SalutationConfigurationForm`对配置API有所了解，我们在其中存储和读取了一个简单的配置值。现在是时候深入理解API并查看一些更多示例，了解我们如何使用它。
- en: The class that represents simple configuration is `Drupal\Core\Config` and it
    wraps around the data found in one individual configuration item. Moreover, it
    does all the necessary in terms of interacting with the underlying storage system
    in order to persist the configuration (by default into the database). In addition,
    it handles the overrides we talked about earlier automatically.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 表示简单配置的类是`Drupal\Core\Config`，它围绕单个配置项中找到的数据进行包装。此外，它还处理了之前提到的所有必要的与底层存储系统交互操作，以便持久化配置（默认情况下存储到数据库中）。此外，它自动处理我们之前讨论的覆盖。
- en: An important subclass of `Config` that we work with a lot is `ImmutableConfig`.
    Its purpose is to prevent changes being made to the configuration object, and
    as such, it is for read-only uses.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 我们经常与之打交道的`Config`的一个重要子类是`ImmutableConfig`。它的目的是防止对配置对象进行更改，因此它适用于只读用途。
- en: 'The way we get to use instances of these classes is through the `ConfigFactory`
    service which has two handy methods for getting a configuration object:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 我们获取这些类实例的方式是通过`ConfigFactory`服务，该服务有两个方便的方法用于获取配置对象：
- en: '[PRE29]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'The `get()` method returns an `ImmutableConfig` object that is read-only, while
    the `getEditable()` method returns a `Config` object that can be used also for
    changing the configuration values. The way we do this is via the `set()` and `save()`
    methods:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: '`get()`方法返回一个只读的`ImmutableConfig`对象，而`getEditable()`方法返回一个`Config`对象，也可以用于更改配置值。我们通过`set()`和`save()`方法来完成这项操作：'
- en: '[PRE30]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Very simple. We also have the `setData()` method which allows us to change the
    entire data of the configuration item at once. As a parameter, it expects an associative
    array of values.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 非常简单。我们还有`setData()`方法，它允许我们一次性更改配置项的全部数据。作为参数，它期望一个值关联数组。
- en: 'TIP: If you cannot inject the `ConfigFactory` but have to rely on the static
    call, the `Drupal` class has a shortcut for loading config objects directly: `$config
    = \Drupal::config(''system.maintenance'');`. The `config()` method takes the name
    of the configuration as a parameter and returns an `ImmutableConfig` object.'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 提示：如果您无法注入`ConfigFactory`但必须依赖静态调用，`Drupal`类有一个直接加载配置对象的快捷方式：`$config = \Drupal::config('system.maintenance');`。`config()`方法接受配置名称作为参数，并返回一个`ImmutableConfig`对象。
- en: 'To read the data, we have a number of options. We can read one element from
    the config:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 读取数据时，我们有多种选择。我们可以从配置中读取一个元素：
- en: '[PRE31]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'If the element is nested, we can traverse down via the dot `(.)` notation:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 如果元素是嵌套的，我们可以通过点`(.)`表示法向下遍历：
- en: '[PRE32]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: This will return the value set for the 403 page in the `system.site` configuration.
    We can also get all the values by simply not passing any parameters to the `get()`
    method, which would return an associative array.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 这将返回为 `system.site` 配置中的403页面设置的值。我们也可以通过不向 `get()` 方法传递任何参数来获取所有值，这将返回一个关联数组。
- en: 'If you remember our discussion about the configuration overrides, by default,
    the `get()` method will return the values as they had been overridden through
    the module or globally (or as a language if the language manager has a different
    language set for configuration). However, if we want, we can also retrieve the
    original value:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你还记得我们关于配置覆盖的讨论，默认情况下，`get()` 方法将返回通过模块或全局（或如果语言管理器为配置设置了不同的语言）覆盖的值。然而，如果我们想，我们也可以检索原始值：
- en: '[PRE33]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: The second parameter of `getOriginal()` indicates whether to apply overrides
    and, by default, it is `TRUE`. So this way, we get the configuration value that
    is set in the active storage.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: '`getOriginal()` 方法的第二个参数表示是否应用覆盖，默认情况下它是 `TRUE`。因此，这样我们就能获取到在活动存储中设置的配置值。'
- en: 'Finally, we can also clear configuration values or the entire objects themselves.
    For example, consider the following code:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们还可以清除配置值或整个对象本身。例如，考虑以下代码：
- en: '[PRE34]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'It will remove the `message` key from the configuration object and save it
    without that value. Alternatively, we can also remove the entire thing:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 它将移除配置对象中的 `message` 键并保存不带该值的配置。或者，我们也可以完全移除它：
- en: '[PRE35]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: That is pretty much it. The power of this API also stems from its simplicity.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 大概就是这样。这个API的强大之处也源于其简单性。
- en: Entities
  id: totrans-226
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实体
- en: We have finally reached the point where we talk about the most complex, robust,
    and powerful system for modeling data and content in Drupal 8—the Entity API.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 我们终于到了讨论Drupal 8中最复杂、最稳健、最强大的数据建模和内容建模系统的点——实体API。
- en: Entities have been around since Drupal 7 which shipped with a few types such
    as node, taxonomy terms, users, comments, files, and so on. However, Drupal core
    only provided a basic API for defining entities and loading them consistently.
    The *Entity API* contributed module bridged a large gap and provided a lot of
    functionality to make entities much more powerful. In Drupal 8, however, these
    principles (and more) are found in core as part of a robust data modeling system.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 实体自Drupal 7以来就存在了，当时它包含了一些类型，如节点、分类术语、用户、评论、文件等。然而，Drupal核心只为定义实体和一致地加载它们提供了基本的API。*实体API*
    贡献模块填补了很大的差距，并为实体提供了很多功能，使实体变得更加强大。但在Drupal 8中，这些原则（以及更多）作为稳健的数据建模系统的一部分包含在核心中。
- en: The Entity API integrates seamlessly with the multilingual system to bring fully
    translatable content and configuration entities. This means that most data you
    store can be translated easily into multiple languages. In Drupal 7, this was
    always a herculean task that involved over 10 contributed modules to achieve something
    not nearly as powerful as we have now.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 实体API无缝集成到多语言系统中，以提供完全可翻译的内容和配置实体。这意味着你存储的大多数数据都可以轻松地翻译成多种语言。在Drupal 7中，这始终是一项艰巨的任务，需要超过10个贡献模块才能实现现在所拥有的功能。
- en: Because there is so much to cover about entities, in this section we will start
    with just a general overview of the entity system. But not to worry, in the next
    section, and all the way to the end of this chapter, we will break it down and
    talk about all the important aspects.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 因为关于实体有很多要讲的内容，所以在本节中，我们将从对实体系统的概述开始。但不用担心，在下一节，以及本章的结尾，我们将将其分解并讨论所有重要的方面。
- en: Content versus configuration entity types
  id: totrans-231
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 内容与配置实体类型
- en: 'Let us start by establishing some basic terminology in order to prevent confusion
    down the line:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先确立一些基本术语，以避免后续的混淆：
- en: Entities are instances of a given entity type. Thus, we can have one or more
    entities of a certain type, the latter being like a blueprint for the individual
    entities.
  id: totrans-233
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实体是给定实体类型的实例。因此，我们可以有一个或多个某种类型的实体，后者是单个实体的蓝图。
- en: 'Entity types can be of two kinds: content and configuration.'
  id: totrans-234
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实体类型可以分为两种：内容和配置。
- en: We talked a little bit about configuration entities in the previous section.
    There, we saw that they are multiple instances of a certain *type* of configuration,
    as opposed to simple configuration, which is only one set of configuration values.
    Essentially, configuration entities are exportable sets of configuration values
    that inherit much of the same handling API as content entities.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节中，我们简要讨论了配置实体。在那里，我们看到它们是某种特定**类型**配置的多个实例，而不是简单的配置，后者只有一组配置值。本质上，配置实体是可导出的配置值集合，它们继承了与内容实体相同的大量处理
    API。
- en: 'Some examples of configuration entity types:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 一些配置实体类型的示例：
- en: 'View: A set of configuration values that make up a view'
  id: totrans-237
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 视图：构成视图的一组配置值
- en: 'Image Style: Defines how an image needs to be manipulated in that given style'
  id: totrans-238
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 图片样式：定义了在给定样式下图像需要如何被操作
- en: 'Role: Defines a role that can be given to a user'
  id: totrans-239
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 角色：定义可以分配给用户的角色
- en: Content entities, on the other hand, are not exportable and are the most important
    way we can model and persist data in Drupal 8\. These can be used for content
    and all sorts of other structured data used in your business logic that needs
    to be persisted but not deployed to other environments.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 内容实体，另一方面，是不可导出的，并且是我们可以在 Drupal 8 中建模和持久化数据的最重要方式。这些可以用于内容以及所有其他在您的业务逻辑中需要持久化但不需要部署到其他环境中的结构化数据。
- en: 'Some examples of content entity types:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 一些内容实体类型的示例：
- en: Node
  id: totrans-242
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 节点
- en: Comment
  id: totrans-243
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 评论
- en: User
  id: totrans-244
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户
- en: Taxonomy Term
  id: totrans-245
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 分类术语
- en: Apart from the exportability aspect, the main difference between content and
    configuration entities is the type of fields they use. The latter uses simpler
    fields, the combination of which gets stored as one entity "record" in the database
    (and exported to YAML). The content entity fields are complex and structured both
    in code modeling and in the persistence layer (the database).
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 除了可导出方面，内容和配置实体之间的主要区别在于它们使用的字段类型。后者使用更简单的字段，这些字段的组合存储为数据库中的一个实体“记录”（并导出到 YAML）。内容实体字段在代码建模和持久化层（数据库）中都是复杂和结构化的。
- en: Moreover, configuration entities also lack bundles. Bundles are yet another
    categorization of entities that sits below the content entity type. That means
    that each content entity type can have (but it doesn't have to have) one or more
    bundles, onto which configurable fields can be attached. And not to throw more
    confusion at you but bundles are actually configuration entities themselves as
    they need to be exported, and there can be multiples of them.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，配置实体还缺少捆绑。捆绑是实体分类的另一种形式，位于内容实体类型之下。这意味着每个内容实体类型都可以有（但不一定有）一个或多个捆绑，可配置字段可以附加到这些捆绑上。而且为了避免给您带来更多困惑，捆绑实际上是配置实体本身，因为它们需要被导出，并且可以有多个。
- en: The Entity API is very flexible in terms of the types of data that you can store.
    Content entity types come with a number of different field types for various forms
    of data, from primitive values to more complex ones such as dates or references.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 实体 API 在存储数据类型方面非常灵活。内容实体类型包含多种不同的字段类型，用于各种形式的数据，从原始值到更复杂的数据，如日期或引用。
- en: Content entities can also be made revisionable. This means content entity types
    can be configured to keep in store older versions of the same entity with some
    extra metadata related to the change process.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 内容实体也可以被设置为可修订的。这意味着内容实体类型可以被配置为存储与变更过程相关的额外元数据的同一实体的旧版本。
- en: 'In this section and going forward, I will illustrate the most common features
    of entities by way of exemplifying two entity types:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节以及接下来的内容中，我将通过举例说明两种实体类型来展示实体的最常见功能：
- en: 'Node: The most prolific content entity type that comes with Drupal core and
    that is typically used as the main content modeling entity type'
  id: totrans-251
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 节点：Drupal 核心中最丰富的内容实体类型，通常用作主要的内容建模实体类型
- en: 'NodeType: The configuration entity type that defines Node bundles'
  id: totrans-252
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 节点类型：定义节点捆绑的配置实体类型
- en: In the next chapter, we will learn how to create our own. But after everything
    we will have  here, it will be a breeze.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将学习如何创建自己的。但有了这里的一切，那将是一件轻而易举的事情。
- en: Entity type plugins
  id: totrans-254
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实体类型插件
- en: 'Entity types are registered with Drupal as plugins. Yes, again. The `Drupal\Core\Entity\Annotation\EntityType`
    class is the base annotation class for these plugins and you will mainly see two
    subclasses (annotations): `ContentEntityType` and `ConfigEntityType`. These are
    used to register content and configuration entity types, respectively.'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 实体类型以插件的形式注册到 Drupal 中。是的，又是这样。`Drupal\Core\Entity\Annotation\EntityType` 类是这些插件的基础注解类，你将主要看到两个子类（注解）：`ContentEntityType`
    和 `ConfigEntityType`。这些用于分别注册内容和配置实体类型。
- en: The annotations classes map to plugin classes used to represent the entity types.
    The base class for these is `Drupal\Core\Entity\EntityType`, which is then extended
    by another `ContentEntityType` and `ConfigEntityType`. These plugin classes are
    used to represent the entity types in the system and are a good resource for seeing
    what kind of data we can use on the annotation of these plugins. At a quick glance
    we can already see that the differences between the two types is not so big.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 注解类映射到用于表示实体类型的插件类。这些插件的基础类是 `Drupal\Core\Entity\EntityType`，然后由另一个 `ContentEntityType`
    和 `ConfigEntityType` 扩展。这些插件类用于在系统中表示实体类型，并且是查看我们可以在这些插件的注解中使用哪些数据的良好资源。快速浏览一下，我们就可以看到这两种类型之间的差异并不大。
- en: The plugin manager for entity types is the `EntityTypeManager`, an important
    service you will probably interact with most as a Drupal developer. Apart from
    various handy things we will see a bit later, it is responsible for managing the
    entity type plugins using the regular annotation-based discovery method.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 实体类型的插件管理器是 `EntityTypeManager`，这是一个作为 Drupal 开发者你可能会与之交互最多的重要服务。除了我们稍后会看到的各种实用功能外，它还负责使用基于常规注解的发现方法管理实体类型插件。
- en: The Node entity type is defined in `Drupal\node\Entity\Node`, where you will
    see a huge annotation at the top of the class. The NodeType configuration entity
    type, on the other hand, is found in `Drupal\node\Entity\NodeType`. You can spot
    the difference in the annotation they use.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 节点实体类型定义在 `Drupal\node\Entity\Node` 中，在那里你会在类的顶部看到一个巨大的注解。另一方面，节点类型配置实体类型位于
    `Drupal\node\Entity\NodeType` 中。你可以看到它们使用的注解之间的差异。
- en: Identifiers
  id: totrans-259
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 标识符
- en: 'The entity type annotations start with some basic information about them: ID,
    label, and things like that. For example, consider the Node entity:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 实体类型注解以一些关于它们的基本信息开始：ID、标签等。例如，考虑节点实体：
- en: '[PRE36]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: These are used in various places in the system to properly reference the entity
    type by machine and human readable names.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 这些在系统中的多个地方被用来通过机器和可读名称正确地引用实体类型。
- en: Bundles
  id: totrans-263
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 束
- en: 'The Node entity type happens to have bundles which is the reason why we have
    a `bundle_label` property as well:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 节点实体类型恰好有束，这也是为什么我们还有一个 `bundle_label` 属性的原因：
- en: '[PRE37]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'We can deduce that Node has bundles by the fact that it references the ID of
    the plugin defining the bundle configuration entity type:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过它引用定义束配置实体类型的插件 ID 来推断出节点有束。
- en: '[PRE38]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Lo and behold, that is the NodeType's `ConfigEntityType` plugin ID. On its plugin
    annotation, we can find the reverse `bundle_of` property that references the Node
    entity type. Needless to say, this is not mandatory for all configuration entity
    types but used for the ones that act as content entity bundles. For example, the
    `View` configuration entity type does not have this.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 哇，这就是节点类型的 `ConfigEntityType` 插件 ID。在其插件注解中，我们可以找到反向的 `bundle_of` 属性，它引用了节点实体类型。不用说，这并不是所有配置实体类型的强制要求，但用于那些作为内容实体束的实体类型。例如，`View`
    配置实体类型就没有这个属性。
- en: 'In addition, we also find on the Node plugin annotation the route to where
    the bundles are configured:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们还在节点插件注解中找到了配置束的路径：
- en: '[PRE39]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: This is a route defined for the NodeType configuration entity.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个为节点类型配置实体定义的路径。
- en: As I mentioned earlier, bundles do not exist for configuration entities.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 如我之前提到的，束对于配置实体来说是不存在的。
- en: Database tables
  id: totrans-273
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 数据库表
- en: 'Another important bit of information for content entities is the database table
    name they will use for storage:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 对于内容实体来说，另一个重要的信息是它们将用于存储的数据库表名：
- en: '[PRE40]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: The `node` table in this case holds the primary information about the entities
    such as ID, uuid or bundle, while the `node_field_data` table holds field data
    that is singular and not translatable. Otherwise, these fields get their own database
    tables automatically. I will explain how field data is stored a bit later on.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，`node` 表存储了关于实体（如ID、uuid或bundle）的原始信息，而`node_field_data` 表则存储了单一且不可翻译的字段数据。否则，这些字段会自动拥有自己的数据库表。我将在稍后解释字段数据是如何存储的。
- en: Entity keys
  id: totrans-277
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实体键
- en: 'The entity API defines a set of *keys* that are consistent across all entity
    types and by which common entity information can be retrieved. Since not all entity
    types need to have the same fields for storing that data, there is a mapping that
    can be done in the annotation for these:'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 实体API定义了一套*键*，这些键在所有实体类型中都是一致的，并且可以通过这些键检索常见的实体信息。由于并非所有实体类型都需要存储这些数据的相同字段，因此可以在注释中进行映射：
- en: '[PRE41]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: The Node entity type has a relatively comprehensive example of entity keys.
    As you can see, the unique identifier field for Nodes has always been `nid`. However,
    the common identifier for entities across the system is `id`. So, a mapping here
    helps facilitate that.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 节点实体类型有一个相对全面的实体键示例。正如你所见，节点的唯一标识字段一直是`nid`。然而，系统内实体的通用标识符是`id`。因此，这里的映射有助于简化这个过程。
- en: Links
  id: totrans-281
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 链接
- en: 'Each entity type has a series of links the system needs to know about. Things
    like the canonical URL, the edit URL, the creation URL, and so on. For the node
    entities we have the following:'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 每个实体类型都需要一系列系统需要了解的链接。例如，规范URL、编辑URL、创建URL等。对于节点实体，我们有以下链接：
- en: '[PRE42]'
  id: totrans-283
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Like the entity keys, these links are common across all entity types (depending
    on their enabled capabilities). For example, all entity types have a canonical
    URL and the API allows to quickly find out which one that is based on the definition.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 与实体键一样，这些链接在所有实体类型中都是通用的（取决于它们启用的功能）。例如，所有实体类型都有一个规范URL，API允许根据定义快速找到它。
- en: One thing to note about these paths is that they need to be defined as routes.
    So, you can find them inside the `node.routing.yml` file (where you also find
    the routes used by the NodeType configuration entity type). Alternatively, though,
    these routes can be defined dynamically in order to prevent duplication. This
    can be done using a route provider handler. We will talk about handlers soon but
    also see a concrete example in the next chapter. In case you were wondering where
    the missing routes for the Node links are, check the `NodeRouteProvider` that
    registers them.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 关于这些路径有一点需要注意，它们需要定义为路由。因此，你可以在`node.routing.yml`文件中找到它们（在那里你也可以找到由NodeType配置实体类型使用的路由）。不过，这些路由也可以动态定义，以防止重复。这可以通过使用路由提供者处理器来实现。我们将在稍后讨论处理器，并在下一章中看到一个具体的示例。如果你想知道节点链接缺失的路由在哪里，请查看注册它们的`NodeRouteProvider`。
- en: Entity translation
  id: totrans-286
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实体翻译
- en: 'Entities are translatable across the board—like most of everything else in
    Drupal 8\. To mark an entity type as such, all we need is the following in the
    plugin annotation:'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 实体在全局范围内都是可翻译的——就像Drupal 8中的大多数其他内容一样。为了标记一个实体类型为可翻译，我们只需要在插件注释中包含以下内容：
- en: '[PRE43]'
  id: totrans-288
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: This exposes the entity type to all the multilingual goodness. However, as we
    will see a bit later, the individual fields also need to be declared translatable.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 这使得实体类型能够利用所有多语言功能。然而，正如我们稍后将看到的，各个字段也需要声明为可翻译。
- en: Entity revisions
  id: totrans-290
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实体修订
- en: In Drupal 8, all content entity types can be made revisionable (and publishable)
    with minimal effort. Since Node is such an example, we can check out how it's
    built to understand this better.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 在Drupal 8中，所有内容实体类型都可以通过最小努力实现可修订（并可发布）。由于节点是一个很好的例子，我们可以检查其构建方式以更好地理解这一点。
- en: 'First, the annotation needs to have the database table information where revisions
    are stored. This mirrors exactly the original tables we saw before:'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，注释需要包含存储修订的数据库表信息。这正好与之前看到的原始表相对应：
- en: '[PRE44]'
  id: totrans-293
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Second, the annotation needs to have the entity keys for the revision ID and
    the published status we saw earlier:'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 其次，注释需要包含我们之前看到的修订ID和发布状态的实体键：
- en: '[PRE45]'
  id: totrans-295
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Third, also in the annotation, the revision metadata keys need to be referenced:'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 第三，在注释中还需要引用修订元数据键：
- en: '[PRE46]'
  id: totrans-297
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: These map to table columns in the revision table. And in order to ensure that
    all the necessary columns get created, the entity type class should extend from
    `EditorialContentEntityBase` which provides the necessary field definitions for
    this. But good to know also that this base class already implements the `EntityPublishedInterface`
    which allows to make the entity type publishable.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 这些映射到修订表中的表列。为了确保创建所有必要的列，实体类型类应该扩展 `EditorialContentEntityBase`，它提供了为此所需的字段定义。但也要知道，这个基类已经实现了
    `EntityPublishedInterface`，这使得实体类型可发布。
- en: Finally, the entity fields themselves are not automatically revisionable so
    a flag needs to be also set on them. Again, we will see that in a minute when
    we talk about the fields.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，实体字段本身不是自动可修订的，因此也需要在它们上设置一个标志。我们将在讨论字段时再次看到这一点。
- en: Configuration export
  id: totrans-300
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 配置导出
- en: 'Configuration entity types have a few extra options on their plugin definitions
    that relate to the exportability of the entities. By default, a number of configuration
    entity fields are persisted and exported. However, the `config_export` property
    needs to be used to declare which other fields should be included in the export.
    For example, the NodeType configuration entity type defines the following:'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 配置实体类型在其插件定义中有一些额外的选项，这些选项与实体的可导出性相关。默认情况下，许多配置实体字段都会被持久化和导出。然而，需要使用 `config_export`
    属性来声明应包含在导出中的其他字段。例如，节点类型配置实体类型定义了以下内容：
- en: '[PRE47]'
  id: totrans-302
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: Keep in mind that, without this definition, the configuration schema is used
    as a fallback to determine which fields to persist. If the configuration entity
    type doesn't have a schema (which it should though), no extra fields will get
    persisted.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，如果没有这个定义，配置模式将用作后备来确定哪些字段需要持久化。如果配置实体类型没有模式（尽管它应该有），则不会持久化任何额外字段。
- en: 'Additionally, configuration entity types have a prefix that is used for the
    namespace in the configuration system. This is also defined in the plugin annotation:'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，配置实体类型有一个用于配置系统中命名空间的名称前缀。这也在插件注解中定义：
- en: '[PRE48]'
  id: totrans-305
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: Handlers
  id: totrans-306
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理器
- en: 'The last main group of settings found on the entity type plugin annotations
    are the handlers. Handlers are the objects used by the entity API to manage various
    tasks related to entities. The Node entity type is a good example to look at because
    it defines quite a lot of them, giving us an opportunity to learn:'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 在实体类型插件注解中找到的最后一个主要设置组是处理器。处理器是实体API用来管理与实体相关的各种任务的对象。节点实体类型是一个很好的例子，因为它定义了相当多的处理器，给我们提供了一个学习的机会：
- en: '[PRE49]'
  id: totrans-308
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: As we can immediately notice, these are all simple references to classes. So,
    when in doubt, it's always a good idea to go and see what they do and how they
    work. But let's briefly talk about all of them and see what their main responsibility
    is.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们立即可以注意到的，这些都是对类的简单引用。所以，当有疑问时，总是一个好的主意去查看它们做什么以及它们是如何工作的。但让我们简要地谈谈所有这些，看看它们的主要责任是什么。
- en: The `storage` handler is one of the most important. It does all that has to
    do with CRUD operations and interacting with the underlying storage system. It
    is always an implementation of `EntityStorageInterface` and sometimes a parent
    of the `ContentEntityStorageBase` or `ConfigEntityStorage` classes. If the entity
    type does not declare one, it will default to `SqlContentEntityStorage` (since
    we are using a SQL database most of the time) or `ConfigEntityStorage` for configuration
    entities.
  id: totrans-310
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`storage` 处理器是最重要的之一。它处理所有与 CRUD 操作和与底层存储系统交互相关的事情。它始终是 `EntityStorageInterface`
    的一个实现，有时是 `ContentEntityStorageBase` 或 `ConfigEntityStorage` 类的父类。如果实体类型没有声明一个，它将默认使用
    `SqlContentEntityStorage`（因为我们大多数时候使用 SQL 数据库）或 `ConfigEntityStorage` 用于配置实体。'
- en: The `storage_schema` handler is not something you will deal with too much. Its
    purpose is to handle the schema preparations for the storage handler. It will
    default to the `SqlContentEntityStorageSchema` if one is not provided and it will
    take care of the database tables needed for the entity type definition.
  id: totrans-311
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`storage_schema` 处理器不是你将过多接触的东西。它的目的是处理存储处理器的模式准备。如果没有提供，它将默认使用 `SqlContentEntityStorageSchema`，并负责为实体类型定义所需的数据库表。'
- en: The `view_builder` handler is an `EntityViewBuilderInterface` implementation
    responsible for creating a render array out of an entity with the purpose of preparing
    it for display. If one is not specified, it defaults to `EntityViewBuilder`.
  id: totrans-312
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`view_builder` 处理器是一个 `EntityViewBuilderInterface` 实现，负责从实体创建一个渲染数组，目的是为显示做准备。如果没有指定，则默认为
    `EntityViewBuilder`。'
- en: The `access` handler is an `EntityAccessControlHandlerInterface` implementation
    responsible for checking the access for any of the CRUD operations on a given
    entity of the respective type. If one is not provided, the default `EntityAccessControlHandler`
    is used; it also triggers the access hooks modules can implement to have a say
    in the access rules of a given entity. We will talk a lot more about access in
    a dedicated chapter later on.
  id: totrans-313
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`access` 处理器是一个 `EntityAccessControlHandlerInterface` 实现，负责检查给定类型的实体上任何 CRUD
    操作的访问权限。如果没有提供，则使用默认的 `EntityAccessControlHandler`；它还会触发模块可以实现的访问钩子，以便在给定实体的访问规则中发表意见。我们将在后面的专门章节中详细讨论访问问题。'
- en: The `views_data` handler is an `EntityViewsDataInterface` implementation responsible
    for exposing the respective entity type to the Views API. This is used so that
    Views is able to properly understand the entity and fields. By default, it uses
    the generic `EntityViewsData` if one is not provided.
  id: totrans-314
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`views_data` 处理器是一个 `EntityViewsDataInterface` 实现，负责将相应的实体类型暴露给 Views API。这是为了让
    Views 能够正确理解实体和字段。如果没有提供，则默认使用 `EntityViewsData`。'
- en: The `form` handlers are `EntityFormInterface` implementations used for various
    types of entity manipulations such as create, edit and delete. The referenced
    classes are forms that are used for managing the entities.
  id: totrans-315
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`form` 处理器是用于各种实体操作（如创建、编辑和删除）的 `EntityFormInterface` 实现。所引用的类是用于管理实体的表单。'
- en: The `route_provider` handlers are `EntityRouteProviderInterface` implementations
    responsible for dynamically providing routes necessary for the respective entity
    type. The Node entity type defines one for HTML pages, but others can be defined
    for other kinds of HTTP formats as well.
  id: totrans-316
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`route_provider` 处理器是负责为相应实体类型动态提供必要路由的 `EntityRouteProviderInterface` 实现。节点实体类型定义了一个用于
    HTML 页面的路由，但也可以为其他类型的 HTTP 格式定义。'
- en: The `list_builder` handler is an `EntityListBuilderInterface` implementation
    responsible for building a listing of entities of the respective type. This listing
    is typically used on the administration screen for managing the entities. This
    is an important one to have since, without it, the admin listing won't work. The
    default implementation is `EntityListBuilder`.
  id: totrans-317
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`list_builder` 处理器是一个 `EntityListBuilderInterface` 实现，负责构建相应类型的实体列表。这个列表通常用于管理实体的管理屏幕。这是非常重要的，因为没有它，管理员列表将无法工作。默认实现是
    `EntityListBuilder`。'
- en: The `translation` handler is a `ContentTranslationHandlerInterface` implementation
    responsible for exposing the entities of this type to the translation API.
  id: totrans-318
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`translation` 处理器是一个 `ContentTranslationHandlerInterface` 实现，负责将此类型的实体暴露给翻译
    API。'
- en: Fields
  id: totrans-319
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 字段
- en: The principal way data is modeled by entities is through fields. Entities themselves
    are essentially just a collection of different types of fields that hold various
    types of data.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 实体通过字段建模数据的主要方式。实体本身基本上只是一个不同类型字段的集合，这些字段持有各种类型的数据。
- en: Drupal 7 developers will remember that in D7, entities had two types of fields,
    usually referred to as properties and Field UI fields. The former were essentially
    simple properties on the entity class and were stored in the entity table itself.
    The latter were fields that were attached to bundles through the UI and had separate
    database tables.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: Drupal 7 开发者会记得，在 D7 中，实体有两种类型的字段，通常被称为属性和 Field UI 字段。前者实际上是实体类上的简单属性，存储在实体表中。后者是通过
    UI 附属于捆绑的，并且有单独的数据库表。
- en: 'Things are somewhat similar in Drupal 8 but also very different. First of all,
    there is a big difference between the fields that belong to content versus configuration
    entities. Then, as in D7, we still make a distinction between two types of content
    entity fields: base fields and configurable fields. However, this is not as big
    as it used to be in D7 as they both have the same foundation.'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Drupal 8 中，情况有些相似，但也非常不同。首先，内容实体和配置实体所属的字段之间存在很大差异。然后，就像在 D7 中一样，我们仍然区分两种内容实体字段：基本字段和可配置字段。然而，这并不像
    D7 中那样大，因为它们都有相同的基础。
- en: Configuration entity fields
  id: totrans-323
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 配置实体字段
- en: Configuration entities have relatively simple fields, due to their storage handling.
    We can store complex configuration but there is no complex database schema to
    reflect that. Instead, we have the configuration schema layer that describes configuration
    entities so the Entity API can understand the types of data they store and represent.
    We talked about this earlier in the chapter when we looked at the configuration
    system. But let's examine the NodeType configuration entity type to better understand
    its fields.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 由于它们的存储处理，配置实体具有相对简单的字段。我们可以存储复杂的配置，但没有复杂的数据库模式来反映这一点。相反，我们有配置模式层，它描述了配置实体，以便实体API可以理解它们存储和表示的数据类型。我们之前在查看配置系统时讨论了这一点。但让我们检查NodeType配置实体类型，以更好地理解其字段。
- en: The fields on configuration entities are essentially declared as class properties.
    So, we can see that NodeType has fields such as `$description`, `$help` and others.
    As I mentioned a bit earlier, the plugin annotation includes a reference to the
    class properties that are to be persisted and exported. As you can imagine, a
    class should be allowed to also have some properties that are not actually field
    values that need to be exported.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 配置实体的字段基本上被声明为类属性。因此，我们可以看到NodeType具有诸如`$description`、`$help`等字段。正如我之前提到的，插件注解包括对要持久化和导出的类属性的引用。正如你可以想象的那样，一个类应该允许有一些属性，这些属性实际上不是需要导出的字段值。
- en: The configuration entity class can also have some specific getter and setter
    methods for its field, but can also rely on the `ConfigEntityBase` parent class
    `set()` and `get()` methods for setting and accessing field values. Things are
    relatively simple to understand.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 配置实体类也可以为其字段提供一些特定的获取器和设置器方法，但也可以依赖于`ConfigEntityBase`父类的`set()`和`get()`方法来设置和访问字段值。事情相对简单易懂。
- en: 'Now, let''s check out the NodeType configuration schema found in `node.schema.yml`
    and see what that is all about:'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们检查一下在`node.schema.yml`中找到的NodeType配置模式，看看它究竟是什么：
- en: '[PRE50]'
  id: totrans-328
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: This is just a sample of the schema definition without some of the fields because
    we already know how to read those. However, there are some things that are new
    though.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 这只是一个没有一些字段的模式定义示例，因为我们已经知道如何读取那些。然而，也有一些新事物。
- en: We can see the wildcard notation that indicates that this schema should apply
    to all configuration items that start with that prefix. So, essentially, to all
    entities of a certain type. In this case, the entity type name is `type`, as denoted
    in the NodeType annotation `config_prefix` property. Of course, the namespace
    is prefixed by the module name.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到通配符表示法，这表明此模式应适用于以该前缀开头的所有配置项。所以，本质上，适用于所有特定类型的实体。在这种情况下，实体类型名称是`type`，正如在NodeType注解的`config_prefix`属性中所表示的。当然，命名空间由模块名称作为前缀。
- en: Next, we see that the type is `config_entity`, which is the other major complex
    type besides `config_object` used to denote simple configuration. These are basically
    extensions of the `mapping` type with some extra information. In the case of configuration
    entities, these are the definitions for the fields that automatically get exported—`uuid`,
    `langcode`, `status`, `dependencies` and `third_party_settings`. That is to say,
    these fields exist on all configuration entities of any type and are always persisted/exported.
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们看到类型是`config_entity`，这是除了用于表示简单配置的`config_object`之外的另一个主要复杂类型。这些基本上是`mapping`类型的扩展，包含一些额外信息。在配置实体的情况下，这些是自动导出的字段定义——`uuid`、`langcode`、`status`、`dependencies`和`third_party_settings`。也就是说，这些字段存在于任何类型的所有配置实体上，并且始终被持久化和导出。
- en: Lastly, we have the schema definitions for each individual field, such as `name`,
    `type`, and more. So, now the system knows that the `new_revision` field should
    be treated as a Boolean, or that the `name` field is translatable (since it is
    of a type label that extends the simple `string` type with the translation flag
    on).
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们有每个单独字段的模式定义，例如`name`、`type`等。因此，现在系统知道`new_revision`字段应该被视为布尔值，或者`name`字段是可翻译的（因为它是一种类型标签，它扩展了简单的`string`类型，并带有翻译标志）。
- en: So, as you can see, the field matrix of a configuration entity type is not so
    complex to understand. Content entities are much more complex and we will talk
    about those next.
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，正如你所看到的，配置实体类型的字段矩阵并不复杂，容易理解。内容实体要复杂得多，我们将在下一节讨论这些。
- en: Content entity fields
  id: totrans-334
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 内容实体字段
- en: 'As in Drupal 7, content entities in D8 have two types of fields: base fields
    and configurable fields. For Drupal 7 developers, the former are essentially the
    old "property" fields, while the latter are the "Field UI" fields. However, as
    we will see in a moment, they are now very different implementations in that they
    are very similar to each other.'
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 与 Drupal 7 类似，D8 中的内容实体有两种类型的字段：基础字段和可配置字段。对于 Drupal 7 开发者来说，前者实际上是旧的“属性”字段，而后者是“字段
    UI”字段。然而，正如我们一会儿将看到的，它们现在在实现上非常不同，因为它们非常相似。
- en: First and foremost, content entity fields in Drupal 8 are built on top of the
    low-level TypedData API. The latter is a complex system for modeling data in code
    and is widely used in Drupal 8\. Unfortunately, it is also one of the APIs least
    understood by developers. Not to worry, in the next section I will break it down
    for you. Since we still don't know anything about it, we will now talk about fields
    from a higher-level perspective.
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，Drupal 8 中的内容实体字段是建立在低级的 TypedData API 之上的。后者是一个用于在代码中建模数据的复杂系统，并且在 Drupal
    8 中被广泛使用。不幸的是，它也是开发者最不理解的 API 之一。不用担心，在下一节中，我会为您分解它。由于我们对此一无所知，我们现在将从更高级的角度来讨论字段。
- en: Base fields
  id: totrans-337
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 基础字段
- en: Base fields are the fields closest to a given entity type, things like the title,
    creation/modification date, publication status, and so on. They are defined in
    the entity type class as `BaseFieldDefinition` implementations and are installed
    in the database based on these definitions. Once installed, they are no longer
    configurable from a storage point of view from the UI (except in some cases, in
    which certain aspects can be overridden). Additionally, some display and form
    widget configuration changes can still be made (also depending on whether the
    individual definitions allow this).
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 基础字段是离给定实体类型最近的字段，例如标题、创建/修改日期、发布状态等。它们作为 `BaseFieldDefinition` 实现定义在实体类型类中，并基于这些定义安装到数据库中。一旦安装，它们就不再可以通过
    UI 从存储的角度进行配置（除了在某些情况下，可以覆盖某些方面）。此外，仍然可以做出一些显示和表单小部件配置更改（也取决于个别定义是否允许这样做）。
- en: 'Let''s check out the Node entity type''s `baseFieldDefinitions()` method and
    see an example of a base field definition:'
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看节点实体类型的 `baseFieldDefinitions()` 方法，并查看一个基础字段定义的示例：
- en: '[PRE51]'
  id: totrans-340
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: This is the definition of the Node `title` field. We can deduce that is of of
    the `string` type due to the argument passed to the `create()` method of the `BaseFieldDefinition`
    class. The latter is a complex data definition class on top of the TypedData API.
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 这是节点 `title` 字段的定义。我们可以推断出它属于 `string` 类型，因为这是传递给 `BaseFieldDefinition` 类的 `create()`
    方法的参数。后者是建立在 TypedData API 之上的一个复杂的数据定义类。
- en: Other common types of fields that can be defined are `boolean`, `integer`, `float`,
    `timestamp`, `datetime`, `entity_reference`, `text_long`, and many others. You
    can find out what field types you can use by checking the available `FieldType`
    plugins provided by Drupal core and any other modules. These are the same types
    of fields that can be used by configurable fields in the UI. In a later chapter,
    we will see how we can write our own custom field type.
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 可以定义的其他常见字段类型包括 `boolean`、`integer`、`float`、`timestamp`、`datetime`、`entity_reference`、`text_long`
    以及许多其他类型。您可以通过检查 Drupal 核心和任何其他模块提供的可用 `FieldType` 插件来找出您可以使用哪些字段类型。这些是 UI 中可配置字段可以使用的相同类型的字段。在后面的章节中，我们将看到如何编写我们自己的自定义字段类型。
- en: The field definition can have a number of options that may also differ depending
    on the type of field being defined. I will skip the obvious ones here and jump
    to the `setTranslatable()` and `setRevisionable()` methods and ask you to remember
    when we saw earlier how the Node entity type plugin annotation indicated that
    Nodes will be translatable and revisionable. This is where the fields themselves
    are configured to that effect. Without these settings, they'd be left out of the
    translation capability and revisions.
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 字段定义可以包含多个选项，这些选项可能也取决于正在定义的字段类型。在这里，我将跳过显而易见的选项，直接跳到 `setTranslatable()` 和
    `setRevisionable()` 方法，并请您记住我们之前看到节点实体类型插件注解表明节点将是可翻译和可修订的。这就是字段本身被配置为这种效果的地方。如果没有这些设置，它们将无法使用翻译功能和修订。
- en: If you take a look at how the `baseFieldDefinitions()` method starts, you'll
    see that it inherits some fields from the parent class as well. This is where
    common field definitions are inherited, which allow for the entity type to be
    revisionable and publishable.
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你查看`baseFieldDefinitions()`方法是如何开始的，你会看到它也从父类继承了一些字段。这就是常见字段定义被继承的地方，这允许实体类型可修订和可发布。
- en: The `setSetting()` method is used to provide various options to the field. In
    this case, it's used to indicate the maximum length, which is also mirrored in
    the table column in the database. Then, we have the display options that configure
    the view formatter and form widget the field should use. They reference plugin
    IDs of the type `FieldFormatter` (`string`) and `FieldWidget` (`string_textfield`)
    plugins, respectively. In a later chapter, we will see how we can define our own
    field plugins that can be used for both base and configurable fields.
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: '`setSetting()`方法用于向字段提供各种选项。在这种情况下，它用于指示最大长度，这也在数据库的表列中得到了反映。然后，我们有显示选项，这些选项配置了字段应使用的视图格式化和表单小部件。它们分别引用了`FieldFormatter`（`string`）和`FieldWidget`（`string_textfield`）插件类型。在后面的章节中，我们将看到如何定义我们自己的字段插件，这些插件可以用于基础字段和可配置字段。'
- en: Lastly, we have the `setDisplayConfigurable()` method which is used to enable/disable
    configuration changes on the form widget or display through the UI. In this case,
    only the form widget is exposed to changes.
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们有`setDisplayConfigurable()`方法，它用于通过UI启用/禁用表单小部件或显示的配置更改。在这种情况下，只有表单小部件会暴露给更改。
- en: Not all these options and configurations are always used or mandatory. It depends
    on what type of field we are defining, how we want the field to be configured,
    and whether defaults are okay for us. An important option that can be used on
    all field types is cardinality—whether the field can have more than one value
    of the same type. This allows a field to store multiple values that follow the
    same data definition on that entity field.
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 并非所有这些选项和配置总是被使用或强制要求。这取决于我们正在定义的字段类型，我们希望字段如何配置，以及默认值是否对我们来说可以接受。一个可以在所有字段类型上使用的选项是基数——字段是否可以具有多个相同类型的值。这允许字段存储多个遵循同一数据定义的实体字段值。
- en: If we create our own entity type and want to later add or modify a base field,
    we can do that in the same place as we originally defined them—in the entity class.
    However, for entities that do not "belong" to us, we need to implement some hooks
    in order to contribute with our own changes. To provide a new base field definition
    to an existing entity type, we can implement `hook_entity_base_field_info()` in
    our module and return an array of `BaseFieldDefinition` items just as we saw before
    in the Node entity type. Alternatively, we can implement `hook_entity_base_field_info_alter()`
    and alter existing base field definitions to our liking. Do keep in mind that
    this latter hook might be changed in the future, although at the time of writing,
    no great priority has been given to that.
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们创建自己的实体类型，并希望在以后添加或修改基础字段，我们可以在最初定义它们的地方进行——在实体类中。然而，对于不属于我们的实体，我们需要实现一些钩子，以便贡献我们自己的更改。为了向现有实体类型提供一个新的基础字段定义，我们可以在我们的模块中实现`hook_entity_base_field_info()`，并返回一个`BaseFieldDefinition`项目数组，就像我们在Node实体类型中看到的那样。或者，我们可以实现`hook_entity_base_field_info_alter()`并修改现有的基础字段定义以满足我们的需求。但请记住，这个后置钩子可能会在未来发生变化，尽管在撰写本文时，并没有给予它很高的优先级。
- en: Configurable fields
  id: totrans-349
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 可配置字段
- en: 'Configurable fields are typically created through the UI, **attached to an
    entity type bundle**, and exported to code. The part highlighted with bold is
    a critical difference between these and base fields in that base fields exist
    on all bundles of the entity type. You should already be familiar with the UI
    for creating a configurable field:'
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 可配置字段通常通过UI创建，**附加到实体类型包**，并导出到代码中。加粗的部分是这些字段与基础字段之间一个关键的区别，即基础字段存在于实体类型的所有包中。你应该已经熟悉创建可配置字段的UI：
- en: '![](img/ef0059e3-790d-4d44-a6e6-f2bb926f1a72.png)'
  id: totrans-351
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/ef0059e3-790d-4d44-a6e6-f2bb926f1a72.png)'
- en: 'They also use the TypedData API for their definitions, as well as the same
    field type, widget, and formatter plugins we talked about earlier. Architecturally
    speaking, the main difference between base and configurable fields is that the
    latter are made up of two parts: storage configuration (`FieldStorageConfig`)
    and field configuration (`FieldConfig`). These are both configuration entity types,
    whose entities, together, make up a configurable field. The former defines the
    field settings that relate to how the field is stored. These are options that
    apply to that particular field across all the bundles of an entity type it may
    be attached to (such as cardinality, the field type, and so on). The latter defines
    options for the field specific to the bundle it is attached to. These can, in
    some cases, be overrides of the storage config but also new settings (such as
    the field description, whether it is required, and more).'
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 它们还使用TypedData API进行定义，以及我们之前提到的相同的字段类型、小部件和格式化插件。从架构上来说，基本字段和可配置字段之间的主要区别在于后者由两部分组成：存储配置（`FieldStorageConfig`）和字段配置（`FieldConfig`）。这些都是配置实体类型，它们的实体共同构成一个可配置字段。前者定义了与字段存储相关的字段设置。这些选项适用于可能附加到其实体类型包上的所有包中的特定字段（如基数、字段类型等）。后者定义了特定于附加包的字段选项。在某些情况下，这些选项可以是存储配置的覆盖，也可以是新的设置（如字段描述、是否必需等）。
- en: The easiest way to create configurable fields is through the UI. Just as easily,
    you get them exported into code. You could alternatively write the field storage
    configuration and field configuration yourself and add it to your module's `config/install`
    folder, but you can achieve the same if you just export them through the UI.
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 创建可配置字段最简单的方法是通过UI。同样容易，您可以将它们导出到代码中。您也可以自己编写字段存储配置和字段配置，并将其添加到模块的 `config/install`
    文件夹中，但您也可以通过UI导出它们来实现相同的效果。
- en: Moreover, you can use a couple of hooks to make alterations to existing fields.
    For example, by implementing `hook_entity_field_storage_info_alter()` you can
    alter field storage configurations, while with `hook_entity_bundle_field_info_alter()`
    you can alter field configurations as they are attached to an entity type bundle.
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，您可以使用几个钩子来修改现有字段。例如，通过实现 `hook_entity_field_storage_info_alter()`，您可以修改字段存储配置，而使用
    `hook_entity_bundle_field_info_alter()`，您可以修改字段配置，这些配置是附加到实体类型包上的。
- en: Field storage
  id: totrans-355
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 字段存储
- en: We earlier saw how configuration entities are persisted and exported based on
    the configuration schema and plugin definition. Let's quickly talk about how the
    fields used on content entities are stored in the database.
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前看到配置实体是根据配置架构和插件定义进行持久化和导出的。让我们快速谈谈内容实体上使用的字段在数据库中的存储方式。
- en: Base fields, by default, end up in the entity base table (the one defined in
    the plugin annotation as `base_table`). This makes things more performant than
    having them in individual tables. However, there are some exceptions to this.
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，基本字段最终会出现在实体基表中（在插件注解中定义为 `base_table`）。这使得它们比在单独的表中更高效。然而，也有一些例外。
- en: If the entity type is translatable, a "data" table gets created where records
    of the same entity base field values in different languages can be stored. This
    is the table the Node entity type plugin annotation declared with the property
    `data_table`. If this property is missing, the table name will by default be `[base_table]_field_data`.
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 如果实体类型是可翻译的，则会创建一个“数据”表，用于存储同一实体基字段在不同语言中的记录。这是Node实体类型插件注解中声明了具有属性 `data_table`
    的表。如果此属性不存在，则默认表名为 `[base_table]_field_data`。
- en: Moreover, if the field cardinality of a given field is higher than 1, a new
    table is created for the field with the name `[entity_type_name]__[field_name]`
    where multiple records for the same field can be stored.
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，如果给定字段的字段基数大于1，则会为该字段创建一个名为 `[entity_type_name]__[field_name]` 的新表，其中可以存储同一字段的多个记录。
- en: If the entity and field have translation enabled and the respective field cardinality
    is higher than one, the "data" table holds the records for an entity in all languages
    it is translated into, while the `[entity_type_name]__[field_name]` table holds
    all the value records in all languages for a given field.
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 如果实体和字段启用了翻译，并且相应的字段基数大于一，则“数据”表包含实体在所有翻译语言中的记录，而 `[entity_type_name]__[field_name]`
    表包含给定字段在所有语言中的所有值记录。
- en: Configurable fields, on the other hand, always get a separate field data table
    named `[entity_type_name]__[field_name]`, where the multiple values for the same
    field and in multiple languages can be stored.
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 可配置字段，另一方面，总是有一个名为 `[entity_type_name]__[field_name]` 的单独字段数据表，其中可以存储同一字段在多种语言中的多个值。
- en: Entity types summary
  id: totrans-362
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实体类型摘要
- en: The Entity API is quite complex. We have only begun our journey to understanding
    the different kinds of entity types, bundles, fields, and so on. We have so far
    talked about the differences between configuration and content entity types and
    what exactly they are made up of. To this end, we also touched upon the different
    types of fields they can use and how the data in these fields is stored.
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: Entity API 非常复杂。我们刚刚开始了解不同类型的实体类型、捆绑、字段等。到目前为止，我们已经讨论了配置和内容实体类型之间的区别以及它们究竟由什么组成。为此，我们还简要提到了它们可以使用的不同类型的字段以及这些字段中的数据是如何存储的。
- en: However, there is still a lot to understand about entities, especially content
    entities, which will be our focus in the next sections. We are going to first
    look at the TypedData API to better understand how content entity field data is
    modeled. As of now, that is still a black box; am I right? Next, we'll look at
    how to actually work with the API to query, create, and manipulate entities (both
    content and configuration). Finally, we'll talk a bit about the validation API
    the content entities and fields use consistently to ensure they hold proper data.
    So, let's get to it.
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，关于实体还有很多东西需要理解，尤其是内容实体，这是我们将在下一节中关注的重点。我们将首先查看 TypedData API，以便更好地理解内容实体字段数据是如何建模的。到目前为止，这仍然是一个黑盒；我说的对吗？接下来，我们将看看如何实际使用
    API 来查询、创建和操作实体（内容和配置）。最后，我们将简要谈谈内容实体和字段使用的一致性验证 API，以确保它们持有适当的数据。那么，让我们开始吧。
- en: TypedData
  id: totrans-365
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: TypedData
- en: In order to really understand how entity data is modeled, we need to understand
    the TypedData API. Unfortunately, this API still remains quite a mystery for many.
    But you're in luck because, in this section, we're going to get to the bottom
    of it.
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 为了真正理解实体数据是如何建模的，我们需要了解 TypedData API。不幸的是，这个 API 对许多人来说仍然是一个谜。但你有幸，因为在本节中，我们将深入探讨这个问题。
- en: Why TypedData?
  id: totrans-367
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为什么需要 TypedData？
- en: It helps to understand things better if we first talk about why there was the
    need for this API. It all has to do with the way PHP as a language *is*, compared
    to others, and that is, loosely typed. This means that in PHP it is very difficult
    to use native language constructs to rely on the type of certain data or understand
    more about that data.
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们首先谈谈为什么需要这个 API，这有助于更好地理解事物。这一切都与 PHP 作为一种语言 *是* 的方式有关，与其他语言相比，它是松散类型的。这意味着在
    PHP 中，很难使用原生语言结构来依赖于某些数据类型或了解更多关于该数据的信息。
- en: The difference between the string `"1"` and integer `1` is a very common example.
    We are often afraid of using the `===` sign to compare them because we never know
    what they actually come back as from the database or wherever. So, we either use
    `==` (which is not really good) or forcefully cast them to the same type and hope
    PHP will be able to get it right.
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 字符串 `"1"` 和整数 `1` 之间的区别是一个非常常见的例子。我们常常害怕使用 `===` 符号来比较它们，因为我们永远不知道它们实际上从数据库或其他地方返回的是什么。所以，我们要么使用
    `==`（这其实并不好），要么强制将它们转换为相同的类型，并希望 PHP 能够正确处理。
- en: In PHP 7, we have type hinting for scalar values in function parameters which
    is good, but still not enough. Scalar values alone are not going to cut it if
    you think of the difference between `1495875076` and `2495877076`. The first is
    a timestamp while the second is an integer. Even more importantly, the first has
    meaning while the second one does not. At least seemingly. Maybe I want it to
    have some meaning because it is the specific formatting for the IDs in my package
    tracking app.
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 在 PHP 7 中，我们在函数参数中对标量值有类型提示，这是好的，但仍然不够。如果你考虑 `1495875076` 和 `2495877076` 之间的区别，标量值本身是不够的。第一个是一个时间戳，而第二个是一个整数。更重要的是，第一个有含义，而第二个则没有。至少表面上是这样。也许我想让它有某种含义，因为它是我的包裹跟踪应用中
    ID 的特定格式。
- en: Drupal was not exempt from the problems this loosely typed nature of PHP can
    create. Drupal 7 developers know very well what it meant to deal with field values
    in this way. But not anymore because we now have the TypedData API in Drupal 8.
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: Drupal 并没有免除 PHP 这种松散类型特性可能造成的问题。Drupal 7 开发者非常清楚以这种方式处理字段值意味着什么。但不再是了，因为我们现在在
    Drupal 8 中有了 TypedData API。
- en: What is TypedData?
  id: totrans-372
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 什么是 TypedData？
- en: The TypedData API is a low-level and generic API that essentially does two things
    from which a lot of power and flexibility is derived.
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: '`TypedData` API 是一个低级和通用 API，本质上执行两项主要任务，从中衍生出许多强大和灵活的功能。'
- en: 'First, it wraps "values" of any kind of complexity. More importantly, it forms
    "values". This can be a simple scalar value to a multidimensional map of related
    values of different types that together are considered one value. Let''s take, for
    example, a New York license plate: `405-307`. This is a simple string but we "wrap"
    it with TypedData to give it meaning. In other words, we know programmatically
    that it is a license plate and not just a random PHP string. But wait, that plate
    number can be found in other states as well (possibly, I have no idea). So, in
    order to better define a plate, we need also a state code: `NY`. This is another
    simple string wrapped with TypedData to give it meaning—a state code. Together,
    they can become a slightly more complex piece of TypedData: US license plate,
    which has its own meaning.'
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，它包装了任何类型的“值”。更重要的是，它形成了“值”。这可以是一个简单的标量值，也可以是一个多维映射，其中包含不同类型的关联值，这些值共同被视为一个值。以纽约车牌为例：`405-307`。这是一个简单的字符串，但我们用
    `TypedData` 包装它以赋予它意义。换句话说，我们知道它是一个车牌，而不仅仅是一个随机的 PHP 字符串。但是等等，这个车牌号码也可能在其他州找到（可能，我不知道）。因此，为了更好地定义车牌，我们还需要一个州代码：`NY`。这是另一个简单的字符串，用
    `TypedData` 包装以赋予它意义——州代码。结合起来，它们可以成为一个稍微复杂一点的 `TypedData`：美国车牌，它有自己的意义。
- en: Second, as you can probably infer, it gives meaning to the data that it wraps.
    If we continue our previous example, the US license plate TypedData now has plenty
    of meaning. So, we can programmatically ask it what it is and all sorts of other
    things about it, such as what is the state code for that plate. And the API facilitates
    this interaction with the data.
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 其次，正如你可能推断的那样，它为其包装的数据赋予了意义。如果我们继续之前的例子，美国的车牌数据类型现在具有丰富的意义。因此，我们可以通过编程方式询问它是什么，以及关于它的各种其他信息，例如车牌的州代码是什么。API简化了与数据的这种交互。
- en: As I mentioned, from this flexibility, a lot of power can be built on top. Things
    like data validation are very important in Drupal 8 and rely on TypedData. As
    we will see later in this chapter, validation happens at the TypedData level using
    constraints on the underlying data.
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我之前提到的，从这个灵活性中可以构建很多功能。例如，数据验证在 Drupal 8 中非常重要，并且依赖于 `TypedData`。正如我们将在本章后面看到的那样，验证是在
    `TypedData` 层通过底层数据的约束来进行的。
- en: The low-level API
  id: totrans-377
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 低级 API
- en: Now that we have a basic understanding of the principles behind TypedData and
    why we need it, let's start exploring the API, starting from the smallest pieces
    and going up.
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们对 `TypedData` 的原理及其必要性有了基本的了解，让我们开始探索 API，从最小的部分开始，逐步深入。
- en: 'There are two main pillars of this API: `DataType` plugins and data definitions.'
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: 该 API 的两个主要支柱是 `DataType` 插件和数据定义。
- en: DataType plugins
  id: totrans-380
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 数据类型插件
- en: DataType plugins are responsible for defining the available types of data that
    can be used in the system. For example, the `StringData` plugin is used to model
    a simple primitive string. Moreover, they are responsible for interacting with
    the data itself; things like setting and accessing the respective values.
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: 数据类型插件负责定义系统中可用的数据类型。例如，`StringData` 插件用于模拟简单的原始字符串。此外，它们还负责与数据本身进行交互；例如设置和访问相应的值。
- en: The DataType plugins are managed by the `TypedDataManager` and are annotated
    by the `DataType` annotation class. They implement the `TypedDataInterface` and
    typically extend the `TypedData` base class or one of its subclasses.
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: 数据类型插件由 `TypedDataManager` 管理，并由 `DataType` 注解类进行注解。它们实现了 `TypedDataInterface`
    接口，通常扩展了 `TypedData` 基类或其子类之一。
- en: 'There are three main types of DataType plugins out there, depending on the
    interface they implement:'
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: 根据它们实现的接口，存在三种主要的 `DataType` 插件类型：
- en: First, there is the `TypedDataInterface` I mentioned before; this is typically
    used for simple primitive values such as strings or integers.
  id: totrans-384
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 首先，就是我之前提到的 `TypedDataInterface`；这通常用于简单的原始值，如字符串或整数。
- en: Second, there is the `ListInterface` which is used to form a collection of other
    TypedData elements. It comes with methods specific to interacting with lists of
    elements.
  id: totrans-385
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 其次，是 `ListInterface`，它用于形成其他 `TypedData` 元素的集合。它提供了特定于与元素列表交互的方法。
- en: Third, there is `ComplexDataInterface` which is used for more complex data formed
    of multiple properties that have names and can be accessed accordingly. Going
    forward, we will see examples of all these types.
  id: totrans-386
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第三，有`ComplexDataInterface`，它用于由多个具有名称并可相应访问的属性组成的更复杂的数据。向前看，我们将看到所有这些类型的示例。
- en: The best way to understand how these plugins are used is to first talk about
    data definitions as well.
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: 理解这些插件如何使用的最好方法是首先谈谈数据定义。
- en: Data definitions
  id: totrans-388
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 数据定义
- en: Data definitions are the objects used to store all that meaning about the underlying
    data we talked about. They define the type of data they can hold (using an existing
    DataType plugin) and any kind of other meaningful information about that data.
    So, together with the plugins, the data definitions are one mean data modeling
    machine.
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: 数据定义是用于存储我们之前讨论的底层数据的所有含义的对象。它们定义它们可以持有的数据类型（使用现有的DataType插件）以及关于该数据的任何其他有意义的信息。因此，与插件一起，数据定义是一个强大的数据建模机器。
- en: At the lowest level, they implement the `DataDefinitionInterface` and typically
    extend the `DataDefinition` class (or one of its subclasses). Important subclasses
    of `DataDefinition` are `ListDefinition` and `ComplexDefinitionBase` which are
    used to define more complex data types. And as you might expect, they correlate
    to the `ListInterface` and `ComplexDataInterface` plugins I mentioned earlier.
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: 在最低级别，它们实现了`DataDefinitionInterface`，通常扩展`DataDefinition`类（或其子类之一）。`DataDefinition`的重要子类是`ListDefinition`和`ComplexDefinitionBase`，它们用于定义更复杂的数据类型。正如你所期望的，它们与之前提到的`ListInterface`和`ComplexDataInterface`插件相关联。
- en: Let us see an example of a simple usage of data definitions and DataType plugins
    by modeling a simple string—`my_value`.
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过模拟一个简单的字符串`my_value`来查看数据定义和DataType插件的一个简单用法示例。
- en: 'It all starts with the definition:'
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这一切都始于定义：
- en: '[PRE52]'
  id: totrans-393
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: The argument we pass to the `create()` method is the DataType plugin ID we want
    to be defining our data as. In this case, it is the `StringData` plugin.
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: 我们传递给`create()`方法的参数是我们想要定义数据的DataType插件ID。在这种情况下，它是`StringData`插件。
- en: 'We already have some options out of the box to define our string data. For
    example, we can set a label:'
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经有一些现成的选项来定义我们的字符串数据。例如，我们可以设置一个标签：
- en: '[PRE53]'
  id: totrans-396
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'We can also mark it as read only or set whatever "settings" we want onto the
    definition. However, one thing we don''t do is deal with the actual value. This
    is where the DataType plugin comes into play. The way this happens is that we
    have to create a new plugin instance, based on our definition and a value:'
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以将其标记为只读或设置我们想要的任何“设置”到定义上。然而，我们不做的一件事是处理实际值。这就是DataType插件发挥作用的地方。这种方式是，我们必须基于我们的定义和值创建一个新的插件实例：
- en: '[PRE54]'
  id: totrans-398
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'We used the `TypedDataManager` to create a new instance of our definition with
    our actual string value. What we get is a plugin that we can use to interact with
    our data, understand it better, change its value, and so on:'
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`TypedDataManager`创建了一个新的实例，该实例包含我们实际的字符串值。我们得到的是一个插件，我们可以用它来与我们的数据交互，更好地理解它，更改其值，等等：
- en: '[PRE55]'
  id: totrans-400
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: We can see what kind of data we are dealing with, its label, and other things.
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到我们正在处理什么类型的数据，其标签以及其他信息。
- en: Let's take a look at a slightly more complex example and model our license plate
    use case we talked about earlier.
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看一个稍微复杂一点的例子，并模拟我们之前讨论过的车牌使用案例。
- en: 'We first define the number:'
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先定义数字：
- en: '[PRE56]'
  id: totrans-404
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'Then, we define the state code:'
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们定义状态代码：
- en: '[PRE57]'
  id: totrans-406
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: We are keeping these generic because nobody says we cannot reuse these elsewhere;
    we might need to deal with state codes.
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: 我们保留这些通用性，因为没有人说我们不能在其他地方重用这些；我们可能需要处理状态代码。
- en: 'Next, we create our full plate definition:'
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们创建我们的完整定义：
- en: '[PRE58]'
  id: totrans-409
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'We use the `MapDataDefinition` here which by default uses the `Map` DataType
    plugin. Essentially, this is a well-defined associative array of properties. So,
    let''s add our definitions to it:'
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里使用`MapDataDefinition`，它默认使用`Map` DataType插件。本质上，这是一个定义良好的属性关联数组。因此，让我们将我们的定义添加到其中：
- en: '[PRE59]'
  id: totrans-411
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'This map definition gets two named property definitions: `number` and `state`.
    You can see now the hierarchical aspect of the TypedData API.'
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: 此映射定义获得两个命名的属性定义：`number`和`state`。你现在可以看到TypedData API的层次结构方面。
- en: 'Finally, we instantiate the plugin:'
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们实例化插件：
- en: '[PRE60]'
  id: totrans-414
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: The value we pass to this type of data is an array whose keys should map to
    the property names and values to the individual property definitions (which in
    this case are strings).
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: 我们传递给这种类型数据的值是一个数组，其键应映射到属性名称，值映射到单个属性定义（在这种情况下是字符串）。
- en: 'Now, we can benefit from all the goodness of the TypedData API:'
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以从TypedData API的所有优点中受益：
- en: '[PRE61]'
  id: totrans-417
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'The `$number` and `$state` variables are `StringData` plugins that can then
    be used to access the individual values inside:'
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
  zh: '`$number`和`$state`变量是`StringData`插件，然后可以用来访问内部的单个值：'
- en: '[PRE62]'
  id: totrans-419
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: Their respective definitions can be accessed in the same way that we did before.
    So, we managed in these few lines to properly define a US license plate construct
    and make it intelligible by the rest of our code. Next, we will look at even more
    complex examples and inspect how content entity data is modeled using TypedData.
    Configuration entities, as we saw, rely on configuration schemas to define the
    data types. Under the hood, the schema types themselves reference TypedData API
    data type plugins themselves. So, behind the scenes, the same low-level API is
    used. To keep things a bit simpler, we will look at content entities where this
    API is much more explicit and you will actually have to deal with it.
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
  zh: 它们的相应定义可以通过与我们之前相同的方式进行访问。因此，我们在这些几行代码中成功地定义了一个美国车牌结构，并使其余的代码能够理解。接下来，我们将查看更复杂的示例，并检查内容实体数据是如何使用TypedData进行建模的。正如我们所见，配置实体依赖于配置模式来定义数据类型。在底层，模式类型本身引用了TypedData
    API数据类型插件。因此，在幕后，使用的是相同的低级API。为了使事情更简单一些，我们将查看内容实体，其中此API更为明确，并且你实际上必须处理它。
- en: Content entities
  id: totrans-421
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 内容实体
- en: Let's now examine entities and fields and see how they make use of the TypedData
    API for modeling the data they store and manage. This will also help you better
    understand how data is organized when you are debugging entities and their fields.
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们现在检查实体和字段，看看它们是如何使用TypedData API来建模它们存储和管理的数据的。这也有助于你更好地理解在调试实体及其字段时数据的组织方式。
- en: 'The main place where data is stored and modeled is fields. As we saw, we have
    two types: base fields and configurable fields. However, when it comes to TypedData,
    they do not differ very much. They both use the `FieldItemList` DataType plugin
    (either directly or a subclass). In terms of definitions, base fields use `BaseFieldDefinition`
    instances while configurable fields use `FieldConfig` instances. The latter are
    slightly more complicated because they are actually configuration entities themselves
    (to store the field configuration), but that implement down the line the `DataDefinitionInterface`.
    So, they combine the two tasks. Moreover, base fields can also use `BaseFieldOverride`
    definition instances which are essentially also configuration entities and are
    used for storing alterations made through the UI to the fields defined as base
    fields. Just like the `FieldConfig` definitions, these extend the `FieldConfigBase`
    class, because they share the same exportable characteristics.'
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
  zh: 数据存储和建模的主要地方是字段。正如我们所见，我们有两种类型：基字段和可配置字段。然而，当涉及到TypedData时，它们并没有很大的区别。它们两者都使用`FieldItemList`数据类型插件（直接或其子类）。在定义方面，基字段使用`BaseFieldDefinition`实例，而可配置字段使用`FieldConfig`实例。后者稍微复杂一些，因为它们实际上是配置实体本身（用于存储字段配置），但最终实现了`DataDefinitionInterface`。因此，它们结合了两个任务。此外，基字段还可以使用`BaseFieldOverride`定义实例，这些实例本质上也是配置实体，用于存储通过UI对作为基字段定义的字段所做的更改。就像`FieldConfig`定义一样，这些扩展了`FieldConfigBase`类，因为它们具有相同的可导出特性。
- en: In addition to fields, entities themselves have a TypedData plugin that can
    be used to wrap entities and expose them to the API directly—the `EntityAdapter`.
    These use an `EntityDataDefinition` instance which basically includes all the
    individual field definitions. Using plugin derivatives, each entity types dynamically
    gets an `EntityAdapter` plugin instance.
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
  zh: 除了字段之外，实体本身还有一个TypedData插件，可以用来包装实体并将其直接暴露给API——`EntityAdapter`。这些使用`EntityDataDefinition`实例，它基本上包括所有单个字段定义。使用插件派生，每个实体类型动态地获得一个`EntityAdapter`插件实例。
- en: Let's now examine a simple base field and understand the usage of the TypedData
    API in the context of fields. The `BaseFieldDefinition` class extends `ListDataDefinition`
    which is responsible for defining multiple items of data in a list. Each item
    in the list is an instance of `DataDefinitionInterface` as well, so you can see
    the same kind of hierarchy as we had with our license plate example. But why is
    one field a list of items?
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们现在检查一个简单的基字段，并了解在字段上下文中TypedData API的使用。`BaseFieldDefinition`类扩展了`ListDataDefinition`，它负责在列表中定义多个数据项。列表中的每个项也是`DataDefinitionInterface`的一个实例，因此你可以看到与我们的车牌示例相同的类型层次结构。但为什么一个字段是项的列表呢？
- en: You probably know that when you create a field, you can choose how many items
    this one field can hold—its cardinality. You typically choose one, but can choose
    many. The same is true with all types of fields. Regardless of the cardinality
    you choose, the data is modeled as a list. If the field has a cardinality of one,
    the list will only have one item. It is as simple as that. So, if base field definitions
    are lists of definitions, what are the individual item definitions? The answer
    is implementations of `FieldItemDataDefinition`.
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能知道，当你创建一个字段时，你可以选择这个字段可以包含多少项——它的基数。你通常选择一个，但也可以选择多个。所有类型的字段都是如此。无论你选择什么基数，数据都被建模为一个列表。如果一个字段有一个基数为1，列表将只有一个项。就这么简单。所以，如果基本字段定义是定义列表，那么单个项定义是什么呢？答案是`FieldItemDataDefinition`的实现。
- en: In terms of DataType plugins, as I mentioned, we have the `FieldItemList` class
    which implements the `ListInterface` I mentioned earlier as one of the more complex
    data types. The individual items inside are subclasses of `FieldItemBase` (which
    extends the `Map` DataType we encountered earlier). So, we have the same kind
    of data structure. But just to make matters slightly more complicated, another
    plugin type comes into play here—`FieldType`. The individual field items are actually
    instances of this plugin type (which extend `FieldItemBase` and down the line
    a `DataType` plugin of some kind). So, for instance, a text field will use the
    `StringItem``FieldType` plugin, which inherits a bunch of functionality from the
    `Map` DataType. So, you can see how the TypedData API is at a very low level and
    things can be built on top of it.
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
  zh: 在数据类型插件方面，正如我提到的，我们有`FieldItemList`类，它实现了我之前提到的`ListInterface`，作为更复杂的数据类型之一。内部的项目是`FieldItemBase`的子类（它扩展了我们之前遇到的`Map`数据类型）。所以我们有相同类型的数据结构。但为了使事情稍微复杂一些，这里又出现了一种插件类型——`FieldType`。单个字段项实际上是这种插件类型的实例（它扩展了某种`DataType`插件）。所以，例如，一个文本字段将使用`StringItem``FieldType`插件，它从`Map`数据类型继承了许多功能。所以，你可以看到TypedData
    API处于一个非常低级的位置，并且可以在其之上构建东西。
- en: 'So now, if we combine what we learned and look at a base field, we see the
    following: a `FieldItemList` data type using a `BaseFieldDefinition` (or `BaseFieldOverride`)
    data definition. Inside, each item is a `FieldItemBase` implementation (a `FieldType`
    plugin extending some sort of `DataType` plugin) using a `FieldItemDataDefinition`.
    So, not that complicated after all. We will put this knowledge to good use in
    the final section of this chapter when we see how we can interact with entities
    and field data. I am not throwing all these notions at you just for the sake of
    it.'
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
  zh: 所以现在，如果我们结合我们所学的知识，并观察一个基本字段，我们会看到以下内容：一个使用`BaseFieldDefinition`（或`BaseFieldOverride`）数据定义的`FieldItemList`数据类型。在内部，每个项目都是一个`FieldItemBase`实现（一个扩展某种`DataType`插件的`FieldType`插件）使用`FieldItemDataDefinition`。所以，实际上并没有那么复杂。当我们看到如何与实体和字段数据交互时，我们将在本章的最后部分将这一知识运用到实际中。我并不是为了这些概念而向你抛出这些概念。
- en: The configurable fields work almost exactly the same way, except that the definition
    corresponding to the `FieldItemList` is an instance of `FieldConfig` (which is
    also a configuration entity that stores the settings for this field, and which
    is similar to the `BaseFieldOverride`). However, it is also a type of list definition
    with the individual list items being the same as with the base fields.
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
  zh: 可配置的字段几乎以完全相同的方式工作，只是对应于`FieldItemList`的定义是一个`FieldConfig`实例（它也是一个存储此字段设置的配置实体，类似于`BaseFieldOverride`）。然而，它也是一种列表定义，其中单个列表项与基本字段相同。
- en: TypedData summary
  id: totrans-430
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 类型化数据摘要
- en: So, as we've seen, the scope of understanding the TypedData API in Drupal 8
    is quite broad. We can make things very simple, as with our first example, but
    then hit some really complicated territory with its use in the Entity system.
    The point of this section has been to make you aware of this API, understand its
    reasoning, see a couple of simple examples, and break down all the components
    that are used in the Entity API.
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，正如我们所看到的，在Drupal 8中理解TypedData API的范围相当广泛。我们可以使事情非常简单，就像我们的第一个例子一样，但随后在实体系统中的应用会进入一些非常复杂的领域。本节的目的就是要让你了解这个API，理解其推理，看到几个简单的例子，并分解在实体API中使用到的所有组件。
- en: However, I admit, it must have been quite a difficult section to follow. All
    this terminology and theory can be pretty daunting. But don't worry if you didn't
    fully understand everything, that's fine. It's there for you to reference as we
    go through the next section because we will apply all that knowledge and you will
    see why it's useful to be aware of it. In other words, we will now focus on interacting
    with entities (both content and configuration) and in doing so, make heavy use
    of the functionality made possible by the TypedData API.
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，我必须承认，这一定是一个很难理解的章节。所有这些术语和理论可能相当令人畏惧。但如果你没有完全理解一切，那没关系。它在那里供你在我们进入下一节时参考，因为我们将应用所有这些知识，你将看到了解它的有用之处。换句话说，我们现在将专注于与实体（内容和配置）交互，并在这样做的时候，大量使用由TypedData
    API提供的功能。
- en: Interacting with the Entity API
  id: totrans-433
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 与实体API交互
- en: 'In this final section of the chapter, we''re going to cover the most common
    things you will be doing with content and configuration entities. These are the
    main topics we will discuss going forward:'
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的最后部分，我们将介绍你将最常与内容配置实体一起做的事情。这些是我们接下来将要讨论的主要主题：
- en: Querying and loading entities
  id: totrans-435
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 查询和加载实体
- en: Reading entities
  id: totrans-436
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 读取实体
- en: Manipulating entities (update/save)
  id: totrans-437
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 操作实体（更新/保存）
- en: Creating entities
  id: totrans-438
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建实体
- en: Rendering entities
  id: totrans-439
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 渲染实体
- en: Validating entity data
  id: totrans-440
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 验证实体数据
- en: So, let's hit it.
  id: totrans-441
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，让我们开始吧。
- en: Querying entities
  id: totrans-442
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 查询实体
- en: One of the most common things you will do as a programmer is query for stuff,
    such as data in the database. This is what we were doing a lot in Drupal 7 to
    get our data. A lot. We'd either use the database API or simple query strings
    and load our data. However, in Drupal 8, the entity API has become much more robust
    and offers a layer that reduces the need to query the database directly. In a
    later chapter, we will see how to do we can still do that when things become more
    complex. For now, since most of our structured data belongs in entities, we will
    use the entity query system for retrieving entities.
  id: totrans-443
  prefs: []
  type: TYPE_NORMAL
  zh: 作为程序员，你将要做的一件最常见的事情就是查询东西，比如数据库中的数据。这正是我们在Drupal 7中大量做的事情来获取我们的数据。很多。我们要么使用数据库API，要么使用简单的查询字符串来加载数据。然而，在Drupal
    8中，实体API已经变得更加健壮，并提供了减少直接查询数据库需求的一层。在后面的章节中，我们将看到当事情变得更加复杂时，我们如何仍然可以做到这一点。现在，由于我们的大部分结构化数据都属于实体，我们将使用实体查询系统来检索实体。
- en: 'If you remember when we spoke about the entity type handlers, one of them was
    the storage handler that provides the API for CRUD operations on the entities.
    This is the handler we will use to access also the entity query. And we do this
    via the `entity_type.manager` service (`EntityTypeManager`):'
  id: totrans-444
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你记得我们之前讨论实体类型处理器时，其中之一是提供实体CRUD操作API的存储处理器。这就是我们将用来访问实体查询的处理程序。我们通过`entity_type.manager`服务（`EntityTypeManager`）来做这件事：
- en: '[PRE63]'
  id: totrans-445
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: We request the storage handler which can then give us the query factory for
    that entity type. In this example, I used a static call but, as always, you should
    inject the service where you can.
  id: totrans-446
  prefs: []
  type: TYPE_NORMAL
  zh: 我们请求存储处理器，然后它可以给我们该实体类型的查询工厂。在这个例子中，我使用了静态调用，但，就像往常一样，你应该在可能的地方注入服务。
- en: Building queries
  id: totrans-447
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建查询
- en: 'Now that we have an entity query factory on our hands, we can build a query
    that is made up of conditions and all sorts of typical query elements. Here''s
    a simple example of querying for the last 10 published article nodes:'
  id: totrans-448
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们手头有一个实体查询工厂，我们可以构建一个由条件和各种典型查询元素组成的查询。以下是一个查询最后10篇已发布文章节点的简单示例：
- en: '[PRE64]'
  id: totrans-449
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: The first thing you can see is that the methods on the factory are chainable.
    We have some expected methods to set conditions, range, sorting, and so on. As
    you can already deduce, the first parameter is the field name and the second is
    the value. An optional third parameter can also be the operator for the condition.
  id: totrans-450
  prefs: []
  type: TYPE_NORMAL
  zh: 你首先可以看到的是，工厂上的方法是可以链式的。我们有设置条件、范围、排序等预期的方法。正如你所能推断出的，第一个参数是字段名，第二个是值。可选的第三个参数也可以是条件的运算符。
- en: I strongly recommend you check out the `\Drupal\Core\Entity\Query\QueryInterface`
    class for some documentation about these methods, especially the `condition()`
    method which is the most complex.
  id: totrans-451
  prefs: []
  type: TYPE_NORMAL
  zh: 我强烈建议你查看`\Drupal\Core\Entity\Query\QueryInterface`类中关于这些方法的文档，特别是`condition()`方法，这是最复杂的。
- en: 'Here is a slightly more complex condition that would return nodes of two different
    types:'
  id: totrans-452
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是一个稍微复杂一些的条件，它将返回两种不同类型的节点：
- en: '[PRE65]'
  id: totrans-453
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'Additionally, you can also use condition groups, with OR or AND conjunctions:'
  id: totrans-454
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，你还可以使用条件组，使用OR或AND连接词：
- en: '[PRE66]'
  id: totrans-455
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: In the previous query, we see a few new things. First, we create a condition
    group of the type OR in which we add two conditions. One of them checks whether
    the node title field contains the string "Drupal". The other checks whether any
    of the entities referenced by the `field_tags` field (in this case taxonomy terms)
    has the string "Drupal" in their name. So, you can see the power we have in traversing
    into referenced entities. Finally, we use this condition group as the first parameter
    to the `condition()` method of the query (instead of field name and value).
  id: totrans-456
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的查询中，我们看到了一些新事物。首先，我们创建了一个类型为OR的条件组，在其中添加了两个条件。其中一个检查节点标题字段是否包含字符串"Drupal"。另一个检查由`field_tags`字段（在这种情况下为分类术语）引用的任何实体是否有其名称中包含字符串"Drupal"。因此，你可以看到我们在遍历引用实体方面的强大能力。最后，我们将这个条件组用作查询的`condition()`方法的第一个参数（而不是字段名和值）。
- en: Entity queries for the Node entity type take access restrictions into account
    as they are run from the context of the current user. This means that, for example,
    a query for unpublished nodes triggered on a page hit by an anonymous user is
    not going to return results, but it will if triggered by an administrator. You
    can disable this by adding the `->accessCheck(FALSE)` instruction to the query
    IF you are sure the results are not going to expose unwanted content to users.
    We will talk more about node access in a later chapter.
  id: totrans-457
  prefs: []
  type: TYPE_NORMAL
  zh: 节点实体的实体查询会考虑到访问限制，因为它们是在当前用户的上下文中运行的。这意味着，例如，如果一个匿名用户访问的页面触发了对未发布节点的查询，那么它不会返回结果，但如果是由管理员触发的，则会返回结果。如果你确定结果不会向用户暴露不受欢迎的内容，你可以通过向查询添加`->accessCheck(FALSE)`指令来禁用此功能。我们将在后面的章节中更多地讨论节点访问。
- en: Configuration entities work in the same way. We get the query factory for that
    entity type and build a query. Under the hood, the query is of course run differently
    due to the flat nature of the storage.
  id: totrans-458
  prefs: []
  type: TYPE_NORMAL
  zh: 配置实体以相同的方式工作。我们获取该实体类型的查询工厂并构建一个查询。在底层，由于存储的扁平化特性，查询当然会以不同的方式运行。
- en: 'Each configuration entity gets one record in the database, so they need to
    be loaded and then examined. Moreover, the conditions can be written to also match
    the nested nature of configuration entity field data. For example:'
  id: totrans-459
  prefs: []
  type: TYPE_NORMAL
  zh: 每个配置实体在数据库中都有一个记录，因此它们需要被加载并检查。此外，条件也可以编写来匹配配置实体字段数据的嵌套特性。例如：
- en: '[PRE67]'
  id: totrans-460
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'This query searches for all the View configuration entities that have the display
    plugin of the type "page". The condition essentially looks inside the `display`
    array for any of the elements (hence the `*` wildcard). If any of these elements
    has a `display_plugin` key with the value "page", it''s a match. This is what
    an example view entity looks like in YAML format:'
  id: totrans-461
  prefs: []
  type: TYPE_NORMAL
  zh: 这个查询搜索所有具有类型为"page"的显示插件的视图配置实体。条件本质上是在`display`数组中查找任何元素（因此有`*`通配符）。如果这些元素中的任何一个有`display_plugin`键，其值为"page"，则匹配。以下是一个示例视图实体在YAML格式中的样子：
- en: '[PRE68]'
  id: totrans-462
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: I removed a bunch of data from this entity just to keep it short. But as you
    can see, we have the `display` array, with the `default` and `page_1` elements,
    and each has a `display_plugin` key with a plugin ID.
  id: totrans-463
  prefs: []
  type: TYPE_NORMAL
  zh: 我从该实体中删除了大量数据，只是为了使其更简洁。但正如你所见，我们有`display`数组，其中包含`default`和`page_1`元素，每个元素都有一个`display_plugin`键，其中包含插件ID。
- en: Loading entities
  id: totrans-464
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 加载实体
- en: 'Now that we have our entity IDs found by the query, it''s time to load them.
    It couldn''t be simpler to do so. We just use the storage handler for that entity
    type (and we get that from the entity type manager):'
  id: totrans-465
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经通过查询找到了实体ID，是时候加载它们了。这样做非常简单。我们只需使用该实体类型的存储处理程序（并且我们从实体类型管理器中获取它）：
- en: '[PRE69]'
  id: totrans-466
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'This will return an array of `EntityInterface` objects (in this case `NodeInterface`).
    Or if we have only one ID to load:'
  id: totrans-467
  prefs: []
  type: TYPE_NORMAL
  zh: 这将返回一个`EntityInterface`对象数组（在这种情况下为`NodeInterface`）。或者如果我们只有一个ID要加载：
- en: '[PRE70]'
  id: totrans-468
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: These will return a single `NodeInterface` object.
  id: totrans-469
  prefs: []
  type: TYPE_NORMAL
  zh: 这些将返回一个单独的`NodeInterface`对象。
- en: 'The Entity type storage handler also has a shortcut method that allows you
    to perform simple queries and load the resulting entities in one go. For example,
    if we wanted to load all article nodes:'
  id: totrans-470
  prefs: []
  type: TYPE_NORMAL
  zh: 实体类型存储处理程序还有一个快捷方法，允许你一次性执行简单查询并加载结果实体。例如，如果我们想加载所有文章节点：
- en: '[PRE71]'
  id: totrans-471
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'The `loadByProperties()` method takes one parameter: an associative array that
    contains simple field value conditions that need to match. Behind the scenes,
    it builds a query based on these and loads the returning entities. Do keep in
    mind that you cannot have complex queries here and access checks will be taken
    into account in the query being built under the hood. So, for full control, just
    build the query yourself.'
  id: totrans-472
  prefs: []
  type: TYPE_NORMAL
  zh: '`loadByProperties()` 方法接受一个参数：一个包含需要匹配的简单字段值条件的关联数组。幕后，它根据这些条件构建一个查询并加载返回的实体。请记住，这里不能有复杂的查询，并且底层构建的查询将考虑访问检查。因此，为了完全控制，请自行构建查询。'
- en: Reading entities
  id: totrans-473
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 读取实体
- en: 'So, we have our entity loaded and we can now read its data. For content entities,
    this is where the TypedData knowledge comes into play. Before we look at that,
    let''s see quickly how we can get the data from configuration entities. Let''s
    inspect the Article `NodeType` for this purpose:'
  id: totrans-474
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们已经加载了实体，现在可以读取其数据。对于内容实体，这是TypedData知识发挥作用的地方。在我们查看这一点之前，让我们快速看看如何从配置实体中获取数据。为了这个目的，让我们检查Article的`NodeType`：
- en: '[PRE72]'
  id: totrans-475
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'The first and simplest thing we can do is inspect the individual methods on
    the entity type class. For example, `NodeType` has a `getDescription()` method
    which is a handy helper to get the description field:'
  id: totrans-476
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以做的第一件事和最简单的事是检查实体类型类上的单个方法。例如，`NodeType` 有一个 `getDescription()` 方法，这是一个方便的辅助工具来获取描述字段：
- en: '[PRE73]'
  id: totrans-477
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'This is always the best way to try to get the field values of configuration
    entities, because you potentially get return type documentation that can come
    in handy with your IDE. Alternatively, the `ConfigEntityBase` class has the `get()`
    method that can be used to access any of the fields:'
  id: totrans-478
  prefs: []
  type: TYPE_NORMAL
  zh: 这始终是尝试获取配置实体字段值的最佳方式，因为您可能会得到返回类型文档，这在您的IDE中可能很有用。作为替代，`ConfigEntityBase` 类有一个
    `get()` 方法，可以用来访问任何字段：
- en: '[PRE74]'
  id: totrans-479
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: This is going to do the same thing and it is the common way any field can be
    accessed across the different configuration entity types. The resulting value
    is the raw field value, in this case a string. So, this is pretty simple.
  id: totrans-480
  prefs: []
  type: TYPE_NORMAL
  zh: 这将执行相同的事情，并且这是任何字段跨不同配置实体类型访问的常见方式。结果值是原始字段值，在这种情况下是一个字符串。所以，这很简单。
- en: 'Apart from the typical field data, we have the entity keys (if you remember
    from the entity type plugin definitions). These are common for both configuration
    and content entities and the relevant accessor methods are found on the `EntityInterface`.
    Here are some of the more common ones:'
  id: totrans-481
  prefs: []
  type: TYPE_NORMAL
  zh: 除了典型的字段数据外，我们还有实体键（如果您还记得实体类型插件定义）。这些对于配置和内容实体都是通用的，相关的访问器方法可以在 `EntityInterface`
    上找到。以下是一些更常见的例子：
- en: '[PRE75]'
  id: totrans-482
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: The resulting information naturally depends on the entity type. For example,
    configuration entities don't have bundles or some content entity types either.
    So, the `bundle()` method will return the name of the entity type if there are
    no bundles. By far the most important one is `id()` but you will often use `label()`
    as well as a shortcut to the primitive field value of the field used as the label
    for the entity type. There are other entity keys as well that individual entity
    types can declare. For example, entity types that extend the `EditorialContentEntityBase`,
    such as the Node entity, have a `published` entity key and a corresponding `isPublished()` method.
    So, for any other entity keys, do check the respective entity type if you can
    use them.
  id: totrans-483
  prefs: []
  type: TYPE_NORMAL
  zh: 结果信息自然取决于实体类型。例如，配置实体没有捆绑包或某些内容实体类型也没有。因此，`bundle()` 方法在没有捆绑包的情况下将返回实体类型的名称。迄今为止最重要的一个是
    `id()`，但您通常会使用 `label()` 作为到用作实体类型标签的字段原始字段值的快捷方式。还有其他实体键，各个实体类型可以声明。例如，扩展 `EditorialContentEntityBase`
    的实体类型，如节点实体，有一个 `published` 实体键和相应的 `isPublished()` 方法。因此，对于任何其他实体键，请检查相应的实体类型，看看您是否可以使用它们。
- en: 'Some extra methods you can use to inspect entities of any type:'
  id: totrans-484
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用的一些额外的检查任何类型实体的方法：
- en: '`isNew()` checks whether the entity has been persisted already.'
  id: totrans-485
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`isNew()` 检查实体是否已经被持久化。'
- en: '`getEntityTypeId()` returns the machine name of the entity type of the entity.'
  id: totrans-486
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`getEntityTypeId()` 返回实体的实体类型的机器名。'
- en: '`getEntityType()` returns the `EntityTypeInterface` plugin of the given entity.'
  id: totrans-487
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`getEntityType()` 返回给定实体的 `EntityTypeInterface` 插件。'
- en: '`getTypedData()` returns the `EntityAdapter` DataType plugin instance that
    wraps the entity. It can be used for further inspection as well as validation;'
  id: totrans-488
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`getTypedData()` 返回包装实体的 `EntityAdapter` DataType插件实例。它可以用于进一步的检查以及验证；'
- en: 'Moreover, we can also check whether they are a content or a configuration entity:'
  id: totrans-489
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们还可以检查它们是内容实体还是配置实体：
- en: '[PRE76]'
  id: totrans-490
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'Similarly, we can also check whether they are a specific type of entity:'
  id: totrans-491
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，我们也可以检查它们是否是特定类型的实体：
- en: '[PRE77]'
  id: totrans-492
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: This is similar to using `$entity->getEntityTypeId === 'node'` but it is much
    more explicit and clear, plus the IDE can benefit from the information in many
    cases.
  id: totrans-493
  prefs: []
  type: TYPE_NORMAL
  zh: 这与使用 `$entity->getEntityTypeId === 'node'` 类似，但它更加明确和清晰，IDE 也能在许多情况下从中受益。
- en: Now, let's turn to content entities and see how we can read their field data.
  id: totrans-494
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们转向内容实体，看看我们如何读取它们的字段数据。
- en: Similar to configuration entity types, many content entity types can have helper
    methods on their class (or parent) to make accessing certain fields easier. For
    example, the Node entity type has the `getTitle()` method which gets the first
    primitive value of its title field. However, let's see how we can apply what we
    learned in the TypedData section and navigate through the field values like a
    pro. To exemplify, we will examine a simple article node.
  id: totrans-495
  prefs: []
  type: TYPE_NORMAL
  zh: 与配置实体类型类似，许多内容实体类型可以在它们的类（或父类）上具有辅助方法，以便更容易地访问某些字段。例如，节点实体类型有 `getTitle()` 方法，它获取其标题字段的第一个原始值。然而，让我们看看我们如何在
    `TypedData` 部分学到的知识，并像专业人士一样导航字段值。为了举例说明，我们将检查一个简单的文章节点。
- en: 'Content entities also have the `get()` method, but unlike configuration entities,
    it doesn''t return the raw field value. Instead, it returns an instance of `FieldItemList`:'
  id: totrans-496
  prefs: []
  type: TYPE_NORMAL
  zh: 内容实体也有 `get()` 方法，但与配置实体不同，它不返回原始字段值。相反，它返回 `FieldItemList` 的实例：
- en: '[PRE78]'
  id: totrans-497
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: For quick prototyping, in this example I used the static `load()` method on
    the content entity class to load an entity by ID. Under the hood, this will delegate
    to the relevant storage class. This is a quick alternative to using the entity
    manager, but you should only rely on it wherever you cannot inject dependencies.
  id: totrans-498
  prefs: []
  type: TYPE_NORMAL
  zh: 对于快速原型设计，在这个例子中，我使用了内容实体类上的静态 `load()` 方法通过 ID 加载实体。在底层，这将委托给相关的存储类。这是一个使用实体管理器的快速替代方案，但你只应该在无法注入依赖的情况下依赖它。
- en: 'Here are some of the things we can learn about the title `FieldItemList`:'
  id: totrans-499
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一些关于标题 `FieldItemList` 的我们可以了解的事情：
- en: '[PRE79]'
  id: totrans-500
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: 'This is its parent (the DataType plugin it belongs in, in this case, the `EntityAdapter`):'
  id: totrans-501
  prefs: []
  type: TYPE_NORMAL
  zh: 这是它的父级（它所属的数据类型插件，在这种情况下，是 `EntityAdapter`）：
- en: '[PRE80]'
  id: totrans-502
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: 'This is the `DataDefinitionInterface` of the list. In this case it''s a `BaseFieldDefinition`
    instance but can be a `BaseFieldOverride` or a `FieldConfig` for fully configurable
    fields:'
  id: totrans-503
  prefs: []
  type: TYPE_NORMAL
  zh: 这是列表的 `DataDefinitionInterface`。在这种情况下，它是一个 `BaseFieldDefinition` 实例，但可以是 `BaseFieldOverride`
    或 `FieldConfig`，用于完全可配置的字段：
- en: '[PRE81]'
  id: totrans-504
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: 'This is the `DataDefinitionInterface` for the individual items in the list,
    typically a `FieldItemDataDefinition`:'
  id: totrans-505
  prefs: []
  type: TYPE_NORMAL
  zh: 这是列表中单个项目的 `DataDefinitionInterface`，通常是 `FieldItemDataDefinition`：
- en: '[PRE82]'
  id: totrans-506
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: These are some handy methods for inspecting the list. We can see how many items
    there are in it, whether it's empty, and whether there are any values at a given
    offset. Do keep in mind that value keys start at 0, so if the cardinality of the
    field is 1, the value will be at the key 0.
  id: totrans-507
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是一些方便的方法来检查列表。我们可以看到列表中有多少项，它是否为空，以及给定偏移量是否有任何值。请记住，值键从 0 开始，所以如果字段的基数是 1，值将在键
    0 处。
- en: 'To retrieve values from the list, we have a number of options. The most common
    thing you''ll end up doing is the following:'
  id: totrans-508
  prefs: []
  type: TYPE_NORMAL
  zh: 要从列表中检索值，我们有多种选择。你最终最常做的事情如下：
- en: '[PRE83]'
  id: totrans-509
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: 'This is a magic property pointing to the first primitive value in the list.
    However, it''s very important to note that, although most fields use the `value` property, some
    fields have a different property name. For example, entity reference fields use
    `target_id`:'
  id: totrans-510
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个指向列表中第一个原始值的魔法属性。然而，非常重要的一点是，尽管大多数字段使用 `value` 属性，但一些字段有不同的属性名。例如，实体引用字段使用
    `target_id`：
- en: '[PRE84]'
  id: totrans-511
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: 'This returns the ID of the referenced entity. As an added bonus, if you use
    the magic `entity` property, you get the fully loaded entity object:'
  id: totrans-512
  prefs: []
  type: TYPE_NORMAL
  zh: 这返回引用实体的 ID。作为额外的好处，如果你使用魔法 `entity` 属性，你将得到完全加载的实体对象：
- en: '[PRE85]'
  id: totrans-513
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: 'But enough of this magic way of doing things; let''s see what other options
    we have:'
  id: totrans-514
  prefs: []
  type: TYPE_NORMAL
  zh: 但关于这种魔法般做事的方式就到这里吧；让我们看看我们还有哪些其他选择：
- en: '[PRE86]'
  id: totrans-515
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: The `getValue()` method is present on all `TypedData` objects and returns the
    raw values that it stores. In our case, it will return an array with one item
    (since we only have one item in the list) that contains the individual item raw
    values. Which in this case is an array with one element keyed `value` and the
    title string as its actual value. We will see in a moment why this is keyed `value`.
  id: totrans-516
  prefs: []
  type: TYPE_NORMAL
  zh: '`getValue()` 方法存在于所有 `TypedData` 对象上，并返回它存储的原始值。在我们的例子中，它将返回一个包含单个项的数组（因为我们列表中只有一个项），该数组包含单个项的原始值。在这种情况下，它是一个键为
    `value` 并以标题字符串作为其实际值的数组。我们稍后将看到为什么这是键 `value`。'
- en: 'In some cases, we might want this to be returned and can find it useful. In
    other cases though, we might just want the one field value. For this, we can ask
    for a given item in the list:'
  id: totrans-517
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，我们可能希望返回这个值并且觉得它很有用。然而，在其他情况下，我们可能只想获取单个字段的值。为此，我们可以请求列表中的某个特定项：
- en: '[PRE87]'
  id: totrans-518
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: 'Both of these do the same thing and return a `FieldType` plugin which, as we
    saw, extends `FieldItemBase`, which is nothing more than a fancy `Map` DataType
    plugin. Once we have this, we again have a few choices:'
  id: totrans-519
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个都做同样的事情并返回一个 `FieldType` 插件，正如我们所看到的，它扩展了 `FieldItemBase`，这不过是一个花哨的 `Map`
    数据类型插件。一旦我们有了这个，我们又有几个选择：
- en: '[PRE88]'
  id: totrans-520
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: This again returns an array of the raw values, in this case with one key called
    `value` and the string title as the actual value. So, just as we called `getValue()`
    on the list, but this time returning the raw values of only one item instead of
    an array of raw values of multiple items.
  id: totrans-521
  prefs: []
  type: TYPE_NORMAL
  zh: 这再次返回一个包含原始值的数组，在这种情况下，有一个键名为 `value`，字符串标题作为实际值。所以，就像我们在列表上调用 `getValue()`
    一样，但这次返回的是单个项的原始值，而不是多个项的原始值数组。
- en: The reason why we have the actual title string keyed by `value` is because we
    are requesting the raw value from the `StringItem` field type plugin, which in
    this case happens to define the value columns as `value`. Others might differ
    (for example the entity reference field that stores a `target_id` named value).
  id: totrans-522
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之所以使用 `value` 作为键的实际标题字符串，是因为我们正在从 `StringItem` 字段类型插件请求原始值，在这种情况下，它恰好定义了值列名为
    `value`。其他可能不同（例如，存储名为 `target_id` 的值的实体引用字段）。
- en: 'Alternatively, again, we can navigate a bit further down:'
  id: totrans-523
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，再次，我们可以进一步导航：
- en: '[PRE89]'
  id: totrans-524
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: We know that this field uses the name `value` for its property so we can use
    the `get()` method from the `Map` DataType (which, if you remember, is subclassed
    by the `StringItem` field type) to retrieve its own property by name. This is
    exactly the same as we did with the license plate map and when we requested the
    number or state code. In the case of `StringItem` field types, this is going to
    be a `StringData` DataType plugin.
  id: totrans-525
  prefs: []
  type: TYPE_NORMAL
  zh: 我们知道这个字段使用 `value` 作为其属性名，因此我们可以使用 `Map` 数据类型（如果你记得，它是 `StringItem` 字段类型的子类）的
    `get()` 方法通过名称检索其属性。这与我们处理车牌地图和请求号码或州代码时所做的完全相同。在 `StringItem` 字段类型的情况下，这将是一个
    `StringData` 数据类型插件。
- en: 'And as we did before, we can ask this final plugin for its value:'
  id: totrans-526
  prefs: []
  type: TYPE_NORMAL
  zh: 就像我们之前做的那样，我们可以从这个最终插件请求其值：
- en: '[PRE90]'
  id: totrans-527
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: Now we have the final string for the title. Of course, all the way down from
    the top, we have the opportunity to inspect the definitions of each of these plugins
    and learn more information about them.
  id: totrans-528
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了标题的最终字符串。当然，从顶部到底部，我们都有机会检查每个插件的定义并了解更多关于它们的信息。
- en: 'Typically, on the day to day, you will use two methods for retrieving values
    from fields, depending on the cardinality. If the field has only one value, you
    will end up using something like this:'
  id: totrans-529
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，在日常使用中，你会根据基数使用两种方法来从字段中检索值，如果字段只有一个值，你最终会使用类似这样的方法：
- en: '[PRE91]'
  id: totrans-530
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: 'If the field can have multiple values, you will end up using something like
    this:'
  id: totrans-531
  prefs: []
  type: TYPE_NORMAL
  zh: 如果字段可以有多个值，你最终会使用类似这样的方法：
- en: '[PRE92]'
  id: totrans-532
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: The `referencedEntities()` method is a helper one provided by `EntityReferenceFieldItemList`
    (which is a subclass of `FieldItemList`) that loads all the referenced entities
    and returns them in an array keyed by the position in the field (the delta).
  id: totrans-533
  prefs: []
  type: TYPE_NORMAL
  zh: '`referencedEntities()` 方法是由 `EntityReferenceFieldItemList`（它是 `FieldItemList`
    的一个子类）提供的辅助方法，它加载所有引用的实体并将它们以字段（即 delta）中的位置为键返回到一个数组中。'
- en: Manipulating entities
  id: totrans-534
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实体操作
- en: Now that we know how we can read field data programmatically, let's see how
    we can change this data and persist it to the storage. So, let's look at the same
    Node title field and update its value programmatically.
  id: totrans-535
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们知道了如何以编程方式读取字段数据，让我们看看我们如何更改这些数据并将其持久化到存储中。所以，让我们看看相同的 Node 标题字段并对其进行程序化更新。
- en: 'The most common way you can change a field value on a content entity is this:'
  id: totrans-536
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以更改内容实体字段值的最常见方法是这个：
- en: '[PRE93]'
  id: totrans-537
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: 'This works well with fields that have only one value (cardinality = 1) and,
    behind the scenes, essentially this happens:'
  id: totrans-538
  prefs: []
  type: TYPE_NORMAL
  zh: 这对于只有一个值（基数 = 1）的字段效果很好，幕后实际上发生的是：
- en: '[PRE94]'
  id: totrans-539
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: 'This one value gets transformed into a raw array of one value because we are
    dealing with a list of items and the first item receives the changed value. If
    the field has a higher cardinality and we pass only one value as such, we essentially
    remove both of them and replace them with only one. So, if we want to make sure
    we are not deleting items but instead adding to the list, we can do this:'
  id: totrans-540
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们正在处理项目列表，这个值将转换为一个包含一个值的原始数组。如果字段有更高的基数，并且我们传递一个这样的值，我们实际上会删除两个值并替换为只有一个。所以，如果我们想确保我们不是删除项目而是在列表中添加，我们可以这样做：
- en: '[PRE95]'
  id: totrans-541
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: 'If we want to change a specific item in the list, we can do this:'
  id: totrans-542
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们要更改列表中的特定项，我们可以这样做：
- en: '[PRE96]'
  id: totrans-543
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: 'This will change the value of the second item in the list. You just have to
    make sure it is set first before chaining:'
  id: totrans-544
  prefs: []
  type: TYPE_NORMAL
  zh: 这将改变列表中第二个项目的值。你只需确保在链式操作之前先设置它：
- en: '[PRE97]'
  id: totrans-545
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: 'All these modifications we make to field values are, however, kept in memory
    (they are not persisted). To save them to a database we have to do something extremely
    complicated:'
  id: totrans-546
  prefs: []
  type: TYPE_NORMAL
  zh: 我们对字段值所做的所有这些修改都保留在内存中（它们不会被持久化）。为了将它们保存到数据库，我们必须做一些极其复杂的事情：
- en: '[PRE98]'
  id: totrans-547
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: 'That''s it. We can achieve the same thing via the entity type manager as well:'
  id: totrans-548
  prefs: []
  type: TYPE_NORMAL
  zh: 就这些。我们也可以通过实体类型管理器实现相同的功能：
- en: '[PRE99]'
  id: totrans-549
  prefs: []
  type: TYPE_PRE
  zh: '[PRE99]'
- en: Since we are talking about saving, deleting entities can be done in the exact
    same way, except by using the `delete()` method on the entity object. We also
    have this method on the storage handler. However, it accepts an array of entities
    to delete, so you can use that to delete more entities at once.
  id: totrans-550
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们正在谈论保存，删除实体可以通过与实体对象上的`delete()`方法相同的方式进行，我们也在存储处理程序上拥有这个方法。然而，它接受一个要删除的实体数组，因此你可以一次性删除更多实体。
- en: 'Configuration entities have it a bit easier since their fields do not deal
    with TypedData. This is how we can easily change the value of a configuration
    entity field:'
  id: totrans-551
  prefs: []
  type: TYPE_NORMAL
  zh: 配置实体更容易一些，因为它们的字段不处理TypedData。这就是我们可以轻松更改配置实体字段值的方法：
- en: '[PRE100]'
  id: totrans-552
  prefs: []
  type: TYPE_PRE
  zh: '[PRE100]'
- en: Nothing too complex going on here. We load the entity, set a property value
    and save it using the same API.
  id: totrans-553
  prefs: []
  type: TYPE_NORMAL
  zh: 这里没有太多复杂的事情。我们加载实体，设置属性值，并使用相同的API保存它。
- en: Creating entities
  id: totrans-554
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建实体
- en: 'Programmatically creating new entities is also not rocket science and, again,
    we use the entity type storage handler to do so:'
  id: totrans-555
  prefs: []
  type: TYPE_NORMAL
  zh: 以编程方式创建新实体也不是什么难事，我们再次使用实体类型存储处理程序来完成：
- en: '[PRE101]'
  id: totrans-556
  prefs: []
  type: TYPE_PRE
  zh: '[PRE101]'
- en: The storage handler has the `create()` method, which takes one argument in the
    form of an associative array of field values. The keys represent the field name
    and the values the value. This is where you can set initially some simpler values,
    and for more complex fields you still have the API we covered earlier.
  id: totrans-557
  prefs: []
  type: TYPE_NORMAL
  zh: 存储处理程序有`create()`方法，它接受一个形式为字段值关联数组的参数。键代表字段名，值代表值。这就是你可以设置一些初始简单值的地方，对于更复杂的字段，我们仍然有之前提到的API。
- en: If the entity type has bundles, such as the Node example above, the bundle needs
    to be specified in the `create()` method. The key it corresponds to is the entity
    key for the bundle. If you remember the Node entity type plugin, that is `type`.
  id: totrans-558
  prefs: []
  type: TYPE_NORMAL
  zh: 如果实体类型有捆绑包，例如上面的节点示例，则在`create()`方法中需要指定捆绑包。它对应的键是捆绑包的实体键。如果你记得节点实体类型插件，那就是`type`。
- en: That is pretty much it. Again, we need to save it in order to persist it in
    our storage.
  id: totrans-559
  prefs: []
  type: TYPE_NORMAL
  zh: 大概就是这样。再次强调，我们需要保存它以便将其持久化到我们的存储中。
- en: Rendering content entities
  id: totrans-560
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 渲染内容实体
- en: 'Now, let''s see what we can do with an entity to render it on the page. In
    doing so, we will stick to the existing view modes and try not to break it up
    into pieces for rendering in a custom template through our own theme hook. If
    you want to do that, you can. You should have all the knowledge for that already:'
  id: totrans-561
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看我们可以对实体做什么来在页面上渲染它。在这样做的时候，我们将坚持现有的视图模式，并尽量避免通过我们自己的主题钩子将其拆分成片段进行自定义模板渲染。如果你想这样做，你可以。你应该已经具备所有这方面的知识：
- en: Defining a theme hook with variables
  id: totrans-562
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定义带有变量的主题钩子
- en: Querying and loading entities
  id: totrans-563
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 查询和加载实体
- en: Reading the values of an entity
  id: totrans-564
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 读取实体的值
- en: Creating a render array that uses the theme hook
  id: totrans-565
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个使用主题钩子的渲染数组
- en: Instead, we will rely on the entity's default building methodology that allows
    us to render it according to the display mode configured in the UI, so, for example,
    as a teaser or as the full display mode. As always, we will continue with the
    Node as an example.
  id: totrans-566
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，我们将依赖实体默认的构建方法，这允许我们根据 UI 中配置的显示模式渲染它，例如，作为预告或完整显示模式。一如既往，我们将继续以节点为例。
- en: 'The first thing we need to do is get our hands on the *view builder* handler
    of the entity type. Remember this from the entity type plugin definition? Just
    like the storage handler, we can request it from the `EntityTypeManager`:'
  id: totrans-567
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要做的第一件事是获取实体类型的 *视图构建器* 处理器。记得从实体类型插件定义中提到的这一点吗？就像存储处理器一样，我们可以从 `EntityTypeManager`
    中请求它：
- en: '[PRE102]'
  id: totrans-568
  prefs: []
  type: TYPE_PRE
  zh: '[PRE102]'
- en: 'Now that we have that, the simplest way of turning our entity into a render
    array is to use the `view()` method:'
  id: totrans-569
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了这个，将我们的实体转换为渲染数组的最简单方法就是使用 `view()` 方法：
- en: '[PRE103]'
  id: totrans-570
  prefs: []
  type: TYPE_PRE
  zh: '[PRE103]'
- en: By default, this will use the full view mode, but we can pass a second parameter
    and specify another, such as teaser or whatever we have configured. A third optional
    parameter is the langcode of the translation (if we have it) we want to render
    in.
  id: totrans-571
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，这将使用完整视图模式，但我们可以传递第二个参数并指定另一个，例如预告或我们已配置的任何内容。第三个可选参数是我们想要渲染的翻译的 langcode（如果有的话）。
- en: The `$build` variable is now a render array that uses the `node` theme hook
    defined by the Node module. You will notice also a `#pre_render` theme property
    that specifies a callable to be run before the rendering of this array. That is
    actually a reference back to the `NodeViewBuilder` (the node entity type view
    builder) which is responsible for preparing all the field values and all sorts
    of other processing we are not going to cover now. But the `node.twig.html` template
    file, preprocessed by the `*_preprocess_node()` preprocessors, also plays a big
    role in providing some extra variables to be used or rendered in the template.
  id: totrans-572
  prefs: []
  type: TYPE_NORMAL
  zh: '`$build` 变量现在是一个使用由 Node 模块定义的 `node` 主题钩子构建的渲染数组。你还会注意到一个 `#pre_render` 主题属性，它指定了一个在渲染此数组之前要运行的调用。这实际上是对
    `NodeViewBuilder`（节点实体类型视图构建器）的引用，它负责准备所有字段值和所有其他我们现在不会覆盖的处理。但由 `*_preprocess_node()`
    预处理器预处理的 `node.twig.html` 模板文件，在提供一些额外变量以供模板使用或渲染方面也起着重要作用。'
- en: 'If we want, we can also build render arrays for multiple entities at once:'
  id: totrans-573
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想，我们还可以一次构建多个实体的渲染数组：
- en: '[PRE104]'
  id: totrans-574
  prefs: []
  type: TYPE_PRE
  zh: '[PRE104]'
- en: This will still return a render array that contains multiple children for each
    entity being rendered. The `#pre_render` property I mentioned earlier, however,
    will stay at the top level and, this time, be responsible for building multiple
    entities.
  id: totrans-575
  prefs: []
  type: TYPE_NORMAL
  zh: 这仍然会返回一个包含每个渲染实体的多个子元素的渲染数组。然而，我之前提到的 `#pre_render` 属性将保持在顶级，这次将负责构建多个实体。
- en: 'Essentially, it is that simple to get from loading an entity to turning it
    into a render array. You have many different places where you can take control
    over the output. As I said, you can write your own theme hook and break up the
    entity into variables. You can also implement the preprocessor for its default
    theme functions and change some variables in there. You can even change the theme
    hook used and append a suggestion to it and then take it from there, as we saw
    in the chapter on theming:'
  id: totrans-576
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，从加载实体到将其转换为渲染数组的过程非常简单。你有很多不同的地方可以控制输出。正如我说的，你可以编写自己的主题钩子并将实体分解为变量。你还可以实现其默认主题函数的预处理器并更改那里的某些变量。你甚至可以更改使用的主题钩子，并向其中添加一个建议，然后从那里继续，就像我们在主题章节中看到的那样：
- en: '[PRE105]'
  id: totrans-577
  prefs: []
  type: TYPE_PRE
  zh: '[PRE105]'
- en: 'Another important way in which we can control the output is by implementing
    a hook that gets fired when the entity is being built for rendering: `hook_entity_view()`
    or `hook_ENTITY_TYPE_view()`. So, let''s see an example by which we want to append
    a disclaimer message at the bottom of all our Node entities when they are displayed
    in their `full` view mode. We can do something like this:'
  id: totrans-578
  prefs: []
  type: TYPE_NORMAL
  zh: 我们控制输出的另一种重要方式是通过实现一个在实体被构建用于渲染时触发的钩子：`hook_entity_view()` 或 `hook_ENTITY_TYPE_view()`。那么，让我们通过一个示例来看看我们如何在我们所有节点实体在
    `full` 视图模式下显示时，在底部添加一条免责声明信息。我们可以这样做：
- en: '[PRE106]'
  id: totrans-579
  prefs: []
  type: TYPE_PRE
  zh: '[PRE106]'
- en: The three important arguments we work with are the `$build` array passed by
    reference, and which contains the render array for the entire entity, the `$entity`
    object itself, and the `$view_mode` the latter is being rendered in. So, all we
    have to do is add our own render bits inside the `$build` array. As a bonus, we
    try to ensure that the message gets printed at the bottom by using the `#weight`
    property on the render array.
  id: totrans-580
  prefs: []
  type: TYPE_NORMAL
  zh: 我们处理的三项重要参数是通过引用传递的`$build`数组，它包含整个实体的渲染数组，`$entity`对象本身，以及后者正在渲染的`$view_mode`。所以我们只需在`$build`数组中添加我们自己的渲染部分。作为额外的好处，我们尝试通过在渲染数组上使用`#weight`属性来确保消息打印在底部。
- en: Pseudo-fields
  id: totrans-581
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 伪字段
- en: 'Drawing from our example on implementing `hook_entity_view()`, there''s a neat
    little technique we can use to empower our site builders further with respect
    to that disclaimer message. This is by turning it into a *pseudo field*. By doing
    this, site builders will be able to choose the bundles it should show on, as well
    as the position relative to the other fields, all through the UI in the Manage
    Display section:'
  id: totrans-582
  prefs: []
  type: TYPE_NORMAL
  zh: 从我们实现`hook_entity_view()`的示例中，有一个巧妙的小技巧我们可以使用，以进一步增强我们的站点构建者对那条免责声明消息的控制。这就是通过将其转换为*伪字段*。通过这样做，站点构建者将能够选择它应该在哪些包上显示，以及相对于其他字段的相对位置，所有这些都可以通过管理显示部分中的UI来完成：
- en: '![](img/a2251d18-b89a-4aa3-ae6a-17759425c36f.png)'
  id: totrans-583
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/a2251d18-b89a-4aa3-ae6a-17759425c36f.png)'
- en: 'So, there are two things we need to do for this. First, we need to implement
    `hook_entity_extra_field_info()` and define our *pseudo field*:'
  id: totrans-584
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们需要做两件事。首先，我们需要实现`hook_entity_extra_field_info()`并定义我们的*伪字段*：
- en: '[PRE107]'
  id: totrans-585
  prefs: []
  type: TYPE_PRE
  zh: '[PRE107]'
- en: As you can see, we loop through all the available node types and for the `node`
    entity display list, we add our `disclaimer` definition with some defaults to
    use. The weight and visibility will, of course, be overridable by the user, per
    node bundle.
  id: totrans-586
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所看到的，我们遍历所有可用的节点类型，并在`node`实体显示列表中添加我们的`disclaimer`定义和一些默认值以供使用。权重和可见性当然可以被用户覆盖，每个节点包各不相同。
- en: 'Next, we need to go back to our `hook_entity_view()` implementation and make
    some changes. Because we know we want this applied to Node entities only, we can
    implement the more specific hook instead:'
  id: totrans-587
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要回到我们的`hook_entity_view()`实现并做一些修改。因为我们知道我们只想将此应用于节点实体，所以我们可以实现更具体的钩子：
- en: '[PRE108]'
  id: totrans-588
  prefs: []
  type: TYPE_PRE
  zh: '[PRE108]'
- en: In this case we don't need to check for view modes or entity types, but rather
    use the entity view display configuration object to check for the existence of
    this extra `disclaimer` field (technically called a *component*). If found, we
    simply add our markup to the `$build` array. Drupal will take care of things like
    weight and visibility to match whatever the user has set through the UI, and that's
    it. Clearing the cache, we should still see our disclaimer message, but we can
    now control it a bit from the UI.
  id: totrans-589
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们不需要检查视图模式或实体类型，而是使用实体视图显示配置对象来检查是否存在这个额外的`disclaimer`字段（技术上称为*组件*）。如果找到，我们只需将我们的标记添加到`$build`数组中。Drupal将负责处理诸如权重和可见性等方面的事情，以匹配用户通过UI设置的任何内容，就这样了。清除缓存后，我们应该仍然看到我们的免责声明消息，但现在我们可以从UI中稍微控制它。
- en: Entity validation
  id: totrans-590
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实体验证
- en: The last thing we are going to talk about in this chapter is entity validation
    and how we can make sure that field and entity data as a whole contains valid
    data. When I say valid, I don't mean whether it complies with the strict TypedData
    definition but whether, within that, it complies with certain restrictions (constraints)
    we impose on it. As such, most of the time, entity validation applies to content
    entities. However, we can also run validation on configuration entities but only
    insofar as to ensure that the field values are of the correct data type as described
    in the configuration schema. And in this respect, we are talking about TypedData
    definitions under the hood.
  id: totrans-591
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的最后，我们将讨论实体验证以及我们如何确保字段和实体数据作为一个整体包含有效数据。当我提到有效时，我并不是指它是否遵守严格的TypedData定义，而是在那个定义中，它是否遵守我们对其施加的某些限制（约束）。因此，大多数情况下，实体验证适用于内容实体。然而，我们也可以对配置实体进行验证，但仅限于确保字段值符合配置模式中描述的正确数据类型。在这方面，我们谈论的是底层的TypedData定义。
- en: Drupal 8 uses the Symfony Validator component for applying constraints and then
    validating entities, fields and any other data against those constraints. I do
    recommend that you check out the Symfony documentation page on this component
    to better understand its principles. For now, let's quickly see how it is applied
    in Drupal 8.
  id: totrans-592
  prefs: []
  type: TYPE_NORMAL
  zh: Drupal 8 使用 Symfony 验证器组件来应用约束，然后验证实体、字段和任何其他数据是否与这些约束相符。我确实建议你查看有关此组件的 Symfony
    文档页面，以更好地理解其原理。现在，让我们快速看看它在 Drupal 8 中的应用。
- en: 'There are three main parts to a validation: a constraint plugin, a validator
    class and potential violations. The first is mainly responsible for defining what
    kind of data it can be applied to, the error message it should show, and which
    validator class is responsible for validating it. If it omits the latter, the
    validator class name defaults to the name of the constraint class with the word
    `Validator` appended to it. The validator, on the other hand, is called by the
    validation service to validate the constraint and build a list of violations.
    Finally, the violations are data objects that provide helpful information about
    what went wrong in the validation: things like the error message from the constraint,
    the offending value and the path to the property that failed.'
  id: totrans-593
  prefs: []
  type: TYPE_NORMAL
  zh: 验证有三个主要部分：约束插件、验证器类和潜在的违规。第一个主要负责定义它可以应用于哪种类型的数据，它应该显示的错误信息，以及哪个验证器类负责验证它。如果它省略了后者，验证器类名称将默认为约束类名称，并在其后附加
    `Validator` 字样。另一方面，验证器是由验证服务调用来验证约束并构建违规列表的。最后，违规是提供有关验证中发生错误的有用信息的数据对象：例如约束的错误信息、违规值以及失败属性的路径。
- en: To better understand things, we have to go back to the TypedData and see some
    simple examples, because that is the level at which the validation happens.
  id: totrans-594
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更好地理解这些内容，我们必须回到 TypedData 并查看一些简单的示例，因为验证是在这个级别发生的。
- en: 'So, let''s look at the same example I introduced TypedData with earlier in
    this chapter:'
  id: totrans-595
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，让我们看看我在本章前面介绍的与 TypedData 相同的示例：
- en: '[PRE109]'
  id: totrans-596
  prefs: []
  type: TYPE_PRE
  zh: '[PRE109]'
- en: 'The data definitions have methods for applying and reading constraints. If
    you remember, one of the reasons why we need this API is to be able to enrich
    data with meta information. Constraints are such information. In this example,
    we are applying a constraint called `Length` (the plugin ID of the constraint)
    with some arbitrary parameters expected by that constraint (in this case a maximum
    length but also a minimum would work). Having applied this constraint, we are
    essentially saying that this piece of string data is only valid if it''s shorter
    than 20 characters. And we can use it like so:'
  id: totrans-597
  prefs: []
  type: TYPE_NORMAL
  zh: 数据定义有应用和读取约束的方法。如果你还记得，我们需要这个 API 的一个原因是为了能够用元信息丰富数据。约束就是这样的信息。在这个例子中，我们正在应用一个名为
    `Length`（约束的插件 ID）的约束，并使用该约束期望的一些任意参数（在这种情况下是一个最大长度，但也可以使用最小长度）。应用了这个约束之后，我们本质上是在说，这段字符串数据只有在它的长度小于
    20 个字符时才是有效的。我们可以这样使用它：
- en: '[PRE110]'
  id: totrans-598
  prefs: []
  type: TYPE_PRE
  zh: '[PRE110]'
- en: 'DataType plugins have a `validate()` method on them that uses the validation
    service to validate their underlying data definition against any of the constraints
    applied to it. The result is an instance of the `ConstraintViolationList` iterator
    which contains a `ConstraintViolationInterface` instance for each validation failure.
    In this example, we should have a violation from which we can get some information
    like so:'
  id: totrans-599
  prefs: []
  type: TYPE_NORMAL
  zh: DataType 插件在其上有一个 `validate()` 方法，它使用验证服务来验证其底层数据定义与对其应用的任何约束。结果是 `ConstraintViolationList`
    迭代器的一个实例，它包含每个验证失败的一个 `ConstraintViolationInterface` 实例。在这个例子中，我们应该有一个违规项，我们可以从中获取一些信息，如下所示：
- en: '[PRE111]'
  id: totrans-600
  prefs: []
  type: TYPE_PRE
  zh: '[PRE111]'
- en: The `$message` is the error message that comes from the failing constraint,
    the `$value` is the actual incorrect value, and `$path` is a string representation
    of the hierarchical path down to the value that has failed. If you remember our
    license plate example or the content entity fields, TypedData can be nested, which
    means you can have all sorts of values at different levels. In our previous example, `$path`
    is, however, going to be `""` (an empty string) because the data definition has
    only one level.
  id: totrans-601
  prefs: []
  type: TYPE_NORMAL
  zh: '`$message` 是来自失败约束的错误信息，`$value` 是实际的不正确值，而 `$path` 是表示到失败值所在层级路径的字符串表示。如果你还记得我们的车牌示例或内容实体字段，TypedData
    可以嵌套，这意味着你可以在不同级别拥有各种值。在我们的上一个例子中，`$path` 将会是 `""`（一个空字符串），因为数据定义只有一个级别。'
- en: 'Let''s revisit our license plate example and see how such a constraint would
    work there. Imagine we wanted to add a similar constraint to the state code definition:'
  id: totrans-602
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回顾一下我们的车牌例子，看看这样的约束在那里是如何工作的。想象一下，我们想要向状态码定义添加一个类似的约束：
- en: '[PRE112]'
  id: totrans-603
  prefs: []
  type: TYPE_PRE
  zh: '[PRE112]'
- en: If you look closely, I instantiated the plate with a state code longer than
    two characters. Now, if we ask our individual violations for the property path,
    we get `state`, because that is what we called the state definition property within
    the bigger map definition.
  id: totrans-604
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你仔细观察，我用一个超过两个字符的状态码实例化了该盘子。现在，如果我们为单个违规行为请求属性路径，我们会得到`state`，因为这是我们在大地图定义中称呼状态定义属性的内容。
- en: Content entities
  id: totrans-605
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 内容实体
- en: 'Let''s now see an example of validating constraints on entities. First of all,
    we can run the `validate()` method on an entire entity, which will then use its
    TypedData wrapper (`EntityAdapter`) to run a validation on all the fields on the
    entity plus any of the entity-level constraints. The latter can be added via the
    `EntityType` plugin definition (the annotation). For example, the Comment entity
    type has this bit:'
  id: totrans-606
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来看一个验证实体约束的例子。首先，我们可以在整个实体上运行`validate()`方法，然后它将使用其TypedData包装器（`EntityAdapter`）对实体上的所有字段以及任何实体级别的约束进行验证。后者可以通过`EntityType`插件定义（注解）添加。例如，评论实体类型有如下内容：
- en: '[PRE113]'
  id: totrans-607
  prefs: []
  type: TYPE_PRE
  zh: '[PRE113]'
- en: 'This means that the constraint plugin ID is `CommentName` and it takes no parameters
    (since the braces are empty). We can even add constraints to entity types that
    do not "belong" to us by implementing `hook_entity_type_alter()`, for example:'
  id: totrans-608
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着约束插件ID是`CommentName`，它不接受任何参数（因为括号是空的）。我们甚至可以通过实现`hook_entity_type_alter()`将约束添加到不属于我们的实体类型，例如：
- en: '[PRE114]'
  id: totrans-609
  prefs: []
  type: TYPE_PRE
  zh: '[PRE114]'
- en: 'Going one level below and knowing that content entity fields are built on top
    of the TypedData API, it follows that all those levels can have constraints. We
    can add the constraints regularly to the field definitions or, in the case of
    either fields that are not "ours" or configurable fields, we can use hooks to
    add constraints. Using `hook_entity_base_field_info_alter()` we can add constraints
    to base fields while with `hook_entity_bundle_field_info_alter()` we can add constraints
    to configurable fields (and overridden base fields). Let''s see an example of
    how we can add constraints to the Node ID field:'
  id: totrans-610
  prefs: []
  type: TYPE_NORMAL
  zh: 下一级，我们知道内容实体字段是基于TypedData API构建的，因此所有这些级别都可以有约束。我们可以将约束常规地添加到字段定义中，或者，在字段不是“我们自己的”或可配置字段的情况下，我们可以使用钩子来添加约束。使用`hook_entity_base_field_info_alter()`我们可以添加到基本字段上的约束，而使用`hook_entity_bundle_field_info_alter()`我们可以添加到可配置字段（以及重写的基字段）上的约束。让我们看看如何将约束添加到节点ID字段的例子：
- en: '[PRE115]'
  id: totrans-611
  prefs: []
  type: TYPE_PRE
  zh: '[PRE115]'
- en: As you can see, we are still just working with data definitions. One thing to
    note, however, is that when it comes to base fields and configurable fields (which
    are lists of items), we also have the `addPropertyConstraints()` method available.
    This simply makes sure that whatever constraint we are adding is targeted toward the
    actual items in the list (specifying which property), rather than the entire list
    as it would have happened had we used the main `addConstraint()` API. Another
    difference with this method is that constraints get wrapped into a `ComplexDataConstraint`
    plugin. However, you don't have to worry too much about that; just be aware when
    you see it.
  id: totrans-612
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，我们仍在处理数据定义。然而，值得注意的是，当涉及到基本字段和可配置字段（它们是项目列表）时，我们也有`addPropertyConstraints()`方法可用。这仅仅确保我们添加的任何约束都是针对列表中的实际项目（指定哪个属性），而不是整个列表，如果我们使用主要的`addConstraint()`
    API，就会发生这种情况。这个方法与另一个区别是，约束被包装进`ComplexDataConstraint`插件中。然而，你不必过于担心这一点；只需在你看到它时意识到即可。
- en: 'We can even inspect the constraints found on a data definition object. For
    example, this is how we can read the constraints found on the Node ID field:'
  id: totrans-613
  prefs: []
  type: TYPE_NORMAL
  zh: 我们甚至可以检查数据定义对象上找到的约束。例如，这是读取节点ID字段上找到的约束的方法：
- en: '[PRE116]'
  id: totrans-614
  prefs: []
  type: TYPE_PRE
  zh: '[PRE116]'
- en: Where the `getConstraints()` method returns an array of constraint plugin instances.
  id: totrans-615
  prefs: []
  type: TYPE_NORMAL
  zh: 其中`getConstraints()`方法返回一个约束插件实例数组。
- en: 'Now let''s see how we can validate entities:'
  id: totrans-616
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来看一下我们如何验证实体：
- en: '[PRE117]'
  id: totrans-617
  prefs: []
  type: TYPE_PRE
  zh: '[PRE117]'
- en: The entity-level `validate()` method returns an instance of `EntityConstraintViolationList`
    which is a more specific version of the `ConstraintViolationList` we talked about
    earlier. The latter is, however, returned by the `validate()` method of the other
    cases above. But for all of them, inside we have a collection of `ConstraintViolationInterface`
    instances from which we can learn some things about what did not validate.
  id: totrans-618
  prefs: []
  type: TYPE_NORMAL
  zh: 实体级别的 `validate()` 方法返回一个 `EntityConstraintViolationList` 实例，这是之前提到的 `ConstraintViolationList`
    的一个更具体版本。然而，后者是由上述其他情况的 `validate()` 方法返回的。但对于所有这些情况，我们内部都有一个 `ConstraintViolationInterface`
    实例的集合，我们可以从中了解一些关于哪些没有通过验证的信息。
- en: 'The entity-level validation goes through all the fields and validates them
    all. Next, the list will contain violations of any of the items in the list, while
    the item will contain only the violations on that individual item in the list.
    The property path is something interesting to observe. The following is the result
    of calling `getPropertyPath()` on a violation found in all three of the resulting
    violation lists from the example above:'
  id: totrans-619
  prefs: []
  type: TYPE_NORMAL
  zh: 实体级别的验证会遍历所有字段并对它们进行验证。接下来，列表将包含列表中任何项目的违规行为，而项目将只包含列表中单个项目的违规行为。属性路径是值得关注的一个点。以下是在上述示例中从三个结果违规列表中找到的违规的
    `getPropertyPath()` 调用结果：
- en: '[PRE118]'
  id: totrans-620
  prefs: []
  type: TYPE_PRE
  zh: '[PRE118]'
- en: 'As you can see, this reflects the TypedData hierarchy. When we validate the
    entire entity, it gives us a property path all the way down to the value: field
    name -> delta (position in the list) -> property name. Once we validate the field,
    we already know what field we are validating, so that is omitted. And the same
    goes for the individual item (we know also the delta of the item).'
  id: totrans-621
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，这反映了TypedData层次结构。当我们验证整个实体时，它给我们一个属性路径，一直到底部的值：字段名 -> delta（列表中的位置）->
    属性名。一旦我们验证了字段，我们就已经知道我们正在验证哪个字段，所以这部分被省略了。同样，对于单个项目也是如此（我们也知道项目的delta）。
- en: A word of warning about base fields that can be overridden per bundle such as
    the Node title field. As I mentioned earlier, the base definition for these fields
    uses an instance of `BaseFieldOverride`, which allows certain changes to be made
    to the definition via the UI. In this respect, they are very close to configurable
    fields. The "problem" with this is that, if we tried to apply a constraint like
    we just did with the `nid` to, say, the Node `title` field, we wouldn't have gotten
    any violations when validating. This is because the validator performs the validation
    on the `BaseFieldOverride` definition rather than the `BaseFieldDefinition`.
  id: totrans-622
  prefs: []
  type: TYPE_NORMAL
  zh: 关于可以按包覆盖的基本字段（如节点标题字段）的警告。如我之前提到的，这些字段的基本定义使用 `BaseFieldOverride` 实例，这允许通过UI对定义进行某些更改。在这方面，它们与可配置字段非常相似。这个问题在于，如果我们尝试像刚才对
    `nid` 应用约束一样，对节点 `title` 字段应用约束，我们在验证时不会得到任何违规。这是因为验证器在 `BaseFieldOverride` 定义上执行验证，而不是在
    `BaseFieldDefinition` 上。
- en: This is no problem, though, as we can use `hook_entity_bundle_field_info_alter()`
    and do the same thing as we did before, which will then apply the constraint to
    the overridden definition. In doing so, we can also account for the bundle we
    want this applied to. This is the same way you apply constraints to a configurable
    field you create in the UI.
  id: totrans-623
  prefs: []
  type: TYPE_NORMAL
  zh: 这并不是问题，因为我们可以使用 `hook_entity_bundle_field_info_alter()` 并执行与之前相同的事情，这样就会将约束应用到覆盖的定义上。在这个过程中，我们还可以考虑我们想要应用此约束的包。这与你在UI中创建的可配置字段应用约束的方式相同。
- en: Configuration entities
  id: totrans-624
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 配置实体
- en: Configuration entity fields are not exposed to the TypedData API in terms of
    data definition. If you remember, though, we do have the configuration schema
    that describes the type of data that is considered valid in the entity. This is, for
    the moment, the extent to which we can validate configuration entities as they
    are not (yet) exposed to the constraint-validator system.
  id: totrans-625
  prefs: []
  type: TYPE_NORMAL
  zh: 在数据定义方面，配置实体字段并未暴露给TypedData API。如果你还记得，我们确实有配置模式，它描述了在实体中认为有效的数据类型。目前，这就是我们可以验证配置实体的范围，因为它们尚未（尚未）暴露给约束验证器系统。
- en: 'But before we conclude this chapter, let''s quickly see how we can validate
    a configuration entity. Here is a quick example:'
  id: totrans-626
  prefs: []
  type: TYPE_NORMAL
  zh: 但在我们结束这一章之前，让我们快速看看我们如何验证一个配置实体。以下是一个快速示例：
- en: '[PRE119]'
  id: totrans-627
  prefs: []
  type: TYPE_PRE
  zh: '[PRE119]'
- en: The first thing we do is load a configuration entity. In this case it's a View, but
    it doesn't matter as it's backed by a schema definition (found in `views.schema.yml`).
    By default, the entity is valid, so in this example, I change the `status` field
    to a string (not a Boolean). Then for the actual validation we create a new `ConfigEntityAdapter`
    instance (which is like the `EntityAdapter` we saw earlier for content entities).
    And we can now call `validate()` on that like before. The result will be a list
    of violations, which in the case of this example, will contain one that says we
    are using an incorrect primitive value for the `status` field. And that is pretty
    much it.
  id: totrans-628
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先加载一个配置实体。在这种情况下，它是一个视图，但这并不重要，因为它由一个模式定义支持（在`views.schema.yml`中找到）。默认情况下，实体是有效的，所以在本例中，我将`status`字段改为字符串（而不是布尔值）。然后，对于实际的验证，我们创建一个新的`ConfigEntityAdapter`实例（类似于我们之前看到的用于内容实体的`EntityAdapter`）。现在我们可以像以前一样调用`validate()`。结果将是一个违规列表，在本例中，将包含一个说我们为`status`字段使用了不正确的原始值。这就是全部内容。
- en: Validation summary
  id: totrans-629
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 验证摘要
- en: As we've seen, Drupal 8 applies the Symfony validation component to its very
    own TypedData and plugin API both for discoverability and data validation handling.
    In doing so, we get a low-level API for applying constraints to any kind of data,
    ranging from simple primitive data definitions all the way to complex entities
    and fields. We have not covered this here, but we can also easily create our own
    constraints and validators if the ones provided are not enough.
  id: totrans-630
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所见，Drupal 8将Symfony验证组件应用于其自己的TypedData和插件API，既为了可发现性，也为了数据验证处理。这样做，我们得到了一个低级API，可以应用于任何类型的数据，从简单的原始数据定义到复杂的实体和字段。我们在这里没有涉及这一点，但如果提供的不够，我们也可以轻松创建自己的约束和验证器。
- en: Moreover, we saw that we can also apply schema validations to configuration
    entities. This capability has been made available in version 8.6\. And work is
    underway to expose configuration entities to the full validation system.
  id: totrans-631
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们还看到我们也可以将模式验证应用于配置实体。这种功能在8.6版本中已经提供。目前正在进行工作，以将配置实体暴露给完整的验证系统。
- en: Summary
  id: totrans-632
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: You didn't think you were ever going to see this heading did you? This chapter
    has been very long but highly theoretical. We haven't built anything fun and the
    only code we saw was to exemplify most of the things we talked about. It was a
    difficult chapter as it covered many complex aspects of data storage and handling.
    But trust me, these things are important to know and this chapter can serve both
    as a starting point to dig deeper into the code and a reference to get back to
    when unsure of certain aspects.
  id: totrans-633
  prefs: []
  type: TYPE_NORMAL
  zh: 你难道以为你永远不会看到这个标题了吗？这一章内容非常长，但非常理论化。我们没有构建任何有趣的东西，我们看到的唯一代码只是为了举例说明我们讨论的大部分内容。这是一个很难的章节，因为它涵盖了数据存储和处理的大量复杂方面。但是相信我，了解这些事情很重要，这一章既可以作为深入挖掘代码的起点，也可以作为在不确定某些方面时的参考。
- en: 'We saw what the main options for storing data in Drupal 8 are. Ranging from
    the State API all the way to entities, you have a host of alternatives. After
    covering the more simple ways, such as the State API, the private and shared tempstores
    and the UserData API, we dove a bit more into the configuration system, which
    is a very important one to understand. There, we saw what kinds of configuration
    types we have, how to work with simple configuration, how it''s managed and stored,
    and so on. Finally, in what is arguably the most complex part of the chapter,
    we looked at entities, both content and configuration. Just as you were recovering
    from reading all about how entity types are plugins with so many options, I hit
    you with the TypedData API. But right after that we put it to good use and saw
    how we can interact with entities: query, load, manipulate and validate data based
    on TypedData.'
  id: totrans-634
  prefs: []
  type: TYPE_NORMAL
  zh: 我们看到了在Drupal 8中存储数据的主要选项。从State API到实体，你有一系列替代方案。在介绍了更简单的方法，如State API、私有和共享tempstores以及UserData
    API之后，我们更深入地了解了配置系统，这是一个非常重要的系统需要理解。在那里，我们看到了我们有哪些配置类型，如何处理简单的配置，它是如何管理和存储的，等等。最后，在可能是本章最复杂的一部分，我们看了实体，包括内容和配置。正当你从阅读有关实体类型是具有许多选项的插件的全部内容中恢复过来时，我向你介绍了TypedData
    API。但就在之后，我们立即将其用于实际操作，并看到了我们如何与实体交互：查询、加载、操作和基于TypedData验证数据。
- en: In the next chapter, we will apply in a very practical way a lot of the knowledge
    we learned in this one, especially related to content and configuration entities,
    but also plugin types and so on. So, that should be much more enjoyable, as we
    are going to create a new module that actually does something useful.
  id: totrans-635
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将非常实际地应用在这一章中学到的许多知识，特别是与内容实体和配置实体相关，还包括插件类型等等。因此，这应该会更有趣，因为我们将创建一个真正有用的新模块。
