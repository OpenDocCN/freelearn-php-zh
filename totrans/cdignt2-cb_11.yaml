- en: Chapter 11. SEO, Caching, and Logging
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第11章 SEO、缓存和记录
- en: 'In this chapter, you will learn:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你将学习：
- en: Using SEO-friendly URLs in CodeIgniter
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在CodeIgniter中使用SEO友好的URL
- en: Using CodeIgniter caching
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用CodeIgniter缓存
- en: Logging errors with CodeIgniter
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用CodeIgniter记录错误
- en: Benchmarking your application
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对你的应用程序进行基准测试
- en: Introduction
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简介
- en: In this chapter, we'll be taking a look at various caching recipes, which can
    be used with CodeIgniter. We'll be using the CodeIgniter caching functionality
    to help us store a data feed and database results--although the data feed and
    database results are really only there as a means to show you how to get data
    into CodeIgniter, so it can cache it--the data input can be anything you wish.
    We'll also look at ways to implement SEO-friendly URLs using CodeIgniter routing.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将查看各种可用于CodeIgniter的缓存配方。我们将使用CodeIgniter的缓存功能来帮助我们存储数据源和数据库结果——尽管数据源和数据库结果实际上只是作为向你展示如何将数据输入到CodeIgniter中，以便它可以进行缓存的一种手段——数据输入可以是任何你希望的内容。我们还将探讨使用CodeIgniter路由实现SEO友好URL的方法。
- en: Using SEO-friendly URLs in CodeIgniter
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在CodeIgniter中使用SEO友好的URL
- en: At some point, you might want to alter how CodeIgniter handles the routing of
    URLs to controllers. By default, CodeIgniter splits a URL into several different
    parts. You obviously have the domain section of the URL (`www.domain.com`), but
    after that there are (usually, but not always) up to three more items, each separated
    by a forward slash. The first item is the controller, the second is the function
    (or method, if you want) in the controller, and the third is a parameter that
    you will pass to the function in the controller.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在某个时候，你可能想要改变CodeIgniter处理URL到控制器路由的方式。默认情况下，CodeIgniter将URL分割成几个不同的部分。显然，URL中有域名部分（`www.domain.com`），但之后通常（但不总是）还有三个更多项目，每个项目之间由正斜杠分隔。第一个项目是控制器，第二个是控制器中的函数（或方法，如果你愿意），第三个是你将传递给控制器中函数的参数。
- en: So, a standard URL in CodeIgniter might look like `www.domain.com/users/edit/1`.
    So, user number `1` is being edited using the `edit` function in the `users` controller--that
    seems simple enough and I'm sure you're familiar with it.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，CodeIgniter中的一个标准URL可能看起来像`www.domain.com/users/edit/1`。所以，用户编号`1`正在使用`users`控制器中的`edit`函数进行编辑——这看起来很简单，我相信你很熟悉它。
- en: However, there may be times when you wish this to change. It is possible to
    alter what is displayed in the URL in the web browser's address bar to show something
    different from `controller/function/data`. It is possible to set up a rule in
    the `config/routes`.php file, which will map a URL to a controller, but hide this
    from the address bar; for example, you may have a controller named `bulletin`,
    which you wish to be displayed as `news` in the URL.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，可能会有时候你希望它改变。在`config/routes.php`文件中设置一个规则，可以将URL映射到控制器，但隐藏在地址栏中显示的内容；例如，你可能有一个名为`bulletin`的控制器，你希望它在URL中显示为`news`。
- en: How to do it...
  id: totrans-12
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'We''re going to create one file and amend another file, by performing the following
    steps:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将创建一个文件，并修改另一个文件，通过以下步骤进行：
- en: 'Create the `/path/to/codeigniter/application/controllers/shop.php` file and
    add the following code to it:'
  id: totrans-14
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建`/path/to/codeigniter/application/controllers/shop.php`文件，并将其中的以下代码添加到该文件中：
- en: '[PRE0]'
  id: totrans-15
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Open the `/path/to/codeigniter/config/routes.php` file in your editor and amend
    accordingly (the changes are highlighted):'
  id: totrans-16
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在你的编辑器中打开`/path/to/codeigniter/config/routes.php`文件，并相应地进行修改（更改已突出显示）：
- en: '[PRE1]'
  id: totrans-17
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: How it works...
  id: totrans-18
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'Take a look at the following lines in the `config/routes.php` file:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 查看以下`config/routes.php`文件中的以下行：
- en: '[PRE2]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Now, think of them as being made up of a left and a right, in that before the
    `=` sign is left and anything after the `=` sign is right; the left maps to the
    right and the value in the left will be mapped to the value in the right.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，想象它们由左右两部分组成，即在`=`符号之前是左部分，在`=`符号之后是右部分；左部分映射到右部分，左部分的值将映射到右部分的值。
- en: 'In the preceding example, any URL whose controller name begins with `item`
    will be mapped to the `shop` controller. Let''s look at each rule in turn:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，任何以`item`开头的控制器名称的URL都将映射到`shop`控制器。让我们逐一查看每个规则：
- en: 'By typing the name of the route into your browser (for example, `http://www.your_web_site_name.com/item`),
    the `item` command will cause CodeIgniter to call the `shop` controller, and within
    that controller the `public function all()` method. Because we defined it in the
    routes file, you will see this in your browser by typing `item` into the URL.
    CodeIgniter maps the requested URL to the path defined in the route rule, and
    (in our example) calls the `shop` controller, which using `__CLASS__` and `__FUNCTION__`
    will write the following output to the browser:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 通过在浏览器中输入路由的名称（例如，`http://www.your_web_site_name.com/item`），`item` 命令将导致 CodeIgniter
    调用 `shop` 控制器，并在该控制器中调用 `public function all()` 方法。因为我们已经在路由文件中定义了它，所以你可以在浏览器中通过输入
    `item` 到 URL 中看到这一点。CodeIgniter 将请求的 URL 映射到路由规则中定义的路径，并且（在我们的例子中）调用 `shop` 控制器，它使用
    `__CLASS__` 和 `__FUNCTION__` 将以下输出写入浏览器：
- en: '![How it works...](img/2308OS_11_01.jpg)'
  id: totrans-24
  prefs: []
  type: TYPE_IMG
  zh: '![如何工作...](img/2308OS_11_01.jpg)'
- en: Now, take a look at the URL in the browser address bar, it will still display
    the item, but the text on the screen says it's the `shop` controller that is being
    called. We have now mapped the URL to a controller and the user is none the wiser.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，看看浏览器地址栏中的 URL，它仍然会显示 `item`，但屏幕上的文本说正在调用的是 `shop` 控制器。我们现在已经将 URL 映射到控制器，而用户却毫无察觉。
- en: 'Now, let''s look at the other route rule--`:any`. By typing the name of the
    route into your browser (for example, `http://www.your_web_site_name.com/item/123456`),
    the `item/123456` command will cause CodeIgniter to call the `shop` controller
    and `public function product()` because we defined it in the routes file. In `public
    function product()`, we echo out not only the `__CLASS__` and `__FUNCTION__` names,
    but also the second segment of the URI:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看其他的路由规则--`:any`。通过在浏览器中输入路由的名称（例如，`http://www.your_web_site_name.com/item/123456`），`item/123456`
    命令将导致 CodeIgniter 调用 `shop` 控制器和 `public function product()`，因为我们已经在路由文件中定义了它。在
    `public function product()` 中，我们不仅输出了 `__CLASS__` 和 `__FUNCTION__` 名称，还输出了 URI
    的第二个部分：
- en: '[PRE3]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Which, in this case, is the ID of the product (`12356`), so you will see the
    following screenshot in the browser:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，是产品的 ID (`12356`)，所以你将在浏览器中看到以下截图：
- en: '![How it works...](img/2308OS_11_02.jpg)'
  id: totrans-29
  prefs: []
  type: TYPE_IMG
  zh: '![如何工作...](img/2308OS_11_02.jpg)'
- en: The key to this route is the `(:any)` flag in the route mapping rule; `(:any)`
    tells CodeIgniter that the second segment in the URI, whatever it is, should map
    to the `product` function of the `shop` controller. As we're the ones building
    the code, we will know that the second URI segment in the URL is a product ID,
    which we can use to query the database for the details of that product.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 这条路由的关键在于路由映射规则中的 `(:any)` 标志；`(:any)` 告诉 CodeIgniter，URI 的第二个部分，无论是什么，都应该映射到
    `shop` 控制器的 `product` 函数。因为我们是在编写代码，所以我们会知道 URL 的第二个 URI 段是产品 ID，我们可以用它来查询数据库以获取该产品的详细信息。
- en: Using CodeIgniter caching
  id: totrans-31
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 CodeIgniter 缓存
- en: You can use CodeIgniter caching to cache (or temporarily store) practically
    anything. As an example of caching with CodeIgniter, we're going to cache an RSS
    feed. We could, of course, cache anything we wanted; however, caching an RSS feed
    is a good place to start. Working with RSS is quite simple and the recipe can
    easily be converted to cache feeds from other sources, such as a call to Twitter,
    for example.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用 CodeIgniter 缓存来缓存（或临时存储）几乎任何东西。作为一个使用 CodeIgniter 的缓存示例，我们将缓存一个 RSS 源。我们当然可以缓存我们想要的任何东西；然而，缓存一个
    RSS 源是一个好的开始。处理 RSS 非常简单，这个配方可以很容易地转换为缓存来自其他来源的源，例如调用 Twitter 等。
- en: How to do it...
  id: totrans-33
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: We're going to create the `/path/to/codeigniter/application/controllers/rss_cache.php`
    file.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将创建 `/path/to/codeigniter/application/controllers/rss_cache.php` 文件。
- en: 'Create the preceding file and add the following code to it:'
  id: totrans-35
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建前面的文件，并向其中添加以下代码：
- en: '[PRE4]'
  id: totrans-36
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: How it works...
  id: totrans-37
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'First, let''s look at the constructor. We''re loading one helper and one driver,
    as shown in the following code snippet:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们看看构造函数。我们正在加载一个助手和一个驱动程序，如下面的代码片段所示：
- en: '[PRE5]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Tip
  id: totrans-40
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: To use APC, you'll need to ensure that APC is installed on the environment you're
    working on. If not, you'll need to install it. To do this, visit [http://www.php.net/manual/en/apc.setup.php](http://www.php.net/manual/en/apc.setup.php)
    for more details.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用 APC，你需要确保你正在工作的环境中安装了 APC。如果没有，你需要安装它。为此，请访问 [http://www.php.net/manual/en/apc.setup.php](http://www.php.net/manual/en/apc.setup.php)
    获取更多详细信息。
- en: The URL helper is there as we're using the `redirect()` function and the cache
    driver is there to provide support to help us cache out data, in this case it's
    helping us cache data from the RSS feed--however, it really can be anything.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们使用了`redirect()`函数，所以存在URL辅助器；缓存驱动器用于提供支持以帮助我们缓存数据，在这种情况下，它帮助我们缓存来自RSS源的数据--然而，它实际上可以是任何东西。
- en: '`public function index()` first defines the `$rss_feed` variable with the hardcoded
    RSS feed; this is for illustration purposes really. In reality, you will fetch
    the feed using:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '`public function index()`首先使用硬编码的RSS源定义了`$rss_feed`变量；这只是为了说明。实际上，你将使用以下方式获取源：'
- en: '[PRE6]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: However, it is convenient to hardcode it for this recipe, as by hard coding
    you will see the structure of the feed and know what it should "look" like
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在这个菜谱中硬编码它是方便的，因为通过硬编码，你可以看到源的结构，并知道它应该“看起来”是什么样子
- en: The feed has a simple structure containing only three items. The `$raw_feed`
    variable is passed to the PHP `SimpleXMLElement` class, which returns an object
    (`$feed`) for us to work with.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 该源具有简单的结构，只包含三个项目。`$raw_feed`变量被传递给PHP的`SimpleXMLElement`类，它为我们返回一个对象（`$feed`），我们可以用它来工作。
- en: We then use CodeIgniter to check if there exists in cache an item named `rss`;
    if not, we'll loop through the `$feed` object, pulling out the title and description
    for each item in the RSS feed, and concatenate to a string, which is named `$cached_feed`.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们使用CodeIgniter检查缓存中是否存在名为`rss`的项；如果没有，我们将遍历`$feed`对象，从RSS源中的每个项目提取标题和描述，并将它们连接成一个字符串，该字符串命名为`$cached_feed`。
- en: '[PRE7]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The `$cached_feed` string is saved to the cache with the name `rss` for a period
    of 30 seconds (for more on caching durations, refer to the following code):'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '`$cached_feed`字符串被保存到缓存中，名称为`rss`，持续时间为30秒（有关缓存持续时间的更多信息，请参阅以下代码）：'
- en: '[PRE8]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Once all items in the RSS feed have been processed, we''ll echo out the cache
    item `rss`, as shown in the following code snippet:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦RSS源中的所有项目都已被处理，我们将输出缓存项`rss`，如下代码片段所示：
- en: '[PRE9]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'You should get something similar to the following output in your browser:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该在浏览器中看到以下类似的输出：
- en: '[PRE10]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Why 30 seconds? Because it''ll be a good length of time for you to go to your
    browser, run the script, see the preceding output, and quickly dash back to the
    code in your text editor to change something in the feed (such as the title element
    of the third item to `Gigantic Elephants`). Click on **Save**, and go back to
    the browser to refresh, which after 30 seconds (30 seconds since you first ran
    `rss_cache`) should give you the following output:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么是30秒？因为这将是足够的时间让你去浏览器运行脚本，查看前面的输出，然后快速回到你的文本编辑器中的代码，更改源中的某些内容（例如第三项的标题元素改为`Gigantic
    Elephants`）。点击**保存**，然后回到浏览器刷新，这应该在第一次运行`rss_cache`后的30秒（30秒）给你以下输出：
- en: '[PRE11]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Should 30 seconds be too long for you to wait, you can always manually clear
    the cache by running `public function clear_cache()`, which will call the CodeIgniter
    `$this->cache->clean()` function and redirect us back to the `rss_cache` controller
    where the whole process will begin again.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你觉得30秒的等待时间太长，你可以通过运行`public function clear_cache()`手动清除缓存，这将调用CodeIgniter的`$this->cache->clean()`函数，并将我们重定向回`rss_cache`控制器，整个过程将重新开始。
- en: Alternatively, you can decrease the length of time a cache stays valid from
    30 seconds to, say, 10 seconds (but in reality, you'll want it to be a length
    of time that you feel is right for your server or data).
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，你可以将缓存项有效的时间长度从30秒减少到，比如说，10秒（但现实中，你可能希望它是一个适合你服务器或数据的时间长度）。
- en: 'So now, you can see how to store data in the cache, it doesn''t have to be
    XML or an RSS feed, it really could be data from any source: a database query
    (although CodeIgniter has specific database caching methods for that), a feed
    from a social link (such as a Twitter feed, or from Instagram), or even financial
    data such as the value of the FTSE fetched every 5 minutes (or however long you
    set it).'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，现在你可以看到如何在缓存中存储数据，它不一定是XML或RSS源，它实际上可以是来自任何来源的数据：数据库查询（尽管CodeIgniter为此提供了特定的数据库缓存方法），来自社交链接的源（例如Twitter源或Instagram），甚至是每5分钟获取一次的金融数据，如FTSE的价值（或者你设置的任何时长）。
- en: Problems you may encounter
  id: totrans-60
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 你可能遇到的问题
- en: If you're developing on a MAC using MAMP, the chances are the the default caching
    method is XCache. CodeIgniter doesn't have a driver to work with XCache and you'll
    either need to write your own driver (go on be brave), or (as I did) change your
    caching engine to APC.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您在MAC上使用MAMP进行开发，那么默认的缓存方法很可能是XCache。CodeIgniter没有与XCache一起工作的驱动程序，您可能需要编写自己的驱动程序（勇敢地去做），或者（像我一样）将缓存引擎更改为APC。
- en: Tip
  id: totrans-62
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: '**APC** (**Alternative PHP Caching**) is a caching service, which in this case
    is provided by MAMP.'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '**APC**（**替代PHP缓存**）是一种缓存服务，在这种情况下由MAMP提供。'
- en: You'll need to tell MAMP to use APC rather than XCache. To do this, open your
    MAMP control panel and click on **Preferences**, then click on the **PHP** tab.
    You should now see a section named **PHP extensions**. In that section should
    be a drop-down list (this is probably set to XCache); choose APC from this list,
    and click on the **OK** button. MAMP will restart, and after this you should be
    good to go.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要告诉MAMP使用APC而不是XCache。为此，打开您的MAMP控制面板，点击**偏好设置**，然后点击**PHP**选项卡。现在您应该看到一个名为**PHP扩展**的部分。在该部分中应该有一个下拉列表（这可能是设置为XCache）；从该列表中选择APC，然后点击**确定**按钮。MAMP将重新启动，在此之后，您应该可以正常使用。
- en: Logging errors with CodeIgniter
  id: totrans-65
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用CodeIgniter记录错误
- en: Logging errors which occur within your CodeIgniter application doesn't have
    to be limited to looking at the PHP or Apache logs; you can enable CodeIgniter
    to handle and log errors and other behaviors and events at certain points in your
    code using CodeIgniter's logging functionality. This facility can be particularly
    useful (if you set it up correctly) to track a user's journey and progress through
    the system and should something go wrong with whatever they're doing, you can
    look in the logs and trace what they did and when, and get a better idea of what
    (if at all) went wrong and hopefully think about how to prevent it from occurring
    again.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 在您的CodeIgniter应用程序中记录发生的错误不必仅限于查看PHP或Apache日志；您可以通过CodeIgniter的日志功能启用CodeIgniter在代码的某些点处理和记录错误以及其他行为和事件。这个功能（如果设置正确）可以特别有用，用于跟踪用户的系统旅程和进度，如果他们正在执行的操作出现任何问题，您可以在日志中查找并追踪他们所做的一切以及何时发生，从而更好地了解（如果有的话）发生了什么，并希望考虑如何防止其再次发生。
- en: In this recipe, we're going to look at using the logging functionality within
    CodeIgniter and to track if something goes wrong with an operation.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 在本配方中，我们将探讨在CodeIgniter中使用日志功能以及跟踪操作中是否出现错误。
- en: Getting ready
  id: totrans-68
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'We''ll need to set the log reporting level in the config file so that CodeIgniter
    knows which level of logging messages to report on. The log''s folder should also
    have write access, so perform the following steps:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要在配置文件中设置日志报告级别，以便CodeIgniter知道要报告哪种级别的日志消息。日志文件夹也应具有写权限，因此请执行以下步骤：
- en: 'Open the `/path/to/codeigniter/application/config/config.php` file and find
    the following line:'
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`/path/to/codeigniter/application/config/config.php`文件，找到以下行：
- en: '[PRE12]'
  id: totrans-71
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'You can change the value of the `log_threshold` config array element to one
    of the five states, as shown in the following table:'
  id: totrans-72
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 您可以将`log_threshold`配置数组元素的值更改为以下五种状态之一，具体如下表所示：
- en: '| State | Usage | Description |'
  id: totrans-73
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '| 状态 | 用途 | 描述 |'
- en: '| --- | --- | --- |'
  id: totrans-74
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| `0` | - | CodeIgniter will not log anything. |'
  id: totrans-75
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '| `0` | - | CodeIgniter将不记录任何内容。 |'
- en: '| `1` |'
  id: totrans-76
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '| `1` |'
- en: '[PRE13]'
  id: totrans-77
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '| CodeIgniter will log error messages. |'
  id: totrans-78
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '| CodeIgniter将记录错误信息。 |'
- en: '| `2` |'
  id: totrans-79
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '| `2` |'
- en: '[PRE14]'
  id: totrans-80
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '| CodeIgniter will log debugging messages. |'
  id: totrans-81
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '| CodeIgniter将记录调试信息。 |'
- en: '| `3` |'
  id: totrans-82
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '| `3` |'
- en: '[PRE15]'
  id: totrans-83
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '| CodeIgniter will log information messages. |'
  id: totrans-84
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '| CodeIgniter将记录信息消息。 |'
- en: '| `4` | All of the above | CodeIgniter will log everything. |'
  id: totrans-85
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '| `4` | 所有以上 | CodeIgniter将记录所有内容。 |'
- en: For our recipe, I have set the value to `4` as I want to log any error messages
    or information messages that CodeIgniter might generate for me.
  id: totrans-86
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 对于我们的配方，我已将值设置为`4`，因为我希望记录CodeIgniter可能为我生成的任何错误消息或信息消息。
- en: 'Look for the line:'
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 查找以下行：
- en: '[PRE16]'
  id: totrans-88
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Ensure that `/path/to/log/folder/` is set correctly in `$config[' log_path']`
    and that the folder specified has write permissions (otherwise, CodeIgniter cannot
    write a log file to that folder).
  id: totrans-89
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 确保在`$config['log_path']`中正确设置了`/path/to/log/folder/`，并且指定的文件夹具有写权限（否则，CodeIgniter无法将该文件夹中的日志文件写入）。
- en: How to do it...
  id: totrans-90
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'We''re going to use (as it was convenient) the *Using CodeIgniter caching*
    recipe, mentioned earlier in this chapter, and alter it in such a way as to apply
    CodeIgniter logging. In this recipe, we''ve changed its name to `cache_log.php`
    (to keep it separate from `rss_cache.php`). So, if you haven''t already done so
    (don''t forget to change the name, highlighted in the following code):'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用（因为它很方便）本章前面提到的 *使用 CodeIgniter 缓存* 菜谱，并对其进行修改以应用 CodeIgniter 日志。在这个菜谱中，我们将它的名称更改为
    `cache_log.php`（以保持与 `rss_cache.php` 分离）。所以，如果您还没有这样做（不要忘记更改名称，以下代码中突出显示）：
- en: 'Create the `/path/to/codeigniter/application/controllers/cache_log.php` file
    and add the following code to it (the changes are highlighted):'
  id: totrans-92
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建 `/path/to/codeigniter/application/controllers/cache_log.php` 文件，并将以下代码添加到其中（更改已在代码中突出显示）：
- en: '[PRE17]'
  id: totrans-93
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'If all goes well you shouldn''t have any errors, but you should have some `DEBUG`
    data in the config file. When you open that file you should see something similar
    to:'
  id: totrans-94
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果一切顺利，您不应该有任何错误，但在配置文件中应该有一些 `DEBUG` 数据。当您打开该文件时，您应该看到类似以下内容：
- en: '[PRE18]'
  id: totrans-95
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: You can see the info items we set in the code written in the log; I've highlighted
    them so that they stand out.
  id: totrans-96
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 您可以在日志中看到我们在代码中设置的 info 项；我已经突出显示它们以便它们突出显示。
- en: How it works...
  id: totrans-97
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: You can see that we have added some conditional statements on various stages
    of the controller's execution, checking for the return value of certain CodeIgniter
    functions (the changes are highlighted in the previous code). Depending on that
    returned value (either `TRUE` or `FALSE`), we will write to the logs using the
    CodeIgniter `log_message()` function, but let's take a closer look at those messages
    and when each of them is triggered.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以看到我们在控制器执行的各个阶段添加了一些条件语句，检查某些 CodeIgniter 函数的返回值（更改已在之前的代码中突出显示）。根据返回值（`TRUE`
    或 `FALSE`），我们将使用 CodeIgniter 的 `log_message()` 函数将信息写入日志，但让我们更仔细地看看这些消息以及它们何时被触发。
- en: 'First off, we''ll try to instantiate a new `SimpleXmlElement()` object. If
    we get a returned object, an info message is written to the log (`SimpleXmlElement()`
    was instantiated correctly). If there was an error, we write an error message
    to the log (unable to instantiate `SimpleXmlElement()`); take a look at the following
    code snippet:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将尝试实例化一个新的 `SimpleXmlElement()` 对象。如果我们得到返回的对象，日志中会写入一条信息消息（`SimpleXmlElement()`
    实例化正确）。如果有错误，我们将错误消息写入日志（无法实例化 `SimpleXmlElement()`）；请看以下代码片段：
- en: '[PRE19]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: You can see that we're using CodeIgniter's logging functionality to write messages
    to the log file, and define those messages as either errors or info; this can
    be helpful in debugging the user's journey as you'll know what is a genuine error,
    and what is information entered by you to help you in the logs.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以看到我们正在使用 CodeIgniter 的日志功能将消息写入日志文件，并将这些消息定义为错误或信息；这有助于调试用户的旅程，因为您将知道什么是真正的错误，以及您输入到日志中的信息。
- en: Logging style
  id: totrans-102
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 日志风格
- en: 'I find it useful to write my log messages like the following code snippet:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 我发现将日志消息写成以下代码片段很有用：
- en: '[PRE20]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: In the preceding code snippet, we're defining the message as info, but we begin
    the message with four asterisks (`****`). This'll make the message stand out in
    the logs as we're viewing them, next comes the `__LINE__` argument (to let you
    know where in the script it was triggered), followed by the actual message--here
    it is the unimaginative--`' - This is a message`.'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码片段中，我们将消息定义为信息，但消息以四个星号（`****`）开始。这将使消息在查看日志时突出显示，接下来是 `__LINE__` 参数（让您知道在脚本中的触发位置），然后是实际的消息--这里是非常无趣的--`'
    - This is a message'`。
- en: You may wish to add `__FILE__`, `__CLASS__`, or `__FUNCTION__` for greater accuracy,
    depending on your needs.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能希望根据需要添加 `__FILE__`、`__CLASS__` 或 `__FUNCTION__` 以提高准确性。
- en: Benchmarking your application
  id: totrans-107
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 应用程序的基准测试
- en: Benchmarking can be useful for you as it can let you know how your application
    is coping with the task of computing all your code. It can let you know where
    in your application something is slow, either because of memory constraints or
    perhaps because of a particularly computational intensive block of code. Using
    this information, you can identify whether there are any bottlenecks and if you
    are able to clear them, perhaps by reprogramming or allocating extra resources.
    Here's how it's done.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 基准测试对你来说可能很有用，因为它可以让你了解你的应用程序如何处理计算所有代码的任务。它可以让你知道在你的应用程序中哪里可能存在速度慢的问题，无论是由于内存限制，还是可能是因为一段特别计算密集的代码块。利用这些信息，你可以确定是否存在任何瓶颈，并且如果你能够清除它们，可能通过重新编程或分配额外资源。下面是如何进行的。
- en: Getting ready
  id: totrans-109
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'Many web applications will be linked to some sort of database and as an example
    of benchmarking database connectivity, we''re going to query a database. To do
    that, we will obviously need a database to connect to. Copy the following MySQL
    code into your database:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 许多网络应用程序都会链接到某种数据库，作为基准测试数据库连接性的一个例子，我们将查询一个数据库。为了做到这一点，我们显然需要一个数据库来连接。将以下MySQL代码复制到你的数据库中：
- en: '[PRE21]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: How to do it...
  id: totrans-112
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'We''re going to create the following two files:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将创建以下两个文件：
- en: '`/path/to/codeigniter/application/controllers/bench.php`'
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/path/to/codeigniter/application/controllers/bench.php`'
- en: '`/path/to/codeigniter/application/models/bench_model.php`'
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/path/to/codeigniter/application/models/bench_model.php`'
- en: 'Create the `bench.php` controller file and add the following code to it:'
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建 `bench.php` 控制器文件，并将以下代码添加到其中：
- en: '[PRE22]'
  id: totrans-117
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Create the `bench_model.php` model file and add the following code to it:'
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建 `bench_model.php` 模型文件，并将以下代码添加到其中：
- en: '[PRE23]'
  id: totrans-119
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: How it works...
  id: totrans-120
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'If you run the controller bench in your browser, you should see the following
    output on the screen:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你通过浏览器运行控制器 bench，你应该在屏幕上看到以下输出：
- en: '[PRE24]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: The output is a loop of the contents of the `bench_table` database table followed
    by the benchmark statistics. I've highlighted the stats for the `batch_insert()`
    operation.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 输出是 `bench_table` 数据库表的表内容循环，随后是基准测试统计信息。我已经突出了 `batch_insert()` 操作的统计数据。
- en: '`BM1 (S)` is the start of the BM1 benchmark, and `BM1 (E)` is the end of the
    BM1 benchmark.'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: '`BM1 (S)` 是BM1基准测试的开始，而 `BM1 (E)` 是BM1基准测试的结束。'
- en: You can see that it took significantly longer to perform the `batch_insert()`
    operation than the two read operations (the actual processing times will be different
    in your application and probably each time you run the controller; however, the
    BM2 item will almost always be longer, but the times will differ depending on
    the system you're using).
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到，执行 `batch_insert()` 操作比两个读取操作（在你的应用程序中实际的处理时间可能会有所不同，而且每次运行控制器时也可能会有所不同；然而，BM2项几乎总是更长时间，但时间会根据你使用的系统而有所不同）花费的时间要长得多。
- en: If this were a more complex situation, we could use this information to locate
    bottlenecks in the code and hope to fix them to ensure a more streamlined application.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 如果这是一个更复杂的情况，我们可以使用这些信息来定位代码中的瓶颈，并希望修复它们以确保应用程序更加流畅。
- en: So, what's happening in the code? There's no library or other resource to load
    as the benchmark system is always loaded by CodeIgniter and is always available
    for use.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，代码中发生了什么？由于基准系统总是由CodeIgniter加载并且总是可用，因此没有库或其他资源需要加载。
- en: 'When we run the bench controller, `public function index()` is called and immediately
    runs the `get_people()` function of `bench_model`. This performs an Active Record
    `SELECT` operation on the `bench_table` database table, returning the result object
    to the controller. This is looped over and we echo out each row to display a list
    of rows in the database before the `batch_insert()` operation:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们运行基准控制器时，会调用 `public function index()` 并立即运行 `bench_model` 的 `get_people()`
    函数。这在对 `bench_table` 数据库表的Active Record `SELECT` 操作，将结果对象返回给控制器。然后我们遍历这个循环，并输出每一行以显示在
    `batch_insert()` 操作之前数据库中的行列表：
- en: '[PRE25]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: The keen-eyed amongst you will also notice the highlighted lines, we've defined
    the start and end points for CodeIgniter to pay attention to. The first we've
    named `bm1_start` and the second we've named `bm1_stop`. We can call them anything
    we like, but that's what I've decided to call them.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 眼尖的你们中的一些人也会注意到突出显示的行，我们为CodeIgniter定义了关注的开头和结尾点。第一个我们命名为 `bm1_start`，第二个我们命名为
    `bm1_stop`。我们可以称它们为任何我们喜欢的名字，但这是我决定要叫的名字。
- en: 'We then perform the `batch_ insert` operation, as shown in the following code
    snippet:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 我们随后执行 `batch_insert` 操作，如下代码片段所示：
- en: '[PRE26]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'We''re defining a multidimensional array with the details of people we want
    to add to the database and sending it to the `insert_batch()` function of `bench_model`;
    now the keen eyed among you will again notice the highlighted lines. These are
    the bm2 start and end points. If the `batch_insert()` operation returns `TRUE`
    (it is inserted into the database correctly), we then call the `get_people()`
    model function again, which will return all the records from the database:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 我们正在定义一个包含我们想要添加到数据库中的人的详细信息的多维数组，并将其发送到 `bench_model` 的 `insert_batch()` 函数；现在，那些敏锐的眼睛中的人会再次注意到高亮行。这些是
    bm2 的开始和结束点。如果 `batch_insert()` 操作返回 `TRUE`（正确插入到数据库中），我们随后再次调用 `get_people()`
    模型函数，这将返回数据库中的所有记录：
- en: '[PRE27]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Again, here we define (as highlighted in the previous code) the bm3 start and
    end points. That completes our database operations and we move over to reporting
    of the benchmarks.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，这里我们定义（如前一段代码中高亮显示的）bm3 的开始和结束点。这完成了我们的数据库操作，然后我们转向基准测试的汇报。
- en: 'We ask CodeIgniter to tell us the execution time between points:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 我们要求 CodeIgniter 告诉我们两个点之间的执行时间：
- en: '[PRE28]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'For each bm1, bm2, and bm3, we want to know the time between the points specified
    using the `$this->benchmark->elapsed_time()` function. This function takes two
    arguments: a start point and an end point. For this recipe, we have asked CodeIgniter
    to report the time elapsed between each bm# point (where # is the number 1, 2,
    or 3), but if we wish to we can write this:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: '对于每个 bm1、bm2 和 bm3，我们想要知道使用 `$this->benchmark->elapsed_time()` 函数指定的点之间的时间。这个函数接受两个参数：一个起始点和结束点。对于这个菜谱，我们已经要求
    CodeIgniter 报告每个 bm# 点（其中 # 是数字 1、2 或 3）之间经过的时间，但如果我们愿意，我们可以这样写：'
- en: '[PRE29]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: The previous code will report the elapsed time between `bm1_start` and `bm2_end`
    (or from the beginning of the first `get_people()` query to the end of the `batch_insert()`
    query).
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的代码将报告 `bm1_start` 和 `bm2_end` 之间的时间差（或者从第一个 `get_people()` 查询的开始到 `batch_insert()`
    查询的结束）。
- en: Think of each `$this->benchmark->mark('bm2_end');` as a checkpoint, and you
    can use `$this->benchmark->elapsed_time('checkpoint_1','checkpoint_2')` to return
    the time elapsed between them.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 将每个 `$this->benchmark->mark('bm2_end');` 视为一个检查点，并且你可以使用 `$this->benchmark->elapsed_time('checkpoint_1','checkpoint_2')`
    来返回它们之间的时间差。
