- en: Domain-Events
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 领域事件
- en: Software Events are things that happened in the system that other components
    might be interested in knowing about. PHP developers are generally not used to
    working with Events, which are not a feature in the language. However, it's more
    common to see how new frameworks and libraries embrace them to provide new ways
    of decoupling, reusing, and speeding up code.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 软件事件是系统中发生的事情，其他组件可能想知道。PHP 开发者通常不习惯于使用事件，因为事件不是语言中的特性。然而，更常见的是看到新的框架和库如何接受它们，以提供新的解耦、重用和加速代码的方法。
- en: Domain Events are Events related to Domain changes. Domain Events are things
    that happen in our Domain that Domain Experts care about.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 领域事件是与领域变化相关的事件。领域事件是我们领域中发生的事情，领域专家关心的事情。
- en: 'In Domain-Driven Design, Domain Events are fundamental building blocks that
    help:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在领域驱动设计中，领域事件是基本构建块，有助于：
- en: Communicate with other Bounded Contexts.
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与其他边界上下文进行通信。
- en: Improve performance and scalability, pushing for eventual consistency.
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提高性能和可伸缩性，推动最终一致性。
- en: Serve as historical checkpoints.
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 作为历史检查点。
- en: 'Domain Events represent the essence of asynchronous communication. For more
    on this topic, we recommend the book *Enterprise Integration Patterns:  *[Designing,
    Building, and Deploying Messaging Solutions](http://www.amazon.com/Enterprise-Integration-Patterns-Designing-Deploying/dp/0321200683) by
    Gregor Hohpe and Bobby Woolf.'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 领域事件代表了异步通信的精髓。关于这个话题的更多信息，我们推荐阅读 Gregor Hohpe 和 Bobby Woolf 所著的书籍 *企业集成模式：设计、构建和部署消息解决方案*（[Designing,
    Building, and Deploying Messaging Solutions](http://www.amazon.com/Enterprise-Integration-Patterns-Designing-Deploying/dp/0321200683)）。
- en: Introduction
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简介
- en: Think about a JavaScript 2D platform game. There are tons of different components
    interacting with each other on the screen, all at the same time. There's a component
    that indicates the number of lives remaining, another one that shows all the points
    scored, and another one counting down the time remaining to finish the current
    level. Each time your character jumps on an enemy, the points increase. When your
    scoring goes higher than a certain number of points, you get an extra life. When
    your character picks up a key, a door usually opens. But how do all these components
    interact with one another? What's the optimal architecture for this scenario?
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下一款 JavaScript 2D 平台游戏。屏幕上有成百上千个不同的组件在相互交互，所有这些都在同一时间进行。有一个组件显示剩余生命值，另一个显示所有得分，还有一个倒计时当前关卡剩余时间。每次你的角色跳到敌人身上，得分就会增加。当你的得分超过一定数量时，你会获得额外生命。当角色捡起钥匙时，通常门就会打开。但是，所有这些组件是如何相互交互的呢？这种场景的最佳架构是什么？
- en: 'There are probably two main options: the first one is to couple each component
    with the ones it''s connected to. However, in the above example, that means a
    lot of components are coupled together, with each new addition requiring the developer
    to modify the code. But do you remember the **Open Closed Principle **(**OCP**)?
    Adding a new component shouldn''t make it so the first component has to be updated;
    this would be too much work to maintain.'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 可能有两个主要选项：第一个是将每个组件与其连接的组件耦合在一起。然而，在上面的例子中，这意味着许多组件被耦合在一起，每次添加新组件都需要开发者修改代码。但你还记得**开闭原则**（**OCP**）吗？添加新组件不应该让第一个组件需要更新；这将使维护工作变得过于繁重。
- en: The second — and better — approach is to connect all the components to a single
    object that handles all the important Events in the game. It receives Events from
    each component and forwards them to specific components. For example, the scoring
    component would be interested in an `EnemyKilled` Event, while the `LifeCaptured`
    Event is quite useful for the player Entity and the remaining lives component.
    In this way, all components are coupled to a single component that manages all
    the notifications. With this approach, adding or removing components doesn't affect
    the existing ones.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个——也是更好的——方法是连接所有组件到一个单一的对象，该对象处理游戏中所有重要的事件。它从每个组件接收事件并将它们转发到特定的组件。例如，得分组件会对`EnemyKilled`事件感兴趣，而`LifeCaptured`事件对玩家实体和剩余生命值组件非常有用。这样，所有组件都耦合到一个管理所有通知的单个组件上。使用这种方法，添加或删除组件不会影响现有的组件。
- en: When developing a single application, Events come in handy for decoupling components.
    When developing a whole Domain in a distributed way, Events are very useful for
    decoupling each service or application that plays a role in the Domain. The key
    points are the same, but on a different scale.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 当开发单个应用程序时，事件对于解耦组件很有帮助。当以分布式方式开发整个领域时，事件对于解耦在领域中扮演角色的每个服务或应用程序非常有用。关键点是相同的，但规模不同。
- en: Definition
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 定义
- en: Domain Events are one specific type of Event used for notifying local or remote
    Bounded Contexts of Domain changes.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 领域事件是用于通知本地或远程边界上下文领域变化的一种特定类型的事件。
- en: 'Vaughn Vernon [defines](http://www.amazon.com/Implementing-Domain-Driven-Design-Vaughn-Vernon-ebook/dp/B00BCLEBN8) a
    Domain Event as:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: Vaughn Vernon [定义](http://www.amazon.com/Implementing-Domain-Driven-Design-Vaughn-Vernon-ebook/dp/B00BCLEBN8)领域事件为：
- en: An occurrence of something that happened in the domain.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 领域内发生的事情的一个发生实例。
- en: 'Eric Evans [defines](https://domainlanguage.com/ddd/patterns/DDD_Reference_2011-01-31.pdf) a
    Domain Event as:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: Eric Evans [定义](https://domainlanguage.com/ddd/patterns/DDD_Reference_2011-01-31.pdf)领域事件为：
- en: A full-fledged part of the Domain Model, a representation of something that
    happened in the Domain. Ignore irrelevant Domain activity while making explicit
    the events that the Domain Experts want to track or be notified of, or which are
    associated with state change in the other Model objects.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 领域模型的一个完整部分，表示领域内发生的事情。在制作显式领域专家希望跟踪或通知的事件，或与其它模型对象状态变化相关联的事件时，忽略无关的领域活动。
- en: 'Martin Fowler [defines](http://martinfowler.com/eaaDev/DomainEvent.html) a
    Domain Event as something that:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: Martin Fowler [定义](http://martinfowler.com/eaaDev/DomainEvent.html)领域事件为某种东西：
- en: Captures the memory of something interesting which affects the Domain.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 记录了影响领域内有趣事情的记忆。
- en: Examples of Domain Events in a web application are `UserRegistered`, `OrderPlaced`,
    `UserRelocated`, and `ProductAdded`.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 在Web应用程序中，领域事件的例子有`UserRegistered`（用户注册）、`OrderPlaced`（订单已放置）、`UserRelocated`（用户迁移）和`ProductAdded`（产品添加）。
- en: Short Story
  id: totrans-22
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 短篇小说
- en: In a ticket sales agency, a content manager decides to increase the price of
    a U2 show. Using her back office, she edits the show. A `ShowPriceChanged` Domain
    Event is published and persisted into the database with the new show price in
    the same transaction.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在票务销售代理机构中，内容经理决定提高U2演出的票价。她使用后台编辑演出。一个`ShowPriceChanged`（演出价格已更改）领域事件被发布并持久化到数据库中，与新的演出价格在同一笔交易中。
- en: 'A batch process takes the Domain Event and queues it into RabbitMQ. The Domain
    Event gets distributed in two queues: one for the same local Bounded Context,
    and another remote one for Business Intelligence purposes.'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 批处理过程将领域事件排队到RabbitMQ中。领域事件在两个队列中分发：一个用于相同的本地边界上下文，另一个用于远程的商务智能目的。
- en: In the first queue, a worker fetches the corresponding Show using the ID in
    the Event and pushes it into an Elasticsearch server so that the user can see
    the new price when searching. It could also update the new price in a different
    database table.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一个队列中，一个工作者使用事件中的ID检索相应的演出，并将其推送到Elasticsearch服务器，以便用户在搜索时可以看到新的价格。它也可以在另一个数据库表中更新新的价格。
- en: In the second queue, a worker inserts the information into a Logs Server or
    a Data Lake, where reporting or Data Mining processes can be run.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 在第二个队列中，一个工作者将信息插入到日志服务器或数据湖中，在那里可以运行报告或数据挖掘过程。
- en: An external application that can't be integrated using Domain Events could access
    all the `ShowPriceChanged` Events using a REST API that the local Bounded Context
    provides.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 一个无法使用领域事件集成的外部应用程序可以使用本地边界上下文提供的REST API访问所有`ShowPriceChanged`（演出价格已更改）事件。
- en: As you can see, Domain Events are useful for dealing with eventual consistency
    and integrating different Bounded Contexts. Aggregates create Events and publish
    them. Subscribers may store Events and then forward them to remote subscribers.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，领域事件对于处理最终一致性和集成不同的边界上下文非常有用。聚合创建事件并发布它们。订阅者可以存储事件，然后将它们转发给远程订阅者。
- en: Metaphor
  id: totrans-29
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 隐喻
- en: We go to Babur's for a meal on Tuesday and pay by credit card. This might be
    modeled as an Event with an Event type of `PurchasePlaced`, a subject of my credit
    card, and a date of occurrence of Tuesday. If Babur's uses an old manual system
    and doesn't transmit the transaction until Friday, the transaction would be effective
    on Friday.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在周二去巴布尔餐厅用餐，并使用信用卡支付。这可以建模为一个事件，事件类型为`PurchasePlaced`（购买已放置），主题是我的信用卡，发生日期为周二。如果巴布尔的系统过时且直到周五才传输交易，那么交易将在周五生效。
- en: Things happen. Not all of them are interesting, and some may be worth recording
    but don't provoke a reaction. However, the most interesting things cause a reaction.
    Many systems need to react to interesting Events. Often you need to know why a
    system reacts in the way it did.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 事情发生了。并非所有事情都很有趣，有些可能值得记录但不会引起反应。然而，最有趣的事情会引起反应。许多系统需要对有趣的事件做出反应。通常你需要知道为什么系统以这种方式做出反应。
- en: By funneling inputs to a system into streams of Domain Events, you can keep
    a record of all the inputs to a system. This helps you organize your processing
    logic, and it also allows you to keep an audit log of the inputs to the system.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 通过将系统输入引导到领域事件流中，您可以记录系统所有输入。这有助于您组织您的处理逻辑，同时也允许您保留系统输入的审计日志。
- en: Exercise
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 练习
- en: Try to locate examples of potential Domain Events in your current Domain.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试在你的当前领域定位潜在的领域事件示例。
- en: Real-World Example
  id: totrans-35
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 真实世界示例
- en: Before going into detail about Domain Events, let's see a real example of Domain
    Events and how they can help us in our application and our whole Domain.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 在详细讨论领域事件之前，让我们看看一个领域事件的实际例子以及它们如何帮助我们在我们的应用程序和整个领域中。
- en: 'Let''s consider a simple Application Service that will register a new user
    — for example, in an e-commerce context. Application Services will be explained
    in another chapter, so don''t worry too much about the interface. Instead, just
    focus on the execute method:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们考虑一个简单的应用程序服务，它将注册新用户——例如，在电子商务环境中。应用程序服务将在另一章中解释，所以不必过于担心接口。相反，只需关注执行方法：
- en: '[PRE0]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: As shown, the *Application Service* section checks if the user already exists.
    If not, it creates a new User and adds it to the `UserRepository`.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 如所示，*应用程序服务*部分检查用户是否已存在。如果没有，它将创建一个新的用户并将其添加到`UserRepository`。
- en: 'Now consider an additional requirement: a new user must be notified by email
    when registered. Without thinking about it too much, the first approach that comes
    to mind is to update our Application Service to include a piece of code that would
    do the job — probably some sort of `EmailSender` that would be run after the add
    method. However, let''s consider another approach.'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 现在考虑一个额外的要求：当新用户注册时，必须通过电子邮件通知他们。没有过多思考，首先想到的方法是更新我们的应用程序服务，包括一段执行这项工作的代码——可能是一种`EmailSender`，它会在添加方法之后运行。然而，让我们考虑另一种方法。
- en: What about firing a `UserRegistered` Event so that another component listening
    can react and send that email? There are some cool benefits to this new approach.
    First of all, we don't need to update the code of our Application Service every
    time a new action must be performed when a new user is registered.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 关于触发一个`UserRegistered`事件，以便另一个监听组件可以做出反应并发送电子邮件，有什么好处？这种新方法有一些酷炫的好处。首先，当新用户注册时，我们不需要每次都更新应用程序服务的代码来执行新操作。
- en: Second, it's easier to test. The Application Service remains simpler, and each
    time a new action is developed, we just write the tests for the action.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 其次，它更容易测试。应用程序服务保持简单，每次开发新操作时，我们只需为该操作编写测试。
- en: Later in the same e-commerce project, we're told to integrate an open source
    gamification platform not written in PHP. Each time users place purchases or review
    products in our e-commerce Bounded Context, they can get badges that can be shown
    on their e-commerce user profile pages or be notified by email. How could we model
    the problem?
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 在同一个电子商务项目中稍后，我们被告知要集成一个非PHP编写的开源游戏化平台。每次用户在我们的电子商务边界上下文中进行购买或评论产品时，他们都可以获得可以在他们的电子商务用户个人资料页面上显示的徽章，或者通过电子邮件通知。我们该如何建模这个问题？
- en: Following the first approach, we would update the Application Service to integrate
    with the new platform in a fashion similar to the previous email confirmation
    approach. With the Domain Event approach, we could create another listener for
    the `UserRegistered` Event, which will connect directly, by REST or SOA, to the
    gamification platform. Even better, it could communicate the Event to a messaging
    system like RabbitMQ so that the gamification Bounded Context can subscribe and
    get notified automatically. Our e-commerce Bounded Context doesn't need to know
    about the gamification Bounded Context at all.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 按照第一种方法，我们会更新应用程序服务以类似于之前电子邮件确认方法的方式与新的平台集成。使用领域事件方法，我们可以为`UserRegistered`事件创建另一个监听器，该监听器将通过REST或SOA直接连接到游戏化平台。甚至更好，它可以将事件传递给像RabbitMQ这样的消息系统，以便游戏化边界上下文可以订阅并自动接收通知。我们的电子商务边界上下文根本不需要了解游戏化边界上下文。
- en: Characteristics
  id: totrans-45
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 特征
- en: Domain Events are ordinarily **immutable**, as they're a record of something
    in the past. In addition to a description of the Event, a Domain Event typically
    contains a timestamp for the time the Event occurred and the identity of Entities
    involved in the Event. Additionally, a Domain Event often has a separate timestamp
    indicating when the Event was entered into the system, along with the identity
    of the person who entered it. When useful, an identity for the Domain Event can
    be based on some set of these properties. So, for example, if two instances of
    the same Event arrive at a node, they can be recognized as the same.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 领域事件通常是**不可变的**，因为它们是过去某事的记录。除了事件的描述外，领域事件通常还包含事件发生的时间戳以及参与事件的实体标识。此外，领域事件通常还有一个单独的时间戳，表示事件被输入系统的时间，以及输入该事件的人的身份。当有用时，领域事件的标识可以基于这些属性中的一组。例如，如果同一事件的两个实例到达一个节点，它们可以被识别为相同的。
- en: The essence of a Domain Event is that you use it to capture things that can
    trigger a change to the state of the application you're developing or to another
    application in your Domain that's interested in those changes. These Event objects
    are then processed to cause changes to the system and stored to provide an audit
    log.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 领域事件的本质是，你用它来捕获可以触发你正在开发的应用程序或领域内其他感兴趣的应用程序状态变化的事物。然后处理这些事件对象以引起系统变化，并存储起来以提供审计日志。
- en: Naming Conventions
  id: totrans-48
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 命名规范
- en: All Events should be represented as verbs in the past tense, as they're things
    that have been completed in the past — for example, `CustomerRelocated`, `CargoShipped`,
    or `InventoryLossageRecorde`d. There are interesting examples in the English language
    where one may be tempted to use nouns as opposed to verbs in the past tense; an
    example of this would be *Earthquake* or *Capsize* as relevant Events for a congressperson
    interested in natural disasters. We suggest avoiding the temptation of using names
    like those for Domain Events and sticking with verbs in the past tense.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 所有事件都应该用过去时态的动词来表示，因为它们是过去已经完成的事情——例如，`CustomerRelocated`、`CargoShipped`或`InventoryLossageRecorde`d。在英语中，有一些有趣的例子，人们可能会倾向于使用名词而不是过去时态的动词；例如，对于对自然灾害感兴趣的国会议员来说，*Earthquake*或*Capsize*可以作为相关事件；我们建议避免使用这样的名称作为领域事件，并坚持使用过去时态的动词。
- en: Domain Events and Ubiquitous Language
  id: totrans-50
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 领域事件和通用语言
- en: Consider the differences in the Ubiquitous Language when we discuss the side
    effects of relocating a customer. The Event makes the concept explicit, whereas
    previously, the changes that occurred within an Aggregate or between multiple
    Aggregates were left as an implicit concept that needed to be explored and defined.
    As an example, in most systems, when a side effect occurs on a library like Hibernate
    or the Entity Framework, it doesn't affect the Domain. These Events are implicit
    and transparent from the client point of view. The introduction of the Event makes
    the concept explicit and part of the Ubiquitous Language. Relocating a customer
    doesn't just change some stuff; rather it produces a `CustomerRelocatedEvent`
    that is explicitly defined within the language.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们讨论客户搬迁的副作用时，要考虑通用语言的差异。事件使概念明确，而之前，在聚合内部或多个聚合之间发生的变更被留作一个需要探索和定义的隐含概念。例如，在大多数系统中，当一个库如Hibernate或Entity
    Framework发生副作用时，它不会影响领域。这些事件对客户端来说是隐含且透明的。引入事件使概念明确，并成为通用语言的一部分。搬迁客户不仅仅是改变一些东西；相反，它产生了一个在语言中明确定义的`CustomerRelocatedEvent`。
- en: Immutability
  id: totrans-52
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 不可变性
- en: As we mentioned already, Domain Events talk about the past and describe changes
    in your Domain that have already occurred. By definition, it's impossible to change
    the past, unless you're Marty McFly and have a DeLorean, which is probably not
    the case. So just remember that Domain Events are immutable.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们之前提到的，领域事件谈论的是过去，描述了已经发生的领域变化。根据定义，除非你是Marty McFly并且有一个德洛瑞安，否则不可能改变过去，这可能是不可能的。所以，请记住，领域事件是不可变的。
- en: Symfony Event Dispatcher
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: Symfony事件分发器
- en: Some PHP frameworks support Events. However, don't confuse those Events with
    Domain Events; they're different in characteristics and goals. For example, Symfony
    has the Event Dispatcher component, and if you need to implement an Event system
    for a state machine, you can rely on it. In Symfony, the transformation from requests
    to responses is handled by Events too. However, Symfony Events are mutable, and
    each of the listeners is capable of modifying, adding to, or updating the information
    in the Event.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 一些PHP框架支持事件。然而，不要将这些事件与领域事件混淆；它们在特性和目标上不同。例如，Symfony有事件分发器组件，如果你需要为状态机实现事件系统，你可以依赖它。在Symfony中，请求到响应的转换也由事件处理。然而，Symfony事件是可变的，每个监听器都有能力修改、添加或更新事件中的信息。
- en: Modeling Events
  id: totrans-56
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 建模事件
- en: In order to describe your business Domain accurately, you'll have to work closely
    with Domain Experts and define the Ubiquitous Language. This requires crafting
    Domain concepts using Domain Events, Entities, Value Objects, and so on. When
    modeling Events, name them and their properties according to the Ubiquitous Language,
    in the Bounded Context where they originated. If an Event is the result of executing
    a command operation on an Aggregate, the name is usually derived from the command
    that was executed. It's important that the Event name reflects the past nature
    of the occurrence.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 为了准确描述你的业务领域，你必须与领域专家紧密合作，并定义通用的语言。这需要使用领域事件、实体、值对象等来构建领域概念。在建模事件时，根据它们起源的边界上下文中的通用语言来命名它们及其属性。如果一个事件是执行聚合体上的命令操作的结果，那么其名称通常是从所执行的命令中派生出来的。事件名称反映事件发生的过去性质是很重要的。
- en: 'Let''s consider our user registration feature; the Domain Event needs to represent
    it. The following code shows a minimal interface for a base Domain Event:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们考虑我们的用户注册功能；领域事件需要表示它。以下代码显示了一个基础领域事件的简化接口：
- en: '[PRE1]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: As you can see, the minimum information required is a `DateTimeImmutable`, which
    is necessary in order to know when the Event happened.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，所需的最小信息是一个`DateTimeImmutable`，这是为了知道事件发生的时间。
- en: 'Now let''s model the new user registration Event using the following code.
    As we mentioned above, the name should be a verb in the past tense, so `UserRegistered`
    is probably a good choice:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们使用以下代码来建模新的用户注册事件。如我们上面提到的，名称应该是过去时态的动词，所以`UserRegistered`可能是一个不错的选择：
- en: '[PRE2]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The minimum amount of information required to notify subscribers about the creation
    of new users is the `UserId`. With this information, any process, command, or
    Application Service — from either the same Bounded Context or a different one
    — may react to this Event.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 通知订阅者关于新用户创建所需的最小信息量是`UserId`。有了这些信息，任何过程、命令或应用程序服务——无论是同一个边界上下文还是不同的边界上下文——都可以对此事件做出反应。
- en: As a Rule of Thumb
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 作为经验法则
- en: Domain Events are usually designed as immutable
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 领域事件通常设计为不可变的
- en: The Constructor will initialize the full state of the Domain Event.
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构造函数将初始化领域事件的完整状态。
- en: Domain Events will have getters to access their attributes
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 领域事件将提供getter来访问它们的属性
- en: Include the identity of the Aggregate that performs the action
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 包含执行动作的聚合体身份
- en: Include other Aggregate identities related to the first one
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 包含与第一个相关的其他聚合体身份
- en: Include parameters that caused the Event (if useful)
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 包含导致事件的参数（如果有用）
- en: 'But what happens if your Domain experts from the same Bounded Context or a
    different one need more information? Let''s see the same Domain Event modeled
    with more information — for example, the email address:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 但如果你的领域专家来自同一个边界上下文或不同的边界上下文需要更多信息怎么办？让我们看看用更多信息建模的相同领域事件——例如，电子邮件地址：
- en: '[PRE3]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Above, we've added the email address. Adding more information to a Domain Event
    can help improve performance or simplify the integration between different Bounded
    Contexts. Thinking from the point of view of another Bounded Context could help
    modeling Events. When a new user is created in the upstream Bounded Context, the
    downstream one would have to create its own user. Adding the user email could
    possibly save a sync request to the upstream Bounded Context in the case the downstream
    one needed it.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 如上所示，我们添加了电子邮件地址。向领域事件添加更多信息可以帮助提高性能或简化不同边界上下文之间的集成。从另一个边界上下文的角度思考可以帮助建模事件。当上游边界上下文中创建新用户时，下游的一个将不得不创建自己的用户。添加用户电子邮件地址可能在下游需要它的情况下，可能节省对上游边界上下文的同步请求。
- en: Do you remember the gamification example? In order to create a user of the gamification
    platform, probably called Player, the UserId from the e-commerce Bounded Context
    was probably enough. But what happens if the gamification platform has to notify
    the users by email about being rewarded? In this case, the email address is also
    mandatory. So if the email address is included in the original Domain Event, we're
    done. If that's not the case, the gamification Bounded Context needs to request
    this information from the e-commerce Bounded Context via REST or SOA integration.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 你还记得那个游戏化示例吗？为了创建一个游戏化平台上的用户，可能被称为玩家，来自电子商务边界上下文的 UserId 可能已经足够。但如果游戏化平台需要通过电子邮件通知用户奖励信息呢？在这种情况下，电子邮件地址也是必需的。所以如果电子邮件地址包含在原始域事件中，我们就完成了。如果不是这样，游戏化边界上下文需要通过
    REST 或 SOA 集成从电子商务边界上下文请求这些信息。
- en: Why Not the Whole User Entity?
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么不是整个用户实体？
- en: Wondering if you should include the whole User Entity from your Bounded Context
    in the Domain Event? Our suggestion is that you don't. Domain Events might be
    used to communicate messages internally to a given Bounded Context or externally
    to other Bounded Contexts. In other words, what can be a `Seller` in a C2C e-commerce
    product catalog Bounded Context can be an `Author` of a product review in a product
    feedback one. Both can share the same ID or email, but `Seller` and `Author` are
    different concepts representing different Entities from different Bounded Contexts.
    So Entities from one Bounded Context have no meaning or a totally different one
    in another Bounded Context.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 想知道你是否应该在域事件中包含你边界上下文的整个用户实体吗？我们的建议是不要这样做。域事件可能用于在给定的边界上下文中内部通信消息或外部与其他边界上下文通信。换句话说，在一个
    C2C 电子商务产品目录边界上下文中可能是一个“卖家”的，在产品反馈中可能是一个产品的“作者”。两者可以共享相同的 ID 或电子邮件，但“卖家”和“作者”是不同的概念，代表来自不同边界上下文的不同实体。因此，来自一个边界上下文的实体在另一个边界上下文中可能没有意义或具有完全不同的意义。
- en: Doctrine Events
  id: totrans-77
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Doctrine 事件
- en: Domain Events are not just for doing batch jobs such as sending emails or communicating
    to other Bounded Contexts; they're also interesting for performance and scalability
    improvements. Let's see an example.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 域事件不仅用于执行批量作业，如发送电子邮件或与其他边界上下文通信；它们对于性能和可扩展性的改进也非常有趣。让我们看看一个例子。
- en: Consider the following scenario. You have an e-commerce application. Your main
    persistence mechanism is MySQL, but for browsing and filtering your catalog, you're
    using a better approach, such as Elasticsearch or Solr. On Elasticsearch, you'll
    end up with a subset of the information stored in your full database. How do you
    keep the data in sync? What happens when the Content Team updates the catalog
    from the back office tool?
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下场景。你有一个电子商务应用程序。你的主要持久化机制是 MySQL，但为了浏览和过滤你的目录，你使用了一个更好的方法，比如 Elasticsearch
    或 Solr。在 Elasticsearch 上，你最终会得到存储在你完整数据库中的信息的一个子集。你如何保持数据同步？当内容团队从后台工具更新目录时会发生什么？
- en: There have been people re-indexing the entire catalog from time to time. This
    is very expensive and slow. A smarter approach may be updating one or some of
    the documents related to the Product that has been updated. How can we do that?
    Using Domain Events.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 有些人时不时地重新索引整个目录。这非常昂贵且缓慢。一个更聪明的做法可能是更新已更新的产品相关的一个或多个文档。我们如何做到这一点？使用域事件。
- en: 'However, if you''ve been working with Doctrine, this is likely not something
    that''s new to you. According to the [Doctrine 2 ORM 2 Documentation](http://docs.doctrine-project.org/projects/doctrine-orm/en/latest/reference/events.html#events):'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果你一直在使用 Doctrine，这很可能不是什么新鲜事。根据[Doctrine 2 ORM 2 文档](http://docs.doctrine-project.org/projects/doctrine-orm/en/latest/reference/events.html#events)：
- en: Doctrine 2 features a lightweight event system that is part of the Common package.
    Doctrine uses it to dispatch system events, mainly life cycle events. You can
    also use it for your own custom events.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: Doctrine 2 拥有一个轻量级的事件系统，它是 Common 包的一部分。Doctrine 使用它来分发系统事件，主要是生命周期事件。你也可以用它来处理你自己的自定义事件。
- en: 'Furthermore, it [states](http://docs.doctrine-project.org/projects/doctrine-orm/en/latest/reference/events.html#lifecycle-callbacks)
    that:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，它[声明](http://docs.doctrine-project.org/projects/doctrine-orm/en/latest/reference/events.html#lifecycle-callbacks)如下：
- en: Life cycle Callbacks are defined on an entity class. They allow you to trigger
    callbacks whenever an instance of that entity class experiences a relevant life
    cycle event. More than one callback can be defined for each life cycle event.
    Life cycle Callbacks are best used for simple operations specific to a particular
    entity class's life cycle.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 生命周期回调是在实体类上定义的。它们允许你在该实体类的实例经历相关生命周期事件时触发回调。每个生命周期事件都可以定义多个回调。生命周期回调最适合用于特定实体类生命周期的简单操作。
- en: 'Let''s see an example from the [Doctrine Events Documentation](http://doctrine-orm.readthedocs.io/projects/doctrine-orm/en/latest/reference/events.html):'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看[Doctrine事件文档](http://doctrine-orm.readthedocs.io/projects/doctrine-orm/en/latest/reference/events.html)中的一个例子：
- en: '[PRE4]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: You can hook specific tasks on each different important moment in the Doctrine
    Entity life cycle. For example, on `PostPersist`, you can generate the JSON document
    of your Entity and put it into Elasticsearch. That way, it's easy to keep data
    consistent between different persistence mechanisms.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在Doctrine实体生命周期中的每个不同的重要时刻挂钩特定的任务。例如，在`PostPersist`时，你可以生成你的实体JSON文档并将其放入Elasticsearch。这样，就很容易在不同持久化机制之间保持数据的一致性。
- en: Doctrine Events are a good example of the benefits of Events around your Entities.
    But you may be wondering what the problem with them is. This is because they're
    coupled to a framework, they're synchronous, and they act on your application
    level, but not for communication purposes. So that's why Domain Events, despite
    being a bit more difficult to implement and handle, are so much more interesting.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: Doctrine事件是围绕实体周围事件带来好处的良好例子。但你可能想知道它们的问题是什么。这是因为它们与框架耦合，是同步的，并且作用于应用层面，但不是用于通信目的。所以这就是为什么尽管领域事件在实现和处理上可能更困难，但它们仍然非常有意思。
- en: Persisting Domain Events
  id: totrans-89
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 持久化领域事件
- en: 'Persisting Events is always a good idea. Some of you may be wondering why you
    shouldn''t publish Domain Events directly to a messaging or logging system. This
    is because persisting them has interesting benefits:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 持久化事件总是一个好主意。有些人可能想知道为什么你不应该直接将领域事件发布到消息或日志系统中。这是因为持久化它们有一些有趣的好处：
- en: You can expose your Domain Events to other Bounded Contexts through a REST interface.
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以通过REST接口将你的领域事件暴露给其他边界上下文。
- en: You can persist the Domain Event and the Aggregate changes in the same database
    transaction before pushing them to RabbitMQ. (You don't want to send notifications
    about something that didn't happen, just as you don't want to miss a notification
    about something that did happen.)
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以在将事件和聚合更改推送到RabbitMQ之前，在同一个数据库事务中持久化领域事件和聚合更改。（你不想发送关于没有发生的事情的通知，就像你不想错过关于已经发生的事情的通知一样。）
- en: Business Intelligence can use this data to analyze, forecast, or trend.
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 商业智能可以使用这些数据进行分析、预测或趋势分析。
- en: You can audit your Entity changes.
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以审计实体更改。
- en: For Event Sourcing, you can reconstitute Aggregates from Domain Events.
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于事件源，你可以从领域事件中重新构成聚合。
- en: Event Store
  id: totrans-96
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 事件存储
- en: 'Where do we persist Domain Events? In an Event Store. An Event Store is a Domain
    Event Repository that lives in our Domain space as an abstraction (interface or
    abstract class). Its responsibility is to append Domain Events and query them.
    A possible basic interface could be the following:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在哪里持久化领域事件？在事件存储中。事件存储是一个存在于我们的领域空间中的领域事件仓库，作为一个抽象（接口或抽象类）。其责任是追加领域事件并查询它们。一个可能的基本接口可能是以下内容：
- en: '[PRE5]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: However, depending on the usage of your Domain Events, the previous interface
    can have more methods to query your Events.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，根据你的领域事件的使用情况，之前的接口可能有更多方法来查询你的事件。
- en: 'In terms of implementation, you can decide to use a Doctrine Repository, a
    DBAL one, or a plain PDO. Because Domain Events are immutable, using a Doctrine
    Repository adds an unnecessary performance penalty, though for a small to medium
    application, Doctrine is probably OK. Let''s look at a possible implementation
    with Doctrine:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 在实现方面，你可以选择使用Doctrine仓库、DBAL仓库或纯PDO。由于领域事件是不可变的，使用Doctrine仓库会增加不必要的性能惩罚，但对于小型到中型应用，Doctrine可能还是可以的。让我们看看使用Doctrine的一个可能实现：
- en: '[PRE6]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '`StoredEvent` is the Doctrine Entity needed to map to the database. As you
    may have seen, when appending and after persisting the `Store`, there''s no `flush`
    call. If this operation is inside a Doctrine transaction, it''s not needed. So,
    let''s leave it without the call and we''ll go into more details when talking
    about Application Services.'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '`StoredEvent`是映射到数据库的Doctrine实体。正如你可能看到的，在追加并持久化`Store`之后，没有`flush`调用。如果这个操作在Doctrine事务中，则不需要。所以，让我们不调用它，我们将在讨论应用程序服务时详细介绍。'
- en: 'Now let''s see the `StoredEvent` implementation:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们看看`StoredEvent`的实现：
- en: '[PRE7]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'And here is its mapping:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是其映射：
- en: '[PRE8]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: In order to persist Domain Events with different fields, we'll have to join
    those fields as a serialized string. `typeName` identifies the Domain-wide Domain
    Event. An Entity or Value Object makes sense inside a Bounded Context, but Domain
    Events define a communication protocol between Bounded Contexts.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 为了持久化具有不同字段的领域事件，我们必须将这些字段作为序列化字符串连接起来。`typeName`标识全局领域事件。实体或值对象在边界上下文中是有意义的，但领域事件定义了边界上下文之间的通信协议。
- en: In distributed systems, shit happens. You'll have to deal with Domain Events
    that aren't published, are lost somewhere in the chain, or are published more
    than once. That's why it's important to persist a Domain Event with an ID, so
    that it's easy to track which Domain Events have been published and which are
    missing.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 在分布式系统中，总会发生一些事情。你将不得不处理那些未发布、在链中丢失或发布多次的领域事件。这就是为什么将领域事件持久化并带有ID很重要，这样就可以轻松跟踪哪些领域事件已被发布，哪些缺失。
- en: Publishing Events from the Domain Model
  id: totrans-109
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从领域模型发布事件
- en: Domain Events should be published when the fact they represent occurs. For instance,
    when a new user has been registered, a new `UserRegistered` Event should be published.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 当表示的事实发生时，应该发布领域事件。例如，当新用户注册时，应该发布一个新的`UserRegistered`事件。
- en: 'Following the newspaper metaphor:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 按照报纸的比喻：
- en: '**Modeling** a Domain Event is like writing a news article'
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**建模**领域事件就像撰写新闻文章'
- en: '**Publishing** a Domain Event is like printing the article in the paper'
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**发布**领域事件就像在报纸上打印文章'
- en: '**Spreading** a Domain Event is like delivering the newspaper so everyone can
    read the article'
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**传播**领域事件就像分发报纸，让每个人都能阅读文章'
- en: The recommended approach for publishing Domain Events is to use a simple Listener-Observer
    pattern to implement a `DomainEventPublisher`.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 发布领域事件的建议方法是使用简单的监听器-观察者模式来实现`DomainEventPublisher`。
- en: Publishing a Domain Event from an Entity
  id: totrans-116
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从实体发布领域事件
- en: 'Continuing with the example of a new user who has been registered in our application,
    let''s see how the corresponding Domain Event can be published:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 继续以一个新用户在我们的应用程序中注册的例子，让我们看看相应的领域事件是如何发布的：
- en: '[PRE9]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: As seen in the example, when the `User` is created, a new `UserRegistered` Event
    is published. It's done in the Entity constructor and not outside because, with
    this approach, it's easier to keep our Domain consistent; any client who creates
    a new `User` will publish its corresponding Event. On the other hand, this makes
    it a bit more complex to use an infrastructure that needs to create a `User` Entity
    without using its constructor. For example, Doctrine uses the `serialize` and
    `unserialize` technique that recreates an object without calling its constructor.
    However, if you have to create your own, this isn't going to be as easy as in
    Doctrine.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 如示例所示，当创建`User`时，会发布一个新的`UserRegistered`事件。这是在实体构造函数中完成的，而不是在外部，因为采用这种方法，更容易保持我们的领域一致性；任何创建新`User`的客户端都会发布其对应的事件。另一方面，这也使得使用需要创建`User`实体而不使用其构造函数的基础设施变得更加复杂。例如，Doctrine使用`serialize`和`unserialize`技术来重新创建一个对象，而不调用其构造函数。然而，如果你必须自己创建，这不会像在Doctrine中那样简单。
- en: In general, constructing an object from plain data such as an array is called
    **hydration**. Let's see an easy approach to building a new `User` fetched from
    a database. First of all, let's extract the Domain Event publication to its own
    method by applying the [Factory Method pattern](http://en.wikipedia.org/wiki/Template_method_pattern).
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，从平面数据（如数组）构建对象称为**解冻**。让我们看看从数据库中获取新`User`的简单方法。首先，让我们通过应用[工厂方法模式](http://en.wikipedia.org/wiki/Template_method_pattern)将领域事件发布提取到自己的方法中。
- en: 'According to [Wikipedia](https://en.wikipedia.org/wiki/Template_method_pattern):'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 根据[维基百科](https://en.wikipedia.org/wiki/Template_method_pattern)：
- en: 'The template method pattern is a behavioral design pattern that defines the
    program skeleton of an algorithm in an operation, deferring some steps to subclasses:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 模板方法模式是一种行为设计模式，它在一个操作中定义了算法的程序骨架，将一些步骤推迟到子类中：
- en: '[PRE10]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Now, let''s extend our current `User` with a new infrastructure Entity that
    will do the job for us. The trick here is make `publishEvent` do nothing so that
    the Domain Event isn''t published:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们通过添加一个新的基础设施实体来扩展我们当前的`User`，这个实体将为我们完成工作。这里的技巧是让`publishEvent`不执行任何操作，这样域事件就不会被发布：
- en: '[PRE11]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Remember to be careful with this approach; you might fetch invalid objects
    from the persistence mechanism, as Domain rules change all the time. Another approach
    without using the parent constructor could be the following:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 记住要小心使用这种方法；你可能会从持久化机制中获取无效的对象，因为域规则总是在变化。不使用父构造函数的另一种方法可能是以下：
- en: '[PRE12]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: With this approach, the parent constructor isn't called and User attributes
    must be protected. Other alternatives are Reflection, passing flags in the constructor,
    using a proxy library like [Proxy-Manager](https://packagist.org/packages/ocramius/proxy-manager),
    or using an ORM like Doctrine.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这种方法，不会调用父构造函数，并且用户属性必须是受保护的。其他替代方案包括反射、在构造函数中传递标志、使用像[Proxy-Manager](https://packagist.org/packages/ocramius/proxy-manager)这样的代理库，或者使用像Doctrine这样的ORM。
- en: Other Strategy for Publishing Domain Events
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 发布域事件的另一种策略
- en: 'As you can see in the previous example, we''re using a static class for publishing
    our Domain Events. Other people, as an alternative, and especially when using
    [Event Sourcing](http://martinfowler.com/eaaDev/EventSourcing.html), will suggest
    that Entities hold all the fired Events internally within a field. In order to
    access all the Events, a getter is used in the Aggregate. This is also a valid
    approach. However, sometimes it''s a bit difficult to keep track of which Entities
    have fired an Event. It can also be difficult to fire Events from places that
    aren''t just Entities, example: Domain Services. On the plus side, testing if
    an Entity has fired an Event is much easier.'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 如前一个示例所示，我们正在使用一个静态类来发布我们的域事件。其他人，作为一个替代方案，尤其是在使用[事件溯源](http://martinfowler.com/eaaDev/EventSourcing.html)时，会建议实体在字段内部保留所有已触发的事件。为了访问所有事件，聚合体中使用了一个getter。这也是一个有效的方法。然而，有时很难跟踪哪些实体触发了事件。从不是实体的地方触发事件也可能很困难，例如：域服务。优点是，检查实体是否触发了事件要容易得多。
- en: Publishing your Domain Events from Domain or Application Services
  id: totrans-131
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从域或应用服务发布你的域事件
- en: You should struggle to publish Domain Events from deeper in the chain. The closer
    to the inside of the Entity or the Value Object, the better. As we saw in the
    previous section, sometimes this isn't easy, but the final result is simpler for
    the clients. We've seen developers publishing Domain Events from the Application
    Services or Domain Services. This looks easier to do, but it will eventually lead
    to an Anemic Domain Model. This is not unlike when pushing business logic in Domain
    Services instead of placing it into your Entities.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该努力从链的更深层次发布域事件。越接近实体或值对象的内部，越好。正如我们在前一个部分中看到的，有时这并不容易，但最终结果对客户端来说更简单。我们已经看到开发者从应用服务或域服务发布域事件。这看起来更容易做，但最终会导致贫血域模型。这就像在域服务中推入业务逻辑而不是将其放入你的实体中一样。
- en: How the Domain Event Publisher Works
  id: totrans-133
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 域事件发布者是如何工作的
- en: 'A Domain Event Publisher is a Singleton class available from our Bounded Context
    needed to publish Domain Events. It also has support to attach listeners — Domain
    Event Subscribers — that will be listening for any Domain Event they''re interested
    in. This isn''t much different from subscribing to an Event with jQuery using
    the on method:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 域事件发布者是一个单例类，可以从我们的边界上下文中获取，用于发布域事件。它还支持附加监听器——域事件订阅者——它们将监听任何它们感兴趣的事件。这与使用jQuery的on方法订阅事件没有太大区别：
- en: '[PRE13]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The `publish` method goes through all the possible subscribers, checking if
    they're interested in the published Domain Event. If that's the case, the `handle`
    method of the subscriber is called.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: '`publish`方法遍历所有可能的订阅者，检查它们是否对发布的事件感兴趣。如果是这样，就会调用订阅者的`handle`方法。'
- en: 'The `subscribe` method adds a new `DomainEventSubscriber` that will be listening
    to specific Domain Event types:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: '`subscribe`方法添加了一个新的`DomainEventSubscriber`，它将监听特定的域事件类型：'
- en: '[PRE14]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'As we''ve already discussed, persisting all the Domain Events is a great idea.
    We can easily persist all the Domain Events published in our app by using a specific
    subscriber. Let''s create a `DomainEventSubscriber` that will listen to all Domain
    Events, no matter what type, and persist them using our `EventStore`:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们已经讨论过的，持久化所有领域事件是一个很好的主意。我们可以通过使用特定的订阅者轻松地将我们应用中发布的所有领域事件持久化。让我们创建一个`DomainEventSubscriber`，它将监听所有领域事件，无论其类型如何，并使用我们的`EventStore`来持久化它们：
- en: '[PRE15]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '`$eventStore` could be a custom Doctrine Repository, as already seen, or any
    other object capable of persisting `DomainEvents` into a database.'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: '`$eventStore`可以是自定义的Doctrine存储库，如之前所见，或任何其他能够将`DomainEvents`持久化到数据库的对象。'
- en: Setting Up DomainEventListeners
  id: totrans-142
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置领域事件监听器
- en: Where's the best place to set up the subscribers to the `DomainEventPublisher`?
    It depends. For global subscribers that will potentially affect the entire request
    cycle, the best place might be on the `DomainEventPublisher` initialization itself.
    For subscribers affected by a specific Application Service, the service instantiation
    might be a better place. Let's see an example using Silex.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 在哪里设置`DomainEventPublisher`的订阅者最好？这取决于。对于可能会影响整个请求周期的全局订阅者，最好的地方可能是`DomainEventPublisher`的初始化本身。对于受特定应用程序服务影响的订阅者，服务实例化可能是一个更好的地方。让我们通过Silex看看一个例子。
- en: 'In [Silex](http://silex.sensiolabs.org/), the best way to register a Domain
    Event Publisher that will persist all Domain Events is by using an Application
    Middleware. According to the [Silex 2.0 Documentation](http://silex.sensiolabs.org/doc/master/middlewares.html):'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 在[Silex](http://silex.sensiolabs.org/)中，通过使用应用程序中间件注册将所有领域事件持久化的领域事件发布者是最简单的方法。根据[Silex
    2.0文档](http://silex.sensiolabs.org/doc/master/middlewares.html)：
- en: A *before* application middleware allows you to tweak the Request before the
    controller is executed.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 一个*前置*应用程序中间件允许你在控制器执行之前调整请求。
- en: 'This is the correct place to subscribe the listener responsible for persisting
    to the database those Events that will be sent to RabbitMQ later:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 这是订阅负责将稍后发送到RabbitMQ的Event事件持久化到数据库的监听器的正确位置：
- en: '[PRE16]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: With this setup, each time an Aggregate publishes a Domain Event, it will get
    persisted into the database. Mission accomplished.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 使用此设置，每当聚合发布领域事件时，它将被持久化到数据库中。任务完成。
- en: Exercise
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 练习
- en: If you're working with Symfony, Laravel, or another PHP framework, find a way
    to subscribe globally specific subscribers for performing tasks around your Domain
    Events.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你正在使用Symfony、Laravel或其他PHP框架，找到一种方法来全局订阅特定的订阅者，以执行围绕你的领域事件的任务。
- en: In case you want to perform any action on all Domain Events when the request
    is about to finish, you can create a Listener that will store all published Domain
    Events in memory. If you add a getter to that Listener to return all Domain Events,
    you can then decide what to do. This can be useful if you don't want to or if
    you can't persist the Events in the same transaction, as suggested before.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想在请求即将结束时对所有领域事件执行任何操作，你可以创建一个监听器，该监听器将所有已发布的领域事件存储在内存中。如果你给这个监听器添加一个getter来返回所有领域事件，然后你可以决定要做什么。如果不想或不能在之前提到的同一事务中持久化事件，这可能会很有用。
- en: Testing Domain Events
  id: totrans-152
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试领域事件
- en: 'You already know how to publish Domain Events, but how can you unit test this
    and ensure that `UserRegistered` is really fired? The easiest way we suggest is
    to use a specific `EventListener` that will work as a [Spy](http://www.martinfowler.com/bliki/TestDouble.html) to
    record whether or not the Domain Event was published. Let''s see an example of
    the `User` Entity unit test:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经知道如何发布领域事件，但如何进行单元测试以确保`UserRegistered`事件确实被触发？我们建议的最简单方法是使用一个特定的`EventListener`，它将作为一个[间谍](http://www.martinfowler.com/bliki/TestDouble.html)来记录领域事件是否被发布。让我们看看`User`实体单元测试的一个例子：
- en: '[PRE17]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: There are some alternatives to the above. You could use a static setter for
    the `DomainEventPublisher` or some reflection framework to detect the call. However,
    we think the approach we've shared is more natural. Last but not least, remember
    to clean up the Spy subscription so it won't affect the execution of the rest
    of the unit tests.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 上述方法有一些替代方案。你可以为`DomainEventPublisher`使用静态setter或使用一些反射框架来检测调用。然而，我们认为我们分享的方法更自然。最后但并非最不重要的是，记得清理间谍订阅，以免影响单元测试的其余部分的执行。
- en: Spreading the news to Remote Bounded Contexts
  id: totrans-156
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将消息传播到远程边界上下文
- en: 'In order to communicate a set of Domain Events to local or remote Bounded Contexts,
    there are two main strategies: messaging and a REST API. The first plans to use
    a messaging system such as RabbitMQ to transmit the Domain Events. The second
    plans to create a REST API for accessing the Domain Events of a specific Bounded
    Context.'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 为了将一组领域事件传达给本地或远程的边界上下文，有两种主要策略：消息传递和REST API。第一种计划使用消息系统（如RabbitMQ）来传输领域事件。第二种计划为访问特定边界上下文的领域事件创建REST
    API。
- en: Messaging
  id: totrans-158
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 消息传递
- en: With all Domain Events persisted into the database, the only thing remaining
    to spread the news is to push them to our favorite messaging system. We prefer
    [RabbitMQ](https://www.rabbitmq.com), but any other system, such as ActiveMQ or
    ZeroMQ, will do the job. For integrating with RabbitMQ using PHP, there aren't
    many options, but *[`php-amqplib`](https://packagist.org/packages/php-amqplib/php-amqplib)* will
    do the work.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 将所有领域事件持久化到数据库后，剩下的唯一事情就是将它们推送到我们喜欢的消息系统。我们更喜欢[RabbitMQ](https://www.rabbitmq.com)，但任何其他系统，如ActiveMQ或ZeroMQ，也能完成这项工作。对于使用PHP与RabbitMQ集成，选项并不多，但*[`php-amqplib`](https://packagist.org/packages/php-amqplib/php-amqplib)*将完成这项工作。
- en: 'First of all, we need a service capable of sending persisted Domain Events
    to RabbitMQ. You may want to query EventStore for all the Events and send each
    one, which isn''t a bad idea. However, we could push the same Domain Event more
    than once, and generally speaking, *we need to minimize the number of Domain Events
    republished*. If the number of Domain Events republished is 0, that''s even better.
    In order to not republish Domain Events, we need some sort of component to track
    which Domain Events have already been pushed and which ones are remaining. Last
    but not least, once we know which Domain Events we have to push, we send them
    and keep track of the last one published into our messaging system. Let''s see
    a possible implementation for this service:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要一个能够将持久化的领域事件发送到RabbitMQ的服务。你可能想查询EventStore中的所有事件并发送每一个，这并不是一个坏主意。然而，我们可能会多次推送同一个领域事件，一般来说，*我们需要最小化重新发布的领域事件数量*。如果重新发布的领域事件数量为0，那就更好了。为了不重新发布领域事件，我们需要某种组件来跟踪哪些领域事件已经被推送，哪些尚未推送。最后但同样重要的是，一旦我们知道哪些领域事件需要推送，我们就将它们发送出去，并跟踪最后一条发布到我们的消息系统中的消息。让我们看看这个服务的可能实现：
- en: '[PRE18]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '`NotificationService` depends on three interfaces. We''ve already seen `EventStore`,
    which is responsible for appending and querying Domain Events. The second one
    is `PublishedMessageTracker`, which is responsible for keeping track of pushed
    messages. The third one is `MessageProducer`, an interface representing our messaging
    system:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: '`NotificationService`依赖于三个接口。我们已经看到了`EventStore`，它负责追加和查询领域事件。第二个是`PublishedMessageTracker`，它负责跟踪推送的消息。第三个是`MessageProducer`，这是一个代表我们的消息系统的接口：'
- en: '[PRE19]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'The `mostRecentPublishedMessageId` method returns the ID of last `PublishedMessage`,
    so that the process can start from the next one. `trackMostRecentPublishedMessage`
    is responsible for tracking which message was sent last, in order to be able to
    republish messages in case you need to. `$exchangeName` represents the communication
    channel we''re going to use to send out our Domain Events. Let''s see a Doctrine
    implementation of `PublishedMessageTracker`:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: '`mostRecentPublishedMessageId`方法返回最后一条`PublishedMessage`的ID，以便过程可以从下一条开始。`trackMostRecentPublishedMessage`负责跟踪最后一条发送的消息，以便在需要时能够重新发布消息。`$exchangeName`代表我们将用于发送领域事件的通信通道。让我们看看`PublishedMessageTracker`的Doctrine实现：'
- en: '[PRE20]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: This code is quite straightforward. The only edge case we have to consider is
    when no Domain Event has already been published.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码相当简单。我们唯一需要考虑的边缘情况是没有任何领域事件已经被发布。
- en: Why an Exchange Name?
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么需要一个交换机名称？
- en: We'll see this in more detail in the Chapter 12, *Integrating Bounded Contexts*.
    However, when a system is running and a new Bounded Context comes into play, you
    might be interested in resending all the Domain Events to the new Bounded Context.
    So keeping track of the last Domain Event published and the channel where it was
    sent might come in handy later.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在第12章“集成边界上下文”中更详细地介绍这一点。然而，当系统运行时，一个新的边界上下文开始发挥作用，你可能希望将所有领域事件重新发送到新的边界上下文。因此，跟踪最后一条已发布的领域事件及其发送的通道可能会在以后派上用场。
- en: 'In order to keep track of published Domain Events, we need an exchange name
    and a notification ID. Here''s a possible implementation:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 为了跟踪已发布的领域事件，我们需要一个交换机名称和一个通知ID。以下是一个可能的实现：
- en: '[PRE21]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'And here is its corresponding mapping:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是其对应的映射：
- en: '[PRE22]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Now let''s see what the `MessageProducer` interface is used for, along with
    its implementation details:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来看看`MessageProducer`接口是用来做什么的，以及它的实现细节：
- en: '[PRE23]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Easy. The open and close methods open and close a connection with the messaging
    system. send takes a message body — message name and message ID — and sends them
    to our messaging engine, whatever it is. Because we''ve chosen RabbitMQ, we need
    to implement the connection and sending process:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 很简单。打开和关闭方法用于打开和关闭与消息系统的连接。`send`方法接收一个消息体——消息名称和消息ID——并将它们发送到我们的消息引擎，无论它是什么。因为我们选择了RabbitMQ，我们需要实现连接和发送过程：
- en: '[PRE24]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Now that we have a `DomainService` for pushing Domain Events into a messaging
    system like RabbitMQ, it''s time to execute them. We need to choose a delivery
    mechanism to run the service. We personally suggest creating a [Symfony Console](http://symfony.com/doc/current/components/console/introduction.html) Command:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经有一个`DomainService`用于将领域事件推送到像RabbitMQ这样的消息系统，现在是时候执行它们了。我们需要选择一个交付机制来运行该服务。我们个人建议创建一个[Symfony控制台命令](http://symfony.com/doc/current/components/console/introduction.html)：
- en: '[PRE25]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Following the Silex example, let''s see the definition of the `$app[''notification_service'']`
    defined in the [Silex Pimple Service Container](http://silex.sensiolabs.org/doc/services.html#id1):'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 按照Silex示例，让我们看看在[Silex Pimple服务容器](http://silex.sensiolabs.org/doc/services.html#id1)中定义的`$app['notification_service']`的定义：
- en: '[PRE26]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Syncing Domain Services with REST
  id: totrans-181
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将领域服务与REST同步
- en: 'With the `EventStore` already implemented in the messaging system, it should
    be easy to add some pagination capabilities, query for Domain Events, and render
    a JSON or XML representation publishing a REST API. Why is that interesting? Well,
    distributed systems using messaging have to face many different problems, such
    as messages that don''t arrive, messages that arrive duplicated, or messages that
    arrive in an unexpected order. That''s why it''s nice to provide an API to publish
    your Domain Events so that other Bounded Contexts can ask for some missing information.
    Just as an example, consider that you make an HTTP request to an `/events` endpoint.
    A possible result would be the following:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 在消息系统中已经实现了`EventStore`之后，添加一些分页功能、查询领域事件以及发布JSON或XML表示形式的REST API应该很容易。这有什么有趣的地方吗？嗯，使用消息传递的分布式系统必须面对许多不同的问题，例如消息没有到达、消息重复到达，或者消息以意外的顺序到达。这就是为什么提供一个API来发布你的领域事件，以便其他边界上下文可以请求一些缺失信息是很好的。仅作为一个例子，考虑你向`/events`端点发出一个HTTP请求。可能的结果如下：
- en: '[PRE27]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'As you can see in the previous example, we''re exposing a set of Domain Events
    in a JSON REST API. In the output example, you can see a JSON representation of
    each of the Domain Events. There are some interesting points. First, the `version`
    field. Sometimes your Domain Events will evolve: they''ll include more fields,
    they''ll change the behavior of some existing fields, or they''ll remove some
    existing fields. That''s why it''s important to add a version field in your Domain
    Events. If other Bounded Contexts are listening to such Events, they can use the
    version field to parse the Domain Event in different ways. You may have faced
    the same problem when versioning REST APIs.'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 如前一个示例所示，我们正在通过JSON REST API公开一组领域事件。在输出示例中，你可以看到每个领域事件的JSON表示。有一些有趣的地方。首先，`version`字段。有时你的领域事件会进化：它们将包括更多的字段，它们会改变一些现有字段的行为，或者它们会删除一些现有字段。这就是为什么在领域事件中添加一个版本字段很重要。如果其他边界上下文正在监听此类事件，它们可以使用版本字段以不同的方式解析领域事件。你可能遇到过在版本化REST
    API时遇到相同的问题。
- en: Another point is the name. If you want to use the `classname` of the Domain
    Event, it may work in most cases. The problem is when a team decides to change
    the name of the class because of a refactoring. In this case, all Bounded Contexts
    listening to that name would stop working. This problem only occurs if you publish
    different Domain Events in the same queue. If you publish each Domain Event type
    in a different queue, it's not a real problem, but if you choose this approach,
    you'll face a different set of problems, such as receiving unordered events. Like
    in many other instances, there's a tradeoff involved. We strongly recommend you
    read *Enterprise Integration Patterns:* [Designing, Building, and Deploying Messaging
    Solutions](http://www.amazon.com/Enterprise-Integration-Patterns-Designing-Addison-Wesley-ebook/dp/B007MQLL4E).
    In this book, you'll learn different patterns for integrating multiple applications
    using asynchronous methods. Because Domain Events are messages sent in an integration
    channel, all messaging patterns also apply to them.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 另一点是名称。如果你想使用领域事件的`classname`，在大多数情况下可能可行。问题是当团队决定因为重构而更改类的名称时，所有监听该名称的边界上下文都会停止工作。这个问题只会在你在同一个队列中发布不同的领域事件时出现。如果你在每个不同的队列中发布每种领域事件类型，这并不是真正的问题，但如果你选择这种方法，你将面临另一组问题，例如接收无序的事件。就像在许多其他情况下一样，这里涉及到权衡。我们强烈建议你阅读*《企业集成模式：设计、构建和部署消息解决方案》*
    [Designing, Building, and Deploying Messaging Solutions](http://www.amazon.com/Enterprise-Integration-Patterns-Designing-Addison-Wesley-ebook/dp/B007MQLL4E)。在这本书中，你将学习到使用异步方法集成多个应用程序的不同模式。因为领域事件是在集成通道中发送的消息，所以所有消息模式也适用于它们。
- en: Exercise
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 练习
- en: Think about the pros and cons of having a REST API for Domain Events. Consider
    Bounded Context coupling. You can also try to implement a REST API for your current
    application.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑一下为领域事件拥有REST API的利弊。考虑边界上下文的耦合。你也可以尝试为你的当前应用程序实现REST API。
- en: Wrap-Up
  id: totrans-188
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: We've seen the tricks to model a proper `DomainEvent` with a base interface,
    we've seen where to publish the `DomainEvent` (the nearer to the Entities the
    better), and we've seen the strategies for spreading those `DomainEvents` to local
    and remote Bounded Contexts. Now, the only thing remaining is listening for a
    notification in the messaging system, reading it, and executing the corresponding
    Application Service or Command. We'll see how to do this in [Chapter 12](31f29fd9-2a73-42bd-88ad-2b189981cd1b.xhtml), *Integrating
    Bounded Contexts* and [Chapter 5](dd26d3b0-1441-4dc1-81fb-0be8332e0540.xhtml),
    *Services*.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到了如何使用基接口来正确建模`DomainEvent`的技巧，我们已经看到了在哪里发布`DomainEvent`（越靠近实体越好），我们也已经看到了将那些`DomainEvents`传播到本地和远程边界上下文的策略。现在，唯一剩下的事情就是在消息系统中监听通知，读取它，并执行相应的应用程序服务或命令。我们将在第12章*整合边界上下文*和第5章*服务*中看到如何做到这一点。[Chapter
    12](31f29fd9-2a73-42bd-88ad-2b189981cd1b.xhtml), *Integrating Bounded Contexts*
    和 [Chapter 5](dd26d3b0-1441-4dc1-81fb-0be8332e0540.xhtml), *Services*.
