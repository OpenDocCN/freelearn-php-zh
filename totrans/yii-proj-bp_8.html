<html><head></head><body><div class="chapter" title="Chapter&#xA0;8.&#xA0;Building an API for the CMS"><div class="titlepage"><div><div><h1 class="title"><a id="ch08"/>Chapter 8. Building an API for the CMS</h1></div></div></div><p>Throughout this book, we've covered the development of view-oriented applications—applications that the user can interact with directly. Our view-oriented approach, however, doesn't allow us to easily integrate with other services or provide functionalities for native applications. This view-oriented approach often leaves us with hardcoded functionality and makes integrations significantly more difficult. The Yii framework, however, is extremely adaptable and enables us to build API-driven applications rather than view-driven applications. An API reduces the amount of code we have to maintain; if executed properly, it reduces the amount of code that needs to change when we want to add a feature. Ultimately, this allows us to work faster and be more adaptable to changes.</p><p>Building an <a id="id697" class="indexterm"/>API-driven application also enables us to easily develop <a id="id698" class="indexterm"/>both web and native clients that work with our API, thus completely separating view-oriented logic from our application. In this chapter, we'll go over what we'll need to do in order to build an API-driven module for our content-management system that we created earlier. By fostering an ecosystem around our application, we can provide value to both developers and users, and increase the value of our application.</p><p>The following is the demonstration:</p><div class="mediaobject"><img src="graphics/7734OS_08_01.jpg" alt="Building an API for the CMS"/></div><p>In this<a id="id699" class="indexterm"/> chapter, we'll go over what we'll need to do to build an <a id="id700" class="indexterm"/>API-driven module for our content management system that we created earlier.</p><div class="section" title="Prerequisites"><div class="titlepage"><div><div><h1 class="title"><a id="ch08lvl1sec69"/>Prerequisites</h1></div></div></div><p>Since we'll be expanding upon the work we did in <a class="link" href="ch07.html" title="Chapter 7. Creating a Management Module for the CMS">Chapter 7</a>, <span class="emphasis"><em>Creating a Management Module for the CMS</em></span>, we'll need the completed source code from the previous chapter. You can<a id="id701" class="indexterm"/> either build the project yourself, or you can use the completed source code available in the project resources folder in the previous chapter. We'll also need a URL request client that will allow us to send <code class="literal">GET</code>, <code class="literal">POST</code>, and <code class="literal">DELETE</code> requests with JSON-encoded data to our application. You can either use cURL, or you can<a id="id702" class="indexterm"/> download a Google Chrome extension called <span class="strong"><strong>RESTClient</strong></span> available at <a class="ulink" href="https://chrome.google.com/webstore/detail/rest-console/cokgbflfommojglbmbpenpphppikmonn?hl=en">https://chrome.google.com/webstore/detail/rest-console/cokgbflfommojglbmbpenpphppikmonn?hl=en</a>. The examples throughout this chapter <a id="id703" class="indexterm"/>will use RESTClient.</p></div></div>
<div class="section" title="Describing the project"><div class="titlepage"><div><div><h1 class="title"><a id="ch08lvl1sec70"/>Describing the project</h1></div></div></div><p>In this<a id="id704" class="indexterm"/> chapter, we'll be building an API module for our content-management system. The development of this module can be broken down into several pieces:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Configuring the module</li><li class="listitem" style="list-style-type: disc">Extending Yii to "RESTfully" render JSON or XML instead of a view file</li><li class="listitem" style="list-style-type: disc">Handling data input</li><li class="listitem" style="list-style-type: disc">Handling user authentication</li><li class="listitem" style="list-style-type: disc">Handling exceptions and errors</li><li class="listitem" style="list-style-type: disc">Specifying what data will be returned with each response</li><li class="listitem" style="list-style-type: disc">Implementing authentication, deauthentication, and basic CRUD actions</li></ul></div><div class="section" title="Configuring the module"><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec129"/>Configuring the module</h2></div></div></div><p>The first <a id="id705" class="indexterm"/>component of this project will consist of creating and <a id="id706" class="indexterm"/>configuring our module so that it integrates with our main application. Since we added the functionality that seamlessly integrates modules into our application in the previous chapter, the only work required for this section will be to clear out our module cache, initialize the module, and add in the necessary routes.</p></div><div class="section" title="Extending Yii to render JSON or XML in a RESTful way"><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec130"/>Extending Yii to render JSON or XML in a RESTful way</h2></div></div></div><p>Since <a id="id707" class="indexterm"/>the Yii framework is designed to work<a id="id708" class="indexterm"/> with view files, we'll need to extend several components of the Yii framework in order to get it to output and render JSON or XML documentations. We'll also need to make several different changes to Yii so that it knows how to handle <code class="literal">GET</code>, <code class="literal">POST</code>, and <code class="literal">DELETE</code> actions independently of one another. To accomplish this, we'll create a new controller that will extend <code class="literal">CMSController</code>, which we created in the previous chapters. This will overload several key methods from <code class="literal">CController</code>, namely <code class="literal">runAction()</code>, <code class="literal">filterAccessControl()</code>, <code class="literal">createAction()</code>, and <code class="literal">beforeAction()</code>. We'll also extend several other classes—<code class="literal">CInlineAction</code>, <code class="literal">CAccessControlFilter</code>, and <code class="literal">CAccessRule</code>—to implement all the functionality<a id="id709" class="indexterm"/> we need. Finally, we'll also change<a id="id710" class="indexterm"/> the way the renderer works so that we can return data from our actions and have our base controller handle the output, thus reducing the amount of echoing we need to perform in each controller.</p></div><div class="section" title="Handling data input"><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec131"/>Handling data input</h2></div></div></div><p>For any<a id="id711" class="indexterm"/> request that modifies data in our application, we'll need to handle the acceptance of that data to the RESTful endpoint. To keep things simple, we'll accept JSON-encoded data, or we'll accept data encoded with <code class="literal">application/x-www-form-urlencoded</code> or HTML form fields for our convenience. In our application, we'll turn either of these data sources into usable attributes that we can modify and work from in order to complete tasks.</p></div><div class="section" title="Authenticating users to the API"><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec132"/>Authenticating users to the API</h2></div></div></div><p>In Yii, user authentication and identification are typically handled by our <code class="literal">UserIdentity</code> class and cookies. By convention, RESTful API's don't send or accept any cookies, which means <a id="id712" class="indexterm"/>that we'll have to change the way we perform authentication <a id="id713" class="indexterm"/>within our application. For this, we'll create a custom <code class="literal">AccessControlFilter</code> that will initially authenticate our users using their username and password. If a user successfully authenticates against our API, we'll return to them a unique token that the user will use for all future requests that require authentication. This token, and the user's email address will be sent via two custom headers, <code class="literal">X-Auth-Token</code> and <code class="literal">X-Auth-Email</code>, and will allow us to identify the user in our API without requiring them to resend their password information. This token will be stored alongside our user in the <code class="literal">user_metadata</code> table we created in the previous chapters.</p></div><div class="section" title="Handling API exceptions"><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec133"/>Handling API exceptions</h2></div></div></div><p>The next components we'll need to handle are errors and exceptions. These will range from <a id="id714" class="indexterm"/>errors that Yii will encounter naturally, such as 404 errors <a id="id715" class="indexterm"/>when an action isn't found, to exceptions that we throw within our application to notify clients interacting with our API of either an unexpected error or a warning that something has happened. Since we'll be changing the way rendering works within our application, we'll simply reroute our errors the same way we would for the response of any action.</p></div><div class="section" title="Handling data responses"><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec134"/>Handling data responses</h2></div></div></div><p>With every<a id="id716" class="indexterm"/> request, we'll return the HTTP status code, a message if an error occurred, and a mixed content response attribute that will contain all the information that we want to return to the client for consumption. The response will look as follows:</p><div class="informalexample"><pre class="programlisting">{
   "status": &lt;integer::http_status_code&gt;,
   "message": "&lt;string::null_or_error_message&gt;",
   "response": &lt;mixed::boolean_string_or_array_response"
}</pre></div><p>We'll also have our actions return a method that will allow us to define what attributes should be returned with each request. This will allow us to return only a limited amount of information, preventing accidental information disclosure, and will enable us to protect private information such as passwords or credentials.</p></div><div class="section" title="Implementing actions"><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec135"/>Implementing actions</h2></div></div></div><p>The<a id="id717" class="indexterm"/> last big part that we'll handle is the implementation of all of our controller actions. This will include our authentication endpoint, all the user actions such as registering and resetting their password, and the management of our three core data models: Users, Categories, and Content.</p></div></div>
<div class="section" title="Initializing the project"><div class="titlepage"><div><div><h1 class="title"><a id="ch08lvl1sec71"/>Initializing the project</h1></div></div></div><p>For this <a id="id718" class="indexterm"/>project, we'll be starting where we left off in <a class="link" href="ch07.html" title="Chapter 7. Creating a Management Module for the CMS">Chapter 7</a>, <span class="emphasis"><em>Creating a Management Module for the CMS</em></span>. The steps are as follows:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">For your <a id="id719" class="indexterm"/>convenience, a skeleton project has been included in the project resources folder for this chapter that contains the foundation that we'll be starting with. Begin by copying the source code to a new folder, and make sure that it is available at a different URL from the one we used in the previous chapter. In this chapter, I'll be using <code class="literal">http://chapter8.example.com</code> as our example URL.</li><li class="listitem">After importing the database and updating the database configuration using the instructions provided in the previous chapter, create a new folder called <code class="literal">api</code> in <code class="literal">protected/modules</code> and also create the following directory structure:<div class="informalexample"><pre class="programlisting">api/
   components/
   config/
   controllers/</pre></div></li><li class="listitem">Next, create <a id="id720" class="indexterm"/>the <code class="literal">ApiModule</code> class, <code class="literal">ApiModule.php</code>, in <code class="literal">protected/modules/api/</code>, which will bootstrap our module:<div class="informalexample"><pre class="programlisting">&lt;?php

class ApiModule extends CWebModule
{
   public function init()
   {
      // import the module-level models and components
      $this-&gt;setImport(array(
         'api.components.*',
      ));

      Yii::app()-&gt;log-&gt;routes[0]-&gt;enabled = false;
        
      Yii::app()-&gt;setComponents(array(
            'errorHandler' =&gt; array(
               'errorAction'  =&gt; 'api/default/error',
           )
        ));
   }
}</pre></div></li><li class="listitem">Next, create <code class="literal">routes.php</code> in <code class="literal">protected/modules/api/config/</code>, and populate it with the following information:<div class="informalexample"><pre class="programlisting">&lt;?php return array(
   '/api/&lt;controller:\w+&gt;/&lt;action:\w+&gt;' =&gt; '/api/&lt;controller&gt;/&lt;action&gt;',
   '/api/&lt;controller:\w+&gt;/&lt;action:\w+&gt;/&lt;id:\w+&gt;' =&gt; '/api/&lt;controller&gt;/&lt;action&gt;'
);</pre></div></li></ol></div><p>Finally, remove <code class="literal">modules.config.php</code> in the <code class="literal">protected/runtime/</code> directory, and the contents of the <code class="literal">protected/runtime/cache</code> directory, to clear the modules cache that we implemented in the previous chapter. This will ensure that Yii recognizes and caches our new module. The next time we access Yii, this file will be regenerated and will contain the appropriate module configuration for our application.</p></div>
<div class="section" title="Extending Yii to return data"><div class="titlepage"><div><div><h1 class="title"><a id="ch08lvl1sec72"/>Extending Yii to return data</h1></div></div></div><p>There are two approaches to having Yii render the JSON or XML data. The first and the easiest <a id="id721" class="indexterm"/>approach is to create a JSON or XML view file and, from every action, call <code class="literal">$this-&gt;render('json')</code>. While this is simple, it forces us to store a lot of information and explicitly call the <code class="literal">render()</code> method in each action. If we're extending a class that modifies the <code class="literal">render()</code> method, this can be extremely problematic if we want to make changes later. Another issue with this approach is that it treats errors as separate response types. When throwing an error with this approach, Yii will want to render the error as HTML rather than JSON. Depending upon our logging and debug level, this can cause our API to return the wrong data to our client.</p><p>A more preferable approach is to simply return the data that we want to present to the client in each action and have our parent controller class handle the rendering and output. This approach makes it easier to identify what data is being presented from each action and ensures that our API consistently returns the right data format even when exceptions or errors happen.</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">To get this working, however, we need to extend a few classes from the Yii framework and modify them so that they return data instead of outputting it. The first class we need to extend is <code class="literal">CInlineAction</code>. <code class="literal">CInlineAction</code>. It represents the actual action method within our controllers and is called by the <code class="literal">runAction()</code> controller method. To make our API return data instead of outputting it, we first need to intercept the response of our actions by modifying the <code class="literal">CInlineAction</code> <code class="literal">runWithParamsInternal()</code> method, which we'll then return to the <code class="literal">runAction()</code> method in the parent controller.</li><li class="listitem">We'll do this by creating a new class called <code class="literal">ApiInlineAction</code> that extends <code class="literal">CInlineAction</code> and overloads the <code class="literal">runWithParamsInternal()</code> method. For our convenience, we'll put this code in <code class="literal">ApiInlineAction.php</code>, located at <code class="literal">protected/modules/api/components/</code>:<div class="informalexample"><pre class="programlisting">&lt;?php
class ApiInlineAction extends CInlineAction
{
    protected function runWithParamsInternal($object, $method, $params)
    {
        $ps=array();
        foreach($method-&gt;getParameters() as $i=&gt;$param)
        {
            $name=$param-&gt;getName();
            if(isset($params[$name]))
            {
                if($param-&gt;isArray())
                    $ps[]=is_array($params[$name]) ? $params[$name] : array($params[$name]);
                elseif(!is_array($params[$name]))
                    $ps[]=$params[$name];
                else
                    return false;
            }
            elseif($param-&gt;isDefaultValueAvailable())
                $ps[]=$param-&gt;getDefaultValue();
            else
                return false;
        }

        return $method-&gt;invokeArgs($object,$ps);
    }
}</pre></div></li><li class="listitem">Next, we'll need to create a base controller class that all of our API controllers will extend from. This parent class will be what ultimately class <code class="literal">runWithParamsInternal</code>. Begin by creating a new class in <code class="literal">protected/modules/api/components</code> called <code class="literal">ApiController.php</code> with the following definition:<div class="informalexample"><pre class="programlisting">&lt;?php class ApiController extends CMSController {}</pre></div></li><li class="listitem">Throughout<a id="id722" class="indexterm"/> this class, we'll be referencing the private <code class="literal">$_action</code> variable, which we'll need to redefine from the parent class. We'll define the status and message variables at this time as well. These variables will hold the HTTP status code as well as any error messages that we want to present to the client:<div class="informalexample"><pre class="programlisting">private $_action;
public $status = 200;
public $message = null;</pre></div></li><li class="listitem">We'll then overload our <code class="literal">runAction()</code> method to call our output method instead of Yii's rendering methods:<div class="informalexample"><pre class="programlisting">public function runAction($action)
{
   $response = null;
    $priorAction=$this-&gt;_action;
    $this-&gt;_action=$action;

    if($this-&gt;beforeAction($action))
    {
       $response = $action-&gt;runWithParams($this-&gt;getActionParams());
        if($response===false)
            $this-&gt;invalidActionParams($action);
        else
            $this-&gt;afterAction($action);
    }

    $this-&gt;_action=$priorAction;

    $this-&gt;renderOutput($response);
}</pre></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note43"/>Note</h3><p>Have <a id="id723" class="indexterm"/>questions about <code class="literal">CInlineAction</code>? Be <a id="id724" class="indexterm"/>sure to check out the class documentation at <a class="ulink" href="http://www.yiiframework.com/doc/api/1.1/CInlineAction">http://www.yiiframework.com/doc/api/1.1/CInlineAction</a>.</p></div></div></li></ol></div><div class="section" title="Rendering data"><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec136"/>Rendering data</h2></div></div></div><p>The <a id="id725" class="indexterm"/>next part in outputting our data is to create the <code class="literal">renderOutput()</code> method that we called earlier:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">We'll begin by defining the method. In order to make it as adaptable as possible, we'll want the ability to manually call this method with the status and message that we want to present:<div class="informalexample"><pre class="programlisting">public function renderOutput($response = array(), $status=NULL, $message=NULL) {}</pre></div></li><li class="listitem">At this time, we'll define several response headers that will allow web clients to talk to our API and get the same-origin policy settings that modern web browsers have in place in order to protect users. Without these cross-origin resource-sharing headers (CORS, for short), web clients won't be able to talk to our API. This will also allow web browsers to send our API custom authentication headers that we'll define later:<div class="informalexample"><pre class="programlisting">header("Access-Control-Allow-Origin: *");
header("Access-Control-Allow-Headers: x-auth-token, x-auth-email");
header('Access-Control-Allow-Methods: PUT, PATCH, DELETE, POST, GET, OPTIONS');</pre></div></li><li class="listitem">We'll then define our base data response:<div class="informalexample"><pre class="programlisting">$data = array(
    'status' =&gt; $status != NULL ? $status : $this-&gt;status,
    'message' =&gt; $message != NULL ? $message : ($this-&gt;message == NULL ? 'Your request was successfully fulfilled' : $this-&gt;message),
    'response' =&gt; $response
);</pre></div></li><li class="listitem">Then, we'll <a id="id726" class="indexterm"/>determine the data format in which we want to return our data from a <code class="literal">GET</code> parameter called <code class="literal">format</code> and render the data appropriately:<div class="informalexample"><pre class="programlisting">$format = Yii::app()-&gt;request-&gt;getParam('format', 'json');
if ($format == 'xml')
{
    header ("Content-Type:text/xml");
    echo $this-&gt;renderXML($data);
}
else
    echo $this-&gt;renderJSON($data);
Yii::app()-&gt;end();</pre></div></li><li class="listitem">To render JSON data, we'll simply take the data response that we built in the previous steps and output it with <code class="literal">CJSON::encode()</code>:<div class="informalexample"><pre class="programlisting">private function renderJSON($data)
{
    header('Content-Type: application/json');
    return CJSON::encode($data);
}</pre></div></li><li class="listitem">Rendering the XML data is slightly more involved but can easily be done with the following recursive method:<div class="informalexample"><pre class="programlisting">private function renderXML($array, $level=1)
{
    $xml = '';
    if ($level==1)
        $xml .= '&lt;?xml version="1.0" encoding="ISO-8859-1"?&gt;'."\n&lt;data&gt;\n";

    foreach ($array as $key=&gt;$value)
    {
        $key = strtolower($key);
        if (is_array($value))
        {
            $multi_tags = false;
            foreach($value as $key2=&gt;$value2)
            {
                if (is_array($value2))
                {
                    $xml .= str_repeat("\t",$level)."&lt;$key&gt;\n";
                    $xml .= $this-&gt;renderXML($value2, $level+1);
                    $xml .= str_repeat("\t",$level)."&lt;/$key&gt;\n";
                    $multi_tags = true;
                }
                else
                {
                    if (trim($value2)!='')
                    {
                        if (htmlspecialchars($value2)!=$value2)
                            $xml .= str_repeat("\t",$level)."&lt;$key&gt;&lt;![CDATA[$value2]]&gt;"."&lt;/$key&gt;\n";
                        else
                            $xml .= str_repeat("\t",$level)."&lt;$key&gt;$value2&lt;/$key&gt;\n";
                    }

                    $multi_tags = true;
                }
            }

            if (!$multi_tags and count($value)&gt;0)
            {
                $xml .= str_repeat("\t",$level)."&lt;$key&gt;\n";
                $xml .= $this-&gt;renderXML($value, $level+1);
                $xml .= str_repeat("\t",$level)."&lt;/$key&gt;\n";
            }

        }
        else
        {
            if (trim($value)!='')
            {
                if (htmlspecialchars($value)!=$value)
                    $xml .= str_repeat("\t",$level)."&lt;$key&gt;"."&lt;![CDATA[$value]]&gt;&lt;/$key&gt;\n";
                else
                    $xml .= str_repeat("\t",$level)."&lt;$key&gt;$value&lt;/$key&gt;\n";
            }
        }
    }

    if ($level==1)
        $xml .= "&lt;/data&gt;\n";
    
    return $xml;
}</pre></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note44"/>Note</h3><p>Have <a id="id727" class="indexterm"/>questions about the methods we're extending from <code class="literal">CController</code>? Be sure to take a look at the guide for this<a id="id728" class="indexterm"/> class at <a class="ulink" href="http://www.yiiframework.com/doc/api/1.1/CController">http://www.yiiframework.com/doc/api/1.1/CController</a>.</p></div></div></li></ol></div></div><div class="section" title="Calling actions in a RESTful way"><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec137"/>Calling actions in a RESTful way</h2></div></div></div><p>In a RESTful API, a single endpoint might respond differently to different kinds of HTTP requests. For instance, the <code class="literal">/api/user/index</code> endpoint might return a list of users or a particular<a id="id729" class="indexterm"/> user if a <code class="literal">GET</code> request is called with an ID parameter. However, if a <code class="literal">POST</code> request is called, a new user will either be created or modified. If a <code class="literal">DELETE</code> request was called to that endpoint with an ID, it would delete a <a id="id730" class="indexterm"/>user from the system.</p><p>To emulate this behavior in Yii, we need to overload the <code class="literal">createAction()</code> method of our <code class="literal">ApiController</code> so that it calls the correct action. In our controllers, this will allow us to separate functionality by the request type. Internally, our API will be calling actions in the format of <code class="literal">action&lt;Name&gt;&lt;Method&gt;</code>, with the default <code class="literal">GET</code> action hitting the raw action method (for example, <code class="literal">actionIndex()</code>, <code class="literal">actionIndexPost()</code> and <code class="literal">actionIndexDelete()</code>). This method will also call the <code class="literal">ApiInlineAction</code> class that we defined<a id="id731" class="indexterm"/> earlier instead of <code class="literal">CInlineAction</code>:</p><div class="informalexample"><pre class="programlisting">public function createAction($actionID)
{
    if($actionID==='')
        $actionID=$this-&gt;defaultAction;

    if (Yii::app()-&gt;request-&gt;getRequestType() != 'GET' &amp;&amp; $actionID != 'error')
        $actionID .= Yii::app()-&gt;request-&gt;getRequestType();

    if(method_exists($this,'action'.$actionID) &amp;&amp; strcasecmp($actionID,'s')) // we have actions method
        return new ApiInlineAction($this,$actionID);
    else
    {
        $action=$this-&gt;createActionFromMap($this-&gt;actions(),$actionID,$actionID);
        if($action!==null &amp;&amp; !method_exists($action,'run'))
            throw new CException(Yii::t('yii', 'Action class {class} must implement the "run" method.', array('{class}'=&gt;get_class($action))));
        return $action;
    }
}</pre></div></div><div class="section" title="Authenticating users"><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec138"/>Authenticating users</h2></div></div></div><p>Since RESTful APIs don't pass the cookie information between the API and the client, we need to<a id="id732" class="indexterm"/> make several modifications to our controller <a id="id733" class="indexterm"/>in order to separate authenticated users from unauthenticated users. For this, we'll overload <code class="literal">CAccessControlFilter</code> so that it operates against the user information that we'll populate in our controller:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">We'll begin by adding a few more public properties to our <code class="literal">ApiController</code>. The <code class="literal">xauth</code> attributes will store the <code class="literal">X-Auth-Token</code> and <code class="literal">X-Auth-Email</code> headers that we'll send for authentication, and the <code class="literal">user</code> property will store the raw user model for the authenticated user. We'll pass this information down to the child controllers for authentication and also to our overloaded <code class="literal">CAccessControlFilter</code> class:<div class="informalexample"><pre class="programlisting">public $xauthtoken = null;
public $xauthemail = null;
public $user = null;</pre></div></li><li class="listitem">Next, we'll load our <code class="literal">accessControl</code> filter. We'll also define another filter called <code class="literal">CHttpCacheFilter</code> that will tell clients not to cache the responses our <a id="id734" class="indexterm"/>API returns:<div class="informalexample"><pre class="programlisting">public function filters()
{
    return array(
        array(
            'CHttpCacheFilter',
            'cacheControl'=&gt;'public, no-store, no-cache, must-revalidate',
        ),
        'accessControl'
    );
}</pre></div></li><li class="listitem">We'll then <a id="id735" class="indexterm"/>define our base <code class="literal">accessRules()</code>that will deny access to any method other than our error action:<div class="informalexample"><pre class="programlisting">public function accessRules()
{   
    return array(
        array('allow',
            'actions' =&gt; array('error')
        ),
        array('deny')
    );
}</pre></div></li><li class="listitem">Next, we'll need to handle the authentication in our controller before passing it to <code class="literal">CInlineActionFilter</code>. We'll begin by overloading the <code class="literal">filterAccessControl()</code> method in our <code class="literal">ApiController</code>:<div class="informalexample"><pre class="programlisting">public function filterAccessControl($filterChain) {}</pre></div></li><li class="listitem">We'll then retrieve the <code class="literal">X-Auth-Token</code> and <code class="literal">X-Auth-Email</code> headers:<div class="informalexample"><pre class="programlisting">$this-&gt;xauthtoken = isset($_SERVER['HTTP_X_AUTH_TOKEN']) ? $_SERVER['HTTP_X_AUTH_TOKEN'] : NULL;
$this-&gt;xauthemail =isset($_SERVER['HTTP_X_AUTH_EMAIL']) ? $_SERVER['HTTP_X_AUTH_EMAIL'] : NULL;</pre></div></li><li class="listitem">Now we'll validate these against our database. For this, we'll look up a user in our database with the <code class="literal">X-Auth-Email</code> address; if this is found, we'll then check for the<a id="id736" class="indexterm"/> API token that we'll generate<a id="id737" class="indexterm"/> later on in the <code class="literal">user_metadata</code> table. If an API token is found, we'll populate <code class="literal">$this-&gt;user</code> with the raw user model:<div class="informalexample"><pre class="programlisting">if ($this-&gt;xauthemail != NULL)
{
    // If a user exists with that email address
    $user = User::model()-&gt;findByAttributes(array('email' =&gt; $this-&gt;xauthemail));
    if ($user != NULL)
    {
        $q = new CDbCriteria();
        $q-&gt;addCondition('t.key LIKE :key');
        $q-&gt;addCondition('value = :value');
        $q-&gt;addCondition('user_id = :user_id');
        $q-&gt;params = array(
            ':user_id' =&gt; $user-&gt;id,
            ':value' =&gt; $this-&gt;xauthtoken,
            ':key' =&gt; 'api_key'
        );

        $meta = UserMetadata::model()-&gt;find($q);

        // And they have an active XAuthToken, set $this-&gt;user = the User object
        if ($meta != NULL)
            $this-&gt;user = $user;
    }
}</pre></div></li><li class="listitem">Finally, we'll call our custom <code class="literal">CAccessControlFilter</code> class, pass the user to it, set rules, and call the filter:<div class="informalexample"><pre class="programlisting">$filter=new ApiAccessControlFilter;
$filter-&gt;user = $this-&gt;user;
$filter-&gt;setRules($this-&gt;accessRules());
$filter-&gt;filter($filterChain);</pre></div></li></ol></div><div class="section" title="Overloading CAccessControlFilter"><div class="titlepage"><div><div><h3 class="title"><a id="ch08lvl3sec40"/>Overloading CAccessControlFilter</h3></div></div></div><p>We need <a id="id738" class="indexterm"/>to create a new class<a id="id739" class="indexterm"/> called the <code class="literal">ApiAccessControl</code> filter within <code class="literal">protected/modules/api/components/</code> so that we can continue using the <code class="literal">accessRules</code> array in our controllers. This class will operate on the <code class="literal">user</code> object we passed to it from our controller and will make our <code class="literal">accessRules</code> array work with our new user object:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">After creating the <code class="literal">ApiAccessControlFilter.php</code> file, define it as follows:<div class="informalexample"><pre class="programlisting">&lt;?php class ApiAccessControlFilter extends CAccessControlFilter {}</pre></div></li><li class="listitem">We'll then need to add the <code class="literal">user</code> attribute to store the user as passed from our controller and redefine the <code class="literal">private $_rules</code> property that the parent class operates on:<div class="informalexample"><pre class="programlisting">public $user;
private $_rules;</pre></div></li><li class="listitem">Since the <code class="literal">$_rules</code> array in the parent class is private, we'll need to redefine the getter and setter for the rules array as well as the <code class="literal">preFilter()</code> method that uses the private property. We'll start with the <code class="literal">preFilter()</code> method:<div class="informalexample"><pre class="programlisting">protected function preFilter($filterChain)
{
    $app=Yii::app();
    $request=$app-&gt;getRequest();
    $user=$this-&gt;user;
    $verb=$request-&gt;getRequestType();
    $ip=$request-&gt;getUserHostAddress();

    foreach($this-&gt;getRules() as $rule)
    {
        if(($allow=$rule-&gt;isUserAllowed($user,$filterChain-&gt;controller,$filterChain-&gt;action,$ip,$verb))&gt;0) // allowed
            break;
        elseif($allow&lt;0) // denied
        {
            if(isset($rule-&gt;deniedCallback))
                call_user_func($rule-&gt;deniedCallback, $rule);
            else
                $this-&gt;accessDenied($user,$this-&gt;resolveErrorMessage($rule));
            return false;
        }
    }

    return true;
}</pre></div></li><li class="listitem">We'll <a id="id740" class="indexterm"/>then create <a id="id741" class="indexterm"/>both a getter and setter for our <code class="literal">rules</code> array:<div class="informalexample"><pre class="programlisting">public function getRules()
{
    return $this-&gt;_rules;
}

public function setRules($rules)
{
    foreach($rules as $rule)
    {
        if(is_array($rule) &amp;&amp; isset($rule[0]))
        {
            $r=new ApiAccessRule;
            $r-&gt;allow=$rule[0]==='allow';
            foreach(array_slice($rule,1) as $name=&gt;$value)
            {
                if($name==='expression' || $name==='roles' || $name==='message' || $name==='deniedCallback')
                    $r-&gt;$name=$value;
                else
                    $r-&gt;$name=array_map('strtolower',$value);
            }
            $this-&gt;_rules[]=$r;
        }
    }
}</pre></div></li><li class="listitem">At this time, we'll also want to redefine the <code class="literal">accessDenied</code> behavior that gets called when a user doesn't have access to a particular action. Here, we'll simply call the <code class="literal">renderOutput()</code> method of <code class="literal">ApiController</code>:<div class="informalexample"><pre class="programlisting">protected function accessDenied($user,$message=NULL)
{
    http_response_code(403);
    Yii::app()-&gt;controller-&gt;renderOutput(array(), 403, $message);
}</pre></div></li><li class="listitem">To<a id="id742" class="indexterm"/> follow the <a id="id743" class="indexterm"/>same convention as Yii, we will also add a second class, <code class="literal">ApiAccessRule</code>, that extends <code class="literal">CAccessRule</code> inside the same file. This is just a simple modification that ensures that our information is loaded instead of the information that is passed to <code class="literal">CAccessRule</code>:<div class="informalexample"><pre class="programlisting">class ApiAccessRule extends CAccessRule
{
    public function isUserAllowed($user,$controller,$action,$ip,$verb)
    {
        if($this-&gt;isActionMatched($action)
            &amp;&amp; $this-&gt;isIpMatched($ip)
            &amp;&amp; $this-&gt;isVerbMatched($verb)
            &amp;&amp; $this-&gt;isControllerMatched($controller)
            &amp;&amp; $this-&gt;isExpressionMatched($user))
            return $this-&gt;allow ? 1 : -1;
        else
            return 0;
    }
}</pre></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note45"/>Note</h3><p>Want to learn more about <code class="literal">CAccessControlFilter</code>? Take a look at the class <a id="id744" class="indexterm"/>documentation at <a class="ulink" href="http://www.yiiframework.com/doc/api/1.1/CAccessControlFilter">http://www.yiiframework.com/doc/api/1.1/CAccessControlFilter</a>.</p></div></div></li></ol></div></div></div><div class="section" title="Processing the incoming data"><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec139"/>Processing the incoming data</h2></div></div></div><p>Since<a id="id745" class="indexterm"/> our RESTful API will be returning JSON, it's only appropriate that it should accept JSON as well. For convenience, we'll configure our API to accept <code class="literal">application/x-www-form-urlencoded</code> from the data (data sent from a form), so that our web clients can simply POST directly to our API without having to perform data conversion.</p><p>To make our API <a id="id746" class="indexterm"/>accept this data, we'll overload the <code class="literal">beforeAction()</code> method in order to take the raw JSON body, if supplied, and populate it into our <code class="literal">$_POST</code> data if it is a valid JSON request. If invalid JSON is sent, we'll return an HTTP 400 error, indicating that something was wrong with the request. The error will hit our <code class="literal">actionError()</code> method and bubble up to our <code class="literal">runAction()</code> method, which will finally display the error:</p><div class="informalexample"><pre class="programlisting">public function beforeAction($action)
{
    // If content was sent as application/x-www-form-urlencoded, use it. Otherwise, assume raw JSON was sent and convert it into
    // the $_POST variable for ease of use
    if (Yii::app()-&gt;request-&gt;rawBody != "" &amp;&amp; empty($_POST))
    {
        // IF the rawBody is malformed, throw an HTTP 500 error. Use json_encode so that we can get json_last_error
        $_POST = json_decode(Yii::app()-&gt;request-&gt;rawBody);
        if (json_last_error() != JSON_ERROR_NONE)
        {
            header('HTTP/1.1 400 Bad Request');
            $this-&gt;status = 400;
            $this-&gt;message = 'Request payload not properly formed JSON.';
            return null;
        }

        $_POST = CJSON::decode(Yii::app()-&gt;request-&gt;rawBody);
    }

    return parent::beforeAction($action);
}</pre></div></div><div class="section" title="Handling errors"><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec140"/>Handling errors</h2></div></div></div><p>Before<a id="id747" class="indexterm"/> moving on to creating controllers, we need to <a id="id748" class="indexterm"/>make sure that our parent class can handle any errors that get sent to it. There are two types of errors we'll want to handle—the first being errors that Yii encounters either internally, or through exceptions we call, and the second being errors that we want to present to the user but that we don't want to send through an exception.</p><div class="section" title="Exception handling"><div class="titlepage"><div><div><h3 class="title"><a id="ch08lvl3sec41"/>Exception handling</h3></div></div></div><p>To handle <a id="id749" class="indexterm"/>exceptions that either we throw or that Yii throws <a id="id750" class="indexterm"/>internally, we'll define the base <code class="literal">actionError()</code> method as follows. The data set here will simply populate the <code class="literal">runAction()</code> method that we overloaded earlier and will ensure that the appropriate error is displayed in the correct format:</p><div class="informalexample"><pre class="programlisting">public function actionError()
{
    if($error=Yii::app()-&gt;errorHandler-&gt;error)
    {
        $this-&gt;status = $error['code'];
        $this-&gt;message = $error['message'];
    }
}</pre></div></div><div class="section" title="Custom error handling"><div class="titlepage"><div><div><h3 class="title"><a id="ch08lvl3sec42"/>Custom error handling</h3></div></div></div><p>Within <a id="id751" class="indexterm"/>our controllers, there will be situations<a id="id752" class="indexterm"/> that we'll want to return an error to the user without triggering an exception. A great example of this is a model validation error. We want to inform the user that something went wrong, but we want to return from the error gracefully without stalling our application. For this, we'll create a <code class="literal">returnError()</code> method that we'll call from our controller that will populate back up to the <code class="literal">runAction()</code> method we defined earlier:</p><div class="informalexample"><pre class="programlisting">public function returnError($status, $message = NULL, $response)
{
    header('HTTP/1.1 '. $status);
    $this-&gt;status = $status;

    if ($message === NULL)
        $this-&gt;message = 'Failed to set model attributes.';
    else
        $this-&gt;message = $message;

    return $response;
}</pre></div></div></div><div class="section" title="Testing whether everything works"><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec141"/>Testing whether everything works</h2></div></div></div><p>Before we<a id="id753" class="indexterm"/> start creating other controllers and actions, let's create a very simple controller in order to verify that our API is working the way we want it to. For this, let's create a class called <code class="literal">DefaultController</code> in <code class="literal">protected/modules/api/controllers</code> with the following setup:</p><div class="informalexample"><pre class="programlisting">class DefaultController extends ApiController
{
    public function accessRules()
    {
        return array(
            array('allow',
                'actions' =&gt; array('index', 'error')
            ),
            array('deny')
        );
    }

    public function actionIndex()
    {
        return "test";
    }
}</pre></div><p>If your API is set up correctly, you should be able to open your browser to <code class="literal">http://chapter8.example.com/api</code> and see the following displayed:</p><div class="informalexample"><pre class="programlisting">{
    "status":200,
    "message":"Your request was successfully fulfilled",
    "response":"test"
}</pre></div><p>As you can see, whatever data we returned from our action is now in the response attribute of our JSON object. Additionally, if we want to render XML instead of JSON, we can add the <code class="literal">format=xml GET</code> parameter to the <code class="literal">http://chapter8.example.com/api?format=xml</code> URL as follows:</p><div class="informalexample"><pre class="programlisting">&lt;data&gt;
    &lt;status&gt;200&lt;/status&gt;
    &lt;message&gt;Your request was successfully fulfilled&lt;/message&gt;
    &lt;response&gt;test&lt;/response&gt;
&lt;/data&gt;</pre></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note46"/>Note</h3><p>Most load <a id="id754" class="indexterm"/>balancers and health-check services verify that endpoints return a <code class="literal">200</code> status. For this reason, it's recommended that you simply return true from this default method if you're going to add a health check to your API.</p></div></div></div></div>
<div class="section" title="Authenticating users"><div class="titlepage"><div><div><h1 class="title"><a id="ch08lvl1sec73"/>Authenticating users</h1></div></div></div><p>Now that <a id="id755" class="indexterm"/>our API is functional, let's add the ability for users to be authenticated against our API. For this, we're going to create an endpoint that accepts the following JSON request body:</p><div class="informalexample"><pre class="programlisting">{
   "email": "user@example.com",
   "password": "&lt;example_password&gt;"
}</pre></div><p>With this information, the API will be authenticated using <code class="literal">LoginForm</code>, which we worked on in previous chapters. If the user is valid, we'll generate a new API token that will be stored in the <code class="literal">user_metadata</code> table. This token will be returned to the client who is making the request and will be used to authenticate for all future requests:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">To get started, create a new controller in <code class="literal">protected/modules/api/controllers/</code> called <code class="literal">UserController.php</code> with the following definition:<div class="informalexample"><pre class="programlisting">&lt;?php class UserController extends ApiController {}</pre></div></li><li class="listitem">Next, we'll need to define a default set of access rules so as to allow our authentication method to be used without authentication:<div class="informalexample"><pre class="programlisting">public function accessRules()
{
    return array(
       array('allow',
          'actions' =&gt; array('tokenPost'),
       ),
        array('deny')
    );
}</pre></div></li><li class="listitem">Since this is a <code class="literal">POST</code> endpoint, we'll define our new method as follows:<div class="informalexample"><pre class="programlisting">public function actionTokenPost() {}</pre></div></li><li class="listitem">We'll then <a id="id756" class="indexterm"/>instantiate a new instance of <code class="literal">LoginForm</code> and retrieve our e-mail address and password from the JSON body. Remember that, in our <code class="literal">ApiController</code> class, we transformed the raw JSON body directly into our <code class="literal">$_POST</code> parameters in order to make things easier to work with:<div class="informalexample"><pre class="programlisting">$model = new LoginForm;
$model-&gt;username = Yii::app()-&gt;request-&gt;getParam('email', NULL);
$model-&gt;password = Yii::app()-&gt;request-&gt;getParam('password', NULL);</pre></div></li><li class="listitem">After retrieving this information, we'll attempt to log in:<div class="informalexample"><pre class="programlisting">if ($model-&gt;login()) {}</pre></div></li><li class="listitem">If successful, we'll load the user information:<div class="informalexample"><pre class="programlisting">$user = User::model()-&gt;findByAttributes(array('email' =&gt; $model-&gt;username));</pre></div></li><li class="listitem">Try to either update an existing API token, or generate a new one:<div class="informalexample"><pre class="programlisting">$token = UserMetadata::model()-&gt;findByAttributes(array(
    'user_id' =&gt; $user-&gt;id,
    'key' =&gt; 'api_key'
));

if ($token == NULL)
    $token = new UserMetadata;

$token-&gt;attributes = array(
   'user_id' =&gt; $user-&gt;id,
   'key' =&gt; 'api_key',
   'value' =&gt; $user-&gt;generateActivationKey() // Reuse this method for cryptlib
);</pre></div></li><li class="listitem">If we are able to save the token to the database, we'll return it:<div class="informalexample"><pre class="programlisting">if ($token-&gt;save())
    return $token-&gt;value;</pre></div></li><li class="listitem">Outside our <code class="literal">if ($model-&gt;login())</code> condition, we'll simply return an error to the user, indicating that something went wrong. Since this is an authentication method, we don't want to give away too much information in order to prevent people from attempting to brute-force our API endpoint:<div class="informalexample"><pre class="programlisting">return $this-&gt;returnError(401, $model-&gt;getErrors(), null);</pre></div></li></ol></div><div class="section" title="Testing the authentication"><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec142"/>Testing the authentication</h2></div></div></div><p>Before<a id="id757" class="indexterm"/> proceeding, let's make sure that our authentication endpoint works. To test this, we'll be using a Google Chrome extension called <span class="strong"><strong>RestConsole</strong></span> and that<a id="id758" class="indexterm"/> can be downloaded from the Chrome App <a id="id759" class="indexterm"/>Store at <a class="ulink" href="https://chrome.google.com/webstore/detail/rest-console/cokgbflfommojglbmbpenpphppikmonn?hl=en">https://chrome.google.com/webstore/detail/rest-console/cokgbflfommojglbmbpenpphppikmonn?hl=en</a>. If you do not already have Google Chrome installed, you <a id="id760" class="indexterm"/>can download it from <a class="ulink" href="https://www.google.com/intl/en-US/chrome/browser/">https://www.google.com/intl/en-US/chrome/browser/</a>. After installing, navigate to the RestConsole download page and install the plugin. Once it's installed, you can click on the <span class="strong"><strong>Launch App</strong></span> button in the Chrome App Store to load RestConsole. Once it's loaded, you'll see several different sections:</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note47"/>Note</h3><p>A tool such as RestConsole will allow us to quickly test our API endpoints from a nice GUI interface. If you prefer, you can test the endpoints directly from your command line using the cURL utility, available through most package managers.</p></div></div><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">In the <span class="strong"><strong>Target</strong></span> section, fill out the form as shown in the following screenshot. Be sure to adjust to your local environment. The key detail in this section is the <span class="strong"><strong>Request URI</strong></span> field.<div class="mediaobject"><img src="graphics/7734OS_08_02.jpg" alt="Testing the authentication"/></div></li><li class="listitem">Then, scroll <a id="id761" class="indexterm"/>down to the <span class="strong"><strong>Body</strong></span> section, and fill out the section as follows:<div class="mediaobject"><img src="graphics/7734OS_08_03.jpg" alt="Testing the authentication"/></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note48"/>Note</h3><p>The key part of this section is the <span class="strong"><strong>Request Payload</strong></span> section. This is where you'll add the raw JSON body that will be sent to the server. In this example, we're using the credentials that we established in <a class="link" href="ch07.html" title="Chapter 7. Creating a Management Module for the CMS">Chapter 7</a>, <span class="emphasis"><em>Creating a Management Module for the CMS</em></span>.</p></div></div><div class="informalexample"><pre class="programlisting">{
    "email": "user1@example.com",
    "password": "test"
}</pre></div><p>If you've changed these credentials since then, be sure to change them in your JSON body.</p></li><li class="listitem">Finally, click<a id="id762" class="indexterm"/> on the <span class="strong"><strong>Post</strong></span> button at the bottom of the page. This will send the request to the server. If successful, you'll receive an HTTP 200 status code in response with your API token in the response body:<div class="mediaobject"><img src="graphics/7734OS_08_04.jpg" alt="Testing the authentication"/></div><div class="informalexample"><pre class="programlisting">{
    "status": 200,
    "message": "Your request was successfully fulfilled",
    "response": "aRwfTYyKlMm2SDaK"
}</pre></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note49"/>Note</h3><p>Your response body will differ slightly as the API token is randomly generated on each authentication request.</p></div></div></li></ol></div></div><div class="section" title="Sending authenticated requests"><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec143"/>Sending authenticated requests</h2></div></div></div><p>Now that we can authenticate against our API, let's make sure that we can send authenticated<a id="id763" class="indexterm"/> requests. For this, we'll be creating an API endpoint in order to deauthenticate our user. This will accept the user's credentials and then delete the API token from the database in order to prevent future use:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Creating this endpoint consists of two parts. First, we need to add an item to our <code class="literal">accessRules</code> array that allows authenticated users to send a <code class="literal">DELETE</code> request to the token endpoint. We'll do this by adding the following to our <code class="literal">accessRules</code> array:<div class="informalexample"><pre class="programlisting">array('allow',
   'actions' =&gt; array('tokenDelete'),
   'expression' =&gt; '$user!=NULL'
)</pre></div></li><li class="listitem">Then we'll add the delete method for our token endpoint that will be available over the HTTP <code class="literal">DELETE</code> method:<div class="informalexample"><pre class="programlisting">public function actionTokenDelete()
{
   $model = UserMetadata::model()-&gt;findByAttributes(array('user_id' =&gt; $this-&gt;user-&gt;id, 'value' =&gt; $this-&gt;xauthtoken));

   if ($model === NULL)
      throw new CHttpException(500, 'An unexpected error occured while deleting the token. Please re-generate a new token for subsequent requests.');
   return $model-&gt;delete();
}</pre></div></li></ol></div><p>Now<a id="id764" class="indexterm"/> that are endpoint is set up, return to RestConsole, remove the request body, and add the following custom headers to the <span class="strong"><strong>Custom Headers</strong></span> section below the request body, as shown in the following screenshot:</p><div class="informalexample"><pre class="programlisting">X-Auth-Email: user1@example.com
X-Auth-Token: aRwfTYyKlMm2SDaK</pre></div><div class="mediaobject"><img src="graphics/7734OS_08_05.jpg" alt="Sending authenticated requests"/></div><p>Then, hit the <span class="strong"><strong>Delete</strong></span> button at the bottom of the page to send a <code class="literal">DELETE</code> request. You should<a id="id765" class="indexterm"/> receive the following response:</p><div class="informalexample"><pre class="programlisting">{
    "status": 200,
    "message": "Your request was successfully fulfilled",
    "response": true
}</pre></div><p>We've now successfully tested user authentication and added the ability to deauthenticate from our API. Notice that, if you try to submit a <code class="literal">DELETE</code> request again, our <code class="literal">acccessRules</code> array will kick in and will block the request for us, thus returning the following response:</p><div class="informalexample"><pre class="programlisting">{
    "status": 403,
    "message": "You are not authorized to perform this action.",
    "response": []
}</pre></div></div></div>
<div class="section" title="Implementing CRUD actions"><div class="titlepage"><div><div><h1 class="title"><a id="ch08lvl1sec74"/>Implementing CRUD actions</h1></div></div></div><p>Now that <a id="id766" class="indexterm"/>we can authenticate and work with our API, we can work on implementing the four basic CRUD actions in a RESTful manner. The RESTful actions boil down to three main HTTP request types—<code class="literal">GET</code>, <code class="literal">POST</code>, and <code class="literal">DELETE</code>. We'll <a id="id767" class="indexterm"/>implement each one for our users.</p><p>The first method we need to implement is our <code class="literal">loadModel()</code> method. This method will be loaded in <a id="id768" class="indexterm"/>our User model and will throw the appropriate errors if something goes wrong:</p><div class="informalexample"><pre class="programlisting">private function loadModel($id=NULL)
{
    if ($id == NULL)
        throw new CHttpException(400, 'Missing ID');

    $model = User::model()-&gt;findByPk($id);

    if ($model == NULL)
        throw new CHttpException(400, 'User not found');

    return $model;
}</pre></div><div class="section" title="Deleting users"><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec144"/>Deleting users</h2></div></div></div><p>The first <a id="id769" class="indexterm"/>method that we'll implement is our <code class="literal">DELETE</code> method. Remember that, for each method, we'll be hitting a single endpoint, <code class="literal">/api/user/index</code> , with different HTTP request types:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">The first change that we need to make is to our <code class="literal">accessRules</code>. We want only administrators to have the ability to delete a user. We'll do this by setting up an expression that checks whether the user is an admin:<div class="informalexample"><pre class="programlisting">array('allow',
    'actions' =&gt; array('indexDelete'),
    'expression' =&gt; '$user!=NULL&amp;&amp;$user-&gt;role-&gt;id==2'
)</pre></div></li><li class="listitem">Then, we'll implement the delete action. We want to make sure that users are not able to delete themselves:<div class="informalexample"><pre class="programlisting">public function actionIndexDelete($id=NULL)
{
    if ($id == $this-&gt;user-&gt;id)
         return $this-&gt;returnError(401, 'You cannot delete yourself', null);

     return $this-&gt;loadModel($id)-&gt;delete();
}</pre></div></li></ol></div><p>Sending a <a id="id770" class="indexterm"/>
<code class="literal">DELETE</code> request to <code class="literal">/api/user/index/id/&lt;user_id&gt;</code> will now delete a user with the given ID.</p></div><div class="section" title="Retrieving users"><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec145"/>Retrieving users</h2></div></div></div><p>The <a id="id771" class="indexterm"/>second method that we'll implement is a <code class="literal">GET</code> method<a id="id772" class="indexterm"/> that will either retrieve a single user if an ID is provided, or multiple users if a user is an administrator. In either case, we'll want to make sure that a user is authenticated:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">The first change, once again, will be to our <code class="literal">accessRules</code> array. We'll check to see whether a user is an admin, or whether the given ID belongs to the currently authenticated users:<div class="informalexample"><pre class="programlisting">array('allow',
    'actions' =&gt; array('index'),
    'expression' =&gt; '$user!=NULL&amp;&amp;($user-&gt;role-&gt;id==2||Yii::app()-&gt;request-&gt;getParam("id")==$user-&gt;id)'
)</pre></div></li><li class="listitem">We'll then set up a <code class="literal">GET</code> method in our controller. Remember, we set up our <code class="literal">createAction()</code> method in our <code class="literal">ApiController</code> class so that <code class="literal">GET</code> requests don't require the HTTP verb at the end of the method:<div class="informalexample"><pre class="programlisting">public function actionIndex($id=NULL) {}</pre></div></li><li class="listitem">Then, if an ID was provided, we'll simply load the requested user. If the user is not an admin and they requested another user, we'll throw an exception; otherwise, we'll return the appropriate data:<div class="informalexample"><pre class="programlisting">array('allow',
    'actions' =&gt; array('index', 'indexPost'),
    'expression' =&gt; '$user!=NULL&amp;&amp;($user-&gt;role-&gt;id==2||Yii::app()-&gt;request-&gt;getParam("id")==$user-&gt;id)'
if ($id !== NULL)
{
    if ($this-&gt;user-&gt;role-&gt;id != 2 &amp;&amp; $this-&gt;user-&gt;id != $id)
       throw new CHttpException(403, 'You do not have access to this resource');

    return $this-&gt;loadModel($id)-&gt;getApiAttributes(array('password'), array('role', 'metadata'));
}</pre></div><p>If you <a id="id773" class="indexterm"/>recall, we made changes to our <code class="literal">CMSActiveRecord</code> model in order to add a <code class="literal">getApiAttributes()</code> method. Calling this method now allows us to exclude certain elements that we don't want to send in the request, such as the user password. This also allows us to return metadata about the user, such as the role and any metadata associated with the user.</p></li><li class="listitem">Carrying on, if an ID was not specified, we'll make sure that the user is an admin:<div class="informalexample"><pre class="programlisting">if ($this-&gt;user-&gt;role-&gt;id != 2)
    throw new CHttpException(403, 'You do not have access to this resource');</pre></div></li><li class="listitem">If so, we'll load up a search instance of our model. This extends our endpoint to allow for dynamic searching:<div class="informalexample"><pre class="programlisting">$model = new User('search');
$model-&gt;unsetAttributes();  // clear any default values
if(isset($_GET['User']))
    $model-&gt;attributes = $_GET['User'];</pre></div></li><li class="listitem">To allow for pagination, we'll instance a copy of <code class="literal">CActiveDataProvider</code> from the <code class="literal">$model-&gt;search()</code> method and set the page variable to the <code class="literal">GET</code> parameter page. This will allow us to paginate through our users rather than dumping all of them in a single request:<div class="informalexample"><pre class="programlisting">$dataProvider = $model-&gt;search();
$dataProvider-&gt;pagination = array(
    'pageVar' =&gt; 'page'
);</pre></div></li><li class="listitem">To handle pagination, we'll simply continue to display results until no results are found. When no results are found, we'll throw an HTTP 404 error. This will allow for infinite scrolling on the client side and will let our clients know when to stop asking for data:<div class="informalexample"><pre class="programlisting">if ($dataProvider-&gt;totalItemCount == 0 || ($dataProvider-&gt;totalItemCount / ($dataProvider-&gt;itemCount * Yii::app()-&gt;request-&gt;getParam('page', 1))) &lt; 1)
    throw new CHttpException(404, 'No results found');</pre></div></li><li class="listitem">We'll then iterate through our <code class="literal">dataProvider</code> using the <code class="literal">getData()</code> method and <a id="id774" class="indexterm"/>generate an array of all the user objects in the current page:<div class="informalexample"><pre class="programlisting">$response = array();

foreach ($dataProvider-&gt;getData() as $user)
    $response[] = $user-&gt;getAPIAttributes(array('password'), array('role', 'metadata'));</pre></div></li><li class="listitem">Finally, we'll return the entire response:<div class="informalexample"><pre class="programlisting">return $response;</pre></div></li></ol></div><p>Now, make a few requests to the API endpoint in order to test everything out. You should be able to log in as an admin and view all users or any user. You should also be able to log in as a regular user and only retrieve information about yourself.</p></div><div class="section" title="Creating and updating users"><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec146"/>Creating and updating users</h2></div></div></div><p>The last<a id="id775" class="indexterm"/> endpoint we'll need to implement is a <code class="literal">POST</code> method <a id="id776" class="indexterm"/>that will serve as an endpoint to both creating <a id="id777" class="indexterm"/>and updating existing users:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">We'll begin by updating the <code class="literal">accessRules</code> array that we defined in the previous section in order to include <code class="literal">indexPost</code>:<div class="informalexample"><pre class="programlisting">array('allow',
    'actions' =&gt; array('index', 'indexPost'),
    'expression' =&gt; '$user!=NULL&amp;&amp;($user-&gt;role-&gt;id==2||Yii::app()-&gt;request-&gt;getParam("id")==$user-&gt;id)'
)</pre></div></li><li class="listitem">We'll then create a <code class="literal">POST</code> endpoint that will branch off into two separate methods—one that creates users and one that modifies users:<div class="informalexample"><pre class="programlisting">public function actionIndexPost($id=NULL)
{
    if ($id == NULL)
        return $this-&gt;createUser();
    else
        return $this-&gt;updateUser($id);
}</pre></div></li><li class="listitem">Since all the information for creating users will be coming from a normal <code class="literal">POST</code> response, all we need to do to create a new user is verify that they are an admin, instantiate a new User model, validate it, and save it. If, for any reason, we encounter an error (such as an invalidate attribute), we'll simply return the errors from <code class="literal">$model-&gt;getErrors()</code> in the JSON response:<div class="informalexample"><pre class="programlisting">private function createUser()
{
    if ($this-&gt;user-&gt;role-&gt;id != 2)
        throw new CHttpException(403, 'You do not have access to this resource');

    $model = new User;
    $model-&gt;attributes = $_POST;

    if ($model-&gt;save())
        return User::model()-&gt;findByPk($model-&gt;id)-&gt;getApiAttributes(array('password'), array('role', 'metadata'));
    else
        return $this-&gt;returnError(400, $model-&gt;getErrors(), null);
}</pre></div></li><li class="listitem">As it<a id="id778" class="indexterm"/> turns out, updating users is as simple as<a id="id779" class="indexterm"/> loading an existing User model and doing the same thing as creating a new user. The only difference in this endpoint is that we need to make sure that the user is either an admin, or that they are trying to modify their own data:<div class="informalexample"><pre class="programlisting">private function updateUser($id=NULL)
{
    if ($this-&gt;user-&gt;role-&gt;id != 2 &amp;&amp; $this-&gt;user-&gt;id != $id)
        throw new CHttpException(403, 'You do not have permission to modify this user');

    $model = $this-&gt;loadModel($id);

    $model-&gt;attributes = $_POST;

    if ($model-&gt;save())
         return User::model()-&gt;findByPk($model-&gt;id)-&gt;getApiAttributes(array('password'), array('role', 'metadata'));
    else
        return $this-&gt;returnError(400, $model-&gt;getErrors(), null);
}</pre></div></li></ol></div><p>At this point, go ahead and verify that you can create new users as an admin and that existing users can modify their own data.</p></div><div class="section" title="Implementing other controller actions from the main application"><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec147"/>Implementing other controller actions from the main application</h2></div></div></div><p>At this point, we've created the basic CRUD interface for our User data model. While this takes care of a lot of the administrative tasks, there are a couple of other methods that we can move<a id="id780" class="indexterm"/> from the frontend of our application to our API. These methods include actions such as registration, account verification, and password reset requests. Moving these methods from our frontend and into our API immediately makes this functionality available to any consumer of our API, which makes our API more valuable to both web and native clients.</p><p>For example, we can easily adapt our registration action from our frontend to our API by simply replacing the render actions with either a Boolean value indicating that the registration was successful, or a list of errors generated by the model. Because all of our validation rules and verification checks are performed in the model, adapting the action is fairly simple, as shown:</p><div class="informalexample"><pre class="programlisting">public function actionRegisterPost()
{
    $form = new RegistrationForm;
    $form-&gt;attributes = $_POST;

    if ($form-&gt;save())
        return true;
    else
        return $this-&gt;returnError(400, $form-&gt;getErrors(), null);
}</pre></div><p>Go ahead and try implementing the other actions from our frontend controller, such as <code class="literal">actionVerifyPost</code>, <code class="literal">actionActivate</code>, <code class="literal">actionForgotPost</code>, and <code class="literal">actionResetPasswordPost</code>.</p></div><div class="section" title="Implementing categories and content API controllers"><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec148"/>Implementing categories and content API controllers</h2></div></div></div><p>Our<a id="id781" class="indexterm"/> CMS is made up of more than user-related <a id="id782" class="indexterm"/>actions—we also have to manage content and <a id="id783" class="indexterm"/>categories. Once again, moving this<a id="id784" class="indexterm"/> functionality from our dashboard controllers to our API is fairly simple. We simply strip out the view-related functionality and return either Boolean values, or errors generated from the model. In the case of our <code class="literal">GET</code> method, we simply add in some pagination using the already provided pagination functionality of <code class="literal">CActiveDataProvider</code> and return the relevant results. Both of these controllers will look nearly identical to our <code class="literal">UserController</code>, as they work in the same way except with different data models. Go ahead and try to complete these controllers on your own.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note50"/>Note</h3><p>Remember that a fully completed application is included with the project resources. If you get stuck, take a look at the resources folder.</p></div></div></div><div class="section" title="Documenting our API"><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec149"/>Documenting our API</h2></div></div></div><p>While our <a id="id785" class="indexterm"/>API can be fun to work with and easy to integrate with, it means nothing to developers who want to work with our API if the available endpoints, details, and examples aren't documented clearly. Before sharing your API with the world, be sure to document what endpoints clients can access. It's also a good idea to thoroughly document what users need to do in order to authenticate against the API. Generally, this is done by providing detailed example requests and detailed example responses.</p></div></div>
<div class="section" title="Summary"><div class="titlepage"><div><div><h1 class="title"><a id="ch08lvl1sec75"/>Summary</h1></div></div></div><p>As shown throughout this book, the Yii framework is an extremely powerful, flexible, and easy PHP framework to work with. In this chapter, we completely overhauled how the Yii framework handles user authentication through JSON requests and adapts it to return both JSON and XML document types for an API that can be consumed by both web and native applications. In this chapter, we also covered what changes we needed to make in order to migrate functionality that was previously designed to be rendered directly to the client to our API to be rendered as JSON or XML. Finally, we adapted our API to respond to different types of HTTP requests on the same endpoint, allowing us to make a RESTful JSON API that is well documented.</p><p>Thank you for reading this book. Throughout this book, we've shown countless examples of how powerful and flexible Yii is. From working with third-party APIs to performing database-agnostic migrations and all the way to developing feature-complete applications complete with an API, the Yii framework enables us to quickly work, develop, and adapt our code to meet our objectives and end goals in a timely manner. I hope that you found the information contained within this book informative, useful, and fun. I also hope that you've learned how to use the Yii framework to do more than just create simple web applications.</p><p>On the about page of the Yii framework, Yii is described as an acronym for "Yes It Is" that answers some of the most basic questions asked about Yii. Is Yii fast? Is Yii secure? Is Yii professional? Is Yii right for your next project? I hope this book has shown you that the answer to those questions is a simple "Yes, it is".</p></div></body></html>