- en: Chapter 4. Handling Data in Phalcon
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第四章：在Phalcon中处理数据
- en: Unless you are building an application that retrieves all of its data via APIs,
    you are most likely going to need a database in the application. Phalcon gives
    you a few ways to access data from PHP. In the previous chapter, we didn't interact
    directly with our MySQL database. We could create blog posts and store them in
    our database, but Phalcon models did all of the dirty work for us. All we did
    was add the database connection details to our configuration file.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 除非你正在构建一个通过API检索所有数据的程序，否则你很可能需要在应用程序中有一个数据库。Phalcon为你提供了几种从PHP访问数据的方法。在前一章中，我们没有直接与我们的MySQL数据库交互。我们可以创建博客文章并将它们存储在我们的数据库中，但Phalcon模型为我们做了所有的脏活。我们所做的只是将数据库连接详情添加到我们的配置文件中。
- en: There are a few more features our models can handle before we have to start
    using more of the available Phalcon features. But even the simplest application
    will grow to the point where unique database queries come into play. However,
    databases are not the only way to handle data in your application.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始使用更多可用的Phalcon功能之前，我们的模型可以处理一些更多功能。但是，即使是最简单的应用程序也会发展到需要独特的数据库查询的程度。然而，数据库并不是在应用程序中处理数据的唯一方式。
- en: 'In this chapter, you will learn the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你将学习以下主题：
- en: How to use the more advanced features of Phalcon models
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何使用Phalcon模型的更高级功能
- en: How to store session data in a Phalcon application
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何在Phalcon应用程序中存储会话数据
- en: How to filter and sanitize our data
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何过滤和清理我们的数据
- en: How to replace our MySQL database with another database system
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何将我们的MySQL数据库替换为另一个数据库系统
- en: How to access databases with Phalcon Query Language (PHQL)
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何使用Phalcon查询语言（PHQL）访问数据库
- en: How to use Phalcon's Object-Document Mapper (ODM)
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何使用Phalcon的对象-文档映射器（ODM）
- en: How to handle database migrations
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何处理数据库迁移
- en: Adding models
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加模型
- en: Currently, our blog application doesn't do much. We can create and view posts,
    but that's about it. We need to think about what other tables we need in our blog.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，我们的博客应用程序并没有做什么。我们可以创建和查看帖子，但仅此而已。我们需要考虑在我们的博客中还需要哪些其他表。
- en: Creating the database tables
  id: totrans-13
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建数据库表
- en: 'We will have users, and each user will be able to write multiple posts. So,
    we need a `users` table, and we need to add a `users_id` field to our `posts`
    table so that each post is related to a user. The following is the SQL code for
    our `users` table:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将会有用户，并且每个用户都将能够写多篇帖子。因此，我们需要一个`users`表，并且我们需要在我们的`posts`表中添加一个`users_id`字段，以便每篇帖子都与一个用户相关联。以下是我们`users`表的SQL代码：
- en: '[PRE0]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Run this SQL snippet on your MySQL database. If you need help using `phpMyAdmin`,
    refer to [Chapter 3](ch03.html "Chapter 3. Using Phalcon Models, Views, and Controllers"),
    *Using Phalcon Models, Views, and Controllers*, for how to execute this code.
    Now, you have a table where you can store a minimal amount of data about your
    users, including their chosen username and password, their name, and their e-mail
    address. We create a unique key on the `username` column because we don't want
    two users to have the same username.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的MySQL数据库上运行这个SQL片段。如果你需要使用`phpMyAdmin`的帮助，请参考[第三章](ch03.html "第三章：使用Phalcon模型、视图和控制器")，*使用Phalcon模型、视图和控制器*，了解如何执行此代码。现在，你有一个可以存储关于你的用户的最小数据的表，包括他们选择的用户名和密码、他们的姓名和他们的电子邮件地址。我们在`username`列上创建了一个唯一键，因为我们不希望有两个用户使用相同的用户名。
- en: 'Also, a blog is not really a blog without comments. We want visitors to be
    able to comment on our blog applications. The following is the SQL code that we
    need to run on our database to create a home for our comments:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，一个没有评论的博客实际上并不算是一个真正的博客。我们希望访客能够对我们的博客应用进行评论。以下是我们需要在数据库上运行的SQL代码，以创建我们的评论空间：
- en: '[PRE1]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: We need to relate each comment to a specific post, so we have a `post_id` field.
    To store the commenter's details, we have `name`, `email`, and `url`. We have
    a `submitted` date so that we can sort our comments. And, we have a `publish`
    field that we will set to `0` when a comment is submitted, and `1` when we approve
    the comment.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要将每个评论与特定的帖子相关联，所以我们有一个`post_id`字段。为了存储评论者的详细信息，我们有`name`、`email`和`url`。我们有一个`submitted`日期，这样我们就可以对评论进行排序。此外，我们有一个`publish`字段，当评论提交时我们将它设置为`0`，当我们批准评论时设置为`1`。
- en: 'We might possibly need to organize our posts. We have a few options for doing
    this. We could use categories, where each post must fit into a specific category.
    Our categories can have child categories, or we can use tags, where each tag can
    be freely applied to any post, and each post can have more than one tag. Or we
    can do both, like most blogging applications. For our application, we are going
    to use tags only for simplicity. Run the following SQL code to create the `tags`
    table:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可能需要组织我们的帖子。我们有几种选择来做这件事。我们可以使用分类，每个帖子都必须适合特定的分类。我们的分类可以有子分类，或者我们可以使用标签，每个标签可以自由地应用于任何帖子，每个帖子也可以有多个标签。或者我们可以两者都做，就像大多数博客应用一样。对于我们的应用，我们将为了简单起见只使用标签。运行以下SQL代码来创建`tags`表：
- en: '[PRE2]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'There is not much to this table, just an `id` and `tag` column. That''s because
    we have to use an intermediate table to relate our `posts` table to our `tags`
    table due to the many-to-many relationship between posts and tags. However, we
    do want each tag to be unique, so we make the `tag` column a unique key. We are
    going to call this table `post_tags`, and the following is the SQL code you need
    to run to create it:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 这个表没有太多内容，只有一个`id`和`tag`列。这是因为由于帖子与标签之间存在多对多关系，我们必须使用一个中间表来将我们的`posts`表与`tags`表相关联。然而，我们确实希望每个标签都是唯一的，所以我们把`tag`列设为唯一键。我们将把这个表称为`post_tags`，以下是你需要运行的SQL代码来创建它：
- en: '[PRE3]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: This is just a table of IDs. A record in this table will have its own unique
    ID, a post ID, and a tag ID.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 这只是一个ID表。这个表中的每条记录都将有一个唯一的ID，一个帖子ID和一个标签ID。
- en: 'Now, we need to modify our `posts` table. It needs a user ID. The following
    is the SQL code we need to run to delete and recreate our `posts` table:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们需要修改我们的`posts`表。它需要一个用户ID。以下是我们需要运行的SQL代码来删除并重新创建我们的`posts`表：
- en: '[PRE4]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The last step in our process is to create the foreign key relationships between
    our tables. Run the following SQL code to add the foreign key constraints to our
    database:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 我们流程的最后一个步骤是在我们的表之间创建外键关系。运行以下SQL代码来向我们的数据库添加外键约束：
- en: '[PRE5]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The following screenshot represents a diagram showing the relationships in
    our database:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图表示显示我们数据库中关系的图：
- en: '![Creating the database tables](img/7673OS_04_01.png.jpg)'
  id: totrans-30
  prefs: []
  type: TYPE_IMG
  zh: '![创建数据库表](img/7673OS_04_01.png.jpg)'
- en: The preceding screenshot was made from the EER diagram tool in MySQL Workbench,
    which you can download for free at [http://www.mysql.com/products/workbench/](http://www.mysql.com/products/workbench/).
    This tool is really handy for designing databases. I created all the tables and
    relationships for this blog with drag-and-drop and fill in the blanks.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 上述截图是从MySQL Workbench中的EER图工具生成的，您可以在[http://www.mysql.com/products/workbench/](http://www.mysql.com/products/workbench/)免费下载此工具。这个工具对于设计数据库来说非常实用。我用拖放和填写空白的方式创建了所有这些表格和关系。
- en: Generating the models
  id: totrans-32
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 生成模型
- en: 'Now, let''s use Phalcon web tools to create all of our new models at once.
    Browse to `http://localhost/phalconBlog/webtools.php?_url=/models/index` and you
    will see the following screen:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们使用Phalcon网络工具一次性创建所有我们的新模型。浏览到`http://localhost/phalconBlog/webtools.php?_url=/models/index`，你会看到以下屏幕：
- en: '![Generating the models](img/7673OS_04_02.png.jpg)'
  id: totrans-34
  prefs: []
  type: TYPE_IMG
  zh: '![生成模型](img/7673OS_04_02.png.jpg)'
- en: 'This time, we are going to select the **Table name** as **All** and make sure
    we check **Set Foreign Keys**, **Define Relations**, and **Force**. This way,
    web tools will set up the necessary relationships in our models. This will create
    the following files in our `models` folder located at `app`:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 这次，我们将选择**表名**为**所有**，并确保我们检查**设置外键**、**定义关系**和**强制**。这样，网络工具就会在我们的模型中设置必要的关系。这将在位于`app`目录下的`models`文件夹中创建以下文件：
- en: '`Comments.php`'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Comments.php`'
- en: '`PostTags.php`'
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`PostTags.php`'
- en: '`Tags.php`'
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Tags.php`'
- en: '`Users.php`'
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Users.php`'
- en: We will take a look at these files as we continue to refactor our blog project
    throughout the rest of this chapter. But, to understand a little bit about what
    we just did, let's take a look at how relationships are handled by Phalcon. The
    Phalcon model's manager handles the relationships between models, and these relationships
    must be set up in the `initialize` function of these models. By having Phalcon
    web tools define relationships, we can simply have it generate the `initialize`
    function for us.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们继续重构本章剩余部分的博客项目时，我们将查看这些文件。但是，为了更好地理解我们刚才所做的工作，让我们看看Phalcon是如何处理关系的。Phalcon模型管理器处理模型之间的关系，并且这些关系必须在这些模型的`initialize`函数中设置。通过让Phalcon网络工具定义关系，我们可以简单地让它为我们生成`initialize`函数。
- en: 'In the `initialize` function of the `Users.php` file, you will find the following
    line of code:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 在`Users.php`文件的`initialize`函数中，你会找到以下代码行：
- en: '[PRE6]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'This line of code sets up the relationships between the posts and the users
    in our application. A user will have many posts. This is one of four methods.
    The other three methods are as follows:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 这行代码设置了应用中文章和用户之间的关系。一个用户将拥有多个文章。这是四种方法之一。其他三种方法如下：
- en: '`hasOne()`'
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`hasOne()`'
- en: '`belongsTo()`'
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`belongsTo()`'
- en: '`hasManyToMany()`'
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`hasManyToMany()`'
- en: 'The first parameter is the field of the local model that is a key in the relationship.
    The second parameter is the model being referenced. The third parameter is the
    remote model''s key. And since posts belong to users, we will find the following
    line of code in the `initialize` function of the Posts model:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个参数是本地模型中作为关系键的字段。第二个参数是被引用的模型。第三个参数是远程模型的键。由于文章属于用户，我们将在`Posts`模型的`initialize`函数中找到以下代码行：
- en: '[PRE7]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: For the most part, you can forget about the relationships and foreign keys in
    your database and just treat your records as objects.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 对于大部分情况，你可以忘记数据库中的关系和外键，只需将你的记录当作对象来处理。
- en: Storing session data in Phalcon
  id: totrans-50
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在Phalcon中存储会话数据
- en: First, we are going to give ourselves the ability to log in to our blog and
    store our user information in our session. We are going to wait to encrypt our
    passwords and set up permissions for our user until the next chapter. For now,
    we only want to be able to save a user ID when a user saves a blog post.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将赋予自己登录博客并存储用户信息到会话中的能力。我们将等到下一章再加密密码和设置用户权限。现在，我们只想在用户保存博客文章时保存用户ID。
- en: 'We made our changes to the model, but that doesn''t mean everything is going
    to work. Browse to `http://localhost/phalconBlog/posts/create` and try to create
    a new post. You will not be able to. Instead, you will see the following error
    message in your browser because we just created a rule that our database requires
    every post to have a user ID:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 我们对模型进行了更改，但这并不意味着一切都会正常工作。浏览到`http://localhost/phalconBlog/posts/create`并尝试创建一个新的帖子。你将无法做到。相反，你将在浏览器中看到以下错误消息，因为我们刚刚创建了一个规则，要求我们的数据库中的每个帖子都必须有一个用户ID：
- en: '![Storing session data in Phalcon](img/7673OS_04_03.png.jpg)'
  id: totrans-53
  prefs: []
  type: TYPE_IMG
  zh: '![在Phalcon中存储会话数据](img/7673OS_04_03.png.jpg)'
- en: Another problem is that in order to have a user ID, we need a user in the `users`
    table to reference. Therefore, we need to be able to add users to our database
    with our application. So, go back to `http://localhost/phalconBlog/webtools.php?_url=/scaffold`
    and generate the scaffolding for your `users` table. We are going to cut a lot
    out of it and change some things, but again, it is a good place to start.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个问题是为了有一个用户ID，我们需要在`users`表中有一个用户来引用。因此，我们需要能够使用我们的应用程序向数据库中添加用户。所以，回到`http://localhost/phalconBlog/webtools.php?_url=/scaffold`并为你用户的表生成脚手架。我们将从中删除很多内容并更改一些东西，但同样，这是一个好的开始。
- en: 'Once you have generated the scaffolding for your `users` table, browse to `http://localhost/phalconBlog/users/new`
    and create your user as shown in the following screenshot:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你为你用户的表生成了脚手架，浏览到`http://localhost/phalconBlog/users/new`并创建你的用户，如下面的截图所示：
- en: '![Storing session data in Phalcon](img/7673OS_04_04.png.jpg)'
  id: totrans-56
  prefs: []
  type: TYPE_IMG
  zh: '![在Phalcon中存储会话数据](img/7673OS_04_04.png.jpg)'
- en: 'Now that we have a user, let''s make sure that when we create a new blog post,
    the user ID gets related to it. We are going to set a `user_id` variable in the
    user''s session. First, we need a form to log in, and we might as well put this
    in the `indexAction` function''s template so we can log in there. Open up the
    `index.volt` file located `at app/views/users` that you generated with Phalcon
    web tools and modify it to look like the following code snippet:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了用户，让我们确保在创建新的博客文章时，用户ID与之相关联。我们将在用户的会话中设置一个`user_id`变量。首先，我们需要一个登录表单，并且我们可以将它放在`indexAction`函数的模板中，这样我们就可以在那里登录。打开位于`app/views/users`的`index.volt`文件，这是使用Phalcon
    Web工具生成的，并修改它以看起来像以下代码片段：
- en: '[PRE8]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: What we have left is a `username` and `password` field and a **submit** button.
    Also, we have modified the original search form that web tools built for us to
    post to an action that doesn't exist yet in our controller, that is, the `loginAction`
    function.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 我们剩下的是一个`username`和`password`字段以及一个**提交**按钮。我们还修改了网络工具为我们构建的原始搜索表单，将其提交到一个我们控制器中尚未存在的动作，即`loginAction`函数。
- en: 'Now, let''s create a `loginAction` function in the `UsersController.php` file
    located at `app/controllers`. The method we will be adding is the following code
    snippet:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们在位于`app/controllers`的`UsersController.php`文件中创建一个`loginAction`函数。我们将添加的方法是以下代码片段：
- en: '[PRE9]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: This method is pretty simple. It checks that there is a `POST` variable, and
    if so, sets `$parameters` to the `POST` variable. Then, we set the `$users` variable
    to the result of the Phalcon model's `Find` method. Since we made the `username`
    column a unique key in our database, we should either get one or no records. If
    we get no records, we set a flash message to tell the user that what they entered
    was incorrect. If we get one record, we call `$users->getFirst()` to get the first
    and only result from our query. And then, we set the session variable `user_id`
    to the `id` instance in our `$user` object. We started the session when our bootstrap
    file loaded the `services.php` file located at `app/config`, so it is available
    here in this controller.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 这个方法很简单。它检查是否存在`POST`变量，如果存在，则将`$parameters`设置为`POST`变量。然后，我们将`$users`变量设置为Phalcon模型`Find`方法的结果。由于我们在数据库中将`username`列设置为唯一键，我们应该得到一条或没有记录。如果没有记录，我们设置一个闪存消息告诉用户他们输入的内容不正确。如果得到一条记录，我们调用`$users->getFirst()`从我们的查询中获取第一条也是唯一的结果。然后，我们将会话变量`user_id`设置为我们的`$user`对象中的`id`实例。我们在`app/config`中的`services.php`文件加载时启动了会话，因此它在这个控制器中可用。
- en: 'While we have this file open, we should also create an action to log out. This
    method is even easier to write. We just call `$this->session->remove($var)`, where
    `$var` is the variable we want to remove from the session. Here is what the code
    looks like:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们打开此文件时，我们还应该创建一个注销动作。这个方法甚至更容易编写。我们只需调用`$this->session->remove($var)`，其中`$var`是我们想要从会话中删除的变量。以下是代码的示例：
- en: '[PRE10]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'We are going to make one last change to this file. We have already set the
    `indexAction` function''s view to display the login form when the `indexAction`
    function is called. But, if a user is already logged in, let''s show them a list
    of users. To do this, we will change the `indexAction` function so that it looks
    like the following code snippet:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将对这个文件进行最后一次修改。我们已经设置了`indexAction`函数的视图，以便在调用`indexAction`函数时显示登录表单。但是，如果用户已经登录，让我们显示用户列表。为此，我们将修改`indexAction`函数，使其看起来像以下代码片段：
- en: '[PRE11]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Here, we simply check if there is a user ID in the session, and if so, we forward
    the user to the search controller, which displays a list of all users when no
    search parameters are posted.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们简单地检查会话中是否存在用户ID，如果存在，则将用户转发到搜索控制器，该控制器在未提交搜索参数时显示所有用户的列表。
- en: 'We still can''t create a post yet until we set this user ID in it. So, open
    up the `PostsController.php` file located at `app/controllers`. We only have to
    worry about setting this ID when the blog post is created, so we are only going
    to modify the `createAction` function. Right before we instantiate the new post
    with `$post = new Posts()`, we are going to add the following code snippet:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们设置此用户ID之前，我们仍然无法创建帖子。因此，打开位于`app/controllers`的`PostsController.php`文件。我们只需在创建博客帖子时设置此ID，因此我们只将修改`createAction`函数。在我们使用`$post
    = new Posts()`实例化新帖子之前，我们将添加以下代码片段：
- en: '[PRE12]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'To check whether the session has a user ID in it or not, forward the user to
    the login page. If there is an ID, the code creates the new post, and we need
    to add the following line of code to add our user ID to the `post` object:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 要检查会话中是否包含用户ID，请将用户转发到登录页面。如果存在ID，代码将创建新帖子，我们需要在`post`对象中添加以下代码行来添加我们的用户ID：
- en: '[PRE13]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'And finally, we need a way to log out. We have created the `action` method
    already, but there is no way to get to it. So, open up the `search.volt` file
    located at `app/views/users` and add the following code snippet right after the
    `{{ content() }}` tag:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们需要一种注销的方法。我们已经创建了`action`方法，但没有方法可以访问它。因此，打开位于`app/views/users`的`search.volt`文件，并在`{{
    content() }}`标签之后添加以下代码片段：
- en: '[PRE14]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: This will add a button to the top of the list of users that will log us out.
    Now, we can log in and create a post without any issues.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 这将在用户列表顶部添加一个按钮，用于注销我们。现在，我们可以无任何问题地登录并创建帖子。
- en: Filtering and sanitizing data
  id: totrans-75
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 过滤和清理数据
- en: To prevent unauthorized access, SQL injection, and other malicious attacks on
    our application, we need to filter and sanitize user input. We can use the `Phalcon\Filter`
    component to do this for us. This component supplies wrappers for the PHP filter
    extension.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 为了防止未经授权的访问、SQL注入和其他针对我们应用程序的恶意攻击，我们需要过滤和清理用户输入。我们可以使用`Phalcon\Filter`组件来为我们完成这项工作。此组件为PHP过滤器扩展提供了包装器。
- en: 'Securing your application is beyond the scope of this book, but we can take
    a look at a filter that Phalcon development tools already added for us when we
    named one of our user field''s e-mail. In the `UsersControllers.php` file located
    at `app/controller`, you will find that the `createAction` function has the following
    line of code:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 保护您的应用程序超出了本书的范围，但我们可以看看当我们将用户字段之一命名为电子邮件时，Phalcon开发工具已经为我们添加的一个过滤器。在位于`app/controller`的`UsersControllers.php`文件中，您会发现`createAction`函数有以下代码行：
- en: '[PRE15]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The filter object is accessed through the Phalcon request object. The first
    parameter is the name of the variable we are accessing, and the second optional
    parameter is our filter. Phalcon has the following built-in filters:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 过滤器对象是通过Phalcon请求对象访问的。第一个参数是我们正在访问的变量名，第二个可选参数是我们的过滤器。Phalcon有以下内置过滤器：
- en: '| Name | Description |'
  id: totrans-80
  prefs: []
  type: TYPE_TB
  zh: '| 名称 | 描述 |'
- en: '| --- | --- |'
  id: totrans-81
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `string` | Strips tags |'
  id: totrans-82
  prefs: []
  type: TYPE_TB
  zh: '| `string` | 移除标签 |'
- en: '| `email` | Removes all characters except letters, digits, and special characters
    such as !, #, $, %, &, *, +, -, /, =, ?, ^, _, '', {, &#124;, }, ~, @, and []
    |'
  id: totrans-83
  prefs: []
  type: TYPE_TB
  zh: '| `email` | 移除所有字符，除了字母、数字和特殊字符，如!、#、$、%、&、*、+、-、/、=、?、^、_、''、{、|}、~、@和[] |'
- en: '| `int` | Removes all characters except digits, dots, plus, and minus |'
  id: totrans-84
  prefs: []
  type: TYPE_TB
  zh: '| `int` | 移除所有字符，除了数字、点、加号和减号 |'
- en: '| `float` | Removes all characters except digits, dots, plus, and minus |'
  id: totrans-85
  prefs: []
  type: TYPE_TB
  zh: '| `float` | 移除所有字符，除了数字、点、加号和减号 |'
- en: '| `alphanum` | Removes all characters except a-z, A-Z, and 0-9 |'
  id: totrans-86
  prefs: []
  type: TYPE_TB
  zh: '| `alphanum` | 移除所有字符，除了a-z、A-Z和0-9 |'
- en: '| `striptags` | Applies the `strip_tags` function |'
  id: totrans-87
  prefs: []
  type: TYPE_TB
  zh: '| `striptags` | 应用`strip_tags`函数 |'
- en: '| `trim` | Applies the `trim` function |'
  id: totrans-88
  prefs: []
  type: TYPE_TB
  zh: '| `trim` | 应用`trim`函数 |'
- en: '| `lower` | Applies the `strtolower` function |'
  id: totrans-89
  prefs: []
  type: TYPE_TB
  zh: '| `lower` | 应用`strtolower`函数 |'
- en: '| `upper` | Applies the `strtoupper` function |'
  id: totrans-90
  prefs: []
  type: TYPE_TB
  zh: '| `upper` | 应用`strtoupper`函数 |'
- en: You can also write your own filters. You can read more about doing that at [http://docs.phalconphp.com/en/latest/reference/filter.html#creating-your-own-filters](http://docs.phalconphp.com/en/latest/reference/filter.html#creating-your-own-filters).
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 您也可以编写自己的过滤器。您可以在[http://docs.phalconphp.com/en/latest/reference/filter.html#creating-your-own-filters](http://docs.phalconphp.com/en/latest/reference/filter.html#creating-your-own-filters)了解更多相关信息。
- en: Phalcon models revisited
  id: totrans-92
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 重新审视Phalcon模型
- en: 'Another thing we need to fix in our application is the fact that our dates
    don''t mean anything. We have published and updated dates in our `posts` table,
    which we are not using. Let''s make sure we''re setting those dates. Let''s open
    up the `Posts.php` file located at `app/model`. We are going to add more code
    to the `initialize` function of our Posts model, and we are going to use a behavior
    on our date fields. First, add this line of code after the first PHP tag:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要在我们的应用程序中修复的另一件事是，我们的日期没有任何意义。在我们的`posts`表中，我们发布了和更新了日期，但我们没有使用。让我们确保我们设置了这些日期。让我们打开位于`app/model`的`Posts.php`文件。我们将在我们的帖子模型`initialize`函数中添加更多代码，并且我们将使用日期字段的行为。首先，在第一个PHP标签之后添加以下代码行：
- en: '[PRE16]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Then, add the following lines of code to the `initialize` function in this
    model:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，将以下代码行添加到该模型的`initialize`函数中：
- en: '[PRE17]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: We can use the `Timestamable` behavior to handle the setting of our published
    and updated dates for us. The first parameter is the event we are attaching this
    behavior to, the next parameter is the field, and the third is the date format.
    So, the published date will now be set when a new record is created, as will the
    updated date when it is updated, without having to set the date manually whenever
    we modify data in our controller.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用`Timestamable`行为来为我们处理发布的和更新的日期设置。第一个参数是我们附加此行为的活动，下一个参数是字段，第三个是日期格式。因此，当创建新记录时，发布的日期将被设置，当更新时，更新的日期也将被设置，而无需在控制器中修改数据时手动设置日期。
- en: Now let's add tags to our posts. The first thing we need to do is go back to
    Phalcon web tools in the browser or Phalcon Developer Tools in the command line
    and generate the models for both the `tags` table and the `post_tags` table. Then,
    we regenerate the model for our `posts` table. Make sure to choose **Set Foreign
    Keys** and **Define Relations**. For the `posts` table, you will have to set the
    **Forced** option.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们给我们的帖子添加标签。首先，我们需要回到浏览器中的Phalcon Web工具或命令行中的Phalcon Developer Tools，并生成`tags`表和`post_tags`表的模型。然后，我们重新生成我们的`posts`表的模型。确保选择**设置外键**和**定义关系**。对于`posts`表，您将不得不设置**强制**选项。
- en: 'Open your newly generated files. You will find them in the `models` folder
    located at `app`. At the bottom of the `Posts.php` file, you will find the following
    new code:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 打开您新生成的文件。您可以在位于`app`目录下的`models`文件夹中找到它们。在`Posts.php`文件的底部，您将找到以下新代码：
- en: '[PRE18]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'At the bottom of `Tags.php`, you will also find an `initialize` function:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 在`Tags.php`文件的底部，您也将找到一个`initialize`函数：
- en: '[PRE19]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'At the bottom of the `PostTags.php` file, you will find the following lines
    of code:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 在`PostTags.php`文件的底部，您将找到以下代码行：
- en: '[PRE20]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The code in the `initialize` functions of these models relate these models based
    on the foreign keys we created in our database and allow us to create, read, update,
    and delete our records as objects. However, we still have to write a little bit
    of code to actually save our tags when we save a post.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 这些模型`initialize`函数中的代码基于我们在数据库中创建的外键将这些模型关联起来，并允许我们以对象的形式创建、读取、更新和删除我们的记录。然而，我们仍然需要编写一些代码来实际保存我们保存帖子时的标签。
- en: Next, let's create a new method in our `Posts.php` file.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们在`Posts.php`文件中创建一个新的方法。
- en: '[PRE21]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Our function accepts an array of tags as the first parameter and the ID of a
    post as the second. Here, we loop through the tags. Using `findFirst`, we check
    if the tag already exists. In this example, we use an array that simply holds
    what would be the `WHERE` clause of our SQL. If there is a tag, it is loaded in
    the `$tag` variable. If not, `$tag` will be false, and then we create a new tag
    and save it. Next, we check if there is a record in the `post_tag` table that
    relates the current tag to the post ID. If there is, we load it, and if not, we
    create it and save it.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的功能接受一个标签数组作为第一个参数，以及一个帖子的ID作为第二个参数。在这里，我们遍历标签。使用`findFirst`，我们检查标签是否已经存在。在这个例子中，我们使用一个数组，它简单地保存了我们SQL查询的`WHERE`子句。如果存在标签，它将被加载到`$tag`变量中。如果没有，`$tag`将为false，然后我们创建一个新的标签并保存它。接下来，我们检查`post_tag`表中是否有记录将当前标签与帖子ID相关联。如果有，我们加载它，如果没有，我们创建它并保存它。
- en: 'We have the model handled, so let''s move to the controllers. Open up the `PostsController.php`
    file located at `app/controllers`. Find the following line of code in both the
    `createAction` and `saveAction` functions:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经处理了模型，所以让我们转到控制器。打开位于`app/controllers`目录下的`PostsController.php`文件。在`createAction`和`saveAction`函数中找到以下代码行：
- en: '[PRE22]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'This is the point where the post gets saved to the database after being created
    or edited. The `$post` object will now have an ID attached to it. After each post,
    add the following lines of code:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 这是在帖子创建或编辑后被保存到数据库的点。现在，`$post`对象将附加一个ID。在每个帖子之后，添加以下代码行：
- en: '[PRE23]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Here, we are assuming that when we get to creating our form, we will be accepting
    comma delimited tags. So, we turn this string of tags into an array with `explode`
    after setting the string to lowercase letters in order to ensure a bit more uniqueness.
    Then, we use the `addTags` method that we just added to our `Post` model in order
    to save the tags to our database.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们假设当我们开始创建我们的表单时，我们将接受以逗号分隔的标签。因此，我们将这个标签字符串转换成一个数组，使用`explode`在将字符串设置为小写字母后进行，以确保更多的唯一性。然后，我们使用刚刚添加到我们的`Post`模型中的`addTags`方法来将标签保存到我们的数据库中。
- en: 'Now, we need to modify the `editAction` function so that we can send tags to
    our edit form. Locate the following line of code in that function:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们需要修改`editAction`函数，以便我们可以将标签发送到我们的编辑表单。在该函数中找到以下代码行：
- en: '[PRE24]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Add the following code after it:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 在它之后添加以下代码：
- en: '[PRE25]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Now, all we have to do is modify our post views. The `edit.volt` and `new.volt`
    files located at `app/view/post` just need a field added to our form for tags
    at the bottom of the table, before the button markup.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们只需要修改我们的帖子视图。位于`app/view/post`目录下的`edit.volt`和`new.volt`文件只需要在表格底部，在按钮标记之前添加一个用于标签的字段。
- en: '[PRE26]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'In the `show.volt` file located at `app/view/post`, find the following line
    of code:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 在位于`app/view/post`目录下的`show.volt`文件中找到以下代码行：
- en: '[PRE27]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Insert the following code snippet below the previous code snippet:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的代码片段下方插入以下代码片段：
- en: '[PRE28]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Now we can browse to `http://localhost/phalconBlog/posts/new` and create a post
    that has tags.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以浏览到`http://localhost/phalconBlog/posts/new`并创建一个带有标签的帖子。
- en: Using PHQL
  id: totrans-125
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用PHQL
- en: '**Phalcon Query Language** (**PHQL**) is a high-level SQL dialect that standardizes
    SQL queries for the database systems that Phalcon supports. However, this is not
    the only feature of PHQL. It also has the following features:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: '**Phalcon查询语言**（**PHQL**）是一种高级SQL方言，它为Phalcon支持的数据库系统标准化SQL查询。然而，这并不是PHQL的唯一特性。它还具有以下特性：'
- en: It uses bound parameters to secure your application
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它使用绑定参数来保护你的应用程序
- en: It treats tables as models and fields as class attributes
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它将表视为模型，字段视为类属性
- en: It allows data manipulation statements to prevent data loss
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它允许数据操作语句以防止数据丢失
- en: It allows only one query per call to prevent SQL injection
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它只允许每次调用一个查询，以防止SQL注入
- en: 'We are going to use PHQL for the search form in our sidebar. Currently, it
    is actually pretty useless. We will cut it down to search only the body field
    just to make things easy. Now, we are going to make it work a little bit better.
    We can make the value from this one search field do a little more work by searching
    not only the body, but the title and the excerpt as well. So, we need to edit
    the `searchAction` function in the `PostsController.php` file located at `app/controllers`.
    The following code snippet tells us how we need to edit the file:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在侧边栏的搜索表单中使用PHQL。目前，它实际上相当无用。我们将将其简化，只搜索正文字段，以便事情变得简单。现在，我们将让它工作得更好。我们可以通过不仅搜索正文，还搜索标题和摘要，使这个搜索字段的价值得到提升。因此，我们需要编辑位于`app/controllers`目录下的`PostsController.php`文件中的`searchAction`函数。以下代码片段告诉我们如何编辑文件：
- en: '[PRE29]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: The lines of code that have been commented out in the previous code snippet
    are old code. The important part of the code is at the end where we create the
    PHQL query. Notice that instead of selecting from a table, we select from the
    actual model. Then, we set the `$posts` variable to the results returned by `$this->modelsManager->executeQuery()`.
    `modelsManager` is a service that was loaded into our Dependency Injection container.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的代码片段中已被注释掉的代码行是旧代码。代码的重要部分在末尾，我们在这里创建PHQL查询。注意，我们不是从表中选择，而是从实际模型中选择。然后，我们将`$posts`变量设置为`$this->modelsManager->executeQuery()`返回的结果。`modelsManager`是我们依赖注入容器中加载的服务。
- en: 'Another thing that PHQL can help us out with is joins. Since we already defined
    the relationships between our models, we can use a PHQL query like the following
    line of code to get a list of posts with the users'' names:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: PHQL还可以帮助我们处理连接操作。由于我们已经定义了模型之间的关系，我们可以使用以下PHQL查询来获取带有用户名称的帖子列表：
- en: '[PRE30]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Note that we don't have to specify the predicates for the join operation. Here,
    an `INNER JOIN` operation is assumed, but any type of join can be used.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们不需要指定连接操作的条件。在这里，假设了一个`INNER JOIN`操作，但可以使用任何类型的连接。
- en: 'If you don''t feel like writing the PHQL statements, there is a query builder
    available which is similar to the query builder in other PHP frameworks such as
    Zend and Yii. We could build the previous query with the following lines of code,
    as well as execute it and return the records:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你不想编写PHQL语句，可以使用一个查询构建器，它类似于其他PHP框架（如Zend和Yii）中的查询构建器。我们可以用以下几行代码构建之前的查询，并执行它并返回记录：
- en: '[PRE31]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: PHQL is a powerful language, and the scope of this book and application don't
    really do it justice. To learn more than what this book can teach you about PHQL,
    visit [http://docs.phalconphp.com/en/latest/reference/phql.html](http://docs.phalconphp.com/en/latest/reference/phql.html).
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: PHQL是一种强大的语言，本书和应用程序的范围并不能真正体现其价值。要了解更多关于PHQL的知识，超出本书所能教授的内容，请访问[http://docs.phalconphp.com/en/latest/reference/phql.html](http://docs.phalconphp.com/en/latest/reference/phql.html)。
- en: Switching databases in Phalcon
  id: totrans-140
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在Phalcon中切换数据库
- en: 'We have used a MySQL database in our application. If we wanted to change the
    database software midstream, it would not be too hard, as long as we have the
    same data structure in our new database. Currently, Phalcon supports the following
    relational database backends:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在我们的应用程序中使用了MySQL数据库。如果我们想在中途更改数据库软件，只要我们的新数据库中有相同的数据结构，这并不会太难。目前，Phalcon支持以下关系型数据库后端：
- en: '**MySQL**: This is the world''s most used relational database management system
    available at [https://phalcon-php-framework-documentation.readthedocs.org/en/latest/api/Phalcon_Db_Dialect_Mysql.html](https://phalcon-php-framework-documentation.readthedocs.org/en/latest/api/Phalcon_Db_Dialect_Mysql.html)'
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**MySQL**：这是世界上使用最广泛的关系型数据库管理系统，可在[https://phalcon-php-framework-documentation.readthedocs.org/en/latest/api/Phalcon_Db_Dialect_Mysql.html](https://phalcon-php-framework-documentation.readthedocs.org/en/latest/api/Phalcon_Db_Dialect_Mysql.html)找到。'
- en: '**PostgreSQL**: This is a powerful, reliable, and open source database management
    system available at [https://phalcon-php-framework-documentation.readthedocs.org/en/latest/api/Phalcon_Db_Dialect_Postgresql.html](https://phalcon-php-framework-documentation.readthedocs.org/en/latest/api/Phalcon_Db_Dialect_Postgresql.html)'
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**PostgreSQL**：这是一个强大、可靠且开源的数据库管理系统，可在[https://phalcon-php-framework-documentation.readthedocs.org/en/latest/api/Phalcon_Db_Dialect_Postgresql.html](https://phalcon-php-framework-documentation.readthedocs.org/en/latest/api/Phalcon_Db_Dialect_Postgresql.html)找到。'
- en: '**SQLite**: This is a self-contained, server-less database engine available
    at [https://phalcon-php-framework-documentation.readthedocs.org/en/latest/api/Phalcon_Db_Dialect_Sqlite.html](https://phalcon-php-framework-documentation.readthedocs.org/en/latest/api/Phalcon_Db_Dialect_Sqlite.html)'
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**SQLite**：这是一个自包含、无服务器的数据库引擎，可在[https://phalcon-php-framework-documentation.readthedocs.org/en/latest/api/Phalcon_Db_Dialect_Sqlite.html](https://phalcon-php-framework-documentation.readthedocs.org/en/latest/api/Phalcon_Db_Dialect_Sqlite.html)找到。'
- en: '**Oracle**: This is an object-relational database management system produced
    by the Oracle corporation available at [https://phalcon-php-framework-documentation.readthedocs.org/en/latest/api/Phalcon_Db_Dialect_Oracle.html](https://phalcon-php-framework-documentation.readthedocs.org/en/latest/api/Phalcon_Db_Dialect_Oracle.html)'
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Oracle**：这是由Oracle公司生产的对象关系型数据库管理系统，可在[https://phalcon-php-framework-documentation.readthedocs.org/en/latest/api/Phalcon_Db_Dialect_Oracle.html](https://phalcon-php-framework-documentation.readthedocs.org/en/latest/api/Phalcon_Db_Dialect_Oracle.html)找到。'
- en: 'Our application sets the database adapter by importing it in the `services.php`
    file located at `app/config` with the following line of code:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的应用程序通过在`app/config`目录下的`services.php`文件中导入它来设置数据库适配器，如下所示：
- en: '[PRE32]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: If we wanted to use a different database system, we would just include a different
    adapter here. Each adapter handles most of the proprietary quirks of its respective
    database.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想使用不同的数据库系统，我们只需在这里包含不同的适配器。每个适配器处理其相应数据库的大部分专有特性。
- en: Phalcon's Object-Document Mapper and MongoDB
  id: totrans-149
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Phalcon的对象-文档映射器和MongoDB
- en: Relational databases aren't the only type of database you can use in Phalcon.
    You can also use Phalcon's **Object-Document Mapper** (**ODM**) to connect to
    MongoDB. Phalcon's ODM offers CRUD functionality, validation, events, and other
    useful services.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 在Phalcon中，你不仅可以使用关系数据库，还可以使用Phalcon的**对象-文档映射器**（**ODM**）连接到MongoDB。Phalcon的ODM提供了CRUD功能、验证、事件和其他有用的服务。
- en: 'You start by adding a connection from your MongoDB database to your Dependency
    Injection container, as in the following code snippet:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过以下代码片段将MongoDB数据库的连接添加到你的依赖注入容器中：
- en: '[PRE33]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: This will be a connection to the default localhost MongoDB instance running
    on the default port.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 这将是一个连接到默认的localhost MongoDB实例的连接，该实例在默认端口上运行。
- en: We can now add models just as we add models when our application uses a standard
    relational database, but instead, we extend `\Phalcon\Mvc\Collection`.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以像在应用程序使用标准关系数据库时添加模型一样添加模型，但在这里，我们扩展了`\Phalcon\Mvc\Collection`。
- en: '[PRE34]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: And really, that is all you need in your model file. This assumes we will be
    using a collection called `pages` in our `blog` database to hold the data. This
    may seem a little confusing, but it is a standard convention to use lowercase
    names for MongoDB collections. This class has the same functionality as that of
    the MongoDB PHP extension. So, if we want to find a page by its ID, we would use
    the same function name.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 真的，在你的模型文件中你只需要这些。这假设我们将使用名为`pages`的集合在我们的`blog`数据库中存储数据。这可能会有些令人困惑，但使用小写名称作为MongoDB集合的标准约定。这个类具有与MongoDB
    PHP扩展相同的函数。因此，如果我们想通过ID查找页面，我们将使用相同的函数名。
- en: '[PRE35]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Each collection is an object with the flexibility of a MongoDB record. Once
    you have the `page` object, it can be modified and saved again.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 每个集合都是一个具有MongoDB记录灵活性的对象。一旦你有了`page`对象，就可以对其进行修改并再次保存。
- en: '[PRE36]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: You can read more about the ODM at [http://docs.phalconphp.com/en/latest/reference/odm.html](http://docs.phalconphp.com/en/latest/reference/odm.html).
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在[http://docs.phalconphp.com/en/latest/reference/odm.html](http://docs.phalconphp.com/en/latest/reference/odm.html)了解更多关于ODM的信息。
- en: Migrating databases
  id: totrans-161
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 数据库迁移
- en: 'Another tool that both Phalcon Developer Tools and Phalcon web tools provide
    is one that manages database changes between your various software environments.
    To generate a database migration, you would run the following command in your
    project directory:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: Phalcon开发者工具和Phalcon Web工具提供的一个另一个工具是管理不同软件环境之间的数据库更改。要生成数据库迁移，你需要在项目目录中运行以下命令：
- en: '[PRE37]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'This command will simply dump every object from your database in migration
    classes. In our application, these classes will be stored inside a folder named
    after the current migration version in the `migrations` folder located at `app`.
    Let''s say you just changed the data model in the local version of your application
    and you have created a migration for it. Then, you would just upload the migration
    to your development server and run the following command to execute the changes
    to your database on this server:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 此命令将简单地从你的数据库中导出每个对象到迁移类中。在我们的应用程序中，这些类将存储在`app`目录下名为当前迁移版本的文件夹中。假设你刚刚更改了应用程序的本地数据模型，并为它创建了一个迁移。然后，你只需将迁移上传到你的开发服务器，并运行以下命令来执行此服务器上数据库的更改：
- en: '[PRE38]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'To list the configuration options available, run the following command:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 要列出可用的配置选项，请运行以下命令：
- en: '[PRE39]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'To use web tools, we would just browse to `http://localhost/phalconBlog/webtools.php?_url=/migrations/index`
    in our current application, and we will see the following screen:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用Web工具，我们只需在我们的当前应用程序中浏览到`http://localhost/phalconBlog/webtools.php?_url=/migrations/index`，我们就会看到以下屏幕：
- en: '![Migrating databases](img/7673OS_04_05.png.jpg)'
  id: totrans-169
  prefs: []
  type: TYPE_IMG
  zh: '![迁移数据库](img/7673OS_04_05.png.jpg)'
- en: You can learn more about Phalcon database migrations at [http://docs.phalconphp.com/en/latest/reference/migrations.html](http://docs.phalconphp.com/en/latest/reference/migrations.html).
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在[http://docs.phalconphp.com/en/latest/reference/migrations.html](http://docs.phalconphp.com/en/latest/reference/migrations.html)了解更多关于Phalcon数据库迁移的信息。
- en: Summary
  id: totrans-171
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we fleshed out our blog application a little by adding relationships
    between our models. We can now log in, create our own posts that have updated
    and created dates, and add tags to our posts. During the process of refactoring
    our application to do these things, we learned various ways to handle data in
    Phalcon. However, our application is far from complete.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们通过添加模型之间的关系来稍微完善了我们的博客应用程序。我们现在可以登录，创建自己的帖子，这些帖子包含更新和创建的日期，并为我们帖子添加标签。在重构应用程序以执行这些操作的过程中，我们学习了在Phalcon中处理数据的各种方法。然而，我们的应用程序远未完成。
- en: In the next chapter, we will fill in some of the missing gaps in our application,
    including the ability to comment on posts, hiding content and functionality from
    visitors who aren't logged in, encrypting users' passwords, generating RSS feeds,
    and pinging sites when we create posts.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将填补我们应用程序中的一些空白，包括对帖子进行评论的能力、隐藏未登录访客的内容和功能、加密用户密码、生成RSS源，以及在我们创建帖子时ping网站。
