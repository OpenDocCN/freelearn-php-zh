<html><head></head><body>
        <section>

                            <header>
                    <h1 class="header-title">The Database API</h1>
                </header>
            
            <article>
                
<p>In the previous two chapters, we talked extensively about our options as Drupal 8 module developers for modeling and storing data in Drupal 8. We also saw some examples of how to use things such as the State, Configuration, and Entity APIs, going into greater detail about the latter by using it to build something useful. One of the key takeaways from th<span><span>o</span></span>se chapters is that the need for custom database tables and/or direct queries against them and the database has become minimal.</p>
<p>The Entity system is much more flexible and robust, the combination of configuration and content entities providing much of the needs for storing data. Moreover, the Entity query and loading mechanisms have also made finding them easy. Odds are, this is enough for most of your use cases.</p>
<p>Furthermore, storage subsystems such as the State API (key/value) and UserData have also removed much of the need to create custom tables to store that kind of "one-off" data. Also, the Configuration API provides a unified way to model exportable data, leaving no need for anything else.</p>
<p>However, apart from these features, Drupal also has a strong Database API that actually powers them under the hood. This API is made available to us in case we need it. For example, we can create our own database tables and then run queries against them however we want, all through a secure layer that can work on top of multiple types of databases.</p>
<p>Creating custom database tables is not something you will do very often— maybe never— but in this chapter, you will still learn how the API works in order to do so. There are contributed modules out there that have legitimate uses for them, and who knows, you might also. So, it is still important to understand this system. However, even more pertinent is the API for running queries (particularly select queries), because you may need to run these, even against entities. There are times in which the entity query does not provide all you need, so looking up entities based on complex queries can, in fact, be more common. Hence, we will cover how to do that in this chapter, as well.</p>
<p>More concretely, in this chapter, we will start by creating a couple of database tables so that we can see how the Schema API works in Drupal 8. For D7 developers, this will look strikingly familiar. Then, we will see the various ways we can perform queries against these tables by using the database abstraction layer. We can make two different types of select query, and we will practice both. For the others (<kbd>INSERT</kbd>, <kbd>UPDATE</kbd>, and <kbd>DELETE</kbd>), there is a standard way of doing it. Next, we will take a look at how queries can be altered and how we can tag them for better targeting. Finally, we will look at the database update hooks, which were one of the principal ways configuration was deployed in previous versions of Drupal. In reality, the purpose of these hooks is to make database updates once the tables have already been created.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The Schema API</h1>
                </header>
            
            <article>
                
<p>The purpose of the Schema API is to allow defining database table structures in PHP and to have Drupal interact with the database engine and turn th<span><span>o</span></span>se definitions into a reality. Apart from the fact that we don't ever have to see things such as <kbd>CREATE TABLE</kbd>, we ensure that our table structures can be applied to multiple types of databases. If you remember in <a href="5c4ab442-1596-40ca-b305-d72b6c47ed59.xhtml">Chapter 1</a>, <em>Developing for Drupal 8</em>, I mentioned that Drupal can work with MySQL, PostgreSQL, SQLite, and others, if they support PDO, so the Schema API ensures this cross-compatibility.</p>
<p>The central component of the Schema API is <kbd>hook_schema()</kbd>. This is used to provide the initial table definitions of a given module. Implementations of this hook belong in the <kbd>*.install</kbd> file of the module and are fired when the module is first installed. If alterations need to be made to existing database tables, there are a number of methods that can be used inside update hooks to make these changes.</p>
<p>In this section, we will create a new module called <kbd>sports</kbd> in which we want to define two tables: <kbd>players</kbd> and <kbd>teams</kbd>. The records in the former can reference records in the latter, as each player can be part of only one team at a time. This is a simple example, and one which could, and should, be implemented using entities. However, for the purpose of demonstrating the database API, we will stick with the manual setup.</p>
<p>So, in our <kbd>sports.install</kbd> file, we can implement <kbd>hook_schema()</kbd> as follows:</p>
<pre><span>/**<br/></span><span> * Implements hook_schema().<br/></span><span> */<br/></span><span>function </span><span>sports_schema</span><span>() {<br/></span><span>  </span><span>$schema </span><span>= []</span><span>;<br/></span><span><br/></span><span>  </span><span>$schema</span><span>[</span><span>'teams'</span><span>] = [<br/></span><span>    </span><span>'description' </span><span>=&gt; </span><span>'The table that holds team data.'</span><span>,<br/></span><span>    </span><span>'fields' </span><span>=&gt; [<br/></span><span>      </span><span>'id' </span><span>=&gt; [<br/></span><span>        </span><span>'description' </span><span>=&gt; </span><span>'The primary identifier.'</span><span>,<br/></span><span>        </span><span>'type' </span><span>=&gt; </span><span>'serial'</span><span>,<br/></span><span>        </span><span>'unsigned' </span><span>=&gt; </span><span>TRUE</span><span>,<br/></span><span>        </span><span>'not null' </span><span>=&gt; </span><span>TRUE</span><span>,<br/></span><span>      </span><span>]</span><span>,<br/></span><span>      </span><span>'name' </span><span>=&gt; [<br/></span><span>        </span><span>'description' </span><span>=&gt; </span><span>'The team name.'</span><span>,<br/></span><span>        </span><span>'type' </span><span>=&gt; </span><span>'varchar'</span><span>,<br/></span><span>        </span><span>'length' </span><span>=&gt; </span><span>255</span><span>,<br/></span><span>        </span><span>'not null' </span><span>=&gt; </span><span>TRUE</span><span>,<br/></span><span>      </span><span>]</span><span>,<br/></span><span>      </span><span>'description' </span><span>=&gt; [<br/></span><span>        </span><span>'description' </span><span>=&gt; </span><span>'The team description.'</span><span>,<br/></span><span>        </span><span>'type' </span><span>=&gt; </span><span>'text'</span><span>,<br/></span><span>        </span><span>'size' </span><span>=&gt; </span><span>'normal'</span><span>,<br/></span><span>      </span><span>]</span><span>,<br/></span><span>    </span><span>]</span><span>,<br/></span><span>    </span><span>'primary key' </span><span>=&gt; [</span><span>'id'</span><span>]</span><span>,<br/></span><span>  </span><span>]</span><span>;<br/></span><span><br/></span><span>  </span><span>$schema</span><span>[</span><span>'players'</span><span>] = [<br/></span><span>    </span><span>'description' </span><span>=&gt; </span><span>'The table that holds player data.'</span><span>,<br/></span><span>    </span><span>'fields' </span><span>=&gt; [<br/></span><span>      </span><span>'id' </span><span>=&gt; [<br/></span><span>        </span><span>'description' </span><span>=&gt; </span><span>'The primary identifier.'</span><span>,<br/></span><span>        </span><span>'type' </span><span>=&gt; </span><span>'serial'</span><span>,<br/></span><span>        </span><span>'unsigned' </span><span>=&gt; </span><span>TRUE</span><span>,<br/></span><span>        </span><span>'not null' </span><span>=&gt; </span><span>TRUE</span><span>,<br/></span><span>      </span><span>]</span><span>,<br/></span><span>      </span><span>'team_id' </span><span>=&gt; [<br/></span><span>        </span><span>'description' </span><span>=&gt; </span><span>'The ID of the team it belongs to.'</span><span>,<br/></span><span>        </span><span>'type' </span><span>=&gt; </span><span>'int'</span><span>,<br/></span><span>        </span><span>'unsigned' </span><span>=&gt; </span><span>TRUE</span><span>,<br/></span><span>      </span><span>]</span><span>,<br/></span><span>      </span><span>'name' </span><span>=&gt; [<br/></span><span>        </span><span>'description' </span><span>=&gt; </span><span>'The player name.'</span><span>,<br/></span><span>        </span><span>'type' </span><span>=&gt; </span><span>'varchar'</span><span>,<br/></span><span>        </span><span>'length' </span><span>=&gt; </span><span>255</span><span>,<br/></span><span>        </span><span>'not null' </span><span>=&gt; </span><span>TRUE</span><span>,<br/></span><span>      </span><span>]</span><span>,<br/></span><span>      </span><span>'data' </span><span>=&gt; [<br/></span><span>        </span><span>'description' </span><span>=&gt; </span><span>'Arbitrary data about the player.'</span><span>,<br/></span><span>        </span><span>'type' </span><span>=&gt; </span><span>'blob'</span><span>,<br/></span><span>        </span><span>'size' </span><span>=&gt; </span><span>'big'</span><span>,<br/></span><span>      </span><span>]</span><span>,<br/></span><span>    </span><span>]</span><span>,<br/></span><span>    </span><span>'primary key' </span><span>=&gt; [</span><span>'id'</span><span>]</span><span>,<br/></span><span>  </span><span>]</span><span>;<br/></span><span><br/></span><span>  </span><span>return </span><span>$schema</span><span>;<br/></span><span>}</span></pre>
<p>Implementations of this hook need to return an associative array keyed by the table name whose values are an array that defines the respective table. The table definition consists of various types of information, particularly the individual column definitions (fields), and also things such as which fields represent the primary key, foreign keys (strictly for documentation purposes), unique keys, and indexes. For a full reference to all the available options, check out the Drupal.org (<span class="URLPACKT"><a href="https://www.drupal.org/">https://www.drupal.org/</a></span>) documentation pages for the Schema API.</p>
<p>In our example, we defined the two tables we mentioned and defined their fields inside the <kbd>fields</kbd> array. The <kbd>primary key</kbd> indicates which of the fields will be used for that purpose, opting for the standard <kbd>id</kbd> field for both. Speaking of which, the latter is a field of the type <kbd>serial</kbd>, which means that it is an integer that has an auto-increment option to it. For number fields such as integer, float, and numeric, the <kbd>unsigned</kbd> option means that numbers cannot go below 0. Also, <kbd>not null</kbd> is pretty easy to understand—it prevents the column from ever being empty.</p>
<p>For the team and player name, we opted for a simple <kbd>varchar</kbd> field that takes a maximum of 255 characters (a pretty standard table column definition), and these, too, cannot be null. The description field, on the other hand, is of the <kbd>text</kbd> type with the <kbd>normal</kbd> size (as opposed to <kbd>tiny</kbd>, <kbd>small</kbd>, <kbd>medium</kbd>, or <kbd>big</kbd>). In here, we want to store strings that are longer than 255 characters. At the time of writing this book, there is no full documentation for the available data types (and their options) for Drupal 8; however, the D7 version (<span class="URLPACKT"><a href="https://www.drupal.org/docs/7/api/schema-api/data-types">https://www.drupal.org/docs/7/api/schema-api/data-types</a></span>) is a good indicator and will pretty much work exactly the same.</p>
<p>Lastly, for the player table, we also have a <kbd>team_id</kbd>, which is a simple integer field, and a <kbd>data</kbd> column, in which we want to store some arbitrary serialized data. This is a <kbd>blob</kbd> type, which can also be <kbd>big</kbd> or <kbd>normal</kbd>.</p>
<p>That is pretty much all for our schema definitions. Installing the <kbd>sports</kbd> module will create these tables for us automatically, according to these definitions. Also, just as important, uninstalling the module will delete these tables, so we don't need to do any kind of handling. However, if our module is already enabled and we add this implementation afterward, it won't get fired. Instead, we will need to implement an update hook and use the <kbd>drupal_install_schema()</kbd> function, which will trigger it. Like this:</p>
<pre>drupal_install_schema('sports');  </pre>
<p>We will see more about update hooks soon.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Running queries</h1>
                </header>
            
            <article>
                
<p>Now that we have some tables to work with, let's take a look at how we can run queries against them. If you are following along, for testing purposes, feel free to add some dummy data into the tables via the database management tool of your choice. We will look at <kbd>INSERT</kbd> statements soon, but before that, we will need to talk about the more common types of query you'll run—<kbd>SELECT</kbd>.</p>
<p>Queries using the Drupal 8 database abstraction layer are run using a central database connection service—<kbd>database</kbd>. Statically, this can be accessed via a shortcut:</p>
<pre>$database = \Drupal::database();  </pre>
<p>This service is a special one compared to the ones we saw before, because it is actually created using a factory. This is its definition to better help you understand what I mean:</p>
<pre>database:<br/>  class: Drupal\Core\Database\Connection<br/>  factory: Drupal\Core\Database\Database::getConnection<br/>  arguments: [default]</pre>
<p>This is a definition by which the responsibility for the instantiation is delegated to the factory mentioned, instead of the container as we've seen before. So, the resulting class does not necessarily need to match the one specified for the <kbd>class</kbd> key. However, in this case, the <kbd>Drupal\Core\Database\Connection</kbd> is an abstract base class that the resulting service extends. Again, in this case, the <kbd>arguments</kbd> are responsible for specifying the type of connection that it has to create. The site-default type is used (MySQL, usually), which means that the resulting service will be an instance of <kbd>Drupal\Core\Database\Driver\mysql\Connection</kbd>.</p>
<p>From this connection service, we can then request the relevant object with which we can build queries. So, let's see how these work.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Select queries</h1>
                </header>
            
            <article>
                
<p>There are two ways we can run select queries in Drupal 8, and they both work similarly to the way they did in Drupal 7. We have the D8 equivalents of <kbd>db_query()</kbd> and <kbd>db_query_range()</kbd> and the equivalent of <kbd>db_select()</kbd>. This will look familiar to D7 developers. In Drupal 8, these procedural functions still exist, but in a deprecated state. This means that instead of using the old functions, we should use the connection service I will mention next.</p>
<p>The first type of select query is typically more performant because we construct them by writing the SQL statements ourselves (with placeholders, of course), whereas the <kbd>db_select()</kbd> type of query is an OOP query builder that still needs to transform a chained object construct into an SQL statement. However, don't let this performance be a real deciding factor, because as you can imagine, the impact is minimal. Also, the query builder is the more proper way of running queries, because they are alterable (can be deconstructed).</p>
<p>The first type of select query is typically used for simpler queries, but if you are an SQL guru, it can actually be faster and easier to write a complex query using that method. Moreover, they rely on developers ensuring that the SQL statement is compatible with the underlying database. So, it is up to you which of the two types you choose, considering all of these factors.</p>
<p>Let's first take a look at how we can run a basic query against our tables using the <kbd>db_query()</kbd>-like method. We'll then see how the same query can be run using the other way:</p>
<pre>$database = \Drupal::database();<br/>$result = $database-&gt;query("SELECT * FROM {players} WHERE id = :id", [':id' =&gt; 1]);</pre>
<p>This is a simple SQL statement, albeit a bit funky if you have not done any D7 development. We passed the query string as the first argument to the <kbd>query()</kbd> method of the connection object. The second argument is an array of placeholder values for this query string. These are found throughout the SQL string proceeded by a colon (<kbd>:id</kbd>) and are later replaced with the value that maps to the same key in the placeholder values array. Another thing to note is that the table name in the query is surrounded by curly braces. This is because, in reality, table names can be prefixed when the site is installed, and our code should not concern itself with that prefix. Drupal will prepend it automatically.</p>
<p>Now, let's take a look at how we can run the same query using the query builder:</p>
<pre>$result = $database-&gt;select('players', 'p')<br/>   -&gt;fields('p')<br/>   -&gt;condition('id', 1)<br/>   -&gt;execute();</pre>
<p>This time, we will use the <kbd>select()</kbd> method on the connection object to get our hands on a <kbd>SelectInterface</kbd> instance with which we can build our query. We need to pass the table we want to query, as well as an alias for that table. This is particularly important when performing joins. Then, we use the <kbd>fields()</kbd> method to specify which of the table columns we want to retrieve. The first parameter is the table alias, whereas the second (optional) is an array of column names. All columns will be included (<kbd>*</kbd>). Next, we have a single condition being applied to the query for the <kbd>id</kbd> <span>column </span>and the value <kbd>1</kbd>. The third optional parameter is the operator that defaults to <kbd>=</kbd>. Lastly, we execute the query and get the same result as with the preceding example.</p>
<p>You will immediately note, if you remember, that the structure of this query builder is very similar to the Entity Query, and the components are also chainable to a certain extent, as we will see.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Handling the result</h1>
                </header>
            
            <article>
                
<p>Both of the previous queries return a <kbd>StatementInterface</kbd>, which is iterable. So, to access its data, we can do this:</p>
<pre><span>foreach </span><span>(</span><span>$result </span><span>as </span><span>$record</span><span>) {<br/></span><span>  </span><span>$id </span><span>= </span><span>$record</span><span>-&gt;</span><span>id</span><span>;<br/></span><span>  </span><span>$team_id </span><span>= </span><span>$record</span><span>-&gt;</span><span>team_id</span><span>;<br/></span><span>  </span><span>$name </span><span>= </span><span>$record</span><span>-&gt;</span><span>name</span><span>;<br/></span><span>  </span><span>$data </span><span>= </span><span>$record</span><span>-&gt;</span><span>data</span><span>;<br/></span><span>}</span></pre>
<p>Each item in the loop is a <kbd>stdClass</kbd>, and their property names are the actual names of the columns returned, while their values are the column values.</p>
<p>Alternatively, the <kbd>StatementInterface</kbd> also has some fetcher methods that can prepare the results for us in different ways. These mostly come from the parent <kbd>\PDOStatement</kbd> class, which is native PHP. The simplest is <kbd>fetchAll()</kbd>:</p>
<pre>$records = $result-&gt;fetchAll();  </pre>
<p>This returns an array of <kbd>stdClass</kbd> objects, as we saw before, so it does all the looping to extract the records for us. If we want this array keyed by the value of a field in the record, we can perform the following:</p>
<pre>$records = $result-&gt;fetchAllAssoc('id');</pre>
<p>This will use the value in the <kbd>id</kbd> field to key the array.</p>
<p>If we're expecting single records, we can also use the <kbd>fetch()</kbd> method, which returns only one such object (the next one in the result set); <kbd>fetchObject()</kbd> does the same thing.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">More complex select queries</h1>
                </header>
            
            <article>
                
<p>Let's create a more complex query now, to join our team table and retrieve the team information in the same record as the player:</p>
<pre>$result = $database-&gt;query("SELECT * FROM {players} p JOIN {teams} t ON t.id = p.team_id WHERE p.id = :id", [':id' =&gt; 1]);  </pre>
<p>This will return the same record as before, but inclusive of the values from the matching team record. Note that since we have a join, we had to use table aliases here as well. There is one problem with this query, though—since both tables have the <kbd>name</kbd> column, we cannot use <kbd>*</kbd> to include all of the fields, as they will get overridden. Instead, we need to include them manually:</p>
<pre>$result = $database-&gt;query("SELECT p.id, p.name as player_name, t.name as team_name, t.description as team_description, p.data FROM {players} p JOIN {teams} t ON t.id = p.team_id WHERE p.id = :id", [':id' =&gt; 1]); </pre>
<p>As you can see, we specified the fields from both tables we wanted to include, and we indicated different names as aliases where there was a name conflict. Now, let's write the same query using the query builder:</p>
<pre><span>$query </span><span>= </span><span>$database</span><span>-&gt;</span><span>select</span><span>(</span><span>'players'</span><span>, </span><span>'p'</span><span>)</span><span>;<br/></span><span>$query</span><span>-&gt;</span><span>join</span><span>(</span><span>'teams'</span><span>, </span><span>'t'</span><span>)</span><span>;<br/></span><span>$query</span><span>-&gt;</span><span>addField</span><span>(</span><span>'p'</span><span>, </span><span>'name'</span><span>, </span><span>'player_name'</span><span>)</span><span>;<br/></span><span>$query</span><span>-&gt;</span><span>addField</span><span>(</span><span>'t'</span><span>, </span><span>'name'</span><span>, </span><span>'team_name'</span><span>)</span><span>;<br/></span><span>$query</span><span>-&gt;</span><span>addField</span><span>(</span><span>'t'</span><span>, </span><span>'description'</span><span>, </span><span>'team_description'</span><span>)</span><span>;<br/></span><span>$result </span><span>= </span><span>$query<br/></span><span>  </span><span>-&gt;</span><span>fields</span><span>(</span><span>'p'</span><span>, </span><span>[</span><span>'id'</span><span>, </span><span>'data'</span><span>])<br/></span><span>  -&gt;</span><span>condition</span><span>(</span><span>'p.id'</span><span>, </span><span>1</span><span>)<br/></span><span>  -&gt;</span><span>execute</span><span>()</span><span>;<br/></span><span><br/></span><span>$records </span><span>= </span><span>$result</span><span>-&gt;</span><span>fetchAll</span><span>()</span><span>;</span></pre>
<p>First of all, not all methods on the query builder are chainable. The <kbd>join()</kbd> method (and the other types of join methods, such as <kbd>innerJoin()</kbd>, <kbd>leftJoin()</kbd>, and <kbd>rightJoin()</kbd>) and the <kbd>addField()</kbd> method are prominent examples. The latter is a way we can add fields to the query by specifying an alias (we cannot do it via the <kbd>fields()</kbd> method). Moreover, the <kbd>condition()</kbd> field is also prefixed with the table alias it needs to be in (which was not necessary before when we didn't use a join).</p>
<p>For more information about all the other methods useful for building queries, go to <kbd>SelectInterface</kbd> and <kbd>ConditionInterface</kbd>. They are typically well-documented in there.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Range queries</h1>
                </header>
            
            <article>
                
<p>Since limiting queries to a certain range depends on the underlying database engine, we also have the <kbd>queryRange()</kbd> method on our database connection service, which we can use to write queries that include ranges:</p>
<pre> $result = $database-&gt;queryRange("SELECT * FROM {players}", 0, 10);  </pre>
<p>In this example, we query for all the players and limit the result set to the first 10 records (from 0 to 10). So, with this method, the placeholder value array is the fourth parameter after <kbd>$from</kbd> and <kbd>$count</kbd>.</p>
<p>Alternatively, using the <kbd>SELECT</kbd> query builder, we have a method on the <kbd>SelectInterface</kbd> whereby we can specify a range. So, in that format, the previous query would look like this:</p>
<pre>$result = $database-&gt;select('players', 'p')<br/>   -&gt;fields('p')<br/>   -&gt;range(0, 10)<br/>   -&gt;execute();</pre>
<p>As you can see, we have the <kbd>range()</kbd> method, which takes those arguments and limits the query.</p>
<div class="packt_infobox">A note on running select queries on Entity tables: if you can do so using the Entity Query, use that. If not, feel free to use the database API. However, stick to using the query to figure out the IDs of the entities you need, but then use the entity storage handler to load those entities properly. This is unlike the many times in Drupal 7 where we simply used field values from such queries directly. In Drupal 8, that is highly discouraged.</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Pagers</h1>
                </header>
            
            <article>
                
<p>Now that we have seen how to make <kbd>SELECT</kbd> queries of all kinds, let's take a look at how we can use Drupal's built-in pagination capabilities and how pagers work in Drupal 8. We will illustrate these by running some queries and rendering the results inside a table. Refer to <a href="feada4d1-f255-4dd6-83b5-8d66bab5f852.xhtml">Chapter 4</a>, <em>Theming</em>, if you don't remember the theming aspects of outputting a table.</p>
<p>Our playground will be inside a new controller method (<kbd>SportsController::players()</kbd>) which maps to the route with the <kbd>/players</kbd> path. Refer to <a href="601b4dd0-c521-459e-9342-2645a109642c.xhtml">Chapter 2</a>, <em>Creating Your First Module</em>, for a refresher on how to create routes if you don't remember.</p>
<p>The first thing we'll do is create a simple query that loads all the players and outputs them inside a table. We'll stick to only showing the player names for simplicity:</p>
<pre>/** 
 * Renders a table of players. 
 */ 
public function players() { 
  $query = $this-&gt;database-&gt;select('players', 'p') 
    -&gt;fields('p'); 
  $result = $query-&gt;execute()-&gt;fetchAll(); 
  $header = [$this-&gt;t('Name')]; 
  $rows = []; 
 
  foreach ($result as $row) { 
    $rows[] = [ 
      $row-&gt;name 
    ]; 
  } 
 
  $build = []; 
  $build[] = [ 
    '#theme' =&gt; 'table', 
    '#header' =&gt; $header, 
    '#rows' =&gt; $rows, 
  ]; 
 
  return $build; 
} </pre>
<p>All of this should already be familiar to you. We are running the query and preparing the data for a table, using the <kbd>table</kbd> theme hook to render it. You'll note that we are creating a <kbd>$build</kbd> array so that we can include more things in the final output.</p>
<p>By navigating to <kbd>/players</kbd>, we should now already <span>see </span>a table with our player names. This will be our baseline from which to explore pagers.</p>
<p>Pagers work by storing some information regarding a query in the global state, namely the total number of items to be paged, the limit of items per page, and an identifier for the respective pager (so we can potentially have multiple pagers at once). All of this information is set using the following code (you don't have to add this anywhere now):</p>
<pre>pager_default_initialize($total, $limit, $element = 0);  </pre>
<p>Moreover, the current page is determined by the query parameter in the URL, named <kbd>page</kbd>.</p>
<p>Once the pager is initialized, we have a <kbd>pager</kbd> render element we can use to easily render a themed pager that uses this information and builds all the necessary links to move between the pages. As query builders, we then have to read the current page and use that inside our query.</p>
<p>However, there is a much simpler way to work with pagers, and that is using <em>select extenders</em>. These are <em>decorator</em> classes for the <kbd>SELECT</kbd> query class we've seen before, and they allow us to decorate it with an extra functionality, such as pagers or sorting; they encapsulate the necessary functionality for handling pagers in the query. So, let's see it in action.</p>
<p>Here is how our player query would look using the <kbd>PagerSelectExtender</kbd>:</p>
<pre>$limit = 5; // The number of items per page. 
$query = $this-&gt;database-&gt;select('players', 'p') 
  -&gt;fields('p') 
  -&gt;extend('\Drupal\Core\Database\Query\PagerSelectExtender') 
  -&gt;limit($limit); 
$result = $query-&gt;execute()-&gt;fetchAll();  </pre>
<p>As you can see, we have an <kbd>extend()</kbd> method on the <kbd>SELECT</kbd> query builder, which allows us to pass the name of the class that will decorate the resulting <kbd>SELECT</kbd> query class. This also provides us with a new method called <kbd>limit()</kbd>, through which we specify the number of records to load per page. Under the hood, it uses the <kbd>range()</kbd> method we saw earlier. Moreover, when running the query, it initializes the pager for us using <kbd>pager_default_initialize()</kbd>, and even determines the current page all on its own. So typically you'll use the extender directly.</p>
<div class="packt_infobox">The <em>Decorator Pattern</em> is an object-oriented programming design pattern that allows us to statically or dynamically add behavior to an existing object without altering how it, or other objects of the same class, behaves inside. A decorator essentially wraps an existing object to provide extra functionality from the outside.</div>
<p>So, all we need to do now is render the following pager (below the table):</p>
<pre>$build[] = [ 
  '#type' =&gt; 'pager' 
]; </pre>
<p>Positively rocket science, right? Not really. If we refresh the page, we should now see only five players in the table, and also a pager below it.</p>
<p>The Pager render element (<span class="URLPACKT"><a href="https://api.drupal.org/api/drupal/core%21lib%21Drupal%21Core%21Render%21Element%21Pager.php/class/Pager/8.2.x">https://api.drupal.org/api/drupal/core%21lib%21Drupal%21Core%21Render%21Element%21Pager.php/class/Pager/8.2.x</a></span>) has some interesting properties we can use to customize it further. We can append query elements to the resulting links, or even specify another route for the links if we want to. We can, of course, control the label of the pager links, and even the number of links being output. Check out the documentation of this element for more information.</p>
<p>Moreover, for full customization, we also have the option of preprocessing these variables by implementing our own preprocessor for the <kbd>pager</kbd> hook (such as <kbd>template_preprocess_page</kbd>) and/or overriding the <kbd>pager.twig.html</kbd> template file. We learned how to do these things in in <a href="feada4d1-f255-4dd6-83b5-8d66bab5f852.xhtml">Chapter 4</a>, <em>Theming</em>.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Insert queries</h1>
                </header>
            
            <article>
                
<p>In order to get data into our custom database tables, we have an <kbd>INSERT</kbd> query builder that we can use. For this and the other types of queries it is highly discouraged to use the <kbd>db_query()</kbd> approach because Drupal cannot ensure that it works across the different types of database engines. Instead, we can use the <kbd>insert()</kbd> method on the connection service and build our query using the <kbd>Insert</kbd> object that gets returned. So, let's see how we can add a record to our <kbd>players</kbd> table:</p>
<pre><span>$database</span><span>-&gt;</span><span>insert</span><span>(</span><span>'players'</span><span>)</span><span>;<br/></span><span>$fields </span><span>= [</span><span>'name' </span><span>=&gt; </span><span>'Diego M'</span><span>, </span><span>'data' </span><span>=&gt; serialize([</span><span>'known for' </span><span>=&gt; </span><span>'Hand of God'</span><span>])]</span><span>;<br/></span><span>$id </span><span>= </span><span>$database</span><span>-&gt;</span><span>insert</span><span>(</span><span>'players'</span><span>)<br/></span><span>  -&gt;</span><span>fields</span><span>(</span><span>$fields</span><span>)<br/></span><span>  -&gt;</span><span>execute</span><span>()</span><span>;</span></pre>
<p>The main thing about an insert query is the <kbd>fields()</kbd> method. It expects an array of key/value pairs, where the keys are the column names and the values are the data that needs to be added to the respective columns. Alternatively, the first argument can be an array of the column names and the second an array of the values in the same order as the column names from the first array.</p>
<p>We can also run an <kbd>INSERT</kbd> query with multiple sets of values (records):</p>
<pre><span>$values </span><span>= [<br/></span><span>  [</span><span>'name' </span><span>=&gt; </span><span>'Novak D.'</span><span>, </span><span>'data' </span><span>=&gt; serialize([</span><span>'sport' </span><span>=&gt; </span><span>'tennis'</span><span>])]</span><span>,<br/></span><span>  </span><span>[</span><span>'name' </span><span>=&gt; </span><span>'Micheal P.'</span><span>, </span><span>'data' </span><span>=&gt; serialize([</span><span>'sport' </span><span>=&gt; </span><span>'swimming'</span><span>])]<br/></span><span>]</span><span>;<br/></span><span>$fields </span><span>= [</span><span>'name'</span><span>, </span><span>'data'</span><span>]</span><span>;<br/></span><span>$query </span><span>=  </span><span>$database</span><span>-&gt;</span><span>insert</span><span>(</span><span>'players'</span><span>)<br/></span><span>  -&gt;</span><span>fields</span><span>(</span><span>$fields</span><span>)</span><span>;<br/></span><span>foreach </span><span>(</span><span>$values </span><span>as </span><span>$value</span><span>) {<br/></span><span>  </span><span>$query</span><span>-&gt;</span><span>values</span><span>(</span><span>$value</span><span>)</span><span>;<br/></span><span>}<br/></span><span>$result </span><span>= </span><span>$query</span><span>-&gt;</span><span>execute</span><span>()</span><span>;</span></pre>
<p>In this example, the <kbd>fields()</kbd> method receives only an array of column names that need to be inserted, and we use <kbd>values()</kbd> method calls to add the individual values.</p>
<p>The <kbd>execute()</kbd> method typically returns the ID (primary key) of the last record to be inserted. This is handy, especially if you insert only one record. However, for multiple inserts, it can also be misleading. So, do experiment for yourself with different use cases.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Update queries</h1>
                </header>
            
            <article>
                
<p>Now that we've seen <kbd>INSERT</kbd> queries, let's take a look at how we can update existing records. Say we wanted to update one of our player records; we will do so as follows:</p>
<pre><span>$result </span><span>= </span><span>$database</span><span>-&gt;</span><span>update</span><span>(</span><span>'players'</span><span>)<br/></span><span>  -&gt;</span><span>fields</span><span>([</span><span>'data' </span><span>=&gt; serialize([<br/></span><span>    </span><span>'sport' </span><span>=&gt; </span><span>'swimming'</span><span>, <br/></span><span>    </span><span>'feature' </span><span>=&gt; </span><span>'This guy can swim'<br/></span><span>  </span><span>])])<br/></span><span>  -&gt;</span><span>condition</span><span>(</span><span>'name'</span><span>, </span><span>'Micheal P.'</span><span>)<br/></span><span>  -&gt;</span><span>execute</span><span>()</span><span>;</span></pre>
<p><kbd>UPDATE</kbd> queries are like <kbd>INSERT</kbd> ones, except that they take a <kbd>condition()</kbd> to figure out which records to update (all that match the condition). Leaving this out will update all records, naturally. Using the <kbd>fields()</kbd> method, we will simply specify which columns are getting updated, and with what. If we leave out a column, it will stay untouched. Lastly, the result of this query is the total number of records affected.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Delete queries</h1>
                </header>
            
            <article>
                
<p>Lastly, we can also get rid of our records using the <kbd>DELETE</kbd> query:</p>
<pre>$result = $database-&gt;delete('players')<br/>   -&gt;condition('name', 'Micheal P.')<br/>   -&gt;execute();</pre>
<p>All records that match the condition will get removed. Be careful with this because, as with update queries, leaving out a condition will basically truncate your table. The query will return the number of records affected, that is, deleted.</p>
<div class="packt_infobox">Although you can write <kbd>SELECT</kbd> queries against entity and field tables to find the IDs of the entities you want to load, you should never perform <kbd>INSERT</kbd>, <kbd>UPDATE</kbd>, or <kbd>DELETE</kbd> queries against these tables. You run a very high risk of corrupting your data.</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Transactions</h1>
                </header>
            
            <article>
                
<p>The Drupal database API also provides a way to represent and handle database transactions (for database types that support them). Transactions are a way in which database operations can be wrapped and grouped together with a view of committing them in an "all or none" type of fashion. For example, if you have multiple records that are related, it's possible you will want only some of them written if one fails its <kbd>INSERT</kbd> operation for some reason. This could leave you with corrupt or incomplete data that could throw your application into a spin.</p>
<p>Performing multiple database-changing operations after a transaction has been opened only finalizes (commits) those changes to the database when that transaction closes. If something goes wrong, it can also be rolled back, which will prevent the data from being committed.</p>
<p>In Drupal 8, a transaction is represented by a <kbd>Transaction</kbd> object (a specific subclass for each database type). As soon as the object is destroyed (is no longer in scope), the operations get committed to the database. However, if we get an indication that something went wrong in our operations (usually via catching an exception), we can roll back the transaction, which will stop those operations from being committed. Moreover, transactions can be nested, so Drupal keeps track of transactions that have been opened within the scope of other transactions.</p>
<p>Let's see an example of how to use transactions:</p>
<pre><span>$transaction </span><span>= </span><span>$database</span><span>-&gt;</span><span>startTransaction</span><span>()</span><span>;<br/></span><span>try </span><span>{<br/></span><span>  </span><span>$database</span><span>-&gt;</span><span>update</span><span>(</span><span>'players'</span><span>)<br/></span><span>    -&gt;</span><span>fields</span><span>([</span><span>'data' </span><span>=&gt; serialize([</span><span>'sport' </span><span>=&gt; </span><span>'tennis'</span><span>, </span><span>'feature' </span><span>=&gt; </span><span>'This guy can play tennis'</span><span>])])<br/></span><span>    -&gt;</span><span>condition</span><span>(</span><span>'name'</span><span>, </span><span>'Novak D.'</span><span>)<br/></span><span>    -&gt;</span><span>execute</span><span>()</span><span>;<br/></span><span>}<br/></span><span>catch </span><span>(\Exception </span><span>$e</span><span>) {<br/></span><span>  </span><span>$transaction</span><span>-&gt;</span><span>rollback</span><span>()</span><span>;<br/></span><span>  </span><span>watchdog_exception(</span><span>'my_type'</span><span>, </span><span>$e</span><span>)</span><span>;<br/></span><span>}</span></pre>
<p>The first thing we did was start a transaction using our connection service. Then, we wrapped our operation in a <em>try/catch</em> block to catch any exceptions that might be thrown in performing it. If one does get thrown, we roll back the transaction because we don't want to commit anything to the database, as we don't know what failed and what shape our data is in. Finally, we used the <kbd>watchdog_exception()</kbd> helper to log the exception to the database log. Do note that logging this before the rollback would prevent the exception from being written to the database as well.</p>
<p>If there is no exception, the operation gets committed as soon as the <kbd>$transaction</kbd> variable gets removed and is no longer in scope (usually at the end of the function). It is also interesting to note that if, within this transaction, we call another function in which we perform database operations, those operations will be part of this same transaction by default. So they also get rolled back if we roll back or get committed if we don't. This is why the database watchdog log will not be saved if called before the rollback.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Query alters</h1>
                </header>
            
            <article>
                
<p>Lots of things in Drupal are alterable using various hooks; queries are no different. This means that if a module writes a query such as we've seen before, other modules can alter it by implementing <kbd>hook_query_alter()</kbd>. So let's consider an example of how this may work.</p>
<p>Let's assume the following query, which simply returns all player records:</p>
<pre>$result = $database-&gt;select('players', 'p')<br/>   -&gt;fields('p')<br/>   -&gt;execute();</pre>
<p>Imagine that another module wants to alter this query and limit the results to find only the players in a specific team. There is one problem. Our query has no markers that can indicate to another module that this is the one that needs to be altered. As you can imagine, there are a bunch of queries that are run in any given request, so identifying queries becomes impossible. Enter <em>query tags</em>.</p>
<p>The previous query would not be alterable because it's not recognizable, and therefore, <kbd>hook_query_alter()</kbd> is not even fired on it. In order to make it alterable, we will need to add a query tag and make it identifiable. There is a simple method on the query builder for doing just that: <kbd>addTag()</kbd>:</p>
<pre>$result = $database-&gt;select('players', 'p')<br/>   -&gt;fields('p')<br/>   -&gt;addTag('player_query')<br/>   -&gt;execute();</pre>
<p>Query tags are simple strings that can be read from inside a <kbd>hook_query_alter()</kbd> implementation. So, we could alter the query like this:</p>
<pre><span>/**<br/></span><span> * Implements hook_query_alter().<br/></span><span> */<br/></span><span>function </span><span>module_name_query_alter</span><span>(Drupal\Core\Database\Query\AlterableInterface </span><span>$query</span><span>) {<br/></span><span>  </span><span>if </span><span>(!</span><span>$query</span><span>-&gt;</span><span>hasTag</span><span>(</span><span>'player_query'</span><span>)) {<br/></span><span>    </span><span>return</span><span>;<br/></span><span>  </span><span>}<br/></span><span><br/></span><span>  </span><span>// Alter query<br/></span><span>}</span></pre>
<p>The only parameter of this hook is the query object onto which we can apply our changes. It also has methods for reading the tags, such as <kbd>hasTag()</kbd>, <kbd>hasAnyTag()</kbd>, or <kbd>hasAllTags()</kbd>. In the previous example we took a defensive approach and simply exited if the query was not about our <kbd>player_query</kbd> tagged query. I'll come back to this later on.</p>
<p>Now, let's see how we can alter this query to achieve what we set out to do:</p>
<pre><span>$query</span><span>-&gt;</span><span>join</span><span>(</span><span>'teams'</span><span>, </span><span>'t'</span><span>, </span><span>'t.id = p.team_id'</span><span>)</span><span>;<br/></span><span>$query</span><span>-&gt;</span><span>addField</span><span>(</span><span>'t'</span><span>, </span><span>'name'</span><span>, </span><span>'team_name'</span><span>)</span><span>;<br/></span><span>$query</span><span>-&gt;</span><span>condition</span><span>(</span><span>'t.name'</span><span>, </span><span>'My Team'</span><span>)</span><span>;</span></pre>
<p>As you can see, we are doing a similar thing to what we did before when we built our joined query. We join the team table, add its name field (as a bonus), and set a condition to only return the players in a certain team. Easy peasy.</p>
<p>Let's now return for a second to my remark about the defensive approach we took with this hook implementation. I personally prefer to keep methods short and return early, rather than have a bunch of unintelligible nested conditions. This is typically easy to do in an object-oriented setting. However, with procedural code, it becomes a bit more tedious as you need many private functions that are tricky to name, and even more so with hook implementations into which you might need to add more than one block of code. For example, in our <kbd>hook_query_alter()</kbd> implementation, we might need to add an alteration for another query later on. Also, since we return early, we need to add another condition for checking for two tags, and then some more conditions and <em>if</em> statements, and even more conditions (<span><span>OK</span></span>, rant over). From a PHP point of view, in this case you'd delegate the actual logic to another function based on the tag of the query, either using a simple switch block or <em>if</em> conditionals. This way, if a new tag comes, a new function can be created for it specifically and called from the switch block. However, we can do one better in this case.</p>
<p>There are a few hooks, particularly <em>alter</em> ones, that have general targeting but also a more specific one. In this example, we also have a <kbd>hook_query_TAG_alter()</kbd> hook, which is specific to a given tag. So, instead of us delegating to other functions, we could implement the more specific:</p>
<pre><span>/**<br/></span><span> * Implements hook_query_TAG_alter().<br/></span><span> */<br/></span><span>function </span><span>module_name_query_player_query_alter</span><span>(Drupal\Core\Database\Query\AlterableInterface </span><span>$query</span><span>) {<br/></span><span>  </span><span>// Sure to alter only the "player_query" tagged queries.<br/></span><span>}</span></pre>
<p>So, essentially, the tag itself becomes part of the function name, and we don't need any extra functions.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Update hooks</h1>
                </header>
            
            <article>
                
<p>At the beginning of this chapter, we defined two tables using <kbd>hook_schema()</kbd> which got installed together with the module. To reiterate, if the module had already been installed, we could have triggered the schema installation using the <kbd>drupal_install_schema()</kbd> function. However, what if we needed to add another column later on, say to the <kbd>teams</kbd> table? Our module is installed, and so is the schema; so we cannot exactly uninstall it on production just to trigger the schema creation again, not to mention losing the data. Luckily, there is a system in place for this, namely <em>update</em> hooks<span>—</span> <kbd>hook_update_N()</kbd>—where <kbd>N</kbd> represents the schema version. These are sequentially named hook implementations that go inside the module <kbd>*.install</kbd> file and that are triggered when running the updates, either via going to <kbd>/update.php</kbd> or by using the <kbd>drush updatedb</kbd> command.</p>
<p>The main purpose of these update hooks is making schema alterations to existing database tables. However, partly due to the weak configuration management system in earlier versions of Drupal, they have evolved—through developer creativity—into a mechanism for updating various types of configuration or performing tasks (even content-related) upon a deployment to the next environment. Helping out with this is the <kbd>$sandbox</kbd> argument passed to the hook implementations, which can be used to batch these operations (to prevent an execution timeout). We will not cover this aspect here, but will instead talk about the standalone Batch API in a future chapter, lessons from which you'll be able to apply here as well. Instead, we will see how to implement such a hook to perform schema updates.</p>
<p>As mentioned, these hook implementations go into the <kbd>*.install</kbd> file. Let's see an example:</p>
<pre><span>/**<br/></span><span> * Update hook for performing an update task.<br/></span><span> */<br/></span><span>function </span><span>my_module_update_8001</span><span>(&amp;</span><span>$sandbox</span><span>) {<br/></span><span>  </span><span>// Do stuff<br/></span><span>}</span></pre>
<p>The DocBlock of this hook implementation should contain a description of what it does. It is displayed when running the updates (either via the UI or using Drush).</p>
<p>The name of the function is one of its most important aspects. It starts with the module name, followed by <kbd>update</kbd>, and finally, by the module's schema version (the next one if we want this update hook to actually run); but what is a module's schema version?</p>
<p>When installed, Drupal sets each module a schema version: 8000. In Drupal 7, it was 7000, and in 6, it was 6000. You get the difference between the major versions of Drupal. When an update hook runs, Drupal sets that module's schema version to the number found in the update hook. So, in the previous example, it would be 8001. This is to keep track of all the update hooks and to not run them more than once. By convention, but not necessity, the second digit from the left in the schema version represents the major version number of the module itself. For example, for an <kbd>8.x-1.x</kbd> version, it would be 8101.</p>
<p>Let's now see how we can alter our <kbd>teams</kbd> database table with an update hook and add a column to store a <kbd>location</kbd> string field. The first thing we want to do is update our <kbd>hook_schema()</kbd> implementation and add this information there as well. This won't do anything in our case; however, due to the way update hooks work, we need to add it there as well. What I mean by this is that if a module is first installed and it has update hooks in it already, those update hooks do not run, but the module's schema version gets set as the number of the last update hook found in it. So, if we do not add our new column inside <kbd>hook_schema()</kbd>, installing this module on another site (or even on the current one after an uninstall) will not get our new column in. So, we need to account for both situations.</p>
<p>In the field definition of our <kbd>teams</kbd> table schema, we can add the following column definition:</p>
<pre>'location' =&gt; [<br/>   'description' =&gt; 'The team location.',<br/>   'type' =&gt; 'varchar',<br/>   'length' =&gt; 255,<br/> ],</pre>
<p>It's as simple as that. Next, we can implement an update hook and add this field to the table:</p>
<pre><span>/**<br/></span><span> * Adds the "location" field to the teams table.<br/></span><span> */<br/></span><span>function </span><span>sports_update_8001</span><span>(&amp;</span><span>$sandbox</span><span>) {<br/></span><span>  </span><span>$field </span><span>= [<br/></span><span>    </span><span>'description' </span><span>=&gt; </span><span>'The team location.'</span><span>,<br/></span><span>    </span><span>'type' </span><span>=&gt; </span><span>'varchar'</span><span>,<br/></span><span>    </span><span>'length' </span><span>=&gt; </span><span>255</span><span>,<br/></span><span>  </span><span>]</span><span>;<br/></span><span>  </span><span>$schema </span><span>= \Drupal::</span><span>database</span><span>()-&gt;</span><span>schema</span><span>()</span><span>;<br/></span><span>  </span><span>$schema</span><span>-&gt;</span><span>addField</span><span>(</span><span>'teams'</span><span>, </span><span>'location'</span><span>, </span><span>$field</span><span>)</span><span>;<br/></span><span>}</span></pre>
<p>Here, we used the same field definition, loaded the database connection service, and used its schema object to add that field to the table. The code itself is pretty self-explanatory, but it's also worth mentioning that this is an example in which we cannot inject the service, hence we have to use it statically. So, don't feel bad about situations like this.</p>
<p>Next, we can use Drush to run the updates:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/47651417-f60d-450c-acc1-fbe5471f4075.png" style="width:29.17em;height:14.08em;"/></p>
<p>Sure enough, the <kbd>teams</kbd> table now has a new column. If you try to run the updates again, you'll note that there are none to be run because Drupal has set the schema version of the <kbd>sports</kbd> module to 8001. So, the next one in line to be run has to have 8002 at the end (or, something greater than 8001 and lower than 9000, in any case).</p>
<p>In the previous example, we added a new field to an existing table. However, we might need to create a new table entirely, or even delete one. The schema object on the database connection service has the relevant methods to do so. The following are a few examples, but I recommend that you check out the base <kbd>Drupal\Core\Database\Schema</kbd> class for the available methods:</p>
<pre><span>$schema</span><span>-&gt;</span><span>createTable</span><span>(</span><span>'new_table'</span><span>, </span><span>$table_definition</span><span>)</span><span>;<br/></span><span>$schema</span><span>-&gt;</span><span>addField</span><span>(</span><span>'teams'</span><span>, </span><span>'location'</span><span>, </span><span>$field</span><span>)</span><span>;<br/></span><span>$schema</span><span>-&gt;</span><span>dropTable</span><span>(</span><span>'table_name'</span><span>)</span><span>;<br/></span><span>$schema</span><span>-&gt;</span><span>dropField</span><span>(</span><span>'table_name'</span><span>, </span><span>'field_to_delete'</span><span>)</span><span>;<br/></span><span>$schema</span><span>-&gt;</span><span>changeField</span><span>(</span><span>'table_name'</span><span>, </span><span>'field_name_to_change'</span><span>, </span><span>'new_field_name'</span><span>, </span><span>$new_field_definition</span><span>)</span><span>;</span></pre>
<p>There are a few cautionary aspects you need to consider when using update hooks. For example, you cannot be sure of the state of the environment before the hooks actually run, so ensure that you account for this. I recommend you check out the documentation (<span class="URLPACKT"><a href="https://api.drupal.org/api/drupal/core%21lib%21Drupal%21Core%21Extension%21module.api.php/function/hook_update_N/8.2.x">https://api.drupal.org/api/drupal/core%21lib%21Drupal%21Core%21Extension%21module.api.php/function/hook_update_N/8.2.x</a></span>) about <kbd>hook_update_N()</kbd> and carefully read the section about the function body.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Summary</h1>
                </header>
            
            <article>
                
<p>In this chapter, we looked at the basics of interacting with the database API. Although it's something that has taken a significant step back in importance in day-to-day Drupal module development, it's important to understand it and be able work with it.</p>
<p>We started the chapter by creating our very own database tables to hold player and team information in a relational way. We did so using an API that transforms definitions into actual tables without us having to even understand much about MySQL. The SQL terminology and basic operations are, however, something that every developer should be familiar with, notwithstanding their actual day-to-day application in Drupal.</p>
<p>Then, we looked at some examples of how we can run <kbd>SELECT</kbd>, <kbd>INSERT</kbd>, <kbd>UPDATE</kbd>, and <kbd>DELETE</kbd> queries using both the more SQL-oriented way of writing statements and the query builder approach, which uses an OO representation of the queries. We've also seen how these queries can be wrapped into transactions (where supported) so that we can commit data changes while minimizing the potential for incomplete or corrupt data. Finally, we saw how these queries can be altered using query tags, allowing for yet another small extension point that other modules can contribute through. Regardless of how we build our queries, however, a key takeaway is that using this API is crucial for a secure interaction with the database. Moreover, it accounts for cross-compatibility with the different database types Drupal can work with.</p>
<p>Lastly, we looked at update hooks and how they can be used to perform changes to our database tables. More than that, they can be employed to perform some other tasks that might need to be coded and then deployed to the next environment to be run once. However, due to the Drupal 8 Configuration API, the need for this has reduced significantly.</p>
<p>In the next chapter, we will look at custom Drupal 8 entity fields and see how we can define our own; yes, we'll be playing with some more plugins.</p>


            </article>

            
        </section>
    </body></html>