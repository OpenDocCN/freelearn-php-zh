- en: Chapter 8. Cooking Library Plugins
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Creating a library plugin
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Refining the plugin
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Configuring the plugin with PhpStorm
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Code hinting for the plugin
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Imagine a world where programmers such as you just enjoy writing code. That
    world seems enjoyable, perfect, and highly suitable for you in the first place.
    However, it isn't. What makes a programmer happier and satisfied more than anything
    in the world is the scenario in which the application reaches the end user. However,
    if programmers just enjoyed writing their code, who would ensure delivery of the
    code to the end user?
  prefs: []
  type: TYPE_NORMAL
- en: The end user can be anyone—a naive user, a professional user or even another
    programmer. So, regardless of the case, scenario, or end user, you, as a programmer,
    must be careful and concerned to make sure that whatever you code is (re)usable.
    Throughout your software-engineering life, you were told and you would be told
    not to reinvent the wheel. If you want this *dry* principle to be alive, you must
    make your code usable and reusable.
  prefs: []
  type: TYPE_NORMAL
- en: Another use case! Suppose you are asked to develop an application programming
    interface (API) in PHP. So, your task at hand is to write code. But another (untold)
    task for you is to ensure that the code you write can be included with minimum
    hassle. One quick solution to achieve this feat is to wrap up your application
    in an archive such that the archive itself can be included wherever required.
    Kindly read again! You need to have a bundle-like entity that you can pass on
    to the testing team to validate and verify. A wise programmer would advise the
    use of Phing to build the files together. However, the catch in this situation
    is that Phing will do what you ask it to do. However, do you actually know what
    to do?
  prefs: []
  type: TYPE_NORMAL
- en: You read it right that you need to create an archive. This time, we make use
    of a PHP archive, or phar, as they call it in the industry ([http://www.php.net/manual/en/book.phar.php](http://www.php.net/manual/en/book.phar.php)).
    Phar should not be alien to you. You must have used phar a number of times during
    your software engineering career. A PhpStorm cookbook author might have instructed
    you at some point in time as to how to get phar and include it in the PhpStorm
    library path. Can you recall how easy you used to find the task to have a PHP
    functionality in your project? If yes, it is the time to switch roles—from a phar
    user to a phar creator. If no, the time is ripe to learn how to create phars.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Phar is an archive file created in PHP. Like other archives, phars also contain
    a number of files and directories. To be able to use phar in your application
    code, you just need to include or require phar in your code. That's it! Phar would
    behave as if you included (or required) a regular PHP class. You will be able
    to use the classes, corresponding methods, and member variables that are declared
    inside phar (of course, the access specifiers will be respected).
  prefs: []
  type: TYPE_NORMAL
- en: However, having PhpStorm at your disposal helps you a lot. You can also include
    phar in the include path for the project so that a particular project is able
    to use the functionality provided by phar. If you need to make the PHP functionality
    available to all projects across your development machine, consider adding phar
    to the global include path.
  prefs: []
  type: TYPE_NORMAL
- en: PHP programming has always been fun. However, since you are an experienced member
    of your team, it is highly encouraged that you love your work while still taking
    care of the utility of the work.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a library plugin
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Have you ever thought about what makes up a library? A library is a collection
    of useful methods just as a book library is a collection of useful books. So is
    the case with an application library contains numerous useful methods and elements.
    The emphasis is on the word *useful* to stress the importance of not having redundant
    methods and elements in the library. A redundant piece of code requires documentation.
    When the company spends resources (essentially money), it will never want to have
    entities that have less usage. What is the reason for this? The principles of
    economics—the primary objective of any company is to maximize profit. No matter
    what!
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'However, not to worry, you do not need to be a Nobel Prize winner in Economics
    to stop putting redundant elements in the library. Just stay calm and stay wise.
    Cooking a plugin involves a number of engineering decisions to be made. Some of
    the decisions can be:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Decide what is that which makes you write a library**: You will not have
    the task of creating libraries too often. A library is a collection of a number
    of methods that you require a bit too often. So, to decide which methods are required,
    involves maturity.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Plan in advance**: Since a library is something that is used again and again
    without much modification, you will not get to release versions very often. Since
    the versions are released once in a while, if an incorrect plan creeps in while
    creating the library, it will be discovered very late that you do not have a big
    margin for error.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Make/reuse decision**: You have to decide whether the required library can
    be built by reusing another''s or even your code that you created for another
    project in the past. Remember, you need to have a sharp memory for that. The other
    option to decide on is whether to create a library from scratch.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: So, in essence, all the rules are to facilitate the creation of *phar* containing
    PHP code. Get ready for the ride!
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Choose a directory containing the code you want to include for the plugin. Since
    you have been attempting to cook pizza, you can assume a use case where an end
    user needs an algorithm to cook pizza. There, you have the requirements!
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a directory with the name `src`, which will contain the source PHP scripts.
    This will serve as the source for the library.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a directory with the name `build`, which will contain the target library,
    as shown in the following screenshot. This is the library you were longing for.![How
    to do it…](img/3878OT_08_00.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: There is a change that you need to make inside the `php.ini` file. To find out
    which `php.ini` your system uses, you can type `php-ini` inside PhpStorm (do you
    remember the command window available by the keyboard shortcut *Ctrl* + *Shift*
    + *X*). You need to add the line `phar.readonly=0` to enable creating phars with
    PHP.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You will need to define an entry point for the library. What's the reason for
    this? This is the way phars behave. There has to be an `index.php` file by default.
    You need to put it at the top level in the `src` (or sources) directory. At the
    minimum, it needs to include a file that will provide access to the required class
    in the library (of course, you can change the name of `index.php` to another `file.php`
    and make it act as the entry point).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In the current scenario, you need to include the file `PizzaDish.php` so that
    you are able to cook pizza again—this time by the library. So, considering PHP
    code, you will write something like the following:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Since phar is a PHP functionality, you need to write code to create a phar
    package. You will write something like the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: With that done, you can sit back and feel happy having created a new plugin
    that you can easily pass on to the testing and the quality assurance teams.
  prefs: []
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: It's time for the nuts and bolts and grease and dirty workshop clothes!
  prefs: []
  type: TYPE_NORMAL
- en: 'You can see that you did nothing extraordinary: you just wrote very simple
    and native PHP code to generate an archive that will be available to be used as
    a plugin. You created directories to contain the source files and the build file(s)
    separately. This step was not a mandatory step, but it ensured that your working
    area remained clean.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `index.php` file serves as the entry point for phar. Thus, when you include
    a functionality, you need to involve the reference to that functionality. This
    is what you do when you *include* `PizzaDish.php`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: When you write this, you are initializing the phar-creating facility, which
    takes in the name of the expected plugin (the first argument), flags to pass to
    the parent class `RecursiveDirectoryIterator` (the second argument), and the name
    of the archive that will serve as its calling name. Thus, you will create a library
    that will have the filename `pizza.phar` and will be known as `pizza.phar` when
    you access it through the `phar://` stream.
  prefs: []
  type: TYPE_NORMAL
- en: You need to start buffering to initiate the process of creating the archive.
    Buffering is the process of writing to the disk until the time the buffering is
    stopped. It is done by `$phar->startBuffering();`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The source files inside a directory are included in the plugin that you created
    when you write the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The process of including files to the archive continues until you stop the buffering
    of the output. You need to stop buffering to finish the process of writing the
    changes to disk. The archive that you wrote will not be visible until you stop
    buffering. This is done by `$phar->stopBuffering();`.
  prefs: []
  type: TYPE_NORMAL
- en: Once you stop the buffering of the output, the output (which was the archive
    file) will be displayed to you. How? In the form of the archive itself! Simple,
    isn't it?
  prefs: []
  type: TYPE_NORMAL
- en: Refining the plugin
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Having a plugin by your side definitely encourages you. However, this encouragement
    can lead to some dire consequences if the software engineering principles are
    not applied to the plugin at hand. The plugin at hand can then lead you to become
    an engineer at bay!
  prefs: []
  type: TYPE_NORMAL
- en: Software engineering is the entity that does not let you forget it easily in
    whatever you do. You need to validate that the product you created (here, the
    plugin) is working correctly. Now, this *correctly* has a very broad meaning.
    Simply put, you just need to check that the plugin you created performs the intended
    action. Another aspect is verification. Having checked the intended actions, you
    need to check whether the action performed is correct or not. This is especially
    useful because the actual testing is done on the plugin according to this phenomenon.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You need to take two actions. Both are mandatory. The first is the validation
    part. You need to validate if the pizza-cooking plugin works or not. To do that,
    you need to:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new PHP file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Include (or require) the plugin you created in it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Run this file, as shown in the following screenshot.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If the run process gets completed as shown, it means your pizza is being cooked.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![How to do it…](img/3878OT_08_01.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: 'Now comes the verification part. You might need to verify that the dish you
    are cooking is actually pizza, else you might end up destroying your taste buds.
    To verify this is rather a vague sequence of steps, and it is not impossible to
    have different versions. The steps can be:'
  prefs: []
  type: TYPE_NORMAL
- en: Check whether the classes in the plugin are accessible freely. You will need
    to create a new instance of the object. Thus, something like `$pizza = new PizzaDish('Mushroom',
    'Dish')` should not produce an error. You should be able to use the object and
    the members in some external class in just the same way as you use a locally created
    class. Also, something like `echo $pizza->getDishName()` should not create an
    error about the unavailability of this function and should perform the intended
    activity correctly.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'If a problem occurs in the plugin that you think is not in accordance with
    business requirements, you need to (obviously) fix it (quickly). So, you might
    need to again follow a few steps:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the `src` directory, locate the file (here `PizzaDish.php`).
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Identify the error-creating (or misbehaving) line(s).
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Make the appropriate changes.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Create phar afresh with the changed source code. You might want to revisit the
    *Creating a library plugin* recipe.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Repeat steps 1-3 until the plugin starts behaving in the way it was expected
    to behave.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Whatever you do, you just need to have a refined version of the plugin.
  prefs: []
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The working of the validation process is quite straightforward to understand.
    The validation of a product checks whether the plugin that you created is actually
    working as a plugin. Thus, you check for possible errors and problems in the process
    of using the plugin as a system. This is like saying, "Dude, check whether the
    plugin is working". Can you imagine who says this? A programmer says this to his
    fellow programmer!
  prefs: []
  type: TYPE_NORMAL
- en: The verification process needs to be understood. When you create a plugin, you
    don't know which agent will use it—it could be a command-line user, an IDE, or
    another bigger plugin. So, you need to ensure that the plugin you wrote is usable.
    Thus, when you create a new object, you check whether the classes that you intended
    to provide in the plugin are present. When you call a method, you check whether
    the method defined inside the plugin is accessible, and that too, no improper
    access specifier is restricting you from using the method.
  prefs: []
  type: TYPE_NORMAL
- en: The process of verification of the plugin is rather cyclic. Since it is your
    responsibility to ensure a proper functioning plugin, you need to repeat the verification
    steps until the quality assurance team is fully satisfied with the plugin. In
    the process, if you detect errors, you would have to go back to the source code
    to fix the problems and rebuild the entire plugin again.
  prefs: []
  type: TYPE_NORMAL
- en: So, the process continues for you. You write code. The code gets tested. You
    correct code. The code gets tested. The code gets tested. You create a plugin.
    The plugin gets tested. You go back to the correct code, and the process continues
    from that point. Cyclic, isn't it?
  prefs: []
  type: TYPE_NORMAL
- en: Configuring the plugin with PhpStorm
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When it comes to saying that there is a plugin, it is to be assumed that there
    has to be a user of that plugin. Since you are a PhpStorm lover, you can safely
    assume that PhpStorm can be (one of the) possible users of the plugin. So, you
    need to act as a pseudo recipient of the library plugin and make an attempt to
    use the library. By configuring, it is to be understood as making the necessary
    adjustments in the project structure so that the library can be used to add functionality
    to the project. The age-old practice of reusability is at work, you see.
  prefs: []
  type: TYPE_NORMAL
- en: The main advantage that is associated with a library plugin is the ease of inclusion
    in a project. You just have to make use of this advantage.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To configure the plugin with PhpStorm, the steps to be followed are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Obtain phar from whichever source you wish.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a directory inside your project with a proper and descriptive name.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The plugin can be used very easily via `require(_once) 'phar://name-of-phar.phar';`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: All done! So simple—quite unlike what it appeared to be. This is the power of
    PHP unleashed.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: However, if you think that you want to do more with the library and are more
    interested in doing development by tinkering with the internal classes and/or
    packages, you might need to select certain classes in particular. This is done
    as `require_once 'phar://pizza.phar/Dish.php';`.
  prefs: []
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The creation of a directory to hold the library plugin is not rocket science.
    It just facilitates obeying software engineering conventions. You as a developer
    or the plugin user is being referenced here. Thus, when you create a new directory,
    the code base of the project you are working on remains compartmentalised. So,
    when you need to change this library, you know where you have to go. Also, when
    you need to delete this library from your code base, you know where you have to
    go. If you are asked a question as to when you need to add a similar functioning
    library or some dependency, do you know where to go?
  prefs: []
  type: TYPE_NORMAL
- en: 'The way you use the library is dependent on the scenario. Recall that the library
    plugin contains two files: `PizzaDish.php` and `Dish.php`. If you want to use
    the basic functionality—cook pizza by adding some simple toppings and ingredients—requiring
    phar as a whole will serve the purpose. If you want selected functionality, specifying
    the name of the file relative to phar (inside phar) serves the purpose.'
  prefs: []
  type: TYPE_NORMAL
- en: Since phar is said to behave in the same way as a PHP file does, when you included
    phar, the hinting also starts. Thus, when you write `phar://pizza.phar/` and press
    *Ctrl* + *Space*, there is a list of all the files contained inside phar shown
    to you. You can select one from the list in just the same way you used to do for
    regular PHP files.
  prefs: []
  type: TYPE_NORMAL
- en: Code hinting for the plugin
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Here comes the actual utility of using an IDE for the plugin you created. It
    is a very common article of faith among developers that IDEs provide the autocompletion
    feature no matter what. However, at the same time, it is very uncommon amongst
    the same set of developers to know exactly how it is possible that the IDE provides
    autocompletion. Grandma always used to say *Ignorance never pays*. Exactly! Ignorance
    never pays (pun intended).
  prefs: []
  type: TYPE_NORMAL
- en: A question could be popping up in your mind. Why on the earth do you need to
    use the **autocomplete** feature? The answer to this might not be a diplomatic
    one, but it is true. In most cases, developers are ignorant enough not to write
    documentation for their code. Thus, autocompletion and / or code hinting serve
    as the saviors for the users of the code you provided. Since you are a programmer
    yourself, you can very easily understand the ease of using the code-hinting feature.
  prefs: []
  type: TYPE_NORMAL
- en: In the current context, you need to have similar settings so that PhpStorm is
    able to show you the documentation, method usage, and necessary information that
    is essential for a potential plugin user.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Enabling code hinting for a plugin is a one-liner. If you really want to configure
    code hinting for PhpStorm, you need to update the include path that PhpStorm respects.
    Updating the include path is done by opening the Project view and adding the location
    of phar to the list of libraries for the project.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The steps are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Select the Project view (*Alt* + *1*).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Find the `External Libraries` directory.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Press *F4*.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Provide the location of the directory where you have the plugin located.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on **Apply** and press **OK**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Done! Take a deep breath and press *Ctrl* + *Space* whenever you need code-hinting
    activation for this plugin. PhpStorm is again at your disposal!
  prefs: []
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: PhpStorm makes a lookup in the include paths that are available for the project
    and provides the list of classes and methods available in the current context.
    The system-wide include paths (`/usr/share/php`, `/usr/share/pear`, and so on.)
    are also looked up. Thus, when you add the phar to the include path, PhpStorm
    gets an additional path to look up.
  prefs: []
  type: TYPE_NORMAL
- en: So, the methods and classes available in phar (which you included in `index.php`)
    become available for code hinting. The code-hinting process covers the documentation,
    member methods, member variables, and every other thing that you designed to be
    available for use.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: It is worth noting that when you add the library plugin to the include path,
    you start getting hints in just the same way as other methods available in the
    classes and libraries declared in the include path, but there is a difference
    to be noted. When you add the library location in the include path, PhpStorm is
    able to provide you with *only* the code hints. If you want to use the methods,
    you will not be able to do that. Another aspect is that when you need to use the
    plugin, and you `require` (`_once`) it, the code hinting is available then too,
    but this time *only* to the current script.
  prefs: []
  type: TYPE_NORMAL
- en: What is the difference, then? The difference is in the usage and availability
    of the plugin and its methods.
  prefs: []
  type: TYPE_NORMAL
- en: To sum it up, if you wish to use the plugin, you need to use `include(_once)`
    or `require(_once)`, and when you need the code hinting to be available across
    the project, you need to add the location of the plugin to the PhpStorm include
    path.
  prefs: []
  type: TYPE_NORMAL
