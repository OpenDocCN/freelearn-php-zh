- en: 9\. Composer
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 9. Composer
- en: Overview
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 概述
- en: By the end of this chapter, you will be able to describe the benefits of using
    a dependency manager in your application; identify high-quality, open source packages
    to solve common problems; add third-party libraries to your project; set up autoloading
    in your project so that you don't have to use include statements; and implement
    the Monolog logging package.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，你将能够描述在应用程序中使用依赖管理器的优点；识别解决常见问题的优质开源包；将第三方库添加到你的项目中；在你的项目中设置自动加载，这样你就不必使用include语句；并实现Monolog日志包。
- en: Introduction
  id: totrans-3
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简介
- en: In the previous chapter, we covered how to handle error conditions by using
    PHP's built-in `Exception` class and how to use the `try`…`catch` block to control
    the flow of your application.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们介绍了如何通过使用PHP内置的`Exception`类来处理错误条件，以及如何使用`try`…`catch`块来控制应用程序的流程。
- en: Most modern-day applications are built on top of an amalgamation of other open
    source libraries. Many problems that are frequently encountered across all applications
    have already been solved and tested by developers who have made their solutions
    freely available to include in your project. This may be as small as a library
    that generates unique identifiers, or as large as full application frameworks
    that help you to organize your code. Take authentication, for example. Nearly
    every PHP application is going to include some form of authentication and, the
    majority of the time, it will be built in exactly the same way each time. We make
    use of third-party solutions for authentication, so we don't have to write the
    same authentication code over and over again in each application we write. Other
    examples of these types of libraries that are needed across multiple applications,
    known as cross-cutting concerns, are logging, security, and interacting with the
    filesystem. The list goes on.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数现代应用程序都是建立在其他开源库的混合之上。许多在所有应用程序中经常遇到的问题已经被开发者解决并测试过，他们已经将他们的解决方案免费提供给包括在你的项目中的使用。这可能是一个生成唯一标识符的库，也可能是一个完整的应用程序框架，帮助你组织代码。以身份验证为例。几乎每个PHP应用程序都将包含某种形式的身份验证，而且大多数情况下，它将以完全相同的方式构建。我们使用第三方解决方案进行身份验证，这样我们就不必在编写的每个应用程序中重复编写相同的身份验证代码。其他这类需要在多个应用程序中使用的库，称为横切关注点，包括日志记录、安全和与文件系统的交互。列表还在继续。
- en: With so many dependencies on external libraries, it becomes a necessity to have
    some tooling for the management of such libraries. In PHP, we are fortunate enough
    to have a great open source tool for that exact purpose – Composer. On top of
    that, if you are so inclined, you can leverage Composer to organize your company's
    frequently implemented features into a library that you use as a jumping-off point
    for all your applications, preventing the need to write the code over and over,
    and managing any updates to that library as it evolves.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 由于许多外部库的依赖，拥有一些用于管理这些库的工具变得至关重要。在PHP中，我们非常幸运地拥有一个专为这一目的设计的优秀开源工具——Composer。除此之外，如果你愿意，可以利用Composer将公司经常实现的功能组织成一个库，作为所有应用程序的起点，避免重复编写代码，并管理该库的任何更新。
- en: In this chapter, we will explain what dependency management is and why you should
    be using a tool to handle it for you. We will walk you through the essential commands
    you will use to start using it in your projects and explain the configuration
    file. We will introduce you to PSR-4, one of many recommendations defined by the
    **PHP Framework Interoperability Group** (**PHP-FIG**), which is not exclusive
    to Composer but is frequently utilized to streamline the inclusion of code in
    a process called **autoloading**. We will demonstrate autoloading by setting up
    a sample project that uses a popular logging framework, Monolog. Finally, we will
    introduce you to Packagist, a website that functions as a directory listing for
    packages, and we will give you some tips on navigating the site and evaluating
    the packages you find to help you choose packages that will not only provide the
    functionality you need but are backed by a level of support.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将解释什么是依赖管理以及为什么你应该使用一个工具来处理它。我们将带你了解你将用于在项目中开始使用它的基本命令，并解释配置文件。我们将介绍
    PSR-4，这是由 **PHP 框架互操作性小组**（**PHP-FIG**）定义的许多建议之一，它不仅限于 Composer，但经常被用来简化代码在称为
    **自动加载** 的过程中的包含。我们将通过设置一个使用流行的日志框架 Monolog 的示例项目来演示自动加载。最后，我们将介绍 Packagist，这是一个作为包目录列表的网站，我们将提供一些关于导航网站和评估你找到的包的建议，以帮助你选择不仅提供你需要的功能，而且有支持水平的包。
- en: Dependency Management
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 依赖管理
- en: 'You may be asking yourself why we need the complexity of another tool to manage
    our external dependencies for us. You could always just grab a copy of the source
    code and put it directly in your project. The answer is made apparent by one word
    in the question: *external*. The dependencies are not your code, and you don''t
    want to be responsible for managing them. This becomes even more apparent as you
    consider that those packages are likely to also depend on other libraries, which
    may still have dependencies themselves, and so on. This is further complicated
    by the fact that each of these libraries needs to be compatible with each other
    over time as they implement new features, bug fixes, and security maintenance
    releases.'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会问自己，为什么我们需要另一个工具的复杂性来管理我们的外部依赖。你总是可以直接获取源代码的副本并将其直接放入你的项目中。答案在问题中的一个词中变得明显：*外部*。这些依赖不是你的代码，你也不想负责管理它们。当你考虑到这些包可能也依赖于其他库，而这些库可能自身也有依赖，如此等等时，这一点变得更加明显。此外，随着这些库实现新功能、修复错误和安全维护版本，它们需要相互兼容，这也使得问题更加复杂。
- en: Composer does all the hard work of determining whether any of the libraries
    you depend on have upgrades available and determining which versions of those
    libraries are compatible with each other, and generates a verbose list of packages
    and their metadata that tells it exactly what to install and where those packages
    can be located for installation in the project. All you have to do is use a few
    simple commands or edit a configuration file to give Composer a list of packages
    you want to include in your project and run a command to install them.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: Composer 会完成所有艰苦的工作，确定你依赖的任何库是否有可用的升级，并确定这些库的哪些版本可以相互兼容，然后生成一个详尽的包及其元数据列表，告诉它确切需要安装什么以及这些包可以在项目的哪个位置安装。你所要做的就是使用几个简单的命令或编辑一个配置文件，为
    Composer 提供一个你想要包含在项目中的包列表，并运行一个命令来安装它们。
- en: Using Composer
  id: totrans-11
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 Composer
- en: Composer is a tool that you will most frequently interact with from the command
    line. The next few sections cover the most common operations you will use day
    to day, with exercises for each. You will need to have Composer installed, the
    instructions for which are provided in the preface. Composer can be installed
    at a project level or at a global level on your system. Ensure that you have installed
    Composer globally.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: Composer 是一个你将最频繁地从命令行与之交互的工具。接下来的几节将介绍你日常最常用的操作，并为每个操作提供练习。你需要安装 Composer，安装说明在序言中提供。Composer
    可以在项目级别或系统全局级别安装。确保你已经全局安装了 Composer。
- en: 'Exercise 9.1: Getting Started with Composer'
  id: totrans-13
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习 9.1：开始使用 Composer
- en: 'In this brief exercise, we will run Composer from the command line for the
    first time to verify that it is installed correctly, run a command that will give
    us a list of arguments we can pass to it in order to perform the various functions
    it has available, and then introduce you to the `help` command so that you can
    get summary information on any of the commands Composer has available:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个简短的练习中，我们将从命令行首次运行 Composer 以验证其是否正确安装，运行一个命令，该命令将给出我们可以传递给它的参数列表，以便执行其提供的各种功能，然后向您介绍
    `help` 命令，以便您可以获取 Composer 所提供的任何命令的摘要信息：
- en: Open your Command Prompt and navigate to the folder where you store your code.
  id: totrans-15
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开您的命令提示符并导航到您存储代码的文件夹。
- en: 'Verify that Composer is functioning properly by checking the version you have
    installed by running the following command:'
  id: totrans-16
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过运行以下命令来检查您已安装的 Composer 版本，以验证 Composer 是否正常工作：
- en: '[PRE0]'
  id: totrans-17
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The version number may be different, but if everything is set up correctly,
    you will see output similar to the following screenshot:'
  id: totrans-18
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 版本号可能不同，但如果一切设置正确，您将看到类似以下截图的输出：
- en: '![Figure 9.1: Printing the version number'
  id: totrans-19
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图 9.1：打印版本号'
- en: '](img/C14196_09_01.jpg)'
  id: totrans-20
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图片](img/C14196_09_01.jpg)'
- en: 'Figure 9.1: Printing the version number'
  id: totrans-21
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图 9.1：打印版本号'
- en: 'Next, list out all of the available functions of Composer with a short summary
    of each using the following command:'
  id: totrans-22
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，使用以下命令列出 Composer 所有的可用功能及其简要说明：
- en: '[PRE1]'
  id: totrans-23
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'You will obtain output similar to the following:'
  id: totrans-24
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 您将获得类似以下输出的结果：
- en: '![Figure 9.2: Functions of Composer'
  id: totrans-25
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图 9.2：Composer 的功能'
- en: '](img/C14196_09_02.jpg)'
  id: totrans-26
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图片](img/C14196_09_02.jpg)'
- en: 'Figure 9.2: Functions of Composer'
  id: totrans-27
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图 9.2：Composer 的功能'
- en: This is an easy way to explore the functionality of Composer and to look up
    commands you have used before but can't remember the exact names for.
  id: totrans-28
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这是一种探索 Composer 功能和查找您之前使用过但记不清确切名称的命令的简单方法。
- en: 'Lastly, the `help` command takes the name of a command as an argument and explains
    the usage of that feature. Call the `help` command, passing the `init` command
    as an argument:'
  id: totrans-29
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，`help` 命令接受一个命令名称作为参数，并解释该功能的用法。调用 `help` 命令，将 `init` 命令作为参数传递：
- en: '[PRE2]'
  id: totrans-30
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'You will obtain output similar to the following:'
  id: totrans-31
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 您将获得类似以下输出的结果：
- en: '![Figure 9.3: Screenshot of the help command'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 9.3：帮助命令的截图'
- en: '](img/C14196_09_03.jpg)'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片](img/C14196_09_03.jpg)'
- en: 'Figure 9.3: Screenshot of the help command'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 9.3：帮助命令的截图'
- en: The `help` command is a useful tool for looking up the specific syntax for any
    other command if you can't remember it, or even to discover options that may modify
    its behavior to suit your needs.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您记不起具体的语法，或者甚至想要发现可能修改其行为以适应您需求的选项，`help` 命令是一个有用的工具。
- en: Initializing a Project
  id: totrans-36
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 初始化项目
- en: 'Now that you''ve seen how to call Composer on the command line, you can initialize
    a project with some basic settings. These are stored in a file named `composer.json`,
    which should be in your project root directory. This file will include some meta-information
    about your project as well as definitions of every dependency to be installed
    in your project. Fortunately, Composer provides a simple command to get us started:
    `init`.'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您已经看到了如何在命令行上调用 Composer，您可以使用一些基本设置来初始化一个项目。这些设置存储在一个名为 `composer.json` 的文件中，该文件应位于您的项目根目录中。此文件将包含有关您项目的元信息以及您项目中要安装的每个依赖项的定义。幸运的是，Composer
    提供了一个简单的命令来帮助我们开始：`init`。
- en: 'Exercise 9.2: Initializing a Project'
  id: totrans-38
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习 9.2：初始化项目
- en: 'In this exercise, we will walk through the initial installation of a project
    using the `init` command. There are a few options you will be asked to configure,
    as you will see in the following:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们将通过使用 `init` 命令来逐步介绍项目的初始安装。您将需要配置一些选项，如下所示：
- en: Create a new directory to be the project directory for this example and navigate
    to it. Here, we will use `composer-example`.
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为此示例创建一个新的目录作为项目目录，并导航到该目录。这里，我们将使用 `composer-example`。
- en: 'From this directory, run the command to initialize a project:'
  id: totrans-41
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从此目录运行以下命令以初始化项目：
- en: '[PRE3]'
  id: totrans-42
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Type the name you would like to choose for your package and hit *Enter*:'
  id: totrans-43
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 输入您想要为您的包选择的名称并按 *Enter*：
- en: '[PRE4]'
  id: totrans-44
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Enter a description and hit *Enter*.
  id: totrans-45
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 输入描述并按 *Enter*。
- en: Hit *Enter* to accept the default author.
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按 *Enter* 以接受默认的作者。
- en: Enter `stable` as the minimum stability.
  id: totrans-47
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 输入 `stable` 作为最低稳定性。
- en: Note
  id: totrans-48
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意
- en: The minimum stability tells Composer what level of stability is acceptable when
    selecting which version of a package to install when you require one. The options,
    from most to least stable, are stable, RC, beta, alpha, and dev. Ordinarily, it's
    best to select "stable" for projects that will end up in production.
  id: totrans-49
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 最小稳定性告诉 Composer 在您需要包时选择哪个版本的包时可以接受的稳定性级别。选项，从最稳定到最不稳定，依次为稳定版、RC 版、beta 版、alpha
    版和开发版。通常，对于最终将用于生产的项目，选择 "稳定版" 是最好的。
- en: Enter *project* for the package type and hit *Enter*.
  id: totrans-50
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 输入 *project* 作为包类型并按 *Enter* 键。
- en: Hit *Enter* to skip selecting a license.
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按 *Enter* 键跳过选择许可证。
- en: Answer `no` to defining dependencies and dev dependencies interactively.
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对定义依赖和开发依赖项进行交互式操作时，回答 `no`。
- en: 'The output on your screen should look similar to this:'
  id: totrans-53
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 您屏幕上的输出应类似于以下内容：
- en: '![Figure 9.4: Screenshot after confirmation'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 9.4：确认后的截图'
- en: '](img/C14196_09_04.jpg)'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/C14196_09_04.jpg)'
- en: 'Figure 9.4: Screenshot after confirmation'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.4：确认后的截图
- en: You will now have a new `composer.json` file listed in your project root directory.
    The contents of the `composer.json` file are output to the screen as the final
    step of generating the file. Open it up and take a look at it. All the information
    you entered during the `init` command should be listed in the file. You can always
    make changes to this file directly, but it is easier to interact with it from
    the command line in most cases.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您项目根目录下将列出一个新的 `composer.json` 文件。`composer.json` 文件的内容在生成文件的最后一步输出到屏幕上。打开它并查看它。您在
    `init` 命令期间输入的所有信息都应该列在该文件中。您可以直接修改此文件，但在大多数情况下，从命令行与之交互更方便。
- en: Requiring Packages
  id: totrans-58
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 需求包
- en: At this stage, all the setup has been completed and you can begin pulling packages
    into your project. You only need to tell Composer that your project requires the
    package and Composer will determine the appropriate version of the package to
    install, alter the `composer.json` file to add the package as a dependency, and
    download the files for the project and place them in the vendor directory, which
    it will create if one does not exist.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 到此阶段，所有设置都已完成，您现在可以开始将包拉入您的项目。您只需要告诉 Composer 您的项目需要该包，Composer 将确定安装包的适当版本，修改
    `composer.json` 文件以将包添加为依赖项，并下载项目文件并将它们放置在供应商目录中，如果不存在，它将创建该目录。
- en: The vendor directory is a special directory where Composer keeps all of the
    files it adds to your project. This is configurable if you need it to be different,
    but generally, it's best to keep it with the default to keep with convention.
    Once you require packages, inside the folder, there will be a folder for each
    project that will contain the source code for that library. It is important not
    to edit files inside this directory, or you risk your changes being lost as packages
    are upgraded. In general, it's a good idea to keep your own code separate from
    the dependencies you are building on top of.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 供应商目录是一个特殊目录，Composer 将所有添加到您项目的文件都保存在这里。如果需要将其设置为不同的目录，则可以进行配置，但通常最好保持默认设置以符合惯例。一旦您在文件夹内需求包，将为每个项目创建一个文件夹，其中包含该库的源代码。重要的一点是不要编辑此目录内的文件，否则在包升级时您的更改可能会丢失。一般来说，将您自己的代码与您构建在之上的依赖项保持分离是一个好主意。
- en: In order to work through an example, we need to choose a package that is available
    to pull in via Composer. We have chosen Monolog, which happens to be developed
    and maintained by one of the primary developers of Composer. It is a handy library
    that serves as an abstraction of the logging functions that are commonly needed
    across all applications. It allows you to set up any number of processes that
    will listen for the log function to be called using a common interface and will
    log to their respective output, which ranges from the filesystem to NoSQL database
    clients, to a bucket on Amazon Web Services. If there's a place you want to capture
    your logs, there's a good chance that Monolog supports it and makes it easy to
    do so.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 为了通过一个示例进行操作，我们需要选择一个可以通过 Composer 拉取的包。我们选择了 Monolog，它恰好是由 Composer 的主要开发者之一开发和维护的。这是一个方便的库，它作为所有应用程序中常见日志功能的抽象。它允许您设置任意数量的进程，这些进程将使用通用接口监听日志函数的调用，并将日志记录到各自的输出中，这些输出从文件系统到
    NoSQL 数据库客户端，再到亚马逊网络服务的存储桶。如果您想捕获日志的地方，Monolog 很有可能支持它，并使其变得容易实现。
- en: 'Exercise 9.3: Adding Dependencies'
  id: totrans-62
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习 9.3：添加依赖
- en: 'In this exercise, we will add dependencies to your project using Composer.
    We have selected a popular logging framework, to begin with, that we will make
    use of later in the chapter:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们将使用 Composer 向您的项目添加依赖项。我们选择了一个流行的日志框架，我们将在本章后面使用它：
- en: In your Command Prompt, navigate to the directory where you initialized your
    project.
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在您的命令提示符中，导航到您初始化项目的目录。
- en: 'Run the command to install Monolog:'
  id: totrans-65
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行以下命令安装 Monolog：
- en: '[PRE5]'
  id: totrans-66
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The output is as follows:'
  id: totrans-67
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '![Figure 9.5: Installing Monolog'
  id: totrans-68
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图 9.5：安装 Monolog'
- en: '](img/C14196_09_05.jpg)'
  id: totrans-69
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图片 9.5](img/C14196_09_05.jpg)'
- en: 'Figure 9.5: Installing Monolog'
  id: totrans-70
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 9.5：安装 Monolog
- en: 'Examine the vendor directory:'
  id: totrans-71
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 检查供应商目录：
- en: '![Figure 9.6: Examining the directory'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 9.6：检查目录'
- en: '](img/C14196_09_06.jpg)'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片 9.6](img/C14196_09_06.jpg)'
- en: 'Figure 9.6: Examining the directory'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.6：检查目录
- en: 'Inside the vendor directory, you will see the directory for Monolog as well
    as its dependency, `psr`. There is also a directory for Composer itself, and an
    `autoload.php` file. We will cover the purpose of the autoload file later in this
    chapter. The `composer.json` file will also be updated, now including a line in
    the `require` section for `monolog/monolog` and showing you the version of the
    package it selected:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 在供应商目录中，您将看到 Monolog 的目录以及它的依赖项 `psr`。还有一个用于 Composer 自身的目录，以及一个 `autoload.php`
    文件。我们将在本章后面介绍自动加载文件的作用。`composer.json` 文件也将被更新，现在在 `require` 部分包括 `monolog/monolog`
    的一行，并显示它选择的包版本：
- en: '![Figure 9.7: Printing version'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 9.7：打印版本'
- en: '](img/C14196_09_07.jpg)'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片 9.7](img/C14196_09_07.jpg)'
- en: 'Figure 9.7: Printing version'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.7：打印版本
- en: Semantic Versioning
  id: totrans-79
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 语义化版本控制
- en: Packages available in Composer conform to a versioning convention known as semantic
    versioning. This is a standardized format for increasing version identifiers that
    applies a meaning, on which basis the number in the identifier increases. The
    official documentation is located at [https://semver.org/](https://semver.org/).
    The version is formatted so that it has three integers separated by periods. The
    first integer represents a major version change and indicates that the release
    may have breaking changes that their clients will need to rework in order to integrate
    with the library. The second integer indicates minor changes, such as new features,
    and should be backward compatible. The third number indicates bug fixes or security
    updates, also known as patches, and should typically be allowed to update automatically.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: Composer 中可用的包遵循一种称为语义化版本控制的版本约定。这是一个用于增加版本标识符的标准格式，它赋予数字以意义，基于此，标识符中的数字增加。官方文档位于
    [https://semver.org/](https://semver.org/)。版本格式化为三个整数，由点分隔。第一个整数代表主要版本变更，表明发布可能包含破坏性更改，其客户端需要重新工作以与库集成。第二个整数表示次要更改，如新功能，应向后兼容。第三个数字表示错误修复或安全更新，也称为补丁，通常应允许自动更新。
- en: When a number is increased, the numbers behind it are reset to 0\. For example,
    at the time of writing, when I installed the Monolog package, the current stable
    release is 1.24.0\. This means that there have been 24 minor releases since the
    project was deemed stable and ready for production. If a bug were found in the
    software and they released that individually, the next version number would be
    1.24.1\. After that, the next release of minor features would bring the version
    number to 1.25.0\. If they ever need to change the library in a way that breaks
    the consumer interface, the version would bump up to 2.0.0\. This is a very useful
    format, and I recommend using it for your own projects within your version control
    system.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个数字增加时，其后的数字会重置为 0。例如，在撰写本文时，当我安装 Monolog 包时，当前的稳定版本是 1.24.0。这意味着自项目被认为稳定并准备投入生产以来，已有
    24 个小版本发布。如果发现软件中存在错误并且他们单独发布，下一个版本号将是 1.24.1。之后，下一个小功能版本的发布将版本号提升到 1.25.0。如果他们需要以破坏消费者界面的方式更改库，版本号将提升到
    2.0.0。这是一个非常有用的格式，我建议在您的版本控制系统中的项目中使用它。
- en: Applying Version Constraints
  id: totrans-82
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 应用版本约束
- en: When you require a package, you may optionally specify version constraints that
    limit the available versions of that package that Composer may select to install.
    You will want to ensure that when you upgrade the packages installed by Composer,
    it does not automatically upgrade to a version that will be incompatible with
    your code base. The most common use case for this is that you only want to apply
    patch-level updates automatically and wait until you can test minor and major
    versions before releasing them alongside your code. Another example from my personal
    experience was a scenario when we converted a large legacy application to use
    Composer, which made use of a library several major versions behind the current
    one. It was not cost-effective to update the library, so I needed to lock it into
    the same version that was installed prior to being managed by Composer.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 当你需要一个包时，你可以选择性地指定版本约束，以限制 Composer 可能选择的安装的包的版本。你将想要确保当你升级由 Composer 安装的包时，它不会自动升级到一个将与你的代码库不兼容的版本。最常见的用例是你只想自动应用补丁级别的更新，并在可以测试次要和主要版本之前等待，然后再与你的代码一起发布。另一个例子来自我的个人经验，当时我们转换了一个大型遗留应用程序以使用
    Composer，该应用程序使用了比当前版本落后几个主要版本的库。更新库并不划算，所以我需要将其锁定在由 Composer 管理之前安装的同一版本。
- en: 'Composer offers a number of modifiers you can add to the version definition
    that will allow it to dynamically select a version according to your specifications.
    You can find a full description of the modifiers at [https://packt.live/2MJNAur](https://packt.live/2MJNAur).
    The two most common of these are the next-significant-release operators: one identified
    by a tilde character, as in ~1.24.3, and the other a caret, as in ^1.24.0\.'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: Composer 提供了一些修饰符，你可以添加到版本定义中，以便根据你的指定动态选择版本。你可以在 [https://packt.live/2MJNAur](https://packt.live/2MJNAur)
    找到这些修饰符的完整描述。其中最常见的是下一个重要版本的操作符：一个由波浪线字符表示，如 ~1.24.3，另一个是 caret 符号，如 ^1.24.0\。
- en: The tilde operator will limit upgrades to the next major or minor version, depending
    on whether the patch number is specified. For example, ~1.24.3 would accept any
    version prior to 1.25.0, while ~1.24 would accept any version prior to 2.0.0\.
    The caret operator is similar but assumes that any non-breaking change as specified
    by semantic versioning would be acceptable. If ^1.24.3 were specified, this would
    allow any upgrade prior to 2.0.0.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 波浪线操作符将限制升级到下一个主要或次要版本，具体取决于是否指定了补丁号。例如，~1.24.3 将接受任何低于 1.25.0 的版本，而 ~1.24 将接受任何低于
    2.0.0 的版本。caret 操作符类似，但假设任何非破坏性更改，如语义版本控制所指定，都是可接受的。如果指定了 ^1.24.3，这将允许任何低于 2.0.0
    的升级。
- en: 'Exercise 9.4: Applying Version Constraints'
  id: totrans-86
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习 9.4：应用版本约束
- en: 'In this exercise, we will introduce the `show` command and give an example
    of applying version constraints to a dependency. You will also see that when you
    require a package, you can add the version you would like installed to the end
    of the command and it will target that constraint:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们将介绍 `show` 命令，并给出将版本约束应用于依赖项的示例。你还会看到，当你需要包时，你可以在命令的末尾添加你希望安装的版本，它将针对该约束：
- en: 'From the Command Prompt, run the command to view the currently installed packages:'
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从命令提示符运行命令以查看当前安装的包：
- en: '[PRE6]'
  id: totrans-89
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Update your requirement to the 1.0.0 version of Monolog:'
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将你的需求更新到 Monolog 的 1.0.0 版本：
- en: '[PRE7]'
  id: totrans-91
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'If you run Composer again, you will see that Monolog has been downgraded to
    1.0.0:'
  id: totrans-92
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果你再次运行 Composer，你会看到 Monolog 已降级到 1.0.0：
- en: '![](img/C14196_09_08.jpg)'
  id: totrans-93
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![](img/C14196_09_08.jpg)'
- en: 'Figure 9.8: Screenshot of Composer'
  id: totrans-94
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 9.8：Composer 的截图
- en: 'Now, update the `require` command to accept version 1.23 or higher, but less
    than 2.0\. Note that it will install the highest version that is less than 2.0.0:'
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，更新 `require` 命令以接受 1.23 或更高版本，但低于 2.0\. 注意，它将安装低于 2.0.0 的最高版本：
- en: '[PRE8]'
  id: totrans-96
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Composer will again show that it has been brought back up to the current version
    (1.24.0 at the time of writing).
  id: totrans-97
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: Composer 将再次显示它已升级到当前版本（写作时的 1.24.0 版本）。
- en: Using these constraints, you can be confident that as time passes and new versions
    are released by vendors, your code will be unaffected until you are ready to implement
    their changes. You may also notice that the version of `psr/log` does not change
    with the version of Monolog being upgraded/downgraded, as 1.1.0 satisfies both
    versions.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这些约束，你可以确信随着时间的推移和新版本的发布，你的代码将不受影响，直到你准备好实施他们的更改。你也许还会注意到，`psr/log` 的版本不会随着升级或降级
    Monolog 的版本而改变，因为 1.1.0 满足这两个版本。
- en: The Lock File
  id: totrans-99
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 锁定文件
- en: At this stage, if you examine the files in your project directory, you will
    see the `composer.json` file you generated with the `init` command, the vendor
    directory that was created when you required a package, and lastly, a `composer.lock`
    file. The `composer.lock` file is a counterpart to the `composer.json` file and
    is regenerated every time you make a modification to the required packages. If
    you view the contents of the file, you will see a few sections, such as `_readme`
    and a content hash, but the primary one is the packages section, which details
    the packages you have installed and some metadata about each that allows Composer
    to reliably reinstall the packages in the same configuration they have at this
    point in time. Each package has the name listed, the version installed, the version
    control type, and the URL where it can be found, as well as any required dependencies,
    among other things.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个阶段，如果你检查你的项目目录中的文件，你会看到使用`init`命令生成的`composer.json`文件，当你需要一个包时创建的供应商目录，以及最后的`composer.lock`文件。`composer.lock`文件是`composer.json`文件的对应文件，每次你对所需包进行修改时都会重新生成。如果你查看文件的内容，你会看到几个部分，例如`_readme`和内容哈希，但主要的部分是包部分，它详细说明了你安装的包以及一些元数据，这些元数据允许Composer以相同的配置可靠地重新安装包。每个包都有列出名称、安装的版本、版本控制类型以及可以找到它的URL，以及其他所需依赖项等。
- en: This is important because it allows you to consistently reproduce the installation
    of your entire list of dependencies using the known versions you have used during
    development. Imagine a scenario in which you are brought onto a team to work on
    a project and `acme/awesome-package` was required in version 1.0.0\. However,
    by the time you join the project, version 2.0.0 has been released. Without the
    `.lock` file, you would be getting a version of the library that may be incompatible
    with the code base. Using the `install` command will make use of the `.lock` file
    to determine which versions of the packages to install, while the `update` command
    will ignore the current lock file and generate a new one with the most current
    versions that are compatible with all required packages. The `.lock` file specifies
    the exact versions of the packages that are installed each time you make an update
    to your dependencies. For this reason, both the `composer.json` and `composer.lock`
    files are typically committed to version control. By specifying the exact version
    that is installed, you can have confidence that the version you get will be compatible
    with your code until the point at which you explicitly update packages.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 这很重要，因为它允许你使用在开发期间使用的已知版本一致地重新安装整个依赖项列表。想象一下这样一个场景：你被带到团队中参与一个项目，需要使用版本1.0.0的`acme/awesome-package`。然而，当你加入项目时，版本2.0.0已经发布。如果没有`.lock`文件，你可能会得到一个可能与代码库不兼容的库版本。使用`install`命令将利用`.lock`文件来确定要安装的包的版本，而`update`命令将忽略当前的锁文件，并生成一个与所有所需包兼容的最新版本的新锁文件。`.lock`文件指定了每次更新依赖项时安装的包的确切版本。因此，通常将`composer.json`和`composer.lock`文件提交到版本控制。通过指定安装的确切版本，你可以有信心你得到的版本将与你的代码兼容，直到你明确更新包的那一刻。
- en: 'Exercise 9.5: Re-Installing Vendor Files'
  id: totrans-102
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习9.5：重新安装供应商文件
- en: 'To show you how the `composer.lock` file works, we will delete the vendor directory
    entirely and restore the required packages with the `install` command:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 为了展示`composer.lock`文件是如何工作的，我们将完全删除供应商目录，并使用`install`命令恢复所需包：
- en: 'From the Command Prompt, delete the entire vendor directory:'
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从命令提示符中删除整个供应商目录：
- en: 'OSX or Linux: `rm –rf vendor`'
  id: totrans-105
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 'OSX或Linux: `rm –rf vendor`'
- en: 'Windows: `rmdir vendor`'
  id: totrans-106
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 'Windows: `rmdir vendor`'
- en: View the contents of your project directory to see that the vendor directory
    has disappeared. You should still have both your `composer.json` and `composer.lock`
    files, which will allow you to reinstall your required packages by running the
    `install` command.
  id: totrans-107
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 查看你的项目目录的内容，以查看供应商目录已消失。你应该仍然拥有你的`composer.json`和`composer.lock`文件，这将允许你通过运行`install`命令重新安装所需包。
- en: 'Run the command to install the dependencies:'
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行以下命令来安装依赖项：
- en: '[PRE9]'
  id: totrans-109
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The output is as follows:'
  id: totrans-110
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '![Figure 9.9: Installing dependencies'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: '![图9.9：安装依赖项'
- en: '](img/C14196_09_09.jpg)'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: '![img/C14196_09_09.jpg](img/C14196_09_09.jpg)'
- en: 'Figure 9.9: Installing dependencies'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.9：安装依赖项
- en: Voilà! The vendor directory is restored, with all the files and folders from
    your dependencies back in their usual places.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 哇！供应商目录已恢复，所有依赖项的文件和文件夹都回到了它们通常的位置。
- en: Dev Dependencies
  id: totrans-115
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 开发依赖项
- en: Many of the packages your project depends on will be production code, but some
    of them will be libraries you use for development purposes only. A couple of examples
    of these would be testing frameworks and command-line utilities. Composer provides
    the capability to specify packages as dev dependencies, so that when you run the
    `install` command on a non-dev environment, you can pass the `--no-dev` flag and
    it will omit any development-only packages.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 你项目依赖的许多包将是生产代码，但其中一些将是仅用于开发目的的库。这些例子包括测试框架和命令行工具。Composer提供了将包指定为开发依赖项的能力，这样当你在非开发环境中运行`install`命令时，你可以传递`--no-dev`标志，它将省略任何仅用于开发的包。
- en: 'Exercise 9.6: Installing Development Dependencies'
  id: totrans-117
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习9.6：安装开发依赖项
- en: 'In this exercise, we will add the popular unit testing framework PHPUnit as
    a development dependency only:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们将仅将流行的单元测试框架PHPUnit添加为开发依赖项：
- en: 'Install the PHPUnit testing framework:'
  id: totrans-119
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 安装PHPUnit测试框架：
- en: '[PRE10]'
  id: totrans-120
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Now, if you view the contents of the `composer.json` file, you will see the
    `phpunit/phpunit` package listed under the `require-dev` section:'
  id: totrans-121
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，如果你查看`composer.json`文件的内容，你将在`require-dev`部分看到列出的`phpunit/phpunit`包：
- en: '![Figure 9.10: Contents of composer.json'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: '![图9.10：composer.json的内容'
- en: '](img/C14196_09_10.jpg)'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/C14196_09_10.jpg)'
- en: 'Figure 9.10: Contents of composer.json'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.10：composer.json的内容
- en: Requiring packages as dev dependencies is a way to maintain a nice separation
    between the code you intend to go out to production and the code that is really
    only meant for development purposes.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 将包作为开发依赖项是一种在打算推向生产的代码和真正仅用于开发目的的代码之间保持良好分离的方法。
- en: Packagist
  id: totrans-126
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Packagist
- en: Composer has a companion site at [https://packagist.org](https://packagist.org)
    that serves as the primary listing of all the packages available to be pulled
    into your project. When you are adding features to your application, you should
    first ask yourself whether other developers have likely solved this problem before
    you, and then you should check Packagist to see whether there's a package that
    can simplify the development of your feature. This will make you much more efficient
    as a developer, as you will not be spending time writing code that's been written
    time and time again by other developers and can focus on the code that makes your
    project deliver value. The cost of developing software is more than just writing
    code; you have to test the code and maintain it. Making a habit of using open
    source solutions can save you countless hours of development time in the long
    run. Simply search according to the keyword of the functionality you are looking
    for, or by the name of the package if you know it.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: Composer有一个配套网站[https://packagist.org](https://packagist.org)，它作为所有可拉入你项目的包的主要列表。当你正在向应用程序添加功能时，你应该首先问问自己，在其他开发者之前是否可能已经解决了这个问题，然后你应该检查Packagist，看看是否有可以简化你功能开发的包。这将使你作为一个开发者更加高效，因为你将不会花费时间编写其他开发者已经一次又一次编写过的代码，可以专注于使你的项目产生价值的代码。软件开发的成本不仅仅是编写代码；你还需要测试和维护代码。养成使用开源解决方案的习惯，从长远来看可以节省你无数的开发时间。只需根据你正在寻找的功能的关键词进行搜索，或者如果你知道包名，也可以按包名搜索。
- en: An important concept to understand when you are browsing packages on Packagist
    is that they are prefixed with a vendor namespace, followed by a slash and the
    name of the actual package. For example, there is a group of developers who call
    themselves *The League of Extraordinary Packages* because they produce a variety
    of open source libraries that are well-tested and use modern coding practices.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 当你在Packagist上浏览包时，理解的一个重要概念是它们以供应商命名空间为前缀，后面跟着一个斜杠和实际包的名称。例如，有一组开发者称自己为*非凡包联盟*，因为他们生产了各种经过良好测试的开源库，并使用现代编码实践。
- en: One of their popular packages is `flysystem`, a library that functions as an
    abstraction layer for interacting with the filesystem. The vendor name that they
    operate under is "league," so the name of the package is `league/flysystem`.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 他们最受欢迎的包之一是`flysystem`，这是一个作为与文件系统交互的抽象层的库。他们运营的供应商名称是"league"，因此包的名称是`league/flysystem`。
- en: Having both the vendor name and package name combined helps by allowing projects
    to have the same base name, while still being able to distinguish between two
    different packages. In some cases, a project that has the same name but two different
    vendor prefixes may be a project that was abandoned by one vendor and picked up
    by another under the new vendor name. That's one of the great things about open
    source. Projects are always available to be copied and used as a starting point
    for extension.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 将供应商名称和包名称结合使用，可以通过允许项目具有相同的基名，同时仍然能够区分两个不同的包来有所帮助。在某些情况下，具有相同名称但两个不同供应商前缀的项目可能是一个被一个供应商遗弃并由另一个供应商以新供应商名称拾起的项目。这是开源的一大优点。项目总是可供复制和使用，作为扩展的起点。
- en: 'Exercise 9.7: Discovering Packages on Packagist.org'
  id: totrans-131
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习9.7：在Packagist.org上发现包
- en: 'In the following exercise, we will walk through an example of the way you might
    use the Packagist site to seek out a package and some criteria you can use as
    guidance for evaluating different packages so that you can choose the one that''s
    right for your specific situation. We will search for a widely used package to
    handle logging functionality in our application:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的练习中，我们将通过一个示例来展示您如何使用Packagist网站寻找包，以及一些可以作为评估不同包的指导准则的标准，以便您可以选择适合您特定情况的包。我们将搜索一个广泛使用的包来处理我们应用程序的日志功能：
- en: 'Open a browser window and navigate to [https://packt.live/2MlwgNv](https://packt.live/2MlwgNv):![Figure
    9.11: Packagist window'
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开浏览器窗口并导航到[https://packt.live/2MlwgNv](https://packt.live/2MlwgNv)：![图9.11：Packagist窗口]
- en: '](img/C14196_09_11.jpg)'
  id: totrans-134
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图片 C14196_09_11.jpg]'
- en: 'Figure 9.11: Packagist window'
  id: totrans-135
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图9.11：Packagist窗口
- en: 'In the main search bar, enter `logging`:![Figure 9.12: Searching packages'
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在主搜索栏中输入`logging`：![图9.12：搜索包]
- en: '](img/C14196_09_12.jpg)'
  id: totrans-137
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图片 C14196_09_12.jpg]'
- en: 'Figure 9.12: Searching packages'
  id: totrans-138
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图9.12：搜索包
- en: Note
  id: totrans-139
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意
- en: Packagist lists the number of downloads and stars a package has in the search
    results. It is a good idea to select packages that have as many downloads and
    stars as possible, as those are more likely to be quality packages and to maintain
    support in the long term.
  id: totrans-140
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: Packagist在搜索结果中列出包的下载次数和星级。选择下载次数和星级尽可能多的包是个好主意，因为这些包更有可能是高质量的，并且长期维护支持的可能性也更大。
- en: 'Click the link to view the details pertaining to the monolog/monolog package,
    which should be one of the first listings. At the time of writing, it has over
    132 million downloads and in excess of 14,000 stars:'
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击链接查看与monolog/monolog包相关的详细信息，这应该是列表中的第一个条目之一。在撰写本文时，它已有超过1.32亿次下载和超过14,000颗星：
- en: '![Figure 9.13: Details of Monolog'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: '![图9.13：Monolog的详细信息]'
- en: '](img/C14196_09_13.jpg)'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片 C14196_09_13.jpg]'
- en: 'Figure 9.13: Details of Monolog'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.13：Monolog的详细信息
- en: Note
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: In the panel on the right-hand side, you will see links to the repository on
    GitHub and to the home page for the package. These will frequently provide important
    instructions on how to use the package. You can review the source code of the
    package on GitHub. This is useful for evaluating the quality of the package.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 在右侧的面板上，您将看到指向GitHub上存储库和包主页的链接。这些通常会提供有关如何使用包的重要说明。您可以在GitHub上查看包的源代码。这有助于评估包的质量。
- en: 'There is a lot of information that you can glean from the details page of a
    package on Packagist that will help you to determine whether it is a good idea
    to include it in your own project. Here are some things you may want to consider:
    is the package in widespread use by other developers? A good indication of this
    is the number of stars, installs, and other packages that list it as a suggestion.'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以从Packagist上包的详细信息页面中获取大量信息，这些信息将帮助您确定是否将其包含在自己的项目中。以下是一些您可能想要考虑的事项：该包是否被其他开发者广泛使用？一个很好的迹象是该包的星级、安装次数以及其他列出它作为建议的包的数量。
- en: The more people that use the package, the more likely it is to be well maintained
    long into the future. If the project does not have as many stars and downloads
    as some of the other very popular projects, is it because it only applies to a
    narrower set of use cases, and yet is still very much in demand with this smaller
    group? Are there many open issues on the GitHub page for the project? Have they
    responded to them? How long have they been open? Are there many that have been
    resolved? When was the last update made to the project? Finding answers to these
    questions should give you a sense of whether or not the project is being maintained
    well.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 使用该包的人越多，它在未来被良好维护的可能性就越大。如果项目没有像其他一些非常受欢迎的项目那样拥有那么多星和下载量，这是否意味着它只适用于更窄的使用案例，但在这个较小的群体中仍然非常受欢迎？GitHub页面上是否有许多开放的问题？他们是否已经回应了这些问题？这些问题已经开放了多久？有多少问题已经被解决？项目最后一次更新是什么时候？找到这些问题的答案应该能让你对项目是否得到了良好的维护有一个感觉。
- en: Because the projects are open source, we will see forks and pull requests. A
    fork is when a developer creates a copy of the project under their own vendor
    name so that they can make updates to the project and most likely submit them
    back to the main project maintainer in a pull request. It's called a pull request
    because the developer that made the update is making a request to pull the update
    back into the main project repository. You can see on GitHub how many pull requests
    have been merged, and it's a really good indicator that the project will be updated
    as time goes on, and even allow you the opportunity to contribute back to the
    project if you discover a useful feature or a bug that needs to be fixed.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 由于项目是开源的，我们将会看到分支和拉取请求。分支是指开发者用自己的供应商名称创建项目的副本，以便他们可以对项目进行更新，并且很可能会通过拉取请求将其提交回主项目的维护者。这被称为拉取请求，因为进行更新的开发者正在请求将更新拉回到主项目仓库。你可以在GitHub上看到有多少拉取请求已被合并，这真的是一个很好的指标，表明项目会随着时间的推移而更新，甚至如果你发现了一个有用的功能或需要修复的bug，这还给你提供了向项目贡献的机会。
- en: 'In the center pane of the details page, you will see two lists of other packages:
    one listing packages that the selected package has as its own dependencies, while
    the other has suggested packages. If you plan on installing a package, it''s a
    good idea to evaluate each of the package''s dependencies just as you would the
    original package, as they will all end up being code that your application could
    potentially execute. You may not be able to read every line of source code, but
    you should be able to get a reasonable idea of whether or not the package is respectable.
    The suggested packages are packages that will work with the selected package,
    but would not be applicable to every project that installs the package and were
    not therefore worth including in the main package. For example, the `flysystem`
    package we mentioned earlier has many suggestions for extensions that integrate
    with systems including Amazon Web Services, Azure, and Dropbox. It makes the most
    sense to only include the base and let users pick which extensions apply to themselves.'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 在详情页面的中心面板中，你会看到其他包的两个列表：一个列出所选包作为其依赖项的包，而另一个则列出建议的包。如果你计划安装一个包，评估每个包的依赖项就像评估原始包一样是个好主意，因为它们最终都会成为你的应用程序可能执行的代码。你可能无法阅读每一行源代码，但你应该能够合理地判断这个包是否值得信赖。建议的包是与所选包兼容的包，但它们并不适用于安装该包的每个项目，因此不值得包含在主包中。例如，我们之前提到的`flysystem`包有许多与包括亚马逊网络服务、Azure和Dropbox在内的系统集成的扩展建议。只包含基础部分，让用户选择适合自己的扩展，这是最有意义的。
- en: It is also important to take a moment to note that these packages are being
    made freely available over the internet, and you should also evaluate them from
    a security perspective and ensure that you are receiving the code you expect when
    you install them.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 也很重要的是，要注意这些包正在互联网上免费提供，你应该从安全的角度评估它们，并确保在安装它们时你得到的是你预期的代码。
- en: These are the important pieces of information you should consider when selecting
    third-party software to include in your project. If you prefer not to interface
    directly with Packagist, the makers of Composer provide solutions to be used in
    the Enterprise, Toran Proxy and Satis. These solutions function as proxies to
    both Packagist and GitHub and can be used to host your own company's packages,
    but keep them private to your own organization. Toran Proxy provider has been
    phased out, and Private Packagist ([https://packt.live/2Beq5Ez](https://packt.live/2Beq5Ez))
    is recommended These days, open source software has solved many of our common
    problems and, with a little effort, you will often find a package to do exactly
    what you are looking for and you are only left to implement it.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 在选择第三方软件并将其包含到您的项目中时，您应该考虑这些重要的信息。如果您不想直接与Packagist接口，Composer的制作者提供了适用于企业的解决方案，包括Toran
    Proxy和Satis。这些解决方案作为Packagist和GitHub的代理，可以用来托管您自己公司的包，但请保持它们仅对您的组织内部可见。Toran Proxy提供商已被淘汰，现在推荐使用Private
    Packagist ([https://packt.live/2Beq5Ez](https://packt.live/2Beq5Ez))。如今，开源软件已经解决了我们许多常见问题，只要稍加努力，您通常就能找到一个正好符合您需求的包，然后只需实现它即可。
- en: Namespaces
  id: totrans-153
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 命名空间
- en: Before we go on to actually using a package we have installed with Composer,
    let's take a brief moment to review what we learned about namespaces in *Chapter
    5*, *ObjectOriented Programming*. This is a similar concept to the namespaces
    we just referenced on the Packagist site. However, these are built into the PHP
    language. Namespaces have been part of PHP since version 5.3 and most, if not
    all, of the libraries you come across will use namespaces. Namespaces allow multiple
    pieces of code that would otherwise have a name collision to exist side by side.
    Prior to namespaces, vendors would inconveniently have to create extraordinarily
    long class names that were prefixed with their vendor name and usually separated
    by underscores to avoid naming collisions. It is highly recommended that you use
    namespaces in your own code to help keep things well organized and simplify references
    between files.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们继续使用Composer安装的包之前，让我们简要回顾一下在*第五章*，*面向对象编程*中学到的关于命名空间的知识。这与我们在Packagist网站上提到的命名空间类似。然而，这些是内置于PHP语言中的。命名空间自PHP
    5.3版本以来就是PHP的一部分，您遇到的库几乎都会使用命名空间。命名空间允许多个代码片段在名称冲突的情况下并排存在。在命名空间之前，供应商不得不不便利地创建非常长的类名，这些类名以供应商名称为前缀，通常由下划线分隔，以避免命名冲突。强烈建议您在自己的代码中使用命名空间，以帮助保持事物井然有序并简化文件之间的引用。
- en: To define a namespace in a file, it must be declared at the top of a file before
    any other code. Just use the `namespace` keyword, followed by the namespace you
    want to define, and complete the line with a semicolon. You can prefix a namespace
    in a directory structure-like manner by inserting a backslash character between
    the prefix and the namespace. You can use multiple levels of prefixes if you so
    desire. You will see an example of this in the next exercise. To reference a namespace,
    you can either reference a full namespace by providing an absolute path to the
    namespace, or you can make use of the `use` keyword, which will make the namespace
    available throughout the rest of the scope. This will also be demonstrated in
    the example.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 要在文件中定义一个命名空间，它必须在文件顶部声明，在任意其他代码之前。只需使用`namespace`关键字，后跟您想要定义的命名空间，并用分号完成该行。您可以通过在前缀和命名空间之间插入反斜杠字符以目录结构的方式给命名空间添加前缀。如果您愿意，可以使用多级前缀。您将在下一个练习中看到这个示例。要引用一个命名空间，您可以通过提供命名空间的绝对路径来引用一个完整的命名空间，或者您可以使用`use`关键字，这将使命名空间在整个作用域内可用。这将在示例中演示。
- en: Autoloading
  id: totrans-156
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 自动加载
- en: There is one more subject we need to touch on before writing code to use one
    of the dependencies we installed, and that is autoloading. Autoloading is a term
    that refers to programmatically automating the inclusion of classes and functions
    external to the file you are working in. Without it, our code would be littered
    with `include` or `require` statements. PHP offers a function, `spl_autoload_register`,
    that accepts a function to do your autoloading for you, but Composer makes it
    even easier than that.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们使用Composer安装的依赖项编写代码之前，还有一个主题需要讨论，那就是自动加载。自动加载是一个术语，指的是在您正在工作的文件外部程序化地自动包含类和函数。没有它，我们的代码将会充斥着`include`或`require`语句。PHP提供了一个函数`spl_autoload_register`，它接受一个函数来为您完成自动加载，但Composer使这个过程更加简单。
- en: When Composer creates the vendor directory, it places an `autoload.php` file
    in it. With a little configuration in the `composer.json` file, if you require
    this one file (ideally in a central file as part of bootstrapping the rest of
    your application) and follow the convention for naming your files and directories,
    Composer will automatically include everything for you, saving you the hassle.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 当 Composer 创建 vendor 目录时，它会在其中放置一个 `autoload.php` 文件。通过在 `composer.json` 文件中进行一些配置，如果您需要这个文件（理想情况下在启动应用程序其余部分时作为一个中央文件）并遵循文件和目录的命名约定，Composer
    将自动为您包含所有内容，从而节省您的时间和麻烦。
- en: Using Composer Packages
  id: totrans-159
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 Composer 包
- en: Let's now walk through using a library pulled in by Composer. You can use this
    example of Monolog as a solid base to use for your logging in any PHP application
    you build. First, we will create a simple script to work as our example, and then
    we will wire our script up to Composer so that the classes in our dependencies
    will be autoloaded. This way, our own code can be kept clean and not be cluttered
    by needless `require` or `include` statements.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来了解一下如何使用由 Composer 拉入的库。您可以将 Monolog 的这个示例用作构建任何 PHP 应用程序时日志记录的坚实基础。首先，我们将创建一个简单的脚本作为示例，然后我们将连接我们的脚本到
    Composer，以便我们的依赖项中的类将被自动加载。这样，我们的代码可以保持干净，不会被无用的 `require` 或 `include` 语句所杂乱。
- en: Composer can also autoload your own classes for you. You can configure this
    in the `composer.json` file. PHP has a standard way of structuring your files
    and directories so that you don't need to specify them. It is part of a series
    of standards maintained by the PHP-FIG. The autoloading standard is named PSR-4\.
    You can see the full documentation at [https://packt.live/314fBCj](https://packt.live/314fBCj).
    To follow this standard, you should place your classes in a directory structure
    that matches the namespace structure of your class. For example, if you wrote
    a dummy class with the namespace `Acme/Helper`, the path to it would be `Acme/Helper/Dummy.php`.
    Often, this path exists inside another directory inside your project root to keep
    your application code separate, such as an `src` directory.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: Composer 也可以为您自动加载您自己的类。您可以在 `composer.json` 文件中配置此功能。PHP 有一个标准的文件和目录结构，您不需要指定它们。它是
    PHP-FIG 维护的一系列标准的一部分。自动加载标准被称为 PSR-4。您可以在 [https://packt.live/314fBCj](https://packt.live/314fBCj)
    查看完整的文档。为了遵循此标准，您应该将您的类放置在与您的类命名空间结构相匹配的目录结构中。例如，如果您编写了一个具有命名空间 `Acme/Helper`
    的虚拟类，其路径将是 `Acme/Helper/Dummy.php`。通常，此路径位于项目根目录内的另一个目录中，以保持您的应用程序代码分离，例如一个 `src`
    目录。
- en: 'Exercise 9.8: Using PSR-4 to Load Classes'
  id: totrans-162
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习 9.8：使用 PSR-4 加载类
- en: 'In this exercise, we will write a basic PHP class and use a filename and directory
    structure that conforms to the PSR-4 convention. Then, we will use Composer to
    autoload that class, omitting the need to require the class file ourselves:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们将编写一个基本的 PHP 类，并使用符合 PSR-4 约定的文件名和目录结构。然后，我们将使用 Composer 来自动加载该类，无需我们自己引入类文件：
- en: 'Inside the directory that contains the `composer.json` file, create a new directory
    named `src`. Inside that directory, create a directory named `Packt`:'
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在包含 `composer.json` 文件的目录中，创建一个名为 `src` 的新目录。在该目录内，创建一个名为 `Packt` 的目录：
- en: '[PRE11]'
  id: totrans-165
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Inside the `Packt` directory, create a file named `Example.php` with the following
    contents:'
  id: totrans-166
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Packt` 目录中，创建一个名为 `Example.php` 的文件，并包含以下内容：
- en: '[PRE12]'
  id: totrans-167
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Back at the root of your project, open the `composer.json` file and add the
    autoload section below the `require-dev` section:'
  id: totrans-168
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在您的项目根目录中，打开 `composer.json` 文件，并在 `require-dev` 部分下方添加自动加载部分：
- en: '[PRE13]'
  id: totrans-169
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Create an `index.php` file:'
  id: totrans-170
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个 `index.php` 文件：
- en: '[PRE14]'
  id: totrans-171
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Run the `index.php` file. You can see the output in the following screenshot:'
  id: totrans-172
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行 `index.php` 文件。您可以在下面的屏幕截图中看到输出：
- en: '![Figure 9.14: Output of the index'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 9.14：index 的输出]'
- en: '](img/C14196_09_14.jpg)'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: '![img/C14196_09_14.jpg](img/C14196_09_14.jpg)'
- en: 'Figure 9.14: Output of the index'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.14：index 的输出
- en: You can see that by configuring Composer and following the PSR-4 format, your
    class will be loaded up into memory on demand as you call it, without the need
    to explicitly require the file. Next, let's extend our example with a very basic
    Monolog implementation.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以看到，通过配置 Composer 并遵循 PSR-4 格式，当您调用类时，您的类将按需加载到内存中，无需显式地引入文件。接下来，让我们通过一个非常基本的
    Monolog 实现来扩展我们的示例。
- en: 'Exercise 9.9: Implementing Monolog'
  id: totrans-177
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习 9.9：实现 Monolog
- en: 'In this exercise, we will give an example implementation of integrating with
    the Monolog library we installed earlier in this chapter. This example assumes
    you have worked through the previous examples and are at a Command Prompt in the
    main project directory:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们将给出一个示例实现，说明如何将我们在本章早期安装的Monolog库集成。这个示例假设你已经完成了之前的示例，并且正在主项目目录的命令提示符下工作：
- en: 'From the command line, create a `logs` directory. This directory will be where
    our logs will be written:'
  id: totrans-179
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从命令行创建一个`logs`目录。这个目录将是我们日志的存放位置：
- en: '[PRE15]'
  id: totrans-180
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Edit the `index.php` file to include `use` statements for Monolog, set up a
    handler, and pass it to our `Example` class:'
  id: totrans-181
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编辑`index.php`文件以包含Monolog的`use`语句，设置一个处理器，并将其传递给我们的`Example`类：
- en: '[PRE16]'
  id: totrans-182
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Edit the `src/Example.php` file to add the `use` statements for Monolog, add
    a constructor to accept the logger, and call the logger:'
  id: totrans-183
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编辑`src/Example.php`文件以添加Monolog的`use`语句，添加一个接受日志记录器的构造函数，并调用日志记录器：
- en: '[PRE17]'
  id: totrans-184
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Run the `index.php` script again:'
  id: totrans-185
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 再次运行`index.php`脚本：
- en: '[PRE18]'
  id: totrans-186
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Now, view the `app.log` file in the `./logs` directory:'
  id: totrans-187
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，查看`./logs`目录下的`app.log`文件：
- en: '![Figure 9.15: Printing the log'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: '![图9.15：打印日志'
- en: '](img/C14196_09_15.jpg)'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/C14196_09_15.jpg)'
- en: 'Figure 9.15: Printing the log'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.15：打印日志
- en: You will see three lines written to it for the three log levels in the `doSomething`
    method.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 你将在`doSomething`方法中的三个日志级别中看到三条写入的行。
- en: Working through this example has not only shown you how to use libraries you
    have included in your project with Composer, but also gives you a very basic example
    of setting up Monolog that you can apply the same principles to in order to set
    up advanced logging in your application.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这个示例的学习不仅展示了你如何使用通过Composer包含在你的项目中的库，而且还提供了一个非常基本的Monolog设置示例，你可以将这些相同的原理应用到设置你应用程序的高级日志中。
- en: Before starting the next activity, there are a few concepts you should be familiar
    with in order to make it useful in the real world. You will modify the example
    application we just wrote to generate a universally unique identifier, known as
    a UUID for short. A UUID is a 128-bit number used to uniquely identify data in
    computer systems. They look like long alphanumeric strings with sections separated
    by dashes. They can have many use cases, but one of the most common is to generate
    unique IDs for data in your system that you may store in a database. It is generally
    considered poor practice nowadays to use ascending integers as unique identifiers
    for your publicly accessible objects as you may not want the user to be able to
    guess the next one in the sequence. The package we have selected for the activity
    makes this task trivial.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 在开始下一个活动之前，你应该熟悉一些概念，以便在实际世界中使其有用。你将修改我们刚刚编写的示例应用程序，以生成一个称为UUID的通用唯一标识符。UUID是一个128位的数字，用于在计算机系统中唯一标识数据。它们看起来像由破折号分隔的长字母数字字符串。它们可以有多个用途，但最常见的一个用途是为你的系统中可能存储在数据库中的数据生成唯一的ID。现在，使用递增整数作为公开可访问对象的唯一标识符通常被认为是不良的做法，因为你可能不希望用户能够猜测序列中的下一个数字。我们为这个活动选择的包使这项任务变得非常简单。
- en: 'Activity 9.1: Implementing a Package to Generate a UUID'
  id: totrans-194
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 活动九.1：实现一个生成UUID的包
- en: 'In this activity, you have an opportunity to apply what you have learned in
    this chapter. You will need to have completed the previous exercises in this chapter
    and use them as a starting point. There is a Composer package for generating UUIDs
    named `ramsey/uuid`:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个活动中，你有机会应用本章学到的知识。你需要完成本章之前的练习，并将它们作为起点。有一个名为`ramsey/uuid`的Composer包用于生成UUID：
- en: Add the UUID package to your project dependencies and ensure that it is installed
    in the vendor directory.
  id: totrans-196
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将UUID包添加到你的项目依赖项中，并确保它已安装在vendor目录中。
- en: Add a method to your `Example.php` script to call the library to generate a
    UUID and echo the result. There are multiple methods provided for generating one;
    `uuid1()` will be sufficient. Include a concatenated new line, `PHP_EOL`, at the
    end of your `echo` statement.
  id: totrans-197
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在你的`Example.php`脚本中添加一个方法来调用库生成UUID并输出结果。提供了多种生成UUID的方法；`uuid1()`就足够了。在`echo`语句的末尾包含一个连接的新行，`PHP_EOL`。
- en: Call the new method you created in `Example.php` from your `index.php` file
    after your previous output.
  id: totrans-198
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在你的`index.php`文件中调用你在`Example.php`中创建的新方法，在你的前一个输出之后。
- en: Run the `index.php` script and confirm that you see the UUID generated.
  id: totrans-199
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行`index.php`脚本并确认你看到了生成的UUID。
- en: 'The output should be similar to the following:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 输出应类似于以下内容：
- en: '![Figure 9.16: Expected Outcome'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: '![图9.16：预期结果'
- en: '](img/C14196_09_16.jpg)'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/C14196_09_16.jpg)'
- en: 'Figure 9.16: Expected Outcome'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.16：预期结果
- en: Note
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: The solution to this activity can be found on page 558.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 该活动的解决方案可以在第558页找到。
- en: Summary
  id: totrans-206
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, you were introduced to the concept of dependency management
    and Composer, the primary tool for bringing external dependencies into your projects
    in PHP. Dependency management is important to keep your own application code separate
    from third-party libraries that need to be kept up to date and compatible with
    one another.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您介绍了依赖管理以及Composer的概念，Composer是PHP中将外部依赖项引入项目的首选工具。依赖管理对于保持您的应用程序代码与需要保持更新并相互兼容的第三方库分离非常重要。
- en: We covered Packagist, Composer's companion site that catalogs packages available
    for inclusion in projects. You can identify reputable packages by noting the rating,
    the number of downloads, and other such criteria. The site links to the source
    code of each of its listings, so you can review the code yourself if you need
    a better understanding of its inner workings or if you want to confirm the quality
    of the code.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 我们介绍了Packagist，这是Composer的配套网站，它列出了可用于项目包含的包。您可以通过注意评分、下载次数和其他此类标准来识别信誉良好的包。该网站链接到其列表的每个源代码，因此如果您需要更好地了解其内部工作原理或想要确认代码的质量，您可以自己审查代码。
- en: We provided an overview of setting up your project to use Composer and how to
    use the essential features you will need to integrate with other libraries. Libraries
    are required in the command line or by editing the `composer.json` file directly.
    They can have version constraints placed on them so that Composer will only install
    versions from a specified range. Each time a package is required, a lock file
    is generated to keep track of the exact versions of the current set of installed
    libraries. Packages can also be specified as only for development purposes, and
    therefore can be omitted when passing a flag to the `install` script to omit development
    dependencies.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 我们概述了如何设置项目以使用Composer，以及如何使用您将需要集成其他库的基本功能。在命令行中或直接编辑`composer.json`文件时需要库。可以对它们施加版本约束，以便Composer只安装指定范围内的版本。每次需要包时，都会生成一个锁文件，以跟踪当前已安装的库的确切版本。包也可以指定为仅用于开发目的，因此可以在传递给`install`脚本的标志时省略开发依赖项。
- en: Finally, we set up a sample implementation of Monolog to demonstrate using a
    package installed by Composer. We can use Composer to autoload our own code as
    long as we follow the PSR-4 standard and take advantage of namespaces. In the
    next chapter, we will look at the basics of concepts of web services and connecting
    your application with them using Guzzle, a popular PHP open-source library for
    making HTTP requests.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们设置了一个Monolog的示例实现，以展示如何使用Composer安装的包。只要我们遵循PSR-4标准并利用命名空间，我们就可以使用Composer来自动加载我们的代码。在下一章中，我们将探讨网络服务的基本概念，以及如何使用Guzzle（一个流行的PHP开源库，用于发送HTTP请求）将您的应用程序与它们连接。
- en: In the next chapter, we will present an overview of web services and take a
    look at some examples of interacting with them.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将概述网络服务，并查看一些与之交互的示例。
