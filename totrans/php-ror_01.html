<html><head></head><body>
<div id="_idContainer008">
<h1 class="chapter-number" id="_idParaDest-15"><a id="_idTextAnchor015"/><span class="koboSpan" id="kobo.1.1">1</span></h1>
<h1 id="_idParaDest-16"><a id="_idTextAnchor016"/><span class="koboSpan" id="kobo.2.1">Understanding the Ruby Mindset and Culture</span></h1>
<p><span class="koboSpan" id="kobo.3.1">Ruby has had quite </span><a id="_idIndexMarker000"/><span class="koboSpan" id="kobo.4.1">a history since its inception by Yukihiro Matsumoto. </span><span class="koboSpan" id="kobo.4.2">The adoption of the language by the community has, of course, influenced the direction in which Ruby has been focused. </span><span class="koboSpan" id="kobo.4.3">But, at its core, Ruby has been very straightforward in the way you </span><em class="italic"><span class="koboSpan" id="kobo.5.1">can</span></em><span class="koboSpan" id="kobo.6.1"> and the way you </span><em class="italic"><span class="koboSpan" id="kobo.7.1">should</span></em><span class="koboSpan" id="kobo.8.1"> write programs/scripts with it. </span><span class="koboSpan" id="kobo.8.2">Every language has its own peculiarities, which the community takes to define what a good practice is and what is considered “bad” code. </span><span class="koboSpan" id="kobo.8.3">While this may be entirely subjective, this subjectiveness paves the way for what the author’s original intention for creating the language was into what the community wants the language </span><span class="No-Break"><span class="koboSpan" id="kobo.9.1">to become.</span></span></p>
<p><span class="koboSpan" id="kobo.10.1">Ruby was created with the idea of being extremely easy to read, flexible, and object-oriented. </span><span class="koboSpan" id="kobo.10.2">The same can be said about the technologies that came to pass because of Ruby. </span><span class="koboSpan" id="kobo.10.3">I’m talking about frameworks </span><a id="_idIndexMarker001"/><span class="koboSpan" id="kobo.11.1">created in Ruby, such as Ruby on Rails (</span><a href="https://rubyonrails.org"><span class="koboSpan" id="kobo.12.1">https://rubyonrails.org</span></a><span class="koboSpan" id="kobo.13.1">) and </span><a id="_idIndexMarker002"/><span class="koboSpan" id="kobo.14.1">Sinatra (</span><a href="http://sinatrarb.com/"><span class="koboSpan" id="kobo.15.1">http://sinatrarb.com/</span></a><span class="koboSpan" id="kobo.16.1">). </span><span class="koboSpan" id="kobo.16.2">But I’m also talking about other tools that were created with that same mindset, such </span><a id="_idIndexMarker003"/><span class="koboSpan" id="kobo.17.1">as Chef (</span><a href="https://www.chef.io/"><span class="koboSpan" id="kobo.18.1">https://www.chef.io/</span></a><span class="koboSpan" id="kobo.19.1">). </span><span class="koboSpan" id="kobo.19.2">All of these tools have common traits but the trait that stands out the most is readability. </span><span class="koboSpan" id="kobo.19.3">Once you’re in the Ruby “realm,” you’re able to read and understand code made for vanilla Ruby, a Ruby on Rails application API, or even a Chef recipe to manage and configure infrastructure. </span><span class="koboSpan" id="kobo.19.4">Ruby does not automatically make your code more understandable or readable, but it goes a long way to give you the tools to make your code easier to read. </span><span class="koboSpan" id="kobo.19.5">Making your code understandable is key to focusing more on the business (or hobby) at hand and focusing less on trying to understand what some code </span><span class="No-Break"><span class="koboSpan" id="kobo.20.1">is doing.</span></span></p>
<p><span class="koboSpan" id="kobo.21.1">But before we get there, we will need to make the switch to the Ruby mindset. </span><span class="koboSpan" id="kobo.21.2">In this chapter, we will start our journey into this mindset by covering the </span><span class="No-Break"><span class="koboSpan" id="kobo.22.1">following topics:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.23.1">Creating readable </span><span class="No-Break"><span class="koboSpan" id="kobo.24.1">Ruby code</span></span></li>
<li><span class="No-Break"><span class="koboSpan" id="kobo.25.1">Object-oriented Ruby</span></span></li>
<li><span class="koboSpan" id="kobo.26.1">Writing </span><span class="No-Break"><span class="koboSpan" id="kobo.27.1">Ruby-esque code</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.28.1">You made up your mind to learn a new programming language. </span><span class="koboSpan" id="kobo.28.2">Congratulations! </span><span class="koboSpan" id="kobo.28.3">I, for one, would like to applaud this decision and hope it took you less time than it took me to be seriously curious about another programming language. </span><span class="koboSpan" id="kobo.28.4">I was a bit stubborn and reluctant at first, seeing every single downside of Ruby. </span><span class="koboSpan" id="kobo.28.5">My favorite phrase was, “I can do that in PHP easier.” </span><span class="koboSpan" id="kobo.28.6">But then, one day, it simply clicked and I never went back. </span><span class="koboSpan" id="kobo.28.7">Ruby has been my go-to language for a long time now. </span><span class="koboSpan" id="kobo.28.8">And I won´t try to oversell this to you. </span><span class="koboSpan" id="kobo.28.9">I refuse to say that Ruby is the best programming language there is because that would be answering a loaded question. </span><span class="koboSpan" id="kobo.28.10">There is no programming language that is universally better than the rest. </span><span class="koboSpan" id="kobo.28.11">What I can do is try to show you why I </span><span class="No-Break"><span class="koboSpan" id="kobo.29.1">love Ruby.</span></span></p>
<h1 id="_idParaDest-17"><a id="_idTextAnchor017"/><span class="koboSpan" id="kobo.30.1">Technical requirements</span></h1>
<p><span class="koboSpan" id="kobo.31.1">To follow along with this book, you </span><span class="No-Break"><span class="koboSpan" id="kobo.32.1">will need:</span></span></p>
<ul>
<li><span class="No-Break"><span class="koboSpan" id="kobo.33.1">Git client</span></span></li>
<li><span class="koboSpan" id="kobo.34.1">rbenv (Ruby version manager to enable multiple versions </span><span class="No-Break"><span class="koboSpan" id="kobo.35.1">of Ruby)</span></span></li>
<li><span class="koboSpan" id="kobo.36.1">Ruby (versions 2.6.10 and 3.0 </span><span class="No-Break"><span class="koboSpan" id="kobo.37.1">or above)</span></span></li>
<li><span class="koboSpan" id="kobo.38.1">Any IDE of your choice installed to edit code (Sublime, Visual Studio Code, vim, Emacs, </span><span class="No-Break"><span class="koboSpan" id="kobo.39.1">Rubymine, etc.)</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.40.1">All code examples have been written to work with Ruby versions 2.6.10 and 3.0 (or above). </span><span class="koboSpan" id="kobo.40.2">Some of the examples will need previous versions of Ruby (i.e. </span><span class="koboSpan" id="kobo.40.3">2.6.10) to work with previous versions of Ruby on Rails (e.g. </span><span class="koboSpan" id="kobo.40.4">Ruby on Rails 5), but to guarantee that they work the same way as in this chapter, you should try to install the latest version of Ruby. </span><span class="koboSpan" id="kobo.40.5">You may get the installer for different operating systems </span><span class="No-Break"><span class="koboSpan" id="kobo.41.1">here: </span></span><a href="https://www.ruby-lang.org/en/downloads/"><span class="No-Break"><span class="koboSpan" id="kobo.42.1">https://www.ruby-lang.org/en/downloads/</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.43.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.44.1">Additionally, to be able to use different versions of Ruby, I would also suggest you install rbenv from this GitHub </span><span class="No-Break"><span class="koboSpan" id="kobo.45.1">repository: </span></span><a href="https://github.com/rbenv/rbenv"><span class="No-Break"><span class="koboSpan" id="kobo.46.1">https://github.com/rbenv/rbenv</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.47.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.48.1">The code presented in this book is available </span><span class="No-Break"><span class="koboSpan" id="kobo.49.1">at </span></span><a href="https://github.com/PacktPublishing/From-PHP-to-Ruby-on-Rails"><span class="No-Break"><span class="koboSpan" id="kobo.50.1">https://github.com/PacktPublishing/From-PHP-to-Ruby-on-Rails</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.51.1">.</span></span></p>
<h1 id="_idParaDest-18"><a id="_idTextAnchor018"/><span class="koboSpan" id="kobo.52.1">Ruby is meant to be read as sentences</span></h1>
<p><span class="koboSpan" id="kobo.53.1">Having said all that about Ruby, let’s get our hands dirty and start with the most basic of concepts. </span><span class="koboSpan" id="kobo.53.2">You already</span><a id="_idIndexMarker004"/><span class="koboSpan" id="kobo.54.1"> know about PHP variables. </span><span class="koboSpan" id="kobo.54.2">Variables hold information that can be used and referenced in our program. </span><span class="koboSpan" id="kobo.54.3">Also, PHP is a dynamically typed language, which means that the PHP “engine,” which interprets our PHP code, will automatically infer the type of content within that variable. </span><span class="koboSpan" id="kobo.54.4">That’s to say the following </span><span class="No-Break"><span class="koboSpan" id="kobo.55.1">two things:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.56.1">We don’t have to define what type of content our </span><span class="No-Break"><span class="koboSpan" id="kobo.57.1">variable has</span></span></li>
<li><span class="koboSpan" id="kobo.58.1">A variable can change types </span><span class="No-Break"><span class="koboSpan" id="kobo.59.1">without failing</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.60.1">Coming from PHP, you won’t have to break your head to learn a new way of using or defining variables with Ruby, as Ruby behaves exactly the same way. </span><span class="koboSpan" id="kobo.60.2">However, beware that in other languages that are strongly typed, such as Java, a variable has to be defined with the type that it will contain and it can’t change types </span><span class="No-Break"><span class="koboSpan" id="kobo.61.1">over time.</span></span></p>
<p><span class="koboSpan" id="kobo.62.1">So let’s play around with some variables </span><span class="No-Break"><span class="koboSpan" id="kobo.63.1">in PHP:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.64.1">
&lt;?php
$name = "bernard";
$age = 40;
$height_in_cms = 177.5;
$chocolate_allergy = true;
$travel_bucket_list = ["Turkey", "Japan", "Canada"];</span></pre> <p><span class="koboSpan" id="kobo.65.1">Ruby is not much different in </span><span class="No-Break"><span class="koboSpan" id="kobo.66.1">this scenario:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.67.1">
name = "bernard";
age = 40;
height_in_cms = 177.5;
chocolate_allergy = true;
travel_bucket_list = ["Turkey", "Japan", "Canada"];</span></pre> <p><span class="koboSpan" id="kobo.68.1">For those experienced PHP developers reading this whose eyes might be bleeding from my lack of using </span><strong class="bold"><span class="koboSpan" id="kobo.69.1">PHP Standard Recommendation </span></strong><span class="koboSpan" id="kobo.70.1">(</span><strong class="bold"><span class="koboSpan" id="kobo.71.1">PSR</span></strong><span class="koboSpan" id="kobo.72.1">) standards on the PHP block, I apologize, but I wanted to give you a </span><a id="_idIndexMarker005"/><span class="koboSpan" id="kobo.73.1">glimpse of how the code could be written in a similar manner rather than focusing on PHP’s best practices. </span><span class="koboSpan" id="kobo.73.2">Notice that we just wrote the variable names without the </span><strong class="source-inline"><span class="koboSpan" id="kobo.74.1">$</span></strong><span class="koboSpan" id="kobo.75.1"> symbol. </span><span class="koboSpan" id="kobo.75.2">Another difference between PHP and Ruby is that we do not use any tag to denote PHP code, whereas, in PHP, we use the opening PHP tags (</span><strong class="source-inline"><span class="koboSpan" id="kobo.76.1">&lt;?php</span></strong><span class="koboSpan" id="kobo.77.1">). </span><span class="koboSpan" id="kobo.77.2">So, the main differences (so far) between our snippets are the way we call PHP code with the PHP tags and the way we refer to variables. </span><span class="koboSpan" id="kobo.77.3">While this is a functioning Ruby code, I intentionally wrote the Ruby block very PHP-esque to also give you all a glimpse of Ruby’s</span><a id="_idIndexMarker006"/><span class="koboSpan" id="kobo.78.1"> flexibility. </span><span class="koboSpan" id="kobo.78.2">Ruby is extremely flexible to the point of being able to bend Ruby’s own behavior. </span><span class="koboSpan" id="kobo.78.3">An example of this flexibility is that while we can add a semicolon (</span><strong class="source-inline"><span class="koboSpan" id="kobo.79.1">;</span></strong><span class="koboSpan" id="kobo.80.1">) at the end of each line, it is a Ruby best practice to leave them out. </span><span class="koboSpan" id="kobo.80.2">Should this topic of Ruby’s flexibility interest you, you may want to check metaprogramming in Ruby. </span><span class="koboSpan" id="kobo.80.3">This Ruby guide is a great </span><span class="No-Break"><span class="koboSpan" id="kobo.81.1">starting point:</span></span></p>
<p><a href="https://www.rubyguides.com/2016/04/metaprogramming-in-the-wild/"><span class="No-Break"><span class="koboSpan" id="kobo.82.1">https://www.rubyguides.com/2016/04/metaprogramming-in-the-wild/</span></span></a></p>
<p><span class="koboSpan" id="kobo.83.1">But let’s not get ahead of ourselves, as this topic is really a complex one – at least for a beginner </span><span class="No-Break"><span class="koboSpan" id="kobo.84.1">Ruby programmer.</span></span></p>
<p><span class="koboSpan" id="kobo.85.1">Given the preceding code in PHP, let´s now determine whether the name is empty. </span><span class="koboSpan" id="kobo.85.2">In PHP, you would use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.86.1">empty</span></strong><span class="koboSpan" id="kobo.87.1"> internal function. </span><span class="koboSpan" id="kobo.87.2">We surround it with another internal function called </span><strong class="source-inline"><span class="koboSpan" id="kobo.88.1">var_dump</span></strong><span class="koboSpan" id="kobo.89.1"> to show the contents of the empty </span><span class="No-Break"><span class="koboSpan" id="kobo.90.1">function result:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.91.1">
$name = "Bernard";
var_dump( empty($name) );</span></pre> <p><span class="koboSpan" id="kobo.92.1">This will output </span><span class="No-Break"><span class="koboSpan" id="kobo.93.1">the following:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.94.1">
bool(false)</span></pre> <p><span class="koboSpan" id="kobo.95.1">According to the documentation of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.96.1">empty</span></strong><span class="koboSpan" id="kobo.97.1"> function, this is </span><strong class="source-inline"><span class="koboSpan" id="kobo.98.1">false</span></strong><span class="koboSpan" id="kobo.99.1"> because the name is not an empty string. </span><span class="koboSpan" id="kobo.99.2">Now, let’s try that </span><span class="No-Break"><span class="koboSpan" id="kobo.100.1">in Ruby:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.101.1">
name = "bernard";
puts name.empty?;</span></pre> <p><span class="koboSpan" id="kobo.102.1">There are a couple of things that we have to notice here. </span><span class="koboSpan" id="kobo.102.2">The first thing that comes to mind is that this is read almost as a sentence. </span><span class="koboSpan" id="kobo.102.3">This is one of the key points to how the Ruby community has come together and used Ruby to make code that is read by humans. </span><span class="koboSpan" id="kobo.102.4">For the most part, you should avoid writing comments on your code unless it’s for copyright and/or it does require an explanation. </span><span class="koboSpan" id="kobo.102.5">Ruby goes as far as having a strange way to write multiline comments. </span><span class="koboSpan" id="kobo.102.6">If I were to write a multiline comment on my code, I would have to look the syntax up because I’ve never used that notation. </span><span class="koboSpan" id="kobo.102.7">That’s not to say that you can’t or that you shouldn’t. </span><span class="koboSpan" id="kobo.102.8">It’s there for a reason. </span><span class="koboSpan" id="kobo.102.9">It simply means that the Ruby community seldom uses that notation. </span><span class="koboSpan" id="kobo.102.10">To write a comment in Ruby, you would simply add the hashtag symbol (</span><strong class="source-inline"><span class="koboSpan" id="kobo.103.1">#</span></strong><span class="koboSpan" id="kobo.104.1">) as the first character on </span><span class="No-Break"><span class="koboSpan" id="kobo.105.1">a line:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.106.1">
# This is a comment</span></pre> <p><span class="koboSpan" id="kobo.107.1">As you know from comments within a snippet of code, this line will be ignored by Ruby. </span><span class="koboSpan" id="kobo.107.2">Keep in mind that a</span><a id="_idIndexMarker007"/><span class="koboSpan" id="kobo.108.1"> programming language, just like a spoken language, evolves due to its use. </span><span class="koboSpan" id="kobo.108.2">The best of tools may be lost just because no one uses them. </span><span class="koboSpan" id="kobo.108.3">Part of learning a language also involves learning the usage of the tools and best practices. </span><span class="koboSpan" id="kobo.108.4">This includes knowing what the Ruby community has decided not to exploit and what to use. </span><span class="koboSpan" id="kobo.108.5">So, while the community rarely uses multiline comments, all Ruby developers will take advantage of one of its most powerful </span><span class="No-Break"><span class="koboSpan" id="kobo.109.1">tools: objects.</span></span></p>
<h1 id="_idParaDest-19"><a id="_idTextAnchor019"/><span class="koboSpan" id="kobo.110.1">Everything is an object</span></h1>
<p><span class="koboSpan" id="kobo.111.1">The second thing that came to my mind while reading the previous code is that we are calling a method on</span><a id="_idIndexMarker008"/><span class="koboSpan" id="kobo.112.1"> a string. </span><span class="koboSpan" id="kobo.112.2">Now, let’s step back a bit, and this is where we start looking at code through our newbie set of Ruby eyes. </span><span class="koboSpan" id="kobo.112.3">Our variable name contains a string. </span><span class="koboSpan" id="kobo.112.4">Does this mean that our name is an object? </span><span class="koboSpan" id="kobo.112.5">Well, the short answer is </span><em class="italic"><span class="koboSpan" id="kobo.113.1">Yes</span></em><span class="koboSpan" id="kobo.114.1">. </span><span class="koboSpan" id="kobo.114.2">Almost everything in Ruby is an object. </span><span class="koboSpan" id="kobo.114.3">I know this might seem as if we’re skipping a few chapters, but bear with me. </span><span class="koboSpan" id="kobo.114.4">We will see Ruby’s object-oriented syntax in </span><a href="B19230_05.xhtml#_idTextAnchor080"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.115.1">Chapter 5</span></em></span></a><span class="koboSpan" id="kobo.116.1">. </span><span class="koboSpan" id="kobo.116.2">For now, let’s take this a step further within our code by getting what type of object our variable has with the </span><span class="No-Break"><span class="koboSpan" id="kobo.117.1">following line:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.118.1">
puts name.class();</span></pre> <p><span class="koboSpan" id="kobo.119.1">This will return the type of class of our object (in this specific case, </span><strong class="source-inline"><span class="koboSpan" id="kobo.120.1">String</span></strong><span class="koboSpan" id="kobo.121.1">). </span><span class="koboSpan" id="kobo.121.2">We are able to do the same with the rest of our variables and we would get similar values (</span><strong class="source-inline"><span class="koboSpan" id="kobo.122.1">Integer</span></strong><span class="koboSpan" id="kobo.123.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.124.1">Float</span></strong><span class="koboSpan" id="kobo.125.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.126.1">TrueClass</span></strong><span class="koboSpan" id="kobo.127.1">, or </span><strong class="source-inline"><span class="koboSpan" id="kobo.128.1">Array</span></strong><span class="koboSpan" id="kobo.129.1">). </span><span class="koboSpan" id="kobo.129.2">And to take this even further to prove my point that almost everything in Ruby is an object, let’s read the </span><span class="No-Break"><span class="koboSpan" id="kobo.130.1">following example:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.131.1">
puts "benjamin".class();</span></pre> <p><span class="koboSpan" id="kobo.132.1">This will also return a </span><strong class="source-inline"><span class="koboSpan" id="kobo.133.1">String</span></strong><span class="koboSpan" id="kobo.134.1"> type. </span><span class="koboSpan" id="kobo.134.2">So, bear that in mind when you’re writing Ruby code. </span><span class="koboSpan" id="kobo.134.3">Now, let’s go back to the initial example with the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.135.1">empty</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.136.1"> function:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.137.1">
name = "bernard";
puts name.empty?();</span></pre> <p><span class="koboSpan" id="kobo.138.1">The third thing we also notice is that we are actually asking a question. </span><span class="koboSpan" id="kobo.138.2">This baffled me the first time I saw it. </span><span class="koboSpan" id="kobo.138.3">How do you know when to ask? </span><span class="koboSpan" id="kobo.138.4">Is Ruby </span><em class="italic"><span class="koboSpan" id="kobo.139.1">so</span></em><span class="koboSpan" id="kobo.140.1"> intuitive that you can actually ask questions? </span><span class="koboSpan" id="kobo.140.2">What type of sorcery is this? </span><span class="koboSpan" id="kobo.140.3">Unfortunately, the truth is far less ominous than the code itself. </span><span class="koboSpan" id="kobo.140.4">In Ruby, we can name a function or a method with the question mark symbol</span><a id="_idIndexMarker009"/><span class="koboSpan" id="kobo.141.1"> as part of the name, solely to improve readability. </span><span class="koboSpan" id="kobo.141.2">It does not have any special execution or meaning to the Ruby interpreter. </span><span class="koboSpan" id="kobo.141.3">We are just able to name a method/function like that. </span><span class="koboSpan" id="kobo.141.4">Having said that, by convention, Ruby developers use the question mark to hint that we will return a Boolean value. </span><span class="koboSpan" id="kobo.141.5">In this case, it merely answers the question about the emptiness of the variable name. </span><span class="koboSpan" id="kobo.141.6">Simply put, if the name is empty, the question will return a </span><strong class="source-inline"><span class="koboSpan" id="kobo.142.1">true</span></strong><span class="koboSpan" id="kobo.143.1"> value, and vice versa. </span><span class="koboSpan" id="kobo.143.2">This naming technique is part of the Ruby philosophy to make our whole code readable. </span><span class="koboSpan" id="kobo.143.3">Additionally, this type of code style is permeated throughout many of Ruby’s internal classes. </span><span class="koboSpan" id="kobo.143.4">Some methods that are attached to number objects and array objects are an example of this. </span><span class="koboSpan" id="kobo.143.5">Here are a </span><span class="No-Break"><span class="koboSpan" id="kobo.144.1">few examples:</span></span></p>
<ul>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.145.1">.</span></strong><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.146.1">odd?</span></strong></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.147.1">.</span></strong><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.148.1">even?</span></strong></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.149.1">.</span></strong><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.150.1">include?</span></strong></span></li>
</ul>
<p><span class="koboSpan" id="kobo.151.1">All these examples were named like that for the sole purpose of readability and nothing more. </span><span class="koboSpan" id="kobo.151.2">Some of them are even shared between different classes but have their own implementation for each type. </span><span class="koboSpan" id="kobo.151.3">While we are currently looking at the question mark symbol, let’s take a peek at a similar symbol: the exclamation point (</span><strong class="source-inline"><span class="koboSpan" id="kobo.152.1">!</span></strong><span class="koboSpan" id="kobo.153.1">). </span><span class="koboSpan" id="kobo.153.2">Also known as a bang, it has a slightly different connotation within Ruby developers. </span><span class="koboSpan" id="kobo.153.3">Let’s look at it with </span><span class="No-Break"><span class="koboSpan" id="kobo.154.1">an example.</span></span></p>
<p><span class="koboSpan" id="kobo.155.1">Let’s show the name in uppercase letters. </span><span class="koboSpan" id="kobo.155.2">In PHP, we would write </span><span class="No-Break"><span class="koboSpan" id="kobo.156.1">the following:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.157.1">
$name = "bernard";
echo strtoupper($name);</span></pre> <p><span class="koboSpan" id="kobo.158.1">In Ruby, the same can be accomplished with the </span><span class="No-Break"><span class="koboSpan" id="kobo.159.1">following code:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.160.1">
name = "bernard";
puts(name.upcase());</span></pre> <p><span class="koboSpan" id="kobo.161.1">In both cases, this will return the name in uppercase (</span><strong class="source-inline"><span class="koboSpan" id="kobo.162.1">BERNARD</span></strong><span class="koboSpan" id="kobo.163.1">). </span><span class="koboSpan" id="kobo.163.2">However, if we make any additional </span><a id="_idIndexMarker010"/><span class="koboSpan" id="kobo.164.1">references to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.165.1">name</span></strong><span class="koboSpan" id="kobo.166.1"> variable, the variable will </span><span class="No-Break"><span class="koboSpan" id="kobo.167.1">remain unchanged:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.168.1">
name = "bernard";
puts(name.upcase());
puts(name);</span></pre> <p><span class="koboSpan" id="kobo.169.1">This would return </span><span class="No-Break"><span class="koboSpan" id="kobo.170.1">the following:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.171.1">
BERNARD
bernard</span></pre> <p><span class="koboSpan" id="kobo.172.1">But what happens if we add the bang </span><span class="No-Break"><span class="koboSpan" id="kobo.173.1">symbol (</span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.174.1">!</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.175.1">)?</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.176.1">
name = "bernard";
puts(name.upcase!());
puts(name);</span></pre> <p><span class="koboSpan" id="kobo.177.1">This will return the name in </span><span class="No-Break"><span class="koboSpan" id="kobo.178.1">uppercase twice:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.179.1">
BERNARD
BERNARD</span></pre> <p><span class="koboSpan" id="kobo.180.1">The bang symbol in fact modifies the variable contents permanently. </span><span class="koboSpan" id="kobo.180.2">Functions that are named with the bang symbol are</span><a id="_idIndexMarker011"/><span class="koboSpan" id="kobo.181.1"> referred to as </span><strong class="bold"><span class="koboSpan" id="kobo.182.1">destructive methods</span></strong><span class="koboSpan" id="kobo.183.1"> because they modify or mutate the original object rather than just return the modified value. </span><span class="koboSpan" id="kobo.183.2">Examples of this are these methods from the </span><strong class="source-inline"><span class="koboSpan" id="kobo.184.1">String</span></strong><span class="koboSpan" id="kobo.185.1"> and </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.186.1">Array</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.187.1"> classes:</span></span></p>
<ul>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.188.1">.</span></strong><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.189.1">downcase!</span></strong></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.190.1">.</span></strong><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.191.1">reverse!</span></strong></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.192.1">.</span></strong><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.193.1">strip!</span></strong></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.194.1">.</span></strong><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.195.1">flatten!</span></strong></span></li>
</ul>
<p><span class="koboSpan" id="kobo.196.1">We can infer what they do just from reading them, but we now know what the bang symbol means in this context. </span><span class="koboSpan" id="kobo.196.2">Be careful when using these, but also don’t be shy of using them when the use case requires it. </span><span class="koboSpan" id="kobo.196.3">Now, when you read Ruby code, you will be aware of the question mark (</span><strong class="source-inline"><span class="koboSpan" id="kobo.197.1">?</span></strong><span class="koboSpan" id="kobo.198.1">) and the bang (</span><strong class="source-inline"><span class="koboSpan" id="kobo.199.1">!</span></strong><span class="koboSpan" id="kobo.200.1">) </span><span class="No-Break"><span class="koboSpan" id="kobo.201.1">symbol.</span></span></p>
<h1 id="_idParaDest-20"><a id="_idTextAnchor020"/><span class="koboSpan" id="kobo.202.1">Transitioning to Ruby</span></h1>
<p><span class="koboSpan" id="kobo.203.1">So far, we’ve seen examples in which our code looks very similar to PHP. </span><span class="koboSpan" id="kobo.203.2">As I mentioned before, I purposely did this to showcase the flexibility of Ruby. </span><span class="koboSpan" id="kobo.203.3">This makes the change to Ruby easier than other languages</span><a id="_idIndexMarker012"/><span class="koboSpan" id="kobo.204.1"> in which the syntax is a lot different than Ruby. </span><span class="koboSpan" id="kobo.204.2">However, this is only the beginning of our journey to becoming a Ruby developer. </span><span class="koboSpan" id="kobo.204.3">If we want to be able to read and write Ruby code and snippets like seasoned Ruby developers, we will need to see how the community has come to make Ruby code. </span><span class="koboSpan" id="kobo.204.4">In short, while we can write our code similar to other languages, we should avoid this practice and, in the process, learn about what Ruby has to offer to make our code more and </span><span class="No-Break"><span class="koboSpan" id="kobo.205.1">more readable.</span></span></p>
<p><span class="koboSpan" id="kobo.206.1">The first step we are going to take toward this goal is to remove unnecessary syntax within our code. </span><span class="koboSpan" id="kobo.206.2">To do this, we also must understand the utility of what we </span><span class="No-Break"><span class="koboSpan" id="kobo.207.1">are removing.</span></span></p>
<p><span class="koboSpan" id="kobo.208.1">Let’s take for an example our </span><span class="No-Break"><span class="koboSpan" id="kobo.209.1">original code:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.210.1">
name = "bernard";
age = 40;
height_in_cms = 177.5;
chocolate_allergy = true;
travel_bucket_list = ["Turkey", "Japan", "Canada"];</span></pre> <p><span class="koboSpan" id="kobo.211.1">In Ruby, the semicolon can be useful to separate multiline code into a single line dividing each line with a semicolon. </span><span class="koboSpan" id="kobo.211.2">If we took the name and the example to turn it into uppercase, we would have </span><span class="No-Break"><span class="koboSpan" id="kobo.212.1">the following:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.213.1">
name = "bernard"; name.upcase!(); puts(name);</span></pre> <p><span class="koboSpan" id="kobo.214.1">And this works perfectly fine. </span><span class="koboSpan" id="kobo.214.2">But remember, we are trying to make our code more readable. </span><span class="koboSpan" id="kobo.214.3">This is not more readable. </span><span class="koboSpan" id="kobo.214.4">It’s the opposite. </span><span class="koboSpan" id="kobo.214.5">And, if we are not going to write our whole code in a single line, then let’s take the original snippet (in multiple lines), and remove every single semicolon. </span><span class="koboSpan" id="kobo.214.6">This is starting to look more </span><span class="No-Break"><span class="koboSpan" id="kobo.215.1">like Ruby:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.216.1">
name = "bernard"
age = 40
height_in_cms = 177.5
chocolate_allergy = true
travel_bucket_list = ["Turkey", "Japan", "Canada"]</span></pre> <p><span class="koboSpan" id="kobo.217.1">This certainly seems to improve readability slightly by removing unused characters, but we are not finished. </span><span class="koboSpan" id="kobo.217.2">Let’s put this into practice with another example. </span><span class="koboSpan" id="kobo.217.3">Let’s write an example that will print </span><a id="_idIndexMarker013"/><span class="koboSpan" id="kobo.218.1">out the string </span><strong class="source-inline"><span class="koboSpan" id="kobo.219.1">This person is allergic to chocolate</span></strong><span class="koboSpan" id="kobo.220.1"> if the value of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.221.1">$chocolate_allergy</span></strong><span class="koboSpan" id="kobo.222.1"> variable is set to </span><strong class="source-inline"><span class="koboSpan" id="kobo.223.1">true</span></strong><span class="koboSpan" id="kobo.224.1">. </span><span class="koboSpan" id="kobo.224.2">Because of our background in PHP, we might be compelled to write something similar to PHP. </span><span class="koboSpan" id="kobo.224.3">In PHP, we would write </span><span class="No-Break"><span class="koboSpan" id="kobo.225.1">the following:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.226.1">
$chocolate_allergy = true;
if($chocolate_ allergy)
{
  echo "This person is allergic to chocolate";
}</span></pre> <p><span class="koboSpan" id="kobo.227.1">With this in mind, we would write the following </span><span class="No-Break"><span class="koboSpan" id="kobo.228.1">in Ruby:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.229.1">
chocolate_allergy = true
if(chocolate_allergy)
  puts("This person is allergic to chocolate")
end</span></pre> <p><span class="koboSpan" id="kobo.230.1">This works fine, but it still looks a lot like PHP. </span><span class="koboSpan" id="kobo.230.2">An intermediate Ruby developer would most likely write something </span><span class="No-Break"><span class="koboSpan" id="kobo.231.1">like this:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.232.1">
chocolate_allergy = true
puts "This person is allergic to chocolate"
  if chocolate_allergy</span></pre> <p><span class="koboSpan" id="kobo.233.1">This is getting more and more readable by the second. </span><span class="koboSpan" id="kobo.233.2">But it also brings a couple of new practices to the table. </span><span class="koboSpan" id="kobo.233.3">For starters, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.234.1">puts</span></strong><span class="koboSpan" id="kobo.235.1"> sentence is not surrounded by parenthesis. </span><span class="koboSpan" id="kobo.235.2">This is because, in Ruby, the use of parenthesis is optional for functions and methods. </span><span class="koboSpan" id="kobo.235.3">This is extremely useful as it’s starting to read like plain English. </span><span class="koboSpan" id="kobo.235.4">It works with functions with multiple</span><a id="_idIndexMarker014"/><span class="koboSpan" id="kobo.236.1"> arguments, too. </span><span class="koboSpan" id="kobo.236.2">As an example, an implemented function could very well look </span><span class="No-Break"><span class="koboSpan" id="kobo.237.1">like this:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.238.1">
add_locations "location 1", "location 2"</span></pre> <p><span class="koboSpan" id="kobo.239.1">Of course, this becomes cumbersome if we need to call nested functions. </span><span class="koboSpan" id="kobo.239.2">Let’s take this example with </span><span class="No-Break"><span class="koboSpan" id="kobo.240.1">two functions:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.241.1">
def concatenate( text1, text2 )
  puts text1 + " " + text2
end
def to_upper( text )
  return text.upcase()
end</span></pre> <p><span class="koboSpan" id="kobo.242.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.243.1">concatenate</span></strong><span class="koboSpan" id="kobo.244.1"> function takes two strings and prints out both strings joined with a space between them. </span><span class="koboSpan" id="kobo.244.2">The second function just turns the input string into an uppercase string and returns the value. </span><span class="koboSpan" id="kobo.244.3">And this is where it could become problematic if we failed to use the parenthesis. </span><span class="koboSpan" id="kobo.244.4">If we wanted to concatenate the two strings and turn each string into an uppercase string, we could try </span><span class="No-Break"><span class="koboSpan" id="kobo.245.1">the following:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.246.1">
concatenate to_upper "something", to_upper "else"</span></pre> <p><span class="koboSpan" id="kobo.247.1">But we would fail miserably because the Ruby interpreter doesn’t know that </span><strong class="source-inline"><span class="koboSpan" id="kobo.248.1">"something"</span></strong><span class="koboSpan" id="kobo.249.1"> is the argument for the </span><strong class="source-inline"><span class="koboSpan" id="kobo.250.1">to_upper</span></strong><span class="koboSpan" id="kobo.251.1"> function. </span><span class="koboSpan" id="kobo.251.2">We can easily fix this </span><span class="No-Break"><span class="koboSpan" id="kobo.252.1">with parenthesis:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.253.1">
concatenate to_upper("something"), to_upper("else")</span></pre> <p><span class="koboSpan" id="kobo.254.1">Be careful with this knowledge as, like everything else, if overdone, it can be detrimental to our code’s readability. </span><span class="koboSpan" id="kobo.254.2">There are two additional points that we need to consider while deciding whether to use parenthesis. </span><span class="koboSpan" id="kobo.254.3">The first is that these rules also apply to the definition of the function. </span><span class="koboSpan" id="kobo.254.4">So, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.255.1">concatenate</span></strong><span class="koboSpan" id="kobo.256.1"> function can be defined </span><span class="No-Break"><span class="koboSpan" id="kobo.257.1">like this:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.258.1">
def concatenate text1, text2
  puts text1 + " " + text2
end</span></pre> <p><span class="koboSpan" id="kobo.259.1">The second point is that the rule also applies to functions with no arguments – that is, we may remove the parenthesis from them, too. </span><span class="koboSpan" id="kobo.259.2">Let’s take the following as </span><span class="No-Break"><span class="koboSpan" id="kobo.260.1">an example:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.261.1">
return text.upcase()</span></pre> <p><span class="koboSpan" id="kobo.262.1">This will now become </span><span class="No-Break"><span class="koboSpan" id="kobo.263.1">the following:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.264.1">
return text.upcase</span></pre> <p><span class="koboSpan" id="kobo.265.1">More importantly, the use of </span><a id="_idIndexMarker015"/><span class="koboSpan" id="kobo.266.1">methods that use the question mark and destructive methods (</span><strong class="source-inline"><span class="koboSpan" id="kobo.267.1">!</span></strong><span class="koboSpan" id="kobo.268.1">) now make perfect sense </span><span class="No-Break"><span class="koboSpan" id="kobo.269.1">for readability.</span></span></p>
<p><span class="koboSpan" id="kobo.270.1">Let’s look at </span><span class="No-Break"><span class="koboSpan" id="kobo.271.1">the following:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.272.1">
name.empty?()</span></pre> <p><span class="koboSpan" id="kobo.273.1">This becomes </span><span class="No-Break"><span class="koboSpan" id="kobo.274.1">as follows:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.275.1">
name.empty?</span></pre> <p><span class="koboSpan" id="kobo.276.1">As another example, let’s take </span><span class="No-Break"><span class="koboSpan" id="kobo.277.1">the following:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.278.1">
name.upcase!()</span></pre> <p><span class="koboSpan" id="kobo.279.1">This now becomes </span><span class="No-Break"><span class="koboSpan" id="kobo.280.1">as follows:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.281.1">
name.upcase!</span></pre> <p><span class="koboSpan" id="kobo.282.1">The last point we will look at now is related to how Ruby behaves with the return of values. </span><span class="koboSpan" id="kobo.282.2">While a method can explicitly return a value with the </span><strong class="source-inline"><span class="koboSpan" id="kobo.283.1">return</span></strong><span class="koboSpan" id="kobo.284.1"> keyword, Ruby doesn’t need this keyword. </span><span class="koboSpan" id="kobo.284.2">Within functions and methods, Ruby automatically returns the last value that is referenced. </span><span class="koboSpan" id="kobo.284.3">Let’s use the following example </span><span class="No-Break"><span class="koboSpan" id="kobo.285.1">for this:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.286.1">
def to_upper text
  return text.upcase
end</span></pre> <p><span class="koboSpan" id="kobo.287.1">That example would turn </span><span class="No-Break"><span class="koboSpan" id="kobo.288.1">into this:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.289.1">
def to_upper text
  text.upcase
end</span></pre> <p><span class="koboSpan" id="kobo.290.1">You will see a lot of Ruby code like this. </span><span class="koboSpan" id="kobo.290.2">It can be intimidating and confusing at first, but once you understand what Ruby is doing, it simply starts to make </span><span class="No-Break"><span class="koboSpan" id="kobo.291.1">more sense.</span></span></p>
<p><span class="koboSpan" id="kobo.292.1">As you have probably realized by now, Ruby’s creator put a lot of emphasis on these tools to make it easier to write readable code. </span><span class="koboSpan" id="kobo.292.2">The community adopted this ideology and put it into practice. </span><span class="koboSpan" id="kobo.292.3">We not only see code using these conventions and rules to increment readability but we also see Ruby programmers adopt other conventions that, while they are not part of the Ruby rules per se, make perfect sense when used in context. </span><span class="koboSpan" id="kobo.292.4">I’m referring to variable and method naming. </span><span class="koboSpan" id="kobo.292.5">Because Ruby developers will try to make their code read like </span><a id="_idIndexMarker016"/><span class="koboSpan" id="kobo.293.1">plain English, they will spend a lot of time thinking about how to name methods and variables to make the code more readable. </span><span class="koboSpan" id="kobo.293.2">For this reason, snake-case is more often used in Ruby, as it helps with readability. </span><span class="koboSpan" id="kobo.293.3">With that in mind, let’s look at </span><span class="No-Break"><span class="koboSpan" id="kobo.294.1">this example:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.295.1">
chocolate_allergy = true
puts "This person is allergic to chocolate"
  if chocolate_allergy</span></pre> <p><span class="koboSpan" id="kobo.296.1">We can still improve its readability. </span><span class="koboSpan" id="kobo.296.2">And it wouldn’t just be a syntactic change; it would also involve variable names and even defining a method, just to improve readability. </span><span class="koboSpan" id="kobo.296.3">So, a seasoned Ruby developer might write the final snippet for this example </span><span class="No-Break"><span class="koboSpan" id="kobo.297.1">as follows:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.298.1">
def say text
  text
end
is_allergic = true
say "This person is allergic to chocolate" if is_allergic</span></pre> <p><span class="koboSpan" id="kobo.299.1">As you can see, Ruby developers will go very far to make the code as readable as plain English. </span><span class="koboSpan" id="kobo.299.2">Of course, this is not always feasible and sometimes it’s not practical as it at times requires putting a lot of effort into writing even something simple, but for the most part, as long as it’s readable, by following these guidelines, other developers will thank you, not just the </span><span class="No-Break"><span class="koboSpan" id="kobo.300.1">Ruby ones.</span></span></p>
<h1 id="_idParaDest-21"><a id="_idTextAnchor021"/><span class="koboSpan" id="kobo.301.1">Summary</span></h1>
<p><span class="koboSpan" id="kobo.302.1">In this chapter, we covered the syntactic differences and similarities between PHP and Ruby, Ruby’s tools for readability, and Ruby’s syntactic flexibility. </span><span class="koboSpan" id="kobo.302.2">We also learned about the question mark (</span><strong class="source-inline"><span class="koboSpan" id="kobo.303.1">?</span></strong><span class="koboSpan" id="kobo.304.1">) and the exclamation or bang symbol (</span><strong class="source-inline"><span class="koboSpan" id="kobo.305.1">!</span></strong><span class="koboSpan" id="kobo.306.1">). </span><span class="koboSpan" id="kobo.306.2">Making it this far means that you are indeed trying to reuse your previous programming skills but with a new language: Ruby. </span><span class="koboSpan" id="kobo.306.3">This is a great start because you can skip one of the most difficult parts of learning a new language from scratch: the logical part. </span><span class="koboSpan" id="kobo.306.4">And while we’ve only seen the surface of Ruby, more importantly, we got a clear glimpse of how Ruby developers think when they’re writing code. </span><span class="koboSpan" id="kobo.306.5">We learned that to a Ruby developer, readability comes first. </span><span class="koboSpan" id="kobo.306.6">We not only use syntax and language constructs to make this possible but we also use objects to increase the code’s legibleness. </span><span class="koboSpan" id="kobo.306.7">The more it reads like a sentence, the better. </span><span class="koboSpan" id="kobo.306.8">We looked at some simple examples of Ruby, and while you could follow along, it was not the purpose of the exercise. </span><span class="koboSpan" id="kobo.306.9">It was more to pique </span><span class="No-Break"><span class="koboSpan" id="kobo.307.1">your interest.</span></span></p>
<p><span class="koboSpan" id="kobo.308.1">To move along on this learning path, we now need the proper tools to start writing and running Ruby code. </span><span class="koboSpan" id="kobo.308.2">In the next chapter, we will look at the different ways to install Ruby and set up our local environment so that we can start learning real examples of Ruby, and eventually follow along in </span><span class="No-Break"><span class="koboSpan" id="kobo.309.1">the process.</span></span></p>
</div>
</body></html>