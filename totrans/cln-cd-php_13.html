<html><head></head><body>
		<div id="_idContainer054">
			<h1 id="_idParaDest-194" class="chapter-number"><a id="_idTextAnchor195"/>13</h1>
			<h1 id="_idParaDest-195"><a id="_idTextAnchor196"/>Creating Effective Documentation</h1>
			<p>Many developers consider documentation as a burden rather than a meaningful activity. This is comprehensible since often enough, the documentation is not updated anymore after it has been written. Soon, it is full of wrong statements and outdated information, which is indeed something that nobody wants.</p>
			<p>We are convinced that documentation is too important to abandon it. If done right, it will be a valuable addition and an important building block for writing clean code, especially when Working in a Team. </p>
			<p>Therefore, in the last chapter of this book, we want to give you some ideas about how to write documentation that is practical and maintainable.  </p>
			<p>We are going to cover the following main topics in this chapter:</p>
			<ul>
				<li>Why documentation matters</li>
				<li>Creating documentation</li>
				<li>Inline documentation</li>
			</ul>
			<h1 id="_idParaDest-196"><a id="_idTextAnchor197"/>Technical requirements</h1>
			<p>For this chapter, there are no additional technical requirements. All code samples can be found in our GitHub repository: <a href="https://github.com/PacktPublishing/Clean-Code-in-PHP">https://github.com/PacktPublishing/Clean-Code-in-PHP</a>.</p>
			<h1 id="_idParaDest-197"><a id="_idTextAnchor198"/>Why documentation matters</h1>
			<p>Welcome to <a id="_idIndexMarker750"/>the last chapter of this book. You have come a long way, and before you put this book down, for the time being, we want to draw your attention to the often-neglected topic of creating documentation. Let us convince you on the following pages that documentation does not necessarily have to be tiring and annoying, but instead has valuable benefits.</p>
			<h2 id="_idParaDest-198"><a id="_idTextAnchor199"/>Why documentation is important</h2>
			<p>Why should we actually create any documentation? Is our code, or our tests, not enough documentation already? There is some truth in these thoughts, and we will discuss this topic further in this section. Yet over the years, countless developers have never stopped creating countless documents, so there must be something about it.</p>
			<p>We create <a id="_idIndexMarker751"/>documentation because we can make it easier for other people to work with our software. It is about context, which cannot be easily extracted from reading the code of a couple of classes. Documentation is often not only about the <em class="italic">what</em> or <em class="italic">how</em>, but also about the <em class="italic">why</em>. </p>
			<p>Knowing the motivation or the external factors that lead to a decision is crucial to understanding and accepting why a project was built in a certain way. For example, you might complain about your former colleague who has implemented a brittle, cronjob-triggered <a id="_idIndexMarker752"/>download of <strong class="bold">comma-separated values</strong> (<strong class="bold">CSV</strong>) files from <a id="_idIndexMarker753"/>an external <strong class="bold">File Transfer Protocol</strong> (<strong class="bold">FTP</strong>) server, unless you learn from the documentation that the customer was simply <a id="_idIndexMarker754"/>unable to provide a <strong class="bold">REpresentational State Transfer</strong> (<strong class="bold">REST</strong>) <strong class="bold">application programming interface</strong> (<strong class="bold">API</strong>) endpoint <a id="_idIndexMarker755"/>to deliver the data before the project deadline.</p>
			<p>A new colleague who starts on your project will surely be happy to have at least some documentation to read, to not need to ask (and probably disturb) other developers for every little question. And let us not forget our future selves, who have not touched that project for many months and must fix a critical bug now. If only we knew what our past selves did back in the day... and why.</p>
			<p>If you <a id="_idIndexMarker756"/>create <strong class="bold">open source software</strong> (<strong class="bold">OSS</strong>), then documentation is also important. If you need to evaluate several third-party packages to decide which one to use in a project, it is more likely that a package will be considered if it has good documentation. Wouldn’t it be a shame if you invested countless hours in a tool, but nobody uses it because it has no or no good documentation?</p>
			<p>Lastly, if you do software development for a living, you should consider it part of the duty of a professional developer to write documentation. This is what you get paid for.</p>
			<h2 id="_idParaDest-199"><a id="_idTextAnchor200"/>Developer documentation</h2>
			<p>When we think of <a id="_idIndexMarker757"/>documentation, it is usually <em class="italic">user documentation</em> that comes to our minds first: long, hard-to-read, and boring texts about how to use every single feature of a software <a id="_idIndexMarker758"/>product, such as—for example—a word processor. Of course, this documentation exists for a good reason, but that should not interest us in the context of this book, as it is usually not written by (and for) developers.</p>
			<p><em class="italic">Software documentation</em> is an <a id="_idIndexMarker759"/>extensive field, and as such, cannot be covered in total in this chapter. We rather want to focus on documentation that supports you in the development process and enables you to write <em class="italic">clean code</em>, as described in the following, non-exhaustive list:</p>
			<ul>
				<li><strong class="bold">Administration and configuration guides</strong>: Besides the obvious need to describe <a id="_idIndexMarker760"/>how to install and configure the software, make sure to include a section about <em class="italic">code quality</em>. This should contain information about which tools are used locally, and how they are configured.</li>
				<li><strong class="bold">System architecture documentation</strong>: As soon as your project becomes big enough <a id="_idIndexMarker761"/>that the basic server setup (usually a web server and database on one physical machine) becomes a bottleneck, and you start scaling it, you should think about documenting your infrastructure as well. Eventually, this will save you and others a <a id="_idIndexMarker762"/>lot of time searching for the correct <strong class="bold">Uniform Resource Locators</strong> (<strong class="bold">URLs</strong>) or server accesses, especially in critical situations. It <a id="_idIndexMarker763"/>might be a good place to add information about the <strong class="bold">continuous integration</strong> (<strong class="bold">CI</strong>) pipeline as well.</li>
				<li><strong class="bold">Software architecture documentation</strong>: How is your software built internally? Does it use <em class="italic">events</em> to communicate between the modules? Are there any <a id="_idIndexMarker764"/>queues that should be used? Questions such as these should be answered in the <em class="italic">software architecture documentation</em>. This makes it easier for other developers to follow the principles.</li>
				<li><strong class="bold">Coding guidelines</strong>: In <a id="_idIndexMarker765"/>addition to the software architecture documentation, <em class="italic">coding guidelines</em> offer advice on how to write the code. We discussed this topic in depth in <a href="B19050_12.xhtml#_idTextAnchor174"><em class="italic">Chapter 12</em></a><em class="italic">, Working in a Team</em>.</li>
				<li><strong class="bold">API documentation</strong>: If <a id="_idIndexMarker766"/>your <strong class="bold">PHP: Hypertext Preprocessor</strong> (<strong class="bold">PHP</strong>) application has an API that is used by other developers <a id="_idIndexMarker767"/>or even customers, you need to provide a good overview of the API functionality. This makes theirs and your life easier, as you will have fewer interruptions from people who want to know how the API works. You can also give good examples of how to build additional API endpoints.</li>
			</ul>
			<p>In the next section, we would like to have a closer look at how writing these types of documentation can be made easier.</p>
			<h1 id="_idParaDest-200"><a id="_idTextAnchor201"/>Creating documentation</h1>
			<p>Documentation <a id="_idIndexMarker768"/>can be written in many ways. There is no one correct approach, and it is often predetermined by the tools already in use, such as the repository service or the company wiki. Still, there are a few tips and tricks that will help you to write and maintain it, and we want to introduce you to these in this section.</p>
			<h2 id="_idParaDest-201"><a id="_idTextAnchor202"/>Text documents</h2>
			<p>Let us first <a id="_idIndexMarker769"/>focus on the typical, manually written text documents. The <a id="_idIndexMarker770"/>classic approach is to set up a wiki, as these have the great advantage that they can be accessed and used even by less-technical people. This makes them a <a id="_idIndexMarker771"/>great choice for companies. Modern wikis, either self-hosted or <strong class="bold">software-as-a-service</strong> (<strong class="bold">SaaS</strong>), offer a lot of reassurance and useful features such as inline comments or versioning. They also can connect with many external tools, such as ticket systems.</p>
			<p>Another option is to keep the documentation close to your code by adding it to the repository—for example, within a subfolder. This is a valid approach as well, especially for smaller <a id="_idIndexMarker772"/>teams or open source projects. You should not use bloated <a id="_idIndexMarker773"/>formats such as <strong class="bold">Word</strong> or <strong class="bold">Portable Document Format</strong> (<strong class="bold">PDF</strong>), though, and rather focus on text-based formats such as <strong class="bold">Markdown</strong>. They <a id="_idIndexMarker774"/>are many times smaller, and changes to them are easy to track through the version control history. </p>
			<p>The crux with manually written documentation is to keep it up to date. Text files or wikis are patient <a id="_idIndexMarker775"/>and do not forget, and over time, many <a id="_idIndexMarker776"/>pages of documentation virtually pile up in their storage. It gets problematic when it is unclear which documentation is correct and which is outdated. Once in doubt, it is not trustworthy at all anymore.</p>
			<p>The only way to address this problem is to set up a process that makes sure that the documents get updated. In the previous chapter, we already introduced a possible way: <em class="italic">code reviews</em> in combination <a id="_idIndexMarker777"/>with a <strong class="bold">Definition of Done</strong> (<strong class="bold">DoD</strong>). This makes sure that, whenever we are about to add some new or changed code to our code base, we get reminded by a checklist to update the documentation, if necessary.</p>
			<p>In particular, system and software architecture are documented using diagrams. Therefore, in the next section, we want to show you how to effectively create these.</p>
			<h2 id="_idParaDest-202"><a id="_idTextAnchor203"/>Diagrams</h2>
			<p>A good diagram <a id="_idIndexMarker778"/>is usually much more telling than a long text. There <a id="_idIndexMarker779"/>are many free-to-use <em class="italic">diagramming tools</em> available, and you can choose to either manually draw the diagrams or generate them from text definitions.</p>
			<h3>Drawing diagrams manually</h3>
			<p>The classical <a id="_idIndexMarker780"/>way of creating a diagram is by using a diagramming tool that allows you to draw it manually. These tools are specifically designed to assist you in the creation process—for example, by offering templates and icon sets, or by maintaining the connecting arrows between objects if they are moved.</p>
			<p>A versatile tool that we want to<a id="_idIndexMarker781"/> present to you in this chapter is <em class="italic">diagrams.net</em> (<a href="https://www.diagrams.net">https://www.diagrams.net</a>). In fact, we also used it to create illustrations for this book. It offers a library of elements that, for example, can be used to create diagrams such as <strong class="bold">Unified Modeling Language</strong> (<strong class="bold">UML</strong>) diagrams<a id="_idIndexMarker782"/> and <em class="italic">flow charts</em>. It also<a id="_idIndexMarker783"/> offers icons for the <a id="_idIndexMarker784"/>most <a id="_idIndexMarker785"/>popular cloud providers, such as <strong class="bold">Google Cloud Platform</strong> (<strong class="bold">GCP</strong>), <strong class="bold">Amazon Web Services</strong> (<strong class="bold">AWS</strong>), and Microsoft Azure.</p>
			<p>If you <a id="_idIndexMarker786"/>intend to use it, we recommend saving your diagrams as <strong class="bold">Scalable Vector Graphics</strong> (<strong class="bold">SVG</strong>). SVG is based on <strong class="bold">Extensible Markup Language</strong> (<strong class="bold">XML</strong>), and <a id="_idIndexMarker787"/>although XML is <a id="_idIndexMarker788"/>quite verbose, it still consumes less disk space than graphic formats such as <strong class="bold">Portable Network Graphics</strong> (<strong class="bold">PNG</strong>).</p>
			<p>More <a id="_idIndexMarker789"/>importantly, it can be loaded and amended in the editor repeatedly, so you do not have to start over again every time your system changes. Most <strong class="bold">integrated development environments</strong> (<strong class="bold">IDEs</strong>) and all browsers will display <a id="_idIndexMarker790"/>SVG files as graphical images that can even be scaled indefinitely, and if necessary, they can easily be exported into the most popular image formats.</p>
			<h3>Generating diagrams from definitions</h3>
			<p>Not everybody <a id="_idIndexMarker791"/>likes to use fiddly editors to draw diagrams, though. Luckily, there is a variety of <em class="italic">diagramming tools</em> that can generate<a id="_idIndexMarker792"/> diagrams from definitions. To demonstrate how they work in general, we chose <em class="italic">Mermaid.js</em> (<a href="https://mermaid-js.github.io">https://mermaid-js.github.io</a>) as an example. It is written in <em class="italic">JavaScript</em> and utilizes a Markdown-inspired language to define the diagrams.</p>
			<p>Before we check out the advantages of this approach, let us first have a look at a simple example of a flow chart:</p>
			<pre class="source-code">
graph LR 
    A{Do you know how to write great PHP code?} --&gt; B[No]
    A --&gt; C[Yes] 
    C --&gt; E(Awesome!) 
    B --&gt; D{Did you read Clean Code in PHP?} --&gt; F[No] 
    D --&gt; G[Yes] 
    G --&gt; H(Please read it again) 
    F --&gt; I(Please read it)</pre>
			<p>The preceding code would render a diagram, as shown here:</p>
			<div>
				<div id="_idContainer052" class="IMG---Figure">
					<img src="image/Figure_13.01_B19050.jpg" alt=""/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 13.1: Mermaid diagram example</p>
			<p>Diagram <a id="_idIndexMarker793"/>generation tools help you to create several <a id="_idIndexMarker794"/>diagram types, such <a id="_idIndexMarker795"/>as <em class="italic">sequence diagrams</em>, <em class="italic">Gantt charts</em>, or <a id="_idIndexMarker796"/>even the well-known <em class="italic">pie charts</em>. You do not have to think about how to style them or how they are arranged. The main work is taken over by the diagramming tool. Of course, Mermaid.js offers many ways to affect the appearance of generated diagrams.</p>
			<p>Since the diagram definitions are simple text blocks, they can be added to the code repository. Changes to them are comfortably traceable through the version history. Mermaid diagrams integrate especially well in Markdown documents since the most popular IDEs can display these diagrams directly in the document through additional extensions.</p>
			<p>Lastly, if you <a id="_idIndexMarker797"/>just want to play around with the possibilities of Mermaid, you can use the <em class="italic">Mermaid Live Editor</em> (<a href="https://mermaid.live">https://mermaid.live</a>) to better understand how it works.</p>
			<p class="callout-heading">Mermaid alternatives</p>
			<p class="callout">Other noteworthy <a id="_idIndexMarker798"/>diagramming tools are <em class="italic">PlantUML</em> (<a href="https://plantuml.com">https://plantuml.com</a>), which offers even more practical diagram types to document software architecture, and <em class="italic">Diagrams</em> (<a href="https://diagrams.mingrammer.com">https://diagrams.mingrammer.com</a>), which is strong <a id="_idIndexMarker799"/>in documenting system architecture.</p>
			<h2 id="_idParaDest-203"><a id="_idTextAnchor204"/>Documentation generators</h2>
			<p>Probably the best documentation is one we do not need to create ourselves and is still as useful as <a id="_idIndexMarker800"/>human written content. Unfortunately, this will continue to be a dream for now, although we do not know where <strong class="bold">machine learning</strong> (<strong class="bold">ML</strong>) will take <a id="_idIndexMarker801"/>us in the future. </p>
			<p>Right now, we can already use tools to create documentation from our code. At least, we can use them to aggregate information that is spread across the many classes of our projects.</p>
			<h3>API documentation</h3>
			<p>In this section, we will show you how to create documentation from code using an example <a id="_idIndexMarker802"/>of API documentation. If your application provides an API, it is fundamental to have up-to-date documentation for it. Writing such documentation is a time-consuming and error-prone process, but we can at least make it a bit easier. </p>
			<p>There <a id="_idIndexMarker803"/>exist many approaches to documenting APIs. In this book, we will introduce you to one format <a id="_idIndexMarker804"/>that has become more and more popular: <strong class="bold">OpenAPI</strong>. This format, formerly <a id="_idIndexMarker805"/>known as <strong class="bold">Swagger</strong>, describes all aspects of an API <a id="_idIndexMarker806"/>in a <strong class="bold">YAML Ain’t Markup Language</strong> (<strong class="bold">YAML</strong>) document, which could look like this:</p>
			<pre class="source-code">
openapi: 3.0.0
info:
  title: 'Product API'
  version: '0.1'
paths:
  /product:
    get:
      operationId: getProductsUsingAnnotations
      parameters:
        -
          name: limit
          in: query
          description: 'How many products to return'
          required: false
          schema:
            type: integer
      responses:
        '200':
          description: 'Returns the product data'</pre>
			<p>This <a id="_idIndexMarker807"/>might be a bit too much information <a id="_idIndexMarker808"/>at first glance. Do not worry, though—it is not that complicated. In a nutshell, the preceding YAML describes the <strong class="source-inline">Product</strong> API in its version <strong class="source-inline">0.1</strong>, which offers <a id="_idIndexMarker809"/>one endpoint, <strong class="source-inline">/product</strong>. This endpoint can be called using the <strong class="bold">Hypertext Transfer Protocol</strong> (<strong class="bold">HTTP</strong>) verb <strong class="source-inline">GET</strong> and accepts the optional parameter <strong class="source-inline">limit</strong>, which is of type <strong class="source-inline">integer</strong> and must be written in the URL query (for example, <strong class="source-inline">/product?limit=50</strong>). If all goes well, the endpoint will return with the HTTP code <strong class="source-inline">200</strong>.</p>
			<p class="callout-heading">OpenAPI documentation</p>
			<p class="callout">The <strong class="source-inline">OpenAPI</strong> format is <a id="_idIndexMarker810"/>quite extensive, so we cannot cover it in this book. If you are interested in learning more about it, please look at the official documentation:  <a href="https://oai.github.io/Documentation">https://oai.github.io/Documentation</a>.</p>
			<p>As a welcome benefit, IDEs such<a id="_idIndexMarker811"/> as <em class="italic">PhpStorm</em> by default support you in writing these YAML files by checking the validity of the schema. If you, for example, wrote <strong class="source-inline">operation</strong> instead of <strong class="source-inline">operationId</strong>, the IDE would highlight the wrong usage.</p>
			<p>You can either write a YAML file manually or have it generated. We want to have a closer look at the latter use case. To achieve this, we need the help of a <em class="italic">Composer</em> package <a id="_idIndexMarker812"/>called <strong class="source-inline">swagger-php</strong> (<a href="https://github.com/zircote/swagger-php">https://github.com/zircote/swagger-php</a>). Please refer to the package documentation on how to install it.</p>
			<p>Of course, the package cannot magically create documentation out of nothing. Instead, <strong class="source-inline">swagger-php</strong> parses meta information that is written directly in the PHP code, either as <em class="italic">DocBlock annotations</em> or, with PHP <strong class="source-inline">8.1</strong>, as <em class="italic">attributes</em>. In other words, we need to make sure that the meta information is already there before we can generate the YAML file.</p>
			<p>What <a id="_idIndexMarker813"/>does this information look like? Let <a id="_idIndexMarker814"/>us have a look at the first example, using <em class="italic">annotations</em>:</p>
			<pre class="source-code">
/**
 * @OA\Info(
 *     title="Product API",
 *     version="0.1"
 * )
 */
class ProductController
{
    /**
     * @OA\Get(
     *     path="/product",
     *     operationId="getProducts",
     *     @OA\Parameter(
     *         name="limit",
     *         in="query",
     *         description="How many products to return",
     *         required=false,
     *         @OA\Schema(
     *             type="integer"
     *         )
     *     ),
     *     @OA\Response(
     *         response="200",
     *         description="Returns the product data"
     *     )
     * )
     */
    public function getProducts(): array
    {
        // ...
    }
}</pre>
			<p>Based <a id="_idIndexMarker815"/>on the information inside <a id="_idIndexMarker816"/>the DocBlocks, <strong class="source-inline">swagger-php</strong> will return the documentation of our API as a YAML file that will look exactly like the preceding example. But why should we use <strong class="source-inline">swagger-php</strong> when we could write the YAML directly?</p>
			<p>Indeed, not everybody wants to have big blocks of documentation within the code, and depending on the level of detail you want to document, they can become much bigger than in our previous example. If you think of an API with many endpoints that are scattered across various controllers in your code, though, you might already realize the benefits: all required meta information is stored close to the code, so if changes are made on the endpoint, it is much easier for the developer to simply amend the DocBlock annotations than to do these changes in some additional document or wiki. Since the comments are part of the code, the changes are also already under version control. In the end, the decision to use <strong class="source-inline">swagger-php</strong> is up to you or the team.</p>
			<p>In the <em class="italic">Inline documentation</em> section of this chapter, we will discuss why DocBlocks are not the best place to store meta information. Since PHP <strong class="source-inline">8.0</strong>, we luckily have a better place for them—namely, attributes, which we already talked about in <a href="B19050_06.xhtml#_idTextAnchor069"><em class="italic">Chapter 6</em></a><em class="italic">, PHP is Evolving- Deprecations and Revolutions</em>. </p>
			<p>Before <a id="_idIndexMarker817"/>we discuss why they are <a id="_idIndexMarker818"/>the better option, let us have a look here at how our endpoint would be documented by using attributes:</p>
			<pre class="source-code">
use OpenApi\Attributes as OAT;
#[OAT\Info(
    version: '0.1',
    title: 'Product API',
)]
class ProductController
{
    #[OAT\Get(
        path: '/v2/product',
        operationId: 'getProducts',
        parameters: [
            new OAT\Parameter(
                name: 'limit',
                description: 'How many products to return',
                in: 'query',
                required: false,
                schema: new OAT\Schema(
                    type: 'integer'
                ),
            ),
        ],
        responses: [
            new OAT\Response(
                response: 200,
                description: 'Returns the product data',
            ),
        ]
    )]
    public function getProducts(): array
    {
        // ...
    }
}</pre>
			<p>Admittedly, the attribute syntax might look a bit unfamiliar. We recommend using attributes <a id="_idIndexMarker819"/>instead of annotations, however, because they come with convenient advantages. Firstly, they are real code; they <a id="_idIndexMarker820"/>get parsed by the PHP interpreter, and your IDE will be able to support you in writing them. In the first line of the preceding example, you can see that we need to import the <strong class="source-inline">OpenApi\Attributes</strong> namespace to make this example work. </p>
			<p>Within this namespace, you will find actual classes that are referenced here. The files are located inside the <strong class="source-inline">vendor</strong> folder of your project. This enables you to use features such as autocompletion, and you will get immediate feedback from your IDE if something is not correct, which makes the writing of such documentation much easier.</p>
			<p>As the last step, you need to generate a YAML file from the code. This step can, of course, be automated in the <em class="italic">CI pipeline</em>, which we introduced in <a href="B19050_11.xhtml#_idTextAnchor145"><em class="italic">Chapter 11</em></a><em class="italic">, Continuous Integration</em>. You can find examples of the usage in our Git repository for this book.</p>
			<p>You might wonder: what can I do with this API documentation? Surely, it can already function as documentation for other developers, but there is much more to it. You can, for example, import it into HTTP clients such as <em class="italic">Insomnia</em> or <em class="italic">Postman</em>. That way, you can immediately start to interact with the API without having to look up the exact schema.</p>
			<p>Another <a id="_idIndexMarker821"/>use case is to help you <a id="_idIndexMarker822"/>write functional tests for your API. There <a id="_idIndexMarker823"/>are packages such as <em class="italic">PHP Swagger Test</em> (<a href="https://github.com/byjg/php-swagger-test">https://github.com/byjg/php-swagger-test</a>) or <em class="italic">Spectator</em> (<a href="https://github.com/hotmeteor/spectator">https://github.com/hotmeteor/spectator</a>) that <a id="_idIndexMarker824"/>can assist you <a id="_idIndexMarker825"/>in writing tests against the <strong class="bold">OpenAPI Specification</strong> (<strong class="bold">OAS</strong>), which can also be considered as a <em class="italic">contract</em>. You can test, for example, if the returned object for a specific HTTP status code equals what is specified in that <strong class="source-inline">contract</strong>.</p>
			<p>Lastly, and <a id="_idIndexMarker826"/>probably the most important use case, is to use the OAS specification with <em class="italic">Swagger UI</em> (<a href="https://github.com/swagger-api/swagger-ui">https://github.com/swagger-api/swagger-ui</a>), which is a visual and interactive documentation of your API. </p>
			<p>The following screenshot shows what our example API would look like:</p>
			<div>
				<div id="_idContainer053" class="IMG---Figure">
					<img src="image/Figure_13.02_B19050.jpg" alt=""/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 13.2: Swagger UI</p>
			<p>Exploring all possibilities of <strong class="source-inline">OpenAPI</strong> and Swagger UI would go beyond the scope of our book. We <a id="_idIndexMarker827"/>recommend you check <a id="_idIndexMarker828"/>out both tools if you want to learn more about them.</p>
			<p class="callout-heading">OpenAPI alternatives</p>
			<p class="callout">There <a id="_idIndexMarker829"/>are other <a id="_idIndexMarker830"/>formats such as <strong class="bold">RESTful API Modeling Language</strong> (<strong class="bold">RAML</strong>) (<a href="https://raml.org">https://raml.org</a>) or <em class="italic">API Blueprint</em> (<a href="https://apiblueprint.org">https://apiblueprint.org</a>) that you could use, and we <a id="_idIndexMarker831"/>are not opinionated toward any solution.</p>
			<h1 id="_idParaDest-204"><a id="_idTextAnchor205"/>Inline documentation</h1>
			<p>A special case is documentation that many of us have done regularly since we started writing <a id="_idIndexMarker832"/>software: comments. These are written directly in the code, where the developers can immediately see them, so that seems to be a good place to put documentation. But should comments really be seen as or used for documentation?</p>
			<p>In our opinion, comments should generally be avoided. Let us have a look at some arguments on the next pages.</p>
			<h2 id="_idParaDest-205"><a id="_idTextAnchor206"/>Annotations are no code</h2>
			<p>Comments are <a id="_idIndexMarker833"/>not part of the code. Although it is possible to parse comments through the Reflection API of PHP, they were originally not meant to store meta information. Ideally, your software should still work the same after stripping out all comments.</p>
			<p>Today, though, this is <a id="_idIndexMarker834"/>often not the case anymore. Frameworks and packages such as <strong class="bold">object-relational mappers</strong> (<strong class="bold">ORMs</strong>) use DocBlock annotations to store information in them, such as route definitions or relations between database objects. Some <em class="italic">code quality tools</em> use annotations to control their behavior on certain parts of the code. </p>
			<p>PHP cannot throw error messages if your annotations are wrong. If they serve an important purpose, your tests will hopefully catch the bug before they are deployed to production. A better choice is attributes, which are a real language construct. We discussed <a id="_idIndexMarker835"/>these in more detail earlier in this chapter when we talked about API documentation.</p>
			<h2 id="_idParaDest-206"><a id="_idTextAnchor207"/>Unreadable code</h2>
			<p>Furthermore, as we already discussed in <a href="B19050_12.xhtml#_idTextAnchor174"><em class="italic">Chapter 12</em></a>, <em class="italic">Working in a team</em>, comments are often <a id="_idIndexMarker836"/>an indicator of code that is too complex. Instead of explaining your code, you should rather aim to write code that does not need to be commented in the first place.</p>
			<p>It can be a fun exercise to compress a whole function into a one-liner—for example, by using some quadruple-nested ternary operators or a frighteningly complicated <strong class="source-inline">if</strong> clause that nobody will understand. You will regret having written it latest at the point when there is a high-priority bug in the production environment, and it is on you to fix it without having the slightest idea anymore what your cryptic masterpiece is supposed to do. </p>
			<p>Or, even worse, your new colleague on their first on-call shift has the honor of debugging late at night, when the alerts keep coming in. There are better ways to start a working relationship.</p>
			<h2 id="_idParaDest-207"><a id="_idTextAnchor208"/>Outdated comments</h2>
			<p>A comment is quickly written, but also quickly forgotten. Since comments are not parsed by <a id="_idIndexMarker837"/>the PHP interpreter, you will not get informed when they are not correct anymore—for example, when the function they are supposed to explain gets rewritten and suddenly serves a different purpose. There is no other way to validate the comments than a developer trying to read and understand their meaning, and comparing it with the actual function code.</p>
			<p>At the time of writing, this might not sound like a problem but imagine coming back to a class after a year and finding a comment that you do not understand anymore. Why did you write it in the first place? And if you do not know why, how is anybody else supposed to know?</p>
			<p>Outdated comments are wrong information within your code. They are distracting and costly since <a id="_idIndexMarker838"/>the developer time does not come for free. Therefore, think twice before you add them.</p>
			<h2 id="_idParaDest-208"><a id="_idTextAnchor209"/>Useless comments</h2>
			<p>Try to <a id="_idIndexMarker839"/>avoid comments that state the obvious and do not add any further information. The following code snippet is a real-life example of this:</p>
			<pre class="source-code">
// write the string to the log file
file_put_contents($logFileName, $someString)</pre>
			<p>Although it could be considered a nice gesture that the developer took the time to explain the <strong class="source-inline">file_put_contents</strong> function, it does not add value to the code. If you do not know a function, you can look it up. Other than that, it is just an unnecessary line of code you need to scan when reading the code. </p>
			<p>It is sometimes not easy to draw a line between useful and useless comments. You could use code reviews to cope with this problem; as discussed in <a href="B19050_12.xhtml#_idTextAnchor174"><em class="italic">Chapter 12</em></a>, <em class="italic">Working in a Team</em>, having somebody else from your team do honest reviews of your code will help to avoid comments such as these.</p>
			<h2 id="_idParaDest-209"><a id="_idTextAnchor210"/>Wrong or useless DocBlocks</h2>
			<p>We already <a id="_idIndexMarker840"/>discussed DocBlocks and what makes them problematic in <a href="B19050_12.xhtml#_idTextAnchor174"><em class="italic">Chapter 12</em></a><em class="italic">, Working in a Team,</em> when we introduced coding guidelines. In short, since DocBlocks are basically comments (yet following a certain structure), they can get outdated or simply go wrong quickly if— for example—the parameters of a function call change and necessary changes were not updated in the DocBlock too. Your IDE might throw warnings, but PHP will not.</p>
			<p>With the introduction of better type hinting in PHP, many DocBlocks can simply be removed. The redundancy is of no benefit and can rather confuse the reader if the actual code diverges from the annotations.</p>
			<h2 id="_idParaDest-210"><a id="_idTextAnchor211"/>TODO comments</h2>
			<p>Comments are not a suitable place to store tasks. You probably know comments such as this:</p>
			<p class="source-code">// TODO refactor once new version of service XY is released</p>
			<p>While some <a id="_idIndexMarker841"/>IDEs can assist you in managing your <strong class="source-inline">TODO</strong> comments, this approach will only work if you are the only one on the project. As soon as you are Working in a Team, using a work management tool such as JIRA, Asana, or even Trello, writing such a comment is simply a way of creating <em class="italic">technical debt</em>, or, in other words, you are offloading the task into some uncertain day in the future. Somebody else will hopefully fix it one day—most of the time, this will not happen, though.</p>
			<p>Instead of a comment, consider creating a task in your work management tool of choice. This way, it is transparent to your colleagues, and it is much easier to plan this work.</p>
			<h2 id="_idParaDest-211"><a id="_idTextAnchor212"/>When commenting is useful</h2>
			<p>After discussing <a id="_idIndexMarker842"/>what should not be commented, are there any use cases left where comments are useful? Indeed, not so many, but there are some occasions where comments still make sense, such as in the following cases:</p>
			<ul>
				<li><strong class="bold">To avoid confusion</strong>: If you can anticipate that other developers might wonder why you chose that implementation, you should add more context by adding a comment.</li>
				<li><strong class="bold">When implementing complex algorithms</strong>: Even if we try to avoid it, we sometimes have to write code that is hard to understand—for example, if we need to implement a certain algorithm or some unknown business logic. In these cases, a brief comment can be a lifesaver.</li>
				<li><strong class="bold">For reference purposes</strong>: If your code implements some logic that is already explained elsewhere—for example, in a wiki or a ticket—you can add a link to the corresponding source to make it easier for others to find more information about it. This should only be an exception and not the rule.</li>
			</ul>
			<p>Please bear in mind that we do not want to be dogmatic. If you feel a comment is needed at <a id="_idIndexMarker843"/>some point, write it. It can still be deleted, probably after discussing the topic with another developer in the code review. </p>
			<h2 id="_idParaDest-212"><a id="_idTextAnchor213"/>Tests as documentation</h2>
			<p>Developers <a id="_idIndexMarker844"/>who write tests often say that these tests also function as documentation. We, too, made the claim in <a href="B19050_10.xhtml#_idTextAnchor128"><em class="italic">Chapter 10</em></a><em class="italic">, Automated Testing</em> when we talked about the benefits of <em class="italic">automated tests</em>.</p>
			<p>If you do not know what the purpose of a class is, you can at least infer its expected behavior from the tests, because this is precisely what tests do: they make assertions that the code will be tested against. By looking at these assertions, you know what the code is supposed to do.</p>
			<p>If the tests fail, you at least know that there is a discrepancy between the assertions and the actual code, and you cannot trust them now. Unless test failures are not generally ignored in your project, you can be sure that someone will fix them soon—or, in other words, the implicit documentation gets updated.</p>
			<p>If all the tests pass, you know that you can trust the class implementation—given the tests are well written and do not just test the implementation of a mock object, as discussed in <a href="B19050_10.xhtml#_idTextAnchor128"><em class="italic">Chapter 10</em></a><em class="italic">, Automated Testing</em>, when we talked about <em class="italic">unit tests</em>. </p>
			<p>Surely, reading and understanding tests are not the easiest form of documentation, but they can <a id="_idIndexMarker845"/>be a reliable <strong class="bold">source of truth</strong> (<strong class="bold">SOT</strong>) if there is no other documentation. They should, however, not be the only type of documentation in your project.</p>
			<h1 id="_idParaDest-213"><a id="_idTextAnchor214"/>Summary</h1>
			<p>Writing clean code is not only knowing how to do it yourself but also about making sure that other developers will follow this path too. To be able to do this, they need to know the rules that apply to the project. </p>
			<p>In this chapter, we discussed how to create documentation that can help you to achieve this goal. We discussed best practices for manually writing documentation, as well as creating informative and at the same time maintainable diagrams. Lastly, we introduced ways to generate documentation from the code and elaborated on the pros and cons of inline documentation.</p>
			<p>Congratulations! You made it to the end of this book. We hope you enjoyed reading it and are now fully motivated to write clean code.</p>
			<p>You will probably not succeed with it right away. Strengthening your coding skills is a process that can be frustrating and sometimes even hard to do when working on a commercial project. Try to be patient, and over time you will get better and better.</p>
			<p>Reading just one book about clean code is surely not enough. Over the course of this book, we were often only able to merely scratch topics on the surface, and we encourage you to dive deeper into the topics that interest you—and into those that you might not consider interesting in the first place. It requires more studies, an open mind, and the willingness to accept feedback from others to grow your skills.</p>
			<p>Yet we are convinced that with this book, we gave you more than a solid starting point for your future journey as a great PHP developer. We would be glad if you think that too.</p>
			<h1 id="_idParaDest-214"><a id="_idTextAnchor215"/>Further reading</h1>
			<p>If you want to learn more about Mermaid.js, we recommend the book <em class="italic">The Official Guide to Mermaid.js</em> by <em class="italic">Knut Sveidqvist</em> and <em class="italic">Ashish Jain</em>, published by Packt in 2021.</p>
		</div>
	</body></html>