- en: Chapter 6. Modules, Models, and Services
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第6章 模块、模型和服务
- en: 'In this chapter we will cover:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖：
- en: Creating a new module
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个新的模块
- en: Using modules as a widget
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将模块作为小部件使用
- en: A Model and a Hydrator
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个模型和一个Hydrator
- en: A basic service
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基本服务
- en: Introduction
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简介
- en: This chapter is all about making the most of our module, models, and services
    and their configuration. As Zend Framework 2 is a modular framework, the modules
    are obviously one of the most important features of it all. We will talk about
    customizing the configuration of the modules and how to go about working with
    models and services as well.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 本章全部关于充分利用我们的模块、模型和服务及其配置。由于 Zend Framework 2 是一个模块化框架，模块显然是其中最重要的功能之一。我们将讨论如何自定义模块的配置以及如何与模型和服务一起工作。
- en: Creating a new module
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建一个新的模块
- en: The core of the Zend Framework 2 library is modular and everything is based
    around a module based system. That's why we will explain this thoroughly in this
    recipe, so that we can use it in its best way possible.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: Zend Framework 2 库的核心是模块化的，一切都是基于模块化系统。这就是为什么我们将在本食谱中详细解释这一点，以便我们可以以最佳方式使用它。
- en: Getting ready
  id: totrans-10
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: We will be using the Zend Framework skeleton application for creating new modules.
    As a reminder, the Zend Framework 2 skeleton application can be found at [https://github.com/zendframework/ZendSkeletonApplication](https://github.com/zendframework/ZendSkeletonApplication).
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用 Zend Framework 骨干应用程序来创建新模块。提醒一下，Zend Framework 2 骨干应用程序可以在 [https://github.com/zendframework/ZendSkeletonApplication](https://github.com/zendframework/ZendSkeletonApplication)
    找到。
- en: How to do it…
  id: totrans-12
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做…
- en: Creating a new module is like starting a new drawing, it is exciting and fun
    to create a new functionality, but there are always rules we need to obey. In
    this recipe we will discuss what the rules are for setting up a new module.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个新的模块就像开始一幅新的画作一样，创建新的功能既令人兴奋又有趣，但总有规则需要我们遵守。在本食谱中，我们将讨论设置新模块的规则。
- en: Creating the Module.php
  id: totrans-14
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建Module.php
- en: We can start off with just a simple class file (that is, `/module/Sample/Module.php`)
    in the right namespace (`Sample`) with nothing in it, which is basically the only
    requirement there is for the module.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以开始于一个简单的类文件（即 `/module/Sample/Module.php`），在正确的命名空间（`Sample`）中没有任何内容，这是模块的唯一要求。
- en: '[PRE0]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'We can add the following method to our `Module` class:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将以下方法添加到我们的`Module`类中：
- en: '[PRE1]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Let's just create a `/module/Sample/config/module.config.php` file now which
    will return an empty array for now, as we don't really have anything to configure
    at the moment.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们创建一个`/module/Sample/config/module.config.php`文件，现在它将返回一个空数组，因为我们目前实际上没有要配置的内容。
- en: '[PRE2]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: To hook up to the bootstrap event, a module just have to have an `onBootstrap`
    method in our `Module.php` file which does all the bootstrapping for us, or we
    can define bootstrap events that are executed when the bootstrap has been called
    (my personal favorite).
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 要连接到引导事件，模块只需在我们的`Module.php`文件中有一个`onBootstrap`方法，它为我们完成所有引导工作，或者我们可以定义在引导被调用时执行的引导事件（我个人最喜欢的）。
- en: 'Let''s see both ways, beginning with the `onBootstrap method`:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看两种方法，从`onBootstrap`方法开始：
- en: '[PRE3]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: As we can see a simple method is enough to create bootstrapping, it bootstraps
    the module as soon as the bootstrap event of the application is being triggered.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，一个简单的方法就足以创建引导，一旦应用程序的引导事件被触发，它就会引导模块。
- en: Attaching to the loadModules.postevent
  id: totrans-25
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 附加到loadModules.postevent
- en: 'The following example makes use of the `/module/Application/Module.php` file:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例使用了 `/module/Application/Module.php` 文件：
- en: '[PRE4]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Implementing the getAutoloaderConfig
  id: totrans-28
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 实现getAutoloaderConfig
- en: 'The following example is part of the `Module.php` `Module` class:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例是`Module.php`中的`Module`类的一部分：
- en: '[PRE5]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Let''s consider the following updated code snippet:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们考虑以下更新的代码片段：
- en: '[PRE6]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'An example of a class map file (file `/module/Application/autoload_classmap.php`)
    is as follows:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 一个类映射文件的示例（文件 `/module/Application/autoload_classmap.php`）如下：
- en: '[PRE7]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Implementing the getControllerConfig, getControllerPluginConfig and getViewHelperConfig
  id: totrans-35
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 实现getControllerConfig、getControllerPluginConfig和getViewHelperConfig
- en: 'Take a look at the following implementation of the `getViewHelperConfig` (in
    the `/module/Application/Module.php` file):'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 看看以下`getViewHelperConfig`的实现（在`/module/Application/Module.php`文件中）：
- en: '[PRE8]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: How it works…
  id: totrans-38
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: Modules are instantiated by the framework once they are introduced in the `application.config.php`
    file. Adding a module's name the file will make the framework look for the `Module.php`
    file in a directory bearing the name of the module. The `Module.php` file has
    a selection of methods which will then be called by the framework at certain times,
    such as loading the configuration or running the module's bootstrap.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 模块在`application.config.php`文件中引入后，由框架实例化。将模块的名称添加到文件中，框架将寻找名为模块的目录中的`Module.php`文件。`Module.php`文件包含一系列方法，这些方法将在框架在特定时间调用，例如加载配置或运行模块的引导。
- en: For our example we will create a module called `Sample`, which will have a simple
    controller and an action that outputs some text.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的示例中，我们将创建一个名为`Sample`的模块，它将有一个简单的控制器和一个输出一些文本的操作。
- en: 'To make sure the `ModuleManager` of Zend Framework 2 picks up our new module,
    we need to understand how the `ModuleManager` works. What the `ModuleManager`
    does is fulfill three operations:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 为了确保Zend Framework 2的`ModuleManager`能够识别我们的新模块，我们需要了解`ModuleManager`是如何工作的。`ModuleManager`执行的操作有三个：
- en: It collects the enabled modules
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它收集已启用的模块
- en: It initializes the module, if necessary
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果需要，它初始化模块
- en: It collects the configuration from all the modules
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它从所有模块收集配置
- en: Although we can automatically create a whole new module with the `ZFTool`, it
    is still recommended that we know how to make and structure a module without it.
    We will now begin to create a module that makes sure the `ModuleManager` is happy
    with it.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我们可以使用`ZFTool`自动创建一个全新的模块，但我们仍然建议我们了解如何在没有它的情况下创建和构建模块。现在，我们将开始创建一个确保`ModuleManager`满意的模块。
- en: Creating a new module directory
  id: totrans-46
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建一个新的模块目录
- en: When creating a new module, we will follow the recommended way as much as possible,
    so that we get the clearest view on how it all works. First things first, create
    a new directory in the module directory with the name `Sample`. This directory
    will be our main directory when it comes to code relating to the Sample module's
    namespace, that way we will have every related piece of code enclosed in this
    directory.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 当创建一个新模块时，我们将尽可能地遵循推荐的方式，以便我们能够清楚地了解它是如何工作的。首先，在模块目录中创建一个名为`Sample`的新目录。这个目录将成为我们与Sample模块命名空间相关的代码的主要目录，这样我们就可以将所有相关的代码都包含在这个目录中。
- en: Creating the Module.php
  id: totrans-48
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建`Module.php`
- en: The most important file of every module is the `Module.php` file, which is not
    only required, but also feeds the framework with important information about things
    such as; where to find the code, and what the configuration is.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 每个模块最重要的文件是`Module.php`文件，它不仅是必需的，而且还向框架提供了有关诸如代码位置和配置等重要信息的重要信息。
- en: Although it won't actually initialize anything in the module, it is the basic
    requirement to have a module. Note that because of the lack of code inside `Module.php`,
    it is impossible for our application to reach any of the code inside the module
    as well.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然它实际上不会在模块中初始化任何内容，但拥有一个模块的基本要求。请注意，由于`Module.php`中缺少代码，我们的应用程序无法访问模块内部的任何代码。
- en: The first thing we want to do is to make sure that the framework will read our
    configuration for our module. This can be done by defining a `getConfig` method
    in our `Module.php`. which requires an array as a return value.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先想确保框架能够读取我们模块的配置。这可以通过在`Module.php`中定义一个`getConfig`方法来实现，该方法需要一个数组作为返回值。
- en: Because laziness is a skill, we will simply return the complete `module.config.php`
    file to the `ModuleManager`. We don't have to do this, we can also just return
    an array with the configuration in as well, but for the purpose of maintainability
    it is best to keep the actual configuration separate from the code. This way we
    don't have to edit the code to edit the configuration.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 因为懒惰也是一种技能，我们只需将完整的`module.config.php`文件返回给`ModuleManager`。我们不必这样做，我们也可以返回一个包含配置的数组，但为了便于维护，最好将实际的配置与代码分开。这样我们就不必编辑代码来编辑配置。
- en: Now we know that our `ModuleManager` will load our configuration, it is time
    to go over the bootstrapping of the module, which is sometimes necessary to initialize
    more after the configuration has loaded. This can be done either by using the
    `onBootstrap` method in the `Module.php` or attach to the `ModuleManager` events.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们知道我们的`ModuleManager`将加载我们的配置，是时候回顾模块的引导过程了，这在配置加载后有时是必要的。这可以通过在`Module.php`中使用`onBootstrap`方法或附加到`ModuleManager`事件来实现。
- en: Optionally act on ModuleManager events
  id: totrans-54
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 可选地处理 ModuleManager 事件
- en: 'Another way of making sure additional pieces of code will be executed is by
    attaching them to one of the four other strategic events, namely: `loadModules`,
    `loadModules.resolve`, `loadModule`, and `loadModules.post`.'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 确保额外的代码片段将被执行的另一种方式是将它们附加到四个其他战略事件之一，即：`loadModules`、`loadModules.resolve`、`loadModule`
    和 `loadModules.post`。
- en: To explain them all a bit better, let's go through all of them briefly.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更好地解释它们，让我们简要地了解一下所有这些。
- en: Understanding the loadModules event
  id: totrans-57
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 理解 loadModules 事件
- en: The `loadModules` event will be triggered when the framework is loading the
    modules, so for initializing a module, this event is pretty much useless as it
    will never be called in the `Module.php` file (the event has already passed at
    that point).
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 当框架加载模块时，将触发 `loadModules` 事件，因此对于初始化模块，此事件几乎毫无用处，因为它永远不会在 `Module.php` 文件中调用（此时事件已经过去）。
- en: At this point the framework is still loading the modules up and nothing has
    happened for our module yet. That is why this event is primarily used on the internal
    side of the framework and not on our development side. However, as this event
    is active throughout the whole process of loading the modules, it also does some
    extra things when all the other events have been done.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，框架仍在加载模块，我们的模块还没有发生任何事情。这就是为什么这个事件主要在框架的内部使用，而不是在我们的开发侧使用。然而，由于这个事件在整个加载模块的过程中都是活跃的，当所有其他事件都完成后，它也会做一些额外的事情。
- en: 'This event triggers the following functionality by default:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 此事件默认触发以下功能：
- en: '`Zend\Loader\ModuleAutoloader::register`: This makes sure that the `Module`
    class can be found and initiated (It doesn''t initiate it just yet, just checks).'
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Zend\Loader\ModuleAutoloader::register`：确保 `Module` 类可以被找到并启动（它还没有启动，只是检查）。'
- en: '`Zend\ModuleManager\Listener\ConfigListener` `::onLoadModulesPre` `::onLoadModulesPost`:
    This functionality merges the configuration files with the local configuration
    files found by the defined `glob()` in the application configuration when all
    the modules have been loaded, but only if the configuration is not cached internally
    (which is not the case by default).'
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Zend\ModuleManager\Listener\ConfigListener` `::onLoadModulesPre` `::onLoadModulesPost`：当所有模块都已加载时，此功能会将配置文件与通过应用程序配置中定义的
    `glob()` 找到的本地配置文件合并，但仅当配置未内部缓存时（默认情况下不是这种情况）。'
- en: '`Zend\ModuleManager\Listener\LocatorRegistration::onLoadModulesPost`: This
    attaches the service of the modules to the `ServiceManager`, if the `Module` class
    implemented the `LocatorRegisteredInterface` interface, which will immediately
    add the `Module` class to the DI. This is done when all the modules are loaded
    up.'
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Zend\ModuleManager\Listener\LocatorRegistration::onLoadModulesPost`：如果 `Module`
    类实现了 `LocatorRegisteredInterface` 接口，则此操作会将模块的服务附加到 `ServiceManager`，并将 `Module`
    类立即添加到 DI 中。这是在所有模块都已加载时完成的。'
- en: The loadModules.resolve event
  id: totrans-64
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: loadModules.resolve 事件
- en: Another internal event and not an event a module can make use of is this event,
    which is triggered for each module that is defined in our `application.config.php`.
    This event will actually try to find the `Module` class in the `Module.php` file
    of our module, so although not useful (yet) to our module, it is coming close!
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个内部事件，模块无法使用的事件是此事件，它为我们在 `application.config.php` 中定义的每个模块触发。实际上，此事件将尝试在我们的模块的
    `Module.php` 文件中找到 `Module` 类，所以虽然对我们模块（目前）没有用，但它已经接近了！
- en: 'This event triggers the following functionality by default:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 此事件默认触发以下功能：
- en: '`Zend\ModuleManager\Listener\ModuleResolverListener::__invoke`: This initiates
    the `Module` class'
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Zend\ModuleManager\Listener\ModuleResolverListener::__invoke`：启动 `Module`
    类。'
- en: The loadModule event
  id: totrans-68
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: loadModule 事件
- en: Now the object (of the `Module` class) has been created; the `loadModule` event
    will pass it along the other listeners.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，`Module` 类的对象已经创建；`loadModule` 事件将通过其他监听器传递它。
- en: 'This event triggers the following functionality by default:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 此事件默认触发以下功能：
- en: '`Zend\ModuleManager\Listener\ConfigListener::onLoadModule`: This merges the
    configuration by getting all the getConfig() of the Module classes.'
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Zend\ModuleManager\Listener\ConfigListener::onLoadModule`：通过获取所有 Module 类的
    getConfig() 来合并配置。'
- en: '`Zend\ModuleManager\Listener\AutoloaderListener::__invoke`: This calls the
    `getAutoloaderConfig` in the `Module` class if available, so that we can get the
    autoloading going for our new module'
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Zend\ModuleManager\Listener\AutoloaderListener::__invoke`：如果可用，此操作会在 `Module`
    类中调用 `getAutoloaderConfig`，以便我们可以为新模块启动自动加载。'
- en: '`Zend\ModuleManager\Listener\InitTrigger::__invoke`: This calls the init method
    in the `Module` class if available.'
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Zend\ModuleManager\Listener\InitTrigger::__invoke`：如果可用，此方法会调用`Module`类中的init方法。'
- en: '`Zend\ModuleManager\Listener\OnBootstrapListener::__invoke`: This attaches
    the `onBootstrap` method of the `Module` class to the bootstrap event of the application,
    so it will be run at that time.'
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Zend\ModuleManager\Listener\OnBootstrapListener::__invoke`：这会将`Module`类的`onBootstrap`方法附加到应用程序的引导事件，因此它将在那时运行。'
- en: '`Zend\ModuleManager\Listener\ServiceListener::onLoadModule`: This calls the
    following methods in the `Module` class if they exist (we will discuss these methods
    more extensively a bit further on in this recipe):'
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Zend\ModuleManager\Listener\ServiceListener::onLoadModule`：如果存在，此方法会调用`Module`类中的以下方法（我们将在本食谱的稍后部分更详细地讨论这些方法）：'
- en: '`getServiceConfig`: This gets the `ServiceManager` configuration from the Module
    class.'
  id: totrans-76
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`getServiceConfig`：从模块类获取`ServiceManager`配置。'
- en: '`getControllerConfig`: This gets the controller configuration from the `Module`
    class.'
  id: totrans-77
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`getControllerConfig`：从`Module`类获取控制器配置。'
- en: '`getControllerPluginConfig`: This gets the controller plugin configuration
    from the `Module` class.'
  id: totrans-78
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`getControllerPluginConfig`：从`Module`类获取控制器插件配置。'
- en: '`getViewHelperConfig`: This gets the view helper configuration from the `Module`
    class.'
  id: totrans-79
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`getViewHelperConfig`：从`Module`类获取视图助手配置。'
- en: 'The flow chart showing a simplified version of the module loading is as follows:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 显示模块加载简化版本的流程图如下：
- en: '![The loadModule event](img/4841OS_06_01.jpg)'
  id: totrans-81
  prefs: []
  type: TYPE_IMG
  zh: '![模块加载事件](img/4841OS_06_01.jpg)'
- en: The loadModules.post
  id: totrans-82
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: loadModules.post
- en: The `loadModules.post` event is triggered when the modules have successfully
    been loaded and the last bits are needed to be done to complete it all.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 当模块成功加载并且需要完成最后一些工作以完成整个过程时，会触发`loadModules.post`事件。
- en: This event triggers the `Zend\ModuleManager\Listener\ServiceListener::onLoadModulesPost`
    functionality by default and instructs the `ServiceManager` to create more services
    if needed.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 此事件默认触发`Zend\ModuleManager\Listener\ServiceListener::onLoadModulesPost`功能，并指示`ServiceManager`根据需要创建更多服务。
- en: Attaching to the loadModules.post event
  id: totrans-85
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 附加到loadModules.post事件
- en: The `loadModules.post` event is the first event we can attach a handler to in
    our application, as events before this one can only be used by the internal listeners
    of Zend Framework 2\. That means there is not a good way of hooking up to those
    events without making extensions to the framework ourselves.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '`loadModules.post`事件是我们可以在应用程序中附加处理程序的第一个事件，因为在此事件之前的事件只能由Zend Framework 2的内部监听器使用。这意味着没有很好的方法可以挂钩到这些事件，而不需要对我们自己的框架进行扩展。'
- en: However, the `loadModules.post` event can still be useful, for example, to make
    sure that our modules are loaded correctly, or for something else modules config
    related. The best way of attaching ourselves to this event is by doing that as
    high up as we can get with the `EventManager`. In this case that would be in the
    `init()` method of the module, as that is being called during the `loadModule`
    event, and is the first one to contain an `EventManager`.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，`loadModules.post`事件仍然可能很有用，例如，确保我们的模块被正确加载，或者用于其他与模块配置相关的事情。将我们自身附加到这个事件的最佳方式是通过尽可能高地使用`EventManager`。在这种情况下，这将是模块的`init()`方法，因为该方法在`loadModule`事件期间被调用，并且是第一个包含`EventManager`的方法。
- en: More specific non configuration file Module configuration
  id: totrans-88
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 更具体的非配置文件模块配置
- en: Sometimes we choose not to use the `module.config.php` file all the time and
    we require a more dynamic instantiation, for example, of services or configurations.
    Luckily Zend Framework 2 fully supports any dynamic configuration functionality.
    As discussed before, there are five extra methods we can add to our `Module` class,
    which are picked up during the module instantiation, namely the `getAutoloaderConfig`,
    `getServiceConfig`, `getControllerConfig`, `getControllerPluginConfig`, and the
    `getViewHelperConfiguration`.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 有时我们选择不始终使用`module.config.php`文件，并需要更动态的实例化，例如，服务或配置。幸运的是，Zend Framework 2完全支持任何动态配置功能。如前所述，我们可以向我们的`Module`类添加五个额外的方法，这些方法在模块实例化期间被拾取，分别是`getAutoloaderConfig`、`getServiceConfig`、`getControllerConfig`、`getControllerPluginConfig`和`getViewHelperConfiguration`。
- en: The getAutoloaderConfig method
  id: totrans-90
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: getAutoloaderConfig方法
- en: The `getAutoloaderConfig` method will load in the autoloader configuration for
    our module and expects an array that is compatible with the `AutoloaderFactory`.
    There are generally two accepted ways of autoloading in Zend Framework 2\. The
    first one is to use the `StandardAutoloader`, which requires a namespace to load
    and a directory to recur in to. The second one is to use a `ClassMapAutoloader`,
    which is basically a file with an array where every full domain and class name
    is mentioned with a reference to a specific file.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '`getAutoloaderConfig`方法将加载我们模块的自动加载器配置，并期望一个与`AutoloaderFactory`兼容的数组。在Zend
    Framework 2中，通常有两种接受的方式来自动加载。第一种是使用`StandardAutoloader`，它需要一个要加载的命名空间和一个要递归的目录。第二种是使用`ClassMapAutoloader`，它基本上是一个包含每个完整域名和类名及其对特定文件的引用的数组的文件。'
- en: Both of them are displayed in the examples, so please take a look at them to
    see the differences.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 它们在示例中都显示出来了，所以请查看它们以了解差异。
- en: We use the `StandardAutoloader` in the first example because we just want our
    framework to load all the classes in the namespace `__NAMESPACE__` (which is `Sample`
    for our module) through the directory structure in the `[current directory]/src/Sample`
    directory. This means that a class that is fully called in `Sample\Model\Test`,
    will be searched in `/src/Sample/Model/Test.php`. Although this is very handy
    in a development environment, it isn't handy in a production environment because
    a large application will put a lot of strain on searching for the class names
    we need. In that case we can use this `StandardAutoloader`, but in addition (with
    a higher priority) we will also be using a `ClassMapAutoloader` that loads in
    a static file with all the class names mapped to a specific directory.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一个例子中，我们使用`StandardAutoloader`是因为我们只想让我们的框架通过`[当前目录]/src/Sample`目录中的目录结构加载命名空间`__NAMESPACE__`（对于我们的模块来说是`Sample`）中的所有类。这意味着完全在`Sample\Model\Test`中调用的类将在`/src/Sample/Model/Test.php`中搜索。虽然这在开发环境中非常方便，但在生产环境中并不方便，因为大型应用程序会对搜索我们需要的类名造成很大压力。在这种情况下，我们可以使用这个`StandardAutoloader`，但除此之外（具有更高的优先级），我们还将使用一个`ClassMapAutoloader`，它加载一个静态文件，其中包含所有类名映射到特定目录。
- en: This tells PHP that when we search for the class `Sample\Model\Test`, it can
    be found in `/src/Sample/Model/Test.php` (or wherever really, as we point the
    PHP directly towards our file anyway). Both of the autoloaders are PSR-0, where
    PSR stands for PHP Standards Recommendation compliant.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 这告诉PHP，当我们搜索类`Sample\Model\Test`时，它可以在`/src/Sample/Model/Test.php`（或者实际上任何地方，因为我们直接将PHP指向我们的文件）中找到。这两个自动加载器都是PSR-0，其中PSR代表PHP标准建议的兼容性。
- en: In the second example we can see we prioritized our `autoload_classmap.php`
    file over our `StandardAutoloader`, which means that it will look first in our
    class map file before trying to find it on its own.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 在第二个例子中，我们可以看到我们优先考虑了我们的`autoload_classmap.php`文件，而不是`StandardAutoloader`，这意味着它将首先在我们的类映射文件中查找，然后再尝试自己查找。
- en: To make the framework use the `getAutoloaderConfig` method, we must make sure
    our `Module` class implements the `Zend\ModuleManager\Feature\AutoloaderProviderInterface`
    class as well as it consists of the single public method `getAutoloaderConfig()`,
    otherwise it will not try to execute it. Remember that simply implementing the
    method is not enough to make it fire as it specifically looks if we are implementing
    the interface.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 要使框架使用`getAutoloaderConfig`方法，我们必须确保我们的`Module`类实现了`Zend\ModuleManager\Feature\AutoloaderProviderInterface`类，并且它包含单个公共方法`getAutoloaderConfig()`，否则它将不会尝试执行它。记住，仅仅实现该方法是不够的，因为它会具体检查我们是否实现了接口。
- en: The getControllerConfig, getControllerPluginConfig, and getViewHelperConfig
    methods
  id: totrans-97
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '`getControllerConfig`、`getControllerPluginConfig`和`getViewHelperConfig`方法'
- en: Instead of loading the controller configuration through the `module.config.php`
    or as an override, we can also do it through the `get***Config` method. We can
    create the method the same way as the `getServiceConfig` method, as the return
    object can either be of the instance `Zend\ServiceManager\Config` or simply an
    array with the configuration like in the `module.config.php`.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过`get***Config`方法，而不是通过`module.config.php`或作为覆盖来加载控制器配置。我们可以像`getServiceConfig`方法一样创建该方法，因为返回的对象可以是`Zend\ServiceManager\Config`的实例，或者是一个包含配置的简单数组，就像在`module.config.php`中一样。
- en: 'If we want to use these methods, we should not forget to implement our class
    with the respective interfaces:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想使用这些方法，我们不应该忘记用相应的接口实现我们的类：
- en: '`For the getControllerConfig method we need to implement the Zend\ModuleManager\Feature\ControllerProviderInterface
    interface.`'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '`对于getControllerConfig方法，我们需要实现Zend\ModuleManager\Feature\ControllerProviderInterface接口。`'
- en: '`For the getControllerPluginConfig method we need to implement the Zend\ModuleManager\Feature\ControllerPluginProviderInterface
    interface.`'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '`对于getControllerPluginConfig方法，我们需要实现Zend\ModuleManager\Feature\ControllerPluginProviderInterface接口。`'
- en: '`And lastly for the getViewHelperConfig method we need to implement the Zend\ModuleManager\Feature\ViewHelperProviderInterface
    interface.`'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '`最后，对于getViewHelperConfig方法，我们需要实现Zend\ModuleManager\Feature\ViewHelperProviderInterface接口。`'
- en: Using modules as a widget
  id: totrans-103
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将模块作为小部件使用
- en: Widgetizing is a great method to use modules on different places in our applications.
    That's why this recipe will explain everything we need to know about doing this
    in the best way possible.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 将模块作为小部件使用是一个很好的方法，可以在我们应用程序的不同位置使用模块。这就是为什么这个配方将解释我们如何以最佳方式完成这项工作。
- en: Getting ready
  id: totrans-105
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: A working Zend Framework 2 skeleton application is needed to make full use of
    this recipe.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 需要一个可工作的Zend Framework 2骨架应用程序才能充分利用这个配方。
- en: How to do it…
  id: totrans-107
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点…
- en: Widgets, they even sound great! We will explain in this recipe what they do
    and how they can be used.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 小部件，听起来就很好！我们将在这个配方中解释它们的作用以及如何使用它们。
- en: Creating the Comment/Controller/Index
  id: totrans-109
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建Comment/Controller/Index
- en: 'We will create a small controller that will return some example comments, which
    are static and hardcoded for example only. First we should make sure we have a
    `Comment` module, so we create the following directories and files:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将创建一个小控制器，它将返回一些示例评论，这些评论是静态的，仅用于示例。首先，我们应该确保我们有一个`Comment`模块，因此我们创建以下目录和文件：
- en: '[PRE9]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Once we have the structure in place, we put the simplest code in the `/module/Comment/Module.php`
    as possible to initialize the module, which is shown as follows:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们建立了结构，我们就在`/module/Comment/Module.php`中尽可能简单地放置代码以初始化模块，如下所示：
- en: '[PRE10]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'As we can see this is the most basic `Module` class because we don''t need
    it more advanced than this. Now let''s quickly create our `module.config.phpconfiguration`
    file in the `/module/Comment/config` directory:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，这是一个最基本的`Module`类，因为我们不需要比这更高级的。现在让我们快速在`/module/Comment/config`目录中创建我们的`module.config.php`配置文件：
- en: '[PRE11]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Now that we have set up a quick configuration with a route that responds to
    the `/`comment and maps to `Comment\Controller\IndexController::indexAction`,
    we can continue with the actual controller (present in the file `/module/Comment/src/Comment/Controller/IndexController.php`):'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经使用一个响应`/`路径并映射到`Comment\Controller\IndexController::indexAction`的快速配置设置好了，我们可以继续处理实际的控制器（位于文件`/module/Comment/src/Comment/Controller/IndexController.php`）：
- en: '[PRE12]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'After creating our controller, the only thing we still need to create is the
    view script (found in the file `/module/Comment/view/comment/index/index.phtml`)
    to actually output the data in an HTML table:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建我们的控制器之后，我们还需要创建的是视图脚本（位于文件`/module/Comment/view/comment/index/index.phtml`），以便实际以HTML表格的形式输出数据：
- en: '[PRE13]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Now that we have our module completely set up, we can go forth and display the
    comments in widget form.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经完全设置了我们的模块，我们可以继续并以小部件的形式显示评论。
- en: Using a view helper to display the comments statically
  id: totrans-121
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用视图助手来静态显示评论
- en: 'First we want to create the view helper itself, let''s do this in the `Comment`
    module (the file is `/module/Comment/src/Comment/View/Helper/Comments.php`) as
    the data comes from there anyway:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们想要创建视图助手本身，让我们在`Comment`模块（文件是`/module/Comment/src/Comment/View/Helper/Comments.php`）中这样做，因为数据无论如何都是从那里来的：
- en: '[PRE14]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Now all we need to do is add this view helper to our module configuration (the
    file is `/module/Comment/config/module.config.php`) before we are able to use
    it in our views:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们需要做的只是在我们能够将其用于视图之前，将这个视图助手添加到我们的模块配置（文件是`/module/Comment/config/module.config.php`）中：
- en: '[PRE15]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Obviously we omitted the rest of the configuration here because we didn''t
    want to repeat ourselves. All that is left now is to actually use the new view
    helper in the code. We can do that to put the following code line in our view
    script:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，我们在这里省略了其余的配置，因为我们不想重复自己。现在剩下的就是实际上在代码中使用新的视图助手。我们可以在视图脚本中添加以下代码行：
- en: '[PRE16]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Using the forward to render the comments statically
  id: totrans-128
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用转发来静态渲染评论
- en: 'Let''s take a look at a code snippet of the action of a `forward()` in our
    `CommentController` (the file is `/module/Application/src/Application/Controller/CommentController.php`):'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看`CommentController`（文件是`/module/Application/src/Application/Controller/CommentController.php`）中`forward()`操作的代码片段：
- en: '[PRE17]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'This gets the dispatched state of a action in a specific controller (our `Comment\Controller\Index::indexAction`)
    and returns it to us as `$comments`, which is a `ViewModel` instance. We add that
    as a child to our current `ViewModel` instance and then we can simply output it
    in the view script with the following code snippet:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 这获取了特定控制器（我们的 `Comment\Controller\Index::indexAction`）中动作的已分发状态，并将其作为 `$comments`
    返回给我们，这是一个 `ViewModel` 实例。我们将它作为子实例添加到当前的 `ViewModel` 实例中，然后我们可以在视图脚本中使用以下代码片段简单地输出它：
- en: '[PRE18]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: This is the same as outputting a normal variable, and although this gives the
    feeling of a clean solution, the `forward()` method is known to be horrible under
    stress.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 这与输出一个正常变量相同，尽管这给人一种干净解决方案的感觉，但 `forward()` 方法在压力下是出了名的糟糕。
- en: Getting the comments through AJAX
  id: totrans-134
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 通过 AJAX 获取评论
- en: 'Let''s see what our view script looks like with JavaScript:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看我们的视图脚本在 JavaScript 中的样子：
- en: '[PRE19]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: How it works…
  id: totrans-137
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: 'This is the scenario: We have a page that contains a little story on which
    users should be able to comment. The comment section however is used at several
    other locations in the code and should therefore be reusable. There is one proviso
    though, the comment section doesn''t change in layout, it will always need to
    be displayed in the same way.'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 这是这种情况：我们有一个页面，其中包含一个用户应该能够评论的小故事。然而，评论部分在代码的几个其他位置也被使用，因此应该是可重用的。但是有一个前提，评论部分在布局上不会改变，它总是需要以相同的方式显示。
- en: What we are going to do is create three different but valid implementations
    of a module that is being used as a widget. The first two will give a more static
    feel to it all, while the third one will use JavaScript (jQuery to be exact) to
    load in the comments. We will also discuss a theoretic fourth solution that should
    be considered.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要创建三个不同但有效的模块实现，该模块被用作小部件。前两个将给整个系统带来更多的静态感，而第三个将使用 JavaScript（确切地说，是 jQuery）来加载评论。我们还将讨论一个理论上的第四种解决方案，这应该被考虑。
- en: But first of all we will set up a small environment, which we will use in the
    examples of retrieving the comments.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 但首先，我们将设置一个小环境，我们将在获取评论的示例中使用它。
- en: We will set up the `Application/Controller/Comment` controller, which will have
    the `helperAction`, `forwardAction` and `ajaxAction` method defined. Then we will
    use this controller and actions to display the comments in the `Comment/Controller/Index`
    controller and `indexAction` method.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将设置 `Application/Controller/Comment` 控制器，该控制器将定义 `helperAction`、`forwardAction`
    和 `ajaxAction` 方法。然后我们将使用这个控制器和动作在 `Comment/Controller/Index` 控制器和 `indexAction`
    方法中显示评论。
- en: Using a view helper to display the comments statically
  id: totrans-142
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用视图助手静态显示评论
- en: The best option to display the comments in a statically way would be to create
    a view helper specific for this widget. What we are going to do is create a small
    view helper that will render our comments and return them to our view. This way
    we can use it everywhere in our view without using a lot of hassle like the `forward()`
    or the AJAX methods do.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 在静态方式显示评论的最佳选项是创建一个特定于此小部件的视图助手。我们将要做的是创建一个小视图助手，它将渲染我们的评论并将它们返回到我们的视图。这样我们就可以在我们的视图中到处使用它，而无需像
    `forward()` 或 AJAX 方法那样造成很多麻烦。
- en: As we can see in the example we instantiate our controller and manually retrieve
    the output of the action, and after that manually render it and return it to the
    view. It is not always this easy to do it like this, but it comes close to reality.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在示例中所见，我们实例化控制器并手动检索动作的输出，然后手动渲染并返回给视图。这样做并不总是这么简单，但它接近现实。
- en: Using the forward() method to render the comments statically
  id: totrans-145
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用 forward() 方法静态渲染评论
- en: A not so great idea but worth mentioning also is getting the comments through
    the `forward()` method, which is brittle, but at least it doesn't go through the
    whole MVC initialization like the AJAX functionality does.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个不太好的想法但也值得提及的是，通过 `forward()` 方法获取评论，这种方法虽然脆弱，但至少它不像 AJAX 功能那样需要经过整个 MVC
    初始化。
- en: Getting the comments through AJAX
  id: totrans-147
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 通过 AJAX 获取评论
- en: Last but not least, a more technical non-PHP solution is also at hand for when
    we want to be a little bit more creative, or when our environment just calls for
    an asynchronous AJAX implementation. The idea of this method is that we simply
    retrieve our comments from the URL through JavaScript, or to be specific the jQuery
    library.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 最后但同样重要的是，当我们想要更加创新，或者我们的环境需要异步 AJAX 实现时，我们也有一个更技术性的非 PHP 解决方案。这种方法的想法是，我们简单地通过
    JavaScript（具体来说是 jQuery 库）从 URL 中检索我们的评论。
- en: This only requires us to input a bit of client-side JavaScript in the view script
    to make it work, which is nice because we don't have to fiddle around much in
    the code. It has one big con though, and that is that we will go through the whole
    MVC process again to receive the comments from the database. On the other hand
    it will speed up the response time from our main action as it doesn't have to
    load the comments statically. Another con would be that the user visiting the
    website needs a JavaScript enabled browser to see the comments, but we assume
    everyone has such browser nowadays.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 这只需要我们在视图脚本中输入一点客户端 JavaScript 代码来使其工作，这很好，因为我们不需要在代码中做太多调整。然而，它有一个很大的缺点，那就是我们又将经历整个
    MVC 流程来从数据库接收评论。另一方面，它将加快我们主要动作的响应时间，因为它不需要静态地加载评论。另一个缺点是，访问网站的访客需要启用 JavaScript
    的浏览器才能看到评论，但我们假设现在每个人都有这样的浏览器。
- en: As we can see from the example this is a pretty easy method of retrieving the
    comments as well, but it has afore mentioned cons attached to it. However, sometimes
    this might be the best option performance wise to get the data from somewhere
    else. It is all due to the architecture of the application.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们从示例中看到的那样，这是一个检索评论相当简单的方法，但它附带有之前提到的缺点。然而，有时从其他地方获取数据在性能上可能是最佳选择。这完全归因于应用程序的架构。
- en: About Widgetizing
  id: totrans-151
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 关于小部件化
- en: Widgetizing a module is not something that is absolutely native to the framework,
    but as we can see in the paragraphs above, it is something we can easily achieve
    by using (not abusing) the framework as much as we can.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 将模块小部件化并不是框架绝对原生支持的功能，但正如上文所述，我们可以通过尽可能多地使用（而不是滥用）框架来轻松实现这一点。
- en: Especially, instantiating controllers and executing actions our self is a great
    method of dealing with data from other sections of the application. We want to
    be wary, however, that modules in itself should be independent (or at least as
    much as possible) from each other and we shouldn't rely too much on their existence.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 尤其是自行实例化控制器和执行动作是处理应用程序其他部分数据的一种极好方法。然而，我们必须小心，模块本身应该是独立的（或者至少尽可能独立），我们不应该过分依赖它们的存在。
- en: But to be fair, a perfect situation is never to be found, and we just need to
    do some concessions some times. In our case this might be relying on modules that
    might not be there.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 但公平地说，完美的状况永远不会出现，我们有时只需要做一些妥协。在我们的情况下，这可能是依赖于可能不存在的模块。
- en: A Model and a Hydrator
  id: totrans-155
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 模型和水化器
- en: Models are a great way of providing functionality to our application, and they
    keep out the Controllers, nice and clean, from any critical logic. A hydrator
    is also great to transport properties and values from one model to another, that's
    why we will go into this a bit further to make optimal use of it.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 模型是向我们的应用程序提供功能的一种极好方式，并且它们将控制器保持得非常干净，远离任何关键逻辑。水化器也非常适合在模型之间传输属性和值，这就是为什么我们要进一步探讨它，以便充分利用它。
- en: Getting ready
  id: totrans-157
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: For this recipe a working Zend Framework 2 skeleton application is necessary
    to make full use of the examples.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 为了充分利用这个菜谱中的示例，需要一个可工作的 Zend Framework 2 框架骨架应用程序。
- en: How to do it…
  id: totrans-159
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作…
- en: In this recipe we will set up a model and a method for hydrating data to and
    from our model, so that we have easy access of our data.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将设置一个模型和一种将数据从模型中填充到模型以及从模型中提取数据的方法，以便我们能够轻松访问我们的数据。
- en: Accessing the Model
  id: totrans-161
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 访问模型
- en: 'We can access the model anywhere in the application by simply adding a use
    statement at the top of our document:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过在文档顶部简单地添加一个 use 语句在任何地方访问模型：
- en: '[PRE20]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Or by using the fully qualified name of the class including the namespace,
    shown as follows:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 或者通过使用包括命名空间在内的类的完全限定名称，如下所示：
- en: '[PRE21]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'If there is already a class `SampleModel` used, but from a different namespace,
    or if we just want to give it a more identifiable name, we can also use an alias
    (this is not model specific however, and we can use it in any namespaced class),
    as shown as follows:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 如果已经存在一个名为 `SampleModel` 的类，但来自不同的命名空间，或者如果我们只想给它一个更易识别的名字，我们也可以使用别名（但这不是模型特有的，我们可以在任何命名空间类中使用它），如下所示：
- en: '[PRE22]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Creating a Hydrator
  id: totrans-168
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建水化器
- en: 'First thing now is to set up an incredibly simple model (the file is `/module/Application/src/Application/Model/SampleModel.php`),
    which we will use to hydrate, as shown as follows:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 现在的首要任务是设置一个非常简单的模型（文件位于 `/module/Application/src/Application/Model/SampleModel.php`），我们将使用它来进行数据填充，如下所示：
- en: '[PRE23]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'This incredibly basic model has nothing more than a couple of properties with
    the getters and setters for them, simple, but it will work for what we try to
    achieve next. What we are going to do in the following example is create a `Hydrator`
    for our imaginary database table and then we will hydrate our `SampleModel` (the
    file is `/module/Application/src/Application/Model/Hydrator/SampleModelHydrator.php`)
    with the data from the table:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 这个极其基础的模型除了几个属性及其getter和setter之外，没有其他东西，简单，但它将适用于我们试图实现的目标。在接下来的示例中，我们将为我们的虚拟数据库表创建一个`Hydrator`，然后我们将使用表中的数据水化我们的`SampleModel`（文件位于`/module/Application/src/Application/Model/Hydrator/SampleModelHydrator.php`）：
- en: '[PRE24]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'We have now set up the very basic class of our hydrator, and the methods implemented
    are now only the definitions that we need to have because of the `AbstractHydrator`
    class. The next thing we want to do is to get some code in there to actually make
    it all work. The first thing we will implement further is the `hydrate()` method,
    which will make our `SampleModel` hydrated:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经设置了hydrator的基本类，现在实现的方法只是由于`AbstractHydrator`类我们需要拥有的定义。接下来我们想要做的是在其中有代码来真正使其工作。我们将进一步实现的是`hydrate()`方法，这将使我们的`SampleModel`变得可水化：
- en: '[PRE25]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Now let''s use the `extract()` method, which extracts values from our `SampleModel`
    and puts them back in an array which is also formatted in the way we used to hydrate
    the object in the first place:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们使用`extract()`方法，它从我们的`SampleModel`中提取值，并将它们放回一个数组中，这个数组也是我们最初用于水化对象的方式：
- en: '[PRE26]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: And that is how we extract values from the hydrated object again.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 那就是如何再次从水化对象中提取值。
- en: Creating a Hydrator strategy
  id: totrans-178
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建水化策略
- en: 'If we change the setter of the primary property in the `SampleModel` (the file
    is `/module/Application/src/Application/Model/SampleModel.php`) a bit so that
    it reflects in the following code snippet:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们稍微改变`SampleModel`（文件位于`/module/Application/src/Application/Model/SampleModel.php`）中的主属性设置器，使其反映在以下代码片段中：
- en: '[PRE27]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Let''s begin by creating our strategy first (the file is `/module/Application/src/Application/Model/Hydrator/Strategy/SampleHydratorStrategy.php`):'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先创建我们的策略（文件位于`/module/Application/src/Application/Model/Hydrator/Strategy/SampleHydratorStrategy.php`）：
- en: '[PRE28]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Now we need to change two things in our `Hydrator` class that we created, so
    that it also supports a hydrator strategy (the file is `/module/Application/src/Application/Model/Hydrator/SampleModelHydrator.php`):'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们需要在我们的`Hydrator`类中更改两个东西，以便它也支持水化策略（文件位于`/module/Application/src/Application/Model/Hydrator/SampleModelHydrator.php`）：
- en: '[PRE29]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: As we can see we just have to change the previously shown code lines to make
    sure it will use the hydrator strategy in our `Hydrator`.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所见，我们只需更改之前显示的代码行，以确保它将使用我们的`Hydrator`中的水化策略。
- en: 'In the next example we will use the `Hydrator` to hydrate our `SampleModel`
    into our controller (the file is `/module/Application/src/Application/Controller/IndexController.php`):'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一个示例中，我们将使用`Hydrator`将我们的`SampleModel`水化到我们的控制器中（文件位于`/module/Application/src/Application/Controller/IndexController.php`）：
- en: '[PRE30]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: If we know to compare the extract with the original values, we can see that
    the ID has now changed to a random number, telling us that the hydrator strategy
    did its job.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们知道比较提取值与原始值，我们可以看到ID现在已更改为随机数，这告诉我们水化策略已经完成了其工作。
- en: How it works…
  id: totrans-189
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: Think about the model's purpose
  id: totrans-190
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 考虑模型的目的
- en: By definition models should only have functionality related to one very specific
    bit of the application. This means that if we begin coding a model, we should
    be wary of this requirement and make our models lightweight and catering to a
    single purpose.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 根据定义，模型应该只包含与应用程序一个非常具体的部分相关的功能。这意味着如果我们开始编写模型，我们应该注意这个要求，并使我们的模型轻量级且针对单一目的。
- en: The idea of having loads of small pieces of code is that we can maintain them
    a lot easier and we only load in what we like to use. Instead of loading a 40k
    line long model with all the functionality we need, we would like to split them
    up into small functional classes that do only the thing they are named after.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 有很多小块代码的想法是我们可以更容易地维护它们，我们只加载我们想要使用的。而不是加载一个包含所有所需功能的40k行长的模型，我们希望将它们拆分成小型功能类，这些类只做它们名字所表示的事情。
- en: Think about the model's location
  id: totrans-193
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 考虑模型的位置
- en: The location of a model is especially important as we still want to be able
    to find it among our code. We should give it a name that resembles its functionality,
    and it should be as specific as possible.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 模型的位置特别重要，因为我们仍然希望能够在我们的代码中找到它。我们应该给它一个与其功能相似的名字，并且它应该尽可能具体。
- en: If we name the model we need to put it in a location that makes sense as well,
    so when we look for certain functionality we can find it by just searching in
    the location it makes most sense.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们需要命名一个模型，我们还需要将其放置在一个有意义的地点，这样当我们寻找某些功能时，我们只需在最有意义的位置搜索即可找到它。
- en: 'For example let''s take a look at the following namespace and class name:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，让我们看看以下命名空间和类名：
- en: '[PRE31]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: If we search for a method that retrieves user information then this class would
    be a great way to start searching.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们搜索一个检索用户信息的方法，那么这个类将是开始搜索的好方法。
- en: Think about the model's methods
  id: totrans-199
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 考虑模型的方法
- en: The model's methods are obviously the most important part of the model, it is
    also one that is usually highly overlooked. For example, developers sometimes
    use the wrong visibility while defining their methods, which then ends up misused
    by other developers who think they could (or couldn't) use a specific method because
    of its visibility.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 模型的方法显然是模型最重要的部分，它也是通常被高度忽视的部分。例如，开发者有时在定义方法时使用错误的可见性，这导致其他开发者错误地使用它们，因为他们认为可以（或不能）使用特定方法，因为其可见性。
- en: Sometimes the method is named incorrect or the visibility has been set up wrong
    and in turn we end up refactoring the code. All of which can be avoided by simply
    thinking about it beforehand.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 有时方法命名不正确或可见性设置错误，结果我们不得不重构代码。所有这些都可以通过事先考虑来避免。
- en: Tip
  id: totrans-202
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: It is also wise to name your method right, put the visibility in correctly,
    and to use a strict naming convention in our application.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 也很明智地为你的方法命名正确，正确放置可见性，并在我们的应用程序中使用严格的命名约定。
- en: Method names should be named through `camelCase`, and only protected and private
    methods should be allowed to start with an underscore.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 方法名应该通过`camelCase`命名，并且只有受保护和私有方法可以以下划线开头。
- en: Unit test the model
  id: totrans-205
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 单元测试模型
- en: Testing your model is a great way of making sure the output of the methods always
    matches with the output we expect it to be. An even greater way (personally) of
    developing your model is to TDD (Test-Driven Development) the code so that you
    have an objective test, instead of a subjective one, if you write the test after
    you have written the method. We will talk more about unit testing and TDD in [Chapter
    9](ch09.html "Chapter 9. Catching Bugs"), *Catching bugs*.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 测试你的模型是确保方法输出始终与预期输出匹配的绝佳方式。一个更伟大的（个人）开发模型的方式是进行TDD（测试驱动开发），这样你就有了一个客观的测试，而不是主观的测试，如果你在编写方法之后编写测试。我们将在第9章[捕捉错误](ch09.html
    "第9章。捕捉错误")中更多地讨论单元测试和TDD。
- en: Document your class
  id: totrans-207
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 记录你的类
- en: Usually documenting a class is overlooked and/or unmaintained while it should
    be something that exists in your routine. Even if we are the only developer on
    the project, and we know that in ten years time we would still be the only developer,
    it still is a great way to let the future us know why we created that method,
    what it does, and what we can expect back from it.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，在类被忽视和/或未维护的同时，它应该是你日常工作中存在的东西。即使我们是这个项目唯一的开发者，并且我们知道十年后我们仍然是唯一的开发者，这仍然是一个很好的方式，让未来的我们知道我们为什么创建那个方法，它做什么，以及我们可以期望它返回什么。
- en: 'The PHP DocBlock or in short the PHPDoc is the formal standard of documenting
    our code in the comment format. First of all a docblocks can be identified by
    the following syntax:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: PHP DocBlock，简称PHPDoc，是我们以注释格式记录代码的正式标准。首先，docblocks可以通过以下语法来识别：
- en: '[PRE32]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: As we can see, the difference between a normal comment block and a docblock
    is the two asterisks used at the beginning. After that the first line should always
    describe the current method, class, or file (whatever the context is). The lines'
    following that consists of tags, which are used to define certain properties of
    the docblock. For example, the `@param` tag is used to define parameters to a
    method, which have a type defined, and the name of the parameter behind it. The
    `@result` expresses the return value of the method call, and the `@throws` tells
    us an exception can occur in this method. And last but not least `@author` tells
    us who initially created the method/file/class.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，普通注释块与文档块之间的区别在于开头使用的两个星号。之后的第一行应始终描述当前的方法、类或文件（无论上下文如何）。随后的行包含标签，这些标签用于定义文档块的一些属性。例如，`@param`
    标签用于定义方法参数，这些参数具有定义的类型和其后参数的名称。`@result` 表达了方法调用的返回值，而 `@throws` 告诉我们在这个方法中可能会抛出异常。最后但同样重要的是，`@author`
    告诉我们谁最初创建了该方法/文件/类。
- en: Obviously there are dozens of other tags to use, of which most of them can be
    found at [http://en.wikipedia.org/wiki/PHPDoc](http://en.wikipedia.org/wiki/PHPDoc).
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，还有许多其他标签可以使用，其中大多数可以在 [http://en.wikipedia.org/wiki/PHPDoc](http://en.wikipedia.org/wiki/PHPDoc)
    找到。
- en: We would recommend using the `phpDocumenter` syntax to use as the standard of
    creating method and class documentation as it is an industry standard and gives
    us the option of generating a technical document quite easily.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 我们建议使用 `phpDocumenter` 语法作为创建方法和类文档的标准，因为它是一个行业标准，并为我们提供了轻松生成技术文档的选项。
- en: Creating a hydrator
  id: totrans-214
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建填充器
- en: Hydrators are the sort classes that can be used to hydrate a specific class
    with values given to the `Hydrator`.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 填充器是那些可以用来使用给定的值填充特定类的类。
- en: This can be especially useful when retrieving data from a database table, and
    when we want to map it to another model, where the model doesn't have to know
    the mappings of the table and the `TableGateway` doesn't have to know how to map
    them to the model. In such cases a `Hydrator` is perfect for the job as an intermediary
    between the model and the data access layers.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 这在从数据库表检索数据并将其映射到另一个模型时特别有用，其中模型不需要知道表和 `TableGateway` 如何将它们映射到模型。在这种情况下，`Hydrator`
    作为模型和数据访问层之间的中介是完美的。
- en: The `mapping` property defines the mapping between the received array (which
    we use to hydrate) and the property on the object side. So, for example, if our
    array contains a key ID, we will set the property primary in the object. Obviously
    this is the most basic a `hydrate` method can possibly be as it simply checks
    if we have a valid object and then checks if we have the property name we want
    to set and sets it if it does.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: '`mapping` 属性定义了接收到的数组（我们用它来填充）与对象侧属性之间的映射。例如，如果我们的数组包含一个键 ID，我们将在对象中设置 primary
    属性。显然，这是 `hydrate` 方法可能的最基本形式，因为它只是检查我们是否有一个有效的对象，然后检查我们是否具有想要设置的属性名称，如果存在则设置它。'
- en: Creating a hydrator strategy
  id: totrans-218
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建填充器策略
- en: 'Now that we have a simple hydrator, we might want to take a look at another
    amazing piece of the Zend Framework that is new: the hydrator strategy. The hydrator
    strategy is simply said a transformation of one value that is being parsed into
    the `Hydrator`.'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有一个简单的填充器，我们可能想看看 Zend 框架中的另一件新奇的部件：填充器策略。简单地说，填充器策略是将正在解析的值转换成 `Hydrator`
    的过程。
- en: We changed the primary setter of the hydrator now, so that when it receives
    something else than an integer it will throw an exception.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已更改填充器的首要设置器，以便当它接收到除整数之外的其他内容时，将抛出异常。
- en: But our `Hydrator` is not familiar with the properties in our model, which in
    turn means that when an incompatible value is used and exception will be thrown.
    To overcome this (and many other) problem, we can use a hydrator strategy, which
    will have the last chance to set a value before it goes to the model.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 但我们的 `Hydrator` 不熟悉模型中的属性，这反过来意味着当使用不兼容的值时，将抛出异常。为了克服这个问题（以及许多其他问题），我们可以使用填充器策略，它将在值传递到模型之前有最后的机会设置值。
- en: Now the plan is that we will create a hydrator strategy which will check our
    primary property and make sure it returns an integer. As we can see further on,
    we basically created an `extract` and a `hydrate` method, which will check if
    there is an integer as value, and if not return a random integer. This way we
    safeguard ourselves so that any value that comes in to our model is at least the
    type we expect it to be.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 现在的计划是我们将创建一个hydrator策略，该策略将检查我们的主要属性并确保它返回一个整数。正如我们稍后可以看到的，我们基本上创建了一个`extract`和一个`hydrate`方法，这些方法将检查是否存在整数值，如果不存在，则返回一个随机整数。这样我们就可以确保进入我们模型的所有值至少是我们期望的类型。
- en: About models
  id: totrans-223
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 关于模型
- en: Models are just regular classes which differ nothing from any other class. However,
    the principle behind a model is that all the business critical logic is defined
    in them. An MVC prefers to have skinny controllers (which means no or almost no
    logic) and fat models.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 模型只是普通的类，与任何其他类没有区别。然而，模型背后的原则是所有业务关键逻辑都定义在其中。MVC倾向于拥有瘦控制器（这意味着没有或几乎没有逻辑）和胖模型。
- en: Hydrators, on the other hand, are classes that are used in between models, for
    example, when exchanging data from one model to another, or from a `TableGateway`
    to a model and vice versa. Obviously not every model we write would require a
    `Hydrator`, but as applications tend to grow, we like to implement new features
    without having to change the existing ones, and `Hydrator` can then serve as a
    key factor as they can serve as a proxy between objects.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，hydrator是用于模型之间的类，例如，在从一个模型到另一个模型或从`TableGateway`到模型以及相反的数据交换时使用。显然，我们编写的每个模型都不需要`Hydrator`，但随着应用程序的增长，我们喜欢在不改变现有功能的情况下实现新功能，而`Hydrator`可以作为关键因素，因为它们可以作为对象之间的代理。
- en: There's more…
  id: totrans-226
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多…
- en: There is a lot more to write about hydrators, and especially the different kinds
    of default hydrators that come with Zend Framework 2\. If we want to know more
    about that we should check the documentation for the `Zend\Stdlib\Hydrator\ArraySerializable`,
    `Zend\Stdlib\Hydrator\ClassMethods`, and the `Zend\Stdlib\Hydrator\ObjectProperty`
    hydrator.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 还有更多关于hydrator的内容要写，特别是与Zend Framework 2一起提供的不同类型的默认hydrator。如果我们想了解更多关于这方面的信息，我们应该查看`Zend\Stdlib\Hydrator\ArraySerializable`、`Zend\Stdlib\Hydrator\ClassMethods`和`Zend\Stdlib\Hydrator\ObjectProperty`
    hydrator的文档。
- en: A basic service
  id: totrans-228
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 基本服务
- en: One of the biggest features of Zend Framework 2 is the `ServiceManager` , and
    its influence in the framework can be seen from the initial bootstrap of our application.
    We don't need a reason to explain why this recipe goes deeper in this topic, do
    we?
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: Zend Framework 2最大的特性之一是`ServiceManager`，其在我们应用程序的初始引导阶段就可以看到它的影响。我们不需要理由来解释为什么这个菜谱会在这个主题上深入探讨，对吧？
- en: Getting ready
  id: totrans-230
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: Again a Zend Framework 2 skeleton application should be running to make the
    full use of our examples in this recipe.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调，为了充分利用这个菜谱中的示例，应该有一个Zend Framework 2骨架应用程序正在运行。
- en: Before we continue let's get the difference between a service and a model. Although
    the definition of a service is sometimes a judgment call, it can be safely assumed
    that a service is a class between the controller and the model, which hides all
    the nasty logic from the controller, for example, checking the authentication
    or calling a method in a model. Another thing that is different is that the service
    in our case will be managed by the `ServiceManager`, and therefore, can be called
    from any controller (and other service) in our application.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们继续之前，让我们弄清楚服务和模型之间的区别。尽管服务的定义有时是一个判断性的选择，但可以安全地假设服务是一个位于控制器和模型之间的类，它隐藏了控制器中所有糟糕的逻辑，例如检查身份验证或调用模型中的方法。另一个不同之处在于，我们案例中的服务将由`ServiceManager`管理，因此可以从我们的应用程序中的任何控制器（和其他服务）中调用。
- en: How to do it…
  id: totrans-233
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做…
- en: Services are a great way of making sure our functionality can be accessed virtually
    anywhere in our application, and in this recipe we will show exactly how to do
    that!
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 服务是确保我们的功能可以在应用程序的几乎任何地方访问的绝佳方式，在这个菜谱中，我们将展示如何做到这一点！
- en: Creating a service
  id: totrans-235
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建服务
- en: 'We will create our service in the `/module/Application/src/Application/Service/Example.php`
    file:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在`/module/Application/src/Application/Service/Example.php`文件中创建我们的服务：
- en: '[PRE33]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Now the only thing that left to do is to add this service to the module configuration
    (the file is `/module/Application/config/module.config.php`), so it can be reached
    by the rest of the application as well:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 现在唯一剩下的事情是将此服务添加到模块配置（文件是`/module/Application/config/module.config.php`）中，这样它也可以被应用程序的其余部分访问：
- en: '[PRE34]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Of course, this is again a snippet to show what needs to be added to the configuration.
    We can now easily retrieve the service in, for example, a controller by performing
    the following:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，这又是一个片段，用来展示需要添加到配置中的内容。现在，我们可以通过执行以下操作轻松地在控制器中检索服务，例如：
- en: '[PRE35]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Getting a service from within a controller
  id: totrans-242
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在控制器中获取服务
- en: 'This example shows that it is very easy to retrieve a service from a controller.
    From within a service we can also easily get our main application configuration
    by performing the following:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子表明，从控制器中检索服务非常简单。在服务内部，我们也可以通过执行以下操作轻松地获取我们的主要应用程序配置：
- en: '[PRE36]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: How it works…
  id: totrans-245
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: We created a very basic service and added it to the configuration of our `Application`
    module. The idea behind it is that we can show how easy it is to create a service,
    activate it, and use it in the application. We will create a service that is going
    to be managed by the `ServiceManager` and does nothing more than rot13 encode
    on a string.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建了一个非常基本的服务并将其添加到我们的 `Application` 模块的配置中。其背后的想法是，我们可以展示创建服务、激活它以及在应用程序中使用它的简单性。我们将创建一个将由
    `ServiceManager` 管理的服务，它所做的只是对字符串进行 rot13 编码。
- en: To create a service we only need to implement the `Zend\ServiceManager\ServiceLocatorAwareInterface`
    in our class, which predefines two methods, the `getServiceLocator` and the `setServiceLocator`.
    The `setServiceLocator` is called during instantiation, and most of the time (at
    least not when we add the service in our configuration) we don't have to do this
    manually.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建一个服务，我们只需要在我们的类中实现 `Zend\ServiceManager\ServiceLocatorAwareInterface`，它预定义了两个方法，即
    `getServiceLocator` 和 `setServiceLocator`。`setServiceLocator` 在实例化期间被调用，大多数时候（至少在我们将服务添加到配置中时）我们不需要手动执行此操作。
- en: The `getServiceLocator` however is a method we can use to get the `ServiceLocator`,
    from which we can get useful things like other services, or perhaps the configuration
    of the application itself.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，`getServiceLocator` 是一个我们可以用来获取 `ServiceLocator` 的方法，从它我们可以获取其他服务或可能是应用程序本身的配置等有用的东西。
- en: Services are instantiated either at the loading of the modules if they are in
    the module configuration, or just during some place in the application. However,
    when we instantiate the service, we know that we can always get it through the
    same easy `get()` method of the `ServiceLocator` anywhere else in the application
    once it has been instantiated.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 服务是在模块加载时实例化的，如果它们在模块配置中，或者只是在应用程序的某个地方。然而，当我们实例化服务时，我们知道我们总是可以通过 `ServiceLocator`
    的相同简单 `get()` 方法在任何其他地方获取它，一旦它被实例化。
