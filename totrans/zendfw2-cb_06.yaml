- en: Chapter 6. Modules, Models, and Services
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter we will cover:'
  prefs: []
  type: TYPE_NORMAL
- en: Creating a new module
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using modules as a widget
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A Model and a Hydrator
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A basic service
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter is all about making the most of our module, models, and services
    and their configuration. As Zend Framework 2 is a modular framework, the modules
    are obviously one of the most important features of it all. We will talk about
    customizing the configuration of the modules and how to go about working with
    models and services as well.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a new module
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The core of the Zend Framework 2 library is modular and everything is based
    around a module based system. That's why we will explain this thoroughly in this
    recipe, so that we can use it in its best way possible.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We will be using the Zend Framework skeleton application for creating new modules.
    As a reminder, the Zend Framework 2 skeleton application can be found at [https://github.com/zendframework/ZendSkeletonApplication](https://github.com/zendframework/ZendSkeletonApplication).
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Creating a new module is like starting a new drawing, it is exciting and fun
    to create a new functionality, but there are always rules we need to obey. In
    this recipe we will discuss what the rules are for setting up a new module.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the Module.php
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We can start off with just a simple class file (that is, `/module/Sample/Module.php`)
    in the right namespace (`Sample`) with nothing in it, which is basically the only
    requirement there is for the module.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'We can add the following method to our `Module` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Let's just create a `/module/Sample/config/module.config.php` file now which
    will return an empty array for now, as we don't really have anything to configure
    at the moment.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: To hook up to the bootstrap event, a module just have to have an `onBootstrap`
    method in our `Module.php` file which does all the bootstrapping for us, or we
    can define bootstrap events that are executed when the bootstrap has been called
    (my personal favorite).
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s see both ways, beginning with the `onBootstrap method`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: As we can see a simple method is enough to create bootstrapping, it bootstraps
    the module as soon as the bootstrap event of the application is being triggered.
  prefs: []
  type: TYPE_NORMAL
- en: Attaching to the loadModules.postevent
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The following example makes use of the `/module/Application/Module.php` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Implementing the getAutoloaderConfig
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The following example is part of the `Module.php` `Module` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s consider the following updated code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'An example of a class map file (file `/module/Application/autoload_classmap.php`)
    is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Implementing the getControllerConfig, getControllerPluginConfig and getViewHelperConfig
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Take a look at the following implementation of the `getViewHelperConfig` (in
    the `/module/Application/Module.php` file):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Modules are instantiated by the framework once they are introduced in the `application.config.php`
    file. Adding a module's name the file will make the framework look for the `Module.php`
    file in a directory bearing the name of the module. The `Module.php` file has
    a selection of methods which will then be called by the framework at certain times,
    such as loading the configuration or running the module's bootstrap.
  prefs: []
  type: TYPE_NORMAL
- en: For our example we will create a module called `Sample`, which will have a simple
    controller and an action that outputs some text.
  prefs: []
  type: TYPE_NORMAL
- en: 'To make sure the `ModuleManager` of Zend Framework 2 picks up our new module,
    we need to understand how the `ModuleManager` works. What the `ModuleManager`
    does is fulfill three operations:'
  prefs: []
  type: TYPE_NORMAL
- en: It collects the enabled modules
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It initializes the module, if necessary
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It collects the configuration from all the modules
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Although we can automatically create a whole new module with the `ZFTool`, it
    is still recommended that we know how to make and structure a module without it.
    We will now begin to create a module that makes sure the `ModuleManager` is happy
    with it.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a new module directory
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When creating a new module, we will follow the recommended way as much as possible,
    so that we get the clearest view on how it all works. First things first, create
    a new directory in the module directory with the name `Sample`. This directory
    will be our main directory when it comes to code relating to the Sample module's
    namespace, that way we will have every related piece of code enclosed in this
    directory.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the Module.php
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The most important file of every module is the `Module.php` file, which is not
    only required, but also feeds the framework with important information about things
    such as; where to find the code, and what the configuration is.
  prefs: []
  type: TYPE_NORMAL
- en: Although it won't actually initialize anything in the module, it is the basic
    requirement to have a module. Note that because of the lack of code inside `Module.php`,
    it is impossible for our application to reach any of the code inside the module
    as well.
  prefs: []
  type: TYPE_NORMAL
- en: The first thing we want to do is to make sure that the framework will read our
    configuration for our module. This can be done by defining a `getConfig` method
    in our `Module.php`. which requires an array as a return value.
  prefs: []
  type: TYPE_NORMAL
- en: Because laziness is a skill, we will simply return the complete `module.config.php`
    file to the `ModuleManager`. We don't have to do this, we can also just return
    an array with the configuration in as well, but for the purpose of maintainability
    it is best to keep the actual configuration separate from the code. This way we
    don't have to edit the code to edit the configuration.
  prefs: []
  type: TYPE_NORMAL
- en: Now we know that our `ModuleManager` will load our configuration, it is time
    to go over the bootstrapping of the module, which is sometimes necessary to initialize
    more after the configuration has loaded. This can be done either by using the
    `onBootstrap` method in the `Module.php` or attach to the `ModuleManager` events.
  prefs: []
  type: TYPE_NORMAL
- en: Optionally act on ModuleManager events
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Another way of making sure additional pieces of code will be executed is by
    attaching them to one of the four other strategic events, namely: `loadModules`,
    `loadModules.resolve`, `loadModule`, and `loadModules.post`.'
  prefs: []
  type: TYPE_NORMAL
- en: To explain them all a bit better, let's go through all of them briefly.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the loadModules event
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `loadModules` event will be triggered when the framework is loading the
    modules, so for initializing a module, this event is pretty much useless as it
    will never be called in the `Module.php` file (the event has already passed at
    that point).
  prefs: []
  type: TYPE_NORMAL
- en: At this point the framework is still loading the modules up and nothing has
    happened for our module yet. That is why this event is primarily used on the internal
    side of the framework and not on our development side. However, as this event
    is active throughout the whole process of loading the modules, it also does some
    extra things when all the other events have been done.
  prefs: []
  type: TYPE_NORMAL
- en: 'This event triggers the following functionality by default:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Zend\Loader\ModuleAutoloader::register`: This makes sure that the `Module`
    class can be found and initiated (It doesn''t initiate it just yet, just checks).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Zend\ModuleManager\Listener\ConfigListener` `::onLoadModulesPre` `::onLoadModulesPost`:
    This functionality merges the configuration files with the local configuration
    files found by the defined `glob()` in the application configuration when all
    the modules have been loaded, but only if the configuration is not cached internally
    (which is not the case by default).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Zend\ModuleManager\Listener\LocatorRegistration::onLoadModulesPost`: This
    attaches the service of the modules to the `ServiceManager`, if the `Module` class
    implemented the `LocatorRegisteredInterface` interface, which will immediately
    add the `Module` class to the DI. This is done when all the modules are loaded
    up.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The loadModules.resolve event
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Another internal event and not an event a module can make use of is this event,
    which is triggered for each module that is defined in our `application.config.php`.
    This event will actually try to find the `Module` class in the `Module.php` file
    of our module, so although not useful (yet) to our module, it is coming close!
  prefs: []
  type: TYPE_NORMAL
- en: 'This event triggers the following functionality by default:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Zend\ModuleManager\Listener\ModuleResolverListener::__invoke`: This initiates
    the `Module` class'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The loadModule event
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Now the object (of the `Module` class) has been created; the `loadModule` event
    will pass it along the other listeners.
  prefs: []
  type: TYPE_NORMAL
- en: 'This event triggers the following functionality by default:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Zend\ModuleManager\Listener\ConfigListener::onLoadModule`: This merges the
    configuration by getting all the getConfig() of the Module classes.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Zend\ModuleManager\Listener\AutoloaderListener::__invoke`: This calls the
    `getAutoloaderConfig` in the `Module` class if available, so that we can get the
    autoloading going for our new module'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Zend\ModuleManager\Listener\InitTrigger::__invoke`: This calls the init method
    in the `Module` class if available.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Zend\ModuleManager\Listener\OnBootstrapListener::__invoke`: This attaches
    the `onBootstrap` method of the `Module` class to the bootstrap event of the application,
    so it will be run at that time.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Zend\ModuleManager\Listener\ServiceListener::onLoadModule`: This calls the
    following methods in the `Module` class if they exist (we will discuss these methods
    more extensively a bit further on in this recipe):'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`getServiceConfig`: This gets the `ServiceManager` configuration from the Module
    class.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`getControllerConfig`: This gets the controller configuration from the `Module`
    class.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`getControllerPluginConfig`: This gets the controller plugin configuration
    from the `Module` class.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`getViewHelperConfig`: This gets the view helper configuration from the `Module`
    class.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The flow chart showing a simplified version of the module loading is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The loadModule event](img/4841OS_06_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The loadModules.post
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `loadModules.post` event is triggered when the modules have successfully
    been loaded and the last bits are needed to be done to complete it all.
  prefs: []
  type: TYPE_NORMAL
- en: This event triggers the `Zend\ModuleManager\Listener\ServiceListener::onLoadModulesPost`
    functionality by default and instructs the `ServiceManager` to create more services
    if needed.
  prefs: []
  type: TYPE_NORMAL
- en: Attaching to the loadModules.post event
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `loadModules.post` event is the first event we can attach a handler to in
    our application, as events before this one can only be used by the internal listeners
    of Zend Framework 2\. That means there is not a good way of hooking up to those
    events without making extensions to the framework ourselves.
  prefs: []
  type: TYPE_NORMAL
- en: However, the `loadModules.post` event can still be useful, for example, to make
    sure that our modules are loaded correctly, or for something else modules config
    related. The best way of attaching ourselves to this event is by doing that as
    high up as we can get with the `EventManager`. In this case that would be in the
    `init()` method of the module, as that is being called during the `loadModule`
    event, and is the first one to contain an `EventManager`.
  prefs: []
  type: TYPE_NORMAL
- en: More specific non configuration file Module configuration
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Sometimes we choose not to use the `module.config.php` file all the time and
    we require a more dynamic instantiation, for example, of services or configurations.
    Luckily Zend Framework 2 fully supports any dynamic configuration functionality.
    As discussed before, there are five extra methods we can add to our `Module` class,
    which are picked up during the module instantiation, namely the `getAutoloaderConfig`,
    `getServiceConfig`, `getControllerConfig`, `getControllerPluginConfig`, and the
    `getViewHelperConfiguration`.
  prefs: []
  type: TYPE_NORMAL
- en: The getAutoloaderConfig method
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `getAutoloaderConfig` method will load in the autoloader configuration for
    our module and expects an array that is compatible with the `AutoloaderFactory`.
    There are generally two accepted ways of autoloading in Zend Framework 2\. The
    first one is to use the `StandardAutoloader`, which requires a namespace to load
    and a directory to recur in to. The second one is to use a `ClassMapAutoloader`,
    which is basically a file with an array where every full domain and class name
    is mentioned with a reference to a specific file.
  prefs: []
  type: TYPE_NORMAL
- en: Both of them are displayed in the examples, so please take a look at them to
    see the differences.
  prefs: []
  type: TYPE_NORMAL
- en: We use the `StandardAutoloader` in the first example because we just want our
    framework to load all the classes in the namespace `__NAMESPACE__` (which is `Sample`
    for our module) through the directory structure in the `[current directory]/src/Sample`
    directory. This means that a class that is fully called in `Sample\Model\Test`,
    will be searched in `/src/Sample/Model/Test.php`. Although this is very handy
    in a development environment, it isn't handy in a production environment because
    a large application will put a lot of strain on searching for the class names
    we need. In that case we can use this `StandardAutoloader`, but in addition (with
    a higher priority) we will also be using a `ClassMapAutoloader` that loads in
    a static file with all the class names mapped to a specific directory.
  prefs: []
  type: TYPE_NORMAL
- en: This tells PHP that when we search for the class `Sample\Model\Test`, it can
    be found in `/src/Sample/Model/Test.php` (or wherever really, as we point the
    PHP directly towards our file anyway). Both of the autoloaders are PSR-0, where
    PSR stands for PHP Standards Recommendation compliant.
  prefs: []
  type: TYPE_NORMAL
- en: In the second example we can see we prioritized our `autoload_classmap.php`
    file over our `StandardAutoloader`, which means that it will look first in our
    class map file before trying to find it on its own.
  prefs: []
  type: TYPE_NORMAL
- en: To make the framework use the `getAutoloaderConfig` method, we must make sure
    our `Module` class implements the `Zend\ModuleManager\Feature\AutoloaderProviderInterface`
    class as well as it consists of the single public method `getAutoloaderConfig()`,
    otherwise it will not try to execute it. Remember that simply implementing the
    method is not enough to make it fire as it specifically looks if we are implementing
    the interface.
  prefs: []
  type: TYPE_NORMAL
- en: The getControllerConfig, getControllerPluginConfig, and getViewHelperConfig
    methods
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Instead of loading the controller configuration through the `module.config.php`
    or as an override, we can also do it through the `get***Config` method. We can
    create the method the same way as the `getServiceConfig` method, as the return
    object can either be of the instance `Zend\ServiceManager\Config` or simply an
    array with the configuration like in the `module.config.php`.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we want to use these methods, we should not forget to implement our class
    with the respective interfaces:'
  prefs: []
  type: TYPE_NORMAL
- en: '`For the getControllerConfig method we need to implement the Zend\ModuleManager\Feature\ControllerProviderInterface
    interface.`'
  prefs: []
  type: TYPE_NORMAL
- en: '`For the getControllerPluginConfig method we need to implement the Zend\ModuleManager\Feature\ControllerPluginProviderInterface
    interface.`'
  prefs: []
  type: TYPE_NORMAL
- en: '`And lastly for the getViewHelperConfig method we need to implement the Zend\ModuleManager\Feature\ViewHelperProviderInterface
    interface.`'
  prefs: []
  type: TYPE_NORMAL
- en: Using modules as a widget
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Widgetizing is a great method to use modules on different places in our applications.
    That's why this recipe will explain everything we need to know about doing this
    in the best way possible.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A working Zend Framework 2 skeleton application is needed to make full use of
    this recipe.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Widgets, they even sound great! We will explain in this recipe what they do
    and how they can be used.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the Comment/Controller/Index
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We will create a small controller that will return some example comments, which
    are static and hardcoded for example only. First we should make sure we have a
    `Comment` module, so we create the following directories and files:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Once we have the structure in place, we put the simplest code in the `/module/Comment/Module.php`
    as possible to initialize the module, which is shown as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'As we can see this is the most basic `Module` class because we don''t need
    it more advanced than this. Now let''s quickly create our `module.config.phpconfiguration`
    file in the `/module/Comment/config` directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that we have set up a quick configuration with a route that responds to
    the `/`comment and maps to `Comment\Controller\IndexController::indexAction`,
    we can continue with the actual controller (present in the file `/module/Comment/src/Comment/Controller/IndexController.php`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'After creating our controller, the only thing we still need to create is the
    view script (found in the file `/module/Comment/view/comment/index/index.phtml`)
    to actually output the data in an HTML table:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Now that we have our module completely set up, we can go forth and display the
    comments in widget form.
  prefs: []
  type: TYPE_NORMAL
- en: Using a view helper to display the comments statically
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'First we want to create the view helper itself, let''s do this in the `Comment`
    module (the file is `/module/Comment/src/Comment/View/Helper/Comments.php`) as
    the data comes from there anyway:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Now all we need to do is add this view helper to our module configuration (the
    file is `/module/Comment/config/module.config.php`) before we are able to use
    it in our views:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Obviously we omitted the rest of the configuration here because we didn''t
    want to repeat ourselves. All that is left now is to actually use the new view
    helper in the code. We can do that to put the following code line in our view
    script:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Using the forward to render the comments statically
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Let''s take a look at a code snippet of the action of a `forward()` in our
    `CommentController` (the file is `/module/Application/src/Application/Controller/CommentController.php`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'This gets the dispatched state of a action in a specific controller (our `Comment\Controller\Index::indexAction`)
    and returns it to us as `$comments`, which is a `ViewModel` instance. We add that
    as a child to our current `ViewModel` instance and then we can simply output it
    in the view script with the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: This is the same as outputting a normal variable, and although this gives the
    feeling of a clean solution, the `forward()` method is known to be horrible under
    stress.
  prefs: []
  type: TYPE_NORMAL
- en: Getting the comments through AJAX
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Let''s see what our view script looks like with JavaScript:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This is the scenario: We have a page that contains a little story on which
    users should be able to comment. The comment section however is used at several
    other locations in the code and should therefore be reusable. There is one proviso
    though, the comment section doesn''t change in layout, it will always need to
    be displayed in the same way.'
  prefs: []
  type: TYPE_NORMAL
- en: What we are going to do is create three different but valid implementations
    of a module that is being used as a widget. The first two will give a more static
    feel to it all, while the third one will use JavaScript (jQuery to be exact) to
    load in the comments. We will also discuss a theoretic fourth solution that should
    be considered.
  prefs: []
  type: TYPE_NORMAL
- en: But first of all we will set up a small environment, which we will use in the
    examples of retrieving the comments.
  prefs: []
  type: TYPE_NORMAL
- en: We will set up the `Application/Controller/Comment` controller, which will have
    the `helperAction`, `forwardAction` and `ajaxAction` method defined. Then we will
    use this controller and actions to display the comments in the `Comment/Controller/Index`
    controller and `indexAction` method.
  prefs: []
  type: TYPE_NORMAL
- en: Using a view helper to display the comments statically
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The best option to display the comments in a statically way would be to create
    a view helper specific for this widget. What we are going to do is create a small
    view helper that will render our comments and return them to our view. This way
    we can use it everywhere in our view without using a lot of hassle like the `forward()`
    or the AJAX methods do.
  prefs: []
  type: TYPE_NORMAL
- en: As we can see in the example we instantiate our controller and manually retrieve
    the output of the action, and after that manually render it and return it to the
    view. It is not always this easy to do it like this, but it comes close to reality.
  prefs: []
  type: TYPE_NORMAL
- en: Using the forward() method to render the comments statically
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A not so great idea but worth mentioning also is getting the comments through
    the `forward()` method, which is brittle, but at least it doesn't go through the
    whole MVC initialization like the AJAX functionality does.
  prefs: []
  type: TYPE_NORMAL
- en: Getting the comments through AJAX
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Last but not least, a more technical non-PHP solution is also at hand for when
    we want to be a little bit more creative, or when our environment just calls for
    an asynchronous AJAX implementation. The idea of this method is that we simply
    retrieve our comments from the URL through JavaScript, or to be specific the jQuery
    library.
  prefs: []
  type: TYPE_NORMAL
- en: This only requires us to input a bit of client-side JavaScript in the view script
    to make it work, which is nice because we don't have to fiddle around much in
    the code. It has one big con though, and that is that we will go through the whole
    MVC process again to receive the comments from the database. On the other hand
    it will speed up the response time from our main action as it doesn't have to
    load the comments statically. Another con would be that the user visiting the
    website needs a JavaScript enabled browser to see the comments, but we assume
    everyone has such browser nowadays.
  prefs: []
  type: TYPE_NORMAL
- en: As we can see from the example this is a pretty easy method of retrieving the
    comments as well, but it has afore mentioned cons attached to it. However, sometimes
    this might be the best option performance wise to get the data from somewhere
    else. It is all due to the architecture of the application.
  prefs: []
  type: TYPE_NORMAL
- en: About Widgetizing
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Widgetizing a module is not something that is absolutely native to the framework,
    but as we can see in the paragraphs above, it is something we can easily achieve
    by using (not abusing) the framework as much as we can.
  prefs: []
  type: TYPE_NORMAL
- en: Especially, instantiating controllers and executing actions our self is a great
    method of dealing with data from other sections of the application. We want to
    be wary, however, that modules in itself should be independent (or at least as
    much as possible) from each other and we shouldn't rely too much on their existence.
  prefs: []
  type: TYPE_NORMAL
- en: But to be fair, a perfect situation is never to be found, and we just need to
    do some concessions some times. In our case this might be relying on modules that
    might not be there.
  prefs: []
  type: TYPE_NORMAL
- en: A Model and a Hydrator
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Models are a great way of providing functionality to our application, and they
    keep out the Controllers, nice and clean, from any critical logic. A hydrator
    is also great to transport properties and values from one model to another, that's
    why we will go into this a bit further to make optimal use of it.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For this recipe a working Zend Framework 2 skeleton application is necessary
    to make full use of the examples.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this recipe we will set up a model and a method for hydrating data to and
    from our model, so that we have easy access of our data.
  prefs: []
  type: TYPE_NORMAL
- en: Accessing the Model
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We can access the model anywhere in the application by simply adding a use
    statement at the top of our document:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Or by using the fully qualified name of the class including the namespace,
    shown as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'If there is already a class `SampleModel` used, but from a different namespace,
    or if we just want to give it a more identifiable name, we can also use an alias
    (this is not model specific however, and we can use it in any namespaced class),
    as shown as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Creating a Hydrator
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'First thing now is to set up an incredibly simple model (the file is `/module/Application/src/Application/Model/SampleModel.php`),
    which we will use to hydrate, as shown as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'This incredibly basic model has nothing more than a couple of properties with
    the getters and setters for them, simple, but it will work for what we try to
    achieve next. What we are going to do in the following example is create a `Hydrator`
    for our imaginary database table and then we will hydrate our `SampleModel` (the
    file is `/module/Application/src/Application/Model/Hydrator/SampleModelHydrator.php`)
    with the data from the table:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'We have now set up the very basic class of our hydrator, and the methods implemented
    are now only the definitions that we need to have because of the `AbstractHydrator`
    class. The next thing we want to do is to get some code in there to actually make
    it all work. The first thing we will implement further is the `hydrate()` method,
    which will make our `SampleModel` hydrated:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Now let''s use the `extract()` method, which extracts values from our `SampleModel`
    and puts them back in an array which is also formatted in the way we used to hydrate
    the object in the first place:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: And that is how we extract values from the hydrated object again.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a Hydrator strategy
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'If we change the setter of the primary property in the `SampleModel` (the file
    is `/module/Application/src/Application/Model/SampleModel.php`) a bit so that
    it reflects in the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s begin by creating our strategy first (the file is `/module/Application/src/Application/Model/Hydrator/Strategy/SampleHydratorStrategy.php`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we need to change two things in our `Hydrator` class that we created, so
    that it also supports a hydrator strategy (the file is `/module/Application/src/Application/Model/Hydrator/SampleModelHydrator.php`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: As we can see we just have to change the previously shown code lines to make
    sure it will use the hydrator strategy in our `Hydrator`.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the next example we will use the `Hydrator` to hydrate our `SampleModel`
    into our controller (the file is `/module/Application/src/Application/Controller/IndexController.php`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: If we know to compare the extract with the original values, we can see that
    the ID has now changed to a random number, telling us that the hydrator strategy
    did its job.
  prefs: []
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Think about the model's purpose
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: By definition models should only have functionality related to one very specific
    bit of the application. This means that if we begin coding a model, we should
    be wary of this requirement and make our models lightweight and catering to a
    single purpose.
  prefs: []
  type: TYPE_NORMAL
- en: The idea of having loads of small pieces of code is that we can maintain them
    a lot easier and we only load in what we like to use. Instead of loading a 40k
    line long model with all the functionality we need, we would like to split them
    up into small functional classes that do only the thing they are named after.
  prefs: []
  type: TYPE_NORMAL
- en: Think about the model's location
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The location of a model is especially important as we still want to be able
    to find it among our code. We should give it a name that resembles its functionality,
    and it should be as specific as possible.
  prefs: []
  type: TYPE_NORMAL
- en: If we name the model we need to put it in a location that makes sense as well,
    so when we look for certain functionality we can find it by just searching in
    the location it makes most sense.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example let''s take a look at the following namespace and class name:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: If we search for a method that retrieves user information then this class would
    be a great way to start searching.
  prefs: []
  type: TYPE_NORMAL
- en: Think about the model's methods
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The model's methods are obviously the most important part of the model, it is
    also one that is usually highly overlooked. For example, developers sometimes
    use the wrong visibility while defining their methods, which then ends up misused
    by other developers who think they could (or couldn't) use a specific method because
    of its visibility.
  prefs: []
  type: TYPE_NORMAL
- en: Sometimes the method is named incorrect or the visibility has been set up wrong
    and in turn we end up refactoring the code. All of which can be avoided by simply
    thinking about it beforehand.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: It is also wise to name your method right, put the visibility in correctly,
    and to use a strict naming convention in our application.
  prefs: []
  type: TYPE_NORMAL
- en: Method names should be named through `camelCase`, and only protected and private
    methods should be allowed to start with an underscore.
  prefs: []
  type: TYPE_NORMAL
- en: Unit test the model
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Testing your model is a great way of making sure the output of the methods always
    matches with the output we expect it to be. An even greater way (personally) of
    developing your model is to TDD (Test-Driven Development) the code so that you
    have an objective test, instead of a subjective one, if you write the test after
    you have written the method. We will talk more about unit testing and TDD in [Chapter
    9](ch09.html "Chapter 9. Catching Bugs"), *Catching bugs*.
  prefs: []
  type: TYPE_NORMAL
- en: Document your class
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Usually documenting a class is overlooked and/or unmaintained while it should
    be something that exists in your routine. Even if we are the only developer on
    the project, and we know that in ten years time we would still be the only developer,
    it still is a great way to let the future us know why we created that method,
    what it does, and what we can expect back from it.
  prefs: []
  type: TYPE_NORMAL
- en: 'The PHP DocBlock or in short the PHPDoc is the formal standard of documenting
    our code in the comment format. First of all a docblocks can be identified by
    the following syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: As we can see, the difference between a normal comment block and a docblock
    is the two asterisks used at the beginning. After that the first line should always
    describe the current method, class, or file (whatever the context is). The lines'
    following that consists of tags, which are used to define certain properties of
    the docblock. For example, the `@param` tag is used to define parameters to a
    method, which have a type defined, and the name of the parameter behind it. The
    `@result` expresses the return value of the method call, and the `@throws` tells
    us an exception can occur in this method. And last but not least `@author` tells
    us who initially created the method/file/class.
  prefs: []
  type: TYPE_NORMAL
- en: Obviously there are dozens of other tags to use, of which most of them can be
    found at [http://en.wikipedia.org/wiki/PHPDoc](http://en.wikipedia.org/wiki/PHPDoc).
  prefs: []
  type: TYPE_NORMAL
- en: We would recommend using the `phpDocumenter` syntax to use as the standard of
    creating method and class documentation as it is an industry standard and gives
    us the option of generating a technical document quite easily.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a hydrator
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Hydrators are the sort classes that can be used to hydrate a specific class
    with values given to the `Hydrator`.
  prefs: []
  type: TYPE_NORMAL
- en: This can be especially useful when retrieving data from a database table, and
    when we want to map it to another model, where the model doesn't have to know
    the mappings of the table and the `TableGateway` doesn't have to know how to map
    them to the model. In such cases a `Hydrator` is perfect for the job as an intermediary
    between the model and the data access layers.
  prefs: []
  type: TYPE_NORMAL
- en: The `mapping` property defines the mapping between the received array (which
    we use to hydrate) and the property on the object side. So, for example, if our
    array contains a key ID, we will set the property primary in the object. Obviously
    this is the most basic a `hydrate` method can possibly be as it simply checks
    if we have a valid object and then checks if we have the property name we want
    to set and sets it if it does.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a hydrator strategy
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Now that we have a simple hydrator, we might want to take a look at another
    amazing piece of the Zend Framework that is new: the hydrator strategy. The hydrator
    strategy is simply said a transformation of one value that is being parsed into
    the `Hydrator`.'
  prefs: []
  type: TYPE_NORMAL
- en: We changed the primary setter of the hydrator now, so that when it receives
    something else than an integer it will throw an exception.
  prefs: []
  type: TYPE_NORMAL
- en: But our `Hydrator` is not familiar with the properties in our model, which in
    turn means that when an incompatible value is used and exception will be thrown.
    To overcome this (and many other) problem, we can use a hydrator strategy, which
    will have the last chance to set a value before it goes to the model.
  prefs: []
  type: TYPE_NORMAL
- en: Now the plan is that we will create a hydrator strategy which will check our
    primary property and make sure it returns an integer. As we can see further on,
    we basically created an `extract` and a `hydrate` method, which will check if
    there is an integer as value, and if not return a random integer. This way we
    safeguard ourselves so that any value that comes in to our model is at least the
    type we expect it to be.
  prefs: []
  type: TYPE_NORMAL
- en: About models
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Models are just regular classes which differ nothing from any other class. However,
    the principle behind a model is that all the business critical logic is defined
    in them. An MVC prefers to have skinny controllers (which means no or almost no
    logic) and fat models.
  prefs: []
  type: TYPE_NORMAL
- en: Hydrators, on the other hand, are classes that are used in between models, for
    example, when exchanging data from one model to another, or from a `TableGateway`
    to a model and vice versa. Obviously not every model we write would require a
    `Hydrator`, but as applications tend to grow, we like to implement new features
    without having to change the existing ones, and `Hydrator` can then serve as a
    key factor as they can serve as a proxy between objects.
  prefs: []
  type: TYPE_NORMAL
- en: There's more…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There is a lot more to write about hydrators, and especially the different kinds
    of default hydrators that come with Zend Framework 2\. If we want to know more
    about that we should check the documentation for the `Zend\Stdlib\Hydrator\ArraySerializable`,
    `Zend\Stdlib\Hydrator\ClassMethods`, and the `Zend\Stdlib\Hydrator\ObjectProperty`
    hydrator.
  prefs: []
  type: TYPE_NORMAL
- en: A basic service
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One of the biggest features of Zend Framework 2 is the `ServiceManager` , and
    its influence in the framework can be seen from the initial bootstrap of our application.
    We don't need a reason to explain why this recipe goes deeper in this topic, do
    we?
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Again a Zend Framework 2 skeleton application should be running to make the
    full use of our examples in this recipe.
  prefs: []
  type: TYPE_NORMAL
- en: Before we continue let's get the difference between a service and a model. Although
    the definition of a service is sometimes a judgment call, it can be safely assumed
    that a service is a class between the controller and the model, which hides all
    the nasty logic from the controller, for example, checking the authentication
    or calling a method in a model. Another thing that is different is that the service
    in our case will be managed by the `ServiceManager`, and therefore, can be called
    from any controller (and other service) in our application.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Services are a great way of making sure our functionality can be accessed virtually
    anywhere in our application, and in this recipe we will show exactly how to do
    that!
  prefs: []
  type: TYPE_NORMAL
- en: Creating a service
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We will create our service in the `/module/Application/src/Application/Service/Example.php`
    file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Now the only thing that left to do is to add this service to the module configuration
    (the file is `/module/Application/config/module.config.php`), so it can be reached
    by the rest of the application as well:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'Of course, this is again a snippet to show what needs to be added to the configuration.
    We can now easily retrieve the service in, for example, a controller by performing
    the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: Getting a service from within a controller
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'This example shows that it is very easy to retrieve a service from a controller.
    From within a service we can also easily get our main application configuration
    by performing the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We created a very basic service and added it to the configuration of our `Application`
    module. The idea behind it is that we can show how easy it is to create a service,
    activate it, and use it in the application. We will create a service that is going
    to be managed by the `ServiceManager` and does nothing more than rot13 encode
    on a string.
  prefs: []
  type: TYPE_NORMAL
- en: To create a service we only need to implement the `Zend\ServiceManager\ServiceLocatorAwareInterface`
    in our class, which predefines two methods, the `getServiceLocator` and the `setServiceLocator`.
    The `setServiceLocator` is called during instantiation, and most of the time (at
    least not when we add the service in our configuration) we don't have to do this
    manually.
  prefs: []
  type: TYPE_NORMAL
- en: The `getServiceLocator` however is a method we can use to get the `ServiceLocator`,
    from which we can get useful things like other services, or perhaps the configuration
    of the application itself.
  prefs: []
  type: TYPE_NORMAL
- en: Services are instantiated either at the loading of the modules if they are in
    the module configuration, or just during some place in the application. However,
    when we instantiate the service, we know that we can always get it through the
    same easy `get()` method of the `ServiceLocator` anywhere else in the application
    once it has been instantiated.
  prefs: []
  type: TYPE_NORMAL
