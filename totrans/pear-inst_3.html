<html><head></head><body><div class="chapter" title="Chapter&#xA0;3.&#xA0;Leveraging Full Application Support with the PEAR Installer"><div class="titlepage"><div><div><h1 class="title"><a id="ch03"/>Chapter 3. Leveraging Full Application Support with the PEAR Installer</h1></div></div></div><p>In the last chapter we learned a great deal about the internals of<code class="literal"> package.xml</code>. In this chapter, we are stepping up the intensity a notch, and exploring the exciting new features that enable us to easily distribute PHP applications and manage their installation and post-installation customization.</p><p>If you've ever wanted to make it easy to customize an installation of your PHP application across multiple platforms, PHP versions, and user setups, then this is the chapter for you.</p><div class="section" title="package.xml Version 2.0: Your Sexy New Friend"><div class="titlepage"><div><div><h1 class="title"><a id="ch03lvl1sec01"/>package.xml Version 2.0: Your Sexy New Friend</h1></div></div></div><p>The title of this section says it all.<code class="literal"> package.xml 2.0</code> is a major improvement over<code class="literal"> package.xml 1.0</code>. The implementations of several important new features in the PEAR installer such as custom file roles/tasks, enterprise-level dependencies, and channels are reflected by new tags in<code class="literal"> package.xml 2.0</code>. In addition, the structure is designed to be easily validated using other tools.<a id="id101" class="indexterm"/>
</p></div></div>
<div class="section" title="PEAR Channels: A Revolution in PHP Installation"><div class="titlepage"><div><div><h1 class="title"><a id="ch03lvl1sec02"/>PEAR Channels: A Revolution in PHP Installation</h1></div></div></div><p>The smallest addition to<code class="literal"> package.xml 2.0</code> is the<code class="literal">&lt;channel&gt;</code> tag. Don't be fooled though, channels are the most significant new feature implemented in the PEAR installer. Channels are to PEAR what dependencies are to team development. By opening up the ease of the PEAR installer to sites other than <a class="ulink" href="http://pear.php.net"> pear.php.net</a>, a number of free choices have been made available to PHP users. For the first time, it is possible to design an application that depends upon packages from<code class="literal"> pear.php.net</code>,<code class="literal"> pear.example.com</code>, and any number of sites, and all of them can be automatically downloaded, installed, and easily upgraded on the end-user's computer with a single command. Although <a class="link" href="ch05.html" title="Chapter 5. Releasing to the World: PEAR Channels">Chapter 5</a> discusses the minutiae of channels and the<code class="literal"> channel.xml</code> channel definition file, it is good to have a basic understanding of how channels work when designing your packages.<a id="id102" class="indexterm"/>
</p><p>There are two problems that channels effectively solve:<a id="id103" class="indexterm"/>
</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Distributing application development across multiple development teams</li><li class="listitem" style="list-style-type: disc">Preventing conflicting packages from overwriting each other</li></ul></div><p>A user's PEAR installer can have knowledge of a channel, in this example, <a class="ulink" href="http://channelserver.example.com"> channelserver.example.com</a> via:<a id="id104" class="indexterm"/>
</p><div class="informalexample"><pre class="programlisting"><span class="strong"><strong>$ pear channel-discover channelserver.example.com
</strong></span>
</pre></div><p>Once the user's PEAR installer has this knowledge, packages from <a class="ulink" href="http://channelserver.example.com"> channelserver.example.com</a>, like a hypothetical package named <a class="ulink" href="http://Packagename"> Packagename</a> can be simply installed with:</p><div class="informalexample"><pre class="programlisting"><span class="strong"><strong>$ pear install channelserver.example.com/Packagename
</strong></span>
</pre></div><p>Users can also install packages that depend on <code class="literal"> channelserver.example.com/Packagename</code>. This was impossible before the advent of PEAR channels.<a id="id105" class="indexterm"/>
</p><p>When a user simply types the following command:</p><div class="informalexample"><pre class="programlisting"><span class="strong"><strong>$ pear install Package
</strong></span>
</pre></div><p>as they would with PEAR version 1.3.6 and older, the installer uses the<code class="literal"> default_channel</code> configuration variable, which is usually<code class="literal"> pear.php.net</code> or<code class="literal"> pecl.php.net</code> (for the<code class="literal"> pecl</code> command), and then acts as if the user had instead typed:</p><div class="informalexample"><pre class="programlisting"><span class="strong"><strong>$ pear install pear.php.net/Package
</strong></span>
</pre></div><p>In fact, every existing PEAR package Foo has now become <code class="literal"> pear.php.net/Foo</code>, effectively acting as a namespace differentiating it from <code class="literal"> channelserver.example.com/Foo</code>. This is the mechanism that channels use to prevent conflicting packages from overwriting each other. Since<code class="literal"> pear.php.net/Foo</code> is not the same package as <code class="literal"> channelserver.example.com/Foo</code>, it is not possible to<span class="emphasis"><em> upgrade</em></span> from <code class="literal"> pear.php.net/Foo</code> to <code class="literal"> channelserver.example.com/Foo</code>. For this reason, it is time for an important concept:</p><div class="note" title="Note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="tip18"/>Tip</h3><p>Even though<span class="emphasis"><em> channel names</em></span> are<span class="emphasis"><em> server names</em></span>, they also function as a classification naming scheme to differentiate packages from different sources.</p></div><p>To understand this, we need to study some of the history behind channels. In the original draft proposal describing channels, the name of a channel (as used in both installation and dependencies) and the server used to access the channel were different. For instance, the <a class="ulink" href="http://pear.php.net"> pear.php.net</a> channel was originally named the PEAR channel, so that users would type:</p><div class="informalexample"><pre class="programlisting"><span class="strong"><strong>$ pear install PEAR/Foo
</strong></span>
</pre></div><p>After a few development releases of PEAR, it became clear that this was a bad idea for several reasons, one of them being the fact that if you didn't know where to locate a channel, it simply couldn't be located. So, by the first alpha version of PEAR, 1.4.0a1, the name of the channel became the same as the server name.</p><div class="note" title="Note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="tip19"/>Tip</h3><p><span class="strong"><strong>So Do We Always Have to Type pear.php.net/Package?</strong></span></p><p>No, in fact the innovation that made it reasonable to use the server name as a channel's name was the idea of a channel alias. From the command line, we can type the following and PEAR would install <a class="ulink" href="http://pear.php.net/Package"> pear.php.net/Package</a>.</p><div class="informalexample"><pre class="programlisting"><span class="strong"><strong>$ pear install pear/Package
</strong></span>
</pre></div><p>In addition, if we wish, we can change this alias to anything we want by using the<code class="literal"> channel-alias</code> command as shown:</p><div class="informalexample"><pre class="programlisting"><span class="strong"><strong>$ pear channel-alias pear.php.net p $ pear install p/Package
</strong></span>
</pre></div><p>However, in<code class="literal"> package.xml's &lt;channel&gt;</code> and other tags, the full channel server name always must be used, aliases are never allowed.</p></div><p>The switch to using the server name as the channel name has another desirable consequence. Originally, it was possible to change the server associated with the channel transparently. This is a bad idea on many levels! Firstly, this meant that a malicious coder could quite easily override the conflict protections in the PEAR channel simply by changing the server that the PEAR channel uses to get package information. Secondly, by supplying identically-named packages to the ones available at <a class="ulink" href="http://pear.php.net"> pear.php.net</a> with malevolent code hidden inside, it would even be possible to fool the user into using malicious code without their knowledge.<a id="id106" class="indexterm"/>
</p><p>By using the server name as the channel name, this is no longer possible without an old-fashioned hacking attack against the original channel server, something that is bound to be noticed pretty quickly.</p><p>In short, the strength of channels lies not just in their ease of use for the end user and flexibility for the developer, but in the extensive security considerations that have gone into their design. As evidenced by recent security flaws in major PHP packages such as XML_RPC and phpBB, one cannot be too careful. At PEAR, security is deadly serious, and the developers have gone to great lengths to ensure that PEAR is hack-proof.</p></div>
<div class="section" title="Application Support"><div class="titlepage"><div><div><h1 class="title"><a id="ch03lvl1sec03"/>Application Support</h1></div></div></div><p>So far, we have learned that the PEAR installer was designed to support libraries first, and then application support was added in PEAR version 1.4.0. Let's take a closer look at what that specifically means by examining four exciting new features: custom file roles, custom file tasks, post-installation scripts, and the ability to bundle several packages into a single archive.<a id="id107" class="indexterm"/>
</p><p>In this section, we will explore the details of these features by creating a new custom file role<code class="literal"> chiaramdb2schema</code>, a custom file task<code class="literal"> chiara-managedb</code>, a post-install script to populate needed data, and a sample application. We'll then distribute the role and task in a single archive.</p><div class="note" title="Note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="tip20"/>Tip</h3><p>Before we begin, you need to examine one vital point:</p><p>What problem are you solving? Should you use a custom file role, custom file task, post-install script, or something else?</p></div><p>Custom file roles are designed to group related file classes together. If, for instance, you wish to install all web-based image files in a different way from web-based JavaScript files, custom file roles are the best way to do this.<a id="id108" class="indexterm"/>
</p><p>Custom file tasks are designed to manipulate the contents of individual files prior to installation or prior to packaging. If you need to convert a generic template into a machine-specific file (such as a generic database creation SQL file into a MySQL-specific or Oracle-specific SQL file), custom tasks are a very good choice.<a id="id109" class="indexterm"/>
</p><p>Post-installation scripts are designed to allow any other advanced configuration that the user must perform before the package will be ready for use.</p><p>Our sample file role and task are designed for a single-user situation. On a shared host, this must be done with a post-installation script, and so we will provide one to allow systems administrators to maintain multiple database installs of a package.</p><div class="note" title="Note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="tip21"/>Tip</h3><p><span class="strong"><strong>Naming Conventions for Custom File Roles/Tasks</strong></span></p><p>It is a very good idea to use a custom prefix for all functionality that extends the PEAR Installer. In our examples, if we were to name the role<code class="literal"> sql</code> instead of<code class="literal"> chiara_sql</code> and the task<code class="literal"> updatedb</code> instead of<code class="literal"> chiara_updatedb</code>, there is a risk of conflicting with an official custom role or task distributed from <a class="ulink" href="http://pear.php.net"> pear.php.net</a>. In particular, should any role or task be deemed useful enough to be implemented as a default part of the PEAR installer, users of your custom role/task would be unable to upgrade their PEAR installations unless they uninstalled the role and every package that depends on it.</p></div><div class="section" title="Introduction to Custom File Roles"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec01"/>Introduction to Custom File Roles</h2></div></div></div><p>File roles are used to group related files together to handle installation. The standard file roles are<code class="literal"> php, data, doc, test, script, src</code>, and<code class="literal"> ext</code>. Each of these roles is handled differently by the installer. A file specified by a tag such as this one in a package named<code class="literal"> My_Package</code> will be installed in<code class="literal"> My/Package/foo.php</code>.<a id="id110" class="indexterm"/>
</p><div class="informalexample"><pre class="programlisting">&lt;file name="foo.php" role="php" baseinstalldir="My/Package"/&gt;
</pre></div><p>However, the same tag with a role of<code class="literal"> data</code> prompts the installer to act very differently. Instead of being installed in<code class="literal"> My/Package/foo.php</code>, this file will be installed in<code class="literal"> My_Package/foo.php</code>.</p><div class="informalexample"><pre class="programlisting">&lt;file name="foo.php" role="data" baseinstalldir="My/Package"/&gt;
</pre></div><p>The<code class="literal"> baseinstalldir</code> attribute is ignored by the<code class="literal"> data, doc</code>, and<code class="literal"> test</code> roles, which are instead installed into<code class="literal">&lt;package name&gt;/path/to/file</code> as defined by the relative path in<code class="literal"> package.xml</code>.</p><p>In addition, each role determines where to install files from a different<code class="literal"> config</code> variable. The<code class="literal"> role: configuration</code> variable mapping is as follows:<a id="id111" class="indexterm"/>
</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">php: php_dir</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">data: data_dir</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">doc: doc_dir</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">test: test_dir</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">script: bin_dir</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">ext: ext_dir</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">src: &lt;none&gt;</code> (not installed)</li></ul></div><p>Generally speaking, configuration variables are the same as the file role with<code class="literal"> _dir</code> appended, with the exception of<code class="literal"> role="script"</code>, which is to be appended with<code class="literal"> bin_dir</code>. In addition, note that files with<code class="literal"> role="src"</code> are not actually installed. Instead, these files are extracted and then compiled to create extension binaries, and then discarded. Each of these roles has a set of characteristics that differentiate it from other roles:<a id="id112" class="indexterm"/>
</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Some are valid for PHP packages, others for extension packages</li><li class="listitem" style="list-style-type: disc">Some are installed, others are not</li><li class="listitem" style="list-style-type: disc">Installable roles have a configuration variable that determines where they should be installed</li><li class="listitem" style="list-style-type: disc">Some honor the<code class="literal"> baseinstalldir</code> attribute, others don't</li><li class="listitem" style="list-style-type: disc">Some install into<code class="literal">&lt;packagename&gt;/path</code> and others don't</li><li class="listitem" style="list-style-type: disc">Some represent PHP scripts</li><li class="listitem" style="list-style-type: disc">Some represent executable files (like scripts)</li><li class="listitem" style="list-style-type: disc">Some represent PHP extension binaries</li></ul></div><p>These characteristics are all that is needed to define customized file roles. In fact, the existing file roles are defined using these traits and special objects. For instance, the code to define the PHP role is:<a id="id113" class="indexterm"/>
</p><div class="informalexample"><pre class="programlisting">&lt;?php
/**
* PEAR_Installer_Role_Php
*
* PHP versions 4 and 5
*
* LICENSE: This source file is subject to version 3.0 of the PHP
* license
* that is available through the world-wide-web at the following URI:
* http://www.php.net/license/3_0.txt. If you did not receive a copy
* of the PHP License and are unable to obtain it through the web,
* please send a note to license@php.net so we can mail you a copy
* immediately.
*
* @category pear
* @package PEAR
* @author Greg Beaver &lt;cellog@php.net&gt;
* @copyright 1997-2005 The PHP Group
* @license http://www.php.net/license/3_0.txt PHP License 3.0
* @version CVS: $Id: Php.php,v 1.5 2005/07/28 16:51:53 cellog Exp
$
* @link http://pear.php.net/package/PEAR
* @since File available since Release 1.4.0a1
*/
/**
* @category pear
* @package PEAR
* @author Greg Beaver &lt;cellog@php.net&gt;
* @copyright 1997-2005 The PHP Group
* @license http://www.php.net/license/3_0.txt PHP License 3.0
* @version Release: @package_version@
* @link http://pear.php.net/package/PEAR
* @since Class available since Release 1.4.0a1
*/
class PEAR_Installer_Role_Php extends PEAR_Installer_Role_Common {}
?&gt;
<a id="id114" class="indexterm"/>
</pre></div><p>For most roles, this is the only code that needs to be defined! In addition to this PHP code, however, an XML file should be installed that documents the properties of a role. The XML file for the PHP role is as follows:<a id="id115" class="indexterm"/>
</p><div class="informalexample"><pre class="programlisting">&lt;role version="1.0"&gt;
&lt;releasetypes&gt;php&lt;/releasetypes&gt;
&lt;releasetypes&gt;extsrc&lt;/releasetypes&gt;
&lt;releasetypes&gt;extbin&lt;/releasetypes&gt;
&lt;installable&gt;1&lt;/installable&gt;
&lt;locationconfig&gt;php_dir&lt;/locationconfig&gt;
&lt;honorsbaseinstall&gt;1&lt;/honorsbaseinstall&gt;
&lt;unusualbaseinstall /&gt;
&lt;phpfile&gt;1&lt;/phpfile&gt;
&lt;executable /&gt;
&lt;phpextension /&gt;
&lt;config_vars /&gt;
&lt;/role&gt;
</pre></div><p>The various tags are as follows:<a id="id116" class="indexterm"/>
</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">&lt;releasetypes&gt;:</code> This tag works like an array, whose contents define which release types are allowed to contain this role. The list of possible release types is<code class="literal"> php, extsrc, extbin</code>, or<code class="literal"> bundle</code>.</li><li class="listitem" style="list-style-type: disc"><code class="literal">&lt;installable&gt;:</code> This Boolean value determines whether a role is installed to disk or not.</li><li class="listitem" style="list-style-type: disc"><code class="literal">&lt;locationconfig&gt;:</code> For installable roles, this string value determines which configuration variable to use for installing the file.</li><li class="listitem" style="list-style-type: disc"><code class="literal">&lt;honorsbaseinstall&gt;:</code> This Boolean value (represented as 1 or an empty tag) determines whether<code class="literal"> baseinstalldir</code> is used in calculating the final installation location.</li><li class="listitem" style="list-style-type: disc"><code class="literal">&lt;unusualbaseinstall&gt;:</code> This Boolean value (represented as 1 or an empty tag) determines whether the package name is prepended to the installation path.</li><li class="listitem" style="list-style-type: disc"><code class="literal">&lt;phpfile&gt;:</code> This Boolean value (represented as 1 or an empty tag) determines whether a file is treated as a PHP file (analyzed at packaging time for valid PHP/class names/function names).</li><li class="listitem" style="list-style-type: disc"><code class="literal">&lt;executable&gt;:</code> This Boolean value (represented as 1 or an empty tag) determines whether a file is installed with the executable attribute on UNIX-based systems.</li><li class="listitem" style="list-style-type: disc"><code class="literal">&lt;phpextension&gt;:</code> This Boolean value (represented as 1 or an empty tag) determines whether the installer will display a helpful error message if overwriting an existing extension binary fails due to file locking.<a id="id117" class="indexterm"/></li></ul></div><div class="section" title="Creating PEAR_Installer_Role_Chiaramdb2schema Custom Role"><div class="titlepage"><div><div><h3 class="title"><a id="ch03lvl3sec01"/>Creating PEAR_Installer_Role_Chiaramdb2schema Custom Role</h3></div></div></div><p>First, it is important to understand how this role is used in<code class="literal"> package.xml</code>. In order to implement a custom role,<code class="literal"> package.xml</code> validation should be able to tell a user where to download and install it, as dependency validation occurs only after the<code class="literal"> package.xml</code> file has been validated from a basic structural standpoint.<a id="id118" class="indexterm"/>
</p><div class="informalexample"><pre class="programlisting">&lt;package&gt;
&lt;name&gt;Role_Chiaramdb2schema&lt;/name&gt;
&lt;channel&gt;pear.chiaraquartet.net&lt;/channel&gt;
&lt;/package&gt;
</pre></div><p>As such, in addition to a package dependency<code class="literal"> package.xml</code> should also contain the<code class="literal">&lt;usesrole&gt;</code> tag describing the name of a custom file role that is used, and the remote location of the package containing this role. For our example this will be as follows:<a id="id119" class="indexterm"/>
</p><div class="informalexample"><pre class="programlisting">&lt;usesrole&gt;
&lt;role&gt;chiaramdb2schema&lt;/role&gt;
&lt;package&gt;Role_Chiaramdb2schema&lt;/package&gt;
&lt;channel&gt;pear.chiaraquartet.net&lt;/channel&gt;
&lt;/usesrole&gt;
</pre></div><p>This tag will prompt the installer to first check if the<code class="literal"> pear.chiaraquartet.net/Role_Chiaramdb2schemaql</code> package is installed. If not, the installer will issue a warning:</p><div class="informalexample"><pre class="programlisting"><span class="strong"><strong>This package contains role "chiaramdb2schema" and requires package "pear.chiaraquartet.net/Role_Chiaramdb2schema" to be used
</strong></span>
</pre></div><div class="note" title="Note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="tip22"/>Tip</h3><p><span class="strong"><strong>Why Use &lt;usesrole&gt;/&lt;usestask&gt; in Addition to a Dependency?</strong></span></p><p>The PEAR installer cannot successfully configure roles or tasks once installation has begun. They must be installed and configured prior to any attempt to install a package that uses them. For this reason, installation of custom roles or tasks must be performed in a separate process from the packages that use them.</p></div><p>To use a custom role inside the<code class="literal">&lt;file&gt;</code> tag is no different from any regular role.</p><div class="informalexample"><pre class="programlisting">&lt;file name="dbcontents.xml" role="chiaramdb2schema"/&gt;
</pre></div><p>All custom file roles are implemented in a single PHP file that is installed into the<code class="literal"> PEAR/Installer/Role/</code> directory. So, for instance, the<code class="literal"> data</code> role is located in<code class="literal"> PEAR/Installer/Role/Data.php</code>. Unlike custom tasks, custom file roles cannot be in subdirectories, so prefixing should be done without underscores to match the PEAR naming conventions. In addition, every custom role must extend the<code class="literal"> PEAR_Installer_Role_Common</code> class, which is found in<code class="literal"> PEAR/Installer/Role/Common.php</code>.</p><p>Our custom file role uses the<code class="literal"> data_dir</code> configuration variable to determine installation location, and so in terms of installation it acts exactly like the<code class="literal"> data</code> role. However, it does a magical thing through this XML in the<code class="literal"> Chiaramdb2schema.xml</code> file:<a id="id120" class="indexterm"/>
</p><div class="informalexample"><pre class="programlisting">&lt;config_vars&gt;
&lt;chiaramdb2schema_driver&gt;
&lt;type&gt;string&lt;/type&gt;
&lt;default /&gt;
&lt;doc&gt;MDB2 database driver used to connect to the database&lt;/doc&gt;
&lt;prompt&gt;Database driver type. This must be a valid MDB2 driver.
Example drivers are mysql, mysqli, pgsql, sqlite, and so on&lt;/prompt&gt;
&lt;group&gt;Database&lt;/group&gt;
&lt;/chiaramdb2schema_driver&gt;
&lt;chiaramdb2schema_dsn&gt;
&lt;type&gt;string&lt;/type&gt;
&lt;default /&gt;
&lt;doc&gt;PEAR::MDB2 dsn string[s] for database connection, separated
by ;.
This must be of format:
[user@]host/dbname[;[Package[#schemafile]::]dsn2...]
One default database connection must be specified, and package-
specific databases
may be specified. The driver type and password should be excluded.
Passwords
are set with the chiaramdb2schema_password config variable
&lt;/doc&gt;
&lt;prompt&gt;Database connection DSN[s] (no driver/password)&lt;/prompt&gt;
&lt;group&gt;Database&lt;/group&gt;
&lt;/chiaramdb2schema_dsn&gt;
&lt;chiaramdb2schema_password&gt;
&lt;type&gt;string&lt;/type&gt;
&lt;default /&gt;
&lt;doc&gt;PEAR::MDB2 dsn password[s] for database connection.
This must be of format: password[:password...]
Each DSN in chiaramdb2schema_dsn must match with a password in this
list, or
none will be used. To use no password, simply put another :: like
::::
&lt;/doc&gt;
&lt;prompt&gt;Database connection password[s]&lt;/prompt&gt;
&lt;group&gt;Database&lt;/group&gt;
&lt;/chiaramdb2schema_password&gt;
&lt;/config_vars&gt;
</pre></div><p>By defining the<code class="literal">&lt;config_vars&gt;</code> tag in this way, three entirely new configuration variables will be added to the PEAR configuration. They are manipulated in the same manner as any other configuration variable, and provide the information that will make our<code class="literal"> chiaramdb2schema</code> role something special.<a id="id121" class="indexterm"/>
</p><p>Our role takes advantage of the fact that MDB2-based schema files are a special sub-class of data files by directly extending the<code class="literal"> PEAR_Installer_Role_Data</code> class. Here is the complete source code for our example role:<a id="id122" class="indexterm"/>
</p><div class="informalexample"><pre class="programlisting">&lt;?php
/**
* Custom file role for MDB2_Schema-based database setup files
*
* This file contains the PEAR_Installer_Role_Chiaramdb2schema file * role
*
* PHP versions 4 and 5
*
* @package Role_Chiaramdb2schema
* @author Greg Beaver &lt;cellog@php.net&gt;
* @copyright 2005 Gregory Beaver
* @license http://www.opensource.org/licenses/bsd-license.php BSD
* License
* @version Release: 0.2.0
* @link
http://pear.chiaraquartet.net/index.php?package=Role_Chiaramdb2schema
*/
/**
* Contains the PEAR_Installer_Role_Data class
*/
require_once 'PEAR/Installer/Role/Data.php';
/**
* chiaramdb2schema Custom file role for MDB2_Schema-based database
* setup files
*
* This file role provides the &lt;var&gt;chiaramdb2schema_driver&lt;/var&gt;,
* &lt;var&gt;chiaramdb2schema_dsn&lt;/var&gt;, and
&lt;var&gt;chiaramdb2schema_password&lt;/var&gt;
* configuration variables for use by the chiara-managedb custom task
* to set up and initialize database files
*
* PHP versions 4 and 5
*
* @package Role_Chiaramdb2schema
* @author Greg Beaver &lt;cellog@php.net&gt;
* @copyright 2005 Gregory Beaver
* @license http://www.opensource.org/licenses/bsd-license.php BSD
* License
* @version Release: 0.2.0
* @link http://pear.chiaraquartet.net/index.php?package=Role_Chiaramdb2schema
*/
class PEAR_Installer_Role_Chiaramdb2schema extends
PEAR_Installer_Role_Data
{
}
?&gt;
</pre></div><p>And the<code class="literal"> Chiaramdb2schema.xml</code> file that accompanies this role:<a id="id123" class="indexterm"/>
</p><div class="informalexample"><pre class="programlisting">&lt;role version="1.0"&gt;
&lt;releasetypes&gt;php&lt;/releasetypes&gt;
&lt;releasetypes&gt;extsrc&lt;/releasetypes&gt;
&lt;releasetypes&gt;extbin&lt;/releasetypes&gt;
&lt;installable&gt;1&lt;/installable&gt;
&lt;locationconfig&gt;data_dir&lt;/locationconfig&gt;
&lt;honorsbaseinstall /&gt;
&lt;unusualbaseinstall /&gt;
&lt;phpfile /&gt;
&lt;executable /&gt;
&lt;phpextension /&gt;
&lt;config_vars&gt;
&lt;chiaramdb2schema_driver&gt;
&lt;type&gt;string&lt;/type&gt;
&lt;default /&gt;
&lt;doc&gt;MDB2 database driver used to connect to the database&lt;/doc&gt;
&lt;prompt&gt;Database driver type. This must be a valid MDB2 driver.
Example drivers are mysql, mysqli, pgsql, sqlite, and so on&lt;/prompt&gt;
&lt;group&gt;Database&lt;/group&gt;
&lt;/chiaramdb2schema_driver&gt;
&lt;chiaramdb2schema_dsn&gt;
&lt;type&gt;string&lt;/type&gt;
&lt;default /&gt;
&lt;doc&gt;PEAR::MDB2 dsn string[s] for database connection, separated
by ;.
This must be of format:
[user@]host/dbname[;[Package[#schemafile]::]dsn2...]
One default database connection must be specified, and package-
specific databases
may be specified. The driver type and password should be excluded.
Passwords
are set with the chiaramdb2schema_password config variable
&lt;/doc&gt;
&lt;prompt&gt;Database connection DSN[s] (no driver/password)&lt;/prompt&gt;
&lt;group&gt;Database&lt;/group&gt;
&lt;/chiaramdb2schema_dsn&gt;
&lt;chiaramdb2schema_password&gt;
&lt;type&gt;string&lt;/type&gt;
&lt;default /&gt;
&lt;doc&gt;PEAR::MDB2 dsn password[s] for database connection.
This must be of format: password[:password...]
Each DSN in chiaramdb2schema_dsn must match with a password in this
list, or
none will be used. To use no password, simply put another :: like
::::
&lt;/doc&gt;
&lt;prompt&gt;Database connection password[s]&lt;/prompt&gt;
&lt;group&gt;Database&lt;/group&gt;
&lt;/chiaramdb2schema_password&gt;
&lt;/config_vars&gt;
&lt;/role&gt;
</pre></div><p>That's it! Now that we've seen how to implement a simple role, let's examine the range of possibility built into the design of custom file roles.</p></div><div class="section" title="Full Range of Possible Custom File Roles"><div class="titlepage"><div><div><h3 class="title"><a id="ch03lvl3sec02"/>Full Range of Possible Custom File Roles</h3></div></div></div><p>Most custom file roles will only need to specify configuration variables and attributes as described in previous sections. However, sometimes this is not enough, and some unusual setup is required. The protected<code class="literal"> setup()</code> method of the base class<code class="literal"> PEAR_Installer_Role_Common</code> is provided specifically to allow file roles to perform any unusual setup functionality needed. The method signature is:<a id="id124" class="indexterm"/>
</p><div class="informalexample"><pre class="programlisting">/**
* Do any unusual setup here
* @param PEAR_Installer
* @param PEAR_PackageFile_v2
* @param array file attributes
* @param string file name
*/
function setup(&amp;$installer, $pkg, $atts, $file)
</pre></div><p>The parameters are pretty straightforward:<a id="id125" class="indexterm"/>
</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">PEAR_Installer $installer:</code> This allows any specialized installation tasks to be done through the public API of the<code class="literal"> PEAR_Installer</code> class.</li><li class="listitem" style="list-style-type: disc"><code class="literal">PEAR_PackageFile_v2 $pkg:</code> This allows retrieval of any information from the<code class="literal"> package.xml</code> that may be useful to the custom role. Note that the<code class="literal"> PEAR_PackageFile_v2</code> class's public API is read-only.</li><li class="listitem" style="list-style-type: disc"><code class="literal">array $atts:</code> This is the file attribute as parsed from<code class="literal"> package.xml</code>, in a format similar to the following:<div class="informalexample"><pre class="programlisting">array(
'name' =&gt; 'Full/Path/To/File.php',
'role' =&gt; 'customrolename',
'baseinstalldir' =&gt; 'Whatever',
);
</pre></div></li><li class="listitem" style="list-style-type: disc"><code class="literal">string $file:</code> This is the file name.</li></ul></div><p>Note that the<code class="literal"> setup()</code> method is called for every role just prior to any installation location calculations. In addition, the current<code class="literal"> PEAR_Config</code> configuration object is available via the<code class="literal"> $this-&gt;config</code> member.</p><p>Also important to explore is the manner in which custom file roles's configuration variables are defined.</p><p>The<code class="literal">&lt;config_vars&gt;</code> tag defines configuration variables. Each configuration variable is declared using a tag with its name. If you wish to create a simple configuration variable named<code class="literal"> foo</code>, you would use this XML:<a id="id126" class="indexterm"/>
</p><div class="informalexample"><pre class="programlisting">&lt;config_vars&gt;
&lt;foo&gt;
&lt;type&gt;string&lt;/type&gt;
&lt;default /&gt;
&lt;doc&gt;Foo configuration&lt;/doc&gt;
&lt;prompt&gt;Foo protocol login&lt;/prompt&gt;
&lt;group&gt;Auth&lt;/group&gt;
&lt;/foo&gt;
&lt;/config_vars&gt;
</pre></div><p>Legal configuration types are<code class="literal"> string, directory, file, set</code>, and<code class="literal"> password</code>. If you wish to limit possible input to specified values, you also need to define the set of valid values using the<code class="literal">&lt;valid_set&gt;</code> tag:</p><div class="informalexample"><pre class="programlisting">&lt;config_vars&gt;
&lt;foo&gt;
&lt;type&gt;set&lt;/type&gt;
&lt;default /&gt;
&lt;doc&gt;Foo configuration&lt;/doc&gt;
&lt;valid_set&gt;bar&lt;/valid_set&gt;
&lt;valid_set&gt;baz&lt;/valid_set&gt;
&lt;valid_set&gt;gronk&lt;/valid_set&gt;
&lt;prompt&gt;Foo protocol type&lt;/prompt&gt;
&lt;group&gt;Auth&lt;/group&gt;
&lt;/foo&gt;
&lt;/config_vars&gt;
</pre></div><p>Take a look in the<code class="literal"> PEAR/Config.php</code> file for examples of existing configuration variable groups. This variable is for informational purposes, and can be anything you wish it to be.<a id="id127" class="indexterm"/>
</p><p>The<code class="literal">&lt;default&gt;</code> tag, on the other hand, has a large range of possibilities. There are three kinds of values that can be accessed to set the default value of a configuration variable:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Default values of existing configuration variables</li><li class="listitem" style="list-style-type: disc">PHP constants</li><li class="listitem" style="list-style-type: disc">Any text</li></ul></div><p>In order to retrieve the default value of the<code class="literal"> php_dir</code> configuration variable, you would use this tag:</p><div class="informalexample"><pre class="programlisting">&lt;default&gt;&lt;php_dir/&gt;&lt;/default&gt;
</pre></div><p>Only built-in configuration variables may be accessed for their default values. To access a PHP constant like the<code class="literal"> PHP_OS</code> constant, use this tag:</p><div class="informalexample"><pre class="programlisting">&lt;default&gt;&lt;constant&gt;PHP_OS&lt;/constant&gt;&lt;/default&gt;
</pre></div><p>Note that any constant defined in<code class="literal"> PEAR/Common.php</code> or<code class="literal"> PEAR/Config.php</code> will also be available for use as a default value. Finally, straight text may be used like so:</p><div class="informalexample"><pre class="programlisting">&lt;default&gt;&lt;text&gt;hello world&lt;/text&gt;&lt;/default&gt;
</pre></div><p>In order to combine several of these, simply use them in the desired sequence:</p><div class="informalexample"><pre class="programlisting">&lt;default&gt;&lt;php_dir/&gt;&lt;constant&gt;DIRECTORY_SEPARATOR&lt;/constant&gt; &lt;text&gt;foo&lt;/text&gt;&lt;/default&gt;
</pre></div><p>If you wish to use multiple constants or multiple texts, append a number to the end of the tag name like so:</p><div class="informalexample"><pre class="programlisting">&lt;default&gt;&lt;text1&gt;.&lt;/text1&gt;&lt;constant&gt;PATH_SEPARATOR&lt;/constant&gt; &lt;text2&gt;mychannel&lt;/text2&gt;&lt;/default&gt;
</pre></div></div></div><div class="section" title="Introduction to Custom File Tasks"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec02"/>Introduction to Custom File Tasks</h2></div></div></div><p>There are three custom file tasks bundled with PEAR and one script task (post-install scripts are discussed in the next section). The tasks are as follows:<a id="id128" class="indexterm"/>
</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">&lt;tasks:replace/&gt;:</code> Performs a basic<code class="literal"> str_replace</code> on installed or packaged files. Possible replacement values are information from<code class="literal"> package.xml</code>, information from PEAR's configuration such as the value of<code class="literal"> php_dir</code>, or PHP constants like<code class="literal"> PHP_OS</code>.</li><li class="listitem" style="list-style-type: disc"><code class="literal">&lt;tasks:windowseol/&gt;:</code> This converts all line endings to Windows<code class="literal">"\r\n"</code> line endings.</li><li class="listitem" style="list-style-type: disc"><code class="literal">&lt;tasks:unixeol/&gt;:</code> This converts all line endings to UNIX<code class="literal">"\n"</code> line endings</li></ul></div><p>In this section, we will examine how these tasks are defined inside the PEAR code, and how to create your own custom file tasks.</p><p>File tasks are generally used to manipulate the contents of files prior to installation. However, this is only limited by your imagination. In our example, we will use a task to create and update a database's structure on upgrade using the<code class="literal"> chiaramdb2schema</code> file role that we created earlier. This task is a very advanced task, performing sophisticated processing, and as such shows the versatility of such a system.<a id="id129" class="indexterm"/>
</p><p>The only constraint on the XML content of custom tasks is that the task's namespace (normally<code class="literal"> tasks)</code> must prefix each tag. Validation is controlled with the PHP code for each task. A custom file task must extend<code class="literal"> PEAR_Task_Common</code>, and must reside in the<code class="literal"> PEAR/Task/</code> subdirectory of PEAR. Unlike custom file roles, custom file tasks can support subdirectories directly by using underscores. In our example file task,<code class="literal"> chiara-managedb</code>, the class name is<code class="literal"> PEAR_Task_Chiara_Managedb</code>, and this is found in file<code class="literal"> PEAR/Task/Chiara/Managedb.php</code>.<a id="id130" class="indexterm"/>
</p><p>There are three kinds of custom file tasks: single, <span class="strong"><strong>multiple, and script. Single tasks</strong></span> perform their operations on a single file, and are executed just prior to installation of the file. Multiple tasks operate on every file containing the task, and are executed after installation is completed. Script tasks are executed after installation using the<code class="literal"> run-scripts</code> command, and are covered in detail in the next section on post-installation scripts. In addition, the order in which tasks appear in a file tag is important. The following possible but illogical task ordering will result in occurrences of<code class="literal"> @blah@</code> within<code class="literal"> foo.php</code> being replaced with the contents of the<code class="literal"> data_dir</code> configuration variable.<a id="id131" class="indexterm"/>
</p><div class="informalexample"><pre class="programlisting">&lt;file name="foo.php" role="php"&gt;
&lt;tasks:replace from="@blah@" to="data_dir" type="pear-config"/&gt;
&lt;tasks:replace from="@blah@" to="version" type="package-info"/&gt;
&lt;/file&gt;
</pre></div><p>However, the opposite ordering will result in occurrences of<code class="literal"> @blah@</code> within<code class="literal"> foo.php</code> being replaced with the contents of the<code class="literal">&lt;version&gt;</code> tag from<code class="literal"> package.xml</code>.</p><div class="informalexample"><pre class="programlisting">&lt;file name="foo.php" role="php"&gt;
&lt;tasks:replace from="@blah@" to="version" type="package-info"/&gt;
&lt;tasks:replace from="@blah@" to="data_dir" type="pear-config"/&gt;
&lt;/file&gt;
</pre></div><p>In addition, single tasks can be executed when packaging. In other words, some tasks do not depend on the state of the client machine in order to execute. An example is the<code class="literal"> replace</code> task. The<code class="literal"> package-info</code> replacement only depends on the contents of the<code class="literal"> package.xml</code> file, which is known at the time of<code class="literal"> pear package</code>. The time at which a task is executed is referred to as the install phase of the task. Currently recognized install phases are install and package. A custom task can control its install phase with the<code class="literal"> $phase</code> property. There are three constants defined:<a id="id132" class="indexterm"/>
</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">PEAR_TASK_INSTALL:</code> Installation phase</li><li class="listitem" style="list-style-type: disc"><code class="literal">PEAR_TASK_PACKAGE:</code> Packaging phase</li><li class="listitem" style="list-style-type: disc"><code class="literal">PEAR_TASK_PACKAGEANDINSTALL:</code> Both installation and packaging phase</li></ul></div><p>So, for instance, the phase declaration for the<code class="literal"> windowseol</code> task is:</p><div class="informalexample"><pre class="programlisting">var $phase = PEAR_TASK_PACKAGEANDINSTALL;
</pre></div><p>The actual installation phase is set by the constructor of<code class="literal"> PEAR_Task_Common</code>, and can be accessed through the<code class="literal"> $installphase</code> property. The only legal values are<code class="literal"> PEAR_TASK_INSTALL</code> and<code class="literal"> PEAR_TASK_PACKAGE</code>. This member is used, for instance, to determine which replacements should occur. For instance, if<code class="literal"> $this-&gt;installphase</code> is<code class="literal"> PEAR_TASK_PACKAGE</code>, then<code class="literal"> pear-config</code> and<code class="literal"> php-const</code> replacements are not performed.</p><p>Perhaps the best introduction to custom file tasks is with some of the simpler tasks distributed in the PEAR package itself. The simplest tasks are the<code class="literal">&lt;tasks:windowseol/&gt;</code> and<code class="literal">&lt;tasks:unixeol/&gt;</code> tasks. These will process the contents of their file and convert line endings to Windows format, or to UNIX format. Here is the complete source code for the<code class="literal"> windowseol</code> task:<a id="id133" class="indexterm"/>
</p><div class="informalexample"><pre class="programlisting">&lt;?php
/**
* &lt;tasks:windowseol&gt;
*
* PHP versions 4 and 5
*
* LICENSE: This source file is subject to version 3.0 of the PHP
* license that is available through the world-wide-web at the * following URI:
* http://www.php.net/license/3_0.txt. If you did not receive a copy * of the PHP License and are unable to obtain it through the web,
* please send a note to license@php.net so we can mail you a copy
immediately.
*
* @category pear
* @package PEAR
* @author Greg Beaver &lt;cellog@php.net&gt;
* @copyright 1997-2005 The PHP Group
* @license http://www.php.net/license/3_0.txt PHP License 3.0
* @version CVS: $Id: Windowseol.php,v 1.6 2005/10/02 06:29:39
cellog Exp $
* @link http://pear.php.net/package/PEAR
* @since File available since Release 1.4.0a1
*/
/**
* Base class
*/
require_once 'PEAR/Task/Common.php';
/**
* Implements the windows line endings file task.
* @category pear
* @package PEAR
* @author Greg Beaver &lt;cellog@php.net&gt;
* @copyright 1997-2005 The PHP Group
* @license http://www.php.net/license/3_0.txt PHP License 3.0
* @version Release: @package_version@
* @link http://pear.php.net/package/PEAR
* @since Class available since Release 1.4.0a1
*/
class PEAR_Task_Windowseol extends PEAR_Task_Common
{
var $type = 'simple';
var $phase = PEAR_TASK_PACKAGE;
var $_replacements;
/**
* Validate the raw xml at parsing-time.
* @param PEAR_PackageFile_v2
* @param array raw, parsed xml
* @param PEAR_Config
* @static
*/
function validateXml($pkg, $xml, &amp;$config, $fileXml)
{
if ($xml != '') {
return array(PEAR_TASK_ERROR_INVALID, 'no attributes allowed');
}
return true;
}
/**
* Initialize a task instance with the parameters
* @param array raw, parsed xml
* @param unused
*/
function init($xml, $attribs)
{
}
/**
* Replace all line endings with windows line endings
*
* See validateXml() source for the complete list of allowed
fields
* @param PEAR_PackageFile_v1|PEAR_PackageFile_v2
* @param string file contents
* @param string the eventual final file location (informational
only)
* @return string|false|PEAR_Error false to skip this file,
PEAR_Error to fail
* (use $this-&gt;throwError), otherwise return the new contents
*/
function startSession($pkg, $contents, $dest)
{
$this-&gt;logger-&gt;log(3, "replacing all line endings with \\r\\n in $dest");
return preg_replace("/\r\n|\n\r|\r|\n/", "\r\n", $contents);
}
}
?&gt;
</pre></div><p>As you can see, the primary operation performed is in the<code class="literal"> startSession()</code> method. For most tasks, this is sufficient. Next, let's create our own custom file task!</p><div class="section" title="Creating the PEAR_Task_Chiara_Managedb Custom Task"><div class="titlepage"><div><div><h3 class="title"><a id="ch03lvl3sec03"/>Creating the PEAR_Task_Chiara_Managedb Custom Task</h3></div></div></div><p>The first step in creating our task is to determine the desired purpose of the task. In our case, we can sum up the desired purpose with a problem that needs to be solved.<a id="id134" class="indexterm"/>
</p><div class="note" title="Note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="tip23"/>Tip</h3><p>
THE PROBLEM:Installing and updating a database used by the package is a tedious process that should be automated.</p></div><p>More specifically, we need a solution that can perform these tasks:<a id="id135" class="indexterm"/>
</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Create a database from scratch on a fresh installation of the package</li><li class="listitem" style="list-style-type: disc">Update an existing database structure to reflect any changes in a new version of the package upon upgrading the package</li><li class="listitem" style="list-style-type: disc">Operate with a large variety of databases, and easily manage migration to a different database at a future date</li><li class="listitem" style="list-style-type: disc">Operate on different databases for different packages, as controlled by the user<a id="id136" class="indexterm"/></li></ul></div><p>In order to satisfy these constraints, we will be taking advantage of the MDB2_Schema package, available at <a class="ulink" href="http://pear.php.net/MDB2_Schema"> http://pear.php.net/MDB2_Schema</a>. This package provides a number of distinct advantages over any custom solution we could design from scratch:<a id="id137" class="indexterm"/>
</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">MDB2 supports a wide variety of database drivers.</li><li class="listitem" style="list-style-type: disc">The XML schema format used to describe a database structure is database-independent, allowing users of any database MDB2 supports to use a package that uses this task.</li><li class="listitem" style="list-style-type: disc">There is a wide user base and several active maintainers helping to ensure that the package performs as advertised.</li><li class="listitem" style="list-style-type: disc">The<code class="literal"> MDB2_Schema::updateDatabase()</code> method is capable of performing a sophisticated update of a database by comparing two schema files.</li></ul></div><p>In addition, we will rely upon a less-than-optimal solution to satisfy the need for different databases per package: we will use a required format for the configuration variables provided by the<code class="literal"> chiaramdb2schema</code> role.<a id="id138" class="indexterm"/>
</p><p>In order to determine whether the task needs a unique database for the package, we will add an optional attribute named<code class="literal"> unique</code> to the XML. As such, the three legal possibilities for our task in<code class="literal"> package.xml</code> will be:</p><div class="informalexample"><pre class="programlisting">&lt;tasks:chiara-managedb/&gt;
&lt;tasks:chiara-managedb unique="0"/&gt;
&lt;tasks:chiara-managedb unique="1"/&gt;
</pre></div><div class="note" title="Note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="tip24"/>Tip</h3><p><span class="strong"><strong>PEAR 1.5.0a1 or Newer Is Needed to Run this Task</strong></span></p><p>Unfortunately, a serious bug in PEAR versions prior to 1.5.0a1 prevents proper usage of this task, so if you want to try it, make sure you have the latest version of PEAR installed.</p></div><p>In addition, as we require the<code class="literal"> chiaramdb2schema</code> role in order to be sure that our configuration variables are installed and ready to use, we will require that the task is contained with a file of role<code class="literal"> chiaramdb2schema</code> like so:</p><div class="informalexample"><pre class="programlisting">&lt;file name="blah.xml" role="chiaramdb2schema"&gt;
&lt;tasks:chiara-managedb/&gt;
&lt;/file&gt;
</pre></div><p>Here is the XML validation method for our task:<a id="id139" class="indexterm"/>
</p><div class="informalexample"><pre class="programlisting">/**
* Validate the raw xml at parsing-time.
* @param PEAR_PackageFile_v2
* @param array raw, parsed xml
* @param PEAR_Config
* @static
*/
function validateXml($pkg, $xml, &amp;$config, $fileXml)
{
if ($fileXml['role'] !='chiaramdb2schema') {
return array(PEAR_TASK_ERROR_INVALID,
'chiara_managedb task can only be ' .
'used with files whose role is chiaramdb2schema.
File is role "' .
$fileXml['role'] . '"');
}
if (isset($xml['attribs'])) {
if (!isset($xml['attribs']['unique'])) {
return array(PEAR_TASK_ERROR_MISSING_ATTRIB, 'unique');
}
if (!in_array($xml['attribs']['unique'], array('0', '1'))) {
return array (PEAR_TASK_ERROR_WRONG_ATTRIB_VALUE, 'unique',
$xml['attribs']['unique'], array('0', '1'));
}
}
return true;
}
</pre></div><p>When running the task, we will use the value of the<code class="literal"> unique</code> attribute to control the database DSN (Data Source Name) used to connect to the database. As such, here is our initialization method:<a id="id140" class="indexterm"/>
</p><div class="informalexample"><pre class="programlisting">/**
* Initialize a task instance with the parameters
* @param array raw, parsed xml
* @param unused
*/
function init($xml, $attribs)
{
if (isset($xml['attribs']['unique']) &amp;&amp;
$xml['attribs']['unique']) {
$this-&gt;_unique = true;
} else {
$this-&gt;_unique = false;
}
}
</pre></div><p>So far, this is pretty simple, isn't it? The next step is to determine which database to use, and how to connect. To do this, we will be using a combination of the<code class="literal"> chiaramdb2schema_driver</code> configuration variable, the<code class="literal"> chiaramdb2schema_dsn</code> variable, and the<code class="literal"> chiara_mdb2schema_password</code> variable.<a id="id141" class="indexterm"/>
</p><p>First of all, we will define a method to construct the data source name (DSN) from these configuration variables. Before analyzing the source, let's see it in all of its glory:</p><div class="informalexample"><pre class="programlisting">/**
* parse the chiaramdb2schema_dsn config variable and the
* password variable to determine an actual DSN that should be * used for this task.
* @return string|PEAR_Error
* @access private
*/
function _parseDSN($pkg)
{
// get channel-specific configuration for this variable
$driver = $this-&gt;config-&gt;get('chiaramdb2schema_driver', null, $pkg-&gt;getChannel());
if (!$driver) {
return PEAR::raiseError('Error: no driver set. use
"config-set ' . 'chiaramdb2schema_driver &lt;drivertype&gt;" before installing');
}
$allDSN = $this-&gt;config-&gt;get('chiaramdb2schema_dsn', null, $pkg-&gt;getChannel());
if (!$allDSN) {
return $this-&gt;throwError('Error: no dsn set. use
"config-set ' . 'chiaramdb2schema_dsn &lt;dsn&gt;" before installing');
}
$allPasswords = $this-&gt;config-&gt;get('chiaramdb2schema_password', null, $pkg-&gt;getChannel());
$allDSN = explode(';', $allDSN);
$badDSN = array();
$allPasswords = explode(':', $allPasswords);
for ($i = 0; $i &lt; count($allDSN); $i++) {
if ($i &amp;&amp; strpos($allDSN[$i], '::')) {
$allDSN[$i] = explode('::', $allDSN[$i]);
$password = (isset($allPasswords[$i]) &amp;&amp;
$allPasswords[$i]) ? $allPasswords[$i] : '';
if (!strpos($allDSN[$i][1], '@')) {
$password = '';
} elseif ($password) {
// insert password into DSN
$a = explode('@', $allDSN[$i][1]);
$allDSN[$i][1] = $a[0] . ':' . $password . '@';
unset($a[0]);
$allDSN[$i][1] .= implode('@', $a);
}
} elseif (!$i &amp;&amp; !strpos($allDSN[0], '::')) {
$password = (isset($allPasswords[0]) &amp;&amp;
$allPasswords[0]) ? $allPasswords[0] : '';
if (!strpos($allDSN[0], '@'))
{$password = '';
} elseif ($password) {
// insert password into DSN
$a = explode('@', $allDSN[0]);
$allDSN[0] = $a[0] . ':' . $password . '@';
unset($a[0]);
$allDSN[0] .= implode('@', $a);
}
} else {
// invalid DSN
$badDSN[$i] = $allDSN[$i];
$allDSN[$i] = false;
}
}
if ($this-&gt;_unique) {
$lookfor = array($pkg-&gt;getPackage(), $pkg-&gt;getPackage() . '#' . $this-&gt;_file);
foreach ($allDSN as $i =&gt; $dsn) {
if (!$i) {
continue;
}
if (strcasecmp($dsn[0], $lookfor[0]) === 0) {
return $driver . '://' . $dsn[1];
}
if (strcasecmp($dsn[0], $lookfor[1]) === 0) {
return $driver . '://' . $dsn[1];
}
}
return $this-&gt;throwError('No valid DSNs for package "' .
$pkg-&gt;getPackage() . '" were found in config variable
chiaramdb2schema_dsn');
} else {
if (!$allDSN[0]) {
return $this-&gt;throwError('invalid default DSN "' .
$badDSN[0] . '" in config variable chiaramdb2schema_dsn');
}
return $driver . '://' . $allDSN[0];
}
}
</pre></div><p>First, the configuration variables are retrieved using the<code class="literal"> $config</code> member, which is set in the constructor:<a id="id142" class="indexterm"/>
</p><div class="informalexample"><pre class="programlisting">// get channel-specific configuration for this variable
$driver = $this-&gt;config-&gt;get('chiaramdb2schema_driver', null, $pkg-&gt;getChannel());
if (!$driver) {
return PEAR::raiseError('Error: no driver set. use
"config-set ' . 'chiaramdb2schema_driver &lt;drivertype&gt;" before installing');
}
$allDSN = $this-&gt;config-&gt;get('chiaramdb2schema_dsn', null, $pkg-&gt;getChannel());
if (!$allDSN) {
return $this-&gt;throwError('Error: no dsn set. use
"config-set ' . 'chiaramdb2schema_dsn &lt;dsn&gt;" before installing');
}
$allPasswords = $this-&gt;config-&gt;get('chiaramdb2schema_password', null, $pkg-&gt;getChannel());
</pre></div><p>In order to make things simpler on the user's end, we will also attempt to retrieve configuration data for the package's channel, and then default to the <a class="ulink" href="http://pear.php.net"> pear.php.net</a> channel configuration.</p><p>Next, we will split the<code class="literal"> DSN</code> variable on its separator ";" and the<code class="literal"> Passwords</code> variable on its separator ":". By iterating over the<code class="literal"> DSN</code> variable, we can then insert the appropriate password for each DSN. For instance, for a DSN "user:pass@localhost/databasename", the DSN will be stored as "user@localhost/databasename", so we will need to insert ":pass" right before the "@". In addition, the first DSN is the default DSN to be used if a non-package-specific DSN is found, so there is a special case for this DSN (which is found via<code class="literal"> $allDSN[0]</code>).<a id="id143" class="indexterm"/>
</p><div class="informalexample"><pre class="programlisting">$allDSN = explode(';', $allDSN);
$badDSN = array();
$allPasswords = explode(':', $allPasswords);
for ($i = 0; $i &lt; count($allDSN); $i++) {
if ($i &amp;&amp; strpos($allDSN[$i], '::')) {
$allDSN[$i] = explode('::', $allDSN[$i]);
$password = (isset($allPasswords[$i]) &amp;&amp;
$allPasswords[$i]) ?
$allPasswords[$i] : '';
if (!strpos($allDSN[$i][1], '@')) {
$password = '';
} elseif ($password) {
// insert password into DSN
$a = explode('@', $allDSN[$i][1]);
$allDSN[$i][1] = $a[0] . ':' . $password . '@';
unset($a[0]);
$allDSN[$i][1] .= implode('@', $a);
}
} elseif (!$i &amp;&amp; !strpos($allDSN[0], '::')) {
$password = (isset($allPasswords[0]) &amp;&amp;
$allPasswords[0]) ?
$allPasswords[0] : '';
if (!strpos($allDSN[0], '@')) {
$password = '';
} elseif ($password) {
// insert password into DSN
$a = explode('@', $allDSN[0]);
$allDSN[0] = $a[0] . ':' . $password . '@';
unset($a[0]);
$allDSN[0] .= implode('@', $a);
}
} else {
// invalid DSN
$badDSN[$i] = $allDSN[$i];
$allDSN[$i] = false;
}
}
</pre></div><p>Finally, we will determine whether the package requires a specific database connection string for the package using<code class="literal"> $this-&gt;_unique</code>, which as you recall, was set in the<code class="literal"> init()</code> method. Package-specific DSNs are prefixed with the package name as in "Packagename::user:password@localhost/databasename" or with a specific file within a package like "Packagename#file::user:password@localhost/databasename", so we will search through the parsed DSNs until we either find one or fail.<a id="id144" class="indexterm"/>
</p><p>Finally, after determining which DSN to use, we need to prepend the kind of database that should be connected to. For instance, this could be MySQL, MySQLi, OCI, Firebird, pgSQL, and so on.</p><div class="informalexample"><pre class="programlisting">if ($this-&gt;_unique) {
$lookfor = array($pkg-&gt;getPackage(), $pkg-&gt;getPackage() . '#' . $this-&gt;_file);
foreach ($allDSN as $i =&gt; $dsn) {
if (!$i) {
continue;
}
if (strcasecmp($dsn[0], $lookfor[0]) === 0) {
return $driver . ':/' . $dsn[1];
}
if (strcasecmp($dsn[0], $lookfor[1]) === 0) {
return $driver . ':/' . $dsn[1];
}
}
return $this-&gt;throwError('No valid DSNs for package "' .
$pkg-&gt;getPackage() .
'" were found in config variable
chiaramdb2schema_dsn');
} else {
if (!$allDSN[0]) {
return $this-&gt;throwError('invalid default DSN "' .
$badDSN[0] . '" in config variable
chiaramdb2schema_dsn');
}
return $driver . ':/' . $allDSN[0];
}
</pre></div><p>If you find your eyes glazing over, don't fear. What is important is to realize that at the end of the experience, the method will either return a<code class="literal"> PEAR_Error</code> with a detailed error message, or a string like<span class="strong"><strong> "mysqli://user:pass@localhost/databasename"</strong></span>.</p><p>The final portion of our custom task is the<code class="literal"> startSession()</code> method, which actually performs the task, as this is a task of type single.<a id="id145" class="indexterm"/>
</p><div class="informalexample"><pre class="programlisting">/**
* Update the database.
*
* First, determine which DSN to use from the
* chiaramdb2schema_dsn config variable
* with {@link _parseDSN()}, then determine whether the database
* already exists based
* on the contents of a previous installation, and finally use
* {@link MDB2_Schema::updateDatabase()} * to update the database itself
*
* PEAR_Error is returned on any problem.
* See validateXml() source for the complete list of allowed fields
* @param PEAR_PackageFile_v2
* @param string file contents
* @param string the eventual final file location * (informational only)
* @return string|false|PEAR_Error false to skip this file,
* PEAR_Error to fail
* (use $this-&gt;throwError), otherwise return the new contents
*/
function startSession($pkg, $contents, $dest)
{
$this-&gt;_file = basename($dest);
$dsn = $this-&gt;_parseDSN($pkg);
if (PEAR::isError($dsn)) {
return $dsn;
}
require_once 'MDB2/Schema.php';
require_once 'System.php';
$tmp = System::mktemp(array('foo.xml'));
if (PEAR::isError($tmp)) {
return $tmp;
}
$fp = fopen($tmp, 'wb');
fwrite($fp, $contents);
fclose($fp);
$schema = &amp;MDB2_Schema::factory($dsn);
$reg = &amp;$this-&gt;config-&gt;getRegistry();
if ($installed &amp;&amp; file_exists($dest)) {
// update existing database
$res = $schema-&gt;updateDatabase($tmp, $dest);
if (PEAR::isError($res)) {
return PEAR::raiseError($res-&gt;getMessage() . $res-&gt;getUserInfo());
}
} else {
// create new database
$res = $schema-&gt;updateDatabase($tmp);
if (PEAR::isError($res)) {
return PEAR::raiseError($res-&gt;getMessage() . $res-&gt;getUserInfo());
}
}
// unmodified
return $contents;
}
</pre></div><p>
<code class="literal">MDB2_Schema::updateDatabase()</code> requires two schema files in order to upgrade a database. While upgrading the database, we will use the final installation destination<code class="literal"> $dest</code> to determine whether we are replacing an existing schema file. If so, then this is passed to<code class="literal"> updateDatabase()</code>. Otherwise, we will simply call<code class="literal"> updateDatabase()</code> to create the new database structure.<a id="id146" class="indexterm"/>
</p><p>Note that at this point, the contents of the file have<span class="emphasis"><em> not</em></span> been written to disk yet, as the tasks are to operate on a file prior to installation. As such, we will write out the schema file to a temporary location created using the<code class="literal"> System</code> class, which is bundled with the PEAR package.</p><p>The bulk of the task's work is performed by the<code class="literal"> MDB2_Schema</code> class. After completing the task, the user's database is automatically configured on installation and upgrade.</p></div><div class="section" title="The Full Range of Possible Custom File Tasks"><div class="titlepage"><div><div><h3 class="title"><a id="ch03lvl3sec04"/>The Full Range of Possible Custom File Tasks</h3></div></div></div><p>The methods that are available to a custom task are:<a id="id147" class="indexterm"/>
</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">true|array validXml($pkg, $xml, &amp;$config, $fileXml):</code> Validates task<code class="literal"> XML</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">void init($xml, $fileAttributes, $lastVersion):</code> Initializes a task</li><li class="listitem" style="list-style-type: disc"><code class="literal">true|PEAR_Error startSession($pkg, $contents, $dest):</code> Starts (and generally finishes) task handling</li><li class="listitem" style="list-style-type: disc"><code class="literal">true|PEAR_Error run($tasks):</code> For tasks of type "multiple" only, processes all tasks and performs the needed actions</li></ul></div><div class="section" title="validXml($pkg, $xml, &amp;$config, $fileXml)"><div class="titlepage"><div><div><h4 class="title"><a id="ch03lvl4sec01"/>validXml($pkg, $xml, &amp;$config, $fileXml)</h4></div></div></div><p>This method is called for all three types of task during<code class="literal"> package.xml</code> validation to validate the XML of a specific task.<code class="literal"> $pkg</code> is a<code class="literal"> PEAR_PackageFile_v2</code> object representing the<code class="literal"> package.xml</code> containing the task. This is read-only, and should simply be used to retrieve information.<code class="literal"> $xml</code> is the parsed contents of the file task,<code class="literal"> $config</code> is a<code class="literal"> PEAR_Config</code> object representing the current configuration, and<code class="literal"> $fileXml</code> is the parsed contents of the file tag from<code class="literal"> package.xml</code>.<a id="id148" class="indexterm"/>
</p><p>Here is a simple mapping of some sample task XML and the contents of the<code class="literal"> $xml</code> variable:<a id="id149" class="indexterm"/>
</p><div class="informaltable"><table border="1"><colgroup><col style="text-align: left"/><col style="text-align: left"/></colgroup><thead><tr><th style="text-align: left" valign="bottom">
<p>XML</p>
</th><th style="text-align: left" valign="bottom">
<p>Parsed Contents</p>
</th></tr></thead><tbody><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">&lt;tasks:something/&gt;</code>
</p>
</td><td style="text-align: left" valign="top">
<p><code class="literal">''</code></p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">&lt;tasks:something att="blah"/&gt;</code>
</p>
</td><td style="text-align: left" valign="top">
<p>
<code class="literal">array('attribs' =&gt; array('att' =&gt; 'blah'))</code>
</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">&lt;tasks:something&gt;blah&lt;/tasks:something&gt;</code>
</p>
</td><td style="text-align: left" valign="top">
<p>
<code class="literal">'blah'</code>
</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">&lt;tasks:something att="blah"&gt;blah2&lt;/tasks:something&gt;</code>
</p>
</td><td style="text-align: left" valign="top">
<p>
<code class="literal">array('attribs' =&gt; array('att' =&gt; 'blah'), '_content' =&gt; 'blah2')</code>
</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">&lt;tasks:something&gt; &lt;tasks:subtag&gt;hi&lt;/tasks:subtag&gt; &lt;/tasks:something&gt;</code>
</p>
</td><td style="text-align: left" valign="top">
<p>
<code class="literal">array('tasks:subtag' =&gt; 'hi')</code>
</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">&lt;tasks:something&gt; &lt;tasks:subtag&gt;hi&lt;/tasks:subtag&gt; &lt;tasks:subtag att="blah"&gt;again&lt;/tasks:subtag&gt; &lt;/tasks:something&gt;</code>
</p>
</td><td style="text-align: left" valign="top">
<p>
<code class="literal">array('tasks:subtag' =&gt; array(0 =&gt; 'hi', 1 =&gt; array('attribs' =&gt; array('att' =&gt; 'blah'), '_content' =&gt; 'again'))))</code>
</p>
</td></tr></tbody></table></div><p>The<code class="literal"> $fileXml</code> parameter will consist of an array of this format containing all of the attributes defined in the<code class="literal">&lt;file&gt;</code> tag.</p><div class="informalexample"><pre class="programlisting">array('attribs' =&gt; array('name' =&gt; 'Filename', 'role' =&gt;
'filerole',...));
</pre></div><p>Error should be returned as an array. The first index must be one of the following error codes:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">PEAR_TASK_ERROR_NOATTRIBS:</code> The array should be returned as:<code class="literal"> array(PEAR_TASK_ERROR_NOATTRIBS)</code>;</li><li class="listitem" style="list-style-type: disc"><code class="literal">PEAR_TASK_ERROR_MISSING_ATTRIB:</code> The array should be returned as:<code class="literal"> array(PEAR_TASK_ERROR_MISSING_ATTRIB, 'attributename')</code>;</li><li class="listitem" style="list-style-type: disc"><code class="literal">PEAR_TASK_ERROR_WRONG_ATTRIB_VALUE:</code> The array should be returned as:<code class="literal"> array(PEAR_TASK_ERROR_WRONG_ATTRIB_VALUE, 'attributename', 'actualvalue', ['expectedvalue'|array('expectedvalue1', 'expectedvalue2',...)])</code>;</li><li class="listitem" style="list-style-type: disc"><code class="literal">PEAR_TASK_ERROR_INVALID:</code> The array should be returned as:<code class="literal"> array(PEAR_TASK_ERROR_INVALID, 'unusual error message')</code>;</li></ul></div></div><div class="section" title="init($xml, $fileAttributes, $lastVersion)"><div class="titlepage"><div><div><h4 class="title"><a id="ch03lvl4sec02"/>init($xml, $fileAttributes, $lastVersion)</h4></div></div></div><p>The<code class="literal"> init()</code> method is called to initialize all non-script tasks, and can be used for any purpose. The three parameters are:<a id="id150" class="indexterm"/>
</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">mixed $xml:</code> An array representing the task's XML from<code class="literal"> package.xml</code>. This is the same format as the<code class="literal"> $xml</code> parameter passed to<code class="literal"> validXml()</code>.</li><li class="listitem" style="list-style-type: disc"><code class="literal">array $fileAttributes:</code> An array representing the file attributes. This is in the same format as the<code class="literal"> $fileXml</code> parameter to<code class="literal"> validXml()</code>.</li><li class="listitem" style="list-style-type: disc"><code class="literal">string|NULL $lastVersion:</code> The last installed version of the package if the package is being upgraded, or<code class="literal"> NULL</code> if this package is being installed for the first time. This can be used for tasks that rely upon previously installed configuration to operate.<a id="id151" class="indexterm"/></li></ul></div><p>Any return value from<code class="literal"> init()</code> is discarded.</p></div><div class="section" title="startSession($pkg, $contents, $dest)"><div class="titlepage"><div><div><h4 class="title"><a id="ch03lvl4sec03"/>startSession($pkg, $contents, $dest)</h4></div></div></div><p>The<code class="literal"> startSession()</code> method is called to execute a task, and is called after the<code class="literal"> init()</code> method. It is important to note that this method is expected to return the exact contents of the file, as it should be installed to disk. No modification of files on disk should be performed. If there is any error running the task, a<code class="literal"> PEAR_Error</code> object should be returned with a clear error message describing the problem, and containing information on the file that contains the task.<a id="id152" class="indexterm"/>
</p><p>If the task determines that this file should not be installed, returning<code class="literal"> FALSE</code> will prompt the installer to skip installation of this file. Note that only the literal<code class="literal"> FALSE</code> will cause skipping of installation; an empty string, the number 0, and any other literal that can be used as a false condition will not affect installation.</p><p>After successful performance of a task, the complete file contents<span class="emphasis"><em> must</em></span> be returned. The return value is used to write out the file contents to disk. For instance, the<code class="literal"> windowseol</code> task returns the value of<code class="literal"> $contents</code> after converting all new lines into<code class="literal"> \r\n</code>.</p><p>The parameters passed to<code class="literal"> startSession()</code> are:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">PEAR_PackageFile_v2 $pkg:</code> The packagefile object representing the complete<code class="literal"> package.xml</code> containing this task.</li><li class="listitem" style="list-style-type: disc"><code class="literal">string $contents:</code> The complete contents of the file, which can be operated on and must be returned upon successful completion of the task.</li><li class="listitem" style="list-style-type: disc"><code class="literal">string $dest:</code> The full path of the final installation location of the file. This is for informational use only.</li></ul></div></div><div class="section" title="run($tasks)"><div class="titlepage"><div><div><h4 class="title"><a id="ch03lvl4sec04"/>run($tasks)</h4></div></div></div><p>This method is only called for tasks of type multiple. The<code class="literal"> $tasks</code> parameter is an array of each of the multiple tasks in<code class="literal"> package.xml</code>. For instance, if<code class="literal"> package.xml</code> contains tasks of type multiple<code class="literal">&lt;tasks:foo/&gt;</code> and<code class="literal">&lt;tasks:bar/&gt;</code>, the<code class="literal"> run()</code> method will be called for all<code class="literal"> foo</code> tasks and the<code class="literal"> $tasks</code> parameter will contain an array of each<code class="literal"> foo</code> task. Then, the same procedure will be repeated for the<code class="literal"> bar</code> tasks.<a id="id153" class="indexterm"/>
</p><p>The<code class="literal"> run()</code> method is called after installation has been successfully completed, and as such, can manipulate the installed contents of a package.<a id="id154" class="indexterm"/>
</p><p>Upon error, the<code class="literal"> run()</code> method should return a<code class="literal"> PEAR_Error</code> object with an error message containing detailed information on the cause of task failure. All other return values are ignored.</p></div></div></div><div class="section" title="Post-Installation Scripts for Ultimate Customization"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec03"/>Post-Installation Scripts for Ultimate Customization</h2></div></div></div><p>The third and final task type is post-installation scripts. These are the most powerful and customizable tasks, and can quite literally be used to perform any needed customization of an installation. The PEAR installer implements post-installation scripts by defining sets of questions to ask the user in the<code class="literal"> package.xml</code> file, and by passing the answers a user gives to a special PHP file. Here is a simple set of questions and a post-install script to match:<a id="id155" class="indexterm"/>
</p><p>First, the XML from<code class="literal"> package.xml:</code>
<a id="id156" class="indexterm"/>
</p><div class="informalexample"><pre class="programlisting">&lt;file name="rolesetup.php" role="php"&gt;
&lt;tasks:postinstallscript&gt;
&lt;tasks:paramgroup&gt;
&lt;tasks:id&gt;setup&lt;/tasks:id&gt;
&lt;tasks:param&gt;
&lt;tasks:name&gt;channel&lt;/tasks:name&gt;
&lt;tasks:prompt&gt;Choose a channel to modify configuration
values from&lt;/tasks:prompt&gt;
&lt;tasks:type&gt;string&lt;/tasks:type&gt;
&lt;tasks:default&gt;pear.php.net&lt;/tasks:default&gt;
&lt;/tasks:param&gt;
&lt;/tasks:paramgroup&gt;
&lt;tasks:paramgroup&gt;
&lt;tasks:id&gt;driver&lt;/tasks:id&gt;
&lt;tasks:instructions&gt;
In order to set up the database, please choose a database
driver.
This should be a MDB2-compatible driver name, such as mysql, mysqli,
Pgsql, oci8, etc.
&lt;/tasks:instructions&gt;
&lt;tasks:param&gt;
&lt;tasks:name&gt;driver&lt;/tasks:name&gt;
&lt;tasks:prompt&gt;Database driver?&lt;/tasks:prompt&gt;
&lt;tasks:type&gt;string&lt;/tasks:type&gt;
&lt;/tasks:param&gt;
&lt;/tasks:paramgroup&gt;
&lt;tasks:paramgroup&gt;
&lt;tasks:id&gt;choosedsn&lt;/tasks:id&gt;
&lt;tasks:param&gt;
&lt;tasks:name&gt;dsnchoice&lt;/tasks:name&gt;
&lt;tasks:prompt&gt;%sChoose a DSN to modify, or to add a new
dsn, type
&amp;quot;new&amp;quot;. To remove a DSN prepend with
&amp;quot;!&amp;quot;&lt;/tasks:prompt&gt;
&lt;tasks:type&gt;string&lt;/tasks:type&gt;
&lt;tasks:default&gt;new&lt;/tasks:default&gt;
&lt;/tasks:param&gt;
&lt;/tasks:paramgroup&gt;
&lt;tasks:paramgroup&gt;
&lt;tasks:id&gt;deletedsn&lt;/tasks:id&gt;
&lt;tasks:param&gt;
&lt;tasks:name&gt;confirm&lt;/tasks:name&gt;
&lt;tasks:prompt&gt;Really delete &amp;quot;%s&amp;quot; DSN? (yes to
delete)&lt;/tasks:prompt&gt;
&lt;tasks:type&gt;string&lt;/tasks:type&gt;
&lt;tasks:default&gt;no&lt;/tasks:default&gt;
&lt;/tasks:param&gt;
&lt;/tasks:paramgroup&gt;
&lt;tasks:paramgroup&gt;
&lt;tasks:id&gt;modifydsn&lt;/tasks:id&gt;
&lt;tasks:name&gt;choosedsn::dsnchoice&lt;/tasks:name&gt;
&lt;tasks:conditiontype&gt;!=&lt;/tasks:conditiontype&gt;
&lt;tasks:value&gt;new&lt;/tasks:value&gt;
&lt;tasks:param&gt;
&lt;tasks:name&gt;user&lt;/tasks:name&gt;
&lt;tasks:prompt&gt;User name&lt;/tasks:prompt&gt;
&lt;tasks:type&gt;string&lt;/tasks:type&gt;
&lt;/tasks:param&gt;
&lt;tasks:param&gt;
&lt;tasks:name&gt;password&lt;/tasks:name&gt;
&lt;tasks:prompt&gt;Database password&lt;/tasks:prompt&gt;
&lt;tasks:type&gt;password&lt;/tasks:type&gt;
&lt;/tasks:param&gt;
&lt;tasks:param&gt;
&lt;tasks:name&gt;host&lt;/tasks:name&gt;
&lt;tasks:prompt&gt;Database host&lt;/tasks:prompt&gt;
&lt;tasks:type&gt;string&lt;/tasks:type&gt;
&lt;tasks:default&gt;localhost&lt;/tasks:default&gt;
&lt;/tasks:param&gt;
&lt;tasks:param&gt;
&lt;tasks:name&gt;database&lt;/tasks:name&gt;
&lt;tasks:prompt&gt;Database name&lt;/tasks:prompt&gt;
&lt;tasks:type&gt;string&lt;/tasks:type&gt;
&lt;/tasks:param&gt;
&lt;/tasks:paramgroup&gt;
&lt;tasks:paramgroup&gt;
&lt;tasks:id&gt;newpackagedsn&lt;/tasks:id&gt;
&lt;tasks:param&gt;
&lt;tasks:name&gt;package&lt;/tasks:name&gt;
&lt;tasks:prompt&gt;Package name&lt;/tasks:prompt&gt;
&lt;tasks:type&gt;string&lt;/tasks:type&gt;
&lt;/tasks:param&gt;
&lt;tasks:param&gt;
&lt;tasks:name&gt;host&lt;/tasks:name&gt;
&lt;tasks:prompt&gt;Database host&lt;/tasks:prompt&gt;
&lt;tasks:type&gt;string&lt;/tasks:type&gt;
&lt;tasks:default&gt;localhost&lt;/tasks:default&gt;
&lt;/tasks:param&gt;
&lt;tasks:param&gt;
&lt;tasks:name&gt;user&lt;/tasks:name&gt;
&lt;tasks:prompt&gt;User name&lt;/tasks:prompt&gt;
&lt;tasks:type&gt;string&lt;/tasks:type&gt;
&lt;tasks:default&gt;root&lt;/tasks:default&gt;
&lt;/tasks:param&gt;
&lt;tasks:param&gt;
&lt;tasks:name&gt;password&lt;/tasks:name&gt;
&lt;tasks:prompt&gt;Database password&lt;/tasks:prompt&gt;
&lt;tasks:type&gt;password&lt;/tasks:type&gt;
&lt;/tasks:param&gt;
&lt;tasks:param&gt;
&lt;tasks:name&gt;database&lt;/tasks:name&gt;
&lt;tasks:prompt&gt;Database name&lt;/tasks:prompt&gt;
&lt;tasks:type&gt;string&lt;/tasks:type&gt;
&lt;/tasks:param&gt;
&lt;/tasks:paramgroup&gt;
&lt;tasks:paramgroup&gt;
&lt;tasks:id&gt;newdefaultdsn&lt;/tasks:id&gt;
&lt;tasks:param&gt;
&lt;tasks:name&gt;host&lt;/tasks:name&gt;
&lt;tasks:prompt&gt;Database host&lt;/tasks:prompt&gt;
&lt;tasks:type&gt;string&lt;/tasks:type&gt;
&lt;tasks:default&gt;localhost&lt;/tasks:default&gt;
&lt;/tasks:param&gt;
&lt;tasks:param&gt;
&lt;tasks:name&gt;user&lt;/tasks:name&gt;
&lt;tasks:prompt&gt;User name&lt;/tasks:prompt&gt;
&lt;tasks:type&gt;string&lt;/tasks:type&gt;
&lt;tasks:default&gt;root&lt;/tasks:default&gt;
&lt;/tasks:param&gt;
&lt;tasks:param&gt;
&lt;tasks:name&gt;password&lt;/tasks:name&gt;
&lt;tasks:prompt&gt;Database password&lt;/tasks:prompt&gt;
&lt;tasks:type&gt;password&lt;/tasks:type&gt;
&lt;/tasks:param&gt;
&lt;tasks:param&gt;
&lt;tasks:name&gt;database&lt;/tasks:name&gt;
&lt;tasks:prompt&gt;database name&lt;/tasks:prompt&gt;
&lt;tasks:type&gt;string&lt;/tasks:type&gt;
&lt;/tasks:param&gt;
&lt;/tasks:paramgroup&gt;
&lt;/tasks:postinstallscript&gt;
&lt;/file&gt;
<a id="id160" class="indexterm"/>
</pre></div><p>Then, the post-installation script (contents of<code class="literal"> rolesetup.php</code>
):
<a id="id161" class="indexterm"/>
</p><div class="informalexample"><pre class="programlisting">&lt;?php
/**
* Post-installation script for the Chiara_Managedb task.
*
* This script takes user input on DSNs and sets up DSNs, allowing
* the addition of one custom DSN per iteration.
* @version @package_version@
*/
class rolesetup_postinstall
{
/**
* object representing package.xml
* @var PEAR_PackageFile_v2
* @access private
*/
var $_pkg;
/**
* Frontend object
* @var PEAR_Frontend
* @access private
*/
var $_ui;
/**
* @var PEAR_Config
* @access private
*/
var $_config;
/**
* The actual DSN value as will be saved to the configuration file
* @var string
*/
var $dsnvalue;
/**
* The actual password value as will be saved to the * configuration file
* @var string
*/
var $passwordvalue;
/**
* The channel to modify configuration values from
*
* @var string
*/
var $channel;
/**
* The task object used for dsn serialization/unserialization
* @var PEAR_Task_Chiara_Managedb
*/
var $managedb;
/**
* An "unserialized" array of DSNs parsed from the chiaramdb2schema
* configuration variables.
* @var array
*/
var $dsns;
/**
* The index of the DSN in $this-&gt;dsns we will be modifying
* @var string
*/
var $choice;
/**
* Initialize the post-installation script
*
* @param PEAR_Config $config
* @param PEAR_PackageFile_v2 $pkg
* @param string|null $lastversion Last installed version. * Not used in this script
* @return boolean success of initialization
*/
function init(&amp;$config, &amp;$pkg, $lastversion)
{
require_once 'PEAR/Task/Chiara/Managedb.php';
$this-&gt;_config = &amp;$config;
$this-&gt;_ui = &amp;PEAR_Frontend::singleton();
$this-&gt;managedb = new PEAR_Task_Chiara_Managedb($config,
$this-&gt;_ui, PEAR_TASK_INSTALL);
$this-&gt;_pkg = &amp;$pkg;
if (!in_array('chiaramdb2schema_dsn', $this-&gt;_config-&gt;getKeys())) {
// fail: role was not installed?
return false;
}
$this-&gt;channel = $this-&gt;_config-&gt;get('default_channel');
$this-&gt;dsns = PEAR::isError( $e = $this-&gt;managedb-&gt;unserializeDSN($pkg)) ? array() : $e;
return true;
}
/**
* Set up the prompts properly for the script
*
* @param array $prompts
* @param string $section
* @return array
*/
function postProcessPrompts($prompts, $section)
{
switch ($section) {
case 'driver' :
if ($this-&gt;driver) {
$prompts[0]['default'] = $this-&gt;driver;
}
break;
case 'deletedsn' :
$count = 1;
foreach ($this-&gt;dsns as $i =&gt; $dsn) {
$text = ($i ? "(Package $i) " : '') . $dsn;
if ($count == $this-&gt;choice) {
break;
}
$count++;
}
$prompts[0]['prompt'] = sprintf($prompts[0]['prompt'], $text);
break;
case 'choosedsn' :
$text = '';
$count = 1;
foreach ($this-&gt;dsns as $i =&gt; $dsn) {
$text .= "[$count] " . ($i ? "(Package $i) " : '') . $dsn . "\n";
$count++;
}
$prompts[0]['prompt'] =
sprintf($prompts[0]['prompt'], $text);
break;
case 'modifydsn' :
$count = 1;
$found = false;
foreach ($this-&gt;dsns as $i =&gt; $dsn) {
if ($count == $this-&gt;choice) {
$found = true;
break;
}
$count++;
}
if ($found) {
$dsn = MDB2::parseDSN($this-&gt;dsns[$i]);
// user
$prompts[0]['default'] = $dsn['username'];
// password
if (isset($dsn['password'])) {
$prompts[1]['default'] = $dsn['password'];
}
// host
$prompts[2]['default'] = $dsn['hostspec'];
if (isset($dsn['port'])) {
$prompts[2]['default'] .= ':' . $dsn['port'];
}
// database
$prompts[3]['default'] = $dsn['database'];
}
break;
}
return $prompts;
}
/**
* Run the script itself
*
* @param array $answers
* @param string $phase
*/
function run($answers, $phase)
{
switch ($phase) {
case 'setup' :
return $this-&gt;_doSetup($answers);
break;
case 'driver' :
require_once 'MDB2.php';
PEAR::pushErrorHandling(PEAR_ERROR_RETURN);
if (PEAR::isError($err =
MDB2::loadFile('Driver' . DIRECTORY_SEPARATOR .
$answers['driver']))) {
PEAR::popErrorHandling();
$this-&gt;_ui-&gt;outputData( 'ERROR: Unknown MDB2 driver "' .
$answers['driver'] . '": ' .
$err-&gt;getUserInfo() . '. Be sure you have
installed ' . 'MDB2_Driver_' .
$answers['driver']);
return false;
}
PEAR::popErrorHandling();
$ret = $this-&gt;_config-&gt;set('chiaramdb2schema_driver',
$answers['driver'],
'user', $this-&gt;channel);
return $ret &amp;&amp; $this-&gt;_config-&gt;writeConfigFile();
break;
case 'choosedsn' :
if ($answers['dsnchoice'] &amp;&amp; $answers['dsnchoice']{0} == '!') {
// delete a DSN
$answers['dsnchoice'] =
substr($answers['dsnchoice'], 1);
} else {
$this-&gt;_ui-&gt;skipParamgroup('deletedsn');
}
if ($answers['dsnchoice'] &gt; count($this-&gt;dsns)) {
$this-&gt;_ui-&gt;outputData('ERROR: No suchdsn "' .
$answers['dsnchoice'] . '"');
return false;
}
$this-&gt;choice = $answers['dsnchoice'];
break;
case 'deletedsn' :
$this-&gt;_ui-&gt;skipParamgroup('modifydsn');
$this-&gt;_ui-&gt;skipParamgroup('newpackagedsn');
$this-&gt;_ui-&gt;skipParamgroup('newdefaultdsn');
if ($answers['confirm'] == 'yes') {
$count = 1;
foreach ($this-&gt;dsns as $i =&gt; $dsn) {
if ($count == $this-&gt;choice) {
unset($this-&gt;dsns[$i]);
break;
}
$count++;
}
$this-&gt;_ui-&gt;outputData('DSN deleted');
$this-&gt;managedb-&gt;serializeDSN($this-&gt;dsns, $this-&gt;channel);
return true;
} else {
$this-&gt;_ui-&gt;outputData('No changes performed');
}
break;
case 'modifydsn' :
$count = 1;
$found = false;
foreach ($this-&gt;dsns as $i =&gt; $dsn) {
if ($count == $this-&gt;choice) {
$found = true;
break;
}
$count++;
}
if (!$found) {
$this-&gt;_ui-&gt;outputData('ERROR: DSN "' . $this-&gt;choice . '" not found!');
return false;
}
$dsn = $answers['user'] . ':' . $answers['password'] . '@' .
$answers['host'] . '/' . $answers['database'];
$this-&gt;dsns[$i] = $dsn;
$this-&gt;managedb-&gt;serializeDSN($this-&gt;dsns, $this-&gt;channel);
$this-&gt;_ui-&gt;skipParamgroup('newpackagedsn');
$this-&gt;_ui-&gt;skipParamgroup('newdefaultdsn');
break;
case 'newpackagedsn' :
$dsn = $answers['user'] . ':' . $answers['password'] . '@' .
$answers['host'] . '/' . $answers['database'];
$this-&gt;dsns[$answers['package']] = $dsn;
$this-&gt;managedb-&gt;serializeDSN($this-&gt;dsns, $this-&gt;channel);
$this-&gt;_ui-&gt;skipParamgroup('newdefaultdsn');
break;
case 'newdefaultdsn' :
$dsn = $answers['user'] . ':' . $answers['password'] . '@' .
$answers['host'] . '/' . $answers['database'];
$this-&gt;dsns[0] = $dsn;
$this-&gt;managedb-&gt;serializeDSN($this-&gt;dsns, $this-&gt;channel);
break;
case '_undoOnError' :
// answers contains paramgroups that succeeded in
// reverse order foreach ($answers as $group) {
}
break;
}
return true;
}
/**
* Run the setup paramgroup
*
* @param array $answers
* @return boolean
* @access private
*/
function _doSetup($answers)
{
$reg = &amp;$this-&gt;_config-&gt;getRegistry();
if (!$reg-&gt;channelExists($answers['channel'])) {
$this-&gt;_ui-&gt;outputData('ERROR: channel "' .
$answers['channel'] . '" is not registered, use the channel-discover command');
return false;
}
$this-&gt;channel = $answers['channel'];
$this-&gt;driver = $this-&gt;_config-&gt;get('chiaramdb2schema_driver', null, $this-&gt;channel);
$this-&gt;dsnvalue = $this-&gt;_config-&gt;get('chiaramdb2schema_dsn',
null, $this-&gt;channel);
$this-&gt;passwordvalue = $this-&gt;_config-&gt;get('chiaramdb2schema_dsn', null,
$this-&gt;channel);
if (!$this-&gt;dsnvalue) {
// magically skip the "choosedsn", "deleteDSN" and
// "modifydsn" &lt;paramgroup&gt;s,
// and only create a new, default DSN
$this-&gt;_ui-&gt;skipParamgroup('choosedsn');
$this-&gt;_ui-&gt;skipParamgroup('deletedsn');
$this-&gt;_ui-&gt;skipParamgroup('modifydsn');
$this-&gt;_ui-&gt;skipParamgroup('newpackagedsn');
}
return true;
}
}
?&gt;
</pre></div><p>Post-installation scripts interact intimately with the different front ends that PEAR provides. There are many possibilities available to a script. In addition to using data provided by the user, a post-installation script can interactively modify prompts based on the user's previous answers, and can dynamically skip entire<code class="literal">&lt;tasks:paramgroup&gt;</code> sections. These capabilities allow significant customization of the actual script.</p><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="ch03lvl3sec05"/></h3></div></div></div><div class="section" title="Components of a Post-Install Script"><div class="titlepage"><div><div><h4 class="title"><a id="ch03lvl4sec05"/>Components of a Post-Install Script</h4></div></div></div><p>Every post-installation script must define two methods,<code class="literal"> init()</code> and<code class="literal"> run()</code>. The<code class="literal"> init()</code> method should be defined somewhat like this:<a id="id170" class="indexterm"/>
</p><div class="informalexample"><pre class="programlisting">/**
* Initialize the post-installation script
*
* @param PEAR_Config $config
* @param PEAR_PackageFile_v2 $pkg
* @param string|null $lastversion Last installed version. * Not used in this script
* @return boolean success of initialization
*/
function init(&amp;$config, &amp;$pkg, $lastversion)
{
require_once 'PEAR/Task/Chiara/Managedb.php';
$this-&gt;_config = &amp;$config;
$this-&gt;_ui = &amp;PEAR_Frontend::singleton();
$this-&gt;managedb = new PEAR_Task_Chiara_Managedb($config, $this-&gt;_ui,
PEAR_TASK_INSTALL);
$this-&gt;_pkg = &amp;$pkg;
if (!in_array('chiaramdb2schema_dsn', $this-&gt;_config-&gt;getKeys())) {
// fail: role was not installed?
return false;
}
$this-&gt;channel = $this-&gt;_config-&gt;get('default_channel');
$this-&gt;dsns = PEAR::isError($e = $this-&gt;managedb-&gt;unserializeDSN($pkg)) ? array() : $e;
return true;
}
</pre></div><p>Note the use of<code class="literal"> $this-&gt;_ui = &amp;PEAR_Frontend::singleton():</code> This line of code opens up a huge array of possibilities. In addition to exposing the entire public API available to display text, such as:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">Void outputData(string $text):</code> Displays information to the user</li><li class="listitem" style="list-style-type: disc"><code class="literal">string bold(string $text):</code> Takes the text and returns a bold-face-transformed version of that text, which can then be passed to<code class="literal"> outputData()</code></li></ul></div><p>this makes available the<code class="literal"> skipParamGroup(string $id)</code> method. The<code class="literal"> $id</code> parameter should be the ID of a paramgroup yet to be executed (contents of a<code class="literal">&lt;tasks:id&gt;</code> tag from a<code class="literal">&lt;tasks:paramgroup&gt;</code>).</p><p>Modifying the prompt or default value of a parameter is accomplished through the creation of a method named<code class="literal"> postProcessPrompts()</code>, like so:<a id="id171" class="indexterm"/>
</p><div class="informalexample"><pre class="programlisting">/**
* Set up the prompts properly for the script
*
* @param array $prompts
* @param string $section
* @return array
*/
function postProcessPrompts($prompts, $section)
{
switch ($section) {
case 'driver' :
if ($this-&gt;driver) {
$prompts[0]['default'] = $this-&gt;driver;
}
break;
case 'deletedsn' :
$count = 1;
foreach ($this-&gt;dsns as $i =&gt; $dsn) {
$text = ($i ? "(Package $i) " : '') . $dsn;
if ($count == $this-&gt;choice) {
break;
}
$count++;
}
$prompts[0]['prompt'] =
sprintf($prompts[0]['prompt'], $text);
break;
case 'choosedsn' :
$text = '';
$count = 1;
foreach ($this-&gt;dsns as $i =&gt; $dsn) {
$text .= "[$count] " . ($i ? "(Package $i) " :
'') . $dsn . "\n";
$count++;
}
$prompts[0]['prompt'] =
sprintf($prompts[0]['prompt'], $text);
break;
case 'modifydsn' :
$count = 1;
$found = false;
foreach ($this-&gt;dsns as $i =&gt; $dsn) {
if ($count == $this-&gt;choice) {
$found = true;
break;
}
$count++;
}
if ($found) {
$dsn = MDB2::parseDSN($this-&gt;dsns[$i]);
// user
$prompts[0]['default'] = $dsn['username'];
// password
if (isset($dsn['password'])) {
$prompts[1]['default'] = $dsn['password'];
}
// host
$prompts[2]['default'] = $dsn['hostspec'];
if (isset($dsn['port'])) {
$prompts[2]['default'] .= ':' . $dsn['port'];
}
// database
$prompts[3]['default'] = $dsn['database'];
}
break;
}
return $prompts;
}
</pre></div><p>The<code class="literal"> $prompts</code> parameter will be the parsed contents of a<code class="literal">&lt;tasks:paramgroup&gt;</code> tag.<a id="id173" class="indexterm"/>
</p><div class="informalexample"><pre class="programlisting">&lt;tasks:paramgroup&gt;
&lt;tasks:id&gt;databaseSetup&lt;/tasks:id&gt;
&lt;tasks:param&gt;
&lt;tasks:name&gt;database&lt;/tasks:name&gt;
&lt;tasks:prompt&gt;%s database name&lt;/tasks:prompt&gt;
&lt;tasks:type&gt;string&lt;/tasks:type&gt;
&lt;tasks:default&gt;pear&lt;/tasks:default&gt;
&lt;/tasks:param&gt;
&lt;tasks:param&gt;
&lt;tasks:name&gt;user&lt;/tasks:name&gt;
&lt;tasks:prompt&gt;%s database username&lt;/tasks:prompt&gt;
&lt;tasks:type&gt;string&lt;/tasks:type&gt;
&lt;tasks:default&gt;%s_pear&lt;/tasks:default&gt;
&lt;/tasks:param&gt;
&lt;/tasks:paramgroup&gt;
</pre></div><p>For this<code class="literal"> paramgroup</code> the<code class="literal"> $prompts</code> variable would be as follows:</p><div class="informalexample"><pre class="programlisting">array(
'id' =&gt; 'databaseSetup';
'param' =&gt;
array(
array(
'name' =&gt; 'database',
'prompt' =&gt; '%s database name',
'type' =&gt; 'string',
'default' =&gt; 'pear',
),
array(
'name' =&gt; 'user',
'prompt' =&gt; '%s database username',
'type' =&gt; 'string',
'default' =&gt; '%s_pear',
),
),
);
</pre></div><p>The<code class="literal"> postProcessPrompts()</code> method should return the<code class="literal"> $prompts</code> array with modifications only to the prompt and default fields. If anything else is modified, it will cause the post-install script to simply fail.<a id="id174" class="indexterm"/>
</p><p>For instance, after determining that the user is using the pgSQL driver, the return value from<code class="literal"> postProcessPrompts()</code> could be:</p><div class="informalexample"><pre class="programlisting">array(
'id' =&gt; 'databaseSetup';
'param' =&gt;
array(
array(
'name' =&gt; 'database',
'prompt' =&gt; 'Postgresql database name',
'type' =&gt; 'string',
'default' =&gt; 'pear',
),
array(
'name' =&gt; 'user',
'prompt' =&gt; 'Postgresql database username',
'type' =&gt; 'string',
'default' =&gt; 'pgsql_pear',
),
),
);
</pre></div><p>In addition, the entire prompt can be replaced. This could be a simple way to handle internationalization as well. For example:</p><div class="informalexample"><pre class="programlisting">array(
'id' =&gt; 'databaseSetup';
'param' =&gt;
array(
array(
'name' =&gt; 'database',
'prompt' =&gt; 'Nom de la base de données Postgresql',
'type' =&gt; 'string',
'default' =&gt; 'pear',
),
array(
'name' =&gt; 'user',
'prompt' =&gt; 'Nom d'utilisateur de la base de données Postgresql',
'type' =&gt; 'string',
'default' =&gt; 'pgsql_pear',
),
),
);
<a id="id175" class="indexterm"/>
</pre></div><p>The<code class="literal"> run()</code> method should accept two kinds of parameters. In normal operation, the first parameter will be an array containing the user's answers, and the second parameter will be the ID of the paramgroup. For this<code class="literal">&lt;tasks:paramgroup&gt;</code>, sample values might be:<a id="id176" class="indexterm"/>
</p><div class="informalexample"><pre class="programlisting">array(
'database' =&gt; 'huggiepear',
'user' =&gt; 'killinator',
);
</pre></div><p>And the ID would be (as you might imagine)<code class="literal">'databaseSetup'</code>.</p><p>In addition to these features designed for success, sometimes, it is necessary to abort a post-installation script on error. In these cases, the<code class="literal"> run()</code> method is also called with two parameters, but the second is<code class="literal">'_undoOnError'</code>, and the first is an array of completed paramgroup IDs in reverse order, to facilitate iteration for rolling back changes made by the post-install script.</p><div class="note" title="Note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="tip25"/>Tip</h3><p><span class="strong"><strong>_undoOnError is the Error Header and not Another Paramgroup ID?</strong></span></p><p>A Paramgroup ID cannot begin with an underscore, it may only contain alphanumeric characters. Hence,<code class="literal"> _undoOnError</code> is the error header and not another paramgroup ID.</p></div></div></div></div></div>
<div class="section" title="Bundling Several Packages into a Single Archive"><div class="titlepage"><div><div><h1 class="title"><a id="ch03lvl1sec04"/>Bundling Several Packages into a Single Archive</h1></div></div></div><p>Often, it is a desired feature to bundle a package and its dependencies into a single installable archive. There are two ways of doing this. The simplest way is to use a<code class="literal"> package.xml</code> file similar to this one:<a id="id177" class="indexterm"/>
</p><div class="informalexample"><pre class="programlisting">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;package version="2.0" 


xsi:schemaLocation="http://pear.php.net/dtd/tasks-1.0
http://pear.php.net/dtd/tasks-1.0.xsd
http://pear.php.net/dtd/package-2.0
http://pear.php.net/dtd/package-2.0.xsd"&gt;
&lt;name&gt;PEAR_all&lt;/name&gt;
&lt;channel&gt;pear.php.net&lt;/channel&gt;
&lt;summary&gt;PEAR Base System&lt;/summary&gt;
&lt;description&gt;
The PEAR package and its dependencies
&lt;/description&gt;
&lt;lead&gt;
&lt;name&gt;Greg Beaver&lt;/name&gt;
&lt;user&gt;cellog&lt;/user&gt;
&lt;email&gt;cellog@php.net&lt;/email&gt;
&lt;active&gt;yes&lt;/active&gt;
&lt;/lead&gt;
&lt;date&gt;2005-09-25&lt;/date&gt;
&lt;version&gt;
&lt;release&gt;1.4.2&lt;/release&gt;
&lt;api&gt;1.0.0&lt;/api&gt;
&lt;/version&gt;
&lt;stability&gt;
&lt;release&gt;stable&lt;/release&gt;
&lt;api&gt;stable&lt;/api&gt;
&lt;/stability&gt;
&lt;license uri="http://www.php.net/license"&gt;PHP License&lt;/license&gt;
&lt;notes&gt;
This contains PEAR version 1.4.2 and its dependencies
&lt;/notes&gt;
&lt;contents&gt;
&lt;bundledpackage&gt;PEAR-1.4.2.tgz&lt;/bundledpackage&gt;
&lt;bundledpackage&gt;Archive_Tar-1.3.1.tgz&lt;/bundledpackage&gt;
&lt;bundledpackage&gt;Console_Getopt-1.2.tgz&lt;/bundledpackage&gt;
&lt;bundledpackage&gt;XML_RPC-1.4.3.tgz&lt;/bundledpackage&gt;
&lt;/contents&gt;
&lt;dependencies&gt;
&lt;required&gt;
&lt;php&gt;
&lt;min&gt;4.2&lt;/min&gt;
&lt;/php&gt;
&lt;pearinstaller&gt;
&lt;min&gt;1.4.0a12&lt;/min&gt;
&lt;/pearinstaller&gt;
&lt;/required&gt;
&lt;/dependencies&gt;
&lt;bundle/&gt;
&lt;/package&gt;
</pre></div><p>This simple<code class="literal"> package.xml</code> can then be packaged into<code class="literal"> PEAR_all-1.4.2.tgz</code>, and distributed as a single archive that users can use to upgrade all packages from a non-internet location via:<a id="id178" class="indexterm"/>
</p><div class="informalexample"><pre class="programlisting"><span class="strong"><strong>$ pear upgrade PEAR_all-1.4.2.tgz
</strong></span>
</pre></div><p>The other way of distributing dependencies is a clever mixture of the old bundle-all-dependencies approach and the PEAR way of distributing dependencies.</p></div>
<div class="section" title="Backwards Compatibility: Using package.xml 1.0 and 2.0"><div class="titlepage"><div><div><h1 class="title"><a id="ch03lvl1sec05"/>Backwards Compatibility: Using package.xml 1.0 and 2.0</h1></div></div></div><p>One of the most important new features of PEAR version 1.4.0 and newer that comes with the advent of<code class="literal"> package.xml 2.0</code> is the ability to make a package installable by older PEAR versions. The package command, invoked with the following historically takes a<code class="literal"> package.xml</code> and spits out a GZIP-compressed tar (<code class="literal">.tgz</code>) file.<a id="id179" class="indexterm"/>
</p><div class="informalexample"><pre class="programlisting"><span class="strong"><strong>$ pear package
</strong></span>
</pre></div><p>If the package name is<code class="literal"> Foo</code>, and the version is<code class="literal"> 1.0.0</code>, the<code class="literal"> .tgz</code> file will be named<code class="literal"> Foo-1.0.0.tgz</code>. New in version 1.4.0, if there is a second<code class="literal"> package.xml</code> named<code class="literal"> package2.xml</code>, the package command will attempt to include it in the archive. When PEAR downloads a package for installation, it first looks for a<code class="literal"> package2.xml</code> file, which is always in version 2.0 format, and then falls back to<code class="literal"> package.xml</code>. In this way, older versions of PEAR are supported, because they always look for<code class="literal"> package.xml</code> first.</p><p>For this to work, PEAR does a very strict comparison of the contents of the<code class="literal"> package.xml</code> files.<code class="literal"> package.xml</code> version 1.0 and<code class="literal"> package.xml</code> version 2.0, must satisfy the following list of constraints to be considered equivalent, otherwise validation will fail:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Same package name</li><li class="listitem" style="list-style-type: disc">Same package summary</li><li class="listitem" style="list-style-type: disc">Same package description</li><li class="listitem" style="list-style-type: disc">Same package version (release version)</li><li class="listitem" style="list-style-type: disc">Same package stability (release stability/state)</li><li class="listitem" style="list-style-type: disc">Same license</li><li class="listitem" style="list-style-type: disc">Same release notes</li><li class="listitem" style="list-style-type: disc">Same maintainers</li><li class="listitem" style="list-style-type: disc">All files in<code class="literal"> package.xml 1.0</code> must be present in<code class="literal"> package.xml 2.0 &lt;contents&gt;</code></li></ul></div><p>Note that because<code class="literal"> package.xml 2.0</code> allows files to be present but ignored during installation using the<code class="literal">&lt;ignore&gt;</code> tag,<code class="literal"> package.xml 2.0</code> can be used to provide an archive that is both PEAR-installable as well as unzip-and-go.<a id="id180" class="indexterm"/>
</p></div>
<div class="section" title="Why Support Old and Crusty package.xml 1.0?"><div class="titlepage"><div><div><h1 class="title"><a id="ch03lvl1sec06"/>Why Support Old and Crusty package.xml 1.0?</h1></div></div></div><p>This is a common debate in the PHP world. Why support backwards compatibility? These are old, buggy versions of PEAR, right? Yes, they are old and buggy versions and anyone using them is asking for trouble, but people may not find a compelling reason to upgrade their PEAR installer just so that they can use your package because what they have already "works for them". It is (or should be) your goal as a package distributor to make the process of upgrading as painless as possible. You should only drop<code class="literal"> package.xml</code> version 1.0 support if you are in fact using new features of PEAR itself in the PHP code, or your package is a new one without an installed userbase.<a id="id181" class="indexterm"/>
</p><p>PEAR development has progressed at a rapid pace, but the adoption of the new installer will not happen overnight. Large software projects like Linux distributions need time to evaluate the new features and make sure that everything works properly prior to adopting a new version. As PEAR developers, we must honor this need.</p><p>Once the installed userbase is no longer using the old and buggy versions of PEAR, upgrading the installer dependency is an option that should be taken up as soon as possible, for the sake of the users themselves. Having said this, PEAR users need to upgrade as soon as possible to avoid security holes discovered in older versions of the PEAR installer.</p><div class="note" title="Note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="tip26"/>Tip</h3><p><span class="strong"><strong>Security Issues in PEAR 1.4.3 and Older</strong></span></p><p>A few months before writing this chapter, two major security holes were discovered in PEAR. Basically, if you're using PEAR 1.4.3 or older, you need to upgrade as soon as possible.</p><p>Details are available at: <a class="ulink" href="http://pear.php.net/advisory-20051104.txt"> http://pear.php.net/advisory-20051104.txt</a> and <a class="ulink" href="http://pear.php.net/advisory-20060108.txt"> http://pear.php.net/advisory-20060108.txt</a>.</p></div></div>
<div class="section" title="Case Study: The PEAR Package"><div class="titlepage"><div><div><h1 class="title"><a id="ch03lvl1sec07"/>Case Study: The PEAR Package</h1></div></div></div><p>PEAR is a perfect example of a package that will always need to support<code class="literal"> package.xml 1.0</code>. We will always have users who are upgrading from an earlier version to the latest one and PEAR 1.3.6 and older simply doesn't know anything about<code class="literal"> package.xml 2.0</code>. If we don't make it possible to upgrade PEAR, there isn't much point in making the code available.<a id="id182" class="indexterm"/>
</p><p>However, at the same time, the new dependency features and tasks of<code class="literal"> package.xml 2.0</code> are very important for the PEAR package, and so both<code class="literal"> package.xml 1.0</code> and<code class="literal"> package.xml 2.0</code> are needed. For instance, the<code class="literal"> pear</code> command itself is a shell script on UNIX (with UNIX<code class="literal"> \n</code> line endings) and a batch file on Windows (with Windows<code class="literal"> \r\n</code> line endings). Before<code class="literal"> package.xml 2.0</code>, it was necessary to add these scripts as binary files to CVS, so that the line endings are not replaced with the packager's system line endings. Now, through the use of the<code class="literal">&lt;tasks:windowseol/&gt;</code> and<code class="literal">&lt;tasks:unixeol/&gt;</code> tasks, this is no longer necessary, as the correct line endings are set at package time. In addition, because of incompatibilities between PEAR 1.4.0 and earlier versions of PEAR_Frontend_Web and the older PEAR_Frontend_Gtk (superseded by PEAR_Frontend_Gtk2), it is necessary to check for the presence of these versions, and to silently succeed if the versions are OK.<code class="literal"> package.xml 2.0</code> provides this functionality through the use of the<code class="literal">&lt;conflicts/&gt;</code> tag in a package dependency.</p></div>
<div class="section" title="PEAR_PackageFileManager"><div class="titlepage"><div><div><h1 class="title"><a id="ch03lvl1sec08"/>PEAR_PackageFileManager</h1></div></div></div><p>Although the commands<code class="literal"> convert</code> and<code class="literal"> pickle</code> can be used in limited situations to manage both a<code class="literal"> package.xml</code> version 1.0 and version 2.0, these commands can also be dangerous. A far safer way to maintain two versions of<code class="literal"> package.xml</code> from a single location is through the use of the PEAR package PEAR_PackageFileManager. This package provides a simple interface from which to import an existing<code class="literal"> package.xml</code> file and update with current information, or to create a new<code class="literal"> package.xml</code> file from scratch. In addition, it is very simple to take an existing<code class="literal"> package.xml 2.0</code>, no matter how complicated it is, and easily create an equivalent<code class="literal"> package.xml 1.0</code> with absolute control over the contents of each<code class="literal"> package.xml</code>.<a id="id183" class="indexterm"/>
</p><div class="section" title="Obtaining PEAR_PackageFileManager"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec04"/>Obtaining PEAR_PackageFileManager</h2></div></div></div><p>PEAR_PackageFileManager can be easily obtained by using the PEAR installer. As of the writing of this book, version 1.6.0b1 is available. To install it, you must set the<code class="literal"> preferred_state</code> configuration variable to<code class="literal"> beta</code> via:<a id="id184" class="indexterm"/>
</p><div class="informalexample"><pre class="programlisting"><span class="strong"><strong>$ pear config-set preferred_state beta
</strong></span>
</pre></div><p>Or you can run:</p><div class="informalexample"><pre class="programlisting"><span class="strong"><strong>$ pear install PEAR_PackageFileManager-beta
</strong></span>
</pre></div><p>Of course, it is always good practice to determine the latest version at <a class="ulink" href="http://pear.php.net/package/PEAR_PackageFileManager"> http://pear.php.net/package/PEAR_PackageFileManager</a> and to install that version.</p></div><div class="section" title="PEAR_PackageFileManager Script and the package.xml Files it Generates"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec05"/>PEAR_PackageFileManager Script and the package.xml Files it Generates</h2></div></div></div><p>For our sample<code class="literal"> PEAR_PackageFileManager</code> script, we will be generating a<code class="literal"> package.xml</code> for the<code class="literal"> Chiara_Managedb</code> task. Before writing the<code class="literal"> package.xml</code> script, let's make sure we understand the components we wish to have for our<code class="literal"> package.xml</code>. In our case, we will have three files to package up, the<code class="literal"> Managedb.php</code> file containing the actual code for the task, the<code class="literal"> rw.php</code> file containing the read/writable<code class="literal"> PEAR_Task_Chiara_Managedb_rw</code> class for adding the task to<code class="literal"> package.xml</code> through the<code class="literal"> PEAR_PackageFile_v2_rw</code> API, and<code class="literal"> rolesetup.php</code>, the post-installation script for initializing the<code class="literal"> chiaramdb2schema</code> configuration variables.<a id="id185" class="indexterm"/>
</p><p>There are several important details to note before diving into the source. First of all, this script generates a<code class="literal"> package.xml</code> file from scratch. Most scripts will not need this kind of detail when using the<code class="literal"> importOptions()</code> method. In addition, it is important to note that the<code class="literal"> PEAR_PackageFileManager2</code> class extends the<code class="literal"> PEAR_PackageFile_v2_rw</code> class provided with PEAR itself. This allows use of utility methods such as</p><p>
<code class="literal">setPackage()</code> and others to tweak the contents of the<code class="literal"> package.xml</code>. Let's take a look at how to generate a somewhat complicated<code class="literal"> package.xml 2.0</code> with a post-installation script.<a id="id186" class="indexterm"/>
</p><div class="informalexample"><pre class="programlisting">&lt;?php
/**
* package.xml generation script for Task_Chiara_Managedb package
* @author Gregory Beaver &lt;cellog@php.net&gt;
*/
require_once 'PEAR/PackageFileManager2.php';
PEAR::setErrorHandling(PEAR_ERROR_DIE);
$pfm = &amp;PEAR_PackageFileManager2::importOptions('package.xml',
array(
// set a subdirectory everything is installed into
'baseinstalldir' =&gt; 'PEAR/Task/Chiara',
// location of files to package
'packagedirectory' =&gt; dirname(__FILE__),
// what method is used to glob files? cvs, svn, perforce
// and file are options
'filelistgenerator' =&gt; 'file',
// don't distribute this script
'ignore' =&gt; array('package.php', 'package2.xml', 'package.xml'),
// put the post-installation script in a
// different location from the task itself
'installexceptions' =&gt;
array(
'rolesetup.php' =&gt; 'Chiara/Task/Managedb',
),
// make the output human-friendly
'simpleoutput' =&gt; true,
));
$pfm-&gt;setPackage('PEAR_Task_Chiara_Managedb');
$pfm-&gt;setChannel('pear.chiaraquartet.net');
$pfm-&gt;setLicense('BSD license', 'http://www.opensource.org/licenses/bsd-license.php');
$pfm-&gt;setSummary('Provides the &lt;tasks:chiara-managedb/&gt; file task for
managing ' . 'databases on installation');
$pfm-&gt;setDescription('Task_Chiara_Managedb provides the code to
implement the &lt;tasks:chiara-managedb/&gt; task, as well as a post- installation script to manage the configuration variables it needs.
This task works in conjunction with the chiaramdb2schema file role
(package PEAR_Installer_Role_Chiaramdb2schema) to create databases
used by a package on installation, and to upgrade the database structure automatically on upgrade. To do this, it uses MDB2_Schema\'s
updateDatabase() functionality.
The post-install script must be run with "pear run-scripts"
to initialize configuration variables');
// initial release version should be 0.1.0
$pfm-&gt;addMaintainer('lead', 'cellog', 'Greg Beaver',
'cellog@php.net', 'yes');
$pfm-&gt;setAPIVersion('0.1.0');
$pfm-&gt;setReleaseVersion('0.1.0');
// our API is reasonably stable, but may need tweaking
$pfm-&gt;setAPIStability('beta');
// the code is very new, and may change dramatically
$pfm-&gt;setReleaseStability('alpha');
// release notes
$pfm-&gt;setNotes('initial release');
// this is a PHP script, not a PECL extension source/binary or a
// bundle package
$pfm-&gt;setPackageType('php');
$pfm-&gt;addRelease();
// set up special file properties
$pfm-&gt;addGlobalReplacement('package-info', '@package_version@',
'version');
$script = &amp;$pfm-&gt;initPostinstallScript('rolesetup.php');
// add paramgroups to the post-install script
$script-&gt;addParamGroup(
'setup',
$script-&gt;getParam('channel', 'Choose a channel to modify
configuration values from',
'string', 'pear.php.net'));
$script-&gt;addParamGroup(
'driver',
$script-&gt;getParam('driver', 'Database driver?'),
'In order to set up the database, please choose a database
driver. This should be a MDB2-compatible driver name, such as mysql, mysqli, Pgsql, oci8, etc.');
$script-&gt;addParamGroup(
'choosedsn',
$script-&gt;getParam('dsnchoice', '%sChoose a DSN to modify, or to add a' . ' new dsn, type "new". To remove a DSN prepend with "!"'));
$script-&gt;addParamGroup(
'deletedsn',
$script-&gt;getParam('confirm', 'Really delete "%s" DSN? (yes to delete)', 'string', 'no'));
$script-&gt;addConditionTypeGroup(
'modifydsn',
'choosedsn', 'dsnchoice', 'new', '!=',
array(
$script-&gt;getParam('user', 'User name', 'string', 'root'),
$script-&gt;getParam('password', 'Database password',
'password'),
$script-&gt;getParam('host', 'Database host', 'string',
'localhost'),
$script-&gt;getParam('database', 'Database name'),
));
$script-&gt;addParamGroup(
'newpackagedsn',
array(
$script-&gt;getParam('package', 'Package name'),
$script-&gt;getParam('user', 'User name', 'string', 'root'),
$script-&gt;getParam('password', 'Database password',
'password'),
$script-&gt;getParam('host', 'Database host', 'string',
'localhost'),
$script-&gt;getParam('database', 'Database name'),
));
$script-&gt;addParamGroup(
'newdefaultdsn',
array(
$script-&gt;getParam('user', 'User name', 'string', 'root'),
$script-&gt;getParam('password', 'Database password',
'password'),
$script-&gt;getParam('host', 'Database host', 'string',
'localhost'),
$script-&gt;getParam('database', 'Database name'),
));
$pfm-&gt;addPostinstallTask($script, 'rolesetup.php');
// start over with dependencies
$pfm-&gt;clearDeps();
$pfm-&gt;setPhpDep('4.2.0');
// we use post-install script features fixed in PEAR 1.4.3
$pfm-&gt;setPearinstallerDep('1.4.3');
$pfm-&gt;addPackageDepWithChannel('required', 'PEAR', 'pear.php.net',
'1.4.3');
$pfm-&gt;addPackageDepWithChannel('required', 'MDB2_Schema',
'pear.php.net', '0.3.0');
$pfm-&gt;addPackageDepWithChannel('required',
'PEAR_Installer_Role_Chiaramdb2schmea',
'pear.chiaraquartet.net', '0.1.0');
// create the &lt;contents&gt; tag
$pfm-&gt;generateContents();
// create package.xml 1.0 to gracefully tell PEAR 1.3.x users they have
// to upgrade to use this package
$pfm1 = $pfm-&gt;exportCompatiblePackageFile1(array(
// set a subdirectory everything is installed into
'baseinstalldir' =&gt; 'PEAR/Task/Chiara',
// location of files to package
'packagedirectory' =&gt; dirname(__FILE__),
// what method is used to glob files? cvs, svn, perforce
// and file are options
'filelistgenerator' =&gt; 'file',
// don't distribute this script
'ignore' =&gt; array('package.php', 'package.xml', 'package2.xml', 'rolesetup.php'),
// put the post-installation script in a
// different location from the task itself
// make the output human-friendly
'simpleoutput' =&gt; true,
));
// display the package.xml by default to allow "debugging" by eye,
// and then create it if explicitly asked to
if (isset($_GET['make']) || (isset($_SERVER['argv']) &amp;&amp;
@$_SERVER['argv'][1] == 'make')) {
$pfm1-&gt;writePackageFile();
$pfm-&gt;writePackageFile();
} else {
$pfm1-&gt;debugPackageFile();
$pfm-&gt;debugPackageFile();
}
?&gt;
<a id="id187" class="indexterm"/>
</pre></div><p>And the<code class="literal"> package.xml</code> it generates:<a id="id188" class="indexterm"/>
</p><div class="informalexample"><pre class="programlisting">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;package packagerversion="1.4.3" version="2.0"

 
xsi:schemaLocation="http://pear.php.net/dtd/tasks-1.0
http://pear.php.net/dtd/tasks-1.0.xsd
http://pear.php.net/dtd/package-2.0
http://pear.php.net/dtd/package-2.0.xsd"&gt;
&lt;name&gt;PEAR_Task_Chiara_Managedb&lt;/name&gt;
&lt;channel&gt;pear.chiaraquartet.net&lt;/channel&gt;
&lt;summary&gt;Provides the &amp;lt;tasks:chiara-managedb/&amp;gt; file task for
managing databases on installation&lt;/summary&gt;
&lt;description&gt;Task_Chiara_Managedb provides the code to implement the
&amp;lt;tasks:chiara-managedb/&amp;gt; task, as well as a post-installation
script to manage the configuration variables it needs.
This task works in conjunction with the chiaramdb2schema file role
(package PEAR_Installer_Role_Chiaramdb2schema) to create databases
used by a package on installation, and to upgrade the database structure automatically on upgrade. To do this, it uses MDB2_Schema&amp;apos;s
updateDatabase() functionality.
The post-install script must be run with &amp;quot;pear run-scripts&amp;quot;
to initialize configuration variables&lt;/description&gt;
&lt;lead&gt;
&lt;name&gt;Greg Beaver&lt;/name&gt;
&lt;user&gt;cellog&lt;/user&gt;
&lt;email&gt;cellog@php.net&lt;/email&gt;
&lt;active&gt;yes&lt;/active&gt;
&lt;/lead&gt;
&lt;date&gt;2005-10-18&lt;/date&gt;
&lt;time&gt;23:55:29&lt;/time&gt;
&lt;version&gt;
&lt;release&gt;0.1.0&lt;/release&gt;
&lt;api&gt;0.1.0&lt;/api&gt;
&lt;/version&gt;
&lt;stability&gt;
&lt;release&gt;alpha&lt;/release&gt;
&lt;api&gt;beta&lt;/api&gt;
&lt;/stability&gt;
&lt;license uri="http://www.opensource.org/licenses/bsd-
license.php"&gt;BSD license&lt;/license&gt;
&lt;notes&gt;initial release&lt;/notes&gt;
&lt;contents&gt;
&lt;dir baseinstalldir="PEAR/Task/Chiara" name="/"&gt;
&lt;dir name="Managedb"&gt;
&lt;file name="rw.php" role="php"&gt;
&lt;tasks:replace from="@package_version@" to="version"
type="package-info" /&gt;
&lt;/file&gt;
&lt;/dir&gt; &lt;!-- //Managedb --&gt;
&lt;file name="Managedb.php" role="php"&gt;
&lt;tasks:replace from="@package_version@" to="version"
type="package-info" /&gt;
&lt;/file&gt;
&lt;file name="rolesetup.php" role="php"&gt;
&lt;tasks:postinstallscript&gt;
&lt;tasks:paramgroup&gt;
&lt;tasks:id&gt;setup&lt;/tasks:id&gt;
&lt;tasks:param&gt;
&lt;tasks:name&gt;channel&lt;/tasks:name&gt;
&lt;tasks:prompt&gt;Choose a channel to modify configuration values
from&lt;/tasks:prompt&gt;
&lt;tasks:type&gt;string&lt;/tasks:type&gt;
&lt;tasks:default&gt;pear.php.net&lt;/tasks:default&gt;
&lt;/tasks:param&gt;
&lt;/tasks:paramgroup&gt;
&lt;tasks:paramgroup&gt;
&lt;tasks:id&gt;driver&lt;/tasks:id&gt;
&lt;tasks:instructions&gt;In order to set up the database, please choose a database driver.
This should be a MDB2-compatible driver name, such as mysql, mysqli, Pgsql, oci8, etc. &lt;/tasks:instructions&gt;
&lt;tasks:param&gt;
&lt;tasks:name&gt;driver&lt;/tasks:name&gt;
&lt;tasks:prompt&gt;Database driver?&lt;/tasks:prompt&gt;
&lt;tasks:type&gt;string&lt;/tasks:type&gt;
&lt;/tasks:param&gt;
&lt;/tasks:paramgroup&gt;
&lt;tasks:paramgroup&gt;
&lt;tasks:id&gt;choosedsn&lt;/tasks:id&gt;
&lt;tasks:param&gt;
&lt;tasks:name&gt;dsnchoice&lt;/tasks:name&gt;
&lt;tasks:prompt&gt;%sChoose a DSN to modify, or to add a new dsn, type &amp;quot;new&amp;quot;. To remove a DSN prepend with &amp;quot;!&amp;quot; &lt;/tasks:prompt&gt;
&lt;tasks:type&gt;string&lt;/tasks:type&gt;
&lt;/tasks:param&gt;
&lt;/tasks:paramgroup&gt;
&lt;tasks:paramgroup&gt;
&lt;tasks:id&gt;deletedsn&lt;/tasks:id&gt;
&lt;tasks:param&gt;
&lt;tasks:name&gt;confirm&lt;/tasks:name&gt;
&lt;tasks:prompt&gt;Really delete &amp;quot;%s&amp;quot; DSN? (yes to delete)&lt;/tasks:prompt&gt;
&lt;tasks:type&gt;string&lt;/tasks:type&gt;
&lt;tasks:default&gt;no&lt;/tasks:default&gt;
&lt;/tasks:param&gt;
&lt;/tasks:paramgroup&gt;
&lt;tasks:paramgroup&gt;
&lt;tasks:id&gt;modifydsn&lt;/tasks:id&gt;
&lt;tasks:name&gt;choosedsn::dsnchoice&lt;/tasks:name&gt;
&lt;tasks:conditiontype&gt;!=&lt;/tasks:conditiontype&gt;
&lt;tasks:value&gt;new&lt;/tasks:value&gt;
&lt;tasks:param&gt;
&lt;tasks:name&gt;user&lt;/tasks:name&gt;
&lt;tasks:prompt&gt;User name&lt;/tasks:prompt&gt;
&lt;tasks:type&gt;string&lt;/tasks:type&gt;
&lt;tasks:default&gt;root&lt;/tasks:default&gt;
&lt;/tasks:param&gt;
&lt;tasks:param&gt;
&lt;tasks:name&gt;password&lt;/tasks:name&gt;
&lt;tasks:prompt&gt;Database password&lt;/tasks:prompt&gt;
&lt;tasks:type&gt;password&lt;/tasks:type&gt;
&lt;/tasks:param&gt;
&lt;tasks:param&gt;
&lt;tasks:name&gt;host&lt;/tasks:name&gt;
&lt;tasks:prompt&gt;Database host&lt;/tasks:prompt&gt;
&lt;tasks:type&gt;string&lt;/tasks:type&gt;
&lt;tasks:default&gt;localhost&lt;/tasks:default&gt;
&lt;/tasks:param&gt;
&lt;tasks:param&gt;
&lt;tasks:name&gt;database&lt;/tasks:name&gt;
&lt;tasks:prompt&gt;Database name&lt;/tasks:prompt&gt;
&lt;tasks:type&gt;string&lt;/tasks:type&gt;
&lt;/tasks:param&gt;
&lt;/tasks:paramgroup&gt;
&lt;tasks:paramgroup&gt;
&lt;tasks:id&gt;newpackagedsn&lt;/tasks:id&gt;
&lt;tasks:param&gt;
&lt;tasks:name&gt;package&lt;/tasks:name&gt;
&lt;tasks:prompt&gt;Package name&lt;/tasks:prompt&gt;
&lt;tasks:type&gt;string&lt;/tasks:type&gt;
&lt;/tasks:param&gt;
&lt;tasks:param&gt;
&lt;tasks:name&gt;user&lt;/tasks:name&gt;
&lt;tasks:prompt&gt;User name&lt;/tasks:prompt&gt;
&lt;tasks:type&gt;string&lt;/tasks:type&gt;
&lt;tasks:default&gt;root&lt;/tasks:default&gt;
&lt;/tasks:param&gt;
&lt;tasks:param&gt;
&lt;tasks:name&gt;password&lt;/tasks:name&gt;
&lt;tasks:prompt&gt;Database password&lt;/tasks:prompt&gt;
&lt;tasks:type&gt;password&lt;/tasks:type&gt;
&lt;/tasks:param&gt;
&lt;tasks:param&gt;
&lt;tasks:name&gt;host&lt;/tasks:name&gt;
&lt;tasks:prompt&gt;Database host&lt;/tasks:prompt&gt;
&lt;tasks:type&gt;string&lt;/tasks:type&gt;
&lt;tasks:default&gt;localhost&lt;/tasks:default&gt;
&lt;/tasks:param&gt;
&lt;tasks:param&gt;
&lt;tasks:name&gt;database&lt;/tasks:name&gt;
&lt;tasks:prompt&gt;Database name&lt;/tasks:prompt&gt;
&lt;tasks:type&gt;string&lt;/tasks:type&gt;
&lt;/tasks:param&gt;
&lt;/tasks:paramgroup&gt;
&lt;tasks:paramgroup&gt;
&lt;tasks:id&gt;newdefaultdsn&lt;/tasks:id&gt;
&lt;tasks:param&gt;
&lt;tasks:name&gt;user&lt;/tasks:name&gt;
&lt;tasks:prompt&gt;User name&lt;/tasks:prompt&gt;
&lt;tasks:type&gt;string&lt;/tasks:type&gt;
&lt;tasks:default&gt;root&lt;/tasks:default&gt;
&lt;/tasks:param&gt;
&lt;tasks:param&gt;
&lt;tasks:name&gt;password&lt;/tasks:name&gt;
&lt;tasks:prompt&gt;Database password&lt;/tasks:prompt&gt;
&lt;tasks:type&gt;password&lt;/tasks:type&gt;
&lt;/tasks:param&gt;
&lt;tasks:param&gt;
&lt;tasks:name&gt;host&lt;/tasks:name&gt;
&lt;tasks:prompt&gt;Database host&lt;/tasks:prompt&gt;
&lt;tasks:type&gt;string&lt;/tasks:type&gt;
&lt;tasks:default&gt;localhost&lt;/tasks:default&gt;
&lt;/tasks:param&gt;
&lt;tasks:param&gt;
&lt;tasks:name&gt;database&lt;/tasks:name&gt;
&lt;tasks:prompt&gt;Database name&lt;/tasks:prompt&gt;
&lt;tasks:type&gt;string&lt;/tasks:type&gt;
&lt;/tasks:param&gt;
&lt;/tasks:paramgroup&gt;
&lt;/tasks:postinstallscript&gt;
&lt;tasks:replace from="@package_version@" to="version"
type="package-info" /&gt;
&lt;/file&gt;
&lt;/dir&gt; &lt;!-- / --&gt;
&lt;/contents&gt;
&lt;dependencies&gt;
&lt;required&gt;
&lt;php&gt;
&lt;min&gt;4.2.0&lt;/min&gt;
&lt;/php&gt;
&lt;pearinstaller&gt;
&lt;min&gt;1.4.3&lt;/min&gt;
&lt;/pearinstaller&gt;
&lt;package&gt;
&lt;name&gt;PEAR&lt;/name&gt;
&lt;channel&gt;pear.php.net&lt;/channel&gt;
&lt;min&gt;1.4.3&lt;/min&gt;
&lt;/package&gt;
&lt;package&gt;
&lt;name&gt;MDB2_Schema&lt;/name&gt;
&lt;channel&gt;pear.php.net&lt;/channel&gt;
&lt;min&gt;0.3.0&lt;/min&gt;
&lt;/package&gt;
&lt;package&gt;
&lt;name&gt;PEAR_Installer_Role_Chiaramdb2schema&lt;/name&gt;
&lt;channel&gt;pear.chiaraquartet.net&lt;/channel&gt;
&lt;min&gt;0.1.0&lt;/min&gt;
&lt;/package&gt;
&lt;/required&gt;
&lt;/dependencies&gt;
&lt;phprelease /&gt;
&lt;changelog&gt;
&lt;release&gt;
&lt;version&gt;
&lt;release&gt;0.1.0&lt;/release&gt;
&lt;api&gt;0.1.0&lt;/api&gt;
&lt;/version&gt;
&lt;stability&gt;
&lt;release&gt;alpha&lt;/release&gt;
&lt;api&gt;beta&lt;/api&gt;
&lt;/stability&gt;
&lt;date&gt;2005-10-18&lt;/date&gt;
&lt;license&gt;BSD license&lt;/license&gt;
&lt;notes&gt;initial release&lt;/notes&gt;
&lt;/release&gt;
&lt;/changelog&gt;
&lt;/package&gt;
</pre></div></div><div class="section" title="How PEAR_PackageFileManager Makes a Hard Life Easy"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec06"/>How PEAR_PackageFileManager Makes a Hard Life Easy</h2></div></div></div><p>Astute readers may have noticed that the<code class="literal"> package.xml</code> generation script is quite extensive and long. The good news is that in many cases, this will be unnecessary. In fact, the initial generation of<code class="literal"> package.xml</code> is generally not the most important feat accomplished by PEAR_PackageFileManager. Far more significant is the management of release data. Maintaining a<code class="literal"> package.xml</code> file, and in many instances<code class="literal"> package.xml</code> and<code class="literal"> package2.xml</code> is a serious problem. Although the PEAR installer makes it a bit easier by doing a careful equivalency comparison between package files, this process is not perfect.</p><p>PEAR_PackageFileManager takes the same data and uses explicit logic to generate the metadata that is<code class="literal"> package.xml</code> guaranteeing that equivalent<code class="literal"> package.xml</code> files will be created. In addition, the centralization of data means that you need to modify only the script when updating release notes. In addition, it is impossible to generate an invalid<code class="literal"> package.xml</code>, as PEAR's built-in<code class="literal"> package.xml</code> validation is used to validate generated<code class="literal"> package.xml</code> files — the same validation used on packaging and on installation.<a id="id193" class="indexterm"/>
</p><div class="section" title="Globbing Files for package.xml"><div class="titlepage"><div><div><h3 class="title"><a id="ch03lvl3sec06"/>Globbing Files for package.xml</h3></div></div></div><p>The single most important function that PEAR_PackageFileManager performs is the creation of the file list. Our simple package only has a few files in it, but for large, complex packages like PhpDocumentor ( <a class="ulink" href="http://pear.php.net/PhpDocumentor">http://pear.php.net/PhpDocumentor</a>), it becomes an increasingly difficult task to manage<code class="literal"> package.xml</code>. PhpDocumentor not only has several hundred files in it, but they also tend to change dramatically from release to release because of the use of Smarty templates.<a id="id194" class="indexterm"/>
</p><p>By turning off the<code class="literal"> simpleoutput</code> option, it is possible to easily detect modified files and monitor this from release to release without having to rely upon external tools.</p><div class="note" title="Note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="tip27"/>Tip</h3><p><span class="strong"><strong>Why was PEAR_PackageFileManager Conceived?</strong></span></p><p>Originally, PEAR_PackageFileManager was a single script for generating PhpDocumentor's<code class="literal"> package.xml</code>. Over time, as more requests for the script came in, it improved and eventually it became clear that it should be a standalone project.</p></div><p>At first, PEAR_PackageFileManager simply globbed all of the files in the current file list, using an<code class="literal">'ignore'</code> option with shell wildcards to exclude files. For instance, we can ignore all files containing "test" in their name with this wildcard:<code class="literal">"*test*"</code>. In addition, entire directories and all contents including subdirectories can be ignored by appending a "/" to the pattern as in<code class="literal">"CVS/"</code>.</p><p>The previous example highlights one of the problems with this approach: In a CVS-based package, there may be files that are not part of the project inside the package and would not be exported with the<code class="literal"> cvs export</code> command. As such, PEAR_PackageFileManager has several file-globbing drivers, or file list generators. The choice of which file list generator driver to use is controlled by the<code class="literal">'filelistgenerator'</code> option in the<code class="literal"> setOptions()/importOptions()</code> family of methods. The simplest is the<code class="literal"> file</code> generator.</p><p>Other drivers are<code class="literal">'cvs', 'svn'</code>, and<code class="literal">'perforce'</code>. Each of these drivers is identical to the<code class="literal">'file'</code> driver except that instead of simply globbing every file in a directory and all subdirectories, it limits the list of files to those in a local checkout of a remote revision source control repository. Concurrent Versioning System (CVS), Subversion, and Perforce are all revision source control repository systems. If you don't know what they are, it would be a good idea to investigate Subversion and CVS, as both are free, open-source solutions. Subversion is much more full-featured than CVS, and is newer, whereas CVS is a tried-and-true warhorse.</p></div><div class="section" title="Managing Changelog"><div class="titlepage"><div><div><h3 class="title"><a id="ch03lvl3sec07"/>Managing Changelog</h3></div></div></div><p>PEAR_PackageFileManager automatically generates a changelog for the current release, by default from oldest to newest. There are a few options for controlling this. First, the<code class="literal">'changelogoldtonew'</code> option, if set to false, will re-order the changelog so that newer entries are closer to the top of the file. In addition, if a different set of notes is to be used for the changelog than the release notes, use the<code class="literal">'changelognotes'</code> option to control this.<a id="id195" class="indexterm"/>
</p></div><div class="section" title="Synchronizing package.xml Version 1.0 and package.xml Version 2.0"><div class="titlepage"><div><div><h3 class="title"><a id="ch03lvl3sec08"/>Synchronizing package.xml Version 1.0 and package.xml Version 2.0</h3></div></div></div><p>In some cases, it might be necessary to generate an equivalent<code class="literal"> package.xml</code> version 1.0. For instance, we may wish to allow PEAR 1.3.x users to gracefully fail with a "requires PEAR 1.4.3 or newer" error message. Doing this with PEAR_PackageFileManager is a piece of cake. Change the<code class="literal"> importOptions</code> line from:<a id="id196" class="indexterm"/>
</p><div class="informalexample"><pre class="programlisting">$pfm = &amp;PEAR_PackageFileManager2::importOptions('package.xml',
</pre></div><p>To this:</p><div class="informalexample"><pre class="programlisting">$pfm = &amp;PEAR_PackageFileManager2::importOptions('package2.xml',
</pre></div><p>Then, change the last few lines of the script to:</p><div class="informalexample"><pre class="programlisting">// create the &lt;contents&gt; tag
$pfm-&gt;generateContents();
// create package.xml 1.0 to gracefully tell PEAR 1.3.x users they
// have to upgrade to use this package
$pfm1 = $pfm-&gt;exportCompatiblePackageFile1(array(
// set a subdirectory everything is installed into
'baseinstalldir' =&gt; 'PEAR/Task/Chiara',
// location of files to package
'packagedirectory' =&gt; dirname(__FILE__),
// what method is used to glob files? cvs, svn, perforce
// and file are options
'filelistgenerator' =&gt; 'file',
// don't distribute this script
'ignore' =&gt; array('package.php', 'package.xml',
'package2.xml', 'rolesetup.php'),
// put the post-installation script in a
// different location from the task itself
// make the output human-friendly
'simpleoutput' =&gt; true,
));
// display the package.xml by default to allow "debugging" by eye,
// and then create it if explicitly asked to
if (isset($_GET['make']) || (isset($_SERVER['argv']) &amp;&amp;
@$_SERVER['argv'][1] == 'make')) {
$pfm1-&gt;writePackageFile();
$pfm-&gt;writePackageFile();
} else {
$pfm1-&gt;debugPackageFile();
$pfm-&gt;debugPackageFile();
}
?&gt;
</pre></div><p>The script will then output both<code class="literal"> package.xml</code> and<code class="literal"> package2.xml</code>.<a id="id197" class="indexterm"/>
</p></div></div></div>
<div class="section" title="Creating a Package for Installation with the PEAR Installer"><div class="titlepage"><div><div><h1 class="title"><a id="ch03lvl1sec09"/>Creating a Package for Installation with the PEAR Installer</h1></div></div></div><p>The final step in the process is creating a package. Once you have a<code class="literal"> package.xml</code> file that has been generated, you can use it to create a file containing the contents of the package. To do this, you should use the<code class="literal"> package</code> command:<a id="id198" class="indexterm"/>
</p><div class="informalexample"><pre class="programlisting"><span class="strong"><strong>$ pear package
</strong></span>
</pre></div><p>This command should be executed from the directory containing the<code class="literal"> package.xml</code> file. This will create a<code class="literal"> .tgz</code> file like<code class="literal"> Package-version.tgz</code> where<code class="literal"> Package</code> is the package name, and<code class="literal"> version</code> is the release version. If your package is named<code class="literal"> Foo</code> and is version<code class="literal"> 1.2.3</code> the package command will create a file named<code class="literal"> Foo-1.2.3.tgz</code>. This file can be installed with:</p><div class="informalexample"><pre class="programlisting"><span class="strong"><strong>$ pear install Foo-1.2.3.tgz
</strong></span>
</pre></div><p>Or can also be uploaded to a channel server for public release (discussed in <a class="link" href="ch05.html" title="Chapter 5. Releasing to the World: PEAR Channels">Chapter 5</a>).</p><p>The package command can also be used to create an uncompressed<code class="literal"> .tar</code> file with the<code class="literal"> --uncompress</code> or<code class="literal"> -Z</code> option:</p><div class="informalexample"><pre class="programlisting"><span class="strong"><strong>$ pear package Z
</strong></span>
</pre></div><p>In some cases, you may have renamed a package file. In this case, it is necessary to explicitly specify a<code class="literal"> package.xml</code> to be used for packaging as in:</p><div class="informalexample"><pre class="programlisting"><span class="strong"><strong>$ pear package package-PEAR.xml package2.xml
</strong></span>
</pre></div><p>This is the actual command line used to create the PEAR package for release. Note that it does not matter which<code class="literal"> package.xml</code> (version 1.0 or version 2.0) is passed in, the following command-line sequence is identical.</p><div class="informalexample"><pre class="programlisting"><span class="strong"><strong>$ pear package package2.xml package-PEAR.xml
</strong></span>
</pre></div><p>However, if both<code class="literal"> package.xml</code> are the same version, the packaging will fail. In addition, there is a strict comparison made between the two<code class="literal"> package.xml</code> files. If there is even the slightest difference between the texts of the<code class="literal">&lt;description&gt;</code> tag,<code class="literal">&lt;summary&gt;</code> tag, or<code class="literal">&lt;notes&gt;</code> tag, validation will fail. In fact, every file within the<code class="literal"> package.xml 1.0</code> must be contained with the<code class="literal"> package.xml 2.0</code>. The number of maintainers and their roles must be identical.</p><p>However, there are a few differences that are allowed. For instance, the dependencies of<code class="literal"> package.xml 1.0</code> need not match those of<code class="literal"> package.xml 2.0</code> whatsoever, due to the fact that<code class="literal"> package.xml 2.0</code> simply represents a far greater set of possible dependencies than<code class="literal"> package.xml 1.0</code>. In addition, the introduction of the<code class="literal">&lt;ignore&gt;</code> tag in<code class="literal"> package.xml 2.0</code> makes it possible to distribute files that are ignored by the PEAR installer. In this way, an application that will run out-of-the-box can also be easily installed with PEAR by distributing files needed for the out-of-the-box run and asking the PEAR installer to ignore them. These files will not be present in the<code class="literal"> package.xml 1.0</code> because PEAR 1.3.x did not have this capability.<a id="id199" class="indexterm"/>
</p></div>
<div class="section" title="Summary"><div class="titlepage"><div><div><h1 class="title"><a id="ch03lvl1sec10"/>Summary</h1></div></div></div><p>At this stage, we've explored the inner workings of the PEAR installer and of<code class="literal"> package.xml</code> to the highest level — it is safe to say that you are now a<code class="literal"> package.xml</code> expert.</p></div></body></html>