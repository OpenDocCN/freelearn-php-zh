["```php\nCREATE TABLE `students`(\n`id` INT UNSIGNED AUTO_INCREMENT NOT NULL,\n`name` VARCHAR(255) NOT NULL,\nPRIMARY KEY(`id`)\n);\nCREATE TABLE `categories`(\n`id` INT UNSIGNED AUTO_INCREMENT NOT NULL,\n`name` VARCHAR(255) NOT NULL,\nPRIMARY KEY(`id`)\n);\nCREATE TABLE `exams`(\n`id` INT UNSIGNED AUTO_INCREMENT NOT NULL,\n`category_id` INT UNSIGNED NOT NULL,\n`name` VARCHAR(255) NOT NULL,\nPRIMARY KEY(`id`),\nFOREIGN KEY `exams__categories`(`category_id`) REFERENCES `categories`(`id`)\n);\nCREATE TABLE `grades`(\n`id` INT UNSIGNED AUTO_INCREMENT NOT NULL,\n`student_id` INT UNSIGNED NOT NULL,\n`exam_id` INT UNSIGNED NOT NULL,\n`grade` FLOAT UNSIGNED NOT NULL,\nPRIMARY KEY(`id`),\nFOREIGN KEY `grades__students`(`student_id`) REFERENCES `students`(`id`),\nFOREIGN KEY `grades__exams`(`exam_id`) REFERENCES `exams`(`id`)\n);\nINSERT INTO `students`(`id`, `name`) VALUES\n(1, 'John Doe'),\n(2, 'Jane Doe');\nINSERT INTO `categories`(`id`, `name`) VALUES\n(1, 'Programming Language'),\n(2, 'Databases');\nINSERT INTO `exams`(`id`, `category_id`, `name`) VALUES\n(1, 1, 'PHP 5.3'),\n(2, 1, 'C++'),\n(3, 1, 'Haskell'),\n(4, 2, 'MySQL'),\n(5, 2, 'MongoDB');\nINSERT INTO `grades`(`student_id`, `exam_id`, `grade`) VALUES\n(1, 1, 10),\n(1, 2, 8),\n(1, 3, 7.5),\n(1, 4, 9),\n(1, 5, 6),\n(2, 1, 7),\n(2, 2, 9.5),\n(2, 3, 6),\n(2, 4, 10),\n(2, 5, 9);\n\n```", "```php\n<?php\nclass ExamsController extends AppController {\npublic function index() {\n}\n}\n?>\n\n```", "```php\n<?php\nclass Exam extends AppModel {\npublic $belongsTo = array('Category');\npublic $hasMany = array('Grade');\n}\n?>\n\n```", "```php\n<?php\nclass Grade extends AppModel {\npublic $belongsTo = array(\n'Exam',\n'Student'\n);\n}\n?>\n\n```", "```php\n    $gradeValues = Set::extract(\n    $this->Exam->find('all'),\n    '/Grade/grade'\n    );\n    $average = array_sum($gradeValues) / count($gradeValues);\n    $categories = $this->Exam->Category->find('all');\n    $mappedCategories = Set::combine(\n    $categories,\n    '/Category/id',\n    '/Category/name'\n    );\n    $gradeRows = $this->Exam->Grade->find('all', array(\n    'recursive' => 2\n    ));\n    $grades = Set::format(\n    $gradeRows,\n    '%s got a %-.1f in %s (%s)',\n    array(\n    '/Student/name',\n    '/Grade/grade',\n    '/Exam/name',\n    '/Exam/Category/name'\n    )\n    );\n    $categories = Set::map($categories);\n    $this->set(compact('average', 'grades', 'categories'));\n\n    ```", "```php\n    <h2>Average: <strong><?php echo $average; ?></strong></h2>\n    <ul>\n    <?php foreach($grades as $string) { ?>\n    <li><?php echo $string; ?></li>\n    <?php } ?>\n    </ul>\n    <h2>Categories:</h2>\n    <ul>\n    <?php foreach($categories as $category) { ?>\n    <li><?php echo $category->id; ?>: <?php echo $category->name; ?></li>\n    <?php } ?>\n    </ul>\n\n    ```", "```php\n$data = $this->Exam->find('all');\n\n```", "```php\nSet::extract('/Exam', $data);\n\n```", "```php\nSet::extract('/Exam/name', $data);\n\n```", "```php\nSet::extract('/Grade[grade<8]', $data);\n\n```", "```php\nSet::extract('/Grade[grade>=8]/grade[2:3]', $data);\n\n```", "```php\n$records = $this->Exam->Grade->find('all', array(\n'conditions' => array('Student.id' => 1),\n'recursive' => 2\n));\n$data = Set::combine(\n$records,\n'/Exam/name',\n'/Grade/grade',\n'/Exam/Category/name'\n);\n\n```", "```php\narray(\n'Programming Language' => array(\n'PHP 5.3' => '10',\n'C++' => '8',\n'Haskell' => '7.5'\n),\n'Databases' => array(\n'MySQL' => '9',\n'MongoDB' => '6'\n)\n)\n\n```", "```php\n<?php\nclass ExamplesController extends AppController {\npublic $uses = null;\npublic function index() {\n$this->_stop();\n}\n?>\n\n```", "```php\n$lines = array(\n'\"Doe, Jane\", jane.doe@email.com',\n'\"Doe, John\", john.doe@email.com'\n);\nforeach($lines as $i => $line) {\n$line = String::tokenize($line, ',', '\"', '\"');\n\n```", "```php\n$line = array_combine(array('name', 'email'), $line);\nforeach($line as $field => $value) {\n$line[$field] = preg_replace('/^\"(.+)\"$/', '\\\\1', $value);\n}\n$line['id'] = String::uuid();\n$lines[$i] = $line;\n}\nforeach($lines as $line) {\necho String::insert('[:id] Hello :name! Your email is\\\\: :email', $line) . '<br />';\n}\n\n```", "```php`# Sending an e-mail    If there is one task we can hardly avoid when building web applications it is sending out e-mails. It is such a basic need that CakePHP provides us with a ready-to-go component that can send e-mails, either through SMTP, or using PHP's `mail()` function.    In this recipe we will learn how to use the `Email` component to send out e-mails through SMTP using a Google Mail account, and how to use e-mail layouts to proper render the e-mails.    ## Getting ready    We only need some place to put our code, and that place will be a model-less controller. Create a file named `emails_controller.php` and place it in your `app/controllers` folder, with the following contents:    ```", "```php    ## How to do it...    1.  Edit your `app/controllers/emails_controller.php` and add the following property to the `EmailsController` class (right below the `uses` property declaration), replacing the `username` and `password` settings highlighted with your Google Mail account, and password:          ```", "```php           2.  While still editing the controller, add the following code to its `index()` method, right above the call to the `_stop()` method (replace the `to` property highlighted with the e-mail address where you wish to receive the test e-mail):          ```", "```php           3.  If you now browse to `http://localhost/emails`, you should see the message **Email sent!**, and you should then receive the test e-mail message in your inbox, as shown in the following screenshot:![How to do it...](img/1926_11_02.jpg)          Let us now continue by sending an HTML e-mail, using layouts and templates.           4.  Make the following changes to the `index()` method in your `app/controllers/emails_controller.php` file (remember to change the highlighted `to` property to your desired destination e-mail):          ```", "```php           5.  Create a file named `default.ctp` and place it in your `app/views/layouts/email/html` folder with the following contents:          ```", "```php           6.  Create a file named `default.ctp` and place it in your `app/views/layouts/email/text` folder with the following contents:          ```", "```php           7.  Create a file named `test.ctp` and place it in your `app/views/elements/email/html` folder, with the following contents:          ```", "```php           8.  Create a file named `test.ctp` and place it in your `app/views/elements/email/text` folder, with the following contents:          ```", "```php              If you now browse to `http://localhost/emails` you should see the message **Email sent!**, and you should then receive the test e-mail message in your inbox in HTML format, and with a link to your web application.    ## How it works...    We start by adding the `Email` component to our controller's list of components. While adding it, we set the settings required to specify the type of delivery we wish to use. The connection settings available in the `Email` component are:    *   `delivery`: It is the type of delivery to use, and can be either: `mail` (uses PHP's `mail()` function), `smtp` (uses SMTP, and requires proper configuration of the `smtpOptions` setting), and `debug` (which tells the `Email` component to avoid sending the e-mail, and instead create a session flash message with the message contents.) *   `smtpOptions`: If delivery is set to `smtp`, it defines an array of settings to specify the type of SMTP connection to attempt. Available settings for this setting are:          *   `protocol`: Protocol to use when connecting. Defaults to `smtp`.     *   `host`: SMTP host to connect to. Defaults to `localhost`.     *   `port`: Port to use when connecting to `host`. Defaults to `25`.     *   `username`: Username.     *   `password`: Password to use.     *   `client`: What is the client connecting to the SMTP server. Defaults to the `HTTP_HOST` environment variable.     *   `timeout`: How many seconds to wait until the attempt to reach the server times out. Defaults to `30`.              We set delivery to `smtp`, and set the `smtpOptions` to what is required when attempting to send e-mails through Google Mail's SMTP server. Once the `Email` component is added to the controller and properly configured, we are ready to build and send e-mails.    The controller's `index()` method builds the e-mail by setting some properties. The `Email` component takes most of its configuration through public properties, some of which are:    *   `to`: Destination, in the form: `name <email>`, where `email` is a valid e-mail address. It can also simply be an email address. *   `from`: E-mail address that is sending the e-mail. This property uses the same format as the `to` property. Notice that if you use Google Mail's SMTP, only the name part of this setting will be used (as the e-mail address will be set to your Google Mail e-mail address.) *   `replyTo`: Email address to which responses should be sent to. Same format as the `to` property. *   `return`: E-mail address to send any delivery errors, sent by the remote mail server. Same format as the `to` property. *   `readReceipt`: An e-mail address (using the same format as the `to` property) to where to send read receipt e-mails. Defaults to none. *   `cc`: An array containing the e-mail address to where to send copies of this e-mail. Each e-mail address should be specified using the same format as the `to` property. *   `bcc`: An array containing e-mail address to send blind copies of this e-mail. Each e-mail address should be specified using the same format as the `to` property. *   `subject`: Subject for the e-mail. *   `headers`: An array containing additional headers to send with the e-mail; each of those headers will be prefixed with `X-` as per `RFC 2822`. *   `attachments`: An array if paths to files that should be attached to the e-mail.    Using the `to` and `subject` property we specify the destination and subject of the e-mail. We did not have to define the `from` property since Google Mail uses the account specified when connecting to the SMTP server.    We then issue a call to the `send()` method, passing the body of the e-mail as its argument, and based on its boolean response we inform if the e-mail was successfully sent or if it failed, in which case we use the `smtpError` property to show the error.    The next part of the recipe uses templates and layouts to properly build the e-mail in two formats: HTML, and text, and uses replacement variables to show the flexibility of the e-mail component. E-mail layouts and templates are no different than controller layouts and views, as they inherit the controller properties (such as its replacement variables, and available helpers.)    E-mail layouts wrap the contents of e-mail templates, by means of their `content_for_layout` variable, just as controllers layouts do. There are two types of email layouts: HTML layouts, stored in `app/views/layouts/email/html`, and text layouts, stored in `app/views/layouts/email/text`. Similarly, you can define templates for HTML emails by storing them in the folder `app/views/elements/emails/html`, and text email templates in `app/views/elements/emails/text`.    We set the layout of the e-mail through the `layout` property of the `Email` component. If no layout is set, the default is used. Therefore, we start by creating the HTML layout in the file `app/views/layouts/email/html/default.ctp`, and the text layout in `app/views/layouts/email/text/default.ctp`.    We create two versions of the same template, called `test`: its HTML version is stored in `app/views/elements/email/html/test.ctp`, and its text version in `app/views/elements/email/html/test.ctp`.    The recipe continues by modifying the `index()` action. We start by defining two replacement variables: `name` and `url`, which are used in the `test` template. We then use the `sendAs` property of the `Email` component to say we are sending an HTML and text friendly e-mail. This property can be set to: `html`, to send HTML only e-mails; `text`, to send text only e-mails; and `both`, to send emails that support HTML and text e-mail clients.    We use the `template` property of the `Email` component to specify that we wish to use our `test` template, and we finalize with a call to the `send()` method to send out the e-mail.    ## There's more...    A common mistake that web application developers make is sending out e-mails as part of a controller action that is triggered by the visitor. Strictly speaking, e-mail sending is a non-interactive task, and as such should not be tied to the user browsing experience.    It is therefore recommended that the email sending task be performed in a non-interactive manner, which in CakePHP terms means from the console, also known as shell.    To exemplify this solution, consider a subscription website, where users enter their information (including their e-mail address), and, as a result, the application sends out a confirmation e-mail. Instead of sending the e-mail as part of the controller action that is triggered from the submission form, we may set a database field that shows that those users have not yet been sent out the confirmation e-mail, and then have a CakePHP shell periodically check for users that need their confirmation e-mails, sending out those e-mails from the shell.    This means that we find ourselves needing to be able to send e-mails from the shell, a topic covered in the recipe *Sending e-mails from shells* in [Chapter 8](ch08.html \"Chapter 8. Working with Shells\"),    ## See also    *Sending e-mails from shells* in [Chapter 8](ch08.html \"Chapter 8. Working with Shells\"), *Working with Shells*.    # Detecting file types with MagicDb    When handling file uploads, it is often important to determine the type of file being uploaded. While some files may be easily recognizable based on their contents, others may prove to be hard to identify.    `MagicDb` is a file database that consists of specifications for several file formats. This recipe shows us how to use this database, through CakePHP's `MagicDb` class, to properly identify files uploaded by our users.    The license for the `MagicDb` database file allows its use only on open source or freely available software. If you wish to identify files on commercial applications, you will have to find a different approach.    ## Getting ready    As we will be working on files uploaded by our users, we need to build a form to upload files. We will store these uploads in a table, so create this table with the following SQL statement:    ```", "```php    Create a file named `uploads_controller.php` and place it in your `app/controllers` folder, with the following contents:    ```", "```php    Create a folder named `uploads` in your `app/views` folder. Create the view for the `add()` method in a file named `add.ctp` and place it in your `app/views/uploads` folder, with the following contents:    ```", "```php    ## How to do it...    1.  Download the latest MagicDb database file from [http://www.magicdb.org/magic.db](http://www.magicdb.org/magic.db) and place it in your `app/vendors` folder. You should now have a file named `magic.db` in your `app/vendors` folder. 2.  Edit your `app/controllers/uploads_controller.php` file and add the following methods right below the `add()` method:          ```", "```php           3.  Create the view for the `view()` method in a file named `view.ctp` and place it in your `app/views/uploads` folder with the following contents:          ```", "```php           4.  Create the model in a file named `upload.php` and place it in your `app/models` folder with the following contents:          ```", "```php           5.  While still editing your `app/models/upload.php` file, add the following method to the `Upload` class:          ```", "```php              If you now browse to `http://localhost/uploads/add`, you will see a form where you can select a file, and then click the button **Upload**. Doing so with a GIF image will produce a result similar to what shown in the following screenshot:  ![How to do it...](img/1926_11_03.jpg)  ## How it works...    The recipe starts by downloading the `MagicDb` file and placing it into the `app/vendors` directory. This file is a text file; containing blocks of identifier file signatures, and for each of these file signature definitions, their respective mime type, and description.    Next, we create the `view()` and `download()` controller actions. Both of them are very similar, except that the `download()` action uses the field `mime` to set the `Content-type` header, thus properly informing the client browser the type of data being sent.    The `download()` action simply sends the contents of the file by using PHP's `readfile()` function, then calling the `_stop()` method (available to all CakePHP classes that descend from `Object)` to stop execution. The `view()` action, on the other hand, requires a view, which prints out the `Upload` record information, showing an image if the file is indeed an image, or showing a link to download the file, in any other case.    The `Upload` model defines two methods: `beforeValidate()`, and `getMagicDb()`. The second method creates an instance of the `MagicDb` class provided by CakePHP, populating it with the contents from the `magic.db` file that was saved in the `app/vendors` directory.    The validation callback `beforeValidate()` starts by making sure that a proper file was uploaded. If so, it moves the uploaded file to the application's temporary directory, and then uses the `analyze()` method of the `MagicDb` class to obtain the file information.    This method will return an empty array if the file was not identified, or a set of file identifications that match the file. These file identifications are themselves arrays, containing information that is defined in the `magic.db` file. The fourth element out of this array contains the information we are looking for: a string that includes the file extension, the mime type, and the file type description.    We extract this information, and we set it so it is saved together with the filename. If the file was not identified, we invalidate the `file` field.    # Throwing and handling exceptions    CakePHP 1.3 still offers support for PHP4, yet most CakePHP applications are built exclusively for PHP5\\. Therefore, it is only expected that our applications use language features only available in PHP5, such as exceptions.    However, there is no built-in support in CakePHP to handle exceptions. This recipe shows us how to create a base exception class that can be used throughout our application, and how to properly recover the application workflow after an exception is thrown.    ## Getting ready    We need a basic application skeleton to work with. Follow the entire recipe *Detecting file types with MagicDb*.    ## How to do it...    1.  Edit your `app/controllers/uploads_controller.php` file and change the `view()` and `download()` methods, so that where it reads:          ```", "```php                    It now reads:                    ```", "```php           2.  Create a file named `app_exception.php` and place it in your `app/` folder, with the following contents:          ```", "```php           3.  Create a file named `exception_handler.php` and place it in your `app/libs` folder, with the following contents:          ```", "```php           4.  While still editing your `app/libs/exception_handler.php` file, add the following methods to the `ExceptionHandler` class:          ```", "```php           5.  Add the following at the end of your `app/config/bootstrap.php` file (right above the closing PHP tag):          ```", "```php           6.  Create a folder named `exceptions` in your `app/views` folder. Create a file named `view.ctp` and place it in your `app/views/exceptions` folder, with the following contents:          ```", "```php              If you now force an error by browsing to `http://localhost/uploads/view/xx`, you will see a page describing the exception, its stack trace, and including relevant information, such as the URL, any POST or GET parameters, and session information, as shown in the following screenshot:  ![How to do it...](img/1926_11_04.jpg)  ## How it works...    We start by using exceptions in our `UploadsController` class, instead of using CakePHP's `cakeError()` method, whenever an `Upload` record is not found. These exceptions are actually instances of `AppException`, but we could have as well created custom exceptions that inherit from `AppException`.    The `AppException` class provides us with a base class from where to extend our application exceptions. This class offers us more contextual information through its `getInfo()` method. This information includes not only the exception message and the stack trace (which is simplified by removing the arguments, and limiting the number of items), but also the URL, method, any POST or GET data, and session information, details that can become valuable when working out the exception.    We still have to add the ability to handle any exceptions that are thrown. For that purpose, we create the `ExceptionHandler` class. Through the code added to the `app/config/bootstrap.php` file, which uses PHP's `set_exception_handler()` function, we tell PHP that whenever an exception is thrown and not caught anywhere, the static `handleException()` method of the `ExceptionHandler` class is to be executed.    This method logs the exception, using the `logException()` method, and renders a friendly page by calling the `renderException()` method. This rendering is performed by creating a dummy controller as an instance of `Controller`, using this controller to render the view `app/views/exceptions.ctp` (optionally using a layout named `exception.ctp` if one is available in `app/views/exceptions`), and setting the view variable `exception` to the exception being handled.    This view shows a simple message if the debug level is set to `0`, or a thorough description of the stack trace and any context information that may be relevant.```"]