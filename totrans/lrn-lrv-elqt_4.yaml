- en: Chapter 4. Exploring the World of Relationships
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '*United (and related) we stand, divided we fall.*'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: In a real-world context, everything is connected; for example, a car has an
    owner, a book has an author (or maybe more than one), or an e-commerce order is
    related to one or more products that a customer (another relation!) has ordered.
  prefs: []
  type: TYPE_NORMAL
- en: Everything, actually, is related!
  prefs: []
  type: TYPE_NORMAL
- en: There are no differences in the application development world; usually, you
    create software to solve a real-world problem. The real world is made from related
    things, so you will probably have to define many relationships between your entities.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, let''s be clear: I am not saying anything new. Just go to Wikipedia
    and search for `entity-relationship model`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Usually, in your school books, you can find three fundamental types of relationships:'
  prefs: []
  type: TYPE_NORMAL
- en: '**One-to-one**: This is used to relate a single entity with another single
    entity (for example, a person and an identity document)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**One-to-many**: This is used to define a connection between an entity with
    more entities of the same type (for example, all the books of the same author)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Many-to-many**: This is used to relate multiple entities with many other
    entities (for example, a book can be a part of more than one category, and one
    category can include more than one book)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Of course, web development makes no exceptions. Eloquent makes no exceptions.
  prefs: []
  type: TYPE_NORMAL
- en: Following the *convention* used in what you have seen until now, Eloquent has
    a great way to deal with relationships, the methods used to define them for your
    models, and the techniques you can adopt to work with them.
  prefs: []
  type: TYPE_NORMAL
- en: So, let's explore what we are going to do in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: First of all, we will deal with the basic relationship types we just saw. How
    does Eloquent handle them? You will discover the beauty of powerful methods such
    as `hasMany` or `belongsTo`. This time, there are no more snippets; we will follow
    the creation of our library management tool classes, defining every entity and
    every relationship.
  prefs: []
  type: TYPE_NORMAL
- en: 'After the basics, you will discover how to work with these relationships: how
    to query and use them in a comfortable and clean way. Also, we will see how to
    insert and delete related models in your database, or update the existing models.'
  prefs: []
  type: TYPE_NORMAL
- en: Sometimes, working with many-to-many relationships will mean storing some data
    specific to that relationship. Eloquent has a very useful property named **pivot**
    that you can use to query the desired pivot table.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, many things to look at this time! However, it is not over yet! Eloquent
    offers two other *relationships* that you can use: the *has many through* and
    *polymorphic many to many* relationships.'
  prefs: []
  type: TYPE_NORMAL
- en: Alright, enough chit-chat! I am not going to spoil anything now. Follow the
    chapter, and you will fall in love with it.
  prefs: []
  type: TYPE_NORMAL
- en: Obviously, I will show you a real-world example for every concept. Come on,
    hero!
  prefs: []
  type: TYPE_NORMAL
- en: 'The trinity: one to one, one to many, and many to many'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Querying-related models
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Eager loading (and the N + 1 problem)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Inserting and updating related models
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Accessing *distant* relationships
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: More power! Polymorphic relationships
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The trinity – one to one, one to many, many to many
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As I mentioned earlier, we will start from the basics. So, the first thing we
    will see is how you can define relationships between entities in Eloquent. This
    is really simple, and usually you will just have to add a single line of code
    for every relationship.
  prefs: []
  type: TYPE_NORMAL
- en: One to one
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Our library is very concerned about tracking people who borrow books. For this
    reason, every new user has to give to the library some identity document data.
  prefs: []
  type: TYPE_NORMAL
- en: Now, every user has a single identity document, and every document is absolutely
    unique. If you think about it, this is a perfect one-to-one relationship. When
    you build your database, the most followed rule tells you that you have to add
    the necessary columns in the *first* table. In this specific example, we would
    add columns to the user table.
  prefs: []
  type: TYPE_NORMAL
- en: However, someone could say "yes, but this is a completely different entity!"
  prefs: []
  type: TYPE_NORMAL
- en: 'Also, we could have to store many details about the identity document of every
    user: number, type, due date, city, and so on.'
  prefs: []
  type: TYPE_NORMAL
- en: In this case, you would add four or five columns to an existing table. Many
    people don't like this solution, so imagine that you have the `User` and `IdentityDocument`
    models.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s our default `User` model:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is our `IdentityDocument` model:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s see how to define the connection between them. For one-to-one relationships,
    the methods used are `hasOne()` and `belongsTo()`. The `hasOne()` method is used
    in the following way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Also, the `belongsTo()` method is used as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'The syntax makes sense, right? A user has a document, and a document belongs
    to a certain user! I know what you are thinking: you can''t just place this method
    call wherever you want in the class.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In fact, you must define a method that returns that method call like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Similarly, `belongsTo()` must be defined as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'So, the final model''s code will be like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'The code for the `User` class will be:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Et voilà!
  prefs: []
  type: TYPE_NORMAL
- en: What exactly happened?
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: At a database level, we created an `identitydocuments` table with some data
    columns and a `user_id` external key. This external key is important because it
    is used automatically by Eloquent to resolve the relationship.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you want, you can specify a different foreign key as a second parameter
    in both methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Otherwise, you can use this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: The field we specify is the same. Of course, the `hasOne` method (the `User`
    model) will see it as an external key, and the `belongsTo` method (the `IdentityDocument`
    model) will see it as a local one.
  prefs: []
  type: TYPE_NORMAL
- en: There's also a third parameter that you can use in both methods. In `hasOne()`,
    it is used to specify the local key (the default is the `id` field). In the `belongsTo()`
    method, it is used to define the parent key on the parent table (again, the default
    is the `id` field).
  prefs: []
  type: TYPE_NORMAL
- en: Let's take another example with the same models. Imagine that we have our `IdentityDocuments`
    table with a primary key named `documentidentifier`. Also, we need to follow a
    certain standard, and we can't use `user_id` as the external foreign key name.
    We must use `documentowner_id`.
  prefs: []
  type: TYPE_NORMAL
- en: 'No problem. First, you will define your `hasOne` like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: We don't need to define the third argument, as our `users` primary key is `id`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, you define `belongsTo`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Now you're done! Note that this concept is applied in the same way for other
    relationship methods that we will see.
  prefs: []
  type: TYPE_NORMAL
- en: One to many
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This time it''s easier than before: every book has an author, right? Sometimes,
    a book may have more than one author, but let''s assume a basic case. The second
    relationship type we will analyze here is one to many. Every author can have more
    than one book. Let''s consider the involved models: `Author` and `Book`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s the `Author` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'The `Book` class is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: These are nothing more than simple Eloquent models. Now, in order to define
    a one-to-many relationship, we must use the `hasMany()` method.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, the `Author` class will look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'You can then use the `belongsTo()` method, as before, to define the `inverse`
    of this relationship:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: So, we are done! We used `belongsTo()` again as the concept of *belonging* is
    exactly the same; no differences.
  prefs: []
  type: TYPE_NORMAL
- en: At a database structure level, I just added an external `author_id` key in the
    `books` table.
  prefs: []
  type: TYPE_NORMAL
- en: 'So yeah, finished! I mention it in a note before, but I will repeat: remember
    that you can change your foreign key just by specifying it as a second parameter
    in the `hasMany()` and `belongsTo()` methods.'
  prefs: []
  type: TYPE_NORMAL
- en: Many to many
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let's imagine a good example for many-to-many relationships. Well, the books/categories
    relationship is perfect. In fact, imagine *Twenty Thousand Leagues Under the Sea*,
    *Jules Verne*.
  prefs: []
  type: TYPE_NORMAL
- en: 'It is not only an adventure novel but also a classic. So, you will need to
    classify it under two separate categories: *Classics* and *Adventure*. Our library
    could also contain *Journey to the Center of the Earth*, another classic, but
    also an other adventure novel. Same thing!'
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, this time a many-to-many relationship is absolutely necessary.
    Let's discover how Eloquent handles many-to-many relationships and how you can
    define them on models.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s the code for our `Book` model:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'The code for `Category` model is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: This time, we don't have any *directions* or a possible *inverse* of a relationship.
  prefs: []
  type: TYPE_NORMAL
- en: 'Specifically, there are many books for many categories. So, the only method
    you need to use in this case is `belongsToMany()`. Use the method like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'The other method is used as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Nothing else!
  prefs: []
  type: TYPE_NORMAL
- en: Let's see what we need at a database level to handle this relation. As you can
    easily imagine, you will have to work with a pivot table in this case.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, you will need to specify an appropriate extra table in your migration file,
    using the `up()` method, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'You also have some conventions to follow. These are given here:'
  prefs: []
  type: TYPE_NORMAL
- en: The table name is comprised of the name of the entities, which is singular,
    separated by an underscore
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The table will contain two columns named after the interested entities (`author_id`
    and `book_id`)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When you specify a relation, remember to use `return` before the appropriate
    method call. I know that's a little obvious, but very often newbies forget it.
  prefs: []
  type: TYPE_NORMAL
- en: It's really, really important that you follow the defined conventions. Laravel
    and Eloquent can change your workflow timeline significantly, but to get the result,
    you must follow conventions. The sooner you do it, the better you will feel.
  prefs: []
  type: TYPE_NORMAL
- en: A question of inverses
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A little extra before we go forward. We just saw how to define a relationship
    and its inverse. However, what are the consequences you would stumble upon if
    you don't define an inverse? Or what if I define an inverse and not the *inverse
    of the inverse*?
  prefs: []
  type: TYPE_NORMAL
- en: Nothing special, actually!
  prefs: []
  type: TYPE_NORMAL
- en: 'The best rule is to define the relationship you need. Let''s imagine a situation
    like this: in your software, you will need to know the category of a book, but
    not all the books in a certain category.'
  prefs: []
  type: TYPE_NORMAL
- en: It is a strange situation, but this happens. In this case, you can just define
    the `categories()` relationship in `Book` and nothing else.
  prefs: []
  type: TYPE_NORMAL
- en: Vice versa, if in your application you will just need to get a list of books
    from the category and nothing else, you will define only the `books()` relationship
    in the `Category` model. That's all.
  prefs: []
  type: TYPE_NORMAL
- en: Done! The three basic relationship types are covered! You don't have to do anything
    more; actually, Eloquent handles everything automatically, so all you have to
    do is to write your code, use models, and raise your queries.
  prefs: []
  type: TYPE_NORMAL
- en: Oh, about queries...
  prefs: []
  type: TYPE_NORMAL
- en: Querying-related models
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that you have learned how to define your relationships, I think you are
    ready to learn how to query them. Let's start with a very basic example.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s suppose that we are searching for the document number of a specific
    user. We will use the `User` and `IdentityDocument` entities we just saw. For
    the purpose of this example, imagine that you have a table `identitydocuments`
    with the following columns:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Number`: This indicates the document number'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Type`: This indicates the document type'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`due_date`: This indicates the due date of the document'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`City`: This indicates the city where the document was released'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Here''s the code to get the document identity number, starting from a `User`
    instance:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: If you echo `$identityDocumentNumber`, you will read the desired information.
    Nice, huh?
  prefs: []
  type: TYPE_NORMAL
- en: Well, this is the way Laravel and Eloquent deal with querying your relationships.
    Once you have defined it, all you have to do is to access it as a simple property
    or a method.
  prefs: []
  type: TYPE_NORMAL
- en: 'All the other queries will be executed automatically by Laravel. In fact, follow
    these simple instructions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'You just executed these queries:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Now put the result in to the `$identityDocumentNumber`. It is quite obvious
    for a one-to-one relationship; however, the same applies for a one-to-many relationship.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s consider another example right now: good old Jules will be a perfect
    fit. Let''s suppose that we want to get a list of every Jules Verne books we have,
    and the code is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As I told you before, you can have access to your relationship using a simple
    attribute or a method call. What's the difference? Well, with the method call,
    you can do some filtering, and everything you saw before, in order to get the
    desired result. In fact, you can raise a query on a relationship.
  prefs: []
  type: TYPE_NORMAL
- en: 'Imagine that we want to get all the books with a *the* in the title. Here''s
    the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Cool, right? It's not over yet, this is just scratching the surface!
  prefs: []
  type: TYPE_NORMAL
- en: Accessing a pivot table
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Working with many-to-many relationships, is not always about just defining a
    couple of external keys. You can choose to put extra data in to your pivot table
    in order to store some information for a specific connection between entities.
  prefs: []
  type: TYPE_NORMAL
- en: 'You already know how to create a pivot table, but how to access it? It''s nothing
    complex: all you have to do is to use the `pivot` attribute of your relationship.
    Let''s take an example using the previous books/categories relationship we created.'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, you must define which attribute you want to take from the table, modifying
    the `belongsToMany()` call in your model:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then your code should be as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In this little example, we just have printed all the dates that we *attached*
    a specific category to the book with `id = 23`. As an extra, we also printed some
    extra notes. This means that on the pivot table, we have the `created_at` and
    `notes` fields.
  prefs: []
  type: TYPE_NORMAL
- en: 'As a shortcut, you can also use:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: This is used if you just want to import timestamps data from the pivot table.
  prefs: []
  type: TYPE_NORMAL
- en: Querying a relationship
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Eloquent allows you to query a relationship. In other words, you can get some
    results based on the existence of a certain relationship. Imagine that we want
    to get all the authors who have at least one book in the database.
  prefs: []
  type: TYPE_NORMAL
- en: 'With Eloquent, we can do something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: In this case, you have to use the `has` method, specifying the name of the desired
    method for the relationship you want to check. The author will be added to `$authorsWithABook`
    only if at least one related book is be found.
  prefs: []
  type: TYPE_NORMAL
- en: If you don't like this *Boolean* approach, don't worry; let's see how to find
    every author with at least five books in the database.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: Yeah, you can specify the second and third arguments as operator and comparison
    term, respectively, for this *count check*.
  prefs: []
  type: TYPE_NORMAL
- en: I know, I know, cool, but not enough. Alright, what about getting all the authors
    with at least one book dated 1864?
  prefs: []
  type: TYPE_NORMAL
- en: 'Here we go, this time with the `whereHas` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, you can do it in a quite elegant way. The first parameter specified
    is the name of the relationship you want to query. The second argument is a closure
    that takes a `$q` query parameter, which you can use to define conditions.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The same concept you just saw here for a one-to-many relationship is also used
    for a many-to-many relationship.
  prefs: []
  type: TYPE_NORMAL
- en: Eager loading (and the N + 1 problem)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Every powerful tool must be used wisely. Relationships in Eloquent are no exception
    to the rule. Actually, one of the most common problems in using Eloquent is the
    *N + 1* problem. To explain it, I will use an example as usual.
  prefs: []
  type: TYPE_NORMAL
- en: Let's suppose that I am showing some data for the first 100 books. Starting
    with this data, I also want to print the author name for every single book.
  prefs: []
  type: TYPE_NORMAL
- en: 'Using what we''ve learned before now, here''s the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: Even if the syntax is simple, under the hood, Eloquent is performing 101 queries!
    The first one is to get the list of the 100 books, then a query for every book
    to get the author. This is not exactly performance friendly, right?
  prefs: []
  type: TYPE_NORMAL
- en: Don't worry, there is a solution!
  prefs: []
  type: TYPE_NORMAL
- en: Basic eager loading
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Eager loading solves your problem. This time using the `with()` method of the
    `Book` model, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: Now, the number of executed queries will precipitate down to two, using a `where
    in`!
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: If you want, you can also include multiple relationships in your final result.
    Let's also include categories data for every book!
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: As if it's not enough, you can also include data from *nested relationships*.
  prefs: []
  type: TYPE_NORMAL
- en: Let's imagine that you are getting a list of categories in your application.
    Then, you want to include book data for every category, and for every related
    book you want to include the author's data.
  prefs: []
  type: TYPE_NORMAL
- en: 'All you have to do is this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: Advanced eager loading
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If you want better control over your eager loading, you can define some constraints
    or conditions. Let's assume that you are getting a list of authors. From this
    list, you want to get every published book, from the oldest to the most recent.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can do it like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'All you have to do is to specify the desired eager-loaded relationships as
    elements of an associative array with this syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: Lazy eager loading
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Sometimes you will use eager loading, but not every time. Sometimes you will
    need it, sometimes not.
  prefs: []
  type: TYPE_NORMAL
- en: If you want, you can manually eager load a specific relationship in the next
    moment.
  prefs: []
  type: TYPE_NORMAL
- en: 'How? It can be done with the `load()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: The syntax is really similar to what you saw before; all you have to do is to
    specify the desired relationships as arguments.
  prefs: []
  type: TYPE_NORMAL
- en: 'Of course, you can also define conditions with the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: The same way, nothing less, nothing more!
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Remember that eager loading is a great solution to many performance issues.
    Especially in my initial experiments, it helped me a lot by letting me reach a
    lower number of queries. Just to make an example, on the Laravel-Italia forum,
    I showed a list of threads, with some replies, information, and thread author
    data, with just three queries.
  prefs: []
  type: TYPE_NORMAL
- en: Inserting and updating related models
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Until now, you have learned how to define relationships and query them, in order
    to get data from related models. However, you can also insert and update related
    models in an easy way.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s pick a really basic example to get started: imagine that we are adding
    a new book (*Michael Strogoff*, *Jules Verne*). We have to specify some details
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we specify the correct author ID:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: The save() and associate() methods
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let's be clear; this works really well. However, it is not the best way you
    can do it. In fact, with Eloquent, you can work with related models using some
    other specific methods.
  prefs: []
  type: TYPE_NORMAL
- en: Let's rewrite this example using the method `save()` on a relationship. Also,
    we will use an associative array as a constructor argument in order to assign
    attributes.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: Done! It only took a couple of instructions. The `save()` method will automatically
    set the `author_id` key for the book you just passed as a parameter.
  prefs: []
  type: TYPE_NORMAL
- en: However, this is not just a time-saving trick; if you read the code carefully,
    you will note that we are actually creating very readable code. Instead of setting
    external keys, treating the relationship in a more *physical* way, we are saving
    the book as an element of the collection of books for a certain author. Quite
    different!
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also do the same thing with arrays of objects, using the `saveMany()`
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: As mentioned before, the `saveMany` method will set the external `author_id`
    key for every `Book` instance passed in the array. You can also update an existing
    relationship, changing its association with another model.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this case, you must use the `associate()` method. Take a look at this example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: What happened? In the first part of the example, I assigned *The Alchemist*
    to Jules Verne. After one year of penitence in the desert, I came back to get
    the right author (by using the `$rightAuthor` variable), and then using the `associate()`
    method on the books relationship.
  prefs: []
  type: TYPE_NORMAL
- en: The first passed parameter is the model instance you want to work with.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'So, the rule is quite simple: use the `save()` method when inserting a new
    record or the `associate()` method in order to update an existing record.'
  prefs: []
  type: TYPE_NORMAL
- en: Remember that *The Alchemist* was not written by Jules Verne but by Paulo Coelho!
  prefs: []
  type: TYPE_NORMAL
- en: What about many to many?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Everything we saw is great for one-to-one or one-to-many relationships. However,
    what about many-to-many relationships? The mechanism, this time, is a little bit
    different; not in terms of complexity, but in terms of syntax, more than anything
    else. However, let's use an example as we did before.
  prefs: []
  type: TYPE_NORMAL
- en: 'We have a few books: *The Alchemist* and *Journey to the Center of the Earth*.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We also have some categories: *Science Fiction*, *Adventure*, and *Classic*.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As I mentioned in the first part of this chapter, this is a many-to-many relationship.
    What can we do to register a relationship between *The Alchemist* and *Adventure*,
    or *Journey to the Center of the Earth* and *Classic*?
  prefs: []
  type: TYPE_NORMAL
- en: In order to access our data in separate pivot tables, we will need other dedicated
    methods. I know that it seems stupid and boring, but use your database management
    tool to see what happens in your database when you interact with your data. It's
    always a good idea to familiarize with the process.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, the first method you will use is `attach()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can easily see, the `attach()` method is another one you can call on
    a relationship. Of course, only on a many-to-many one! It takes a single parameter
    in this case: the primary ID of the book I want to associate with the category.'
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also add an associative array as a second parameter if you are storing
    some extra data in your pivot table:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: The associative array follows the `attribute_name => attribute_value` format,
    as usual.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the same way you *attach*, you can *detach*. If you want to remove a many-to-many
    relationship between two model instances, use the `detach()` method, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: So, you are done!
  prefs: []
  type: TYPE_NORMAL
- en: Also, both `attach()` and `detach()` methods support an array as a parameter
    instead of a simple integer.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: The sync() method
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This is a really cool way to deal with many-to-many relationships. However,
    attaching and detaching things could be a little boring sometimes. Let''s try
    the `sync()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'Confused? Let me explain everything. The `sync` method automatically *synchronizes*
    relationship data, taking an array of IDs. Element after element, it checks if
    the relationship was previously created or not, and sets (or unsets) them when
    necessary. Let''s imagine that the pivot table `book_category` is empty; here''s
    the first instruction:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'This instruction will create a connection between the chosen category and the
    books with the IDs 4, 8, 15, 17, 22, and 42\. However, here''s the second method
    call:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: It checks everything, and calculates a positive difference and a negative one.
    Books 17 and 22 are no longer in the array. The relationship will be automatically
    *detached*. Instead, books 16 and 23 will be added with *attach*, another really
    cool utility method that saves you a lot of time!
  prefs: []
  type: TYPE_NORMAL
- en: 'You can obviously add data to the pivot table with the same method used earlier:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: Accessing distant relationships
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Another really interesting Eloquent feature is the possibility to define (and
    then access) a distant relation, using the `hasManyThrough()` method.
  prefs: []
  type: TYPE_NORMAL
- en: 'What? I see you are a little confused. No problem: let''s take another example,
    which is a little different from our actual context.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Imagine that you are writing an application for some kind of research management
    for a research team. In this software, every user will be able to create a new
    research entity, and then add some sections to that research something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: A `User` entity that has a one-to-many relationship with a `Research` entity
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `Research` entity has a one-to-many relationship with a `Section` entity
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Good. First of all, for models, you could write something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'As a basic setup, it could work. Now, what if we want access to every section
    added by a certain user? Probably, you would use something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: The `$allSections` array would contain every section added by the user. With
    Eloquent, if you want, you can create a shortcut using the `hasManyThrough()`
    method I mentioned earlier.
  prefs: []
  type: TYPE_NORMAL
- en: 'All you have to do is to put it in the User model as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'If you want, you can specify external keys (for the current and *middle* entities)
    as the third and fourth parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: In some such specific cases, it is a very useful shortcut. Enjoy it!
  prefs: []
  type: TYPE_NORMAL
- en: More power – polymorphic relationships
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Probably, you are thinking that Eloquent is cool and very powerful.
  prefs: []
  type: TYPE_NORMAL
- en: Well, yes, it is. However, sometimes, `hasMany()` or `belongsToMany()` isn't
    enough. In some situations during your development flow, you will have to deal
    with more complex relationships that could involve more than two entities.
  prefs: []
  type: TYPE_NORMAL
- en: So, as a last part of this chapter, I will talk about polymorphic relationships.
    As usual, even if they aren't complex to learn, I will cover them with many detailed
    examples, in order to let you fully understand the entire concept.
  prefs: []
  type: TYPE_NORMAL
- en: Let's start from the simple polymorphic relationship.
  prefs: []
  type: TYPE_NORMAL
- en: A simple polymorphic relationship
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A simple polymorphic relationship can be used when you have an entity that can
    belong to either one entity or to another.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, here''s our first example. Imagine that you are creating an e-commerce
    application. You will be able to upload some photos: either for a product, a category,
    or a blog post.'
  prefs: []
  type: TYPE_NORMAL
- en: 'This means that we will have, first of all, four separate entities:'
  prefs: []
  type: TYPE_NORMAL
- en: Photo
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Product
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Category
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Post
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Now, let''s prepare some code skeletons as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: Now, you can define this polymorphic relationship using the `morphTo()` and
    `morphMany()` methods.
  prefs: []
  type: TYPE_NORMAL
- en: The `morphTo()` method is used by the class that is related to all the other
    classes.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `morphMany()` method is called by the `owner` classes.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'So, let''s edit our models like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'Done! Wait, wait. What''s that `imageable` that is used both as a name for
    the method and as a string parameter? It is a name you can choose for yourself:
    however, take a look at the table structure I have used, to understand.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'The photos table has two special fields: `imageable_id` and `imageable_type`.
    A simple external key, the only difference is that, for the elements in this photos
    table, you can count *owners* of different types.'
  prefs: []
  type: TYPE_NORMAL
- en: So, in `imageable_id`, you will put the owner ID and in `imageable_type`, the
    owner class name!
  prefs: []
  type: TYPE_NORMAL
- en: If a photo belongs to a product, you will see `Product` in the `imageable_type`
    column, then `Category` if the photo belongs to a category, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: 'Obviously, working with this relationship is very simple. Here''s an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: This applies for every other entity!
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, you can also *reverse* things. If you have a photo and want to know
    *who* the owner is, all you have to do is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: No matter what the owner's class is, Eloquent will automatically resolve the
    instance and return it to you. If the *owner* is a blog post, you'll get the blog
    post. Easy!
  prefs: []
  type: TYPE_NORMAL
- en: A many-to-many polymorphic relationship
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If a simple polymorphic relationship can be defined as a *special* one to many,
    the many-to-many relationship finds equivalence in many-to-many polymorphic relationships.
  prefs: []
  type: TYPE_NORMAL
- en: As you saw in the earlier text, it works exactly like a many-to-many relationship.
    The only difference is that you can *connect* a certain entity with more entities.
  prefs: []
  type: TYPE_NORMAL
- en: 'For our example, this time, let''s return to our library management system.
    At the beginning of this chapter, you saw three main entities:'
  prefs: []
  type: TYPE_NORMAL
- en: Author
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Book
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Category
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Between books and categories, there is a many-to-many relationship. A book can
    belong to more than one category. Similarly, a category can include more than
    one book. Now, imagine that you want to *extend* this concept to authors.
  prefs: []
  type: TYPE_NORMAL
- en: Let's pick good old Jules as a perfect example. He wrote adventure books, so
    he could be easily classified as an adventure author.
  prefs: []
  type: TYPE_NORMAL
- en: 'The many-to-many polymorphic relationship is the best way to deal with the
    situation. This time, you will have to use the `morphMany()` and `morphedByMany()`
    methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: 'Of course, as for every many-to-many relationship, you will need a pivot table
    with a structure similar to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: Pay maximum attention to names and conventions, as usual. The second parameter
    of `categorizable` for the `morphToMany()` and `morphedByMany()` methods is the
    same as you specify in the pivot table, for `categorizable_id` and `categorizable_type`.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Also, the table name used is the plural for the term (`categorizable` and `categorizables`).
  prefs: []
  type: TYPE_NORMAL
- en: 'After this setup, you are able to use the relationship in your code, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: While creating tables, you will need to add the specific `_id` and `_type` columns,
    such as `categorizable_id` and `categorizable_type`.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In the Schema Builder, you can use the `$table->morphs('categorizable')`, if
    you want. It will automatically add the columns you need, just specify the `-able`
    name you desire.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Alright, I think that's enough. Well, actually that's all; time to rest!
  prefs: []
  type: TYPE_NORMAL
- en: 'You have learned everything related to relationships in Eloquent, and now you
    can even build complex applications in no time. You know everything related to
    Eloquent basics, so my suggestion is: take your time to recap everything, do some
    tests, write good code, and enjoy models and relationships.'
  prefs: []
  type: TYPE_NORMAL
- en: When ready, turn the page and dive into something more advanced!
  prefs: []
  type: TYPE_NORMAL
