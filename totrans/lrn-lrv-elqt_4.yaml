- en: Chapter 4. Exploring the World of Relationships
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第四章：探索关系的世界
- en: '*United (and related) we stand, divided we fall.*'
  id: totrans-1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*团结（和关联）使我们站立，分裂使我们倒下。*'
- en: In a real-world context, everything is connected; for example, a car has an
    owner, a book has an author (or maybe more than one), or an e-commerce order is
    related to one or more products that a customer (another relation!) has ordered.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在现实世界的背景下，一切事物都是相互关联的；例如，一辆车有一个车主，一本书有一个作者（或者可能不止一个），或者一个电子商务订单与一个或多个客户（另一个关系！）所订购的产品相关联。
- en: Everything, actually, is related!
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，一切事物都是相互关联的！
- en: There are no differences in the application development world; usually, you
    create software to solve a real-world problem. The real world is made from related
    things, so you will probably have to define many relationships between your entities.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在应用开发的世界里没有区别；通常，你创建软件来解决现实世界的问题。现实世界是由相关事物构成的，所以你可能需要在你的实体之间定义许多关系。
- en: 'However, let''s be clear: I am not saying anything new. Just go to Wikipedia
    and search for `entity-relationship model`.'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，让我们明确一点：我并没有说什么新东西。只需去维基百科上搜索`实体-关系模型`。
- en: 'Usually, in your school books, you can find three fundamental types of relationships:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，在你的学校教科书中，你可以找到三种基本的关系类型：
- en: '**One-to-one**: This is used to relate a single entity with another single
    entity (for example, a person and an identity document)'
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**一对一**：这是用来关联一个单一实体与另一个单一实体（例如，一个人和身份证）'
- en: '**One-to-many**: This is used to define a connection between an entity with
    more entities of the same type (for example, all the books of the same author)'
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**一对一**：这是用来定义一个实体与同一类型的其他实体之间的连接（例如，同一作者的所有书籍）'
- en: '**Many-to-many**: This is used to relate multiple entities with many other
    entities (for example, a book can be a part of more than one category, and one
    category can include more than one book)'
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**多对多**：这是用来关联多个实体与许多其他实体（例如，一本书可以属于多个类别，一个类别可以包含多本书）'
- en: Of course, web development makes no exceptions. Eloquent makes no exceptions.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，网络开发也不例外。Eloquent也不例外。
- en: Following the *convention* used in what you have seen until now, Eloquent has
    a great way to deal with relationships, the methods used to define them for your
    models, and the techniques you can adopt to work with them.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 按照你迄今为止所看到的*约定*，Eloquent有一个处理关系、用于定义它们的方法以及你可以采用的与它们一起工作的技术的好方法。
- en: So, let's explore what we are going to do in this chapter.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，让我们探索我们将在本章中做什么。
- en: First of all, we will deal with the basic relationship types we just saw. How
    does Eloquent handle them? You will discover the beauty of powerful methods such
    as `hasMany` or `belongsTo`. This time, there are no more snippets; we will follow
    the creation of our library management tool classes, defining every entity and
    every relationship.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将处理我们刚刚看到的基本关系类型。Eloquent是如何处理它们的？你将发现诸如`hasMany`或`belongsTo`等强大方法的美丽。这次，没有更多的代码片段；我们将跟随我们的图书馆管理工具类的创建，定义每一个实体和每一个关系。
- en: 'After the basics, you will discover how to work with these relationships: how
    to query and use them in a comfortable and clean way. Also, we will see how to
    insert and delete related models in your database, or update the existing models.'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在基础之后，你将发现如何处理这些关系：如何查询和使用它们，以舒适和整洁的方式。此外，我们还将看到如何在数据库中插入和删除相关模型，或者更新现有模型。
- en: Sometimes, working with many-to-many relationships will mean storing some data
    specific to that relationship. Eloquent has a very useful property named **pivot**
    that you can use to query the desired pivot table.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候，处理多对多关系可能意味着存储一些特定于该关系的特定数据。Eloquent有一个非常有用的属性名为**pivot**，你可以用它来查询所需的枢纽表。
- en: 'So, many things to look at this time! However, it is not over yet! Eloquent
    offers two other *relationships* that you can use: the *has many through* and
    *polymorphic many to many* relationships.'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，这次有很多东西要看看！然而，还没有结束！Eloquent提供了两种其他你可以使用的*关系*：*通过has many*和多态*多对多*关系。
- en: Alright, enough chit-chat! I am not going to spoil anything now. Follow the
    chapter, and you will fall in love with it.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，别再闲聊了！我现在不会泄露任何东西。跟随这一章节，你会爱上它的。
- en: Obviously, I will show you a real-world example for every concept. Come on,
    hero!
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，我将为每个概念展示一个现实世界的例子。来吧，英雄！
- en: 'The trinity: one to one, one to many, and many to many'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 三位一体：一对一、一对多和多对多
- en: Querying-related models
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 查询相关模型
- en: Eager loading (and the N + 1 problem)
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 懒加载（以及N + 1问题）
- en: Inserting and updating related models
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 插入和更新相关模型
- en: Accessing *distant* relationships
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 访问 *远程* 关系
- en: More power! Polymorphic relationships
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更强大的功能！多态关系
- en: The trinity – one to one, one to many, many to many
  id: totrans-25
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 三位一体——一对一、一对多、多对多
- en: As I mentioned earlier, we will start from the basics. So, the first thing we
    will see is how you can define relationships between entities in Eloquent. This
    is really simple, and usually you will just have to add a single line of code
    for every relationship.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 如我之前提到的，我们将从基础知识开始。所以，我们将首先看到如何定义 Eloquent 中实体之间的关系。这真的很简单，通常你只需要为每个关系添加一行代码。
- en: One to one
  id: totrans-27
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 一对一
- en: Our library is very concerned about tracking people who borrow books. For this
    reason, every new user has to give to the library some identity document data.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的库非常关注追踪借书的人。因此，每个新用户都必须向图书馆提供一些身份证明文件数据。
- en: Now, every user has a single identity document, and every document is absolutely
    unique. If you think about it, this is a perfect one-to-one relationship. When
    you build your database, the most followed rule tells you that you have to add
    the necessary columns in the *first* table. In this specific example, we would
    add columns to the user table.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，每个用户都有一个唯一的身份证明文件，每个文件都是独一无二的。如果你仔细想想，这是一个完美的一对一关系。当你构建数据库时，最遵循的规则告诉你，你必须首先在第一个表中添加必要的列。在这个特定例子中，我们会向用户表添加列。
- en: However, someone could say "yes, but this is a completely different entity!"
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，有人可能会说“是的，但这是一个完全不同的实体！”
- en: 'Also, we could have to store many details about the identity document of every
    user: number, type, due date, city, and so on.'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们可能需要存储每个用户身份证明文件的许多详细信息：号码、类型、到期日、城市等等。
- en: In this case, you would add four or five columns to an existing table. Many
    people don't like this solution, so imagine that you have the `User` and `IdentityDocument`
    models.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，你会在一个现有的表中添加四到五列。许多人不喜欢这种解决方案，所以想象一下，你有了 `User` 和 `IdentityDocument`
    模型。
- en: 'Here''s our default `User` model:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们的默认 `User` 模型：
- en: '[PRE0]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The following is our `IdentityDocument` model:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是我们 `IdentityDocument` 模型：
- en: '[PRE1]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Now, let''s see how to define the connection between them. For one-to-one relationships,
    the methods used are `hasOne()` and `belongsTo()`. The `hasOne()` method is used
    in the following way:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看如何定义它们之间的连接。对于一对一关系，使用的方法是 `hasOne()` 和 `belongsTo()`。`hasOne()` 方法的使用方式如下：
- en: '[PRE2]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Also, the `belongsTo()` method is used as follows:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，`belongsTo()` 方法的使用方式如下：
- en: '[PRE3]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The syntax makes sense, right? A user has a document, and a document belongs
    to a certain user! I know what you are thinking: you can''t just place this method
    call wherever you want in the class.'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 语法是合理的，对吧？一个用户有一个文件，一个文件属于某个用户！我知道你在想什么：你不能随意在类中放置这个方法调用。
- en: 'In fact, you must define a method that returns that method call like this:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，你必须定义一个返回该方法调用的方法，如下所示：
- en: '[PRE4]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Similarly, `belongsTo()` must be defined as follows:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，`belongsTo()` 必须定义为以下方式：
- en: '[PRE5]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'So, the final model''s code will be like this:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，最终模型的代码将如下所示：
- en: '[PRE6]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The code for the `User` class will be:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '`User` 类的代码如下：'
- en: '[PRE7]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Et voilà!
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 哎呀！
- en: What exactly happened?
  id: totrans-51
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 究竟发生了什么？
- en: At a database level, we created an `identitydocuments` table with some data
    columns and a `user_id` external key. This external key is important because it
    is used automatically by Eloquent to resolve the relationship.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 在数据库层面，我们创建了一个包含一些数据列和 `user_id` 外键的 `identitydocuments` 表。这个外键很重要，因为它会被 Eloquent
    自动用来解析关系。
- en: 'If you want, you can specify a different foreign key as a second parameter
    in both methods:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你愿意，你可以在两个方法中指定不同的外键作为第二个参数：
- en: '[PRE8]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Otherwise, you can use this:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 否则，你可以使用这个：
- en: '[PRE9]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The field we specify is the same. Of course, the `hasOne` method (the `User`
    model) will see it as an external key, and the `belongsTo` method (the `IdentityDocument`
    model) will see it as a local one.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 我们指定的字段是相同的。当然，`hasOne` 方法（`User` 模型）会将其视为外键，而 `belongsTo` 方法（`IdentityDocument`
    模型）会将其视为本地键。
- en: There's also a third parameter that you can use in both methods. In `hasOne()`,
    it is used to specify the local key (the default is the `id` field). In the `belongsTo()`
    method, it is used to define the parent key on the parent table (again, the default
    is the `id` field).
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 在这两个方法中，还有一个你可以使用的第三个参数。在 `hasOne()` 中，它用于指定本地键（默认是 `id` 字段）。在 `belongsTo()`
    方法中，它用于在父表上定义父键（再次，默认是 `id` 字段）。
- en: Let's take another example with the same models. Imagine that we have our `IdentityDocuments`
    table with a primary key named `documentidentifier`. Also, we need to follow a
    certain standard, and we can't use `user_id` as the external foreign key name.
    We must use `documentowner_id`.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们用相同的模型再举一个例子。想象一下，我们有一个名为 `IdentityDocuments` 的表，其主键名为 `documentidentifier`。此外，我们需要遵循一定的标准，我们不能使用
    `user_id` 作为外部外键的名称。我们必须使用 `documentowner_id`。
- en: 'No problem. First, you will define your `hasOne` like this:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 没有问题。首先，你将像这样定义你的 `hasOne`：
- en: '[PRE10]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: We don't need to define the third argument, as our `users` primary key is `id`.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不需要定义第三个参数，因为我们的 `users` 主键是 `id`。
- en: 'Then, you define `belongsTo`:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，你定义 `belongsTo`：
- en: '[PRE11]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Now you're done! Note that this concept is applied in the same way for other
    relationship methods that we will see.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你完成了！注意，这个概念适用于我们将要看到的其他关系方法。
- en: One to many
  id: totrans-66
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 一对多
- en: 'This time it''s easier than before: every book has an author, right? Sometimes,
    a book may have more than one author, but let''s assume a basic case. The second
    relationship type we will analyze here is one to many. Every author can have more
    than one book. Let''s consider the involved models: `Author` and `Book`.'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 这次比之前更容易：每本书都有一个作者，对吧？有时，一本书可能有多个作者，但让我们假设一个基本的情况。我们将要分析的第二种关系类型是一对多。每个作者可以有多本书。让我们考虑涉及到的模型：`Author`
    和 `Book`。
- en: 'Here''s the `Author` class:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 这是 `Author` 类：
- en: '[PRE12]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The `Book` class is as follows:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: '`Book` 类如下：'
- en: '[PRE13]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: These are nothing more than simple Eloquent models. Now, in order to define
    a one-to-many relationship, we must use the `hasMany()` method.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 这些只是简单的 Eloquent 模型。现在，为了定义一个一对多关系，我们必须使用 `hasMany()` 方法。
- en: 'So, the `Author` class will look like this:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，`Author` 类将看起来像这样：
- en: '[PRE14]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'You can then use the `belongsTo()` method, as before, to define the `inverse`
    of this relationship:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，你可以像之前一样使用 `belongsTo()` 方法来定义这种关系的 `inverse`：
- en: '[PRE15]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: So, we are done! We used `belongsTo()` again as the concept of *belonging* is
    exactly the same; no differences.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，我们完成了！我们再次使用了 `belongsTo()`，因为 *属于* 的概念完全相同；没有差异。
- en: At a database structure level, I just added an external `author_id` key in the
    `books` table.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 在数据库结构层面，我在 `books` 表中添加了一个外部的 `author_id` 键。
- en: 'So yeah, finished! I mention it in a note before, but I will repeat: remember
    that you can change your foreign key just by specifying it as a second parameter
    in the `hasMany()` and `belongsTo()` methods.'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，是的，完成了！我在之前的笔记中提到过，但我会重复一遍：记住，你可以通过在 `hasMany()` 和 `belongsTo()` 方法中指定它作为第二个参数来更改你的外键。
- en: Many to many
  id: totrans-80
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 多对多
- en: Let's imagine a good example for many-to-many relationships. Well, the books/categories
    relationship is perfect. In fact, imagine *Twenty Thousand Leagues Under the Sea*,
    *Jules Verne*.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们想象一个多对多关系的好例子。好吧，书籍/类别的关系是完美的。事实上，想象一下 *海底两万里*，*儒勒·凡尔纳*。
- en: 'It is not only an adventure novel but also a classic. So, you will need to
    classify it under two separate categories: *Classics* and *Adventure*. Our library
    could also contain *Journey to the Center of the Earth*, another classic, but
    also an other adventure novel. Same thing!'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 这不仅是一部冒险小说，也是一部经典。所以，你需要将其归类为两个不同的类别：*经典* 和 *冒险*。我们的图书馆也可能包含另一部经典作品 *地球中心之旅*，它也是一部冒险小说。同样如此！
- en: As you can see, this time a many-to-many relationship is absolutely necessary.
    Let's discover how Eloquent handles many-to-many relationships and how you can
    define them on models.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，这次一个多对多关系是绝对必要的。让我们来看看 Eloquent 如何处理多对多关系以及如何在模型上定义它们。
- en: 'Here''s the code for our `Book` model:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们的 `Book` 模型的代码：
- en: '[PRE16]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The code for `Category` model is:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '`Category` 模型的代码如下：'
- en: '[PRE17]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: This time, we don't have any *directions* or a possible *inverse* of a relationship.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 这次，我们没有任何 *方向* 或关系的可能 *反向*。
- en: 'Specifically, there are many books for many categories. So, the only method
    you need to use in this case is `belongsToMany()`. Use the method like this:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 特别是，对于许多类别，有许多书籍。所以，在这种情况下，你需要使用的唯一方法是 `belongsToMany()`。像这样使用该方法：
- en: '[PRE18]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The other method is used as follows:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种方法的使用方式如下：
- en: '[PRE19]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Nothing else!
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 没有其他的事情！
- en: Let's see what we need at a database level to handle this relation. As you can
    easily imagine, you will have to work with a pivot table in this case.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看在数据库层面需要什么来处理这种关系。正如你很容易想象的，在这种情况下，你将不得不与一个交叉表（pivot table）一起工作。
- en: 'So, you will need to specify an appropriate extra table in your migration file,
    using the `up()` method, as follows:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，你需要在迁移文件中使用 `up()` 方法指定一个合适的额外表，如下所示：
- en: '[PRE20]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'You also have some conventions to follow. These are given here:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 你也有一些约定要遵循。这些在这里给出：
- en: The table name is comprised of the name of the entities, which is singular,
    separated by an underscore
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 表名由实体的名称组成，这些名称是单数，由下划线分隔
- en: The table will contain two columns named after the interested entities (`author_id`
    and `book_id`)
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 表格将包含两个以感兴趣实体命名的列（`author_id` 和 `book_id`）
- en: Note
  id: totrans-100
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: When you specify a relation, remember to use `return` before the appropriate
    method call. I know that's a little obvious, but very often newbies forget it.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 当你指定一个关系时，请记住在适当的方法调用之前使用 `return`。我知道这有点明显，但新手经常忘记这一点。
- en: It's really, really important that you follow the defined conventions. Laravel
    and Eloquent can change your workflow timeline significantly, but to get the result,
    you must follow conventions. The sooner you do it, the better you will feel.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 真的，真的非常重要，你必须遵循定义的约定。Laravel 和 Eloquent 可以显著改变你的工作流程时间表，但为了得到结果，你必须遵循约定。你越早这样做，感觉就会越好。
- en: A question of inverses
  id: totrans-103
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 反向问题
- en: A little extra before we go forward. We just saw how to define a relationship
    and its inverse. However, what are the consequences you would stumble upon if
    you don't define an inverse? Or what if I define an inverse and not the *inverse
    of the inverse*?
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们继续前进之前，有一些额外的事情。我们刚刚看到了如何定义一个关系及其反向。然而，如果你不定义反向，或者如果你定义了反向但没有定义 *反向的反向*，你会遇到什么后果？
- en: Nothing special, actually!
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上没有什么特别的！
- en: 'The best rule is to define the relationship you need. Let''s imagine a situation
    like this: in your software, you will need to know the category of a book, but
    not all the books in a certain category.'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 最好的规则是定义你需要的关联。让我们想象这种情况：在你的软件中，你需要知道一本书的类别，但不需要知道某个类别中的所有书籍。
- en: It is a strange situation, but this happens. In this case, you can just define
    the `categories()` relationship in `Book` and nothing else.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个奇怪的情况，但这种情况确实会发生。在这种情况下，你只需在 `Book` 中定义 `categories()` 关系，无需其他。
- en: Vice versa, if in your application you will just need to get a list of books
    from the category and nothing else, you will define only the `books()` relationship
    in the `Category` model. That's all.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 反之，如果你的应用程序只需要从类别获取书籍列表，而不需要其他内容，你将只在 `Category` 模型中定义 `books()` 关系。仅此而已。
- en: Done! The three basic relationship types are covered! You don't have to do anything
    more; actually, Eloquent handles everything automatically, so all you have to
    do is to write your code, use models, and raise your queries.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 完成！已经涵盖了三种基本的关系类型！你不需要做更多的事情；实际上，Eloquent 会自动处理一切，所以你只需要编写代码，使用模型，提出查询。
- en: Oh, about queries...
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 哦，关于查询...
- en: Querying-related models
  id: totrans-111
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 查询相关模型
- en: Now that you have learned how to define your relationships, I think you are
    ready to learn how to query them. Let's start with a very basic example.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经学会了如何定义你的关系，我认为你准备好学习如何查询它们了。让我们从一个非常基础的例子开始。
- en: 'Let''s suppose that we are searching for the document number of a specific
    user. We will use the `User` and `IdentityDocument` entities we just saw. For
    the purpose of this example, imagine that you have a table `identitydocuments`
    with the following columns:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们正在搜索特定用户的文档编号。我们将使用我们刚才看到的 `User` 和 `IdentityDocument` 实体。为了这个示例，想象你有一个名为
    `identitydocuments` 的表，其中包含以下列：
- en: '`Number`: This indicates the document number'
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`编号`: 这表示文档编号'
- en: '`Type`: This indicates the document type'
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`类型`: 这表示文档类型'
- en: '`due_date`: This indicates the due date of the document'
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`due_date`: 这表示文档的到期日期'
- en: '`City`: This indicates the city where the document was released'
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`城市`: 这表示文档发布的城市'
- en: 'Here''s the code to get the document identity number, starting from a `User`
    instance:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 这是获取文档身份编号的代码，从一个 `User` 实例开始：
- en: '[PRE21]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: If you echo `$identityDocumentNumber`, you will read the desired information.
    Nice, huh?
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你输出 `$identityDocumentNumber`，你会读取所需的信息。不错，对吧？
- en: Well, this is the way Laravel and Eloquent deal with querying your relationships.
    Once you have defined it, all you have to do is to access it as a simple property
    or a method.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 嗯，这就是 Laravel 和 Eloquent 处理查询你的关系的方式。一旦你定义了它，你所要做的就是像访问一个简单的属性或方法一样访问它。
- en: 'All the other queries will be executed automatically by Laravel. In fact, follow
    these simple instructions:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 所有其他查询将由 Laravel 自动执行。实际上，请遵循以下简单说明：
- en: '[PRE22]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'You just executed these queries:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 你刚刚执行了这些查询：
- en: '[PRE23]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Now put the result in to the `$identityDocumentNumber`. It is quite obvious
    for a one-to-one relationship; however, the same applies for a one-to-many relationship.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 现在将结果放入 `$identityDocumentNumber`。对于一对一关系来说，这是显而易见的；然而，对于一对一多关系也是如此。
- en: 'Let''s consider another example right now: good old Jules will be a perfect
    fit. Let''s suppose that we want to get a list of every Jules Verne books we have,
    and the code is as follows:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们考虑另一个例子：老牌的Jules将是一个完美的选择。假设我们想要获取我们拥有的所有儒勒·凡尔纳书籍的列表，代码如下：
- en: '[PRE24]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Note
  id: totrans-129
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: As I told you before, you can have access to your relationship using a simple
    attribute or a method call. What's the difference? Well, with the method call,
    you can do some filtering, and everything you saw before, in order to get the
    desired result. In fact, you can raise a query on a relationship.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我之前告诉你的，你可以通过一个简单的属性或方法调用来访问你的关系。有什么区别呢？嗯，通过方法调用，你可以进行一些过滤，并且之前看到的一切都是为了得到期望的结果。实际上，你可以在关系上发起一个查询。
- en: 'Imagine that we want to get all the books with a *the* in the title. Here''s
    the code:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下，我们想要获取所有标题中包含*the*的书籍。以下是代码：
- en: '[PRE25]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Cool, right? It's not over yet, this is just scratching the surface!
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 很酷，对吧？但这还没有结束，这只是触及了表面！
- en: Accessing a pivot table
  id: totrans-134
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 访问交叉表
- en: Working with many-to-many relationships, is not always about just defining a
    couple of external keys. You can choose to put extra data in to your pivot table
    in order to store some information for a specific connection between entities.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 在处理多对多关系时，并不仅仅是定义几个外部键。你可以选择在你的交叉表中添加额外的数据，以便存储实体之间特定连接的一些信息。
- en: 'You already know how to create a pivot table, but how to access it? It''s nothing
    complex: all you have to do is to use the `pivot` attribute of your relationship.
    Let''s take an example using the previous books/categories relationship we created.'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经知道如何创建一个交叉表，但如何访问它呢？这并不复杂：你只需要使用你关系的`pivot`属性。让我们用一个例子来说明，这个例子是我们之前创建的书籍/类别关系。
- en: 'First, you must define which attribute you want to take from the table, modifying
    the `belongsToMany()` call in your model:'
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，你必须定义你想要从表中获取哪个属性，修改你的模型中的`belongsToMany()`调用：
- en: '[PRE26]'
  id: totrans-138
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Then your code should be as follows:'
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，你的代码应该是这样的：
- en: '[PRE27]'
  id: totrans-140
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: In this little example, we just have printed all the dates that we *attached*
    a specific category to the book with `id = 23`. As an extra, we also printed some
    extra notes. This means that on the pivot table, we have the `created_at` and
    `notes` fields.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个小例子中，我们只是打印了所有我们将特定类别附加到`id = 23`的书籍上的日期。作为额外信息，我们还打印了一些额外的注释。这意味着在交叉表中，我们有`created_at`和`notes`字段。
- en: 'As a shortcut, you can also use:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 作为快捷方式，你也可以使用：
- en: '[PRE28]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: This is used if you just want to import timestamps data from the pivot table.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 这用于你只想从交叉表中导入时间戳数据时。
- en: Querying a relationship
  id: totrans-145
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 查询关系
- en: Eloquent allows you to query a relationship. In other words, you can get some
    results based on the existence of a certain relationship. Imagine that we want
    to get all the authors who have at least one book in the database.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: Eloquent允许你查询一个关系。换句话说，你可以根据某个关系的存在来获取一些结果。想象一下，我们想要获取数据库中至少有一本书的所有作者。
- en: 'With Eloquent, we can do something like this:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Eloquent，我们可以这样做：
- en: '[PRE29]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: In this case, you have to use the `has` method, specifying the name of the desired
    method for the relationship you want to check. The author will be added to `$authorsWithABook`
    only if at least one related book is be found.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，你必须使用`has`方法，指定你想要检查的关系的所需方法。只有当至少找到一本相关书籍时，作者才会被添加到`$authorsWithABook`中。
- en: If you don't like this *Boolean* approach, don't worry; let's see how to find
    every author with at least five books in the database.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你不喜欢这种*布尔*方法，不要担心；让我们看看如何找到数据库中至少有五本书的每个作者。
- en: '[PRE30]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Yeah, you can specify the second and third arguments as operator and comparison
    term, respectively, for this *count check*.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 是的，你可以指定第二个和第三个参数作为操作符和比较项，分别用于这个*计数检查*。
- en: I know, I know, cool, but not enough. Alright, what about getting all the authors
    with at least one book dated 1864?
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 我知道，我知道，很酷，但还不够。好吧，那么获取所有至少有一本书在1864年出版的作者怎么办？
- en: 'Here we go, this time with the `whereHas` method:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 这里我们来了，这次使用`whereHas`方法：
- en: '[PRE31]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: As you can see, you can do it in a quite elegant way. The first parameter specified
    is the name of the relationship you want to query. The second argument is a closure
    that takes a `$q` query parameter, which you can use to define conditions.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，你可以以一种相当优雅的方式做到这一点。指定的第一个参数是你想要查询的关系的名称。第二个参数是一个闭包，它接受一个`$q`查询参数，你可以使用它来定义条件。
- en: Note
  id: totrans-157
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The same concept you just saw here for a one-to-many relationship is also used
    for a many-to-many relationship.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 你刚才看到的关于一对一关系的相同概念也适用于多对多关系。
- en: Eager loading (and the N + 1 problem)
  id: totrans-159
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 预加载（以及 N + 1 问题）
- en: Every powerful tool must be used wisely. Relationships in Eloquent are no exception
    to the rule. Actually, one of the most common problems in using Eloquent is the
    *N + 1* problem. To explain it, I will use an example as usual.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 每个强大的工具都必须明智地使用。Eloquent 中的关系也不例外。实际上，使用 Eloquent 最常见的问题之一就是 *N + 1* 问题。为了解释它，我将像往常一样使用一个例子。
- en: Let's suppose that I am showing some data for the first 100 books. Starting
    with this data, I also want to print the author name for every single book.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我正在展示前 100 本书的一些数据。从这些数据开始，我还想打印每本书的作者姓名。
- en: 'Using what we''ve learned before now, here''s the code:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 使用我们之前学到的知识，以下是代码：
- en: '[PRE32]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Even if the syntax is simple, under the hood, Eloquent is performing 101 queries!
    The first one is to get the list of the 100 books, then a query for every book
    to get the author. This is not exactly performance friendly, right?
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 即使语法很简单，在底层，Eloquent 正在进行 101 个查询！第一个查询是获取 100 本书列表，然后对每一本书进行查询以获取作者。这并不完全符合性能友好，对吧？
- en: Don't worry, there is a solution!
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 别担心，有解决方案！
- en: Basic eager loading
  id: totrans-166
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 基本预加载
- en: 'Eager loading solves your problem. This time using the `with()` method of the
    `Book` model, like this:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 预加载解决了你的问题。这次使用 `Book` 模型的 `with()` 方法，如下所示：
- en: '[PRE33]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Now, the number of executed queries will precipitate down to two, using a `where
    in`!
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，执行查询的数量将急剧下降到两个，使用 `where in`！
- en: '[PRE34]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: If you want, you can also include multiple relationships in your final result.
    Let's also include categories data for every book!
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你愿意，你还可以在你的最终结果中包含多个关系。让我们也包含每本书的分类数据！
- en: '[PRE35]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: As if it's not enough, you can also include data from *nested relationships*.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 似乎还不够，你还可以包含来自 *嵌套关系* 的数据。
- en: Let's imagine that you are getting a list of categories in your application.
    Then, you want to include book data for every category, and for every related
    book you want to include the author's data.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你正在获取应用中的分类列表。然后，你想要包含每个分类的书籍数据，并且对于每个相关书籍，你想要包含作者的数据。
- en: 'All you have to do is this:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 你只需这样做：
- en: '[PRE36]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Advanced eager loading
  id: totrans-177
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 高级预加载
- en: If you want better control over your eager loading, you can define some constraints
    or conditions. Let's assume that you are getting a list of authors. From this
    list, you want to get every published book, from the oldest to the most recent.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想更好地控制预加载，你可以定义一些约束或条件。假设你正在获取一个作者列表。从这个列表中，你想要获取从最古老到最新出版的每一本书。
- en: 'You can do it like this:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以这样操作：
- en: '[PRE37]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'All you have to do is to specify the desired eager-loaded relationships as
    elements of an associative array with this syntax:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 你所要做的就是指定所需的预加载关系作为关联数组的元素，使用这种语法：
- en: '[PRE38]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Lazy eager loading
  id: totrans-183
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 懒预加载
- en: Sometimes you will use eager loading, but not every time. Sometimes you will
    need it, sometimes not.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候你会使用预加载，但不是每次都需要。有时候你需要它，有时候不需要。
- en: If you want, you can manually eager load a specific relationship in the next
    moment.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你愿意，你可以在下一刻手动预加载一个特定的关系。
- en: 'How? It can be done with the `load()` method:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 如何？可以使用 `load()` 方法来完成：
- en: '[PRE39]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: The syntax is really similar to what you saw before; all you have to do is to
    specify the desired relationships as arguments.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 语法与之前看到的一样；你所要做的就是指定所需的关联关系作为参数。
- en: 'Of course, you can also define conditions with the following:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，你还可以使用以下方式定义条件：
- en: '[PRE40]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: The same way, nothing less, nothing more!
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 同样的方式，不多也不少！
- en: Note
  id: totrans-192
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Remember that eager loading is a great solution to many performance issues.
    Especially in my initial experiments, it helped me a lot by letting me reach a
    lower number of queries. Just to make an example, on the Laravel-Italia forum,
    I showed a list of threads, with some replies, information, and thread author
    data, with just three queries.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，预加载是一个解决许多性能问题的绝佳方案。特别是在我最初的实验中，它通过让我达到更低的查询数量而极大地帮助了我。仅举一个例子，在 Laravel-Italia
    论坛上，我展示了包含一些回复、信息和线程作者数据的线程列表，只需三个查询即可。
- en: Inserting and updating related models
  id: totrans-194
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 插入和更新相关模型
- en: Until now, you have learned how to define relationships and query them, in order
    to get data from related models. However, you can also insert and update related
    models in an easy way.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，你已经学会了如何定义关系并查询它们，以便从相关模型中获取数据。然而，你也可以轻松地插入和更新相关模型。
- en: 'Let''s pick a really basic example to get started: imagine that we are adding
    a new book (*Michael Strogoff*, *Jules Verne*). We have to specify some details
    as follows:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们选择一个真正基础的例子来开始：想象一下我们要添加一本新书（*《米哈伊尔·斯特罗戈夫》，*儒勒·凡尔纳*）。我们必须指定以下一些细节：
- en: '[PRE41]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Then, we specify the correct author ID:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们指定正确的作者ID：
- en: '[PRE42]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: The save() and associate() methods
  id: totrans-200
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: save()和associate()方法
- en: Let's be clear; this works really well. However, it is not the best way you
    can do it. In fact, with Eloquent, you can work with related models using some
    other specific methods.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们明确一点；这确实很有效。然而，这并不是你能做的最好的方法。实际上，使用Eloquent，你可以使用一些其他特定方法来处理相关模型。
- en: Let's rewrite this example using the method `save()` on a relationship. Also,
    we will use an associative array as a constructor argument in order to assign
    attributes.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用关系上的`save()`方法重写这个例子。同时，我们将使用关联数组作为构造函数参数来分配属性。
- en: '[PRE43]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: Done! It only took a couple of instructions. The `save()` method will automatically
    set the `author_id` key for the book you just passed as a parameter.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 完成！这只需要几条指令。`save()`方法将自动为刚刚传入作为参数的书籍设置`author_id`键。
- en: However, this is not just a time-saving trick; if you read the code carefully,
    you will note that we are actually creating very readable code. Instead of setting
    external keys, treating the relationship in a more *physical* way, we are saving
    the book as an element of the collection of books for a certain author. Quite
    different!
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这不仅仅是一个节省时间的技巧；如果你仔细阅读代码，你会注意到我们实际上正在创建非常易于阅读的代码。我们不是设置外部键，而是以一种更*物理*的方式处理关系，我们将书籍保存为某个作者书籍集合中的一个元素。大不相同！
- en: 'You can also do the same thing with arrays of objects, using the `saveMany()`
    method:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以使用`saveMany()`方法与对象数组做同样的事情：
- en: '[PRE44]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: As mentioned before, the `saveMany` method will set the external `author_id`
    key for every `Book` instance passed in the array. You can also update an existing
    relationship, changing its association with another model.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，`saveMany`方法将为数组中传递的每个`Book`实例设置外部的`author_id`键。你还可以更新现有关系，更改其与另一个模型的关系。
- en: 'In this case, you must use the `associate()` method. Take a look at this example:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，你必须使用`associate()`方法。看看这个例子：
- en: '[PRE45]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: What happened? In the first part of the example, I assigned *The Alchemist*
    to Jules Verne. After one year of penitence in the desert, I came back to get
    the right author (by using the `$rightAuthor` variable), and then using the `associate()`
    method on the books relationship.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 发生了什么？在示例的第一部分，我将《炼金术士》分配给了儒勒·凡尔纳。在沙漠中忏悔了一年之后，我回来找到正确的作者（通过使用`$rightAuthor`变量），然后使用`associate()`方法在书籍关系上操作。
- en: The first passed parameter is the model instance you want to work with.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个传入的参数是你想要与之工作的模型实例。
- en: Tip
  id: totrans-213
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: 'So, the rule is quite simple: use the `save()` method when inserting a new
    record or the `associate()` method in order to update an existing record.'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，规则相当简单：在插入新记录时使用`save()`方法，在更新现有记录时使用`associate()`方法。
- en: Remember that *The Alchemist* was not written by Jules Verne but by Paulo Coelho!
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，《炼金术士》不是由儒勒·凡尔纳写的，而是由保罗·科埃略写的！
- en: What about many to many?
  id: totrans-216
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 那么多对多关系呢？
- en: Everything we saw is great for one-to-one or one-to-many relationships. However,
    what about many-to-many relationships? The mechanism, this time, is a little bit
    different; not in terms of complexity, but in terms of syntax, more than anything
    else. However, let's use an example as we did before.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 我们所看到的一切对于一对一或多对一的关系来说都很棒。然而，对于多对多关系呢？这次机制略有不同；不是在复杂性的意义上，而是在语法上，更多的是在语法上。然而，让我们用一个例子来说明。
- en: 'We have a few books: *The Alchemist* and *Journey to the Center of the Earth*.'
  id: totrans-218
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们有几本书：《炼金术士》和《地球中心之旅》。
- en: 'We also have some categories: *Science Fiction*, *Adventure*, and *Classic*.'
  id: totrans-219
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们还有一些类别：*科幻*、*冒险*和*经典*。
- en: As I mentioned in the first part of this chapter, this is a many-to-many relationship.
    What can we do to register a relationship between *The Alchemist* and *Adventure*,
    or *Journey to the Center of the Earth* and *Classic*?
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我在本章第一部分提到的，这是一个多对多的关系。我们如何注册《炼金术士》和《冒险》或《地球中心之旅》和《经典》之间的关系呢？
- en: In order to access our data in separate pivot tables, we will need other dedicated
    methods. I know that it seems stupid and boring, but use your database management
    tool to see what happens in your database when you interact with your data. It's
    always a good idea to familiarize with the process.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在单独的连接表中访问我们的数据，我们需要其他专用方法。我知道这看起来很愚蠢且无聊，但请使用你的数据库管理工具查看当你与数据交互时数据库中发生了什么。熟悉这个过程总是一个好主意。
- en: 'However, the first method you will use is `attach()`:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，你将首先使用的是`attach()`方法：
- en: '[PRE46]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'As you can easily see, the `attach()` method is another one you can call on
    a relationship. Of course, only on a many-to-many one! It takes a single parameter
    in this case: the primary ID of the book I want to associate with the category.'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 如你容易看到的，`attach()`方法是你可以调用的另一个关系方法。当然，只适用于多对多关系！在这种情况下，它需要一个参数：我想与该类别关联的书籍的主ID。
- en: 'You can also add an associative array as a second parameter if you are storing
    some extra data in your pivot table:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你正在你的连接表中存储一些额外数据，你也可以添加一个关联数组作为第二个参数：
- en: '[PRE47]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: The associative array follows the `attribute_name => attribute_value` format,
    as usual.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 关联数组遵循`attribute_name => attribute_value`格式，就像往常一样。
- en: 'In the same way you *attach*, you can *detach*. If you want to remove a many-to-many
    relationship between two model instances, use the `detach()` method, as follows:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 就像你可以*附加*一样，你也可以*解除*。如果你想删除两个模型实例之间的多对多关系，请使用以下`detach()`方法：
- en: '[PRE48]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: So, you are done!
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，你已经完成了！
- en: Also, both `attach()` and `detach()` methods support an array as a parameter
    instead of a simple integer.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，`attach()`和`detach()`方法都支持数组作为参数，而不是简单的整数。
- en: '[PRE49]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: The sync() method
  id: totrans-233
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '`sync()`方法'
- en: 'This is a really cool way to deal with many-to-many relationships. However,
    attaching and detaching things could be a little boring sometimes. Let''s try
    the `sync()` method:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一种处理多对多关系的真正酷的方法。然而，附加和解除东西有时可能会有些无聊。让我们尝试`sync()`方法：
- en: '[PRE50]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Confused? Let me explain everything. The `sync` method automatically *synchronizes*
    relationship data, taking an array of IDs. Element after element, it checks if
    the relationship was previously created or not, and sets (or unsets) them when
    necessary. Let''s imagine that the pivot table `book_category` is empty; here''s
    the first instruction:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 迷惑？让我解释一下。`sync`方法自动*同步*关系数据，接受一个ID数组。元素一个接一个地检查关系之前是否已创建，并在必要时设置（或取消设置）它们。让我们想象一下，连接表`book_category`是空的；这是第一条指令：
- en: '[PRE51]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'This instruction will create a connection between the chosen category and the
    books with the IDs 4, 8, 15, 17, 22, and 42\. However, here''s the second method
    call:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 此指令将在所选类别和ID为4、8、15、17、22和42的书籍之间建立连接。然而，这里是第二个方法调用：
- en: '[PRE52]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: It checks everything, and calculates a positive difference and a negative one.
    Books 17 and 22 are no longer in the array. The relationship will be automatically
    *detached*. Instead, books 16 and 23 will be added with *attach*, another really
    cool utility method that saves you a lot of time!
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 它会检查一切，并计算正差和负差。书籍17和22不再在数组中。关系将自动*解除*。相反，书籍16和23将通过*附加*方法添加，这是一个非常酷的实用方法，可以节省你大量时间！
- en: 'You can obviously add data to the pivot table with the same method used earlier:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 你显然可以使用之前使用的方法向连接表中添加数据：
- en: '[PRE53]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: Accessing distant relationships
  id: totrans-243
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 访问远程关系
- en: Another really interesting Eloquent feature is the possibility to define (and
    then access) a distant relation, using the `hasManyThrough()` method.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个非常有趣的Eloquent特性是使用`hasManyThrough()`方法定义（然后访问）一个远程关系。
- en: 'What? I see you are a little confused. No problem: let''s take another example,
    which is a little different from our actual context.'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 什么？我看到你有点困惑。没问题：让我们再举一个例子，这个例子与我们的实际环境略有不同。
- en: 'Imagine that you are writing an application for some kind of research management
    for a research team. In this software, every user will be able to create a new
    research entity, and then add some sections to that research something like this:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下，你正在为某个研究团队编写一个研究管理应用程序。在这个软件中，每个用户都将能够创建一个新的研究实体，然后添加一些章节到该研究中，例如：
- en: A `User` entity that has a one-to-many relationship with a `Research` entity
  id: totrans-247
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个与`Research`实体存在一对一关系的`User`实体
- en: The `Research` entity has a one-to-many relationship with a `Section` entity
  id: totrans-248
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Research`实体与`Section`实体存在一对一关系'
- en: 'Good. First of all, for models, you could write something like this:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 好的。首先，对于模型，你可以写点这样的东西：
- en: '[PRE54]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'As a basic setup, it could work. Now, what if we want access to every section
    added by a certain user? Probably, you would use something like this:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 作为基本设置，它可以工作。现在，如果我们想访问某个用户添加的每个部分呢？可能你会使用类似这样的东西：
- en: '[PRE55]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: The `$allSections` array would contain every section added by the user. With
    Eloquent, if you want, you can create a shortcut using the `hasManyThrough()`
    method I mentioned earlier.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: '`$allSections`数组将包含用户添加的每个部分。使用Eloquent，如果你想，你可以使用我之前提到的`hasManyThrough()`方法创建一个快捷方式。'
- en: 'All you have to do is to put it in the User model as follows:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 你所要做的就是将其放入如下所示的User模型中：
- en: '[PRE56]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'If you want, you can specify external keys (for the current and *middle* entities)
    as the third and fourth parameters:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你愿意，你可以指定外部键（对于当前和*中间*实体）作为第三个和第四个参数：
- en: '[PRE57]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: In some such specific cases, it is a very useful shortcut. Enjoy it!
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些这样的特定情况下，这是一个非常有用的快捷方式。享受它！
- en: More power – polymorphic relationships
  id: totrans-259
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更强大的多态关系
- en: Probably, you are thinking that Eloquent is cool and very powerful.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 可能你正在想Eloquent很酷，非常强大。
- en: Well, yes, it is. However, sometimes, `hasMany()` or `belongsToMany()` isn't
    enough. In some situations during your development flow, you will have to deal
    with more complex relationships that could involve more than two entities.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 嗯，是的。然而，有时`hasMany()`或`belongsToMany()`还不够。在开发流程中的某些情况下，你将不得不处理更复杂的关系，这可能涉及两个以上的实体。
- en: So, as a last part of this chapter, I will talk about polymorphic relationships.
    As usual, even if they aren't complex to learn, I will cover them with many detailed
    examples, in order to let you fully understand the entire concept.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，作为本章的最后一部分，我将讨论多态关系。像往常一样，即使它们学习起来并不复杂，我仍会用许多详细的例子来涵盖，以便让你完全理解整个概念。
- en: Let's start from the simple polymorphic relationship.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从简单的多态关系开始。
- en: A simple polymorphic relationship
  id: totrans-264
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 简单的多态关系
- en: A simple polymorphic relationship can be used when you have an entity that can
    belong to either one entity or to another.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 当你有一个实体可以属于一个实体或另一个实体时，可以使用简单的多态关系。
- en: 'So, here''s our first example. Imagine that you are creating an e-commerce
    application. You will be able to upload some photos: either for a product, a category,
    or a blog post.'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，这是我们的第一个例子。想象一下你正在创建一个电子商务应用程序。你将能够上传一些照片：可以是产品、类别或博客文章。
- en: 'This means that we will have, first of all, four separate entities:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着我们首先将有四个独立的实体：
- en: Photo
  id: totrans-268
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 照片
- en: Product
  id: totrans-269
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 产品
- en: Category
  id: totrans-270
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类别
- en: Post
  id: totrans-271
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 文章
- en: 'Now, let''s prepare some code skeletons as follows:'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们准备一些代码框架如下：
- en: '[PRE58]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: Now, you can define this polymorphic relationship using the `morphTo()` and
    `morphMany()` methods.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你可以使用`morphTo()`和`morphMany()`方法定义这个多态关系。
- en: The `morphTo()` method is used by the class that is related to all the other
    classes.
  id: totrans-275
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`morphTo()`方法由与所有其他类相关联的类使用。'
- en: The `morphMany()` method is called by the `owner` classes.
  id: totrans-276
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`morphMany()`方法由`owner`类调用。'
- en: 'So, let''s edit our models like this:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，让我们像这样编辑我们的模型：
- en: '[PRE59]'
  id: totrans-278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'Done! Wait, wait. What''s that `imageable` that is used both as a name for
    the method and as a string parameter? It is a name you can choose for yourself:
    however, take a look at the table structure I have used, to understand.'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 完成！等等，那个既用作方法名称又用作字符串参数的`imageable`是什么？这是一个你可以自己选择的名字：然而，看看我使用的表结构，以了解。
- en: '[PRE60]'
  id: totrans-280
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'The photos table has two special fields: `imageable_id` and `imageable_type`.
    A simple external key, the only difference is that, for the elements in this photos
    table, you can count *owners* of different types.'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 照片表有两个特殊字段：`imageable_id`和`imageable_type`。这是一个简单的外部键，唯一的区别是，对于这个照片表中的元素，你可以计算不同类型的*所有者*。
- en: So, in `imageable_id`, you will put the owner ID and in `imageable_type`, the
    owner class name!
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在`imageable_id`中，你将放入所有者的ID，在`imageable_type`中，放入所有者类名！
- en: If a photo belongs to a product, you will see `Product` in the `imageable_type`
    column, then `Category` if the photo belongs to a category, and so on.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一张照片属于一个产品，你将在`imageable_type`列中看到`Product`，如果照片属于一个类别，那么就是`Category`，依此类推。
- en: 'Obviously, working with this relationship is very simple. Here''s an example:'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，处理这种关系非常简单。以下是一个例子：
- en: '[PRE61]'
  id: totrans-285
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: This applies for every other entity!
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 这适用于其他每个实体！
- en: '[PRE62]'
  id: totrans-287
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'Finally, you can also *reverse* things. If you have a photo and want to know
    *who* the owner is, all you have to do is:'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，你也可以*反转*这些关系。如果你有一张照片，想知道*谁*是所有者，你所要做的就是：
- en: '[PRE63]'
  id: totrans-289
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: No matter what the owner's class is, Eloquent will automatically resolve the
    instance and return it to you. If the *owner* is a blog post, you'll get the blog
    post. Easy!
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 无论所有者的类是什么，Eloquent 都会自动解析实例并将其返回给你。如果 *所有者* 是一篇博客文章，你将得到这篇博客文章。很简单！
- en: A many-to-many polymorphic relationship
  id: totrans-291
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 多对多多态关系
- en: If a simple polymorphic relationship can be defined as a *special* one to many,
    the many-to-many relationship finds equivalence in many-to-many polymorphic relationships.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 如果可以将简单的多态关系定义为一种 *特殊* 的多对一关系，那么多对多关系在多对多多态关系中找到了等价。
- en: As you saw in the earlier text, it works exactly like a many-to-many relationship.
    The only difference is that you can *connect* a certain entity with more entities.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你在前面的文本中看到的，它的工作方式与多对多关系完全一样。唯一的区别是你可以 *连接* 某个实体与更多实体。
- en: 'For our example, this time, let''s return to our library management system.
    At the beginning of this chapter, you saw three main entities:'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的例子，这次，让我们回到我们的图书馆管理系统。在本章的开头，你看到了三个主要实体：
- en: Author
  id: totrans-295
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 作者
- en: Book
  id: totrans-296
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 书籍
- en: Category
  id: totrans-297
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 分类
- en: Between books and categories, there is a many-to-many relationship. A book can
    belong to more than one category. Similarly, a category can include more than
    one book. Now, imagine that you want to *extend* this concept to authors.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 在书籍和分类之间，存在多对多关系。一本书可以属于多个分类。同样，一个分类可以包含多本书。现在，想象一下，你想要 *扩展* 这个概念到作者。
- en: Let's pick good old Jules as a perfect example. He wrote adventure books, so
    he could be easily classified as an adventure author.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们以那位久经考验的朱尔斯为例。他写了冒险书籍，所以他很容易被归类为冒险作家。
- en: 'The many-to-many polymorphic relationship is the best way to deal with the
    situation. This time, you will have to use the `morphMany()` and `morphedByMany()`
    methods:'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 多对多多态关系是处理这种情况的最佳方式。这次，你将不得不使用 `morphMany()` 和 `morphedByMany()` 方法：
- en: '[PRE64]'
  id: totrans-301
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'Of course, as for every many-to-many relationship, you will need a pivot table
    with a structure similar to the following:'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，对于每个多对多关系，你都需要一个具有类似以下结构的枢纽表：
- en: '[PRE65]'
  id: totrans-303
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: Pay maximum attention to names and conventions, as usual. The second parameter
    of `categorizable` for the `morphToMany()` and `morphedByMany()` methods is the
    same as you specify in the pivot table, for `categorizable_id` and `categorizable_type`.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 像往常一样，请密切关注名称和约定。`categorizable` 的第二个参数对于 `morphToMany()` 和 `morphedByMany()`
    方法与你在枢纽表中指定的相同，即 `categorizable_id` 和 `categorizable_type`。
- en: Note
  id: totrans-305
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Also, the table name used is the plural for the term (`categorizable` and `categorizables`).
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，使用的表名是该术语的复数形式（`categorizable` 和 `categorizables`）。
- en: 'After this setup, you are able to use the relationship in your code, as follows:'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 在此设置完成后，你可以在代码中使用这种关系，如下所示：
- en: '[PRE66]'
  id: totrans-308
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: While creating tables, you will need to add the specific `_id` and `_type` columns,
    such as `categorizable_id` and `categorizable_type`.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建表时，你需要添加特定的 `_id` 和 `_type` 列，例如 `categorizable_id` 和 `categorizable_type`。
- en: Note
  id: totrans-310
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: In the Schema Builder, you can use the `$table->morphs('categorizable')`, if
    you want. It will automatically add the columns you need, just specify the `-able`
    name you desire.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Schema Builder 中，如果你想使用 `$table->morphs('categorizable')`，可以这样做。它将自动添加你需要的列，只需指定你想要的
    `-able` 名称即可。
- en: Summary
  id: totrans-312
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: Alright, I think that's enough. Well, actually that's all; time to rest!
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，我认为这就足够了。实际上，这就是全部；是时候休息一下了！
- en: 'You have learned everything related to relationships in Eloquent, and now you
    can even build complex applications in no time. You know everything related to
    Eloquent basics, so my suggestion is: take your time to recap everything, do some
    tests, write good code, and enjoy models and relationships.'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经在 Eloquent 中学习了所有关于关系的内容，现在你可以迅速构建复杂的应用程序。你对 Eloquent 的基础知识了如指掌，所以我的建议是：花时间回顾一下所有内容，做一些测试，编写好的代码，并享受模型和关系。
- en: When ready, turn the page and dive into something more advanced!
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 准备好了，翻页，深入探索更高级的内容！
