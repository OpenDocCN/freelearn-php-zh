- en: Chapter 9. Multithreaded and Distributed Computing with pthreads and Gearman
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 9 章：使用 pthreads 和 Gearman 进行多线程和分布式计算
- en: We've spent quite some time with pthreads in the previous chapter. However,
    we haven't seen them used in any practical applications. That's what we're going
    to do in this chapter where we'll wrap pthreads with RxPHP to hide their internal
    implementation details and to make thread pools easily reusable in any RxPHP application.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在前一章中，我们花费了很多时间与 pthreads 一起工作。然而，我们还没有看到它们在任何实际应用中使用。这正是本章我们要做的，我们将使用 RxPHP
    包装 pthreads 以隐藏其内部实现细节，并使线程池在任何 RxPHP 应用程序中易于重用。
- en: Apart from pthreads, we'll take a look at distributing jobs across multiple
    workers locally or on multiple machines. We'll use the Gearman framework and its
    PHP bindings to make the same application as we'll do with pthreads, just instead
    of running it in multiple threads we'll use multiple workers (independent processes).
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 除了 pthreads 之外，我们还将查看如何在本地或多个机器上跨多个工作进程分配工作。我们将使用 Gearman 框架及其 PHP 绑定来创建与 pthreads
    相同的应用程序，只是我们不会在多个线程中运行它，而是使用多个工作进程（独立进程）。
- en: In this chapter, we're going to write an extendable code quality tool to test
    various style checks in PHP scripts. For example, this can be not using assignments
    in conditions, or just variable names following certain coding standard. PHP projects
    tend to grow very large these days. If we wanted to analyze every file in a single
    thread, it would take a very long time, so we want to run the analyzer part in
    parallel if possible.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将编写一个可扩展的代码质量工具，用于测试 PHP 脚本中的各种样式检查。例如，这可以是不在条件中使用赋值，或者只是变量名遵循某些编码标准。如今，PHP
    项目往往变得非常大。如果我们想在一个线程中分析每个文件，这将花费很长时间，因此我们希望在可能的情况下并行运行分析器部分。
- en: 'In particular, this chapter will cover the following topics:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 尤其是本章将涵盖以下主题：
- en: Quick introduction to the PHP Parser library and how can we wrap its parser
    with an RxPHP operator
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: PHP 解析器库的快速介绍以及我们如何使用 RxPHP 操作符包装其解析器
- en: Wrap pthreads `Pool` class with our custom operator that'll receive `Thread`
    classes and run them in parallel automatically
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用我们的自定义操作符包装 pthreads `Pool` 类，该操作符将接收 `Thread` 类并在并行中自动运行它们
- en: Write a `Thread` class that'll run PHP Parser in a separate thread
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写一个 `Thread` 类，它将在单独的线程中运行 PHP 解析器
- en: Introduce the Gearman framework and write a very basic client and worker in
    PHP. We'll also see how to run clients and workers using just Gearman's CLI options
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 介绍 Gearman 框架，并编写一个基本的 PHP 客户端和工作进程。我们还将看到如何仅使用 Gearman 的 CLI 选项来运行客户端和工作进程
- en: Distribute PHP Parser tasks across multiple Gearman workers
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在多个 Gearman 工作进程中分配 PHP 解析器任务
- en: Compare single process multithreaded applications with a distributed Gearman
    application
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 比较单进程多线程应用程序与分布式 Gearman 应用程序
- en: We'll go through the PHP Parser library very quickly because our main interest
    is mostly in pthreads and the Gearman framework.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将快速浏览 PHP 解析器库，因为我们的主要兴趣主要在于 pthreads 和 Gearman 框架。
- en: However, we'll spend some time writing the `PHPParserOperator` class, which
    will combine many of the things we've learned in the previous chapters.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，我们将花费一些时间编写 `PHPParserOperator` 类，它将结合我们在前几章中学到的许多东西。
- en: Introduction to the PHP Parser library
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: PHP 解析器库简介
- en: PHP Parser is a library that takes a source code written in PHP, passes it through
    a lexical analyzer, and creates its respective syntax tree. This is very useful
    for static code analysis, where we want to check our own code not only for syntactic
    errors but also for satisfying certain quality criteria.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: PHP 解析器是一个库，它接受用 PHP 编写的源代码，通过词法分析器传递它，并创建其相应的语法树。这对于静态代码分析非常有用，我们不仅想要检查自己的代码是否存在语法错误，还想要满足某些质量标准。
- en: In this chapter, we'll write an application that takes a directory, iterates
    all its files and subdirectories recursively, and runs each PHP file through the
    PHP Parser. We will check only for one specific pattern; that is enough for this
    demo.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将编写一个应用程序，它接受一个目录，递归地迭代其所有文件和子目录，并将每个 PHP 文件通过 PHP 解析器运行。我们只检查一个特定的模式；这对于这个演示来说已经足够了。
- en: 'We want to be able to find any statement where we use the assignment inside
    a condition. This could be any of the following examples (this time we''re also
    including line numbers for clarity):'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望能够找到任何我们在条件中使用赋值的语句。这可以是以下任何一种示例（这次我们还包括行号以增强清晰度）：
- en: '[PRE0]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: All this is of course a valid PHP syntax, but let's say we want to make our
    code easy to understand. When your application is not behaving as you'd expect
    and you don't know how you might spot any of the preceding examples, then you
    would not be able to say at first sight whether this is intentional or you're
    just missing one equals sign. Maybe you wanted to write a condition such as `if
    ($a == 1)` and you just forgot one `=`.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些都是有效的PHP语法，但让我们假设我们想要使我们的代码易于理解。当您的应用程序没有按预期运行，并且您不知道如何找到前面的任何示例时，您可能一开始无法立即判断这是故意的还是只是遗漏了一个等号。也许您想写一个条件语句，如`if
    ($a == 1)`，但您忘记了一个`=`。
- en: This can be easily spotted and reported by the static code analyzer.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 这可以通过静态代码分析器轻松地发现并报告。
- en: So, let's start by first trying the PHP Parser library itself and then wrap
    it with the RxPHP operator.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，让我们首先尝试PHP解析器库本身，然后使用RxPHP操作符对其进行包装。
- en: Using the PHP Parser library
  id: totrans-21
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用PHP解析器库
- en: 'Before we start, we need to install the PHP Parser library. As usual, we''ll
    use the `composer` for this:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始之前，我们需要安装PHP解析器库。像往常一样，我们将使用`composer`来完成这项工作：
- en: '[PRE1]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The easiest use case is just taking the source code we want to analyze and
    process it with the parser:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 最好的用例就是取我们想要分析的源代码，并用解析器处理它：
- en: '[PRE2]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The output from this script is going to be a very long nested tree structure
    representing the code we passed to the parser:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 此脚本的输出将是一个非常长的嵌套树结构，代表我们传递给解析器的代码：
- en: '[PRE3]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: We can see that the `if` statement has a property called `cond` that contains
    the parsed condition, which is an instance of `Expr\Assign`. In fact, all the
    statements we're going to test have the `cond` property, so testing whether they
    contain an assignment in condition is going to be relatively simple. The only
    exception is the `for` loop, where the condition might have multiple expressions
    separated by the comma `,` character.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到`if`语句有一个名为`cond`的属性，它包含解析后的条件，这是一个`Expr\Assign`的实例。实际上，我们将要测试的所有语句都有`cond`属性，因此测试它们是否包含条件中的赋值将相对简单。唯一的例外是`for`循环，其中条件可能由逗号`,`分隔的多个表达式组成。
- en: Since the syntax tree is a nested structure, we'll need some way to iterate
    it recursively. Fortunately, this is supported by the library out of the box via
    the `NodeTraverser` class and by registering custom visitors. Visitors are classes
    with multiple callbacks that are called when the tree traverser starts/ends processing
    the entire tree or enters/leaves a single node.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 由于语法树是一个嵌套结构，我们需要某种方式来递归地迭代它。幸运的是，库通过`NodeTraverser`类和注册自定义访问者来支持这一点。访问者是具有多个回调的类，当树遍历器开始/结束处理整个树或进入/离开单个节点时会被调用。
- en: We will make a very simple node visitor that checks for the node type and eventually
    the `cond` property. This is a way we can spot all the assignments inside conditions
    and print their respective line number from the source PHP script.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将创建一个非常简单的节点访问者，用于检查节点类型，并最终检查`cond`属性。这是一种方法，我们可以找到条件内的所有赋值，并从源PHP脚本中打印出它们各自的行号。
- en: 'Consider the following code. This will also be part of the custom operator
    that we''ll write later:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下代码。这将是我们将要编写的自定义操作符的一部分：
- en: '[PRE4]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: As you can see, we're checking each node type with multiple `instanceof` statements
    and their respective `cond` properties. With the `for` statement, we need to check
    the array of the `cond` statements but the rest is analogous.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，我们使用多个`instanceof`语句及其相应的`cond`属性来检查每个节点类型。对于`for`语句，我们需要检查`cond`语句的数组，但其余部分类似。
- en: 'Every time we spot our tested style check, we just print the line number so
    that the preceding example will print the following:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 每当我们发现测试的样式检查时，我们只需打印行号，因此前面的示例将打印以下内容：
- en: '[PRE5]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: We can see that the line numbers really match the source file we presented earlier.
    This is all nice but not very helpful when we want to use it with RxPHP or, even
    more interestingly, with pthreads.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到行号确实与之前提供的源文件匹配。这很好，但当我们想要与RxPHP或更有趣的是与pthreads一起使用时，并不太有帮助。
- en: Implementing PHPParserOperator
  id: totrans-37
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现PHPParserOperator
- en: If we wanted to process multiple files, we could just run the parser multiple
    times. But what if we wanted to have better control over what files are going
    in, or we wanted to make the preconfigured parser with our custom node visitor
    easily embeddable into any RxPHP application.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想要处理多个文件，我们只需多次运行解析器。但如果我们想要更好地控制要处理的文件，或者我们想要将预配置的解析器与我们的自定义节点访问者轻松地嵌入到任何RxPHP应用程序中，该怎么办呢？
- en: 'For example, let''s assume we want to use the PHP Parser library in the following
    way:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，假设我们想以下这种方式使用PHP解析器库：
- en: '[PRE6]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: We have a typical RxPHP chain of operators where we lifted `PHPParserOperator`.
    This class takes in its constructor an array of classes that will be added as
    node visitors to its internal `NodeTraverser`.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有一个典型的RxPHP操作符链，其中我们提升使用了`PHPParserOperator`。这个类在其构造函数中接受一个数组，该数组将作为节点访问者添加到其内部的`NodeTraverser`。
- en: As an input, we're using a primitive array of filenames that'll be emitted by
    the source Observable. The observer will then receive just an array of code style
    violations reported by each of the visitor classes.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 作为输入，我们使用由源可观察对象发出的原始文件名数组。观察者随后将接收到每个访问者类报告的代码风格违规的数组。
- en: Before writing the operator itself, we should first take a look at how to modify
    the visitor class from the previous example. Since we want to be able to add any
    number of custom node visitors that can check anything they want, we need to be
    able to collect all their results and re-emit them as a single value by `PHPParserOperator`.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 在编写操作符本身之前，我们首先应该看看如何修改前一个示例中的访问者类。由于我们希望能够添加任意数量的自定义节点访问者，它们可以检查他们想要的任何内容，我们需要能够收集它们的所有结果，并通过`PHPParserOperator`重新发出一个单一值。
- en: Writing AssignmentInConditionNodeVisitor
  id: totrans-44
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 编写AssignmentInConditionNodeVisitor
- en: 'We can start by defining an interface that all our node visitors have to implement:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以从定义一个接口开始，所有我们的节点访问者都必须实现这个接口：
- en: '[PRE7]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The one requirement for a node visitor is to return an Observable where it''ll
    emit all code style violations:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 对于节点访问者有一个要求，就是返回一个可观察对象，它将发出所有代码风格违规：
- en: '[PRE8]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: This node visitor uses a Subject internally and in the `emitNext()` method it
    emits every code style violation as a single item. This item is an associative
    array itself that contains the line number and the well formatted expression that
    caused the violation (to make it obvious to the user why it's reported). The `PrettyPrinter`
    class is a part of the PHP Parser library.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 这个节点访问者内部使用一个`Subject`，在`emitNext()`方法中，它将每个代码风格违规作为一个单一的项目发出。这个项目本身是一个关联数组，它包含行号和导致违规的格式良好的表达式（以便用户明白为什么被报告）。`PrettyPrinter`类是PHP解析器库的一部分。
- en: This `Subject` class also needs to emit a `complete` signal when we're done
    with this syntax tree. That's in the `afterTraverse()` method. Calling the `complete`
    signal is very important to let other operators work with this `Subject` properly.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 这个`Subject`类还需要在我们完成这个语法树时发出一个`complete`信号。这发生在`afterTraverse()`方法中。调用`complete`信号对于让其他操作符正确地使用这个`Subject`非常重要。
- en: Since we need to expose this `Subject`, we need to be sure nobody else can manipulate
    with it so we wrap it using the `asObservable()` operator.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们需要公开这个`Subject`，我们需要确保没有人可以操纵它，因此我们使用`asObservable()`操作符将其包装起来。
- en: Writing PHPParserOperator
  id: totrans-52
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 编写PHPParserOperator
- en: This operator will hold a single reference to the PHP Parser that we'll invoke
    for every file that comes to this operator. This also means that we'll need to
    create a new instance of the `NodeTraverser` class for each file and add new instances
    of each custom node visitor to it.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 这个操作符将保留对PHP解析器的单一引用，我们将为每个到达这个操作符的文件调用它。这也意味着我们需要为每个文件创建一个新的`NodeTraverser`类实例，并将每个自定义节点访问者的新实例添加到其中。
- en: From the operator's point of view, all node visitors are just Observables that
    emit style violations. The operator needs to collect all values from all of them
    and then reemit this collection as a single item.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 从操作符的角度来看，所有节点访问者只是发出风格违规的可观察对象。操作符需要从所有这些对象中收集所有值，然后将这个集合重新发出作为一个单一的项目。
- en: 'We''ll split this example into two smaller chunks. First, we''ll have a look
    at the creation of the `NodeTraverser` instances filled with node visitors:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将把这个示例分成两个更小的部分。首先，我们将看看如何创建填充了节点访问者的`NodeTraverser`实例：
- en: '[PRE9]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: We keep an array of class names for node visitors in the `$traverserClasses`
    property. When we want to create a new `NodeTraverser`, we iterate this array
    with the `array_map()` function and instantiate each class. Then we not only add
    it to the traverser but we also take its Observable (returned from the `asObservable()`
    method) and chain it with the `toArray()` and `map()` operators.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在`$traverserClasses`属性中保留一个节点访问者类名的数组。当我们想要创建一个新的`NodeTraverser`时，我们使用`array_map()`函数迭代这个数组，并实例化每个类。然后我们不仅将其添加到遍历器中，我们还将其从`asObservable()`方法返回的可观察对象与`toArray()`和`map()`操作符链式连接。
- en: The `toArray()` operator collects all items emitted by the source Observable
    and re-emits them as a single array when the source completes. This is why we
    had to be sure we properly called complete in the `AssignmentInConditionNodeVisitor`
    class. We also used `map()` to emit the final collection of violations with the
    class name that generated them. This isn't necessary, but for practical reasons
    we want to be able to tell what node visitor generated these results (or, in other
    words, what style violations are in this collection).
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '`toArray()` 操作符收集源 Observable 发射的所有项目，并在源完成时将它们重新发射为一个单个数组。这就是为什么我们必须确保在 `AssignmentInConditionNodeVisitor`
    类中正确调用 complete 的原因。我们还使用了 `map()` 来发射带有生成它们的类名的最终违规集合。这不是必需的，但出于实际原因，我们希望能够知道是哪个节点访问者生成了这些结果（或者说，换句话说，这个集合中有什么样式违规）。'
- en: 'The `createTraverser()` method returns two values: the `NodeTraverser` instance
    and an array of Observables returned from each node visitor.'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: '`createTraverser()` 方法返回两个值：`NodeTraverser` 实例和从每个节点访问者返回的 Observables 数组。'
- en: 'The rest of `PHPParserOperator` is where the actual subscription happens:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '`PHPParserOperator` 的其余部分是实际订阅发生的地方：'
- en: '[PRE10]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'First of all, we''re using `CallbackObserver`, which just passes through all
    `error` and `complete` signals. The interesting things happen only in the anonymous
    function `$onNext`:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们使用 `CallbackObserver`，它只是传递所有的 `error` 和 `complete` 信号。有趣的事情只发生在匿名函数 `$onNext`
    中：
- en: We're expecting each item to be a string representing a file path. We read the
    content of the file with the `file_get_contents()` function to get the source
    code we want to analyze.
  id: totrans-63
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们期望每个项目都是一个表示文件路径的字符串。我们使用 `file_get_contents()` 函数读取文件内容，以获取我们想要分析的源代码。
- en: Then, we call `createTraverser()`, which returns a new instance of `NodeTraverser`
    and also an array of Observables, where we'll get all the style violations. These
    are already wrapped with `toArray()` and `map()` as we saw earlier.
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们调用 `createTraverser()`，它返回一个新的 `NodeTraverser` 实例以及一个 Observables 数组，我们将从中获取所有样式违规。这些已经像之前看到的那样用
    `toArray()` 和 `map()` 包装。
- en: We're creating a new `ForkJoinObservable` and passing it the array of Observables
    from the previous call. We implemented this Observable in [Chapter 5](part0043_split_000.html#190861-bd355a22cf10407cb10df27e65585b8d
    "Chapter 5. Testing RxPHP Code") , *Testing RxPHP Code*. The `ForkJoinObservable`
    class subscribes to all its source Observables and remembers only the latest value
    emitted by each one of them. When all the source Observables are complete, it
    reemits all the values as a single array. We know all the sources will emit just
    one value and then complete, thanks to the `toArray()` operator.
  id: totrans-65
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们创建一个新的 `ForkJoinObservable`，并将之前调用中的 Observables 数组传递给它。我们在 [第 5 章](part0043_split_000.html#190861-bd355a22cf10407cb10df27e65585b8d
    "第 5 章。测试 RxPHP 代码") 中实现了这个 Observable，*测试 RxPHP 代码*。`ForkJoinObservable` 类订阅到所有其源
    Observables，并记住每个源 Observables 发射的最新值。当所有源 Observables 都完成时，它将所有值重新发射为一个单个数组。我们知道所有源都将发射一个值然后完成，这是由于
    `toArray()` 操作符。
- en: We're not interested in node visitors that didn't emit any violations, so we
    remove them from the result in the `map()` operator.
  id: totrans-66
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们对没有发射任何违规的节点访问者不感兴趣，所以我们从 `map()` 操作符的结果中移除它们。
- en: In the end, we just subscribe the observer itself to this chain. Note that we're
    purposely not using just `subscribe($observer)` because this would reemit everything
    including errors and complete signals. The Observable chain we created will complete
    immediately after emitting its single value thanks to `ForkJoinObservable`, which
    is what we don't want. Have a look at the previous chapter where we talked about
    sharing a single instance of Subject and what unexpected results it might produce.
    The same reasons apply here as well.
  id: totrans-67
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们只是将观察者本身订阅到这个链上。请注意，我们故意没有使用 `subscribe($observer)`，因为这会重新发射包括错误和完成信号在内的一切。我们创建的
    Observable 链会在发射其单个值后立即完成，这是由于 `ForkJoinObservable`，而这正是我们不想要的。看看前一章，我们讨论了共享单个
    Subject 实例及其可能产生的不预期结果。同样的原因也适用于这里。
- en: After all this, we just run the `traverse()` method that analyzes the source
    code and, thanks to our custom node visitors with Observables, will emit all violations
    that'll be gathered in `ForkJoinObservable`.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 在所有这些之后，我们只是运行 `traverse()` 方法，该方法分析源代码，并借助我们的具有 Observables 的自定义节点访问者，将发射所有将被收集到
    `ForkJoinObservable` 中的违规。
- en: This was a pretty complex operator with a sophisticated behavior. If we go back
    to the example where we showed how we want to use this operator, we can see that
    all this logic is effectively hidden from us.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个相当复杂的操作符，具有复杂的行为。如果我们回到我们展示了如何使用此操作符的示例，我们可以看到所有这些逻辑实际上对我们是隐藏的。
- en: 'When we run the original example that we used earlier, we''ll get the following
    result:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们运行之前使用的原始示例时，我们会得到以下结果：
- en: '[PRE11]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Each item coming from this operator is a series of nested arrays. We can see
    the filename we analyzed and the array of results, where each items is generated
    by one node visitor. Since we have just one result, we also have just one array
    here. Each result is marked by the node visitor class name and a list of violations.
    Each violation contains the line number and the exact expression where it occurred.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 从此操作符出来的每个项目都是一系列嵌套数组。我们可以看到我们分析的文件名和结果数组，其中每个项目都是由一个节点访问者生成的。由于我们只有一个结果，这里也只有一个数组。每个结果都由节点访问者类名和违规列表标记。每个违规包含行号和发生的确切表达式。
- en: This is all nice but how long would it take to analyze a larger project such
    as the Symfony3 framework? Right now, Symfony3 (without third-party dependencies)
    has over 3200 files. If processing a single file would take just 1ms, then analyzing
    the entire project would take over 3s (in fact, processing would take much longer
    just because of so many filesystem operations).
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 这听起来很好，但是分析一个更大的项目，比如Symfony3框架，需要多长时间？目前，Symfony3（不包括第三方依赖项）有超过3200个文件。如果处理单个文件只需要1毫秒，那么分析整个项目将需要超过3秒（实际上，由于文件系统操作如此之多，处理将需要更长的时间）。
- en: So, this looks like a prime example where we could utilize our knowledge of
    multithreaded programming in PHP with pthreads.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，这似乎是一个我们可以利用我们在PHP中使用pthreads的多线程编程知识的绝佳例子。
- en: Implementing ThreadPoolOperator
  id: totrans-75
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现`ThreadPoolOperator`
- en: We're going to write a universal operator that receives jobs represented by
    `Thread` class instances from its source Observable. Then, it'll submit them to
    an internal instance of the `Pool` class that we saw in the previous chapter.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将编写一个通用操作符，它从其源Observable接收由`Thread`类实例表示的工作。然后，它将它们提交到我们在上一章中看到的`Pool`类的内部实例。
- en: In fact, this example with pthreads is going to be entirely built on all the
    things we've learned in the previous chapter, so we won't recap them here.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 事实上，这个使用pthreads的例子将完全基于我们在上一章中学到的所有内容，所以我们在这里不会回顾它们。
- en: Note
  id: totrans-78
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: This example is also going to use PHP7 syntax in some situations since pthreads
    v3 works only with PHP7 anyway.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子在某些情况下也将使用PHP7语法，因为pthreads v3版本仅支持PHP7。
- en: 'For this operator, well internally use an event loop. In RxPHP, this means
    we''ll use the `StreamSelectLoop` class wrapped with a `Scheduler` class. Let''s
    see the source code for `ThreadPoolOperator` and then talk about why it''s implemented
    like this:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个操作符，我们内部将使用事件循环。在RxPHP中，这意味着我们将使用`StreamSelectLoop`类，并用`Scheduler`类包装它。让我们看看`ThreadPoolOperator`的源代码，然后讨论为什么它被这样实现：
- en: '[PRE12]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The constructor for `ThreadPoolOperator` takes the same arguments as the constructor
    for the `Pool` class that is created right away. The interesting things take place
    in the `__invoke()` method.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '`ThreadPoolOperator`的构造函数接受与创建的`Pool`类构造函数相同的参数。有趣的事情发生在`__invoke()`方法中。'
- en: Every item that arrives to this operator is sent to the thread pool with the
    `submit()` method. This means that `ThreadPoolOperator` can only work with items
    represented by the `Thread` class from the pthreads extension (and of course all
    classes extending this class).
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 到达此操作符的每个项目都将通过`submit()`方法发送到线程池。这意味着`ThreadPoolOperator`只能与由pthreads扩展中的`Thread`类（以及当然所有扩展这个类的类）表示的项目一起工作。
- en: Internally, we use the `Scheduler` class to periodically call a callable that
    will check the thread pool for threads that have finished and are ready to be
    collected. This is the same `collect()` method we saw in the previous chapter.
    However, in this implementation we're making only a single check in every iteration
    of the callable. There's one very important reason why we want to use it this
    way. We know that we can use the `collect()` method in a loop that runs as long
    as there are tasks scheduled to be run.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 内部，我们使用`Scheduler`类定期调用一个可调用对象，该对象将检查线程池中已完成并准备好收集的线程。这就是我们在上一章中看到的相同的`collect()`方法。然而，在这个实现中，我们在可调用对象的每次迭代中只进行一次检查。有一个非常重要的原因我们要这样使用它。我们知道我们可以在一个循环中使用`collect()`方法，只要还有计划运行的任务。
- en: 'The loop typically looks like this:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 循环通常看起来像这样：
- en: '[PRE13]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: This is of course correct. The only problem is that this call is blocking. The
    interpreter is stuck in this loop and doesn't let us do anything else. If we wanted
    to use such a loop and at the same time read data from a stream via `StreamSelectLoop`
    (see [Chapter 6](part0050_split_000.html#1FLS41-bd355a22cf10407cb10df27e65585b8d
    "Chapter 6. PHP Streams API and Higher-Order Observables") , *PHP Streams API
    and Higher-Order Observables*), we wouldn't be able to receive anything as long
    as this loop is running. Another example that wouldn't work if we used just this
    `while` loop could be `IntervalObservable` , which needs to schedule timers itself.
    These wouldn't be triggered until this loop is ended.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，这是正确的。唯一的问题是这个调用是阻塞的。解释器在这个循环中卡住，不允许我们做任何事情。如果我们想使用这样的循环，同时通过`StreamSelectLoop`（见[第6章](part0050_split_000.html#1FLS41-bd355a22cf10407cb10df27e65585b8d
    "第6章。PHP Streams API和高级观察者")，*PHP Streams API和高级观察者*）从流中读取数据，只要这个循环在运行，我们就无法接收任何东西。如果我们只使用这个`while`循环，另一个无法工作的例子可能是`IntervalObservable`，它需要自己安排定时器。这些定时器只有在循环结束时才会被触发。
- en: That's why we're periodically scheduling a 10ms timer to run `collect()` just
    once and then let other timers or streams be handled. The finished threads are
    kept in the `Pool` class until we read and reemit their results.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 正因如此，我们定期安排一个10毫秒的定时器来运行`collect()`一次，然后让其他定时器或流进行处理。完成后的线程被保存在`Pool`类中，直到我们读取并重新发射它们的结果。
- en: This implementation has one very important behavior. Since it is running all
    tasks in parallel and completely independently of the rest of the Observable chain,
    we need to be aware when we send the `complete` signal.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 这种实现有一个非常重要的行为。由于它并行运行所有任务，并且完全独立于其余的Observable链，我们需要注意何时发送`complete`信号。
- en: 'Consider the following code:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下代码：
- en: '[PRE14]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: In this example, the `ThreadPoolOperator` class receives three instances of
    `MyThread` that'll be submitted to the `Pool` instance, but it also receives a
    complete signal. This complete signal is immediately passed to its observer that
    unsubscribes before any of the threads are finished and emit any value.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，`ThreadPoolOperator`类接收三个`MyThread`实例，这些实例将被提交给`Pool`实例，但它也接收一个完成信号。这个完成信号立即传递给它的观察者，在任何一个线程完成并发射任何值之前取消订阅。
- en: At the same time, `ThreadPoolOperator` can't decide for itself when you want
    to send the `complete` signal. Sometimes when the thread pool is empty and there
    are no tasks running. Other times we might want to start threads based on PHP
    stream activity that can happen at any time.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 同时，`ThreadPoolOperator`不能自己决定何时发送`complete`信号。有时当线程池为空且没有任务运行时，我们可能想要发送信号。其他时候，我们可能希望根据PHP流活动在任何时候启动线程。
- en: That's why we don't send `complete` signals automatically.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 正因如此，我们不自动发送`complete`信号。
- en: Implementing PHPParserThread
  id: totrans-95
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现`PHPParserThread`
- en: Now we can take a look at how the actual parser task is going to be implemented.
    We already know that it needs to be represented by a class extending the default
    `Thread` class from the pthreads extension and we also know that we're going to
    process files using the PHP Parser, so we can reuse the `PHPParserOperator` class.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以看看实际的解析任务是如何实现的。我们已经知道它需要由从`pthreads`扩展的默认`Thread`类扩展的类来表示，我们也知道我们将使用PHP解析器处理文件，因此我们可以重用`PHPParserOperator`类。
- en: 'Before we do that, we should define some common behavior for all `Thread` objects:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们这样做之前，我们应该为所有的`Thread`对象定义一些共同的行为：
- en: '[PRE15]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: All tasks we want to run with `ThreadPoolOperator` need to extend this abstract
    class that defines some common methods.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 我们想要使用`ThreadPoolOperator`运行的所有任务都需要扩展这个抽象类，该类定义了一些共同的方法。
- en: 'Notice that we don''t have a setter method for the `$result` property. This
    is intentional and we''ll see why when we look at the implementation of `PHPParserThread`
    that we will use in this application:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们没有为`$result`属性提供一个设置方法。这是故意的，我们将在查看我们将在此应用程序中使用的`PHPParserThread`的实现时看到原因：
- en: '[PRE16]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: As you can see, we're using typecasting for the exact same reasons as described
    in the previous chapter. Also notice that we're wrapping the input file with an
    array. Since we want to make this class reusable, we'll support both passing a
    single file and an array of files. We're initializing the `$result` property with
    an empty array that's automatically converted to a `Volatile` object by pthreads
    (again, for more information refer to the previous chapter). For this reason,
    we need to keep track of the number of items already persistent by ourselves with
    the `$last` variable. Also, notice that our result is always going to be an array,
    even when processing just a single file.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，我们正在使用类型转换，原因与上一章中描述的完全相同。同时请注意，我们正在将输入文件包裹在一个数组中。由于我们希望使这个类可重用，我们将支持传递单个文件或文件数组。我们使用一个空数组初始化
    `$result` 属性，该数组会被 pthreads 自动转换为 `Volatile` 对象（再次，有关更多信息，请参阅上一章）。因此，我们需要通过自己的
    `$last` 变量跟踪已持久化的项目数量。此外，请注意，我们的结果始终将是一个数组，即使只是处理单个文件也是如此。
- en: At this point, we need to be aware why not to use any setter method for `$result`.
    In the previous chapter, when talking about `Volatile` objects, we said that pthreads
    automatically convert arrays to `Volatile` when assigning to a property in any
    class extending the `Threaded` class. For this reason, we can't use a setter because
    we wouldn't be able to force typecasting to array with `(array)`. This automatic
    conversion happens on assignment, so we'd have to force all results in `AbstractRxThread`
    to be arrays or leave it to the automatic conversion, which is something we definitely
    don't want.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，我们需要意识到为什么不能为 `$result` 使用任何设置方法。在前一章中，当我们谈到 `Volatile` 对象时，我们提到 pthreads
    在将数组赋值给任何扩展 `Threaded` 类的类的属性时，会自动将数组转换为 `Volatile`。因此，我们不能使用设置器，因为我们无法通过 `(array)`
    强制类型转换到数组。这种自动转换发生在赋值时，因此我们必须强制 `AbstractRxThread` 中的所有结果都是数组，或者让它自动转换，而这绝对不是我们想要的。
- en: 'To be extra clear about this issue, let''s consider the following setter method:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更清楚地说明这个问题，让我们考虑以下设置方法：
- en: '[PRE17]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The assignment happens inside this function where we don't want to force using
    arrays with `(array)` typecast. We might want to use a simple string or an integer,
    for example.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 赋值发生在我们不想使用 `(array)` 类型转换强制使用数组的这个函数内部。我们可能想使用一个简单的字符串或整数，例如。
- en: So this was our `PHPParserThread` class that we'll use in this example. There's
    actually one more issue.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，这是我们将在本例中使用的 `PHPParserThread` 类。实际上还有一个问题。
- en: Creating a new thread with pthreads means we're internally creating a new PHP
    interpreter context. The only classes and functions this new context knows are
    those built into the PHP interpreter itself. This new context has no idea what
    `Observable` or `PHPParserOperator` classes are.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 pthreads 创建新线程意味着我们在内部创建了一个新的 PHP 解释器上下文。这个新上下文所知道的类和函数仅限于 PHP 解释器本身内置的。这个新上下文对
    `Observable` 或 `PHPParserOperator` 类一无所知。
- en: Just like we include the `autoload.php` Composer autoloader script when running
    any PHP application, we need to do this for every new thread we create. Since
    we don't want to do this every time we use `PHPParserThread`, we can make use
    of a custom worker that'll do it for us in its `run()` method. This `run()` method
    is called when spawning a new interpreter context and lets us initialize it by,
    for example, including the `autoload.php` script.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在运行任何 PHP 应用程序时包含 `autoload.php` Composer 自动加载脚本一样，我们需要为每个新创建的线程做这件事。由于我们不希望在每次使用
    `PHPParserThread` 时都这样做，我们可以使用一个自定义的工作者，它将在其 `run()` 方法中为我们完成这件事。这个 `run()` 方法在创建新的解释器上下文时被调用，并允许我们通过例如包含
    `autoload.php` 脚本来初始化它。
- en: Implementing PHPParserWorker
  id: totrans-110
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现 PHPParserWorker
- en: 'For the sake of simplicity, we''re not defining our classes in namespaces and
    usually just including them with the `require_once` keyword, such as in the following
    example:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 为了简化，我们没有在命名空间中定义我们的类，通常只是使用 `require_once` 关键字包含它们，例如以下示例：
- en: '[PRE18]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: For this reason, we need to tell the autoloader created inside each worker where
    to find such classes ideally without relying on the `require_once` statements.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们需要告诉每个工作者内部创建的自动加载器在哪里可以找到这样的类，理想情况下不依赖于 `require_once` 语句。
- en: 'Our worker will be a simple class (based on the official example on how to
    use Composer''s autoloader with pthreads at [https://github.com/krakjoe/pthreads-autoloading-composer](https://github.com/krakjoe/pthreads-autoloading-composer)
    ):'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的工作者将是一个简单的类（基于官方示例，如何在 pthreads 中使用 Composer 的自动加载器，请参阅 [https://github.com/krakjoe/pthreads-autoloading-composer](https://github.com/krakjoe/pthreads-autoloading-composer)）：
- en: '[PRE19]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: This worker uses `require_once` to register the autoloader, where we add a few
    class paths. The initialized interpreter context will be used by all `Thread`
    instances ran by this worker.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 这个工作进程使用`require_once`来注册自动加载器，我们在其中添加了一些类路径。初始化的解析器上下文将由这个工作进程运行的所有`Thread`实例使用。
- en: Finally, we can put all this into a single Observable chain.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们可以将这些全部放入一个单独的可观察链中。
- en: Running PHP Parser in a multithreaded application
  id: totrans-118
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在多线程应用程序中运行PHP解析器
- en: 'First, we will test all the classes we made right now on processing the same
    sample file as earlier and then move to recursively processing directories from
    the Symfony3 project:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将测试我们现在制作的类，处理与之前相同的样本文件，然后递归地处理来自Symfony3项目的目录：
- en: '[PRE20]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'This example is using all three classes for multithreading that we created
    in this chapter. Let''s see what happens in this operator chain step by step:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子使用了本章中创建的所有三个用于多线程的类。让我们一步一步看看这个操作符链会发生什么：
- en: We have a single source Observable that emits the filename as its value. Notice
    that we're purposely not sending the complete signal.
  id: totrans-122
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们有一个单独的源可观察对象，它发射文件名作为其值。请注意，我们故意没有发送完整的信号。
- en: Then we use map to turn all filenames to instances of the `PHPParserThread`
    class.
  id: totrans-123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后我们使用map将所有文件名转换为`PHPParserThread`类的实例。
- en: The `ThreadPoolOperator` class is fed with tasks it has to run.
  id: totrans-124
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`ThreadPoolOperator`类被喂入它必须运行的任务。'
- en: We've mentioned already that all results from `ThreadPoolOperator` are returned
    as arrays even when we processed just a single file. For this reason, we use `flatMap()`
    to reemit its values and flatten the result. Also we need to typecast the result
    from `Volatile` to an array.
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们已经提到，即使我们只处理单个文件，`ThreadPoolOperator`的所有结果都作为数组返回。因此，我们使用`flatMap()`重新发射其值并展平结果。此外，我们还需要将结果从`Volatile`类型转换为数组。
- en: We didn't send the `complete` signal from the source on purpose. However, we
    know that we processed only one file and therefore we're expecting only one item
    to be emitted. So we can use `take(1)` to send the `complete` signal for us and
    the observer will unsubscribe successfully, which will stop the event loop as
    well.
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们故意没有从源发送`complete`信号。然而，我们知道我们只处理了一个文件，因此我们期望只发射一个项目。所以我们可以使用`take(1)`为我们发送`complete`信号，观察者将成功取消订阅，这将停止事件循环。
- en: 'We can run this example and see that it returned exactly the same result as
    the original version with just `PHPParserOperator`:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以运行这个示例，并看到它返回了与仅使用`PHPParserOperator`的原版完全相同的结果：
- en: '[PRE21]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Note
  id: totrans-129
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Although most of our CLI applications in this book are based on the Symfony
    Console component, this time we don't even need it since the entire application
    can be written as a single operator chain.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管本书中的大多数CLI应用程序都是基于Symfony Console组件，但这次我们甚至不需要它，因为整个应用程序可以写成一个单独的操作符链。
- en: In this example, we spawned two workers even though we wanted to process just
    a single file.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，尽管我们只想处理单个文件，但我们还是启动了两个工作进程。
- en: 'The question is what will be the difference if we try to process multiple files
    in parallel. For this reason, we''ll create a Symfony3 test project that contains
    literally thousands of PHP files we can test:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 问题是如果我们尝试并行处理多个文件，会有什么不同。因此，我们将创建一个包含成千上万个PHP文件以供测试的Symfony3测试项目：
- en: '[PRE22]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'The following example will work just like the previous one. This time, however,
    we''ll make a recursive iterator that walks through all subdirectories and emits
    all PHP files it finds. We can write this all as one large operator chain:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例将像上一个示例一样工作。然而，这次我们将创建一个递归迭代器，遍历所有子目录并发射它找到的所有PHP文件。我们可以将所有这些写成一个大的操作符链：
- en: '[PRE23]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: This is the longest operator chain we've written in this book. The main thing
    that has changed is the source emitting filenames that we want to analyze. We
    have two different iterators, where both of them return `SplFileInfo` objects.
    We know how many files we want to test in total, so we can avoid emitting redundant
    values with the `take()` operator.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们在本书中编写的最长的操作符链。主要变化是源端发射的我们要分析的文件名。我们有两个不同的迭代器，它们都返回`SplFileInfo`对象。我们知道我们总共要测试多少个文件，因此我们可以使用`take()`操作符避免发射冗余值。
- en: When we spoke about backpressure in the previous chapters, we mentioned the
    `bufferWithCount()` operator that stacks values and then reemits them in a single
    array. This comes very handy now where we don't want to create a task on the thread
    pool for every single file and rather emit them in batches.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 在前几章中我们讨论了背压时，提到了`bufferWithCount()`操作符，它会堆叠值然后在一个数组中重新发射它们。现在这非常有用，因为我们不希望在线程池中为每个文件创建一个任务，而是批量发射它们。
- en: In the end, we also used `filter()` to ignore all the results that don't have
    any violations. Of course, we're interested only in files that have at least one
    violation.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们也使用了`filter()`来忽略所有没有违规的结果。当然，我们只对至少有一个违规的文件感兴趣。
- en: An important part of this example is that it measures how long it took to run
    this entire application (from the initial subscription until disposing `CallbackDisposable`).
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 这个示例的一个重要部分是它测量了运行整个应用程序所需的时间（从初始订阅到销毁`CallbackDisposable`）。
- en: 'If we run this code, we''ll see a large list that looks similar to the following:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们运行这段代码，我们会看到一个类似以下的大列表：
- en: '[PRE24]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'The line reported contains the following code:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 报告的行包含以下代码：
- en: '[PRE25]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: This is really a code style that we wanted to be able to report.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 这确实是我们想要能够报告的代码风格。
- en: 'Now comes the important question, what is the effect of running the analyzer
    in multiple-threads? We can make a couple of reruns with settings such as `1`,
    `2`, `4`, and `6` threads. To get more relevant results, we can increase the number
    of files processed to 1,000 and also disable the `xdebug` extension that otherwise
    slows down the execution significantly. On average, the times were as follows:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 现在来谈谈一个重要的问题，运行分析器在多线程中的效果是什么？我们可以用`1`、`2`、`4`和`6`线程等设置进行几次重跑。为了得到更相关的结果，我们可以增加处理的文件数量到1,000，并且禁用`xdebug`扩展，否则它会显著减慢执行速度。平均下来，时间如下：
- en: '[PRE26]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: As we can see, increasing the number of threads starts to be counterproductive.
    These times were measured on 2, 5 GHz Intel Core i5, which is a dual-core processor
    with an SSD hard drive. The result for a higher number of threads would probably
    be better with a non-SSD hard drive because each thread would have to spend more
    time loading file contents, which would allow other threads to execute in the
    meantime.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，增加线程的数量开始变得适得其反。这些时间是在2.5 GHz英特尔酷睿i5上测量的，这是一个双核处理器，带有SSD硬盘。对于更多的线程，使用非SSD硬盘的结果可能会更好，因为每个线程将不得不花费更多的时间来加载文件内容，这会允许其他线程在此期间执行。
- en: We almost reached half the time of running just a single thread, which is a
    realistic expectation. On a dual-core processor and with the overhead generated
    by RxPHP and PHP itself, this is an expected result.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 我们几乎达到了只运行一个线程时间的一半，这是一个现实的目标。在一个双核处理器上，以及RxPHP和PHP本身产生的开销下，这是一个预期的结果。
- en: 'We can have a look at the output of the `htop` command that shows the current
    CPU usage to prove that both cores are fully utilized:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以查看`htop`命令的输出，它显示了当前的CPU使用情况，以证明两个核心都被充分利用：
- en: '![Running PHP Parser in a multithreaded application](img/00032.jpeg)'
  id: totrans-150
  prefs: []
  type: TYPE_IMG
  zh: '![在多线程应用程序中运行PHP解析器](img/00032.jpeg)'
- en: Current CPU usage when running threads_php_parser_02.php example
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 运行threads_php_parser_02.php示例时的当前CPU使用率
- en: The `htop` tool is showing four cores because there are two hardware threads
    per core (it's in fact just a dual-core processor).
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: '`htop`工具显示有四个核心，因为每个核心有两个硬件线程（实际上它只是一个双核处理器）。'
- en: Running the parser in parallel in a single process by just utilizing pthreads
    is pretty efficient.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 只通过利用pthread在单个进程中并行运行解析器非常高效。
- en: Our use case can be generalized as simply splitting a job among multiple workers.
    We don't really care what protocols we'll use or how the distribution is going
    to happen. We don't even care about what worker will process a particular batch.
    We just need to get the job done.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的使用案例可以概括为简单地在一个多个工作者之间分割一个工作。我们并不关心我们将使用什么协议或分布将如何发生。我们甚至不关心哪个工作者将处理特定的批次。我们只需要完成这项工作。
- en: This is an ideal use case for Gearman.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 这是对Gearman的理想用例。
- en: Introduction to Gearman
  id: totrans-156
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Gearman简介
- en: Gearman is a framework for distributing work among multiple processes and machines.
    Due to its functionality, it can serve as a manager, load balancer, or interface
    between different languages with no single point of failure.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: Gearman是一个在多个进程和机器之间分配工作的框架。由于其功能，它可以作为一个管理者、负载均衡器，或者在不同语言之间没有单点故障的接口。
- en: Since this book is about Rx/reactive/asynchronous programming, we're going to
    cover Gearman fairly quickly. Needless to say, Gearman is very easy to set up
    and use.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 由于本书是关于 Rx/reactive/异步编程的，我们将快速介绍 Gearman。不用说，Gearman 非常容易设置和使用。
- en: The Gearman PHP extension is written in the C language, so we need to install
    it via PECL or a package manager relevant to your platform (refer to [http://gearman.org/download/](http://gearman.org/download/)
    for more information).
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: Gearman PHP 扩展是用 C 语言编写的，因此我们需要通过 PECL 或与您的平台相关的包管理器来安装它（有关更多信息，请参阅 [http://gearman.org/download/](http://gearman.org/download/)）。
- en: Gearman's name is an anagram of the word "Manager" and it pretty well captures
    its purpose. Gearman doesn't do the work itself. It just receives a task (also
    referred to simply as a job) from a client and delegates it to an available worker.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: Gearman 的名字是 "Manager" 一词的字母重组，很好地概括了其用途。Gearman 本身并不执行工作。它只是从客户端接收一个任务（也简单地称为工作）并将其委托给一个可用的工人。
- en: 'The structure of any Gearman application is easily understood from the following
    diagram:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 从以下图表中可以很容易地理解任何 Gearman 应用程序的结构：
- en: '![Introduction to Gearman](img/00033.jpeg)'
  id: totrans-162
  prefs: []
  type: TYPE_IMG
  zh: '![Gearman 简介](img/00033.jpeg)'
- en: Diagram from the official Gearman documentation (http://gearman.org/)
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 来自官方 Gearman 文档的图表（http://gearman.org/）
- en: 'Every Gearman application has the following three main components:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 每个 Gearman 应用程序都有以下三个主要组件：
- en: '**Gearman Job Server**: This is usually run as a daemon that accepts tasks
    from clients and delegates them to workers. It''s written in C (originally in
    Perl) and doesn''t do any work by itself. It''s also able to keep the current
    tasks queue persisted in a database so it can be restored on failure.'
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Gearman 工作服务器**：这通常作为一个守护进程运行，接受来自客户端的任务并将它们委托给工人。它用 C 语言编写（最初用 Perl 编写），并且本身不执行任何工作。它还能够将当前任务队列持久化到数据库中，以便在失败时恢复。'
- en: '**Client**: This is any application in any language that needs some job to
    be done. This can be a web application that needs to send an e-mail or a CLI application
    that needs to run static analysis on a couple of files. The client doesn''t do
    the job by itself. It sends a message to the job server and either waits until
    it''s done or just waits for confirmation from the job server that it was added
    to the queue.'
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**客户端**：这是任何需要执行某些工作的应用程序，可以是任何语言的。这可能是一个需要发送电子邮件的 Web 应用程序或需要运行几个文件上的静态分析的
    CLI 应用程序。客户端本身不执行工作。它向工作服务器发送消息，要么等待工作完成，要么等待工作服务器确认它已被添加到队列中。'
- en: '**Worker**: This is the part that actually does the job delegated by the job
    server. It can be written in any language as well. It contains a list of functions
    that it''s able to perform and based on that the job server assigns the work it
    needs to do.'
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**工人**：这是实际执行工作服务器委托的工作的部分。它也可以用任何语言编写。它包含一个它能执行的功能列表，根据这个列表，工作服务器分配它需要执行的工作。'
- en: So in order to start using Gearman, we need to have the job server part installed
    and running on our system; it's usually called **gearman** or **gearmand**. You
    can find the instructions how to install and run Gearman for your platform at
    [http://gearman.org/download/](http://gearman.org/download/) .
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，为了开始使用 Gearman，我们需要在我们的系统上安装并运行工作服务器部分；它通常被称为 **gearman** 或 **gearmand**。您可以在
    [http://gearman.org/download/](http://gearman.org/download/) 找到有关如何为您的平台安装和运行
    Gearman 的说明。
- en: String strlen client and worker
  id: totrans-169
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 字符串长度客户端和工人
- en: We can create a very simple application, where we'll have a worker that takes
    a string and returns its length. The client in this case will just send a string
    to the job server requesting to get the length back.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以创建一个非常简单的应用程序，其中我们将有一个工人，它接受一个字符串并返回其长度。在这种情况下，客户端将仅向工作服务器发送一个字符串，请求返回长度。
- en: 'Our client is going to be pretty simple. It''ll just request a job, `strlen`,
    to be done and then wait until it receives a response from the job server:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的客户端将非常简单。它将仅请求一个工作，`strlen`，然后等待从工作服务器收到响应：
- en: '[PRE27]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Our client connects to a single job server and sets a three-second timeout.
    If it doesn't receive a response within this time, then it continues executing
    the rest of the script. We're using a single server, but we can have multiple
    job servers running on different machines, and if any of them crash, clients will
    continue with the other ones. This makes the system fault tolerant. Also, notice
    that our client is blocking.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的客户端连接到单个工作服务器并设置三秒的超时。如果在规定时间内没有收到响应，则继续执行脚本的其他部分。我们使用单个服务器，但可以在不同的机器上运行多个工作服务器，如果其中任何一个崩溃，客户端将继续使用其他服务器。这使得系统具有容错能力。此外，请注意，我们的客户端是阻塞的。
- en: We're requesting a job to be done using the `doNormal()` method, where we need
    to specify the name of the job we want to do and all the data the worker needs
    in order to complete it. Apart from `doNormal()`, there are also methods such
    as `doLow()` and `doHigh()` that request the job with a different priority.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 我们正在使用`doNormal()`方法请求执行一个作业，其中我们需要指定我们想要执行的作业名称以及工作者完成它所需的所有数据。除了`doNormal()`之外，还有`doLow()`和`doHigh()`等方法，它们以不同的优先级请求作业。
- en: Typically, when we want to run a job, we want to know its result. For example,
    in this case, we wanted to wait to get the string length back. In some situations,
    we just want to schedule a job, but we're not interested in when it happens and
    what its result is. A typical use case is a web application where a user registers
    and we want to send them a confirmation e-mail. We don't want to slow down the
    page load by waiting until the e-mail is sent.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，当我们想要运行一个作业时，我们想知道它的结果。例如，在这种情况下，我们想要等待获取字符串长度。在某些情况下，我们只想安排一个作业，但我们不关心它何时发生以及它的结果是什么。一个典型的用例是Web应用程序，其中用户注册，我们想要给他们发送确认电子邮件。我们不希望通过等待电子邮件发送来减慢页面加载速度。
- en: For this reason, the `Client` class also has the `doBackground()` method (with
    their higher and lower priority variants). This method sends the request to a
    job server and only waits for confirmation that it was received. The client is
    not interested in when it'll be executed and with what result. If we refer to
    the previous use case with a web application and sending confirmation e-mails,
    it doesn't matter whether the e-mail is sent right now or after 10 seconds.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，`Client`类还有一个`doBackground()`方法（及其更高和更低优先级的变体）。此方法将请求发送到作业服务器，并且只等待确认它已被接收。客户端不关心它何时执行以及结果如何。如果我们参考之前的Web应用程序和发送确认电子邮件的用例，现在发送电子邮件或10秒后发送都无关紧要。
- en: 'The worker script will wait for jobs from the job server, execute them, and
    return the result:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 工作者脚本将等待来自作业服务器的作业，执行它们，并返回结果：
- en: '[PRE28]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Usually, the worker runs in a loop and therefore is blocking as well. We connect
    to the same job server as the client and define a single function called `strlen`.
    This is the same name that the client specified when requesting a job. The value
    returned from the callable will be sent back to the client automatically.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，工作者在循环中运行，因此也是阻塞的。我们连接到与客户端相同的作业服务器，并定义一个名为`strlen`的单个函数。这是客户端在请求作业时指定的相同名称。从可调用返回的值将自动发送回客户端。
- en: 'Now, we can test this example. Before running either the client or the worker,
    we need to start the Gearman job server:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以测试这个例子。在运行客户端或工作者之前，我们需要启动Gearman作业服务器：
- en: '[PRE29]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: We can use the `verbose` option to make the process more talkative. Without
    specifying any other options, the job server will listen on port `4730`, which
    is used by the PHP extension as well, so we don't need to configure anything.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用`verbose`选项使过程更加健谈。如果没有指定任何其他选项，作业服务器将监听端口`4730`，这个端口也被PHP扩展使用，因此我们不需要进行任何配置。
- en: Then, we'll run both the worker and the client. It doesn't matter which one
    we run first. Our client waits for three seconds before the timeout expires, so
    we can run it first and the pending job will be queued by the job server until
    there's at least one worker available to execute this job.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将运行工作者和客户端。哪个先运行都无关紧要。我们的客户端在超时到期前等待三秒钟，因此我们可以先运行它，挂起的作业将被作业服务器排队，直到至少有一个工作者可以执行此作业。
- en: 'The console output after we run both the client and the worker will look like
    the following:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 运行客户端和工作者后的控制台输出将如下所示：
- en: '[PRE30]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'The worker is, in fact, running in a loop, so after processing this job, it''ll
    wait for another one:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，工作者是在循环中运行的，因此处理完这个作业后，它会等待另一个作业：
- en: '[PRE31]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: The client just receives the response and ends.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 客户端只接收响应并结束。
- en: 'What''s sometimes useful is that the Gearman CLI also contains a `gearman`
    application that can run as a client or worker. In our example, we didn''t have
    to write a worker at all and could simply run the following command:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 有时很有用的一点是，Gearman CLI还包含一个可以运行为客户端或工作者的`gearman`应用程序。在我们的例子中，我们根本不需要编写工作者，只需简单地运行以下命令：
- en: '[PRE32]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: This command creates a worker that connects to its default settings (localhost
    on port `4730`). With `-w`, we told Gearman that we want to start a worker, and
    with `-f strlen`, we defined what function it handles. Then, when it receives
    a new job, it spawns a new subprocess and runs `wc -c`, where it feeds the workload
    as a standard input. So, this command is a drop-in replacement for our PHP worker.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 这个命令创建了一个连接到其默认设置（localhost端口`4730`）的工作者。通过`-w`，我们告诉Gearman我们想要启动一个工作者，通过`-f
    strlen`，我们定义了它处理的函数。然后，当它收到一个新作业时，它会启动一个新的子进程并运行`wc -c`，其中它将工作负载作为标准输入传递。因此，这个命令是我们PHP工作者的直接替代品。
- en: Of course we can run multiple workers at the same time on the same machine.
    Each worker can handle multiple different functions. The job server is responsible
    for deciding what worker is going to process each job.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，我们可以在同一台机器上同时运行多个工作者。每个工作者可以处理多个不同的函数。作业服务器负责决定哪个工作者将处理每个作业。
- en: Running PHP Parser as a Gearman worker
  id: totrans-193
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将PHP解析器作为Gearman工作者运行
- en: We've already seen how to run our `PHPParserOperator` in multiple threads. We
    can, however, run it in multiple processes more easily than in threads by writing
    a Gearman worker that runs `PHPParserOperator` internally.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到了如何在多个线程中运行我们的`PHPParserOperator`。然而，我们可以通过编写一个内部运行`PHPParserOperator`的Gearman工作者来更容易地在多个进程中运行它，而不是在线程中。
- en: 'The worker will be very simple. It''ll just receive the filename it needs to
    load and analyze, and then return the result:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 工作者将非常简单。它只需接收它需要加载和分析的文件名，然后返回结果：
- en: '[PRE33]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: The main difference is that we're not using any return statement in the callable
    for the `phpparser` function. Since everything is asynchronous in RxPHP, we need
    to use the `sendComplete(...)` method to send the result to the client and mark
    the job as done.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 主要的区别是我们没有在`phpparser`函数的可调用对象中使用任何返回语句。由于在RxPHP中一切都是异步的，我们需要使用`sendComplete(...)`方法将结果发送给客户端并标记作业已完成。
- en: 'When we run this worker, it won''t print any output to the console:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们运行这个工作者时，它不会向控制台打印任何输出：
- en: '[PRE34]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Then we can test it right away, without writing any client application, and
    just use the CLI command as a client:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以立即测试它，而无需编写任何客户端应用程序，只需使用CLI命令作为客户端：
- en: '[PRE35]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: We can see that the console output is the same as we saw previously when testing
    the `PHPParserOperator` operator.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到，控制台输出与我们之前测试`PHPParserOperator`操作符时看到的是相同的。
- en: The `-f phpparser` tells `gearman` what function we want to run, and with `-s`
    we can skip reading from the standard input and just pass the string as a workload.
    At the end, we used `json_pp` to pretty print the output to make it more readable.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: '`-f phpparser`告诉`gearman`我们想要运行哪个函数，通过`-s`我们可以跳过从标准输入读取，并直接将字符串作为工作负载传递。最后，我们使用了`json_pp`来美化输出，使其更易于阅读。'
- en: Of course, we're running this example on the same machine and in the same directory,
    so we don't need to worry about correct file paths. In a real-world application,
    we'd probably send the file content instead.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，我们在这个机器和同一个目录下运行这个示例，所以我们不需要担心正确的文件路径。在实际应用中，我们可能会发送文件内容。
- en: This was a fairly quick introduction to Gearman. As we can see, using Gearman
    is very easy. Actually, in PHP it's much easier to use Gearman than using the pthreads
    extension to run jobs in parallel.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 这是对Gearman的相当快速的介绍。正如我们所看到的，使用Gearman非常简单。实际上，在PHP中使用Gearman比使用pthreads扩展并行运行作业要容易得多。
- en: From our perspective, it's important to know that Gearman applications are usually
    blocking, so everything we mentioned about running multiple even loops in [Chapter
    6](part0050_split_000.html#1FLS41-bd355a22cf10407cb10df27e65585b8d "Chapter 6. PHP
    Streams API and Higher-Order Observables") , *PHP Streams API and Higher-Order
    Observables*, is very relevant here as well.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 从我们的角度来看，了解Gearman应用程序通常是阻塞的这一点很重要，因此我们在[第6章](part0050_split_000.html#1FLS41-bd355a22cf10407cb10df27e65585b8d
    "第6章。PHP Streams API和高级观察者")中提到的关于运行多个事件循环的内容，*PHP Streams API和高级观察者*，在这里也非常相关。
- en: If you want to read more about Gearman, head over to their official documentation
    with examples at [http://gearman.org/manual/](http://gearman.org/manual/) .
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想了解更多关于Gearman的信息，请访问他们的官方文档，其中包含示例[http://gearman.org/manual/](http://gearman.org/manual/)。
- en: Comparing pthreads and Gearman
  id: totrans-208
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 比较pthread和Gearman
- en: The main difference between using pthreads and Gearman is obviously whether
    we're running a single process with multiple threads or just one process multiple
    times.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 使用pthread和Gearman之间的主要区别显然是我们是运行一个进程的多个线程还是仅仅运行多个进程。
- en: The advantages and disadvantages of pthreads were partly covered in the previous
    chapter and also here. Having completely separated PHP interpreter contexts makes
    things a little non-intuitive (for example, using autoloaders and yet again sharing
    data between contexts) and definitely requires more debugging than the same single-threaded
    equivalent. However, if we're willing to spend the necessary time with it, the
    performance benefits are significant and at the end running a single process is
    always easier than taking care of multiple processes.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: pthreads的优缺点在上一章和本章都有所涉及。完全分离的PHP解释器上下文使得事情稍微有些不直观（例如，使用自动加载器，并且在上下文之间再次共享数据）并且肯定需要比单线程等效方案更多的调试。然而，如果我们愿意投入必要的时间，性能优势是显著的，并且最终运行单个进程总是比管理多个进程要容易。
- en: Gearman is designed to delegate work from clients to workers and send the results
    back to clients, if necessary. It's not supposed to be a general message exchanging
    framework. Thanks to this very specific focus, using Gearman is very easy. With
    workers, we don't care who, where, and sometimes not even when the work will be
    done. This is all up to the job server to decide.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: Gearman的设计目的是将客户端的工作委托给工作者，并在必要时将结果发送回客户端。它不是一个通用的消息交换框架。正因为这种非常具体的关注点，使用Gearman非常简单。有了工作者，我们不必关心是谁、在哪里，有时甚至不必关心工作何时完成。这一切都由作业服务器来决定。
- en: In terms of scaling, threads are not a real option here. On the other hand,
    scaling with Gearman is simple. Just add more workers and Gearman will distribute
    the load evenly between them.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 在扩展性方面，线程在这里并不是一个真正的选择。另一方面，使用Gearman进行扩展很简单。只需添加更多的工作者，Gearman就会在它们之间均匀分配负载。
- en: If we wanted to use some more adaptable frameworks, then RabbitMQ or ZMQ would
    be some good options. These are designed to be easily optimizable, for example
    by disabling acknowledge messages or using the publish/subscribe pattern, and
    overall provide more flexibility than Gearman. However, more effort is definitely
    required to implement these properly.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想要使用更灵活的框架，那么RabbitMQ或ZMQ将是不错的选择。这些框架设计得易于优化，例如通过禁用确认消息或使用发布/订阅模式，并且总体上比Gearman提供更多的灵活性。然而，要正确实现这些框架肯定需要更多的努力。
- en: Summary
  id: totrans-214
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: The purpose of this chapter was to use multithreaded and distributed computing
    on a practical example that also involves RxPHP.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的目的是通过一个实际例子来展示多线程和分布式计算，这个例子还涉及到RxPHP。
- en: We used PHP Parser library to make static code analysis of PHP scripts. We wrapped
    the parser with the RxPHP operator and ran it in parallel in multiple threads
    using the pthreads extension and in multiple workers with Gearman.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用了PHP解析器库来对PHP脚本进行静态代码分析。我们用RxPHP操作符包装了解析器，并使用pthreads扩展在多个线程中并行运行，以及使用Gearman在多个工作者中运行。
- en: We also saw how we can make thread pools reusable in RxPHP by wrapping them
    with `ThreadPoolOperator`.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也看到了如何通过使用`ThreadPoolOperator`包装来使RxPHP中的线程池可重用。
- en: The next chapter will cover topics that didn't fit into any of the previous
    ones, and show some interesting and advanced use cases for RxPHP.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 下一章将涵盖那些不适合之前任何一章的主题，并展示一些关于RxPHP的有趣和高级用法案例。
