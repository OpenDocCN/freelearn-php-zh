<html><head></head><body>
		<div id="_idContainer229">
			<h1 id="_idParaDest-241"><em class="italic"><a id="_idTextAnchor243"/>Chapter 14</em>: Data Integration</h1>
			<p>In the previous chapter, you learned about the concept of <strong class="bold">Master Data Management </strong>(<strong class="bold">MDM</strong>), and how to expose Pimcore objects to third-party applications using the <strong class="bold">Datahub</strong> Pimcore bundle. After defining how to install and activate that bundle and how to configure it, you learned how to perform GraphQL queries to retrieve object data and to create, update, or delete objects.</p>
			<p>In this chapter, you will learn how to perform data integration in Pimcore through standard import and export functionalities, when these standards are supposed to be used, and, otherwise, when the implementation of custom solutions is necessary.</p>
			<p>The chapter is organized as follows:</p>
			<ul>
				<li>Importing Data</li>
				<li>Exporting Data</li>
				<li>Limitations of Standard Functionalities</li>
				<li>Implementing Custom Solutions</li>
				<li>Configuring the Data Importer</li>
			</ul>
			<p>We'll start by presenting how to perform simple CSV data importing and exporting using standard solutions. Then, we will explain the limitations you may encounter on using these standard solutions for importing and exporting, and we will explain how to implement a custom data operator that can be used in import configuration. Later in this chapter, we will present how to implement custom solutions for importing and exporting.</p>
			<h1 id="_idParaDest-242"><a id="_idTextAnchor244"/>Technical requirements</h1>
			<p>As you have done in previous chapters, all you need to do is run the demo connected to this chapter by navigating to the <strong class="source-inline">14. Data Integration</strong> folder of the official book repository and start a Docker environment.</p>
			<p>To do so, just follow these instructions:</p>
			<ol>
				<li>Run Docker with the following command:<p class="source-code"><strong class="bold">docker-compose up</strong></p></li>
				<li>Then, to restore all the settings on your local machine, just open a new shell and type the following:<p class="source-code"><strong class="bold">docker-compose exec php bash restore.sh</strong></p></li>
				<li>Navigate to <a href="http://localhost/admin">http://localhost/admin</a> and log in with your admin/pimcore credentials.</li>
			</ol>
			<p>You can access the official book repository to get the source code through the following link:</p>
			<p><a href="https://github.com/PacktPublishing/Modernizing-Enterprise-CMS-using-Pimcore/tree/main/14.%20Data%20Integration">https://github.com/PacktPublishing/Modernizing-Enterprise-CMS-using-Pimcore/tree/main/14.%20Data%20Integration</a></p>
			<p>Now you are ready to navigate the demo to discover all the aspects related to this chapter.</p>
			<h1 id="_idParaDest-243"><a id="_idTextAnchor245"/>Importing Data</h1>
			<p>In this section, you will learn<a id="_idIndexMarker881"/> how to import data through a standard Pimcore CSV import. We will see how to configure the import of a simple CSV file, looking at the details of each step of the configuration<a id="_idIndexMarker882"/>, and how to save this configuration to use it in future imports.</p>
			<p>Although this feature is deprecated in PimcoreX, we must consider that the Pimcore 6 version still has widespread usage, so the explanation of this feature is still quite important. In the <em class="italic">Configuring the Data Importer</em> section of this chapter, we will then explain how to configure the new Pimcore Data Importer.</p>
			<p>To start a new CSV import, just right-click on the folder in which you want to import the objects, select <strong class="bold">CSV Import</strong>, and select the object class of the objects you want to import. This operation will open an <strong class="bold">Upload</strong> dialog, through which you can upload the CSV file<a id="_idIndexMarker883"/> to import.</p>
			<p>Once the file is uploaded, a new <a id="_idIndexMarker884"/>modal will be opened, and you can start to configure the import. In the following sections, we will analyze each step of this configuration.</p>
			<h2 id="_idParaDest-244"><a id="_idTextAnchor246"/>CSV File Preview</h2>
			<p>In the first panel of the imported<a id="_idIndexMarker885"/> configuration<a id="_idIndexMarker886"/>, a preview of the uploaded CSV file is shown. In the following screenshot, you can see how this panel looks:</p>
			<div>
				<div id="_idContainer210" class="IMG---Figure">
					<img src="image/Figure_14.01_B17073.jpg" alt="Figure 14.1: CSV File Preview&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 14.1: CSV File Preview</p>
			<p>As you can see in the previous screenshot, the CSV file rows are rendered as a table. If the checkbox at the top is enabled, the first CSV row is intended to contain the headers.</p>
			<p>In the next section, we will see how to perform column configuration, to associate every CSV column with the corresponding class attribute.</p>
			<h2 id="_idParaDest-245"><a id="_idTextAnchor247"/>Column Configuration</h2>
			<p>In the <strong class="bold">Column Configuration</strong> panel<a id="_idIndexMarker887"/>, we can associate every CSV column to the corresponding class attribute, so that for each CSV import<a id="_idIndexMarker888"/>, we can affect only a subset of the class fields. You can see how this panel looks in the following screenshot:</p>
			<div>
				<div id="_idContainer211" class="IMG---Figure">
					<img src="image/Figure_14.02_B17073.jpg" alt="Figure 14.2: Column Configuration&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 14.2: Column Configuration</p>
			<p>As you can see in the previous screenshot, in this panel there are two distinct areas. In the left region, you will find the class attributes, and you can drag and drop each attribute to the corresponding<a id="_idIndexMarker889"/> CSV columns, which are disposed of in the right region.</p>
			<p>In the left region<a id="_idIndexMarker890"/>, you can also see the <strong class="bold">Operators</strong> section. These operators can be used to change the way the data is processed. Let's describe how each of these operators works:</p>
			<ul>
				<li><strong class="bold">Operator Base64</strong>: This operator performs a Base64 encode or decode on the CSV data.</li>
				<li><strong class="bold">Operator Ignore</strong>: This operator just lets the importer skip the corresponding CSV column.</li>
				<li><strong class="bold">Operator Iterator</strong>: This operator lets you import the same CSV cell to multiple class attributes, by dragging and dropping these attributes as operator children.</li>
				<li><strong class="bold">Operator Locale Switcher</strong>: This operator is useful to select the language for each localized field, allowing the import of text in different languages within the same CSV file.</li>
				<li><strong class="bold">Operator ObjectBrick Setter</strong>: This operator lets you import a specific attribute of an <strong class="bold">ObjectBrick</strong>.</li>
				<li><strong class="bold">Operator PHP Code</strong>: This operator type does not do anything on its own. It requires you to develop a PHP class to manage the CSV data, and pass the class namespace as a parameter of the operator. You will learn how to create a custom PHP operator in the <em class="italic">Creating a Custom Operator</em> section of this chapter.</li>
				<li><strong class="bold">Operator Published</strong>: This operator<a id="_idIndexMarker891"/> just lets you publish or unpublish the imported objects, based on the CSV column value.</li>
				<li><strong class="bold">Operator Splitter</strong>: This operator<a id="_idIndexMarker892"/> can be used to split the value of the CSV column into multiple attributes, given the separator character.</li>
			</ul>
			<p>Now that we have defined how to map each object attribute, in the next section we will show the criteria that permits us to resolve each row, to recognize whether each object already exists.</p>
			<h2 id="_idParaDest-246"><a id="_idTextAnchor248"/>Resolver Settings</h2>
			<p>In the following screenshot<a id="_idIndexMarker893"/>, you can see how the <strong class="bold">Resolver Settings</strong> panel<a id="_idIndexMarker894"/> looks:</p>
			<div>
				<div id="_idContainer212" class="IMG---Figure">
					<img src="image/Figure_14.03_B17073.jpg" alt="Figure 14.3: Resolver Settings&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 14.3: Resolver Settings</p>
			<p>As you can see in the previous screenshot, there is a set of properties<a id="_idIndexMarker895"/> to configure, which we are going to describe here:</p>
			<ul>
				<li><strong class="bold">Skip head row</strong>: Defines whether the first row must be skipped. This must be checked if the first row of the CSV contains column headers.</li>
				<li><strong class="bold">Language</strong>: The language of the import. All the values for localized fields will be imported for the specified language. If you need to import localized values for different languages within<a id="_idIndexMarker896"/> the same CSV import, you must use a <strong class="bold">Locale Switcher</strong> operator.</li>
				<li><strong class="bold">Resolver Strategy</strong>: This property is the one that specifies the strategy rule to recognize whether objects already exist. Based on the selection, different properties must be filled. The following options are choosable:<p>-  <strong class="bold">ID</strong>: Resolves the objects via the object ID. If the object does not exist, an error will be thrown.</p><p>-  <strong class="bold">Filename</strong>: Resolves the objects via the object key within the import folder. If the object does not exist, it will be created.</p><p>-  <strong class="bold">Full Path</strong>: Resolves the objects via the object's full path. </p><p>-  <strong class="bold">Get by Attribute</strong>: Resolves the objects via one of the class attributes. That attribute must be specified as a property if this option is selected.</p><p>-  <strong class="bold">Code</strong>: This option lets you create a custom resolver. This can be done by implementing a PHP class that extends the <strong class="source-inline">Pimcore\DataObject\Import\Resolver\AbstractResolver</strong> class and passes the class namespace as an attribute.</p></li>
				<li><strong class="bold">Column</strong>: This property lets you select the CSV column that contains the value that must be used by the resolver<a id="_idIndexMarker897"/> strategy.</li>
				<li><strong class="bold">Type</strong>: This property lets you define whether the imported rows must be objects or variants. It's possible to force this type, to let the importer keep the current type, or to dynamically<a id="_idIndexMarker898"/> set the type for each row, specifying the <strong class="bold">Type column</strong> property.</li>
				<li><strong class="bold">Create on demand</strong>: If checked, not existing objects will be created.</li>
				<li><strong class="bold">Create parents</strong>: If checked, subfolders on the object path will be created if they don't exist.</li>
				<li><strong class="bold">Skip row if exists</strong>: If checked, the row is skipped if the object already exists.</li>
			</ul>
			<p>Now that we have seen how to set up the resolver strategy, in the next section we will see how to change the CSV settings.</p>
			<h2 id="_idParaDest-247"><a id="_idTextAnchor249"/>CSV Settings</h2>
			<p>Here, you can see how the <strong class="bold">CSV Settings</strong> panel<a id="_idIndexMarker899"/> looks:</p>
			<div>
				<div id="_idContainer213" class="IMG---Figure">
					<img src="image/Figure_14.04_B17073.jpg" alt="Figure 14.4: CSV Settings&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 14.4: CSV Settings</p>
			<p>As you can see in the previous screenshot, in this panel you can change the CSV parsing settings, which include <strong class="bold">Delimiter</strong>, <strong class="bold">Quote Character</strong>, and so on. These settings are automatically detected<a id="_idIndexMarker900"/> during the file upload, but you can change them manually. After having changed these values, you must click on the <strong class="bold">Reload column configuration</strong> button to apply the changes.</p>
			<p>In the next section, we will see how to save and share the defined configuration.</p>
			<h2 id="_idParaDest-248"><a id="_idTextAnchor250"/>Save &amp; Share</h2>
			<p>In the following screenshot, you can see what the <strong class="bold">Save &amp; Share</strong> panel<a id="_idIndexMarker901"/> looks like:</p>
			<div>
				<div id="_idContainer214" class="IMG---Figure">
					<img src="image/Figure_14.05_B17073.jpg" alt="Figure 14.5: Save &amp; Share&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 14.5: Save &amp; Share</p>
			<p>As you can see in the previous screenshot, you can set the configuration name, and click on the <strong class="bold">Save</strong> button to save the configuration in the database. All the saved configurations can be restored by clicking the <strong class="bold">Load</strong> button and selecting the chosen configuration. The import configurations<a id="_idIndexMarker902"/> can be shared globally to all users, or to a restricted set of users and roles.</p>
			<p>Once the configuration<a id="_idIndexMarker903"/> is done, you can run the import by clicking the <strong class="bold">Import</strong> button. In the following screenshot, you can see the <strong class="bold">Import Report</strong> panel:</p>
			<div>
				<div id="_idContainer215" class="IMG---Figure">
					<img src="image/Figure_14.06_B17073.jpg" alt="Figure 14.6: Import Report&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 14.6: Import Report</p>
			<p>As you can see in the previous screenshot, for each row we can see whether the row was imported<a id="_idIndexMarker904"/> successfully and, if not, the error message<a id="_idIndexMarker905"/> for the row. For each imported row, the imported object can be opened.</p>
			<p>To summarize, in this section you learned how to configure and run CSV imports. In the following section, you will learn how to export data in Pimcore.</p>
			<h1 id="_idParaDest-249"><a id="_idTextAnchor251"/>Exporting Data</h1>
			<p>In the previous section, you learned how to configure and run CSV imports. In this section, you will learn how to export data. Similar to what we saw in the previous section on data importing, we can set up and save export configurations. </p>
			<p>The first step to start a data export is to open an object grid by clicking on an object folder. When the grid is opened, the grid<a id="_idIndexMarker906"/> will contain only the class attributes that were marked as <strong class="bold">Visible in Grid View</strong> in the class configuration, as you learned in <a href="B17073_05_ePub_RK.xhtml#_idTextAnchor093"><em class="italic">Chapter 5</em></a>, <em class="italic">Exploring Objects and Classes</em>.</p>
			<p>To add or remove the fields that are shown in the grid, you must click on the <strong class="bold">Grid Options</strong> button to open the configuration modal. You can see how this configuration modal looks in the following screenshot:</p>
			<div>
				<div id="_idContainer216" class="IMG---Figure">
					<img src="image/Figure_14.07_B17073.jpg" alt="Figure 14.7: Grid Options Configuration&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 14.7: Grid Options Configuration</p>
			<p>As you can see in the previous screenshot, the configuration modal structure is quite similar to the one that we saw in the column configuration panel of the import configuration. </p>
			<p>In the left region, you can find the list of the class attributes and some sets of operators to format, render, and transform object data and to extract values from object relations. We can drag and drop class<a id="_idIndexMarker907"/> attributes and the operators in the right region so that these attributes will be shown in the grid.</p>
			<p>In the previous screenshot, you may note that we used <strong class="bold">Operator Any Getter</strong> to extract a specific property from a relation. To do this, we just need to drag and drop the relation attribute as a child of the operator and specify the property that we want to extract for that relation.</p>
			<p>Once the grid configuration is completed<a id="_idIndexMarker908"/>, you can click on the <strong class="bold">Apply</strong> button to confirm the changes, and you can also save the configuration to reuse it in the future by clicking the <strong class="bold">Save Copy &amp; Share</strong> button.</p>
			<p>In the following screenshot, you can see how the object grid looks after the changes:</p>
			<div>
				<div id="_idContainer217" class="IMG---Figure">
					<img src="image/Figure_14.08_B17073.jpg" alt="Figure 14.8: Object Grid&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 14.8: Object Grid</p>
			<p>As you can see in the previous screenshot, in the object grid the previously defined columns are shown. In the screenshot, you can also see that, if we open the <strong class="bold">Grid Options</strong> submenu, we can switch from different configurations, save a copy of the current configuration, set that configuration as favorite, or delete the current configuration.</p>
			<p>The object grid shows all the objects and variants created inside the opened folder and, eventually, in existing subfolders. If you want to limit the objects shown to the first level of the hierarchy, you can enable the <strong class="bold">just direct children</strong> checkbox, as you can see in the following screenshot:</p>
			<div>
				<div id="_idContainer218" class="IMG---Figure">
					<img src="image/Figure_14.09_B17073.jpg" alt="Figure 14.9: Object Grid&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 14.9: Object Grid</p>
			<p>As you can see in the previous screenshot<a id="_idIndexMarker909"/>, only direct children objects are shown. The objects in the grid can be exported both in CSV and in XLSX files. For CSV exports, you will be asked to choose the delimiter character.</p>
			<p>To summarize, in this section you learned how to configure object grids, and how to perform data export. In the following section, you will discover which limitations you may encounter using standard import and export functionalities, and how to create custom operators for importing.</p>
			<h1 id="_idParaDest-250"><a id="_idTextAnchor252"/>Limitations of Standard Functionalities</h1>
			<p>In the previous sections, you learned how to perform data importing and exporting through standard functionalities. As you learned, these functionalities are easy to configure and work well for simple scenarios.</p>
			<p>In this section, you will learn what the main limitations<a id="_idIndexMarker910"/> of these standard functionalities are, and you will learn how to implement a custom PHP operator to be used in CSV importing. Let's start by presenting the limitations of the previously seen export functionality.</p>
			<h2 id="_idParaDest-251"><a id="_idTextAnchor253"/>Limitations of Data Export</h2>
			<p>In the <em class="italic">Exporting data</em> section, you learned how to configure object grids to export object data<a id="_idIndexMarker911"/>. When using these configurations, you may encounter the following limitations:</p>
			<ul>
				<li><strong class="bold">Showing complex field values</strong>: The grid configuration is quite similar for simple textual and numeric fields, but it could be difficult to extract information for structured fields, such as for <strong class="source-inline">Fieldcollections</strong> attributes. The <strong class="source-inline">Fieldcollections</strong> can present a different cardinality for each object class, and it's very difficult to represent these kinds of attributes in a flat structure such as a CSV or an XLSX file.</li>
				<li><strong class="bold">Parent-child relation</strong><strong class="bold"><a id="_idIndexMarker912"/></strong><strong class="bold"> redundancy</strong>: Another limitation given by the file format is the fact that the parent-child relations cannot be explained without avoiding data redundancy because each object variant will be placed in a different row, and in the exported file there will not be any information about the fact that a row represents an object or a variant.</li>
				<li><strong class="bold">Excluding variants</strong>: In the previous section, in terms of data filtering, you learned that you can use the <strong class="bold">just direct children</strong> checkbox to filter objects only and exclude object variants. This works only in the case that all the objects are directly created inside the opened folder, because if objects are created in subfolders, they will be skipped by clicking the checkbox. The only way to filter just for objects is to add a direct SQL condition, as you can see in the following screenshot:</li>
			</ul>
			<div>
				<div id="_idContainer219" class="IMG---Figure">
					<img src="image/Figure_14.10_B17073.jpg" alt="Figure 14.10: Direct SQL query&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 14.10: Direct SQL query</p>
			<p>As you can see in the previous screenshot, clicking on the <strong class="bold">Direct SQL query</strong> icon will open a textual input in which you can write a valid SQL condition. This is quite useful, but it requires knowing the database structure.</p>
			<ul>
				<li><strong class="bold">Server timeout</strong>: Last but not least, there could be a problem related to timings. The export operation is done through an HTML call to a controller, so for<a id="_idIndexMarker913"/> thousands of objects to export, this operation may require a lot of time, and there could be a timeout depending on the server settings.</li>
			</ul>
			<p>Now that you have learned about the limitations of the standard data export, let's see which limitations you may encounter on data import.</p>
			<h2 id="_idParaDest-252"><a id="_idTextAnchor254"/>Limitations of Data Import</h2>
			<p>The main problem with importing CSV files is the standard required format for the <a id="_idIndexMarker914"/>different types of attributes. For example, for the following kinds of fields, we have the following limitations:</p>
			<ul>
				<li><strong class="bold">QuantityValue</strong>: To import the value for this kind of field, you have to put the numeric value in the CSV cell, followed by the unit of measure.</li>
				<li><strong class="bold">Select</strong>: The CSV cell must contain a valid value for the selection and not the option label. This can be a problem in cases in which the created select has numeric IDs or, in general, not mnemonic values.</li>
				<li><strong class="bold">Multiselect</strong>: Different values on multiselect fields must be only separated by the comma character.</li>
				<li><strong class="bold">Relations</strong>: For relation fields, the CSV cell must contain the <strong class="source-inline">object:/</strong> prefix, followed by the full path of the related object.</li>
				<li><strong class="bold">Advanced Relation</strong>: Metadata for advanced relations cannot be imported.</li>
				<li><strong class="bold">Fieldcollection</strong>: Values for Fieldcollection cannot be imported.</li>
				<li><strong class="bold">Media</strong>: Images and videos cannot be attached to objects through a CSV import.</li>
			</ul>
			<p>These limitations make the compilation of CSV files quite complex because it's difficult for non-expert users to create a CSV file that respects all the format rules. These limitations can be circumvented by creating custom PHP operators, as we will see in the following section, but of course, we will lose the advantage of importing data without the need to write any lines of code.</p>
			<p>Another limitation related to CSV files is the format itself. Although the CSV format is a widespread<a id="_idIndexMarker915"/> standard, there could be dated external applications that cannot produce exports in the CSV format. That said, to import any other kind of file, a custom solution must be developed.</p>
			<p>As for what concerns the importation process itself, the whole process cannot be run as a background process. Once the import is started, the import modal cannot be closed until the end of the import process because closing the modal will cause the import to be stopped. For each imported line, the frontend interface is refreshed, and for thousands of rows to be imported, the entire process can last some hours.</p>
			<p>Due to these timings, it is not possible to schedule an automatic importation flow between external software and Pimcore because, as said, the import cannot be run as a background process and requires maintaining an open browser for a lot of hours.</p>
			<p>Now that you have learned about the limitations of a standard data import, let's see how to create a custom PHP operator to be used on CSV imports. The use of these PHP operators can circumvent some of the previously mentioned limitations.</p>
			<h2 id="_idParaDest-253"><a id="_idTextAnchor255"/>Creating a Custom Operator</h2>
			<p>In the previous section, you learned which limitations you may encounter in the standard data import process. One of these limitations is the strict format required for some attribute types. This limitation can be circumvented by creating custom operators to manage CSV cell data.</p>
			<p>In this section, you will learn how to create these custom operators<a id="_idIndexMarker916"/>, and how to use them within CSV imports. In particular, we will see an example operator that will search for the option of a select field by the option label and not by its value. In the following code snippet, you can see how this operator can be created:</p>
			<p class="source-code">&lt;?php</p>
			<p class="source-code">namespace App\Import\Operators;</p>
			<p class="source-code">use Pimcore\DataObject\Import\ColumnConfig\Operator\AbstractOperator;</p>
			<p class="source-code">use Pimcore\Model\DataObject\ClassDefinition;</p>
			<p class="source-code">class SelectOperator extends AbstractOperator{</p>
			<p class="source-code">protected $additionalData;</p>
			<p class="source-code">    public function __construct(\stdClass $config, $context = null){</p>
			<p class="source-code">parent::__construct($config, $context);</p>
			<p class="source-code">        $this-&gt;additionalData = json_decode($config-&gt;additionalData, true);</p>
			<p class="source-code">    }</p>
			<p class="source-code">    public function process($element, &amp;$target, array &amp;$rowData, $colIndex, array &amp;$context = array()) {  </p>
			<p class="source-code">        $value = $rowData[$colIndex];</p>
			<p class="source-code">        $field = $this-&gt;additionalData["field"];</p>
			<p class="source-code">        $target-&gt;set($field, $this-&gt;getValueByDisplayName($target-&gt;getClass(), $field, $value));</p>
			<p class="source-code">    }</p>
			<p class="source-code">    public function getValueByDisplayName(ClassDefinition $class, $field, $displayName){</p>
			<p class="source-code">        $fieldDefinition = $class-&gt;getFieldDefinition($field);</p>
			<p class="source-code">        if(in_array($fieldDefinition-&gt;getFieldtype(), array("select", "multiselect"))){</p>
			<p class="source-code">            $options = $fieldDefinition-&gt;getOptions();</p>
			<p class="source-code">            $option = array_search(strtolower($displayName), array_map('strtolower', array_column($options, "key")));</p>
			<p class="source-code">            return $option !== false ? $options[$option]["value"] : null;</p>
			<p class="source-code">        }</p>
			<p class="source-code">        return null;</p>
			<p class="source-code">    }</p>
			<p class="source-code">}</p>
			<p>As you can see in the previous code snippet, the operator must extend the <strong class="source-inline">AbstractOperator</strong> class. In the class constructor, we can parse the additional data that is defined in the operator configuration, and the implementation of the business logic must be done in the <strong class="source-inline">process</strong> function, which will be automatically called by the import flow.</p>
			<p>In this specific example, we use the <strong class="source-inline">getFieldDefinition</strong> method of the object's class to retrieve the field definition. If the<a id="_idIndexMarker917"/> field is a select or a multiselect attribute, we can use the <strong class="source-inline">getOptions</strong> function to retrieve the select options and search the value that corresponds to the given label.</p>
			<p>Once the operator is created, we must use it on CSV import configurations. To do this, just drag and drop the <strong class="bold">Operator PHP Code</strong> operator in the CSV column to which you want to apply the operator to. In the operator configuration panel, you must put the operator namespace, as you can see in the following screenshot:</p>
			<div>
				<div id="_idContainer220" class="IMG---Figure">
					<img src="image/Figure_14.11_B17073.jpg" alt="Figure 14.11: Operator PHP Code&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 14.11: Operator PHP Code</p>
			<p>As you can see in the previous screenshot, in the operator configuration we must put the PHP class namespace in the <strong class="bold">PHP Class</strong> input. Then, in the <strong class="bold">Additional Data</strong> text area, we can put some data to pass to the operator. In our example, we are passing this additional information as JSON<a id="_idIndexMarker918"/>, which will be parsed by the operator.</p>
			<p>To summarize, in this section you learned about which limitations you may encounter on performing standard import and export processes. Then, you learned how to create custom PHP operators that can be used on the CSV import processes. In the following section, you will learn how to implement custom solutions for importing and exporting.</p>
			<h1 id="_idParaDest-254"><a id="_idTextAnchor256"/>Implementing Custom Solutions</h1>
			<p>In the previous section, you learned <a id="_idIndexMarker919"/>about the limitations of standard import and export functionalities. Then, you learned how to create a custom operator to be used on CSV import processes.</p>
			<p>In this section, you will learn how to implement custom solutions<a id="_idIndexMarker920"/> for importing and exporting. In particular, you will learn how to add additional buttons to the object and folder editor in the Pimcore backend interface, which will call custom controllers on clicking, and how to create commands that could be scheduled and run as a background process.</p>
			<h2 id="_idParaDest-255"><a id="_idTextAnchor257"/>Adding custom buttons</h2>
			<p>In this section, you will learn how to add custom buttons<a id="_idIndexMarker921"/> to the Pimcore<a id="_idIndexMarker922"/> backend interface, and how to let these buttons call for custom controllers to perform imports and exports.</p>
			<p>To add these buttons, we need to implement the <strong class="source-inline">postOpenObject</strong> function inside the <strong class="source-inline">Resources/js/Pimcore/startup.js</strong> file of a previously created Pimcore bundle. In the following code snippet, you can see an example of how to create two buttons to upload and download files:</p>
			<p class="source-code">postOpenObject: function (object, type) {</p>
			<p class="source-code">    if (object.data.general.o_type === 'folder') {</p>
			<p class="source-code">object.toolbar.add({</p>
			<p class="source-code">            text: t('Export'),</p>
			<p class="source-code">iconCls: 'pimcore_icon_download',</p>
			<p class="source-code">            scale: 'medium',</p>
			<p class="source-code">            handler: function (obj) {</p>
			<p class="source-code">pimcore.helpers.download("/admin/export-objects?folderId=" + object.id);</p>
			<p class="source-code">}.bind(this, object)</p>
			<p class="source-code">        });</p>
			<p class="source-code">object.toolbar.add({</p>
			<p class="source-code">            text: t('Import'),</p>
			<p class="source-code">iconCls: 'pimcore_icon_upload',</p>
			<p class="source-code">            scale: 'medium',</p>
			<p class="source-code">            handler: function (obj) {</p>
			<p class="source-code">pimcore.helpers.uploadDialog("/admin/import-objects?folderId=" + object.id, "Filedata", function (response) {</p>
			<p class="source-code">pimcore.layout.refresh();</p>
			<p class="source-code">object.reload();</p>
			<p class="source-code">}.bind(this), function () {</p>
			<p class="source-code">Ext.MessageBox.alert(t("error"), t("error"));</p>
			<p class="source-code">                });</p>
			<p class="source-code">}.bind(this, object)</p>
			<p class="source-code">        });</p>
			<p class="source-code">pimcore.layout.refresh();</p>
			<p class="source-code">    }</p>
			<p class="source-code">}</p>
			<p>As you can see in the previous code snippet, we first check whether the opened object is a folder, to add two different buttons<a id="_idIndexMarker923"/> in the folder editor toolbar<a id="_idIndexMarker924"/>. For each button, the <strong class="source-inline">handler</strong> function is the one that is called when the object is clicked.</p>
			<p>In the first button, we are using the <strong class="source-inline">pimcore.helpers.download</strong> function to let the browser download the file returned in the response. In the second button, the use of <strong class="source-inline">pimcore.helpers.uploadDialog</strong> will render an upload modal; the uploaded file will be passed to the controller.</p>
			<p>Let's now have a look at how to implement the controller actions<a id="_idIndexMarker925"/> that will be called by the created buttons. In the following code snippet, you can see an example<a id="_idIndexMarker926"/> of controller implementation:</p>
			<p class="source-code">&lt;?php</p>
			<p class="source-code">namespace App\Controller;</p>
			<p class="source-code">use Pimcore\Bundle\AdminBundle\Controller;</p>
			<p class="source-code">use Symfony\Component\Routing\Annotation\Route;</p>
			<p class="source-code">use Symfony\Component\HttpFoundation\Request;</p>
			<p class="source-code">use Symfony\Component\HttpFoundation\Response;</p>
			<p class="source-code">use Symfony\Component\HttpFoundation\ResponseHeaderBag;</p>
			<p class="source-code">/** @Route("/admin") */</p>
			<p class="source-code">class AdminController extends Controller\AdminController {</p>
			<p class="source-code">    /** @Route("/export-objects") */</p>
			<p class="source-code">    public function exportObjectsAction(Request $request) {</p>
			<p class="source-code">        $folderId = $request-&gt;get("folderId");</p>
			<p class="source-code">        //Add business logic here</p>
			<p class="source-code">        $response = new Response();</p>
			<p class="source-code">        $response-&gt;setContent($jsonResponse);</p>
			<p class="source-code">        $disposition = $response-&gt;headers-&gt;makeDisposition(</p>
			<p class="source-code">ResponseHeaderBag::DISPOSITION_ATTACHMENT,</p>
			<p class="source-code">            "export_".date("YmdHis").".json";</p>
			<p class="source-code">        );</p>
			<p class="source-code">        $response-&gt;headers-&gt;set('Content-Type', 'application/json');</p>
			<p class="source-code">        $response-&gt;headers-&gt;set('Content-Disposition', $disposition);</p>
			<p class="source-code">        return $response;</p>
			<p class="source-code">    }</p>
			<p class="source-code">    /** @Route("/import-objects", methods={"POST"}) */</p>
			<p class="source-code">    public function importObjectsAction(Request $request) {</p>
			<p class="source-code">        $folderId = $request-&gt;get("folderId");</p>
			<p class="source-code">        $tmpName = $_FILES['Filedata']['tmp_name'];</p>
			<p class="source-code">        $fileContent = file_get_contents($tmpName);</p>
			<p class="source-code">        //Add business logic here</p>
			<p class="source-code">        $response = $this-&gt;adminJson(['success' =&gt; true]);</p>
			<p class="source-code">        $response-&gt;headers-&gt;set('Content-Type', 'text/html');</p>
			<p class="source-code">        return $response;</p>
			<p class="source-code">    }</p>
			<p class="source-code">} </p>
			<p>As you can see in the previous code snippet, a specific function is created for each controller action. The HTTP request<a id="_idIndexMarker927"/> object is passed as an input argument for each action, and the request attribute values can be accessed by the <strong class="source-inline">get</strong> function.</p>
			<p>On the <strong class="source-inline">exportObjectsAction</strong> function, we have configured the response to accept the download of a JSON file<a id="_idIndexMarker928"/> by setting the response header properly. The chosen file format is just an example and can be changed to the required one. On the <strong class="source-inline">importObjectsAction</strong> function, we read the uploaded file content from the <strong class="source-inline">$_FILES</strong> global variable, so that depending on the business logic, we can import the objects.</p>
			<p>To summarize, in this section you learned how to add custom buttons to the Pimcore backend interface, and how to specifically realize controllers to import and export files. In the following section, you will learn how to create a command that can be invoked by the Pimcore console and that, eventually, can be scheduled to be executed as a background process.</p>
			<h2 id="_idParaDest-256"><a id="_idTextAnchor258"/>Creating Pimcore Commands</h2>
			<p>In the previous section, you learned how to create custom controllers to perform imports and exports of any kind of file, by creating additional buttons to place in the Pimcore backend<a id="_idIndexMarker929"/> interface. In this section, you will learn how to create commands that can be invoked by the Pimcore console.</p>
			<p>To create a new command<a id="_idIndexMarker930"/>, you just need to create a class that extends the <strong class="source-inline">Pimcore\Console\AbstractCommand</strong> class, as you can see in the following code snippet:</p>
			<p class="source-code">&lt;?php</p>
			<p class="source-code">namespace App\Command;</p>
			<p class="source-code">use Pimcore\Console\AbstractCommand;</p>
			<p class="source-code">use Pimcore\Console\Dumper;</p>
			<p class="source-code">use Symfony\Component\Console\Input\InputInterface;</p>
			<p class="source-code">use Symfony\Component\Console\Input\InputOption;</p>
			<p class="source-code">use Symfony\Component\Console\Output\OutputInterface;</p>
			<p class="source-code">class ImportCommand extends AbstractCommand</p>
			<p class="source-code">{</p>
			<p class="source-code">    const IMPORT_FOLDER = PIMCORE_PROJECT_ROOT."/var/imports";</p>
			<p class="source-code">    protected function configure() {</p>
			<p class="source-code">        $this-&gt;setName('import-file')</p>
			<p class="source-code">            -&gt;setDescription('Import a file in background');</p>
			<p class="source-code">        $this-&gt;addOption("filename", null, InputOption::VALUE_REQUIRED, "The name of the file to import");</p>
			<p class="source-code">    }</p>
			<p class="source-code">    protected function execute(InputInterface $input, OutputInterface $output) {</p>
			<p class="source-code">        $this-&gt;dump("The execution is starting!",  Dumper::NEWLINE_AFTER);</p>
			<p class="source-code">        $filename = $input-&gt;getOption("filename");</p>
			<p class="source-code">        $fileContent = file_get_contents(self::IMPORT_FOLDER."/".$filename);</p>
			<p class="source-code">        //Add business logic here</p>
			<p class="source-code">        $this-&gt;writeError('Please implement this command with business logic...');</p>
			<p class="source-code">    }</p>
			<p class="source-code">}</p>
			<p>As you can see in the previous code snippet, in the command configuration you can specify a name and a description for the command, and a list of optional or required arguments and options<a id="_idIndexMarker931"/> for the command. </p>
			<p>The business logic for the command<a id="_idIndexMarker932"/> must be implemented in the <strong class="source-inline">execute</strong> function. We can use command native functions such as <strong class="source-inline">dump</strong> and <strong class="source-inline">writeError</strong> to print messages in the console.</p>
			<p>Once the command is developed, it must be declared as a service, as is shown in the following code snippet:</p>
			<p class="source-code">services:</p>
			<p class="source-code">App\Command\ImportCommand:</p>
			<p class="source-code">        tags:</p>
			<p class="source-code">            - { name: 'console.command', command: 'import-file' }</p>
			<p>You may note that, in the previous code snippet, the <strong class="source-inline">command</strong> tag reports the name of the created command. To invoke the command, you just need to run the following instruction:</p>
			<p class="source-code">php bin/console import-file --filename=my-import-file.csv</p>
			<p>When running the command, the filename must be specified as an attribute. You can see the command result in the following screenshot:</p>
			<div>
				<div id="_idContainer221" class="IMG---Figure">
					<img src="image/Figure_14.12_B17073.jpg" alt="Figure 14.12: Command execution&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 14.12: Command execution</p>
			<p>As you can see in the previous screenshot, messages and errors are dumped in the console.</p>
			<p>To summarize, in the first part of this section<a id="_idIndexMarker933"/> you learned how to add custom buttons<a id="_idIndexMarker934"/> to the Pimcore backend interface, and how to let these buttons call for controller actions to upload and download files. Then, you learned how to create and run Pimcore commands through the Pimcore console.</p>
			<p>In the next section, you will learn how to configure the new Pimcore Data Importer, which will let you import data from different sources and schedule imports in the background.</p>
			<h1 id="_idParaDest-257"><a id="_idTextAnchor259"/>Configuring the Data Importer</h1>
			<p>In the previous section, you learned how to implement custom solutions, and in particular, how to add custom buttons to the object interface and how to create executable commands.</p>
			<p>In this section, you will learn how to install<a id="_idIndexMarker935"/> and configure the new Pimcore Data Importer, which in the PimcoreX version will replace the standard CSV import that we described in the <em class="italic">Importing Data</em> section.</p>
			<p>The Data Importer plugin is an extension of the Datahub bundle, which we described in <a href="B17073_13_ePub_RK.xhtml#_idTextAnchor228"><em class="italic">Chapter 13</em></a>, <em class="italic">Implementing Master Data Management</em>. To install Data Importer, you just need to run the following script:</p>
			<p class="source-code">docker-compose exec php bash</p>
			<p class="source-code">composer require pimcore/data-importer</p>
			<p class="source-code">./bin/console pimcore:bundle:enable PimcoreDataImporterBundle</p>
			<p>As you can see in the preceding script, the Data Importer can be downloaded through Composer and can be enabled like every other Pimcore bundle, with the <strong class="source-inline">pimcore:bundle:enable</strong> command.</p>
			<p>Once you have enabled the bundle, you can open the <strong class="bold">Datahub</strong> configuration panel by accessing the <strong class="bold">Settings </strong>|<strong class="bold"> Datahub Config</strong> option in the Pimcore menu. To create a new import configuration<a id="_idIndexMarker936"/>, you just need to click on the <strong class="bold">Add Configuration</strong> button, as you can see in the following screenshot:</p>
			<div>
				<div id="_idContainer222" class="IMG---Figure">
					<img src="image/Figure_14.13_B17073.jpg" alt="Figure 14.13: Add import configuration&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 14.13: Add import configuration</p>
			<p>As you can see in the previous screenshot, in addition to the GraphQL configuration, you can select the <strong class="bold">Data Objects Importer</strong> option and fill in the configuration name.</p>
			<p>To configure and run the import, you must follow these steps:</p>
			<ol>
				<li value="1">In the <strong class="bold">General</strong> tab, enable the <strong class="bold">Active</strong> checkbox and add an optional description, as you can see in the following screenshot:<div id="_idContainer223" class="IMG---Figure"><img src="image/Figure_14.14_B17073.jpg" alt="Figure 14.14: General settings&#13;&#10;"/></div><p class="figure-caption">Figure 14.14: General settings</p><p>As you can see in the previous screenshot, the defined configuration name is shown in the settings.</p></li>
				<li>In the <strong class="bold">Data Source</strong> tab, define the kind of import<a id="_idIndexMarker937"/> that you want to perform. In the following screenshot, you will see an example of data source configuration:<div id="_idContainer224" class="IMG---Figure"><img src="image/Figure_14.15_B17073.jpg" alt="Figure 14.15: Data source configuration&#13;&#10;"/></div><p class="figure-caption">Figure 14.15: Data source configuration</p><p>As you can see in the previous screenshot, you can select different source types:</p><ul><li><strong class="bold">SFTP</strong>: If this option is selected, you must fill in the SFTP connection credentials such as <strong class="bold">Host</strong>, <strong class="bold">Port</strong>, <strong class="bold">Username</strong>, and <strong class="bold">Password</strong>, and the remote file location inside the SFTP server.</li><li><strong class="bold">HTTP</strong>: This option lets you define an HTTP or HTTPS URL that points to the remote file.</li><li><strong class="bold">Asset</strong>: With this option, you can select the file to import from the previously uploaded Pimcore assets.</li><li><strong class="bold">Upload</strong>: If this option is selected, you must upload a file from your local sources.</li><li><strong class="bold">Push</strong>: This option lets you define an API key and generate a URL that an external application can invoke to pass the file to import with a <strong class="source-inline">POST</strong> call to the generated URL.<p>Once you have defined the data source<a id="_idIndexMarker938"/>, you can specify the file format, choosing from CSV, JSON, XLSX, and XML, and fill in the specific configurations.</p></li></ul></li>
				<li>In the <strong class="bold">Import Settings</strong> panel, configure the resolver and the mapping for each field in the uploaded file. In the following screenshot, you will see how to configure the resolver:<div id="_idContainer225" class="IMG---Figure"><img src="image/Figure_14.16_B17073.jpg" alt="Figure 14.16: Import Resolver&#13;&#10;"/></div><p class="figure-caption">Figure 14.16: Import Resolver</p><p>As you can see in the previous screenshot, you can define the class involved in the import and the loading strategy, choosing from <strong class="bold">Path</strong>, <strong class="bold">Id</strong>, <strong class="bold">Attribute</strong>, or <strong class="bold">No Loading</strong>. This last option will let the importer always create new objects, without looking at these objects' existence. Then, you can choose where created and updated objects must be located<a id="_idIndexMarker939"/>, by defining an existing folder path, and how the published status must be affected.</p><p>In the <strong class="bold">Processing Settings</strong> tab, you can define whether the configured import can be run multiple times in parallel or whether every importation run must be sequential.</p></li>
				<li>In the <strong class="bold">Mappings</strong> tab, define a mapping for each attribute of the uploaded file that you want to import. In the following screenshot<a id="_idIndexMarker940"/>, you will see how to add a new mapping and how to map a simple text field:<div id="_idContainer226" class="IMG---Figure"><img src="image/Figure_14.17_B17073.jpg" alt="Figure 14.17: Import Mappings&#13;&#10;"/></div><p class="figure-caption">Figure 14.17: Import Mappings</p><p>As you can see in the previous screenshot, you can add a new field mapping by clicking on the <strong class="bold">Add</strong> button. To map a simple text field, you just need to select the correct field from the auto-detected source attributes and select the corresponding class field in the <strong class="bold">Field Name</strong> picklist.</p><p>For different kinds of fields, you may need to add one or more transformations using the <strong class="bold">Transformation Pipeline</strong>. You can see an example in the following screenshot:</p><div id="_idContainer227" class="IMG---Figure"><img src="image/Figure_14.18_B17073.jpg" alt="Figure 14.18: Import Mappings&#13;&#10;"/></div><p class="figure-caption">Figure 14.18: Import Mappings</p><p>As you can see in the previous screenshot, for <strong class="bold">QuantityValue</strong> attributes we can add a specific transformation. This requires selecting two source attributes, one containing the value and one containing the unit of measure.</p><p>These pipelines can be used to import dates<a id="_idIndexMarker941"/> and numeric fields, or mode complex fields such as, for example, images and other kinds of assets, or the relation with other objects.</p><p>In the left panel, you can see that the already defined fields are highlighted.</p></li>
				<li>In the <strong class="bold">Execution</strong> panel, run the import that you have configured. You can manually run the import by clicking on the <strong class="bold">Start</strong> button, as you can see in the following screenshot:<div id="_idContainer228" class="IMG---Figure"><img src="image/Figure_14.19_B17073.jpg" alt="Figure 14.19: Import Execution&#13;&#10;"/></div><p class="figure-caption">Figure 14.19: Import Execution</p><p>As you can see in the previous screenshot, the import status is shown in the progress bar, and you can stop the import at any time.</p><p>If you want to schedule the import to be run in the background, you just need to fill in the <strong class="bold">Cron Definition</strong> rule. </p></li>
				<li>To enable the <strong class="source-inline">cron</strong> execution<a id="_idIndexMarker942"/>, you just need to schedule the execution command as shown in the following script:<p class="source-code"><strong class="bold">* * * * * php /home/project/www/bin/console datahub:data-importer:execute-cron</strong></p><p>Scheduling the <strong class="source-inline">cron</strong> execution, as shown previously, will let Pimcore check which import configurations must be run every minute. These configurations <a id="_idTextAnchor260"/>will be run according to the <strong class="source-inline">cron</strong> definition of every single configuration.</p></li>
			</ol>
			<p>To summarize, in this section you learned how to install and enable the Data Importer plugin. Through a step-by-step configuration, you learned how to create and execute an import configuration.</p>
			<h1 id="_idParaDest-258"><a id="_idTextAnchor261"/>Summary</h1>
			<p>In this chapter, you learned how to import and export data using the standard Pimcore functionalities, which let you import and export CSV files after having defined the respective import and export configurations.</p>
			<p>After having described how to properly set up these configurations, you learned which limitations you might encounter when performing these standard functionalities, and how to implement a custom operator to be used in the CSV import process.</p>
			<p>Later in this chapter, you learned how to implement custom solutions for importing and exporting. In particular, you learned how to add custom buttons to the Pimcore backend interface, which lets you upload and download files, and how to create commands that can be invoked by the Pimcore console and, eventually, scheduled as background processes.</p>
			<p>In the last section, you finally learned how to enable the Data Importer plugin to create import configurations from different kinds of sources, which you can execute manually or schedule to be executed in the background.</p>
			<p>As this is the last chapter, let's try to summarize the whole book's content. In the first part of the book, we talked about the Pimcore basics, introducing Pimcore and its features, showing how to set up a development environment, how to move inside the Pimcore menus and functionalities, and how to administrate Pimcore sites.</p>
			<p>In the second part, you learned how to implement a blog, step by step, using the Pimcore CMS engine, starting by learning how to create custom CMS pages and how to render data for the blog, and then how to create reusable components and how to finalize the website.</p>
			<p>In the last chapters, we described how to use Pimcore for enterprise solutions, with a focus on the PIM and MDM Pimcore features and the data integration processes, providing concrete examples of how to connect Pimcore to external systems.</p>
			<p>Now that you have reached the end of this book, we hope it has been an inspiring read, and that this book will be a useful guide for you to develop your projects with Pimcore.</p>
		</div>
	</body></html>