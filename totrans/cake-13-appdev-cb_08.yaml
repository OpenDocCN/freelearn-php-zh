- en: Chapter 8. Working with Shells
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover:'
  prefs: []
  type: TYPE_NORMAL
- en: Building and running a shell
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Parsing command line parameters
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating reusable shell tasks
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Sending e-mails from shells
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating Non-interactive tasks with the robot plugin
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One of the most powerful, yet unknown, features of CakePHP is its shell framework.
    It provides applications with all that is required for building command-line tools,
    which can be used to perform intensive tasks and any other type of non-interactive
    processing.
  prefs: []
  type: TYPE_NORMAL
- en: This chapter introduces the reader to CakePHP shells by starting with the process
    of building basic shells, and then moving on to more advanced features, such as
    sending e-mails and running controller actions from shells. It finishes by presenting
    the robot plugin, which offers a fully featured solution for scheduling and running
    tasks.
  prefs: []
  type: TYPE_NORMAL
- en: Building and running a shell
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we will learn how to build and run a custom shell, which will
    ask for a username and a password, and add the given account to a list of user
    accounts. Based on the system created in the recipe *Setting up a basic authentication
    system* from [Chapter 1](ch01.html "Chapter 1. Authentication"), *Authentication*,
    this shell is a great help when looking to create test accounts.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To go through this recipe we need an authentication system. Follow the entire
    recipe *Setting up a basic authentication system* from *Authentication* chapter.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Create a file named `user.php` and place it in your `app/vendors/shells` folder,
    with the following contents:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'We are now ready to run our shell. Open a terminal window, and access the directory
    where your application resides. Inside this directory you should have your `app/`
    and `cake/` folders. For example, if your application is installed in `/var/www/myapp`,
    then `/var/www/myapp/app` should be your `app/` folder, and `/var/www/myapp/cake`
    your `cake/` folder. While standing in your application''s main directory (`/var/www/myapp`
    in this example), run:'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: To learn more about setting the right path when running shells, or how to add
    the cake shell script to your PATH environment variable see [http://book.cakephp.org/view/1106/The-CakePHP-Console](http://book.cakephp.org/view/1106/The-CakePHP-Console)
  prefs: []
  type: TYPE_NORMAL
- en: 'If you are on a GNU Linux / Mac / Unix system:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'If you are on Microsoft Windows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'If you receive an error message such as **Error: Class UserShell could not
    be loaded**, this means that CakePHP is unable to find your `app/` folder, which
    is probably because you have a different name for the `app/` folder. In this case,
    you can specify the folder with the `app` argument, like so: `$ cake/console/cake
    -app /var/www/myapp/app user`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Once the shell is run, it will ask us for the desired username and password,
    and will wait for a final confirmation before creating the account, as shown in
    the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How to do it...](img/1926_8_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: We are now able to use this account when logging in through our application's
    login page.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We started by importing the `Security` class, which is used for hashing the
    password prior to saving the user record. We then created a class named `UserShell`,
    extending it from CakePHP's `Shell` class, which offers us a set of methods and
    properties that are helpful when building shells. One of such properties is `uses`,
    which works the same way as a controller's `uses` property—by defining a list
    of application models that should be instantiated and ready to use from any method
    in the shell.
  prefs: []
  type: TYPE_NORMAL
- en: Our shell's entry point is the `main()` method. This comes as no surprise if
    you have any experience developing C, C++, or Java applications, as `main()` is
    also their entry function. If you have no such experience, then all there is to
    know is that `main()` will be automatically executed by CakePHP when our shell
    is invoked through the command line.
  prefs: []
  type: TYPE_NORMAL
- en: 'Our `main()` method starts by asking the user for their desired username. To
    ask for user input, we use the `in()` method (available through the `Shell` parent
    class), which takes up to three arguments:'
  prefs: []
  type: TYPE_NORMAL
- en: '`prompt`: The message that is shown to the user before asking for their input.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`options`: An optional set of values that the user should be restricted to
    when entering their input.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`default`: An optional default value that is to be used if the user enters
    no input by clicking *Enter* at the prompt.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If the user does not specify a user name, we exit the application by calling
    the `_stop()` method, available to all CakePHP classes that descend from `Object,
    Shell` being one of them.
  prefs: []
  type: TYPE_NORMAL
- en: Once we have our username, we need to ask for a password. As a useful alternative,
    we want to offer the user an automatically generated password. To generate this
    password, we implement a method called, not surprisingly, `_randomPassword().`
  prefs: []
  type: TYPE_NORMAL
- en: 'This method takes one argument, the size of the generated password, and builds
    it by randomly selecting an element from a defined set of characters. This set
    is constructed by including all characters between the letters `A` and `Z, a`
    and `Z`, and `0` and `9`. For more secure passwords, we also included the symbols
    `@ ! # $` and `_` as valid characters.'
  prefs: []
  type: TYPE_NORMAL
- en: When we use the `in()` method to ask the user for a password, we use this default
    generated password as its third argument (`default.`) After asking for the password,
    we show the user the choice for username and password, and ask for confirmation,
    utilizing the `options` argument in our call to `in()`.
  prefs: []
  type: TYPE_NORMAL
- en: 'If the user confirms the operation, we proceed to create the user record, hashing
    the entered password with the `Security::hash()` method, which takes up to three
    arguments:'
  prefs: []
  type: TYPE_NORMAL
- en: '`string`: The string to be hashed.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`method`: The method to use for hashing, which can be any of: `sha1, sha256,
    md5`, or any other method supported by the `hash()` PHP function. Defaults to
    the following PHP functions, depending on their availability: `sha1()` (also used
    if `sha1` is the chosen method), `mhash()` (also used if `sha256` is the chosen
    method), `hash()`, and finally `md5()`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`salt`: If `true`, prefixes the string with the application''s salt (available
    in the `Configure` setting `Security.salt`). If a string is specified, it is prefixed
    to the password being hashed in place of the application''s `Security.salt` setting.
    If `false`, hashes the given string without a prefix.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If a record is created, we inform the user that the operation succeeded. Otherwise
    we use the `error()` method (available through the `Shell` parent class) which
    sends an error message through the standard error stream and exits the application.
  prefs: []
  type: TYPE_NORMAL
- en: Using the Auth component for hashing passwords
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this recipe, we called the `Security::hash()` method to hash passwords, by
    specifying the same exact arguments that are utilized in the `Auth` component.
    If we did not do so, we would have different hash values for the same passwords,
    which would render our shell useless, as any user account created with it wouldn't
    be able to log in.
  prefs: []
  type: TYPE_NORMAL
- en: 'The problem with this approach is that if the method that is used by the `Auth`
    component to hash passwords is changed, we would need to reflect such changes
    in our shell. Therefore, we may want to use the `Auth` component to do the hashing
    instead. This solution requires a bit of extra effort, as components are not natively
    available in a shell. Edit your `app/vendors/shells/user.php` file and remove
    the import of the `Security` class, and then add the following import statement
    at the beginning of the file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'We now need to instantiate the `AuthComponent` class. Add the following code
    to the beginning of the `main()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally change the definition of the data that is used for creating the `User`
    record, so its `password` field is hashed using the `Auth` component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*Parsing command line parameters*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Parsing command line parameters
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The recipe *Building and running a shell* showed us how to create a shell that
    adds records based on user-provided information. This recipe adds support to import
    accounts from a CSV file, while allowing the user to configure different settings
    through the use of command-line parameters.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To go through this recipe we need the user shell implemented. Follow the entire
    recipe *Building and running a shell*.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will also need a sample CSV file from which to import records. Create a
    file named `users.csv` and place it in a directory of your choice (for example,
    in the application''s `app/tmp` directory) with the following contents:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Edit your `app/vendors/shells/user.php` file, and change the name of the method
    `main()` to `add()`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the following method right below the `add()` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now add the following method above the `_randomPassword()` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Finally, add the following below the `help()` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'If we run the shell without arguments, CakePHP will say that there is no known
    command, and suggest that we get help by specifying `help` as an argument to our
    shell. Doing so will display our help message, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How to do it...](img/1926_8_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: If we run our shell with the `add` argument, we will see exactly the same functionality
    implemented in the recipe *Building and running a shell*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Executing the shell with the `import` argument and the `verbose` parameter,
    and specifying the path to our CSV file with a command such as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'would import the users listed in the CSV file, generating an output similar
    to what is shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How to do it...](img/1926_8_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We started by changing the name of the entry method to `add()`. Doing so means
    we no longer have an entry method, so how does CakePHP find what to run when our
    shell is invoked? Through the use of commands.
  prefs: []
  type: TYPE_NORMAL
- en: If there is no entry method defined in a shell, CakePHP will assume that the
    first argument used when executing a shell is a command. A command is nothing
    more than a public method that does not start with an underscore sign. As such,
    a method named `add()` is executed when the shell is invoked with the `add` argument.
    If no argument is specified, CakePHP complains, as there is no command to run,
    and suggests the user use the `help` argument, which is nothing more than a way
    to call the `help()` method in our shell (as `help` is a regular command).
  prefs: []
  type: TYPE_NORMAL
- en: 'We use the `help()` method to show usage instructions for our shell, listing
    the available commands (add, and `import)`, and the parameters for each of those
    commands. While the `add` command has no available parameters, we support the
    following parameters for our `import` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Setting | Purpose |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `limit` | A maximum number of records to process from the CSV file. If omitted,
    all records will be processed. |'
  prefs: []
  type: TYPE_TB
- en: '| `size` | The maximum length for the generated passwords. Defaults to `10`.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `verbose` | If specified, the shell will output information as its creating
    the user records. |'
  prefs: []
  type: TYPE_TB
- en: The `_parseCSV()` method is our helper method to parse a CSV file, returning
    an array of rows found in a file, where each row is itself an array of values.
    This method uses PHP's `fgetcsv()` function to parse a record from a file handle,
    obtained with the use of PHP's `fopen()` function, and closed with `fclose()`
    once the parsing is finished.
  prefs: []
  type: TYPE_NORMAL
- en: We continue by implementing the `import()` method, the body of our `import`
    command. This method uses the `_checkArgs()` method (available through the `Shell`
    class) to make sure that the command receives at least the specified number of
    arguments, in our case `1`. If the method finds that the user did not specify
    the minimum number of arguments, it will throw an error message and abort the
    execution. This is a way for us to make sure that at least the path to the CSV
    file is provided.
  prefs: []
  type: TYPE_NORMAL
- en: 'If the number of arguments is correct we proceed to process the optional parameters.
    To do so, we use the `params` property. This property is available to all shells,
    and includes the following values even when no parameters are provided:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Setting | Purpose |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `app` | The name of the `app/` directory. |'
  prefs: []
  type: TYPE_TB
- en: '| `root` | The full path to our application''s root directory, which would
    contain the `app/` and `cake/` directories. |'
  prefs: []
  type: TYPE_TB
- en: '| `webroot` | The name of the `webroot/` directory, which is inside the `app/`
    directory. |'
  prefs: []
  type: TYPE_TB
- en: '| `working` | The full path to the `app/` directory. |'
  prefs: []
  type: TYPE_TB
- en: However, we are only interested in the parameters given by the user through
    the command line. Therefore, we define the set of valid parameters with their
    default values, and we merge the values for those parameters that are available
    in the `params` property. We store this merged values in an array named `options`.
  prefs: []
  type: TYPE_NORMAL
- en: Using the `is_file()` and `is_readable()` PHP functions, we make sure we were
    given a valid file. If not, we use the `error()` method to print out an error
    message and abort the application.
  prefs: []
  type: TYPE_NORMAL
- en: We then proceed to use `_importCSV()` to get a list of parsed rows, and for
    each of those rows we assign a random password, using the `size` option. We stop
    generating passwords once we reach the value of the `limit` option, if one is
    provided. By the end of this loop, we will have an array named `users` where its
    index is a username, and its value is the password for the given user.
  prefs: []
  type: TYPE_NORMAL
- en: For each of the values in the `users` array, we create the account record similar
    to the way we do it in the `add` command, while outputting the status of each
    creation if the `verbose` option is set. If we get an error while creating a specific
    record, we remove the problematic user from the `users` array.
  prefs: []
  type: TYPE_NORMAL
- en: Once the creation process is finalized, we output the list of successfully created
    usernames, together with their generated passwords.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*Parsing CSV files with a datasource* in [Chapter 5](ch05.html "Chapter 5. Datasources"),
    *Datasources*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Creating reusable shell tasks*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating reusable shell tasks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Just as we have components to share functionality amongst controllers, we also
    have behaviors for models, and helpers for views. What about shells? CakePHP offers
    the concept of tasks, which are classes that also extend from the `Shell` class,
    but can be reused from other shells.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we will learn how to build a task that handles argument and
    parameter processing for our shell, can auto-generate help messages, and check
    the definition of mandatory arguments and optional parameters. We will implement
    this task in the most generic fashion, so we can use it for any future shells
    we may decide to build.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To go through this recipe we need a shell that accepts parameters and has different
    commands available. Follow the entire recipe *Parsing command line parameters*.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Edit your `app/vendors/shells/user.php` file and add the following right below
    the declaration of the `uses` property:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'While still editing the shell, remove the `help()` method, and remove the following
    lines from the beginning of the `import()` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add the following lines at the beginning of the `import()` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create a file named `help.php` and place it in your `app/vendors/shells/tasks`,
    with the following contents:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add the following methods to the created `HelpTask` class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'While still editing the `HelpTask` class, add the following helper methods
    to the class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'If you now run the shell without any parameters, with a command such as the
    following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'we would get the thorough help message shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How to do it...](img/1926_8_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'We can also obtain detailed help for a specific command. Running the shell
    with a command such as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'would show us the help message for the `import` command, as shown in the following
    screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How to do it...](img/1926_8_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Running the shell with the same parameters as the ones used in the recipe *Parsing
    command line parameters* to import CSV files should work as expected.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When a shell includes the property `tasks` in its declaration, it is said to
    use the specified tasks. Tasks are stored in the `app/vendors/shells/tasks` folder,
    and are accessible in the shell as instances. In our case, we add a task named
    `Help`, which should be implemented in a class named `HelpTask` and placed in
    a file named `help.php` in the `tasks` folder, and we refer to it as `$this->Help`
    from within the shell.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before proceeding, a point has to be made regarding the naming of this particular
    task. As we want our task to automatically generate help messages for our shell,
    we somehow need to catch the call to the `help()` command. This is only achievable
    if we first understand how the shell dispatching process works. Let us assume
    the following invocation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'The shell dispatcher, implemented in the file `cake/console/cake.php`, would
    go through the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Instantiate the shell class `UserShell`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Call its `initialize()` method.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Load all tasks defined in the `tasks` property of the shell.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: For each of those tasks, call their `initialize()` method, and load any tasks
    that they themselves may be using.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If the given command (`import` in this case) is the name of one of the included
    tasks, call the task's `startup()` method, and then its `execute()` method.
  prefs: []
  type: TYPE_NORMAL
- en: If the given command is not a task name, then call the shell's `startup()` method,
    and execute the command's method, if it exists, or the entry method `main()` if
    the command is not implemented.
  prefs: []
  type: TYPE_NORMAL
- en: 'This means that if we have a task named `Help` included in our shell, and the
    user launches the shell with the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Then the shell dispatcher would call the `execute()` method of the `HelpTask`
    class, because the command, `help`, is actually the name of one of the shell's
    tasks. Knowing this, we can remove the `help()` implementation of our `User` shell,
    and have the `Help` task handle the display of help messages.
  prefs: []
  type: TYPE_NORMAL
- en: 'Furthermore, our `Help` task needs to be generic enough to not be tied to a
    specific shell. Therefore, we need a way to tell it about our available commands,
    expected arguments, and optional parameters. This is what the `commands` property
    is there for: an array of commands, where the key is the command name and the
    value any of the following settings:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Setting | Purpose |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `help` | The help message describing the purpose of the command. Defaults
    to no message. |'
  prefs: []
  type: TYPE_TB
- en: '| `args` | The list of mandatory and optional arguments the command takes.
    Defaults to no arguments. |'
  prefs: []
  type: TYPE_TB
- en: '| `params` | The list of optional parameters the command accepts. Defaults
    to no parameters. |'
  prefs: []
  type: TYPE_TB
- en: 'Notice, however, that the `add` command is defined in a different fashion:
    instead of being defined in the key, it is simply the name of the command added
    to the `commands` array. This means that the command has no help message, no arguments,
    and no parameters.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `args` command setting is an array of arguments, indexed by argument name.
    Each argument may define any of the following settings:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Setting | Purpose |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `help` | The help message that describes the argument. Defaults to no message.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `mandatory` | If `true`, this argument must be present. If `false`, the argument
    may be omitted. Defaults to `false`. |'
  prefs: []
  type: TYPE_TB
- en: 'Similarly, the `params` command setting is also an array, indexed by parameter
    name, where each parameter may define any of the following settings:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Setting | Purpose |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `help` | The help message that describes the parameter. Defaults to no message.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `type` | The type of data this parameter holds. May be `int, bool`, or `string`.
    Any other type is interpreted as `string`. Defaults to `string`. |'
  prefs: []
  type: TYPE_TB
- en: '| `value` | A default value to use if the parameter is not specified. Defaults
    to no default value. |'
  prefs: []
  type: TYPE_TB
- en: Using the `commands` property in the `UserShell` class, we define the set of
    available arguments and parameters for our `import` command, and we then modify
    the `import()` method so that the options are obtained from the `parameters` property
    of the `Help` task. We also use the `extract()` PHP function to convert any arguments
    that are defined in the `arguments` property of the `Help` task to local variables.
    This way, the `path` argument will be available to the method as the variable
    `$path`.
  prefs: []
  type: TYPE_NORMAL
- en: These were all the modifications required in the `UserShell` class. Notice how
    we not only removed the `help()` method implementation, but also the processing
    of parameters, and the check for the right number of arguments from the `import()`
    method. This is all done automatically by the `Help` task now, based on what we
    define in our `commands` property.
  prefs: []
  type: TYPE_NORMAL
- en: This means that our `Help` task is indeed the Swiss Army knife of our shells,
    with most of its work being done in its `initialize()` method. This method starts
    by utilizing the PHP method, `get_class_vars(),` to obtain the `commands` property
    defined in the shell, because our task has no way of getting a hold of the instance
    of the `UserShell` class. It then proceeds to go through the list of commands,
    and normalizes all arguments and parameters thereby defined, assigning the resulting
    array to the `commands` property of the `HelpTask` class.
  prefs: []
  type: TYPE_NORMAL
- en: Once we have all our commands ready to be checked, we establish if the user
    has indeed selected a command to be executed through the `command` property, available
    to all classes that extend from `Shell`, and set to the current command. If the
    user has not, and if there is no `main()` method implemented in the shell, we
    use the `_help()` method to display the help.
  prefs: []
  type: TYPE_NORMAL
- en: If users have indeed specified a command that is within the list of available
    commands, we make sure that the specified arguments match the minimum number of
    mandatory arguments, if any, aborting the execution with a proper error message
    if the check fails. If the number of arguments is correct, we store the value
    of each given argument in the `arguments` property of the task.
  prefs: []
  type: TYPE_NORMAL
- en: Once the arguments are processed, we proceed to deal with the parameters. Going
    through the specified parameters, we check their provided value against the data
    type, if any, aborting the shell with a proper error message if the value given
    is of an incorrect type. If no value is given, the default value is used, if any.
    The resulting array of parameters and values is stored in the `parameters` property
    of the task.
  prefs: []
  type: TYPE_NORMAL
- en: The `execute()` method is the one called whenever the `Help` task is invoked,
    which is whenever the `help` command is used when calling the shell. Therefore,
    this method will simply display the help message by calling the `_help()` method,
    optionally passing to it the first argument, which would provide the user with
    the help message for the given command.
  prefs: []
  type: TYPE_NORMAL
- en: The `_help()` method builds the help message, for the entire shell or a specific
    command. It uses the command information stored in the `commands` property, and
    calls the `_usageCommand()` helper method to get the usage message for a given
    command, and the `_helpCommand()` method to get the help message for all available
    parameters and arguments in the command.
  prefs: []
  type: TYPE_NORMAL
- en: Sending e-mails from shells
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: E-mail sending is not a task that requires any interaction by visitors to our
    web applications, so it is pointless to make them wait for their delivery, which
    is exactly what we would do if we were to send an e-mail from a controller's action.
  prefs: []
  type: TYPE_NORMAL
- en: Deferring e-mail sending to a shell makes real sense both from a performance
    perspective and from the administrator point of view, as we may also add the ability
    to re-send failed e-mails.
  prefs: []
  type: TYPE_NORMAL
- en: This recipe uses the `Email` component provided by CakePHP to send a fictitious
    newsletter, adding the ability to test the sending process through a shell parameter.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To go through this recipe we need some data to work with. Create a `subscribers`
    table with the following SQL statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a `newsletters` table with the following statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a `newsletters_subscribers` table with the following statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Now add some sample data to these tables with the following statements:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a file named `newsletter.php` and place it in your `app/models` folder,
    with the following contents:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Create a file named `email.php` and place it in your `app/vendors/shells`,
    with the following contents:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Make sure to change the following lines in the `startup()` function to match
    your settings:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'If you wish to use PHP''s `mail()` function instead of SMTP, change the `delivery`
    property of the `Email` component to `mail`. Once configured, you can run the
    shell with the following command to force all e-mails to go to your specific address
    (in this case, `my@email.com`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'As all e-mails are forced to be sent to `my@email.com` through the use of the
    shell parameter, we need a way to tell if each e-mail will be going to the real
    e-mail address. Use your e-mail program to view the headers of the e-mail, and
    you will notice the following header lines:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: From these headers we can tell that the **X-Destination** header is set to the
    address to which the e-mail was originally intended for.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `EmailShell` starts by implementing the `startup()` method, which is called
    before any shell command or its entry method is executed. In this method, we create
    an instance of the `Email` component. Once we have the instance, we configure
    its delivery settings through the properties `delivery` and `smtpOptions`.
  prefs: []
  type: TYPE_NORMAL
- en: The entry method `main()` checks to see if the `to` parameter is given. If so,
    this will be the e-mail to which all e-mails will be sent to, a basic way to test
    the sending process. It continues to fetch the first newsletter that has not yet
    been sent, and the list of subscribers that should receive the newsletter.
  prefs: []
  type: TYPE_NORMAL
- en: 'For each of those subscribers, we set the appropriate properties of the `Email`
    component:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Property | Purpose |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `sendAs` | Type of e-mail to send. Can be text, `html`, or `both`. We set
    it to `html` to specify that we are sending an HTML-only e-mail. |'
  prefs: []
  type: TYPE_TB
- en: '| `subject` | The subject of the e-mail. |'
  prefs: []
  type: TYPE_TB
- en: '| `from` | The address sending the e-mail. |'
  prefs: []
  type: TYPE_TB
- en: '| `to` | The destination address. If the parameter is provided, this is the
    e-mail to send `to`, otherwise we use the e-mail of the subscriber. |'
  prefs: []
  type: TYPE_TB
- en: Finally, we proceed to send the actual e-mail through the component's `send()`
    method, informing the user of the result of the operation, and resetting the e-mail
    contents with the component's `reset()` method prior to the next loop in the `for`
    operation. We end the shell by marking that the newsletter is sent.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*Sending an e-mail* in [Chapter 11](ch11.html "Chapter 11. Utility Classes
    and Tools"), *Utility Classes and Tools*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Non-interactive tasks with the robot plugin
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As our application grows in size and complexity, we will find ourselves in the
    need to create and automate certain tasks, deferring the processing of non-interactive
    tasks for later execution. While we can create shells to perform these operations,
    some of our needs may be met by the Robot plugin.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: While this recipe shows a pure CakePHP approach, there are more involved and
    scalable alternatives. One of the most used tools is **Gearman**, available at
    [http://gearman.org/](http://gearman.org/).
  prefs: []
  type: TYPE_NORMAL
- en: The Robot plugin allows us to schedule tasks for later execution, and have those
    tasks run by a shell. The tasks themselves are actually CakePHP controller actions,
    which are run by the shell at the specified time.
  prefs: []
  type: TYPE_NORMAL
- en: This recipe shows us how to use the Robot plugin to send an e-mail after a user
    has signed up for our newsletters, and how to have the shell in the Robot plugin
    periodically check for pending tasks and run them as they become available.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To go through this recipe we need some data to work with. Follow the *Getting
    ready* section of the previous recipe.
  prefs: []
  type: TYPE_NORMAL
- en: We need to download the Robot plugin. Go to [http://github.com/mariano/robot/downloads](http://github.com/mariano/robot/downloads)
    and download the latest release. Uncompress the downloaded file into your `app/plugins`
    folder. You should now have a directory named `robot` inside `app/plugins`.
  prefs: []
  type: TYPE_NORMAL
- en: Run the SQL statements found in the `app/plugins/robot/config/sql/robot.sql`
    file to create the tables required by the Robot plugin.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Create a file named `subscribers_controller.php` and place it in your `app/controllers`
    folder, with the following contents:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create a folder named `subscribers` in your `app/views` folder. Create a file
    named `add.ctp` and place it in the folder `app/views/subscribers`, with the following
    contents:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create a file named `welcome.ctp` and place it in the `app/views/subscribers`
    folder, with the following contents:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add the following property to the beginning of the `SubscribersController`
    class (change the delivery settings of the `Email` component to match your needs):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Edit the `add()` method of the `SubscribersController` class and make the following
    changes:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'While still editing the `SubscribersController` class, replace the `welcome()`
    method with the following contents:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'You can now browse to `http://localhost/subscribers/add` and enter your name
    and e-mail address. Now run the robot shell with the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: 'If you are on a GNU Linux / Mac / Unix system:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'If you are on Microsoft Windows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'You should get an output similar to what is shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How to do it...](img/1926_8_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The robot is informing us that a task executed the CakePHP URL `/subscribers/welcome`
    successfully, after which we should receive a welcome e-mail.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We started with a basic controller that takes new subscriptions and saves them,
    redirecting to a welcome screen after the record is created. Then we added the
    `Email` component to our controller, as it will be used for sending e-mails.
  prefs: []
  type: TYPE_NORMAL
- en: 'We continued by modifying the `add()` method to create the scheduled task.
    We scheduled a task using the `schedule()` method of the `RobotTask` model located
    in the Robot plugin. This method takes up to three arguments:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Argument | Purpose |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `action` | The URL to a CakePHP action, which can be given as a string or
    as an array. |'
  prefs: []
  type: TYPE_TB
- en: '| `parameters` | Optional parameters to send to the controller action specified
    in `action`. Defaults to no parameters. |'
  prefs: []
  type: TYPE_TB
- en: '| `scheduled` | The time at which the action should be executed. This can be
    either a specific time stamp (in seconds since the Unix Epoch, which is January
    1, 1970 00:00:00 GMT), or any string that can be used by the PHP function `strtotime()`.
    Defaults to `null`, which means the task should be executed as soon as possible.
    |'
  prefs: []
  type: TYPE_TB
- en: 'In our `add()` method, we set the `action` argument to the `welcome` action
    of the current controller, and send two parameters: `name`, and `email`. These
    parameters are available to the called action through the `$this->params[''robot'']`
    array.'
  prefs: []
  type: TYPE_NORMAL
- en: In fact, whenever a controller action is called through the robot shell, `$this->params['robot']`
    will be available. If no parameters were specified when scheduling the task, this
    array will be empty, hence the check with `isset()` instead of `!empty()` in the
    `welcome()` method.
  prefs: []
  type: TYPE_NORMAL
- en: When called through the robot shell, the `welcome()` method uses the given parameters
    to build and send the e-mail. It returns a Boolean value to indicate the success
    of the executed task. If no value is returned, the task is assumed to have succeeded.
  prefs: []
  type: TYPE_NORMAL
- en: To test the Robot plugin, we ended the recipe by signing up as a subscriber,
    and then running the robot. Naturally, the application should not have to wait
    for us to manually run the robot shell in order for e-mails to go out. We need
    to add the shell to our list of automated tasks, commonly known as CRON tasks
    on most operative systems.
  prefs: []
  type: TYPE_NORMAL
- en: 'Assuming your application lives at `/var/www/myapp`, and that the path to your
    PHP binary is `/usr/bin/php`, the following would be the command that should be
    included as an automated task in your operative system:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: Notice the `silent` option. This tells the robot plugin to output no messages
    unless an error is found. This is particularly important when adding this command
    to our list of automated tasks, as it may be configured to e-mail the output of
    any executed command.
  prefs: []
  type: TYPE_NORMAL
- en: When adding this command to our list of automated tasks, we have to decide how
    often we want the robot to check for tasks. If we are interested in immediate
    results, we should set the robot to run every minute. However, what happens if
    at second 0 of a given minute the robot finds no tasks? We will have 59 seconds
    of idle time.
  prefs: []
  type: TYPE_NORMAL
- en: 'Fortunately, the plugin offers an interesting solution to this problem. Using
    the parameter `daemon`, we tell the Robot plugin to wait for tasks even if there
    are none available. If we try to manually run it with this option using the following
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: we will notice the shell complains, saying that there is no limit specified.
    This is because the robot should not be set to wait for tasks indefinitely, as
    any PHP fatal error that may be provoked by a called action could render the robot
    useless.
  prefs: []
  type: TYPE_NORMAL
- en: 'Instead, we can use the `time` parameter to limit the number of seconds to
    which the robot should wait for tasks. If we wanted to run the robot every minute,
    this limit should be set to 59 seconds:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: This means that we would have a robot waiting up to 59 seconds for tasks, after
    which the next robot run will be triggered.
  prefs: []
  type: TYPE_NORMAL
