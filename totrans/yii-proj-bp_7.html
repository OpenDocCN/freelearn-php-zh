<html><head></head><body><div class="chapter" title="Chapter&#xA0;7.&#xA0;Creating a Management Module for the CMS"><div class="titlepage"><div><div><h1 class="title"><a id="ch07"/>Chapter 7. Creating a Management Module for the CMS</h1></div></div></div><p>For our next project, we will be expanding upon the content management system we built in <a class="link" href="ch06.html" title="Chapter 6. Building a Content Management System">Chapter 6</a>, <span class="emphasis"><em>Building a Content Management System</em></span>, by migrating the management functionality into a module. Moving this functionality into a module will decouple administrative behaviors from the presentation layer of our application. This change will also enable us to develop and deploy administrative changes without having to make changes to our main application.</p><p>Our finished project will look as follows:</p><div class="mediaobject"><img src="graphics/7734OS_07_01.jpg" alt="Creating a Management Module for the CMS"/></div><div class="section" title="Prerequisites"><div class="titlepage"><div><div><h1 class="title"><a id="ch07lvl1sec58"/>Prerequisites</h1></div></div></div><p>Since we'll expanding upon the work we did in <a class="link" href="ch06.html" title="Chapter 6. Building a Content Management System">Chapter 6</a>, <span class="emphasis"><em>Building a Content Management System</em></span>, the only prerequisite for this chapter is the completed source code from the <a id="id609" class="indexterm"/>previous chapter. You can either build the project yourself, or you can use the completed source code available in the project resources folder from the previous chapter.</p></div></div>
<div class="section" title="What are modules?"><div class="titlepage"><div><div><h1 class="title"><a id="ch07lvl1sec59"/>What are modules?</h1></div></div></div><p>In Yii, modules are self-contained packages that operate independently of a Yii application<a id="id610" class="indexterm"/> but must reside within an existing application or module. Modules can additionally have as much or as little integration with our core application as we desire. In many aspects, modules are identical to Yii applications in that they have controllers, models, views, configurations, and components. This functionality allows us to deploy and manage code independently of our main application. It also provides us with greater usability if we choose to reuse our module across multiple projects. For our application, we'll be using our modules solely to separate the management of our application from the presentation layer and to independently deploy our application without having to make changes to our main application code.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note40"/>Note</h3><p>More information <a id="id611" class="indexterm"/>about Yii modules can be found in the official Yii guide located at <a class="ulink" href="http://www.yiiframework.com/doc/guide/1.1/en/basics.module">http://www.yiiframework.com/doc/guide/1.1/en/basics.module</a>.</p></div></div></div>
<div class="section" title="Describing the project"><div class="titlepage"><div><div><h1 class="title"><a id="ch07lvl1sec60"/>Describing the project</h1></div></div></div><p>Our dashboard module can be broken down into several components:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Initializing and configuring the dashboard module</li><li class="listitem" style="list-style-type: disc">Enabling custom routing for our module</li><li class="listitem" style="list-style-type: disc">Moving the management functionality out of our application and into the module</li><li class="listitem" style="list-style-type: disc">Adding file upload capabilities</li><li class="listitem" style="list-style-type: disc">Module deployment</li></ul></div><div class="section" title="Initializing the module"><div class="titlepage"><div><div><h2 class="title"><a id="ch07lvl2sec113"/>Initializing the module</h2></div></div></div><p>The<a id="id612" class="indexterm"/> first component of this project will consist of creating and configuring <a id="id613" class="indexterm"/>our module so that it integrates with our primary application. We'll accomplish this by making several changes to our main configuration file as well as creating the basic structure for the module that we'll be using. We'll also go over managing our module assets independently of our main application.</p></div><div class="section" title="Routing with a module"><div class="titlepage"><div><div><h2 class="title"><a id="ch07lvl2sec114"/>Routing with a module</h2></div></div></div><p>In the Yii framework, the default routes are defined by the name of the module combined with the<a id="id614" class="indexterm"/> default routes that are specified within <code class="literal">CUrlManager</code>. Unfortunately, Yii<a id="id615" class="indexterm"/> does not natively provide the functionality to define our own custom routes for a module without modifying the routes specified in <code class="literal">CUrlManager</code>. To get around this restriction, we'll be modifying our <code class="literal">CMSURLManager</code>, which we defined in <a class="link" href="ch06.html" title="Chapter 6. Building a Content Management System">Chapter 6</a>, <span class="emphasis"><em>Building a Content Management System</em></span>, in order to allow us to store and configure routes independently of our main application. When completed, we'll have a <code class="literal">routes.php</code> file in the <code class="literal">protected/modules/&lt;module&gt;/config/</code> file; this will contain all the custom routes for our module and will integrate with our main application without altering the application's behavior.</p></div><div class="section" title="Moving the management functionality into the module"><div class="titlepage"><div><div><h2 class="title"><a id="ch07lvl2sec115"/>Moving the management functionality into the module</h2></div></div></div><p>The third component of this project will entail moving the management functionality from <a id="id616" class="indexterm"/>our controls to the module's controllers. This will additionally involve moving the presentation layers out of the theme we created in the previous chapter and into the module itself. For additional security and user experience, we'll also be modifying how our module handles errors for both unauthenticated and unauthorized users.</p></div><div class="section" title="Adding file upload capabilities"><div class="titlepage"><div><div><h2 class="title"><a id="ch07lvl2sec116"/>Adding file upload capabilities</h2></div></div></div><p>To make<a id="id617" class="indexterm"/> our content management system more<a id="id618" class="indexterm"/> versatile, we'll also be adding a file upload capability that will allow us to upload files from our content page and store them in our database. We'll also implement the functionality necessary to view these files in a file manager and additionally, to delete them.</p></div><div class="section" title="Deploying modules"><div class="titlepage"><div><div><h2 class="title"><a id="ch07lvl2sec117"/>Deploying modules</h2></div></div></div><p>Finally, we'll go over the different deployment options that we can use to easily deploy our <a id="id619" class="indexterm"/>module independently of our main application. Using a combination of both Git and Composer, we can deploy our module in a way that makes the most sense for the type of project we are using.</p></div></div>
<div class="section" title="Initializing the project"><div class="titlepage"><div><div><h1 class="title"><a id="ch07lvl1sec61"/>Initializing the project</h1></div></div></div><p>For this <a id="id620" class="indexterm"/>project, we'll be starting where we left off in the previous<a id="id621" class="indexterm"/> chapter, <a class="link" href="ch06.html" title="Chapter 6. Building a Content Management System">Chapter 6</a>, <span class="emphasis"><em>Building a Content Management System</em></span>. For your convenience, a skeleton project has been included in the project resources folder for this chapter that contains the foundation that we'll be starting with. Begin by copying the source code over to a new folder, and make sure that it is available at a different URL. In this chapter, I'll be using <code class="literal">http://chapter7.example.com</code> as our example URL. After importing the database and updating the database configuration using the instructions provided in the previous chapter, you should see the home page of our blog:</p><div class="mediaobject"><img src="graphics/7734OS_07_02.jpg" alt="Initializing the project"/></div></div>
<div class="section" title="Creating the module"><div class="titlepage"><div><div><h1 class="title"><a id="ch07lvl1sec62"/>Creating the module</h1></div></div></div><p>Now that <a id="id622" class="indexterm"/>our application is set up, we can begin to create our module. We'll start by creating the basic folder structure within our <code class="literal">protected/modules</code> directory:</p><div class="informalexample"><pre class="programlisting">protected/
   [...]
   modules/
      /dashboard
         assets/
         components/
         config/
         controllers/
         views/
            layouts/
            user/
            category/
            filemanager/
            default/</pre></div><p>As you can <a id="id623" class="indexterm"/>see, the basic structure of our module looks identical to that of our main application. With our folder structure in place, we now need to create the <code class="literal">DashboardModule</code> class that we'll later tell Yii about so that it knows what to load. The steps are as follows:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Start by creating a new file, called <code class="literal">DashboardModule.php</code>, within <code class="literal">protected/modules/dashboard</code> with the following definition:<div class="informalexample"><pre class="programlisting">&lt;?php class DashboardModule extends CWebModule {}</pre></div></li><li class="listitem">Then, create an <code class="literal">init()</code> method for the module:<div class="informalexample"><pre class="programlisting">public function init() {}</pre></div></li><li class="listitem">Within the module, we'll want to set the <code class="literal">layoutPath</code> so that our module knows what layout to provide our views with:<div class="informalexample"><pre class="programlisting">$this-&gt;layoutPath = Yii::getPathOfAlias('dashboard.views.layouts');</pre></div></li><li class="listitem">We'll also want to tell our module to automatically import the contents of the <code class="literal">components</code> directory in which we'll be storing classes later:<div class="informalexample"><pre class="programlisting">$this-&gt;setImport(array(
   'dashboard.components.*',
));</pre></div><p>This will tell Yii's autoloader to automatically load classes in the <code class="literal">components</code> folder. This is the same behavior that is used within Yii to load the classes registered in the import section of our <code class="literal">protected/config/main.php</code> file.</p></li><li class="listitem">Finally, we'll want to set a few custom components for our module—mainly the error handler—so that we can handle errors that occur within our module in a different manner from the errors that occur within our main application:<div class="informalexample"><pre class="programlisting">Yii::app()-&gt;setComponents(array(
   'errorHandler' =&gt; array(
       'errorAction'  =&gt; 'dashboard/default/error',
   )
));</pre></div></li></ol></div><p>We'll then need to create two new classes; the first will be a controller component that all controllers <a id="id624" class="indexterm"/>within our module will extend from, and the second will be the default controller that will be accessed when no routes are specified. Within <code class="literal">protected/modules/dashboard/components/</code>, create a new file called <code class="literal">DashboardController.php</code> with the following definition. We'll be adding more information to this component once we've registered our module with Yii:</p><div class="informalexample"><pre class="programlisting">&lt;?php class DashboardController extends CMSController {}</pre></div><p>Then, create <code class="literal">DefaultController.php</code> inside <code class="literal">protected/modules/dashboard/controllers</code>. We'll also specify our <code class="literal">actionIndex()</code> method so that, once we register our module with Yii, we can see something:</p><div class="informalexample"><pre class="programlisting">&lt;?php class DefaultController extends DashboardController
{
   public function actionIndex()
   {
      echo "Hello World!";
   }
}</pre></div><div class="section" title="Registering the module with Yii"><div class="titlepage"><div><div><h2 class="title"><a id="ch07lvl2sec118"/>Registering the module with Yii</h2></div></div></div><p>Before <a id="id625" class="indexterm"/>we can see anything in our module, we first need to tell <a id="id626" class="indexterm"/>Yii about our module. For this, we simply need to specify the module name within the modules section of our <code class="literal">main.php</code> file at <code class="literal">protected/config/</code>:</p><div class="informalexample"><pre class="programlisting">&lt;?php return array(
   [...]
'modules' =&gt; array(
      'dashboard'
),
[...]
);</pre></div><p>Now, if you navigate to <code class="literal">http://chapter7.example.com/dashboard</code>, you should see the text <span class="strong"><strong>Hello World</strong></span> displayed. This is the simplest way to register a module with Yii. Unfortunately, this method requires us to make a change to our configuration file every time we want to use a new module, which in turn means we have to change the application code every time we use a new module. Another method of loading our module is to create a <code class="literal">protected/config/modules.php</code> file that we register in the modules section, instead. This allows us to simply change a cache setting outside our application without having to modify the code within our configuration file.</p><p>For this, first <a id="id627" class="indexterm"/>change the modules section of <code class="literal">main.php</code> at <code class="literal">protected/config/</code> so that it looks as follows:</p><div class="informalexample"><pre class="programlisting">&lt;?php return array(
[...]
'modules' =&gt; require_once __DIR__ . DIRECTORY_SEPARATOR . 'modules.php',
[...]
);</pre></div><p>Then, create <a id="id628" class="indexterm"/>a <code class="literal">modules.php</code> file at <code class="literal">protected/config/</code>. We'll start by declaring where the <code class="literal">modules</code> directory is located, and the location where our generated configuration file should be cached:</p><div class="informalexample"><pre class="programlisting">&lt;?php

// Set the scan directory
$directory = __DIR__ . DIRECTORY_SEPARATOR . '..' . DIRECTORY_SEPARATOR . 'modules';
$cachedConfig = __DIR__.DIRECTORY_SEPARATOR.'..'.DIRECTORY_SEPARATOR.'runtime'.DIRECTORY_SEPARATOR.'modules.config.php';</pre></div><p>We'll then check to see whether a cached file already exists. If it does, we'll simply return it:</p><div class="informalexample"><pre class="programlisting">// Attempt to load the cached file if it exists
if (file_exists($cachedConfig))
    return require_once($cachedConfig);</pre></div><p>If a cached file doesn't exist, we'll iterate through all the folders in the <code class="literal">protected/modules</code> directory to retrieve all the module names and push them to an array. Since some Yii modules require additional configuration, we'll tell our loader to inject anything in <code class="literal">main.php</code> at <code class="literal">protected/modules/&lt;module&gt;/config/</code> as options for the module to use. When we've compiled a list of all the modules we're going to load, we'll write that out as a serialized array to a file within our <code class="literal">protected/runtime</code> directory:</p><div class="informalexample"><pre class="programlisting">else
{
    // Otherwise generate one, and return it
    $response = array();

    // Find all the modules currently installed, and preload them
    foreach (new IteratorIterator(new DirectoryIterator($directory)) as $filename)
    {
        // Don't import dot files
        if (!$filename-&gt;isDot())
        {
            $path = $filename-&gt;getPathname();

            if (file_exists($path.DIRECTORY_SEPARATOR.'config'.DIRECTORY_SEPARATOR.'main.php'))
                $response[$filename-&gt;getFilename()] = require($path.DIRECTORY_SEPARATOR.'config'.DIRECTORY_SEPARATOR.'main.php');
            else
                array_push($response, $filename-&gt;getFilename());
        }
    }

    $encoded = serialize($response);
    file_put_contents($cachedConfig, '&lt;?php return unserialize(\''.$encoded.'\');');

    // return the response
    return $response;
}</pre></div><p>The <a id="id629" class="indexterm"/>resulting file that is generated then looks as follows and is<a id="id630" class="indexterm"/> returned all the way up to our <code class="literal">main.php</code> file at <code class="literal">protected/config/</code>:</p><div class="informalexample"><pre class="programlisting">&lt;?php return unserialize('a:1:{i:0;s:9:"dashboard";}');</pre></div><p>If we ever want to add a new module, we simply need to delete the <code class="literal">module.config.php</code> file at <code class="literal">protected/runtime/</code>. The first request to hit the system will immediately regenerate the updated file.</p><p>While slightly more expensive in terms of disk operation, this method of loading modules enables us to dynamically load modules with Yii just by adding them to the <code class="literal">modules</code> directory. It also eliminates any changes we need to make to our application in order to add a new module, which in turn means that we'll be less likely to introduce new behaviors or bugs to our main application while adding a new module.</p></div></div>
<div class="section" title="Adding custom routes to a module"><div class="titlepage"><div><div><h1 class="title"><a id="ch07lvl1sec63"/>Adding custom routes to a module</h1></div></div></div><p>While Yii will perform a lot of module routing for free, we have to add our routes to our <code class="literal">CUrlManager</code> configuration in <code class="literal">main.php</code> at <code class="literal">protected/config/</code> in order for our module to <a id="id631" class="indexterm"/>have any custom routing. While it's easy to <a id="id632" class="indexterm"/>execute, this method does not keep our module and application configurations sufficiently separated. To get around this limitation in Yii, we need to modify the <code class="literal">CMSUrlManager</code> class that we created in the previous chapter in order to retrieve custom module routes that we define. This enables us to write routes as part of our module rather than as part of our application. The steps are as follows:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Start by creating a new file, <code class="literal">routes.php</code>, in <code class="literal">protected/modules/dashboard/config/</code>, that contains the following. For this module, we'll define a custom route for our save actions to be loaded from:<div class="informalexample"><pre class="programlisting">&lt;?php return array(
   '/dashboard/&lt;controller:\w+&gt;/save' =&gt; '/dashboard/&lt;controller&gt;/save',
);</pre></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note41"/>Note</h3><p>This example is purely to illustrate how to add custom routing to a module, since Yii does not support it natively.</p></div></div></li><li class="listitem">With our custom route defined, we'll next update <code class="literal">CMSUrlManager</code> to automatically import these rules. Open <code class="literal">CMSUrlManager.php</code> at <code class="literal">protected/components/</code>, and add the following to the <code class="literal">if</code> block of the <code class="literal">processRules()</code> method:<div class="informalexample"><pre class="programlisting">$this-&gt;rules = CMap::mergearray($this-&gt;addModuleRules(), $this-&gt;rules);</pre></div></li><li class="listitem">We'll finally define a <code class="literal">addModuleRules()</code> method that will search all of our installed modules for a <code class="literal">routes.php</code> file at <code class="literal">config/</code> and register them with Yii:<div class="informalexample"><pre class="programlisting">private function addModuleRules()
{
    // Load the routes from cache
    $moduleRoutes = array();
    $directories = glob(Yii::getPathOfAlias('application.modules') . '/*' , GLOB_ONLYDIR);

    foreach ($directories as $dir)
    {
        $routePath = $dir .DS. 'config' .DS. 'routes.php';
        if (file_exists($routePath))
        {
            $routes = require_once($routePath);
            foreach ($routes as $k=&gt;$v)
                $moduleRoutes[$k] = $v;
        }
    }

    return $moduleRoutes;
}</pre></div></li></ol></div><p>Now, our<a id="id633" class="indexterm"/> dashboard module will be able to handle <a id="id634" class="indexterm"/>nonstandard routes without having to update a configuration file within our main application.</p></div>
<div class="section" title="Creating the controllers"><div class="titlepage"><div><div><h1 class="title"><a id="ch07lvl1sec64"/>Creating the controllers</h1></div></div></div><p>Now that <a id="id635" class="indexterm"/>we have registered our application with Yii and defined our custom routes, we can start working on our controllers. First, we should work on our <code class="literal">DashboardController</code> component so that our controllers automatically inherit some common behaviors. The steps are as follows:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Within our <code class="literal">DashboardController.php</code> component, we should first define our <code class="literal">accessRules()</code> method. This will ensure that only administrators have access to the dashboard:<div class="informalexample"><pre class="programlisting">public function filters()
{
   return array(
      'accessControl'
   );
}

public function accessRules()
{
   return array(
      array('allow',  // allow authenticated admins to perform any action
         'users'=&gt;array('@'),
      ),
      array('deny',  // deny all users
         'users'=&gt;array('*'),
         'deniedCallback' =&gt; array($this, 'actionError')
      ),
   );
}</pre></div></li><li class="listitem">Next, we'll define the <code class="literal">default</code> layout that we'll want to use throughout the module:<div class="informalexample"><pre class="programlisting">public $layout='default';</pre></div></li><li class="listitem">Then, we'll <a id="id636" class="indexterm"/>create a custom error action that will prevent both unauthenticated users and unauthorized users from accessing our module. By default, if Yii encounters an unauthorized error, it will simply return a 403 error. Our error action will improve the user experience by redirecting unauthenticated users to the login page with a next <code class="literal">$_GET</code> parameter so that they can be returned to the exact page they wanted to go to after they have been authenticated. If a user is simply unauthorized, on the other hand, it will display the appropriate error and deny them access:<div class="informalexample"><pre class="programlisting">public function actionError()
{
    if (Yii::app()-&gt;user-&gt;isGuest)
       return $this-&gt;redirect($this-&gt;createUrl('/site/login?next=' . Yii::app()-&gt;request-&gt;requestUri));

    if($error=Yii::app()-&gt;errorHandler-&gt;error)
    {
        if(Yii::app()-&gt;request-&gt;isAjaxRequest)
            echo $error['message'];
        else
            $this-&gt;render('error', array('error' =&gt; $error));
    }
}</pre></div></li><li class="listitem">To complete this, redirect the <code class="literal">$_GET</code> parameter. We also need to make a change to our <code class="literal">SiteController.php</code> file at <code class="literal">protected/controllers/</code> so that it knows how to handle the parameter. Simply replace the redirect with the following:<div class="informalexample"><pre class="programlisting">$this-&gt;redirect(Yii::app()-&gt;request-&gt;getParam('next', $this-&gt;createAbsoluteUrl('content/index')));</pre></div></li><li class="listitem">Finally, we <a id="id637" class="indexterm"/>need to implement a way to manage our assets independently of our main application. Many module implementations simple add assets to a globally available <code class="literal">assets</code> folder. This implementation makes it very difficult to ensure that all traces of a module have been removed. An easier way of managing assets for modules is to create a folder for all of our module-specific assets to reside in, and then, publish that folder using <code class="literal">CAssetManager</code> independently of our application. This way, if we make any changes to our module assets, they won't affect our main application. In our <code class="literal">SiteController</code>, we should define the following method:<div class="informalexample"><pre class="programlisting">public function getAsset()
{
   return Yii::app()-&gt;assetManager-&gt;publish(YiiBase::getPathOfAlias('application.modules.dashboard.assets'), true, -1, YII_DEBUG);
}</pre></div><p>Since this method is a getter and since it returns the path where the assets are published, we can call it from our layout file as follows (using the <code class="literal">dashboard.css</code> file that should be copied from the project resources folder to your module's <code class="literal">assets</code> folder):</p><div class="informalexample"><pre class="programlisting">Yii::app()-&gt;clientScript-&gt;registerCssFile($this-&gt;getAsset().'/dashboard.css');</pre></div></li></ol></div></div>
<div class="section" title="Migrating the functionality to the module"><div class="titlepage"><div><div><h1 class="title"><a id="ch07lvl1sec65"/>Migrating the functionality to the module</h1></div></div></div><p>Now that <a id="id638" class="indexterm"/>our module is set up, we can start by <a id="id639" class="indexterm"/>moving the functionality from our application controllers and theme into our dashboard module. We'll go over everything that is needed for each model: Categories, Content, and Users.</p><div class="section" title="Migrating content management"><div class="titlepage"><div><div><h2 class="title"><a id="ch07lvl2sec119"/>Migrating content management</h2></div></div></div><p>In this <a id="id640" class="indexterm"/>next section, we <a id="id641" class="indexterm"/>will migrate all of the management functionalities we built in the previous chapter into our new module:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Starting with our <code class="literal">ContentController</code>, we first want to remove the <code class="literal">actionAdmin()</code>, <code class="literal">actionSave()</code>, and <code class="literal">actionDelete()</code> methods from the <code class="literal">ContentController.php</code> file at <code class="literal">protected/controllers/</code>.</li><li class="listitem">Next, we<a id="id642" class="indexterm"/> should remove the access control properties for the actions we just deleted<a id="id643" class="indexterm"/> from our <code class="literal">ContentController</code>. The restored <code class="literal">accessRules()</code> method should look as follows:<div class="informalexample"><pre class="programlisting">public function accessRules()
{
   return array(
      array('allow',
         'actions' =&gt; array('index', 'view', 'search'),
         'users' =&gt; array('*')
      ),
      array('deny',  // deny all users
         'users'=&gt;array('*'),
      ),
   );
}</pre></div></li><li class="listitem">With our <code class="literal">ContentController</code> stripped of our administrative behaviors, we can begin moving the functionality into our <code class="literal">DefaultController.php</code> file at <code class="literal">protected/modules/dashboard/controllers/</code>, which we'll be using as our <code class="literal">ContentController</code>. We'll start by adding our <code class="literal">accessRules()</code> method to our <code class="literal">DefaultController</code>. Since we want to inherit the rules defined in <code class="literal">DashboardController.php</code> at <code class="literal">components/</code>, we'll use <code class="literal">CMap::mergeArray()</code> to merge the parent rules with our newly defined rules:<div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note42"/>Note</h3><p>Do the naming conventions have you confused? If you don't want to store the content-related functionality in <code class="literal">DefaultController</code>, you can set the <code class="literal">$defaultController</code> property in <code class="literal">DashboardModule</code> to <code class="literal">content</code>. This will override Yii's default behavior.</p></div></div><div class="informalexample"><pre class="programlisting">public function accessRules()
{
   return CMap::mergeArray(parent::accessRules(), array(
      array('allow',
         'actions' =&gt; array('index', 'save', 'delete'),
         'users'=&gt;array('@'),
         'expression' =&gt; 'Yii::app()-&gt;user-&gt;role==2'
      ),
      array('deny',  // deny all users
         'users'=&gt;array('*'),
      )
   ));
}</pre></div></li><li class="listitem">Then, we'll<a id="id644" class="indexterm"/> redefine <a id="id645" class="indexterm"/>our <code class="literal">loadModel()</code> method:<div class="informalexample"><pre class="programlisting">private function loadModel($id=NULL)
{
   if ($id == NULL)
      throw new CHttpException(404, 'No category with that ID exists');

   $model = Content::model()-&gt;findByPk($id);

   if ($model == NULL)
      throw new CHttpException(404, 'No category with that ID exists');

   return $model;
}</pre></div></li><li class="listitem">Then, we'll define our <code class="literal">actionDelete()</code> method:<div class="informalexample"><pre class="programlisting">public function actionDelete($id)
{
   $this-&gt;loadModel($id)-&gt;delete();
   
   $this-&gt;redirect($this-&gt;createUrl('/dashboard'));
}</pre></div></li><li class="listitem">Then we'll write an index method to display all of the content entries on our database:<div class="informalexample"><pre class="programlisting">public function actionIndex()
{
   $model = new Content('search');
   $model-&gt;unsetAttributes();

   if (isset($_GET['Content']))
      $model-&gt;attributes = $_GET;

   $this-&gt;render('index', array(
      'model' =&gt; $model
   ));
}</pre></div></li><li class="listitem">Finally, we'll <a id="id646" class="indexterm"/>write a <a id="id647" class="indexterm"/>method to both create new content entries and edit existing content entries:<div class="informalexample"><pre class="programlisting">public function actionSave($id=NULL)
{
   if ($id == NULL)
      $model = new Content;
   else
      $model = $this-&gt;loadModel($id);

   if (isset($_POST['Content']))
   {
      $model-&gt;attributes = $_POST['Content'];
      $model-&gt;author_id = Yii::app()-&gt;user-&gt;id;

      if ($model-&gt;save())
      {
         Yii::app()-&gt;user-&gt;setFlash('info', 'The articles was saved');
         $this-&gt;redirect($this-&gt;createUrl('/dashboard'));
      }
   }

   $this-&gt;render('save', array(
      'model' =&gt; $model
   ));
}</pre></div></li><li class="listitem">Next, we should copy our <code class="literal">save.php</code> file located at <code class="literal">protected/modules/dashboard/views/default/</code> from our project resources folder into our module. If you haven't done so already, copy the <code class="literal">default.php</code> layout file located at <code class="literal">protected/modules/dashboard/views/layouts/</code> into your project.</li><li class="listitem">Finally, we need to make sure that our <code class="literal">index</code> view file is properly updated so that it links to the appropriate controller actions. If you were simply to copy the view from the theme file, you'd notice that none of the links work. To correct these links, we need to update our <code class="literal">createUrl</code> calls to point to the <code class="literal">save()</code> method <a id="id648" class="indexterm"/>our <a id="id649" class="indexterm"/>module's <code class="literal">DefaultController</code>, and update the <code class="literal">CButtonColumn</code> links to point to our module:<div class="informalexample"><pre class="programlisting">&lt;?php echo CHtml::link('Create New Post', $this-&gt;createUrl('/dashboard/default/save'), array('class' =&gt; 'btn btn-primary')); ?&gt;
&lt;?php $this-&gt;widget('zii.widgets.grid.CGridView', array(
    'dataProvider'=&gt;$model-&gt;search(),
    'htmlOptions' =&gt; array(
        'class' =&gt; 'table-responsive'
    ),
    'itemsCssClass' =&gt; 'table table-striped',
    'columns' =&gt; array(
       'id',
       'title',
       'published' =&gt; array(
          'name' =&gt; 'Published',
          'value' =&gt; '$data-&gt;published==1?"Yes":"No"'
       ),
       'author.username',
       array(
            'class'=&gt;'CButtonColumn',
            'viewButtonUrl'=&gt;'Yii::app()-&gt;createUrl("/".$data["slug"])',
            'deleteButtonUrl'=&gt;'Yii::app()-&gt;createUrl("/dashboard/default/delete", array("id" =&gt;  $data["id"]))',
            'updateButtonUrl'=&gt;'Yii::app()-&gt;createUrl("/dashboard/default/save", array("id" =&gt;  $data["id"]))',
        ),
    ),
    'pager' =&gt; array(
       'htmlOptions' =&gt; array(
          'class' =&gt; 'pager'
       ),
       'header' =&gt; '',
       'firstPageCssClass'=&gt;'hide',
       'lastPageCssClass'=&gt;'hide',
       'maxButtonCount' =&gt; 0
    )
));</pre></div></li></ol></div><p>Now that <a id="id650" class="indexterm"/>we're finished, we'll <a id="id651" class="indexterm"/>be able to view all the articles in our CMS, delete them, edit them, and navigate to the frontend view—all from a single interface, as shown in the following screenshot:</p><div class="mediaobject"><img src="graphics/7734OS_07_03.jpg" alt="Migrating content management"/></div></div><div class="section" title="Migrating categories"><div class="titlepage"><div><div><h2 class="title"><a id="ch07lvl2sec120"/>Migrating categories</h2></div></div></div><p>The <a id="id652" class="indexterm"/>changes for our users and <a id="id653" class="indexterm"/>categories controllers are going to be very similar—let's work through them. The steps are as follows:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Starting with our <code class="literal">CategoryController</code>, we first want to remove the <code class="literal">actionAdmin()</code>, <code class="literal">actionSave()</code>, and <code class="literal">actionDelete()</code> methods from the <code class="literal">CategoryController.php</code> file at <code class="literal">protected/controllers/</code>.</li><li class="listitem">Next, we should remove the access control properties for the actions we just deleted from our <code class="literal">CategoryController</code>. The restored <code class="literal">accessRules()</code> method should look as follows:<div class="informalexample"><pre class="programlisting">public function accessRules()
{
   return array(
      array('allow',
         'actions' =&gt; array('index', 'view', 'search'),
         'users' =&gt; array('*')
      ),
      array('deny',  // deny all users
         'users'=&gt;array('*'),
      ),
   );
}</pre></div></li><li class="listitem">Our new <code class="literal">accessRules()</code> method for our <code class="literal">CategoryController.php</code> file at <code class="literal">protected/modules/dashboard/controllers/</code> will then look as follows:<div class="informalexample"><pre class="programlisting">public function accessRules()
{
   return CMap::mergeArray(parent::accessRules(), array(
      array('allow',
         'actions' =&gt; array('index', 'save', 'delete'),
         'users'=&gt;array('@'),
         'expression' =&gt; 'Yii::app()-&gt;user-&gt;role==2'
      ),
      array('deny',  // deny all users
         'users'=&gt;array('*'),
      )
   ));
}</pre></div></li><li class="listitem">Next, we'll <a id="id654" class="indexterm"/>reimplement all of the management actions with updated redirects, starting with <a id="id655" class="indexterm"/>our <code class="literal">actionIndex()</code> method:<div class="informalexample"><pre class="programlisting">public function actionIndex()
{
   $model = new Category('search');
   $model-&gt;unsetAttributes();

   if (isset($_GET['Category']))
      $model-&gt;attributes = $_GET;

   $this-&gt;render('index', array(
      'model' =&gt; $model
   ));
}</pre></div></li><li class="listitem">We'll then re-implement the save method and modify it to work in our module:<div class="informalexample"><pre class="programlisting">public function actionSave($id=NULL)
{
   if ($id == NULL)
      $model = new Category;
   else
      $model = $this-&gt;loadModel($id);

   if (isset($_POST['Category']))
   {
      $model-&gt;attributes = $_POST['Category'];

      if ($model-&gt;save())
      {
         Yii::app()-&gt;user-&gt;setFlash('info', 'The category was saved');
         $this-&gt;redirect($this-&gt;createUrl('/dashboard/category'));
      }
   }

   $this-&gt;render('save', array(
      'model' =&gt; $model
   ));
}</pre></div></li><li class="listitem">We'll then reimplement the delete method in our module and update the redirects:<div class="informalexample"><pre class="programlisting">public function actionDelete($id)
{
   $this-&gt;loadModel($id)-&gt;delete();
   
   $this-&gt;redirect($this-&gt;createUrl('/dashboard/category'));
}</pre></div></li><li class="listitem">Finally, we'll <a id="id656" class="indexterm"/>update<a id="id657" class="indexterm"/> the <code class="literal">loadModel()</code> method so that it works without our module:<div class="informalexample"><pre class="programlisting">private function loadModel($id=NULL)
{
   if ($id == NULL)
      throw new CHttpException(404, 'No category with that ID exists');

   $model = Category::model()-&gt;findByPk($id);

   if ($model == NULL)
      throw new CHttpException(404, 'No category with that ID exists');

   return $model;
}</pre></div></li><li class="listitem">Then copy the view files' <code class="literal">index.php</code> located at <code class="literal">protected/modules/dashboard/views/category/</code> and <code class="literal">save.php</code> located at <code class="literal">protected/modules/dashboard/views/category/</code> from the project resources folder into our module.</li><li class="listitem">Notice once again that we've updated our <code class="literal">CButtonColumn</code> links to point to our module rather than to the home page routes we had defined earlier:<div class="informalexample"><pre class="programlisting">array(
    'class'=&gt;'CButtonColumn',
    'viewButtonUrl'=&gt;'Yii::app()-&gt;createUrl("/".$data["slug"])',
   'deleteButtonUrl'=&gt;'Yii::app()-&gt;createUrl("/dashboard/category/delete", array("id" =&gt;  $data["id"]))',
   'updateButtonUrl'=&gt;'Yii::app()-&gt;createUrl("/dashboard/category/save", array("id" =&gt;  $data["id"]))',
),</pre></div></li></ol></div><p>Our<a id="id658" class="indexterm"/> final category management <a id="id659" class="indexterm"/>interface will look as follows and will behave identically to how our content management interface behaves:</p><div class="mediaobject"><img src="graphics/7734OS_07_04.jpg" alt="Migrating categories"/></div></div><div class="section" title="Implementing user management"><div class="titlepage"><div><div><h2 class="title"><a id="ch07lvl2sec121"/>Implementing user management</h2></div></div></div><p>In the <a id="id660" class="indexterm"/>previous chapter, we <a id="id661" class="indexterm"/>didn't implement a UI for user management; let's go ahead and implement that functionality now so that our dashboard module fully encompasses all the management functionality. The steps are as follows:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Begin by creating a new controller, <code class="literal">UserController.php</code>, in <code class="literal">protected/modules/dashboard/controllers</code> with the following definition:<div class="informalexample"><pre class="programlisting">&lt;?php class UserController extends DashboardController {}</pre></div></li><li class="listitem">Next, we'll define our <code class="literal">accessRules()</code> method for this controller:<div class="informalexample"><pre class="programlisting">public function accessRules()
{
   return CMap::mergeArray(parent::accessRules(), array(
      array('allow',
         'actions' =&gt; array('index', 'save', 'delete'),
         'users'=&gt;array('@'),
         'expression' =&gt; 'Yii::app()-&gt;user-&gt;role==2'
      ),
      array('deny',  // deny all users
         'users'=&gt;array('*'),
      )
   ));
}</pre></div></li><li class="listitem">Then, we'll <a id="id662" class="indexterm"/>implement a <code class="literal">loadModel()</code> utility method:<div class="informalexample"><pre class="programlisting">private function loadModel($id=NULL)
{
   if ($id == NULL)
      throw new CHttpException(404, 'No category with that ID exists');

   $model = User::model()-&gt;findByPk($id);

   if ($model == NULL)
      throw new CHttpException(404, 'No category with that ID exists');

   return $model;
}</pre></div></li><li class="listitem">Next, we'll<a id="id663" class="indexterm"/> update our delete action so that it redirects properly within our module:<div class="informalexample"><pre class="programlisting">public function actionDelete($id)
{
   $this-&gt;loadModel($id)-&gt;delete();
   
   $this-&gt;redirect($this-&gt;createUrl('/dashboard/user'));
}</pre></div></li><li class="listitem">Then we'll reimplement the index action to display a listing of all of our users:<div class="informalexample"><pre class="programlisting">public function actionIndex()
{
   $model = new User('search');
   $model-&gt;unsetAttributes();

   if (isset($_GET['User']))
      $model-&gt;attributes = $_GET;

   $this-&gt;render('index', array(
      'model' =&gt; $model
   ));
}</pre></div></li><li class="listitem">Finally, we'll migrate our save method into our module. Since we've already implemented all the core functionality of how our users behave into our User model<a id="id664" class="indexterm"/> class, the<a id="id665" class="indexterm"/> implementation of our <code class="literal">actionSave()</code> method is straightforward:<div class="informalexample"><pre class="programlisting">public function actionSave($id=NULL)
{
   if ($id == NULL)
      $model = new User;
   else
      $model = $this-&gt;loadModel($id);

   if (isset($_POST['User']))
   {
      $model-&gt;attributes = $_POST['User'];

      if ($model-&gt;save())
      {
         Yii::app()-&gt;user-&gt;setFlash('info', 'The user was saved');
         $this-&gt;redirect($this-&gt;createUrl('/dashboard/user'));
      }
   }

   $this-&gt;render('save', array(
      'model' =&gt; $model
   ));
}</pre></div></li><li class="listitem">Finally, copy the <code class="literal">index.php</code> view file located at <code class="literal">protected/modules/dashboard/views/user/</code> and the <code class="literal">save.php</code> view file located at <code class="literal">protected/modules/dashboard/views/user/</code> from the project resources folder into your application. Once again, we're left with an interface<a id="id666" class="indexterm"/> that <a id="id667" class="indexterm"/>is identical to our content and category management interfaces:<div class="mediaobject"><img src="graphics/7734OS_07_05.jpg" alt="Implementing user management"/></div></li></ol></div></div></div>
<div class="section" title="Uploading files"><div class="titlepage"><div><div><h1 class="title"><a id="ch07lvl1sec66"/>Uploading files</h1></div></div></div><p>The final <a id="id668" class="indexterm"/>component that we'll be adding to our module is a file manager with file upload capabilities. For this component, we'll be creating a dedicated controller to view all of our uploaded files in paginated format, several new classes to handle the actual file upload, and a few view changes to our content save view so that we can associate files with a particular article.</p><p>Rather than bundling all of this functionality into our <code class="literal">FileController</code> that we'll be building, we'll start by building three different components to handle the various aspects of uploading a file. The first class <code class="literal">File</code> will represent a <code class="literal">$_FILES['file']</code> object and will provide the functionality for saving the file. The second class, <code class="literal">FileUpload</code>, will be our call point for uploading our file and will return the appropriate database to us. The final class, <code class="literal">FileUploader</code>, will handle the interactions between the <code class="literal">File</code> and <code class="literal">FileUpload</code> class. These three classes will ensure that our <code class="literal">FileController</code> class is clean and will<a id="id669" class="indexterm"/> make working with the file upload extremely easy.</p><div class="section" title="Creating the File class"><div class="titlepage"><div><div><h2 class="title"><a id="ch07lvl2sec122"/>Creating the File class</h2></div></div></div><p>We'll start<a id="id670" class="indexterm"/> by creating the <code class="literal">File</code> class, a simple<a id="id671" class="indexterm"/> object that represents <code class="literal">$_FILES['file']</code>, that we'll be sending via a <code class="literal">POST</code> request. Create the <code class="literal">File.php</code> file in <code class="literal">protected/modules/dashboard/components/</code>:</p><div class="informalexample"><pre class="programlisting">&lt;?php

class File {
    public function save($path)
    {
        if (!move_uploaded_file($_FILES['file']['tmp_name'], $path))
            return false;

        return true;
    }

    public function __get($name)
    {
        if (isset($_FILES['file'][$name]))
            return $_FILES['file'][$name];

        return NULL;
    }
}</pre></div><p>For simplicity, we'll be storing all of our files in the root directory of our main application called <code class="literal">/uploads</code>. Go ahead and create this folder now, and make sure that your web server has write access to it.</p></div><div class="section" title="Creating the FileUploader class"><div class="titlepage"><div><div><h2 class="title"><a id="ch07lvl2sec123"/>Creating the FileUploader class</h2></div></div></div><p>The next <a id="id672" class="indexterm"/>class we'll be building out is the <code class="literal">FileUploader</code> class. This <a id="id673" class="indexterm"/>class will handle the validation and will call the <code class="literal">File</code> class that we just created in order to save the file to the uploads directory. The steps are as follows:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Start with the class definition in <code class="literal">FileUploader.php</code> located at <code class="literal">protected/modules/dashboard/components/</code>:<div class="informalexample"><pre class="programlisting">&lt;?php class FileUploader {}</pre></div></li><li class="listitem">Then, define <a id="id674" class="indexterm"/>some private attributes <a id="id675" class="indexterm"/>to be used as validators:<div class="informalexample"><pre class="programlisting">private $allowedExtensions = array(
    'png',
    'jpeg',
    'jpg',
    'gif',
    'bmp'
);

private $sizeLimit = 10485760;

private $file;</pre></div></li><li class="listitem">Next, we'll create a constructor for this new object that will set some basic variables for the validator later on and will also create the <code class="literal">File</code> object using the <code class="literal">$_FILES['file']</code> array:<div class="informalexample"><pre class="programlisting">function __construct(array $allowedExtensions = array(), $sizeLimit = 10485760)
{
    $allowedExtensions = array_map("strtolower", $allowedExtensions);

    If (!empty($allowedExtensions))
        $this-&gt;allowedExtensions = $allowedExtensions;
    $this-&gt;sizeLimit = $sizeLimit;

    $this-&gt;checkServerSettings();

    $this-&gt;file = false;
    if (isset($_FILES['file']))
       $this-&gt;file = new File();
}</pre></div></li><li class="listitem">Next, we'll create the <code class="literal">checkServerSettings()</code> method that we defined earlier. This will ensure that we don't try to upload files that are larger than what is defined in our <code class="literal">php.ini</code> file:<div class="informalexample"><pre class="programlisting">private function checkServerSettings()
{
    $postSize = $this-&gt;toBytes(ini_get('post_max_size'));
    $uploadSize = $this-&gt;toBytes(ini_get('upload_max_filesize'));

    if ($postSize &lt; $this-&gt;sizeLimit || $uploadSize &lt; $this-&gt;sizeLimit){
        $size = max(1, $this-&gt;sizeLimit / 1024 / 1024) . 'M';
        $json = CJSON::encode(array(
            'error' =&gt; 'increase post_max_size and upload_max_filesize'
        ));
        die($json);
    }
}</pre></div></li><li class="listitem">Finally, we'll <a id="id676" class="indexterm"/>create the validators that will <a id="id677" class="indexterm"/>validate that the file meets the restrictions we put in place earlier. This class will ultimately return an array to our <code class="literal">FileUpload</code> class that we'll be creating next:<div class="informalexample"><pre class="programlisting">private function toBytes($str)
{
    $val = trim($str);
    $last = strtolower($str[strlen($str)-1]);
    switch($last)
    {
        case 'g': $val *= 1024;
        case 'm': $val *= 1024;
        case 'k': $val *= 1024;
    }
    return $val;
}

public function handleUpload($uploadDirectory, $replaceOldFile = FALSE)
{
    if (!is_writable($uploadDirectory))
        return array('error' =&gt; "Server error. Upload directory isn't writable.");
    
    if (!$this-&gt;file)
        return array('error' =&gt; 'No files were uploaded.');
    
    $size = $this-&gt;file-&gt;size;

    if ($size == 0)
        return array('error' =&gt; 'File is empty');
    
    $pathinfo = pathinfo($this-&gt;file-&gt;name);
    $filename = $pathinfo['filename'];

    //$filename = md5(uniqid());
    $ext = $pathinfo['extension'];

    if(!in_array(strtolower($ext), $this-&gt;allowedExtensions))
    {
        $these = implode(', ', $this-&gt;allowedExtensions);
        return array('error' =&gt;"File has an invalid extension");
    }

    $filename = 'upload-'.md5($filename);

   if(!$replaceOldFile)
    {
        /// don't overwrite previous files that were uploaded
        while (file_exists($uploadDirectory . $filename . '.' . $ext))
            $filename .= rand(10, 99);
    }
   
    if ($this-&gt;file-&gt;save($uploadDirectory . $filename . '.' . $ext))
        return array('success'=&gt;true,'filename'=&gt;$filename.'.'.$ext);
    else
        return array('error'=&gt; 'Could not save uploaded file. The upload was cancelled, or server error encountered');
}</pre></div></li></ol></div></div><div class="section" title="Creating the FileUpload class"><div class="titlepage"><div><div><h2 class="title"><a id="ch07lvl2sec124"/>Creating the FileUpload class</h2></div></div></div><p>The last <a id="id678" class="indexterm"/>component that we'll create is the <code class="literal">FileUpload</code> class<a id="id679" class="indexterm"/> that will act as an intermediary between our <code class="literal">FileUploader</code> class and our <code class="literal">FileController</code> class:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Begin by creating the <code class="literal">FileUpload.php</code> file in <code class="literal">protected/modules/dashboard/components/</code> with the following definition:<div class="informalexample"><pre class="programlisting">&lt;?php class FileUpload {}</pre></div></li><li class="listitem">Then, declare a few properties and the constructor:<div class="informalexample"><pre class="programlisting">private $_id = NULL;

private $_response = NULL;

public $_result = array();

public function __construct($id)
{
   $this-&gt;_id = $id;
    $this-&gt;_uploadFile();
}</pre></div></li><li class="listitem">We'll then create our <code class="literal">_uploadFile()</code> method that we called in our constructor. This method will instantiate a <code class="literal">FileUploader</code> object and will perform the upload before passing it off to our <code class="literal">ContentMetadata</code> object, where we'll store the reference to the file:<div class="informalexample"><pre class="programlisting">private function _uploadFile()
{
    $path = '/';
    $folder = Yii::app()-&gt;getBasePath() .'/../uploads' . $path;

    $sizeLimit = Yii::app()-&gt;params['max_fileupload_size'];
    $allowedExtensions = array('jpg', 'jpeg', 'png', 'gif', 'bmp');
    $uploader = new FileUploader($allowedExtensions, $sizeLimit);

    $this-&gt;_result = $uploader-&gt;handleUpload($folder);

    if (isset($this-&gt;_result['error']))
        throw new CHttpException(500, $this-&gt;_result['error']);
    return $this-&gt;_handleResourceUpload('/uploads/' . $this-&gt;_result['filename']);
}</pre></div></li><li class="listitem">Finally, we'll <a id="id680" class="indexterm"/>create the <code class="literal">_handleResourceUpload()</code> method. This method will take the response object<a id="id681" class="indexterm"/> returned by the <code class="literal">FileUploader</code> object and, if the file was successfully uploaded, will store the filename of the uploaded file in our database so that we can manage it easily. It will also link a particular file to a given article:<div class="informalexample"><pre class="programlisting">private function _handleResourceUpload($value)
{
  if ($this-&gt;_result['success'] == true)
    {
        $meta = ContentMetadata::model()-&gt;findbyAttributes(array('content_id' =&gt; $this-&gt;_id, 'key' =&gt; $this-&gt;_result['filename']));

        if ($meta == NULL)
            $meta = new ContentMetadata;

        $meta-&gt;content_id = $this-&gt;_id;
        $meta-&gt;key = $this-&gt;_result['filename'];
        $meta-&gt;value = $value;
        if ($meta-&gt;save())
        {
            $this-&gt;_result['filepath'] = $value;
            return $this-&gt;_result;
        }
        else
            throw new CHttpException(400,  'Unable to save uploaded image.');
    }
    else
    {
        return htmlspecialchars(CJSON::encode($this-&gt;_result), ENT_NOQUOTES);
        throw new CHttpException(400, $this-&gt;_result['error']);
    }
}</pre></div></li></ol></div></div><div class="section" title="Creating the controller for the file manager"><div class="titlepage"><div><div><h2 class="title"><a id="ch07lvl2sec125"/>Creating the controller for the file manager</h2></div></div></div><p>Now <a id="id682" class="indexterm"/>that we have the functionality in place to upload a file, we need to<a id="id683" class="indexterm"/> create the controller actions to manage it. We'll be creating three separate actions: an <code class="literal">index</code> action where all files and their associations can be viewed; a <code class="literal">delete</code> action; and an <code class="literal">upload</code> action. The steps are as follows:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Begin by creating the <code class="literal">FileController</code> class in <code class="literal">protected/modules/dashboard/controllers</code> with the following definition:<div class="informalexample"><pre class="programlisting">&lt;?php class FileController extends DashboardController {}</pre></div></li><li class="listitem">We'll then define the <code class="literal">accessRules()</code> method:<div class="informalexample"><pre class="programlisting">public function accessRules()
{
   return CMap::mergeArray(parent::accessRules(), array(
      array('allow',
         'actions' =&gt; array('index', 'upload', 'delete'),
         'users'=&gt;array('@'),
         'expression' =&gt; 'Yii::app()-&gt;user-&gt;role==2'
      ),
      array('deny',  // deny all users
         'users'=&gt;array('*'),
      )
   ));
}</pre></div></li><li class="listitem">Next, we'll define our <code class="literal">index</code> action that will allow us to view all files uploaded into our CMS. Since our <code class="literal">ContentMetadata</code> table might contain other attributes, we'll only be searching against items that have a key of upload:<div class="informalexample"><pre class="programlisting">public function actionIndex()
{
   $model = new ContentMetadata('search');
   $model-&gt;unsetAttributes();
   $model-&gt;key = 'upload';

   if (isset($_GET['ContentMetadata']))
      $model-&gt;attributes = $_GET;

   $this-&gt;render('index', array(
      'model' =&gt; $model
   ));
}</pre></div></li><li class="listitem">Then, we'll create an <code class="literal">upload </code>action that will call our <code class="literal">FileUpload</code> class. After <a id="id684" class="indexterm"/>uploading the file or having an error, the action will<a id="id685" class="indexterm"/> redirect the user to where they came from with either the relative URI to the file, or a useful error message generated from our <code class="literal">FileUploader</code> class:<div class="informalexample"><pre class="programlisting">public function actionUpload($id = NULL)
{
   if ($id == NULL)
      throw new CHttpException(400, 'Missing ID');

   if (isset($_FILES['file']))
   {
      $file = new FileUpload($id);

      if ($file-&gt;_result['success'])
         Yii::app()-&gt;user-&gt;setFlash('info', 'The file uploaded to ' . $file-&gt;_result['filepath']);
      elseif ($file-&gt;_result['error'])
         Yii::app()-&gt;user-&gt;setFlash('error', 'Error: ' . $file-&gt;_result['error']);
      
   }
   else
      Yii::app()-&gt;user-&gt;setFlash('error', 'No file detected');

   $this-&gt;redirect($this-&gt;createUrl('/dashboard/default/save?id='.$id));
}</pre></div></li><li class="listitem">Then we'll create a <code class="literal">loadModel()</code> method and a <code class="literal">delete</code> action to remove files from our database:<div class="informalexample"><pre class="programlisting">public function actionDelete($id)
{
   if ($this-&gt;loadModel($id)-&gt;delete())
   {
      Yii::app()-&gt;user-&gt;setFlash('info', 'File has been deleted');
      $this-&gt;redirect($this-&gt;createUrl('/dashboard/file/index'));
   }

   throw new CHttpException(500, 'The server failed to delete the requested file from the database. Please retry');
}

private function loadModel($id=NULL)
{
   if ($id == NULL)
      throw new CHttpException(400, 'Missing ID');

   $model = ContentMetadata::model()-&gt;findByAttributes(array('id' =&gt; $id));
   if ($model == NULL)
      throw new CHttpException(400, 'Object not found');

   return $model;
}</pre></div></li><li class="listitem">We'll then<a id="id686" class="indexterm"/> move on to creating the views for our file<a id="id687" class="indexterm"/> manager. The first view we'll create will be an index view, which will consist of a <code class="literal">CListView</code> container that will allow us to easily browse through our images. Add the following to <code class="literal">index.php</code> located at <code class="literal">protected/modules/dashboard/views/file/</code>:<div class="informalexample"><pre class="programlisting">&lt;?php $this-&gt;widget('zii.widgets.CListView', array(
    'dataProvider'=&gt;$model-&gt;search(),
    'itemView'=&gt;'_file',
));</pre></div></li><li class="listitem">We'll also create the corresponding <code class="literal">itemView</code> file called <code class="literal">_file.php</code> located at<code class="literal"> protected/modules/dashboard/views/file/</code>:<div class="informalexample"><pre class="programlisting">&lt;div class="file"&gt;
   &lt;a href="&lt;?php echo $data-&gt;value; ?&gt;"&gt;&lt;img src="&lt;?php echo $data-&gt;value; ?&gt;" style="width: 150px; height: 150px;"/&gt;&lt;/a&gt;
   &lt;?php echo CHtml::link('Article ID: '. $data-&gt;content_id, $this-&gt;createUrl('/dashboard/default/save', array('id' =&gt; $data-&gt;content_id))); ?&gt;
   &lt;?php echo CHtml::link('Delete', $this-&gt;createUrl('/dashboard/file/delete', array('id' =&gt; $data-&gt;id)), array('class' =&gt; 'btn btn-danger')); ?&gt;
&lt;/div&gt;</pre></div></li><li class="listitem">Finally, we'll <a id="id688" class="indexterm"/>need to update <code class="literal">save.php</code> at <code class="literal">protected/modules/dashboard/views/default/</code> with a file upload form so<a id="id689" class="indexterm"/> that files can be uploaded:<div class="informalexample"><pre class="programlisting">&lt;?php if (!$model-&gt;isNewRecord): ?&gt;
    &lt;hr /&gt;
    &lt;?php $form=$this-&gt;beginWidget('CActiveForm', array(
        'id'=&gt;'file-upload-form',
        'action' =&gt; $this-&gt;createUrl('/dashboard/file/upload', array('id' =&gt; $model-&gt;id)),
        'htmlOptions' =&gt; array(
            'class' =&gt; 'form-horizontal',
            'role' =&gt; 'form',
            'enctype'=&gt;'multipart/form-data'
            
        )
    )); ?&gt;
        &lt;div class="form-group"&gt;
            &lt;div class="col-sm-10"&gt;
                &lt;input type="file" name="file" /&gt;
            &lt;/div&gt;
        &lt;/div&gt;

        &lt;div class="row buttons"&gt;
            &lt;?php echo CHtml::submitButton('Upload file', array('class' =&gt; 'btn btn-primary pull-right col-md-offset-1')); ?&gt;
        &lt;/div&gt;

    &lt;?php $this-&gt;endWidget(); ?&gt;
&lt;?php endif; ?&gt;</pre></div></li></ol></div><p>Now, if you upload a file from the content save screen, the URL of the file will be returned back to you for you to add it to your article:</p><div class="mediaobject"><img src="graphics/7734OS_07_07.jpg" alt="Creating the controller for the file manager"/></div><p>Additionally, if <a id="id690" class="indexterm"/>you want to view all files uploaded to the CMS, or if <a id="id691" class="indexterm"/>you want to delete a file, you can navigate to <code class="literal">http://chapter7.example.com/dashboard/files</code> in your web browser or add a link to the sidebar in your <code class="literal">default.php</code> file at <code class="literal">protected/modules/dashboard/views/layouts/</code>, as shown in the following screenshot:</p><div class="mediaobject"><img src="graphics/7734OS_07_08.jpg" alt="Creating the controller for the file manager"/></div></div></div>
<div class="section" title="Strategies for deploying our application"><div class="titlepage"><div><div><h1 class="title"><a id="ch07lvl1sec67"/>Strategies for deploying our application</h1></div></div></div><p>The last topic we should discuss is how we want to deploy our new module alongside our application. There are several different deployment strategies that we can make use of, each of <a id="id692" class="indexterm"/>which has its own advantages and disadvantages. In the next section, we'll go over the benefits and downfalls of a few different strategies. When the time comes to deploy your module alongside your application, be sure to give careful thought to how you want your module and application to be integrated.</p><div class="section" title="Deploying as the application"><div class="titlepage"><div><div><h2 class="title"><a id="ch07lvl2sec126"/>Deploying as the application</h2></div></div></div><p>The<a id="id693" class="indexterm"/> simplest deployment strategy we can use is to simply commit our module's source code directly to our main application. When the time comes to deploy our application, our module is automatically included. While incredibly simple and basic, this strategy has several disadvantages.</p><p>First and<a id="id694" class="indexterm"/> foremost, it binds the state of our module to our application, which makes it more likely that we'll unintentionally introduce bugs or incomplete features when we deploy our application. The second disadvantage is that it tightly couples our module's state at any given time to our application. The final disadvantage is that it makes it very difficult to deploy a module update independently of our application.</p></div><div class="section" title="Deploying as a submodule"><div class="titlepage"><div><div><h2 class="title"><a id="ch07lvl2sec127"/>Deploying as a submodule</h2></div></div></div><p>The second deployment strategy is to commit our module code to a completely separate repository<a id="id695" class="indexterm"/> and include it in our project as a submodule. This method not only ensures that our project retrieves the latest code, but it also ensures that our module code and application code are properly separated. The alternative to using a submodule is to simply clone the module repository into the <code class="literal">protected/modules</code> directory every time we want to run a deployment. While this method is simple, it does increase the complexity of our application and requires us to have a detailed understanding of Git submodules. Additionally, it is difficult to automate while ensuring that deployments don't result in downtime.</p></div><div class="section" title="Deploying as a Composer dependency"><div class="titlepage"><div><div><h2 class="title"><a id="ch07lvl2sec128"/>Deploying as a Composer dependency</h2></div></div></div><p>A third <a id="id696" class="indexterm"/>strategy is to create a completely separate repository for our module, include it into our project as a Composer dependency, and use the <code class="literal">composer/installers</code> package to ensure that the module is placed in the correct directory. While it is significantly more complex than the other strategies, this strategy has the advantage of ensuring that our module and application code remain separated. It also has the advantage of moving deployment-related tasks back to the application rather than the module.</p></div></div>
<div class="section" title="Summary"><div class="titlepage"><div><div><h1 class="title"><a id="ch07lvl1sec68"/>Summary</h1></div></div></div><p>We covered a lot of information on working with modules and overcoming some of the limitations that they have. We discussed how to create a module, how to integrate it with our application, how to handle custom routing for modules, how to migrate the management functionality from a regular Yii application into our module, and we also added a file manager and upload capabilities to our CMS. Additionally, we covered different strategies for deploying our module alongside our application.</p><p>In the next chapter, we will create an API module for our application that will allow for web services and native applications to connect to our CMS. We'll expand upon the topics covered in this chapter, and we'll also cover how we can override several core Yii components to make our API flexible and easy to develop with.</p><p>Before continuing to the next chapter, be sure to review the Yii Class Reference at <a class="ulink" href="http://www.yiiframework.com/doc/api/">http://www.yiiframework.com/doc/api/</a> and review all the classes that we used in this chapter.</p></div></body></html>