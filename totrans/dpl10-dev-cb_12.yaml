- en: '12'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '12'
- en: Building APIs with Drupal
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Drupal构建API
- en: Drupal 10 comes with several awesome features to help facilitate building out
    RESTful APIs using the core Serialization and JSON:API modules. These enable you
    to build headless and/or decoupled solutions that can still interact with and
    query for data in Drupal.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: Drupal 10自带了一些很棒的功能，可以帮助您使用核心序列化和JSON:API模块构建RESTful API。这些功能使您能够构建无头和/或解耦的解决方案，同时仍然可以与Drupal交互并查询数据。
- en: 'In this chapter, we will look at how to do the following:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将探讨以下内容：
- en: Fetching data from Drupal using JSON:API ([https://jsonapi.org/](https://jsonapi.org/))
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用JSON:API从Drupal获取数据 ([https://jsonapi.org/](https://jsonapi.org/))
- en: Using POST to create data with JSON:API
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用POST和JSON:API创建数据
- en: Using PATCH to update data with JSON:API
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用PATCH和JSON:API更新数据
- en: Using DELETE to remove data with JSON:API
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用DELETE和JSON:API删除数据
- en: Using Views to provide custom data sources
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用视图提供自定义数据源
- en: Using OAuth methods
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用OAuth方法
- en: The Serialization module provides a means of serializing data to or deserializing
    from formats such as JSON and XML. The RESTful Web Services module then exposes
    entities and other resource types through web APIs. Operations done over RESTful
    resource endpoints use the same create, edit, delete, and view permissions that
    would be used in a non-API context. The JSON:API module exposes your data entities
    (nodes, taxonomy, media, and users) in JSON representation on API routes. We will
    also cover how to handle custom authentication for your API.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: '序列化模块提供了一种将数据序列化到或从JSON和XML等格式反序列化的方法。RESTful Web Services模块随后通过Web API公开实体和其他资源类型。在RESTful资源端点执行的运算使用与在非API环境中相同的创建、编辑、删除和查看权限。JSON:API模块在API路由上以JSON表示形式公开您的数据实体（节点、分类法、媒体和用户）。我们还将介绍如何处理API的自定义认证。 '
- en: Technical requirements
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'All of the APIs in this chapter operate over HTTP. An HTTP response code is
    returned, regardless of whether the request was successful or not. If you are
    not familiar with HTTP response codes or just need to brush up on them, you can
    review them here: [https://developer.mozilla.org/en-US/docs/Web/HTTP/Status](https://developer.mozilla.org/en-US/docs/Web/HTTP/Status).
    You will see plenty of HTTP response codes when working with the APIs in Drupal,
    so it is a good idea to review them. You can find the full code used in this chapter
    on GitHub: [https://github.com/PacktPublishing/Drupal-10-Development-Cookbook/tree/main/chp12](https://github.com/PacktPublishing/Drupal-10-Development-Cookbook/tree/main/chp12)'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中的所有API都通过HTTP操作。无论请求是否成功，都会返回HTTP响应代码。如果您不熟悉HTTP响应代码或只是需要复习它们，可以在此处查看：[https://developer.mozilla.org/en-US/docs/Web/HTTP/Status](https://developer.mozilla.org/en-US/docs/Web/HTTP/Status)。当您使用Drupal中的API时，您将看到大量的HTTP响应代码，因此复习它们是个好主意。您可以在GitHub上找到本章中使用的完整代码：[https://github.com/PacktPublishing/Drupal-10-Development-Cookbook/tree/main/chp12](https://github.com/PacktPublishing/Drupal-10-Development-Cookbook/tree/main/chp12)
- en: Fetching data from Drupal using JSON:API
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用JSON:API从Drupal获取数据
- en: With just a few clicks, we can open up and expose data from Drupal to consume
    from external services. This will enable us to ask Drupal for data and return
    it to us in JSON, making it easy to consume.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 只需几步点击，我们就可以打开并公开Drupal中的数据，以便外部服务消费。这将使我们能够请求Drupal中的数据，并以JSON格式返回，使其易于消费。
- en: Getting ready
  id: totrans-15
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'First, we need to enable some core modules. Head to **Admin** | **Extend**
    and enable the following:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要启用一些核心模块。前往**管理** | **扩展**并启用以下模块：
- en: '**HTTP** **Basic Authentication**'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**HTTP** **基本认证**'
- en: '**JSON:API**'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**JSON:API**'
- en: '**RESTful** **Web Services**'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**RESTful** **Web Services**'
- en: '**Serialization**:'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**序列化**：'
- en: '![Figure 12.1 – Enabling the necessary modules in Drupal](img/Figure_12.1_B18548.jpg)'
  id: totrans-21
  prefs: []
  type: TYPE_IMG
  zh: '![图12.1 – 在Drupal中启用必要的模块](img/Figure_12.1_B18548.jpg)'
- en: Figure 12.1 – Enabling the necessary modules in Drupal
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.1 – 在Drupal中启用必要的模块
- en: The JSON:API module users the Serialization module to handle the normalization
    of a response and denormalization of data from requests. Endpoints support specific
    formats (JSON, XML, and so on), and authentication providers support passing authentication
    in the headers of requests.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: JSON:API模块使用序列化模块来处理响应的规范化以及从请求中数据的反规范化。端点支持特定的格式（JSON、XML等），并且认证提供者支持在请求头中传递认证信息。
- en: Important note
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: 'Note that at the time of writing, multilingual support is still being finalized
    under JSON:API. You can track the status of this issue here: [https://www.drupal.org/project/drupal/issues/2794431](https://www.drupal.org/project/drupal/issues/2794431).'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，在撰写本文时，多语言支持仍在 JSON:API 下进行最终确定。您可以通过此处跟踪此问题的状态：[https://www.drupal.org/project/drupal/issues/2794431](https://www.drupal.org/project/drupal/issues/2794431)。
- en: How to do it…
  id: totrans-26
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点……
- en: 'You will have a new area in the **Configuration** section of the Drupal admin
    area called **JSON:API**:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 您将在 Drupal 管理区域的 **配置** 部分中看到一个名为 **JSON:API** 的新区域：
- en: '![Figure 12.2 – JSON:API adds a new configuration section of the Drupal admin
    area](img/Figure_12.2_B18548.jpg)'
  id: totrans-28
  prefs: []
  type: TYPE_IMG
  zh: '![图 12.2 – JSON:API 为 Drupal 管理区域添加了一个新的配置部分](img/Figure_12.2_B18548.jpg)'
- en: Figure 12.2 – JSON:API adds a new configuration section of the Drupal admin
    area
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 图 12.2 – JSON:API 为 Drupal 管理区域添加了一个新的配置部分
- en: 'JSON:API does not provide many settings out of the box beyond two security
    settings. One allows only read endpoints, while the other allows **create, read,
    update, delete** (**CRUD**) operations on endpoints:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: JSON:API 默认提供的设置不多，除了两个安全设置之外。一个允许只有读取端点，而另一个允许在端点上执行 **创建、读取、更新、删除** （**CRUD**）
    操作：
- en: '![Figure 12.3 – Configuration options for JSON:API](img/Figure_12.3_B18548.jpg)'
  id: totrans-31
  prefs: []
  type: TYPE_IMG
  zh: '![图 12.3 – JSON:API 的配置选项](img/Figure_12.3_B18548.jpg)'
- en: Figure 12.3 – Configuration options for JSON:API
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 12.3 – JSON:API 的配置选项](img/Figure_12.3_B18548.jpg)'
- en: Leave the default as-is for now. Create a new `Basic Page` node and save it.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 目前请保持默认设置。创建一个新的 `基本页面` 节点并保存。
- en: 'Then, go to this URL (replace `localhost` with your local site domain):'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，转到此 URL（将 `localhost` 替换为您的本地站点域名）：
- en: '[PRE0]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Drupal will respond with a JSON:API representation of all `Basic Page` nodes
    in your site:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: Drupal 将以 JSON:API 的形式响应您网站中所有 `基本页面` 节点的信息：
- en: '![Figure 12.4 – A sample JSON:API response from Drupal](img/Figure_12.4_B18548.jpg)'
  id: totrans-37
  prefs: []
  type: TYPE_IMG
  zh: '![图 12.4 – Drupal 的一个示例 JSON:API 响应](img/Figure_12.4_B18548.jpg)'
- en: Figure 12.4 – A sample JSON:API response from Drupal
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 12.4 – Drupal 的一个示例 JSON:API 响应](img/Figure_12.4_B18548.jpg)'
- en: If you wanted to fetch a specific node by ID, you can use the `filter` keyword
    in the request URL as a query parameter.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想通过 ID 获取特定的节点，您可以在请求 URL 中使用 `filter` 关键字作为查询参数。
- en: 'The format for `filter` is `filter[attribute]`. Following that, we can fetch
    a node with an ID of 1 by requesting this URL in the browser:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: '`filter` 的格式为 `filter[attribute]`。在此之后，我们可以通过在浏览器中请求此 URL 来获取 ID 为 1 的节点：'
- en: '[PRE1]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'You will get the same response you got in the first example, but now, the `data`
    array in the response will contain `only` the node matching ID 1\. This works
    for any attribute you want to filter by. If you know an entity’s UUID, you can
    also request it directly by using it as a parameter:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 您将得到与第一个示例相同的响应，但现在，响应中的 `data` 数组将只包含匹配 ID 1 的节点。这适用于您想要按任何属性筛选的任何属性。如果您知道实体的
    UUID，您也可以直接通过将其用作参数来请求它：
- en: '[PRE2]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'By passing the UUID as a URL parameter, you would get that specific `Basic
    Page` node type’s node information. Create a few more `Basic Page` nodes using
    the word `Test` in the title. Suppose you wanted to filter by nodes containing
    the word `Test` in the title; you could request this like so:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 通过将 UUID 作为 URL 参数传递，您将获得特定 `基本页面` 节点类型的节点信息。使用标题中的单词 `Test` 创建更多 `基本页面` 节点。假设您想按标题中包含单词
    `Test` 的节点进行筛选；您可以像这样请求：
- en: '[PRE3]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Drupal will only return nodes with the word “Test” in the title. Here, we also
    added `&fields[node—page]=title` to the request to make the response easier to
    see:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: Drupal 只会返回标题中包含单词 “Test” 的节点。在这里，我们还添加了 `&fields[node—page]=title` 到请求中，以便更容易看到响应：
- en: '![Figure 12.5 – A filtered JSON:API response from Drupal](img/Figure_12.5_B18548.jpg)'
  id: totrans-47
  prefs: []
  type: TYPE_IMG
  zh: '![图 12.5 – Drupal 的一个筛选后的 JSON:API 响应](img/Figure_12.5_B18548.jpg)'
- en: Figure 12.5 – A filtered JSON:API response from Drupal
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 12.5 – Drupal 的一个筛选后的 JSON:API 响应](img/Figure_12.5_B18548.jpg)'
- en: 'If you prefer to use `cURL` instead, you can do the following:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想使用 `cURL` 而不是其他方式，可以这样做：
- en: '[PRE4]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: You can request this from any HTTP API in any language or command-line tool
    such as `cURL`, so long as your parameters and options are correct. Consult the
    appropriate documentation on using `fetch` ([https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API](https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API))
    in JavaScript, for example, to integrate this with a decoupled JavaScript application.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以从任何 HTTP API、任何语言或命令行工具（如 `cURL`）请求此内容，只要您的参数和选项正确。例如，请参阅使用 `fetch` ([https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API](https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API))
    的适当文档，以将其与解耦的 JavaScript 应用程序集成。
- en: 'curl: (60) SSL certificate problem'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 'curl: (60) SSL 证书问题'
- en: If you get an error about an SSL certificate problem with cURL, it is likely
    your SSL certificate could not be verified. This is common with local self-signed
    certificates. To get around this error in development, you can pass the `--insecure`
    flag with the cURL request mentioned previously. In production, make sure you
    have a valid working SSL certificate – do not use this flag for real-world applications.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您在cURL中遇到关于SSL证书问题的错误，那么很可能是您的SSL证书无法验证。这在本地自签名证书中很常见。为了在开发中绕过此错误，您可以在之前提到的cURL请求中传递`--insecure`标志。在生产中，请确保您有一个有效的正常工作的SSL证书
    – 不要在实际应用中使用此标志。
- en: JSON:API can also include related data in the response by asking for it with
    `include`. If we add `include` to the query parameter plus any relationship name
    under the relationships section of a JSON item, we receive them back with the
    JSON:API response.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: JSON:API还可以通过使用`include`来请求相关数据，将其包含在响应中。如果我们向查询参数添加`include`以及JSON项目关系部分下的任何关系名称，我们将在JSON:API响应中收到它们。
- en: 'If you want the node author information, for example, you can request it like
    so:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想获取节点作者信息，例如，您可以像这样请求它：
- en: '[PRE5]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'We will receive that information in the response:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在响应中收到以下信息：
- en: '![Figure 12.6 – A sample JSON:API response with the author data attached](img/Figure_12.6_B18548.jpg)'
  id: totrans-58
  prefs: []
  type: TYPE_IMG
  zh: '![图12.6 – 带有作者数据的示例JSON:API响应](img/Figure_12.6_B18548.jpg)'
- en: Figure 12.6 – A sample JSON:API response with the author data attached
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.6 – 带有作者数据的示例JSON:API响应
- en: Note that to view user data, the requesting user needs the `View user information`
    permission. You will get an **access denied** error otherwise.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，要查看用户数据，请求用户需要“查看用户信息”权限。否则，您将收到一个**访问拒绝**错误。
- en: Any item listed under **relationships** can be requested – for example, author
    data, taxonomy attached to returned entities, media attached to returned entities,
    or other types of related data.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 列在**关系**下的任何项目都可以请求 – 例如，作者数据、附加到返回实体的分类、附加到返回实体的媒体或其他类型的关联数据。
- en: Paginating, filtering, and sorting requests
  id: totrans-62
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 分页、过滤和排序请求
- en: Pagination is done by appending a page query parameter. To limit the request
    to 10 nodes, we must use `append ?page[limit]=10`. To access the next set of results,
    we must also pass `page[offset]=10`.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 分页是通过附加一个页面查询参数来完成的。要限制请求为10个节点，我们必须使用`append ?page[limit]=10`。要访问下一组结果，我们还必须传递`page[offset]=10`。
- en: 'The following is an example of returning the first and second pages of results:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个返回第一页和第二页结果的示例：
- en: '[PRE6]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Each request contains a link property; this will also contain the next and previous
    links when using a paginated result.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 每个请求都包含一个链接属性；当使用分页结果时，这还将包含下一页和上一页的链接。
- en: 'Filtering is done by appending a filter query parameter. The following is an
    example of requesting all nodes that have been promoted to the front page:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 过滤是通过附加一个过滤查询参数来完成的。以下是一个请求所有已提升到首页的节点的示例：
- en: '[PRE7]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Each filter is defined by a name – in the preceding example, it is promoted.
    The filter then takes `path`, which is the field to filter on. The value and operator
    decide how to filter.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 每个过滤器都由一个名称定义 – 在前面的示例中，它是提升。然后，过滤器获取`path`，即要过滤的字段。值和操作符决定了如何过滤。
- en: 'Sorting is the simplest operation to perform. Here, a `sort` query parameter
    is added. The field name value is the field to sort by; to sort in descending
    order, you must add a minus symbol in front of the field name. The following examples
    show how to sort by `nid` in ascending and descending order, respectively:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 排序是最简单的操作。在这里，添加了一个`sort`查询参数。字段名称值是要排序的字段；要按降序排序，必须在字段名称前添加一个减号。以下示例分别展示了如何按`nid`升序和降序排序：
- en: '[PRE8]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: How it works…
  id: totrans-72
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: 'The Serialization module in Drupal provides the necessary plumbing to normalize
    and denormalize data structures to and from formats such as JSON and XML. When
    requests are made to Drupal, the responsible route gets the resource and normalizes
    it to an array; then, a registered **encoder** (in this case, **JsonEncoder**)
    returns the data in the requested format (JSON, XML, and so on):'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: Drupal中的序列化模块提供了将数据结构从JSON和XML等格式进行归一化和反归一化的必要工具。当对Drupal发出请求时，负责的路由获取资源并将其归一化为一个数组；然后，一个注册的**编码器**（在这种情况下，**JsonEncoder**）以请求的格式（JSON、XML等）返回数据：
- en: '![Figure 12.7 – A high-level look at how serialization works in Drupal](img/Figure_12.7_B18548.jpg)'
  id: totrans-74
  prefs: []
  type: TYPE_IMG
  zh: '![图12.7 – 高级查看Drupal中序列化工作方式](img/Figure_12.7_B18548.jpg)'
- en: Figure 12.7 – A high-level look at how serialization works in Drupal
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.7 – 高级查看Drupal中序列化工作方式
- en: This is the backbone of the normalization and serialization of data in Drupal.
    When you enabled the `JSON:API` module, new routes were registered for resources
    under `/jsonapi/`. These dynamically generated routes automatically encode data
    and return it as JSON. Any time an entity is requested, the serializer and encoders
    are responsible for building the data for the response.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 这是Drupal中数据归一化和序列化的基础。当您启用`JSON:API`模块时，会在`/jsonapi/`下的资源注册新路由。这些动态生成的路由会自动编码数据并以JSON格式返回。每次请求实体时，序列化和编码器负责构建响应数据。
- en: There’s more…
  id: totrans-77
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: Installing the JSON:API Extras module
  id: totrans-78
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 安装JSON:API额外模块
- en: 'The JSON:API Extras module provides a user interface for additional customization.
    The JSON:API Extras module should be added to your Drupal installation like all
    other modules – that is, using Composer:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: JSON:API额外模块提供了一个用户界面进行额外定制。JSON:API额外模块应像所有其他模块一样添加到您的Drupal安装中 – 即，使用Composer：
- en: '[PRE9]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Once the module has been installed in Drupal, you will be able to enable or
    disable endpoints, change resource names, alter resource paths, disable fields,
    provide alias field names, and enhance field outputs of JSON:API routes.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦该模块在Drupal中安装，您将能够启用或禁用端点、更改资源名称、更改资源路径、禁用字段、提供别名字段名称以及增强JSON:API路由的字段输出。
- en: Changing the JSON:API path prefix
  id: totrans-82
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 更改JSON:API路径前缀
- en: The API path prefix can be changed from `jsonapi` to `api` or any other prefix
    using the Extras module.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 使用“额外模块”，可以将API路径前缀从`jsonapi`更改为`api`或其他任何前缀。
- en: 'From the administrative toolbar, navigate to **Configuration**. Under the **Web
    services** section, click on **JSON:API Overwrites** to customize the JSON:API
    implementation. The **Settings** tab allows you to modificy the API path prefix:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 从管理工具栏，导航到**配置**。在**网络服务**部分下，点击**JSON:API覆盖**来自定义JSON:API实现。**设置**选项卡允许您修改API路径前缀：
- en: '![Figure 12.8 – Using JSON:API Extras to change the JSON path prefix](img/Figure_12.9_B18548.jpg)'
  id: totrans-85
  prefs: []
  type: TYPE_IMG
  zh: '![图12.8 – 使用JSON:API额外功能更改JSON路径前缀](img/Figure_12.9_B18548.jpg)'
- en: Figure 12.8 – Using JSON:API Extras to change the JSON path prefix
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.8 – 使用JSON:API额外功能更改JSON路径前缀
- en: After changing **Path prefix**, clear the cache in Drupal to see the result
    and the new path.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 更改**路径前缀**后，请在Drupal中清除缓存以查看结果和新路径。
- en: Disabling and enhancing returned entity fields
  id: totrans-88
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 禁用和增强返回的实体字段
- en: The JSON:API Extras module allows you to overwrite endpoints automatically exposed
    by the JSON:API module. This allows you to disable fields from being returned.
    It also allows you to use enhancers to simplify the structure of a field property.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: JSON:API额外模块允许您覆盖JSON:API模块自动暴露的端点。这允许您禁用返回的字段。它还允许您使用增强器简化字段属性的架构。
- en: From the administrative toolbar, go to **Configuration**. Under the **Web services**
    section, click on **JSON:API Overwrites** to customize the JSON:API implementation.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 从管理工具栏，转到**配置**。在**网络服务**部分下，点击**JSON:API覆盖**来自定义JSON:API实现。
- en: 'To disable an endpoint, click on **Overwrite** on any endpoint. Check the **Disabled**
    checkbox to turn off that specific endpoint:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 要禁用端点，请点击任何端点的**覆盖**。勾选**禁用**复选框以关闭该特定端点：
- en: '![Figure 12.9 – You can disable resources with JSON:API Extras so that endpoints
    are not accessible](img/Figure_12.10_B18548.jpg)'
  id: totrans-92
  prefs: []
  type: TYPE_IMG
  zh: '![图12.9 – 使用JSON:API额外功能禁用资源，以便端点不可访问](img/Figure_12.10_B18548.jpg)'
- en: Figure 12.9 – You can disable resources with JSON:API Extras so that endpoints
    are not accessible
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.9 – 使用JSON:API额外功能禁用资源，以便端点不可访问
- en: 'To disable, alias, or use an enhancer, click on `POST`/`PATCH` requests:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 要禁用、别名或使用增强器，请点击`POST`/`PATCH`请求：
- en: '![Figure 12.10 – You can change field aliases and disable fields in JSON:API
    endpoints](img/Figure_12.11_B18548.jpg)'
  id: totrans-95
  prefs: []
  type: TYPE_IMG
  zh: '![图12.10 – 您可以在JSON:API端点中更改字段别名并禁用字段](img/Figure_12.11_B18548.jpg)'
- en: Figure 12.10 – You can change field aliases and disable fields in JSON:API endpoints
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.10 – 您可以在JSON:API端点中更改字段别名并禁用字段
- en: 'Here, we have disabled the revision fields from appearing in the JSON:API output.
    We can apply enhancers to the created and changed fields:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们已经禁用了修订字段在JSON:API输出中显示。我们可以对创建和更改的字段应用增强器：
- en: '![Figure 12.11 – Using enhancers to format data returned in JSON:API](img/Figure_12.12_B18548.jpg)'
  id: totrans-98
  prefs: []
  type: TYPE_IMG
  zh: '![图12.11 – 使用增强器格式化JSON:API返回的数据](img/Figure_12.12_B18548.jpg)'
- en: Figure 12.11 – Using enhancers to format data returned in JSON:API
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.11 – 使用增强器格式化JSON:API返回的数据
- en: In this example, the created and changed fields will no longer return Unix timestamps,
    but *RFC ISO* *8601*-formatted timestamps.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，创建和更改的字段将不再返回Unix时间戳，而是返回*RFC ISO* *8601*格式的时间戳。
- en: 'Going back and viewing our JSON:API route now, we can see that revision fields
    were removed and that the created and changed fields are formatted:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 回到并查看我们的JSON:API路由，我们可以看到修订字段已被删除，创建和更改的字段已格式化：
- en: '![Figure 12.12 – A JSON:API response customized by the JSON:API Extras module](img/Figure_12.13_B18548.jpg)'
  id: totrans-102
  prefs: []
  type: TYPE_IMG
  zh: '![图12.12 – 由JSON:API Extras模块定制的JSON:API响应](img/Figure_12.13_B18548.jpg)'
- en: Figure 12.12 – A JSON:API response customized by the JSON:API Extras module
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.12 – 由JSON:API Extras模块定制的JSON:API响应
- en: See also
  id: totrans-104
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: 'JSON and XML are not the only formats Drupal can return data in as a response.
    There are contributed modules that provide other data formats as well, such as
    PDF, CSV, and XLS (Excel) serialization. Check out the source code of these modules
    if you are curious as to how they work:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: JSON和XML并不是Drupal作为响应返回数据的唯一格式。还有一些贡献的模块提供了其他数据格式，例如PDF、CSV和XLS（Excel）序列化。如果您对它们的工作原理感到好奇，可以查看这些模块的源代码：
- en: 'PDF serialization: [https://www.drupal.org/project/pdf_serialization](https://www.drupal.org/project/pdf_serialization)'
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: PDF序列化：[https://www.drupal.org/project/pdf_serialization](https://www.drupal.org/project/pdf_serialization)
- en: 'CSV serialization: [https://www.drupal.org/project/csv_serialization](https://www.drupal.org/project/csv_serialization)'
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: CSV序列化：[https://www.drupal.org/project/csv_serialization](https://www.drupal.org/project/csv_serialization)
- en: 'Excel Serialization serialization: [https://www.drupal.org/project/xls_serialization](https://www.drupal.org/project/xls_serialization)'
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Excel序列化序列化：[https://www.drupal.org/project/xls_serialization](https://www.drupal.org/project/xls_serialization)
- en: Using POST to create data with JSON:API
  id: totrans-109
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用POST通过JSON:API创建数据
- en: An API that returns data is great, but to make a more functional decoupled app
    or integrate external services, we need to be able to send data into Drupal as
    well. After reading the following section, you will be able to create entities
    in a Drupal 10 application from remote sources.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 返回数据的API很棒，但为了创建更功能化的解耦应用或集成外部服务，我们还需要能够将数据发送到Drupal。阅读以下章节后，您将能够从远程源在Drupal
    10应用程序中创建实体。
- en: Getting ready
  id: totrans-111
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: We are going to use the `Article` content type that comes installed in the Drupal
    10 standard profile. If you do not have an `Article` content type, create one
    and add a basic field such as `Body`.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用在Drupal 10标准配置文件中预安装的`Article`内容类型。如果您没有`Article`内容类型，请创建一个并添加一个基本字段，例如`Body`。
- en: How to do it…
  id: totrans-113
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点…
- en: 'First, we need to tell Drupal to allow CRUD operations for JSON:API. Head back
    to the JSON:API settings page in the **Configuration** section of the Drupal admin
    and enable **Accept all JSON:API create, read, update, and** **delete operations.**:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要告诉Drupal允许对JSON:API进行CRUD操作。返回到Drupal管理中**配置**部分的JSON:API设置页面，并启用**接受所有JSON:API创建、读取、更新和**
    **删除操作**。：
- en: '![Figure 12.13 – Enabling JSON:API to allow more actions](img/Figure_12.14_B18548.jpg)'
  id: totrans-115
  prefs: []
  type: TYPE_IMG
  zh: '![图12.13 – 启用JSON:API以允许更多操作](img/Figure_12.14_B18548.jpg)'
- en: Figure 12.13 – Enabling JSON:API to allow more actions
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.13 – 启用JSON:API以允许更多操作
- en: If you do not enable this, you cannot do anything other than read data from
    a JSON:API endpoint.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您不启用此功能，您将无法执行除从JSON:API端点读取数据之外的操作。
- en: Next, create a user account that has only the necessary permissions to create
    an `Article` node. This is the account we will use in our requests to create new
    nodes. You should not use an administrator account in your APIs for security reasons.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，创建一个只有创建`Article`节点所需权限的用户账户。这是我们将在创建新节点请求中使用该账户。出于安全原因，您不应在API中使用管理员账户。
- en: With each request to create an API in Drupal, we need to authenticate before
    our request will be accepted.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 在Drupal中创建API的每个请求中，我们都需要在请求被接受之前进行身份验证。
- en: 'Open a terminal (command line). Unlike the previous section, we cannot perform
    these requests directly in the browser. For this, we are going to use `curl`,
    which comes pre-installed on many operating systems:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 打开终端（命令行）。与上一节不同，我们无法在浏览器中直接执行这些请求。为此，我们将使用`curl`，它在许多操作系统上都是预安装的：
- en: '[PRE10]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Again, remember to replace `localhost` with the correct hostname for your development
    site. We created a user named `chapter12` with a password of `chapter12` and set
    them as the `Content Editor` role (included with the Standard install profile),
    which has basic permissions to create and edit nodes. This user is passed in the
    `--``user` parameter.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 再次提醒，记得将`localhost`替换为你的开发站点的正确主机名。我们创建了一个名为`chapter12`的用户，密码为`chapter12`，并将其设置为`内容编辑`角色（包含在标准安装配置文件中），该角色具有创建和编辑节点的基本权限。此用户通过`--user`参数传递。
- en: 'The response will return either a successful or unsuccessful authorization
    response. If it succeeded, you will see a large JSON response reflecting the new
    node that was created, and you will see the new node in Drupal:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 响应将返回成功或失败的授权响应。如果成功，你将看到一个大的JSON响应，反映新创建的节点，你将在Drupal中看到新节点：
- en: '![Figure 12.14 – The node created by a POST request](img/Figure_12.15_B18548.jpg)'
  id: totrans-124
  prefs: []
  type: TYPE_IMG
  zh: '![图12.14 – 通过POST请求创建的节点](img/Figure_12.15_B18548.jpg)'
- en: Figure 12.14 – The node created by a POST request
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.14 – 通过POST请求创建的节点
- en: 'We can also see that it was correctly added to the body field, along with the
    text format we specified in the request:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以看到，它被正确地添加到了正文字段中，以及我们在请求中指定的文本格式：
- en: '![Figure 12.15 – Verifying that the content we passed in a POST request was
    created correctly](img/Figure_12.16_B18548.jpg)'
  id: totrans-127
  prefs: []
  type: TYPE_IMG
  zh: '![图12.15 – 验证我们通过POST请求传递的内容是否正确创建](img/Figure_12.16_B18548.jpg)'
- en: Figure 12.15 – Verifying that the content we passed in a POST request was created
    correctly
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.15 – 验证我们通过POST请求传递的内容是否正确创建
- en: 'If we look back at our JSON:API route in the browser, we will see this new
    node there as well:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们在浏览器中查看我们的JSON:API路由，我们也会在那里看到这个新节点：
- en: '![Figure 12.16 – Accessing the newly created node with an HTTP request](img/Figure_12.17_B18548.jpg)'
  id: totrans-130
  prefs: []
  type: TYPE_IMG
  zh: '![图12.16 – 使用HTTP请求访问新创建的节点](img/Figure_12.17_B18548.jpg)'
- en: Figure 12.16 – Accessing the newly created node with an HTTP request
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.16 – 使用HTTP请求访问新创建的节点
- en: How it works…
  id: totrans-132
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: In this instance, the JSON:API module in this instance is not doing anything
    extra concerning authentication or entity access. The request is processed by
    Drupal no differently than if the `chapter12` user came to the site, logged in,
    and created the node in the admin interface.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，本例中的JSON:API模块在身份验证或实体访问方面没有做任何额外的工作。请求的处理方式与`chapter12`用户来到网站，登录，并在管理界面中创建节点没有区别。
- en: 'The type of request is a `POST` request. This is different from the `GET` request
    in the first section for reading data. A `POST` is required to send data to the
    server. You can read more about `POST` request(s) on MDN: [https://developer.mozilla.org/en-US/docs/Web/HTTP/Methods/POST](https://developer.mozilla.org/en-US/docs/Web/HTTP/Methods/POST).'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 请求类型是`POST`请求。这与第一部分中用于读取数据的`GET`请求不同。发送数据到服务器需要使用`POST`请求。你可以在MDN上了解更多关于`POST`请求（s）的信息：[https://developer.mozilla.org/en-US/docs/Web/HTTP/Methods/POST](https://developer.mozilla.org/en-US/docs/Web/HTTP/Methods/POST)。
- en: This is a powerful abstraction that can help you build out APIs and decoupled
    applications as it requires valid user authentication, but it cannot perform any
    actions outside of the scope of what that user/user role is permitted to do. This
    means that if we were to remove the permission to `Create article nodes` for the
    Content Editor role, this `POST` request would fail with a `403` Forbidden response.
    Therefore, it is a good idea to create an `API User` role with limited permissions
    in the real world that you can toggle on or off at a moment’s notice.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个强大的抽象，可以帮助你构建API和解耦的应用程序，因为它需要有效的用户身份验证，但不能执行超出该用户/用户角色允许范围的任何操作。这意味着如果我们移除内容编辑角色的“创建文章节点”权限，这个`POST`请求将因为`403`禁止响应而失败。因此，在现实世界中创建一个具有有限权限的`API用户`角色是一个好主意，你可以随时打开或关闭它。
- en: '`Never` use the superuser (`user 1`) or user with the administrator role for
    API requests. If the credentials leak, a bad actor could perform any request they
    desire. After reading this chapter, it would be a good idea to review the security
    considerations when using APIs in Drupal on Drupal.org: [https://www.drupal.org/docs/core-modules-and-themes/core-modules/jsonapi-module/security-considerations](https://www.drupal.org/docs/core-modules-and-themes/core-modules/jsonapi-module/security-considerations).'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: '`永远`不要使用超级用户（`user 1`）或具有管理员角色的用户进行API请求。如果凭证泄露，恶意行为者可以执行他们想要的任何请求。在阅读本章后，回顾Drupal.org上使用API时的安全考虑因素会是一个好主意：[https://www.drupal.org/docs/core-modules-and-themes/core-modules/jsonapi-module/security-considerations](https://www.drupal.org/docs/core-modules-and-themes/core-modules/jsonapi-module/security-considerations)。'
- en: In the `curl` request, when we pass the `--user` parameter, it automatically
    creates the Authorization header for the request. This header passes along a basic
    authentication, which the Basic Auth module in Drupal intercepts and uses to authenticate
    the request.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 在`curl`请求中，当我们传递`--user`参数时，它将自动为请求创建一个授权头。此头传递了一个基本认证，Drupal中的Basic Auth模块会拦截并使用它来验证请求。
- en: 'Alternatively, you can get the basic auth token manually with the command line;
    for example:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，你可以使用命令行手动获取基本认证令牌；例如：
- en: '[PRE11]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'This returns `Y2hhcHRlcjEyOmNoYXB0ZXIxMg==`. Then, you can pass that in a header
    instead of using the `–user` parameter:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 这将返回`Y2hhcHRlcjEyOmNoYXB0ZXIxMg==`。然后，你可以将其作为标题而不是使用`–user`参数传递：
- en: '[PRE12]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: See also
  id: totrans-142
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: While powerful, **cURL** is a low-level tool that can be difficult to use from
    the command line for longer, larger requests. You can install Google’s Postman
    tool to make working with APIs easier. You can download it from [https://www.postman.com/](https://www.postman.com/).
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然**cURL**功能强大，但它是一个低级工具，对于更长时间、更大的请求，从命令行使用它可能会很困难。你可以安装Google的Postman工具来简化与API的工作。你可以从[https://www.postman.com/](https://www.postman.com/)下载它。
- en: Using PATCH to update data with JSON:API
  id: totrans-144
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用PATCH通过JSON:API更新数据
- en: Now that we know how to create some data in Drupal, let’s learn how to update
    existing data.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经知道了如何在Drupal中创建一些数据，让我们学习如何更新现有数据。
- en: How to do it…
  id: totrans-146
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: Our request will look similar to the `POST` request from the previous sections
    but with a few changes.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的要求将与前几节中的`POST`请求类似，但有一些变化。
- en: First, to update an entity in Drupal, you need to pass the entity UUID in the
    request payload for it to work. This is different than the numeric entity ID.
    You can get the UUID from fetching data from JSON:API, as we saw in the *Fetching
    data from Drupal using JSON:API* section. For the node that we created in our
    `POST` request, the UUID value is `1ddf244d-e8e6-40f5-be48-23bc8fa0fa3e`.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，为了在Drupal中更新一个实体，你需要将实体的UUID传递到请求负载中，这样它才能正常工作。这与数字实体ID不同。你可以从JSON:API获取数据来获取UUID，正如我们在*使用JSON:API从Drupal获取数据*部分所看到的。对于我们通过`POST`请求创建的节点，UUID值是`1ddf244d-e8e6-40f5-be48-23bc8fa0fa3e`。
- en: 'Let’s go ahead and change the title and body of the article node we created
    previously. This time, we must pass the UUID in the URL as well as the request
    body:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续更改我们之前创建的文章节点的标题和正文。这次，我们必须在URL以及请求体中传递UUID：
- en: '[PRE13]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Note that the `id` property is outside of the `attributes` data. If you try
    to pass it under `attributes`, you will get an `HTTP 422 Unprocessable Content`
    error. If you pass invalid attributes, you will receive a `500` error. What you
    are updating must match the data model to be successful.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，`id`属性位于`attributes`数据之外。如果你尝试将其放在`attributes`下，你会得到一个`HTTP 422 Unprocessable
    Content`错误。如果你传递无效的属性，你会收到一个`500`错误。你必须更新的内容必须与数据模型匹配才能成功。
- en: 'After submitting this request, we get the updated node back in JSON format
    on the command line, and we will see in Drupal that our updates were applied:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 提交此请求后，我们将在命令行以JSON格式收到更新后的节点，我们将在Drupal中看到我们的更新已被应用：
- en: '![Figure 12.17 – Reviewing a node that was updated using a PATCH request](img/Figure_12.18_B18548.jpg)'
  id: totrans-153
  prefs: []
  type: TYPE_IMG
  zh: '![图12.17 – 使用PATCH请求更新节点的审查](img/Figure_12.18_B18548.jpg)'
- en: Figure 12.17 – Reviewing a node that was updated using a PATCH request
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.17 – 使用PATCH请求更新节点的审查
- en: What if we wanted to attribute the node to another user? It is a good idea to
    use an account solely to handle API actions, but we certainly don’t want all content
    attributed to that user.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想要将节点归因于另一个用户怎么办？使用一个仅用于处理API操作的账户是个好主意，但我们当然不希望所有内容都归因于该用户。
- en: For example, assume you have an external publishing platform where users are
    submitting content. When content is published, that system makes a `POST` request
    to Drupal so that the content is created. Let’s attribute that content to a user
    in Drupal named `Johnny Editor` with a UUID of `c1ce9fe6-4eea-4f69-92c2-883415019002`.
    Like nodes, you can view user entity data at `/jsonapi/user/user`.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，假设你有一个外部发布平台，用户正在提交内容。当内容发布时，该系统会向Drupal发送一个`POST`请求，以便创建内容。让我们将内容归因于一个名为`Johnny
    Editor`的Drupal用户，其UUID为`c1ce9fe6-4eea-4f69-92c2-883415019002`。像节点一样，你可以在`/jsonapi/user/user`查看用户实体数据。
- en: We can fix the existing content with a `PATCH` request and change the author
    from the `chapter12` user to the `Johnny Editor` user by passing `relationships`
    data in the request body. Before we can do that, though, our API user role needs
    `PATCH` the data. Go ahead and enable that permission.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用`PATCH`请求来修复现有内容，并将作者从`chapter12`用户更改为`Johnny Editor`用户，通过在请求体中传递`relationships`数据来实现。不过，在我们能够这样做之前，我们的API用户角色需要`PATCH`数据。现在，请启用这个权限。
- en: This is because, in this example, we are requesting to change ownership of a
    node from one user to another, and this is explicitly checked by Drupal before
    the action is executed.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 这是因为，在这个例子中，我们请求更改节点的所有权从一位用户到另一位用户，Drupal在执行操作之前会明确检查这一点。
- en: Review your permissions
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 审查你的权限
- en: 'Again, once you’ve read this chapter, it is a good idea to review the security
    considerations when using APIs in Drupal on Drupal.org: [https://www.drupal.org/docs/core-modules-and-themes/core-modules/jsonapi-module/security-considerations](https://www.drupal.org/docs/core-modules-and-themes/core-modules/jsonapi-module/security-considerations).'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调，一旦你阅读了这一章，就很好去Drupal.org上回顾一下使用API时的安全考虑：[https://www.drupal.org/docs/core-modules-and-themes/core-modules/jsonapi-module/security-considerations](https://www.drupal.org/docs/core-modules-and-themes/core-modules/jsonapi-module/security-considerations)。
- en: 'Now, we can make our new `PATCH` request:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以发出新的`PATCH`请求：
- en: '[PRE14]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Here, we receive a successful response from Drupal, along with the JSON representation
    of the node. We can see that the content was updated and that the node owner was
    re-assigned to **Johnny Editor**:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们收到了Drupal的成功响应，以及节点的JSON表示。我们可以看到内容已更新，节点所有者已被重新分配给**Johnny Editor**：
- en: '![Figure 12.18 – Re-assigning node ownership using a PATCH request](img/Figure_12.19_B18548.jpg)'
  id: totrans-164
  prefs: []
  type: TYPE_IMG
  zh: '![图12.18 – 使用PATCH请求重新分配节点所有权](img/Figure_12.19_B18548.jpg)'
- en: Figure 12.18 – Re-assigning node ownership using a PATCH request
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.18 – 使用PATCH请求重新分配节点所有权
- en: You can use relationships to add any entity reference you want to add to entities.
    Using this same formula, we can add some taxonomy to this article. Let’s assume
    there are two terms in the `taxonomy` tag called `Technology` and `News`. We want
    to tag them in this article.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用关系添加任何你想要添加到实体的实体引用。使用这个相同的公式，我们可以向这篇文章添加一些分类。假设有两个术语在`taxonomy`标签中，分别称为`Technology`和`News`。我们想在文章中标记它们。
- en: 'Like nodes and users, you can see taxonomy term data by navigating to `/jsonapi/taxonomy_term/tags`:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 就像节点和用户一样，你可以通过导航到`/jsonapi/taxonomy_term/tags`来查看分类术语数据：
- en: '![Figure 12.19 – Reading taxonomy terms using its JSON:API endpoint](img/Figure_12.20_B18548.jpg)'
  id: totrans-168
  prefs: []
  type: TYPE_IMG
  zh: '![图12.19 – 使用其JSON:API端点读取分类术语](img/Figure_12.20_B18548.jpg)'
- en: Figure 12.19 – Reading taxonomy terms using its JSON:API endpoint
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.19 – 使用其JSON:API端点读取分类术语
- en: 'Using the UUIDs here, we can pass both of them in the `relationships` part
    of the request:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这里的UUID，我们可以在请求的`relationships`部分传递它们：
- en: '[PRE15]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'When submitted, we will see that the article node was successfully updated
    with the two taxonomy terms specified:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 提交后，我们将看到文章节点已成功更新为指定的两个分类术语：
- en: '![Figure 12.20 – Taxonomy tags added to a node via a PATCH request](img/Figure_12.21_B18548.jpg)'
  id: totrans-173
  prefs: []
  type: TYPE_IMG
  zh: '![图12.20 – 通过PATCH请求向节点添加分类标签](img/Figure_12.21_B18548.jpg)'
- en: Figure 12.20 – Taxonomy tags added to a node via a PATCH request
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.20 – 通过PATCH请求向节点添加分类标签
- en: 'Now, if we were to fetch the data from Drupal as we did in the first section,
    we will see the author and taxonomy relationships in the node data:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果我们像第一部分那样从Drupal获取数据，我们将在节点数据中看到作者和分类关系：
- en: '![Figure 12.21 – Taxonomy relationships in the response for a node](img/Figure_12.22_B18548.jpg)'
  id: totrans-176
  prefs: []
  type: TYPE_IMG
  zh: '![图12.21 – 节点响应中的分类关系](img/Figure_12.22_B18548.jpg)'
- en: Figure 12.21 – Taxonomy relationships in the response for a node
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.21 – 节点响应中的分类关系
- en: 'When you combine that this with `include` in the URL query string, you will
    get the author data, as well as the taxonomy data: `include=uid,field_tags`.'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 当你将此与 URL 查询字符串中的 `include` 结合使用时，你将获得作者数据以及分类数据：`include=uid,field_tags`。
- en: 'If you want to remove referenced items, you can submit a `PATCH` request without
    that item. If we wanted to remove one of the terms, we can just pass the term
    we want to keep:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要删除引用项，你可以提交一个没有该项目的 `PATCH` 请求。如果我们想要删除一个术语，我们只需传递我们想要保留的术语：
- en: '[PRE16]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'To completely empty the `tags` field, pass an empty value:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 要完全清空 `tags` 字段，传递一个空值：
- en: '[PRE17]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'You will see that the terms have been removed from the article node:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 你将看到术语已被从文章节点中删除：
- en: '![Figure 12.22 – Passing an empty value in a PATCH request will remove relationships](img/Figure_12.23_B18548.jpg)'
  id: totrans-184
  prefs: []
  type: TYPE_IMG
  zh: '![图 12.22 – 在 PATCH 请求中传递空值将删除关系](img/Figure_12.23_B18548.jpg)'
- en: Figure 12.22 – Passing an empty value in a PATCH request will remove relationships
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 图 12.22 – 在 PATCH 请求中传递空值将删除关系
- en: How it works…
  id: totrans-186
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: Just like `POST`, `PATCH` provides a powerful way to update entity data in Drupal
    from a decoupled application or remote system. When you understand your entity
    data and schema, you can create and manipulate it in any way that you want via
    the API.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 就像 `POST` 和 `PATCH` 一样，`PATCH` 提供了一种强大的方式，可以从解耦的应用程序或远程系统更新 Drupal 中的实体数据。当你理解你的实体数据和模式时，你可以通过
    API 以任何你想要的方式创建和操作它。
- en: Also like `POST`, `PATCH` requests must abide by the permission system in Drupal.
    The same rules are respected as if this were a real user logging in to Drupal
    to update content.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 同样地，`POST` 和 `PATCH` 请求必须遵守 Drupal 的权限系统。相同的规则被尊重，就像这是一个真实用户登录到 Drupal 更新内容一样。
- en: With these two methods, you can create a decoupled site that can collect data
    from users and post it back to Drupal, such as a kiosk, survey, or commenting
    system. The possibilities are endless.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这两种方法，你可以创建一个解耦的网站，可以从用户那里收集数据并将其发回 Drupal，例如自助服务亭、调查或评论系统。可能性是无限的。
- en: Using DELETE to remove data with JSON:API
  id: totrans-190
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 DELETE 命令通过 JSON:API 删除数据
- en: 'Finally, we have come to the final action of the CRUD acronym: the `delete`
    method. This method removes requested data in Drupal, provided you have the UUID.'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们来到了 CRUD 简称的最终动作：`delete` 方法。此方法从 Drupal 中删除请求的数据，前提是你有 UUID。
- en: How to do it…
  id: totrans-192
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作…
- en: 'Like `PATCH`, issuing `DELETE` requires the appropriate permission in Drupal.
    In this case, the role assigned to our API user needs to be allowed to delete
    article nodes. Head back to the permissions section of the Drupal admin area and
    grant **Article: Delete any content** to the role.'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: '与 `PATCH` 类似，发出 `DELETE` 需要在 Drupal 中具有适当的权限。在这种情况下，分配给我们的 API 用户的角色需要允许删除文章节点。返回到
    Drupal 管理区域的权限部分，并将 **Article: Delete any content** 授予该角色。'
- en: We need to assign `delete any` instead of `delete own` since we assigned the
    node ownership to another user.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要将`delete any`分配而不是`delete own`，因为我们已经将节点所有权分配给了另一个用户。
- en: 'All the `DELETE` request needs is the UUID of the entity we wish to remove.
    Using the node we created, the UUID of it is `1ddf244d-e8e6-40f5-be48-23bc8fa0fa3e`.
    The `DELETE` request looks like this:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 所有的 `DELETE` 请求需要的只是我们希望删除的实体的 UUID。使用我们创建的节点，它的 UUID 是 `1ddf244d-e8e6-40f5-be48-23bc8fa0fa3e`。`DELETE`
    请求看起来是这样的：
- en: '[PRE18]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: When you submit it this time, there will be no response output on the command
    line. When successful, the response will be an `HTTP 204` empty response.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 当你这次提交时，命令行上不会有任何响应输出。当成功时，响应将是一个 `HTTP 204` 空响应。
- en: 'The JSON:API route now shows no nodes, which means `DELETE` was successful:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: JSON:API 路由现在显示没有节点，这意味着 `DELETE` 操作成功：
- en: '![Figure 12.23 – After using a DELETE request, the node was successfully deleted](img/Figure_12.24_B18548.jpg)'
  id: totrans-199
  prefs: []
  type: TYPE_IMG
  zh: '![图 12.23 – 使用 DELETE 请求后，节点已成功删除](img/Figure_12.24_B18548.jpg)'
- en: Figure 12.23 – After using a DELETE request, the node was successfully deleted
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 图 12.23 – 使用 DELETE 请求后，节点已成功删除
- en: How it works…
  id: totrans-201
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: Just like `POST` and `PATCH`, `DELETE` performs actions on behalf of the specified
    user. Since this user has permission to `delete any` article content, the request
    is permitted and Drupal removes the article node from the website.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 就像 `POST` 和 `PATCH` 一样，`DELETE` 代表指定的用户执行操作。由于此用户有权限 `delete any` 文章内容，请求被允许，Drupal
    从网站上删除了文章节点。
- en: For some use cases, `DELETE` may be too destructive of an action to either have
    an API perform or permission to grant. In this case, you could use `PATCH` and
    change the entity status to `unpublished` or `archived` (if using the `Content`
    `Moderation` module).
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 对于某些用例，`DELETE`可能对执行API或授予权限过于破坏性。在这种情况下，您可以使用`PATCH`并将实体状态更改为`未发布`或`存档`（如果使用`内容**审阅**模块）。
- en: Using Views to provide custom data sources
  id: totrans-204
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用视图提供自定义数据源
- en: The RESTful Web Services module provides Views plugins that allow you to expose
    data over Views for your RESTful API. This allows you to create a view that has
    a path and outputs data using a serializer plugin. You can use this to output
    entities in JSON or XML and it can be sent with appropriate headers.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: RESTful Web Services模块提供了视图插件，允许您通过视图公开RESTful API的数据。这允许您创建一个具有路径并使用序列化插件输出数据的视图。您可以使用此功能以JSON或XML格式输出实体，并且可以带有适当的头信息发送。
- en: In this recipe, we will create a view that outputs the users of the Drupal site,
    providing their username, email, and picture if provided.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 在本菜谱中，我们将创建一个视图，输出Drupal站点的用户，提供他们的用户名、电子邮件和图片（如果提供）。
- en: Getting ready
  id: totrans-207
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'Make sure you have the following core modules enabled:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 确保您已启用以下核心模块：
- en: Views
  id: totrans-209
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 视图
- en: Views UI
  id: totrans-210
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 视图UI
- en: RESTful Web Services
  id: totrans-211
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: RESTful Web Services
- en: How to do it…
  id: totrans-212
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: Navigate to **Structure** and then **Views**.
  id: totrans-213
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导航到**结构**然后**视图**。
- en: Click on **Add new view**.
  id: totrans-214
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**添加新视图**。
- en: 'Name the view `API Users` and have it show `/api/users`:'
  id: totrans-215
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将视图命名为`API Users`并显示`/api/users`：
- en: '![Figure 12.24 – Setting the path for Views for a custom REST endpoint](img/Figure_12.25_B18548.jpg)'
  id: totrans-216
  prefs: []
  type: TYPE_IMG
  zh: '![图12.24 – 为自定义REST端点设置视图的路径](img/Figure_12.25_B18548.jpg)'
- en: Figure 12.24 – Setting the path for Views for a custom REST endpoint
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.24 – 为自定义REST端点设置视图的路径
- en: Save the view and continue.
  id: totrans-218
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存视图并继续。
- en: 'With the view created, make the following changes:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建视图后，进行以下更改：
- en: Change the format of the row plugin from **Entity** to **Fields** so that we
    can control the specific output.
  id: totrans-220
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将行插件格式从**实体**更改为**字段**，以便我们可以控制特定的输出。
- en: Under the **Settings** section of format, enable **json** under **Accepted**
    **request formats**.
  id: totrans-221
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在格式设置部分的**设置**部分，在**接受**的**请求格式**下启用**json**。
- en: Ensure that your view has **Name**, **Email**, and **Picture** as user entity
    fields
  id: totrans-222
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 确保您的视图具有**名称**、**电子邮件**和**图片**作为用户实体字段
- en: 'Change the **User: Name** field to the **Plain text** formatter. Do not link
    it to the user to ensure the response does not contain any HTML.'
  id: totrans-223
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将**用户：名称**字段更改为**纯文本**格式化程序。不要将其链接到用户，以确保响应不包含任何HTML。
- en: 'Change the **User: Picture** field so that it uses the URL to image formatter
    so that only a URL is returned and not HTML.'
  id: totrans-224
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将**用户：图片**字段更改为使用URL到图片格式化程序，以便只返回URL而不是HTML。
- en: Save the updated View.
  id: totrans-225
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 保存更新后的视图。
- en: Access your view by visiting `/api/users`. You will receive a JSON response
    containing the user information.
  id: totrans-226
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过访问 `/api/users` 来访问您的视图。您将收到一个包含用户信息的JSON响应。
- en: 'In your browser, you will see the output of the users in your system formatted
    in the way we set it in the View:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 在您的浏览器中，您将看到以我们在视图中设置的方式格式化的系统用户输出：
- en: '[PRE19]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: How it works…
  id: totrans-229
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The RESTful Web Services module provides a display, row, and format plugin that
    allows you to export content entities in a serialized format. The REST Export
    display plugin is what allows you to specify a path to access the RESTful endpoint,
    and properly assigns the `Content-Type` header for the requested format.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: RESTful Web Services模块提供了一个显示、行和格式插件，允许您以序列化格式导出内容实体。REST Export显示插件允许您指定路径以访问RESTful端点，并为请求的格式正确分配`Content-Type`头。
- en: The Serializer style is provided as the only supported style plugin for the
    REST Export display. This style plugin only supports row plugins that identify
    themselves as data display types. It expects data from the row plugin to be raw
    so that it can be passed to the appropriate serializer.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 序列化风格作为唯一支持的样式插件提供，用于REST Export显示。此样式插件仅支持标识为数据显示类型的行插件。它期望从行插件接收原始数据，以便可以将其传递给适当的序列化器。
- en: You then have the option of using the Data entity or Data field row plugins.
    Instead of returning a render array from their render method, they return raw
    data that will be serialized into the proper format. With the row plugins returning
    raw format data and the data then serialized by the style plugin, the display
    plugin will return the response, converted into the proper format via the Serialization
    module, which we saw earlier in this chapter.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，您可以选择使用数据实体或数据字段行插件。它们不是从它们的渲染方法返回渲染数组，而是返回将被序列化为正确格式的原始数据。通过行插件返回原始格式数据，并由样式插件进行序列化，显示插件将返回响应，通过序列化模块转换为正确的格式，这是我们之前在本章中看到的。
- en: Using Views is an excellent way to provide API routes for reading. You get all
    the convenience of using the Views UI that you are used to in Drupal with the
    combined power of JSON or XML serialization. You can create as many of these as
    you need to satisfy different use cases.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 使用视图是提供API读取路由的绝佳方式。您将获得在Drupal中使用的视图UI的所有便利性，以及JSON或XML序列化的综合力量。您可以根据需要创建尽可能多的这些视图来满足不同的用例。
- en: There’s more…
  id: totrans-234
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更多内容...
- en: Views allow you to deliver specific RESTful endpoints. With Views, you can add
    displays with custom paths and add fields to them, creating a custom JSON response.
    This makes for a rapid way of developing custom read-only data APIs in Drupal.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 视图允许您提供特定的RESTful端点。使用视图，您可以添加具有自定义路径的显示，并将字段添加到其中，创建自定义JSON响应。这使得在Drupal中快速开发自定义只读数据API变得简单。
- en: Controlling the key name in the JSON output
  id: totrans-236
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 控制JSON输出中的键名
- en: 'The Data fields row plugin allows you to configure field aliases. When the
    data is returned to the view, it will contain Drupal’s machine names. This means
    that custom fields will look something like `field_my_field`, which may not make
    sense to the consumer. By clicking on **Settings** next to **Fields**, you can
    set aliases in the modal form:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 数据字段行插件允许您配置字段别名。当数据返回到视图时，它将包含Drupal的机器名称。这意味着自定义字段看起来可能像`field_my_field`，这可能对消费者来说没有意义。通过点击**字段**旁边的**设置**，您可以在模态表单中设置别名：
- en: '![Figure 12.25 – You can alias field names in a Views REST display](img/Figure_12.26_B18548.jpg)'
  id: totrans-238
  prefs: []
  type: TYPE_IMG
  zh: '![图12.25 – 您可以在视图REST显示中别名字段名称](img/Figure_12.26_B18548.jpg)'
- en: Figure 12.25 – You can alias field names in a Views REST display
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.25 – 您可以在视图REST显示中别名字段名称
- en: 'When you provide an alias, the fields will match. For example, `user_picture`
    can be changed to `avatar` and the `mail` key can be changed to `email`:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 当您提供一个别名时，字段将匹配。例如，`user_picture`可以改为`avatar`，而`mail`键可以改为`email`：
- en: '[PRE20]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Controlling access to RESTful Views
  id: totrans-242
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 控制RESTful视图的访问
- en: When you create a RESTful endpoint with Views, you are not using the same permissions
    created by the RESTful Web Services module. You need to define the route permissions
    within the view, allowing you to specify specific roles or permissions for the
    request.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 当您使用视图创建RESTful端点时，您不是使用RESTful Web Services模块创建的相同权限。您需要在视图中定义路由权限，这样您就可以指定请求的特定角色或权限。
- en: The default `GET` method provided by the `EntityResource` plugin does not provide
    a way to list entities and allows any entity to be retrieved by an ID. Using Views,
    you can provide a list of entities, limiting them to specific bundles and much
    more.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: '`EntityResource`插件提供的默认`GET`方法不提供列出实体的方式，并允许通过ID检索任何实体。使用视图，您可以提供实体列表，限制它们到特定的捆绑包，等等。'
- en: With Views, you can even provide a new endpoint to retrieve a specific entity.
    Using Contextual filters, you can add route parameters and filters to limit and
    validate entity IDs. For example, you may want to expose the article content over
    the API, but not pages.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 使用视图，您甚至可以提供一个新端点来检索特定实体。使用上下文过滤器，您可以添加路由参数和过滤器来限制和验证实体ID。例如，您可能希望通过API公开文章内容，但不公开页面。
- en: Using OAuth methods
  id: totrans-246
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用OAuth方法
- en: Using the RESTful Web Services module, we can define specific supported authentication
    providers for an endpoint. Drupal core provides a cookie provider, which authenticates
    through a valid cookie, such as your regular login experience. Then, there is
    the HTTP Basic Authentication module to support HTTP authentication headers.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 使用RESTful Web Services模块，我们可以为端点定义特定的支持认证提供者。Drupal核心提供了一个cookie提供者，它通过有效的cookie进行认证，例如您的常规登录体验。然后，还有HTTP
    Basic Authentication模块来支持HTTP认证头。
- en: Some alternatives provide more robust authentication methods. With cookie-based
    authentication, you need to use CSRF tokens to prevent unrequested page loads
    by an unauthorized party. When you use HTTP authentication, you are sending a
    password for each request in the request header.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 一些替代方案提供了更健壮的认证方法。使用基于cookie的认证，你需要使用CSRF令牌来防止未经授权的第三方加载未请求的页面。当你使用HTTP认证时，你会在请求头中发送每个请求的密码。
- en: A popular, and open, authorization framework is OAuth. OAuth is a proper authentication
    method that uses tokens and not passwords. In this recipe, we will implement the
    `Simple OAuth` module to provide OAuth 2.0 authentication for `GET` and `POST`
    requests.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 一个流行且开放的授权框架是OAuth。OAuth是一种使用令牌而不是密码的正确认证方法。在这个菜谱中，我们将实现`Simple OAuth`模块，为`GET`和`POST`请求提供OAuth
    2.0认证。
- en: Getting ready
  id: totrans-250
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'If you are not familiar with OAuth or OAuth 2.0, it is a standard for authorization.
    The implementation of OAuth revolves around the usage of tokens sent in HTTP headers.
    Refer to the OAuth home page for more information: [http://oauth.net/](http://oauth.net/).'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你不太熟悉OAuth或OAuth 2.0，它是一个授权标准。OAuth的实现围绕在HTTP头中发送的令牌的使用。有关更多信息，请参阅OAuth主页：[http://oauth.net/](http://oauth.net/)。
- en: For the following sections, you will need the contributed **Rest UI** module.
    Rest UI will make it easier for you to see and control your REST-based routes
    in Drupal.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 对于以下部分，你需要贡献的**Rest UI**模块。Rest UI将使你更容易在Drupal中查看和控制基于REST的路由。
- en: How to do it…
  id: totrans-253
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'Go ahead and get the necessary module with Composer:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 继续使用Composer获取必要的模块：
- en: '[PRE21]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Enable the **REST UI** module in the admin area under **Extend**.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 在**扩展**下的管理区域启用**REST UI**模块。
- en: 'Now, do the following:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，执行以下操作：
- en: 'First, we must add the `Simple OAuth` module to our Drupal site:'
  id: totrans-258
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们必须将`Simple OAuth`模块添加到我们的Drupal站点中：
- en: '[PRE22]'
  id: totrans-259
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Go to **Configuration** and click on **REST** under **Web Services** to configure
    the available endpoints:'
  id: totrans-260
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 前往**配置**，然后在**网络服务**下点击**REST**以配置可用的端点：
- en: '![Figure 12.26 – With the REST UI module, you can manage RESTful endpoints
    in the admin](img/Figure_12.27_B18548.jpg)'
  id: totrans-261
  prefs: []
  type: TYPE_IMG
  zh: '![图12.26 – 使用REST UI模块，你可以在管理中管理RESTful端点](img/Figure_12.27_B18548.jpg)'
- en: Figure 12.26 – With the REST UI module, you can manage RESTful endpoints in
    the admin
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.26 – 使用REST UI模块，你可以在管理中管理RESTful端点
- en: Now that the endpoint has been enabled, it must be configured. Check the `GET`
    and `POST` requests. Then, check the **JSON** checkbox so that data can be returned
    as JSON. Check the **oauth2** checkbox and then save it.
  id: totrans-263
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在端点已经启用，必须进行配置。检查`GET`和`POST`请求。然后，勾选**JSON**复选框，以便数据可以以JSON格式返回。勾选**oauth2**复选框，然后保存。
- en: 'Before we can configure the `Simple OAuth` module, we have to generate a pair
    of keys to encrypt the `OAuth` tokens. We can do this in one of two ways:'
  id: totrans-264
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在我们能够配置`Simple OAuth`模块之前，我们必须生成一对密钥来加密`OAuth`令牌。我们可以通过两种方式之一来完成这项工作：
- en: Create a directory outside of the webroot, then click **Generate keys**. In
    the dialog that appears, add the full path to this folder on the server and click
    **Generate**.
  id: totrans-265
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在webroot之外创建一个目录，然后点击**生成密钥**。在出现的对话框中，添加服务器上此文件夹的完整路径，然后点击**生成**。
- en: 'If the admin UI does not work, we can use the following two commands to generate
    keys. Place them on the server outside of the webroot:'
  id: totrans-266
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果管理UI不起作用，我们可以使用以下两个命令来生成密钥。将它们放在webroot之外的服务器上：
- en: '[PRE23]'
  id: totrans-267
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '[PRE24]'
  id: totrans-268
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'With the keys generated, go to the **Configuration** page and then to **Simple
    OAuth**. Enter the paths to the private and public keys that were just generated
    and click on **Save configuration**:'
  id: totrans-269
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 生成密钥后，转到**配置**页面，然后转到**Simple OAuth**。输入刚刚生成的私钥和公钥的路径，然后点击**保存配置**：
- en: '![Figure 12.27 – Managing keys in Simple OAuth in the admin area](img/Figure_12.28_B18548.jpg)'
  id: totrans-270
  prefs: []
  type: TYPE_IMG
  zh: '![图12.27 – 在管理区域中管理Simple OAuth的密钥](img/Figure_12.28_B18548.jpg)'
- en: Figure 12.27 – Managing keys in Simple OAuth in the admin area
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.27 – 在管理区域中管理Simple OAuth的密钥
- en: From the **Simple** **OAuth** **Settings** configuration form, click on **+**
    **Add Client**. Provide a label for the client and select the **Administrator**
    scope. Then, click on **Save** to create the client.
  id: totrans-272
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从**Simple OAuth 设置**配置表单中，点击**+** **添加客户端**。为客户端提供一个标签，并选择**管理员**范围。然后，点击**保存**以创建客户端。
- en: 'Next, we will generate a token through the `/oauth/` token endpoint. You will
    need the ID from the client you just created. We must pass `grant_type`, `client_id`,
    and the username and password. `grant_type` is the password, whereas `client_id`
    is the ID from the created client. The username and password will be of the account
    you wish to use:'
  id: totrans-273
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将通过`/oauth/`令牌端点生成一个令牌。你需要使用你刚刚创建的客户端的ID。我们必须传递`grant_type`、`client_id`以及用户名和密码。`grant_type`是密码，而`client_id`是从创建的客户端中获取的ID。用户名和密码将是你要使用的账户：
- en: '[PRE25]'
  id: totrans-274
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: '[PRE26]'
  id: totrans-275
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: '[PRE27]'
  id: totrans-276
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: '[PRE28]'
  id: totrans-277
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: '[PRE29]'
  id: totrans-278
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: '[PRE30]'
  id: totrans-279
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: The response will contain an `access_token` property. This is to be used as
    your token when making API requests.
  id: totrans-280
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 响应将包含一个`access_token`属性。这将在进行API请求时用作你的令牌。
- en: 'Request a node over REST with the **Authorization: Bearer [****token]** header:'
  id: totrans-281
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '使用**Authorization: Bearer [****token]**头请求REST节点：'
- en: '[PRE31]'
  id: totrans-282
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: '[PRE32]'
  id: totrans-283
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: '[PRE33]'
  id: totrans-284
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: That’s it! You can now set authenticated routes using OAuth to various resources
    in Drupal and configure all the different REST endpoints with the methods and
    authentication types they accept.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 就这样！你现在可以使用OAuth设置认证路由，用于Drupal中的各种资源，并配置所有不同的REST端点，包括它们接受的方法和认证类型。
- en: How it works…
  id: totrans-286
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: The `Simple OAuth` module is built using the `League\OAuth2` PHP library, a
    community standard library for OAuth2 implementation.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: '`Simple OAuth`模块是使用社区标准库`League\OAuth2` PHP库构建的，这是一个OAuth2实现的社区标准库。'
- en: In a typical authentication request, there is an authentication manager that
    uses the `authentication_collector` service to collect all the tagged authentication
    provider servers. Based on the provider’s set priority, each service is invoked
    to check whether it applies to the current request. Each applied authentication
    provider then gets invoked to see whether the authentication is invalid.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 在典型的认证请求中，存在一个认证管理器，该管理器使用`authentication_collector`服务来收集所有标记的认证提供者服务器。根据提供者设置的优先级，每个服务被调用以检查它是否适用于当前请求。然后，每个应用的认证提供者被调用以查看认证是否无效。
- en: For the RESTful Web Services module, this process is more explicit. The providers
    identified in the `supported_auth` definition for the endpoint are the only services
    that run through the `applies` and `authenticates` processes.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 对于RESTful Web Services模块，这个过程更为明确。端点的`supported_auth`定义中标识的提供者是唯一通过`applies`和`authenticates`过程运行的服务。
