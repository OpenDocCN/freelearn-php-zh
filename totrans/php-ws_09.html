<html><head></head><body>
		<div>
			<div class="Content" id="_idContainer257">
			</div>
		</div>
		<div class="Content" id="_idContainer258">
			<h1 id="_idParaDest-327"><a id="_idTextAnchor336"/>9. Composer</h1>
		</div>
		<div class="Content" id="_idContainer275">
			<p class="callout-heading">Overview</p>
			<p class="callout">By the end of this chapter, you will be able to describe the benefits of using a dependency manager in your application; identify high-quality, open source packages to solve common problems; add third-party libraries to your project; set up autoloading in your project so that you don't have to use include statements; and implement the Monolog logging package.</p>
			<h1 id="_idParaDest-328"><a id="_idTextAnchor337"/>Introduction</h1>
			<p>In the previous chapter, we covered how to handle error conditions by using PHP's built-in <strong class="source-inline">Exception</strong> class and how to use the <strong class="source-inline">try</strong>…<strong class="source-inline">catch</strong> block to control the flow of your application.</p>
			<p>Most modern-day applications are built on top of an amalgamation of other open source libraries. Many problems that are frequently encountered across all applications have already been solved and tested by developers who have made their solutions freely available to include in your project. This may be as small as a library that generates unique identifiers, or as large as full application frameworks that help you to organize your code. Take authentication, for example. Nearly every PHP application is going to include some form of authentication and, the majority of the time, it will be built in exactly the same way each time. We make use of third-party solutions for authentication, so we don't have to write the same authentication code over and over again in each application we write. Other examples of these types of libraries that are needed across multiple applications, known as cross-cutting concerns, are logging, security, and interacting with the filesystem. The list goes on.</p>
			<p>With so many dependencies on external libraries, it becomes a necessity to have some tooling for the management of such libraries. In PHP, we are fortunate enough to have a great open source tool for that exact purpose – Composer. On top of that, if you are so inclined, you can leverage Composer to organize your company's frequently implemented features into a library that you use as a jumping-off point for all your applications, preventing the need to write the code over and over, and managing any updates to that library as it evolves.</p>
			<p>In this chapter, we will explain what dependency management is and why you should be using a tool to handle it for you. We will walk you through the essential commands you will use to start using it in your projects and explain the configuration file. We will introduce you to PSR-4, one of many recommendations defined by the <strong class="bold">PHP Framework Interoperability Group</strong> (<strong class="bold">PHP-FIG</strong>), which is not exclusive to Composer but is frequently utilized to streamline the inclusion of code in a process called <strong class="bold">autoloading</strong>. We will demonstrate autoloading by setting up a sample project that uses a popular logging framework, Monolog. Finally, we will introduce you to Packagist, a website that functions as a directory listing for packages, and we will give you some tips on navigating the site and evaluating the packages you find to help you choose packages that will not only provide the functionality you need but are backed by a level of support.</p>
			<h1 id="_idParaDest-329"><a id="_idTextAnchor338"/>Dependency Management</h1>
			<p>You may be asking yourself why we need the complexity of another tool to manage our external dependencies for us. You could always just grab a copy of the source code and put it directly in your project. The answer is made apparent by one word in the question: <em class="italic">external</em>. The dependencies are not your code, and you don't want to be responsible for managing them. This becomes even more apparent as you consider that those packages are likely to also depend on other libraries, which may still have dependencies themselves, and so on. This is further complicated by the fact that each of these libraries needs to be compatible with each other over time as they implement new features, bug fixes, and security maintenance releases.</p>
			<p>Composer does all the hard work of determining whether any of the libraries you depend on have upgrades available and determining which versions of those libraries are compatible with each other, and generates a verbose list of packages and their metadata that tells it exactly what to install and where those packages can be located for installation in the project. All you have to do is use a few simple commands or edit a configuration file to give Composer a list of packages you want to include in your project and run a command to install them.</p>
			<h2 id="_idParaDest-330"><a id="_idTextAnchor339"/>Using Composer</h2>
			<p>Composer is a tool that you will most frequently interact with from the command line. The next few sections cover the most common operations you will use day to day, with exercises for each. You will need to have Composer installed, the instructions for which are provided in the preface. Composer can be installed at a project level or at a global level on your system. Ensure that you have installed Composer globally. </p>
			<h2 id="_idParaDest-331"><a id="_idTextAnchor340"/>Exercise 9.1: Getting Started with Composer</h2>
			<p>In this brief exercise, we will run Composer from the command line for the first time to verify that it is installed correctly, run a command that will give us a list of arguments we can pass to it in order to perform the various functions it has available, and then introduce you to the <strong class="source-inline">help</strong> command so that you can get summary information on any of the commands Composer has available:</p>
			<ol>
				<li>Open your Command Prompt and navigate to the folder where you store your code.</li>
				<li>Verify that Composer is functioning properly by checking the version you have installed by running the following command:<p class="source-code">composer –V</p><p>The version number may be different, but if everything is set up correctly, you will see output similar to the following screenshot:</p><div class="IMG---Figure" id="_idContainer259"><img alt="Figure 9.1: Printing the version number&#13;&#10;" src="image/C14196_09_01.jpg"/></div><p class="figure-caption">Figure 9.1: Printing the version number</p></li>
				<li>Next, list out all of the available functions of Composer with a short summary of each using the following command:<p class="source-code">composer list</p><p>You will obtain output similar to the following:</p><div class="IMG---Figure" id="_idContainer260"><img alt="Figure 9.2: Functions of Composer&#13;&#10;" src="image/C14196_09_02.jpg"/></div><p class="figure-caption">Figure 9.2: Functions of Composer</p><p>This is an easy way to explore the functionality of Composer and to look up commands you have used before but can't remember the exact names for.</p></li>
				<li>Lastly, the <strong class="source-inline">help</strong> command takes the name of a command as an argument and explains the usage of that feature. Call the <strong class="source-inline">help</strong> command, passing the <strong class="source-inline">init</strong> command as an argument:<p class="source-code">composer help init</p><p>You will obtain output similar to the following:</p></li>
			</ol>
			<div>
				<div class="IMG---Figure" id="_idContainer261">
					<img alt="Figure 9.3: Screenshot of the help command&#13;&#10;" src="image/C14196_09_03.jpg"/>
				</div>
			</div>
			<p class="figure-caption">Figure 9.3: Screenshot of the help command</p>
			<p>The <strong class="source-inline">help</strong> command is a useful tool for looking up the specific syntax for any other command if you can't remember it, or even to discover options that may modify its behavior to suit your needs.</p>
			<h2 id="_idParaDest-332"><a id="_idTextAnchor341"/>Initializing a Project</h2>
			<p>Now that you've seen how to call Composer on the command line, you can initialize a project with some basic settings. These are stored in a file named <strong class="source-inline">composer.json</strong>, which should be in your project root directory. This file will include some meta-information about your project as well as definitions of every dependency to be installed in your project. Fortunately, Composer provides a simple command to get us started: <strong class="source-inline">init</strong>.</p>
			<h2 id="_idParaDest-333"><a id="_idTextAnchor342"/>Exercise 9.2: Initializing a Project</h2>
			<p>In this exercise, we will walk through the initial installation of a project using the <strong class="source-inline">init</strong> command. There are a few options you will be asked to configure, as you will see in the following:</p>
			<ol>
				<li value="1">Create a new directory to be the project directory for this example and navigate to it. Here, we will use <strong class="source-inline">composer-example</strong>.</li>
				<li>From this directory, run the command to initialize a project:<p class="source-code">composer init</p></li>
				<li>Type the name you would like to choose for your package and hit <em class="italic">Enter</em>: <p class="source-code">mccollum/composer-example</p></li>
				<li>Enter a description and hit <em class="italic">Enter</em>.</li>
				<li>Hit <em class="italic">Enter</em> to accept the default author.</li>
				<li>Enter <strong class="source-inline">stable</strong> as the minimum stability.<p class="callout-heading">Note</p><p class="callout">The minimum stability tells Composer what level of stability is acceptable when selecting which version of a package to install when you require one. The options, from most to least stable, are stable, RC, beta, alpha, and dev. Ordinarily, it's best to select "stable" for projects that will end up in production.</p></li>
				<li>Enter <em class="italic">project</em> for the package type and hit <em class="italic">Enter</em>.</li>
				<li>Hit <em class="italic">Enter</em> to skip selecting a license.</li>
				<li>Answer <strong class="source-inline">no</strong> to defining dependencies and dev dependencies interactively.<p>The output on your screen should look similar to this:</p></li>
			</ol>
			<div>
				<div class="IMG---Figure" id="_idContainer262">
					<img alt="Figure 9.4: Screenshot after confirmation&#13;&#10;" src="image/C14196_09_04.jpg"/>
				</div>
			</div>
			<p class="figure-caption">Figure 9.4: Screenshot after confirmation</p>
			<p>You will now have a new <strong class="source-inline">composer.json</strong> file listed in your project root directory. The contents of the <strong class="source-inline">composer.json</strong> file are output to the screen as the final step of generating the file. Open it up and take a look at it. All the information you entered during the <strong class="source-inline">init</strong> command should be listed in the file. You can always make changes to this file directly, but it is easier to interact with it from the command line in most cases.</p>
			<h2 id="_idParaDest-334"><a id="_idTextAnchor343"/>Requiring Packages</h2>
			<p>At this stage, all the setup has been completed and you can begin pulling packages into your project. You only need to tell Composer that your project requires the package and Composer will determine the appropriate version of the package to install, alter the <strong class="source-inline">composer.json</strong> file to add the package as a dependency, and download the files for the project and place them in the vendor directory, which it will create if one does not exist.</p>
			<p>The vendor directory is a special directory where Composer keeps all of the files it adds to your project. This is configurable if you need it to be different, but generally, it's best to keep it with the default to keep with convention. Once you require packages, inside the folder, there will be a folder for each project that will contain the source code for that library. It is important not to edit files inside this directory, or you risk your changes being lost as packages are upgraded. In general, it's a good idea to keep your own code separate from the dependencies you are building on top of.</p>
			<p>In order to work through an example, we need to choose a package that is available to pull in via Composer. We have chosen Monolog, which happens to be developed and maintained by one of the primary developers of Composer. It is a handy library that serves as an abstraction of the logging functions that are commonly needed across all applications. It allows you to set up any number of processes that will listen for the log function to be called using a common interface and will log to their respective output, which ranges from the filesystem to NoSQL database clients, to a bucket on Amazon Web Services. If there's a place you want to capture your logs, there's a good chance that Monolog supports it and makes it easy to do so.</p>
			<h2 id="_idParaDest-335"><a id="_idTextAnchor344"/>Exercise 9.3: Adding Dependencies</h2>
			<p>In this exercise, we will add dependencies to your project using Composer. We have selected a popular logging framework, to begin with, that we will make use of later in the chapter:</p>
			<ol>
				<li value="1">In your Command Prompt, navigate to the directory where you initialized your project.</li>
				<li>Run the command to install Monolog:<p class="source-code">composer require monolog/monolog</p><p>The output is as follows:</p><div class="IMG---Figure" id="_idContainer263"><img alt="Figure 9.5: Installing Monolog&#13;&#10;" src="image/C14196_09_05.jpg"/></div><p class="figure-caption">Figure 9.5: Installing Monolog</p></li>
				<li>Examine the vendor directory:</li>
			</ol>
			<div>
				<div class="IMG---Figure" id="_idContainer264">
					<img alt="Figure 9.6: Examining the directory&#13;&#10;" src="image/C14196_09_06.jpg"/>
				</div>
			</div>
			<p class="figure-caption">Figure 9.6: Examining the directory</p>
			<p>Inside the vendor directory, you will see the directory for Monolog as well as its dependency, <strong class="source-inline">psr</strong>. There is also a directory for Composer itself, and an <strong class="source-inline">autoload.php</strong> file. We will cover the purpose of the autoload file later in this chapter. The <strong class="source-inline">composer.json</strong> file will also be updated, now including a line in the <strong class="source-inline">require</strong> section for <strong class="source-inline">monolog/monolog</strong> and showing you the version of the package it selected:</p>
			<div>
				<div class="IMG---Figure" id="_idContainer265">
					<img alt="Figure 9.7: Printing version&#13;&#10;" src="image/C14196_09_07.jpg"/>
				</div>
			</div>
			<p class="figure-caption">Figure 9.7: Printing version</p>
			<h1 id="_idParaDest-336"><a id="_idTextAnchor345"/>Semantic Versioning</h1>
			<p>Packages available in Composer conform to a versioning convention known as semantic versioning. This is a standardized format for increasing version identifiers that applies a meaning, on which basis the number in the identifier increases. The official documentation is located at <a href="https://semver.org/">https://semver.org/</a>. The version is formatted so that it has three integers separated by periods. The first integer represents a major version change and indicates that the release may have breaking changes that their clients will need to rework in order to integrate with the library. The second integer indicates minor changes, such as new features, and should be backward compatible. The third number indicates bug fixes or security updates, also known as patches, and should typically be allowed to update automatically.</p>
			<p>When a number is increased, the numbers behind it are reset to 0. For example, at the time of writing, when I installed the Monolog package, the current stable release is 1.24.0. This means that there have been 24 minor releases since the project was deemed stable and ready for production. If a bug were found in the software and they released that individually, the next version number would be 1.24.1. After that, the next release of minor features would bring the version number to 1.25.0. If they ever need to change the library in a way that breaks the consumer interface, the version would bump up to 2.0.0. This is a very useful format, and I recommend using it for your own projects within your version control system.</p>
			<h2 id="_idParaDest-337"><a id="_idTextAnchor346"/>Applying Version Constraints</h2>
			<p>When you require a package, you may optionally specify version constraints that limit the available versions of that package that Composer may select to install. You will want to ensure that when you upgrade the packages installed by Composer, it does not automatically upgrade to a version that will be incompatible with your code base. The most common use case for this is that you only want to apply patch-level updates automatically and wait until you can test minor and major versions before releasing them alongside your code. Another example from my personal experience was a scenario when we converted a large legacy application to use Composer, which made use of a library several major versions behind the current one. It was not cost-effective to update the library, so I needed to lock it into the same version that was installed prior to being managed by Composer.</p>
			<p>Composer offers a number of modifiers you can add to the version definition that will allow it to dynamically select a version according to your specifications. You can find a full description of the modifiers at <a href="https://packt.live/2MJNAur">https://packt.live/2MJNAur</a>. The two most common of these are the next-significant-release operators: one identified by a tilde character, as in ~1.24.3, and the other a caret, as in ^1.24.0. </p>
			<p>The tilde operator will limit upgrades to the next major or minor version, depending on whether the patch number is specified. For example, ~1.24.3 would accept any version prior to 1.25.0, while ~1.24 would accept any version prior to 2.0.0. The caret operator is similar but assumes that any non-breaking change as specified by semantic versioning would be acceptable. If ^1.24.3 were specified, this would allow any upgrade prior to 2.0.0.</p>
			<h2 id="_idParaDest-338"><a id="_idTextAnchor347"/>Exercise 9.4: Applying Version Constraints</h2>
			<p>In this exercise, we will introduce the <strong class="source-inline">show</strong> command and give an example of applying version constraints to a dependency. You will also see that when you require a package, you can add the version you would like installed to the end of the command and it will target that constraint:</p>
			<ol>
				<li value="1">From the Command Prompt, run the command to view the currently installed packages:<p class="source-code">composer show</p></li>
				<li>Update your requirement to the 1.0.0 version of Monolog:<p class="source-code">composer require monolog/monolog:1.0.0</p><p>If you run Composer again, you will see that Monolog has been downgraded to 1.0.0:</p><div class="IMG---Figure" id="_idContainer266"><img alt="" src="image/C14196_09_08.jpg"/></div><p class="figure-caption">Figure 9.8: Screenshot of Composer</p></li>
				<li>Now, update the <strong class="source-inline">require</strong> command to accept version 1.23 or higher, but less than 2.0. Note that it will install the highest version that is less than 2.0.0:<p class="source-code">composer require monolog/monolog:~1.23</p><p>Composer will again show that it has been brought back up to the current version (1.24.0 at the time of writing).</p></li>
			</ol>
			<p>Using these constraints, you can be confident that as time passes and new versions are released by vendors, your code will be unaffected until you are ready to implement their changes. You may also notice that the version of <strong class="source-inline">psr/log</strong> does not change with the version of Monolog being upgraded/downgraded, as 1.1.0 satisfies both versions.</p>
			<h2 id="_idParaDest-339"><a id="_idTextAnchor348"/>The Lock File</h2>
			<p>At this stage, if you examine the files in your project directory, you will see the <strong class="source-inline">composer.json</strong> file you generated with the <strong class="source-inline">init</strong> command, the vendor directory that was created when you required a package, and lastly, a <strong class="source-inline">composer.lock</strong> file. The <strong class="source-inline">composer.lock</strong> file is a counterpart to the <strong class="source-inline">composer.json</strong> file and is regenerated every time you make a modification to the required packages. If you view the contents of the file, you will see a few sections, such as <strong class="source-inline">_readme</strong> and a content hash, but the primary one is the packages section, which details the packages you have installed and some metadata about each that allows Composer to reliably reinstall the packages in the same configuration they have at this point in time. Each package has the name listed, the version installed, the version control type, and the URL where it can be found, as well as any required dependencies, among other things.</p>
			<p>This is important because it allows you to consistently reproduce the installation of your entire list of dependencies using the known versions you have used during development. Imagine a scenario in which you are brought onto a team to work on a project and <strong class="source-inline">acme/awesome-package</strong> was required in version 1.0.0. However, by the time you join the project, version 2.0.0 has been released. Without the <strong class="source-inline">.lock</strong> file, you would be getting a version of the library that may be incompatible with the code base. Using the <strong class="source-inline">install</strong> command will make use of the <strong class="source-inline">.lock</strong> file to determine which versions of the packages to install, while the <strong class="source-inline">update</strong> command will ignore the current lock file and generate a new one with the most current versions that are compatible with all required packages. The <strong class="source-inline">.lock</strong> file specifies the exact versions of the packages that are installed each time you make an update to your dependencies. For this reason, both the <strong class="source-inline">composer.json</strong> and <strong class="source-inline">composer.lock</strong> files are typically committed to version control. By specifying the exact version that is installed, you can have confidence that the version you get will be compatible with your code until the point at which you explicitly update packages.</p>
			<h2 id="_idParaDest-340"><a id="_idTextAnchor349"/>Exercise 9.5: Re-Installing Vendor Files</h2>
			<p>To show you how the <strong class="source-inline">composer.lock</strong> file works, we will delete the vendor directory entirely and restore the required packages with the <strong class="source-inline">install</strong> command:</p>
			<ol>
				<li value="1">From the Command Prompt, delete the entire vendor directory:<p>OSX or Linux: <strong class="source-inline">rm –rf vendor</strong></p><p>Windows: <strong class="source-inline">rmdir vendor</strong></p></li>
				<li>View the contents of your project directory to see that the vendor directory has disappeared. You should still have both your <strong class="source-inline">composer.json</strong> and <strong class="source-inline">composer.lock</strong> files, which will allow you to reinstall your required packages by running the <strong class="source-inline">install</strong> command.</li>
				<li>Run the command to install the dependencies:<p class="source-code">composer install</p><p>The output is as follows:</p></li>
			</ol>
			<div>
				<div class="IMG---Figure" id="_idContainer267">
					<img alt="Figure 9.9: Installing dependencies&#13;&#10;" src="image/C14196_09_09.jpg"/>
				</div>
			</div>
			<p class="figure-caption">Figure 9.9: Installing dependencies</p>
			<p>Voilà! The vendor directory is restored, with all the files and folders from your dependencies back in their usual places.</p>
			<h2 id="_idParaDest-341"><a id="_idTextAnchor350"/>Dev Dependencies</h2>
			<p>Many of the packages your project depends on will be production code, but some of them will be libraries you use for development purposes only. A couple of examples of these would be testing frameworks and command-line utilities. Composer provides the capability to specify packages as dev dependencies, so that when you run the <strong class="source-inline">install</strong> command on a non-dev environment, you can pass the <strong class="source-inline">--no-dev</strong> flag and it will omit any development-only packages.</p>
			<h2 id="_idParaDest-342"><a id="_idTextAnchor351"/>Exercise 9.6: Installing Development Dependencies</h2>
			<p>In this exercise, we will add the popular unit testing framework PHPUnit as a development dependency only:</p>
			<ol>
				<li value="1">Install the PHPUnit testing framework:<p class="source-code">composer require --dev phpunit/phpunit</p></li>
				<li>Now, if you view the contents of the <strong class="source-inline">composer.json</strong> file, you will see the <strong class="source-inline">phpunit/phpunit</strong> package listed under the <strong class="source-inline">require-dev</strong> section:</li>
			</ol>
			<div>
				<div class="IMG---Figure" id="_idContainer268">
					<img alt="Figure 9.10: Contents of composer.json&#13;&#10;" src="image/C14196_09_10.jpg"/>
				</div>
			</div>
			<p class="figure-caption">Figure 9.10: Contents of composer.json</p>
			<p>Requiring packages as dev dependencies is a way to maintain a nice separation between the code you intend to go out to production and the code that is really only meant for development purposes.</p>
			<h2 id="_idParaDest-343"><a id="_idTextAnchor352"/>Packagist</h2>
			<p>Composer has a companion site at <a href="https://packagist.org">https://packagist.org</a> that serves as the primary listing of all the packages available to be pulled into your project. When you are adding features to your application, you should first ask yourself whether other developers have likely solved this problem before you, and then you should check Packagist to see whether there's a package that can simplify the development of your feature. This will make you much more efficient as a developer, as you will not be spending time writing code that's been written time and time again by other developers and can focus on the code that makes your project deliver value. The cost of developing software is more than just writing code; you have to test the code and maintain it. Making a habit of using open source solutions can save you countless hours of development time in the long run. Simply search according to the keyword of the functionality you are looking for, or by the name of the package if you know it. </p>
			<p>An important concept to understand when you are browsing packages on Packagist is that they are prefixed with a vendor namespace, followed by a slash and the name of the actual package. For example, there is a group of developers who call themselves <em class="italic">The League of Extraordinary Packages</em> because they produce a variety of open source libraries that are well-tested and use modern coding practices. </p>
			<p>One of their popular packages is <strong class="source-inline">flysystem</strong>, a library that functions as an abstraction layer for interacting with the filesystem. The vendor name that they operate under is "league," so the name of the package is <strong class="source-inline">league/flysystem</strong>.</p>
			<p>Having both the vendor name and package name combined helps by allowing projects to have the same base name, while still being able to distinguish between two different packages. In some cases, a project that has the same name but two different vendor prefixes may be a project that was abandoned by one vendor and picked up by another under the new vendor name. That's one of the great things about open source. Projects are always available to be copied and used as a starting point for extension.</p>
			<h2 id="_idParaDest-344"><a id="_idTextAnchor353"/>Exercise 9.7: Discovering Packages on Packagist.org</h2>
			<p>In the following exercise, we will walk through an example of the way you might use the Packagist site to seek out a package and some criteria you can use as guidance for evaluating different packages so that you can choose the one that's right for your specific situation. We will search for a widely used package to handle logging functionality in our application:</p>
			<ol>
				<li value="1">Open a browser window and navigate to <a href="https://packt.live/2MlwgNv">https://packt.live/2MlwgNv</a>:<div class="IMG---Figure" id="_idContainer269"><img alt="Figure 9.11: Packagist window&#13;&#10;" src="image/C14196_09_11.jpg"/></div><p class="figure-caption">Figure 9.11: Packagist window</p></li>
				<li>In the main search bar, enter <strong class="source-inline">logging</strong>:<div class="IMG---Figure" id="_idContainer270"><img alt="Figure 9.12: Searching packages&#13;&#10;" src="image/C14196_09_12.jpg"/></div><p class="figure-caption">Figure 9.12: Searching packages</p><p class="callout-heading">Note </p><p class="callout">Packagist lists the number of downloads and stars a package has in the search results. It is a good idea to select packages that have as many downloads and stars as possible, as those are more likely to be quality packages and to maintain support in the long term.</p></li>
				<li>Click the link to view the details pertaining to the monolog/monolog package, which should be one of the first listings. At the time of writing, it has over 132 million downloads and in excess of 14,000 stars:</li>
			</ol>
			<div>
				<div class="IMG---Figure" id="_idContainer271">
					<img alt="Figure 9.13: Details of Monolog&#13;&#10;" src="image/C14196_09_13.jpg"/>
				</div>
			</div>
			<p class="figure-caption">Figure 9.13: Details of Monolog</p>
			<p class="callout-heading">Note </p>
			<p class="callout">In the panel on the right-hand side, you will see links to the repository on GitHub and to the home page for the package. These will frequently provide important instructions on how to use the package. You can review the source code of the package on GitHub. This is useful for evaluating the quality of the package.</p>
			<p>There is a lot of information that you can glean from the details page of a package on Packagist that will help you to determine whether it is a good idea to include it in your own project. Here are some things you may want to consider: is the package in widespread use by other developers? A good indication of this is the number of stars, installs, and other packages that list it as a suggestion. </p>
			<p>The more people that use the package, the more likely it is to be well maintained long into the future. If the project does not have as many stars and downloads as some of the other very popular projects, is it because it only applies to a narrower set of use cases, and yet is still very much in demand with this smaller group? Are there many open issues on the GitHub page for the project? Have they responded to them? How long have they been open? Are there many that have been resolved? When was the last update made to the project? Finding answers to these questions should give you a sense of whether or not the project is being maintained well.</p>
			<p>Because the projects are open source, we will see forks and pull requests. A fork is when a developer creates a copy of the project under their own vendor name so that they can make updates to the project and most likely submit them back to the main project maintainer in a pull request. It's called a pull request because the developer that made the update is making a request to pull the update back into the main project repository. You can see on GitHub how many pull requests have been merged, and it's a really good indicator that the project will be updated as time goes on, and even allow you the opportunity to contribute back to the project if you discover a useful feature or a bug that needs to be fixed.</p>
			<p>In the center pane of the details page, you will see two lists of other packages: one listing packages that the selected package has as its own dependencies, while the other has suggested packages. If you plan on installing a package, it's a good idea to evaluate each of the package's dependencies just as you would the original package, as they will all end up being code that your application could potentially execute. You may not be able to read every line of source code, but you should be able to get a reasonable idea of whether or not the package is respectable. The suggested packages are packages that will work with the selected package, but would not be applicable to every project that installs the package and were not therefore worth including in the main package. For example, the <strong class="source-inline">flysystem</strong> package we mentioned earlier has many suggestions for extensions that integrate with systems including Amazon Web Services, Azure, and Dropbox. It makes the most sense to only include the base and let users pick which extensions apply to themselves.</p>
			<p>It is also important to take a moment to note that these packages are being made freely available over the internet, and you should also evaluate them from a security perspective and ensure that you are receiving the code you expect when you install them.</p>
			<p>These are the important pieces of information you should consider when selecting third-party software to include in your project. If you prefer not to interface directly with Packagist, the makers of Composer provide solutions to be used in the Enterprise, Toran Proxy and Satis. These solutions function as proxies to both Packagist and GitHub and can be used to host your own company's packages, but keep them private to your own organization. Toran Proxy provider has been phased out, and Private Packagist (<a href="https://packt.live/2Beq5Ez">https://packt.live/2Beq5Ez</a>) is recommended These days, open source software has solved many of our common problems and, with a little effort, you will often find a package to do exactly what you are looking for and you are only left to implement it.</p>
			<h1 id="_idParaDest-345"><a id="_idTextAnchor354"/>Namespaces</h1>
			<p>Before we go on to actually using a package we have installed with Composer, let's take a brief moment to review what we learned about namespaces in <em class="italic">Chapter 5</em>, <em class="italic">ObjectOriented Programming</em>. This is a similar concept to the namespaces we just referenced on the Packagist site. However, these are built into the PHP language. Namespaces have been part of PHP since version 5.3 and most, if not all, of the libraries you come across will use namespaces. Namespaces allow multiple pieces of code that would otherwise have a name collision to exist side by side. Prior to namespaces, vendors would inconveniently have to create extraordinarily long class names that were prefixed with their vendor name and usually separated by underscores to avoid naming collisions. It is highly recommended that you use namespaces in your own code to help keep things well organized and simplify references between files.</p>
			<p>To define a namespace in a file, it must be declared at the top of a file before any other code. Just use the <strong class="source-inline">namespace</strong> keyword, followed by the namespace you want to define, and complete the line with a semicolon. You can prefix a namespace in a directory structure-like manner by inserting a backslash character between the prefix and the namespace. You can use multiple levels of prefixes if you so desire. You will see an example of this in the next exercise. To reference a namespace, you can either reference a full namespace by providing an absolute path to the namespace, or you can make use of the <strong class="source-inline">use</strong> keyword, which will make the namespace available throughout the rest of the scope. This will also be demonstrated in the example.</p>
			<h2 id="_idParaDest-346"><a id="_idTextAnchor355"/>Autoloading</h2>
			<p>There is one more subject we need to touch on before writing code to use one of the dependencies we installed, and that is autoloading. Autoloading is a term that refers to programmatically automating the inclusion of classes and functions external to the file you are working in. Without it, our code would be littered with <strong class="source-inline">include</strong> or <strong class="source-inline">require</strong> statements. PHP offers a function, <strong class="source-inline">spl_autoload_register</strong>, that accepts a function to do your autoloading for you, but Composer makes it even easier than that. </p>
			<p>When Composer creates the vendor directory, it places an <strong class="source-inline">autoload.php</strong> file in it. With a little configuration in the <strong class="source-inline">composer.json</strong> file, if you require this one file (ideally in a central file as part of bootstrapping the rest of your application) and follow the convention for naming your files and directories, Composer will automatically include everything for you, saving you the hassle.</p>
			<h2 id="_idParaDest-347"><a id="_idTextAnchor356"/>Using Composer Packages</h2>
			<p>Let's now walk through using a library pulled in by Composer. You can use this example of Monolog as a solid base to use for your logging in any PHP application you build. First, we will create a simple script to work as our example, and then we will wire our script up to Composer so that the classes in our dependencies will be autoloaded. This way, our own code can be kept clean and not be cluttered by needless <strong class="source-inline">require</strong> or <strong class="source-inline">include</strong> statements.</p>
			<p>Composer can also autoload your own classes for you. You can configure this in the <strong class="source-inline">composer.json</strong> file. PHP has a standard way of structuring your files and directories so that you don't need to specify them. It is part of a series of standards maintained by the PHP-FIG. The autoloading standard is named PSR-4. You can see the full documentation at <a href="https://packt.live/314fBCj">https://packt.live/314fBCj</a>. To follow this standard, you should place your classes in a directory structure that matches the namespace structure of your class. For example, if you wrote a dummy class with the namespace <strong class="source-inline">Acme/Helper</strong>, the path to it would be <strong class="source-inline">Acme/Helper/Dummy.php</strong>. Often, this path exists inside another directory inside your project root to keep your application code separate, such as an <strong class="source-inline">src</strong> directory.</p>
			<h2 id="_idParaDest-348"><a id="_idTextAnchor357"/>Exercise 9.8: Using PSR-4 to Load Classes</h2>
			<p>In this exercise, we will write a basic PHP class and use a filename and directory structure that conforms to the PSR-4 convention. Then, we will use Composer to autoload that class, omitting the need to require the class file ourselves:</p>
			<ol>
				<li value="1">Inside the directory that contains the <strong class="source-inline">composer.json</strong> file, create a new directory named <strong class="source-inline">src</strong>. Inside that directory, create a directory named <strong class="source-inline">Packt</strong>:<p class="source-code">mkdir src</p><p class="source-code">cd src</p><p class="source-code">mkdir Packt</p></li>
				<li>Inside the <strong class="source-inline">Packt</strong> directory, create a file named <strong class="source-inline">Example.php</strong> with the following contents:<p class="source-code">&lt;?php</p><p class="source-code">namespace Packt;</p><p class="source-code">class Example</p><p class="source-code">{</p><p class="source-code">    public function doSomething()</p><p class="source-code">    {</p><p class="source-code">        echo "PHP is great!" . PHP_EOL;</p><p class="source-code">    }</p><p class="source-code">}</p></li>
				<li>Back at the root of your project, open the <strong class="source-inline">composer.json</strong> file and add the autoload section below the <strong class="source-inline">require-dev</strong> section:<p class="source-code-heading">composer.json</p><p class="source-code">15 "require-dev": {</p><p class="source-code">16       "phpunit/phpunit": "^8.0"</p><p class="source-code">17 },</p><p class="source-code">18 "autoload": {</p><p class="source-code">19       "psr-4": {</p><p class="source-code">20             "Packt\\":"src/Packt/"</p><p class="source-code">21 }</p><p class="source-code">22 }</p><p class="source-code-link"><a href="https://packt.live/2VSAwHu">https://packt.live/2VSAwHu</a></p></li>
				<li>Create an <strong class="source-inline">index.php</strong> file:<p class="source-code">&lt;?php</p><p class="source-code">require 'vendor/autoload.php';</p><p class="source-code">use Packt\Example;</p><p class="source-code">$e = new Example();</p><p class="source-code">$e-&gt;doSomething();</p></li>
				<li>Run the <strong class="source-inline">index.php</strong> file. You can see the output in the following screenshot:</li>
			</ol>
			<div>
				<div class="IMG---Figure" id="_idContainer272">
					<img alt="Figure 9.14: Output of the index&#13;&#10;" src="image/C14196_09_14.jpg"/>
				</div>
			</div>
			<p class="figure-caption">Figure 9.14: Output of the index</p>
			<p>You can see that by configuring Composer and following the PSR-4 format, your class will be loaded up into memory on demand as you call it, without the need to explicitly require the file. Next, let's extend our example with a very basic Monolog implementation.</p>
			<h2 id="_idParaDest-349"><a id="_idTextAnchor358"/>Exercise 9.9: Implementing Monolog</h2>
			<p>In this exercise, we will give an example implementation of integrating with the Monolog library we installed earlier in this chapter. This example assumes you have worked through the previous examples and are at a Command Prompt in the main project directory:</p>
			<ol>
				<li value="1">From the command line, create a <strong class="source-inline">logs</strong> directory. This directory will be where our logs will be written:<p class="source-code">mkdir logs</p></li>
				<li>Edit the <strong class="source-inline">index.php</strong> file to include <strong class="source-inline">use</strong> statements for Monolog, set up a handler, and pass it to our <strong class="source-inline">Example</strong> class:<p class="source-code">&lt;?php</p><p class="source-code">require 'vendor/autoload.php';</p><p class="source-code">use Monolog\Logger;</p><p class="source-code">use Monolog\Handler\StreamHandler;</p><p class="source-code">use Packt\Example;</p><p class="source-code">$logger = new Logger('application_log');</p><p class="source-code">$logger-&gt;pushHandler(new StreamHandler('./logs/app.log', Logger::INFO));</p><p class="source-code">$e = new Example($logger);</p><p class="source-code">$e-&gt;doSomething();</p></li>
				<li>Edit the <strong class="source-inline">src/Example.php</strong> file to add the <strong class="source-inline">use</strong> statements for Monolog, add a constructor to accept the logger, and call the logger:<p class="source-code-heading">Example.php</p><p class="source-code">1  &lt;?php</p><p class="source-code">2  namespace Packt;</p><p class="source-code">3  use Monolog\Logger;</p><p class="source-code">4  class Example</p><p class="source-code">5  {</p><p class="source-code">6      protected $logger;</p><p class="source-code">7      public function __construct(Logger $logger)</p><p class="source-code">8      {</p><p class="source-code">9          $this-&gt;logger = $logger;</p><p class="source-code">10     }</p><p class="source-code-link"><a href="https://packt.live/2MNutj6">https://packt.live/2MNutj6</a></p></li>
				<li>Run the <strong class="source-inline">index.php</strong> script again:<p class="source-code">php index.php</p></li>
				<li>Now, view the <strong class="source-inline">app.log</strong> file in the <strong class="source-inline">./logs</strong> directory:</li>
			</ol>
			<div>
				<div class="IMG---Figure" id="_idContainer273">
					<img alt="Figure 9.15: Printing the log&#13;&#10;" src="image/C14196_09_15.jpg"/>
				</div>
			</div>
			<p class="figure-caption">Figure 9.15: Printing the log</p>
			<p>You will see three lines written to it for the three log levels in the <strong class="source-inline">doSomething</strong> method.</p>
			<p>Working through this example has not only shown you how to use libraries you have included in your project with Composer, but also gives you a very basic example of setting up Monolog that you can apply the same principles to in order to set up advanced logging in your application.</p>
			<p>Before starting the next activity, there are a few concepts you should be familiar with in order to make it useful in the real world. You will modify the example application we just wrote to generate a universally unique identifier, known as a UUID for short. A UUID is a 128-bit number used to uniquely identify data in computer systems. They look like long alphanumeric strings with sections separated by dashes. They can have many use cases, but one of the most common is to generate unique IDs for data in your system that you may store in a database. It is generally considered poor practice nowadays to use ascending integers as unique identifiers for your publicly accessible objects as you may not want the user to be able to guess the next one in the sequence. The package we have selected for the activity makes this task trivial.</p>
			<h2 id="_idParaDest-350"><a id="_idTextAnchor359"/>Activity 9.1: Implementing a Package to Generate a UUID</h2>
			<p>In this activity, you have an opportunity to apply what you have learned in this chapter. You will need to have completed the previous exercises in this chapter and use them as a starting point. There is a Composer package for generating UUIDs named <strong class="source-inline">ramsey/uuid</strong>:</p>
			<ol>
				<li value="1">Add the UUID package to your project dependencies and ensure that it is installed in the vendor directory.</li>
				<li>Add a method to your <strong class="source-inline">Example.php</strong> script to call the library to generate a UUID and echo the result. There are multiple methods provided for generating one; <strong class="source-inline">uuid1()</strong> will be sufficient. Include a concatenated new line, <strong class="source-inline">PHP_EOL</strong>, at the end of your <strong class="source-inline">echo</strong> statement.</li>
				<li>Call the new method you created in <strong class="source-inline">Example.php</strong> from your <strong class="source-inline">index.php</strong> file after your previous output.</li>
				<li>Run the <strong class="source-inline">index.php</strong> script and confirm that you see the UUID generated.</li>
			</ol>
			<p>The output should be similar to the following:</p>
			<div>
				<div class="IMG---Figure" id="_idContainer274">
					<img alt="Figure 9.16: Expected Outcome&#13;&#10;" src="image/C14196_09_16.jpg"/>
				</div>
			</div>
			<p class="figure-caption">Figure 9.16: Expected Outcome</p>
			<p class="callout-heading">Note</p>
			<p class="callout">The solution to this activity can be found on page 558.</p>
			<h1 id="_idParaDest-351"><a id="_idTextAnchor360"/>Summary</h1>
			<p>In this <a id="_idTextAnchor361"/>chapter, you were introduced to the concept of dependency management and Composer, the primary tool for bringing external dependencies into your projects in PHP. Dependency management is important to keep your own application code separate from third-party libraries that need to be kept up to date and compatible with one another.</p>
			<p>We covered Packagist, Composer's companion site that catalogs packages available for inclusion in projects. You can identify reputable packages by noting the rating, the number of downloads, and other such criteria. The site links to the source code of each of its listings, so you can review the code yourself if you need a better understanding of its inner workings or if you want to confirm the quality of the code.</p>
			<p>We provided an overview of setting up your project to use Composer and how to use the essential features you will need to integrate with other libraries. Libraries are required in the command line or by editing the <strong class="source-inline">composer.json</strong> file directly. They can have version constraints placed on them so that Composer will only install versions from a specified range. Each time a package is required, a lock file is generated to keep track of the exact versions of the current set of installed libraries. Packages can also be specified as only for development purposes, and therefore can be omitted when passing a flag to the <strong class="source-inline">install</strong> script to omit development dependencies. </p>
			<p>Finally, we set up a sample implementation of Monolog to demonstrate using a package installed by Composer. We can use Composer to autoload our own code as long as we follow the PSR-4 standard and take advantage of namespaces. In the next chapter, we will look at the basics of concepts of web services and connecting your application with them using Guzzle, a popular PHP open-source library for making HTTP requests.</p>
			<p>In the next chapter, we will present an overview of web services and take a look at some examples of interacting with them.</p>
		</div>
	</body></html>