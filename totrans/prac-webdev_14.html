<html><head></head><body><div class="chapter" title="Chapter&#xA0;14.&#xA0;Node.js"><div class="titlepage"><div><div><h1 class="title"><a id="ch14"/>Chapter 14. Node.js</h1></div></div></div><p>Congratulations! You have now made it to the final chapter of this book. After having gone through most of the technologies used in both classical and modern web development, we are now going to discuss the basics of what I would like to call the <span class="emphasis"><em>avant-garde</em></span>, excuse my French, of web development: node.js and friends.</p><p>In everything we discussed so far, we used what is often referred to as<a id="id917" class="indexterm"/> the <span class="strong"><strong>LAMP</strong></span> (or <span class="strong"><strong>MAMP</strong></span> or <span class="strong"><strong>WAMP</strong></span>, depending <a id="id918" class="indexterm"/>on the OS on your server) stack: <span class="strong"><strong>Linux </strong></span><a id="id919" class="indexterm"/>
<span class="strong"><strong>Apache MySQL PHP</strong></span>. Even when<a id="id920" class="indexterm"/> we swap out MySQL for <a id="id921" class="indexterm"/>
<span class="strong"><strong>MongoDB</strong></span>, the acronym still stands. Or we could call it <span class="strong"><strong>LANP</strong></span> <a id="id922" class="indexterm"/>with the N of <a id="id923" class="indexterm"/>
<span class="strong"><strong>NoSQL</strong></span>.</p><p>So we had to learn all these languages: JavaScript on the client side, to be interpreted by the browser; PHP, to be interpreted by the Apache web server; and many more. Just imagine you could swap out everything, even things you would not think of—the web server— in favor of JavaScript? That is what node.js does for you. As I, being of a somewhat older generation, see it, node.js did to web development what Schoenberg and Webern did to classical music, Picasso and Braque to painting, and oh well, why not, Venice Beach rappers to pop music.</p><p>There is good news and bad news here. The bad news is that we are at risk of having to start everything over again and have learned a lot of things in vain, but the good news is that node.js based solutions <span class="emphasis"><em>perform</em></span> well, <span class="emphasis"><em>scale</em></span> well, and, for those that come after us, only require the knowledge of a single programming<a id="id924" class="indexterm"/> language: JavaScript. Acronyms for this are still up for grabs: <span class="strong"><strong>LJMJ</strong></span> <a id="id925" class="indexterm"/>or <span class="strong"><strong>LNMJ</strong></span> (J for <span class="strong"><strong>JavaScript</strong></span> or N for <span class="strong"><strong>node.js</strong></span> respectively) or <a id="id926" class="indexterm"/>
<span class="strong"><strong>MEN</strong></span> (<span class="strong"><strong>MongoDB</strong></span>, <span class="strong"><strong>Express</strong></span>, <span class="strong"><strong>node.js</strong></span>)? One that is already used a<a id="id927" class="indexterm"/> lot is <span class="strong"><strong>MEAN</strong></span>. Over time people will agree on one. Who invented the word <span class="emphasis"><em>cubism</em></span>?</p><p>In this chapter, we will make an attempt to repeat everything you have learned so far while doing things the node.js way. So we already know in which language our code will be written: JavaScript. What we are going to write may come as a surprise to you.</p><div class="section" title="Node.js"><div class="titlepage"><div><div><h1 class="title"><a id="ch14lvl1sec88"/>Node.js</h1></div></div></div><p>Let's recapitulate a bit; in <a class="link" href="ch01.html" title="Chapter 1. The World Wide Web">Chapter 1</a>, <span class="emphasis"><em>The World Wide Web</em></span>, you learned about the World Wide Web and how all these millions of pages are accessed by people using a browser that sends requests to a web server <a id="id928" class="indexterm"/>using the HTTP protocol. Well, people will still use browsers that send HTTP requests, but we just tossed the web server, now what do we do? We write one. Scary? No, it will be a lot of fun. Writing low-level code is not your thing? No sweat, somebody already did it for you. There is a whole community writing code for node.js that everybody else can use. That code is made available as what is referred to as <span class="strong"><strong>modules</strong></span>, and of<a id="id929" class="indexterm"/> course there is a HTTP module available to us.</p><p>Another thing the web server did for us was to actually analyze the URL the user typed and explore the <span class="strong"><strong>file system</strong></span> to see<a id="id930" class="indexterm"/> whether there is a physical file, for example, an <code class="literal">hello.html</code> file, and serve it up back to the client. We will have to write that too. This is cool because it will give us full control over what exactly our web server should be able to handle and what it shouldn't. As expected, there are <code class="literal">url</code> and <code class="literal">fs</code> modules for node.js as well.</p><p>We will need a database but, we already know one that we like: MongoDB. Can we use it with node.js? Yes we can. There is a module or driver for it to access the existing MongoDB server from node.js. As MongoDB is a document database and documents are really JSON objects, this is a perfect fit in an all-JavaScript ecosystem.</p><p>Little by little we are beginning to realize, before even having written one, whether a node application is actually going to be a web server that contains application-specific code or an application that contains a web server; take your pick.</p><p>As soon as I walk you through our first examples, you will realize that we never before had a need to write so much code for a simple <code class="literal">Hello, World</code> program. Imagine having to write a fully-featured single page web application with so much low-level code? This is where <span class="emphasis"><em>Express</em></span> fits in. It is a framework for node.js that will help us write cleaner, more compact code. This is our jQuery on the server side. As soon as our examples become too boringly long, we will switch to Express.</p><p>There is another thing we tossed: Apache as an <a id="id931" class="indexterm"/>
<span class="strong"><strong>Application Server</strong></span>, the part that gave us PHP as a language on the server. We have been generating HTML dynamically on the server using PHP and, by the time the browser read it, it had become all HTML.</p><p>The nice part of using PHP was that we could embed PHP code inside plain HTML in between <code class="literal">&lt;?php</code> and <code class="literal">?&gt;</code>. Stuffing an HTML file with <code class="literal">&lt;script&gt;</code> tags to include JavaScript code is not very appealing. We will look at a solution for that as well.</p></div></div>
<div class="section" title="Installing node.js"><div class="titlepage"><div><div><h1 class="title"><a id="ch14lvl1sec89"/>Installing node.js</h1></div></div></div><p>Let's not delay any<a id="id932" class="indexterm"/> further and install node on your computer. How to install it will be different depending on the OS <a id="id933" class="indexterm"/>you are running. Go to <a class="ulink" href="http://nodejs.org/">http://nodejs.org/</a> and get<a id="id934" class="indexterm"/> the proper <a id="id935" class="indexterm"/>download. The result is the same everywhere: it gives us two programs: <span class="strong"><strong>node</strong></span><a id="id936" class="indexterm"/> and <span class="strong"><strong>npm</strong></span>.</p><div class="section" title="npm"><div class="titlepage"><div><div><h2 class="title"><a id="ch14lvl2sec138"/>npm</h2></div></div></div><p>npm, the <span class="strong"><strong>node packaging manager</strong></span>, is the tool that<a id="id937" class="indexterm"/> you use to look for and install modules. Each time you <a id="id938" class="indexterm"/>write code that needs a module, you specify this by putting something like the following in your code:</p><div class="informalexample"><pre class="programlisting">var module = require('module');</pre></div><p>It will have to be installed if it is not yet present, using the command:</p><div class="informalexample"><pre class="programlisting"><span class="strong"><strong>npm install</strong></span>
</pre></div><p>Or you can also use:</p><div class="informalexample"><pre class="programlisting"><span class="strong"><strong>npm -g install</strong></span>
</pre></div><p>The latter will attempt to install the module globally, the former command in the directory where the command is issued. It will typically install the <a id="id939" class="indexterm"/>module in a folder called <span class="strong"><strong>node_modules</strong></span>.</p></div><div class="section" title="node"><div class="titlepage"><div><div><h2 class="title"><a id="ch14lvl2sec139"/>node</h2></div></div></div><p>The <code class="literal">node</code> command is the <a id="id940" class="indexterm"/>command to use to start your node.js program, for example:</p><div class="informalexample"><pre class="programlisting"><span class="strong"><strong>node myprogram.js</strong></span>
</pre></div><p>Node will start<a id="id941" class="indexterm"/> and interpret your code. Type <span class="emphasis"><em>Ctrl</em></span> + <span class="emphasis"><em>C</em></span> to stop node. Let's get to our first programs right away.</p><p>Our inevitable <code class="literal">Hello, world</code> example is the smallest possible web server:</p><div class="informalexample"><pre class="programlisting">var http = require('http');
   http.createServer(function (req, res) {
     res.writeHead(200, {'Content-Type': 'text/plain'});
     res.end('Hello World\n');
   }).listen(8080, 'localhost');
   console.log('Server running at http://localhost:8080');</pre></div><p>Save this file as <code class="literal">hello.js</code>, or get it from the Packt Publishing website and, in a terminal window, type:</p><div class="informalexample"><pre class="programlisting"><span class="strong"><strong>node hello.js</strong></span>
</pre></div><p>This command will run the program using <code class="literal">node</code>. In the terminal window, which becomes your console, you will see the text <code class="literal">Server running</code>.</p><p>Next, when you start a browser and type in <code class="literal">http://localhost:8080</code> as the URL, something that looks like a web page, containing the famous two-word sentence <code class="literal">Hello World</code>, will appear. As a matter of fact, if you go to <code class="literal">http://localhost:8080/it/does/not/matterwhat</code>, the same thing will appear. Not very useful maybe, but it<a id="id942" class="indexterm"/> is a web server.</p><div class="section" title="Adding HTML"><div class="titlepage"><div><div><h3 class="title"><a id="ch14lvl3sec84"/>Adding HTML</h3></div></div></div><p>This is a slightly different version where <a id="id943" class="indexterm"/>we explicitly specify that we send HTML instead of plain text:</p><div class="informalexample"><pre class="programlisting">var http = require('http');
   http.createServer(function (req, res) {
     res.writeHead(200, {'Content-Type': 'text/html'});
     res.end('&lt;h1&gt;Hello World\&lt;/h1&gt;');
   }).listen(8080, 'localhost');
   console.log('Server running at http://localhost:8080');</pre></div></div><div class="section" title="Serving up static content"><div class="titlepage"><div><div><h3 class="title"><a id="ch14lvl3sec85"/>Serving up static content</h3></div></div></div><p>We are not used to the same<a id="id944" class="indexterm"/> thing popping up no matter what path we give as an URL. URLs typically point to a file (or a folder, in which case the server looks for an <code class="literal">index.html</code> file), <code class="literal">foo.html</code> or <code class="literal">bar.php</code>, and, when present, it is served up to the client.</p><p>So what if we want to do this with node.js? We need a module. There are several ways to do the job. We use <code class="literal">node-static</code> in our example. First we need to install it:</p><div class="informalexample"><pre class="programlisting"><span class="strong"><strong>npm install node-static</strong></span>
</pre></div><p>You can typically find documentation on methods and properties on Github and other cool places. In our app, we create not only a web server but a <code class="literal">fileserver</code> as well. It will serve all the files in the local directory <code class="literal">public</code>. It is good to have all so called <code class="literal">static content</code> together in a separate folder. This is basically all the files that will be served up to and interpreted by the client. As we will now end up with a mix of client code and server code, it is good practice to separate them. When you use the Express framework, it will create these things for you.</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">In our project folder we create <code class="literal">hello.js</code>, our node.js app:<div class="informalexample"><pre class="programlisting">var http = require('http');
var static = require('node-static');
var fileServer = new static.Server('./public');
   http.createServer(function (req, res) {
     fileServer.serve(req,res);
   }).listen(8080, 'localhost');
   console.log('Server running at http://localhost:8080');</pre></div></li><li class="listitem">Next, in a subfolder <code class="literal">public</code>, we create <code class="literal">hello.html</code>:<div class="informalexample"><pre class="programlisting">&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;head&gt;
&lt;meta charset="UTF-8" /&gt;
&lt;title&gt;Hello world document&lt;/title&gt;
&lt;link href="./styles/hello.css" rel="stylesheet"&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;h1&gt;Hello, World&lt;/h1&gt;
&lt;/body&gt;
&lt;/html&gt;</pre></div></li><li class="listitem">We can create the<a id="id945" class="indexterm"/> background with <code class="literal">hello.css</code> as follows:<div class="informalexample"><pre class="programlisting">body {
  background-color:#FFDEAD;
}
h1
{
  color:teal;
  margin-left:30px;
}
.bigbutton {
  height:40px;
  color: white;
  background-color:teal;
  margin-left:150px;
  margin-top:50px;
  padding:15 15 25 15;
  font-size:18px;
}</pre></div></li></ol></div><p>So if we now visit <code class="literal">http://localhost:8080/hello.html</code>, we will see our by now too familiar <code class="literal">Hello World</code> message with some basic styling, proving that our file server also delivered the CSS file.</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Now we will take it one step further by actually adding JavaScript to our html file (<code class="literal">hellobutton.html</code> (body only)). We will reuse the previous CSS file, create a slightly different HTML file, and add a JavaScript file. I assume you have a copy of jQuery around somewhere.<div class="informalexample"><pre class="programlisting">&lt;body&gt;
&lt;div id="content"&gt;
&lt;button type="button" id="hellobutton" class="bigbutton"&gt;Click here for a message&lt;/button&gt;
&lt;/div&gt;
&lt;script src="js/jquery.js"&gt;&lt;/script&gt;
&lt;script src="js/hellobutton.js"&gt;&lt;/script&gt;
&lt;/body&gt;</pre></div></li><li class="listitem">To add the<a id="id946" class="indexterm"/> button, let's create <code class="literal">hellobutton.js</code>:<div class="informalexample"><pre class="programlisting">$(document).ready(function(){
$("#content").on("click", "#hellobutton", function(data){
$('#hellobutton').text("Hello World");
  } );
});</pre></div></li></ol></div><p>So when we go to <code class="literal">http://localhost:8080/hellobutton.html</code>, we see a web page with a button; when we click on it, its text changes into <code class="literal">Hello World</code>. This means our client-side jQuery and JavaScript works.</p><p>In the <code class="literal">public</code> folder, create a file <code class="literal">index.html</code>:</p><div class="informalexample"><pre class="programlisting">&lt;!DOCTYPE html &gt;
&lt;html&gt;
&lt;body&gt;
&lt;h1&gt;It works!&lt;/h1&gt;
&lt;/body&gt;
&lt;/html&gt;</pre></div><p>If we go to <code class="literal">http://localhost:8080</code>, we see <span class="emphasis"><em>It Works !</em></span> Just like when we hit the document root of the Apache Web Server. This is because our <code class="literal">node-static</code> module has that file configured as the default.</p><p>But there are other things that do not work the way we are used to. If we type <code class="literal">hellobutton</code> instead of <code class="literal">hellobutton.html</code>, nothing will happen, as we did not program our web server to look for <code class="literal">hellobutton.something</code>. Don't even think of wanting to process <code class="literal">hello.html?key=value</code>.</p><p>On the other hand, if you put a picture file, for example, <code class="literal">baywatchstation.jpg</code>, in <code class="literal">./public</code> and type <code class="literal">http://localhost:8080/baywatchstation.jpg</code>, you will see the picture in your browser. All this is done with very few lines of code and two cool node.js modules.</p></div><div class="section" title="A tale of two (JavaScript) cities"><div class="titlepage"><div><div><h3 class="title"><a id="ch14lvl3sec86"/>A tale of two (JavaScript) cities</h3></div></div></div><p>We have reached an important stage here: we<a id="id947" class="indexterm"/> have two different JavaScript files, they are both located on our server, but one is interpreted by node.js and the other one is served up by node.js and interpreted by the browser, in other words the client.</p><p>Try this: <code class="literal">http://localhost:8080/js/hellobutton.js</code>. You will see the code of your JavaScript file in a browser. Now insert <code class="literal">alert("Here's Johnny!");</code> and put <code class="literal">&lt;script&gt;</code> tags around it, save it, and refresh your browser. <code class="literal">Johnny</code> pops up and then JavaScript continues with doing nothing without giving you any error message.</p><p>Because we configured <code class="literal">public</code> (well <code class="literal">node-static</code> did) as our document root of our mini web server, we cannot even reach <code class="literal">hello.js</code>, rescuing us from potentially greater confusion. I am confident that by now you understand the difference between a JavaScript file and a JavaScript file. That is why some developers have developed a habit of using different extensions (for example <code class="literal">.njs</code> for server-side JS files). I believe it is a lot clearer to place<a id="id948" class="indexterm"/> the different kinds of files in different folders as we have started doing.</p><p>But, so far, in such a short time, and just a few lines of code, we are capable of doing almost anything we discussed in this book up until now, the node.js way: we can handle HTML, CSS, JavaScript, and jQuery. We tossed PHP and we are replacing MySQL with MongoDB. This leaves us just with the latter and Ajax and then we will have, in a way, rewritten our book the node.js way.</p></div></div><div class="section" title="node.js and MongoDB"><div class="titlepage"><div><div><h2 class="title"><a id="ch14lvl2sec140"/>node.js and MongoDB</h2></div></div></div><p>In <a class="link" href="ch11.html" title="Chapter 11. MongoDB">Chapter 11</a>, <span class="emphasis"><em>MongoDB</em></span>, we introduced MongoDB, a document database, and you learned how to access it from<a id="id949" class="indexterm"/> the command line as well as from within a PHP program. Doing so in node.js is even easier. First of all, let's not forget to start the MongoDB server inside a separate terminal window:</p><div class="informalexample"><pre class="programlisting"><span class="strong"><strong>mongodb</strong></span>
</pre></div><p>Next we need, of course, a node.js module, <code class="literal">mongodb</code>:</p><div class="informalexample"><pre class="programlisting"><span class="strong"><strong>npm install mongodb</strong></span>
</pre></div><p>Here follows a simple program that connects to the MongoDB server, the <code class="literal">california</code> database to be precise, and looks up a document in the <code class="literal">people</code> collection.</p><div class="informalexample"><pre class="programlisting">var MongoClient = require('mongodb').MongoClient;
   MongoClient.connect('mongodb://localhost:27017/california',
   function(err, db) {
       console.log('Connected to MongoDB!');
       var collection = db.collection('people');
       collection.findOne({name: 'Adams'}, function(err, doc) {
               console.log(doc.first + ' - ' + doc.name);
               db.close();
      });
    });</pre></div><div class="section" title="Déjà vu … once more"><div class="titlepage"><div><div><h3 class="title"><a id="ch14lvl3sec87"/>Déjà vu … once more</h3></div></div></div><p>As I went through my first steps with node.js, I had a déjà vu experience. To paraphrase the Grace Jones song based on <span class="emphasis"><em>Libertango</em></span> by Astor Piazolla: <span class="emphasis"><em>Strange, I have seen that happen before</em></span>.</p><p>With node.js, you only add <a id="id950" class="indexterm"/>what you need, so it does not include the kitchen sink by default. This can only mean you will benefit from that as far as performance goes.</p><p>I am a UNIX person but this story goes back to when Linus had not yet rewritten it as Linux, Mac OS X did not exist yet, and so on. Memory and disk space were expensive, so was UNIX, as manufacturers had to pay royalties.</p><p>I was a proud product manager of a PC UNIX product and one of our coolest value-added things was a tool called <a id="id951" class="indexterm"/>
<span class="strong"><strong>kconfig</strong></span>, which would <a id="id952" class="indexterm"/>allow people to customize what was inside the UNIX kernel, so it would only contain what was needed. This is what node.js reminds me of. And it is written in C, just like UNIX. <span class="emphasis"><em>Déjà vu</em></span>.</p><p>Cool as it was then, it would not be cool today, because so much more has been added to UNIX: it would not be manageable.</p><p>The same is true if we wanted to mimic everything the Apache web server can handle with pure node.js. Just look at the output of the PHP <code class="literal">phpinfo()</code> function. It shows all the modules that are loaded into Apache. If we wanted to support all these with with only node.js, we would need too many modules and would end up with unreadable code. The movie Amadeus comes to mind, where the emperor's sidekicks agree on one thing about Mozart's <span class="emphasis"><em>Le Nozze di Figaro</em></span> (I don't): Too many notes!</p></div></div></div>
<div class="section" title="Express"><div class="titlepage"><div><div><h1 class="title"><a id="ch14lvl1sec90"/>Express</h1></div></div></div><p>A good way to get the job done with fewer<a id="id953" class="indexterm"/> notes is by using the Express framework. On the <a class="ulink" href="http://expressjs.com">expressjs.com</a> website, it is called a <span class="emphasis"><em>minimal and flexible node.js web application framework, providing a robust set of features for building web applications</em></span>.</p><p>There probably is no better<a id="id954" class="indexterm"/> way to describe what Express can do for you. It is minimal so there is little overhead for the framework itself. It is flexible, so you can add just what you need. As it gives a robust set of features, this means you do not have to create them yourselves and they have been tested by an ever-growing community.</p><div class="section" title="Installing Express"><div class="titlepage"><div><div><h2 class="title"><a id="ch14lvl2sec141"/>Installing Express</h2></div></div></div><p>Of course, Express is also a node<a id="id955" class="indexterm"/> module, so we install it as such. At the time of writing, we used <span class="strong"><strong>Express 4</strong></span>. In your project directory for your application, type:</p><div class="informalexample"><pre class="programlisting"><span class="strong"><strong>npm install express</strong></span>
</pre></div><p>Or you can also use:</p><div class="informalexample"><pre class="programlisting"><span class="strong"><strong>npm install —save express</strong></span>
</pre></div><p>If you specify the <code class="literal">—save</code> option, <code class="literal">npm</code> will update the <code class="literal">package.json</code> file. You will notice that a folder called <code class="literal">express</code> will be created inside <code class="literal">node_modules</code> and inside that one there is another collection of node-modules. These<a id="id956" class="indexterm"/> are examples of what is called <span class="strong"><strong>middleware</strong></span>.</p><p>In the few examples that follow, we assume app.js as the name for your node.js application and <code class="literal">app</code> for the variable that you will use in that file for your instance of Express. This is for the sake of brevity. It would be better to use a string that matches your project name.</p></div><div class="section" title="Our first Express app"><div class="titlepage"><div><div><h2 class="title"><a id="ch14lvl2sec142"/>Our first Express app</h2></div></div></div><p>Of course, we are <a id="id957" class="indexterm"/>going to do more <code class="literal">Hello, World</code> examples. Here is our first Express app:</p><div class="informalexample"><pre class="programlisting">var express = require('express');
var app = express();
app.set('port', process.env.PORT || 3000);
app.get('/', function (req, res) {
  res.send('&lt;h1&gt;Hello World!&lt;/h1&gt;');
});

app.listen(app.get('port'),  function () {
console.log('Express started on http://localhost:' +
  app.get('port') + '; press Ctrl-C to terminate.' );

});</pre></div><p>Well, compared to our second node.js example, it is about the same number of lines. But it looks a lot cleaner and it does more for us. You no longer need to explicitly include the HTTP module, you no longer have to specify which header to send, and, when you specify a different URL, you will not get <code class="literal">Hello, World</code> but a reasonable error message. We use <code class="literal">app.set</code> and <code class="literal">app.get</code> for the port. When the environment variable <code class="literal">PORT</code> is set, the port will be set to its value.</p><p>The other line containing <code class="literal">app.get</code> tells us what we want to happen when the server is presented with a URL in the <code class="literal">GET</code> mode. Like in node.js, there is a function with the <code class="literal">request</code> and <code class="literal">respond</code> objects as an argument. In <code class="literal">express</code>, they have been extended; there are more<a id="id958" class="indexterm"/> creative things you can do with them as there are more methods available to you.</p><p>For example, you have access to <code class="literal">req.body</code>, which will contain an object of all the values that were sent using<a id="id959" class="indexterm"/> the <code class="literal">POST</code> method in a form (using <code class="literal">app.post</code>).</p></div><div class="section" title="An example with middleware"><div class="titlepage"><div><div><h2 class="title"><a id="ch14lvl2sec143"/>An example with middleware</h2></div></div></div><p>We will now use Express to rewrite the <code class="literal">hello button</code> example. All static resources in the <code class="literal">public</code> directory can<a id="id960" class="indexterm"/> remain untouched. The only change is in the node <code class="literal">app</code> itself:</p><div class="informalexample"><pre class="programlisting">var express = require('express');
var path = require('path');
var app = express();

app.set('port', process.env.PORT || 3000);

var options = {
  dotfiles: 'ignore',
  extensions: ['htm', 'html'],
  index: false
};

app.use(express.static(path.join(__dirname, 'public') ,
options    ));

app.listen(app.get('port'),  function () {
console.log('Hello express started on http://localhost:' +
app.get('port') + '; press Ctrl-C to terminate.' );
});</pre></div><p>This code uses so-called middleware (<code class="literal">static</code>) that is included with <code class="literal">express</code>. There is a lot more available from third parties. In the <code class="literal">req.body</code> referenced earlier, there is middleware available to parse that form data (<code class="literal">body-parse</code>). You can also write your own middleware. In its simplest form, it is a function with <code class="literal">req</code> and <code class="literal">res</code> as its arguments:</p><div class="informalexample"><pre class="programlisting">app.use (function(req,res) {
   res.status(404);
   res.send(" Oops, you have tried to reach a page that does not exist");
});</pre></div><p>This is your minimal 404 handler to give people something meaningful to read on their screen when they type in the wrong URL. You place that in your app.js file after the code that represents the<a id="id961" class="indexterm"/> successful scenarios.</p></div></div>
<div class="section" title="Templating and handlebars.js"><div class="titlepage"><div><div><h1 class="title"><a id="ch14lvl1sec91"/>Templating and handlebars.js</h1></div></div></div><p>There is one more <code class="literal">Hello, world</code> example to go! Throughout the book, we have been using PHP most of the time. We have used it to dynamically generate web pages, or portions thereof. So PHP <a id="id962" class="indexterm"/>code, often embedded inside HTML code in a file with <code class="literal">.php</code> as an extension, is executed on the server and what is rendered by the browser is pure HTML. You also learned how to generate HTML from a separate PHP file or even JavaScript on the client side, using data that comes from the server, and then inject it into a portion of a web page (Ajax).</p><p>Combining PHP and HTML and even a small chunk of client-side JavaScript inside a single file was made possible thanks to the <code class="literal">&lt;script&gt;</code> tag and by putting PHP code in between <code class="literal">&lt;?php</code> and <code class="literal">?&gt;</code>. That is why they sometimes call PHP a <span class="emphasis"><em>templating</em></span> language.</p><p>Now imagine an all-JavaScript ecosystem. Yes, we could still put our client JavaScript code in between <code class="literal">&lt;script&gt;</code> tags, but what about the server JavaScript code? There is no such thing as <code class="literal">&lt;?javascript ?&gt;</code> because this is not how node.js works.</p><p>Node.js and Express support<a id="id963" class="indexterm"/> several templating languages that allow you to separate layout and content and have the template system do the work to go fetch the content and inject it into the HTML. As we no longer want to learn yet another language, we <a id="id964" class="indexterm"/>decided to go with <span class="strong"><strong>handlebars.js</strong></span>, as<a id="id965" class="indexterm"/> it uses plain HTML to define your layout, that you already learned some 12 chapters ago. The default templating language for Express appears to<a id="id966" class="indexterm"/> be <span class="strong"><strong>Jade</strong></span>, which uses its own, albeit more compact, because there are no tags, format. Another advantage of using handlebars.js is that is also available to do client-side templating.</p><p>We conclude this chapter with an example of how you could use handlebars.js.</p><p>Our examples in this chapter are all node.js examples, for which we need modules. To use handlebars in node and Express, there are several modules available. I like the one with the easy to remember name <a id="id967" class="indexterm"/>
<span class="strong"><strong>express-handlebars</strong></span>. If you search the web for handlebars.js, you will find the library to do client-side templating.</p><p>Get the <code class="literal">handlebars</code> module for Express using the following command:</p><div class="informalexample"><pre class="programlisting"><span class="strong"><strong>npm install express-handlebars</strong></span>
</pre></div><div class="section" title="Creating a layout"><div class="titlepage"><div><div><h2 class="title"><a id="ch14lvl2sec144"/>Creating a layout</h2></div></div></div><p>Inside your project folder that contains <code class="literal">public</code>, create a folder <code class="literal">views</code>, with a subdirectory <code class="literal">layouts</code>. Copy other <a id="id968" class="indexterm"/>static content you may have from <code class="literal">public</code> to <code class="literal">views</code>. Inside the <code class="literal">layouts</code> subfolder, create a file called <code class="literal">main.handlebars</code>. This is your default layout. Think of it as a common layout for almost all of your pages:</p><div class="informalexample"><pre class="programlisting">&lt;!doctype html&gt;
    &lt;html&gt;
    &lt;head&gt;
&lt;title&gt;Handlebars demo&lt;/title&gt; &lt;/head&gt;
&lt;link href="./styles/hello.css" rel="stylesheet"&gt;
&lt;body&gt;
{{{body}}}
    &lt;/body&gt;
    &lt;/html&gt;</pre></div><p>Notice the <code class="literal">{{{body}}}</code> part. This token will be replaced by HTML. Create, in the <code class="literal">views</code> folder, a file called <code class="literal">hello.handlebars</code> with the following content. This will be one (of many) example of the HTML, and it will be replaced by:</p><div class="informalexample"><pre class="programlisting">&lt;h1&gt;Hello, World&lt;/h1&gt;</pre></div></div></div>
<div class="section" title="Our last Hello, World example"><div class="titlepage"><div><div><h1 class="title"><a id="ch14lvl1sec92"/>Our last Hello, World example</h1></div></div></div><p>Now create a file <code class="literal">lasthello.js</code> in the<a id="id969" class="indexterm"/> project folder. For convenience, we added the relevant code to the previous Express example. Everything that worked before still works but if you type <code class="literal">http://localhost:3000/</code>, you will see a page with the layout from the layout file and <code class="literal">{{{body}}}</code> replaced by(you guessed it):</p><div class="informalexample"><pre class="programlisting">var express = require('express');
var path = require('path');
var app = express();
var handlebars = require('express-handlebars') .create({ defaultLayout:'main' });
    app.engine('handlebars', handlebars.engine);
    app.set('view engine', 'handlebars');
app.set('port', process.env.PORT || 3000);

var options = {
  dotfiles: 'ignore',
  etag: false,
  extensions: ['htm', 'html'],
  index: false
};

app.use(express.static(path.join(__dirname, 'public') , options    ));
app.get('/', function(req, res)
{
res.render('hello');   // this is the important part
});
app.listen(app.get('port'),  function () {
  console.log('Hello express started on http://localhost:' +
  app.get('port') + '; press Ctrl-C to terminate.' );

});</pre></div></div>
<div class="section" title="Summary"><div class="titlepage"><div><div><h1 class="title"><a id="ch14lvl1sec93"/>Summary</h1></div></div></div><p>In this final chapter, we gave an overview of node.js and Express. Thanks to node.js, you can use JavaScript across the board, on both the client and server side. You can even write your own web server with just a few lines of code. As you only include the things you really need, you can obtain far better performance with this <span class="emphasis"><em>avant-garde</em></span> way of doing web development.</p><p>As you combine the web server and the server application in your code, there may be more code to write than you wish for. That is where Express comes to the rescue: a lightweight framework that results in more compact, yet robust code.</p><p>To conclude, we touched on the tip of the templating iceberg by introducing handlebars.js. This is a better way to separate layout from dynamic content and have the framework combine the two, so the browser can render it as a view. For that purpose, we concluded the chapter by writing a layout in HTML.</p><p>This reminds me of Anna Russell's rendition of Wagner's <span class="emphasis"><em>Der Ring des Nibelungen</em></span>, which she does in 20 minutes (normally the Ring is 16 hours) concluding that the story ends the way it started. It goes a little bit like this:</p><div class="blockquote"><blockquote class="blockquote"><p><span class="emphasis"><em>There is the Rhine, in the river there are the Rhinemaidens and at the bottom there is ... gold …</em></span></p></blockquote></div><p>So, after 14 chapters that took us through many aspects of web development we ended where it all started: HTML. I hope you enjoyed reading it as much as I did writing it.</p></div></body></html>