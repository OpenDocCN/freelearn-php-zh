<html><head></head><body>
		<div id="_idContainer034">
			<h1 id="_idParaDest-115" class="chapter-number"><a id="_idTextAnchor115"/>9</h1>
			<h1 id="_idParaDest-116"><a id="_idTextAnchor116"/>Organizing PHP Quality Tools</h1>
			<p>In the last two chapters, you learned a lot about quality metrics and how to measure them. There will surely be a couple of tools you would like to use in your future work environment, and these tools work best if they are seamlessly integrated so that you don’t even have to think about using them anymore.</p>
			<p>Therefore, in this chapter, we will show you how you can organize these tools in a way that they will be the most productive and helpful in your daily work. This includes the following topics:</p>
			<ul>
				<li>Installing code quality tools using <strong class="bold">Composer</strong></li>
				<li>Installing code quality tools as <strong class="source-inline">phar</strong> files</li>
				<li><a id="_idTextAnchor117"/>Managing <strong class="source-inline">phar</strong> files using the <strong class="bold">PHAR Installation and Verification Environment</strong> (<strong class="bold">Phive</strong>)</li>
			</ul>
			<h1 id="_idParaDest-117"><a id="_idTextAnchor118"/>Technical requirements</h1>
			<p>If you followed the examples in the previous two chapters, you do not need to install anything else. If not, please go back to those chapters and install all the necessary tools first.</p>
			<p>All code samples can be found in our GitHub repository: <a href="https://github.com/PacktPublishing/Clean-Code-in-PHP">https://github.com/PacktPublishing/Clean-Code-in-PHP</a>.</p>
			<h1 id="_idParaDest-118"><a id="_idTextAnchor119"/>Installing code quality tools using Composer</h1>
			<p>Most <strong class="bold">PHP: Hypertext Preprocessor</strong> (<strong class="bold">PHP</strong>) projects nowadays use Composer for a good <a id="_idIndexMarker355"/>reason. Before it entered the PHP world <a id="_idIndexMarker356"/>in 2012, keeping all external dependencies (that is, code from other developers) up to date required a lot of manual work. The required files had to be downloaded from the corresponding websites and added to the correct folders of the project. Autoloading (that is, the automatic resolving of file paths from the class name) was not standardized, if available at all. So, usually, the wanted classes needed to be actively imported using <strong class="source-inline">require()</strong> or <strong class="source-inline">require_once()</strong>. If there were any conflicts between package versions, you had to somehow solve the issues yourself.</p>
			<p>Composer greatly simplified these efforts by solving these issues. It introduced a central repository<a id="_idIndexMarker357"/> called <strong class="bold">Packagist</strong> (https://packagist.org), where all available packages are hosted. Furthermore, it fixed the version problem by introducing version constraints. These are rules that tell Composer which versions of other packages a package supports, enabling Composer to often automatically resolve the right versions. Another groundbreaking feature was the support of autoloading for installed packages. There, we now usually use <strong class="source-inline">require()</strong> only to import Composer’s autoloader. </p>
			<p>All these<a id="_idIndexMarker358"/> features helped PHP compete with<a id="_idIndexMarker359"/> other web languages such as Python or Ruby, and without it, PHP would probably not be the most widely used language on the <strong class="bold">World Wide Web</strong> (<strong class="bold">WWW</strong>) anymore, as it is today. Therefore, we want to give Composer the space in this book that it deserves. In this section, we will show you the most used installation method. Additionally, we will also have a look at another, lesser-known way of using Composer in your project.</p>
			<h2 id="_idParaDest-119"><a id="_idTextAnchor120"/>Installing code quality tools using require-dev</h2>
			<p>Throughout the last <a id="_idIndexMarker360"/>chapters, we already used Composer to<a id="_idIndexMarker361"/> install tools most of the time, so by now, you should already be familiar with the most common use case there is: adding dependencies to your project. <strong class="bold">Dependencies</strong> are <a id="_idIndexMarker362"/>code packages written by other developers that can quickly be integrated into your project.</p>
			<p>To recap, this is done using the <strong class="source-inline">require</strong> keyword and the package name. For example, if you want to add PhpMetrics, you can do so by running the following command:</p>
			<p class="source-code">$ composer require phpmetrics/phpmetrics <strong class="bold">--dev</strong></p>
			<p>Typically, packages<a id="_idIndexMarker363"/> are identified by the name of the developer(s)—the so-called <em class="italic">vendor</em>—and, separated by a slash, the <a id="_idIndexMarker364"/>package name. In the preceding example, the vendor and the package name are identical, but this is not always the case.</p>
			<p>Let us look at the <strong class="source-inline">--dev</strong> option<a id="_idIndexMarker365"/> in more detail now. When we run<a id="_idIndexMarker366"/> the <strong class="source-inline">composer require</strong> command with this option, Composer will add the package in another section of the <strong class="source-inline">composer.json</strong> file, called <strong class="source-inline">require-dev</strong>. Here, you can see an excerpt of a typical <strong class="source-inline">composer.json</strong> file:</p>
			<pre class="source-code">
{
  "name": "vendor/package",
  ...
  "require": {
    "doctrine/dbal": "^2.10",
    "monolog/monolog": "^2.2",
    ...
  },
<strong class="bold">  "require-dev": {</strong>
<strong class="bold">    "phpunit/phpunit": "^9.5",</strong>
<strong class="bold">    "phpmetrics/phpmetrics": "^2.8",</strong>
<strong class="bold">    ...</strong>
<strong class="bold">  },</strong>
  ...
}</pre>
			<p>The idea behind the <strong class="source-inline">require-dev</strong> section is that all packages within this section are not necessary to run the application in production. In the local environment, or during the build, you will surely need PHPUnit and all our held-dear code quality tools; in production, they are not needed anymore, though. </p>
			<p>In fact, you should strive to have as few packages as possible in production. This is mainly for two reasons, as follows: </p>
			<ol>
				<li>Each package you add will be included in Composer’s autoload mechanism, which costs performance on every request. Internally, Composer builds a so-called <em class="italic">classmap</em>, which is a simple array that maps a class name to the respective file location. If you are curious about this, check out—for example—the <strong class="source-inline">vendor/composer/autoload_classmap.php</strong> file. Depending on the number of packages your project uses, this file can get huge, slowing down your application.</li>
				<li>Every additional package can possibly introduce security issues. The less code there is, the fewer attack vectors there are. </li>
			</ol>
			<p>By default, Composer <a id="_idIndexMarker367"/>will install all dependencies. Thus, be<a id="_idIndexMarker368"/> sure to run it using the <strong class="source-inline">--no-dev</strong> option for your production builds to exclude the packages in <strong class="source-inline">require-dev</strong> from being installed. In your local environment, however, you do not need to worry about anything else at this point.</p>
			<p>The previously described installation method is the one you will encounter the most for good reasons: it does not require any additional tooling and there’s just one additional option to be used when installing it on production. This makes it a perfect starting point and is often fully sufficient for a small project. Another approach worth knowing is the global installation of Composer, which we will discuss in the next section. </p>
			<h2 id="_idParaDest-120"><a id="_idTextAnchor121"/>Global installation</h2>
			<p>If you are working on numerous<a id="_idIndexMarker369"/> projects simultaneously on your local system, you can choose to install Composer and packages globally, which means that they will not be installed in any project <strong class="source-inline">root</strong> folder and will thus not be added to any <strong class="source-inline">composer.json</strong> file there. Instead, both Composer and the packages will be installed in a single folder, which is usually <strong class="source-inline">~/.composer</strong>. In this folder, you will then find another <strong class="source-inline">composer.json</strong> file that keeps track of the globally installed packages, as well as another <strong class="source-inline">vendor</strong> folder, where their code is installed. </p>
			<p>Installing packages globally simply requires adding the <strong class="source-inline">global</strong> modifier, like so:</p>
			<p class="source-code">$ composer global require phpmetrics/phpmetrics</p>
			<p>Likewise, updating all global packages is effortless too, as demonstrated here:</p>
			<p class="source-code">$ composer <strong class="bold">global</strong> update</p>
			<p>After global installation, tools such as the <strong class="bold">PHP Coding Standards Fixer</strong> (<strong class="bold">PHP-CS-Fixer</strong>) can simply be<a id="_idIndexMarker370"/> executed without having to specify the path, like so:</p>
			<p class="source-code">$ php-cs-fixer fix src</p>
			<p>To make this approach work, however, you will need to add this global folder to the execution path. Please see the Composer<a id="_idIndexMarker371"/> documentation (<a href="https://getcomposer.org/">https://getcomposer.org/</a>) for more details on how to do this for the operating system you use.</p>
			<p>Using the global installation feature should only be chosen if you are working alone on your projects and do not use any build pipelines. If you are working in a team and/or make use<a id="_idIndexMarker372"/> of a <strong class="bold">continuous integration</strong> (<strong class="bold">CI</strong>) pipeline, you should install it for every project separately, though.</p>
			<p>According to common best practices such as the <strong class="bold">Twelve-Factor App</strong> principles (<a href="https://12factor.net">https://12factor.net</a>), all<a id="_idIndexMarker373"/> dependencies should be explicitly declared, and no global dependencies should be relied on since you can never be sure which version will be installed. Although code quality tool packages are not part of the actual program code, they are still part of the build process. Even small differences between the installed versions can lead to unforeseen behavior and can generate confusion when errors cannot be reproduced locally.</p>
			<p>Furthermore, you<a id="_idIndexMarker374"/> want to make the initial installation of a project as easy as possible. Having your teammates install all the required tools manually is a time-wasting and error-prone process that can lead to frustration. </p>
			<p>For the aforementioned reasons, we do not encourage using the global installation method.</p>
			<h2 id="_idParaDest-121"><a id="_idTextAnchor122"/>Composer scripts</h2>
			<p>Once you have decided <a id="_idIndexMarker375"/>on a possible way to install Composer and have used it to download your desired tools, you want to start using them in the most straightforward way possible. In <a href="B19050_11.xhtml#_idTextAnchor145"><em class="italic">Chapter 11</em></a>, <em class="italic">Continuous Integration</em>, where we will talk about CI, we will also show you how to run these tools automatically during the build process. For now, however, we want to show you how Composer can assist you in running them manually whenever required.</p>
			<p>Let us consider the following example: as a first step, we would like to run PHP-CS-Fixer to automatically fix the code in our <strong class="source-inline">src</strong> folder. Afterward, we wish to run PHPStan with level <strong class="source-inline">1</strong> on our code as well. You could surely run both steps separately, but we want to add a bit more comfort and execute both tools in one go.</p>
			<p>To achieve this, we<a id="_idIndexMarker376"/> can utilize the <strong class="source-inline">scripts</strong> section of the <strong class="source-inline">composer.json</strong> file <em class="italic">in the project root</em>. There, we have to add the tools we want to execute under a concise command name, such as <strong class="source-inline">analyze</strong>. The following example shows what this could look like: </p>
			<pre class="source-code">
{
  ...
  "scripts": {
    "analyze": [
      "vendor/bin/php-cs-fixer fix src",
      "vendor/bin/phpstan analyse --level 1 src"
    ]
  }
}</pre>
			<p>We used<a id="_idIndexMarker377"/> the <strong class="bold">JavaScript Object Notation</strong> (<strong class="bold">JSON</strong>) array notation here to add each command in a separate line, which makes it easier to read and maintain than writing everything in one line.</p>
			<p>If you want to share these Composer commands, you might want to add a short description text as well, which is displayed when you execute <strong class="source-inline">composer list</strong> to see a list of available commands. To do that, you need to add the <strong class="source-inline">script-descriptions</strong> section to your <strong class="source-inline">composer.json</strong> file. For the previously introduced <strong class="source-inline">analyze</strong> command, it could look like this:</p>
			<pre class="source-code">
{
  ...
    "scripts": {
        ...
    },
    "scripts-descriptions": {
        "analyze": "Perform code cleanup and analysis"
    }
}</pre>
			<p>By installing the tools in a<a id="_idIndexMarker378"/> subfolder, we found a suitable way to organize our code quality tools without letting them interfere with our application dependencies. But what if, for whatever reason, you are not using Composer in your project, or you dislike the fact of having two <strong class="source-inline">composer.json</strong> files in your repository? In the next section, we will introduce an alternative way that does not make use of Composer. </p>
			<h1 id="_idParaDest-122"><a id="_idTextAnchor123"/>Installing code quality tools as phar files</h1>
			<p>Composer is not the only possible way to add code quality tools to your project. In this section, we will show you to add the tools as <strong class="source-inline">phar</strong> files.</p>
			<p>We already came across <strong class="bold">phar</strong> in the previous chapters. It stands for <strong class="bold">PHP Archive</strong> and can be considered a <a id="_idIndexMarker379"/>whole PHP project within a single file. Technically, it is a self-executable ZIP archive that contains the source code of the application plus all necessary dependencies as well. The big advantage is that the required code is available immediately after download, so you can instantly use any <strong class="source-inline">phar</strong> file right away without having to care about Composer or dependencies at all. Furthermore, <strong class="source-inline">phar</strong> files are supported by all modern PHP versions.</p>
			<p>This makes<a id="_idIndexMarker380"/> the usage of <strong class="source-inline">phar</strong> files quite handy, as <a id="_idIndexMarker381"/>you can treat them like binaries. Usually, you can download the many PHP tools we introduced to you so far as <strong class="source-inline">phar</strong> files directly and place them in whatever directory you want. However, there is no unified way these files are provided, so please refer to the official documentation of each tool.</p>
			<p>Let us have a<a id="_idIndexMarker382"/> look at how to do that for the <strong class="source-inline">phploc</strong> tool, which <a id="_idIndexMarker383"/>we introduced in <a href="B19050_07.xhtml#_idTextAnchor084"><em class="italic">Chapter 7</em></a><em class="italic">,</em> <em class="italic">Code Quality Tools</em>. According to its GitHub repository, you can simply download it from <a id="_idIndexMarker384"/>the <em class="italic">PHPUnit</em> website, as they are both from the same author. The following code snippet shows how you can do this:</p>
			<p class="source-code">$ wget https://phar.phpunit.de/phploc.phar -O phploc</p>
			<p>Note that we install the tool under the name <strong class="source-inline">phploc</strong>, and not <strong class="source-inline">phploc.phar</strong>. The <strong class="source-inline">-O</strong> option allows you to specify a different filename than the one you are downloading. The <strong class="source-inline">.phar</strong> extension is not necessary to execute the tool, so you can save on a bit of typing effort here.</p>
			<p class="callout-heading">Phar and checksums</p>
			<p class="callout">Downloading and executing files from the internet always includes the risk that they can be corrupted and infected with malicious code. That is why the authors of the tools often generate checksums (for example, through hash algorithms such as <strong class="bold">Secure Hash Algorithm 256</strong> (<strong class="bold">SHA256</strong>)) of the downloads and publish them on their websites so that you can use them<a id="_idIndexMarker385"/> to verify the integrity of the download. Please check the official websites of the tools you’re considering using to find out if they offer checksums, and how to verify them.</p>
			<p>Of course, you can download it using any method you like, be it <strong class="source-inline">curl</strong> or via the browser. Once you download it, you can immediately run it using your local PHP installation, like so:</p>
			<p class="source-code">$ php phploc src</p>
			<p>If you do not want to type <strong class="source-inline">php</strong> every time, you need to make the <strong class="source-inline">phar</strong> file executable, which on Linux—for example—would look like this:</p>
			<p class="source-code">$ chmod +x phploc </p>
			<p>Afterward, you just need to run the following command to execute <strong class="source-inline">phploc</strong>:</p>
			<p class="source-code">$ ./phploc src</p>
			<h2 id="_idParaDest-123"><a id="_idTextAnchor124"/>Keeping your phar files organized</h2>
			<p>Now, we do not just want<a id="_idIndexMarker386"/> to download the <strong class="source-inline">phar</strong> files—we also want to keep them organized in our project so that any other developer does not have to do any manual work before using them. The most obvious choice is to add these files to your repository, and that is precisely what we will look at now. In the following example, we will use Git, but this<a id="_idIndexMarker387"/> approach would work with any other <strong class="bold">version control system</strong> (<strong class="bold">VCS</strong>).</p>
			<p>It is generally discouraged to store large files in Git because they can affect performance negatively. GitHub, for example, blocks files that are greater than 100 <strong class="bold">megabytes</strong> (<strong class="bold">MB</strong>). However, the <strong class="source-inline">phar</strong> files we use are usually just a few MB in size, so adding them should not have any negative side effects.</p>
			<p class="callout-heading">Git Large File Storage (Git LFS)</p>
			<p class="callout">If you need to store large files in <a id="_idIndexMarker388"/>Git, consider using Git LFS, which was designed exactly for this use case. For our needs, though, we do not have to use it.</p>
			<p>You can freely choose where to add <strong class="source-inline">phar</strong> files to your project. A common place is the <strong class="source-inline">root</strong> folder; however, since this will get quite crowded over time, we recommend using a separate folder to store them. A good place would be the <strong class="source-inline">tools</strong> folder again, just like we used it in the previous section. You do not need to consider anything else; just add them to the repository like any other file.</p>
			<p>Let us assume you copied the <strong class="source-inline">phploc</strong> file into the <strong class="source-inline">tools</strong> folder and made it executable as described previously. Then, you would just execute as follows:</p>
			<p class="source-code">$ tools/phploc src</p>
			<p>Using <strong class="source-inline">phar</strong> files is easy and<a id="_idIndexMarker389"/> does not interfere with your application dependencies. However, they are not perfect: if you <a id="_idIndexMarker390"/>want to update them, you need to look up the download <strong class="bold">Uniform Resource Locator</strong> (<strong class="bold">URL</strong>), download the <strong class="source-inline">phar</strong> file, and validate its checksum manually every time—for each tool. In the next section, we will show you how to ease that process by introducing another dependency management tool: Phive.</p>
			<h1 id="_idParaDest-124"><a id="_idTextAnchor125"/>Managing phar files using Phive</h1>
			<p>In the previous section, we learned about using <strong class="source-inline">phar</strong> files instead of using Composer to install our code quality tools. This approach works fine, but it does require some extra work in case you want to update them.</p>
			<p><strong class="bold">Phive</strong> is a <a id="_idIndexMarker391"/>tool that takes over that extra work. Let us install it right away.</p>
			<p>Naturally, Phive itself <a id="_idIndexMarker392"/>can be downloaded as <strong class="source-inline">phar</strong>, too. The <a id="_idIndexMarker393"/>following commands will download it under the name <strong class="source-inline">phive</strong> and make it executable: </p>
			<pre class="source-code">
$ wget https://github.com/phar-io/phive/releases/download/0.15.1/phive-0.15.1.phar -O phive
$ chmod +x phive</pre>
			<p>Please note that this installation <a id="_idIndexMarker394"/>method is not very secure. Check the tool’s website (https://phar.io) to learn how to install it securely and how to make it globally available.</p>
			<p>For demonstration purposes, the simple download works just fine. Once the file is downloaded and made executable, you can directly start using Phive to install the first tools. Let us use <strong class="source-inline">phploc</strong>, which we introduced in the previous chapter, to demonstrate how it works, as follows:</p>
			<p class="source-code">$ ./phive install phploc</p>
			<p class="callout-heading">Download verification</p>
			<p class="callout">Phive not only takes care of the <em class="italic">installation</em> but also of the <em class="italic">verification</em> of the downloads. This is done automatically during the installation process. However, this requires the vendor to make the checksums available, which is also the main reason why not all tools can be managed through Phive.  </p>
			<p>As you saw previously, installing a tool is done just by using the <strong class="source-inline">install</strong> command. The following four things have happened now:</p>
			<ol>
				<li value="1">Phive downloaded the latest version of <strong class="source-inline">phploc</strong> and verified its checksum.</li>
				<li>The <strong class="source-inline">phar</strong> file got stored in a shared folder (usually located in your home folder under the name <strong class="source-inline">.phive</strong>).</li>
				<li>Phive then created a symbolic link to that shared folder. A symbolic link is a reference in the filesystem so that a file or directory can appear in multiple directories, although it is stored in just one place. By default, this symbolic link is stored in the <strong class="source-inline">tools</strong> folder, which will be generated if it does not exist.</li>
				<li>Another <strong class="source-inline">.phive</strong> folder <a id="_idIndexMarker395"/>has been created in your project<a id="_idIndexMarker396"/> root folder, which is used to store the information about which tools have been downloaded.</li>
			</ol>
			<p>Symbolic links appear just as “real” executables in your directory, while the original file stays in one single location. If you do not want to use symbolic links, you can install a file copy instead by using the <strong class="source-inline">--copy</strong> option.</p>
			<p>After installation, the execution of <strong class="source-inline">phploc</strong> is simple, as we can see here:</p>
			<p class="source-code">$ tools/phploc src</p>
			<p>Phive offers more useful commands. Just run the following code without any command to get a list of them:</p>
			<p class="source-code">$ ./phive</p>
			<p>Here, we introduce the most important ones:</p>
			<ul>
				<li><strong class="source-inline">list</strong>—Lists all tools that can be managed through Phive</li>
				<li><strong class="source-inline">update</strong>—Updates all installed <strong class="source-inline">phar</strong> files, if newer versions are available</li>
				<li><strong class="source-inline">selfupdate</strong>—Updates the <strong class="source-inline">phive</strong> executable itself</li>
				<li><strong class="source-inline">outdated</strong>—Tells you which <strong class="source-inline">phar</strong> files can be updated</li>
				<li><strong class="source-inline">status</strong>—Lists an overview of all installed tools</li>
			</ul>
			<h2 id="_idParaDest-125"><a id="_idTextAnchor126"/>Adding Phive to your project</h2>
			<p>If you work in <a id="_idIndexMarker397"/>a team, you not only want to locally install the <strong class="source-inline">phar</strong> files. Phive has got you covered here as well. Two steps are necessary to properly add Phive to your project, as follows:</p>
			<ol>
				<li value="1">Add the <strong class="source-inline">.phive</strong> folder in your project root to your repository. The <strong class="source-inline">phars.xml</strong> file inside contains all necessary information (such as the <strong class="source-inline">composer.lock</strong> file).</li>
				<li>Make sure the <strong class="source-inline">tools</strong> folder is not under version control (for example, by using a <strong class="source-inline">.gitignore</strong> file). You explicitly do not want to add the <strong class="source-inline">phar</strong> files themselves to your repository.</li>
			</ol>
			<p>Once this is done, the next time the project gets checked out from the repository, the tools can be installed by executing the following command:</p>
			<p class="source-code">$ ./phive install </p>
			<p>This command can be easily integrated into other workflows—for example, as an additional <strong class="source-inline">post-install-cmd</strong> script in the <strong class="source-inline">composer.json</strong> file.</p>
			<p>That is already all you need to know about Phive to start using it. As usual, we recommend you read the official documentation because we could not cover every feature it provides in this book.</p>
			<h1 id="_idParaDest-126"><a id="_idTextAnchor127"/>Summary</h1>
			<p>Composer is an indispensable part of today’s PHP world. The usual approach to adding code quality tools to your project is by adding them to the <strong class="source-inline">require-dev</strong> section of the dependencies, which works fine in many cases.</p>
			<p>However, Composer is not the one and only way there is. Therefore, in this chapter, we introduced two more options to manage your code quality tools: by adding the <strong class="source-inline">phar</strong> files manually to your project, or by utilizing Phive to manage the <strong class="source-inline">phar</strong> files.</p>
			<p>You are probably eager to apply all your gained knowledge to your code now. However, relentless refactoring can do more harm than good, and clicking through all parts of your application after every change to check if anything broke will cost you a lot of time and can be very frustrating. Thus, in the next chapter, we will show you how automated testing can help you here.</p>
		</div>
	</body></html>