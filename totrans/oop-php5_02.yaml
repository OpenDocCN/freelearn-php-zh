- en: Chapter 2. Kick-Starting OOP
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter we will learn how to create objects, define their attributes
    (or properties) and methods. Objects in PHP are always created using a "class"
    keyword. In this chapter we will learn the details of classes, properties, and
    methods. We will also learn the scope of methods and about modifiers and the benefits
    of using interfaces This chapter will also introduce us to other basic OOP features
    in PHP. As a whole, this chapter is one of the better resources for you to kick-start
    OOP in PHP.
  prefs: []
  type: TYPE_NORMAL
- en: Let's Bake Some Objects
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As I said before, you can create an object in PHP using the `class` keyword.
    A class consists of some properties and methods, either public or private. Let''s
    take the `Emailer` class that we have seen in our first chapter. We will discuss
    here what it actually does:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: In this code, we started with `class` `Emailer`, which means that the name of
    our class is `Emailer`. While naming a class, follow the same naming convention
    as variables, i.e. you can't start with a numeric letter, etc.
  prefs: []
  type: TYPE_NORMAL
- en: After that we declared the properties of this class. There are four properties
    here, namely, `$sender`, `$recipient`, `$subject`, and `$body`. Please note that
    we declare each of them with a keyword `private`. A private property means that
    this property can only be accessed internally from this class. Properties are
    nothing but variables inside a class.
  prefs: []
  type: TYPE_NORMAL
- en: If you remember what a method is, it is just a function inside the class. In
    this class there are five functions, `__construct()`, `addRecipient()`, `setSubject()`,
    `setBody()`, and `sendEmail()`. Please note that the last four methods are declared
    public. That means when someone instantiates this object, they can access these
    methods.
  prefs: []
  type: TYPE_NORMAL
- en: The `__construct()` is a special method inside a class which is called constructor
    method. Whenever a new object is created from this class, this method will execute
    automatically. So if we have to perform some preliminary tasks in our object while
    initiating it, we will do from this constructor method. For example, in the constructor
    method of this `Emailer` class we just set the `$recipients` as a blank array
    and we also set the sender name.
  prefs: []
  type: TYPE_NORMAL
- en: Accessing Properties and Methods from Inside the Class
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Are you wondering how a function can access the class properties from inside
    its content? Let''s see using the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: There is a private property named `$body` inside our class, and if we want to
    access it from within the function, we must refer to it with `$this`. `$this`
    means a reference to current instance of this object. So we can access the `body`
    property with `$this->body`. Please note that we have to access the properties
    (i.e class variables) of a class using a "->" following the instance.
  prefs: []
  type: TYPE_NORMAL
- en: Similarly, like properties, we can access any member method from inside another
    member method in this format. For example, we can evoke `setSubject` method as
    `$this->setSubject()`.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Please note that `$this` keyword is only valid inside the scope of a method,
    as long as it is not declared as static. You can not use `$this` keyword from
    outside the class. We will learn about this "static", "private", "public" keywords
    more in the *Modifiers* section later this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Using an Object
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s use the newly created `Emailer` object from inside our PHP code. We
    must note some things before using an object. You must initiate an object before
    using it. After initiating, you can access all its public properties and methods
    using "->" after the instance. Let''s see using the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'In the above code piece, we first created an instance of `Emailer` class to
    a variable name `$emailerobject` in the first line. Here, there is something important
    to note: We are supplying a sender address while instantiating this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Remember we had a constructor method in our class as `__construct($sender)`.
    When initiating an object, we said that the constructor method is called automatically.
    So while initiating this `Emailer` class we must supply the proper arguments as
    declared in the constructor method. For example the following code will create
    a warning:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'When you execute the above code, it shows the warning as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: See the difference? If your class had no constructor method or a constructor
    with no arguments, you can instantiate it with the above code.
  prefs: []
  type: TYPE_NORMAL
- en: Modifiers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You have seen that we used some keywords like `private` or `public` in our class.
    So what are these and why do we need to use them? Well, these keywords are called
    modifier and introduced in PHP5\. They were *not* available in PHP4\. These keywords
    help you to define how these variables and properties will be accessed by the
    user of this class. Let's see what these modifiers actually do.
  prefs: []
  type: TYPE_NORMAL
- en: '**Private**: Properties or methods declared as private are not allowed to be
    called from outside the class. However any method inside the same class can access
    them without a problem. In our `Emailer` class we have all these properties declared
    as private, so if we execute the following code we will find an error.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'The above code upon execution gives a fatal error as shown below:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: That means you can't access any private property or method from outside the
    class.
  prefs: []
  type: TYPE_NORMAL
- en: '**Public**: Any property or method which is not explicitly declared as private
    or protected is a public method. You can access a public method from inside or
    outside the class.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Protected:** This is another modifier which has a special meaning in OOP.
    If any property or method is declared as protected, you can only access the method
    from its subclass. We will learn details about subclass later in this chapter.
    But to see how a protected method or property actually works, we''ll use the following
    example:'
  prefs: []
  type: TYPE_NORMAL
- en: 'To start, let''s open `class.emailer.php` file (the `Emailer` class) and change
    the declaration of the `$sender` variable. Make it as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Now create another file name `class.extendedemailer.php` with the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Now use this object like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Now if you look carefully at the code of the `ExtendedEmailer` class, you will
    find that we accessed the `$sender` property of its parent (which is actually
    `Emailer` class). We have been able to access that property only because it was
    declared as protected. One more benefit we get here, is that the property `$sender`
    is still inaccessible directly from outside the scope of these two classes. That
    means if we execute the following code, it will generate a fatal error.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Upon execution, it gives the following error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Constructors and Destructors
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We discussed earlier in this chapter about the constructor method. A constructor
    method is the method that executes automatically while creating instances of the
    class. In PHP5, there are two ways you can write a constructor method inside a
    class. The first one is to create a method with the name `__construct()` inside
    the class. The second is to create a method naming exactly the same as class name.
    For example if your class name is `Emailer`, the name of the constructor method
    will be `Emailer()`. Let''s take a look at the following class which calculates
    the factorial of any number:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: In the code above, we used `__construct()` as our constructor function. The
    behaviour will be same if you rename the `__construct()` function as `factorial()`.
  prefs: []
  type: TYPE_NORMAL
- en: Now, you may ask if a class can have constructors in both styles? This means
    a function named `__construct()` and a function named the same as class name.
    So which constructor will execute, or will they both execute? This is a good question.
    Actually there is no chance of executing both. If there is a constructor in both
    styles, PHP5 will give preference to the `__construct()` function and the other
    one will be ignored. Let's take a look using the following example
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Now if you use this class as shown below:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'You will find that the output is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Similar to the constructor method, there is a **destructor** method which actually
    works upon destroying an object. You can explicitly create a destructor method
    by naming it `__destruct()`. This method will be invoked automatically by PHP
    at the end of the execution of your script. To test this, let''s add the following
    code in our factorial class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Now execute the usage script again, you will see the following output this
    time:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Class Constants
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Hopefully, you will already know that you can create constants in your PHP
    scripts using the **define** keyword to define (constant name, constant value).
    But to create constants in the class you have to use the `const` keyword. These
    constants actually work like static variables, the only difference is that they
    are read-only. Let''s see how we can create constants and use them:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: This `WordCounter` class counts the frequency of words in any given file. Here
    we define two constant names `ASC` and `DESC` whose values are 1 and 2 respectively.
    To access these constants from within the class, we reference them with the `self`
    keyword. Please note that we are accessing them with the `::` operator, not a
    `->` operator, because these constants act like a static member.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally to use this class, let''s create a snippet as shown below. In this
    snippet we are also accessing those constants:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Please note that we are accessing the class constants from outside the class
    by following the `::` operator right after the class name, not after the instance
    of the class. Now let''s test the script, please create a file named `words.txt`
    with the following content in the same directory where you placed the above script:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Now, if you execute the usage script, this time, you will see the following
    output.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Nice utility, what do you think?
  prefs: []
  type: TYPE_NORMAL
- en: Extending a Class [Inheritance]
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One of the greatest features in OOP is that you can extend a class and create
    a completely new object. The new object can retain all the functionality of the
    parent object from which it is extended or can override. The new object can also
    introduce some features. Let's extend our `Emailer` class and override the `sendEmail`
    function so that it can send HTML mails.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'As this class extends the `Emailer` class and introduces a new function, `sendHTMLEmail()`,
    you can still have all the methods from its parent. That means the following code
    is fully valid:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: If you want to access any method of the parent class (or you may say superclass)
    from which it is derived, you can call using the `parent` keyword. For example,
    if you want to access a method named `sayHello`, you should write `parent::sayHello();`
  prefs: []
  type: TYPE_NORMAL
- en: Please note that we didn't write any function named `sendEmail()` in `HtmlEmailer`
    class, but that method is working from its parent, `Emailer` class.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In the above example, `HtmlEmailer` is a subclass of `Emailer` class and `Emailer`
    class is a superclass of `HtmlEmailer`. You must remember that if the subclass
    has no constructor in it, the constructor from superclass will be invoked. At
    the time of writing this book, there is no support for multiple inheritances at
    class level. This means you can't extend more than one class at a time. However
    multiple inheritance is supported in interfaces. An interface can extend an arbitrary
    number of other interfaces at a time.
  prefs: []
  type: TYPE_NORMAL
- en: Overriding Methods
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In an extended object you can override any method (either declared as protected
    or public) and perform anything as you wish. So how can you override any method?
    Simply create a function with the same name that you want to override. For example,
    if you create a function name `sendEmail` in `HtmlEmailer` class, it will override
    the `sendEmail()` method of its parent, `Emailer` class. If you declare any variable
    in subclass which is also available in superclass, then when you access that variable,
    the one from subclass will be accessed.
  prefs: []
  type: TYPE_NORMAL
- en: Preventing from Overriding
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'If you declare any method as a `final` method, it can''t be overridden in any
    of its subclass. So if you don''t want someone to override your class methods,
    declare it as final. Let''s take a look at the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: If you execute the above code, it will generate a fatal error because class
    `SubClass` tried to override a method in `SuperClass` which was declared as `final`.
  prefs: []
  type: TYPE_NORMAL
- en: Preventing from Extending
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Similar to a final method, you can declare a class as final, which will prevent
    anyone from extending it. So if you declare any class, as shown in following example,
    it is no more extensible.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'If you execute the code above, it will trigger the following error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Polymorphism
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we explained before, polymorphism is the process of creating several objects
    from specific base classes. For example, take a look at the following case in
    point. We need the three classes that we created earlier in this chapter, `Emailer`,
    `ExtendedEmailer` and `HtmlEmailer`. Let's take a look at the following code.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'If you execute the script above, you will find the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: This is an example of polymorphism.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You can always check if a class is derived from another class by using the `instanceof`
    operator.
  prefs: []
  type: TYPE_NORMAL
- en: Interface
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Interface is an empty class which contains only the declaration of methods.
    So any class which implements this interface must contain the declared functions
    in it. So, interface is nothing but a strict ruling, which helps to extend any
    class and strictly implement all methods defined in interface. A class can use
    any interface by using the `implements` keyword. Please note that in interface
    you can only declare methods, but you cannot write their body. That means the
    body of all methods must remain blank.
  prefs: []
  type: TYPE_NORMAL
- en: So why is an interface necessary, you might ask? One of the reasons is it implies
    strict rules while creating a class. For example, we know that we need to create
    some driver classes in our application, which can handle DB operations. For MySQL,
    there will be one class, for PostgreSQL there will be another, For SQLite, another
    one and so forth. Now your developer team has three developers, who will separately
    create these three classes.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now how will it be if each of them implements their own style in their own
    classes? The developers who are going to use those driver classes will have to
    check how they define their methods and following that, the way they have to write
    their code, which is too boring and hard to maintain. So if you define that, all
    driver class must have two methods named `connect()` and `execute()`. Now developers
    need not worry while changing the driver, because they know that all these classes
    have the same method definition. Interface helps in this scenario. Let''s create
    the interface here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Did you notice that the functions are empty in an interface? Now let''s create
    our `MySQLDriver` class, which implements this interface:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Now if you execute the code above, it will give the following error because
    `MySQLDriver` class has no `connect()` and `execute()` function as defined in
    the interface. Let''s run the code and read the error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Well, now we have to add those two methods in our `MySQLDriver` class. Let''s
    see the code below:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'If we run the code now, we get the following error message again:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'The error message is saying that our `execute()` method is not compatible with
    the `execute()` method structure that was defined in the interface. If you now
    take a look at the interface, you will find that `execute()` method should have
    one argument. So that means whenever we implement an interface in our class, every
    method structure must exactly be the same as defined in the interface. Let''s
    rewrite our `MySQLDriver` class as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: Abstract Class
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'An abstract class is almost the same as interface, except that now the methods
    can contain body. An abstract class must also be "extended", not "implemented".
    So if the extended classes have some methods with common functionalities, then
    you can define those functions in an abstract class. Let''s see the example below:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: In our abstract class we have a method named `generateReport`, which takes a
    multidimensional array as argument and then generates an HTML report using it.
    Now, why did we put this method in an abstract class? Because generating a report
    will be a common function to all DB Drivers and it doesn't affect the code because
    it is taking only one array as an argument, not anything relevant to DB itself.
    Now we can use this abstract class in our `MySQLDriver` class as shown below.
    Please note that all the code to generate the report is already written, so we
    need not write code for that method in our driver class again as we did for interfaces.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: Please note that we can use the abstract class and implement an interface concurrently
    as shown in the above example.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You cannot declare an abstract class as final, because abstract class means
    it has to be extended and final class means it can't be extended. So it's totally
    meaningless to use these two keywords together. PHP won't allow you to use them
    together.
  prefs: []
  type: TYPE_NORMAL
- en: 'Similar to declaring a class as abstract, you can also declare any method as
    abstract. When a method is declared as abstract, it means that the subclass must
    override that method. An abstract method should not contain any body where it
    is defined. An abstract method can be declared as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: Static Method and Properties
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A `static` keyword is very important in object oriented programming. Static
    methods and properties play a vital role in application design and also in design
    patterns. So what are static methods and properties?
  prefs: []
  type: TYPE_NORMAL
- en: You have already seen that to access any method or attribute in a class you
    must create an instance (i.e. using `new` keyword, like `$object` `=` `new` `emailer()`),
    otherwise you can't access them. But there is a difference for static methods
    and properties. You can access a static method or property directly without creating
    any instance of that class. A static member is like a global member for that class
    and all instances of that class. Also, static properties persist the last state
    of what it was assigned, which is very useful in some cases.
  prefs: []
  type: TYPE_NORMAL
- en: You might ask why someone uses a static method. Well, most of the static methods
    are similar to utility methods. They perform a very specific task, or return a
    specific object (static properties and methods are used significantly in design
    patterns, we will learn that later). So declaring a new object every time for
    those works might be considered resource extensive. Let's see an example of static
    methods.
  prefs: []
  type: TYPE_NORMAL
- en: Consider that in our application we keep support for all three databases, MySQL,
    PostgreSQL, and SQLite. Now we need to use one particular driver at a time. For
    that, we are designing a `DBManager` class, which can instantiate any driver on
    demand and return that to us.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'How do we use this class? You can access any static property using a `::` operator
    and not using the `->` operator. Let''s see the example below:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: Notice that we didn't create any instance of `DBManager` object like `$dbmanager`
    `=` `new` `DBManager()`. Rather we directly access one of its methods using the
    `::` operator.
  prefs: []
  type: TYPE_NORMAL
- en: So how does this benefit us? Well, we just need a driver object, so no need
    to create a new `DBManager` object and commit it to memory as long as our scripts
    are executing. Static methods usually perform a specific task and finish it.
  prefs: []
  type: TYPE_NORMAL
- en: Here are some important things to note. You can't use `$this` pseudo object
    inside a static method. As the class is not instantiated, `$this` doesn't exist
    inside a static method. You should rather use the `self` keyword.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take a look at the following example. It shows how a static property
    actually works:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'You will see the output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: Whenever we create a new instance, it affects all the instances as the variable
    is declared as static. Using this special facility, a special design pattern "Singleton"
    works perfectly in PHP.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Caution: Using Static Members**'
  prefs: []
  type: TYPE_NORMAL
- en: Static members make object oriented much like old procedural programming; without
    creating instances, you can directly call any function, like the old days. That's
    why we use static method with caution. Excessive static methods make no use at
    all. Unless you have any specific purpose, don't use static members.
  prefs: []
  type: TYPE_NORMAL
- en: Accessor Methods
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Accessor methods are simply methods that are solely devoted to get and set the
    value of any class properties. It's a good practice to access class properties
    using accessor methods instead of directly setting or getting their value. Though
    accessor methods are the same as other methods, there are some conventions writing
    them.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two types of accessor methods. One is called `getter`, whose purpose
    is returning value of any class property. The other is setter that sets a value
    into a class property. Let''s see how to write the `getter` and `setter` methods
    for class properties:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: In the above example there are two `getter` methods and two `setter` methods.
    There is a convention in writing `accessor` methods. A `setter` method should
    start with `set` and the property name with the first character capitalized. A
    `getter` method should start with `get` followed by the variable name with the
    first letter capitalized. That means if we have a property named `email`, the
    getter method should be named as `getEmail` and the setter method should be named
    as `setEmail`. That's it.
  prefs: []
  type: TYPE_NORMAL
- en: So you might ask why someone does these extra jobs, when they can easily set
    these variables as public and leave everything else as is. Aren't all these the
    same? Well, no. Using accessor methods, you get some extra benefits. You will
    have full control while setting or retrieving the value of any property. "So what?"
    You might ask. Let's use a scenario where you need to filter users' input and
    set into properties. In this case, a `setter` can help you to filter the input
    before setting them into work.
  prefs: []
  type: TYPE_NORMAL
- en: Does this mean we have to write 100 `getter` and `setter` methods if my class
    contains 100 properties? You ask as good question. PHP is kind enough to relieve
    you from this boredom. How? Let us see the next section where we discuss using
    magic methods for setting and getting property values dynamically. Those methods
    will reduce the stress up to 90%. Don't you believe me? Let's see.
  prefs: []
  type: TYPE_NORMAL
- en: Using Magic Methods to Set/Get Class Properties
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We discussed in the previous section that writing accessor method for a number
    of properties will be a real nightmare. To avoid that boredom, you can use magic
    methods. This process is called property overloading.
  prefs: []
  type: TYPE_NORMAL
- en: 'PHP5 introduced some magic methods in classes to reduce the pain of OOP in
    some cases. Two of those magic methods are introduced to set and get dynamic property
    values in a class. These two magic methods are named as `__get()` and `__set()`.
    Let us see how to use them:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'Now let us see the code in action. Use the class above with the following script:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'When you execute the preceding code, PHP recognizes immediately that no property
    named `name` or `roll` exists in the class. Since the named property doesn''t
    exist, the `__set()` method is called, which then assigns the value to the newly-created
    property of the class, allowing you to see the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: Seems quite interesting, huh? Using magic methods you still have full control
    over setting and retrieving property values in classes. However, you have one
    limitation if you use magic methods. While using reflection API, you can't investigate
    class properties (we will discuss about reflection API in a later chapter). Moreover,
    your class lost the "readability" and "maintainability" quite a lot. Why? See
    the code of previous `Student` class and new `Student` class and you will understand
    that for yourself.
  prefs: []
  type: TYPE_NORMAL
- en: Magic Methods for Overloading Class Methods
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Like overloading, and using the accessor methods, there are magic methods to
    overload any method call in a class. If you are still not familiar with method
    overloading, then this is a process of accessing any method that doesn't even
    exist in the class. Sounds funny, right? Let's take a closer look.
  prefs: []
  type: TYPE_NORMAL
- en: 'There is a magic method, which helps to overload any method call in PHP5 class
    context. The name of that magic method is `__call()`. This allows you to provide
    actions or return values when undefined methods are called on an object. It can
    be used to simulate method overloading, or even to provide smooth error handling
    when an undefined method is called on an object. `__call` takes two arguments:
    the name of the method and an array of the arguments passed to the undefined method.'
  prefs: []
  type: TYPE_NORMAL
- en: 'For example see the code below:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: If you see the code above, then you will see that there is no method called
    `access` and `notAnyMethod`. So therefore, it should raise an error, right? However,
    the method overloader still helps you to call any non existing method. If you
    execute the code above, you will get the following output.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: That means you will get all arguments as an array. There are many more magic
    methods, which you will learn step-by-step in this book.
  prefs: []
  type: TYPE_NORMAL
- en: Visually Representing a Class
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In OOP, sometimes you have to visually represent your class. Let's learn how
    to visually represent a class. For this, we will use our `Emailer` class this
    time.
  prefs: []
  type: TYPE_NORMAL
- en: '![Visually Representing a Class](img/2561_01_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In this graphical representation, there are three sections. At the top most
    section a class name should be written. In the second section all methods with
    or without parameters are written. And in the third box all the properties are
    written. That's it!
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter we have learned how to create objects and interact between them.
    PHP5 brings amazing improvements in object models when compared to PHP4\. Zend
    Engine 2, which is at the core of PHP5, is also very efficient in handling these
    features with great performance optimization.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter we will go through more details and the core features of
    OOP in PHP. But before starting next chapter, please practice everything discussed
    here, otherwise you may get confused in some topics. Practice them as much as
    you can, try to refactor all your previous code in OOP. The more you practice,
    the more efficient you become.
  prefs: []
  type: TYPE_NORMAL
