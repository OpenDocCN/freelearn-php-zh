- en: '10'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '10'
- en: Considerations for Hosting Rails Applications versus PHP Applications
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 关于托管 Rails 应用程序与 PHP 应用程序的考虑
- en: 'Congratulations for making it to this point. You’ve created a simple Rails
    application that uses controllers, views, and models. You used generators to prep
    for your development. You also set up the database with migrations. Lastly, you
    included a gem to help you out with authentication. And now, you’re happy to say,
    this application works on your machine. Now it’s time to share your application
    with the world (or maybe just a client), and herein lies an important difference
    between a PHP application and a Rails application: the hosting.'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 恭喜你到达这个阶段。你已经创建了一个简单的 Rails 应用程序，它使用了控制器、视图和模型。你使用了生成器来准备你的开发。你还通过迁移设置了数据库。最后，你添加了一个
    gem 来帮助你进行身份验证。现在，你很高兴地说，这个应用程序在你的机器上运行正常。现在，是时候将你的应用程序与世界（或可能只是客户）分享，这就在 PHP
    应用程序和 Rails 应用程序之间存在着一个重要的区别：托管。
- en: In this chapter, we are going to go through certain aspects of hosting that
    we must consider when releasing our Rails application. We’ll compare different
    hosting options, as well as examine additional concepts we need for Rails applications.
    Then, we will look at how the Rails framework behaves depending on the environment
    setup. More specifically, we’ll look at error reporting on production environments.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将探讨发布我们的 Rails 应用程序时必须考虑的托管的一些方面。我们将比较不同的托管选项，并检查我们为 Rails 应用程序需要了解的额外概念。然后，我们将查看
    Rails 框架根据环境设置如何表现。更具体地说，我们将查看生产环境中的错误报告。
- en: 'With Rails hosting in mind, in this chapter, we will cover the following topics:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到 Rails 托管，在本章中，我们将涵盖以下主题：
- en: PHP versus Rails in terms of price
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: PHP 与 Rails 在价格方面的比较
- en: Do it yourself, or have it done for you?
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 自己动手做，还是让别人帮你做？
- en: Why nginx?
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为什么选择 nginx？
- en: Error gossip
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 错误八卦
- en: Technical requirements
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'To follow along this chapter, you will need the following:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 要跟随本章内容，你需要以下这些：
- en: Any IDE to view/edit code (e.g., SublimeText, Visual Studio Code, Notepad++,
    Vim, Emacs, etc.)
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 任何用于查看/编辑代码的 IDE（例如，SublimeText，Visual Studio Code，Notepad++，Vim，Emacs 等）
- en: For macOS users, you will also need to have the Xcode command line tools installed
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于 macOS 用户，你还需要安装 Xcode 命令行工具
- en: Ruby version 3.1.1 or later installed and ready to use
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 已安装并准备好使用的 Ruby 版本 3.1.1 或更高版本
- en: Git client installed on our local machine
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在我们的本地机器上安装 Git 客户端
- en: The code presented in this chapter is available at [https://github.com/PacktPublishing/From-PHP-to-Ruby-on-Rails/](https://github.com/PacktPublishing/From-PHP-to-Ruby-on-Rails/).
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中展示的代码可在[https://github.com/PacktPublishing/From-PHP-to-Ruby-on-Rails/](https://github.com/PacktPublishing/From-PHP-to-Ruby-on-Rails/)找到。
- en: PHP versus Rails in terms of price
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: PHP 与 Rails 在价格方面的比较
- en: 'Before you give me grief about this unfair comparison, I’m not comparing PHP
    and Rails directly. They can’t really be compared, as one is a programming language
    and the other a framework. A more fair comparison would be comparing the Laravel
    framework with the Rails framework. What I’m trying to convey is a PHP universe
    in which many tools live. But to do that, we must go back in time for a bit to
    when PHP finally became object oriented. This object-oriented PHP opened up a
    whole new world of possibilities. In 2004, PHP was already popular, and with this
    new feature (object-oriented programming), it became even more popular. WordPress
    became the standard for managing blogs and eventually websites. More web frameworks
    developed with PHP came into the picture: CodeIgniter, Symfony, Laravel, just
    to name a few. Joomla and Drupal gave developers yet another option that was a
    mix of a framework and a **Content Management System** (**CMS**). Thanks to this
    popularity, everyone was offering hosting options that supported PHP, and very
    cheaply if I may add. As other technologies became available, hosting for these
    technologies was also available but at a much higher cost. With the risk of sounding
    outrageous, I will say that I had a running application for a client in a server
    that cost them just 20 USD each year. Suffice it to say, in 2023, things have
    become a little more balanced than in 2004, but you can still find very cheap
    options for PHP applications, while (for the most part) Rails hosting will be
    slightly more costly. A quick search will land us with several options for Rails
    hosting, including the following more popular ones:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在您对我这个不公平的比较提出异议之前，我要说明，我并不是直接比较PHP和Rails。它们实际上是无法比较的，因为一个是编程语言，另一个是框架。一个更公平的比较应该是将Laravel框架与Rails框架进行比较。我试图传达的是一个PHP宇宙，其中许多工具都存在。但要做到这一点，我们必须回到PHP最终成为面向对象的时候。这种面向对象的PHP开辟了一个全新的可能性世界。在2004年，PHP已经很流行了，而随着这个新特性（面向对象编程）的出现，它变得更加流行。WordPress成为了管理博客和最终网站的标准。随着PHP开发出了更多的网络框架，如CodeIgniter、Symfony、Laravel等，这些框架也进入了视野。Joomla和Drupal为开发者提供了另一种选择，这是一种框架和**内容管理系统**（**CMS**）的混合体。多亏了这种流行，每个人都提供了支持PHP的托管选项，如果我可以补充的话，价格非常便宜。随着其他技术的出现，这些技术的托管也变得可用，但成本要高得多。冒着听起来过于夸张的风险，我要说，我为一个客户在服务器上运行的应用程序，每年只需花费他们20美元。简而言之，到2023年，事情已经比2004年稍微平衡了一些，但您仍然可以找到非常便宜的PHP应用程序的托管选项，而（在大多数情况下）Rails托管将稍微昂贵一些。快速搜索会给我们带来几个Rails托管的选项，包括以下更受欢迎的一些：
- en: DigitalOcean ([https://www.digitalocean.com/](https://www.digitalocean.com/))
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: DigitalOcean ([https://www.digitalocean.com/](https://www.digitalocean.com/))
- en: Amazon Lightsail ([https://aws.amazon.com/lightsail/](https://aws.amazon.com/lightsail/))
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Amazon Lightsail ([https://aws.amazon.com/lightsail/](https://aws.amazon.com/lightsail/))
- en: Heroku ([https://www.heroku.com/platform](https://www.heroku.com/platform))
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Heroku ([https://www.heroku.com/platform](https://www.heroku.com/platform))
- en: AWS ([https://aws.amazon.com/](https://aws.amazon.com/))
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: AWS ([https://aws.amazon.com/](https://aws.amazon.com/))
- en: Google Cloud ([https://cloud.google.com/](https://cloud.google.com/))
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Google Cloud ([https://cloud.google.com/](https://cloud.google.com/))
- en: Azure ([https://azure.microsoft.com/](https://azure.microsoft.com/))
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Azure ([https://azure.microsoft.com/](https://azure.microsoft.com/))
- en: In terms of cost, Amazon Lightsail is probably the most cost-effective option
    you will find (at the time of this writing) with plans for as little as 3.50 USD
    a month. This option offers a simple-to-use environment with **Amazon Web Services**
    (**AWS**) behind the scenes, but without the complexity. DigitalOcean offers a
    great option in terms of price and flexibility starting at 6 USD a month with
    a virtual machine that they fondly call a Droplet. This plan includes a PostgreSQL
    database. Heroku is a little more pricey, starting from 5 USD, and does not include
    a database in that price. A small database will add an additional 7 USD each month
    for a total of 12 USD. The last two options I’d say are only for more advanced
    needs and perhaps more advanced clients. They can be cheap (initially), but the
    more you need, the more expensive they become. Also, setting everything up in
    any cloud service (be it AWS, Google Cloud, or Azure) can be a real challenge
    as you need to fully understand elements of the cloud ecosystem, as opposed to
    other options that deliver a ready-to-use interface for your application.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 在成本方面，Amazon Lightsail 可能是您能找到的（在撰写本文时）最具成本效益的选项，其计划费用低至每月3.50美元。这个选项提供了一个简单易用的环境，背后有**亚马逊网络服务**（**AWS**）的支持，但避免了复杂性。DigitalOcean
    提供了一个价格合理且灵活的选项，起价为每月6美元，他们亲切地称这种虚拟机为Droplet。此计划包括一个PostgreSQL数据库。Heroku 的价格稍高，起价为5美元，但该价格不包括数据库。一个小型数据库每月额外增加7美元，总计12美元。最后两个选项我认为仅适用于更高级的需求和可能更高级的客户。它们（最初）可能很便宜，但随着需求的增加，成本也会上升。此外，在任何一个云服务中（无论是AWS、Google
    Cloud还是Azure）设置一切可能是一个真正的挑战，因为您需要完全理解云生态系统的元素，而其他选项则为您的应用程序提供了一个现成的用户界面。
- en: Additionally, depending on what your application does, the cost will vary and
    you won’t really know how much you’ll be charged until the end of the month. They
    do have built-in cost calculators and give more-or-less precise monthly estimates,
    but since they charge for everything (execution time of your virtual machine,
    networking, data transfer, disk usage, fixed IPs, and many other things), the
    costs will vary from month to month. You have absolute control of how your application
    is deployed and executed, but it comes at a cost. And then there are the worst-case
    scenarios, where if your security is compromised, an attacker might take control
    of not only your server but also your infrastructure, potentially costing you
    thousands of dollars for a simple mistake. That’s not to say that you shouldn’t
    consider the cloud options as viable. They’re just not an option for beginners
    or even intermediate developers. They’re enterprise solutions for those companies
    that can handle the risk and benefit from their usage. Let’s take a closer look
    at these differences between the bundled solutions (DigitalOcean, Amazon Lightsail,
    and Heroku) and the build-your-own options (AWS, Google Cloud, and Azure).
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，根据您的应用程序的功能，成本会有所不同，您直到月底才能真正知道您会被收取多少费用。他们确实有内置的成本计算器和提供或多或少精确的月度估计，但由于他们为一切收费（虚拟机的执行时间、网络、数据传输、磁盘使用、固定IP以及许多其他事物），因此成本会逐月变化。您对应用程序的部署和执行有绝对的控制权，但这需要付出代价。然后还有最坏的情况，如果您的安全受到威胁，攻击者可能会控制您的服务器以及您的整个基础设施，可能因为一个简单的错误而让您损失数千美元。这并不是说您不应该考虑云选项作为可行的选择。它们只是不是初学者甚至中级开发者的选择。它们是那些能够处理风险并从其使用中受益的公司企业的解决方案。让我们更详细地看看这些捆绑式解决方案（DigitalOcean、Amazon
    Lightsail和Heroku）与自行构建的选项（AWS、Google Cloud和Azure）之间的差异。
- en: DIY or have it done for you
  id: totrans-26
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: DIY或让别人为您完成
- en: 'We’ve seen, in terms of costs, the different options that are available to
    us for hosting our application. However, this isn’t the only distinguishing factor
    to consider while determining and implementing a solution. They also differ in
    terms of philosophy and usage. For now, we’ll stick to one option that is bundled,
    packaged, and ready to be used. By *bundled solution*, I’m referring to a solution
    that gives you a server that is installed, configured, and ready to use. For simplicity,
    I picked DigitalOcean and deployed our small application, but rest assured that
    the other bundled options will be very similar in implementation. As this incurs
    a cost, I won’t add the steps to follow along, so you just can sit back and enjoy
    the ride. You can typically select an optimized server image from a marketplace.
    Most bundled solutions have their own marketplaces where you can search and select
    an image (or template) that suits your needs. In our case, we can go to [https://marketplace.digitalocean.com/](https://marketplace.digitalocean.com/)
    and review the available options. Of course, they will have the classic **Linux-Apache-MySQL-PHP**
    (**LAMP**) images ready to go, but we’re interested in the Ruby-on-Rails counterpart,
    which we can easily find here:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到了，在成本方面，我们可供选择的不同托管选项。然而，在确定和实施解决方案时，这并不是唯一需要考虑的区分因素。它们在哲学和用途方面也有所不同。目前，我们将坚持使用一个捆绑、包装并准备好使用的选项。通过*捆绑解决方案*，我指的是一个提供安装、配置并准备好使用的服务器的解决方案。为了简单起见，我选择了DigitalOcean并部署了我们的小型应用程序，但请放心，其他捆绑选项在实施上将会非常相似。由于这会产生成本，我不会添加跟随步骤，所以您只需坐下来享受这个过程。通常，您可以从市场上选择一个优化的服务器镜像。大多数捆绑解决方案都有自己的市场，您可以在其中搜索并选择适合您需求的镜像（或模板）。在我们的案例中，我们可以访问[https://marketplace.digitalocean.com/](https://marketplace.digitalocean.com/)并查看可用的选项。当然，它们将提供经典的**Linux-Apache-MySQL-PHP**（**LAMP**）镜像，但我们感兴趣的是Ruby-on-Rails的对应版本，我们在这里可以轻松找到：
- en: '[https://marketplace.digitalocean.com/apps/ruby-on-rails](https://marketplace.digitalocean.com/apps/ruby-on-rails)'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://marketplace.digitalocean.com/apps/ruby-on-rails](https://marketplace.digitalocean.com/apps/ruby-on-rails)'
- en: 'Once we select the technology we will use, we can view what this virtual machine
    (or Droplet) includes:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们选择了将使用的技术，我们就可以查看这个虚拟机（或Droplet）包含的内容：
- en: '![Figure 10.1 – Rails virtual machine](img/B19230_10_01.jpg)'
  id: totrans-30
  prefs: []
  type: TYPE_IMG
  zh: '![图10.1 – Rails虚拟机](img/B19230_10_01.jpg)'
- en: Figure 10.1 – Rails virtual machine
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.1 – Rails虚拟机
- en: 'The greatest advantage of acquiring a bundled solution is that you don’t have
    to worry about installing Ruby, the Rails gem, and any other dependencies that
    we might need for our application. As we can see in *Figure 10**.1*, this virtual
    machine will have Rails 7.0.4.2 and all the dependencies needed for our application
    to work. Now, we’re presented with access to a shell where we can either log in
    or transfer our application files onto this server. It even comes with an example
    application already configured so that we know for a fact that Rails is installed
    and ready to be used. When I browsed to the IP that DigitalOcean provided for
    me, I encountered this familiar page:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 获取捆绑解决方案的最大优势是您不必担心安装Ruby、Rails gem以及我们可能需要的任何其他依赖项。正如我们在*图10*.1中可以看到的，这个虚拟机将包含Rails
    7.0.4.2以及我们应用程序运行所需的所有依赖项。现在，我们面前有一个shell，我们可以登录或者将我们的应用程序文件传输到这个服务器上。它甚至提供了一个已经配置好的示例应用程序，这样我们就可以确信Rails已经安装并准备好使用。当我浏览DigitalOcean为我提供的IP时，我遇到了这个熟悉的页面：
- en: '![Figure 10.2 – Rails example application on DigitalOcean](img/B19230_10_02.jpg)'
  id: totrans-33
  prefs: []
  type: TYPE_IMG
  zh: '![图10.2 – DigitalOcean上的Rails示例应用程序](img/B19230_10_02.jpg)'
- en: Figure 10.2 – Rails example application on DigitalOcean
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.2 – DigitalOcean上的Rails示例应用程序
- en: 'Deploying our application was simple enough, only requiring the same steps
    we did locally:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 部署我们的应用程序足够简单，只需要我们在本地执行的相同步骤：
- en: Copy the source code to the server.
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将源代码复制到服务器上。
- en: Run Rails migrations.
  id: totrans-37
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行Rails迁移。
- en: Run Rails seeds.
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行Rails种子。
- en: Add a use
  id: totrans-39
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个用途
- en: 'And voilà:'
  id: totrans-40
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 哇哦：
- en: '![Figure 10.3 – Deployed Rails application on DigitalOcean](img/B19230_10_03.jpg)'
  id: totrans-41
  prefs: []
  type: TYPE_IMG
  zh: '![图10.3 – 在DigitalOcean上部署的Rails应用程序](img/B19230_10_03.jpg)'
- en: Figure 10.3 – Deployed Rails application on DigitalOcean
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.3 – 在DigitalOcean上部署的Rails应用程序
- en: 'The same application we had locally has now been deployed to a hosting solution.
    With a few differences here and there, I can guarantee you that the other bundled
    options (such as Heroku or Amazon Lightsail) will provide a similar environment
    to get our app running. The automation of this process (the deployment) is outside
    of the scope of this book, but if you’re interested in more complex options for
    deployment, I suggest you take a look at Jenkins, Docker, and **Continuous Integration/Continuous**
    **Delivery** (**CI/CD**):'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前在本地运行的同一应用程序现在已部署到托管解决方案。尽管有一些细微的差别，但我可以保证其他捆绑选项（如Heroku或Amazon Lightsail）将提供类似的环境来运行我们的应用程序。这个过程（部署）的自动化超出了本书的范围，但如果你对更复杂的部署选项感兴趣，我建议你查看Jenkins、Docker和**持续集成/持续交付**（**CI/CD**）：
- en: '[https://www.jenkins.io/](https://www.jenkins.io/)'
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://www.jenkins.io/](https://www.jenkins.io/)'
- en: '[https://www.docker.com/](https://www.docker.com/)'
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://www.docker.com/](https://www.docker.com/)'
- en: '[https://docs.docker.com/samples/rails/](https://docs.docker.com/samples/rails/)'
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://docs.docker.com/samples/rails/](https://docs.docker.com/samples/rails/)'
- en: '[https://www.synopsys.com/glossary/what-is-cicd.html](https://www.synopsys.com/glossary/what-is-cicd.html)'
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://www.synopsys.com/glossary/what-is-cicd.html](https://www.synopsys.com/glossary/what-is-cicd.html)'
- en: For simplicity with our application, we chose the use of a SQLite database.
    It’s easy to install and implement locally, but for a real-world scenario, we
    would go for a more robust option such as MySQL or PostgreSQL. This Droplet additionally
    comes with a ready-to-use PostgreSQL database. This is what any bundled option
    would provide for us.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 为了简化我们的应用程序，我们选择了使用SQLite数据库。它易于安装和本地实施，但在现实世界的场景中，我们会选择更健壮的选项，如MySQL或PostgreSQL。这个Droplet还附带了一个即用型PostgreSQL数据库。这正是任何捆绑选项为我们提供的。
- en: 'To recap, these are the advantages of the bundled option:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 总结一下，捆绑选项的优势如下：
- en: Can be set up in no time
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可以立即设置
- en: Environment ready to use
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 环境即用
- en: Dependencies resolved
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 依赖关系已解决
- en: Robust database ready
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 强健的数据库已准备就绪
- en: However, this solution may not be a perfect fit for everyone. Most bundled solutions
    are flexible in terms of Ruby, but not in terms of the operating system. These
    solution providers can and will delete deprecated packages. Some solution providers
    even update packages (for security purposes) without your permission and may impact
    the behavior of your application. Additionally, when you need to customize your
    server, that may be your cue to consider the non-bundled solution options.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这个解决方案可能并不适合每个人。大多数捆绑解决方案在Ruby方面具有灵活性，但在操作系统方面则没有。这些解决方案提供商可以并且会删除过时的包。一些解决方案提供商甚至可以在未经你许可的情况下更新包（出于安全目的），这可能会影响你应用程序的行为。此外，当你需要自定义服务器时，这可能是你考虑非捆绑解决方案选项的信号。
- en: DIY
  id: totrans-55
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: DIY
- en: In contrast to the bundled options for hosting, the do-it-yourself options give
    you much more flexibility. Why would we need that flexibility? There are many
    cases where this is necessary, but one specific use case I can think of for this
    scenario is to scale up an application’s resources. Let’s say, for example, that
    your application is initially set up to serve 500 users, but you notice that you
    now have a database with 10,000 users. Your application is now very slow, but
    increasing the size (memory and CPU) of your server for 10,000 users would be
    way too expensive. You also notice that the number of concurrent users (i.e.,
    users using the application at the same time) reaches 4,000 and not 10,000\. In
    comes auto-scaling to the rescue!
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 与捆绑选项的托管服务相比，DIY选项为您提供了更大的灵活性。为什么我们需要这种灵活性呢？有许多情况下这是必要的，但我想出的一个具体用例是扩展应用程序的资源。比如说，如果你的应用程序最初是为服务500个用户而设置的，但现在你注意到你的数据库中有10,000个用户。你的应用程序现在非常慢，但为10,000个用户增加服务器的规模（内存和CPU）将非常昂贵。你也注意到并发用户数（即同时使用应用程序的用户数）达到了4,000，而不是10,000。这时，自动扩展就派上用场了！
- en: 'Auto-scaling determines the resource requirements at a given moment and automatically
    scales up as concurrent users peak, and then scales back down when user concurrency
    drops. By *scaling up* I’m referring to the platform creating more servers on
    the fly to be able to handle more users. As the hosting service only charges you
    when those additional servers are actually running, the whole process can save
    the company money as you don’t have a whole army of servers turned on the whole
    time, but only when the number of users peaks. Additionally, your application’s
    availability increases with this approach. I’m oversimplifying this whole process,
    but I do hope you get where I’m going with this. This is only one of many scenarios
    where a non-bundled solution would be the best fit. If you are interested in learning
    more about the topic of auto-scaling, I recommend you look at the official AWS
    page for auto-scaling:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 自动扩展会在特定时刻确定资源需求，并在并发用户达到峰值时自动扩展，当用户并发下降时再缩小规模。通过 *扩展* 我指的是平台在需要处理更多用户时即时创建更多服务器。由于托管服务只在那些额外服务器实际运行时向您收费，整个过程可以为公司节省资金，因为您不需要一直开启整个服务器军团，而只是在用户数量达到峰值时才开启。此外，采用这种方法，您的应用程序可用性也会提高。我在简化整个过程，但我确实希望您能理解我的意图。这只是一个非捆绑式解决方案最适合的许多场景之一。如果您想了解更多关于自动扩展的信息，我建议您查看
    AWS 官方页面上的自动扩展部分：
- en: '[https://aws.amazon.com/autoscaling/](https://aws.amazon.com/autoscaling/)'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://aws.amazon.com/autoscaling/](https://aws.amazon.com/autoscaling/)'
- en: I’m going to choose AWS for our hypothetical solution, but it would be implemented
    similarly on any other cloud. To deploy our simple application on AWS, we would
    create an EC2 instance and add the security groups.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 我打算为我们的假设解决方案选择 AWS，但同样也可以在任何其他云平台上实现。要在 AWS 上部署我们的简单应用程序，我们会创建一个 EC2 实例并添加安全组。
- en: Once we launch our instance, we would wait for it to come up, which might take
    a couple of minutes. Once our instance was ready, we would access it through SSH
    and then begin our Ruby configuration. This would include installing Ruby, the
    bundler, GCC compilers – the works. Once Ruby was ready, we would install our
    Rails gem. Then we would upload our application code to our virtual machine and
    run the initial setup (installing dependencies, Rails migrations, Rails seed,
    and user setup). Then we’d start the server. This is where things would start
    to get more and more complicated. We would have a number of options for making
    this application available to the world. One option would be to open port `3000`
    to the world, and away we go. However, the Rails server should never be exposed
    directly to the outside world. We’ll see why that is in the next section, but
    for now, let’s just stick to that principle. We’ll need to set up Nginx as our
    web server and have it redirect calls to our Rails app. Once this was ready, we
    would be good to go.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们启动了实例，我们会等待它启动，这可能需要几分钟。一旦我们的实例准备就绪，我们会通过 SSH 访问它，然后开始我们的 Ruby 配置。这包括安装
    Ruby、bundler、GCC 编译器——所有这些。一旦 Ruby 准备就绪，我们会安装我们的 Rails 晶石。然后我们会将我们的应用程序代码上传到我们的虚拟机，并运行初始设置（安装依赖项、Rails
    迁移、Rails 种子以及用户设置）。然后我们会启动服务器。从这里开始，事情会变得越来越复杂。我们会有一系列选项来使这个应用程序对世界可用。一个选项是将端口
    `3000` 打开给世界，然后我们就出发了。然而，Rails 服务器永远不应该直接暴露给外界。我们将在下一节中看到这是为什么，但现在，让我们坚持这个原则。我们需要设置
    Nginx 作为我们的 web 服务器，并让它将调用重定向到我们的 Rails 应用。一旦准备好了，我们就可以出发了。
- en: As you can see, this seems more complicated than the bundled option. With this
    simple example, there isn’t any easily discernable advantage to building it on
    our own, and that’s because it doesn’t really give us any advantage. At least,
    not for our specific case – firstly, because AWS will always be an expensive choice,
    and secondly, because it is an enterprise solution, and as such, as in most enterprise
    solutions, the configuration and deployment will be more complex, albeit resulting
    in many more choices for your application. While I wouldn’t recommend deploying
    our application in any DIY public cloud (AWS, Google Cloud, or Azure) to share
    it with the world, I would recommend you do this as an exercise as it will get
    you familiar with the operations of cloud solutions. Nowadays, familiarity with
    this type of technology is a must for developers.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，这似乎比捆绑选项更复杂。在这个简单的例子中，自己构建它并没有明显的优势，这是因为它实际上并没有给我们带来任何优势。至少，不是针对我们特定的案例——首先，因为AWS始终是一个昂贵的选择，其次，因为它是一个企业级解决方案，因此，就像大多数企业级解决方案一样，配置和部署将会更复杂，尽管这将为你的应用程序提供更多的选择。虽然我不会推荐将我们的应用程序部署到任何DIY公共云（AWS、Google
    Cloud或Azure）以供全世界分享，但我建议你将其作为一个练习来做，因为这会使你熟悉云解决方案的操作。如今，熟悉这类技术对于开发者来说是必须的。
- en: While we don’t really need to go into the details of these solutions (at least
    not for now), I believe we do need to get a grasp of certain concepts regarding
    our application deployment. Deploying our application behind a web server (Nginx)
    is one of these concepts, which we will look at in more depth in the next section.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我们目前并不真的需要深入了解这些解决方案的细节（至少现在还不需要），但我相信我们确实需要掌握一些关于我们应用程序部署的概念。在我们的应用程序后面部署一个网络服务器（Nginx）就是这些概念之一，我们将在下一节中更深入地探讨这一点。
- en: Why nginx?
  id: totrans-63
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为什么是nginx？
- en: 'Coming from a PHP background, one of the concepts that was difficult for me
    to grasp was Rails’ lack of the out-of-the-box server functionality seen in PHP.
    With PHP, if it is installed, you can open a shell and type the following:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 来自PHP背景的我，发现Rails缺乏PHP中常见的开箱即用的服务器功能是一个难以理解的概念。在PHP中，如果它被安装了，你可以在shell中打开它并输入以下内容：
- en: '[PRE0]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: This will bring up an internal PHP server. You can now open a browser, point
    it to `http://localhost:9000/`, and that’s all you need to do. Any PHP scripts
    we add to the same folder where we started the PHP server will be available to
    said server. We don’t need any PHP framework to start programming in PHP. We can
    use this internal server for development and once we deploy our PHP application
    to a production server, our application just requires a web server that has PHP
    enabled. This is an oversimplification of how it’s actually done, but in essence,
    that’s all that’s needed for PHP servers.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 这将启动一个内部PHP服务器。现在你可以打开一个浏览器，将其指向`http://localhost:9000/`，这就足够了。我们添加到启动PHP服务器同一文件夹中的任何PHP脚本都将对该服务器可用。我们不需要任何PHP框架就可以开始用PHP编程。我们可以使用这个内部服务器进行开发，一旦我们将PHP应用程序部署到生产服务器，我们的应用程序只需要一个启用了PHP的网络服务器。这只是一个过于简化的实际操作过程，但本质上，这就是PHP服务器所需的所有内容。
- en: 'In the good ol’ days, Apache was the way to go. These days, you can still use
    Apache, but Nginx has gained a lot of ground here, to the point that Nginx is
    nowadays almost (if not) the standard. What is Nginx? Nginx (according to its
    website) is an advanced load balancer, web server, and reverse proxy designed
    to handle high-traffic websites and applications. It is widely used as a web server
    and has reportedly been adopted by Netflix and Airbnb, among others. With these
    names involved, we can safely assume its efficiency whilst handling web-related
    components is extremely high. Why should we use Nginx as a web server for Rails?
    The answer is delegation. A web server should handle things such as static assets
    (images, stylesheets, etc.), file uploads, SSL certificate display, and some DDoS
    protection, to name just a few. Rails (and many other web frameworks) are very
    capable of handling most of these tasks too, but why reinvent the wheel when we
    can have our Rails application only needing to worry about Rails tasks, and Nginx
    worrying about the web-related tasks? Additionally, Nginx is much faster and more
    efficient at handling these tasks than any web framework. As a matter of fact,
    our demo bundled hosting solution (DigitalOcean) comes with Nginx installed and
    configured to point to the example Rails application. I disabled the Rails upstream
    and set the Nginx page to the default, and this is what I got:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 在那些美好的日子里，Apache是首选。如今，你仍然可以使用Apache，但Nginx在这里已经取得了很大的进展，以至于Nginx现在几乎（如果不是）成为了标准。那么什么是Nginx呢？Nginx（根据其网站）是一个高级负载均衡器、Web服务器和反向代理，旨在处理高流量网站和应用。它被广泛用作Web服务器，据报道已被Netflix和Airbnb等公司采用。由于这些公司的参与，我们可以安全地假设它在处理与Web相关组件时的效率极高。为什么我们应该将Nginx用作Rails的Web服务器呢？答案是委托。Web服务器应该处理诸如静态资源（图像、样式表等）、文件上传、SSL证书显示以及一些DDoS保护等任务，仅举几个例子。Rails（以及许多其他Web框架）也非常擅长处理这些任务中的大多数，但为什么要在我们能够使我们的Rails应用程序只需关注Rails任务，而Nginx关注Web相关任务时重新发明轮子呢？此外，Nginx在处理这些任务方面比任何Web框架都要快得多、效率更高。事实上，我们的演示捆绑式托管解决方案（DigitalOcean）已经安装并配置了Nginx，指向示例Rails应用程序。我禁用了Rails上游，并将Nginx页面设置为默认页面，这就是我得到的结果：
- en: '![Figure 10.3 – Nginx default page on DigitalOcean](img/B19230_10_04.jpg)'
  id: totrans-68
  prefs: []
  type: TYPE_IMG
  zh: '![图10.3 – DigitalOcean上的Nginx默认页面](img/B19230_10_04.jpg)'
- en: Figure 10.3 – Nginx default page on DigitalOcean
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.3 – DigitalOcean上的Nginx默认页面
- en: 'The task of setting up the Nginx configuration is another reason why we should
    opt for the bundled solution – the DIY solution leaves the task of installing
    and configuring Nginx to us. While this is definitely not a complicated task,
    it does add yet another layer of work to the DIY solution. I realize this is a
    lot of information to take in when considering hosting options, but if you want
    to learn more about Nginx and related topics, please take a look at the following
    sites:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 设置Nginx配置的任务是选择捆绑式解决方案的另一个原因——DIY解决方案将安装和配置Nginx的任务留给了我们。虽然这绝对不是一项复杂的工作，但它确实给DIY解决方案增加了另一层工作量。我意识到在考虑托管选项时，这些信息量很大，但如果你想了解更多关于Nginx和相关主题的信息，请查看以下网站：
- en: '[https://www.nginx.com/](https://www.nginx.com/)'
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://www.nginx.com/](https://www.nginx.com/)'
- en: '[https://docs.nginx.com/nginx/admin-guide/installing-nginx/installing-nginx-open-source/](https://docs.nginx.com/nginx/admin-guide/installing-nginx/installing-nginx-open-source/)'
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://docs.nginx.com/nginx/admin-guide/installing-nginx/installing-nginx-open-source/](https://docs.nginx.com/nginx/admin-guide/installing-nginx/installing-nginx-open-source/)'
- en: '[https://unit.nginx.org/howto/rails/](https://unit.nginx.org/howto/rails/)'
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://unit.nginx.org/howto/rails/](https://unit.nginx.org/howto/rails/)'
- en: Lastly, we need to bear in mind that Rails will behave differently when run
    locally than in a production environment, and that includes how we view errors
    on a server.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们需要记住，Rails在本地运行时与在生产环境中运行时的行为会有所不同，这包括我们在服务器上查看错误的方式。
- en: Error gossip and last words
  id: totrans-75
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 错误八卦和遗言
- en: 'So far, we’ve only used the Rails framework with most of the default options.
    These default options include some configurations that would otherwise hinder
    and slow down the overall experience for the end user. These options make sense
    in development, as they make debugging and testing really easy. As developers,
    we need to be able to set up our local environment as soon as possible and start
    programming away. However, these default options do not make sense in a production
    environment. One of these defaults concerns error reporting. We saw locally how
    errors are displayed, but in a real-life scenario, we would never want these errors
    to be shown in the same way. We would not want detailed error output stating paths,
    variables, or even what database we’re using, as this could be a security breach,
    or at least the beginning of one. We would want the error to be like gossip: quiet
    and behind our backs. And that’s exactly what we’re going to do. For this last
    exercise, we will need to load a Rails application as we’ve done in previous chapters.
    If you haven’t downloaded the source code for the course, open a terminal and
    type the following `git` command:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们只使用了Rails框架的大部分默认选项。这些默认选项包括一些配置，否则会阻碍并减慢最终用户的整体体验。这些选项在开发中是有意义的，因为它们使得调试和测试变得非常容易。作为开发者，我们需要尽快设置我们的本地环境并开始编程。然而，这些默认选项在生产环境中并不合适。其中之一是关于错误报告的默认设置。我们在本地看到了错误是如何显示的，但在现实生活中，我们绝对不希望以同样的方式显示这些错误。我们不希望有详细的错误输出，包括路径、变量，甚至我们使用的数据库，因为这可能是安全漏洞，至少是开始。我们希望错误就像八卦一样：安静且在我们背后。这正是我们要做的。对于这个最后的练习，我们需要像前几章那样加载一个Rails应用程序。如果您还没有下载课程的源代码，请打开终端并输入以下`git`命令：
- en: '[PRE1]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'If you’ve already done so, then just navigate into the `chapter10` folder within
    your project by running the following command:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您已经这样做，那么只需通过运行以下命令进入您项目中的`chapter10`文件夹：
- en: '[PRE2]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Again, let’s install our dependencies with the following command:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，让我们使用以下命令安装我们的依赖项：
- en: '[PRE3]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'And to confirm our setup was done correctly, let’s run the following command:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 为了确认我们的设置是否正确，让我们运行以下命令：
- en: '[PRE4]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The output should read something like the following:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 输出应该类似于以下内容：
- en: '[PRE5]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'And now we are ready to run our Rails application in production. We do this
    by adding the `RAILS_ENV=production` environment variable before the Rails startup
    command. Let’s give it a try. In our shell, let’s type the following:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经准备好在生产中运行我们的Rails应用程序。我们通过在Rails启动命令之前添加`RAILS_ENV=production`环境变量来实现这一点。让我们试一试。在我们的shell中，让我们输入以下内容：
- en: '[PRE6]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Once we run the preceding command, our application will run as usual, and our
    shell will look like this:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们运行前面的命令，我们的应用程序将像往常一样运行，我们的shell将看起来像这样：
- en: '[PRE7]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'But now, if we go to our browser and navigate to `http://0.0.0.0:3000`, we
    are now greeted with this page:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 但现在，如果我们去我们的浏览器并导航到`http://0.0.0.0:3000`，我们现在看到的是这个页面：
- en: '![Figure 10.4 – Rails running in production mode](img/B19230_10_05.jpg)'
  id: totrans-91
  prefs: []
  type: TYPE_IMG
  zh: '![图10.4 – Rails在生产模式运行](img/B19230_10_05.jpg)'
- en: Figure 10.4 – Rails running in production mode
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.4 – Rails在生产模式运行
- en: 'Granted, for development, this is a hassle, but trust me, you will be thankful
    when this page shows on your application deployed in production. As we are running
    our application in production mode, all errors are hidden. Now we need to look
    for the error in our logs. So far, we’ve neglected our log files, as the errors
    were always shown on the browser, but the logs have always been there. If we look
    at the `chapter10/hosting_original/log/` folder, we now have two files:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，对于开发来说，这可能是个麻烦，但请相信我，当这个页面出现在您生产部署的应用程序上时，您会感到非常感激。因为我们正在以生产模式运行应用程序，所以所有错误都被隐藏了。现在我们需要在我们的日志中查找错误。到目前为止，我们忽略了日志文件，因为错误总是显示在浏览器上，但日志始终存在。如果我们查看`chapter10/hosting_original/log/`文件夹，我们现在有两个文件：
- en: '![Figure 10.5 – Rails log files](img/B19230_10_06.jpg)'
  id: totrans-94
  prefs: []
  type: TYPE_IMG
  zh: '![图10.5 – Rails日志文件](img/B19230_10_06.jpg)'
- en: Figure 10.5 – Rails log files
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.5 – Rails日志文件
- en: 'Since we are running our application in production, let’s open the `production.log`
    file. If there is too much information in the log, we can delete the contents
    of the file, save the file, and then refresh the browser. Now we can look at the
    file again with less data. We should now see something like this:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们在生产环境中运行应用程序，让我们打开`production.log`文件。如果日志中信息过多，我们可以删除文件内容，保存文件，然后刷新浏览器。现在我们可以用更少的数据再次查看文件。我们现在应该看到如下内容：
- en: '[PRE8]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'We notice the `FATAL` keyword, which is what caused our error. The error states
    that we cannot find the `''users''` table. This is because we have not run the
    Rails migrations. So, let’s do that. Let’s stop our application by pressing *Ctrl
    + C*, and run the following command on our shell:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 我们注意到`FATAL`关键字，这就是导致我们错误的原因。错误指出我们找不到`'users'`表。这是因为我们没有运行Rails迁移。所以，让我们来做这件事。通过在shell上按*Ctrl
    + C*停止我们的应用程序，然后在shell上运行以下命令：
- en: '[PRE9]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Don’t forget to prefix our command with the environment. The command should
    produce output detailing that the tables have been created:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 不要忘记在命令前加上环境前缀。命令应该会输出详细说明已创建表的输出：
- en: '[PRE10]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Now let’s restart our Rails application by typing the following on the shell
    again:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们再次在shell上输入以下命令来重启我们的Rails应用程序：
- en: '[PRE11]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Now, refresh the browser. It looks the same, with just an error page. Let’s
    delete the contents of our `production.log` file again and refresh our browser
    once more. Now when we look at the log file again, we see a different `FATAL`
    error:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，刷新浏览器。看起来一样，只是出现了一个错误页面。让我们再次删除`production.log`文件的内容，并再次刷新浏览器。现在当我们再次查看日志文件时，我们看到一个不同的`FATAL`错误：
- en: '[PRE12]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'I’ve removed the rest of the log for clarity, but the `FATAL` error is what
    gives us a clue as to the problem. In Rails, when executing our application in
    production, some assets need to be compiled or transpiled. In this case, it’s
    the CSS and JavaScript assets that need to be generated and minified. Fortunately,
    Rails has a command to do this task. To do that, we need to stop our application
    with *Ctrl + C* on the shell and then run the following command:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 我为了清晰起见移除了日志的其余部分，但`FATAL`错误正是给我们提供问题线索的地方。在Rails中，当我们以生产模式执行应用程序时，一些资源需要被编译或转换。在这种情况下，需要生成和压缩CSS和JavaScript资源。幸运的是，Rails有一个命令来完成这个任务。为了完成这个任务，我们需要在shell上使用*Ctrl
    + C*停止我们的应用程序，然后运行以下命令：
- en: '[PRE13]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'This should output a series of messages stating that the assets have been generated:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 这应该会输出一系列消息，表明资源已经被生成：
- en: '[PRE14]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'There are a lot of files that were generated, but we’re not going to get into
    details as to how the mechanism works. Let’s just say that the frontend assets
    were generated. Now let’s run our application once more with the following command:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 生成了很多文件，但我们不会深入探讨其工作机制。简单来说，前端资源已经被生成。现在，让我们再次运行我们的应用程序，使用以下命令：
- en: '[PRE15]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'And when we refresh the browser once more, we should see a familiar page:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们再次刷新浏览器时，我们应该看到一个熟悉的页面：
- en: '![Figure 10.6 – Rails login page](img/B19230_10_07.jpg)'
  id: totrans-113
  prefs: []
  type: TYPE_IMG
  zh: '![图10.6 – Rails登录页面](img/B19230_10_07.jpg)'
- en: Figure 10.6 – Rails login page
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.6 – Rails登录页面
- en: Congratulations, my dear readers! We are now running a Rails application in
    production mode. As you can see, it’s a lot more hassle to debug our application
    as the error messages are now hidden in logs. In a real production environment,
    we would have to look for where these logs were kept. Running Rails tasks (db,
    generators, assets, etc.) might also not prove to be so straightforward. You might
    have to tweak the commands, and in some cases, will not be allowed to run them
    at all. Either way, for now, this is the end of the road and I applaud you readers
    for sticking with me in this Ruby-on-Rails voyage.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 恭喜，亲爱的读者们！我们现在正在以生产模式运行Rails应用程序。正如你所见，调试我们的应用程序变得更加麻烦，因为错误信息现在隐藏在日志中。在真正的生产环境中，我们可能需要查找这些日志被保存在哪里。运行Rails任务（数据库、生成器、资源等）可能也不会那么直接。你可能需要调整命令，在某些情况下，甚至不允许运行它们。无论如何，现在这条路已经走到了尽头，我为读者们能坚持与我一起完成这个Ruby-on-Rails之旅而鼓掌。
- en: Summary
  id: totrans-116
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: We covered a lot of information in this chapter. We learned about the costs
    of hosting, the different options on the market, and whether it makes sense to
    opt for a bundled solution with everything configured for us, or a DIY option,
    which offers more flexibility but is also more complex and expensive. We also
    learned why we should deploy our applications behind Nginx. Finally, we learned
    how to debug an application in production mode.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们涵盖了大量的信息。我们学习了托管成本、市场上的不同选项，以及选择为我们配置好的一切的捆绑解决方案是否合理，或者选择DIY选项，它提供了更多的灵活性，但也更加复杂和昂贵。我们还学习了为什么我们应该在Nginx后面部署我们的应用程序。最后，我们学习了如何在生产模式下调试应用程序。
- en: We are now ready to use what we’ve learned in this book and add Ruby to our
    arsenal.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以使用这本书中学到的知识，并将Ruby添加到我们的武器库中。
