- en: '10'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Considerations for Hosting Rails Applications versus PHP Applications
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Congratulations for making it to this point. You’ve created a simple Rails
    application that uses controllers, views, and models. You used generators to prep
    for your development. You also set up the database with migrations. Lastly, you
    included a gem to help you out with authentication. And now, you’re happy to say,
    this application works on your machine. Now it’s time to share your application
    with the world (or maybe just a client), and herein lies an important difference
    between a PHP application and a Rails application: the hosting.'
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we are going to go through certain aspects of hosting that
    we must consider when releasing our Rails application. We’ll compare different
    hosting options, as well as examine additional concepts we need for Rails applications.
    Then, we will look at how the Rails framework behaves depending on the environment
    setup. More specifically, we’ll look at error reporting on production environments.
  prefs: []
  type: TYPE_NORMAL
- en: 'With Rails hosting in mind, in this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: PHP versus Rails in terms of price
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Do it yourself, or have it done for you?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Why nginx?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Error gossip
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To follow along this chapter, you will need the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Any IDE to view/edit code (e.g., SublimeText, Visual Studio Code, Notepad++,
    Vim, Emacs, etc.)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For macOS users, you will also need to have the Xcode command line tools installed
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Ruby version 3.1.1 or later installed and ready to use
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Git client installed on our local machine
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The code presented in this chapter is available at [https://github.com/PacktPublishing/From-PHP-to-Ruby-on-Rails/](https://github.com/PacktPublishing/From-PHP-to-Ruby-on-Rails/).
  prefs: []
  type: TYPE_NORMAL
- en: PHP versus Rails in terms of price
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Before you give me grief about this unfair comparison, I’m not comparing PHP
    and Rails directly. They can’t really be compared, as one is a programming language
    and the other a framework. A more fair comparison would be comparing the Laravel
    framework with the Rails framework. What I’m trying to convey is a PHP universe
    in which many tools live. But to do that, we must go back in time for a bit to
    when PHP finally became object oriented. This object-oriented PHP opened up a
    whole new world of possibilities. In 2004, PHP was already popular, and with this
    new feature (object-oriented programming), it became even more popular. WordPress
    became the standard for managing blogs and eventually websites. More web frameworks
    developed with PHP came into the picture: CodeIgniter, Symfony, Laravel, just
    to name a few. Joomla and Drupal gave developers yet another option that was a
    mix of a framework and a **Content Management System** (**CMS**). Thanks to this
    popularity, everyone was offering hosting options that supported PHP, and very
    cheaply if I may add. As other technologies became available, hosting for these
    technologies was also available but at a much higher cost. With the risk of sounding
    outrageous, I will say that I had a running application for a client in a server
    that cost them just 20 USD each year. Suffice it to say, in 2023, things have
    become a little more balanced than in 2004, but you can still find very cheap
    options for PHP applications, while (for the most part) Rails hosting will be
    slightly more costly. A quick search will land us with several options for Rails
    hosting, including the following more popular ones:'
  prefs: []
  type: TYPE_NORMAL
- en: DigitalOcean ([https://www.digitalocean.com/](https://www.digitalocean.com/))
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Amazon Lightsail ([https://aws.amazon.com/lightsail/](https://aws.amazon.com/lightsail/))
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Heroku ([https://www.heroku.com/platform](https://www.heroku.com/platform))
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: AWS ([https://aws.amazon.com/](https://aws.amazon.com/))
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Google Cloud ([https://cloud.google.com/](https://cloud.google.com/))
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Azure ([https://azure.microsoft.com/](https://azure.microsoft.com/))
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In terms of cost, Amazon Lightsail is probably the most cost-effective option
    you will find (at the time of this writing) with plans for as little as 3.50 USD
    a month. This option offers a simple-to-use environment with **Amazon Web Services**
    (**AWS**) behind the scenes, but without the complexity. DigitalOcean offers a
    great option in terms of price and flexibility starting at 6 USD a month with
    a virtual machine that they fondly call a Droplet. This plan includes a PostgreSQL
    database. Heroku is a little more pricey, starting from 5 USD, and does not include
    a database in that price. A small database will add an additional 7 USD each month
    for a total of 12 USD. The last two options I’d say are only for more advanced
    needs and perhaps more advanced clients. They can be cheap (initially), but the
    more you need, the more expensive they become. Also, setting everything up in
    any cloud service (be it AWS, Google Cloud, or Azure) can be a real challenge
    as you need to fully understand elements of the cloud ecosystem, as opposed to
    other options that deliver a ready-to-use interface for your application.
  prefs: []
  type: TYPE_NORMAL
- en: Additionally, depending on what your application does, the cost will vary and
    you won’t really know how much you’ll be charged until the end of the month. They
    do have built-in cost calculators and give more-or-less precise monthly estimates,
    but since they charge for everything (execution time of your virtual machine,
    networking, data transfer, disk usage, fixed IPs, and many other things), the
    costs will vary from month to month. You have absolute control of how your application
    is deployed and executed, but it comes at a cost. And then there are the worst-case
    scenarios, where if your security is compromised, an attacker might take control
    of not only your server but also your infrastructure, potentially costing you
    thousands of dollars for a simple mistake. That’s not to say that you shouldn’t
    consider the cloud options as viable. They’re just not an option for beginners
    or even intermediate developers. They’re enterprise solutions for those companies
    that can handle the risk and benefit from their usage. Let’s take a closer look
    at these differences between the bundled solutions (DigitalOcean, Amazon Lightsail,
    and Heroku) and the build-your-own options (AWS, Google Cloud, and Azure).
  prefs: []
  type: TYPE_NORMAL
- en: DIY or have it done for you
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We’ve seen, in terms of costs, the different options that are available to
    us for hosting our application. However, this isn’t the only distinguishing factor
    to consider while determining and implementing a solution. They also differ in
    terms of philosophy and usage. For now, we’ll stick to one option that is bundled,
    packaged, and ready to be used. By *bundled solution*, I’m referring to a solution
    that gives you a server that is installed, configured, and ready to use. For simplicity,
    I picked DigitalOcean and deployed our small application, but rest assured that
    the other bundled options will be very similar in implementation. As this incurs
    a cost, I won’t add the steps to follow along, so you just can sit back and enjoy
    the ride. You can typically select an optimized server image from a marketplace.
    Most bundled solutions have their own marketplaces where you can search and select
    an image (or template) that suits your needs. In our case, we can go to [https://marketplace.digitalocean.com/](https://marketplace.digitalocean.com/)
    and review the available options. Of course, they will have the classic **Linux-Apache-MySQL-PHP**
    (**LAMP**) images ready to go, but we’re interested in the Ruby-on-Rails counterpart,
    which we can easily find here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://marketplace.digitalocean.com/apps/ruby-on-rails](https://marketplace.digitalocean.com/apps/ruby-on-rails)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Once we select the technology we will use, we can view what this virtual machine
    (or Droplet) includes:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.1 – Rails virtual machine](img/B19230_10_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.1 – Rails virtual machine
  prefs: []
  type: TYPE_NORMAL
- en: 'The greatest advantage of acquiring a bundled solution is that you don’t have
    to worry about installing Ruby, the Rails gem, and any other dependencies that
    we might need for our application. As we can see in *Figure 10**.1*, this virtual
    machine will have Rails 7.0.4.2 and all the dependencies needed for our application
    to work. Now, we’re presented with access to a shell where we can either log in
    or transfer our application files onto this server. It even comes with an example
    application already configured so that we know for a fact that Rails is installed
    and ready to be used. When I browsed to the IP that DigitalOcean provided for
    me, I encountered this familiar page:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.2 – Rails example application on DigitalOcean](img/B19230_10_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.2 – Rails example application on DigitalOcean
  prefs: []
  type: TYPE_NORMAL
- en: 'Deploying our application was simple enough, only requiring the same steps
    we did locally:'
  prefs: []
  type: TYPE_NORMAL
- en: Copy the source code to the server.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Run Rails migrations.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Run Rails seeds.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add a use
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'And voilà:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 10.3 – Deployed Rails application on DigitalOcean](img/B19230_10_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.3 – Deployed Rails application on DigitalOcean
  prefs: []
  type: TYPE_NORMAL
- en: 'The same application we had locally has now been deployed to a hosting solution.
    With a few differences here and there, I can guarantee you that the other bundled
    options (such as Heroku or Amazon Lightsail) will provide a similar environment
    to get our app running. The automation of this process (the deployment) is outside
    of the scope of this book, but if you’re interested in more complex options for
    deployment, I suggest you take a look at Jenkins, Docker, and **Continuous Integration/Continuous**
    **Delivery** (**CI/CD**):'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://www.jenkins.io/](https://www.jenkins.io/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://www.docker.com/](https://www.docker.com/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://docs.docker.com/samples/rails/](https://docs.docker.com/samples/rails/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://www.synopsys.com/glossary/what-is-cicd.html](https://www.synopsys.com/glossary/what-is-cicd.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For simplicity with our application, we chose the use of a SQLite database.
    It’s easy to install and implement locally, but for a real-world scenario, we
    would go for a more robust option such as MySQL or PostgreSQL. This Droplet additionally
    comes with a ready-to-use PostgreSQL database. This is what any bundled option
    would provide for us.
  prefs: []
  type: TYPE_NORMAL
- en: 'To recap, these are the advantages of the bundled option:'
  prefs: []
  type: TYPE_NORMAL
- en: Can be set up in no time
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Environment ready to use
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Dependencies resolved
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Robust database ready
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: However, this solution may not be a perfect fit for everyone. Most bundled solutions
    are flexible in terms of Ruby, but not in terms of the operating system. These
    solution providers can and will delete deprecated packages. Some solution providers
    even update packages (for security purposes) without your permission and may impact
    the behavior of your application. Additionally, when you need to customize your
    server, that may be your cue to consider the non-bundled solution options.
  prefs: []
  type: TYPE_NORMAL
- en: DIY
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In contrast to the bundled options for hosting, the do-it-yourself options give
    you much more flexibility. Why would we need that flexibility? There are many
    cases where this is necessary, but one specific use case I can think of for this
    scenario is to scale up an application’s resources. Let’s say, for example, that
    your application is initially set up to serve 500 users, but you notice that you
    now have a database with 10,000 users. Your application is now very slow, but
    increasing the size (memory and CPU) of your server for 10,000 users would be
    way too expensive. You also notice that the number of concurrent users (i.e.,
    users using the application at the same time) reaches 4,000 and not 10,000\. In
    comes auto-scaling to the rescue!
  prefs: []
  type: TYPE_NORMAL
- en: 'Auto-scaling determines the resource requirements at a given moment and automatically
    scales up as concurrent users peak, and then scales back down when user concurrency
    drops. By *scaling up* I’m referring to the platform creating more servers on
    the fly to be able to handle more users. As the hosting service only charges you
    when those additional servers are actually running, the whole process can save
    the company money as you don’t have a whole army of servers turned on the whole
    time, but only when the number of users peaks. Additionally, your application’s
    availability increases with this approach. I’m oversimplifying this whole process,
    but I do hope you get where I’m going with this. This is only one of many scenarios
    where a non-bundled solution would be the best fit. If you are interested in learning
    more about the topic of auto-scaling, I recommend you look at the official AWS
    page for auto-scaling:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://aws.amazon.com/autoscaling/](https://aws.amazon.com/autoscaling/)'
  prefs: []
  type: TYPE_NORMAL
- en: I’m going to choose AWS for our hypothetical solution, but it would be implemented
    similarly on any other cloud. To deploy our simple application on AWS, we would
    create an EC2 instance and add the security groups.
  prefs: []
  type: TYPE_NORMAL
- en: Once we launch our instance, we would wait for it to come up, which might take
    a couple of minutes. Once our instance was ready, we would access it through SSH
    and then begin our Ruby configuration. This would include installing Ruby, the
    bundler, GCC compilers – the works. Once Ruby was ready, we would install our
    Rails gem. Then we would upload our application code to our virtual machine and
    run the initial setup (installing dependencies, Rails migrations, Rails seed,
    and user setup). Then we’d start the server. This is where things would start
    to get more and more complicated. We would have a number of options for making
    this application available to the world. One option would be to open port `3000`
    to the world, and away we go. However, the Rails server should never be exposed
    directly to the outside world. We’ll see why that is in the next section, but
    for now, let’s just stick to that principle. We’ll need to set up Nginx as our
    web server and have it redirect calls to our Rails app. Once this was ready, we
    would be good to go.
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, this seems more complicated than the bundled option. With this
    simple example, there isn’t any easily discernable advantage to building it on
    our own, and that’s because it doesn’t really give us any advantage. At least,
    not for our specific case – firstly, because AWS will always be an expensive choice,
    and secondly, because it is an enterprise solution, and as such, as in most enterprise
    solutions, the configuration and deployment will be more complex, albeit resulting
    in many more choices for your application. While I wouldn’t recommend deploying
    our application in any DIY public cloud (AWS, Google Cloud, or Azure) to share
    it with the world, I would recommend you do this as an exercise as it will get
    you familiar with the operations of cloud solutions. Nowadays, familiarity with
    this type of technology is a must for developers.
  prefs: []
  type: TYPE_NORMAL
- en: While we don’t really need to go into the details of these solutions (at least
    not for now), I believe we do need to get a grasp of certain concepts regarding
    our application deployment. Deploying our application behind a web server (Nginx)
    is one of these concepts, which we will look at in more depth in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Why nginx?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Coming from a PHP background, one of the concepts that was difficult for me
    to grasp was Rails’ lack of the out-of-the-box server functionality seen in PHP.
    With PHP, if it is installed, you can open a shell and type the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: This will bring up an internal PHP server. You can now open a browser, point
    it to `http://localhost:9000/`, and that’s all you need to do. Any PHP scripts
    we add to the same folder where we started the PHP server will be available to
    said server. We don’t need any PHP framework to start programming in PHP. We can
    use this internal server for development and once we deploy our PHP application
    to a production server, our application just requires a web server that has PHP
    enabled. This is an oversimplification of how it’s actually done, but in essence,
    that’s all that’s needed for PHP servers.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the good ol’ days, Apache was the way to go. These days, you can still use
    Apache, but Nginx has gained a lot of ground here, to the point that Nginx is
    nowadays almost (if not) the standard. What is Nginx? Nginx (according to its
    website) is an advanced load balancer, web server, and reverse proxy designed
    to handle high-traffic websites and applications. It is widely used as a web server
    and has reportedly been adopted by Netflix and Airbnb, among others. With these
    names involved, we can safely assume its efficiency whilst handling web-related
    components is extremely high. Why should we use Nginx as a web server for Rails?
    The answer is delegation. A web server should handle things such as static assets
    (images, stylesheets, etc.), file uploads, SSL certificate display, and some DDoS
    protection, to name just a few. Rails (and many other web frameworks) are very
    capable of handling most of these tasks too, but why reinvent the wheel when we
    can have our Rails application only needing to worry about Rails tasks, and Nginx
    worrying about the web-related tasks? Additionally, Nginx is much faster and more
    efficient at handling these tasks than any web framework. As a matter of fact,
    our demo bundled hosting solution (DigitalOcean) comes with Nginx installed and
    configured to point to the example Rails application. I disabled the Rails upstream
    and set the Nginx page to the default, and this is what I got:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.3 – Nginx default page on DigitalOcean](img/B19230_10_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.3 – Nginx default page on DigitalOcean
  prefs: []
  type: TYPE_NORMAL
- en: 'The task of setting up the Nginx configuration is another reason why we should
    opt for the bundled solution – the DIY solution leaves the task of installing
    and configuring Nginx to us. While this is definitely not a complicated task,
    it does add yet another layer of work to the DIY solution. I realize this is a
    lot of information to take in when considering hosting options, but if you want
    to learn more about Nginx and related topics, please take a look at the following
    sites:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://www.nginx.com/](https://www.nginx.com/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://docs.nginx.com/nginx/admin-guide/installing-nginx/installing-nginx-open-source/](https://docs.nginx.com/nginx/admin-guide/installing-nginx/installing-nginx-open-source/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://unit.nginx.org/howto/rails/](https://unit.nginx.org/howto/rails/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Lastly, we need to bear in mind that Rails will behave differently when run
    locally than in a production environment, and that includes how we view errors
    on a server.
  prefs: []
  type: TYPE_NORMAL
- en: Error gossip and last words
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'So far, we’ve only used the Rails framework with most of the default options.
    These default options include some configurations that would otherwise hinder
    and slow down the overall experience for the end user. These options make sense
    in development, as they make debugging and testing really easy. As developers,
    we need to be able to set up our local environment as soon as possible and start
    programming away. However, these default options do not make sense in a production
    environment. One of these defaults concerns error reporting. We saw locally how
    errors are displayed, but in a real-life scenario, we would never want these errors
    to be shown in the same way. We would not want detailed error output stating paths,
    variables, or even what database we’re using, as this could be a security breach,
    or at least the beginning of one. We would want the error to be like gossip: quiet
    and behind our backs. And that’s exactly what we’re going to do. For this last
    exercise, we will need to load a Rails application as we’ve done in previous chapters.
    If you haven’t downloaded the source code for the course, open a terminal and
    type the following `git` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'If you’ve already done so, then just navigate into the `chapter10` folder within
    your project by running the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Again, let’s install our dependencies with the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'And to confirm our setup was done correctly, let’s run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'The output should read something like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'And now we are ready to run our Rails application in production. We do this
    by adding the `RAILS_ENV=production` environment variable before the Rails startup
    command. Let’s give it a try. In our shell, let’s type the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Once we run the preceding command, our application will run as usual, and our
    shell will look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'But now, if we go to our browser and navigate to `http://0.0.0.0:3000`, we
    are now greeted with this page:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.4 – Rails running in production mode](img/B19230_10_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.4 – Rails running in production mode
  prefs: []
  type: TYPE_NORMAL
- en: 'Granted, for development, this is a hassle, but trust me, you will be thankful
    when this page shows on your application deployed in production. As we are running
    our application in production mode, all errors are hidden. Now we need to look
    for the error in our logs. So far, we’ve neglected our log files, as the errors
    were always shown on the browser, but the logs have always been there. If we look
    at the `chapter10/hosting_original/log/` folder, we now have two files:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.5 – Rails log files](img/B19230_10_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.5 – Rails log files
  prefs: []
  type: TYPE_NORMAL
- en: 'Since we are running our application in production, let’s open the `production.log`
    file. If there is too much information in the log, we can delete the contents
    of the file, save the file, and then refresh the browser. Now we can look at the
    file again with less data. We should now see something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'We notice the `FATAL` keyword, which is what caused our error. The error states
    that we cannot find the `''users''` table. This is because we have not run the
    Rails migrations. So, let’s do that. Let’s stop our application by pressing *Ctrl
    + C*, and run the following command on our shell:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Don’t forget to prefix our command with the environment. The command should
    produce output detailing that the tables have been created:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Now let’s restart our Rails application by typing the following on the shell
    again:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, refresh the browser. It looks the same, with just an error page. Let’s
    delete the contents of our `production.log` file again and refresh our browser
    once more. Now when we look at the log file again, we see a different `FATAL`
    error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'I’ve removed the rest of the log for clarity, but the `FATAL` error is what
    gives us a clue as to the problem. In Rails, when executing our application in
    production, some assets need to be compiled or transpiled. In this case, it’s
    the CSS and JavaScript assets that need to be generated and minified. Fortunately,
    Rails has a command to do this task. To do that, we need to stop our application
    with *Ctrl + C* on the shell and then run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'This should output a series of messages stating that the assets have been generated:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'There are a lot of files that were generated, but we’re not going to get into
    details as to how the mechanism works. Let’s just say that the frontend assets
    were generated. Now let’s run our application once more with the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'And when we refresh the browser once more, we should see a familiar page:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.6 – Rails login page](img/B19230_10_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.6 – Rails login page
  prefs: []
  type: TYPE_NORMAL
- en: Congratulations, my dear readers! We are now running a Rails application in
    production mode. As you can see, it’s a lot more hassle to debug our application
    as the error messages are now hidden in logs. In a real production environment,
    we would have to look for where these logs were kept. Running Rails tasks (db,
    generators, assets, etc.) might also not prove to be so straightforward. You might
    have to tweak the commands, and in some cases, will not be allowed to run them
    at all. Either way, for now, this is the end of the road and I applaud you readers
    for sticking with me in this Ruby-on-Rails voyage.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We covered a lot of information in this chapter. We learned about the costs
    of hosting, the different options on the market, and whether it makes sense to
    opt for a bundled solution with everything configured for us, or a DIY option,
    which offers more flexibility but is also more complex and expensive. We also
    learned why we should deploy our applications behind Nginx. Finally, we learned
    how to debug an application in production mode.
  prefs: []
  type: TYPE_NORMAL
- en: We are now ready to use what we’ve learned in this book and add Ruby to our
    arsenal.
  prefs: []
  type: TYPE_NORMAL
