- en: Menus and Menu Links
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 菜单和菜单链接
- en: Navigation is an important part of any web application. The ability to create
    menus and links easily in order to connect pages together is a core aspect of
    any content management system. Drupal 8 is fully equipped with both the site-building
    capabilities and developer API to easily build and manipulate menus and links.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 导航是任何网络应用的重要组成部分。能够轻松创建菜单和链接以连接页面是任何内容管理系统的一个核心方面。Drupal 8 完全配备了网站构建能力和开发者 API，可以轻松构建和操作菜单和链接。
- en: 'In this chapter, we will discuss menus and menu links from a Drupal 8 module
    developer perspective. In doing so, we will touch upon a few key aspects:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将从 Drupal 8 模块开发者的角度讨论菜单和菜单链接。在这样做的时候，我们将涉及几个关键方面：
- en: The general architecture of the menu system in Drupal 8
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Drupal 8 中菜单系统的总体架构
- en: Manipulating and rendering menus
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 操作和渲染菜单
- en: Defining various types of menu links
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定义各种类型的菜单链接
- en: By the end of this chapter, you should be able to understand what menus and
    menu links are, how to use them in your code and how to define menu links in your
    module. So let's get started.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，你应该能够理解什么是菜单和菜单链接，如何在你的代码中使用它们，以及如何在你的模块中定义菜单链接。那么，让我们开始吧。
- en: The menu system
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 菜单系统
- en: Before we get our hands dirty with menus and menu links, let's talk a bit about
    the general architecture behind the menu system. To this end, I want to talk a
    bit about its main components, what some of its key players are and what classes
    you should be looking at. As always, no great developer has ever relied solely
    on a book or documentation to figure out complex systems.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们动手操作菜单和菜单链接之前，让我们简要谈谈菜单系统背后的总体架构。为此，我想谈谈其主要组件，一些关键参与者以及你应该查看的类。就像往常一样，没有一个伟大的开发者仅仅依靠书籍或文档来弄清楚复杂的系统。
- en: Menus
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 菜单
- en: 'Menus are configuration entities represented by the following class: `Drupal\system\Entity\Menu`.
    I mentioned in [Chapter 1](5c4ab442-1596-40ca-b305-d72b6c47ed59.xhtml), *Developing
    for Drupal 8*, that we have something called configuration entities in Drupal
    8, which we will explore in detail later in this book. However, for now, it''s
    enough to understand that menus can be created through the UI and become an exportable
    configuration. Additionally, this exported configuration can also be included
    inside a module so that it gets imported when the module is first installed. This
    way, a module can ship with its own menus. We will see how this latter aspect
    works when we talk about the different kinds of storage in Drupal 8\. For now,
    we will work with menus that come with Drupal 8 core.'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 菜单是由以下类表示的配置实体：`Drupal\system\Entity\Menu`。我在[第1章](5c4ab442-1596-40ca-b305-d72b6c47ed59.xhtml)，*为
    Drupal 8 开发*中提到，Drupal 8 中有一种称为配置实体，我们将在本书的后面部分详细探讨。然而，目前来说，理解菜单可以通过 UI 创建并成为可导出的配置就足够了。此外，这个导出的配置也可以包含在一个模块中，以便在模块首次安装时导入。这样，一个模块可以附带自己的菜单。当我们谈到
    Drupal 8 中不同类型的存储时，我们将看到这个后者的工作方式。现在，我们将使用与 Drupal 8 核心一起提供的菜单进行工作。
- en: Each menu can have multiple menu links, structured hierarchically in a tree
    with a maximum depth of `9`. The ordering of the menu links can be done easily
    through the UI or via the weighting of the menu links, if defined in code.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 每个菜单可以有多个菜单链接，这些链接以树状结构组织，最大深度为 `9`。菜单链接的顺序可以通过 UI 或通过在代码中定义的菜单链接权重轻松完成。
- en: Menu links
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 菜单链接
- en: At their most basic level, menu links are YAML-based plugins (like the Layout
    plugins we saw in the previous chapter). To this end, regular menu links are defined
    inside a `module_name.links.menu.yml` file and can be altered by other modules
    by implementing `hook_menu_links_discovered_alter()`. When I say regular, I mean
    those links that go into menus. We will see shortly that there are also a few
    other types.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在最基本层面上，菜单链接是基于 YAML 的插件（就像我们在上一章中看到的布局插件）。为此，常规菜单链接在`module_name.links.menu.yml`文件中定义，并且可以通过实现`hook_menu_links_discovered_alter()`由其他模块进行修改。当我提到常规时，我指的是那些进入菜单的链接。我们很快就会看到还有一些其他类型。
- en: 'There are a number of important classes you should check out in this architecture
    though: `MenuLinkManager` (the plugin manager) and `MenuLinkBase` (menu link plugins
    base class and which implements `MenuLinkInterface`).'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管在这个架构中有很多重要的类你应该检查：`MenuLinkManager`（插件管理器）和`MenuLinkBase`（菜单链接插件基类，并实现了`MenuLinkInterface`）。
- en: Menu links can, however, also be content entities. The links created via the
    UI are stored as entities because they are considered content. The way this works
    is that for each created `MenuLinkContent` entity, a plugin derivative is created.
    We are getting dangerously close to advanced topics that are too early to cover.
    But in a nutshell, via these derivatives, it's as if a new menu link plugin is
    created for each `MenuLinkContent` entity, making the latter behave as any other
    menu link plugin. This is a very powerful system specific to Drupal 8.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 菜单链接也可以是内容实体。通过UI创建的链接被存储为实体，因为它们被视为内容。其工作原理是，对于每个创建的`MenuLinkContent`实体，都会创建一个插件派生版本。我们正越来越接近高级主题，而这些主题可能还太早讨论。但简而言之，通过这些派生版本，对于每个`MenuLinkContent`实体，就好像创建了一个新的菜单链接插件，使后者表现得像任何其他菜单链接插件。这是一个非常强大的、特定于Drupal
    8的系统。
- en: Menu links have a number of properties, among which a path or route. When created
    via the UI, the path can be external or internal or can reference an existing
    resource. When created programmatically, you'll typically use a route.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 菜单链接有许多属性，其中之一是路径或路由。当通过UI创建时，路径可以是外部或内部，也可以引用现有资源。当通过编程创建时，你通常会使用一个路由。
- en: Multiple types of menu links
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 多种类型的菜单链接
- en: The menu links we've been talking about so far are the links that show up in
    menus. There are also a few different kinds of links that show up elsewhere but
    are still considered menu links and work similarly.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前讨论的菜单链接是显示在菜单中的链接。还有一些不同类型的链接出现在其他地方，但仍然被视为菜单链接，并且工作方式类似。
- en: Local tasks
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 本地任务
- en: 'Local tasks, otherwise known as tabs, are grouped links that usually show up
    above the main content of a page (depending on the region where the tabs block
    is placed). They are usually used to group together related links that have to
    deal with the current page. For example, on an entity page, such as the Node detail
    page, you can have two tabs—one for viewing the Node and one for editing it (and
    maybe one for deleting it); in other words, local tasks:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 本地任务，也称为标签页，是一组链接，通常显示在页面主要内容上方（取决于标签块放置的区域）。它们通常用于将处理当前页面的相关链接分组在一起。例如，在一个实体页面上，如节点详情页，你可以有两个标签页——一个用于查看节点，一个用于编辑它（也许还有一个用于删除它）；换句话说，本地任务：
- en: '![](img/3e6a626e-a51f-480f-9ede-0434a00c9901.png)'
  id: totrans-21
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/3e6a626e-a51f-480f-9ede-0434a00c9901.png)'
- en: Local tasks take access rules into account, so if the current user does not
    have access to the route of a given tab, the link is not rendered. Moreover, if
    that means only one link in the set remains accessible, that link doesn't get
    rendered as there is no point. So, for tabs, a minimum of two links are needed
    for them to show up.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 本地任务会考虑访问规则，因此如果当前用户没有访问给定标签页的路由权限，则不会渲染该链接。此外，如果这意味着集合中只剩下一个链接可访问，那么该链接也不会被渲染，因为没有意义。所以，对于标签页，至少需要两个链接才能显示出来。
- en: Modules can define local task links inside a `module_name.links.task.yml` file,
    whereas other modules can alter them by implementing `hook_menu_local_tasks_alter()`.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 模块可以在`module_name.links.task.yml`文件中定义本地任务链接，而其他模块可以通过实现`hook_menu_local_tasks_alter()`来修改它们。
- en: Local actions
  id: totrans-24
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 本地操作
- en: Local actions are links that relate to a given route and are typically used
    for operations. For example, on a **list** page, you might have a local action
    link to create a new list item, which will take you to the relevant form page.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 本地操作是与给定路由相关的链接，通常用于操作。例如，在一个**列表**页面上，你可能有一个用于创建新列表项的本地操作链接，这将带你到相关的表单页面。
- en: 'In the following screenshot, we can see a local action link used to create
    a new user on the main user management page:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下屏幕截图中，我们可以看到一个用于在主要用户管理页面上创建新用户的本地操作链接：
- en: '![](img/71204c74-d253-4143-adfb-536da804adcf.png)'
  id: totrans-27
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/71204c74-d253-4143-adfb-536da804adcf.png)'
- en: Modules can define local action links inside a `module_name.links.action.yml`
    file, whereas other modules can alter them by implementing `hook_menu_local_actions_alter()`.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 模块可以在`module_name.links.action.yml`文件中定义本地操作链接，而其他模块可以通过实现`hook_menu_local_actions_alter()`来修改它们。
- en: Contextual links
  id: totrans-29
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 上下文链接
- en: 'Contextual links are used by the Contextual module to provide handy links next
    to a given component (a render array). You probably encountered this when hovering
    over a block, for example, and getting that little icon with a dropdown that has
    the Configure block link:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 上下文链接由上下文模块用于在给定组件（一个渲染数组）旁边提供便捷的链接。你可能遇到过这种情况，比如在悬停于一个块上时，会看到一个带有下拉菜单的小图标，其中包含配置块的链接：
- en: '![](img/1ae8da6d-16a2-4c5f-82e1-290b9fd6f1cf.png)'
  id: totrans-31
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/1ae8da6d-16a2-4c5f-82e1-290b9fd6f1cf.png)'
- en: Contextual links are tied to render arrays. In fact, any render array can show
    a group of contextual links that have previously been defined.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 上下文链接与渲染数组相关联。实际上，任何渲染数组都可以显示之前定义的一组上下文链接。
- en: Modules can define contextual links inside a `module_name.links.contextual.yml`
    file, whereas other modules can alter them by implementing `hook_contextual_links_alter()`.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 模块可以在`module_name.links.contextual.yml`文件中定义上下文链接，而其他模块可以通过实现`hook_contextual_links_alter()`来修改它们。
- en: MenuLink trees
  id: totrans-34
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 菜单链接树
- en: As I mentioned in the section about menus, menu links are stored hierarchically
    inside a menu. This hierarchy is represented via a menu link tree. There are a
    number of key players here we should go over.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我在关于菜单的部分提到的，菜单链接是按层次存储在菜单中的。这个层次结构通过菜单链接树来表示。这里有几个关键角色我们需要了解。
- en: We have the `MenuLinkTree` service, which is the interface used to load and
    prepare the tree of a certain menu. The loading is deferred to the `MenuTreeStorage`
    service, which does so on the basis of a `MenuTreeParameters` object that contains
    metadata on certain restrictions to be applied on the menu links that are loaded.
    We will see some examples of this a bit later.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有`MenuLinkTree`服务，它是用来加载和准备某个菜单树界面的接口。加载操作被延迟到`MenuTreeStorage`服务，该服务基于一个包含对加载的菜单链接应用某些限制的元数据的`MenuTreeParameters`对象来执行。我们稍后会看到一些这方面的例子。
- en: What comes out of the `MenuLinkTree` service is an array of `MenuLinkTreeElement`
    objects. These are essentially value objects that wrap the `MenuLinkInterface`
    plugins and that provide some extra data about their placement in the tree they
    are loaded in. One such important piece of information is the subtree (the array
    of `MenuLinkTreeElement` objects that are below it).
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: '`MenuLinkTree`服务输出的是一个`MenuLinkTreeElement`对象的数组。这些实际上是封装了`MenuLinkInterface`插件的值对象，并提供了一些关于它们在加载的树中的位置额外数据。其中一条重要信息是子树（位于其下的`MenuLinkTreeElement`对象的数组）。'
- en: Menu link tree manipulators
  id: totrans-38
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 菜单链接树操作符
- en: When loading a menu link tree, you get the entire tree that fits the specified
    parameters. However, when using that tree, you probably want to perform some checks
    and remove certain items. A common example is to remove the menu links to which
    the user doesn't have access. This is where manipulators come into place.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 当加载菜单链接树时，你会得到符合指定参数的整个树。然而，当使用该树时，你可能想要执行一些检查并删除某些项目。一个常见的例子是删除用户无权访问的菜单链接。这就是操作符发挥作用的地方。
- en: The `MenuLinkTree` service has a `transform()` method, which alters a tree based
    on an array of manipulators. The latter take the form of callables, typically
    service names with specific methods. So, the actual manipulators are services
    that traverse the tree and make alterations to the tree items, their order, and
    so on.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: '`MenuLinkTree`服务有一个`transform()`方法，它根据一个操作符数组来改变树。后者以可调用对象的形式出现，通常是具有特定方法的服务名称。因此，实际的操作符是遍历树并对树项、它们的顺序等进行修改的服务。'
- en: Menu active trail
  id: totrans-41
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 菜单活动路径
- en: A menu trail is a list (array) of menu link plugins that are parents of a menu
    link. For the active trail, that specific menu link represents the current route
    (if there is a menu link for that route).
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 菜单路径是一个菜单链接插件列表（数组），这些插件是菜单链接的父级。对于活动路径，特定的菜单链接代表当前路由（如果存在该路由的菜单链接）。
- en: 'The Drupal 8 menu system also has a service that can be used to determine the
    active trail of the current route if used by a menu link. By passing a menu name
    to look inside of, the `MenuActiveTrail` service returns an array of plugin IDs
    of the parents all the way up to the menu root, if the current route is in fact
    an active link. There is also a method that can be used to check that: `getActiveLink()`.'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: Drupal 8的菜单系统还有一个服务，可以用来确定当前路由的活动路径，如果使用菜单链接的话。通过传递一个要查找的菜单名称，`MenuActiveTrail`服务返回一个包含所有父级插件ID的数组，直到菜单根，如果当前路由确实是一个活动链接。还有一个方法可以用来检查这一点：`getActiveLink()`。
- en: Rendering menus
  id: totrans-44
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 渲染菜单
- en: Now that we have covered some theory about the menu system, it's time to get
    our hands dirty with some code. The first thing we will look at is how to work
    with menus programmatically with the view of rendering them in our module. For
    this, we will work with the default **Administration** menu that comes with Drupal
    core and has many links in it, at various levels. Note that the code we write
    in this section will not be included in the code repository.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经介绍了一些关于菜单系统的理论，是时候动手写一些代码了。我们将首先查看如何以在模块中渲染菜单的方式程序化地处理菜单。为此，我们将使用 Drupal
    核心中默认的 **管理** 菜单，它包含许多链接，位于不同的级别。请注意，本节中编写的代码将不会包含在代码库中。
- en: Drupal core provides a block, called `SystemMenuBlock`, which can be used to
    render any menu inside a block. However, let's take a look at how we can do this
    ourselves instead.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: Drupal 核心提供了一个名为 `SystemMenuBlock` 的块，可以用来在块中渲染任何菜单。然而，让我们看看我们如何自己来做这件事。
- en: 'The first thing we will need to do is get the `MenuLinkTree` service. We can
    inject it, or, if that''s not possible, get it statically via the helper `\Drupal`
    class:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要做的第一件事是获取 `MenuLinkTree` 服务。我们可以注入它，或者，如果不可能，可以通过辅助 `\Drupal` 类静态地获取它：
- en: '[PRE0]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Next, we will need to create a `MenuTreeParameters` object so that we can use
    it to load our menu tree. There are two ways we can do this. We can either create
    it ourselves and set our own options on it or we can get a default one based on
    the current route:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要创建一个 `MenuTreeParameters` 对象，以便我们可以使用它来加载我们的菜单树。我们可以以两种方式做到这一点。我们可以自己创建它并设置自己的选项，或者我们可以基于当前路由获取一个默认值：
- en: '[PRE1]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Providing the name of a menu (in our case, "admin"), this method gives us a
    `MenuTreeParameters` instance with the following options set on it:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 提供菜单的名称（在我们的情况下，是“admin”），这个方法给我们一个设置了以下选项的 `MenuTreeParameters` 实例：
- en: The links in the active trail of the current route are marked as expanded, that
    is, they will show up in the resulting tree that we load.
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当前路由活动路径中的链接被标记为展开，即它们将显示在我们加载的结果树中。
- en: The children of the links in the active trail that have the "expanded" property
    set are also included in the resulting tree.
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 活动路径中具有“展开”属性的链接的子链接也包括在结果树中。
- en: Essentially, this set of parameters gives us a tree within the context of the
    current route we are on. In other words, it will load all the root links in the
    menu and all the children of the root link that are in the active trail of the
    current route. It will leave out the children of the other root links.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，这组参数给我们提供了一个在当前路由上下文中的树。换句话说，它将加载菜单中的所有根链接以及当前路由活动路径中的根链接的子链接。它将省略其他根链接的子链接。
- en: 'You can, of course, further customize this set of parameters or create one
    from scratch. For example, if we want to load only the tree of a root link inside
    a menu, we could do it as follows:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 你当然可以进一步自定义这组参数或从头开始创建一个。例如，如果我们只想加载菜单中根链接的树，我们可以这样做：
- en: '[PRE2]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: In this example, `$plugin_id` is the ID of the menu link that should be at the
    root of the tree (defined in the YAML file or derived through a derivative).
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，`$plugin_id` 是应该位于树根处的菜单链接的 ID（在 YAML 文件中定义或通过派生得到）。
- en: I encourage you to look inside the `MenuTreeParameters` class and explore the
    other options you have for loading a tree.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 我鼓励你查看 `MenuTreeParameters` 类，并探索你用于加载树的其他选项。
- en: 'For our example, we want to work with the entire menu tree of the Administration
    menu, so just instantiating a new `MenuTreeParameters` object will be enough,
    as we want to load all links in the menu. We can do this as follows:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的示例，我们想要处理整个“管理”菜单的整个菜单树，因此只需实例化一个新的 `MenuTreeParameters` 对象就足够了，因为我们想要加载菜单中的所有链接。我们可以这样做：
- en: '[PRE3]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Now, we have an array of `MenuLinkTreeElement` objects inside the `$tree` variable,
    which contain, among others, the following:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们在 `$tree` 变量中有一个 `MenuLinkTreeElement` 对象的数组，其中包含，但不仅限于以下内容：
- en: The link property, which is the menu link plugin
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 链接属性，即菜单链接插件
- en: The subtree property, which is an array of `MenuLinkTreeElement` objects going
    down the tree
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 子树属性，它是一个包含 `MenuLinkTreeElement` 对象的数组，沿着树向下延伸
- en: Various metadata about the link within the tree (depth, whether in the active
    trail, whether it has children, access, and so on)
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 树中链接的各种元数据（深度、是否在活动路径中、是否有子链接、访问权限等）
- en: However, it is important to note that notwithstanding any `MenuTreeParameters`
    we may have had, we are now sitting on top of all menu links in that menu, regardless
    of any access check. It is our responsibility to make sure that we don't render
    links to pages the user has no access to (as they will get a 403 error when they
    get there). To do this, we use the manipulators we discussed earlier, which are
    simple methods on a service.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，重要的是要注意，尽管我们可能有一些`MenuTreeParameters`，但我们现在位于该菜单的所有菜单链接的顶部，无论任何访问检查。确保我们不会渲染用户无权访问的链接是我们的责任（因为他们到达那里时会收到403错误）。为此，我们使用之前讨论过的操作器，这些操作器是服务上的简单方法。
- en: 'The Drupal 8 menu system comes with a few default manipulators that can be
    found inside the `DefaultMenuLinkTreeManipulators` service. Most of the time,
    they will be sufficient for you:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: Drupal 8的菜单系统自带了一些默认操作器，可以在`DefaultMenuLinkTreeManipulators`服务中找到。大多数情况下，它们将对你足够用：
- en: 'Access (handled by the `checkAccess()` method): Checks whether the user has
    access to the links in the tree. If they don''t, the link becomes an instance
    of `InaccessibleMenuLink` and any links in its subtree are cleared out.'
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 访问（由`checkAccess()`方法处理）：检查用户是否有访问树中链接的权限。如果没有，链接将变成`InaccessibleMenuLink`的一个实例，并且其子树中的任何链接都将被清除。
- en: 'Node Access (handled by the `checkNodeAccess()` method): Checks whether the
    user has access to the Node entity linked to by the menu link. If you know that
    the menu has links to Nodes, you can use this before the regular access check
    because it''s a bit more performant.'
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 节点访问（由`checkNodeAccess()`方法处理）：检查用户是否有访问由菜单链接链接的节点实体的权限。如果你知道菜单有链接到节点，你可以在常规访问检查之前使用这个方法，因为它性能更好。
- en: 'Index and Sort (handled by the `generateIndexAndSort()` method): Creates unique
    indexes in the tree and sorts it by them.'
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 索引和排序（由`generateIndexAndSort()`方法处理）：在树中创建唯一的索引并按它们排序。
- en: 'Flatten (handled by the `flatten()` method): Flattens the menu tree to one
    level.'
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 扁平化（由`flatten()`方法处理）：将菜单树扁平化到一级。
- en: 'If these are not enough, you can add your own manipulators as needed. All you
    have to do is define a service that has a public method and then reference it
    when transforming the tree. However, speaking of transforming, let''s go ahead
    and use the access check manipulator to ensure that the current user has access
    to our tree links:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 如果这些还不够，你可以根据需要添加自己的操作器。你所要做的就是定义一个具有公共方法的服务，然后在转换树时引用它。然而，说到转换，让我们继续使用访问检查操作器来确保当前用户可以访问我们的树形链接：
- en: '[PRE4]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: As I mentioned earlier, we use the `transform()` method on the service and pass
    an array of callables. The latter are nothing more than the service name, followed
    by `:` and the method name to be used (like shown in the code above). So if you
    create your own service, you can reference it the same way.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 如我之前提到的，我们在服务上使用`transform()`方法，并传递一个可调用对象的数组。后者不过是服务名称，后面跟着`:`和要使用的方法名称（如上面代码所示）。因此，如果你创建了自己的服务，你可以用同样的方式引用它。
- en: Now, each `MenuLinkTreeElement` that remains in the tree has its `access` property
    filled with an instance of `AccessResultInterface` (a system of denoting access
    that we will talk more about in a later chapter). If the link is not accessible,
    it becomes an instance of `InaccessibleMenuLink`, so we know that we cannot render
    it, and even if we did render it, it will go to the home page rather than the
    403.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，树中剩余的每个`MenuLinkTreeElement`都具有其`access`属性填充了`AccessResultInterface`的一个实例（这是我们将在稍后章节中更多讨论的访问表示系统）。如果链接不可访问，它将变成`InaccessibleMenuLink`的一个实例，因此我们知道我们无法渲染它，即使我们渲染了它，它也会跳转到主页而不是403。
- en: 'Now, to render the tree, all we have to do is turn this tree into a render
    array:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，为了渲染树形结构，我们只需将这个树形结构转换成一个渲染数组：
- en: '[PRE5]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Inside `$menu`, we now have a render array that uses the `menu` theme hook with
    a theme hook suggestion based on the menu name. So, in our case, it is `menu__admin`.
    Remember what these are from the previous chapter?
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 在`$menu`中，我们现在有一个使用`menu`主题钩子的渲染数组，其主题钩子建议基于菜单名称。在我们的例子中，它是`menu__admin`。记得这些是从上一章学到的吗？
- en: The `menu` theme hook will use the `menu.html.twig` (or `menu--admin.html.twig`
    if it exists inside a theme) file to render the menu links inside a simple, albeit
    hierarchical, HTML list.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '`menu`主题钩子将使用`menu.html.twig`（或如果它位于主题中，则为`menu--admin.html.twig`）文件来渲染简单的、尽管是分层结构的HTML列表中的菜单链接。'
- en: 'As a quick recap from the theming chapter, at this point you have a few options
    for gaining full control over the output of the menu:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 作为对主题章节的快速回顾，到现在为止，你有几个选项可以完全控制菜单的输出：
- en: Creating a new theme hook and mimicking what the `build()` method does to build
    the render array
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个新的主题钩子并模仿 `build()` 方法来构建渲染数组
- en: Altering the theme registry to switch out the template with your own
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 修改主题注册表以替换模板
- en: Overriding the template inside a theme
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在主题内部覆盖模板
- en: Implementing a preprocessor for the theme hook and altering variables there
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现主题钩子的预处理器并更改那里的变量
- en: So, as you can see, you have many options. The choice you make depends on what
    you need to achieve, how happy you are with what the default markup is, and so
    on.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，正如你所见，你有许多选项。你的选择取决于你需要实现什么，你对默认标记的满意度如何，等等。
- en: Working with menu links
  id: totrans-85
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 与菜单链接一起工作
- en: Now that we know how to load and manipulate trees of menu links, let's talk
    a bit more about the regular menu links. In this section, we will look at how
    our module can define menu links and how we can work with them programmatically
    once we get our hands on them from a tree or somewhere else.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们知道了如何加载和操作菜单链接树，让我们再谈谈常规的菜单链接。在本节中，我们将探讨我们的模块如何定义菜单链接，以及一旦我们从树或其他地方获取它们后，我们如何以编程方式与它们一起工作。
- en: Defining menu links
  id: totrans-87
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 定义菜单链接
- en: In our *Hello World* module we defined a couple of routes, one of which mapping
    to the `/hello` path. Let's now create a link to that path which goes inside the
    main menu that is shipped with Drupal core.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的 *Hello World* 模块中，我们定义了一些路由，其中之一映射到 `/hello` 路径。现在让我们创建一个链接到该路径，该链接位于与
    Drupal 核心一起提供的菜单中。
- en: 'As I mentioned, menu links are defined inside a `*.links.menu.yml` file. So,
    let''s create that file for our module and add our menu link definition in it:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我提到的，菜单链接是在 `*.links.menu.yml` 文件中定义的。所以，让我们为我们的模块创建该文件，并在其中添加我们的菜单链接定义：
- en: '[PRE6]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'In a typical YAML notation, we have the machine name (in this case, also the
    plugin ID) `hello_world.hello`, followed by the relevant information below it.
    These are the most common things you will define for a menu link:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 在典型的 YAML 表示法中，我们有机器名（在这种情况下，也是插件 ID）`hello_world.hello`，然后是其下面的相关信息。这些是你为菜单链接定义的最常见内容：
- en: The `title` is the menu link title whereas the `description` is, by default,
    set as the `title` attribute on the resulting link tag.
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`title` 是菜单链接的标题，而 `description` 默认设置为结果链接标签的 `title` 属性。'
- en: The `route_name` indicates the route to be used behind this link.
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`route_name` 指示此链接背后的路由。'
- en: The `menu_name` indicates the menu that it should be in; this is the machine
    name of the menu.
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`menu_name` 指示该菜单应位于其中；这是菜单的机器名。'
- en: The `weight` can be used to order links within the menu.
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`weight` 可以用来对菜单中的链接进行排序。'
- en: An additional common property is `parent` that can be used to indicate another
    menu link the current one should be a child of. As such, you can build the hierarchy.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个常见的属性是 `parent`，它可以用来指示另一个菜单链接，当前链接应该是其子链接。因此，你可以构建层次结构。
- en: Once this is in, you should clear the cache and check out the links in the menu.
    You'll note that you can edit it, but some things cannot be changed through the
    UI due to them being defined in code.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦设置好，你应该清除缓存并检查菜单中的链接。你会注意到你可以编辑它，但由于它们在代码中定义，因此一些内容无法通过 UI 进行更改。
- en: 'Note that links that are created as a result of plugin derivatives, such as
    the ones created in the UI, have machine names (plugin IDs) in the following format:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，由插件衍生创建的链接，例如在 UI 中创建的链接，具有以下格式的机器名（插件 ID）：
- en: '[PRE7]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The `main_plugin_id` is the ID of the menu link plugin that is responsible
    for deriving multiple links, whereas the `plugin_derivative_id` is the ID given
    to each individual derivative. For example, in the case of `MenuLinkContent` entities,
    the format is like this:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '`main_plugin_id` 是负责派生多个链接的菜单链接插件的 ID，而 `plugin_derivative_id` 是分配给每个单独的衍生品的
    ID。例如，在 `MenuLinkContent` 实体的情况下，格式如下：'
- en: '[PRE8]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The UUID in the previous code is actually the UUID of the menu link content
    entity, which happens to be the plugin derivative ID.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 之前代码中的 UUID 实际上是菜单链接内容实体的 UUID，碰巧也是插件衍生 ID。
- en: Working with menu links
  id: totrans-103
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 与菜单链接一起工作
- en: I mentioned earlier that `MenuLinkTreeElement` objects wrap individual menu
    links, but what can you do with these programmatically if you choose to work with
    this data yourself and not rely on the `menu` theme hook? Let's cover a few common
    things you can do.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 我之前提到 `MenuLinkTreeElement` 对象封装了单个菜单链接，但如果你选择自己处理这些数据而不是依赖于 `menu` 主题钩子，你可以对这些对象进行哪些编程操作呢？让我们了解一下你可以做的几个常见操作。
- en: 'First of all, the most important thing to do is to access the menu link plugin.
    You can do so directly, as it is a public property on the `MenuLinkTreeElement`:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，最重要的事情是访问菜单链接插件。你可以直接这样做，因为它是 `MenuLinkTreeElement` 的公共属性：
- en: '[PRE9]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Now, you can work with the `$link` variable, which is an instance of `MenuLinkInterface`,
    and more often than not, an actual `MenuLinkDefault` instance that extends the
    `MenuLinkBase` class.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你可以使用 `$link` 变量，它是一个 `MenuLinkInterface` 的实例，而且通常是一个扩展了 `MenuLinkBase` 类的
    `MenuLinkDefault` 实例。
- en: So if we inspect that interface, we can see a number of handy methods. The most
    common of these will be the getters for the menu link definition we saw earlier
    when defining the plugins. The `getUrlObject()` is also an important method that
    transforms the route of the menu link into a `Url` object that we already know
    how to use. If the menu link is created in the UI, it could be that it has no
    route but only a path, in which case, this method will still be able to construct
    a common `Url` object based on that path.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，如果我们检查该接口，我们可以看到许多方便的方法。其中最常见的是我们之前在定义插件时看到的菜单链接定义的获取器。`getUrlObject()` 也是一个重要的方法，它将菜单链接的路径转换为我们已经知道如何使用的
    `Url` 对象。如果菜单链接是在 UI 中创建的，它可能没有路由，只有路径，在这种情况下，此方法仍然可以根据该路径构建一个通用的 `Url` 对象。
- en: 'If you have your hands on a menu link that is not from a tree where you have
    already handled access, you can ask the `Url` object to check access before actually
    using it:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你有一个不是来自你已经处理过访问的树的菜单链接，你可以在实际使用之前要求 `Url` 对象检查访问权限：
- en: '[PRE10]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: If the link is not routed, the access will always return `TRUE` because it means
    that the link is external, or, in any case, no access check can be done. We will
    talk more about the access system in a separate chapter.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 如果链接没有路由，访问将始终返回 `TRUE`，因为这表示链接是外部的，或者在任何情况下都无法进行访问检查。我们将在单独的章节中详细讨论访问系统。
- en: Defining local tasks
  id: totrans-112
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 定义本地任务
- en: Let's now take a look at an example of how we can define local task links by
    heading back to our *Hello World* module. On the `/hello` page, let's add two
    local tasks—one for the regular `/hello` page, and the other for the configuration
    form where the salutation can be changed. This is a good example of using local
    tasks (tabs), as the configuration form is strictly related to what is on the
    page and is used to make changes to it.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们通过回到我们的 *Hello World* 模块来查看如何定义本地任务链接的示例。在 `/hello` 页面上，让我们添加两个本地任务——一个用于常规的
    `/hello` 页面，另一个用于可以更改问候语的配置表单。这是一个使用本地任务（标签页）的好例子，因为配置表单严格相关于页面上的内容，并用于对其进行更改。
- en: 'As I mentioned, local tasks go inside a `*.links.task.yml` file. So, let''s
    create one for our module with two links in it:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我提到的，本地任务位于 `*.links.task.yml` 文件中。所以，让我们为我们的模块创建一个包含两个链接的文件：
- en: '[PRE11]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: As usual, the topmost lines are the machine name (plugin IDs) of the links and
    we have the definitions under them. We have a `route_name` property again to specify
    what route these links should go to, a `title` for the link title, and a `base_route`.
    The latter is the route the local task should show up on. As you can see, both
    our links will show up on the `/hello` page. The `weight` property can be used
    to order the tabs.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 如常，最上面的行是链接的机器名（插件 ID），我们下面有它们的定义。我们再次有一个 `route_name` 属性来指定这些链接应该去的路由，一个 `title`
    属性用于链接标题，以及一个 `base_route`。后者是本地任务应该显示的路由。正如你所看到的，我们的两个链接都将显示在 `/hello` 页面上。`weight`
    属性可以用来对标签页进行排序。
- en: 'If you clear the cache and go to that page (as a user who has access to both
    routes), you''ll be able to see the following two tabs:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你清除缓存并访问那个页面（作为一个可以访问这两个路由的用户），你将能够看到以下两个标签页：
- en: '![](img/d7bc1c29-2acc-45c3-8f71-6e4eed51b12f.png)'
  id: totrans-118
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/d7bc1c29-2acc-45c3-8f71-6e4eed51b12f.png)'
- en: If you visit as an anonymous user, neither will show up for the reason I mentioned
    earlier.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你以匿名用户身份访问，前面提到的原因会导致它们都不会显示。
- en: Defining local actions
  id: totrans-120
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 定义本地操作
- en: Nothing about our Hello World module calls for defining a local action link.
    So instead of doing that, let's check out one that actually makes sense. If you
    navigate to the `admin/content` screen, you'll see the `+ Add content` button.
    It looks exactly the same as the example we saw earlier on the user management
    page. That is a local action link for this route. The `+` styling indicates that
    these links are primarily used to add or create new items relevant to the current
    route.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在Hello World模块中没有必要定义一个局部操作链接。所以，我们不妨看看一个真正有意义的例子。如果你导航到`admin/content`屏幕，你会看到`+
    Add content`按钮。它看起来和我们在用户管理页面上看到的例子完全一样。这是一个针对这个路由的局部操作链接。`+`样式表示这些链接主要用于添加或创建与当前路由相关的新项目。
- en: 'This particular local action link is defined in the `node` module inside the
    `node.links.action.yml` file, and it looks like this:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 这个特定的局部操作链接定义在`node`模块内部的`node.links.action.yml`文件中，其外观如下：
- en: '[PRE12]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Again, we have the machine name (plugin ID) and the definition. I hope that
    `route_name` and `title` are, by now, clear to you. A new thing here, though,
    is the `appears_on` key that is used to indicate the routes (plural) on which
    this action link should show up. So, a key feature is that one action link can
    exist on multiple pages.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，我们有机器名（插件ID）和定义。希望到现在为止，`route_name`和`title`对你来说已经很清晰了。不过，这里有一个新东西，那就是`appears_on`键，它用来指示这个操作链接应该显示在哪些路由（复数）上。所以，一个关键特性是，一个操作链接可以存在于多个页面上。
- en: Defining contextual links
  id: totrans-125
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 定义上下文链接
- en: Contextual links are a bit more complicated than the other types of links we've
    seen before, but nothing is too challenging for us. Let's take a look at how we
    can add contextual links to our salutation component so that users can navigate
    to the configuration form via a contextual link.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 上下文链接比我们之前看到的链接类型要复杂一些，但对我们来说，没有什么太具挑战性的。让我们看看如何将上下文链接添加到我们的问候组件中，以便用户可以通过上下文链接导航到配置表单。
- en: 'First, we will need to create the `.links.contextual.yml` file and define the
    link:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要创建`.links.contextual.yml`文件并定义链接：
- en: '[PRE13]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Nothing too complicated here. Again, we have a `title` link and a `route_name`.
    Additionally, we have a `group` key, which indicates the group name that this
    link will be a part of. We will reference this later.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 这里没有太多复杂的东西。再次强调，我们有一个`title`链接和一个`route_name`。此外，我们还有一个`group`键，它表示这个链接将属于哪个组名。我们稍后会引用这个键。
- en: 'Next, we will need to alter our theme hook template file because the contextual
    links are printed in a `title_suffix` variable that is available in all theme
    hooks and is used by various modules to add miscellaneous data to templates. The
    Contextual module is one such example. So, we will need to get that printed. This
    is what it will look like now:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要修改我们的主题钩子模板文件，因为上下文链接是在所有主题钩子中可用的`title_suffix`变量中打印的，并且被各种模块用来向模板添加杂项数据。上下文模块就是这样一个例子。因此，我们需要打印出这个内容。现在它看起来是这样的：
- en: '[PRE14]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: You'll note that we included the `title_prefix` variable to keep things nice
    and consistent. Usually, these will be empty, so no need to worry.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 你会注意到我们包括了`title_prefix`变量来保持事情的一致性。通常，这些变量会是空的，所以无需担心。
- en: Finally, comes the more complex part—one that may even change in the future,
    but, for now, this is how we have to proceed.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，是更复杂的一部分——这部分可能会在未来发生变化，但就目前而言，这是我们必须要走的步骤。
- en: Our `hello_world_salutation` theme hook defines individual variables rather
    than a render element. In such cases, inside a general preprocessor, the Contextual
    module looks at the first defined variable to check whether there are any contextual
    links defined. In the case of theme hooks that use render elements, it checks
    that element instead.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的`hello_world_salutation`主题钩子定义的是单个变量，而不是渲染元素。在这种情况下，在通用预处理器中，上下文模块会查看第一个定义的变量，以检查是否有定义上下文链接。对于使用渲染元素的主题钩子，它会检查那个元素。
- en: 'This is what the contextual links definition looks like inside a render array
    and also what we need to add for our use case:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是上下文链接定义在渲染数组中的样子，也是我们需要为我们的用例添加的内容：
- en: '[PRE15]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Here, we defined that the `hello_world` group of contextual links should be
    rendered here. Also, we specified an array of route parameters, which, in our
    case, is empty. This is because, typically, the contextual links are just that—contextual,
    meaning that they usually work with an entity or something that has an ID, and
    its route requires a parameter. So, here is where we can supply that because as
    we've seen, the `*.links.contextual.yml` definition is static and generic.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们定义了`hello_world`组上下文链接应该在这里渲染。我们还指定了一个路由参数数组，在我们的情况下，它是空的。这是因为，通常，上下文链接就是这样的——上下文相关的，意味着它们通常与一个实体或具有ID的东西一起工作，并且其路由需要一个参数。因此，这就是我们可以提供的地方，因为我们已经看到，`*.links.contextual.yml`定义是静态和通用的。
- en: The `#contextual_links` property is, in fact, a render element itself that gets
    replaced with another render element (`contextual_links_placeholder`). The latter
    outputs a simple text placeholder in the HTML, which gets replaced with the correct links
    via JavaScript.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: '`#contextual_links`属性实际上是一个渲染元素，它会被另一个渲染元素（`contextual_links_placeholder`）替换。后者在HTML中输出一个简单的文本占位符，它会被JavaScript替换为正确的链接。'
- en: 'So, now that we know how to make use of the contextual links, let''s alter
    our Hello World salutation component to make use of this. This is what it looks
    like now:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，现在我们知道了如何使用上下文链接，让我们修改我们的Hello World问候组件以利用这一点。这就是它现在的样子：
- en: '[PRE16]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The main changes are as follows. First, we have already defined the `#salutation`
    variable at the top and made it into a render array. As you remember, these are
    highly nestable. In this render array, we added our `#contextual_links` render
    element. Second, every time we need to set the value for the salutation string
    below, we do so in a `#markup` element this time, because, as we saw in the previous
    chapter, we need a property that defines how the render array gets rendered.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 主要变化如下。首先，我们在顶部已经定义了`#salutation`变量并将其转换为渲染数组。正如你记得的那样，这些是高度可嵌套的。在这个渲染数组中，我们添加了我们的`#contextual_links`渲染元素。其次，每次我们需要设置下面问候字符串的值时，这次我们在`#markup`元素中这样做，因为，正如我们在上一章中看到的，我们需要一个属性来定义渲染数组如何渲染。
- en: 'So now if you clear the cache and navigate to the `/hello` page, you should
    be able to hover over the salutation and see the contextual links icon pop up
    and contain our `Override` link. You should land on the salutation **configuration**
    form when you click on the link and also note a `destination` query parameter
    in the URL:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，现在如果你清除缓存并导航到`/hello`页面，你应该能够悬停在问候上并看到上下文链接图标弹出并包含我们的`Override`链接。当你点击链接时，你应该会跳转到问候**配置**表单，并注意URL中的`destination`查询参数：
- en: '![](img/5c4f4c02-d460-4726-a38f-e8e06838b1ac.png)'
  id: totrans-143
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/5c4f4c02-d460-4726-a38f-e8e06838b1ac.png)'
- en: The destination query parameter is used by Drupal to return the user to the
    page they previously were on after they submitted a form on that page. This is
    a handy trick to keep in mind, as it is a very popular UX technique.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 目标查询参数被Drupal用来在用户在页面上提交表单后返回他们之前所在的页面。这是一个值得记住的技巧，因为它是一个非常流行的用户体验技术。
- en: Summary
  id: totrans-145
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we covered a lot of ground for working with menus and menu
    links. We started by getting an overview of the architecture of the menu system
    in Drupal 8\. I threw many classes and hooks at you because I am a firm believer
    that the best way to learn is to dig into the code.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一章中，我们为使用菜单和菜单链接做了很多工作。我们首先对Drupal 8中菜单系统的架构进行了概述。我向你扔了很多类和钩子，因为我坚信，最好的学习方法是深入代码。
- en: We also saw what types of menu links there are in Drupal 8\. We not only have
    regular links that belong to actual menus, but all sorts of other utility link
    systems, such as local tasks, local actions, and contextual links.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还看到了在Drupal 8中存在哪些类型的菜单链接。我们不仅有属于实际菜单的常规链接，还有各种其他实用链接系统，例如本地任务、本地操作和上下文链接。
- en: Then, we got our hands dirty and started with a practical example of how to
    load menu links in a tree, manipulate them, and finally turn them into a render
    array. Right after that, we looked at how we can define all these types of menu
    links and how to understand them if we need to work with them programmatically.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们亲自动手，通过一个实际示例来了解如何在树中加载菜单链接，如何操作它们，最后将它们转换为渲染数组。在那之后，我们看了如何定义所有这些类型的菜单链接，以及如果我们需要以编程方式处理它们时如何理解它们。
- en: In the next chapter, we will look at one of the most important aspects of any
    kind of content management framework—the different types of data storage we can
    have in Drupal 8 and how we can work with them.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将探讨任何内容管理系统框架最重要的一个方面——在Drupal 8中我们可以拥有的不同类型的数据存储以及如何与它们协同工作。
