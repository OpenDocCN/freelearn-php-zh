- en: Chapter 5. Using Databases
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第5章 使用数据库
- en: Data is probably the cornerstone of most web applications. Sure, your application
    has to be pretty, fast, error-free, and so on, but if something is essential to
    users, it is what data you can manage for them. From this, we can extract that
    managing data is one of the most important things you have to consider when designing
    your application.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 数据可能是大多数Web应用程序的基石。当然，你的应用程序必须很漂亮、快速、无错误，等等，但如果某些东西对用户来说是基本的，那就是你可以为他们管理的数据。从这一点我们可以得出，管理数据是你在设计应用程序时必须考虑的最重要的事情之一。
- en: Managing data implies not only storing read-only files and reading them when
    needed, as we were doing so far, but also adding, fetching, updating, and removing
    individual pieces of information. For this, we need a tool that categorizes our
    data and makes these tasks easier for us, and this is when databases come into
    play.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 管理数据不仅意味着存储只读文件并在需要时读取它们，就像我们迄今为止所做的那样，还包括添加、检索、更新和删除单个信息片段。为此，我们需要一个工具来分类我们的数据，并使这些任务对我们来说更容易，这就是数据库发挥作用的时候。
- en: 'In this chapter, you will learn about:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你将了解：
- en: Schemas and tables
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模式和表
- en: Manipulating and querying data
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 操作和查询数据
- en: Using PDO to connect your database with PHP
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用PDO将您的数据库与PHP连接
- en: Indexing your data
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 索引你的数据
- en: Constructing complex queries in joining tables
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在连接的表中构建复杂查询
- en: Introducing databases
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍数据库
- en: 'Databases are tools to manage data. The basic functions of a database are inserting,
    searching, updating, and deleting data, even though most database systems do more
    than this. Databases are classified into two different categories depending on
    how they store data: relational and nonrelational databases.'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 数据库是管理数据的工具。数据库的基本功能是插入、搜索、更新和删除数据，尽管大多数数据库系统做的不仅仅是这些。根据它们存储数据的方式，数据库分为两个不同的类别：关系型数据库和非关系型数据库。
- en: Relational databases structure data in a very detailed way, forcing the user
    to use a defined format and allowing the creation of connections—that is, relations—between
    different pieces of information. Nonrelational databases are systems that store
    data in a more relaxed way, as though there were no apparent structure. Even though
    with these very vague definitions you could assume that everybody would like to
    use relational databases, both systems are very useful; it just depends on how
    you want to use them.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 关系型数据库以非常详细的方式组织数据，迫使用户使用定义的格式，并允许创建不同信息片段之间的连接——即关系。非关系型数据库是存储数据方式更为宽松的系统，就像没有明显的结构一样。尽管这些非常模糊的定义可能会让你认为每个人都想使用关系型数据库，但这两个系统都非常有用；这完全取决于你如何使用它们。
- en: In this book, we will focus on relational databases as they are widely used
    in small web applications, in which there are not huge amounts of data. The reason
    is that usually the application contains data that is interrelated; for example,
    our application could store sales, which are composed of customers and books.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在这本书中，我们将专注于关系型数据库，因为它们在小型Web应用程序中广泛使用，在这些应用程序中，数据量不是很大。原因是通常应用程序包含相互关联的数据；例如，我们的应用程序可以存储销售数据，这些销售数据由客户和书籍组成。
- en: MySQL
  id: totrans-13
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: MySQL
- en: MySQL has been the favorite choice of PHP developers for quite a long time.
    It is a relational database system that uses SQL as the language to communicate
    with the system. SQL is used in quite a few other systems, which makes things
    easier in case you need to switch databases or just need to understand an application
    with a different database than the one you are used to. The rest of the chapter
    will be focused on MySQL, but it will be helpful for you even if you choose a
    different SQL system.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: MySQL长期以来一直是PHP开发者的首选选择。它是一个使用SQL作为与系统通信语言的数据库系统。SQL在许多其他系统中也被使用，这使得在需要切换数据库或只是需要理解一个使用不同于你习惯的数据库的应用程序时，事情变得更容易。本章的其余部分将专注于MySQL，但即使你选择不同的SQL系统，它也会对你有所帮助。
- en: 'In order to use MySQL, you need to install two applications: the server and
    the client. You might remember server-client applications from [Chapter 2](part0019_split_000.html#I3QM2-edcc22b134104d5db0bf3aa086c86851
    "Chapter 2. Web Applications with PHP"), *Web Applications with PHP*. The MySQL
    server is a program that listens for instructions or queries from clients, executes
    them, and returns a result. You need to start the server in order to access the
    database; take a look at [Chapter 1](part0014_split_000.html#DB7S1-edcc22b134104d5db0bf3aa086c86851
    "Chapter 1. Setting Up the Environment"), *Setting Up the Environment*, on how
    to do this. The client is an application that allows you to construct instructions
    and send them to the server, and it is the one that you will use.'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使用MySQL，你需要安装两个应用程序：服务器和客户端。你可能还记得从[第2章](part0019_split_000.html#I3QM2-edcc22b134104d5db0bf3aa086c86851
    "第2章。使用PHP的Web应用程序")，*使用PHP的Web应用程序*中提到的服务器-客户端应用程序。MySQL服务器是一个程序，它监听来自客户端的指令或查询，执行它们，并返回结果。你需要启动服务器才能访问数据库；请参阅[第1章](part0014_split_000.html#DB7S1-edcc22b134104d5db0bf3aa086c86851
    "第1章。设置环境")，*设置环境*，了解如何进行此操作。客户端是一个应用程序，允许你构建指令并将它们发送到服务器，你将使用它。
- en: Note
  id: totrans-16
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '**GUI versus command line**'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: '**GUI与命令行**'
- en: '**The Graphical User Interface** (**GUI**) is very common when using a database.
    It helps you in constructing instructions, and you can even manage data without
    them using just visual tables. On the other hand, command-line clients force you
    to write all the commands by hand, but they are lighter than GUIs, faster to start,
    and force you to remember how to write SQL, which you need when you write your
    applications in PHP. Also, in general, almost any machine with a database will
    have a MySQL client but might not have a graphical application.'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: '**图形用户界面**（**GUI**）在数据库使用中非常常见。它可以帮助你构建指令，甚至仅使用可视表格就可以管理数据。另一方面，命令行客户端强迫你手动编写所有命令，但它们比GUI轻便，启动速度快，并迫使你记住如何编写SQL，这在用PHP编写应用程序时是必需的。此外，一般来说，几乎任何带有数据库的机器都会有一个MySQL客户端，但可能没有图形应用程序。'
- en: You can choose the one that you are more comfortable with as you will usually
    work with your own machine. However, keep in mind that a basic knowledge of the
    command line will save your life on several occasions.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以选择你更舒适的一个，因为你通常会在自己的机器上工作。然而，请记住，基本的命令行知识会在许多场合救你于水火之中。
- en: 'In order to connect the client with a server, you need to provide some information
    on where to connect and the credentials for the user to use. If you do not customize
    your MySQL installation, you should at least have a root user with no password,
    which is the one we will use. You could think that this seems to be a horrible
    security hole, and it might be so, but you should not be able to connect using
    this user if you do not connect from the same machine on which the server is.
    The most common arguments that you can use to provide information when starting
    the client are:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 为了将客户端与服务器连接起来，你需要提供一些关于连接位置和用户凭证的信息。如果你没有自定义你的MySQL安装，至少你应该有一个没有密码的root用户，这是我们将会使用的。你可能认为这似乎是一个可怕的安全漏洞，可能确实如此，但如果你不是从服务器所在的同一台机器连接，你不应该能够使用此用户连接。在启动客户端时，你可以使用的最常见参数是：
- en: '`-u <name>`: This specifies the user—in our case, `root`.'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-u <用户名>`：这指定了用户——在我们的情况下，`root`。'
- en: '`-p<password>`: Without a space, this specifies the password. As we do not
    have a password for our user, we do not need to provide this.'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-p<密码>`：没有空格，这指定了密码。由于我们没有为我们的用户设置密码，因此我们不需要提供此信息。'
- en: '`-h <host>`: This specifies where to connect. By default, the client connects
    to the same machine. As this is our case, there is no need to specify any. If
    you had to, you could specify either an IP address or a hostname.'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-h <主机>`：这指定了连接的位置。默认情况下，客户端连接到同一台机器。由于我们的情况是这样，因此不需要指定任何内容。如果你需要，你可以指定一个IP地址或主机名。'
- en: '`<schema name>`: This specifies the name of the schema to use. We will explain
    in a bit what this means.'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<模式名称>`：这指定了要使用的模式名称。我们将在稍后解释这意味着什么。'
- en: 'With these rules, you should be able to connect to your database with the `mysql
    -u root` command. You should get an output very similar to the following one:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 根据这些规则，你应该能够使用`mysql -u root`命令连接到你的数据库。你应该得到一个非常类似于以下输出的结果：
- en: '[PRE0]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The terminal will show you the version of the server and some useful information
    about how to use the client. From now on, the command line will start with `mysql>`
    instead of your normal prompt, showing you that you are using the MySQL client.
    In order to execute queries, just type the query, end it with a semicolon, and
    press *Enter*. The client will send the query to the server and will show the
    result of it. To exit the client, you can either type `\q` and press *Enter* or
    press *Ctrl* + *D*, even though this last option will depend on your operating
    system.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 终端将显示服务器的版本以及有关如何使用客户端的一些有用信息。从现在开始，命令行将以 `mysql>` 开头，而不是您的正常提示符，这表明您正在使用 MySQL
    客户端。要执行查询，只需输入查询，以分号结束，然后按 *Enter*。客户端会将查询发送到服务器，并显示其结果。要退出客户端，您可以输入 `\q` 并按 *Enter*，或者按
    *Ctrl* + *D*，尽管最后一个选项将取决于您的操作系统。
- en: Schemas and tables
  id: totrans-28
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 模式和表
- en: Relational database systems usually have the same structure. They store data
    in different databases or **schemas**, which separate the data from different
    applications. These schemas are just collections of **tables**. Tables are definitions
    of specific data structures and are composed of **fields**. A field is a basic
    data type that defines the smallest component of information as though they were
    the atoms of the data. So, schemas are group of tables that are composed of fields.
    Let's look at each of these elements.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 关系型数据库系统通常具有相同的结构。它们在不同的数据库或 **模式** 中存储数据，这些模式将不同应用程序的数据分开。这些模式只是 **表** 的集合。表是特定数据结构的定义，由
    **字段** 组成。字段是基本数据类型，它定义了信息的最小组成部分，就像它们是数据的基本粒子一样。因此，模式是由字段组成的表的集合。让我们看看这些元素中的每一个。
- en: Understanding schemas
  id: totrans-30
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解模式
- en: As defined before, schemas or databases— in MySQL, they are synonyms—are collections
    of tables with a common context, usually belonging to the same application. Actually,
    there are no restrictions around this, and you could have several schemas belonging
    to the same application if needed. However, for small web applications, as it
    is our case, we will have just one schema.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，模式或数据库——在 MySQL 中，它们是同义词——是具有共同上下文的表的集合，通常属于同一应用程序。实际上，在这方面没有限制，如果需要，您可以为同一应用程序拥有多个模式。然而，对于小型网络应用程序，正如我们的情况一样，我们只有一个模式。
- en: Your server probably already has some schemas. They usually contain the metadata
    needed for MySQL in order to operate, and we highly recommend that you do not
    modify them. Instead, let's just create our own schema. Schemas are quite simple
    elements, and they only have a mandatory name and an optional charset. The name
    identifies the schema, and the charset defines which type of codification or "alphabet"
    the strings should follow. As the default charset is `latin1`, if you do not need
    to change it, you do not need to specify it.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 您的服务器可能已经有一些模式。它们通常包含 MySQL 运作所需的元数据，我们强烈建议您不要修改它们。相反，让我们只创建我们自己的模式。模式是非常简单的元素，它们只有一个必需的名称和一个可选的字符集。名称标识模式，字符集定义字符串应遵循的类型编码或“字母表”。由于默认字符集是
    `latin1`，如果您不需要更改它，则不需要指定它。
- en: 'Use `CREATE SCHEMA` followed by the name of the schema in order to create the
    schema that we will use for our bookstore. The name has to be representative,
    so let''s name it `bookstore`. Remember to end your line with a semicolon. Take
    a look at the following:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `CREATE SCHEMA` 后跟模式名称，以便创建我们将用于书店的模式。名称必须具有代表性，所以让我们称它为 `bookstore`。请记住，在行尾加上分号。看看下面的例子：
- en: '[PRE1]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'If you need to remember how a schema was created, you can use `SHOW CREATE
    SCHEMA` to see its description, as follows:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您需要记住模式是如何创建的，可以使用 `SHOW CREATE SCHEMA` 来查看其描述，如下所示：
- en: '[PRE2]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: As you can see, we ended the query with `\G` instead of a semicolon. This tells
    the client to format the response in a different way than the semicolon does.
    When using a command of the `SHOW CREATE` family, we recommend that you end it
    with `\G` to get a better understanding.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，我们以 `\G` 结束查询而不是分号。这告诉客户端以与分号不同的方式格式化响应。当使用 `SHOW CREATE` 类型的命令时，我们建议您以
    `\G` 结束，以获得更好的理解。
- en: Tip
  id: totrans-38
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: '**Should you use uppercase or lowercase?**'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '**您应该使用大写还是小写？**'
- en: When writing queries, you might note that we used uppercase for keywords and
    lowercase for identifiers, such as names of schemas. This is just a convention
    widely used in order to make it clear what is part of SQL and what is your data.
    However, MySQL keywords are case-insensitive, so you could use any case indistinctively.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 当编写查询时，你可能注意到我们使用了大写字母作为关键字，小写字母作为标识符，例如模式的名称。这只是广泛使用的一种约定，以便清楚地表明什么是SQL的一部分，什么是你的数据。然而，MySQL的关键字是不区分大小写的，所以你可以无差别地使用任何大小写。
- en: 'All data must belong to a schema. There cannot be data floating around outside
    all schemas. This way, you cannot do anything unless you specify the schema you
    want to use. In order to do this, just after starting your client, use the `USE`
    keyword followed by the name of the schema. Optionally, you could tell the client
    which schema to use when connecting to it, as follows:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 所有数据都必须属于一个模式。数据不能在所有模式之外漂浮。这样，除非你指定你想要使用的模式，否则你不能做任何事情。为了做到这一点，在你的客户端启动后，使用`USE`关键字后跟模式名称。可选地，你可以在连接时告诉客户端使用哪个模式，如下所示：
- en: '[PRE3]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'If you do not remember what the name of your schema is or want to check which
    other schemas are in your server, you can run the `SHOW SCHEMAS;` command to get
    a list of them, as follows:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你忘记了你的模式名称或者想要检查你的服务器中还有哪些其他模式，你可以运行`SHOW SCHEMAS;`命令来获取它们的列表，如下所示：
- en: '[PRE4]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Database data types
  id: totrans-45
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 数据库数据类型
- en: As in PHP, MySQL also has data types. They are used to define which kind of
    data a field can contain. As in PHP, MySQL is quite flexible with data types,
    transforming them from one type to the other if needed. There are quite a few
    of them, but we will explain the most important ones. We highly recommend that
    you visit the official documentation related to data types at [http://dev.mysql.com/doc/refman/5.7/en/data-types.html](http://dev.mysql.com/doc/refman/5.7/en/data-types.html)
    if you want to build applications with more complex data structures.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 与PHP一样，MySQL也有数据类型。它们用于定义一个字段可以包含哪种类型的数据。与PHP一样，MySQL在数据类型方面相当灵活，如果需要，可以将它们从一种类型转换为另一种类型。它们有很多种，但我们将解释最重要的几种。我们强烈建议如果你想要使用更复杂的数据结构来构建应用程序，请访问有关数据类型的官方文档[http://dev.mysql.com/doc/refman/5.7/en/data-types.html](http://dev.mysql.com/doc/refman/5.7/en/data-types.html)。
- en: Numeric data types
  id: totrans-47
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 数值数据类型
- en: 'Numeric data can be categorized as integers or decimal numbers. For integers,
    MySQL uses the `INT` data type even though there are versions to store smaller
    numbers, such as `TINYINT`, `SMALLINT`, or `MEDIUMINT`, or bigger numbers, such
    as `BIGINT`. The following table shows what the sizes of the different numeric
    types are, so you can choose which one to use depending on your situation:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 数值数据可以分为整数或小数。对于整数，MySQL使用`INT`数据类型，尽管有版本可以存储更小的数字，例如`TINYINT`、`SMALLINT`或`MEDIUMINT`，或者更大的数字，例如`BIGINT`。下表显示了不同数值类型的大小，这样你可以根据你的情况选择使用哪一个：
- en: '| Type | Size/precision |'
  id: totrans-49
  prefs: []
  type: TYPE_TB
  zh: '| 类型 | 大小/精度 |'
- en: '| --- | --- |'
  id: totrans-50
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `TINYINT` | -128 to 127 |'
  id: totrans-51
  prefs: []
  type: TYPE_TB
  zh: '| `TINYINT` | -128 到 127 |'
- en: '| `SMALLINT` | -32,768 to 32,767 |'
  id: totrans-52
  prefs: []
  type: TYPE_TB
  zh: '| `SMALLINT` | -32,768 到 32,767 |'
- en: '| `MEDIUMINT` | -8,388,608 to 8,388,607 |'
  id: totrans-53
  prefs: []
  type: TYPE_TB
  zh: '| `MEDIUMINT` | -8,388,608 到 8,388,607 |'
- en: '| `INT` | -2,147,483,648 to 2,147,483,647 |'
  id: totrans-54
  prefs: []
  type: TYPE_TB
  zh: '| `INT` | -2,147,483,648 到 2,147,483,647 |'
- en: '| `BIGINT` | -9,223,372,036,854,775,808 to 9,223,372,036,854,775,807 |'
  id: totrans-55
  prefs: []
  type: TYPE_TB
  zh: '| `BIGINT` | -9,223,372,036,854,775,808 到 9,223,372,036,854,775,807 |'
- en: Numeric types can be defined as signed by default or unsigned; that is, you
    can allow or not allow them to contain negative values. If a numeric type is defined
    as `UNSIGNED`, the range of numbers that it can take is doubled as it does not
    need to save space for negative numbers.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 数值类型可以被定义为默认有符号或无符号；也就是说，你可以允许或不允许它们包含负值。如果一个数值类型被定义为`UNSIGNED`，那么它可以接受的数字范围会加倍，因为它不需要为负数预留空间。
- en: 'For decimal numbers we have two types: approximate values, which are faster
    to process but are not exact sometimes, and exact values that give you exact precision
    on the decimal value. For approximate values or the floating-point type, we have
    `FLOAT` and `DOUBLE`. For exact values or the fixed-point type we have `DECIMAL`.'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 对于小数，我们有两种类型：近似值，处理速度快但有时并不精确，以及精确值，可以给出小数值的精确精度。对于近似值或浮点类型，我们有`FLOAT`和`DOUBLE`。对于精确值或定点类型，我们有`DECIMAL`。
- en: MySQL allows you to specify the number of digits and decimal positions that
    the number can take. For example, to specify a number that can contains five digits
    and up to two of them can be decimal, we will use the `FLOAT(5,2)` notation. This
    is useful as a constraint, as you will note when we create tables with prices.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: MySQL 允许你指定数字可以包含的位数和小数位数。例如，为了指定一个可以包含五个数字且最多有两个小数的数字，我们将使用 `FLOAT(5,2)` 语法。当我们在创建价格表时，你会注意到这作为一个约束是有用的。
- en: String data types
  id: totrans-59
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 字符串数据类型
- en: 'Even though there are several data types that allow you to store from single
    characters to big chunks of text or binary code, it is outside the scope of this
    chapter. In this section, we will introduce you to three types: `CHAR`, `VARCHAR`,
    and `TEXT`.'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管有几种数据类型允许你存储从单个字符到大量文本或二进制代码，但这超出了本章的范围。在本节中，我们将向你介绍三种类型：`CHAR`、`VARCHAR`
    和 `TEXT`。
- en: '`CHAR` is a data type that allows you to store an exact number of characters.
    You need to specify how long the string will be once you define the field, and
    from this point on, all values for this field have to be of this length. One possible
    usage in our applications could be when storing the ISBN of the book as we know
    it is always 13 characters long.'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '`CHAR` 是一种数据类型，允许你存储一个确切数量的字符。一旦你定义了字段，你需要指定字符串的长度，从这一点开始，这个字段的所有值都必须是这个长度。在我们的应用中，一个可能的用途是当存储书籍的
    ISBN 时，因为我们知道它总是 13 个字符长。'
- en: '`VARCHAR` or variable char is a data type that allows you to store strings
    up to 65,535 characters long. You do not need to specify how long they need to
    be, and you can insert strings of different lengths without an issue. Of course,
    the fact that this type is dynamic makes it slower to process compared with the
    previous one, but after a few times you know how long a string will always be.
    You could tell MySQL that even if you want to insert strings of different lengths,
    the maximum length will be a determined number. This will help its performance.
    For example, names are of different lengths, but you can safely assume that no
    name will be longer than 64 characters, so your field could be defined as `VARCHAR(64)`.'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '`VARCHAR` 或可变字符是一种数据类型，允许你存储长达 65,535 个字符的字符串。你不需要指定它们的长度，并且可以插入不同长度的字符串而不会出现问题。当然，这种类型的动态性使得它的处理速度比前一种类型慢，但经过几次之后，你就会知道字符串的长度总是多少。你可以告诉
    MySQL，即使你想插入不同长度的字符串，最大长度也将是一个确定的数字。这将有助于其性能。例如，名字的长度不同，但你可以安全地假设没有名字的长度会超过 64
    个字符，因此你的字段可以定义为 `VARCHAR(64)`。'
- en: 'Finally, `TEXT` is a data type for really big strings. You could use it if
    you want to store long comments from users, articles, and so on. As with `INT`,
    there are different versions of this data type: `TINYTEXT`, `TEXT`, `MEDIUMTEXT`,
    and `LONGTEXT`. Even if they are very important in almost any web application
    with user interaction, we will not use them in ours.'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，`TEXT` 是一种用于存储非常长字符串的数据类型。如果你想存储用户的长期评论、文章等，可以使用它。与 `INT` 类似，这个数据类型有不同的版本：`TINYTEXT`、`TEXT`、`MEDIUMTEXT`
    和 `LONGTEXT`。尽管它们在几乎任何具有用户交互的 Web 应用程序中都非常重要，但我们将不会在我们的应用中使用它们。
- en: List of values
  id: totrans-64
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 值列表
- en: 'In MySQL, you can force a field to have a set of valid values. There are two
    types of them: `ENUM`, which allows exactly one of the possible predefined values,
    and `SET`, which allows any number of the predefined values.'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 在 MySQL 中，你可以强制一个字段只能包含一组有效的值。它们有两种类型：`ENUM`，它允许正好包含一个预定义的可能值，和`SET`，它允许包含任意数量的预定义值。
- en: 'For example, in our application, we have two types of customers: basic and
    premium. If we want to store our customers in a database, there is a chance that
    one of the fields will be the type of customer. As a customer has to be either
    basic or premium, a good solution would be to define the field as an enum as `ENUM("basic",
    "premium")`. In this way, we will make sure that all customers stored in our database
    will be of a correct type.'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，在我们的应用中，我们有两种类型的客户：基本和高级。如果我们想在数据库中存储我们的客户，那么有一个字段将是客户类型。由于客户必须是基本或高级之一，一个很好的解决方案是将该字段定义为枚举类型
    `ENUM("basic", "premium")`。这样，我们将确保所有存储在我们数据库中的客户都将具有正确的类型。
- en: Although enums are quite common to use, the use of sets is less widespread.
    It is usually a better idea to use an extra table to define the values of the
    list, as you will note when we talk about foreign keys in this chapter.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管枚举（enum）的使用相当普遍，但集合（set）的使用则不太广泛。通常，使用一个额外的表来定义列表的值是一个更好的主意，正如我们在本章讨论外键时将会注意到的。
- en: Date and time data types
  id: totrans-68
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 日期和时间数据类型
- en: Date and time types are the most complex data types in MySQL. Even though the
    idea is simple, there are several functions and edge cases around these types.
    We cannot go through all of them, so we will just explain the most common uses,
    which are the ones we will need for our application.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '日期和时间类型是MySQL中最复杂的数据类型。尽管这个想法很简单，但围绕这些类型有多个函数和边缘情况。我们无法一一介绍，所以我们只解释最常见的用法，这是我们应用程序所需要的。 '
- en: '`DATE` stores dates—that is, a combination of day, month, and year. `TIME`
    stores times—that is, a combination of hour, minute, and second. `DATETIME` are
    data types for both date and time. For any of these data types, you can provide
    just a string specifying what the value is, but you need to be careful with the
    format that you use. Even though you can always specify the format that you are
    entering the data in, you can just enter the dates or times in the default format—for
    example, 2014-12-31 for dates, 14:34:50 for time, and 2014-12-31 14:34:50 for
    the date and time.'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: '`DATE`存储日期——即日、月和年的组合。`TIME`存储时间——即小时、分钟和秒的组合。`DATETIME`是日期和时间的数据类型。对于这些数据类型中的任何一种，你都可以提供一个字符串来指定值，但你需要注意所使用的格式。尽管你可以始终指定输入数据的格式，但你也可以使用默认格式输入日期或时间——例如，日期为2014-12-31，时间为14:34:50，日期和时间为2014-12-31
    14:34:50。'
- en: A fourth type is `TIMESTAMP`. This type stores an integer, which is the representation
    of the seconds from January 1, 1970, which is also known as the Unix timestamp.
    This is a very useful type as in PHP, it is really easy to get the current Unix
    timestamp with the `now()` function, and the format for this data type is always
    the same, so it is safer to work with it. The downside is that the range of dates
    that it can represent is limited as compared to other types.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 第四种类型是`TIMESTAMP`。这种类型存储一个整数，表示从1970年1月1日以来的秒数，也称为Unix时间戳。在PHP中，使用`now()`函数获取当前的Unix时间戳非常容易，并且这种数据类型的格式始终相同，因此与它一起工作更安全。缺点是它所能表示的日期范围与其他类型相比有限。
- en: 'There are some functions that help you manage these types. These functions
    extract specific parts of the whole value, return the value with a different format,
    add or subtract dates, and so on. Let''s take a look at a short list of them:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 有一些函数可以帮助你管理这些类型。这些函数提取整个值的特定部分，以不同的格式返回值，添加或减去日期，等等。让我们看看它们的简要列表：
- en: '| Function name | Description |'
  id: totrans-73
  prefs: []
  type: TYPE_TB
  zh: '| 函数名 | 描述 |'
- en: '| --- | --- |'
  id: totrans-74
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `DAY()`, `MONTH()`, and `YEAR()` | Extracts the specific value for the day,
    month, or year from the `DATE` or `DATETIME` provided value. |'
  id: totrans-75
  prefs: []
  type: TYPE_TB
  zh: '| `DAY()`, `MONTH()`, 和 `YEAR()` | 从提供的`DATE`或`DATETIME`值中提取日、月或年的特定值。|'
- en: '| `HOUR()`, `MINUTE()`, and `SECOND()` | Extracts the specific value for the
    hour, minute, or second from the `TIME` or `DATETIME` provided value. |'
  id: totrans-76
  prefs: []
  type: TYPE_TB
  zh: '| `HOUR()`, `MINUTE()`, 和 `SECOND()` | 从提供的`TIME`或`DATETIME`值中提取小时、分钟或秒的特定值。|'
- en: '| `CURRENT_DATE()` and `CURRENT_TIME()` | Returns the current date or current
    time. |'
  id: totrans-77
  prefs: []
  type: TYPE_TB
  zh: '| `CURRENT_DATE()` 和 `CURRENT_TIME()` | 返回当前的日期或当前的时间。|'
- en: '| `NOW()` | Returns the current date and time. |'
  id: totrans-78
  prefs: []
  type: TYPE_TB
  zh: '| `NOW()` | 返回当前的日期和时间。|'
- en: '| `DATE_FORMAT()` | Returns the `DATE`, `TIME` or `DATETIME` value with the
    specified format. |'
  id: totrans-79
  prefs: []
  type: TYPE_TB
  zh: '| `DATE_FORMAT()` | 返回具有指定格式的`DATE`、`TIME`或`DATETIME`值。|'
- en: '| `DATE_ADD()` | Adds the specified interval of time to a given date or time
    type. |'
  id: totrans-80
  prefs: []
  type: TYPE_TB
  zh: '| `DATE_ADD()` | 将指定的间隔时间添加到给定的日期或时间类型。|'
- en: Do not worry if you are confused on how to use any of these functions; we will
    use them during the rest of the book as part of our application. Also, an extensive
    list of all the types can be found at [http://dev.mysql.com/doc/refman/5.7/en/date-and-time-functions.html](http://dev.mysql.com/doc/refman/5.7/en/date-and-time-functions.html).
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你对如何使用这些函数感到困惑，请不要担心；我们将在本书的其余部分作为我们应用程序的一部分来使用它们。此外，所有类型的详细列表可以在[http://dev.mysql.com/doc/refman/5.7/en/date-and-time-functions.html](http://dev.mysql.com/doc/refman/5.7/en/date-and-time-functions.html)找到。
- en: Managing tables
  id: totrans-82
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 管理表
- en: Now that you understand the different types of data that fields can take, it
    is time to introduce tables. As defined in the *Schemas and tables* section, a
    table is a collection of fields that defines a type of information. You could
    compare it with OOP and think of tables as classes, fields being their properties.
    Each instance of the class would be a row on the table.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经了解了字段可以采取的不同数据类型，是时候介绍表了。如*模式与表*部分所定义，表是一组字段，它定义了一种信息类型。你可以将其与面向对象编程（OOP）进行比较，将表视为类，字段是它们的属性。类的每个实例都会成为表中的一行。
- en: 'When defining a table, you have to declare the list of fields that the table
    contains. For each field, you need to specify its name, its type, and some extra
    information depending on the type of the field. The most common are:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 在定义一个表时，你必须声明该表包含的字段列表。对于每个字段，你需要指定其名称、其类型以及根据字段类型的一些额外信息。最常见的包括：
- en: '`NOT NULL`: This is used if the field cannot be null—that is, if it needs a
    concrete valid value for each row. By default, a field can be null.'
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`NOT NULL`：如果字段不能为null——也就是说，如果它需要为每一行提供一个具体的有效值，则使用此选项。默认情况下，字段可以是null。'
- en: '`UNSIGNED`: As mentioned earlier, this is used to forbid the use of negative
    numbers in this field. By default, a numeric field accepts negative numbers.'
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`UNSIGNED`：如前所述，这用于禁止在此字段中使用负数。默认情况下，数值字段接受负数。'
- en: '`DEFAULT <value>`: This defines a default value in case the user does not provide
    any. Usually, the default value is null if this clause is not specified.'
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`DEFAULT <value>`：这定义了一个默认值，以防用户没有提供任何值。通常，如果没有指定此子句，默认值是null。'
- en: Table definitions also need a name, as with schemas, and some optional attributes.
    You can define the charset of the table or its engine. Engines can be a quite
    large topic to cover, but for the scope of this chapter, let's just note that
    we should use the InnoDB engine if we need strong relationships between tables.
    For more advanced readers, you can read more about MySQL engines at [https://dev.mysql.com/doc/refman/5.0/en/storage-engines.html](https://dev.mysql.com/doc/refman/5.0/en/storage-engines.html).
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 表定义也需要一个名称，就像模式一样，以及一些可选属性。你可以定义表的字符集或其引擎。引擎可以是一个相当大的主题，但就本章的范围而言，让我们只注意，如果我们需要在表之间建立强大的关系，我们应该使用InnoDB引擎。对于更高级的读者，你可以在[https://dev.mysql.com/doc/refman/5.0/en/storage-engines.html](https://dev.mysql.com/doc/refman/5.0/en/storage-engines.html)上了解更多关于MySQL引擎的信息。
- en: 'Knowing this, let''s try to create a table that will keep our books. The name
    of the table should be `book`, as each row will define a book. The fields could
    have the same properties the `Book` class has. Let''s take a look at how the query
    to construct the table would look:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 了解这一点后，让我们尝试创建一个将保存我们的书籍的表。表的名称应该是`book`，因为每一行将定义一本书。字段可以具有与`Book`类相同的属性。让我们看看构建表的查询将是什么样子：
- en: '[PRE5]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'As you can note, we can add more new lines until we end the query with a semicolon.
    With this, we can format the query in a way that looks more readable. MySQL will
    let us know that we are still writing the same query showing the `->` prompt.
    As this table contains five fields, it is very likely that we will need to refresh
    our minds from time to time as we will forget them. In order to display the structure
    of the table, you could use the `DESC` command, as follows:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所注意到的，我们可以添加更多的新行，直到我们用分号结束查询。这样，我们可以以更易读的方式格式化查询。MySQL会让我们知道我们仍在编写同一个查询，显示`->`提示符。由于这个表包含五个字段，我们很可能需要不时地刷新我们的记忆，因为我们可能会忘记它们。为了显示表的结构，你可以使用`DESC`命令，如下所示：
- en: '[PRE6]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'We used `SMALLINT` for `stock` as it is very unlikely that we will have more
    than thousands of copies of the same book. As we know that ISBN is 13 characters
    long, we enforced this when defining the field. Finally, both `stock` and `price`
    are unsigned as negative values do not make sense. Let''s now create our `customer`
    table via the following script:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 我们为`stock`字段使用了`SMALLINT`，因为它非常不可能有超过几千本相同的书的副本。正如我们所知，ISBN是13个字符长，我们在定义字段时强制执行了这一点。最后，`stock`和`price`都是无符号的，因为负值没有意义。现在，让我们通过以下脚本创建我们的`customer`表：
- en: '[PRE7]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'We already anticipated the use of enum for the field type as when designing
    classes, we could draw a diagram identifying the content of our database. On this,
    we could show the tables and their fields. Let''s take a look at how the diagram
    of tables would look so far:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经预见到使用枚举作为字段类型，因为在设计类时，我们可以绘制一个图来标识我们的数据库内容。在这张图上，我们可以显示表及其字段。让我们看看到目前为止表格图会是什么样子：
- en: '![Managing tables](img/00025.jpeg)'
  id: totrans-96
  prefs: []
  type: TYPE_IMG
  zh: '![管理表格](img/00025.jpeg)'
- en: Note that even if we create tables similar to our classes, we will not create
    a table for `Person`. The reason is that databases store data, and there isn't
    any data that we could store for this class as the `customer` table already contains
    everything we need. Also, sometimes, we may create tables that do not exist as
    classes on our code, so the class-table relationship is a very flexible one.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，即使我们创建了与我们的类相似的表格，我们也不会为`Person`创建一个表格。原因是数据库存储数据，而这个类没有可以存储的数据，因为`customer`表已经包含了我们所需的所有信息。此外，有时我们可能会创建在代码中没有作为类的表格，因此类与表之间的关系是非常灵活的。
- en: Keys and constraints
  id: totrans-98
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 键和约束
- en: Now that we have our main tables defined, let's try to think about how the data
    inside would look. Each row inside a table would describe an object, which may
    be either a book or a customer. What would happen if our application has a bug
    and allows us to create books or customers with the same data? How will the database
    differentiate them? In theory, we will assign IDs to customers in order to avoid
    these scenarios, but how do we enforce that the ID not be repeated?
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经定义了主表，让我们尝试思考表内的数据看起来会是什么样子。表内的每一行将描述一个对象，这个对象可能是一本书或一个客户。如果我们的应用程序有一个错误，允许我们创建具有相同数据的书籍或客户会发生什么？数据库将如何区分它们？在理论上，我们将为客户分配ID以避免这些场景，但我们如何强制ID不重复？
- en: 'MySQL has a mechanism that allows you to enforce certain restrictions on your
    data. Other than attributes such as `NOT NULL` or `UNSIGNED` that you already
    saw, you can tell MySQL that certain fields are more special than others and instruct
    it to add some behavior to them. These mechanisms are called **keys**, and there
    are four types: primary key, unique key, foreign key, and index. Let''s take a
    closer look at them.'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: MySQL有一个机制可以让你对你的数据强制执行某些限制。除了你已经看到的`NOT NULL`或`UNSIGNED`等属性之外，你可以告诉MySQL某些字段比其他字段更特殊，并指示它为它们添加一些行为。这些机制被称为**键**，有四种类型：主键、唯一键、外键和索引。让我们更详细地看看它们。
- en: Primary keys
  id: totrans-101
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 主键
- en: Primary keys are fields that identify a unique row from a table. There cannot
    be two of the same value in the same table, and they cannot be null. Adding a
    primary key to a table that defines *objects* is almost a must as it will assure
    you that you will always be able to differentiate two rows by this field.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 主键是标识表中唯一行的字段。同一表中不能有两个相同的值，它们也不能为空。将主键添加到定义*对象*的表中几乎是必须的，因为它将确保你将始终能够通过此字段区分两行。
- en: Another part that makes primary keys so attractive is their ability to set the
    primary key as an autoincremental numeric value; that is, you do not have to assign
    a value to the ID, and MySQL will just pick up the latest inserted ID and increment
    it by 1, as we did with our `Unique` trait. Of course, for this to happen, your
    field has to be an integer data type. In fact, we highly recommend that you always
    define your primary key as an integer, even if the real-life object does not really
    have this ID at all. The reason is that you should search a row by this numeric
    ID, which is unique, and MySQL will add some performance improvements that come
    by setting the field as a key.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 使主键如此吸引人的另一个部分是它们可以将主键设置为自增的数值；也就是说，你不需要为ID分配值，MySQL会自动获取最新插入的ID并将其增加1，就像我们使用`Unique`特性时做的那样。当然，为了实现这一点，你的字段必须是整数数据类型。实际上，我们强烈建议你始终将主键定义为整数，即使现实生活中的对象根本不具有这个ID。原因是你应该通过这个唯一的数值ID来搜索行，MySQL将为设置字段为键提供一些性能改进。
- en: 'Then, let''s add an ID to our `book` table. In order to add a new field, we
    need to alter our table. There is a command that allows you to do this: `ALTER
    TABLE`. With this command, you can modify the definition of any existing field,
    add new ones, or remove existing ones. As we add the field that will be our primary
    key and be autoincremental, we can add all these modifiers to the field definition.
    Execute the following code:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，让我们给我们的`book`表添加一个ID。为了添加一个新字段，我们需要修改我们的表。有一个命令可以让你做到这一点：`ALTER TABLE`。使用这个命令，你可以修改任何现有字段的定义，添加新的字段，或者删除现有的字段。由于我们将添加的字段将成为我们的主键并且是自增的，我们可以将这些修饰符添加到字段定义中。执行以下代码：
- en: '[PRE8]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Note `FIRST` at the end of the command. When adding new fields, if you want
    them to appear on a different position than at the end of the table, you need
    to specify the position. It could be either `FIRST` or `AFTER <other field>`.
    For convenience, the primary key of a table is the first of its fields.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 注意命令末尾的`FIRST`。当添加新字段时，如果你想它们出现在表末尾之外的位置，你需要指定位置。可以是`FIRST`或`AFTER <other field>`。为了方便起见，表的主键是其字段中的第一个。
- en: 'As the table customer already has an ID field, we do not have to add it again
    but rather modify it. In order to do this, we will just use the `ALTER TABLE`
    command with the `MODIFY` option, specifying the new definition of an already
    existing field, as follows:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 由于客户表已经有一个ID字段，我们不需要再次添加它，而是修改它。为了做到这一点，我们将使用带有`MODIFY`选项的`ALTER TABLE`命令，指定已存在字段的新的定义，如下所示：
- en: '[PRE9]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Foreign keys
  id: totrans-109
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 外键
- en: Let's imagine that we need to keep track of the borrowed books. The table should
    contain the borrowed book, who borrowed it, and when it was borrowed. So, what
    kind of data would you use to identify the book or the customer? Would you use
    the title or the name? Well, we should use something that identifies a unique
    row from these tables, and this "something" is the primary key. With this action,
    we will eliminate the change of using a reference that can potentially point to
    two or more rows at the same time.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们想象一下，我们需要跟踪借阅的书籍。该表应包含借阅的书籍、谁借阅了它以及何时借阅。那么，您会用什么数据来识别书籍或客户？您会使用标题还是名字？嗯，我们应该使用一些可以唯一标识这些表中某一行的东西，而这个“东西”就是主键。通过这个操作，我们将消除使用可能同时指向两个或更多行的引用的风险。
- en: We could then create a table that contains `book_id` and `customer_id` as numeric
    fields, containing the IDs that reference these two tables. As the first approach,
    it makes sense, but we can find some weaknesses. For example, what happens if
    we insert wrong IDs and they do not exist in `book` or `customer`? We could have
    some code in our PHP side to make sure that when fetching information from `borrowed_books`,
    we only displayed the information that is correct. We could even have a routine
    that periodically checks for wrong rows and removes them, solving the issue of
    having wrong data wasting space in the disk. However, as with the `Unique` trait
    versus adding primary keys in MySQL, it is usually better to allow the database
    system to manage these things as the performance will usually be better, and you
    do not need to write extra code.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以创建一个包含`book_id`和`customer_id`作为数值字段的表，包含引用这两个表的 ID。作为第一种方法，这是有意义的，但我们也可以找到一些弱点。例如，如果我们插入错误的
    ID，并且它们在`book`或`customer`中不存在会发生什么？我们可以在我们的 PHP 端编写一些代码，确保在从`borrowed_books`获取信息时，我们只显示正确的信息。我们甚至可以有一个定期检查错误行并删除它们的例行程序，解决错误数据占用磁盘空间的问题。然而，就像在
    MySQL 中使用`Unique`特性与添加主键一样，通常最好让数据库系统来管理这些事情，因为性能通常会更好，而且您不需要编写额外的代码。
- en: MySQL allows you to create keys that enforce references to other tables. These
    are called **foreign keys**, and they are the primary reason for which we were
    forced to use the InnoDB table engine instead of any other. A foreign key defines
    and enforces a reference between this field and another row of a different table.
    If the ID supplied for the field with a foreign key does not exist in the referenced
    table, the query will fail. Furthermore, if you have a valid `borrowed_books`
    row pointing to an existing book and you remove the entry from the book table,
    MySQL will complain about it—even though you will be able to customize this behavior
    soon—as this action would leave wrong data in the system. As you can note, this
    is way more useful than having to write code to manage these cases.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: MySQL 允许您创建强制引用其他表的关键字。这些被称为**外键**，这是我们被迫使用 InnoDB 表引擎而不是其他引擎的主要原因。外键定义并强制执行了该字段与另一个表中不同行的引用。如果为具有外键的字段提供的
    ID 在引用表中不存在，查询将失败。此外，如果您有一个有效的指向现有书籍的`borrowed_books`行，然后您从书籍表中删除条目，MySQL 将对此提出抗议——尽管您很快就能自定义这种行为——因为这个操作会在系统中留下错误数据。正如您所注意到的，这比编写代码来管理这些情况要有用得多。
- en: 'Let''s create the `borrowed_books` table with the book, customer references,
    and dates. Note that we have to define the foreign keys after the definition of
    the fields as opposed to when we defined primary keys, as follows:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个包含书籍、客户引用和日期的`borrowed_books`表。请注意，我们必须在定义字段之后而不是在定义主键时定义外键，如下所示：
- en: '[PRE10]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'As with `SHOW CREATE SCHEMA`, you can also check how the table looks. This
    command will also show you information about the keys as opposed to the `DESC`
    command. Let''s take a look at how it would work:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 与`SHOW CREATE SCHEMA`一样，您还可以检查表的外观。此命令还会显示有关键的信息，而不是`DESC`命令。让我们看看它是如何工作的：
- en: '[PRE11]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Note two important things here. On one hand, we have two extra keys that we
    did not define. The reason is that when defining a foreign key, MySQL also defines
    the field as a key that will be used to improve performance on the table; we will
    look into this in a moment. The other element to note is the fact that MySQL defines
    names to the keys by itself. This is necessary as we need to be able to reference
    them in case we want to change or remove this key. You can let MySQL name the
    keys for you, or you can specify the names you prefer when creating them.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里要注意两个重要的事情。一方面，我们有两个额外的键我们没有定义。原因是当我们定义外键时，MySQL也会将字段定义为将用于提高表性能的键；我们稍后会探讨这一点。另一个需要注意的元素是MySQL会自己为键定义名称。这是必要的，因为如果我们想更改或删除这个键，我们需要能够引用它们。你可以让MySQL为你命名键，或者在你创建它们时指定你喜欢的名称。
- en: We are running a bookstore, and even if we allow customers to borrow books,
    we want to be able to sell them. A sale is a very important element that we need
    to track down as customers may want to review them, or you may just need to provide
    this information for taxation purposes. As opposed to borrowing, in which knowing
    the book, customer, and date was more than enough, here, we need to set IDs to
    the sales in order to identify them to the customers.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 我们经营一家书店，即使我们允许顾客借阅书籍，我们也希望能够出售它们。销售是一个非常重要的元素，我们需要追踪它，因为顾客可能想要回顾它们，或者你可能只需要提供这些信息以供税务目的。与借阅不同，知道书籍、客户和日期就足够了，在这里，我们需要为销售设置ID，以便向顾客识别它们。
- en: 'However, this table is more difficult to design than the other ones and not
    just because of the ID. Think about it: do customers buy books one by one? Or
    do they rather buy any number of books at once? Thus, we need to allow the table
    to contain an undefined amount of books. With PHP, this is easy as we would just
    use an array, but we do not have arrays in MySQL. There are two options to this
    problem.'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这个表的设计比其他表更困难，不仅仅是因为ID。想想看：客户是一本书一本书地买书吗？还是他们更愿意一次性买任意数量的书？因此，我们需要允许表中包含未定义数量的书籍。在PHP中，这很简单，因为我们只需使用一个数组，但我们没有MySQL中的数组。这个问题有两个解决方案。
- en: One solution could be to set the ID of the sale as a normal integer field and
    not as a primary key. In this way, we would be able to insert several rows to
    the `sales` table, one for each borrowed book. However, this solution is less
    than ideal as we miss the opportunity of defining a very good primary key because
    it has the `sales` ID. Also, we are duplicating the data about the customer and
    date since they will always be the same.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 一种可能的解决方案是将销售的ID设置为普通整数字段，而不是主键。这样，我们就能向`sales`表中插入多行，每行对应一本借阅的书籍。然而，这个解决方案并不理想，因为我们错过了定义一个非常好的主键的机会，因为这个主键有`sales`
    ID。此外，我们重复了关于客户和日期的数据，因为它们总是相同的。
- en: 'The second solution, the one that we will implement, is the creation of a separated
    table that acts as a "list". We will still have our `sales` table, which will
    contain the ID of the sale as a primary key, the customer ID as a foreign key,
    and the dates. However, we will create a second table that we could name `sale_book`,
    and we will define there the ID of the sale, the ID of the book, and the amount
    of books of the same copy that the customer bought. In this way, we will have
    at once the information about the customer and date, and we will be able to insert
    as many rows as needed in our `sale_book` list-table without duplicating any data.
    Let''s take a look at how we would create these:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个解决方案，我们将要实施的解决方案，是创建一个作为“列表”的独立表。我们仍然会有我们的`sales`表，它将包含作为主键的销售ID，作为外键的客户ID和日期。然而，我们将创建一个名为`sale_book`的第二张表，并在其中定义销售ID、书籍ID和顾客购买的同一副本的书籍数量。这样，我们就可以同时拥有关于客户和日期的信息，并且我们可以在我们的`sale_book`列表表中插入所需的所有行，而不重复任何数据。让我们看看我们将如何创建这些表：
- en: '[PRE12]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Keep in mind that you should always create the `sales` table first because if
    you create the `sale_book` table with a foreign key first, referencing a table
    that does not exist yet, MySQL will complain.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，你应该始终首先创建`sales`表，因为如果你首先创建带有外键的`sale_book`表，引用一个尚未存在的表，MySQL会抱怨。
- en: 'We created three new tables in this section, and they are interrelated. It
    is a good time to update the diagram of tables. Note that we link the fields with
    the tables when there is a foreign key defined. Take a look:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们创建了三个新的表，它们是相互关联的。现在是更新表图的好时机。注意，当定义外键时，我们将字段与表相链接。看看：
- en: '![Foreign keys](img/00026.jpeg)'
  id: totrans-125
  prefs: []
  type: TYPE_IMG
  zh: '![外键](img/00026.jpeg)'
- en: Unique keys
  id: totrans-126
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 唯一键
- en: As you know, primary keys are extremely useful as they provide several features
    with them. One of these is that the field has to be unique. However, you can define
    only one primary key per table, even though you might have several fields that
    are unique. In order to amend this limitation, MySQL incorporates **unique keys**.
    Their job is to make sure that the field is not repeated in multiple rows, but
    they do not come with the rest of the functionalities of primary keys, such as
    being autoincremental. Also, unique keys can be null.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所知，主键非常实用，因为它们提供了几个功能。其中之一是字段必须是唯一的。然而，每个表只能定义一个主键，即使你可能有几个唯一的字段。为了克服这种限制，MySQL引入了**唯一键**。它们的作用是确保字段在多行中不会重复，但它们不包含主键的其他功能，例如自动递增。此外，唯一键可以是空的。
- en: 'Our `book` and `customer` tables contain good candidates for unique keys. Books
    can potentially have the same title, and surely, there will be more than one book
    by the same author. However, they also have an ISBN which is unique; two different
    books should not have the same ISBN. In the same way, even if two customers were
    to have the same name, their e-mail addresses will be always different. Let''s
    add the two keys with the `ALTER TABLE` command, though you can also add them
    when creating the table as we did with foreign keys, as follows:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的`书籍`和`客户`表包含适合作为唯一键的候选字段。书籍可能具有相同的标题，而且肯定会有不止一本书是由同一作者所著。然而，它们还有一个独一无二的ISBN；两本不同的书不应该有相同的ISBN。同样，即使两个客户有相同的名字，他们的电子邮件地址也总是不同的。让我们使用`ALTER
    TABLE`命令添加这两个键，尽管你也可以在创建表时添加它们，就像我们处理外键时那样，如下所示：
- en: '[PRE13]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
