- en: Chapter 5. Using Databases
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Data is probably the cornerstone of most web applications. Sure, your application
    has to be pretty, fast, error-free, and so on, but if something is essential to
    users, it is what data you can manage for them. From this, we can extract that
    managing data is one of the most important things you have to consider when designing
    your application.
  prefs: []
  type: TYPE_NORMAL
- en: Managing data implies not only storing read-only files and reading them when
    needed, as we were doing so far, but also adding, fetching, updating, and removing
    individual pieces of information. For this, we need a tool that categorizes our
    data and makes these tasks easier for us, and this is when databases come into
    play.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, you will learn about:'
  prefs: []
  type: TYPE_NORMAL
- en: Schemas and tables
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Manipulating and querying data
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using PDO to connect your database with PHP
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Indexing your data
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Constructing complex queries in joining tables
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introducing databases
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Databases are tools to manage data. The basic functions of a database are inserting,
    searching, updating, and deleting data, even though most database systems do more
    than this. Databases are classified into two different categories depending on
    how they store data: relational and nonrelational databases.'
  prefs: []
  type: TYPE_NORMAL
- en: Relational databases structure data in a very detailed way, forcing the user
    to use a defined format and allowing the creation of connections—that is, relations—between
    different pieces of information. Nonrelational databases are systems that store
    data in a more relaxed way, as though there were no apparent structure. Even though
    with these very vague definitions you could assume that everybody would like to
    use relational databases, both systems are very useful; it just depends on how
    you want to use them.
  prefs: []
  type: TYPE_NORMAL
- en: In this book, we will focus on relational databases as they are widely used
    in small web applications, in which there are not huge amounts of data. The reason
    is that usually the application contains data that is interrelated; for example,
    our application could store sales, which are composed of customers and books.
  prefs: []
  type: TYPE_NORMAL
- en: MySQL
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: MySQL has been the favorite choice of PHP developers for quite a long time.
    It is a relational database system that uses SQL as the language to communicate
    with the system. SQL is used in quite a few other systems, which makes things
    easier in case you need to switch databases or just need to understand an application
    with a different database than the one you are used to. The rest of the chapter
    will be focused on MySQL, but it will be helpful for you even if you choose a
    different SQL system.
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to use MySQL, you need to install two applications: the server and
    the client. You might remember server-client applications from [Chapter 2](part0019_split_000.html#I3QM2-edcc22b134104d5db0bf3aa086c86851
    "Chapter 2. Web Applications with PHP"), *Web Applications with PHP*. The MySQL
    server is a program that listens for instructions or queries from clients, executes
    them, and returns a result. You need to start the server in order to access the
    database; take a look at [Chapter 1](part0014_split_000.html#DB7S1-edcc22b134104d5db0bf3aa086c86851
    "Chapter 1. Setting Up the Environment"), *Setting Up the Environment*, on how
    to do this. The client is an application that allows you to construct instructions
    and send them to the server, and it is the one that you will use.'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**GUI versus command line**'
  prefs: []
  type: TYPE_NORMAL
- en: '**The Graphical User Interface** (**GUI**) is very common when using a database.
    It helps you in constructing instructions, and you can even manage data without
    them using just visual tables. On the other hand, command-line clients force you
    to write all the commands by hand, but they are lighter than GUIs, faster to start,
    and force you to remember how to write SQL, which you need when you write your
    applications in PHP. Also, in general, almost any machine with a database will
    have a MySQL client but might not have a graphical application.'
  prefs: []
  type: TYPE_NORMAL
- en: You can choose the one that you are more comfortable with as you will usually
    work with your own machine. However, keep in mind that a basic knowledge of the
    command line will save your life on several occasions.
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to connect the client with a server, you need to provide some information
    on where to connect and the credentials for the user to use. If you do not customize
    your MySQL installation, you should at least have a root user with no password,
    which is the one we will use. You could think that this seems to be a horrible
    security hole, and it might be so, but you should not be able to connect using
    this user if you do not connect from the same machine on which the server is.
    The most common arguments that you can use to provide information when starting
    the client are:'
  prefs: []
  type: TYPE_NORMAL
- en: '`-u <name>`: This specifies the user—in our case, `root`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-p<password>`: Without a space, this specifies the password. As we do not
    have a password for our user, we do not need to provide this.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-h <host>`: This specifies where to connect. By default, the client connects
    to the same machine. As this is our case, there is no need to specify any. If
    you had to, you could specify either an IP address or a hostname.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`<schema name>`: This specifies the name of the schema to use. We will explain
    in a bit what this means.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'With these rules, you should be able to connect to your database with the `mysql
    -u root` command. You should get an output very similar to the following one:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The terminal will show you the version of the server and some useful information
    about how to use the client. From now on, the command line will start with `mysql>`
    instead of your normal prompt, showing you that you are using the MySQL client.
    In order to execute queries, just type the query, end it with a semicolon, and
    press *Enter*. The client will send the query to the server and will show the
    result of it. To exit the client, you can either type `\q` and press *Enter* or
    press *Ctrl* + *D*, even though this last option will depend on your operating
    system.
  prefs: []
  type: TYPE_NORMAL
- en: Schemas and tables
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Relational database systems usually have the same structure. They store data
    in different databases or **schemas**, which separate the data from different
    applications. These schemas are just collections of **tables**. Tables are definitions
    of specific data structures and are composed of **fields**. A field is a basic
    data type that defines the smallest component of information as though they were
    the atoms of the data. So, schemas are group of tables that are composed of fields.
    Let's look at each of these elements.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding schemas
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As defined before, schemas or databases— in MySQL, they are synonyms—are collections
    of tables with a common context, usually belonging to the same application. Actually,
    there are no restrictions around this, and you could have several schemas belonging
    to the same application if needed. However, for small web applications, as it
    is our case, we will have just one schema.
  prefs: []
  type: TYPE_NORMAL
- en: Your server probably already has some schemas. They usually contain the metadata
    needed for MySQL in order to operate, and we highly recommend that you do not
    modify them. Instead, let's just create our own schema. Schemas are quite simple
    elements, and they only have a mandatory name and an optional charset. The name
    identifies the schema, and the charset defines which type of codification or "alphabet"
    the strings should follow. As the default charset is `latin1`, if you do not need
    to change it, you do not need to specify it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Use `CREATE SCHEMA` followed by the name of the schema in order to create the
    schema that we will use for our bookstore. The name has to be representative,
    so let''s name it `bookstore`. Remember to end your line with a semicolon. Take
    a look at the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'If you need to remember how a schema was created, you can use `SHOW CREATE
    SCHEMA` to see its description, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, we ended the query with `\G` instead of a semicolon. This tells
    the client to format the response in a different way than the semicolon does.
    When using a command of the `SHOW CREATE` family, we recommend that you end it
    with `\G` to get a better understanding.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Should you use uppercase or lowercase?**'
  prefs: []
  type: TYPE_NORMAL
- en: When writing queries, you might note that we used uppercase for keywords and
    lowercase for identifiers, such as names of schemas. This is just a convention
    widely used in order to make it clear what is part of SQL and what is your data.
    However, MySQL keywords are case-insensitive, so you could use any case indistinctively.
  prefs: []
  type: TYPE_NORMAL
- en: 'All data must belong to a schema. There cannot be data floating around outside
    all schemas. This way, you cannot do anything unless you specify the schema you
    want to use. In order to do this, just after starting your client, use the `USE`
    keyword followed by the name of the schema. Optionally, you could tell the client
    which schema to use when connecting to it, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'If you do not remember what the name of your schema is or want to check which
    other schemas are in your server, you can run the `SHOW SCHEMAS;` command to get
    a list of them, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Database data types
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As in PHP, MySQL also has data types. They are used to define which kind of
    data a field can contain. As in PHP, MySQL is quite flexible with data types,
    transforming them from one type to the other if needed. There are quite a few
    of them, but we will explain the most important ones. We highly recommend that
    you visit the official documentation related to data types at [http://dev.mysql.com/doc/refman/5.7/en/data-types.html](http://dev.mysql.com/doc/refman/5.7/en/data-types.html)
    if you want to build applications with more complex data structures.
  prefs: []
  type: TYPE_NORMAL
- en: Numeric data types
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Numeric data can be categorized as integers or decimal numbers. For integers,
    MySQL uses the `INT` data type even though there are versions to store smaller
    numbers, such as `TINYINT`, `SMALLINT`, or `MEDIUMINT`, or bigger numbers, such
    as `BIGINT`. The following table shows what the sizes of the different numeric
    types are, so you can choose which one to use depending on your situation:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Type | Size/precision |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `TINYINT` | -128 to 127 |'
  prefs: []
  type: TYPE_TB
- en: '| `SMALLINT` | -32,768 to 32,767 |'
  prefs: []
  type: TYPE_TB
- en: '| `MEDIUMINT` | -8,388,608 to 8,388,607 |'
  prefs: []
  type: TYPE_TB
- en: '| `INT` | -2,147,483,648 to 2,147,483,647 |'
  prefs: []
  type: TYPE_TB
- en: '| `BIGINT` | -9,223,372,036,854,775,808 to 9,223,372,036,854,775,807 |'
  prefs: []
  type: TYPE_TB
- en: Numeric types can be defined as signed by default or unsigned; that is, you
    can allow or not allow them to contain negative values. If a numeric type is defined
    as `UNSIGNED`, the range of numbers that it can take is doubled as it does not
    need to save space for negative numbers.
  prefs: []
  type: TYPE_NORMAL
- en: 'For decimal numbers we have two types: approximate values, which are faster
    to process but are not exact sometimes, and exact values that give you exact precision
    on the decimal value. For approximate values or the floating-point type, we have
    `FLOAT` and `DOUBLE`. For exact values or the fixed-point type we have `DECIMAL`.'
  prefs: []
  type: TYPE_NORMAL
- en: MySQL allows you to specify the number of digits and decimal positions that
    the number can take. For example, to specify a number that can contains five digits
    and up to two of them can be decimal, we will use the `FLOAT(5,2)` notation. This
    is useful as a constraint, as you will note when we create tables with prices.
  prefs: []
  type: TYPE_NORMAL
- en: String data types
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Even though there are several data types that allow you to store from single
    characters to big chunks of text or binary code, it is outside the scope of this
    chapter. In this section, we will introduce you to three types: `CHAR`, `VARCHAR`,
    and `TEXT`.'
  prefs: []
  type: TYPE_NORMAL
- en: '`CHAR` is a data type that allows you to store an exact number of characters.
    You need to specify how long the string will be once you define the field, and
    from this point on, all values for this field have to be of this length. One possible
    usage in our applications could be when storing the ISBN of the book as we know
    it is always 13 characters long.'
  prefs: []
  type: TYPE_NORMAL
- en: '`VARCHAR` or variable char is a data type that allows you to store strings
    up to 65,535 characters long. You do not need to specify how long they need to
    be, and you can insert strings of different lengths without an issue. Of course,
    the fact that this type is dynamic makes it slower to process compared with the
    previous one, but after a few times you know how long a string will always be.
    You could tell MySQL that even if you want to insert strings of different lengths,
    the maximum length will be a determined number. This will help its performance.
    For example, names are of different lengths, but you can safely assume that no
    name will be longer than 64 characters, so your field could be defined as `VARCHAR(64)`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, `TEXT` is a data type for really big strings. You could use it if
    you want to store long comments from users, articles, and so on. As with `INT`,
    there are different versions of this data type: `TINYTEXT`, `TEXT`, `MEDIUMTEXT`,
    and `LONGTEXT`. Even if they are very important in almost any web application
    with user interaction, we will not use them in ours.'
  prefs: []
  type: TYPE_NORMAL
- en: List of values
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In MySQL, you can force a field to have a set of valid values. There are two
    types of them: `ENUM`, which allows exactly one of the possible predefined values,
    and `SET`, which allows any number of the predefined values.'
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, in our application, we have two types of customers: basic and
    premium. If we want to store our customers in a database, there is a chance that
    one of the fields will be the type of customer. As a customer has to be either
    basic or premium, a good solution would be to define the field as an enum as `ENUM("basic",
    "premium")`. In this way, we will make sure that all customers stored in our database
    will be of a correct type.'
  prefs: []
  type: TYPE_NORMAL
- en: Although enums are quite common to use, the use of sets is less widespread.
    It is usually a better idea to use an extra table to define the values of the
    list, as you will note when we talk about foreign keys in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Date and time data types
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Date and time types are the most complex data types in MySQL. Even though the
    idea is simple, there are several functions and edge cases around these types.
    We cannot go through all of them, so we will just explain the most common uses,
    which are the ones we will need for our application.
  prefs: []
  type: TYPE_NORMAL
- en: '`DATE` stores dates—that is, a combination of day, month, and year. `TIME`
    stores times—that is, a combination of hour, minute, and second. `DATETIME` are
    data types for both date and time. For any of these data types, you can provide
    just a string specifying what the value is, but you need to be careful with the
    format that you use. Even though you can always specify the format that you are
    entering the data in, you can just enter the dates or times in the default format—for
    example, 2014-12-31 for dates, 14:34:50 for time, and 2014-12-31 14:34:50 for
    the date and time.'
  prefs: []
  type: TYPE_NORMAL
- en: A fourth type is `TIMESTAMP`. This type stores an integer, which is the representation
    of the seconds from January 1, 1970, which is also known as the Unix timestamp.
    This is a very useful type as in PHP, it is really easy to get the current Unix
    timestamp with the `now()` function, and the format for this data type is always
    the same, so it is safer to work with it. The downside is that the range of dates
    that it can represent is limited as compared to other types.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are some functions that help you manage these types. These functions
    extract specific parts of the whole value, return the value with a different format,
    add or subtract dates, and so on. Let''s take a look at a short list of them:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Function name | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `DAY()`, `MONTH()`, and `YEAR()` | Extracts the specific value for the day,
    month, or year from the `DATE` or `DATETIME` provided value. |'
  prefs: []
  type: TYPE_TB
- en: '| `HOUR()`, `MINUTE()`, and `SECOND()` | Extracts the specific value for the
    hour, minute, or second from the `TIME` or `DATETIME` provided value. |'
  prefs: []
  type: TYPE_TB
- en: '| `CURRENT_DATE()` and `CURRENT_TIME()` | Returns the current date or current
    time. |'
  prefs: []
  type: TYPE_TB
- en: '| `NOW()` | Returns the current date and time. |'
  prefs: []
  type: TYPE_TB
- en: '| `DATE_FORMAT()` | Returns the `DATE`, `TIME` or `DATETIME` value with the
    specified format. |'
  prefs: []
  type: TYPE_TB
- en: '| `DATE_ADD()` | Adds the specified interval of time to a given date or time
    type. |'
  prefs: []
  type: TYPE_TB
- en: Do not worry if you are confused on how to use any of these functions; we will
    use them during the rest of the book as part of our application. Also, an extensive
    list of all the types can be found at [http://dev.mysql.com/doc/refman/5.7/en/date-and-time-functions.html](http://dev.mysql.com/doc/refman/5.7/en/date-and-time-functions.html).
  prefs: []
  type: TYPE_NORMAL
- en: Managing tables
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now that you understand the different types of data that fields can take, it
    is time to introduce tables. As defined in the *Schemas and tables* section, a
    table is a collection of fields that defines a type of information. You could
    compare it with OOP and think of tables as classes, fields being their properties.
    Each instance of the class would be a row on the table.
  prefs: []
  type: TYPE_NORMAL
- en: 'When defining a table, you have to declare the list of fields that the table
    contains. For each field, you need to specify its name, its type, and some extra
    information depending on the type of the field. The most common are:'
  prefs: []
  type: TYPE_NORMAL
- en: '`NOT NULL`: This is used if the field cannot be null—that is, if it needs a
    concrete valid value for each row. By default, a field can be null.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`UNSIGNED`: As mentioned earlier, this is used to forbid the use of negative
    numbers in this field. By default, a numeric field accepts negative numbers.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`DEFAULT <value>`: This defines a default value in case the user does not provide
    any. Usually, the default value is null if this clause is not specified.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Table definitions also need a name, as with schemas, and some optional attributes.
    You can define the charset of the table or its engine. Engines can be a quite
    large topic to cover, but for the scope of this chapter, let's just note that
    we should use the InnoDB engine if we need strong relationships between tables.
    For more advanced readers, you can read more about MySQL engines at [https://dev.mysql.com/doc/refman/5.0/en/storage-engines.html](https://dev.mysql.com/doc/refman/5.0/en/storage-engines.html).
  prefs: []
  type: TYPE_NORMAL
- en: 'Knowing this, let''s try to create a table that will keep our books. The name
    of the table should be `book`, as each row will define a book. The fields could
    have the same properties the `Book` class has. Let''s take a look at how the query
    to construct the table would look:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can note, we can add more new lines until we end the query with a semicolon.
    With this, we can format the query in a way that looks more readable. MySQL will
    let us know that we are still writing the same query showing the `->` prompt.
    As this table contains five fields, it is very likely that we will need to refresh
    our minds from time to time as we will forget them. In order to display the structure
    of the table, you could use the `DESC` command, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'We used `SMALLINT` for `stock` as it is very unlikely that we will have more
    than thousands of copies of the same book. As we know that ISBN is 13 characters
    long, we enforced this when defining the field. Finally, both `stock` and `price`
    are unsigned as negative values do not make sense. Let''s now create our `customer`
    table via the following script:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'We already anticipated the use of enum for the field type as when designing
    classes, we could draw a diagram identifying the content of our database. On this,
    we could show the tables and their fields. Let''s take a look at how the diagram
    of tables would look so far:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Managing tables](img/00025.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Note that even if we create tables similar to our classes, we will not create
    a table for `Person`. The reason is that databases store data, and there isn't
    any data that we could store for this class as the `customer` table already contains
    everything we need. Also, sometimes, we may create tables that do not exist as
    classes on our code, so the class-table relationship is a very flexible one.
  prefs: []
  type: TYPE_NORMAL
- en: Keys and constraints
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we have our main tables defined, let's try to think about how the data
    inside would look. Each row inside a table would describe an object, which may
    be either a book or a customer. What would happen if our application has a bug
    and allows us to create books or customers with the same data? How will the database
    differentiate them? In theory, we will assign IDs to customers in order to avoid
    these scenarios, but how do we enforce that the ID not be repeated?
  prefs: []
  type: TYPE_NORMAL
- en: 'MySQL has a mechanism that allows you to enforce certain restrictions on your
    data. Other than attributes such as `NOT NULL` or `UNSIGNED` that you already
    saw, you can tell MySQL that certain fields are more special than others and instruct
    it to add some behavior to them. These mechanisms are called **keys**, and there
    are four types: primary key, unique key, foreign key, and index. Let''s take a
    closer look at them.'
  prefs: []
  type: TYPE_NORMAL
- en: Primary keys
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Primary keys are fields that identify a unique row from a table. There cannot
    be two of the same value in the same table, and they cannot be null. Adding a
    primary key to a table that defines *objects* is almost a must as it will assure
    you that you will always be able to differentiate two rows by this field.
  prefs: []
  type: TYPE_NORMAL
- en: Another part that makes primary keys so attractive is their ability to set the
    primary key as an autoincremental numeric value; that is, you do not have to assign
    a value to the ID, and MySQL will just pick up the latest inserted ID and increment
    it by 1, as we did with our `Unique` trait. Of course, for this to happen, your
    field has to be an integer data type. In fact, we highly recommend that you always
    define your primary key as an integer, even if the real-life object does not really
    have this ID at all. The reason is that you should search a row by this numeric
    ID, which is unique, and MySQL will add some performance improvements that come
    by setting the field as a key.
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, let''s add an ID to our `book` table. In order to add a new field, we
    need to alter our table. There is a command that allows you to do this: `ALTER
    TABLE`. With this command, you can modify the definition of any existing field,
    add new ones, or remove existing ones. As we add the field that will be our primary
    key and be autoincremental, we can add all these modifiers to the field definition.
    Execute the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Note `FIRST` at the end of the command. When adding new fields, if you want
    them to appear on a different position than at the end of the table, you need
    to specify the position. It could be either `FIRST` or `AFTER <other field>`.
    For convenience, the primary key of a table is the first of its fields.
  prefs: []
  type: TYPE_NORMAL
- en: 'As the table customer already has an ID field, we do not have to add it again
    but rather modify it. In order to do this, we will just use the `ALTER TABLE`
    command with the `MODIFY` option, specifying the new definition of an already
    existing field, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Foreign keys
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let's imagine that we need to keep track of the borrowed books. The table should
    contain the borrowed book, who borrowed it, and when it was borrowed. So, what
    kind of data would you use to identify the book or the customer? Would you use
    the title or the name? Well, we should use something that identifies a unique
    row from these tables, and this "something" is the primary key. With this action,
    we will eliminate the change of using a reference that can potentially point to
    two or more rows at the same time.
  prefs: []
  type: TYPE_NORMAL
- en: We could then create a table that contains `book_id` and `customer_id` as numeric
    fields, containing the IDs that reference these two tables. As the first approach,
    it makes sense, but we can find some weaknesses. For example, what happens if
    we insert wrong IDs and they do not exist in `book` or `customer`? We could have
    some code in our PHP side to make sure that when fetching information from `borrowed_books`,
    we only displayed the information that is correct. We could even have a routine
    that periodically checks for wrong rows and removes them, solving the issue of
    having wrong data wasting space in the disk. However, as with the `Unique` trait
    versus adding primary keys in MySQL, it is usually better to allow the database
    system to manage these things as the performance will usually be better, and you
    do not need to write extra code.
  prefs: []
  type: TYPE_NORMAL
- en: MySQL allows you to create keys that enforce references to other tables. These
    are called **foreign keys**, and they are the primary reason for which we were
    forced to use the InnoDB table engine instead of any other. A foreign key defines
    and enforces a reference between this field and another row of a different table.
    If the ID supplied for the field with a foreign key does not exist in the referenced
    table, the query will fail. Furthermore, if you have a valid `borrowed_books`
    row pointing to an existing book and you remove the entry from the book table,
    MySQL will complain about it—even though you will be able to customize this behavior
    soon—as this action would leave wrong data in the system. As you can note, this
    is way more useful than having to write code to manage these cases.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s create the `borrowed_books` table with the book, customer references,
    and dates. Note that we have to define the foreign keys after the definition of
    the fields as opposed to when we defined primary keys, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'As with `SHOW CREATE SCHEMA`, you can also check how the table looks. This
    command will also show you information about the keys as opposed to the `DESC`
    command. Let''s take a look at how it would work:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Note two important things here. On one hand, we have two extra keys that we
    did not define. The reason is that when defining a foreign key, MySQL also defines
    the field as a key that will be used to improve performance on the table; we will
    look into this in a moment. The other element to note is the fact that MySQL defines
    names to the keys by itself. This is necessary as we need to be able to reference
    them in case we want to change or remove this key. You can let MySQL name the
    keys for you, or you can specify the names you prefer when creating them.
  prefs: []
  type: TYPE_NORMAL
- en: We are running a bookstore, and even if we allow customers to borrow books,
    we want to be able to sell them. A sale is a very important element that we need
    to track down as customers may want to review them, or you may just need to provide
    this information for taxation purposes. As opposed to borrowing, in which knowing
    the book, customer, and date was more than enough, here, we need to set IDs to
    the sales in order to identify them to the customers.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, this table is more difficult to design than the other ones and not
    just because of the ID. Think about it: do customers buy books one by one? Or
    do they rather buy any number of books at once? Thus, we need to allow the table
    to contain an undefined amount of books. With PHP, this is easy as we would just
    use an array, but we do not have arrays in MySQL. There are two options to this
    problem.'
  prefs: []
  type: TYPE_NORMAL
- en: One solution could be to set the ID of the sale as a normal integer field and
    not as a primary key. In this way, we would be able to insert several rows to
    the `sales` table, one for each borrowed book. However, this solution is less
    than ideal as we miss the opportunity of defining a very good primary key because
    it has the `sales` ID. Also, we are duplicating the data about the customer and
    date since they will always be the same.
  prefs: []
  type: TYPE_NORMAL
- en: 'The second solution, the one that we will implement, is the creation of a separated
    table that acts as a "list". We will still have our `sales` table, which will
    contain the ID of the sale as a primary key, the customer ID as a foreign key,
    and the dates. However, we will create a second table that we could name `sale_book`,
    and we will define there the ID of the sale, the ID of the book, and the amount
    of books of the same copy that the customer bought. In this way, we will have
    at once the information about the customer and date, and we will be able to insert
    as many rows as needed in our `sale_book` list-table without duplicating any data.
    Let''s take a look at how we would create these:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Keep in mind that you should always create the `sales` table first because if
    you create the `sale_book` table with a foreign key first, referencing a table
    that does not exist yet, MySQL will complain.
  prefs: []
  type: TYPE_NORMAL
- en: 'We created three new tables in this section, and they are interrelated. It
    is a good time to update the diagram of tables. Note that we link the fields with
    the tables when there is a foreign key defined. Take a look:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Foreign keys](img/00026.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Unique keys
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As you know, primary keys are extremely useful as they provide several features
    with them. One of these is that the field has to be unique. However, you can define
    only one primary key per table, even though you might have several fields that
    are unique. In order to amend this limitation, MySQL incorporates **unique keys**.
    Their job is to make sure that the field is not repeated in multiple rows, but
    they do not come with the rest of the functionalities of primary keys, such as
    being autoincremental. Also, unique keys can be null.
  prefs: []
  type: TYPE_NORMAL
- en: 'Our `book` and `customer` tables contain good candidates for unique keys. Books
    can potentially have the same title, and surely, there will be more than one book
    by the same author. However, they also have an ISBN which is unique; two different
    books should not have the same ISBN. In the same way, even if two customers were
    to have the same name, their e-mail addresses will be always different. Let''s
    add the two keys with the `ALTER TABLE` command, though you can also add them
    when creating the table as we did with foreign keys, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
