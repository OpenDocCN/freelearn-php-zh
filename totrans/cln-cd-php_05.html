<html><head></head><body>
		<div id="_idContainer010">
			<h1 id="_idParaDest-56" class="chapter-number"><a id="_idTextAnchor055"/>5</h1>
			<h1 id="_idParaDest-57"><a id="_idTextAnchor056"/>Optimizing Your Time and Separating Responsibilities</h1>
			<p>It’s time for a little practice after all that theory! We’ve already seen a lot together: advanced principles on clean code, how to choose the right external libraries for your applications, and how to take advantage of the latest patches of these libraries while not risking making your project explode in mid-air. But we should not forget that there is the word “code” in “clean code” (obviously). In this chapter, we will therefore concentrate a little more on the source code of your application and see the following points:</p>
			<ul>
				<li>Naming conventions and organization of files and folders</li>
				<li>Why is it important to separate responsibilities to respect the “S” of the SOLID principles? What does it bring to you? </li>
				<li>We’ll discover an elegant way to manage responsibility separation with an event system</li>
				<li>And we’ll finish with some polymorphism—namely, abstract classes and interfaces: why, how, and when to use them?</li>
			</ul>
			<h1 id="_idParaDest-58"><a id="_idTextAnchor057"/>Naming and organizational conventions</h1>
			<p>We<a id="_idIndexMarker102"/> must add a disclaimer before anything else. The naming conventions and organizational ideas given in this chapter are not an absolute truth. As we have seen before, the most important thing is to respect the conventions already in place in your project and to be consistent with your team. If you feel it is necessary, it is possible to adapt these rules to your needs. Again, the important thing is to use common sense and logic and to be as clear as possible.</p>
			<p>Let’s first talk about the naming of source files. Obviously, the naming conventions differ from one technology to another (depending on whether you use a certain framework or another, the good practices may change, for example). Nevertheless, we can note some conventions that can be found almost everywhere.</p>
			<h2 id="_idParaDest-59"><a id="_idTextAnchor058"/>Class files and interface files</h2>
			<p><strong class="bold">PHP: Hypertext Preprocessor</strong> (<strong class="bold">PHP</strong>) source files defining a class, an abstract class, or an interface should have the same name as the class or interface in question. For example, the <strong class="source-inline">Foo</strong> class should be defined in a <strong class="source-inline">Foo.php</strong> file. More than a convention, this naming <a id="_idIndexMarker103"/>technique has a real technical interest. Indeed, the autoloading mechanisms of PHP will assume that your file defines a class with the same name. Autoloading<a id="_idIndexMarker104"/> allows PHP to automatically discover the classes defined in your application, and in particular thanks to namespaces (we’ll come back to this in a few moments, as these are directly linked to the organization of files in your project). If you name your files and the classes they define differently, autoloading is likely to<a id="_idIndexMarker105"/> fail and throw an error. The most common naming style across the various languages and the global developer community for<a id="_idIndexMarker106"/> naming classes is <strong class="bold">PascalCase</strong>. This style simply adds a capital letter to the beginning of each word. So, a class named <em class="italic">My super service class</em> would be named <strong class="source-inline">MySuperServiceClass</strong> if we used PascalCase. There are other naming styles—we will see some of them and in which cases they apply.</p>
			<h2 id="_idParaDest-60"><a id="_idTextAnchor059"/>Executables</h2>
			<p>PHP files, being<a id="_idIndexMarker107"/> executable command-line scripts, have a strong tendency to be named in lowercase. The <strong class="bold">PHPUnit</strong> test framework is a<a id="_idIndexMarker108"/> good example. In practice, it is used as a system command in a terminal. In reality, it is simply a PHP script. We use the hyphen as a word separator. This naming style is<a id="_idIndexMarker109"/> called <strong class="bold">kebab-case</strong>. This is the naming style that is mostly used by command-line programs. The well-known <strong class="source-inline">apt-get</strong>, <strong class="source-inline">docker-compose</strong>, and <strong class="source-inline">git cherry-pick</strong> are perfect ambassadors. Nothing prevents you from naming your executable file in another way, and everything will work fine. However, by naming your command-line applications <a id="_idIndexMarker110"/>written in PHP this way, you provide a uniform <strong class="bold">command-line interface</strong> (<strong class="bold">CLI</strong>) experience with the vast majority of commands. This is exactly what we want when we develop a command-line application in PHP: for it to blend in with more <em class="italic">traditional</em> system commands.</p>
			<h2 id="_idParaDest-61"><a id="_idTextAnchor060"/>Web assets and resources</h2>
			<p>There is <a id="_idIndexMarker111"/>another case where the <a id="_idIndexMarker112"/>kebab-case style is used, which is mainly for public web resources, particularly JavaScript, <strong class="bold">Cascading Style Sheets</strong> (<strong class="bold">CSS</strong>), and <strong class="bold">Hypertext Markup Language</strong> (<strong class="bold">HTML</strong>) files. Indeed, kebab-case is a <a id="_idIndexMarker113"/>naming style easily readable and <a id="_idIndexMarker114"/>understandable by everyone, whether you are in the technical field or not. Moreover, search engines are better able to understand the semantics of your resource by using this notation. It is therefore <a id="_idIndexMarker115"/>essential if you want to do <strong class="bold">search engine optimization</strong> (<strong class="bold">SEO</strong>). Here’s an example: it’s much more <a id="_idIndexMarker116"/>common—even natural—to see a <strong class="bold">Uniform Resource Locator</strong> (<strong class="bold">URL</strong>) such<a id="_idIndexMarker117"/> as <strong class="source-inline">/contact-us</strong>, compared to something such as <strong class="source-inline">/contactus</strong> or <strong class="source-inline">/ContactUs</strong>. This can be particularly important if you must work on frontend files.</p>
			<h2 id="_idParaDest-62"><a id="_idTextAnchor061"/>Naming classes, interfaces, and methods</h2>
			<p>As we have seen in the previous chapters, abbreviations should be banned from your code. <strong class="bold">Integrated development environments</strong> (<strong class="bold">IDEs</strong>) are nowadays<a id="_idIndexMarker118"/> powerful enough to autocomplete the names of the classes and methods you use. Therefore, it is not useful to <a id="_idIndexMarker119"/>shorten repeatedly the names of your classes, methods, and variables as this only brings about confusion. This is also why your abstract classes should start with the prefix <strong class="source-inline">Abstract</strong> (for example, <strong class="source-inline">AbstractMailer</strong>) and your interfaces should end with the suffix <strong class="source-inline">Interface</strong> (for example, <strong class="source-inline">MailerInterface</strong>). This makes the name very slightly longer, but there is no confusion in their use. Their purpose is clear, defined, and visible immediately. Don’t be <a id="_idIndexMarker120"/>afraid to give your classes long names if it is necessary for their understanding. <strong class="source-inline">AbstractWebDeveloperConsoleStreamWrapperExtension</strong> may seem extremely long for a class name, but it is immediately clear what it is for in a project context, without having to ask too many questions. Again, with the autocomplete feature of your IDE, you will be able to use it within seconds by typing the first few letters. The same goes for your attribute and method names. Be explicit.</p>
			<p>Talking about attribute and<a id="_idIndexMarker121"/> method naming, we tend to<a id="_idIndexMarker122"/> prefer the <strong class="bold">camelCase</strong> naming style. The principle is the same as for PascalCase (that is, put a capital letter at the beginning of each word), except that the first letter of the name is in lowercase (for example, <strong class="source-inline">myGreatMethod</strong>). Some languages <a id="_idIndexMarker123"/>use PascalCase for naming methods such as C#. Let’s be honest—there is no real justification or argument for this, and both naming styles are actually equal. For once, it is really a convention—a language-specific habit.</p>
			<h2 id="_idParaDest-63"><a id="_idTextAnchor062"/>Naming folders</h2>
			<p>The<a id="_idIndexMarker124"/> naming conventions for folders are similar to those for files. PascalCase is mostly<a id="_idIndexMarker125"/> used for folders. Other naming styles can also be used for publicly exposed folders, such as web resources. You should not hesitate to create a large tree structure and give it meaning. Therefore, folders named simply <strong class="source-inline">Manager</strong>, <strong class="source-inline">Service</strong>, or <strong class="source-inline">Wrapper</strong> are to be avoided. These terms are too generic and do not allow an easy understanding of what they define. We prefer more explicit variants, such as <strong class="source-inline">Mail</strong> and its subfolders <strong class="source-inline">Provider</strong>, <strong class="source-inline">Logger</strong>, and so on. These subfolders can have more generic names, being contained in a folder whose name defines a context: a domain. A clever way to find your way around is to use folders to separate your source code into different domains. Your application will be better sliced and your architecture clear. What concerns the same theme will be in the same place. You will be much more efficient as this habit becomes natural. Many open source projects and libraries use this way of slicing their sources. So, you will be able to browse not only your own code but also the code of others. It is sometimes extremely complicated and time-consuming to find the right name for an element, whether it is a class, a file, a variable, or anything else. This step is, however, particularly important and should not be neglected. Be careful not to say to yourself: “I put a name that is not necessarily very clear, but I will change it later.” Chances are that you will forget it, and technical debt will be brought in without you even realizing it.</p>
			<h1 id="_idParaDest-64"><a id="_idTextAnchor063"/>Separating responsibilities</h1>
			<p>Let’s see what the separation of responsibilities<a id="_idIndexMarker126"/> in the code consists of, to make it cleaner, understandable, maintainable, and extensible. This is the first point of the SOLID principles. In the second chapter, this is how we defined the principle of single responsibility: “<em class="italic">It means that a class in your code must respond to only one task.</em>”</p>
			<p>As a reminder, SOLID <a id="_idIndexMarker127"/>is a set of known clean-code rules that, when applied together, will make your code much clearer and more accurate. Rather than trying to follow the five principles described by each of the SOLID caps to the letter, it is more important to have a global idea of all this in mind when you code.</p>
			<p>The first<a id="_idIndexMarker128"/> step to respect this is, in fact... naming, as we just saw! Indeed, by naming a class properly, clearly, and, above all, precisely, you are already making sure that it doesn’t become a mess where you put a little bit of everything that you can think of. And it is for this very reason that it is necessary not to name your methods with too generic terms such as <strong class="source-inline">Manager</strong> and <strong class="source-inline">Service</strong>. This leads to a big problem: if we end up with a class named <strong class="source-inline">EmailManager</strong>, we will obviously all have as a first thought to add all our next methods that deal with managing emails. And that’s how the chaos begins. That’s why we will prefer to create classes such as <strong class="source-inline">EmailFactory</strong>, <strong class="source-inline">AbstractEmailSender</strong>, and so on in order to absolutely avoid having classes with hundreds of different methods.</p>
			<p>We start to understand better this principle of<a id="_idIndexMarker129"/> single responsibility. Let’s repeat: the goal is not to create classes with a single method in them. It doesn’t make sense. You must split it up intelligently. There is no general rule for splitting classes. The right way to split a class will come naturally with experience and it will come by itself. If it helps you, you can see folders as domains, and the files as subdomains. Using the next examples, we have a domain (or folder) that would be named <strong class="source-inline">Email</strong>, and subdomains dedicated to specific tasks: creating an email, defining a base class to send an email with a specific email provider, and so on. We can go even further in this separation of responsibilities. Indeed, tools exist to help us solve this problem in an effortless way. We are going to discover (or rediscover!) event dispatching.</p>
			<h2 id="_idParaDest-65"><a id="_idTextAnchor064"/>Event dispatching</h2>
			<p>Event dispatching<a id="_idIndexMarker130"/> is usually implemented thanks to the Observer and Mediator design patterns, as is the case in Symfony’s <strong class="source-inline">EventDispatcher</strong> component. This <a id="_idIndexMarker131"/>information is just for general knowledge. Indeed, design patterns can seem obscure, even scary at first. Moreover, explaining them deserves a book of its own. So, we’re going to vulgarize all this without talking about design patterns. Moreover, we are not going to implement an event dispatcher: it is about understanding how it can help us.</p>
			<p>Very simply, the principle of event dispatching is to notify all parties interested in the change of state of a particular entity when it happens. The parties will notify a central mediator by saying: “I’m interested in knowing when this particular event occurs; notify me when it does because I have things to do if it happens.” The mediator will then retain this information. When said event occurs, the mediator will then go through the list of parties interested in it and say: “The event just happened; do what you have to do.” Taking this a step further, it is even possible that the interested parties will declare a priority to go before everyone else if necessary. Be careful—we are talking about synchronous events, which is to say that the parties interested in the event will execute one by one, following the others, and not in parallel. Asynchronous event management is a whole other story.</p>
			<p>Event dispatching is <a id="_idIndexMarker132"/>as simple as that. But then, how will it help us reinforce our principle of single responsibility? Let’s look at a concrete example: a user deletes their account from your application. You then need to do two tasks, as follows:</p>
			<ul>
				<li>Delete the account from the database</li>
				<li>Send a last email to the user to say a sad goodbye</li>
			</ul>
			<p>So, we will naturally create a service such as <strong class="source-inline">UserRemover</strong>, which will perform these two tasks in a row. It works very well. <strong class="source-inline">UserRemover</strong> is an explicit name that defines a very precise task. No problem so far. Then, one day, your application gains popularity. You want to send an email to the administrators to notify them that the user has left. Our <strong class="source-inline">UserRemover</strong> class ends up deleting data and sending two emails, both with very specific content and recipients. </p>
			<p>Later on, you want to give the user the possibility to delete their account to respect the <strong class="bold">General Data Protection Regulation</strong> (<strong class="bold">GDPR</strong>) because<a id="_idIndexMarker133"/> you are based in Europe. Only, you want to have accurate statistics and keep anonymized data of the user to respect their choice to disappear from your application while having the possibility to exploit their anonymous data to improve your product. You then have an <strong class="source-inline">UserRemover</strong> service<a id="_idIndexMarker134"/> that actually removes nothing, sends emails, and maybe many other tasks. We have a real problem: the class doesn’t do what it is supposed to do, and it is likely that it is now thousands of lines long and has dozens of methods.</p>
			<p>Things would have been hugely different if you had used <a id="_idIndexMarker135"/>event dispatching from the beginning. Here is an example of a resolution. When a user wants to leave your application, you will dispatch an event named <strong class="source-inline">UserRemovalRequestEvent</strong>. Then, as your application grows, you will create parties interested in this event: event listeners. We will have one per task, as follows:</p>
			<ul>
				<li>A listener to remove data from the database</li>
				<li>A listener for the goodbye mail to the user</li>
				<li>A listener for the mail to the administrators</li>
			</ul>
			<p>What about anonymization? Nothing simpler: we will create a listener for this task too, and we will “unplug” the listener for deleting data. So, we have one class per task. Each class has its own unique responsibility (send an email to the administrators, anonymize data, and so on). If in the future you need to add a task, you will create a new class (or listener) with a specific task, without ever touching the other classes. The code is then clean and extremely extensible. The classes remain well-named and concise. If a task is obsolete, you can simply remove it from the list of parties interested in the event in question. The principle of single responsibility is respected.</p>
			<p>If you want to use a ready-to-use event dispatcher, we recommend using the <strong class="source-inline">symfony/event-dispatcher</strong> package. This is exactly the component that is used in the framework for its operation. It is very robust and efficient and has been proven for several years.</p>
			<h1 id="_idParaDest-66"><a id="_idTextAnchor065"/>Demystifying polymorphism – interfaces and abstract classes</h1>
			<p>As far as the separation of responsibilities is concerned, event dispatching is a concept that is already advanced. You can consider that your level in the world of clean code has increased considerably if you know this mechanism, understand it, and have the chance to use it. All this obviously requires a bit of setup. Either you implement this system by yourself or you use an external library. In the second case, there is obviously a whole learning phase to be included. Either way, this is obviously not the only way to improve the separation of your responsibilities. There is a way that is native to PHP to improve this separation, sometimes not used enough, sometimes misunderstood, and often underestimated. We are talking here<a id="_idIndexMarker136"/> about polymorphism, or vulgarly: abstract classes and interfaces.</p>
			<p>First, why the word <em class="italic">polymorphism</em>? <em class="italic">Poly</em> comes <a id="_idIndexMarker137"/>from the Greek meaning <em class="italic">many</em>, and <em class="italic">morphism</em> means <em class="italic">form</em>/<em class="italic">shape</em>. Abstract classes and interfaces are just one way to<a id="_idIndexMarker138"/> implement polymorphism in code and <strong class="bold">object-oriented programming</strong> (<strong class="bold">OOP</strong>). To simplify things, let’s take only the case of interfaces.</p>
			<h2 id="_idParaDest-67"><a id="_idTextAnchor066"/>Interfaces</h2>
			<p>Interfaces define a <a id="_idIndexMarker139"/>common form/shape for classes that implement them later. They determine the methods that each implementation should define for its case. An implementation must necessarily define all the methods of its interface(s). This is often the reason why we hear the following statement: “an interface is a contract”. We can see it this way: if you implement an interface, you commit to implementing the methods it defines. You have no other alternative.</p>
			<p>This is where the full power of polymorphism<a id="_idIndexMarker140"/> takes place. In your code, you can tell PHP that a so-and-so argument of a method will necessarily be an instance of an object implementing a precise interface. You can manipulate the different methods of this interface and call them. You don’t have to worry about how it will be implemented when it is used: we are not interested in that. As an example, is worth a thousand words, let’s take our mail system. </p>
			<p>You have <strong class="source-inline">MailerInterface</strong> that defines only one method: a method to send a mail. We could name it <strong class="source-inline">sendEmail</strong>. As before, when a user is deleted in your application, the event listener for sending a goodbye mail is called. In this case, what you are interested in is that the mail is simply sent, not the internal workings of the sending. By the way, couldn’t these internal workings be different depending on certain conditions? You don’t have to look far for an example: your main email provider could be down, but you absolutely need to send your message. You then must use another email provider, with a different <strong class="bold">application programming interface</strong> (<strong class="bold">API</strong>), different options, and so on. Without polymorphism, things could get extremely complicated very quickly.</p>
			<p>The solution is to create two implementations of <strong class="source-inline">MailerInterface</strong>, each defining the <strong class="source-inline">sendEmail</strong> method, depending on the email provider used. But the result is the same: the mail is sent. When a user deletes their account, you perform a check to make sure that your main email provider is up and instantiate its implementation. If it is down, you instantiate the backup email provider implementation. On the other hand, in the email sending event listener, you just keep calling the <strong class="source-inline">sendEmail</strong> method defined in <strong class="source-inline">MailerInterface</strong>, without worrying about the rest. The code is clean, clear; responsibilities are separated; you save time. And on top of that, it has become resilient to failure.</p>
			<p>You could do <a id="_idIndexMarker141"/>this with 10, 15, or 20 email providers if you wanted to. The advantage is that if the API of one of the providers changes or you find a bug in your implementation, you only<a id="_idIndexMarker142"/> have to touch the one implementation that is problematic. All the others don’t move, as is the case with the calls that are made to the interface. You considerably reduce the risk of bugs, and your code is much more testable: you can write tests specifically for each implementation. This is much more robust than generalized, endless tests that try to evaluate every possible case! The time saved is exceptional and priceless.</p>
			<h2 id="_idParaDest-68"><a id="_idTextAnchor067"/>Abstract classes</h2>
			<p>And how do abstract classes<a id="_idIndexMarker143"/> fit in all this? We can see these as an intermediate layer between an<a id="_idIndexMarker144"/> interface and its implementations. Although it is obviously not mandatory that an abstract class implements an interface, it is often a clever idea to create an interface on top of an abstract class. Indeed, the latter are more permissive than interfaces: you can partially define the methods that are declared, declare attributes, and decide on the visibility of the methods and attributes of the class (where interfaces only allow <strong class="source-inline">public</strong> visibility and not <strong class="source-inline">private</strong> or <strong class="source-inline">protected</strong>). With an interface, you have a clean contract, without any information that would be here “just in case” and with only the bare essentials if you respect the “I” of the SOLID principles—the interfaces’ segregation. As a reminder and simply put, this principle indicates that an interface should not contain methods that are declared “just in case” and that each one should help to meet the principle of single responsibility. </p>
			<p>Abstract classes allow us to define common behaviors to the classes that extend them and that wish to take advantage of the power of polymorphism. In particular, this avoids code redundancy, sources of bugs, and endless copy-pasting. Indeed, in our previous example, it is highly likely that the different implementations of <strong class="source-inline">MailerInterface</strong> have common behaviors, such as the creation of the HTTP client that communicates with the API of the email provider or the creation of a <strong class="source-inline">Message</strong> common object used in the internal workings of the implementations.</p>
			<p>In this case, we would declare <strong class="source-inline">AbstractMailer</strong> implementing <strong class="source-inline">MailerInterface</strong> and define common behaviors of the different implementations. Then, the different implementations would extend <strong class="source-inline">AbstractMailer</strong> in order to enjoy the common behavior you just defined.</p>
			<p>Be careful—this does not mean that it is necessary to create interfaces and abstract classes everywhere, all the time, and in all cases. We should not neglect the impact that this has on the complexity of the code compared to a single class. Also, just because you haven’t created an interface for a case doesn’t mean that it is immutable and set in stone. Very often, we find ourselves refactoring our code and creating interfaces and abstract classes and adapting existing classes to implement and extend them. As we have seen, we need to keep<a id="_idIndexMarker145"/> the code simple at first (respecting the <em class="italic">YAGNI</em> and <em class="italic">KISS</em> principles). We <a id="_idIndexMarker146"/>cannot predict the future, business constraints evolve.</p>
			<p>If at the time of creating a class, there is nothing to suggest that different implementations will be needed, this is not a concern. This is a job that will be done later. On the other hand, if during development you find yourself copying code from one side to the other and perceive a strong redundancy, it will be an excellent reflex to think about polymorphism.</p>
			<h1 id="_idParaDest-69"><a id="_idTextAnchor068"/>Summary</h1>
			<p>We have just covered the most advanced part of the theoretical section of this book. We are now armed with the knowledge to cut our code cleanly while keeping it maintainable and extensible for future developers. It will also be ready for the future by being strongly open to extension and closed to modification (as described in one of the <em class="italic">SOLID</em> principles).</p>
			<p>We have reviewed many of the cases that you may encounter regarding the naming of files, classes, and methods when developing a PHP application. In addition, we have seen that folders must have specific names and can be used to divide your application into different domains.</p>
			<p>The separation of responsibilities was also a big topic. It is particularly important to understand why this separation is useful, even vital, in a project. It is the real key to a well-architected project that is easy to navigate. Event dispatching is an excellent way to achieve this, as we have seen. Event dispatching is one of the cornerstones of some critical web projects such as the Symfony framework, to name but one. This one relies heavily on this mechanism, making it a tool known for its robustness, its efficiency, and—especially—its flexibility. This is also due to the polymorphism and the different interfaces declared within it. You can redeclare pretty much any part of the framework thanks to this and adapt everything to your most advanced needs.</p>
			<p>It is not always easy to understand when to create an interface or an abstract class. This comes with practice and experience. Soon, it will seem natural. When in doubt, talk to one of your peers!</p>
			<p>We will finish the theoretical part of this book with a lighter part in the next chapter, dealing with the new features of PHP. These make us more rigorous and better developers, especially in the last few years. </p>
		</div>
	</body></html>