["```php\nclass SignUpUserService implements ApplicationService\n{\n    private $userRepository;\n    private $userFactory;\n    private $userTransformer;\n\n    public function __construct(\n        UserRepository $userRepository,\n        UserFactory $userFactory,\n        UserTransformer $userTransformer\n    ) {\n        $this->userRepository = $userRepository;\n        $this->userFactory = $userFactory;\n        $this->userTransformer = $userTransformer;\n    }\n\n    /**\n     * @param SignUpUserRequest $request\n     * @return User\n     * @throws UserAlreadyExistsException\n     */\n    public function execute(SignUpUserRequest $request)\n    {\n        $email = $request->email();\n        $password = $request->password();\n\n        $user = $this->userRepository->userOfEmail($email );\n        if ($user) {\n            throw new UserAlreadyExistsException();\n        }\n\n        $user = $this->userFactory->build(\n            $this->userRepository->nextIdentity(),\n            $email,\n            $password\n        );\n\n        $this->userRepository->add($user);\n        $this->userTransformer->write($user);\n    }\n}\n\n```", "```php\ninterface DomainEvent \n{ \n    /** \n     * @return DateTimeImmutable\n     */\n     public function occurredOn(); \n}\n\n```", "```php\nclass UserRegistered implements DomainEvent \n{ \n    private $userId;\n\n    public function __construct(UserId $userId)\n    {\n        $this->userId = $userId;\n        $this->occurredOn = new \\DateTimeImmutable();\n    }\n\n    public function userId()\n    {\n        return $this->userId;\n    }\n\n    public function occurredOn()\n    {\n        return $this->occurredOn;\n    }\n}\n\n```", "```php\nclass UserRegistered implements DomainEvent\n{\n    private $userId;\n    private $userEmail ;\n\n    public function __construct(UserId $userId, $userEmail)\n    {\n        $this-> userId = $userId;\n        $this->userEmail = $userEmail ;\n        $this->occurredOn = new DateTimeImmutable();\n    }\n\n    public function userId()\n    {\n        return $this->userId;\n    }\n\n    public function userEmail ()\n    {\n        return $this->userEmail ;\n    }\n\n    public function occurredOn()\n    {\n        return $this->occurredOn;\n    }\n}\n\n```", "```php\n/** @Entity @HasLifecycleCallbacks */\nclass User\n{\n    // ...\n\n   /**\n    * @Column(type=\"string\", length=255)\n    */\n    public $value;\n\n    /** @Column(name=\"created_at\", type=\"string\", length=255) */\n    private $createdAt;\n\n    /** @PrePersist */\n    public function doStuffOnPrePersist()\n    {\n        $this->createdAt = date('Y-m-d H:i:s');\n    }\n\n    /** @PrePersist */\n    public function doOtherStuffOnPrePersist()\n    {\n        $this-> value = 'changed from prePersist callback!';\n    }\n\n    /** @PostPersist */\n    public function doStuffOnPostPersist()\n    {\n        $this->value = 'changed from postPersist callback!';\n    }\n\n    /** @PostLoad */\n    public function doStuffOnPostLoad()\n    {\n        $this->value = 'changed from postLoad callback!';\n    }\n\n    /** @PreUpdate */\n    public function doStuffOnPreUpdate()\n    {\n        $this->value = 'changed from preUpdate callback!';\n    }\n}\n\n```", "```php\ninterface EventStore\n{\n    public function append(DomainEvent $aDomainEvent);\n    public function allStoredEventsSince($anEventId);\n}\n\n```", "```php\nclass DoctrineEventStore extends EntityRepository implements EventStore\n{\n    private $serializer;\n\n    public function append(DomainEvent $aDomainEvent)\n    {\n        $storedEvent = new StoredEvent(\n            get_class($aDomainEvent),\n            $aDomainEvent->occurredOn(),\n            $this->serializer()->serialize($aDomainEvent, 'json')\n        );\n\n        $this->getEntityManager()->persist($storedEvent);\n     }\n\n     public function allStoredEventsSince($anEventId)\n     {\n         $query = $this->createQueryBuilder('e');\n         if ($anEventId) {\n             $query->where('e.eventId > :eventId');\n             $query->setParameters(['eventId' => $anEventId]);\n         }\n         $query->orderBy('e.eventId');\n\n         return $query->getQuery()->getResult();\n     }\n\n     private function serializer()\n     {\n         if (null === $this->serializer) {\n             /** \\JMS\\Serializer\\Serializer\\SerializerBuilder */\n             $this->serializer = SerializerBuilder::create()->build();\n         }\n\n         return $this->serializer;\n     }\n }\n\n```", "```php\nclass StoredEvent implements DomainEvent\n{\n    private $eventId;\n    private $eventBody;\n    private $occurredOn;\n    private $typeName;\n\n    /**\n     * @param string $aTypeName\n     * @param \\DateTimeImmutable $anOccurredOn\n     * @param string $anEventBody\n     */\n    public function __construct(\n        $aTypeName, \\DateTimeImmutable $anOccurredOn, $anEventBody\n    ) {\n        $this->eventBody = $anEventBody;\n        $this->typeName = $aTypeName;\n        $this->occurredOn = $anOccurredOn;\n    }\n\n    public function eventBody()\n    {\n        return $this->eventBody;\n    }\n\n    public function eventId()\n    {\n        return $this->eventId;\n    }\n\n    public function typeName()\n    {\n        return $this->typeName;\n    }\n\n    public function occurredOn()\n    {\n        return $this->occurredOn;\n    }\n}\n\n```", "```php\nDdd\\Domain\\Event\\StoredEvent:\n    type: entity\n    table: event\n    repositoryClass:\n        Ddd\\Infrastructure\\Application\\Notification\\DoctrineEventStore\n    id:\n        eventId:\n            type: integer\n            column: event_id\n            generator:\n            strategy: AUTO\n    fields:\n        eventBody:\n            column: event_body\n            type: text\n        typeName:\n            column: type_name\n            type: string\n            length: 255\n        occurredOn:\n            column: occurred_on\n            type: datetime\n\n```", "```php\nclass User\n{\n    protected $userId;\n    protected $email ;\n    protected $password;\n\n    public function __construct(UserId $userId, $email, $password)\n    {\n        $this->setUserId($userId);\n        $this->setEmail($email);\n        $this->setPassword($password);\n\n        DomainEventPublisher::instance()->publish(\n            new UserRegistered($this->userId)\n        );\n    }\n\n    // ...\n}\n\n```", "```php\nclass User\n{\n    protected $userId;\n    protected $email ;\n    protected $password;\n\n    public function __construct(UserId $userId, $email, $password)\n    {\n        $this->setUserId($userId);\n        $this->setEmail($email);\n        $this->setPassword($password);\n        $this->publishEvent();\n\n    }\n\n    protected function publishEvent()\n    {\n        DomainEventPublisher::instance()->publish(\n            new UserRegistered($this->userId)\n        );\n    }\n\n    // ...\n}\n\n```", "```php\nclass CustomOrmUser extends User\n{\n    protected function publishEvent()\n    {\n\n    }\n\n    public static function fromRawData($data)\n    {\n        return new self(\n            new UserId($data['user_id']),\n            $data['email'],\n            $data['password']\n        );\n    }\n}\n\n```", "```php\nclass CustomOrmUser extends User\n{\n    public function __construct()\n    {\n    }\n\n    public static function fromRawData($data)\n    {\n        $user = new self();\n        $user->userId = new UserId($data['user_id']);\n        $user->email = $data['email'];\n        $user->password = $data['password'];\n\n        return $user;\n    }\n}\n\n```", "```php\nclass DomainEventPublisher\n{\n    private $subscribers;\n    private static $instance = null;\n\n    public static function instance()\n    {\n        if (null === static::$instance) {\n            static::$instance = new static();\n        }\n\n        return static::$instance;\n    }\n\n    private function __construct()\n    {\n        $this->subscribers = [];\n    }\n\n    public function __clone()\n    {\n        throw new BadMethodCallException('Clone is not supported');\n    }\n\n    public function subscribe(\n        DomainEventSubscriber $aDomainEventSubscriber\n    ) {\n        $this->subscribers[] = $aDomainEventSubscriber;\n    }\n\n    public function publish(DomainEvent $anEvent)\n    {\n        foreach ($this->subscribers as $aSubscriber) {\n           if ($aSubscriber->isSubscribedTo($anEvent)) {\n               $aSubscriber->handle($anEvent);\n           }\n        }\n    }\n}\n\n```", "```php\ninterface DomainEventSubscriber\n{\n    /**\n     * @param DomainEvent $aDomainEvent\n     */\n    public function handle($aDomainEvent);\n\n    /**\n     * @param DomainEvent $aDomainEvent\n     * @return bool\n     */\n    public function isSubscribedTo($aDomainEvent);\n}\n\n```", "```php\nclass PersistDomainEventSubscriber implements DomainEventSubscriber\n{\n    private $eventStore;\n\n    public function __construct(EventStore $anEventStore)\n    {\n        $this->eventStore = $anEventStore;\n    }\n\n    public function handle($aDomainEvent)\n    {\n        $this->eventStore->append($aDomainEvent);\n    }\n\n    public function isSubscribedTo($aDomainEvent)\n    {\n        return true;\n    }\n}\n\n```", "```php\n// ...\n$app['em'] = $app-> share(function () {\n    return (new EntityManagerFactory())->build();\n});\n\n$app['event_repository'] = $app->share(function ($app) {\n    return $app['em']->getRepository(\n        'Ddd\\Domain\\Model\\Event\\StoredEvent'\n    );\n});\n\n$app['event_publisher'] = $app->share(function($app) {\n    return DomainEventPublisher::instance();\n});\n\n$app->before(\n    function(Symfony\\Component\\HttpFoundation\\Request $request)\n        use($app) {\n\n        $app['event_publisher']->subscribe(\n            new PersistDomainEventSubscriber(\n                $app['event_repository']\n            )\n        );\n    }\n);\n\n```", "```php\nuse Ddd\\Domain\\DomainEventPublisher;\nuse Ddd\\Domain\\DomainEventSubscriber;\n\nclass UserTest extends \\PHPUnit_Framework_TestCase\n{\n    // ...\n\n    /**\n     * @test\n     */\n    public function itShouldPublishUserRegisteredEvent()\n    {\n        $subscriber = new SpySubscriber();\n        $id = DomainEventPublisher::instance()->subscribe($subscriber);\n\n        $userId = new UserId();\n        new User($userId, 'valid@email.com', 'password');\n        DomainEventPublisher::instance()->unsubscribe($id);\n\n        $this->assertUserRegisteredEventPublished($subscriber,$userId);\n    }\n\n    private function assertUserRegisteredEventPublished(\n        $subscriber, $userId\n    ) {\n        $this->assertInstanceOf(\n            'UserRegistered', $subscriber->domainEvent\n        );\n        $this->assertTrue(\n            $subscriber->domainEvent->serId()->equals($userId)\n        );\n    }\n}\n\nclass SpySubscriber implements DomainEventSubscriber\n{\n    public $domainEvent;\n\n    public function handle($aDomainEvent)\n    {\n        $this->domainEvent = $aDomainEvent;\n    }\n\n    public function isSubscribedTo($aDomainEvent)\n    {\n        return true;\n    }\n}\n\n```", "```php\nclass NotificationService\n{\n    private $serializer;\n    private $eventStore;\n    private $publishedMessageTracker;\n    private $messageProducer;\n\n    public function __construct(\n        EventStore $anEventStore,\n        PublishedMessageTracker $aPublishedMessageTracker,\n        MessageProducer $aMessageProducer,\n        Serializer $aSerializer\n    ) {\n        $this->eventStore = $anEventStore;\n        $this->publishedMessageTracker = $aPublishedMessageTracker;\n        $this->messageProducer = $aMessageProducer;\n        $this->serializer = $aSerializer;\n    }\n\n    /**\n     * @return int\n     */\n    public function publishNotifications($exchangeName)\n    {\n        $publishedMessageTracker = $this->publishedMessageTracker();\n        $notifications = $this->listUnpublishedNotifications(\n            $publishedMessageTracker\n                ->mostRecentPublishedMessageId($exchangeName)\n        );\n\n        if (!$notifications) {\n            return 0;\n        }\n\n        $messageProducer = $this->messageProducer();\n        $messageProducer->open($exchangeName);\n        try {\n            $publishedMessages = 0;\n            $lastPublishedNotification = null;\n            foreach ($notifications as $notification) {\n                $lastPublishedNotification = $this->publish(\n                    $exchangeName,\n                    $notification,\n                    $messageProducer\n                );\n                $publishedMessages++;\n            }\n        } catch (\\Exception $e) {\n            // Log your error (trigger_error, Monolog, etc.)\n        }\n\n        $this->trackMostRecentPublishedMessage(\n            $publishedMessageTracker,\n            $exchangeName,\n            $lastPublishedNotification\n        );\n\n        $messageProducer->close($exchangeName);\n\n        return $publishedMessages;\n    }\n\n    protected function publishedMessageTracker()\n    {\n        return $this->publishedMessageTracker;\n    }\n\n    /**\n     * @return StoredEvent[]\n     */\n    private function listUnpublishedNotifications(\n        $mostRecentPublishedMessageId\n    ) {\n        return $this\n            ->eventStore()\n            ->allStoredEventsSince($mostRecentPublishedMessageId);\n    }\n\n    protected function eventStore()\n    {\n        return $this->eventStore;\n    }\n\n    private function messageProducer()\n    {\n        return $this->messageProducer;\n    }\n\n    private function publish(\n        $exchangeName,\n        StoredEvent $notification,\n        MessageProducer $messageProducer\n    ) {\n        $messageProducer->send(\n            $exchangeName,\n            $this->serializer()->serialize($notification, 'json'),\n            $notification->typeName(),\n            $notification->eventId(),\n            $notification->occurredOn()\n        );\n\n        return $notification;\n    }\n\n    private function serializer()\n    {\n       return $this->serializer;\n    }\n\n    private function trackMostRecentPublishedMessage(\n        PublishedMessageTracker $publishedMessageTracker,\n        $exchangeName,\n        $notification\n    ) {\n        $publishedMessageTracker->trackMostRecentPublishedMessage(\n            $exchangeName, $notification\n        );\n    }\n}\n\n```", "```php\ninterface PublishedMessageTracker\n{\n    /**\n     * @param string $exchangeName\n     * @return int\n     */\n    public function mostRecentPublishedMessageId($exchangeName);\n\n    /**\n     * @param string $exchangeName\n     * @param StoredEvent $notification\n     */\n    public function trackMostRecentPublishedMessage(\n        $exchangeName, $notification\n    );\n}\n\n```", "```php\nclass DoctrinePublishedMessageTracker extends EntityRepository\\\nimplements PublishedMessageTracker\n{\n    /**\n     * @param $exchangeName\n     * @return int\n     */\n    public function mostRecentPublishedMessageId($exchangeName)\n    {\n        $messageTracked = $this->findOneByExchangeName($exchangeName);\n        if (!$messageTracked) {\n            return null ;\n        }\n\n        return $messageTracked->mostRecentPublishedMessageId();\n    }\n\n    /**\n     *@param $exchangeName\n     * @param StoredEvent $notification\n     */\n    public function trackMostRecentPublishedMessage(\n        $exchangeName, $notification\n    ) {\n        if(!$notification) {\n            return;\n        }\n\n        $maxId = $notification->eventId();\n\n        $publishedMessage= $this->findOneByExchangeName($exchangeName);\n        if(null === $publishedMessage){\n            $publishedMessage = new PublishedMessage(\n                $exchangeName,\n                $maxId\n            );\n        }\n\n        $publishedMessage->updateMostRecentPublishedMessageId($maxId);\n\n        $this->getEntityManager()->persist($publishedMessage);\n        $this->getEntityManager()->flush($publishedMessage);\n    }\n}\n\n```", "```php\nclass PublishedMessage\n{\n    private $mostRecentPublishedMessageId;\n    private $trackerId;\n    private $exchangeName;\n\n    /**\n     * @param string $exchangeName\n     * @param int $aMostRecentPublishedMessageId\n     */\n    public function __construct(\n        $exchangeName, $aMostRecentPublishedMessageId\n    ) {\n        $this->mostRecentPublishedMessageId =\n            $aMostRecentPublishedMessageId;\n        $this->exchangeName = $exchangeName;\n    }\n\n    public function mostRecentPublishedMessageId()\n    {\n        return $this->mostRecentPublishedMessageId;\n    }\n\n    public function updateMostRecentPublishedMessageId($maxId)\n    {\n        $this->mostRecentPublishedMessageId = $maxId;\n    }\n\n    public function trackerId()\n    {\n        return $this->trackerId;\n    }\n}\n\n```", "```php\nDdd\\Domain\\Event\\PublishedMessage:\n    type: entity\n    table: event_published_message_tracker\n    repositoryClass:\n        Ddd\\Infrastructure\\Application\\Notification\\\n            DoctrinePublished\\MessageTracker\n    id:\n        trackerId:\n            column: tracker_id\n            type: integer\n            generator:\n            strategy: AUTO\n    fields:\n        mostRecentPublishedMessageId:\n            column: most_recent_published_message_id\n            type: bigint\n        exchangeName:\n            type: string\n            column: exchange_name\n\n```", "```php\ninterface MessageProducer \n{ \n    public function open($exchangeName);\n\n    /**\n     * @param $exchangeName\n     * @param string $notificationMessage\n     * @param string $notificationType\n     * @param int $notificationId\n     * @param \\DateTimeImmutable $notificationOccurredOn\n     * @return\n     */\n    public function send(\n        $exchangeName,\n        $notificationMessage,\n        $notificationType,\n        $notificationId,\n        \\DateTimeImmutable $notificationOccurredOn\n    );\n\n    public function close($exchangeName);\n}\n\n```", "```php\nabstract class RabbitMqMessaging\n{\n    protected $connection;\n    protected $channel ;\n\n    public function __construct(AMQPConnection $aConnection)\n    {\n        $this->connection =$aConnection;\n        $this->channel = null ;\n    }\n\n    private function connect($exchangeName)\n    {\n        if (null !== $this->channel ) {\n            return;\n        }\n\n        $channel = $this->connection->channel();\n        $channel->exchange_declare(\n            $exchangeName, 'fanout', false, true, false\n        );\n        $channel->queue_declare(\n            $exchangeName, false, true, false, false\n        );\n        $channel->queue_bind($exchangeName, $exchangeName);\n\n        $this->channel = $channel ;\n    }\n\n    public function open($exchangeName)\n    {\n\n    }\n\n    protected function channel ($exchangeName)\n    {\n        $this->connect($exchangeName);\n\n        return $this->channel;\n    }\n\n    public function close($exchangeName)\n    {\n        $this->channel->close();\n        $this->connection->close();\n    }\n}\n\nclass RabbitMqMessageProducer\n    extends RabbitMqMessaging\n    implements MessageProducer\n{\n    /**\n     * @param $exchangeName\n     * @param string $notificationMessage\n     * @param string $notificationType\n     * @param int $notificationId\n     * @param \\DateTimeImmutable $notificationOccurredOn\n     */\n    public function send(\n        $exchangeName,\n        $notificationMessage,\n        $notificationType,\n        $notificationId,\n        \\DateTimeImmutable $notificationOccurredOn\n    ) {\n        $this->channel ($exchangeName)->basic_publish(\n            new AMQPMessage(\n                $notificationMessage,\n                [\n                  'type'=>$notificationType,\n                  'timestamp'=>$notificationOccurredOn->getTimestamp(),\n                  'message_id'=>$notificationId\n                ]\n            ),\n            $exchangeName\n        );\n    }\n}\n\n```", "```php\nclass PushNotificationsCommand extends Command\n{\n    protected function configure()\n    {\n        $this\n            ->setName('domain:events:spread')\n            ->setDescription('Notify all domain events via messaging')\n            ->addArgument(\n                'exchange-name',\n                InputArgument::OPTIONAL,\n                'Exchange name to publish events to',\n                'my-bc-app'\n            );\n    }\n\n    protected function execute(\n        InputInterface $input, OutputInterface $output\n    ) {\n        $app = $this->getApplication()->getContainer();\n\n        $numberOfNotifications =\n            $app['notification_service']\n                ->publishNotifications(\n                    $input->getArgument('exchange-name')\n                );\n\n        $output->writeln(\n            sprintf(\n                '<comment>%d</comment>' .\n                '<info>notification(s) sent!</info>',\n                $numberOfNotifications\n            )\n        );\n    }\n}\n\n```", "```php\n // ...\n $app['event_store']=$app->share( function ($app) {\n     return $app['em']->getRepository('Ddd\\Domain\\Event\\StoredEvent');\n });\n\n$app['message_tracker'] = $app->share(function($app) {\n    return $app['em']\n        ->getRepository('Ddd\\Domain\\Event\\Published\\Message');\n});\n\n$app['message_producer'] = $app->share(function () {\n    return new RabbitMqMessageProducer(\n       new AMQPStreamConnection('localhost', 5672, 'guest', 'guest')\n    );\n});\n\n$app['message_serializer'] = $app->share(function () {\n    return SerializerBuilder::create()->build();\n});\n\n$app['notification_service'] = $app->share(function ($app) {\n    return new NotificationService(\n       $app['event_store'],\n       $app['message_tracker'],\n       $app['message_producer'],\n       $app['message_serializer']\n    );\n});\n//...\n\n```", "```php\n[\n    {\n        \"id\": 1,\n        \"version\": 1,\n        \"typeName\": \"Lw\\\\Domain\\\\Model\\\\User\\\\UserRegistered\",\n        \"eventBody\": {\n            \"user_id\": {\n                \"id\": \"459a4ffc-cd57-4cf0-b3a2-0f2ccbc48234\"\n            }\n        },\n        \"occurredOn\": {\n            \"date\": \"2016-05-26 06:06:07.000000\",\n            \"timezone_type\": 3,\n            \"timezone\": \"UTC\"\n        }\n    },\n    {\n        \"id\": 2,\n        \"version\": 2,\n        \"typeName\": \"Lw\\\\Domain\\\\Model\\\\Wish\\\\WishWasMade\",\n        \"eventBody\": {\n            \"wish_id\": {\n                \"id\": \"9e90435a-395c-46b0-b4c4-d4b769cbf201\"\n            },\n            \"user_id\": {\n                \"id\": \"459a4ffc-cd57-4cf0-b3a2-0f2ccbc48234\"\n            },\n            \"address\": \"john@example.com\",\n            \"content\": \"This is my new wish!\"\n        },\n        \"occurredOn\": {\n            \"date\": \"2016-05-26 06:06:27.000000\",\n            \"timezone_type\": 3,\n            \"timezone\": \"UTC\"\n        },\n        \"timeTaken\": \"650\"\n    },\n    //...\n]\n\n```"]