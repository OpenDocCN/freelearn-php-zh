- en: '[*Chapter 6*](B17606_06_Final_PD_ePub.xhtml#_idTextAnchor116): Configuring
    the Theme Settings'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In previous chapters, we have been learning about Shopify as a platform, familiarizing
    ourselves with Liquid basics, and using the Liquid core to create various features
    on the storefront. However, unless the store owners are developers, they will
    not have much control over any features we create for them.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will be learning how we can use JSON to create settings
    that are accessible through the theme editor, which will allow the store owners
    to easily customize the theme without making the code adjustments throughout the
    theme. We will cover the following topics in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Exploring JSON settings
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Learning about the input setting attributes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Basic and specialized input types
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Organizing the theme editor
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Glancing at the deprecated settings
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By the time we complete this chapter, we will have gained a deeper understanding
    of the importance of JSON, and how we can use it to create theme settings that
    are accessible across the entire theme on any page. We can use these settings
    to modify the CSS values, change the content on certain features, and even use
    the settings to enable or disable a particular feature altogether. By learning
    how to use JSON to create these settings, we will take another step toward creating
    a genuinely dynamic and customizable feature storefront, which is what Shopify
    is.
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: While we will explain each topic and have it presented with the accompanying
    graphics, we will need an internet connection to follow the steps outlined in
    this chapter, considering that Shopify is a hosted service.
  prefs: []
  type: TYPE_NORMAL
- en: The code for this chapter is available on GitHub at [https://github.com/PacktPublishing/Shopify-Theme-Customization-with-Liquid/tree/main/Chapter06](https://github.com/PacktPublishing/Shopify-Theme-Customization-with-Liquid/tree/main/Chapter06).
  prefs: []
  type: TYPE_NORMAL
- en: 'The Code in Action video for the chapter can be found here: [https://bit.ly/3nLQgMf](https://bit.ly/3nLQgMf)'
  prefs: []
  type: TYPE_NORMAL
- en: Exploring JSON settings
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In [*Chapter 1*](B17606_01_Final_PD_ePub.xhtml#_idTextAnchor015), *Getting
    Started with Shopify*, we briefly mentioned the `Config` directory, where we can
    define and manage the global JSON values across the entire theme. Let''s remind
    ourselves of the two essential `.json` files that we can find within this directory:'
  prefs: []
  type: TYPE_NORMAL
- en: The `settings_schema.json` file allows us to create and manage the content inside
    the theme editor on our theme, which we can reference throughout the entire theme
    file.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `settings_data.json` file, on the other hand, records all the options defined
    in our schema file and saves their values. We can consider this file as our theme
    database, which we can manage by updating the theme settings through the theme
    editor or by directly editing the values inside the `settings_data.json` file.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We can group the global settings options into different categories for more
    straightforward navigation, which we can do using the `name` and `settings` attributes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'As we can see, as with the `.json` files in the `Locales` directory mentioned
    in the previous chapter, the `settings_schema.json` file has a specific format
    that we must honor. Using the `name` attribute, we can set the name of the category
    and the `settings` attribute will contain the array of settings that the category
    will contain:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: In the previous example, we have included two types of color settings, one that
    will control the background color of our store and one that will be in charge
    of setting the border color we will use across our store. As we can see, we have
    enclosed each `settings` option within the curly brackets and separated it by
    commas. However, note that the last `settings` option inside the category does
    not have a comma.
  prefs: []
  type: TYPE_NORMAL
- en: 'Important note:'
  prefs: []
  type: TYPE_NORMAL
- en: Including a comma after the last attribute within the `settings` block, or including
    the comma after the last `settings` block in the category, will result in an error
    and we will not be able to save our work.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have defined the global settings, we need to learn how to access
    them and recover their values. We can recover the value of any global input setting
    using the `settings` keyword and the input''s ID, whose value we are looking to
    recover, separated by a dot and encapsulated by double curly braces:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: We have now had the chance to see how we can define input setting options and
    read their values, but where exactly are we rendering this option and how can
    we modify it?
  prefs: []
  type: TYPE_NORMAL
- en: 'We can access the theme editor by navigating to the **Online theme** section
    in the admin section and clicking on the **Customize** button on the theme we
    are looking to customize:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.1 – Example of accessing the theme editor through the Online theme
    section'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_6.01_B17606.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 6.1 – Example of accessing the theme editor through the Online theme
    section
  prefs: []
  type: TYPE_NORMAL
- en: Note that changes made throughout the theme editor are theme-specific, so we
    should remember to click the **Customize** button on the theme we are looking
    to customize.
  prefs: []
  type: TYPE_NORMAL
- en: 'Alternatively, we can access the theme editor through the code editor by clicking
    on the **Customize theme** button, located in the top-right corner:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.2 – Alternative way of accessing the theme editor through the code
    editor'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_6.02_B17606.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 6.2 – Alternative way of accessing the theme editor through the code
    editor
  prefs: []
  type: TYPE_NORMAL
- en: 'Once inside the theme editor, we will see a list of category options within
    our sidebar. However, most of these options are a part of the sections and blocks
    that we will be learning more about in the following chapter. For now, we can
    access the global settings that we define throughout the `settings_schema.json`
    file by clicking on the **Theme settings** button located in the bottom-right
    corner:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.3 – Accessing the global settings inside the theme editor'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_6.03_B17606.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 6.3 – Accessing the global settings inside the theme editor
  prefs: []
  type: TYPE_NORMAL
- en: Inside `settings_schema.json` file, where each input set contains a set of attributes.
    While some of them are required, others are optional. Let's learn more about them.
  prefs: []
  type: TYPE_NORMAL
- en: Learning about the input setting attributes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Each input settings option can contain the following five attributes, which
    are also called standard attributes:'
  prefs: []
  type: TYPE_NORMAL
- en: As its name indicates, the `type` attribute allows us to set the type of the
    input setting, which can be either a basic type or a specialized type. The `type`
    attribute is mandatory.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `id` attribute is another mandatory attribute that we will use later to
    access and read the setting value.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `label` attribute allows us to set the label of the input settings inside
    the theme editor. The `label` attribute is mandatory.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `default` value serves as a failsafe and allows us to set a default option
    for the input settings. However, it is not mandatory.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The final attribute, `info`, allows us to include an additional clarification
    regarding the input settings and is also not mandatory.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: While most of the input settings will contain only the previously mentioned
    attributes, depending on the input type, there will be cases where we will need
    to include some additional attributes.
  prefs: []
  type: TYPE_NORMAL
- en: We have previously mentioned that the type attributes allow us to choose between
    two different types of input settings, basic and specialized, but what exactly
    are they?
  prefs: []
  type: TYPE_NORMAL
- en: Basic input types
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The basic input type is a set of options that allow us to include various types
    of input settings within our theme editor. Under the basic category, we can use
    the following options:'
  prefs: []
  type: TYPE_NORMAL
- en: '`checkbox`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`number`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`radio`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`range`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`select`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`text`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`textarea`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As we have mentioned previously, most of the input settings will contain only
    the standard attributes. However, some of the specialized inputs and even basic
    inputs will require additional attributes. Let's now look into each input type,
    learn how to use it, and what type of results we can expect.
  prefs: []
  type: TYPE_NORMAL
- en: The checkbox input
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `checkbox` type of input, as its name suggests, is a Boolean type of field
    that allows us to create a checkbox option within the theme editor:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'As we can see, the `checkbox` input contains three mandatory and one optional
    attribute whose value we have set to `true`. Otherwise, if we were to remove the
    `default` attribute, the default state of the checkbox will be `false`. The following
    screenshot shows us an example of the checkbox input type:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.4 – Example of the checkbox basic input type'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_6.04_B17606.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 6.4 – Example of the checkbox basic input type
  prefs: []
  type: TYPE_NORMAL
- en: 'We can use the Boolean input type to toggle features on and off, which we can
    achieve by taking the checkbox input value and checking its current state using
    an `if` statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'By checking whether the `checkbox` input value is equal to `true`, we have
    created a simple feature that will enable or disable a certain feature from the
    store easily, as the code block inside the statement will only render if the statement
    is `true`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Note that we can achieve the same results by comparing the checkbox input value
    against the `blank` variable.
  prefs: []
  type: TYPE_NORMAL
- en: The number input
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `number` type of input is the newest addition from Shopify and, as its
    name suggests, it is a number type of field, which allows us to create a number
    selector input inside the theme editor. In addition to the standard attributes,
    we can also use an optional `placeholder` attribute, which allows us to include
    a placeholder value for the text input:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that the `number` type of input can only contain a number value. In the
    following screenshot, we can see an example of the `number` input type:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.5 – Example of the number basic input type'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_6.05_B17606.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 6.5 – Example of the number basic input type
  prefs: []
  type: TYPE_NORMAL
- en: 'Once we have the number input defined, we can access it by pairing the `settings`
    keyword and the ID of the text input:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: The `number` input value will always return a number value, unless it is empty,
    in which case it will return an `EmptyDrop` value. We can remind ourselves of
    `EmptyDrop` by revisiting [*Chapter 2*](B17606_02_Final_PD_ePub.xhtml#_idTextAnchor030),
    *The Basic Flow of Liquid*, and checking the *EmptyDrop* subsection inside the
    *Understand the types of data* section.
  prefs: []
  type: TYPE_NORMAL
- en: The radio input
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Using the `radio` input type, we can output a `radio` option field, which allows
    us to have a multi-option selection. The `radio` input uses standard attributes
    with the addition of the `options` attribute, which is mandatory.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `options` attribute accepts an array of `value` and `label` attributes,
    which are mandatory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that we need to set the `default` attribute to one of the values previously
    defined inside the `options` array. Otherwise, if the `default` attribute is not
    defined, the first radio will be selected by default. Here is an example of the
    `radio` input type:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.6 – Example of the radio basic input type'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_6.06_B17606.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 6.6 – Example of the radio basic input type
  prefs: []
  type: TYPE_NORMAL
- en: 'Once we have the `radio` input defined, we can access it by pairing the `settings`
    keyword and the ID of the radio input:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: The radio button value will always return a string value.
  prefs: []
  type: TYPE_NORMAL
- en: The range input
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'With the `range` input type, we can create a range slider field. Compared to
    the previous inputs, the `range` input has four additional attributes and one
    change to the standard attributes. We can list the additional attributes in the
    following way:'
  prefs: []
  type: TYPE_NORMAL
- en: The `min` attribute allows us to set the minimum value of the range input. The
    `min` value is mandatory.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `max` value is also a mandatory attribute that allows us to set the maximum
    value of the range input.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `step` value allows us to set the increment value between the steps of the
    slider. The `step` slider is mandatory.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The fourth and final additional attribute, `unit`, is an optional attribute,
    which allows us to set the visual unit, such as `px`, for the range slider value.
    Note that the `unit` attribute only accepts up to three characters and will output
    the px purely visually inside the theme editor. The actual value will return a
    number value without the unit.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'One additional change to the standard set of attributes is that the `default`
    attribute is now mandatory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Note that the `min`, `max`, `step`, and `default` attributes are a number type
    of value. Including a string value in any of these attributes will result in an
    error.
  prefs: []
  type: TYPE_NORMAL
- en: When compared to the previous attributes, the `range` attribute comes with a
    few rules that we must follow. The first rule is that the `default` value must
    be a value between the `min` and `max` values. The second and more important rule
    is that each range slider can have a maximum of 100 steps, but what exactly does
    this mean?
  prefs: []
  type: TYPE_NORMAL
- en: For example, in the previous example, we have set a `min` value of `120` and
    a `max` value of `220`. Since we have set the `step` value to `1`, we have precisely
    100 steps between the two values.
  prefs: []
  type: TYPE_NORMAL
- en: 'On the other hand, if we set the `max` value to `320`, we would also have to
    update the `unit` value to `2` to retain the 100 steps between the `min` and `max`
    value. In the following screenshot, we can see the example of a `range` input
    type:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.7 – Example of the range basic input type'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_6.07_B17606.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 6.7 – Example of the range basic input type
  prefs: []
  type: TYPE_NORMAL
- en: 'Once we have the `range` input defined, we can access it by pairing the `settings`
    keyword and the ID of the `range` input. However, remember that the `unit` attribute
    is purely visual. Since the `range` input returns a number value, we would need
    to include the `unit` value within the stylesheet manually:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: This is one of the reasons why we should always include the `default` attribute
    when defining styling settings, or at least to wrap the entire CSS line within
    a statement that checks whether the value exists. Otherwise, we risk breaking
    the stylesheet if the value of the input is not defined.
  prefs: []
  type: TYPE_NORMAL
- en: The select input
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `select` input type allows us to create a drop-down selector field. In
    addition to the standard set of attributes, the `select` input type has two additional
    attributes. We can list the additional attributes in the following way:'
  prefs: []
  type: TYPE_NORMAL
- en: The `options` attribute, similar to the `range` input, allows us to create an
    array of `value` and `label` attributes to define the drop-down options. Both
    options and `value`/`label` inside the array are mandatory attributes.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `group` attribute is an optional attribute that allows us to group different
    options inside the dropdown.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Like the `radio` input type, if we do not define the `default` attribute, the
    first option is selected by default:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Since the `select` input returns a string value, one of the most common uses
    is to include a custom font family within the theme, as we had the chance to see
    in the previous example:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.8 – Example of the select basic input type'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_6.08_B17606.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 6.8 – Example of the select basic input type
  prefs: []
  type: TYPE_NORMAL
- en: 'Additionally, by using the `group` attribute, we have successfully grouped
    all options that belong to the same family:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Shopify also has an extensive font library that we can use and a specialized
    input that provides us with access to the mentioned library, which we will learn
    shortly. However, suppose we are looking to include a custom font that is not
    available within the Shopify font library. In that case, we will need to include
    it using a custom solution by including it through a `select` type dropdown.
  prefs: []
  type: TYPE_NORMAL
- en: The text input
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `text` type of input, as its name suggests, is a string type of field that
    allows us to create a single-line text option within the theme editor. In addition
    to the standard attributes, we can also use a `placeholder` attribute, which allows
    us to include a placeholder value for the text input:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that the `text` type of input can only contain the string value and cannot
    include any HTML tags. In the following screenshot, we can see an example of the
    `text` input type:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.9 – Example of the text basic input type'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_6.09_B17606.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 6.9 – Example of the text basic input type
  prefs: []
  type: TYPE_NORMAL
- en: 'Once we have the text input defined, we can access it by pairing the `settings`
    keyword and the ID of the text input:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: The `text` input value will always return a string value, unless it is empty,
    in which case it will return an `EmptyDrop` value.
  prefs: []
  type: TYPE_NORMAL
- en: The textarea input
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `textarea` type of input works similarly to the text input, with the only
    difference being that `textarea` is a multi-line text field as compared to the
    `text` input, which is a single-line field. In addition to the standard attributes,
    we can also use a `placeholder` attribute to include a placeholder value for the
    `textarea` input:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Similarly, as the `text` input value, the `textarea` input value will always
    return a string value, unless it is empty, in which case it will return an `EmptyDrop`
    value. We can see the example of the `textarea` input in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.10 – Example of the textarea basic input type'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_6.10_B17606.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 6.10 – Example of the textarea basic input type
  prefs: []
  type: TYPE_NORMAL
- en: With `textarea`, we have now covered all of the basic input settings, which
    has set us on a solid path to understanding and working with theme editor `.json`
    files. However, to truly be able to say that we have a working knowledge of `.json`
    files, we will also need to learn about the specialized input settings as well.
  prefs: []
  type: TYPE_NORMAL
- en: Specialized input settings
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The specialized input type is a set of specialized options that don''t allow
    us to include various types of input settings within our theme editor but also
    provide us with access to various Liquid objects easily. Under the specialized
    input, we can use the following options:'
  prefs: []
  type: TYPE_NORMAL
- en: '`richtext`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`html`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`linklist`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`liquid`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`color`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`url`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`video_url`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`image_picker`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`font_picker`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`article`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`blog`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`collection`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`page`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`product`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Similar to the basic input types, most of the input settings will only contain
    the standard attributes. However, some of the inputs will require additional attributes.
    By learning about all the different types of specialized inputs, we will learn
    how to use them and what type of results we can expect, which will help create
    complex sections that we will learn about in the next chapter.
  prefs: []
  type: TYPE_NORMAL
- en: The richtext input
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `richtext` input type is similar to the basic `textarea` type of input
    as they both output a multi-line text field. The major difference is that `richtext`
    also provides us with some basic formatting options:'
  prefs: []
  type: TYPE_NORMAL
- en: Bold
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Italic
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Underline
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Link
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Paragraph
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The second difference is that while `text` and `textarea` input values return
    a clean string, `richtext` will always return a string value formatted as a paragraph,
    encapsulated inside the HTML `<p></p>` tag. The following screenshot shows us
    an example of the `richtext` input:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.11 – Example of the richtext specialized input type'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_6.11_B17606.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 6.11 – Example of the richtext specialized input type
  prefs: []
  type: TYPE_NORMAL
- en: Additionally, using the formatting options that `richtext` provides will automatically
    update the string value with the respective HTML tags.
  prefs: []
  type: TYPE_NORMAL
- en: 'Important note:'
  prefs: []
  type: TYPE_NORMAL
- en: Using the formatting options will automatically apply the necessary HTML tags
    to the `richtext` string value. However, we cannot manually include any HTML tags
    within the theme editor's `richtext` field.
  prefs: []
  type: TYPE_NORMAL
- en: 'While the `default` attribute is not mandatory, if we decide to use it, we
    will have to include the `<p></p>` tags inside the `default` attribute value.
    Otherwise, we will receive an error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Note that `richtext` does not accept any `placeholder` attributes compared to
    `textarea`, which accepts it.
  prefs: []
  type: TYPE_NORMAL
- en: The html input
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `html` input type is a multi-line text field that, as its name suggests,
    allows us to include HTML markup within the input field. In addition to the standard
    attributes, the `html` input type also accepts an optional `placeholder` attribute:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'While the `html` input will accept most of the HTML tags, Shopify will automatically
    remove the following three tags:'
  prefs: []
  type: TYPE_NORMAL
- en: '`<html>`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`<head>`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`<body>`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The `html` type input value will always return a string value or an `EmptyDrop`
    value if it is empty. We can see the example of the `html` input inside the following
    screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.12 – Example of the html specialized input type'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_6.12_B17606.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 6.12 – Example of the html specialized input type
  prefs: []
  type: TYPE_NORMAL
- en: Note that while we can include HTML code inside the `html` type input, we cannot
    include Liquid code inside the field as it will get processed as a simple string.
  prefs: []
  type: TYPE_NORMAL
- en: The linklist input
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Using the `link_list` input type, we can create a special menu picker type
    of field that allows us to output one of the store navigation menus. Note that
    we can only see the menus we have previously created inside the admin **Navigation**
    section, located under the **Online store** section:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that while the `default` attribute is optional, it only accepts two specific
    values, `main-menu` and `footer`. Let''s see how the `linklist` input looks in
    the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.13 – Example of the linklist specialized input type'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_6.13_B17606.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 6.13 – Example of the linklist specialized input type
  prefs: []
  type: TYPE_NORMAL
- en: 'Using the settings and the ID to retrieve the `link_list` value will return
    a `linklist` object, which we can use to build the navigation menu. If we recall,
    in *Chapter 4*, *Diving into Liquid Core with Objects*, we have used the following
    code to output a navigation menu with a specific `indoor-navigation` handle:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'And if we wanted to use different navigation, we would have to manually update
    the menu navigation handle. However, considering that we can now recover the `linklist`
    object directly from the theme editor, we can update the previously hardcoded
    `linklist` object value and replace it with a dynamic one:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Note that if the `link_list` type input does not have a `default` attribute
    or we have not yet selected the menu, we will receive a `blank` value as the return
    value.
  prefs: []
  type: TYPE_NORMAL
- en: The liquid input
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `liquid` input type is also a recent addition from Shopify, and it allows
    us to include both HTML markup and limited Liquid code, which makes it a pretty
    powerful tool. Here is an example code for this input:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that any unclosed HTML tag will automatically close when we save the settings.
    In the following screenshot, we can see an example of the `liquid` input type:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.14 – Example of the liquid specialized input type'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_6.14_B17606.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 6.14 – Example of the liquid specialized input type
  prefs: []
  type: TYPE_NORMAL
- en: The `liquid` input type provides us with access to all global objects, page-based
    objects, and standard tags and filters.
  prefs: []
  type: TYPE_NORMAL
- en: Note that the `liquid` type input value will always return a string value or
    an `EmptyDrop` value if empty.
  prefs: []
  type: TYPE_NORMAL
- en: The color input
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'As its name suggests, the `color` input type allows us to create a color picker
    type input to update the store''s color palette easily:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'We can access the values of the `color` input type by combining the `settings`
    keyword and the ID of the input:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Besides being able to enter the hex color manually inside the `color` field,
    we can trigger an actual color palette where we can select the desired color tone:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.15 – Example of the color specialized input type'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_6.15_B17606.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 6.15 – Example of the color specialized input type
  prefs: []
  type: TYPE_NORMAL
- en: Note that while the `default` attribute is optional, we should always either
    include the default value or wrap the entire CSS line within the statement to
    check whether the input value isn't empty. If we neglect to include either of
    the two, in the event that the `color` input value is not defined, we may end
    up with a broken stylesheet.
  prefs: []
  type: TYPE_NORMAL
- en: The url input
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `url` type input provides us with a special URL entry field where we can
    either manually enter the external URL or use a series of dropdowns to select
    the path to one of the following resources:'
  prefs: []
  type: TYPE_NORMAL
- en: Articles
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Blogs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Collections
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Pages
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Products
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Policies
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We can also include a link to sites outside of our store by simply pasting
    the URL and consequently clicking on the link inside the drop-down menu confirming
    the selection:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.16 – Example of the url specialized input type'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_6.16_B17606.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 6.16 – Example of the url specialized input type
  prefs: []
  type: TYPE_NORMAL
- en: 'Note that while the `default` attribute is optional, it only accepts two specific
    values – `/collections` and `/collections/all`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'We can access the value of the `url` input type by combining the `settings`
    keyword and the input''s ID, which we can then include as the `href` parameter
    to the HTML `<a>` tag:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Considering that the HTML `<a>` tag is hardcoded, we cannot make any dynamic
    modifications to the tag using the `url` type input. However, we can introduce
    an additional input type, such as `checkbox`, which we can use to display or hide
    the `target="_blank"` attribute.
  prefs: []
  type: TYPE_NORMAL
- en: Note that the `color` type input value will always return either a string value
    or nil if the value is not defined.
  prefs: []
  type: TYPE_NORMAL
- en: The video_url input
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `video_url` type input provides us with a special URL entry field where
    we can manually enter the external URL of a video from either YouTube or Vimeo
    and extract their IDs for later use. In addition to the standard set of attributes,
    the `video_url` input type has two additional attributes. We can list the additional
    attributes in the following way:'
  prefs: []
  type: TYPE_NORMAL
- en: The `accept` attribute is a mandatory array type attribute where we can define
    the different types of providers whose video URL we will accept. Valid values
    are `youtube`, `vimeo`, or a combination of both.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `placeholder` attribute is an optional type attribute that allows us to
    include a placeholder value for the `video_url` input.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following code shows the `video_url` type input with the preceding attributes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'After including the video URL to one of the two video platforms, we will see
    the video name and first frame, allowing us to confirm that we have the correct
    video URL:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.17 – Example of the video_url specialized input type'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_6.17_B17606.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 6.17 – Example of the video_url specialized input type
  prefs: []
  type: TYPE_NORMAL
- en: 'We can access the value of the `video_url` input type by combining the `settings`
    keyword and the input''s ID, which will return the URL that we have previously
    included in the theme editor:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Compared to the previous input types, which return a single value, `video_url`
    allows us to access two additional parts of the video URL:'
  prefs: []
  type: TYPE_NORMAL
- en: The `id` attribute, which allows us to recover only the video ID
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The `type` attribute, which allows us to easily identify whether the video
    is from YouTube or Vimeo platforms:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Note that whether we are trying to return a complete URL or only its `type`/`id`,
    the returned value will always be a string type, unless the `video_url` value
    is not defined, in which case the returned value will be nil:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: Now that we have recovered the video information, all that is left is to include
    are the returned values inside the `iframe` embed for each respective platform.
    Note that we will need to include a separate `iframe` embed for each platform,
    which should not be a problem as we can easily identify which platform the video
    belongs to using the `type` attribute.
  prefs: []
  type: TYPE_NORMAL
- en: Note that since `video_url` returns a string type URL, it is impossible to generate
    the necessary `iframe` embed using the media object we mentioned in one of the
    previous chapters.
  prefs: []
  type: TYPE_NORMAL
- en: The image_picker input
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `image_picker` input type, as its name suggests, allows us to create an
    image picker selector field. The image picker selector allows us to upload new
    images, select the photo from a series of free photos available on Shopify, or
    use any of the photos previously included inside the **Files** section on the
    **Shopify** admin.
  prefs: []
  type: TYPE_NORMAL
- en: The `Files` section is home to all assets that we upload through admin or the
    theme editor, and we can find it inside `Files` section, we can also upload assets
    directly into the `Files` section using the **Upload files** button in the top-right
    corner. Additionally, we can easily recover the direct URL path to any asset and
    use it.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following block of code, we can see the example of how we can use the
    `image_picker` input:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that the `image_picker` type input value will always return an image object
    value or nil if the value is not defined:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.18 – Example of the image_picker specialized input type'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_6.18_B17606.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 6.18 – Example of the image_picker specialized input type
  prefs: []
  type: TYPE_NORMAL
- en: 'Since `image_picker` returns an `image` object, we can use the `img_tag` or
    `img_url` filters to generate the necessary image tag dynamically:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: For a detailed reminder regarding the use of `img_tag` and `img_url` filters,
    we can revisit the *HTML and URL filters* section from [*Chapter 5*](B17606_05_Final_PD_ePub.xhtml#_idTextAnchor097),
    *Diving into Liquid Core with Filters*.
  prefs: []
  type: TYPE_NORMAL
- en: The font_picker input
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'While learning about the `select` input type, we have mentioned that Shopify
    provides us with access to an extensive font library. The `font_picker` type input
    allows us to create a font picker selector field that we can use to select any
    font inside the Shopify font library:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'One additional change to the standard set of attributes is that the `default`
    attribute is now mandatory. We can find the possible font handle values for the
    `default` attribute at the following link, [https://shopify.dev/themes/architecture/settings/fonts#available-fonts](https://shopify.dev/themes/architecture/settings/fonts#available-fonts),
    by clicking on the `font_picker` type input:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.19 – Example of the font_picker specialized input type'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_6.19_B17606.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 6.19 – Example of the font_picker specialized input type
  prefs: []
  type: TYPE_NORMAL
- en: Since the `default` value is mandatory, the `font_picker` value will always
    return a `font` object, allowing us to use the `font` filters and objects to manipulate
    the `font_picker` value to our needs.
  prefs: []
  type: TYPE_NORMAL
- en: 'Suppose we try to access the `font_picker` value using the regular approach,
    we would receive `FontDrop` as a result. To resolve this, we will include the
    `font_face` filter, which will generate the `@font-face` CSS:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'Declaring the `font_face` filter will automatically pull all the necessary
    information about the particular font and populate all the information inside
    `@font-face`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: With the `font_face` filter in place, we now have access to the selected font.
    However, with the current setup, we would have to hardcode the values to each
    `font-family`. So, let's learn how we can extract the `@font-face` attributes
    separately.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first thing that we need to do is to create a variable to which we will
    save the `font_picker` object value, after which we need to call the variable
    with the `font_face` filter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: With `font_face` declared, we now have easy access to `@font-face` from within
    the variable.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s say now that we wanted to modify particular attributes, such as `font-weight`
    and `font-style`, for specific elements. To achieve this type of functionality,
    we can use the `font_modify` filter, which accepts two properties, namely, the
    `style` property, which allows us to modify `font-style`, and `weight`, which
    we can use to modify the `font-weight` attribute:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: Note that we now have three different variables containing three different types
    of `@font-face`. All that is left now is to extract the specific attributes that
    we need and assign them to style the content.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can return the specific `@font-face` attribute values by using the `font`
    object''s `family`, `style`, and `weight` attributes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: We have now successfully learned how the `font_picker` input type works and,
    even more importantly, we have also learned how to use `font` objects and filters
    to output the `font_picker` values and make the font selection process entirely
    dynamic.
  prefs: []
  type: TYPE_NORMAL
- en: 'The only addition to the previous example that would make our code more functional
    is the inclusion of a fallback family if the selected font family cannot render
    for some reason. We can do this by introducing the `fallback_families` object,
    which will return a suggested fallback font family:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: For additional information on all the available font filters, we can refer to
    [https://shopify.dev/api/liquid/filters/font-filters](https://shopify.dev/api/liquid/filters/font-filters),
    and, for information on all the font objects available, we can refer to [https://shopify.dev/api/liquid/objects/font](https://shopify.dev/api/liquid/objects/font).
  prefs: []
  type: TYPE_NORMAL
- en: The article input
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `article` type input provides us with a special article picker selector
    field. Through the article picker, we have access to all the available articles
    in the store:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: Until recently, the `article` input type would always return a string handle
    of the article, which then needed to be used to recover the `article` object.
    However, since the Shopify Unite 2021 event, the `article` and other page-related
    inputs now return an object, making our work a lot easier.
  prefs: []
  type: TYPE_NORMAL
- en: 'Note that while the page-related input types will return an object from which
    we can extract any value we require, we will still sometimes find ourselves working
    on a theme where the theme uses the old method to retrieve the page-related input
    type object. For this reason, we will mention both approaches, since while we
    will not use the old approach, it is essential to know how it works if we ever
    need to work with it. In the following screenshot, we can see an example of the
    `article` input type:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.20 – Example of the article specialized input type'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_6.20_B17606.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 6.20 – Example of the article specialized input type
  prefs: []
  type: TYPE_NORMAL
- en: 'Since the `article` input value returns an object value, we already have full
    access to the `article` object and can easily retrieve any attribute that we might
    need:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: As we can see, now that the `article` input returns an object, accessing the
    object itself and retrieving the value of any attribute is almost effortless.
    Let's now look into the obsolete method to retrieve the `article` object using
    the article handle.
  prefs: []
  type: TYPE_NORMAL
- en: 'As mentioned previously, before the Shopify Unite 2021 event, the `article`
    input value returned a handle string. To access the `article` object, we will
    need to pluralize the name of the object we are trying to access, followed by
    a squared bracket `[]` notation, similar to what we did with the product handle
    in [*Chapter 2*](B17606_02_Final_PD_ePub.xhtml#_idTextAnchor030), *The Basic Flow
    of Liquid*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: We now have access to the `article` object and can easily output any type of
    article content to any part of the store. Note that while both approaches produce
    the same results, the second approach of recovering the page-related input object
    through its handle is now obsolete.
  prefs: []
  type: TYPE_NORMAL
- en: The blog input
  prefs: []
  type: TYPE_NORMAL
- en: 'The `blog` type input works similarly, as it provides us with a special blog
    picker selector field through which we have access to all the available articles
    in the store:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'Accessing the featured blog will always return a `blog` object or nil if the
    value has not yet been defined:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.21 – Example of the blog specialized input type'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_6.21_B17606.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 6.21 – Example of the blog specialized input type
  prefs: []
  type: TYPE_NORMAL
- en: 'Similar to the `article` object, we can directly access the `blog` object or
    retrieve it using squared brackets `[]` notation. The only difference is the changed
    `object` keyword:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: Once we have recovered the `blog` object, we can use the `for` tag to loop over
    all the articles inside the selected blog and render them correctly.
  prefs: []
  type: TYPE_NORMAL
- en: The collection input
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `collection` type input provides us with a special collection picker selector
    field, through which we will gain access to all the available products in the
    selected collection:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'Similar to the previous settings type, the returned value will be nil if we
    have not yet selected the collection. Otherwise, the returned value will return
    an object value that we can use to retrieve any object attribute value:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.22 – Example of the collection specialized input type'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_6.22_B17606.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 6.22 – Example of the collection specialized input type
  prefs: []
  type: TYPE_NORMAL
- en: 'Additionally, we can access the `collection` object directly or by pluralizing
    the object''s name we are trying to access, followed by a squared bracket `[]`
    notation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: With the `collection` object in place, we can now easily access all collection
    attributes.
  prefs: []
  type: TYPE_NORMAL
- en: The page input
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `page` type input provides us with another special selector field that
    allows us to access all of the pages previously created inside the admin **Page**
    section of our store:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'The **Featured page** value, when accessed, will always return an object value
    or nil if the value is not yet defined:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.23 – Example of the page specialized input type'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_6.23_B17606.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 6.23 – Example of the page specialized input type
  prefs: []
  type: TYPE_NORMAL
- en: 'We can access the `page` object directly or through a squared bracket `[]`
    notation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: Using the declared page variable, we now have access to the `page` object, which
    we can use to further access any attribute for the specific page.
  prefs: []
  type: TYPE_NORMAL
- en: The product input
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'As its name suggests, `product` provides us with a product input selector,
    which we can use to gain access to the `product` object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'Similar to the previous settings, when accessed, the value will return nil
    if the value is not yet defined or we''ll get an object value:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.24 – Example of the product specialized input type'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_6.24_B17606.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 6.24 – Example of the product specialized input type
  prefs: []
  type: TYPE_NORMAL
- en: 'We can use the returned object value to access an attribute value, or we can
    use the `product` object''s squared bracket `[]` notation to retrieve the object
    using the obsolete method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: Through the product variable, we can now access all attributes within the selected
    `product` object.
  prefs: []
  type: TYPE_NORMAL
- en: So far, we have learned about all the different types of input settings, whether
    they are basic or specialized input types, how we can access them, what additional
    attributes we can include with each of them, and what type of value we can expect
    to receive from them. However, simply stacking a significant number of settings
    inside a single category can be overwhelming if there is no order to those settings.
  prefs: []
  type: TYPE_NORMAL
- en: Organizing the theme editor
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous section, we have learned about different types of configurable
    settings, which allows us to easily update its value using a series of basic or
    specialized input selectors, where now we will learn about a different set of
    settings, **sidebar settings**. The sidebar settings will allow us to divide each
    category's settings into other separate blocks.
  prefs: []
  type: TYPE_NORMAL
- en: The sidebar settings do not hold any value, nor can we configure them through
    the theme editor. Their only use is to provide us with additional information
    and help us organize different sets of input settings into separate blocks for
    more straightforward navigation.
  prefs: []
  type: TYPE_NORMAL
- en: 'Under the sidebar settings, we can use the following options:'
  prefs: []
  type: TYPE_NORMAL
- en: '`header`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`paragraph`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'As opposed to the basic and specialized input settings, `header` and `paragraph`
    can only contain the following standard attributes:'
  prefs: []
  type: TYPE_NORMAL
- en: As its name indicates, the `type` attribute allows us to set the type of setting,
    whose value can be either a `header` or a `paragraph` setting. The `type` attribute
    is mandatory for both `header` and `paragraph`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: While the sidebar settings cannot contain any value, we can use the `content`
    attribute to output certain information to the theme editor. The `content` attribute
    is also mandatory for both `header` and `paragraph`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The final attribute, `info`, allows us to provide additional information regarding
    the `header` type setting. Note that `info` is not a mandatory attribute and we
    can only use it with the `header` type setting.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now that we have all the necessary information about the different types of
    sidebar settings and their attributes, let's look at each type of setting separately
    and learn how to use them.
  prefs: []
  type: TYPE_NORMAL
- en: The header type
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `header` type of setting, as its name suggests, allows us to create a header
    element and consequently group all of the setting input types inside a single
    block. Note that introducing the `header` type setting will automatically group
    all of the input type settings inside the category until it reaches another `header`
    element, or there are no more settings within the current category:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'As we can see, using the `header` type setting is relatively easy, where the
    benefit that we receive is quite significant, as now we can easily group related
    input settings. Additionally, by including the optional `info` attribute, we were
    able to include some additional information related to the specific block of settings,
    which we can see in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.25 – Example of the header sidebar type setting'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_6.25_B17606.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 6.25 – Example of the header sidebar type setting
  prefs: []
  type: TYPE_NORMAL
- en: We have now learned how to group related settings under the header name and
    include additional information about a particular block of settings. However,
    what if we needed to include an additional set of information to further describe
    a specific set of settings? To achieve this, we can use the following type of
    sidebar setting, `paragraph`.
  prefs: []
  type: TYPE_NORMAL
- en: The paragraph type
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As mentioned, the `paragraph` type of sidebar setting allows us to include
    additional information, similar to using the `info` attribute with the header
    type setting:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that including any additional attributes besides `type` and `content`
    with the `paragraph` type setting will result in an error. In the following screenshot,
    we can see an example using `paragraph` inside the theme editor:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.26 – Example of the paragraph sidebar type setting'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_6.26_B17606.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 6.26 – Example of the paragraph sidebar type setting
  prefs: []
  type: TYPE_NORMAL
- en: 'While we cannot include additional attributes, we can use the `content` attribute
    to create a direct link to a specific page, providing some additional information.
    We can do this by including the necessary information by using the following format:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'Including the direct link to a specific page will make our theme editor more
    concise. At the same time, it also allows us to include all the necessary information
    that someone using it might require:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: Note that we can create a direct link to any page within both the `content`
    and the `info` attributes on any type of setting that accepts the `info` attribute.
  prefs: []
  type: TYPE_NORMAL
- en: We have now learned about every type of input and sidebar type of setting. However,
    while it is essential to know all the current settings, it is also essential to
    mention some of the now deprecated settings, but which we may still encounter
    in our everyday work.
  prefs: []
  type: TYPE_NORMAL
- en: Glancing at the deprecated settings
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: While the following settings are no longer supported, there is a high probability
    that we might encounter them on older themes that their store owner never updated.
    Since these settings are no longer supported, we will not go into that much detail
    on how they work, but we will provide some general guidelines for identifying
    them and what they do.
  prefs: []
  type: TYPE_NORMAL
- en: The font input
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `font` input type of setting allowed us to generate a shortlist of font
    files accessible on Shopify:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: The introduction of the `font_picker` input type, which we have mentioned previously,
    made the `font` input type of setting obsolete.
  prefs: []
  type: TYPE_NORMAL
- en: The snippet input
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As its name suggests, the `snippet` input type allowed us to select any snippet
    file that we created previously within our theme and execute its content in a
    specific position:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: The introduction of `sections`, which we will learn about in the following chapter,
    has made the `snippet` input type of setting obsolete.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapters, we have abstained from going over every specific option,
    consequently creating a list of options that we need to learn to keep everything
    concise and to the point. However, in this chapter, we have gone over each option
    and carefully explained how to use it, when, and what we can expect, since, on
    account of their importance, we will use the knowledge that we have learned in
    this chapter on a regular basis.
  prefs: []
  type: TYPE_NORMAL
- en: We have learned how to generate some of the most basic input types, which we
    can use to output various types of content and types of input, allowing us to
    create additional logic related to specific content. Additionally, we have also
    learned how to output specialized input types, allowing us to create complex features
    with an easy and configurable interface.
  prefs: []
  type: TYPE_NORMAL
- en: Lastly, we have learned how we can organize the JSON settings into separate
    blocks for better readability. The knowledge that we have attained through this
    chapter will be helpful and tested in the following chapter.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will learn about sections and blocks, and use them to
    create section/block-specific settings that merchants can use through the theme
    editor to create re-usable sections.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What are the two types of input settings?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What's the issue that will cause an error with the following piece of code?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How can we include a custom font file within Shopify and use it throughout the
    theme editor?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What are the two issues that will prevent us from executing the following piece
    of code?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
