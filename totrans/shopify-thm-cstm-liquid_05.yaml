- en: '[*Chapter 3*](B17606_03_Final_PD_ePub.xhtml#_idTextAnchor047): Diving into
    Liquid Core with Tags'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapters, we saw some Liquid tags, such as control flow tags,
    in action. In this chapter, we will learn more about all the different tags we
    can use to modify our page content dynamically. We will learn about creating variable
    tags and theme tags and the best way to use them.
  prefs: []
  type: TYPE_NORMAL
- en: Learning about various types of iterations tags and parameters, we will gain
    the ability to execute blocks of code repeatedly, which will help us write better-quality
    code. Finally, we will mention some deprecated tags; they still appear in some
    older themes, so it is essential to know what they do and how to use them.
  prefs: []
  type: TYPE_NORMAL
- en: 'This chapter covers the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Controlling the flow of Liquid (control tags)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Variable tags
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Iterations tags
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Theme tags
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Deprecated tags
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This third chapter will expand our knowledge of logic and comparison operators
    and different data types by exploring Liquid programming logic.
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You will need an internet connection to follow the steps outlined in this chapter,
    considering that Shopify is a hosted service.
  prefs: []
  type: TYPE_NORMAL
- en: 'The dataset used in this chapter, in `*.csv` format, is available on GitHub:
    [https://github.com/PacktPublishing/Shopify-Theme-Customization-with-Liquid/blob/main/Product-data.csv](https://github.com/PacktPublishing/Shopify-Theme-Customization-with-Liquid/blob/main/Product-data.csv).'
  prefs: []
  type: TYPE_NORMAL
- en: 'The code for this chapter is available on GitHub: [https://github.com/PacktPublishing/Shopify-Theme-Customization-with-Liquid/tree/main/Chapter03](https://github.com/PacktPublishing/Shopify-Theme-Customization-with-Liquid/tree/main/Chapter03).'
  prefs: []
  type: TYPE_NORMAL
- en: 'The Code in Action video for the chapter can be found here: [https://bit.ly/3nP8uwG](https://bit.ly/3nP8uwG)'
  prefs: []
  type: TYPE_NORMAL
- en: Getting things ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before we can proceed, we will need to create some product and collection pages
    first, which we will be using throughout the following exercises.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the product page
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Generally, creating a page or a product page is a straightforward and intuitive
    process:'
  prefs: []
  type: TYPE_NORMAL
- en: We can start by navigating to the **Products** section in our sidebar and clicking
    the **Add products** button, automatically redirecting us to the page to define
    our product name, description, image, price, and other parameters. We will not
    go into too many details on managing a product. However, if you would like to
    read more about this topic, refer to [https://help.shopify.com/en/manual/products/add-update-products](https://help.shopify.com/en/manual/products/add-update-products).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: To avoid creating a significant number of products manually that we will require
    later, we will use already created products that we can find on GitHub. We have
    created a `.csv` file that allows us to easily create many products for our development
    store for this specific purpose. The only thing we need to do is download the
    file from [https://github.com/PacktPublishing/Shopify-Theme-Customization-with-Liquid/blob/main/Product-data.csv](https://github.com/PacktPublishing/Shopify-Theme-Customization-with-Liquid/blob/main/Product-data.csv)
    and import it to our store.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Once we have downloaded the file, click on the **Products** link within our
    sidebar, which will automatically position us in **All Products** after expanding.
    Click on the **Import** button to trigger a popup and start the process:![Figure
    3.1 – Example of starting the process of importing products
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/Figure_3.01_B17606.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Figure 3.1 – Example of starting the process of importing products
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: After selecting the `Product-data.csv` file, we can start the process by clicking
    the **Upload and continue** button:![Figure 3.2 – Selecting and uploading the
    .csv file into the store
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/Figure_3.02_B17606.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Figure 3.2 – Selecting and uploading the .csv file into the store
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'A few seconds later, we will see another popup previewing one of the products
    we are about to import. After confirming that the fields contain the correct information,
    we can finalize the import process by clicking on the **Import products** button:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 3.3 – Finalizing the process of uploading the products from the .csv
    file to the store'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_3.03_B17606.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.3 – Finalizing the process of uploading the products from the .csv
    file to the store
  prefs: []
  type: TYPE_NORMAL
- en: Creating the collection page
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now that we have filled our store with products, it is time to create some
    collection pages that we can then populate with our new products. The process
    of creating a collection page is as straightforward as that of the product page:'
  prefs: []
  type: TYPE_NORMAL
- en: We can start the process by clicking on the **Products** link in our sidebar
    and subsequently clicking on the **Collection** sub-link located in the extended
    **Products** menu.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Once inside, click on the **Create collection** button, automatically redirecting
    us to the page to define our collection name, description, assign products, and
    other parameters.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Considering that we have two types of products, we will create two collections
    and assign the same type of products to each collection. After clicking on the
    `Outdoor` as the collection name, and set **Collection type** to **Automated**
    so that we will not have to assign each product manually. The last step is to
    set **CONDITIONS** such that we should only populate the products whose type equals
    **Outdoor**:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 3.4 – Example of creating a collection and automatically populating
    it based on the product type'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_3.04_B17606.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.4 – Example of creating a collection and automatically populating it
    based on the product type
  prefs: []
  type: TYPE_NORMAL
- en: After saving the changes, our collection page will instantly be created and
    populated with the products that match our condition. Note that before we proceed,
    we should repeat the preceding steps for the **Indoor** collection, which we will
    need in the following chapters. If you would like to read more about managing
    a collection page, refer to [https://help.shopify.com/en/manual/products/collections](https://help.shopify.com/en/manual/products/collections).
  prefs: []
  type: TYPE_NORMAL
- en: Updating the navigation menu
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'For faster navigation, we can include the links to our two collections inside
    our main menu navigation:'
  prefs: []
  type: TYPE_NORMAL
- en: We can do this by clicking on **Online store** in our sidebar to expand it and
    consequently clicking on the **Navigation** link.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Once inside, we can add any number of links by opening **Main menu** and clicking
    on **Add menu item**. If you would like to read more about managing a navigation
    menu, refer to [https://help.shopify.com/en/manual/online-store/menus-and-links](https://help.shopify.com/en/manual/online-store/menus-and-links).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now that we have finished setting up both our product and collection pages,
    we can learn about Liquid programming logic.
  prefs: []
  type: TYPE_NORMAL
- en: Controlling the flow of Liquid
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the previous chapters, we saw some control flow tags, such as `if`, `and`,
    and `or`, in action; now we will dive further into this topic and learn about
    all the control flow types of tags and how to use them. Control flow tags are
    a type of Liquid programming logic that tells our Liquid code what to do by allowing
    us to be selective about which block of code should execute under specific conditions.
    We can divide the control flow tags into four separate groups:'
  prefs: []
  type: TYPE_NORMAL
- en: '`if/else/elsif`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`and/or`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`case/when`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`unless`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The if/else/elsif tags
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We have had the pleasure of seeing the conditional `if` statement in some of
    our previous examples, which, if proved true, execute the code inside our statement.
    Let's see it in action. In the previous chapter, we created the **Learning about
    the page handle** page.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, let''s try and create a new page for this exercise to solidify our
    knowledge and keep everything concise:'
  prefs: []
  type: TYPE_NORMAL
- en: Let's start by creating a new page named **Controlling the flow of Liquid**,
    which we will continue to use going forward. Suppose we need to remind ourselves
    how to create a new page; we can revisit the previous chapter and consult the
    *EmptyDrop* subsection, located under the *Understand the types of data* section,
    where we previously outlined the process of creating a new page.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: After creating the new page, it is time to edit our newly created page template
    file. We need to navigate to the **Themes** section, located under the **Online
    store** area, click the **Actions** button on the duplicate theme we have created,
    and select the **Edit code** option, which will open our code editor.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Once inside the code editor, find the template currently assigned to our page.
    In our case, the template name is `page.liquid`, so click on it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Currently, our page consists of two Liquid elements: `{{ page.title }}`, which
    generates the title of the page, and `{{ page.content }}`, which generates the
    content of our page, along with a few HTML elements. However, *what if our* `{{
    page.content }}` *is empty?* We would end up with an empty `div` element:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 3.5 – Example of the empty element on a page'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_3.5_B17606.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.5 – Example of the empty element on a page
  prefs: []
  type: TYPE_NORMAL
- en: 'To solve this, we can wrap `{{ page.content }}` along with the `div` that encapsulates
    it within a conditional that will check whether the content of the page is empty:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: We are now sure that we will not see any extra empty strings and elements on
    our page with the conditional in place.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s now try to include some kind of placeholder text instead and let anyone
    who visits our page know that we will add the page content shortly. This is where
    the `else` and `elsif` statements come to help us. With the addition of `else`
    and `elsif`, we can create multiple conditions to ensure that we execute our code
    correctly:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s start by adding the `else` condition before `{% endif %}` to execute
    a different result when our `{{ page.content }}` is empty:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Let''s try to improve our page by adding a statement to check whether we have
    started working on our page content and update our notification message accordingly.
    We can do this by adding an `elsif` statement to check whether our page content
    has more than 100 characters. However, for this to work, we will also need to
    modify the existing `if` statement by altering the existing conditional to display
    the page content if it has `100` or more characters:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: With the two conditionals in place, our page should have enough information
    for anyone visiting our page. However, if we look closely at our statements, we
    will see that the `{% else %}` statement will never execute since the page content
    will either have more than 100 characters or less than 100 characters. As we recall,
    we can execute only one statement within a single block. To resolve this issue,
    we will need to use the `and` operator to ensure that all statements in our code
    block are working correctly.
  prefs: []
  type: TYPE_NORMAL
- en: The and/or tags
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As we recall from the previous chapter, the `and` and `or` operators let us
    include more than one condition in a control flow tag, allowing us to create complex
    conditionals.
  prefs: []
  type: TYPE_NORMAL
- en: 'Using the `and` operator, we can chain another condition to the existing statement,
    which will only return `true` if both the left and right sides of the statement
    are true. Let''s try to include another conditional within our `elsif` statement
    that checks whether the page content has any content:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: With the addition of the second condition, we have ensured that our control
    flow tag will execute correctly. The first statement will return `true` if the
    page content has more than `100` characters, the second statement will return
    `true` if the page content has less than `100` characters and the page is not
    empty. And finally, if both previous statements return `false`, the code inside
    the `else` statement will execute.
  prefs: []
  type: TYPE_NORMAL
- en: Similar to the `and` parameter, the `or` parameter allows us to chain another
    condition to the tag. However, the critical difference is that for a statement
    with the `and` parameter to return `true`, both the left and right sides of the
    conditional had to return `true`. We only need at least one condition to return
    `true` with the `or` parameter, which will make that statement truthy, and the
    code inside will execute.
  prefs: []
  type: TYPE_NORMAL
- en: The case/when tags
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As with the `if/elsif/else` conditions, `case/when` is a type of control flow
    tag we can use to create a `switch` statement, which allows us to execute a particular
    block of code only when the returned value is an exact match. We can use `case`
    to initialize the `switch` statement, and we can use `when` to set the conditions
    in a specific order that we want them executed in.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s return to the `page.liquid` template that we have previously worked
    on and create a `switch` statement that will check the exact number of characters
    our page content has and render the appropriate message depending on which statement
    is true. We can include this functionality above the first `if` statement we have
    added:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding example, we have initialized the `case` tag with `page.content.size`,
    allowing us to use `when` statements to check whether the number of characters
    in a page''s content is strictly equal to our values. Notice that `when` statements
    hold no comparing variables. This is because `when` statement accepts only a value
    as a parameter and will return `true` only if the value is an exact match:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.7 – Example of executing the case/when tag'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_3.07_B17606.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.7 – Example of executing the case/when tag
  prefs: []
  type: TYPE_NORMAL
- en: With our control flow tag in place, if we enter `150` characters as our page
    content, the first `when` statement returns `true`, and as a result, we can see
    our message. In comparison, it might not look like a powerful tag considering
    that we can only use it to match the exact values as opposed to the `if/elsif/else`
    tag. However, the `case/when` tags are a mighty piece of programming logic; we
    will be using them in the following chapters of the book to create complex functionalities.
  prefs: []
  type: TYPE_NORMAL
- en: As we recall, any code added directly to the template file will get executed
    on all of the pages using that particular template. And since we have added all
    of our previous code to the `page.liquid` template, we should ensure that we only
    execute the previously added code on the `unless` tag.
  prefs: []
  type: TYPE_NORMAL
- en: The unless tag
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Similar to an `if` tag, which allows us to check the state of a specific condition,
    the `unless` tag allows us to check if we have not met the condition:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'We can add the opening statement of the `unless` tag just above our opening
    `case` tag and add the closing statement below the closing statement for our `if/elsif/else`
    tag:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.8 – Example of the entire code related to the control flow of Liquid'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_3.8_B17606.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.8 – Example of the entire code related to the control flow of Liquid
  prefs: []
  type: TYPE_NORMAL
- en: With the `unless` statement in place, we have ensured that all of our code will
    only execute on this particular page and will not affect any other page that uses
    the same `page.liquid` template file.
  prefs: []
  type: TYPE_NORMAL
- en: By learning about all the different types of control flow tags, we have taken
    a step forward in mastering Liquid programming logic, which will serve as a stepping
    stone to much more significant and complex things that await us.
  prefs: []
  type: TYPE_NORMAL
- en: In the previous chapter, we have mentioned various data types, such as strings,
    numbers, and Booleans, and how we can use them. However, what if we wanted to
    save any of these data types and re-use them on multiple locations without manually
    updating each line? This is where *variables* come into play.
  prefs: []
  type: TYPE_NORMAL
- en: Variable tags
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We can consider variables as data containers to save the various types of information
    that we want to use later in our code or overwrite as needed. Besides saving the
    information for later use, variables also allow us to use descriptive text as
    a label, allowing us to understand what type of information a particular variable
    contains. We can divide the variable tags into the following four groups:'
  prefs: []
  type: TYPE_NORMAL
- en: '`assign`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`capture`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`increment`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`decrement`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The assign tag
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `assign` tag allows us to declare a variable to which we can assign string,
    number, or Boolean data. We can declare a variable by writing the `assign` keyword
    followed by the name of the variable we are declaring, followed by the equal sign
    and the date we assign to that particular variant, and encapsulating it within
    the curly brace delimiters with percentage symbols:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Once we declare a variable, we can call it as many times as we need by encapsulating
    the variable''s name within double curly brace delimiters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Calling our three variables will generate the same type of data that we have
    initially assigned to each variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that calling a variable using the double curly brace delimiters will return
    the variable value when called on its own. If we wanted to use a variable within
    a `for` tag or an `if` statement, we would call the variable only using its name,
    without the double curly brace delimiters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: We have used our previously declared variable inside a multiple `if` statement
    to determine our variable's value. Since our variable value is equal to the compared
    value of the first statement, the first statement will return `true`.
  prefs: []
  type: TYPE_NORMAL
- en: So far, we have learned how to assign a single type of data to a variable, *but
    what if we wanted to create a variable that will store a combination of a string
    and a variable?* To achieve this, we will need the help of another type of variable
    tag called `capture`.
  prefs: []
  type: TYPE_NORMAL
- en: The capture tag
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As opposed to the `assign` tag, which only allowed us to capture a single value,
    `capture` allows us to capture multiple values using its start and end closing
    tags. We can declare a `capture` variable with a set of curly brace delimiters
    with percentage symbols around the word `capture` followed by the name of the
    variable we are declaring:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'In the previous example, we initially defined two variables using the `assign`
    tag, one containing the number value and one containing the string. Once we have
    declared the two variables, we have again declared a new variable using the `capture`
    tag. We have included a string message containing both the previously defined
    variables, and finally, we have called the `promoMessage` variable by wrapping
    it inside double curly brace delimiters to see the result of our work:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: As we can see, using the `capture` tag, we successfully created a complex string
    message, which will come in handy as we progress further with our knowledge.
  prefs: []
  type: TYPE_NORMAL
- en: 'Important note:'
  prefs: []
  type: TYPE_NORMAL
- en: While the `capture` tag accepts all data types, as we had the chance to see
    in the previous example, the result of calling the capture variable will always
    return string data.
  prefs: []
  type: TYPE_NORMAL
- en: Using the `assign` tag, we have learned how to create new variables where we
    can store a single type of data. Using the `capture` variables, we have learned
    how to create complex strings using different variables, *but how would we create
    a variable whose content is a number value that acts as a counter?*
  prefs: []
  type: TYPE_NORMAL
- en: The increment tag
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As opposed to the `assign` and `capture` tags, the `increment` tag does not
    need to be declared first. Instead, we will automatically create the variable
    as soon as we call it the first time. The `increment` tag allows us to auto-create
    a variable and increment it every time we call the variable using the `increment`
    tag. We can call an `increment` variable with a set of curly brace delimiters
    with percentage symbols around the word `increment` followed by the name of the
    variable we are creating:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: The starting value of this and any other variable created using the `increment`
    tag will always be zero.
  prefs: []
  type: TYPE_NORMAL
- en: 'Important note:'
  prefs: []
  type: TYPE_NORMAL
- en: Calling the `increment` variable will not only automatically generate and increment
    the value starting with zero, but it will also automatically output the content
    of the variable in the template we are working on.
  prefs: []
  type: TYPE_NORMAL
- en: 'Considering that the `increment` tag automatically outputs the value as soon
    as the tag is called, it has a pretty limited usage. The most common use is to
    auto-generate the unique numbered identifiers for HTML elements:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'The result from our previous example will allow us to create a unique ID for
    each `div` element, starting with zero for the first occurrence of the `increment`
    tag and increasing its value by one for each next occurrence:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'One more critical aspect of the `increment` tag is that it works independently
    from variables created using `assign` or `capture` tags. Let''s try to create
    a variable using the `assign` tag and see what happens when we try to increment
    it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Initially, we created the variable and have assigned it a value of `7`, after
    which we used the `increment` tag to call the variable with the same name twice.
    Finally, we called the variable that we initially created using the `assign` tag:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: As we can see from our results, even though we have already declared the `numberVar`
    variable using the `assign` tag and have assigned it a value of `7`, the `increment`
    tag has started incrementing the values starting with `0`. They might share the
    same name, but they are entirely different variables. The `increment` variable
    will not affect the initially created variable in any way and vice versa.
  prefs: []
  type: TYPE_NORMAL
- en: 'Important note:'
  prefs: []
  type: TYPE_NORMAL
- en: Note that a variable created using the `increment` tag cannot be called independently
    without the `increment` tag or used as a logic parameter, as opposed to the case
    with the `assign` and `capture` tags.
  prefs: []
  type: TYPE_NORMAL
- en: We have now learned how to create an independent variable tag to create a unique
    element identifier for any number of elements. However, suppose, for some reason,
    that we needed a variable that outputs the negative values for a large number
    of elements. For this functionality, we will need to use a different type of variable
    tag, named `decrement`.
  prefs: []
  type: TYPE_NORMAL
- en: The decrement tag
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Besides using a `decrement` keyword to initialize the variable, the `decrement`
    tag differs from the `increment` tag in two key aspects:'
  prefs: []
  type: TYPE_NORMAL
- en: The first one is that `decrement` allows us to decrease the variable value by
    one for each occurrence.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The second one is that the initial value starts with a negative value of minus
    one.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In the following example, we can see an example of calling the `decrement`
    tag three times using the same variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'In this initial example, we have called the `decrement` tag three times. Since
    the `decrement` variable starts with a negative value, after calling it three
    times, we will receive the following values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Important note:'
  prefs: []
  type: TYPE_NORMAL
- en: Besides the two differences that we have made, `decrement` shares all the rules
    and limitations of the `increment` tag, meaning that the `decrement` tag works
    independently of the variables created using the `assign` and `capture` methods.
    We cannot call it independently without initializing the `decrement` tag.
  prefs: []
  type: TYPE_NORMAL
- en: Variables are a potent tool that, combined with the iteration tags, will bring
    us one step closer to writing more concise and reusable code.
  prefs: []
  type: TYPE_NORMAL
- en: Iterations tags
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Iterations tags** are different Liquid programming logic types that allow
    us to run blocks of code repeatedly. Using iteration tags will save us the time
    that it would otherwise take us to execute code for each occurrence manually;
    plus, it will make our code much more concise and readable. To keep the topic
    concise, we will only mention some of the most used iteration tags and their parameters,
    which is more important than listing them all as they are all created using similar
    concepts. We can divide the iteration tags into four separate groups:'
  prefs: []
  type: TYPE_NORMAL
- en: '`for/else`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`jump` statements'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`for` parameters'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`cycle`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The for/else tags
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the previous chapter, we had the chance to use the `for` loop in one of our
    examples when we explained the arrays inside the *Understand the types of data*
    topic. However, we have not had the chance to explain all the possibilities that
    the `for` loop gives us. The `for` loop is a type of Liquid programming logic
    that allows us to loop over any code block or array and output the result of that
    loop for further use.
  prefs: []
  type: TYPE_NORMAL
- en: Previously, we have worked on the `page.liquid` template, but now, we will move
    on to the `collection.liquid` template.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s start by writing a `for` loop tag that will list all of our product
    names and place them under the `{% section ''collection-template'' %}` line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'In the previous example, we used a `for` tag followed by the `product` variable
    to loop over the `collection.products` object and return the names of the products
    currently assigned to our collection, which we can see on our **Indoor** collection
    page:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.9 – Example of using a for loop to list the names of the products'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_3.09_B17606.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.9 – Example of using a for loop to list the names of the products
  prefs: []
  type: TYPE_NORMAL
- en: While our `for` loop did make it work, and we can see our product names listed,
    this is not of much use since we already have those same products listed. Let's
    use what we learned in the previous chapter when we talked about different ways
    of accessing the page handles' objects in the *EmptyDrop* subsection, which we
    can find under the *Understand the types of data* section.
  prefs: []
  type: TYPE_NORMAL
- en: 'With our current code in place, we are reading the products of the collection
    we are currently visiting. Instead, let''s try and access the products located
    in our second collection named `outdoor`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Even though we are currently previewing the `Indoor` collection, we have now
    gained a list of products that belong to the `Outdoor` collection.
  prefs: []
  type: TYPE_NORMAL
- en: jump statements
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As their name suggests, `jump` statements allow us to set the conditions that
    exclude certain items from our loop or stop our loop when we meet a specific condition.
    We can split `jump` statements into the two following groups:'
  prefs: []
  type: TYPE_NORMAL
- en: '`continue`: The `{% continue %}` statement allows us to skip the current iteration
    based on the condition that we have set. We can use it to exclude certain products
    from our `for` loop by pairing it with an `if` statement only to accept a product
    whose price is lower than $100.00\. Otherwise, we should exclude the product from
    the loop:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`break`: The `{% break %}` statement, on the other hand, allows us to stop
    the loop when we met a specific condition:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: For example, with `{% continue %}`, our loop returned six products that match
    our condition. However, when we replace `{% continue %}` with `{% break %}`, our
    loop returned zero results. Since the first product inside the `Outdoor` collection,
    whose handle we are using, has a price of $200.00, we have met our condition on
    the first iteration, which caused `{% break %}` to stop the iteration, preventing
    all other iterations.
  prefs: []
  type: TYPE_NORMAL
- en: The for parameters
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In addition to `jump` statements, we also have various parameters that we can
    use further to define the loop''s limits and workflow. We can split the parameters
    that we can use in conjunction with the `for` loop into the four following groups:'
  prefs: []
  type: TYPE_NORMAL
- en: '`limit`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`offset`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`range`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`reversed`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: limit
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As its name suggests, the `limit` parameter limits how many iterations our loop
    should perform. We can add `limit` parameters at the end of the opening `for`
    loop tag, followed by a colon, followed by a number value.
  prefs: []
  type: TYPE_NORMAL
- en: We usually use `limit` parameters when we require a particular number of iterations
    without implementing any condition. This is because the `limit` parameter only
    measures the number of iterations, not whether the number of iterations matches
    the statement we have in place.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s start by adjusting our previous example by replacing `{% break %}` with
    `{% continue %}` and adding the `limit` parameter with the value of `4`, which
    is the maximum number of products that we are looking to get as a result:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: In our previous example, before adding the `limit` parameter, our `for` loop
    returned six product iterations whose price was lower than $100.00\. With the
    addition of the `limit` parameter, the number of iterations returned was `3`,
    even though we set our limit to `4`. *Why?*
  prefs: []
  type: TYPE_NORMAL
- en: Similar to the `{% break %}` statement we mentioned earlier, the `limit` parameter's
    aim is to limit the number of iterations to the assigned value. Let's open our
    `Outdoor` collection, whose handle we are using to loop over. We will notice that
    the first product in that collection has a price of $200.00, which triggered the
    `if` statement, subsequently triggering the `{% continue %}` statement, which
    excluded the first product.
  prefs: []
  type: TYPE_NORMAL
- en: As a result, our `for` loop did not print out that product name. However, the
    `limit` parameter still counts this as one iteration, meaning that it will perform
    three more iterations. Since the following three products' prices were lower than
    $100.00, the three products' names were returned by our `for` loop before stopping.
    For this reason, the `limit` parameter is usually only used in a loop without
    any statements. Otherwise, we risk not meeting the number of iterations we intended,
    or any at all, since the result can also be zero iterations if none matches the
    statement that we have set.
  prefs: []
  type: TYPE_NORMAL
- en: The offset parameter
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `offset` parameter allows us to delay the start of the `for` loop by starting
    the loop from the specific index. We can add an `offset` parameter at the end
    of the opening `for` loop tag, followed by a colon, followed by a number value.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take our previous example and try replacing `limit` with the `offset`
    parameter and setting its value to `4`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Our `for` loop has automatically skipped the first four product iterations and
    has started iterating the products at index number `5`, resulting in our `for`
    loop returning three product iterations. *However, what if we also include the*
    `limit` *parameter after the* `offset` *parameter and set its value to* `1`*?*
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: While at first, it might look like the previous example will not work, this
    is a fully functional loop with valid parameters. As we have previously mentioned,
    the `limit` parameter allows us to limit a `for` loop to a specific number of
    iterations. With two parameters added, our `for` loop will start its iteration
    at index `5`. It will cover one iteration as per the value set with the `limit`
    parameter, and then it will stop the `for` loop, regardless of whether the one
    iteration managed to get past our `if` statement.
  prefs: []
  type: TYPE_NORMAL
- en: The range parameter
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `range` parameter offers us similar functionality to the `offset` parameter.
    The critical difference is that with `range`, we can assign both starting and
    ending index positions. We can add a `range` parameter at the end of the opening
    `for` loop tag by writing opening brace delimiters followed by the starting value,
    followed by two dots, and finally followed by end value and closing brace delimiters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'As we recall, the `offset` parameter does not include the starting position
    index within the loop. Instead, it starts its loop from the next position, where
    the range is inclusive for both starting and ending position values. The result
    of our `for` loop example with the `range` parameter set to `(3..5)` would result
    in the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Besides accepting the number as its value, as we were able to see in our previous
    example, `range` also allows us to place variables and objects as both its starting
    and ending values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: The result of our `for` loop example would return all iterations starting at
    index `3`, all the way to the number of products our collection has. With the
    ability to assign variables and objects as our starting or ending points, we can
    now create reusable `for` loops resulting in more concise and better-quality code.
  prefs: []
  type: TYPE_NORMAL
- en: The reversed parameter
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The final parameter on our list is `reversed`, which, as its name suggests,
    allows us to reverse the order of iteration. The `reversed` parameter does not
    have any value representation, and we can include it at the end of the opening
    `for` loop tag:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'In the previous example, we have added the `reversed` parameter as a secondary
    parameter next to our `range` parameter, resulting in our tag performing iteration
    in reverse order:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: As we have had the chance to see for ourselves, parameters are a powerful addition
    to the `for` tag, which we can use to achieve the necessary type of iteration
    and get only the results we require.
  prefs: []
  type: TYPE_NORMAL
- en: The cycle tag
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`cycle` is another powerful tag that we can only use in combination with the
    `for` tag to loop over a group of strings and output them to each iteration in
    the specific order in which they were initially defined. We can define the `cycle`
    tag by opening curly brace delimiters with a percentage symbol, followed by the
    word `cycle`, followed by any number of strings separated by commas. Finally,
    we close the `cycle` tag with closing brace delimiters and a percentage symbol:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'In the previous example, we have included a `cycle` tag with four different
    strings inside a `for` loop, which we have limited to four iterations. By implementing
    the `cycle` tag, we have ensured that our first `div` element will receive a class
    first, the fourth element will receive a `last` class, while the two elements
    in between will receive no classes as the two strings for those positions are
    empty:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: From our result, we can see that the `cycle` tag is quite a valuable tool that
    we can use to pass data to a specific iteration within a loop in an order that
    we have defined. *However, what would happen if we removed the limit from our
    loop or increased it to have nine iterations instead?*
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'In our previous example, we had the exact same number of iterations as the
    number of strings inside the `cycle` tag. In our newest example, the number of
    iterations is higher than the number of strings, which means that the cycle will
    reset and start applying strings again, in order, for as many iterations as needed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: So far, we have learned the basic use of the `cycle` tag and that the tag will
    continue to output strings for as many iterations as possible, which is quite
    helpful if we have a single `cycle` tag, *but what if we have two or more?*
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'In the previous example, we have created two separate `for` loops, the first
    one limited to six iterations and the second limited to four. As we have just
    learned, no matter how many strings we have defined inside the `cycle` tag, the
    tag will continue to output strings for as many iterations as needed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: As we can see from the results, the first `for` loop has created six iterations
    in the exact order that we intended. However, the second `for` loop did not produce
    the same results. Instead, it continued to output the strings starting from the
    exact position where the previous `cycle` tag stopped.
  prefs: []
  type: TYPE_NORMAL
- en: This type of behavior is logical considering that Liquid currently cannot differentiate
    between different types of `cycle` tags. However, we can easily resolve this by
    introducing a parameter called the **cycle group**.
  prefs: []
  type: TYPE_NORMAL
- en: 'The cycle group parameter allows us to separate `cycle` tags by ensuring that
    each cycle will output strings starting with position one, regardless of whether
    or not we have already used a `cycle` tag on the same page. After the `cycle`
    keyword, we can include the cycle group parameter by adding the string name encapsulated
    by parentheses, followed by a colon:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'The introduction of the cycle group parameter ensures that each `cycle` tag
    functions independently:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: We can see from our results that all iterations have received the string initially
    intended for them even though we have more than one `cycle` tag.
  prefs: []
  type: TYPE_NORMAL
- en: Besides the `for` and `cycle` tags, we have one more type of iteration tag called
    `tablerow`, which works similarly to the `for` tag. The only difference between
    the two tags is that `tablerow` returns results formatted as an HTML table. To
    keep the book concise, we will not be covering the `tablerow` tag or its parameters
    in this book. However, if you would like to read more about it, refer to [https://shopify.dev/docs/themes/liquid/reference/tags/iteration-tags](https://shopify.dev/docs/themes/liquid/reference/tags/iteration-tags).
  prefs: []
  type: TYPE_NORMAL
- en: Theme tags
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Theme tags** are a special type of tag that give us specific control over
    both *un-rendered and rendered code*. Using the various types of theme tags that
    we have at our disposal, we can create a different type of HTML markup for specific
    templates that is essential for creating a form that will allow customers to purchase
    products from our store. Additionally, they allow us to select different theme
    layouts to use for different pages, define sections or snippet files that we can
    use to create reusable blocks of code, and many other things. We can divide theme
    tags into the following groups:'
  prefs: []
  type: TYPE_NORMAL
- en: '`layout`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`liquid` and `echo`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`form`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`paginate`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`render`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`raw`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`comment`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The layout tag
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As we recall from the first chapter, when discussing the `Layout` directory,
    we mentioned the importance of the `theme.liquid` file as it is in this file that
    we will render all of our files and templates. It is in this file that we arrange
    the general layout of our pages.
  prefs: []
  type: TYPE_NORMAL
- en: 'Our pages currently consist of three key elements: **header**, **main content**,
    and **footer**. Let''s say we wanted to remove the header and footer sections
    from our product pages, or at the very least to replace them with a different
    set of headers and footers. *How would we do this?*'
  prefs: []
  type: TYPE_NORMAL
- en: The first step to achieve this would be to create an alternate layout file that
    our theme product pages will use instead. We can do this by expanding the **Layout**
    directory in our code editor and clicking on the **Add a new layout** button,
    which will trigger a popup to select the type of layout page we are looking to
    create and select the name for our new page.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Within the drop-down menu, we will select the `alternate` as our filename.
    Once we have finished selecting our layout file type and name, click on the **Create
    layout** button to finalize the process:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 3.10 – Example of creating a new layout file'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_3.10_B17606.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.10 – Example of creating a new layout file
  prefs: []
  type: TYPE_NORMAL
- en: With this, we have successfully created a new layout file named `theme.alternate.liquid`.
    Suppose we tried to compare this file with our original `theme.liquid`; we would
    see that they are exactly the same. The reason for this is that when we create
    a new page, layout, or template, Shopify will not create a new page entirely,
    but it will copy a default page that our theme is already using. For example,
    if we were to expand the `page.liquid` file.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have created a new layout file, we will assign it to our product
    pages. We can do this by expanding the `product.liquid` file where we can define
    the layout for this particular template, which we should include on the very first
    line of the file. We can define the `layout` tag with a set of curly brace delimiters
    with percentage symbols around the word `layout`, followed by the name of the
    layout file, which we should encapsulate within parentheses:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: If we were to navigate to the `{% section 'header' %}` and `{% section 'footer'
    %}`, the header and footer sections would no longer be visible on our product
    page. However, they would still be visible on pages that use the original `theme.liquid`
    layout.
  prefs: []
  type: TYPE_NORMAL
- en: 'Important note:'
  prefs: []
  type: TYPE_NORMAL
- en: Besides the name of the layout file, the `layout` tag also accepts the `none`
    keyword, without parentheses, as its value, in which case the page will use no
    layout file. In this case, the particular page using this particular template
    will have no access to any code or file, including `.css`, `.js`, or others that
    we initially loaded through the `theme.liquid` file.
  prefs: []
  type: TYPE_NORMAL
- en: Any template file that does not contain the `layout` tag will, by default, use
    the original `theme.liquid` layout as a failsafe.
  prefs: []
  type: TYPE_NORMAL
- en: The liquid and echo tags
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `liquid` tag is one of the newest additions to Liquid, and it is quite a
    powerful one as it allows us to write multiple tags within one set of delimiters,
    making our code a lot easier to read and maintain. We can define the liquid tag
    with a curly brace delimiter and a percentage symbol on the left side of the word
    liquid followed by as many lines of `Liquid` code as we need. Note that we only
    need to define an opening `liquid` tag, where the `liquid` closing tag is automatically
    closed.
  prefs: []
  type: TYPE_NORMAL
- en: The `echo` tag is an addition to the `liquid` tag that allows us to output an
    expression that initially we had to wrap inside double curly brace delimiters.
    We can define the `echo` tag by simply writing an `echo` keyword, followed by
    any expression that we are using.
  prefs: []
  type: TYPE_NORMAL
- en: Let's try and use our `liquid` and `echo` tags to refactor the code that we
    had previously added to our collection template when we learned about the different
    types of iterations.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here, we can see the code that we initially created on our collection page:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'We can see the same code in the following example after refactoring using the
    `liquid` and `echo` tags:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: After refactoring our code, we can see that we have removed all curly brace
    delimiters with percentages and replaced all double curly brace delimiters with
    the `echo` tag. The only curly brace delimiters with percentage symbols left are
    the ones that belong to the `liquid` tag, encapsulating the entire code.
  prefs: []
  type: TYPE_NORMAL
- en: 'Important note:'
  prefs: []
  type: TYPE_NORMAL
- en: While `liquid` and `echo` tags are pretty powerful, we should not use them regularly,
    as while they help us write multiple tags within one set of delimiters, they are
    not so kind when it comes to working with strings. The `echo` tag forces us to
    wrap every string within the parentheses, making it almost impossible to use non-string
    data values inside the string.
  prefs: []
  type: TYPE_NORMAL
- en: The form tag
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `form` tag allows us to automatically output various types of HTML `<form>`
    along with the required `<input>` elements, depending on the type of the `form`
    tag we have called. We can define the `form` tag within a pair of curly brace
    delimiters, followed by the `form` keyword, followed by the form''s name encapsulated
    by parentheses, and lastly, followed by the closing `endfor` tag surrounded by
    curly brace delimiters with percentage symbols:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: In the previous example, we have selected to generate the product form tag by
    using the `product` keyword within the parentheses. However, notice that following
    the comma, we also have another `product` keyword without parentheses. Certain
    forms, such as product forms that we are currently using, require us to pass them
    a parameter to generate the proper content. In this case, that parameter is the
    `product` object.
  prefs: []
  type: TYPE_NORMAL
- en: The most common use for this is on a product page. However, we can also use
    the `form` tag within a collection page or anywhere else where we have access
    to the `product` object. Let's try to include a `form` tag within the loop that
    we previously created on our collection page.
  prefs: []
  type: TYPE_NORMAL
- en: 'Since we will be dealing with a mix of strings and non-strings data, let''s
    first undo the `liquid` and `echo` changes that we previously made. We can do
    this by clicking on the **Older versions** button, located between the file''s
    name and the **Delete file** button:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.11 – Example of reverting changes in the file'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_3.11_B17606.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.11 – Example of reverting changes in the file
  prefs: []
  type: TYPE_NORMAL
- en: Clicking the **Older versions** button will reveal the drop-down menu where
    we can see the date and time of all the changes that we have made within this
    particular file. Each date represents the last time that we pressed the **Save**
    button to save our changes. Selecting any option will automatically revert our
    code to that particular point.
  prefs: []
  type: TYPE_NORMAL
- en: 'After reverting our changes, we are ready to add the `form` tag to our `for`
    loop:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: By introducing the `form` tag within our `for` loop, we have generated an HTML
    form tag that we can see by inspecting the string elements that we see on our
    `Indoor` collection page. While the `form` tag is functional, we still lack one
    key ingredient to make our form usable, which we will be learning in the next
    chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can see that our `form` tag already has quite a few attributes by inspecting
    our collection page. *However, what if we wanted to add some of our own or modify
    the existing ones?* We can do this by simply adding the attribute name, followed
    by a comma, followed by the attribute''s value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: In the previous example, we have included a data attribute in our form using
    a string. However, we have also modified the existing ID value using the previously
    defined variable.
  prefs: []
  type: TYPE_NORMAL
- en: Notice that while we can directly include the variable within the attribute
    value, we cannot mix the string and variable within the `form` tag itself. For
    this reason, we have previously captured the combined string and `increment` tag
    using the `capture` tag and called it the attribute value using the variable name.
  prefs: []
  type: TYPE_NORMAL
- en: 'Besides the ability to pass an object as a `form` parameter, the `form` tag
    provides us with one special parameter named the `return_to` parameter. By default,
    when we submit the product form, we are usually redirected to the cart page. However,
    with the `return_to` parameter, we can select the page we should land on after
    we submit the form:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: In our previous example, we have assigned the `back` value as a string for the
    `return_to` parameter, which will automatically return us to the same page we
    were on before submitting the form. Besides the `back` string, we can also use
    a relative path or a `routes` attribute to generate a dynamic URL to the page
    we should land on once we submit the form.
  prefs: []
  type: TYPE_NORMAL
- en: There are many types of form tags that we can use. However, as they are all
    created using the same format, we will only cover one example. For more information
    on different types of `form` tags and their parameters, refer to [https://shopify.dev/docs/themes/liquid/reference/tags/theme-tags#form](https://shopify.dev/docs/themes/liquid/reference/tags/theme-tags#form).
  prefs: []
  type: TYPE_NORMAL
- en: The paginate tag
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Previously, we have learned all about iteration tags, which we can use to repeatedly
    execute a code block. However, iteration tags have a limitation that means they
    can only output a maximum of 50 results per page. For any higher number of iterations,
    we would need to use the `paginate` tag to split the results across multiple pages.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `paginate` tag must always wrap around a `for` tag that is looping over
    an array to be able to split the content into multiple pages. We can see an example
    of a `paginate` tag wrapping a `for` loop here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: As we can see from our example, the `paginate` tag contains the `paginate` keyword,
    followed by the object that returns an array of products in the collection, followed
    by the `by` parameter and the number value. Depending on the number value that
    we include with the `by` parameter, which can go from one to fifty, the `paginate`
    tag will know the maximum number of items it should present per page. Inside the
    `paginate` tag, we can access attributes of the `paginate` object. To keep the
    book concise, we will not be going into detail regarding the `paginate` object.
    For detailed information, refer to [https://shopify.dev/docs/themes/liquid/reference/objects/paginate](https://shopify.dev/docs/themes/liquid/reference/objects/paginate).
  prefs: []
  type: TYPE_NORMAL
- en: The render tag
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `render` tag allows us to render the content of a snippet file to a place
    of our choosing. As we recall from [*Chapter 1*](B17606_01_Final_PD_ePub.xhtml#_idTextAnchor015),
    *Getting Started with Shopify*, snippet files allow us to re-use repetitive pieces
    of code over **Templates**/**Sections** by referencing their names:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: As we can see from our example, we only need to use the `render` keyword, followed
    by the name of the snippet file, and we will render any content within our snippet
    file. By using the snippet file, we not only make our code more readable, but
    we also make it easier to maintain by re-using the same block of code.
  prefs: []
  type: TYPE_NORMAL
- en: 'Important note:'
  prefs: []
  type: TYPE_NORMAL
- en: After rendering the snippet, we do not automatically have access to the variables
    created within the parent element. Additionally, the parent element cannot access
    the variables defined within the snippet.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s create a new snippet file named `collection-form`, where we will move
    the entire content of the `else` statement from the `for` loop we created within
    our collection page:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: While the preceding code looks correct, we would end up with an error if we
    tried to execute it. *Why?*
  prefs: []
  type: TYPE_NORMAL
- en: 'As we recall, a snippet file does not have access to the variables defined
    in the parent element. In this case, that variable is the product we have defined
    in the `for` loop, which we call inside the snippet as the `form` parameter. To
    resolve this, we will need to pass the variable to the snippet as a parameter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: We have created a parameter named `product`, to which we have assigned the initially
    created variable. We could have given our parameter any name we liked, for example,
    `collection_product`. However, in that case, we would also have to update the
    `product` parameter inside the `form` tag from `product` to `collection_product`
    and `product.title` to `collection_product.title`, currently located within our
    snippet file, to match the new object keyword.
  prefs: []
  type: TYPE_NORMAL
- en: Once we have assigned the variable to a snippet via the parameter, we can modify
    the variable value inside the snippet independently from the value in the parent
    template. Even if we overwrite the variable value within the snippet, the variable
    will keep its value in the parent template. Note that we can pass as many variables
    as we may need to our snippet using its parameters. *However, what if we wanted
    to pass an object to our snippet?*
  prefs: []
  type: TYPE_NORMAL
- en: 'As with variables, we can pass an object to a snippet file using the `with`
    and `as` parameters. However, we are limited to only one object that we can pass
    as a parameter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: In our previous example, we have used `render` parameters to pass the `collection`
    object to the snippet file, where we can access it using the `featured_collection`
    keyword.
  prefs: []
  type: TYPE_NORMAL
- en: The final parameter that we can use with the `render` tag is the `for` parameter.
    Using the `for` and `as` parameters, we can render a snippet for each occurrence.
    Let's try to refactor the code on our collection page by moving it inside the
    `collection-form` snippet and rendering the products using the `for` parameter.
    However, note that we will not be able to copy the parameters that we currently
    have on the original `for` tag, as `render` does not accept additional parameters.
    Additionally, we will need to remove the `capture` and `productId` parameter from
    the form tag, as the `increment` tag does not work with render for parameter.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first thing we need to do is to move the `if` and `else` statements inside
    the snippet file and place them accordingly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'The only thing left to do is to add the additional parameters to the `render`
    tag. In the following example, we have included the `for` and `as` parameters
    with the `render` tag, which allowed us to iterate the `collections["outdoor"].products`
    array and render the snippet for each product iteration that our collection has.
    Additionally, we pass the `iteration` object as a parameter to our snippet, which
    we can use inside:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: Since we are already using the `product` keyword inside our snippet file, we
    successfully pass the object to both the product form parameter and product title.
    If we run our code now, we will see that the results are exactly the same as they
    were, but our code looks a lot cleaner.
  prefs: []
  type: TYPE_NORMAL
- en: The raw tag
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `raw` tag allows us to output unparsed Liquid code directly on the page.
    We can use the `raw` tag by wrapping the content we want unparsed with `raw` and
    `endraw` tags:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'In our previous example, we have created a message to update the collection
    name dynamically. However, since we have wrapped the entire message inside the
    `raw` tag, Liquid will not process it. Rather, it will return it to us in the
    exact same way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: This type of functionality can be pretty helpful, especially when dealing with
    conflicting syntaxes, such as Handlebars.
  prefs: []
  type: TYPE_NORMAL
- en: The comment tag
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As its name suggests, the `comment` tag allows us to leave a comment within
    our Liquid template files. Any text located between the opening and closing comment
    tags will not render inside the Liquid template files at all:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'Since we have wrapped the second part of our message within the `comment` tag,
    Liquid will render only the first part:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: Comment tags are pretty helpful, as they allow us to leave the necessary information
    within our files without polluting the DOM with visible comments.
  prefs: []
  type: TYPE_NORMAL
- en: Deprecated tags
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Deprecated tags** are Liquid tags that are considering as outdated, and we
    should no longer use them in our developing process. However, we may still encounter
    them inside some of the older themes, so it is important to recognize them and
    know what they do.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The only tag that Shopify has deprecated is the `include` tag, which works
    similarly to the `render` tag, which we have previously covered:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: The only key difference between the two is that when rendering a snippet using
    the `include` tag, the code inside our snippet can automatically access and modify
    the variables within its parent template. This not only creates a lot of performance
    issues but also makes our code a lot harder to maintain, which is why Shopify
    replaced it with the `render` tag.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this third chapter, we have learned about the Liquid programming logic that
    allows us to select which code block should execute under specific conditions.
    We have gained an understanding of variable and iteration tags and how we can
    use them in combination with different programming logic to execute a block of
    code repeatedly and recover only specific results.
  prefs: []
  type: TYPE_NORMAL
- en: Lastly, we have learned about the different types of theme tags and how we can
    use them to output a template-specific HTML markup. By learning how to use snippets
    to make our code more readable and maintainable, we have already taken a step
    forward in writing better-quality code. This will be especially important in the
    following chapter, where we will be diving further into Liquid core and learning
    more about Liquid objects and their attributes.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What parameters should we use inside a `for` loop if we want to show a maximum
    of seven iterations while also skipping the first three iterations?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What types of data can we assign to a variable created using the `capture` tag?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What are the two problems in the following block of code?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: What approach should we take to modify an HTML-generated product form by replacing
    the existing class attribute with a combination of a string and a variable?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What parameter should we use if we want to pass an object from the parent element?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
