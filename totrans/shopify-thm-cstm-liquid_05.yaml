- en: '[*Chapter 3*](B17606_03_Final_PD_ePub.xhtml#_idTextAnchor047): Diving into
    Liquid Core with Tags'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '[*第3章*](B17606_03_Final_PD_ePub.xhtml#_idTextAnchor047): 使用标签深入Liquid核心'
- en: In the previous chapters, we saw some Liquid tags, such as control flow tags,
    in action. In this chapter, we will learn more about all the different tags we
    can use to modify our page content dynamically. We will learn about creating variable
    tags and theme tags and the best way to use them.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的章节中，我们看到了一些Liquid标签的实际应用，例如控制流标签。在本章中，我们将学习更多关于我们可以用来动态修改页面内容的不同标签。我们将学习如何创建变量标签和主题标签以及最佳使用方法。
- en: Learning about various types of iterations tags and parameters, we will gain
    the ability to execute blocks of code repeatedly, which will help us write better-quality
    code. Finally, we will mention some deprecated tags; they still appear in some
    older themes, so it is essential to know what they do and how to use them.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 通过了解各种类型的迭代标签和参数，我们将获得执行代码块重复的能力，这将帮助我们编写更高质量的代码。最后，我们将提到一些已弃用的标签；它们仍然出现在一些较旧的主题中，因此了解它们的功能和使用方法至关重要。
- en: 'This chapter covers the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖了以下主题：
- en: Controlling the flow of Liquid (control tags)
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 控制Liquid的流程（控制标签）
- en: Variable tags
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 变量标签
- en: Iterations tags
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 迭代标签
- en: Theme tags
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 主题标签
- en: Deprecated tags
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 已弃用标签
- en: This third chapter will expand our knowledge of logic and comparison operators
    and different data types by exploring Liquid programming logic.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将通过探索Liquid编程逻辑来扩展我们对逻辑和比较运算符以及不同数据类型的知识。
- en: Technical requirements
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: You will need an internet connection to follow the steps outlined in this chapter,
    considering that Shopify is a hosted service.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 由于Shopify是一个托管服务，您需要互联网连接才能遵循本章中概述的步骤。
- en: 'The dataset used in this chapter, in `*.csv` format, is available on GitHub:
    [https://github.com/PacktPublishing/Shopify-Theme-Customization-with-Liquid/blob/main/Product-data.csv](https://github.com/PacktPublishing/Shopify-Theme-Customization-with-Liquid/blob/main/Product-data.csv).'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 本章使用的`*.csv`格式的数据集可在GitHub上找到：[https://github.com/PacktPublishing/Shopify-Theme-Customization-with-Liquid/blob/main/Product-data.csv](https://github.com/PacktPublishing/Shopify-Theme-Customization-with-Liquid/blob/main/Product-data.csv).
- en: 'The code for this chapter is available on GitHub: [https://github.com/PacktPublishing/Shopify-Theme-Customization-with-Liquid/tree/main/Chapter03](https://github.com/PacktPublishing/Shopify-Theme-Customization-with-Liquid/tree/main/Chapter03).'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的代码可在GitHub上找到：[https://github.com/PacktPublishing/Shopify-Theme-Customization-with-Liquid/tree/main/Chapter03](https://github.com/PacktPublishing/Shopify-Theme-Customization-with-Liquid/tree/main/Chapter03).
- en: 'The Code in Action video for the chapter can be found here: [https://bit.ly/3nP8uwG](https://bit.ly/3nP8uwG)'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的“代码在行动”视频可以在这里找到：[https://bit.ly/3nP8uwG](https://bit.ly/3nP8uwG)
- en: Getting things ready
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: Before we can proceed, we will need to create some product and collection pages
    first, which we will be using throughout the following exercises.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们继续之前，我们需要先创建一些产品和收藏夹页面，这些页面将在接下来的练习中使用。
- en: Creating the product page
  id: totrans-17
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建产品页面
- en: 'Generally, creating a page or a product page is a straightforward and intuitive
    process:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，创建一个页面或产品页面是一个简单直观的过程：
- en: We can start by navigating to the **Products** section in our sidebar and clicking
    the **Add products** button, automatically redirecting us to the page to define
    our product name, description, image, price, and other parameters. We will not
    go into too many details on managing a product. However, if you would like to
    read more about this topic, refer to [https://help.shopify.com/en/manual/products/add-update-products](https://help.shopify.com/en/manual/products/add-update-products).
  id: totrans-19
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以先通过导航到侧边栏中的**产品**部分并点击**添加产品**按钮开始，这将自动将我们重定向到定义我们的产品名称、描述、图片、价格和其他参数的页面。我们不会过多地介绍如何管理产品。然而，如果您想了解更多关于这个主题的信息，请参阅[https://help.shopify.com/en/manual/products/add-update-products](https://help.shopify.com/en/manual/products/add-update-products).
- en: To avoid creating a significant number of products manually that we will require
    later, we will use already created products that we can find on GitHub. We have
    created a `.csv` file that allows us to easily create many products for our development
    store for this specific purpose. The only thing we need to do is download the
    file from [https://github.com/PacktPublishing/Shopify-Theme-Customization-with-Liquid/blob/main/Product-data.csv](https://github.com/PacktPublishing/Shopify-Theme-Customization-with-Liquid/blob/main/Product-data.csv)
    and import it to our store.
  id: totrans-20
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了避免手动创建大量我们以后需要的产品，我们将使用GitHub上已经创建的产品。为此目的，我们创建了一个`.csv`文件，使我们能够轻松地为我们的开发商店创建许多产品。我们唯一需要做的就是从[https://github.com/PacktPublishing/Shopify-Theme-Customization-with-Liquid/blob/main/Product-data.csv](https://github.com/PacktPublishing/Shopify-Theme-Customization-with-Liquid/blob/main/Product-data.csv)下载文件并将其导入到我们的商店中。
- en: Once we have downloaded the file, click on the **Products** link within our
    sidebar, which will automatically position us in **All Products** after expanding.
    Click on the **Import** button to trigger a popup and start the process:![Figure
    3.1 – Example of starting the process of importing products
  id: totrans-21
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下载文件后，点击侧边栏中的**产品**链接，这将自动定位到**所有产品**后展开。点击**导入**按钮以触发弹出窗口并开始进程：![图3.1 – 导入产品进程的示例
- en: '](img/Figure_3.01_B17606.jpg)'
  id: totrans-22
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/Figure_3.01_B17606.jpg)'
- en: Figure 3.1 – Example of starting the process of importing products
  id: totrans-23
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图3.1 – 导入产品进程的示例
- en: After selecting the `Product-data.csv` file, we can start the process by clicking
    the **Upload and continue** button:![Figure 3.2 – Selecting and uploading the
    .csv file into the store
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择`Product-data.csv`文件后，我们可以通过点击**上传并继续**按钮开始进程：![图3.2 – 选择并上传.csv文件到商店
- en: '](img/Figure_3.02_B17606.jpg)'
  id: totrans-25
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/Figure_3.02_B17606.jpg)'
- en: Figure 3.2 – Selecting and uploading the .csv file into the store
  id: totrans-26
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图3.2 – 选择并上传.csv文件到商店
- en: 'A few seconds later, we will see another popup previewing one of the products
    we are about to import. After confirming that the fields contain the correct information,
    we can finalize the import process by clicking on the **Import products** button:'
  id: totrans-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 几秒钟后，我们将看到一个弹出窗口预览我们即将导入的产品之一。确认字段包含正确的信息后，我们可以通过点击**导入产品**按钮来最终完成导入进程：
- en: '![Figure 3.3 – Finalizing the process of uploading the products from the .csv
    file to the store'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '![图3.3 – 从.csv文件上传产品到商店的最终过程'
- en: '](img/Figure_3.03_B17606.jpg)'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_3.03_B17606.jpg)'
- en: Figure 3.3 – Finalizing the process of uploading the products from the .csv
    file to the store
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.3 – 从.csv文件上传产品到商店的最终过程
- en: Creating the collection page
  id: totrans-31
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建集合页面
- en: 'Now that we have filled our store with products, it is time to create some
    collection pages that we can then populate with our new products. The process
    of creating a collection page is as straightforward as that of the product page:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经用产品填充了商店，是时候创建一些集合页面了，然后我们可以用新产品填充它们。创建集合页面的过程与产品页面一样简单：
- en: We can start the process by clicking on the **Products** link in our sidebar
    and subsequently clicking on the **Collection** sub-link located in the extended
    **Products** menu.
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以通过点击侧边栏中的**产品**链接并随后点击扩展的**产品**菜单中的**集合**子链接来开始进程。
- en: Once inside, click on the **Create collection** button, automatically redirecting
    us to the page to define our collection name, description, assign products, and
    other parameters.
  id: totrans-34
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 进入后，点击**创建集合**按钮，自动将我们重定向到定义集合名称、描述、分配产品和其他参数的页面。
- en: 'Considering that we have two types of products, we will create two collections
    and assign the same type of products to each collection. After clicking on the
    `Outdoor` as the collection name, and set **Collection type** to **Automated**
    so that we will not have to assign each product manually. The last step is to
    set **CONDITIONS** such that we should only populate the products whose type equals
    **Outdoor**:'
  id: totrans-35
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 考虑到我们有两种类型的产品，我们将创建两个集合，并将相同类型的产品分配给每个集合。点击“户外”作为集合名称，并将**集合类型**设置为**自动**，这样我们就不必手动分配每个产品。最后一步是设置**条件**，以确保只填充类型等于**户外**的产品：
- en: '![Figure 3.4 – Example of creating a collection and automatically populating
    it based on the product type'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: '![图3.4 – 创建集合并根据产品类型自动填充的示例'
- en: '](img/Figure_3.04_B17606.jpg)'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_3.04_B17606.jpg)'
- en: Figure 3.4 – Example of creating a collection and automatically populating it
    based on the product type
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.4 – 创建集合并根据产品类型自动填充的示例
- en: After saving the changes, our collection page will instantly be created and
    populated with the products that match our condition. Note that before we proceed,
    we should repeat the preceding steps for the **Indoor** collection, which we will
    need in the following chapters. If you would like to read more about managing
    a collection page, refer to [https://help.shopify.com/en/manual/products/collections](https://help.shopify.com/en/manual/products/collections).
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 保存更改后，我们的收藏页面将立即创建并填充符合我们条件的商品。注意，在我们继续之前，我们应该为**室内**收藏重复前面的步骤，我们将在接下来的章节中使用它。如果您想了解更多关于管理收藏页面的信息，请参阅[https://help.shopify.com/en/manual/products/collections](https://help.shopify.com/en/manual/products/collections)。
- en: Updating the navigation menu
  id: totrans-40
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更新导航菜单
- en: 'For faster navigation, we can include the links to our two collections inside
    our main menu navigation:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更快的导航，我们可以在主菜单导航中包含我们两个收藏的链接：
- en: We can do this by clicking on **Online store** in our sidebar to expand it and
    consequently clicking on the **Navigation** link.
  id: totrans-42
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以通过点击侧边栏中的**在线商店**来展开它，并随后点击**导航**链接来做到这一点。
- en: Once inside, we can add any number of links by opening **Main menu** and clicking
    on **Add menu item**. If you would like to read more about managing a navigation
    menu, refer to [https://help.shopify.com/en/manual/online-store/menus-and-links](https://help.shopify.com/en/manual/online-store/menus-and-links).
  id: totrans-43
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 进入编辑器后，我们可以通过打开**主菜单**并点击**添加菜单项**来添加任意数量的链接。如果您想了解更多关于管理导航菜单的信息，请参阅[https://help.shopify.com/en/manual/online-store/menus-and-links](https://help.shopify.com/en/manual/online-store/menus-and-links)。
- en: Now that we have finished setting up both our product and collection pages,
    we can learn about Liquid programming logic.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经完成了产品页面和收藏页面设置，我们可以学习关于 Liquid 编程逻辑。
- en: Controlling the flow of Liquid
  id: totrans-45
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 控制Liquid的流程
- en: 'In the previous chapters, we saw some control flow tags, such as `if`, `and`,
    and `or`, in action; now we will dive further into this topic and learn about
    all the control flow types of tags and how to use them. Control flow tags are
    a type of Liquid programming logic that tells our Liquid code what to do by allowing
    us to be selective about which block of code should execute under specific conditions.
    We can divide the control flow tags into four separate groups:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的章节中，我们看到了一些控制流程标签，如`if`、`and`和`or`的实际应用；现在我们将进一步深入这个主题，并学习所有控制流程类型的标签以及如何使用它们。控制流程标签是一种
    Liquid 编程逻辑，它通过允许我们在特定条件下有选择性地决定哪个代码块应该执行，来告诉我们的 Liquid 代码应该做什么。我们可以将控制流程标签分为四个不同的组：
- en: '`if/else/elsif`'
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`if/else/elsif`'
- en: '`and/or`'
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`和/或`'
- en: '`case/when`'
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`case/when`'
- en: '`unless`'
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`unless`'
- en: The if/else/elsif tags
  id: totrans-51
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: if/else/elsif 标签
- en: We have had the pleasure of seeing the conditional `if` statement in some of
    our previous examples, which, if proved true, execute the code inside our statement.
    Let's see it in action. In the previous chapter, we created the **Learning about
    the page handle** page.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在前面的例子中已经愉快地看到了条件`if`语句，如果它被证明是真的，就会执行语句内的代码。让我们看看它是如何工作的。在上一章中，我们创建了**了解页面处理**页面。
- en: 'However, let''s try and create a new page for this exercise to solidify our
    knowledge and keep everything concise:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，让我们尝试为这个练习创建一个新页面，以巩固我们的知识并使一切保持简洁：
- en: Let's start by creating a new page named **Controlling the flow of Liquid**,
    which we will continue to use going forward. Suppose we need to remind ourselves
    how to create a new page; we can revisit the previous chapter and consult the
    *EmptyDrop* subsection, located under the *Understand the types of data* section,
    where we previously outlined the process of creating a new page.
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们从创建一个名为**控制Liquid的流程**的新页面开始，我们将继续使用它。假设我们需要提醒自己如何创建新页面，我们可以回顾前面的章节，并查阅位于**理解数据类型**部分下的**EmptyDrop**子部分，我们之前在那里概述了创建新页面的过程。
- en: After creating the new page, it is time to edit our newly created page template
    file. We need to navigate to the **Themes** section, located under the **Online
    store** area, click the **Actions** button on the duplicate theme we have created,
    and select the **Edit code** option, which will open our code editor.
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在创建新页面后，是时候编辑我们新创建的页面模板文件了。我们需要导航到位于**在线商店**区域下的**主题**部分，点击我们创建的副本主题上的**操作**按钮，然后选择**编辑代码**选项，这将打开我们的代码编辑器。
- en: Once inside the code editor, find the template currently assigned to our page.
    In our case, the template name is `page.liquid`, so click on it.
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 进入代码编辑器后，找到分配给我们的页面当前模板。在我们的例子中，模板名称是`page.liquid`，因此点击它。
- en: 'Currently, our page consists of two Liquid elements: `{{ page.title }}`, which
    generates the title of the page, and `{{ page.content }}`, which generates the
    content of our page, along with a few HTML elements. However, *what if our* `{{
    page.content }}` *is empty?* We would end up with an empty `div` element:'
  id: totrans-57
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 目前，我们的页面由两个Liquid元素组成：`{{ page.title }}`，它生成页面的标题，以及`{{ page.content }}`，它生成我们页面的内容，以及一些HTML元素。然而，*如果我们的*
    `{{ page.content }}` *为空怎么办？* 我们最终会得到一个空的`div`元素：
- en: '![Figure 3.5 – Example of the empty element on a page'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '![图3.5 – 页面上空元素的示例'
- en: '](img/Figure_3.5_B17606.jpg)'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_3.5_B17606.jpg)'
- en: Figure 3.5 – Example of the empty element on a page
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.5 – 页面上空元素的示例
- en: 'To solve this, we can wrap `{{ page.content }}` along with the `div` that encapsulates
    it within a conditional that will check whether the content of the page is empty:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决这个问题，我们可以在条件中包裹`{{ page.content }}`以及封装它的`div`，以检查页面内容是否为空：
- en: '[PRE0]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: We are now sure that we will not see any extra empty strings and elements on
    our page with the conditional in place.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在确信，在放置了条件之后，我们页面上不会出现任何额外的空字符串和元素。
- en: 'Let''s now try to include some kind of placeholder text instead and let anyone
    who visits our page know that we will add the page content shortly. This is where
    the `else` and `elsif` statements come to help us. With the addition of `else`
    and `elsif`, we can create multiple conditions to ensure that we execute our code
    correctly:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们尝试包含一些占位文本，并让访问我们页面的人知道我们将很快添加页面内容。这就是`else`和`elsif`语句帮助我们的时候。通过添加`else`和`elsif`，我们可以创建多个条件，以确保我们正确地执行我们的代码：
- en: 'Let''s start by adding the `else` condition before `{% endif %}` to execute
    a different result when our `{{ page.content }}` is empty:'
  id: totrans-65
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们先在`{% endif %}`之前添加`else`条件，以便在`{{ page.content }}`为空时执行不同的结果：
- en: '[PRE1]'
  id: totrans-66
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Let''s try to improve our page by adding a statement to check whether we have
    started working on our page content and update our notification message accordingly.
    We can do this by adding an `elsif` statement to check whether our page content
    has more than 100 characters. However, for this to work, we will also need to
    modify the existing `if` statement by altering the existing conditional to display
    the page content if it has `100` or more characters:'
  id: totrans-67
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们尝试通过添加一个语句来检查我们是否已经开始编写页面内容，并相应地更新我们的通知消息来改进我们的页面。我们可以通过添加一个`elsif`语句来检查页面内容是否超过100个字符来实现这一点。然而，为了使这可行，我们还需要通过修改现有的`if`语句来改变现有的条件，以便在页面内容有`100`个或更多字符时显示页面内容：
- en: '[PRE2]'
  id: totrans-68
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: With the two conditionals in place, our page should have enough information
    for anyone visiting our page. However, if we look closely at our statements, we
    will see that the `{% else %}` statement will never execute since the page content
    will either have more than 100 characters or less than 100 characters. As we recall,
    we can execute only one statement within a single block. To resolve this issue,
    we will need to use the `and` operator to ensure that all statements in our code
    block are working correctly.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 在放置了两个条件之后，我们的页面应该有足够的信息供任何访问者了解。然而，如果我们仔细查看我们的语句，我们会看到`{% else %}`语句永远不会执行，因为页面内容要么超过100个字符，要么少于100个字符。正如我们回忆的那样，我们只能在单个块中执行一个语句。为了解决这个问题，我们需要使用`and`运算符来确保我们代码块中的所有语句都正常工作。
- en: The and/or tags
  id: totrans-70
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 和/或标签
- en: As we recall from the previous chapter, the `and` and `or` operators let us
    include more than one condition in a control flow tag, allowing us to create complex
    conditionals.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在上一章中回忆的那样，`and`和`or`运算符允许我们在控制流标签中包含多个条件，从而允许我们创建复杂的条件。
- en: 'Using the `and` operator, we can chain another condition to the existing statement,
    which will only return `true` if both the left and right sides of the statement
    are true. Let''s try to include another conditional within our `elsif` statement
    that checks whether the page content has any content:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`and`运算符，我们可以将另一个条件链接到现有语句，只有当语句的左右两边都为真时，它才会返回`true`。让我们在`elsif`语句中尝试包含另一个条件，该条件检查页面内容是否有内容：
- en: '[PRE3]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: With the addition of the second condition, we have ensured that our control
    flow tag will execute correctly. The first statement will return `true` if the
    page content has more than `100` characters, the second statement will return
    `true` if the page content has less than `100` characters and the page is not
    empty. And finally, if both previous statements return `false`, the code inside
    the `else` statement will execute.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 通过添加第二个条件，我们确保了我们的控制流标签将正确执行。第一个语句将在页面内容超过`100`个字符时返回`true`，第二个语句将在页面内容少于`100`个字符且页面不为空时返回`true`。最后，如果前两个语句都返回`false`，则`else`语句中的代码将执行。
- en: Similar to the `and` parameter, the `or` parameter allows us to chain another
    condition to the tag. However, the critical difference is that for a statement
    with the `and` parameter to return `true`, both the left and right sides of the
    conditional had to return `true`. We only need at least one condition to return
    `true` with the `or` parameter, which will make that statement truthy, and the
    code inside will execute.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 与`and`参数类似，`or`参数允许我们将另一个条件链接到标签上。然而，关键的区别在于，对于带有`and`参数的语句要返回`true`，条件表达式的左右两边都必须返回`true`。而使用`or`参数，我们只需要至少有一个条件返回`true`，这样该语句就会变为真值，并且代码块将执行。
- en: The case/when tags
  id: totrans-76
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: case/when标签
- en: As with the `if/elsif/else` conditions, `case/when` is a type of control flow
    tag we can use to create a `switch` statement, which allows us to execute a particular
    block of code only when the returned value is an exact match. We can use `case`
    to initialize the `switch` statement, and we can use `when` to set the conditions
    in a specific order that we want them executed in.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 与`if/elsif/else`条件一样，`case/when`是我们可以使用来创建`switch`语句的控制流标签，它允许我们仅在返回值与精确匹配时执行特定的代码块。我们可以使用`case`来初始化`switch`语句，并使用`when`来设置我们想要它们执行的特定顺序的条件。
- en: 'Let''s return to the `page.liquid` template that we have previously worked
    on and create a `switch` statement that will check the exact number of characters
    our page content has and render the appropriate message depending on which statement
    is true. We can include this functionality above the first `if` statement we have
    added:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回到我们之前工作的`page.liquid`模板，并创建一个`switch`语句，该语句将检查页面内容的精确字符数，并根据哪个语句为真渲染相应的消息。我们可以在添加的第一个`if`语句之上包含此功能：
- en: '[PRE4]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'In the preceding example, we have initialized the `case` tag with `page.content.size`,
    allowing us to use `when` statements to check whether the number of characters
    in a page''s content is strictly equal to our values. Notice that `when` statements
    hold no comparing variables. This is because `when` statement accepts only a value
    as a parameter and will return `true` only if the value is an exact match:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，我们使用`page.content.size`初始化了`case`标签，这使得我们可以使用`when`语句来检查页面内容的字符数是否严格等于我们的值。请注意，`when`语句没有比较变量。这是因为`when`语句只接受一个值作为参数，并且只有在值是精确匹配时才会返回`true`：
- en: '![Figure 3.7 – Example of executing the case/when tag'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: '![Figure 3.7 – 执行case/when标签的示例'
- en: '](img/Figure_3.07_B17606.jpg)'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '![Figure 3.07_B17606.jpg]'
- en: Figure 3.7 – Example of executing the case/when tag
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.7 – 执行case/when标签的示例
- en: With our control flow tag in place, if we enter `150` characters as our page
    content, the first `when` statement returns `true`, and as a result, we can see
    our message. In comparison, it might not look like a powerful tag considering
    that we can only use it to match the exact values as opposed to the `if/elsif/else`
    tag. However, the `case/when` tags are a mighty piece of programming logic; we
    will be using them in the following chapters of the book to create complex functionalities.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的控制流标签就位后，如果我们以`150`个字符作为页面内容，第一个`when`语句将返回`true`，因此我们可以看到我们的消息。相比之下，考虑到我们只能用它来匹配精确值，而不是`if/elsif/else`标签，这个标签可能看起来并不强大。然而，`case/when`标签是强大的编程逻辑的一部分；我们将在本书的后续章节中使用它们来创建复杂的功能。
- en: As we recall, any code added directly to the template file will get executed
    on all of the pages using that particular template. And since we have added all
    of our previous code to the `page.liquid` template, we should ensure that we only
    execute the previously added code on the `unless` tag.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所回忆的，直接添加到模板文件中的任何代码都会在所有使用该特定模板的页面上执行。由于我们已经将所有之前的代码添加到`page.liquid`模板中，我们应该确保我们只在对`unless`标签执行之前添加的代码。
- en: The unless tag
  id: totrans-86
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '`unless`标签'
- en: 'Similar to an `if` tag, which allows us to check the state of a specific condition,
    the `unless` tag allows us to check if we have not met the condition:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 与允许我们检查特定条件状态的`if`标签类似，`unless`标签允许我们检查是否未满足条件：
- en: '[PRE5]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'We can add the opening statement of the `unless` tag just above our opening
    `case` tag and add the closing statement below the closing statement for our `if/elsif/else`
    tag:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在`case`标签的上方添加`unless`标签的打开语句，并在`if/elsif/else`标签的关闭语句下方添加关闭语句：
- en: '![Figure 3.8 – Example of the entire code related to the control flow of Liquid'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '![图3.8 – 与Liquid控制流相关的整个代码示例](img/Figure_3.8_B17606.jpg)'
- en: '](img/Figure_3.8_B17606.jpg)'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '![图3.8 – 与Liquid控制流相关的整个代码示例](img/Figure_3.8_B17606.jpg)'
- en: Figure 3.8 – Example of the entire code related to the control flow of Liquid
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.8 – 与Liquid控制流相关的整个代码示例
- en: With the `unless` statement in place, we have ensured that all of our code will
    only execute on this particular page and will not affect any other page that uses
    the same `page.liquid` template file.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 通过放置`unless`语句，我们确保所有代码只在这个特定的页面上执行，并且不会影响使用相同`page.liquid`模板文件的任何其他页面。
- en: By learning about all the different types of control flow tags, we have taken
    a step forward in mastering Liquid programming logic, which will serve as a stepping
    stone to much more significant and complex things that await us.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 通过了解所有不同类型的控制流标签，我们在掌握Liquid编程逻辑方面又迈出了坚实的一步，这将为我们通往更多重要且复杂的事物奠定基石。
- en: In the previous chapter, we have mentioned various data types, such as strings,
    numbers, and Booleans, and how we can use them. However, what if we wanted to
    save any of these data types and re-use them on multiple locations without manually
    updating each line? This is where *variables* come into play.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们提到了各种数据类型，例如字符串、数字和布尔值，以及我们如何使用它们。然而，如果我们想保存这些数据类型并在多个位置重复使用它们，而不必手动更新每一行，那会怎样呢？这就是*变量*发挥作用的地方。
- en: Variable tags
  id: totrans-96
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 变量标签
- en: 'We can consider variables as data containers to save the various types of information
    that we want to use later in our code or overwrite as needed. Besides saving the
    information for later use, variables also allow us to use descriptive text as
    a label, allowing us to understand what type of information a particular variable
    contains. We can divide the variable tags into the following four groups:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将变量视为数据容器，以保存我们希望在代码中稍后使用或按需覆盖的各种类型的信息。除了保存信息以供以后使用外，变量还允许我们使用描述性文本作为标签，使我们能够理解特定变量包含的信息类型。我们可以将变量标签分为以下四组：
- en: '`assign`'
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`assign`'
- en: '`capture`'
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`capture`'
- en: '`increment`'
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`increment`'
- en: '`decrement`'
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`decrement`'
- en: The assign tag
  id: totrans-102
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '`assign`标签'
- en: 'The `assign` tag allows us to declare a variable to which we can assign string,
    number, or Boolean data. We can declare a variable by writing the `assign` keyword
    followed by the name of the variable we are declaring, followed by the equal sign
    and the date we assign to that particular variant, and encapsulating it within
    the curly brace delimiters with percentage symbols:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: '`assign`标签允许我们声明一个变量，我们可以将字符串、数字或布尔数据分配给该变量。我们可以通过编写`assign`关键字后跟我们要声明的变量的名称，然后是等号和分配给该特定变量的数据，并将其封装在带有百分号符号的大括号定界符中来实现变量的声明：'
- en: '[PRE6]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Once we declare a variable, we can call it as many times as we need by encapsulating
    the variable''s name within double curly brace delimiters:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们声明了一个变量，我们就可以通过将变量的名称封装在双大括号定界符中来多次调用它：
- en: '[PRE7]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Calling our three variables will generate the same type of data that we have
    initially assigned to each variable:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 调用我们的三个变量将生成与我们最初分配给每个变量的相同类型的数据：
- en: '[PRE8]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Note that calling a variable using the double curly brace delimiters will return
    the variable value when called on its own. If we wanted to use a variable within
    a `for` tag or an `if` statement, we would call the variable only using its name,
    without the double curly brace delimiters:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，使用双大括号定界符调用变量时，当单独调用时将返回变量的值。如果我们想在`for`标签或`if`语句中使用变量，我们只需使用变量的名称调用变量，而不需要双大括号定界符：
- en: '[PRE9]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: We have used our previously declared variable inside a multiple `if` statement
    to determine our variable's value. Since our variable value is equal to the compared
    value of the first statement, the first statement will return `true`.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在多个`if`语句中使用了之前声明的变量来确定变量的值。由于我们的变量值等于第一个语句的比较值，第一个语句将返回`true`。
- en: So far, we have learned how to assign a single type of data to a variable, *but
    what if we wanted to create a variable that will store a combination of a string
    and a variable?* To achieve this, we will need the help of another type of variable
    tag called `capture`.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经学习了如何将单一类型的数据分配给一个变量，*但如果我们想创建一个可以存储字符串和变量组合的变量呢？* 要实现这一点，我们需要另一个类型的变量标签的帮助，称为
    `capture`。
- en: The capture tag
  id: totrans-113
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '`capture` 标签'
- en: 'As opposed to the `assign` tag, which only allowed us to capture a single value,
    `capture` allows us to capture multiple values using its start and end closing
    tags. We can declare a `capture` variable with a set of curly brace delimiters
    with percentage symbols around the word `capture` followed by the name of the
    variable we are declaring:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 与只允许我们捕获单个值的 `assign` 标签不同，`capture` 允许我们使用其起始和结束闭合标签捕获多个值。我们可以使用一组花括号定界符和围绕
    `capture` 单词的百分号来声明 `capture` 变量，后面跟着我们声明的变量的名称：
- en: '[PRE10]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'In the previous example, we initially defined two variables using the `assign`
    tag, one containing the number value and one containing the string. Once we have
    declared the two variables, we have again declared a new variable using the `capture`
    tag. We have included a string message containing both the previously defined
    variables, and finally, we have called the `promoMessage` variable by wrapping
    it inside double curly brace delimiters to see the result of our work:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一个例子中，我们最初使用 `assign` 标签定义了两个变量，一个包含数值，一个包含字符串。一旦我们声明了这两个变量，我们又使用 `capture`
    标签声明了一个新变量。我们包含了一个包含先前定义的变量的字符串消息，最后，我们通过将 `promoMessage` 变量包裹在双花括号定界符中来调用它，以查看我们工作的结果：
- en: '[PRE11]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: As we can see, using the `capture` tag, we successfully created a complex string
    message, which will come in handy as we progress further with our knowledge.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所见，使用 `capture` 标签，我们成功创建了一个复杂的字符串消息，随着我们进一步学习知识，这将非常有用。
- en: 'Important note:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示：
- en: While the `capture` tag accepts all data types, as we had the chance to see
    in the previous example, the result of calling the capture variable will always
    return string data.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然 `capture` 标签接受所有数据类型，正如我们在前面的例子中所看到的那样，调用 `capture` 变量将始终返回字符串数据。
- en: Using the `assign` tag, we have learned how to create new variables where we
    can store a single type of data. Using the `capture` variables, we have learned
    how to create complex strings using different variables, *but how would we create
    a variable whose content is a number value that acts as a counter?*
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `assign` 标签，我们学习了如何创建新的变量，我们可以存储单一类型的数据。使用 `capture` 变量，我们学习了如何使用不同的变量创建复杂的字符串，*但我们应该如何创建一个内容为数值的变量，该数值充当计数器呢？*
- en: The increment tag
  id: totrans-122
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '`increment` 标签'
- en: 'As opposed to the `assign` and `capture` tags, the `increment` tag does not
    need to be declared first. Instead, we will automatically create the variable
    as soon as we call it the first time. The `increment` tag allows us to auto-create
    a variable and increment it every time we call the variable using the `increment`
    tag. We can call an `increment` variable with a set of curly brace delimiters
    with percentage symbols around the word `increment` followed by the name of the
    variable we are creating:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 与 `assign` 和 `capture` 标签不同，`increment` 标签不需要先声明。相反，我们将在第一次调用它时自动创建变量。`increment`
    标签允许我们自动创建变量，并在每次使用 `increment` 标签调用变量时增加它。我们可以使用一组花括号定界符和围绕 `increment` 单词的百分号来调用
    `increment` 变量，后面跟着我们创建的变量的名称：
- en: '[PRE12]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The starting value of this and any other variable created using the `increment`
    tag will always be zero.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `increment` 标签创建的任何变量，包括这个变量的起始值，始终为零。
- en: 'Important note:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示：
- en: Calling the `increment` variable will not only automatically generate and increment
    the value starting with zero, but it will also automatically output the content
    of the variable in the template we are working on.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 调用 `increment` 变量不仅会自动生成并增加从零开始的值，而且还会自动输出我们在模板中工作的变量的内容。
- en: 'Considering that the `increment` tag automatically outputs the value as soon
    as the tag is called, it has a pretty limited usage. The most common use is to
    auto-generate the unique numbered identifiers for HTML elements:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到 `increment` 标签在标签被调用时自动输出值，它的用途相当有限。最常见的使用是自动生成 HTML 元素的唯一编号标识符：
- en: '[PRE13]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The result from our previous example will allow us to create a unique ID for
    each `div` element, starting with zero for the first occurrence of the `increment`
    tag and increasing its value by one for each next occurrence:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前示例的结果将使我们能够为每个 `div` 元素创建一个唯一的 ID，从 `increment` 标签首次出现时的零开始，每次后续出现时增加一：
- en: '[PRE14]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'One more critical aspect of the `increment` tag is that it works independently
    from variables created using `assign` or `capture` tags. Let''s try to create
    a variable using the `assign` tag and see what happens when we try to increment
    it:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: '`increment` 标签的一个更关键方面是它独立于使用 `assign` 或 `capture` 标签创建的变量工作。让我们尝试使用 `assign`
    标签创建一个变量，并看看当我们尝试增加它时会发生什么：'
- en: '[PRE15]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Initially, we created the variable and have assigned it a value of `7`, after
    which we used the `increment` tag to call the variable with the same name twice.
    Finally, we called the variable that we initially created using the `assign` tag:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 最初，我们创建了变量并将其赋值为 `7`，之后我们使用 `increment` 标签两次调用具有相同名称的变量。最后，我们调用最初使用 `assign`
    标签创建的变量：
- en: '[PRE16]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: As we can see from our results, even though we have already declared the `numberVar`
    variable using the `assign` tag and have assigned it a value of `7`, the `increment`
    tag has started incrementing the values starting with `0`. They might share the
    same name, but they are entirely different variables. The `increment` variable
    will not affect the initially created variable in any way and vice versa.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们从结果中看到的那样，尽管我们已使用 `assign` 标签声明了 `numberVar` 变量并将其赋值为 `7`，但 `increment` 标签从
    `0` 开始增加值。它们可能具有相同的名称，但它们是完全不同的变量。`increment` 变量不会以任何方式影响最初创建的变量，反之亦然。
- en: 'Important note:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示：
- en: Note that a variable created using the `increment` tag cannot be called independently
    without the `increment` tag or used as a logic parameter, as opposed to the case
    with the `assign` and `capture` tags.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，使用 `increment` 标签创建的变量不能在没有 `increment` 标签或用作逻辑参数的情况下独立调用，这与 `assign` 和 `capture`
    标签的情况不同。
- en: We have now learned how to create an independent variable tag to create a unique
    element identifier for any number of elements. However, suppose, for some reason,
    that we needed a variable that outputs the negative values for a large number
    of elements. For this functionality, we will need to use a different type of variable
    tag, named `decrement`.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经学会了如何创建一个独立的变量标签，为任意数量的元素创建一个唯一的元素标识符。然而，假设由于某种原因，我们需要一个输出大量元素负值的变量。为此功能，我们需要使用不同类型的变量标签，名为
    `decrement`。
- en: The decrement tag
  id: totrans-140
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '`decrement` 标签'
- en: 'Besides using a `decrement` keyword to initialize the variable, the `decrement`
    tag differs from the `increment` tag in two key aspects:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 除了使用 `decrement` 关键字初始化变量外，`decrement` 标签与 `increment` 标签在两个关键方面有所不同：
- en: The first one is that `decrement` allows us to decrease the variable value by
    one for each occurrence.
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第一点是 `decrement` 允许我们每次出现时将变量值减少一。
- en: The second one is that the initial value starts with a negative value of minus
    one.
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第二点是初始值从负一开始。
- en: 'In the following example, we can see an example of calling the `decrement`
    tag three times using the same variable:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下示例中，我们可以看到一个使用相同变量调用 `decrement` 标签三次的例子：
- en: '[PRE17]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'In this initial example, we have called the `decrement` tag three times. Since
    the `decrement` variable starts with a negative value, after calling it three
    times, we will receive the following values:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个初始示例中，我们调用了 `decrement` 标签三次。由于 `decrement` 变量从负值开始，调用三次后，我们将收到以下值：
- en: '[PRE18]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Important note:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示：
- en: Besides the two differences that we have made, `decrement` shares all the rules
    and limitations of the `increment` tag, meaning that the `decrement` tag works
    independently of the variables created using the `assign` and `capture` methods.
    We cannot call it independently without initializing the `decrement` tag.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 除了我们做出的两个不同之处，`decrement` 与 `increment` 标签共享所有规则和限制，这意味着 `decrement` 标签独立于使用
    `assign` 和 `capture` 方法创建的变量工作。我们无法在不初始化 `decrement` 标签的情况下独立调用它。
- en: Variables are a potent tool that, combined with the iteration tags, will bring
    us one step closer to writing more concise and reusable code.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 变量是强大的工具，与迭代标签结合使用，将使我们更接近编写更简洁和可重用的代码。
- en: Iterations tags
  id: totrans-151
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 迭代标签
- en: '**Iterations tags** are different Liquid programming logic types that allow
    us to run blocks of code repeatedly. Using iteration tags will save us the time
    that it would otherwise take us to execute code for each occurrence manually;
    plus, it will make our code much more concise and readable. To keep the topic
    concise, we will only mention some of the most used iteration tags and their parameters,
    which is more important than listing them all as they are all created using similar
    concepts. We can divide the iteration tags into four separate groups:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: '**迭代标签**是不同的液态编程逻辑类型，允许我们重复运行代码块。使用迭代标签将节省我们手动执行每个发生时所需的时间；此外，它将使我们的代码更加简洁和易于阅读。为了保持主题简洁，我们只将提到一些最常用的迭代标签及其参数，这比列出所有标签更重要，因为它们都是使用类似的概念创建的。我们可以将迭代标签分为四个不同的组：'
- en: '`for/else`'
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`for/else`'
- en: '`jump` statements'
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`跳转`语句'
- en: '`for` parameters'
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`for`参数'
- en: '`cycle`'
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`cycle`'
- en: The for/else tags
  id: totrans-157
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: for/else标签
- en: In the previous chapter, we had the chance to use the `for` loop in one of our
    examples when we explained the arrays inside the *Understand the types of data*
    topic. However, we have not had the chance to explain all the possibilities that
    the `for` loop gives us. The `for` loop is a type of Liquid programming logic
    that allows us to loop over any code block or array and output the result of that
    loop for further use.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，当我们解释了*理解数据类型*主题中的数组时，我们有机会在我们的示例中使用`for`循环。然而，我们还没有机会解释`for`循环给我们带来的所有可能性。`for`循环是一种液态编程逻辑，允许我们遍历任何代码块或数组，并将该循环的结果输出以供进一步使用。
- en: Previously, we have worked on the `page.liquid` template, but now, we will move
    on to the `collection.liquid` template.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 之前，我们一直在处理`page.liquid`模板，但现在，我们将继续到`collection.liquid`模板。
- en: 'Let''s start by writing a `for` loop tag that will list all of our product
    names and place them under the `{% section ''collection-template'' %}` line:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们首先编写一个`for`循环标签，该标签将列出所有产品名称，并将它们放在`{% section 'collection-template' %}`行下面：
- en: '[PRE19]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'In the previous example, we used a `for` tag followed by the `product` variable
    to loop over the `collection.products` object and return the names of the products
    currently assigned to our collection, which we can see on our **Indoor** collection
    page:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一个示例中，我们使用了一个`for`标签，后面跟着`product`变量，来遍历`collection.products`对象，并返回分配给我们的集合的产品名称，我们可以在我们的**室内**集合页面上看到这些名称：
- en: '![Figure 3.9 – Example of using a for loop to list the names of the products'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: '![图3.9 – 使用for循环列出产品名称的示例'
- en: '](img/Figure_3.09_B17606.jpg)'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: '![img/Figure_3.09_B17606.jpg]'
- en: Figure 3.9 – Example of using a for loop to list the names of the products
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.9 – 使用for循环列出产品名称的示例
- en: While our `for` loop did make it work, and we can see our product names listed,
    this is not of much use since we already have those same products listed. Let's
    use what we learned in the previous chapter when we talked about different ways
    of accessing the page handles' objects in the *EmptyDrop* subsection, which we
    can find under the *Understand the types of data* section.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我们的`for`循环确实使它工作，并且我们可以看到我们的产品名称列表，但这并没有什么用处，因为我们已经列出了相同的产品。让我们使用我们在上一章中学到的知识，当时我们在*EmptyDrop*子节中讨论了访问页面处理对象的不同方法，该子节位于*理解数据类型*部分。
- en: 'With our current code in place, we are reading the products of the collection
    we are currently visiting. Instead, let''s try and access the products located
    in our second collection named `outdoor`:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 使用我们当前的代码，我们正在读取我们当前访问的集合的产品。相反，让我们尝试访问位于我们名为`outdoor`的第二个集合中的产品：
- en: '[PRE20]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Even though we are currently previewing the `Indoor` collection, we have now
    gained a list of products that belong to the `Outdoor` collection.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管我们目前正在预览`Indoor`集合，但我们现在已经获得了一个属于`Outdoor`集合的产品列表。
- en: jump statements
  id: totrans-170
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 跳转语句
- en: 'As their name suggests, `jump` statements allow us to set the conditions that
    exclude certain items from our loop or stop our loop when we meet a specific condition.
    We can split `jump` statements into the two following groups:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 如其名所示，`跳转`语句允许我们设置条件，排除某些项目从我们的循环中，或者当我们遇到特定条件时停止我们的循环。我们可以将`跳转`语句分为以下两个组：
- en: '`continue`: The `{% continue %}` statement allows us to skip the current iteration
    based on the condition that we have set. We can use it to exclude certain products
    from our `for` loop by pairing it with an `if` statement only to accept a product
    whose price is lower than $100.00\. Otherwise, we should exclude the product from
    the loop:'
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`continue`: `{% continue %}` 语句允许我们根据我们设定的条件跳过当前迭代。我们可以通过将其与 `if` 语句配对来使用它，仅接受价格低于
    $100.00 的产品。否则，我们应该将产品排除在循环之外：'
- en: '[PRE21]'
  id: totrans-173
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '`break`: The `{% break %}` statement, on the other hand, allows us to stop
    the loop when we met a specific condition:'
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`break`: 与之相反，`{% break %}` 语句允许我们在遇到特定条件时停止循环：'
- en: '[PRE22]'
  id: totrans-175
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: For example, with `{% continue %}`, our loop returned six products that match
    our condition. However, when we replace `{% continue %}` with `{% break %}`, our
    loop returned zero results. Since the first product inside the `Outdoor` collection,
    whose handle we are using, has a price of $200.00, we have met our condition on
    the first iteration, which caused `{% break %}` to stop the iteration, preventing
    all other iterations.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，使用 `{% continue %}`，我们的循环返回了六个符合我们条件的产品。然而，当我们用 `{% break %}` 替换 `{% continue
    %}` 时，我们的循环返回了零结果。由于我们使用的 `Outdoor` 收藏中的第一个产品的价格为 $200.00，我们在第一次迭代就满足了我们的条件，这导致
    `{% break %}` 停止了迭代，防止了其他所有迭代。
- en: The for parameters
  id: totrans-177
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: for 参数
- en: 'In addition to `jump` statements, we also have various parameters that we can
    use further to define the loop''s limits and workflow. We can split the parameters
    that we can use in conjunction with the `for` loop into the four following groups:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 除了 `jump` 语句之外，我们还有各种参数可以进一步定义循环的限制和工作流程。我们可以将可以与 `for` 循环一起使用的参数分为以下四个组：
- en: '`limit`'
  id: totrans-179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`limit`'
- en: '`offset`'
  id: totrans-180
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`offset`'
- en: '`range`'
  id: totrans-181
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`range`'
- en: '`reversed`'
  id: totrans-182
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`reversed`'
- en: limit
  id: totrans-183
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 限制
- en: As its name suggests, the `limit` parameter limits how many iterations our loop
    should perform. We can add `limit` parameters at the end of the opening `for`
    loop tag, followed by a colon, followed by a number value.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 如其名所示，`limit` 参数限制了循环应执行的迭代次数。我们可以在打开的 `for` 循环标签末尾添加 `limit` 参数，后面跟着一个冒号，然后是一个数字值。
- en: We usually use `limit` parameters when we require a particular number of iterations
    without implementing any condition. This is because the `limit` parameter only
    measures the number of iterations, not whether the number of iterations matches
    the statement we have in place.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们要求进行特定次数的迭代而不实现任何条件时，我们通常使用 `limit` 参数。这是因为 `limit` 参数只衡量迭代次数，并不检查迭代次数是否与我们的语句匹配。
- en: 'Let''s start by adjusting our previous example by replacing `{% break %}` with
    `{% continue %}` and adding the `limit` parameter with the value of `4`, which
    is the maximum number of products that we are looking to get as a result:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从调整之前的例子开始，将 `{% break %}` 替换为 `{% continue %}`，并添加 `limit` 参数，其值为 `4`，这是我们希望作为结果获取的最大产品数量：
- en: '[PRE23]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: In our previous example, before adding the `limit` parameter, our `for` loop
    returned six product iterations whose price was lower than $100.00\. With the
    addition of the `limit` parameter, the number of iterations returned was `3`,
    even though we set our limit to `4`. *Why?*
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们之前的例子中，在添加 `limit` 参数之前，我们的 `for` 循环返回了六个产品迭代，其价格低于 $100.00。添加 `limit` 参数后，返回的迭代次数为
    `3`，尽管我们将其限制设置为 `4`。*为什么？*
- en: Similar to the `{% break %}` statement we mentioned earlier, the `limit` parameter's
    aim is to limit the number of iterations to the assigned value. Let's open our
    `Outdoor` collection, whose handle we are using to loop over. We will notice that
    the first product in that collection has a price of $200.00, which triggered the
    `if` statement, subsequently triggering the `{% continue %}` statement, which
    excluded the first product.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 与我们之前提到的 `{% break %}` 语句类似，`limit` 参数的目标是限制迭代次数到指定的值。让我们打开我们的 `Outdoor` 收藏，我们正在使用其句柄进行循环。我们会注意到该收藏中的第一个产品的价格为
    $200.00，这触发了 `if` 语句，随后触发了 `{% continue %}` 语句，排除了第一个产品。
- en: As a result, our `for` loop did not print out that product name. However, the
    `limit` parameter still counts this as one iteration, meaning that it will perform
    three more iterations. Since the following three products' prices were lower than
    $100.00, the three products' names were returned by our `for` loop before stopping.
    For this reason, the `limit` parameter is usually only used in a loop without
    any statements. Otherwise, we risk not meeting the number of iterations we intended,
    or any at all, since the result can also be zero iterations if none matches the
    statement that we have set.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们的`for`循环没有打印出那个产品名称。然而，`limit`参数仍然将其计为一个迭代，这意味着它将执行另外三次迭代。由于接下来的三个产品的价格低于$100.00，我们的`for`循环在停止之前返回了这三个产品的名称。因此，`limit`参数通常只在没有其他语句的循环中使用。否则，我们可能会无法达到预期的迭代次数，甚至一个迭代都没有，因为如果没有匹配我们设置的语句，迭代次数也可能为零。
- en: The offset parameter
  id: totrans-191
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 偏移参数
- en: The `offset` parameter allows us to delay the start of the `for` loop by starting
    the loop from the specific index. We can add an `offset` parameter at the end
    of the opening `for` loop tag, followed by a colon, followed by a number value.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: '`offset`参数允许我们通过从特定索引开始循环来延迟`for`循环的开始。我们可以在打开的`for`循环标签的末尾添加一个`offset`参数，后面跟着一个冒号，然后是一个数字值。'
- en: 'Let''s take our previous example and try replacing `limit` with the `offset`
    parameter and setting its value to `4`:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们拿我们之前的例子，尝试用`offset`参数替换`limit`，并将其值设置为`4`：
- en: '[PRE24]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Our `for` loop has automatically skipped the first four product iterations and
    has started iterating the products at index number `5`, resulting in our `for`
    loop returning three product iterations. *However, what if we also include the*
    `limit` *parameter after the* `offset` *parameter and set its value to* `1`*?*
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的`for`循环自动跳过了前四个产品迭代，并从索引号`5`开始迭代产品，导致我们的`for`循环返回三个产品迭代。*然而，如果我们也在* `offset`
    *参数之后包含* `limit` *参数并将其值设置为* `1`*，会怎样呢？*
- en: '[PRE25]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: While at first, it might look like the previous example will not work, this
    is a fully functional loop with valid parameters. As we have previously mentioned,
    the `limit` parameter allows us to limit a `for` loop to a specific number of
    iterations. With two parameters added, our `for` loop will start its iteration
    at index `5`. It will cover one iteration as per the value set with the `limit`
    parameter, and then it will stop the `for` loop, regardless of whether the one
    iteration managed to get past our `if` statement.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然一开始看起来前面的例子可能不会工作，但这实际上是一个完全功能的循环，具有有效的参数。正如我们之前提到的，`limit`参数允许我们将`for`循环限制在特定的迭代次数。添加两个参数后，我们的`for`循环将从索引`5`开始迭代。它将按照`limit`参数设置的值进行一次迭代，然后停止`for`循环，无论这次迭代是否成功通过了我们的`if`语句。
- en: The range parameter
  id: totrans-198
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 范围参数
- en: 'The `range` parameter offers us similar functionality to the `offset` parameter.
    The critical difference is that with `range`, we can assign both starting and
    ending index positions. We can add a `range` parameter at the end of the opening
    `for` loop tag by writing opening brace delimiters followed by the starting value,
    followed by two dots, and finally followed by end value and closing brace delimiters:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: '`range`参数为我们提供了与`offset`参数类似的功能。关键的区别在于，使用`range`，我们可以分配起始和结束索引位置。我们可以在打开的`for`循环标签的末尾添加一个`range`参数，通过编写开括号分隔符，然后是起始值，接着是两个点，最后是结束值和闭括号分隔符：'
- en: '[PRE26]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'As we recall, the `offset` parameter does not include the starting position
    index within the loop. Instead, it starts its loop from the next position, where
    the range is inclusive for both starting and ending position values. The result
    of our `for` loop example with the `range` parameter set to `(3..5)` would result
    in the following:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们回忆的那样，`offset`参数不包括循环中的起始位置索引。相反，它从下一个位置开始循环，范围对于起始和结束位置值都是包含的。我们将`range`参数设置为`(3..5)`的`for`循环示例的结果如下：
- en: '[PRE27]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Besides accepting the number as its value, as we were able to see in our previous
    example, `range` also allows us to place variables and objects as both its starting
    and ending values:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 除了接受数字作为其值之外，正如我们在前面的例子中所能看到的，`range`还允许我们将变量和对象作为其起始和结束值：
- en: '[PRE28]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: The result of our `for` loop example would return all iterations starting at
    index `3`, all the way to the number of products our collection has. With the
    ability to assign variables and objects as our starting or ending points, we can
    now create reusable `for` loops resulting in more concise and better-quality code.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的 `for` 循环示例的结果将返回从索引 `3` 开始的所有迭代，一直到我们集合中的产品数量。有了分配变量和对象作为起始或结束点的功能，我们现在可以创建可重用的
    `for` 循环，从而生成更简洁、质量更高的代码。
- en: The reversed parameter
  id: totrans-206
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '`reversed` 参数'
- en: 'The final parameter on our list is `reversed`, which, as its name suggests,
    allows us to reverse the order of iteration. The `reversed` parameter does not
    have any value representation, and we can include it at the end of the opening
    `for` loop tag:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 我们列表中的最后一个参数是 `reversed`，正如其名称所暗示的，它允许我们反转迭代的顺序。`reversed` 参数没有任何值表示，我们可以在 `for`
    循环开标签的末尾包含它：
- en: '[PRE29]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'In the previous example, we have added the `reversed` parameter as a secondary
    parameter next to our `range` parameter, resulting in our tag performing iteration
    in reverse order:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，我们已经将 `reversed` 参数作为次要参数添加到我们的 `range` 参数旁边，使得我们的标签以相反的顺序执行迭代：
- en: '[PRE30]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: As we have had the chance to see for ourselves, parameters are a powerful addition
    to the `for` tag, which we can use to achieve the necessary type of iteration
    and get only the results we require.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们有机会亲自看到的，参数是 `for` 标签的一个强大补充，我们可以使用它来实现所需的迭代类型，并只获取我们需要的成果。
- en: The cycle tag
  id: totrans-212
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '`cycle` 标签'
- en: '`cycle` is another powerful tag that we can only use in combination with the
    `for` tag to loop over a group of strings and output them to each iteration in
    the specific order in which they were initially defined. We can define the `cycle`
    tag by opening curly brace delimiters with a percentage symbol, followed by the
    word `cycle`, followed by any number of strings separated by commas. Finally,
    we close the `cycle` tag with closing brace delimiters and a percentage symbol:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: '`cycle` 是另一个强大的标签，我们只能与 `for` 标签结合使用，以遍历一组字符串并将它们按最初定义的顺序输出到每个迭代中。我们可以通过使用带有百分号的开花括号、跟随单词
    `cycle`、然后是任意数量的用逗号分隔的字符串来定义 `cycle` 标签。最后，我们用闭合花括号和百分号关闭 `cycle` 标签：'
- en: '[PRE31]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'In the previous example, we have included a `cycle` tag with four different
    strings inside a `for` loop, which we have limited to four iterations. By implementing
    the `cycle` tag, we have ensured that our first `div` element will receive a class
    first, the fourth element will receive a `last` class, while the two elements
    in between will receive no classes as the two strings for those positions are
    empty:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，我们在一个限制为四次迭代的 `for` 循环中包含了一个 `cycle` 标签，其中包含四个不同的字符串。通过实现 `cycle` 标签，我们确保了我们的第一个
    `div` 元素将首先获得一个类，第四个元素将获得 `last` 类，而中间的两个元素将不会获得任何类，因为这些位置的两个字符串是空的：
- en: '[PRE32]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: From our result, we can see that the `cycle` tag is quite a valuable tool that
    we can use to pass data to a specific iteration within a loop in an order that
    we have defined. *However, what would happen if we removed the limit from our
    loop or increased it to have nine iterations instead?*
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 从我们的结果中，我们可以看到 `cycle` 标签是一个非常宝贵的工具，我们可以用它将数据按我们定义的顺序传递到循环中的特定迭代。*然而，如果我们从循环中移除限制或将其增加到九次迭代，会发生什么？*
- en: '[PRE33]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'In our previous example, we had the exact same number of iterations as the
    number of strings inside the `cycle` tag. In our newest example, the number of
    iterations is higher than the number of strings, which means that the cycle will
    reset and start applying strings again, in order, for as many iterations as needed:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们之前的例子中，迭代的次数与 `cycle` 标签内字符串的数量完全相同。在我们的最新例子中，迭代的次数超过了字符串的数量，这意味着循环将重置并再次按顺序应用字符串，直到所需的迭代次数：
- en: '[PRE34]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: So far, we have learned the basic use of the `cycle` tag and that the tag will
    continue to output strings for as many iterations as possible, which is quite
    helpful if we have a single `cycle` tag, *but what if we have two or more?*
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经学习了 `cycle` 标签的基本用法，以及该标签将尽可能继续输出字符串，这对于我们只有一个 `cycle` 标签时非常有帮助。*但是，如果我们有两个或更多
    `cycle` 标签会怎样呢？*
- en: '[PRE35]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'In the previous example, we have created two separate `for` loops, the first
    one limited to six iterations and the second limited to four. As we have just
    learned, no matter how many strings we have defined inside the `cycle` tag, the
    tag will continue to output strings for as many iterations as needed:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，我们创建了两个独立的`for`循环，第一个循环限制为六次迭代，第二个循环限制为四次。正如我们刚刚学到的，无论我们在`cycle`标签内部定义了多少个字符串，标签将继续输出所需次数的字符串：
- en: '[PRE36]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: As we can see from the results, the first `for` loop has created six iterations
    in the exact order that we intended. However, the second `for` loop did not produce
    the same results. Instead, it continued to output the strings starting from the
    exact position where the previous `cycle` tag stopped.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 从结果中我们可以看到，第一个`for`循环按照我们预期的顺序创建了六个迭代。然而，第二个`for`循环没有产生相同的结果。相反，它继续从上一个`cycle`标签停止的确切位置输出字符串。
- en: This type of behavior is logical considering that Liquid currently cannot differentiate
    between different types of `cycle` tags. However, we can easily resolve this by
    introducing a parameter called the **cycle group**.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到Liquid目前无法区分不同类型的`cycle`标签，这种行为是逻辑上的。然而，我们可以通过引入一个名为**cycle group**的参数来轻松解决这个问题。
- en: 'The cycle group parameter allows us to separate `cycle` tags by ensuring that
    each cycle will output strings starting with position one, regardless of whether
    or not we have already used a `cycle` tag on the same page. After the `cycle`
    keyword, we can include the cycle group parameter by adding the string name encapsulated
    by parentheses, followed by a colon:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 周期组参数允许我们通过确保每个周期都将输出以位置一开头的字符串来分离`cycle`标签，无论我们是否已经在同一页上使用了`cycle`标签。在`cycle`关键字之后，我们可以通过添加括号内的字符串名称，后跟一个冒号来包含周期组参数：
- en: '[PRE37]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'The introduction of the cycle group parameter ensures that each `cycle` tag
    functions independently:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 周期组参数的引入确保了每个`cycle`标签独立工作：
- en: '[PRE38]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: We can see from our results that all iterations have received the string initially
    intended for them even though we have more than one `cycle` tag.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 从我们的结果中我们可以看到，所有迭代都接收到了最初为它们设计的字符串，尽管我们有多于一个的`cycle`标签。
- en: Besides the `for` and `cycle` tags, we have one more type of iteration tag called
    `tablerow`, which works similarly to the `for` tag. The only difference between
    the two tags is that `tablerow` returns results formatted as an HTML table. To
    keep the book concise, we will not be covering the `tablerow` tag or its parameters
    in this book. However, if you would like to read more about it, refer to [https://shopify.dev/docs/themes/liquid/reference/tags/iteration-tags](https://shopify.dev/docs/themes/liquid/reference/tags/iteration-tags).
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 除了`for`和`cycle`标签之外，我们还有一种称为`tablerow`的迭代标签，它的工作方式与`for`标签类似。这两个标签之间的唯一区别是`tablerow`返回格式化为HTML表格的结果。为了使本书简明扼要，我们不会在本书中介绍`tablerow`标签及其参数。但是，如果您想了解更多关于它的信息，请参阅[https://shopify.dev/docs/themes/liquid/reference/tags/iteration-tags](https://shopify.dev/docs/themes/liquid/reference/tags/iteration-tags)。
- en: Theme tags
  id: totrans-233
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 主题标签
- en: '**Theme tags** are a special type of tag that give us specific control over
    both *un-rendered and rendered code*. Using the various types of theme tags that
    we have at our disposal, we can create a different type of HTML markup for specific
    templates that is essential for creating a form that will allow customers to purchase
    products from our store. Additionally, they allow us to select different theme
    layouts to use for different pages, define sections or snippet files that we can
    use to create reusable blocks of code, and many other things. We can divide theme
    tags into the following groups:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: '**主题标签**是一种特殊的标签，它让我们能够对**未渲染和已渲染的代码**进行特定控制。使用我们可用的各种类型的主题标签，我们可以为特定模板创建不同类型的HTML标记，这对于创建允许客户从我们的商店购买产品的表单至关重要。此外，它们允许我们为不同的页面选择不同的主题布局，定义我们可以用来创建可重用代码块的分区或片段文件，以及许多其他事情。我们可以将主题标签分为以下几组：'
- en: '`layout`'
  id: totrans-235
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`layout`'
- en: '`liquid` and `echo`'
  id: totrans-236
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`liquid` 和 `echo`'
- en: '`form`'
  id: totrans-237
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`form`'
- en: '`paginate`'
  id: totrans-238
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`paginate`'
- en: '`render`'
  id: totrans-239
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`render`'
- en: '`raw`'
  id: totrans-240
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`raw`'
- en: '`comment`'
  id: totrans-241
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`comment`'
- en: The layout tag
  id: totrans-242
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 布局标签
- en: As we recall from the first chapter, when discussing the `Layout` directory,
    we mentioned the importance of the `theme.liquid` file as it is in this file that
    we will render all of our files and templates. It is in this file that we arrange
    the general layout of our pages.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们从第一章回忆的那样，在讨论`Layout`目录时，我们提到了`theme.liquid`文件的重要性，因为我们将在这个文件中渲染所有文件和模板。正是在这个文件中，我们安排了我们页面的通用布局。
- en: 'Our pages currently consist of three key elements: **header**, **main content**,
    and **footer**. Let''s say we wanted to remove the header and footer sections
    from our product pages, or at the very least to replace them with a different
    set of headers and footers. *How would we do this?*'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 我们当前的页面由三个关键元素组成：**页眉**、**主要内容**和**页脚**。假设我们想要从我们的产品页面上移除页眉和页脚部分，或者至少用一组不同的页眉和页脚来替换它们。*我们该如何操作？*
- en: The first step to achieve this would be to create an alternate layout file that
    our theme product pages will use instead. We can do this by expanding the **Layout**
    directory in our code editor and clicking on the **Add a new layout** button,
    which will trigger a popup to select the type of layout page we are looking to
    create and select the name for our new page.
  id: totrans-245
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现这一目标的第一个步骤是创建一个替代布局文件，我们的主题产品页面将使用该文件。我们可以通过在代码编辑器中展开 **布局** 目录并点击 **添加新布局**
    按钮，这将触发一个弹出窗口以选择我们想要创建的布局页面类型，并为我们的新页面选择名称。
- en: 'Within the drop-down menu, we will select the `alternate` as our filename.
    Once we have finished selecting our layout file type and name, click on the **Create
    layout** button to finalize the process:'
  id: totrans-246
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在下拉菜单中，我们将选择 `alternate` 作为我们的文件名。一旦我们完成选择布局文件类型和名称，点击 **创建布局** 按钮以完成此过程：
- en: '![Figure 3.10 – Example of creating a new layout file'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 3.10 – 创建新布局文件的示例'
- en: '](img/Figure_3.10_B17606.jpg)'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片 3.10 – 创建新布局文件的示例](img/Figure_3.10_B17606.jpg)'
- en: Figure 3.10 – Example of creating a new layout file
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.10 – 创建新布局文件的示例
- en: With this, we have successfully created a new layout file named `theme.alternate.liquid`.
    Suppose we tried to compare this file with our original `theme.liquid`; we would
    see that they are exactly the same. The reason for this is that when we create
    a new page, layout, or template, Shopify will not create a new page entirely,
    but it will copy a default page that our theme is already using. For example,
    if we were to expand the `page.liquid` file.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这种方式，我们已经成功创建了一个名为 `theme.alternate.liquid` 的新布局文件。假设我们尝试将此文件与我们的原始 `theme.liquid`
    文件进行比较；我们会发现它们完全相同。这是因为当我们创建一个新页面、布局或模板时，Shopify 不会完全创建一个新页面，而是会复制我们主题已经使用的默认页面。例如，如果我们展开
    `page.liquid` 文件。
- en: 'Now that we have created a new layout file, we will assign it to our product
    pages. We can do this by expanding the `product.liquid` file where we can define
    the layout for this particular template, which we should include on the very first
    line of the file. We can define the `layout` tag with a set of curly brace delimiters
    with percentage symbols around the word `layout`, followed by the name of the
    layout file, which we should encapsulate within parentheses:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经创建了一个新的布局文件，我们将将其分配给我们的产品页面。我们可以通过展开 `product.liquid` 文件来完成此操作，在那里我们可以定义此特定模板的布局，我们应该在文件的非常第一行包含它。我们可以使用一组带有百分号围绕
    `layout` 单词的花括号定界符来定义 `layout` 标签，后跟布局文件的名称，该名称应包含在括号内：
- en: '[PRE39]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: If we were to navigate to the `{% section 'header' %}` and `{% section 'footer'
    %}`, the header and footer sections would no longer be visible on our product
    page. However, they would still be visible on pages that use the original `theme.liquid`
    layout.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们导航到 `{% section 'header' %}` 和 `{% section 'footer' %}`，页眉和页脚部分将不再在我们的产品页面上可见。然而，它们仍然会在使用原始
    `theme.liquid` 布局的页面上可见。
- en: 'Important note:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示：
- en: Besides the name of the layout file, the `layout` tag also accepts the `none`
    keyword, without parentheses, as its value, in which case the page will use no
    layout file. In this case, the particular page using this particular template
    will have no access to any code or file, including `.css`, `.js`, or others that
    we initially loaded through the `theme.liquid` file.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 除了布局文件的名称外，`layout` 标签还接受 `none` 关键字作为其值，无需括号，在这种情况下，页面将不使用任何布局文件。在这种情况下，使用此特定模板的特定页面将无法访问任何代码或文件，包括
    `.css`、`.js` 或其他我们最初通过 `theme.liquid` 文件加载的文件。
- en: Any template file that does not contain the `layout` tag will, by default, use
    the original `theme.liquid` layout as a failsafe.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 任何不包含 `layout` 标签的模板文件将默认使用原始的 `theme.liquid` 布局作为安全选项。
- en: The liquid and echo tags
  id: totrans-257
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 液体和回声标签
- en: The `liquid` tag is one of the newest additions to Liquid, and it is quite a
    powerful one as it allows us to write multiple tags within one set of delimiters,
    making our code a lot easier to read and maintain. We can define the liquid tag
    with a curly brace delimiter and a percentage symbol on the left side of the word
    liquid followed by as many lines of `Liquid` code as we need. Note that we only
    need to define an opening `liquid` tag, where the `liquid` closing tag is automatically
    closed.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: '`liquid`标签是Liquid的最新补充之一，它相当强大，因为它允许我们在一组定界符内写入多个标签，使我们的代码更容易阅读和维护。我们可以使用花括号定界符和`liquid`一词左侧的百分号符号来定义`liquid`标签，然后跟随我们需要的任意多行`Liquid`代码。请注意，我们只需要定义一个开头的`liquid`标签，其中`liquid`闭合标签会自动关闭。'
- en: The `echo` tag is an addition to the `liquid` tag that allows us to output an
    expression that initially we had to wrap inside double curly brace delimiters.
    We can define the `echo` tag by simply writing an `echo` keyword, followed by
    any expression that we are using.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: '`echo`标签是`liquid`标签的一个补充，它允许我们输出最初必须用双花括号定界符包裹的表达式。我们可以通过简单地写一个`echo`关键字，然后跟随任何我们正在使用的表达式来定义`echo`标签。'
- en: Let's try and use our `liquid` and `echo` tags to refactor the code that we
    had previously added to our collection template when we learned about the different
    types of iterations.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试使用我们的`liquid`和`echo`标签来重构我们在学习不同类型迭代时添加到收藏模板的代码。
- en: 'Here, we can see the code that we initially created on our collection page:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，我们可以看到我们在收藏页面最初创建的代码：
- en: '[PRE40]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'We can see the same code in the following example after refactoring using the
    `liquid` and `echo` tags:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在以下示例中看到重构后使用`liquid`和`echo`标签的相同代码：
- en: '[PRE41]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: After refactoring our code, we can see that we have removed all curly brace
    delimiters with percentages and replaced all double curly brace delimiters with
    the `echo` tag. The only curly brace delimiters with percentage symbols left are
    the ones that belong to the `liquid` tag, encapsulating the entire code.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 在重构我们的代码后，我们可以看到我们已经删除了所有带有百分号的花括号定界符，并用`echo`标签替换了所有双花括号定界符。剩下的带有百分号符号的花括号定界符仅属于`liquid`标签，包围着整个代码。
- en: 'Important note:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示：
- en: While `liquid` and `echo` tags are pretty powerful, we should not use them regularly,
    as while they help us write multiple tags within one set of delimiters, they are
    not so kind when it comes to working with strings. The `echo` tag forces us to
    wrap every string within the parentheses, making it almost impossible to use non-string
    data values inside the string.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然`liquid`和`echo`标签非常强大，但我们不应经常使用它们，因为虽然它们帮助我们在一组定界符内写入多个标签，但在处理字符串时并不那么友好。`echo`标签强制我们用括号包裹每个字符串，这使得在字符串中使用非字符串数据值变得几乎不可能。
- en: The form tag
  id: totrans-268
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 表单标签
- en: 'The `form` tag allows us to automatically output various types of HTML `<form>`
    along with the required `<input>` elements, depending on the type of the `form`
    tag we have called. We can define the `form` tag within a pair of curly brace
    delimiters, followed by the `form` keyword, followed by the form''s name encapsulated
    by parentheses, and lastly, followed by the closing `endfor` tag surrounded by
    curly brace delimiters with percentage symbols:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: '`form`标签允许我们根据我们调用的`form`标签的类型自动输出各种类型的HTML `<form>`以及所需的`<input>`元素。我们可以在一对花括号定界符内定义`form`标签，然后是`form`关键字，接着是括号内的表单名称，最后是包围在带有百分号的花括号定界符中的`endfor`闭合标签：'
- en: '[PRE42]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: In the previous example, we have selected to generate the product form tag by
    using the `product` keyword within the parentheses. However, notice that following
    the comma, we also have another `product` keyword without parentheses. Certain
    forms, such as product forms that we are currently using, require us to pass them
    a parameter to generate the proper content. In this case, that parameter is the
    `product` object.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一个示例中，我们选择通过在括号内使用`product`关键字来生成产品表单标签。然而，请注意，在逗号之后，我们还有一个没有括号的`product`关键字。某些形式，例如我们目前使用的产品形式，需要我们传递一个参数来生成适当的内容。在这种情况下，该参数是`product`对象。
- en: The most common use for this is on a product page. However, we can also use
    the `form` tag within a collection page or anywhere else where we have access
    to the `product` object. Let's try to include a `form` tag within the loop that
    we previously created on our collection page.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 这最常见的使用是在产品页面上。然而，我们也可以在收藏页面或任何我们有权限访问`product`对象的地方使用`form`标签。让我们尝试在我们的收藏页面之前创建的循环中包含一个`form`标签。
- en: 'Since we will be dealing with a mix of strings and non-strings data, let''s
    first undo the `liquid` and `echo` changes that we previously made. We can do
    this by clicking on the **Older versions** button, located between the file''s
    name and the **Delete file** button:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.11 – Example of reverting changes in the file'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_3.11_B17606.jpg)'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.11 – Example of reverting changes in the file
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
- en: Clicking the **Older versions** button will reveal the drop-down menu where
    we can see the date and time of all the changes that we have made within this
    particular file. Each date represents the last time that we pressed the **Save**
    button to save our changes. Selecting any option will automatically revert our
    code to that particular point.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
- en: 'After reverting our changes, we are ready to add the `form` tag to our `for`
    loop:'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: By introducing the `form` tag within our `for` loop, we have generated an HTML
    form tag that we can see by inspecting the string elements that we see on our
    `Indoor` collection page. While the `form` tag is functional, we still lack one
    key ingredient to make our form usable, which we will be learning in the next
    chapter.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
- en: 'We can see that our `form` tag already has quite a few attributes by inspecting
    our collection page. *However, what if we wanted to add some of our own or modify
    the existing ones?* We can do this by simply adding the attribute name, followed
    by a comma, followed by the attribute''s value:'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  id: totrans-282
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: In the previous example, we have included a data attribute in our form using
    a string. However, we have also modified the existing ID value using the previously
    defined variable.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
- en: Notice that while we can directly include the variable within the attribute
    value, we cannot mix the string and variable within the `form` tag itself. For
    this reason, we have previously captured the combined string and `increment` tag
    using the `capture` tag and called it the attribute value using the variable name.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
- en: 'Besides the ability to pass an object as a `form` parameter, the `form` tag
    provides us with one special parameter named the `return_to` parameter. By default,
    when we submit the product form, we are usually redirected to the cart page. However,
    with the `return_to` parameter, we can select the page we should land on after
    we submit the form:'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  id: totrans-286
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: In our previous example, we have assigned the `back` value as a string for the
    `return_to` parameter, which will automatically return us to the same page we
    were on before submitting the form. Besides the `back` string, we can also use
    a relative path or a `routes` attribute to generate a dynamic URL to the page
    we should land on once we submit the form.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
- en: There are many types of form tags that we can use. However, as they are all
    created using the same format, we will only cover one example. For more information
    on different types of `form` tags and their parameters, refer to [https://shopify.dev/docs/themes/liquid/reference/tags/theme-tags#form](https://shopify.dev/docs/themes/liquid/reference/tags/theme-tags#form).
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
- en: The paginate tag
  id: totrans-289
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Previously, we have learned all about iteration tags, which we can use to repeatedly
    execute a code block. However, iteration tags have a limitation that means they
    can only output a maximum of 50 results per page. For any higher number of iterations,
    we would need to use the `paginate` tag to split the results across multiple pages.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
- en: 'The `paginate` tag must always wrap around a `for` tag that is looping over
    an array to be able to split the content into multiple pages. We can see an example
    of a `paginate` tag wrapping a `for` loop here:'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  id: totrans-292
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: As we can see from our example, the `paginate` tag contains the `paginate` keyword,
    followed by the object that returns an array of products in the collection, followed
    by the `by` parameter and the number value. Depending on the number value that
    we include with the `by` parameter, which can go from one to fifty, the `paginate`
    tag will know the maximum number of items it should present per page. Inside the
    `paginate` tag, we can access attributes of the `paginate` object. To keep the
    book concise, we will not be going into detail regarding the `paginate` object.
    For detailed information, refer to [https://shopify.dev/docs/themes/liquid/reference/objects/paginate](https://shopify.dev/docs/themes/liquid/reference/objects/paginate).
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
- en: The render tag
  id: totrans-294
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `render` tag allows us to render the content of a snippet file to a place
    of our choosing. As we recall from [*Chapter 1*](B17606_01_Final_PD_ePub.xhtml#_idTextAnchor015),
    *Getting Started with Shopify*, snippet files allow us to re-use repetitive pieces
    of code over **Templates**/**Sections** by referencing their names:'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  id: totrans-296
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: As we can see from our example, we only need to use the `render` keyword, followed
    by the name of the snippet file, and we will render any content within our snippet
    file. By using the snippet file, we not only make our code more readable, but
    we also make it easier to maintain by re-using the same block of code.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
- en: 'Important note:'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
- en: After rendering the snippet, we do not automatically have access to the variables
    created within the parent element. Additionally, the parent element cannot access
    the variables defined within the snippet.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s create a new snippet file named `collection-form`, where we will move
    the entire content of the `else` statement from the `for` loop we created within
    our collection page:'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  id: totrans-301
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: While the preceding code looks correct, we would end up with an error if we
    tried to execute it. *Why?*
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
- en: 'As we recall, a snippet file does not have access to the variables defined
    in the parent element. In this case, that variable is the product we have defined
    in the `for` loop, which we call inside the snippet as the `form` parameter. To
    resolve this, we will need to pass the variable to the snippet as a parameter:'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  id: totrans-304
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: We have created a parameter named `product`, to which we have assigned the initially
    created variable. We could have given our parameter any name we liked, for example,
    `collection_product`. However, in that case, we would also have to update the
    `product` parameter inside the `form` tag from `product` to `collection_product`
    and `product.title` to `collection_product.title`, currently located within our
    snippet file, to match the new object keyword.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
- en: Once we have assigned the variable to a snippet via the parameter, we can modify
    the variable value inside the snippet independently from the value in the parent
    template. Even if we overwrite the variable value within the snippet, the variable
    will keep its value in the parent template. Note that we can pass as many variables
    as we may need to our snippet using its parameters. *However, what if we wanted
    to pass an object to our snippet?*
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
- en: 'As with variables, we can pass an object to a snippet file using the `with`
    and `as` parameters. However, we are limited to only one object that we can pass
    as a parameter:'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  id: totrans-308
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: In our previous example, we have used `render` parameters to pass the `collection`
    object to the snippet file, where we can access it using the `featured_collection`
    keyword.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
- en: The final parameter that we can use with the `render` tag is the `for` parameter.
    Using the `for` and `as` parameters, we can render a snippet for each occurrence.
    Let's try to refactor the code on our collection page by moving it inside the
    `collection-form` snippet and rendering the products using the `for` parameter.
    However, note that we will not be able to copy the parameters that we currently
    have on the original `for` tag, as `render` does not accept additional parameters.
    Additionally, we will need to remove the `capture` and `productId` parameter from
    the form tag, as the `increment` tag does not work with render for parameter.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
- en: 'The first thing we need to do is to move the `if` and `else` statements inside
    the snippet file and place them accordingly:'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  id: totrans-312
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'The only thing left to do is to add the additional parameters to the `render`
    tag. In the following example, we have included the `for` and `as` parameters
    with the `render` tag, which allowed us to iterate the `collections["outdoor"].products`
    array and render the snippet for each product iteration that our collection has.
    Additionally, we pass the `iteration` object as a parameter to our snippet, which
    we can use inside:'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  id: totrans-314
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: Since we are already using the `product` keyword inside our snippet file, we
    successfully pass the object to both the product form parameter and product title.
    If we run our code now, we will see that the results are exactly the same as they
    were, but our code looks a lot cleaner.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
- en: The raw tag
  id: totrans-316
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `raw` tag allows us to output unparsed Liquid code directly on the page.
    We can use the `raw` tag by wrapping the content we want unparsed with `raw` and
    `endraw` tags:'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  id: totrans-318
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'In our previous example, we have created a message to update the collection
    name dynamically. However, since we have wrapped the entire message inside the
    `raw` tag, Liquid will not process it. Rather, it will return it to us in the
    exact same way:'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  id: totrans-320
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: This type of functionality can be pretty helpful, especially when dealing with
    conflicting syntaxes, such as Handlebars.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
- en: The comment tag
  id: totrans-322
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As its name suggests, the `comment` tag allows us to leave a comment within
    our Liquid template files. Any text located between the opening and closing comment
    tags will not render inside the Liquid template files at all:'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  id: totrans-324
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'Since we have wrapped the second part of our message within the `comment` tag,
    Liquid will render only the first part:'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  id: totrans-326
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: Comment tags are pretty helpful, as they allow us to leave the necessary information
    within our files without polluting the DOM with visible comments.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
- en: Deprecated tags
  id: totrans-328
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Deprecated tags** are Liquid tags that are considering as outdated, and we
    should no longer use them in our developing process. However, we may still encounter
    them inside some of the older themes, so it is important to recognize them and
    know what they do.'
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
- en: 'The only tag that Shopify has deprecated is the `include` tag, which works
    similarly to the `render` tag, which we have previously covered:'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  id: totrans-331
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: The only key difference between the two is that when rendering a snippet using
    the `include` tag, the code inside our snippet can automatically access and modify
    the variables within its parent template. This not only creates a lot of performance
    issues but also makes our code a lot harder to maintain, which is why Shopify
    replaced it with the `render` tag.
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-333
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this third chapter, we have learned about the Liquid programming logic that
    allows us to select which code block should execute under specific conditions.
    We have gained an understanding of variable and iteration tags and how we can
    use them in combination with different programming logic to execute a block of
    code repeatedly and recover only specific results.
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
- en: Lastly, we have learned about the different types of theme tags and how we can
    use them to output a template-specific HTML markup. By learning how to use snippets
    to make our code more readable and maintainable, we have already taken a step
    forward in writing better-quality code. This will be especially important in the
    following chapter, where we will be diving further into Liquid core and learning
    more about Liquid objects and their attributes.
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  id: totrans-336
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What parameters should we use inside a `for` loop if we want to show a maximum
    of seven iterations while also skipping the first three iterations?
  id: totrans-337
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果我们想在`for`循环中显示最多七次迭代，同时跳过前三次迭代，我们应该使用哪些参数？
- en: What types of data can we assign to a variable created using the `capture` tag?
  id: totrans-338
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以将哪些类型的数据分配给使用`capture`标签创建的变量？
- en: What are the two problems in the following block of code?
  id: totrans-339
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在以下代码块中存在哪两个问题？
- en: '[PRE58]'
  id: totrans-340
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE58]'
- en: What approach should we take to modify an HTML-generated product form by replacing
    the existing class attribute with a combination of a string and a variable?
  id: totrans-341
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们应该采取什么方法来通过用字符串和变量的组合替换现有的类属性来修改由HTML生成的产品表单？
- en: What parameter should we use if we want to pass an object from the parent element?
  id: totrans-342
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果我们想从父元素传递一个对象，应该使用哪个参数？
