- en: Chapter 12. Performance and Security
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Out of the box, Yii2 is an both a performant and efficient PHP framework. It
    was designed to be as fast as possible while still providing a feature-rich toolbox
    to work with. There are many factors that determine the performance of our application
    that can negatively affect the performance of our application, such as long running
    queries and data generation. In this chapter, we'll cover several ways in which
    we can optimize and fine-tune Yii2 so that our applications remain performant.
    We'll also cover several important aspects of securing our code.
  prefs: []
  type: TYPE_NORMAL
- en: Caching
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One of the easiest ways to improve the performance of our applications is to
    implement caching. By implementing caching within our application, we can reduce
    the amount of time it takes to generate and deliver data to our end users. With
    Yii2, we can cache everything from generated data, database queries, and even
    entire pages and page fragments. We can also instruct our browsers to cache pages
    for us. In this section, we'll cover several different caching techniques that
    we can implement within Yii2 in order to improve the performance of our application.
  prefs: []
  type: TYPE_NORMAL
- en: Caching data
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Data caching is all about storing commonly generated data so that we can generate
    it once for a given period of time rather than on every request, and in Yii2,
    it is implemented through the cache component of our application. Yii2 provides
    a variety of different classes that we can use to cache data, all of which follow
    and use a consistent API by implementing the `yii\caching\Cache` abstract class.
  prefs: []
  type: TYPE_NORMAL
- en: 'This consistent API enables us to swap out our caching component with any of
    the caches listed in the following table without having to make any change to
    the code within our application:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Cache Name | Description | Class reference |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `yii\caching\ApcCache` | A cache that uses APC PHP extensions. On a single
    server configuration, an APC cache is very performant but suffers from compatibility
    issues if PHP Opcache is enabled. | [http://www.yiiframework.com/doc-2.0/yii-caching-apccache.html](http://www.yiiframework.com/doc-2.0/yii-caching-apccache.html)
    |'
  prefs: []
  type: TYPE_TB
- en: '| `yii\caching\DbCache` | A cache that uses a database table to store information.
    | [http://www.yiiframework.com/doc-2.0/yii-caching-dbcache.html](http://www.yiiframework.com/doc-2.0/yii-caching-dbcache.html)
    |'
  prefs: []
  type: TYPE_TB
- en: '| `yii\caching\DummyCache` | A placeholder cache that doesn''t do any caching
    but serves as a standing for a real cache that can be used during development
    in order to ensure that our applications will work with a real cache. | [http://www.yiiframework.com/doc-2.0/yii-caching-dummycache.html](http://www.yiiframework.com/doc-2.0/yii-caching-dummycache.html)
    |'
  prefs: []
  type: TYPE_TB
- en: '| `yii\caching\FileCache` | A cache that stores data in a file store and is
    recommended for the storing of pages or page fragments. | [http://www.yiiframework.com/doc-2.0/yii-caching-filecache.html](http://www.yiiframework.com/doc-2.0/yii-caching-filecache.html)
    |'
  prefs: []
  type: TYPE_TB
- en: '| `yii\caching\MemCache` | An in-memory cache that uses the PHP memcache or
    memcached extensions to store data. | [http://www.yiiframework.com/doc-2.0/yii-caching-memcache.html](http://www.yiiframework.com/doc-2.0/yii-caching-memcache.html)
    |'
  prefs: []
  type: TYPE_TB
- en: '| `yii\caching\WinCache` | A cache that uses the WinCache PHP extension. |
    [http://www.yiiframework.com/doc-2.0/yii-caching-wincache.html](http://www.yiiframework.com/doc-2.0/yii-caching-wincache.html)
    |'
  prefs: []
  type: TYPE_TB
- en: '| `yii\redis\Cache` | A cache that implements the Redis key value store. |
    [http://www.yiiframework.com/doc-2.0/yii-redis-cache.html](http://www.yiiframework.com/doc-2.0/yii-redis-cache.html)
    |'
  prefs: []
  type: TYPE_TB
- en: '| `yii\caching\XCache` | A cache that uses the XCache PHP extension. | [http://www.yiiframework.com/doc-2.0/yii-caching-xcache.html](http://www.yiiframework.com/doc-2.0/yii-caching-xcache.html)
    |'
  prefs: []
  type: TYPE_TB
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: While each cache that's listed implements the `yii\caching\Cache` API, some
    caches, such as `yii\redis\Cache` and `yii\caching\MemCache`, require some additional
    configuration. Ensure that you refer to the class reference for the cache you
    decide to use in your application.
  prefs: []
  type: TYPE_NORMAL
- en: 'Using `yii\caching\FileCache` as an example, we can implement caching within
    our application by adding the following to our application configuration file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: After implementing a specific caching system, we can then use our cache by referencing
    `Yii::$app->cache` within our application code.
  prefs: []
  type: TYPE_NORMAL
- en: As mentioned previously, each cache implements a consistent API, as defined
    by the `yii\caching\Cache` abstract class. Consequently, each cache provides the
    following methods that we can use to manipulate the data in our cache.
  prefs: []
  type: TYPE_NORMAL
- en: '| Method | Explanation |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `yii\caching\Cache::add()` | Stores the value with a given key in the cache
    if it does not exist. If the cached item exists, no operation will occur. |'
  prefs: []
  type: TYPE_TB
- en: '| `yii\caching\Cache::get()` | Retrieves an item with a given key from the
    cache. |'
  prefs: []
  type: TYPE_TB
- en: '| `yii\caching\Cache::set()` | Sets an item with a given key into the cache
    with the option to specify an expiration date. The cached items set with an expiration
    date will automatically be expunged by either the underlying cache mechanism or
    by Yii2 itself. |'
  prefs: []
  type: TYPE_TB
- en: '| `yii\caching\Cache::madd()` | Stores multiple items in the cache as a key
    value array. If a given cache key already exists, nothing will occur.In Yii 2.1,
    this method will be marked as deprecated and will be superseded by `yii\caching\Cache::multiAdd()`.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `yii\caching\Cache::mget()` | Retrieves multiple data keys from the cache
    simultaneously.In Yii 2.1, this method will be marked as deprecated and will be
    superseded by `yii\caching\Cache::multiGet()`. |'
  prefs: []
  type: TYPE_TB
- en: '| `yii\caching\Cache::mset()` | Sets multiple cached items represented as a
    key value simultaneously into the cache. The cached items set with an expiration
    date will automatically be expunged by either the underlying cache mechanism or
    by Yii2 itself.In Yii 2.1, this method will be marked as deprecated and will be
    superseded by `yii\caching\Cache::multiSet()`. |'
  prefs: []
  type: TYPE_TB
- en: '| `yii\caching\Cache::exists()` | Returns `true` or `false` if a given cache
    key exists within the cache. |'
  prefs: []
  type: TYPE_TB
- en: '| `yii\caching\Cache::delete()` | Deletes a given cache key from the cache.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `yii\caching\Cache::flush()` | Flushes all the data from the cache. |'
  prefs: []
  type: TYPE_TB
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: For more information on each method and its use, refer to the noninherited public
    methods described by the `yii\caching\Cache` abstract class at [http://www.yiiframework.com/doc-2.0/yii-caching-cache.html](http://www.yiiframework.com/doc-2.0/yii-caching-cache.html).
  prefs: []
  type: TYPE_NORMAL
- en: 'In general, our cache can be used by calling any of these methods against our
    `Yii::$app->cache` component, as shown in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Caching dependencies
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In addition to setting a cache with a given expiration time, we can also cache
    data with certain dependencies, such as the last modification time of a file of
    an expression of some kind, and automatically expire our data should that dependency
    change. Yii2 provides several dependencies that we can use.
  prefs: []
  type: TYPE_NORMAL
- en: '| Method | Explanation | Class Reference |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `yii\caching\ChainedDependency` | A dependency that allows us to chain multiple
    dependencies together and expire a cache item if any of the dependencies fail.
    | [http://www.yiiframework.com/doc-2.0/yii-caching-chaineddependency.html](http://www.yiiframework.com/doc-2.0/yii-caching-chaineddependency.html)
    |'
  prefs: []
  type: TYPE_TB
- en: '| `yii\caching\DbDependency` | A dependency upon a given SQL query. Should
    the result of the query change, the cache will be invalidated. | [http://www.yiiframework.com/doc-2.0/yii-caching-dbdependency.html](http://www.yiiframework.com/doc-2.0/yii-caching-dbdependency.html)
    |'
  prefs: []
  type: TYPE_TB
- en: '| `yii\caching\FileDependency` | A dependency upon a file based upon the last
    modification time of the file. | [http://www.yiiframework.com/doc-2.0/yii-caching-filedependency.html](http://www.yiiframework.com/doc-2.0/yii-caching-filedependency.html)
    |'
  prefs: []
  type: TYPE_TB
- en: '| `yii\caching\ExpressionDependency` | A dependency represented by a Boolean
    expression. | [http://www.yiiframework.com/doc-2.0/yii-caching-expressiondependency.html](http://www.yiiframework.com/doc-2.0/yii-caching-expressiondependency.html)
    |'
  prefs: []
  type: TYPE_TB
- en: '| `yii\caching\TagDependency` | A dependency upon an array of tags that can
    be managed. | [http://www.yiiframework.com/doc-2.0/yii-caching-tagdependency.html](http://www.yiiframework.com/doc-2.0/yii-caching-tagdependency.html)
    |'
  prefs: []
  type: TYPE_TB
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Check out the class reference for each dependency for more information on its
    available properties and methods.
  prefs: []
  type: TYPE_NORMAL
- en: 'Expanding upon our previous example, we can add a cache dependency, as shown
    in the following example. In the following code, we create a dependency upon a
    file called `data.csv`, which can contain a report or some other data that we
    wish to generate or import into our application:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Database query caching
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'With Yii2, we can also cache the result of a database query. To enable query
    caching, we need to set three properties within our database component: `$enableQueryCache`,
    which toggles the query cache on and off; `$queryCacheDuration`, which sets the
    duration queries should be cached for; and `$queryCache`, which specifies the
    cache component that should be used.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The following connection example illustrates how to enable the query cache:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'After configuring database query caching, we can then cache the results of
    a single DAO query by adding or chaining the cache method to our query, as shown
    in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Alternatively, if we have multiple queries we''d like to cache, we can call
    the `yii\db\Connection::cache()` function directly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: '`ActiveRecord` can also take advantage of query caching by fetching the database
    component from the `ActiveRecord` model, as shown in the next example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Moreover, within a query cache, we can exclude certain queries from being cached
    by chaining the `noCache()` method to our query, as illustrated by the following
    examples:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Some databases such as MySQL have their own built-in caching implemented in
    the software layer. Implementing both MySQL's native query cache and Yii2's query
    cache can cause problems in ensuring that the right data is presented. Additionally,
    any data that is returned as a resource handler cannot be cached by Yii2\. Furthermore,
    some caches, such as `Memcache`, limit how much data can be associated with a
    specific key. Be cognizant of these limitations when using query caching.
  prefs: []
  type: TYPE_NORMAL
- en: Fragment caching
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Fragment caching is built on top of data caching. Fragment caching in Yii2
    allows us to cache a fragment of a page and present that cached fragment rather
    than regenerating the entire contents of the page on every request. In general,
    we can use fragment caching by wrapping our code in the following block:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Like data caching, fragment caching has support for several conditions, such
    as duration, dependencies, variation, and toggling the fragment cache on and off.
    These conditions can be added as key value arrays to the second parameter of the
    `beginCache()` method, as shown in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Page caching
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As an alternative to caching just a fragment of a web page, with Yii2, we can
    also cache an entire page and serve the cached copy instead of generating the
    page on every page load. This is exceptionally useful when we have a read-heavy
    application, such as a blog. Page caching in Yii2 is implemented by adding the
    `yii\filters\PageCache` filter to the `behaviors()` method of our controller,
    as shown in the following example. Like fragment caching, we can specify variations
    for our page, dependencies upon which our content should be invalidated, and the
    duration it should be cached for. Like other filters, we can also specify the
    actions we want our cache to apply to using the `only` and `except` parameters.
    The following example illustrates the use of page caching:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: HTTP caching
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Data, fragment, and page caching are all strategies that we can use to optimize
    the server-side performance of our application. To further improve the performance
    of our application, we can also send across headers with our application in order
    to indicate that we want the client''s browser to cache the output of our page.
    These three headers are `Last-Modified`, `ETag`, and `Cache-Control`. By sending
    these headers along with our application, we can significantly reduce the number
    of HTTP requests sent to our application from our clients for pages that don''t
    change often. HTTP caching in Yii2 is implemented by the `yii\filtersHttpCache`
    filter:'
  prefs: []
  type: TYPE_NORMAL
- en: The first header, `Last-Modified`, informs the client about the last time the
    page was changed. If a client makes a HEAD request to the server and sees that
    the `Last-Modified` header differs from what it currently has, it will re-request
    the page and cache it instead. Otherwise, it will load the page from the client's
    cache.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `ETag` header is used to represent a hash of the tag. Like the `Last-Modified`
    header, if the `ETag` hash changes, the browser knows that it had to re-download
    the page.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Finally, the `Cache-Control` header indicates what type of cache the page should
    be stored in and for how long. By default, Yii2 will send `public; max-age: 3600`
    for this header, which will indicate that the client should cache the content
    for 3600 seconds or 1 hour.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: More information on the Cache-Control header can be found on the w3c specification
    reference guide at [http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html#sec14.9](http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html#sec14.9).
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'An example illustrating the use of all three of these headers combined is illustrated
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Note that for HTTP caching, you only need to specify the headers you want to
    send. Specifying multiple headers can give you more fine grain control over when
    caches should be expired.
  prefs: []
  type: TYPE_NORMAL
- en: Caching database schema
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In order to make `ActiveRecord` models work automagically, Yii2 will automatically
    query the database to determine the schema of our application at the beginning
    of each query. While useful in a development environment, this operation is unnecessary
    in production environments where our schema rarely changes. We can tell Yii2 to
    cache our database schema to improve the performance of our database operations
    by enabling three properties of database component: `$schemeCache`, which represents
    the cache component we want to use; `$schemaCacheDuration`, which defines how
    long we want Yii2 to cache our schema; and `$enableSchemaCache`, which enables
    or disables the schema cache.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The following MySQL database component illustrates the use of the schema cache
    properties:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When schema cache is enabled, run the `cache/flush` command after applying new
    migrations so that Yii2 can pick up your new database structure.
  prefs: []
  type: TYPE_NORMAL
- en: General performance enhancements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For considerable performance gains, there are several changes that you can make
    to your application as well as your web server environment that can significantly
    increase the performance of your application.
  prefs: []
  type: TYPE_NORMAL
- en: Enabling OPCache
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Unlike compiled languages such as C and C++, PHP is an interpreted scripting
    language. Consequently, every time our web server requests a new page or every
    time we run a command from our command line, PHP needs to interpret our code into
    machine code that our servers can actually run. Even if our source code doesn't
    change, PHP will automatically perform this step on every request. In our development
    environments, this allows us to simply make a change to our source code, save
    the file, and then reload it in the page to see our changes. In a production environment,
    however, this step is unnecessary since our code will only change if we perform
    a deployment.
  prefs: []
  type: TYPE_NORMAL
- en: Starting in PHP 5.5, a new tool called OPCache was released by Zend Framework
    Technologies Ltd and built into the PHP core. Once enabled, OPCache will cache
    the compiled and optimized opcode that our PHP code is generated from and store
    it in a shared memory store. If our code is ever run again, OPCache will look
    inside that shared memory store for our code and execute it rather than re-interpreting
    our raw source code file. Depending upon the size of our application, enabling
    OPCache can have significant performance implications for our app. Moreover, since
    OPCache is now built into PHP, enabling it is fairly simple.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Note that Zend OPCache and APCCache both can be configured to cache PHP's opcode.
    It's highly recommended that you do not run both Zend OPCache and APCCache at
    the same time as it can cause instability within PHP. As Zend OPCache is maintained
    by PHP maintainers, it's recommended that you use it instead of APC.
  prefs: []
  type: TYPE_NORMAL
- en: 'Depending upon your package managed, OPCache may either be built into your
    PHP instance or provided as an external extension. A simply way to check whether
    OPCache is installed or not is to run the following command from your command
    line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'If OPCache is installed, you should see **Zend OPcache** appear in the output.
    If you don''t see this output, you''ll need to install OPCache from your package
    manager. Once OPCache is installed, you can enable it by adding the following
    to your `php.ini` file or to a file in your PHP INI includes folder and restarting
    your web server:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When you perform a deployment, you'll need to clear OPCache for your new code
    to take effect. Typically, this is done by restarting your web server or your
    PHP process. Alternatively, you can use a tool such as `cachetool` (available
    at [https://github.com/gordalina/cachetool](https://github.com/gordalina/cachetool))
    to clear the cache tool. Using a tool like `cachetool` is beneficial because it
    allows you to clear your OPCache without restarting your web server and facing
    potential downtime.
  prefs: []
  type: TYPE_NORMAL
- en: Optimizing Composer dependencies
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Another performance change you can make as part of your deployment is to exclude
    your development dependencies from your production deployments:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Since our development dependencies are used in development, loading and registering
    that code with our application only adds extra overhead to our application.
  prefs: []
  type: TYPE_NORMAL
- en: 'Additionally, we can instruct Composer to optimize the autoloader that it generates
    by running the following command when we install our composer dependencies:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Alternatively, we can generate an optimized autoloader file after installing
    our dependencies by running the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: By optimizing Composer's autoloader file, we can reduce the number of file and
    disk lookups with which we need to load our classes in our source code, which
    in turn will make our application faster.
  prefs: []
  type: TYPE_NORMAL
- en: Upgrading to PHP 7
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: At the time of publication, PHP 7 has been released, and it contains a refactored
    PHP engine that is able to interpret, compile, and execute the same PHP code with
    significantly less instructions. By reducing the number of CPU instructions and
    memory usage, PHP 7 is significantly faster than PHP 5.6\. For significant performance
    gains, consider upgrading your PHP instance from 5.6 to 7.
  prefs: []
  type: TYPE_NORMAL
- en: Switch to Facebook's HHVM
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As an alternative to upgrading to PHP 7, you can consider leaving the PHP engine
    and switching to HHVM, a reengineered engine for PHP created by Facebook. Like
    PHP 7, HHVM is significantly faster than PHP 5.6, and for high traffic applications,
    it can significantly reduce the costs associated with hosting a high traffic application.
    Unlike PHP 7, however, HHVM doesn't have support for all the PHP modules you may
    be accustomed to. Moreover, while Yii2 is fully compatible with HHVM, third-party
    Composer packages may not be, which may cause problems if thorough testing is
    not performed. For more information on HHVM, check out the HHVM documentation
    at [http://docs.hhvm.com/manual/en/index.php](http://docs.hhvm.com/manual/en/index.php).
  prefs: []
  type: TYPE_NORMAL
- en: Security considerations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When using Yii2, it's important to remember to follow security best practices
    in order to ensure the security of your application, the servers they run on,
    the data we collect, and our end users who entrust us with this information. In
    previous chapters, we explored how we can use the `yii\base\Security` class to
    safely encrypt and hash data and how to use hazing algorithms such as Bcrypt to
    secure passwords. In this section, we'll cover some additional security best practices
    that we can apply when building our applications.
  prefs: []
  type: TYPE_NORMAL
- en: Certificates
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In almost every application that Yii2 will be providing the backend for, our
    clients (browsers or native clients) will communicate with our application over
    HTTP (Hypertext Transfer Protocol). An easy way to ensure that the information
    our client submits from their clients reaches our servers in the same state it
    left in is to encrypt the traffic between our clients and the server with a certificate
    signed by a trusted certificate authority transmitted over the TLS (Transport
    Layer Security) protocol.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: TLS is the successor to SSL (Secure Sockets Layer), and both are often referred
    to as SSL certificates. As of 2014, all versions of SSL (1.0, 2.0, and 3.0) have
    been deprecated due to known security issues with the SSL protocol itself. Its
    successor, TLS versions 1.1 and 1.2, are not vulnerable and are the recommended
    protocol to use when encrypting data between clients and servers over HTTP.
  prefs: []
  type: TYPE_NORMAL
- en: 'Adding a signed and trusted certificate to our server has several major advantages:'
  prefs: []
  type: TYPE_NORMAL
- en: Encrypting data in transit prevents data from being viewed and manipulated by
    third parties. Health information, credit card information, usernames, and passwords
    can all be protected by encrypting data while in transit
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Clients can pin certificates that we publish so that they know to communicate
    with us only if our certificate matches the one they have pinned. This prevents
    Man-in-the-Middle attacks (MITM) and prevents others from learning about our data.
    Additionally, when using pinned certificates, our clients will know not to communicate
    with servers masquerading as ours. Again, this protects us and our users
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Search engines such as Google and Bing give higher rankings to sites that use
    TLS
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing TLS in our web server is a simple task, and on modern computers,
    it incurs almost no overhead
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When implementing TLS, there are several resources you can use to determine
    the most secure cipher suites and to verify that your configuration is secure.
    For instance, the [https://cipherli.st](https://cipherli.st) site provides a list
    of modern cipher suites for a variety of web servers and configurations. Qualys'
    SSL Labs site ([https://www.ssllabs.com/ssltest/](https://www.ssllabs.com/ssltest/))
    can also give you a complete report of your TLS configuration and can validate
    your web server configuration. Combined, these tools can help better secure your
    application and infrastructure.
  prefs: []
  type: TYPE_NORMAL
- en: Cookies
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'When retrieving data from cookies using `yii\web\Request` and `yii\web\Response`,
    Yii2 will automatically encrypt your cookie information using your cookie validation
    key:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: When working with cookies and session cookies, we can take additional protections
    by adding additional attributes to our cookies, such as `yii\web\Cookie::$secure`
    and `yii\web\Cookie::$httpOnly`. By marking our cookies as `secure`, we can ensure
    that our cookies will only be sent over a secure connection, as described in the
    previous section. Moreover, by setting our cookies to be `httpOnly`, we can ensure
    that JavaScript and other web scripting languages cannot read our cookies. By
    configuring our cookies with these two flags, we can significantly improve the
    security of our application.
  prefs: []
  type: TYPE_NORMAL
- en: Protecting against cross-site scripting
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As a general rule of web development, any time we display information submitted
    by an end user, we should encode it so that we can protect our site and users
    against XSS or cross-site scripting. XSS occurs when a user submits data that,
    when displayed on our page, can be interpreted by our browser. This could be something
    innocuous, such as adding `<em>` or `<b>` tags to our markup, or it could be something
    more sinister, such as injecting a `<script>` tag that tracks information about
    the user or redirects them to another site all together. Fortunately, Yii2 provides
    two ways of working with data submitted by end users that we can display.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first method we can use to protect our site from XSS is to encode end user
    data using the `yii\helpers\Html::encode()` method, as illustrated in the following
    example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: When encoding our data using this method, Yii2 will convert tags such as `<`
    and `>` into HTML-encoded entities that modern browsers know how to display and
    interpret.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the instance where we do want end user data to be displayed as HTML, we
    can use `yii\web\HtmlPurifier::purify()` to correctly parse our data with the
    rich HTML we want without allowing JavaScript code to be injected:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: HtmlPurifier can be extremely slow even when configured properly. Be sure you
    understand and configure HtmlPurifier properly before deploying your code as it
    can significantly hurt the performance of your application. More information on
    how to configure HtmlPurifier within Yii2 can be found at [http://www.yiiframework.com/doc-2.0/yii-helpers-htmlpurifier.html](http://www.yiiframework.com/doc-2.0/yii-helpers-htmlpurifier.html),
    and HtmlPurifier's complete documentation can be found at [http://htmlpurifier.org/](http://htmlpurifier.org/).
  prefs: []
  type: TYPE_NORMAL
- en: Enabling cross-site request forgery protection
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**CSRF** (**cross-site request forgery**) is another common vulnerability that
    many sites deal with, which Yii2 can help protect us against. When dealing with
    client requests, we generally assume that the request came from the user himself.
    With JavaScript, however, we can send false requests in the background without
    the user''s knowledge. These requests can be as simple as logging a user out of
    a given service without their knowledge or scraping a specific page for information
    about the user then transmitting it to a malicious server. Yii2 automatically
    protects us from CSRF attacks. The only additional protection you can perform
    is to follow the HTTP specification (such as not allowing state changes on GET
    requests).'
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Note that there may be many times when CSRF needs to be disabled for one reason
    or another. Within our controller, we can disable CSRF for specific actions by
    adding this code within our action by setting `Yii::$app->controller->enableCsrfValidation`
    to `false`.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we covered several different ways in which we can improve and
    explore the performance of our application and learned how to improve the security
    of our application. We explored how we can use data, page, fragment, HTTP, database,
    and schema caching to improve the performance of our application. We also discovered
    general improvements we can make to Yii2 and PHP in order to make our application
    run faster. Finally, we discovered several ways in which we can improve the security
    of our application through the use of certificates, enabling certain cookie attributes,
    and protecting our site against XSS and CSRF attacks.
  prefs: []
  type: TYPE_NORMAL
- en: In our final chapter, we'll cover how we can speed up our already fast development
    time with Yii2, learn how to explore our application through logging, and discover
    fast and secure ways to deploy our application with almost no downtime or interruption
    of service.
  prefs: []
  type: TYPE_NORMAL
