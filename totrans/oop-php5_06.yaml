- en: Chapter 6. Standard PHP Library
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第六章. 标准PHP库
- en: PHP5 made a developer's life a lot easier than before by introducing a number
    of built-in objects. These objects simplify tasks and saves countless sleepless
    nights for a lot of coders like me. **Standard PHP Library** (**SPL**) is a set
    of objects for PHP developers introduced in PHP5\. They come with a lot of interfaces
    and objects to simplify your coding. In this chapter we will go through some of
    them and show you their use.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: PHP5通过引入许多内置对象，使开发者的生活比以前容易得多。**标准PHP库**（**SPL**）是一组PHP 5中引入的对象，用于PHP开发者。它们附带了许多接口和对象，以简化您的编码。在本章中，我们将介绍其中的一些，并展示它们的用法。
- en: Available Objects in SPL
  id: totrans-2
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: SPL中的可用对象
- en: You can find out the available objects in SPL by executing the following code.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过执行以下代码来找出SPL中可用的对象。
- en: '[PRE0]'
  id: totrans-4
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The result will show you all the available classes in your current PHP install:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 结果将显示您当前PHP安装中所有可用的类：
- en: '[PRE1]'
  id: totrans-6
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: ArrayObject
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: ArrayObject
- en: This is a fantastic object introduced in SPL to simplify array operation and
    to enrich the normal PHP array. You can use `ArrayObject` as a simple array however
    internally you can enhance it and add new functionalities gradually. In this section
    we will see the properties and methods supported by this object. Also, we will
    design an enhanced `ArrayObject` for easier array access.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个SPL中引入的非常棒的对象，用于简化数组操作并丰富常规PHP数组的功能。您可以将 `ArrayObject` 作为简单的数组使用，但内部可以逐步增强它并添加新的功能。在本节中，我们将看到这个对象支持的属性和方法。此外，我们还将设计一个增强的
    `ArrayObject` 以便于数组访问。
- en: 'Here are the public members of this class:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 这里列出了这个类的公共成员：
- en: '`__construct` `($array,` `$flags=0,` `$iterator_class="ArrayIterator")`'
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`__construct` `($array,` `$flags=0,` `$iterator_class="ArrayIterator")`'
- en: '`append` `($value)`'
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`append` `($value)`'
- en: '`asort` `()`'
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`asort` `()`'
- en: '`count` `()`'
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`count` `()`'
- en: '`exchangeArray` `($array)`'
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`exchangeArray` `($array)`'
- en: '`getArrayCopy` `()`'
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`getArrayCopy` `()`'
- en: '`getFlags` `()`'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`getFlags` `()`'
- en: '`getIterator` `()`'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`getIterator` `()`'
- en: '`getIteratorClass` `()`'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`getIteratorClass` `()`'
- en: '`ksort` `()`'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ksort` `()`'
- en: '`natcasesort` `()`'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`natcasesort` `()`'
- en: '`natsort` `()`'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`natsort` `()`'
- en: '`offsetExists` `($index)`'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`offsetExists` `($index)`'
- en: '`offsetGet` `($index)`'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`offsetGet` `($index)`'
- en: '`offsetSet` `($index,` `$newval)`'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`offsetSet` `($index,` `$newval)`'
- en: '`offsetUnset` `($index)`'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`offsetUnset` `($index)`'
- en: '`setFlags` `($flags)`'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`setFlags` `($flags)`'
- en: '`setIteratorClass` `($itertor_class)`'
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`setIteratorClass` `($itertor_class)`'
- en: '`uasort` `(mixed` `cmp_function)`'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`uasort` `(mixed` `cmp_function)`'
- en: '`uksort` `(mixed` `cmp_function)`'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`uksort` `(mixed` `cmp_function)`'
- en: 'Many of these functions are also available for array operation. Here is a brief
    introduction about some functions, which are differentl to those from array functions:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 许多这些函数也适用于数组操作。以下是一些函数的简要介绍，它们与数组函数不同：
- en: '| Function | Feature |'
  id: totrans-31
  prefs: []
  type: TYPE_TB
  zh: '| 函数 | 功能 |'
- en: '| --- | --- |'
  id: totrans-32
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `exchangeArray($array)` | This function replaces the internal array of an
    `ArrayObject` with the new one and returns the old one. |'
  id: totrans-33
  prefs: []
  type: TYPE_TB
  zh: '| `exchangeArray($array)` | 此函数用新的数组替换 `ArrayObject` 的内部数组，并返回旧的数组。|'
- en: '| `getArrayCopy()` | This function returns a copy of the internal array from
    inside this `ArrayObject`. |'
  id: totrans-34
  prefs: []
  type: TYPE_TB
  zh: '| `getArrayCopy()` | 此函数返回 `ArrayObject` 内部数组的副本。|'
- en: '| `getIteratorClass()` | This function returns the name of the `Iterator` class.
    If you don''t explicitly set any other `Iterator` class for this object, you will
    always get `ArrayIterator` as the result. |'
  id: totrans-35
  prefs: []
  type: TYPE_TB
  zh: '| `getIteratorClass()` | 此函数返回 `Iterator` 类的名称。如果您没有为该对象显式设置任何其他 `Iterator`
    类，您将始终得到 `ArrayIterator` 作为结果。|'
- en: '| `setIteratorClass()` | Using this function you can set any `Iterator` class
    as the Iterator for array object. However there is one limitation; is one limitation;
    this `Iterator` class must extend the `arrayIterator` class. |'
  id: totrans-36
  prefs: []
  type: TYPE_TB
  zh: '| `setIteratorClass()` | 使用此函数，您可以设置任何 `Iterator` 类作为数组对象的迭代器。然而，有一个限制；这个 `Iterator`
    类必须扩展 `arrayIterator` 类。|'
- en: '| `setFlags()` | This function sets some bitwise flags to `ArrayObject`. Flags
    are `0` or `1`. `0`, which means properties of the object have their normal functionality
    when accessed as list (`var_dump`, `foreach`, etc.) and `1` means array indices
    can be accessed as properties in read/write. |'
  id: totrans-37
  prefs: []
  type: TYPE_TB
  zh: '| `setFlags()` | 此函数将一些位运算标志设置到 `ArrayObject` 中。标志是 `0` 或 `1`。`0` 表示当作为列表访问（`var_dump`、`foreach`
    等）时，对象的属性具有其正常功能，而 `1` 表示可以以属性的形式读写数组索引。|'
- en: 'In the interesting example shown below, we are extending `ArrayObject` and
    creating a more flexible `ExtendedArrayObject` for prototype like functionality.
    The extended array provides easier traversing through the collection. Let''s have
    a look:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面有趣的例子中，我们扩展了`ArrayObject`，创建了一个更灵活的`ExtendedArrayObject`以实现类似原型的功能。扩展数组提供了通过集合进行遍历的简便性。让我们看看：
- en: '[PRE2]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'If you want to see how to use it, here it goes:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想看看如何使用它，这里就是：
- en: '[PRE3]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The result looks like this:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 结果看起来像这样：
- en: '[PRE4]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: ArrayIterator
  id: totrans-44
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: ArrayIterator
- en: '`ArrayIterator` is used to iterate over the elements of an array. In SPL, `ArrayObject`
    has a built-in Iterator, which you can access using `getIterator` function. You
    can use this object to iterate over any collection. Let''s take a look at the
    example here:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '`ArrayIterator`用于遍历数组的元素。在SPL中，`ArrayObject`有一个内置的迭代器，你可以使用`getIterator`函数访问它。你可以使用这个对象遍历任何集合。让我们看看下面的例子：'
- en: '[PRE5]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'This will output the following:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 这将输出以下内容：
- en: '[PRE6]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: However, an Iterator also implements the `IteratorAggregator` interface so you
    can even use them in the `foreach()` loop.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，迭代器还实现了`IteratorAggregator`接口，因此你甚至可以在`foreach()`循环中使用它们。
- en: '[PRE7]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: You will get the same output as the previous one.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 你将得到与上一个相同的输出。
- en: 'If you want to implement Iterator to your own collection, collection, I recommend
    you take a look at Chapter 3\. If you want to know how to implement `IteratorAggregator`,
    here is an example for you:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要在自己的集合中实现迭代器，我建议你查看第3章。如果你想了解如何实现`IteratorAggregator`，这里有一个例子供你参考：
- en: '[PRE8]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Please note that if key and value are the same, it will not return that value
    while iterating. You can use it like this:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，如果在迭代过程中键和值相同，则不会返回该值。你可以这样使用它：
- en: '[PRE9]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The output is:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE10]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: DirectoryIterator
  id: totrans-58
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: DirectoryIterator
- en: Another very interesting class introduced in PHP5 is `DirectoryIterator`. This
    object can iterate through the items present in a directory (well, those nothing
    but files) and you can retrieve different attributes of that file using this object.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: PHP5中引入的另一个非常有趣的类是`DirectoryIterator`。这个对象可以遍历目录中存在的项目（好吧，那些只是文件），你可以使用这个对象检索该文件的不同属性。
- en: 'In the PHP Manual this object is not well documented. So if you want to know
    the structure of this object and supported methods and properties, you can use
    `ReflectionClass` for that. Remember the `ReflectionClass` we used in the previous
    chapter? Let''s take a look at the following example:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 在PHP手册中，这个对象没有很好地记录。所以如果你想了解这个对象的结构以及支持的方法和属性，你可以使用`ReflectionClass`来查看。还记得我们在上一章中使用的`ReflectionClass`吗？让我们看看以下例子：
- en: '[PRE11]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The result is:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 结果是：
- en: '[PRE12]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'We have a handful of useful methods here. Let''s make use of them. In the following
    example we will just create a directory crawler, which will display all files
    and directories in a specific drive. Take a look at one of my directories on the
    C drive called `spket`:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一些有用的方法。让我们充分利用它们。在下面的例子中，我们将创建一个目录爬虫，它会显示特定驱动器中的所有文件和目录。看看我的C盘上的一个名为`spket`的目录：
- en: '![DirectoryIterator](img/2561_06_01.jpg)'
  id: totrans-65
  prefs: []
  type: TYPE_IMG
  zh: '![DirectoryIterator](img/2561_06_01.jpg)'
- en: 'Now, if you run the following code, you will get the list of files and directories
    inside it:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果你运行以下代码，你将得到其中文件和目录的列表：
- en: '[PRE13]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The output is:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE14]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: But the output doesn't make any sense. Can you detect which are the directories
    and which are the files? It's very difficult, so let's make the result useful
    for us.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 但是输出没有任何意义。你能检测出哪些是目录，哪些是文件吗？这非常困难，所以让我们使结果对我们有用。
- en: '[PRE15]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The output is:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE16]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: You may ask at this point, if there is a shortcut link, how you can detect it.
    Simple, just use the `$file->isLink()` function to detect if that file is a shortcut.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会问，如果有一个快捷链接，你怎么能检测它。简单，只需使用`$file->isLink()`函数来检测该文件是否是快捷方式。
- en: 'Let''s take a look at other useful methods of the `DirectoryIterator` object:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看`DirectoryIterator`对象的其他有用方法：
- en: '| Methods | Feature |'
  id: totrans-76
  prefs: []
  type: TYPE_TB
  zh: '| 方法 | 功能 |'
- en: '| --- | --- |'
  id: totrans-77
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `getPathname()` | Returns the absolute path name (with file name) of this
    file. |'
  id: totrans-78
  prefs: []
  type: TYPE_TB
  zh: '| `getPathname()` | 返回此文件的绝对路径名（包含文件名）。|'
- en: '| `getSize()` | Returns size of file in number of bytes. |'
  id: totrans-79
  prefs: []
  type: TYPE_TB
  zh: '| `getSize()` | 返回文件的字节数。|'
- en: '| `getOwner()` | Returns the owner ID. |'
  id: totrans-80
  prefs: []
  type: TYPE_TB
  zh: '| `getOwner()` | 返回所有者ID。|'
- en: '| `getATime()` | Returns the last access time in timestamp. |'
  id: totrans-81
  prefs: []
  type: TYPE_TB
  zh: '| `getATime()` | 返回以时间戳表示的最后访问时间。|'
- en: '| `getMTime()` | Returns the modification time in timestamp. |'
  id: totrans-82
  prefs: []
  type: TYPE_TB
  zh: '| `getMTime()` | 返回以时间戳表示的修改时间。|'
- en: '| `getCTime()` | Returns the creation time in timestamp. |'
  id: totrans-83
  prefs: []
  type: TYPE_TB
  zh: '| `getCTime()` | 返回以时间戳表示的创建时间。|'
- en: '| `getType()` | Returns either "file", "dir", or "link". |'
  id: totrans-84
  prefs: []
  type: TYPE_TB
  zh: '| `getType()` | 返回 "file"、"dir" 或 "link"。 |'
- en: Other methods are quite self explanatory, so we are not covering them here.
    One more thing to remember however, is `getInode()`, `getOwner()`, and `getGroup()`
    will return `0` in win32 machines.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 其他方法相当直观，所以我们在这里不讨论它们。然而，还有一件事需要记住，那就是在 win32 机器上，`getInode()`、`getOwner()`
    和 `getGroup()` 将返回 `0`。
- en: RecursiveDirectoryIterator
  id: totrans-86
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: RecursiveDirectoryIterator
- en: So what is this object? Remember our previous example? We got a list of directories
    and files only. However, what if we want to get a list of all directories inside
    that directory without implementing the recursion? Then `RecursiveDirectoryIterator`
    is here to save your life.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，这个对象是什么？还记得我们之前的例子吗？我们只得到了目录和文件列表。然而，如果我们想在不实现递归的情况下获取该目录内所有目录的列表，该怎么办？那么
    `RecursiveDirectoryIterator` 就在这里救你一命。
- en: 'The recursive directory Iterator can be used to great effect with `RecursiveIeratorIterator`
    to implement the recursion. Let''s take a look at the following example, it traverses
    through all the directories under a directory (no matter how nested it is):'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 递归目录迭代器可以与 `RecursiveIeratorIterator` 结合使用，以实现递归。让我们看看以下示例，它遍历目录下的所有目录（无论嵌套多深）：
- en: '[PRE17]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The output is like this one:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下所示：
- en: '[PRE18]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'I can hear you asking yourself: ''why are these useless files printed here?''
    Just take a look at directory structure and see how it retrieves the entire file
    name with their path as key.'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 我能听到你在问自己：“为什么这些无用的文件会打印在这里？”只需看看目录结构，看看它是如何以路径作为键检索整个文件名的。
- en: RecursiveIteratorIterator
  id: totrans-93
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: RecursiveIteratorIterator
- en: To recursively iterate over a collection, you can make take advantage of this
    object introduced in SPL. Let's take a look at the following example to understand
    how effectively it can be used in your everyday programming. In the previous sections
    and also in the coming sections we see many examples using `RecursiveIteratorIterator`;
    so we are not giving any more examples in this section.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 要递归地遍历一个集合，你可以利用 SPL 中引入的这个对象。让我们看看以下示例，了解它在日常编程中如何有效使用。在前面的章节和即将到来的章节中，我们看到许多使用
    `RecursiveIteratorIterator` 的示例；因此，我们在这个章节中不再给出更多示例。
- en: AppendIterator
  id: totrans-95
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: AppendIterator
- en: If you want to use a collection of Iterators to iterate through, then this could
    be your life saver. This object saves all the Iterators in a collection and iterates
    through all of them at once.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要使用一系列迭代器进行迭代，那么这可能是你的救命稻草。此对象将所有迭代器存储在一个集合中，并一次性遍历它们。
- en: 'Let''s take a look at the following example of `append` Iterator, where we
    traverse through a collection of Iterators and then minimize the code:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看以下 `append` 迭代器的示例，其中我们遍历一系列迭代器，然后最小化代码：
- en: '[PRE19]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'And here comes the output:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来是输出：
- en: '[PRE20]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: FilterIterator
  id: totrans-101
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: FilterIterator
- en: As its name suggests, this Iterator helps you to filter out the result through
    iteration so that you get only the results you require. This Iterator is very
    useful for iteration with filtering,
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 如其名所示，这个迭代器帮助你通过迭代过滤结果，以便你只得到所需的结果。这个迭代器在带有过滤的迭代中非常有用，
- en: '`FilterIterator` exposes two extra methods over a regular Iterator. One is
    `accept()` which is called every time in internal iteration and is your key point
    to perform the filter. The second one is `getInnerIterator()`, which returns the
    current Iterator inside this `FilterIterator`.'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: '`FilterIterator` 在常规迭代器之上暴露了两个额外的方法。一个是 `accept()`，它在内部迭代每次调用，是你的过滤关键点。另一个是
    `getInnerIterator()`，它返回当前 `FilterIterator` 内部的迭代器。'
- en: In this example we use `FilterIterator` to filter out data while traversing
    through a collection.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们使用 `FilterIterator` 在遍历集合时过滤数据。
- en: '[PRE21]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'If you run the code, you will get the following result:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你运行代码，你将得到以下结果：
- en: '[PRE22]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'I''m sure you will agree that this is quite interesting, however did you get
    the catch? This is filtered by the following entry point:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 我相信你会同意这相当有趣，然而你抓住了关键吗？这是通过以下入口点过滤的：
- en: '[PRE23]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: LimitIterator
  id: totrans-110
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: LimitIterator
- en: What if you want to define the start point from where your iteration will start
    and also define the times you want to iterate? This is made possible using `LimitIterator`.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想定义迭代开始的位置以及你想迭代的次数，该怎么办？这可以通过 `LimitIterator` 实现。
- en: '`LimitIterator` takes three parameters while constructing. The first one is
    a regular Iterator, the second one is the starting offset, and the third one is
    the number of times that it will iterate. Take a look at the following example:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: '`LimitIterator`在构造时接受三个参数。第一个是一个常规的Iterator，第二个是起始偏移量，第三个是它将迭代的次数。看看以下示例：'
- en: '[PRE24]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'And the output is:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE25]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: NoRewindIterator
  id: totrans-116
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: NoRewindIterator
- en: 'This is another Iterator in which you can''t invoke the `rewind` method. That
    means it is a forward-only Iterator, which can read a collection only once. Take
    a look at the structure; if you execute the following code you will get the methods
    supported by this Iterator:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个您不能调用`rewind`方法的另一个Iterator。这意味着它是一个单向Iterator，只能读取集合一次。看看结构；如果您执行以下代码，您将得到这个Iterator支持的方法：
- en: '[PRE26]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'The output would be the methods, as seen below:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 输出将是以下所示的方法：
- en: '[PRE27]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Surprisingly, it has no rewind method, but you can see it, can't you? Well,
    that method has no implementation, it is empty. It is there as it implements the
    Iterator interface, but there is no implementation of that function, so you can't
    rewind.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 令人惊讶的是，它没有rewind方法，但您可以看到它，不是吗？嗯，该方法没有实现，它是空的。它之所以存在，是因为它实现了Iterator接口，但没有实现该函数，所以您不能回滚。
- en: '[PRE28]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'If the `rewind()` method works, this code will be an endless loop. But in practical,
    it displays the output as shown below:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`rewind()`方法工作，这段代码将是一个无限循环。但在实际中，它显示的输出如下：
- en: '[PRE29]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: SeekableIterator
  id: totrans-125
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: SeekableIterator
- en: This is an interface introduced in SPL, which many Iterator classes actually
    implement internally. If this interface is implemented, you can perform `seek()`
    operation inside this array.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个在SPL中引入的接口，许多Iterator类实际上在内部实现。如果实现了这个接口，您可以在数组内部执行`seek()`操作。
- en: 'Let''s take a look at the following example where we implement `SeekableIterator`
    to provide a searching facility over a collection:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看以下示例，其中我们实现`SeekableIterator`以在集合上提供搜索功能：
- en: '[PRE30]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'The output is:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE31]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: RecursiveIterator
  id: totrans-131
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: RecursiveIterator
- en: This is another interface introduced by SPL for easy recursion over nested collections.
    By implementing this interface and using it with `RecursiveIteratorIterator`,
    you can easily traverse through nested collections.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 这是SPL引入的另一个接口，用于轻松地对嵌套集合进行递归。通过实现此接口并使用`RecursiveIteratorIterator`，您可以轻松地遍历嵌套集合。
- en: 'If you implement `RecursiveIterator`, you have to apply two methods, one is
    `hasChildren()`, which must determine whether the current object is an array or
    not (and that means if it has children or not) and the second one is `getChildren()`,
    which must return an instance of the same class over the collection. That''s it.
    To understand the bigger picture, take a look at the following example:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您实现`RecursiveIterator`，您必须应用两个方法，一个是`hasChildren()`，它必须确定当前对象是否为数组（这意味着它是否有子对象）以及第二个是`getChildren()`，它必须返回集合中相同类的实例。就是这样。为了理解更大的图景，请看以下示例：
- en: '[PRE32]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'The output is:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE33]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: SPLFileObject
  id: totrans-137
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: SPLFileObject
- en: 'This is another fantastic object introduced in SPL for basic file operations.
    You can iterate through the content of the file in a more elegant way using this
    object. In `SPLFileObject`, the following methods are supported:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 这是在SPL中引入的另一个用于基本文件操作的出色对象。您可以使用此对象以更优雅的方式遍历文件内容。在`SPLFileObject`中，支持以下方法：
- en: '[PRE34]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: If you carefully look into it, you will find that general file functions in
    PHP are implemented in this object, which gives you more flexibility to work with.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您仔细观察，您会发现PHP中的通用文件函数都是在这个对象中实现的，这为您提供了更多的工作灵活性。
- en: In the following example we will discuss how to use `SPLFileObject:`
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下示例中，我们将讨论如何使用`SPLFileObject`：
- en: '[PRE35]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Therefore, it works in the same was as an Iterator, you can rewind, seek, and
    perform other general tasks. There are also some interesting functions like `getMaxLineLen`,
    `fstat`, `hasChildren`, `getChildren` etc.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，它的工作方式与Iterator相同，您可以回滚、定位并执行其他一般任务。还有一些有趣的功能，如`getMaxLineLen`、`fstat`、`hasChildren`、`getChildren`等。
- en: Using `SPLFileObject` you can retrieve remote files too.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`SPLFileObject`，您还可以检索远程文件。
- en: SPLFileInfo
  id: totrans-145
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: SPLFileInfo
- en: 'This is another object introduced by SPL, which helps you to retrieve file
    information of any specific file. Let''s have a look at the structure first:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 这是SPL引入的另一个对象，它帮助您检索任何特定文件的文件信息。让我们首先看看它的结构：
- en: '[PRE36]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: You can use `SPLFileInfo` to open any file. However, what is more interesting
    is that it supports overloading the opening of a file. You can supply your open
    file manager class to it and it will be invoked while opening a file.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用`SPLFileInfo`打开任何文件。然而，更有趣的是，它支持文件打开的重载。你可以向它提供一个打开文件管理器类，它将在打开文件时被调用。
- en: Let's take a look at the following example.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看以下示例。
- en: '[PRE37]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'This example will output the following:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 这个示例将输出以下内容：
- en: '[PRE38]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: SPLObjectStorage
  id: totrans-153
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: SPLObjectStorage
- en: Beside Directory, File Objects and Iterators, SPL also introduced another cool
    object which can store any object inside it with special facilities. This object
    is called `SPLObjectStorage`. We will understand this using the example later
    on in this chapter.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 除了目录、文件对象和迭代器之外，SPL还引入了另一个非常酷的对象，它可以存储任何对象，并具有特殊功能。这个对象被称为`SPLObjectStorage`。我们将在本章后面的示例中了解它。
- en: '`SPLObjectStorage` can store any object in it. When you change the main object,
    the object that is stored inside the `SPLObjectStorage` will also be changed.
    If you try to add a specific object more than once, it won''t add actually. You
    can also delete the object from the storage any time.'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: '`SPLObjectStorage`可以存储任何对象。当你更改主对象时，存储在`SPLObjectStorage`中的对象也会发生变化。如果你尝试添加一个特定的对象多次，实际上它不会添加。你还可以随时从存储中删除对象。'
- en: 'Besides this, `SPLObjectStorage` provides the facility to iterate through a
    collection of stored objects. Let''s take a look at the following example, which
    demonstrates the use of `SPLObjectStorage`:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，`SPLObjectStorage`提供了遍历存储对象集合的功能。让我们看看以下示例，它演示了`SPLObjectStorage`的使用：
- en: '[PRE39]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'The output is as follows:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE40]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Summary
  id: totrans-160
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: After introducing PHP5 to the world, the PHP team introduced the strong object
    oriented programming in PHP to PHP developers. PHP5 comes with a lot of handy
    built-in objects amongst which SPL is a fantastic one. It eases programming for
    many tasks, which were once quite tough. So SPL introduced many objects that we
    have just discussed and learned how to use. As the PHP manual doesn't have updated
    and detailed information on all of these classes, you can count this chapter as
    a good reference for programming with SPL objects.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 在将PHP5介绍给世界之后，PHP团队向PHP开发者引入了强大的面向对象编程。PHP5附带了许多实用的内置对象，其中SPL就是一个非常出色的例子。它简化了许多曾经相当困难的编程任务。因此，SPL引入了许多我们刚刚讨论并学习如何使用的对象。由于PHP手册没有关于所有这些类的更新和详细信息，你可以将这一章视为使用SPL对象的良好参考。
