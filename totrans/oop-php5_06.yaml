- en: Chapter 6. Standard PHP Library
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: PHP5 made a developer's life a lot easier than before by introducing a number
    of built-in objects. These objects simplify tasks and saves countless sleepless
    nights for a lot of coders like me. **Standard PHP Library** (**SPL**) is a set
    of objects for PHP developers introduced in PHP5\. They come with a lot of interfaces
    and objects to simplify your coding. In this chapter we will go through some of
    them and show you their use.
  prefs: []
  type: TYPE_NORMAL
- en: Available Objects in SPL
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You can find out the available objects in SPL by executing the following code.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'The result will show you all the available classes in your current PHP install:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: ArrayObject
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This is a fantastic object introduced in SPL to simplify array operation and
    to enrich the normal PHP array. You can use `ArrayObject` as a simple array however
    internally you can enhance it and add new functionalities gradually. In this section
    we will see the properties and methods supported by this object. Also, we will
    design an enhanced `ArrayObject` for easier array access.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are the public members of this class:'
  prefs: []
  type: TYPE_NORMAL
- en: '`__construct` `($array,` `$flags=0,` `$iterator_class="ArrayIterator")`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`append` `($value)`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`asort` `()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`count` `()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`exchangeArray` `($array)`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`getArrayCopy` `()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`getFlags` `()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`getIterator` `()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`getIteratorClass` `()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ksort` `()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`natcasesort` `()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`natsort` `()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`offsetExists` `($index)`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`offsetGet` `($index)`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`offsetSet` `($index,` `$newval)`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`offsetUnset` `($index)`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`setFlags` `($flags)`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`setIteratorClass` `($itertor_class)`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`uasort` `(mixed` `cmp_function)`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`uksort` `(mixed` `cmp_function)`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Many of these functions are also available for array operation. Here is a brief
    introduction about some functions, which are differentl to those from array functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Function | Feature |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `exchangeArray($array)` | This function replaces the internal array of an
    `ArrayObject` with the new one and returns the old one. |'
  prefs: []
  type: TYPE_TB
- en: '| `getArrayCopy()` | This function returns a copy of the internal array from
    inside this `ArrayObject`. |'
  prefs: []
  type: TYPE_TB
- en: '| `getIteratorClass()` | This function returns the name of the `Iterator` class.
    If you don''t explicitly set any other `Iterator` class for this object, you will
    always get `ArrayIterator` as the result. |'
  prefs: []
  type: TYPE_TB
- en: '| `setIteratorClass()` | Using this function you can set any `Iterator` class
    as the Iterator for array object. However there is one limitation; is one limitation;
    this `Iterator` class must extend the `arrayIterator` class. |'
  prefs: []
  type: TYPE_TB
- en: '| `setFlags()` | This function sets some bitwise flags to `ArrayObject`. Flags
    are `0` or `1`. `0`, which means properties of the object have their normal functionality
    when accessed as list (`var_dump`, `foreach`, etc.) and `1` means array indices
    can be accessed as properties in read/write. |'
  prefs: []
  type: TYPE_TB
- en: 'In the interesting example shown below, we are extending `ArrayObject` and
    creating a more flexible `ExtendedArrayObject` for prototype like functionality.
    The extended array provides easier traversing through the collection. Let''s have
    a look:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'If you want to see how to use it, here it goes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'The result looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: ArrayIterator
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`ArrayIterator` is used to iterate over the elements of an array. In SPL, `ArrayObject`
    has a built-in Iterator, which you can access using `getIterator` function. You
    can use this object to iterate over any collection. Let''s take a look at the
    example here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'This will output the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: However, an Iterator also implements the `IteratorAggregator` interface so you
    can even use them in the `foreach()` loop.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: You will get the same output as the previous one.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you want to implement Iterator to your own collection, collection, I recommend
    you take a look at Chapter 3\. If you want to know how to implement `IteratorAggregator`,
    here is an example for you:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Please note that if key and value are the same, it will not return that value
    while iterating. You can use it like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: DirectoryIterator
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Another very interesting class introduced in PHP5 is `DirectoryIterator`. This
    object can iterate through the items present in a directory (well, those nothing
    but files) and you can retrieve different attributes of that file using this object.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the PHP Manual this object is not well documented. So if you want to know
    the structure of this object and supported methods and properties, you can use
    `ReflectionClass` for that. Remember the `ReflectionClass` we used in the previous
    chapter? Let''s take a look at the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'The result is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'We have a handful of useful methods here. Let''s make use of them. In the following
    example we will just create a directory crawler, which will display all files
    and directories in a specific drive. Take a look at one of my directories on the
    C drive called `spket`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![DirectoryIterator](img/2561_06_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Now, if you run the following code, you will get the list of files and directories
    inside it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: But the output doesn't make any sense. Can you detect which are the directories
    and which are the files? It's very difficult, so let's make the result useful
    for us.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: You may ask at this point, if there is a shortcut link, how you can detect it.
    Simple, just use the `$file->isLink()` function to detect if that file is a shortcut.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take a look at other useful methods of the `DirectoryIterator` object:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Methods | Feature |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `getPathname()` | Returns the absolute path name (with file name) of this
    file. |'
  prefs: []
  type: TYPE_TB
- en: '| `getSize()` | Returns size of file in number of bytes. |'
  prefs: []
  type: TYPE_TB
- en: '| `getOwner()` | Returns the owner ID. |'
  prefs: []
  type: TYPE_TB
- en: '| `getATime()` | Returns the last access time in timestamp. |'
  prefs: []
  type: TYPE_TB
- en: '| `getMTime()` | Returns the modification time in timestamp. |'
  prefs: []
  type: TYPE_TB
- en: '| `getCTime()` | Returns the creation time in timestamp. |'
  prefs: []
  type: TYPE_TB
- en: '| `getType()` | Returns either "file", "dir", or "link". |'
  prefs: []
  type: TYPE_TB
- en: Other methods are quite self explanatory, so we are not covering them here.
    One more thing to remember however, is `getInode()`, `getOwner()`, and `getGroup()`
    will return `0` in win32 machines.
  prefs: []
  type: TYPE_NORMAL
- en: RecursiveDirectoryIterator
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So what is this object? Remember our previous example? We got a list of directories
    and files only. However, what if we want to get a list of all directories inside
    that directory without implementing the recursion? Then `RecursiveDirectoryIterator`
    is here to save your life.
  prefs: []
  type: TYPE_NORMAL
- en: 'The recursive directory Iterator can be used to great effect with `RecursiveIeratorIterator`
    to implement the recursion. Let''s take a look at the following example, it traverses
    through all the directories under a directory (no matter how nested it is):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is like this one:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'I can hear you asking yourself: ''why are these useless files printed here?''
    Just take a look at directory structure and see how it retrieves the entire file
    name with their path as key.'
  prefs: []
  type: TYPE_NORMAL
- en: RecursiveIteratorIterator
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To recursively iterate over a collection, you can make take advantage of this
    object introduced in SPL. Let's take a look at the following example to understand
    how effectively it can be used in your everyday programming. In the previous sections
    and also in the coming sections we see many examples using `RecursiveIteratorIterator`;
    so we are not giving any more examples in this section.
  prefs: []
  type: TYPE_NORMAL
- en: AppendIterator
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you want to use a collection of Iterators to iterate through, then this could
    be your life saver. This object saves all the Iterators in a collection and iterates
    through all of them at once.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take a look at the following example of `append` Iterator, where we
    traverse through a collection of Iterators and then minimize the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'And here comes the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: FilterIterator
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As its name suggests, this Iterator helps you to filter out the result through
    iteration so that you get only the results you require. This Iterator is very
    useful for iteration with filtering,
  prefs: []
  type: TYPE_NORMAL
- en: '`FilterIterator` exposes two extra methods over a regular Iterator. One is
    `accept()` which is called every time in internal iteration and is your key point
    to perform the filter. The second one is `getInnerIterator()`, which returns the
    current Iterator inside this `FilterIterator`.'
  prefs: []
  type: TYPE_NORMAL
- en: In this example we use `FilterIterator` to filter out data while traversing
    through a collection.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'If you run the code, you will get the following result:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'I''m sure you will agree that this is quite interesting, however did you get
    the catch? This is filtered by the following entry point:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: LimitIterator
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What if you want to define the start point from where your iteration will start
    and also define the times you want to iterate? This is made possible using `LimitIterator`.
  prefs: []
  type: TYPE_NORMAL
- en: '`LimitIterator` takes three parameters while constructing. The first one is
    a regular Iterator, the second one is the starting offset, and the third one is
    the number of times that it will iterate. Take a look at the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'And the output is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: NoRewindIterator
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This is another Iterator in which you can''t invoke the `rewind` method. That
    means it is a forward-only Iterator, which can read a collection only once. Take
    a look at the structure; if you execute the following code you will get the methods
    supported by this Iterator:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'The output would be the methods, as seen below:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Surprisingly, it has no rewind method, but you can see it, can't you? Well,
    that method has no implementation, it is empty. It is there as it implements the
    Iterator interface, but there is no implementation of that function, so you can't
    rewind.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'If the `rewind()` method works, this code will be an endless loop. But in practical,
    it displays the output as shown below:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: SeekableIterator
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This is an interface introduced in SPL, which many Iterator classes actually
    implement internally. If this interface is implemented, you can perform `seek()`
    operation inside this array.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take a look at the following example where we implement `SeekableIterator`
    to provide a searching facility over a collection:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: RecursiveIterator
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This is another interface introduced by SPL for easy recursion over nested collections.
    By implementing this interface and using it with `RecursiveIteratorIterator`,
    you can easily traverse through nested collections.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you implement `RecursiveIterator`, you have to apply two methods, one is
    `hasChildren()`, which must determine whether the current object is an array or
    not (and that means if it has children or not) and the second one is `getChildren()`,
    which must return an instance of the same class over the collection. That''s it.
    To understand the bigger picture, take a look at the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: SPLFileObject
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This is another fantastic object introduced in SPL for basic file operations.
    You can iterate through the content of the file in a more elegant way using this
    object. In `SPLFileObject`, the following methods are supported:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: If you carefully look into it, you will find that general file functions in
    PHP are implemented in this object, which gives you more flexibility to work with.
  prefs: []
  type: TYPE_NORMAL
- en: In the following example we will discuss how to use `SPLFileObject:`
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: Therefore, it works in the same was as an Iterator, you can rewind, seek, and
    perform other general tasks. There are also some interesting functions like `getMaxLineLen`,
    `fstat`, `hasChildren`, `getChildren` etc.
  prefs: []
  type: TYPE_NORMAL
- en: Using `SPLFileObject` you can retrieve remote files too.
  prefs: []
  type: TYPE_NORMAL
- en: SPLFileInfo
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This is another object introduced by SPL, which helps you to retrieve file
    information of any specific file. Let''s have a look at the structure first:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: You can use `SPLFileInfo` to open any file. However, what is more interesting
    is that it supports overloading the opening of a file. You can supply your open
    file manager class to it and it will be invoked while opening a file.
  prefs: []
  type: TYPE_NORMAL
- en: Let's take a look at the following example.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'This example will output the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: SPLObjectStorage
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Beside Directory, File Objects and Iterators, SPL also introduced another cool
    object which can store any object inside it with special facilities. This object
    is called `SPLObjectStorage`. We will understand this using the example later
    on in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: '`SPLObjectStorage` can store any object in it. When you change the main object,
    the object that is stored inside the `SPLObjectStorage` will also be changed.
    If you try to add a specific object more than once, it won''t add actually. You
    can also delete the object from the storage any time.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Besides this, `SPLObjectStorage` provides the facility to iterate through a
    collection of stored objects. Let''s take a look at the following example, which
    demonstrates the use of `SPLObjectStorage`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: After introducing PHP5 to the world, the PHP team introduced the strong object
    oriented programming in PHP to PHP developers. PHP5 comes with a lot of handy
    built-in objects amongst which SPL is a fantastic one. It eases programming for
    many tasks, which were once quite tough. So SPL introduced many objects that we
    have just discussed and learned how to use. As the PHP manual doesn't have updated
    and detailed information on all of these classes, you can count this chapter as
    a good reference for programming with SPL objects.
  prefs: []
  type: TYPE_NORMAL
