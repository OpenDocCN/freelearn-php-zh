- en: 10\. Web Services
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 10. 网络服务
- en: Overview
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 概述
- en: By the end of this chapter, you will be able to identify key factors in selecting
    a third-party web service; explain the basic concepts of a RESTful web service;
    determine the correct headers to add to a request; explain common web service
    authentication and authorization schemes; create and read request bodies in JSON;
    perform manual API testing using a REST client; and compose `GET` and `POST` requests
    in PHP using Guzzle and then process the results.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章结束时，您将能够识别选择第三方网络服务的关键因素；解释RESTful网络服务的基本概念；确定要添加到请求中的正确头信息；解释常见的网络服务认证和授权方案；在JSON中创建和读取请求体；使用REST客户端进行手动API测试；以及使用Guzzle在PHP中编写`GET`和`POST`请求，然后处理结果。
- en: This chapter presents the basic concepts of web services and explains how to
    connect your application with them using Guzzle, a popular PHP open source library
    for making HTTP requests.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章介绍了网络服务的基本概念，并解释了如何使用 Guzzle（一个流行的PHP开源库，用于发送HTTP请求）将您的应用程序与它们连接。
- en: Introduction
  id: totrans-4
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简介
- en: In the previous chapter, we learned how to use PHP's package manager, Composer,
    to include third-party packages in your application. By doing so, you saw how
    to benefit from the open source solutions to problems that have already been solved
    and drastically reduce the amount of code you must produce and maintain in your
    own projects.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们学习了如何使用PHP的包管理器Composer将第三方包包含到您的应用程序中。通过这样做，您可以看到如何从已经解决的问题的开放源代码解决方案中受益，并极大地减少您必须在自己的项目中产生和维护的代码量。
- en: Web services are a technology that is enabling a lot of innovation in our industry.
    There are countless web services available on the internet, with some requiring
    a paid account to access their service and some freely available to the public
    as long as you don't surpass a rate limit. This is important because it means
    you don't have to own all the data you use in your app. You can leverage the data
    and systems others have built and then build on top of them, stringing them together
    to provide functionality that is unique to your application. PHP is a language
    built specifically for the web in the age of web APIs. By some, it has been called
    the "best glue" to piece together a collection of external services.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 网络服务是我们行业实现许多创新的技术。互联网上有无数的网络服务可供选择，其中一些需要付费账户才能访问其服务，而另一些则可以免费提供给公众，前提是你不超过速率限制。这一点很重要，因为它意味着你不需要拥有你应用中使用的所有数据。你可以利用他人构建的数据和系统，然后在它们之上构建，将它们串联起来，以提供你应用程序特有的功能。PHP是一种专为网络API时代而构建的用于网络的编程语言。有些人称它为“最佳粘合剂”，可以将一系列外部服务拼接在一起。
- en: In this chapter, we will present an overview of web services and show you some
    examples of interacting with them. If you are unfamiliar with what a web service
    is, the term is generally used to refer to an application service that is either
    publicly accessible or available within an intranet that can be programmatically
    interacted with to retrieve or alter data. In other words, a web service is a
    server or cluster of servers that is accessible via a network and that processes
    requests generated by computer processes as opposed to a user entering a URL into
    a browser. Some of the most well-known web services are public APIs exposed by
    social networks, such as Facebook or Twitter, which allow authorized applications
    to gain access to their user's data. An e-commerce application might use a FedEx
    web service for verification of the shipping address on an order before accepting
    it. Another basic example is a large database of movie data that allows clients
    to look up data related to a specific title, actor, or director.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将概述网络服务，并展示一些与它们交互的示例。如果您不熟悉什么是网络服务，这个术语通常用来指代一种应用程序服务，它要么是公开可访问的，要么是在内部网络中可编程交互的，可以用来检索或更改数据。换句话说，网络服务是一个或多个服务器，可以通过网络访问，并处理由计算机进程生成的请求，而不是用户在浏览器中输入URL。一些最著名的网络服务是社交网络公开的公共API，如Facebook或Twitter，允许授权的应用程序访问其用户的数据。一个电子商务应用程序可能会在接收订单之前使用FedEx网络服务来验证订单的送货地址。另一个基本示例是一个包含大量电影数据的数据库，允许客户查找与特定标题、演员或导演相关的数据。
- en: HTTP is the protocol used by these services in order to communicate. It is the
    same protocol a web browser uses to request a web page from a server. Making a
    request to a web service uses the same request/response cycle you learned about
    in *Chapter 6*, *Using HTTP*, and, in fact, you can make some requests directly
    from your browser.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: HTTP是这些服务用于通信的协议。它与网络浏览器用于从服务器请求网页的协议相同。向网络服务发出请求使用您在*第6章*，“使用HTTP”中了解到的相同的请求/响应周期，实际上，您可以直接从您的浏览器发出一些请求。
- en: An Example Web Service
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 一个示例网络服务
- en: 'As a quick example, we can use a site that we will be interacting with later
    in the chapter using PHP, but for now, let''s see what happens when you browse
    to [https://packt.live/33iQi0M](https://packt.live/33iQi0M). This is a simple
    web service that receives the request from the client, reads the public IP address
    of the network that the request is coming from, and sends a response containing
    that IP address back to the client in a format that computers and humans can both
    easily read. Here is a screenshot of what you would see in your browser; however,
    note that the IP address would be different because it is dependent on your actual
    location:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一个快速示例，我们可以使用我们在本章后面将要与之交互的网站，使用PHP，但就目前而言，让我们看看当你浏览到[https://packt.live/33iQi0M](https://packt.live/33iQi0M)时会发生什么。这是一个简单的网络服务，它接收来自客户端的请求，读取请求来自的网络公共IP地址，并以计算机和人类都容易阅读的格式将包含该IP地址的响应发送回客户端。以下是您在浏览器中看到的截图；然而，请注意，IP地址将不同，因为它取决于您的实际位置：
- en: '![Figure 10.1: Printing the IP address'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: '![图10.1：打印IP地址'
- en: '](img/C14196_10_01.jpg)'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/C14196_10_01.jpg)'
- en: 'Figure 10.1: Printing the IP address'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.1：打印IP地址
- en: This is a very simple service, but it illustrates the concepts we are trying
    to learn without the need for very complicated business logic. When you enter
    the preceding URL into your browser, you should see some curly braces, colons,
    and double quotes formatted around some text. The text should indicate the public
    IP address of the network your computer is on. Your browser makes an HTTP `GET`
    request to the server, then the server processes your request and returns a formatted
    response back to your browser. PHP has tools to make these requests programmatically
    and then parse the results so that they are usable by your applications.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个非常简单的服务，但它说明了我们试图学习的概念，而无需非常复杂的企业逻辑。当您将前面的URL输入到您的浏览器中时，您应该会看到一些文本周围格式化的花括号、冒号和双引号。文本应指示您的计算机所在的网络的公共IP地址。您的浏览器向服务器发出HTTP
    `GET`请求，然后服务器处理您的请求，并以格式化的响应返回给您的浏览器。PHP有工具可以编程地发出这些请求，然后解析结果，以便它们可以被您的应用程序使用。
- en: Selecting Third-Party APIs
  id: totrans-15
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 选择第三方API
- en: Sometimes, you will not have a choice of which web service to integrate your
    application with, either because it is the only service that provides the functionality
    you need or because some other constraint has limited your options. When this
    is not the case, it is useful to have a set of guidelines you can use to compare
    web services against each other to aid in your selection, for example, a business
    contract obligation. Some of the things you may want to consider (in no particular
    order) are documentation, stability, availability, and pricing.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候，您可能没有选择与哪个网络服务集成的选择，要么是因为它是唯一提供您所需功能的服务的服务，要么是因为某些其他约束限制了您的选择。当这种情况不是这样时，拥有一套您可以用来比较网络服务并帮助您选择的指南是有用的，例如，商业合同义务。您可能想要考虑的一些事情（不分先后顺序）是文档、稳定性、可用性和定价。
- en: If you've ever integrated with a third-party API before, you know the value
    of having clear, concise, and complete documentation to lead you through the process,
    as opposed to the difficulty of there being an absence of quality documentation.
    Without complete documentation, you will find yourself at the mercy of a support
    chain that may be slow to respond, if there is even support available at all.
    Be sure to read through the documentation of any API and understand it before
    committing it as a dependency for your application.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您之前曾经与第三方API集成过，您知道拥有清晰、简洁和完整的文档来引导您完成这个过程的价值，而不是没有高质量文档的困难。没有完整的文档，您可能会发现自己处于可能反应缓慢的支持链的
    mercy，如果甚至有支持的话。确保在将任何API作为应用程序的依赖项之前，阅读并理解其文档。
- en: The stability of the web service you choose is also another consideration to
    bear in mind. If you are paying for the service, you may be able to get a guarantee
    of uptime in a **service-level agreement** (**SLA**). This won't always be the
    case, and you might not have reliable data on the stability of a third-party system,
    but there are other things you can inquire about, such as how they handle system
    maintenance and rolling out new versions of the API.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 你选择网络服务的稳定性也是需要考虑的另一个因素。如果你为该服务付费，你可能会在**服务级别协议**（**SLA**）中获得对可用性的保证。这并不总是如此，你可能没有关于第三方系统稳定性的可靠数据，但你可以询问其他事情，例如他们如何处理系统维护和推出API的新版本。
- en: Availability has a number of different meanings in this context. In some cases,
    performance will be of utmost importance to your application. In those cases,
    if you depend on live calls to external systems, you will want to ensure the web
    service is available to respond to your requests in a timely fashion. A performant
    web service will return responses measured in microseconds rather than seconds.
    Another aspect of availability is that some web services may limit the number
    of requests you can make to their service in a given timeframe, for example, the
    number of requests Facebook accepts per hour. If this is the case, you will need
    to ensure that the web service will support the number of requests your application
    is likely to make during peak usage. Of course, if the data you are working with
    is cacheable, then that is always a preferable option.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个上下文中，“可用性”有几个不同的含义。在某些情况下，性能对你应用程序的重要性将是至关重要的。在这些情况下，如果你依赖于对外部系统的实时调用，你将希望确保网络服务能够及时响应你的请求。性能良好的网络服务将以微秒为单位返回响应，而不是秒。可用性的另一个方面是，一些网络服务可能会限制你在特定时间段内对其服务发起请求的数量，例如，Facebook每小时接受的请求数量。如果这种情况发生，你需要确保网络服务能够支持你的应用程序在高峰使用期间可能发起的请求数量。当然，如果你正在处理的数据是可缓存的，那么这始终是一个更可取的选择。
- en: Some web services are available to use free of charge or simply with the creation
    of an account, but some require paid access. Often, if there is a charge to use
    a web service, they will have a pricing model that uses a tiered structure, allowing
    a specified number of requests per billing period. If the price is too high for
    your business model to support, this may eliminate some services as options.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 一些网络服务可以免费使用，或者只需创建一个账户即可使用，但有些则需要付费访问。通常，如果使用网络服务需要付费，它们将有一个使用分层结构的定价模型，允许在账单周期内指定数量的请求。如果价格对于你的商业模式来说太高，这可能会消除一些服务作为选项。
- en: RESTful Concepts
  id: totrans-21
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: RESTful概念
- en: Many of the web services you see these days will identify themselves as RESTful
    web services. This is an important concept to know, both for interacting with
    these services and designing your own. **Representational State Transfer (REST)**
    is a style of developing an API, rather than a protocol such as HTTP or **Simple
    Object Access Protocol** (**SOAP**). It is a set of design constraints for architecting
    a web service and was first defined by Roy Fielding in his Ph.D. dissertation,
    Architectural Styles and the Design of Network-based Software Architectures.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 你现在看到的许多网络服务都会将自己标识为RESTful网络服务。这是一个重要的概念，无论是与这些服务交互还是设计你自己的服务。**表征状态转移（REST）**是一种API开发风格，而不是像HTTP或**简单对象访问协议（SOAP）**这样的协议。它是一组设计约束，用于构建网络服务，最初由Roy
    Fielding在他的博士论文《架构风格和网络软件架构设计》中定义。
- en: Rather than try to cover the full dissertation, we will to cover some of the
    important concepts you will need to know for interacting with RESTful services.
    The first is that they are stateless. This means that each request to the server
    happens in isolation. In other words, the server should not need any knowledge
    of previous requests by the client in order to process the current request. Each
    request should contain all the information necessary to process that request.
    This provides the benefits of simplicity, scalability, and flexibility in the
    API.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不会试图涵盖整个论文，而是会介绍一些你需要了解的重要概念，以便与RESTful服务交互。首先，它们是无状态的。这意味着每个对服务器的请求都是独立的。换句话说，服务器不应该需要了解客户端之前的请求来处理当前请求。每个请求都应该包含处理该请求所需的所有信息。这为API提供了简单性、可扩展性和灵活性的好处。
- en: The next concept is that RESTful APIs expose their functionality by representing
    resources through the URLs that are requested. Each URL represents a single resource
    or collection of resources, and the HTTP method (`GET`, `POST`, `PUT`, `PATCH`,
    or `DELETE`) you use to make the request determines whether you are retrieving
    the resource, creating it, updating it, or deleting it, respectively. The URL
    will be the same for all those operations; only the HTTP verb changes. The URL
    for a specific resource will also contain a unique identifier for that resource.
    Let's say there was a fictitious web service located at `acme.com/api` and one
    of the resources you can interact with through the API was called `products`.
    To retrieve a record with an identifier of `123`, you would make a `GET` request
    to `api.acme.com/products/123`. To update that record, you would make a `POST`
    request to `api.acme.com/products/123` with a `POST` body that would contain a
    representation of the product to be updated. Similar requests could also be made
    to create and delete records. The `api.acme.com/products` URL would give you a
    listing of products. The combination of URL and HTTP verb is known as `endpoint`,
    which a very common term in RESTful APIs literature.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个概念是RESTful API通过表示请求的URL来公开其功能。每个URL代表单个资源或资源集合，你用来发送请求的HTTP方法（`GET`、`POST`、`PUT`、`PATCH`或`DELETE`）决定了你是检索资源、创建资源、更新资源还是删除资源。对于所有这些操作，URL将是相同的；只有HTTP动词会改变。特定资源的URL还将包含该资源的唯一标识符。假设有一个虚构的位于`acme.com/api`的Web服务，你可以通过API与之交互的资源之一被称作`products`。要检索标识为`123`的记录，你需要向`api.acme.com/products/123`发送一个`GET`请求。要更新该记录，你需要向`api.acme.com/products/123`发送一个包含要更新产品表示的`POST`请求。类似的请求也可以用来创建和删除记录。`api.acme.com/products`
    URL将为你提供产品列表。URL和HTTP动词的组合被称为`endpoint`，这是RESTful API文献中的一个常用术语。
- en: 'As a consumer of these APIs, you will want to pay attention to the HTTP status
    codes to determine the success of your request. These are standardized codes that
    give information about the response from the server. These codes are divided into
    five groups: 1xx, 2xx, 3xx, 4xx, and 5xx. We have seen a definition of these in
    *Chapter 6*, *Using HTTP*. You can see the full list with explanations of what
    the values represent at [https://packt.live/2M2NfnH](https://packt.live/2M2NfnH).'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 作为这些API的消费者，你需要关注HTTP状态码以确定请求的成功与否。这些是标准化的代码，提供了关于服务器响应的信息。这些代码分为五组：1xx、2xx、3xx、4xx和5xx。我们已经在*第6章*，*使用HTTP*中看到了这些代码的定义。你可以在[https://packt.live/2M2NfnH](https://packt.live/2M2NfnH)上看到完整的列表及其值的解释。
- en: For a `GET` request to retrieve a resource, a status code of 200 represents
    success. A request to create a record would return a status code of 201\. If you
    request a resource that does not exist, you would expect to get back a status
    code of 404\. These are the most common status codes, and it's a good idea to
    be familiar with them.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 对于一个用于检索资源的`GET`请求，状态码200表示成功。创建记录的请求将返回状态码201。如果你请求一个不存在的资源，你预期会收到状态码404。这些是最常见的状态码，了解它们是个好主意。
- en: Another quality of RESTful APIs is that the responses should define whether
    or not they are cacheable, that is, whether they are fit to be stored on the client
    side for a period of time to avoid making a duplicate request. Some requests won't
    be cacheable, such as requests to update data, or resources that are updated frequently.
    For any request that is cacheable, it is likely to be in your best interest as
    a consumer of the API to cache it if you are going to request it frequently. This
    helps reduce the total number of external requests your application makes, which
    can increase your performance dramatically.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: RESTful API的另一个特点是响应应该定义它们是否可缓存，也就是说，它们是否适合在客户端存储一段时间以避免重复请求。某些请求可能不可缓存，例如更新数据的请求或频繁更新的资源。对于任何可缓存的请求，如果你打算频繁请求，作为API的消费者，缓存它可能对你最有利。这有助于减少你的应用程序发出的外部请求总数，这可以显著提高你的性能。
- en: The last concept you should be familiar with is known as **Hypermedia As The
    Engine Of Application State** (**HATEOAS**). This principle states that a client
    should be able to dynamically navigate through the application using hypermedia
    links contained in the response content.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该熟悉的最后一个概念被称为**超媒体作为应用状态引擎**（**HATEOAS**）。这个原则指出，客户端应该能够使用响应内容中包含的超媒体链接动态地导航应用程序。
- en: The simplest example of this is when responding to a PUT request to create a
    new resource; a hypermedia link to the resource (`acme.com/api/widgets/123`, in
    our earlier example) is returned as metadata in the response. While this is one
    of the architectural constraints that makes a web service fully REST compliant,
    many do not apply it due to the extra effort required to complete this stage.
    However, it is important to be aware of it as you may come across it in the future.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 最简单的例子是在响应 PUT 请求以创建新资源时；资源的一个超媒体链接（在我们的早期示例中为 `acme.com/api/widgets/123`）作为响应中的元数据返回。虽然这是使网络服务完全符合
    REST 架构约束之一，但由于完成此阶段需要额外的努力，许多人并没有应用它。然而，重要的是要意识到这一点，因为你可能在将来遇到它。
- en: Request Formats
  id: totrans-30
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 请求格式
- en: 'There are two main formats you will use to format the data you send to servers
    in your requests: XML and JSON. Both of these provide hierarchical structures
    for formatting data so that it may be easily read by both computers and humans.'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的请求中，你将使用两种主要格式来格式化发送给服务器的数据：XML 和 JSON。这两种格式都提供了层次结构来格式化数据，以便计算机和人类都能轻松读取。
- en: '`<` symbol and ending with the `>` symbol. The closing tag is signified with
    a backslash preceding the element name. A full example of an XML element with
    data inside would look like this: `<element>Some Data Here</element>`. These element
    tags can be nested as well, creating a nested hierarchy. For each level of nesting,
    the text is indented for readability.'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '`<` 符号和以 `>` 符号结束。关闭标签由在元素名称之前的前斜杠表示。一个包含数据的完整 XML 元素示例看起来像这样：`<element>Some
    Data Here</element>`。这些元素标签也可以嵌套，创建嵌套层次。对于每个嵌套级别，文本缩进以提高可读性。'
- en: 'Here is an example:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个例子：
- en: '[PRE0]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Each element can also have attributes, which are placed inside the opening
    tag, like so: `<element attribute="some value">`. This gives XML a lot of flexibility
    in modeling data structures, allowing for space to store metadata without affecting
    the rest of the structure. However, this is a trade-off, paying for the flexibility
    with complexity and verbosity. These downsides are part of the reason why much
    of the web community has begun shifting to a newer, more concise format named
    JSON.'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 每个元素也可以有属性，这些属性放置在打开标签内，如下所示：`<element attribute="some value">`。这使得 XML 在建模数据结构方面具有很大的灵活性，允许在不影响整个结构的情况下存储元数据。然而，这是一个权衡，以复杂性和冗长为代价来换取灵活性。这些缺点是网络社区开始转向名为
    JSON 的新、更简洁格式的原因之一。
- en: '**JSON** is an abbreviation of **JavaScript Simple Object Notation**. Despite
    having JavaScript as part of its name, JSON is a language-independent data format.
    JSON is independent now, but it was invented as a way to express Objects in JavaScript,
    and it was popularized as a data transfer support to avoid XML, which is heavier,
    and more expensive, to transfer through Internet. JSON uses curly braces to wrap
    data objects, double quotes to indicate properties and string values, and square
    brackets to wrap arrays. Commas separate items in a sequence, which can be properties
    or array items. Items are indented to keep things organized, just as in XML. This
    structure should give a sufficient visual representation:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: '**JSON** 是 **JavaScript Simple Object Notation** 的缩写。尽管其名称中包含 JavaScript，但
    JSON 是一种与语言无关的数据格式。JSON 现在是独立的，但它最初是为了在 JavaScript 中表达对象而发明的，并且它作为避免更重、更昂贵的 XML
    数据传输的数据传输支持而流行起来。JSON 使用花括号来包围数据对象，双引号来表示属性和字符串值，以及方括号来包围数组。逗号分隔序列中的项，这些项可以是属性或数组项。项缩进以保持整洁，就像在
    XML 中一样。这种结构应该给出足够的视觉表示：'
- en: '[PRE1]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: JSON is great because it's concise, which makes it fast over the wire. It also
    allows for easy conversion from objects to JSON strings and back to objects in
    memory. PHP offers two built-in functions that take care of these processes for
    you, `json_encode` and `json_decode`. With `json_encode`, you pass in the object
    that you want to transform into JSON and it will return it, while `json_decode`
    does the opposite. It's worth noting, if you are decoding JSON into objects, you
    will get objects of the generic `stdClass` type instead of the original type prior
    to encoding. JSON does miss out on the descriptiveness provided by XML, and therefore
    you may see metadata represented in the properties of the objects. However, in
    general, it is easier to read, easier to write, and less complex to interact with
    in code.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: JSON很棒，因为它简洁，这使得它在网络中传输速度快。它还允许在内存中将对象轻松转换为JSON字符串，然后再转换回对象。PHP提供了两个内置函数来处理这些过程，即`json_encode`和`json_decode`。使用`json_encode`时，你传入要转换为JSON的对象，它将返回该对象，而`json_decode`则执行相反的操作。值得注意的是，如果你将JSON解码到对象中，你将得到通用`stdClass`类型的对象，而不是编码前的原始类型。JSON确实失去了XML提供的描述性，因此你可能会在对象的属性中看到表示元数据的属性。然而，总的来说，它更容易阅读，更容易编写，并且在代码中交互起来更简单。
- en: 'Exercise 10.1: JSON Encoding'
  id: totrans-39
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习10.1：JSON编码
- en: 'In this exercise, we will prepare some data for a fictitious email marketing
    web service that allows you to add your data through their API so that you can
    send out emails through their platform to your mailing list. If it was a RESTful
    web service, it would likely accept a PUT request with a body in JSON format at
    an endpoint such as `/recipient`. The purpose of this exercise is to simply demonstrate
    translating PHP objects into JSON, and we will cover actually sending the requests
    later on in the chapter:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们将为一家虚构的电子邮件营销网络服务准备一些数据，该服务允许你通过他们的API添加数据，以便你可以通过他们的平台向你的邮件列表发送电子邮件。如果它是一个RESTful网络服务，它可能会在`/recipient`等端点接受带有JSON格式的请求体的PUT请求。这个练习的目的是简单地演示将PHP对象转换为JSON，我们将在本章后面部分介绍实际发送请求：
- en: 'Create a new folder for this example, `json-example`, and navigate to the folder
    through the Terminal, as follows:![Figure 10.2: Navigating to the desired folder'
  id: totrans-41
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为此示例创建一个新的文件夹`json-example`，并通过终端导航到该文件夹，如下所示：![图10.2：导航到目标文件夹]
- en: '](img/C14196_10_02.jpg)'
  id: totrans-42
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图片 C14196_10_02.jpg]'
- en: 'Figure 10.2: Navigating to the desired folder'
  id: totrans-43
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图10.2：导航到目标文件夹
- en: 'Create a `MailingListRecipient` class in a PHP file with the same name. Include
    public properties for `$email`, `$firstName`, and `$lastName`, which are passed
    in through the constructor:'
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在一个与同一名称的PHP文件中创建一个`MailingListRecipient`类。包含公共属性`$email`、`$firstName`和`$lastName`，这些属性通过构造函数传入：
- en: '[PRE2]'
  id: totrans-45
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Create a file called `json.php` that requires the `MailingListRecipient` class:'
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`json.php`的文件，该文件需要`MailingListRecipient`类：
- en: '[PRE3]'
  id: totrans-47
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Instantiate a new `MailingListRecipient` class:'
  id: totrans-48
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实例化一个新的`MailingListRecipient`类：
- en: '[PRE4]'
  id: totrans-49
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Encode the recipient variable as a JSON string and write it to the output:'
  id: totrans-50
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将接收者变量编码为JSON字符串并写入输出：
- en: '[PRE5]'
  id: totrans-51
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Run the script to see the string as JSON that is ready to be sent as a request
    body:'
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行脚本以查看作为请求体发送的JSON格式的字符串：
- en: '![Figure 10.3: Displaying the string as JSON'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '![图10.3：显示为JSON的字符串]'
- en: '](img/C14196_10_03.jpg)'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片 C14196_10_03.jpg]'
- en: 'Figure 10.3: Displaying the string as JSON'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.3：显示为JSON的字符串
- en: When you are integrating with a web service as the client, the body of your
    request will need to be formatted to match the content type specified in your
    headers in the request. Some web services support multiple request/response data
    formats, allowing you to request the format that suits you best, while others
    will require you to use a specific format.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 当你作为客户端与网络服务集成时，你的请求体需要格式化以匹配请求中头部指定的内容类型。一些网络服务支持多种请求/响应数据格式，允许你请求最适合你的格式，而其他服务将要求你使用特定的格式。
- en: HTTP Headers
  id: totrans-57
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: HTTP头部
- en: Every HTTP request and response is sent with a number of headers that facilitate
    communication between the client and server or provide meta-information about
    itself. Some headers will be automatically generated for you as part of the client
    making the request, such as `Host`, `User-Agent`, or `Content-Length`. It is important
    to be familiar with the extra headers you might want to include when making a
    request, as they can give you some control over the response you receive or the
    headers that might even be required for the request to be accepted.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 每个HTTP请求和响应都会发送多个头，这些头有助于客户端和服务器之间的通信，或提供关于自身的元信息。一些头将作为客户端发出请求的一部分自动为你生成，例如`Host`、`User-Agent`或`Content-Length`。了解你可能希望在发出请求时包含的额外头非常重要，因为它们可以让你对收到的响应或可能被要求用于请求被接受的头进行一些控制。
- en: The first of these is the `Accept` header. It allows you to specify a comma-separated
    list of content types expressed as a MIME type, such as `text/html` or `application/json`,
    which will be used to negotiate with the server to determine a mutual response
    body so that the client can correctly parse the request. The client may provide
    multiple content types it will accept, and the server will select one and specify
    which content type was used to format the response in the response headers. If
    the client is sending a POST request with a body, the `Content-Type` header should
    be provided to assist the server in parsing the data being sent. Most commonly,
    you will see this passed as `application/json` or `application/xml`.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 这些中的第一个是`Accept`头。它允许你指定一个以逗号分隔的内容类型列表，这些内容类型以MIME类型表示，例如`text/html`或`application/json`，这将用于与服务器协商，以确定一个共同的响应体，以便客户端可以正确解析请求。客户端可以提供多个它将接受的内容类型，服务器将选择一个，并在响应头中指定用于格式化响应的内容类型。如果客户端正在发送带有主体的POST请求，则应提供`Content-Type`头以帮助服务器解析发送的数据。最常见的情况是，你会看到它以`application/json`或`application/xml`的形式传递。
- en: The `Cache-Control` header in a server response will give information as to
    whether the response can be cached for later use by the client. This is typically
    only done for responses to GET requests but is nevertheless useful for decreasing
    the total number of requests made to a service if you are using data that is of
    a cacheable nature, thereby improving the performance of the application. If a
    response is cacheable, it will have a `max-age` header that specifies the number
    of seconds in which a request should be kept before it can be considered invalid
    and a new request generated.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 服务器响应中的`Cache-Control`头将提供信息，说明响应是否可以被缓存以供客户端稍后使用。这通常只用于对GET请求的响应，但如果你使用的是可缓存的数据，这仍然有助于减少对服务的总请求次数，从而提高应用程序的性能。如果响应可缓存，它将有一个`max-age`头，指定在请求被视为无效并生成新请求之前应该保持请求的秒数。
- en: If a request needs to be authenticated, the client may be required to pass an
    `Authorization` header. We cover authentication and authorization in the next
    section.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 如果请求需要认证，客户端可能需要传递一个`Authorization`头。我们将在下一节中介绍认证和授权。
- en: Authentication and Authorization
  id: totrans-62
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 认证和授权
- en: As a good security practice, web servers are designed to verify the user's identity
    and authenticate that the requested resource is accessible to the user. It is
    important to recognize the distinction between these two terms. Authentication
    is the process of validating that the user is who they say they are. This may
    be done as simply as checking a password or API key against one stored on the
    user's account, or it may be as complex as hashing values that contain a "secret"
    value known only by the client and the server. It has become common practice these
    days to have a separate authentication server to handle this duty, and by doing
    so taking that responsibility off the application server and handling it in a
    centralized manner.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 作为良好的安全实践，Web服务器被设计用来验证用户的身份，并认证请求的资源是否对用户可访问。认识到这两个术语之间的区别很重要。认证是验证用户是否是他们所说的那个人的过程。这可能像检查密码或API密钥与用户账户上存储的密码或API密钥进行比对那样简单，也可能像对包含只有客户端和服务器知道的“秘密”值的哈希值进行比对那样复杂。如今，拥有一个单独的认证服务器来处理这项任务已成为常见做法，这样做可以将责任从应用服务器中移除，并以集中化的方式处理。
- en: Authorization is the process of verifying that an authenticated user has access
    to the resource they are requesting, whether it's viewing data or altering it.
    For example, if a service has basic-level access provided to anyone with a free
    account, but also provides a member subscription service where only certain endpoints
    are available to paying members, it would need to verify the authenticated user
    has permission to protected resources when they are requested. Another use case
    for authorization would be when users are only given access to resources they
    have created themselves, or can read any created resources, but can only edit
    their own.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 授权是验证已认证用户是否有权访问他们请求的资源的过程，无论是查看数据还是修改数据。例如，如果一个服务向任何拥有免费账户的人提供基本级别的访问权限，但同时也提供会员订阅服务，其中只有某些端点对付费会员可用，那么它需要在请求受保护资源时验证已认证用户是否有权限。授权的另一个用例是当用户只能访问他们自己创建的资源，或者可以读取任何创建的资源，但只能编辑他们自己的资源。
- en: We will take a moment to give a brief overview of some of the common authentication
    and authorization schemes you may run into. The first is open authentication,
    meaning the web service does not verify the user's identity. This is not very
    common, because it is not very secure. Still, there are some cases where it is
    acceptable, such as some of the example services that we will make use of later
    in the chapter.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将花一点时间简要概述一些你可能遇到的常见身份验证和授权方案。第一个是开放身份验证，意味着该网络服务不验证用户的身份。这并不常见，因为它不够安全。尽管如此，还有一些情况下它是可以接受的，例如我们将在本章后面使用的一些示例服务。
- en: Next is authentication by API key, where a user has created an account with
    the web service and requested a key that will be included as part of each request.
    This functions in a similar way to a username and password login process on a
    website, where you provide an account ID and API key, and the web service verifies
    the API key belongs to your account before processing your request. This is significantly
    more secure than open authentication, and most of the public web services you
    interface with will use this method.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来是API密钥认证，用户在网络上创建了一个账户并请求一个密钥，该密钥将作为每个请求的一部分。这类似于网站上的用户名和密码登录过程，你提供账户ID和API密钥，网络服务在处理你的请求之前会验证API密钥是否属于你的账户。这比开放身份验证安全得多，并且你与之交互的大多数公共网络服务都会使用这种方法。
- en: Finally, there is the combination of Open ID Connect for authentication and
    OAuth 2.0 for access authorization. These are separate protocols that work together
    to provide a complete access control solution. Open ID Connect was built on top
    of OAuth 2.0 to shore up the security holes that were left by services using only
    OAuth 2.0 as a pseudo-authentication mechanism. In short, the client authenticates
    through an Open ID server, which may be a well-known internet company such as
    Google, Facebook, Microsoft, or Twitter, or it may be a company's internal authorization
    provider. After authenticating, a token is provided back to the application, which
    can then use it to make a request to the resource server. If we do end up integrating
    with one of these services, we can use the PHP league's Composer package for OAuth,
    which can be found on GitHub at [https://packt.live/35s7tiv](https://packt.live/35s7tiv).
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，是开放ID连接用于身份验证和OAuth 2.0用于访问授权的组合。这些是协同工作的独立协议，提供完整的访问控制解决方案。开放ID连接建立在OAuth
    2.0之上，以填补仅使用OAuth 2.0作为伪身份验证机制的服务留下的安全漏洞。简而言之，客户端通过开放ID服务器进行身份验证，该服务器可能是一家知名互联网公司，如谷歌、Facebook、微软或Twitter，也可能是一家公司的内部授权提供商。身份验证后，会向应用程序提供一个令牌，应用程序可以使用它向资源服务器发出请求。如果我们最终与这些服务之一集成，我们可以使用GitHub上的PHP
    league的Composer包进行OAuth，该包可以在[https://packt.live/35s7tiv](https://packt.live/35s7tiv)找到。
- en: Manual API Testing
  id: totrans-68
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 手动API测试
- en: Sometimes, while you are integrating with a new web service, you will need to
    go through a process of trial and error to get your requests formatted in such
    a way that the service will accept it. In these cases, it can be hugely beneficial
    to have a client that will allow you to manually construct requests, send them
    to the service from the client, and display the response, allowing you to eliminate
    your own code from being the source of the problem. Once you get a successful
    response, you can recreate the request correctly in code. Sometimes, this is a
    necessary step in troubleshooting and, at the very least, it can save you lots
    of frustration when trying to debug the code. I'll describe a few of the options
    available to you in the next few paragraphs.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候，当你与新的网络服务集成时，你可能需要经历一个试错的过程，以使你的请求格式正确，以便服务能够接受它。在这些情况下，拥有一个允许你手动构造请求、从客户端发送到服务并显示响应的客户端将非常有帮助，这样你可以排除自己的代码是问题的来源。一旦你得到成功的响应，你就可以在代码中正确地重新创建请求。有时候，这是故障排除的必要步骤，至少在尝试调试代码时，它可以节省你大量的挫败感。在接下来的几段中，我将描述一些你可以选择的选项。
- en: If you prefer to have a client directly in your IDE to reduce the number of
    applications you have open during development, some have a REST client directly
    integrated into them. Jet Brains' PHPStorm IDE has an integrated client that,
    in many ways, works similarly to Insomnia. PHPStorm is a great IDE filled with
    countless beneficial features that speed up development, but it is a licensed
    software product and requires a subscription. If you have the means, it is definitely
    worth the cost.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你更喜欢在IDE中直接拥有客户端以减少开发过程中打开的应用程序数量，一些IDE直接集成了REST客户端。JetBrains的PHPStorm IDE就集成了这样的客户端，它在很多方面与Insomnia类似。PHPStorm是一个功能强大的IDE，拥有无数有益的特性，可以加快开发速度，但它是一个授权的软件产品，需要订阅。如果你有这个条件，它绝对物有所值。
- en: If you are just sending GET requests, these clients may seem like overkill,
    but if you are sending a POST request with a body or need to send custom headers
    for authentication, clients like these might be your only option to manually test
    the web service. If you are going to be integrating with web services, it's well
    worth it to set up one of these clients.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你只是发送GET请求，这些客户端可能看起来有些过度，但如果你需要发送带有主体的POST请求或需要发送用于身份验证的自定义头，这些客户端可能是你手动测试网络服务的唯一选择。如果你将要与网络服务集成，设置其中一个这样的客户端是非常值得的。
- en: The client we will use here for manual web service testing is called Insomnia,
    and can be found at [https://packt.live/2VuRco8](https://packt.live/2VuRco8).
    It is a thick client that you'll have to install to use, but it has a nice intuitive
    interface that makes it simple to compose requests of all types and easily see
    the results.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里用于手动网络服务测试的客户端称为Insomnia，可以在[https://packt.live/2VuRco8](https://packt.live/2VuRco8)找到。这是一个需要安装才能使用的厚客户端，但它有一个直观的界面，使得编写各种类型的请求和查看结果变得简单。
- en: 'Exercise 10.2: Manual API Testing with Insomnia'
  id: totrans-73
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习10.2：使用Insomnia进行手动API测试
- en: 'In this exercise, we will demonstrate using Insomnia to manually make a web
    service request to the `ipify` endpoint that we called through the browser at
    the beginning of this chapter. The benefit of using a client like this as opposed
    to a browser is that you can set request headers or form data that you would not
    be able to set from a browser:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们将演示如何使用Insomnia手动向我们在本章开头通过浏览器调用的`ipify`端点发送网络服务请求。与浏览器相比，使用此类客户端的好处是你可以设置请求头或表单数据，而这些在浏览器中是无法设置的：
- en: 'Open Insomnia and click on the `New Request` button. Then, enter `Ipify` as
    the request name:![Figure 10.4: The Insomnia interface'
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开Insomnia并点击“新建请求”按钮。然后，将请求名称输入为“Ipify”：![图10.4：Insomnia界面
- en: '](img/C14196_10_04.jpg)'
  id: totrans-76
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/C14196_10_04.jpg)'
- en: 'Figure 10.4: The Insomnia interface'
  id: totrans-77
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图10.4：Insomnia界面
- en: 'Ensure that the request method is set to `GET`:![Figure 10.5: Checking the
    request method'
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保请求方法设置为“GET”：![图10.5：检查请求方法
- en: '](img/C14196_10_05.jpg)'
  id: totrans-79
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/C14196_10_05.jpg)'
- en: 'Figure 10.5: Checking the request method'
  id: totrans-80
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图10.5：检查请求方法
- en: 'Enter [https://packt.live/2oyJqxB](https://packt.live/2oyJqxB) in the URL bar:![Figure
    10.6: Adding the URL'
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在网址栏中输入[https://packt.live/2oyJqxB](https://packt.live/2oyJqxB)：![图10.6：添加网址
- en: '](img/C14196_10_06.jpg)'
  id: totrans-82
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/C14196_10_06.jpg)'
- en: 'Figure 10.6: Adding the URL'
  id: totrans-83
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图10.6：添加网址
- en: 'Open the `Query` tab and enter `format` into the first new name field and `json`
    into the first new value field:![Figure 10.7: Adding data in the Query tab'
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 `查询` 选项卡，在第一个新名称字段中输入 `format`，在第一个新值字段中输入 `json`：![图10.7：在查询选项卡中添加数据
- en: '](img/C14196_10_07.jpg)'
  id: totrans-85
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/C14196_10_07.jpg)'
- en: 'Figure 10.7: Adding data in the Query tab'
  id: totrans-86
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图10.7：在查询选项卡中添加数据
- en: 'Click on the `Send` button at the end of the URL bar:![Figure 10.8: Sending
    the URL'
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击URL栏末尾的 `发送` 按钮：![图10.8：发送URL
- en: '](img/C14196_10_08.jpg)'
  id: totrans-88
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/C14196_10_08.jpg)'
- en: 'Figure 10.8: Sending the URL'
  id: totrans-89
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图10.8：发送URL
- en: 'You will see a `Preview` section displaying the JSON response:'
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你将看到一个显示JSON响应的 `预览` 部分：
- en: '![Figure 10.9: JSON response'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '![图10.9：JSON响应'
- en: '](img/C14196_10_09.jpg)'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/C14196_10_09.jpg)'
- en: 'Figure 10.9: JSON response'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.9：JSON响应
- en: Making a Request with PHP
  id: totrans-94
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用PHP发送请求
- en: Now that we've got all that theory out of the way, we get to cover actually
    making a request in PHP. There are several approaches you can use to make requests
    in the language, and ultimately all of them end up using the cURL extension to
    make the request. If you had a simple GET request to make, then you could use
    the built-in `file_get_contents` function. You could use the cURL functions to
    interact with the cURL extension directly, which are well documented at [https://packt.live/2olkmKv](https://packt.live/2olkmKv);
    however, this can be tedious and is lacking a level of abstraction that can be
    provided by an object-oriented approach. For this, there is a package provided
    by Composer called `guzzlehttp/guzzle`. Guzzle is actually the official implementation
    of the PSR-7 standard for an HTTP message interface and is widely used.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经讲完了所有理论，接下来我们将介绍如何在PHP中实际发送请求。你可以使用几种方法在语言中发送请求，最终它们都会使用cURL扩展来发送请求。如果你有一个简单的GET请求要发送，那么你可以使用内置的
    `file_get_contents` 函数。你可以使用cURL函数直接与cURL扩展交互，这些函数在 [https://packt.live/2olkmKv](https://packt.live/2olkmKv)
    上有很好的文档；然而，这可能很繁琐，并且缺乏面向对象方法可以提供的抽象级别。为此，Composer提供了一个名为 `guzzlehttp/guzzle` 的包。实际上，Guzzle是PSR-7标准HTTP消息接口的官方实现，并且被广泛使用。
- en: 'Exercise 10.3: Making a GET Request with Guzzle'
  id: totrans-96
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习10.3：使用Guzzle发送GET请求
- en: 'In this exercise, we will go over the process of instantiating a Guzzle client,
    configuring the request, and calling the method to send a `GET` request:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们将回顾实例化一个 Guzzle 客户端、配置请求以及调用方法发送 `GET` 请求的过程：
- en: 'First, create a new project for this chapter in the directory where you keep
    your code and change into that directory:'
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，在你的代码存储目录中为这一章创建一个新的项目，并切换到该目录：
- en: '[PRE6]'
  id: totrans-99
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Initialize a new Composer project (refer to *Chapter 9*, *Composer*, if you
    need help) and then install Guzzle:'
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 初始化一个新的 Composer 项目（如需帮助，请参阅 *第9章*，*Composer*），然后安装 Guzzle：
- en: '[PRE7]'
  id: totrans-101
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Create a PHP script named `ipify.php` and require the Composer autoload file:'
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `ipify.php` 的PHP脚本，并包含Composer自动加载文件：
- en: '[PRE8]'
  id: totrans-103
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Reference the `GuzzleHttp\Client` class with the `use` statement, and then
    instantiate a new `Client` object, passing in the base URL of the `ipify` web
    service:'
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `use` 语句引用 `GuzzleHttp\Client` 类，然后创建一个新的 `Client` 对象，传入 `ipify` 网服务的基准URL：
- en: '[PRE9]'
  id: totrans-105
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Make an HTTP `GET` request to the root of the web service, passing in a format
    query parameter with a value of `json`, and store it in a `$response` variable:'
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 向网络服务的根发送一个带有值为 `json` 的格式查询参数的HTTP `GET` 请求，并将其存储在 `$response` 变量中：
- en: '[PRE10]'
  id: totrans-107
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Extract the body of the response, which is a JSON string, using the `getBody()`
    and `getContents()` methods, pass the string through the `json_decode()` function
    to parse it into an object, and then store it in a `$responseObject` variable:'
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `getBody()` 和 `getContents()` 方法提取响应体，这是一个JSON字符串，通过 `json_decode()` 函数将其解析为对象，并将其存储在
    `$responseObject` 变量中：
- en: '[PRE11]'
  id: totrans-109
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Echo a string to print out the `ip` property of the response object:'
  id: totrans-110
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 输出一个字符串以打印出响应对象的 `ip` 属性：
- en: '[PRE12]'
  id: totrans-111
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Run the script from the command line. You should see output similar to the
    following screenshot:'
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在命令行中运行脚本。你应该会看到类似于以下截图的输出：
- en: '![Figure 10.10: Printing the IP address'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: '![图10.10：打印IP地址'
- en: '](img/C14196_10_10.jpg)'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/C14196_10_10.jpg)'
- en: 'Figure 10.10: Printing the IP address'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.10：打印IP地址
- en: Let me walk through the example code line by line to explain what it is doing.
    First, we are including the Composer autoload file so that all of our dependencies
    are automatically included as we covered in the previous chapter. Then, we add
    a `use` statement so that we don't have to refer to the full path of `GuzzleHttp\Client`
    every time we want to reference it. Then, we instantiate an instance of the `Guzzle`
    client, setting our target web service base URL in the `options` array passed
    into the constructor. Next, we call the request method on the `Guzzle` client.
    This accepts the HTTP method as the first parameter, which, in this case, is a
    `GET` request. The second parameter is the relative URI of the resource we are
    trying to access, which, in this case, is just the root, so we just enter a backslash.
    The final parameter is an array of options, which we populate with an associative
    array that tells the web service we would like the body of the response to be
    formatted in JSON.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 让我逐行解释示例代码的功能。首先，我们包含Composer的自动加载文件，这样我们所有的依赖项都会像我们在上一章中介绍的那样自动包含。然后，我们添加一个`use`语句，这样我们就不必每次引用`GuzzleHttp\Client`时都使用完整路径。接着，我们实例化一个`Guzzle`客户端实例，在构造函数中传入的`options`数组中设置我们的目标Web服务基本URL。接下来，我们在`Guzzle`客户端上调用请求方法。这个方法接受HTTP方法作为第一个参数，在这个例子中是一个`GET`请求。第二个参数是我们试图访问的资源的相关URI，在这个例子中只是根，所以我们只输入一个反斜杠。最后一个参数是一个选项数组，我们用关联数组填充它，告诉Web服务我们希望响应体以JSON格式进行格式化。
- en: After we have our response, we call the methods provided by `Guzzle` in a chain
    to get the body object, and then to get the contents of the response as a string,
    which will be JSON formatted text in this example. To be able to access the data
    in the response, we pass it through `json_decode` to turn it into a generic `stdClass`
    object that allows us to access the properties. Finally, we echo out a string
    to the output using string interpolation to inject the `ip` address returned by
    the service into our message.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们得到响应后，我们调用`Guzzle`提供的方法，以链式方式获取主体对象，然后获取响应的内容作为字符串，在这个例子中将是JSON格式的文本。为了能够访问响应中的数据，我们通过`json_decode`将其转换为通用的`stdClass`对象，这样我们就可以访问属性。最后，我们使用字符串插值将服务返回的`ip`地址注入到我们的消息中输出。
- en: Note
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: It is possible to decode JSON string into an array instead of an object.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 将JSON字符串解码成数组而不是对象是可能的。
- en: Sending a `GET` request is useful, and many of the requests you write will use
    this method, but we should also cover sending a `POST` request, where you will
    have to provide some data to the web service to be processed. We have found another
    simple free web service that will allow us to make such a request, and you also
    might find it useful. It is a service that allows you to pass an email address
    and some options in a JSON string in the body of your request and it returns a
    `SpamAssassin` score for that email address. We will also demonstrate setting
    `Accept` and `Content-Type` headers in the request to tell the web service how
    to parse our request body and what format we will accept the response in. It is
    important to check your API calls for error conditions, and we will show some
    examples of this as well.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 发送`GET`请求是有用的，你写的许多请求都将使用此方法，但我们也应该介绍发送`POST`请求，在这种情况下，你必须向Web服务提供一些要处理的数据。我们发现另一个简单的免费Web服务可以让我们进行此类请求，你也可能觉得它很有用。这是一个允许你在请求体中传递一个电子邮件地址和一些选项的JSON字符串的服务，并返回该电子邮件地址的`SpamAssassin`评分。我们还将演示在请求中设置`Accept`和`Content-Type`头，以告诉Web服务如何解析我们的请求体以及我们希望以什么格式接收响应。检查你的API调用以查找错误条件非常重要，我们也将展示一些这方面的例子。
- en: 'Exercise 10.4: Sending a POST Request with Headers'
  id: totrans-121
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习10.4：带有头的POST请求
- en: 'This exercise will be similar to the previous one, with the main difference
    being that we will be using the `POST` method to send data in the body of the
    request. This time, the service we are calling is one that accepts an email address
    and returns the `SpamAssassin` score for that email. `SpamAssassin` is an open
    source project by the Apache Software Foundation that helps system administrators
    filter emails from sources that send unsolicited bulk emails:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 这个练习将与上一个类似，主要区别在于我们将使用`POST`方法在请求体中发送数据。这次，我们调用的服务是接受一个电子邮件地址并返回该电子邮件的`SpamAssassin`评分的服务。`SpamAssassin`是由Apache软件基金会发起的一个开源项目，帮助系统管理员从发送未经请求的大量邮件的来源过滤电子邮件：
- en: 'Create a `spamcheck.php` script in the same folder as the previous chapter.
    Require the Composer autoload file, add a statement to use the `Guzzle` `Client`
    class, and define a variable with any email address as a string:'
  id: totrans-123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在与上一章相同的文件夹中创建一个 `spamcheck.php` 脚本。引入 Composer 自动加载文件，添加一个使用 `Guzzle` `Client`
    类的语句，并定义一个包含任何电子邮件地址的字符串变量：
- en: '[PRE13]'
  id: totrans-124
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Instantiate the `Guzzle` `Client` object, passing the URL of the service in
    the constructor:'
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实例化 `Guzzle` `Client` 对象，在构造函数中传入服务的 URL：
- en: '[PRE14]'
  id: totrans-126
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Create an array for the body of our request with the first item being the email
    variable and having a key of `email` and the second item being the string `short`
    with a key of `options`. Then, transform it into a JSON string using the `json_encode()`
    function and store it in a `$requestBody` variable:'
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为我们的请求体创建一个数组，第一个元素是电子邮件变量，键为 `email`，第二个元素是字符串 `short`，键为 `options`。然后，使用 `json_encode()`
    函数将其转换为 JSON 字符串，并存储在 `$requestBody` 变量中：
- en: '[PRE15]'
  id: totrans-128
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Open a `try`…`catch` block and, inside it, make a `POST` request to the `/filter`
    endpoint. The `Accept` and `Content-Type` headers are included in the `options`
    array as well as our request body:'
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开一个 `try`…`catch` 块，并在其中向 `/filter` 端点发起 `POST` 请求。`Accept` 和 `Content-Type`
    头部信息包含在 `options` 数组中，以及我们的请求体：
- en: '[PRE16]'
  id: totrans-130
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Check the HTTP status code of the response and, if it is not `200` (that is,
    successful), throw an exception:'
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 检查响应的 HTTP 状态码，如果不是 `200`（即成功），则抛出异常：
- en: '[PRE17]'
  id: totrans-132
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Parse the JSON string response into an object and store it in a variable:'
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 JSON 字符串响应解析为对象并存储在变量中：
- en: '[PRE18]'
  id: totrans-134
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'If the `success` property is not set to true on the `response` object, throw
    an exception:'
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果 `response` 对象上的 `success` 属性未设置为 `true`，则抛出异常：
- en: '[PRE19]'
  id: totrans-136
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Output a string that states the `SpamAssassin` score for the email:'
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 输出一个字符串，表示电子邮件的 `SpamAssassin` 分数：
- en: '[PRE20]'
  id: totrans-138
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Catch any exceptions that may have been thrown and output the message:'
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 捕获可能抛出的任何异常并输出消息：
- en: '[PRE21]'
  id: totrans-140
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Run the script and see the output:'
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行脚本并查看输出：
- en: '![Figure 10.11: The final output'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 10.11：最终输出'
- en: '](img/C14196_10_11.jpg)'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 10.11：最终输出](img/C14196_10_11.jpg)'
- en: 'Figure 10.11: The final output'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.11：最终输出
- en: This example is similar to the last one in many ways, with a few exceptions.
    First, we create a JSON string for the body of the request using `json_encode`
    to transform an associative array and store it in the `$json` variable. When we
    make the web service call using the request method, we pass `POST` as the HTTP
    method, and this time the relative path is `/filter`, making the full requested
    URL [https://packt.live/3269n6i](https://packt.live/3269n6i). In the `options`
    array, we include a headers array containing key-value pairs for the headers we
    want to include in our request.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子在许多方面与上一个例子相似，但有几点例外。首先，我们使用 `json_encode` 将关联数组转换为 JSON 字符串，并将其存储在 `$json`
    变量中。当我们使用请求方法调用网络服务时，我们传递 `POST` 作为 HTTP 方法，这次相对路径是 `/filter`，因此完整的请求 URL 为 [https://packt.live/3269n6i](https://packt.live/3269n6i)。在
    `options` 数组中，我们包括一个包含我们想要包含在请求中的头部键值对的头部数组。
- en: The `Content-Type` header tells the web service that our body is formatted as
    JSON, and the `Accept` header tells the service we are expecting the format of
    the response to be JSON. If you needed to include other headers in your request,
    you could do this by adding them to the array. The `$json` variable containing
    our JSON string for the payload of our request is passed in the `body` parameter.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: '`Content-Type` 头部告诉网络服务我们的请求体格式为 JSON，而 `Accept` 头部告诉服务我们期望响应格式为 JSON。如果您需要在请求中包含其他头部，可以通过将它们添加到数组中来实现。包含我们请求有效载荷的
    JSON 字符串的 `$json` 变量通过 `body` 参数传递。'
- en: This time, before we get the content out of the response, we check to make sure
    we have a valid response. In most cases, the easiest way to do this is to look
    at the HTTP status code. Successful responses will be in the 2xx range. Most of
    the time, you will be able to look for 200 or 201, depending on which HTTP method
    you are using. After decoding the response, we check to make sure the `success`
    property is set to true. This is another layer telling us the request was processed
    correctly. Not all web services will provide this layer in the same way, but it
    is fairly common to include some indicator in the body of the response. If we
    find a condition indicating the request was not successful, we throw an exception
    with a message clearly indicating what failed, and handle it in the `catch` clause,
    passing the message onto the user.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 这次，在我们从响应中获取内容之前，我们检查以确保我们有一个有效的响应。在大多数情况下，最简单的方法是查看HTTP状态码。成功的响应将在2xx范围内。大多数时候，你可以寻找200或201，这取决于你使用的HTTP方法。在解码响应后，我们检查以确保`success`属性设置为true。这是另一个告诉我们请求已正确处理的层次。并非所有网络服务都会以相同的方式提供这一层，但在响应体中包含一些指示器是相当常见的。如果我们发现表示请求未成功的条件，我们将抛出一个异常，并清楚地说明失败的原因，然后在`catch`子句中处理它，将消息传递给用户。
- en: 'Activity 10.1: Making Your Own POST Request to httpbin.org'
  id: totrans-148
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 活动10.1：向httpbin.org发送自己的POST请求
- en: Now it's time to practice making a request on your own. To do this, you will
    use a different service located at [https://packt.live/2oyJqxB](https://packt.live/2oyJqxB).
    `Httpbin` is an open web service that will read requests you make to it and respond
    with various data in the response body, based on the API endpoint you request.
    The `/response-headers` endpoint will read the query string parameters you pass
    in the request and include them as properties in a JSON object response.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候自己练习发送请求了。为此，你将使用位于[https://packt.live/2oyJqxB](https://packt.live/2oyJqxB)的不同服务。`Httpbin`是一个公开的网络服务，它将读取你对其发送的请求，并根据你请求的API端点在响应体中返回各种数据。`/response-headers`端点将读取你请求中传递的查询字符串参数，并将它们作为JSON对象响应中的属性包含在内。
- en: Write your own script that will make a request to [https://packt.live/2OE94LV](https://packt.live/2OE94LV).
    Include two query parameters in the request, one with a key of `first` property
    passing `John` as the value, and another for `last` property with `Doe` as the
    value. Be sure to set the `Accept` header to `application/json`. Check the response
    for a status code of 200 and throw an exception if it does not match that. Decode
    the response from JSON and echo the values for the first and last properties in
    the decoded object in a string to output.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 编写自己的脚本，向[https://packt.live/2OE94LV](https://packt.live/2OE94LV)发送请求。请求中包含两个查询参数，一个以`first`属性为键，值为`John`，另一个以`last`属性为键，值为`Doe`。务必将`Accept`头设置为`application/json`。检查响应的状态码是否为200，如果不匹配则抛出异常。将响应从JSON解码，并在字符串中输出解码对象中`first`和`last`属性的值。
- en: 'The output should look like this:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 输出应如下所示：
- en: '![Figure 10.12: The expected output'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: '![图10.12：预期的输出'
- en: '](img/C14196_10_12.jpg)'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/C14196_10_12.jpg)'
- en: 'Figure 10.12: The expected output'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.12：预期的输出
- en: 'The following steps will help you to complete the activity:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 以下步骤将帮助您完成活动：
- en: Create a `httpbin.php` file in the `guzzle-example` directory. Require the Composer
    autoload file and import the `Guzzle Client` class.
  id: totrans-156
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`guzzle-example`目录中创建一个`httpbin.php`文件。需要引入Composer自动加载文件并导入`Guzzle客户端`类。
- en: Instantiate a new `Guzzle Client` by passing the `httpbin` address.
  id: totrans-157
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过传递`httpbin`地址实例化一个新的`Guzzle客户端`。
- en: Inside a `try`…`catch` block, make a `POST` request to the `/response-headers`
    endpoint. Add an `Accept` header set to `application/json` and set two query parameter
    key-value pairs, with `first` as `John` and `last` as `Doe`.
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`try`…`catch`块中，向`/response-headers`端点发送`POST`请求。添加一个设置为`application/json`的`Accept`头，并设置两个查询参数键值对，其中`first`为`John`，`last`为`Doe`。
- en: Check whether the HTTP status code is not 200, and if so, throw an exception.
  id: totrans-159
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 检查HTTP状态码是否不是200，如果是，则抛出异常。
- en: Parse the response body into an object using `json_decode()` and store it in
    a variable.
  id: totrans-160
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`json_decode()`将响应体解析为对象并存储在变量中。
- en: Output a string, `The web service responded with`, concatenated with the first
    and last properties from the response object.
  id: totrans-161
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 输出一个字符串，`The web service responded with`，与响应对象中的第一个和最后一个属性连接。
- en: Run the script and see whether the output contains `John Doe`.
  id: totrans-162
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行脚本并查看输出是否包含`John Doe`。
- en: Note
  id: totrans-163
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意
- en: The solution for this activity can be found on page 560.
  id: totrans-164
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 本活动的解决方案可在第560页找到。
- en: Summary
  id: totrans-165
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: Web services are one of the most important concepts in modern-day computing,
    enabling many of the rich internet applications we use today. In this chapter,
    we have discussed some of the criteria you would want to use while evaluating
    web services to use in your application, such as documentation, availability,
    and pricing. We briefly covered the concepts of a RESTful web service, which are
    stateless services that expose an interface to interact with resources through
    the HTTP verbs. We covered the JSON and XML formats, which are hierarchical structures
    used to transfer data in the body of requests, among other uses.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 网络服务是现代计算中最重要的概念之一，使我们能够使用许多丰富的互联网应用。在本章中，我们讨论了在评估用于你应用程序的网络服务时你可能想要使用的某些标准，例如文档、可用性和定价。我们简要介绍了RESTful网络服务的概念，这些是无状态服务，通过HTTP动词公开接口以与资源交互。我们还涵盖了JSON和XML格式，这些是用于在请求主体中传输数据以及其它用途的分层结构。
- en: HTTP requests are made up of a body and a number of headers, some required,
    some optional, and others that contain metadata about a request and negotiate
    the content type. We went over the authentication methods commonly utilized by
    web service providers, including API keys and Open ID Connect combined with OAuth
    2.0 for authorization. A REST client is a useful tool to have in your toolbox
    to manually test API endpoints as you are working to integrate with them. Guzzle
    is an abstraction layer for making HTTP requests in PHP, available via the Composer
    package manager, that provides a clean and simple interface.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: HTTP请求由一个主体和多个头部组成，其中一些是必需的，一些是可选的，还有一些包含关于请求的元数据并协商内容类型。我们讨论了网络服务提供商通常使用的认证方法，包括API密钥和与OAuth
    2.0结合的Open ID Connect进行授权。REST客户端是在你与它们集成时手动测试API端点的一个有用工具。Guzzle是PHP中制作HTTP请求的抽象层，通过Composer包管理器提供，它提供了一个干净且简单的接口。
