- en: Entities
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We've talked about the benefits of trying to first model everything in the Domain
    as a Value Object. But when modeling the Domain, there will probably be situations
    where you'll find that some concept in the Ubiquitous Language demands a thread
    of Identity.
  prefs: []
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Clear examples of objects requiring an Identity include:'
  prefs: []
  type: TYPE_NORMAL
- en: A **person**. A person always has an Identity and it's always the same in terms
    of their name or identification card.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An **order** in an e-commerce system. In such a context, every new order created
    has its own Identity and it's the same over time.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'These concepts have an Identity that endures over time. No matter how many
    times data in the concepts changes, their Identities remain the same. That''s
    what makes them Entities and not Value Objects. In terms of PHP implementation,
    they would be plain old classes. For example, consider the following in the case
    of a person:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Or, consider the following in the case of an order:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Objects Vs. Primitive Types
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Most of the time, the Identity of an Entity is represented as a primitive type
    — usually a string or an integer. But using a Value Object to represent it has
    more advantages:'
  prefs: []
  type: TYPE_NORMAL
- en: Value Objects are immutable, so they can't be modified.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Value Objects are complex types that can have custom behaviors, something which
    primitive types can't have. Take, as an example, **the equality operation**. With
    Value Objects, equality operations can be modeled and encapsulated in their own
    classes, making concepts go from implicit to explicit.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let''s see a possible implementation for `OrderId`, the `Order` Identity that
    has evolved into a Value Object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: There are different implementations you can consider for implementing the `OrderId`.
    The example shown above is quite simple. As explained in the [Chapter 3](18966f09-304b-4632-b7bb-0f4280e5cce5.xhtml),
    *Value Objects*, you can make the `__constructor` method private and use static
    factory methods to create new instances. Talk with your team, experiment, and
    agree. Because Entity Identities are not complex Value Objects, our recommendation
    is that you shouldn't worry too much here.
  prefs: []
  type: TYPE_NORMAL
- en: 'Going back to the `Order`, it''s time to update references to `OrderId`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Our Entity has an Identity modeled using a Value Object. Let's consider different
    ways of creating an `OrderId`.
  prefs: []
  type: TYPE_NORMAL
- en: Identity Operation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As stated before, the Identity of an Entity is what defines it. So then, handling
    it is an important aspect of the Entity. There are usually four ways to define
    the Identity of an Entity: the persistence mechanism provides the Identity, a
    client provides the Identity, the application itself provides the Identity, or
    another Bounded Context provides the Identity.'
  prefs: []
  type: TYPE_NORMAL
- en: Persistence Mechanism Generates Identity
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Usually, the simplest way of generating the Identity is to delegate it to the
    persistence mechanism, because the vast majority of persistence mechanisms support
    some kind of Identity generation — like MySQL''s `AUTO_INCREMENT` attribute or
    Postgres and Oracle sequences. This, although simple, has a major drawback: we
    won''t have the Identity of the Entity until we persist it. So to some degree,
    if we''re going with persistence mechanism-generated Identities, we''ll couple
    the Identity operation with the underlying persistence store:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'And then we might consider this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: If you've ever tried to build your own ORM, you've already experienced this
    situation. What's the approach for creating a new Person? If the database is going
    to generate the Identity, do we have to pass it in the constructor? When and where
    is the magic that will update the Person with its Identity? What happens if we
    end up not persisting the Entity?
  prefs: []
  type: TYPE_NORMAL
- en: Surrogate Identity
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Sometimes when using an ORM to map Entities to a persistence store, some constraints
    are imposed — for example, Doctrine demands an integer field if an `IDENTITY`
    generator strategy is used. This can conflict with the Domain Model if it requires
    another kind of Identity.
  prefs: []
  type: TYPE_NORMAL
- en: 'The simplest way to handle such a situation is by using a [Layer Supertype](http://martinfowler.com/eaaCatalog/layerSupertype.html),
    where the Identity field created for the persistence store is placed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Active Record Vs. Data Mapper for Rich Domain Models
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Every project always faces the decision of which ORM should be used. There
    are a lot of good ORMs for PHP out there: Doctrine, Propel, Eloquent, Paris, and
    many more.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Most of them are [Active Record](http://www.martinfowler.com/eaaCatalog/activeRecord.html) implementations.
    An Active Record implementation is fine mostly for CRUD applications, but it''s
    not the ideal solution for Rich Domain Models for the following reasons:'
  prefs: []
  type: TYPE_NORMAL
- en: The Active Record pattern assumes a one-to-one relation between an Entity and
    a database table. So it couples the design of the database to the design of the
    object system**.** And in a Rich Domain Model, sometimes Entities are constructed
    with information that may come from different data sources.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Advanced things like collections and inheritance are tricky to implement.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Most of the implementations force the use, through inheritance, of some sort
    of constructions that impose several conventions. This can lead to persistence
    leakage into the Domain Model by coupling the Domain Model with the ORM. The only
    Active Record implementation we've seen that doesn't impose inheriting from a
    base class is `[Castle ActiveRecord](http://docs.castleproject.org/Active%20Record.MainPage.ashx)` from 
    `[Castle Project](http://www.castleproject.org/)`, a .NET framework. While this
    leads to some degree of separation between persistence and Domain concerns in
    the produced Entities, it doesn't decouple the low-level persistence details from
    high-level Domain design.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As mentioned in the previous chapter, currently the best ORM for PHP is [Doctrine ](http://doctrine-project.org),
    which is an implementation of the [Data Mapper pattern](http://www.martinfowler.com/eaaCatalog/dataMapper.html).
    Data Mapper decouples persistence concerns from Domain concerns, leading to persistence-free
    Entities. This makes the tool the best for someone wanting to build a Rich Domain
    Model.
  prefs: []
  type: TYPE_NORMAL
- en: Client Provides Identity
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Sometimes, when dealing with certain Domains, the Identities come naturally,
    with the client consuming the Domain Model. This is likely the ideal case, because
    the Identity can be modeled easily. Let''s take a look at the book-selling market:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'According to [Wikipedia](https://en.wikipedia.org/wiki/International_Standard_Book_Number):
    The **International Standard Book Number** (**ISBN**) is a unique numeric commercial
    book identifier. An ISBN is assigned to each edition and variation (except re-printings)
    of a book. For example, an e-book, a paperback and a hardcover edition of the
    same book would each have a different ISBN. The ISBN is 13 digits long if assigned
    on or after 1 January 2007, and 10 digits long if assigned before 2007\. The method
    of assigning an ISBN is nation-based and varies from country to country, often
    depending on how large the publishing industry is within a country.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The cool thing about the ISBN is that it''s already defined in the Domain,
    it''s a valid identifier because it''s unique, and it can be easily validated.
    This is a good example of an Identity provided by the client:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, it''s just a matter of using it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Exercise
  prefs: []
  type: TYPE_NORMAL
- en: Think about other Domains where Identities are built in and model one.
  prefs: []
  type: TYPE_NORMAL
- en: Application Generates Identity
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If the client can't provide the Identity generally, the preferred way to handle
    the Identity operation is to let the application generate the Identities, usually
    through a UUID. This is our recommended approach in the case that you don't have
    a scenario as shown in the previous section.
  prefs: []
  type: TYPE_NORMAL
- en: 'According to [Wikipedia](https://en.wikipedia.org/wiki/Universally_unique_identifier):'
  prefs: []
  type: TYPE_NORMAL
- en: The intent of UUIDs is to enable distributed systems to uniquely identify information
    without significant central coordination. In this context the word unique should
    be taken to mean *practically unique* rather than *guaranteed unique*. Since the
    identifiers have a finite size, it is possible for two differing items to share
    the same identifier. This is a form of hash collision. The identifier size and
    generation process need to be selected so as to make this sufficiently improbable
    in practice. Anyone can create a UUID and use it to identify something with reasonable
    confidence that the same identifier will never be unintentionally created by anyone
    to identify something else. Information labeled with  UUIDs can therefore be later
    combined into a single database without needing to resolve identifier (ID) conflicts.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are several libraries in PHP that generate UUIDs, and they can be found
    at Packagist: [https://packagist.org/search/?q=uuid](https://packagist.org/search/?q=uuid).
    The best recommendation is the one developed by Ben Ramsey at the following  link:
    [https://github.com/ramsey/uuid](https://github.com/ramsey/uuid) because it has
    tons of watchers on GitHub and millions of installations on Packagist.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The preferred place to put the creation of the Identity would be inside a Repository
    (we''ll go deeper into this in the [Chapter 10](c688814f-5b8c-49f2-9b2c-f292299c2fde.xhtml), *Repositories*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'When using Doctrine, we''ll need to create a custom Repository that implements
    such an interface. It will basically create the new Identity and use the `EntityManager`
    in order to persist and delete Entities. A small variation is to put the `nextIdentity`
    implementation into the interface that will become an abstract class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s quickly review the final implementation of the `OrderId` Value Object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: The main concern about this approach, as you'll see in the following sections,
    is how easy it is to persist Entities that contain Value Objects. However, mapping
    embedded Value Objects that are inside an Entity can be tricky, depending on the
    ORM.
  prefs: []
  type: TYPE_NORMAL
- en: Other Bounded Context Generates Identity
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This is likely the most complex Identity generation strategy because it forces
    a local Entity to be dependent not only on local Bounded Context events, but also
    on external Bounded Contexts events. So in terms of maintenance, the cost would
    be high.
  prefs: []
  type: TYPE_NORMAL
- en: The other Bounded Context provides an interface to select the Identity from
    the local Entity. It can take some of the exposed properties as its own.
  prefs: []
  type: TYPE_NORMAL
- en: When synchronization is needed between the Entities of the Bounded Contexts,
    it can usually be achieved with an Event-Driven Architecture on each of the Bounded
    Contexts that need to be notified when the original Entity is changed.
  prefs: []
  type: TYPE_NORMAL
- en: Persisting Entities
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Currently, as discussed earlier in the chapter, the best tool for saving Entity
    state to a persistent store is Doctrine ORM. Doctrine has several ways to specify
    Entity metadata: by annotations in Entity code, by XML, by YAML, or by plain PHP.
    In this chapter, we''ll discuss in depth why annotations are not the best thing
    to use when mapping Entities.'
  prefs: []
  type: TYPE_NORMAL
- en: Setting Up Doctrine
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'First of all, we need to require Doctrine through Composer. At the root folder
    of the project, the command below has to be executed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, these lines will allow you to set up Doctrine:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Mapping Entities
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: By default, Doctrine's documentation presents the code examples using annotations.
    So we begin the code example using annotations and discussing why they should
    be avoided whenever possible.
  prefs: []
  type: TYPE_NORMAL
- en: To do so, we'll bring back the `Order` class discussed earlier in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Mapping Entities Using Annotated Code
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When Doctrine was released, a catchy way of showing how to map objects in the
    code examples was by using annotations.
  prefs: []
  type: TYPE_NORMAL
- en: What's an annotation?
  prefs: []
  type: TYPE_NORMAL
- en: 'An annotation is a special form of metadata. In PHP, it''s put under source
    code comments. For example, *PHPDocumentor* makes use of annotations to build
    API information, and `PHPUnit` uses some annotations to specify data providers
    or to provide expectations about exceptions thrown by a piece of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '`class SumTest extends PHPUnit_Framework_TestCase  {`'
  prefs: []
  type: TYPE_NORMAL
- en: '`    /** @dataProvider aMethodName */`'
  prefs: []
  type: TYPE_NORMAL
- en: '`    public function testAddition() {`'
  prefs: []
  type: TYPE_NORMAL
- en: '`        //... `'
  prefs: []
  type: TYPE_NORMAL
- en: '`    }`'
  prefs: []
  type: TYPE_NORMAL
- en: '`}`'
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to map the `Order` Entity to the persistence store, the source code
    for the `Order` should be modified to add the Doctrine annotations:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, to persist the Entity to the persistent store, it''s just as easy to
    do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: At first glance, this code looks simple, and this can be an easy way to specify
    mapping information. But it comes at a cost. What's odd about the final code?
  prefs: []
  type: TYPE_NORMAL
- en: First of all, Domain concerns are mixed with Infrastructure concerns. Order
    is a Domain concept, whereas Table, Column, and so on are infrastructure concerns.
  prefs: []
  type: TYPE_NORMAL
- en: As a result, this Entity is tightly coupled to the mapping information specified
    by the annotations in the source code. If the Entity were required to be persisted
    using another Entity manager and with different mapping metadata, this wouldn't
    be possible.
  prefs: []
  type: TYPE_NORMAL
- en: Annotations tend to lead to side effects and tight coupling, so it would be
    better to not use them.
  prefs: []
  type: TYPE_NORMAL
- en: So what's the best way to specify mapping information? The best way is the one
    that allows you to separate the mapping information from the Entity itself. This
    can be achieved by using XML mapping, YAML mapping, or PHP mapping. In this book,
    we're going to cover XML mapping.
  prefs: []
  type: TYPE_NORMAL
- en: Mapping Entities Using XML
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To map the `Order` Entity using the XML mapping, the setup code of Doctrine
    should be altered slightly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'The mapping file should be created on the path where Doctrine will search for
    the mapping files, and the mapping files should be named after the fully qualified
    class name, replacing the backslashes `\` with dots. Consider the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding illustration would have the mapping file named like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Additionally, it''s convenient that all the mapping files use a special XML
    Schema created specially for specifying mapping information:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Mapping Entity Identity
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Our Identity, `OrderId`, is a Value Object. As seen in the previous chapter,
    there are different approaches for mapping a Value Object using Doctrine, embeddables,
    and custom types. When Value Objects are used as Identities, the best option is
    custom types.
  prefs: []
  type: TYPE_NORMAL
- en: 'An interesting new feature in *Doctrine 2.5* is that it''s now possible to
    use Objects as identifiers for Entities, so long as they implement the magic method
    `__toString()`. So we can add  `__toString` to our Identity Value Objects and
    use them in our mappings:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Check the implementation of the Doctrine custom types. They inherit from `GuidType`,
    so their internal representation will be a UUID. We need to specify the database
    native translation. Then we need to register our custom types before we use them.
    If you need help with these steps, [Custom Mapping Types](http://doctrine-orm.readthedocs.io/projects/doctrine-orm/en/latest/cookbook/custom-mapping-types.html) is
    a good reference.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Lastly, we''ll set up the registration of custom types. Again, we have to update
    our bootstrapping:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Final Mapping File
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'With all the changes, we''re finally ready, so let''s take a look at the final
    mapping file. The most interesting detail is to check how the id gets mapped with
    our defined custom type for `OrderId`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Testing Entities
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It's relatively easy to test Entities, simply because they're plain old PHP
    classes with actions derived from the Domain concept they represent. The focus
    of the test should be the invariants that the Entity protects, because the behavior
    on the Entities will likely be modeled around those invariants.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, and for the sake of simplicity, suppose a Domain Model for a blog
    is needed. A possible one could be this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'In order to test this Domain Model, we must ensure the test covers all the
    `Post` invariants:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: DateTimes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Because `DateTimes` are widely used in Entities, we think it''s important to
    point out specific approaches on unit testing Entities that have fields with date
    types. Consider that a `Post` is new if it was created within the last 15 days:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: The `isNew()` method needs to compare two `DateTimes;` it's a comparison between
    the date when the Post was created and today's date. We compute the difference
    and check if it's less than the specified amount of days. How do we unit test
    the `isNew()` method? As we demonstrated in the implementation, it's difficult
    to reproduce specific flows in our test suites. What options do we have?
  prefs: []
  type: TYPE_NORMAL
- en: Passing All Dates as Parameters
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'One possible option could be passing all the dates as parameters when needed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'This is the easiest approach for unit testing purposes. Just pass different
    pairs of dates to test all possible scenarios with 100 percent coverage. However,
    if you consider the client code that''s creating and asking for the `isNew()`
    method result, things don''t look so nice. The resulting code can be a bit weird
    because of always passing today''s `DateTime`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: Test Class
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Another alternative is to use the Test Class pattern. The idea is to extend
    the `Post` class with a new one that we can manipulate to force specific scenarios.
    This new class is going to be used only for unit testing purposes. The bad news
    is that we have to modify the original `Post` class a bit, extracting some methods
    and changing some fields and methods from `private` to `protected`. Some developers
    may worry about increasing the visibility of class properties just because of
    testing reasons. However, we think that in most cases, it''s worth it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, we''ve extracted the logic for getting today''s date into the
    `today()` method. This way, by applying the Template Method pattern, we can change
    its behavior from a derived class. Something similar happens with the `createdAt`
    method and field. Now they''re protected, so they can be used and overridden in
    derived classes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'With these changes, we can now test our original `Post` class through testing
    `PostTestClass`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Just one last small detail: with this approach, it''s impossible to achieve
    100 percent coverage on the `Post` class, because the `today()` method is never
    going to be executed. However, it can be covered by other tests.'
  prefs: []
  type: TYPE_NORMAL
- en: External Fake
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Another option is to wrap calls to the `DateTimeImmutable` constructor or named
    constructors using a new class and some static methods. In doing so, we can statically
    change the result of those methods to behave differently based on specific testing
    scenarios:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'For getting today''s `DateTime`, we now use a static call to `MyCustomDateTimeBuilder::today()`.
    This class also has some setter methods to fake the result to return in the next
    calls:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: The main problem with this approach is it's coupled statically with an object.
    Depending on your use case, it'll also be tricky to create a flexible fake object.
  prefs: []
  type: TYPE_NORMAL
- en: Reflection
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You can also use reflection techniques for building a new `Post` class with
    custom dates. Consider [Mimic](https://github.com/keyvanakbary/mimic), a simple
    functional library for object prototyping, data hydration, and data exposition:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: Share and Discuss
  prefs: []
  type: TYPE_NORMAL
- en: Discuss with your workmates how to properly unit test your Entities with fixed
    `DateTimes` and come up with additional alternatives.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you want to know more about testing patterns and approaches, take a look
    at the book *xUnit Test Patterns: Refactoring Test Code* by Gerard Meszaros.'
  prefs: []
  type: TYPE_NORMAL
- en: Validation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Validation is a highly important process in our Domain Model. It checks not
    only for the correctness of attributes, but also for that of entire objects and
    the composition of those objects. Different levels of validation are required
    in order to keep this Model in a valid state. Just because an object consists
    of valid attributes (on a per basis) doesn''t necessarily mean the object (as
    a whole) is valid. And the opposite is true: valid objects don''t necessarily
    equal valid compositions.'
  prefs: []
  type: TYPE_NORMAL
- en: Attribute Validation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Some people understand validation as the process whereby a service validates
    the state of a given object. In this case, the validation conforms to a [Design-by-contract](http://en.wikipedia.org/wiki/Design_by_contract) approach,
    which consists of preconditions, postconditions, and invariants. One such way
    to protect a single attribute is by using [Chapter 3](18966f09-304b-4632-b7bb-0f4280e5cce5.xhtml), *Value
    Objects*. In order to make our design more flexible for change, we focus only
    on asserting Domain preconditions that must be met. Here, we''ll be using guards
    as an easy way of validating the preconditions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see in the example above, there are four preconditions that must
    be satisfied in order to build a Username Value Object. It:'
  prefs: []
  type: TYPE_NORMAL
- en: Must not be empty
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Must be at least 5 characters
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Must be less than 10 characters
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Must follow a format of alphanumeric characters or underscores
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If all the preconditions are met, the attribute will be set and the object will
    be successfully built. Otherwise, an `InvalidArgumentException` will be raised,
    execution will be halted, and the client will be shown an error.
  prefs: []
  type: TYPE_NORMAL
- en: Some developers may consider this kind of validation defensive programming.
    However, we're not checking that the input is a string or that nulls are not permitted.
    We can't avoid people using our code incorrectly, but we can control the correctness
    of our Domain state. As seen in the [Chapter 3](18966f09-304b-4632-b7bb-0f4280e5cce5.xhtml), *Value
    Objects*, validation can help us with security too.
  prefs: []
  type: TYPE_NORMAL
- en: '[Defensive programming](https://en.wikipedia.org/wiki/Defensive_programming) isn''t
    a bad thing. In general, it makes sense when developing components or libraries
    that are going to be used as a third party in other projects. However, when developing
    your own Bounded Context, those extra paranoid checks (nulls, basic types, type
    hinting, and so  on.) can be avoided to increase development speed by relying
    on the coverage of your unit test suite.'
  prefs: []
  type: TYPE_NORMAL
- en: Entire Object Validation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are times when an object composed of valid properties, as a whole, can
    still be deemed invalid. It can be tempting to add this kind of validation to
    the object itself, but generally this is an anti-pattern. Higher-level validation
    changes at a rhythm different than that of the object logic itself. Also, it's
    good practice to separate these responsibilities.
  prefs: []
  type: TYPE_NORMAL
- en: The validation informs the client about any errors that have been found or collects
    the results to be reviewed later, as sometimes we don't want to stop the execution
    at the first sign of trouble.
  prefs: []
  type: TYPE_NORMAL
- en: 'An `abstract` and reusable `Validator` could be something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'As a concrete example, we want to validate an entire `Location` object, composed
    of valid Country, City, and Postcode Value Objects. However, these individual
    values might be in an invalid state at the time of validation. Maybe the city
    doesn''t form part of the country, or maybe the postcode doesn''t follow the city
    format:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'The validator checks the state of the `Location` object in its entirety, analyzing
    the meaning of the relationships between properties:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'Once all the properties have been set, we''re able to validate the Entity,
    most likely after some described process. On the surface, it looks as if the Location
    validates itself. However, this isn''t the case. The  `Location` class delegates
    this validation to a concrete validator instance, splitting these two clear responsibilities:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: Decoupling Validation Messages
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'With some minor changes to our existing implementation, we''re able to decouple
    the validation messages from the validator:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'We also need to change the signature of the validation method to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: Validating Object Compositions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Validating object compositions can be complicated. As such, the preferred way
    of achieving this is through a Domain Service. The service then communicates with
    Repositories in order to retrieve the valid Aggregate. Due to the likely complex
    object graphs that can be created, an Aggregate could be in an intermediate state,
    requiring other Aggregates to be validated beforehand. We can use Domain Events
    to notify other parts of the system that a particular element has been validated.
  prefs: []
  type: TYPE_NORMAL
- en: Entities and Domain Events
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We''ll explore [Chapter 6](607255c5-e619-4398-94bb-484c008472b7.xhtml), *Domain-Events* in
    future chapters; however, it''s important to highlight that operations performed
    on Entities can fire Domain Events. This approach is used to communicate the Domain
    change to other parts of the Application, or even to other Applications, as you''ll
    see in [Chapter 12](31f29fd9-2a73-42bd-88ad-2b189981cd1b.xhtml), *Integrating
    Bounded Contexts*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'Domain Events can even be fired when a new instance of our Entity is created:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: Wrap-Up
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Some concepts in the Domain demand Identity — that is, changes to their internal
    states don''t change their own unique identities. We''ve seen how modeling Identity
    as a Value Object brings benefits like immutability, in addition to logic for
    operating the Identity itself. We''ve also shown several ways of providing Identity,
    restated in the following pointers:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Persistence mechanism: Easy to implement, but you won''t have the Identity
    before persisting the object, which delays and complicates event propagation.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Surrogate ID: Some ORMs require an extra field on your Entity to map the Identity
    with the persisting mechanism.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Provided by the client: Sometimes the Identity fits a Domain concept and you
    can model it inside your Domain.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Generated by the application: You can use a library to generate IDs.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Generated by a Bounded Context: Probably the most complex strategy. Other Bounded
    Contexts provide an interface for generating Identities.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We''ve seen and discussed Doctrine as a persistence mechanism, we''ve looked
    at the drawbacks of using the Active Record pattern, and finally, we''ve checked
    different levels of Entity validation:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Attribute validation: Check for specifics inside the object state through preconditions,
    postconditions, and invariants.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Entire object validation: Look for consistency of an object as a whole. Extracting
    the validation to an external service is a good practice.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Object compositions: Complex object compositions could be validated through
    Domain Services. A good way of communicating this to the rest of the application
    is through Domain Events.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
