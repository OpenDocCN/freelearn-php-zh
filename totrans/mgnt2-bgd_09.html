<html><head></head><body>
<div id="page" style="height:0pt"/><div class="book" title="Chapter&#xA0;8.&#xA0;Frontend Development"><div class="book" id="1Q5IA2-818f5224668745eb9070ddf1d85e6bfa"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch08" class="calibre1"/>Chapter 8. Frontend Development</h1></div></div></div><p class="calibre7">Frontend development is a term most commonly tied to producing HTML, CSS, and JavaScript <a id="id279" class="calibre1"/>for a website or web application. Interchangeably, it addresses accessibility, usability, and performance toward reaching a satisfying user experience. Various levels of customization we want to apply to our web store require different development skill levels. We can make relatively simple changes to our store using just CSS. These would be the changes where we accept the structure of the store and focus only on visuals like changing colors and images. This might be a good starting point for less experienced developers and those new to the Magento platform. A more involved approach would be to make changes to the output generated by Magento modules. This usually means tiny bits of PHP knowledge, mostly <span class="strong"><em class="calibre9">copy-paste-modify</em></span> of existing code fragments. A skill level above this one would imply knowledge of making structural changes to our store. This usually means mastering Magento's moderately sophisticated layout engine, where we make changes through XML definitions. The final and highest skill level for Magento frontend development implies the modification of existing or new custom functionality development.</p><p class="calibre7">Throughout this chapter, we will take a deep dive through the following sections:</p><div class="book"><ul class="itemizedlist"><li class="listitem">Rendering flow</li><li class="listitem">View elements</li><li class="listitem">Block architecture and life cycle</li><li class="listitem">Templates</li><li class="listitem">XML layouts</li><li class="listitem">Themes</li><li class="listitem">JavaScript</li><li class="listitem">CSS</li></ul></div></div>

<div class="book" title="Chapter&#xA0;8.&#xA0;Frontend Development">
<div class="book" title="Rendering flow"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_1"><a id="ch08lvl1sec55" class="calibre1"/>Rendering flow</h1></div></div></div><p class="calibre7">The Magento application<a id="id280" class="calibre1"/> entry point is its <code class="email">index.php</code> file. All of the HTTP requests go through it.</p><p class="calibre7">Let's analyze the (trimmed) version of the <code class="email">index.php</code> file as follows:</p><div class="informalexample"><pre class="programlisting">//PART-1-1
require __DIR__ . '/app/bootstrap.php';

//PART-1-2
$bootstrap = \Magento\Framework\App\Bootstrap::create(BP, $_SERVER);

//PART-1-3
$app = $bootstrap-&gt; createApplication('Magento\Framework\App\Http');

//PART-1-4
$bootstrap-&gt;run($app);</pre></div><p class="calibre7"><code class="email">PART-1-1</code> of the preceding code simply includes <code class="email">/app/bootstrap.php</code> into the code. What happens inside the bootstrap is the inclusion of <code class="email">app/autoload.php</code> and <code class="email">app/functions.php</code>. The functions file contains a single <code class="email">__()</code> function, used for translation purposes, returning an instance of the <code class="email">\Magento\Framework\Phrase</code> object. Without going into the details of the auto-load file, it is suffice to say it handles the auto-loading of all our class files across Magento.</p><p class="calibre7"><code class="email">PART-1-2</code> is simply a static create method call to obtain the instance of the <code class="email">\Magento\Framework\App\Bootstrap</code> object, storing it into the <code class="email">$bootstrap</code> variable.</p><p class="calibre7"><code class="email">PART-1-3</code> is calling the <code class="email">createApplication</code> method on the <code class="email">$bootstrap</code> object. What is happening within <code class="email">createApplication</code> is nothing more than using object manager to create and return the object instance of the class we are passing to it. Since we are passing the <code class="email">\Magento\Framework\App\Http</code> class name to the <code class="email">createApplication</code> method, our <code class="email">$app</code> variable becomes the instance of that class. What this means, effectively, is that our web store app is an instance of <code class="email">Magento\Framework\App\Http</code>.</p><p class="calibre7"><code class="email">PART-1-4</code> is calling the run method on the <code class="email">$bootstrap</code> object, passing it the instance of the <code class="email">Magento\Framework\App\Http</code> class. Although it looks like a simple line of code, this is where things get complicated, as we will soon see.</p><p class="calibre7">Let's analyze the (trimmed) version of the <code class="email">\Magento\Framework\App\Bootstrap</code> <code class="email">-&gt;</code> <code class="email">run</code> method as follows:</p><div class="informalexample"><pre class="programlisting">public function run(\Magento\Framework\AppInterface $application)
{
    //PART-2-1
    $this-&gt;initErrorHandler();
    $this-&gt;initObjectManager();
    $this-&gt;assertMaintenance();
    $this-&gt;assertInstalled();

    //PART-2-2
    $response = $application-&gt;launch();

    //PART-2-3
    $response-&gt;sendResponse();
}</pre></div><p class="calibre7">In the<a id="id281" class="calibre1"/> preceding code, <code class="email">PART-2-1</code> handles the sort of housekeeping bits. It initializes the custom error handler, initializes the object manager, checks if our application is in maintenance mode, and checks that it is installed.</p><p class="calibre7"><code class="email">PART-2-2</code> looks like a simple line of code. Here, we are calling the <code class="email">launch</code> method on <code class="email">$application</code>, which is the <code class="email">Magento\Framework\App\Http</code> instance. Without going into the inner workings of the <code class="email">launch</code> method for the moment, let's just say it returns the instance of the <code class="email">Magento\Framework\App\Response\Http\Interceptor</code> class defined under <code class="email">var/generation/Magento/Framework/App/Response/Http/Interceptor.php</code>. Note that this is an automatically generated wrapper class, extending the <code class="email">\Magento\Framework\App\Response\Http</code> class. Effectively, ignoring <code class="email">Interceptor</code>, we can say that <code class="email">$response</code> is an instance the <code class="email">\Magento\Framework\App\Response\Http</code> class.</p><p class="calibre7">Finally, <code class="email">PART-2-3</code> calls the <code class="email">sendResponse</code> method on <code class="email">$response</code>. Though <code class="email">$response</code> is an instance of the <code class="email">\Magento\Framework\App\Response\Http</code> class, the actual <code class="email">sendResponse</code> method is found further down the parent tree on the <code class="email">\Magento\Framework\HTTP\PhpEnvironment\Response</code> class. The <code class="email">sendResponse</code> method calls another parent class method called <code class="email">send</code>. The <code class="email">send</code> method can be found under the <code class="email">Zend\Http\PhpEnvironment\Response</code> class. It triggers the <code class="email">sendHeaders</code> and <code class="email">sendContent</code> methods. This is where the actual output gets sent to the browser, as the <code class="email">sendHeaders</code> method is using PHP's <code class="email">header</code> function and <code class="email">echo</code> construct to push the output.</p><p class="calibre7">To reiterate on the preceding, the flow of execution as we understand it comes down to the following:</p><div class="book"><ul class="itemizedlist"><li class="listitem"><code class="email">index.php</code></li><li class="listitem"><code class="email">\Magento\Framework\App\Bootstrap</code> <code class="email">-&gt;</code> <code class="email">run</code></li><li class="listitem"><code class="email">\Magento\Framework\App\Http</code> <code class="email">-&gt;</code> <code class="email">launch</code></li><li class="listitem"><code class="email">\Magento\Framework\App\Response\Http</code> <code class="email">-&gt;</code> <code class="email">sendResponse</code></li></ul></div><p class="calibre7">Though we have just made it to the end of the bootstrap's <code class="email">run</code> method, it would be unfair to say we covered the rendering flow, as we barely touched it.</p><p class="calibre7">We need<a id="id282" class="calibre1"/> to take a step back and take a detailed look at <code class="email">PART-2-2</code>, the inner workings of the <code class="email">launch</code> method. Let's take a look at the (trimmed) version of the <code class="email">\Magento\Framework\App\Http</code> <code class="email">-&gt;</code> <code class="email">launch</code> method as follows:</p><div class="informalexample"><pre class="programlisting">public function launch()
{
    //PART-3-1
    $frontController = $this-&gt;_objectManager-&gt;get ('Magento\Framework\App\FrontControllerInterface');

    //PART-3-2
    $result = $frontController-&gt;dispatch($this-&gt;_request);

    if ($result instanceof \Magento\Framework\Controller \ResultInterface) {
        //PART-3-3
        $result-&gt;renderResult($this-&gt;_response);
    } elseif ($result instanceof \Magento\Framework\App \Response\HttpInterface) {
        $this-&gt;_response = $result;
    } else {
        throw new \InvalidArgumentException('Invalid return type');
    }

    //PART-3-4
    return $this-&gt;_response;
}</pre></div><p class="calibre7"><code class="email">PART-3-1</code> creates the instance of the object whose class conforms to <code class="email">\Magento\Framework\App\FrontControllerInterface</code>. If we look under <code class="email">app/etc/di.xml</code>, we can see there is a preference for <code class="email">FrontControllerInterface</code> in favor of the <code class="email">\Magento\Framework\App\FrontController</code> class. However, if we were to debug the code and check for the actual instance class, it would show <code class="email">Magento\Framework\App\FrontController\Interceptor</code>. This is Magento adding an interceptor wrapper that then extends <code class="email">\Magento\Framework\App\FrontController</code>, which we expected from the <code class="email">di.xml</code> preference entry.</p><p class="calibre7">Now that we know the real class behind the <code class="email">$frontController</code> instance, we know where to look for the <code class="email">dispatch</code> method. The <code class="email">dispatch</code> method is another important step in understanding the rendering flow process. We will look into its inner workings in a bit more detail later on. For now, let's focus back on the <code class="email">$result</code> variable of <code class="email">PART-3-2</code>. If we were to debug the variable, the direct class behind it would show as <code class="email">Magento\Framework\View\Result\Page\Interceptor</code>, defined under the dynamically created <code class="email">var/generation/Magento/Framework/View/Result/Page/Interceptor.php</code> file. <code class="email">Interceptor</code> is the wrapper for the <code class="email">\Magento\Framework\View\Result\Page</code> class. Thus, it is safe to say that our <code class="email">$result</code> variable is an instance of the <code class="email">Page</code> class.</p><p class="calibre7">The<code class="email"> Page</code> class <a id="id283" class="calibre1"/>extends <code class="email">\Magento\Framework\View\Result\Layout</code>, which further extends <code class="email">\Magento\Framework\Controller\AbstractResult</code> and implements <code class="email">\Magento\Framework\Controller\ResultInterface</code>. Quite a chain we have here, but it is important to understand it.</p><p class="calibre7">Notice <code class="email">PART-3-3</code>. Since our <code class="email">$result</code> is an instance of <code class="email">\Magento\Framework\Controller\ResultInterface</code>, we fall into the first <code class="email">if</code> condition that calls the <code class="email">renderResult</code> method. The <code class="email">renderResult</code> method itself is declared within the <code class="email">\Magento\Framework\View\Result\Layout</code> class. Without going into the details of <code class="email">renderResult</code>, suffice to say that it adds HTTP headers, and content to the <code class="email">$this-&gt;_response</code> object passed to it. That same response object is what the <code class="email">launch</code> method returns, as we described before in <code class="email">PART-2-2</code>.</p><p class="calibre7">Though <code class="email">PART-3-3</code> does not depict any return value, the expression <code class="email">$result-&gt;renderResult($this-&gt;_response)</code> does not do any output on its own. It modifies <code class="email">$this-&gt;_response</code> that we finally return from the <code class="email">launch</code> method as shown in <code class="email">PART-3-4</code>.</p><p class="calibre7">To reiterate on the preceding, the flow of execution as we understand it comes down to the following:</p><div class="book"><ul class="itemizedlist"><li class="listitem"><code class="email">index.php</code></li><li class="listitem"><code class="email">\Magento\Framework\App\Bootstrap</code> <code class="email">-&gt;</code> <code class="email">run</code></li><li class="listitem"><code class="email">\Magento\Framework\App\Http</code> <code class="email">-&gt;</code> <code class="email">launch</code></li><li class="listitem"><code class="email">\Magento\Framework\App\FrontController</code> <code class="email">-&gt;</code> <code class="email">dispatch</code></li><li class="listitem"><code class="email">\Magento\Framework\View\Result\Page</code> <code class="email">-&gt;</code> <code class="email">renderResult</code></li><li class="listitem"><code class="email">\Magento\Framework\App\Response\Http</code> <code class="email">-&gt;</code> <code class="email">sendResponse</code></li></ul></div><p class="calibre7">As we mentioned while explaining <code class="email">PART-3-2</code>, the <code class="email">dispatch</code> method is another important step in the rendering flow process. Let's take a look at the (trimmed) version of the <code class="email">\Magento\Framework\App\FrontController</code> <code class="email">-&gt;</code> <code class="email">dispatch</code> method as follows:</p><div class="informalexample"><pre class="programlisting">public function dispatch(\Magento\Framework\App\RequestInterface $request)
{
    //PART-4-1
    while (!$request-&gt;isDispatched() &amp;&amp; $routingCycleCounter++ &lt; 100) {
        //PART-4-2
        foreach ($this-&gt;_routerList as $router) {
            try {
                //PART-4-3
                $actionInstance = $router-&gt;match($request);
                if ($actionInstance) {
                    $request-&gt;setDispatched(true);
                    //PART-4-4
                    $result = $actionInstance-&gt;dispatch($request);
                    break;
                }
            } catch (\Magento\Framework\Exception \NotFoundException $e) {}
        }
    }
    //PART-4-4
    return $result;
}</pre></div><p class="calibre7"><code class="email">PART-4-1</code> and <code class="email">PART-4-2</code> in the preceding code shows (almost) the entire <code class="email">dispatch</code> method body <a id="id284" class="calibre1"/>contained within a loop. The loop does 100 iterations, further looping through all available router types, thus giving each router 100 times to find a route <code class="email">match</code>.</p><p class="calibre7">The router list loop includes routers of the following class types:</p><div class="book"><ul class="itemizedlist"><li class="listitem"><code class="email">Magento\Framework\App\Router\Base</code></li><li class="listitem"><code class="email">Magento\UrlRewrite\Controller\Router</code></li><li class="listitem"><code class="email">Magento\Cms\Controller\Router</code></li><li class="listitem"><code class="email">Magento\Framework\App\Router\DefaultRouter</code></li></ul></div><p class="calibre7">All of the listed routers implement <code class="email">\Magento\Framework\App\RouterInterface</code>, making them all have the implementation of the <code class="email">match</code> method.</p><p class="calibre7">A module can further define new routers if they choose so. As an example, imagine if we are developing a <code class="email">Blog</code> module. We would want our module catching all requests on a URL that starts with a <code class="email">/blog/</code> part. This can be done by specifying the custom router, which would then show up on the preceding list.</p><p class="calibre7"><code class="email">PART-4-3</code> shows the <code class="email">$actionInstance</code> variable storing the result of the router <code class="email">match</code> method call. As per <code class="email">RouterInterface</code> requirements, the <code class="email">match</code> method is required to return an instance whose class implements <code class="email">\Magento\Framework\App\ActionInterface</code>. Let's imagine we are now hitting the URL <code class="email">/foggyline_office/test/crud/</code> from the module we wrote in <a class="calibre1" title="Chapter 4. Models and Collections" href="part0028_split_000.html#QMFO2-818f5224668745eb9070ddf1d85e6bfa">Chapter 4</a>, <span class="strong"><em class="calibre9">Models and Collections</em></span>. In this case, our <code class="email">$router</code> class would be <code class="email">\Magento\Framework\App\Router\Base</code> and our <code class="email">$actionInstance</code> would be of the class <code class="email">\Foggyline\Office\Controller\Test\Crud\Interceptor</code>. Magento automatically <a id="id285" class="calibre1"/>adds <code class="email">Interceptor</code>, through the dynamically generated <code class="email">var/generation/Foggyline/Office/Controller/Test/Crud/Interceptor.php</code> file. This <code class="email">Interceptor</code> class further extends our module <code class="email">\Foggyline\Office\Controller\Test\Crud</code> class file. The <code class="email">Crud</code> class extends <code class="email">\Foggyline\Office\Controller\Test</code>, which further extends <code class="email">\Magento\Framework\App\Action\Action</code>, which implements <code class="email">\Magento\Framework\App\ActionInterface</code>. After a lengthy parent-child tree, we finally got to <code class="email">ActionInterface</code>, which is what our <code class="email">match</code> method is required to return.</p><p class="calibre7"><code class="email">PART-4-4</code> shows the <code class="email">dispatch</code> method being called on <code class="email">$actionInstance</code>. This method is implemented within <code class="email">\Magento\Framework\App\Action\Action</code>, and is expected to return an object that implements <code class="email">\Magento\Framework\App\ResponseInterface</code>. Internal to <code class="email">dispatch</code>, the <code class="email">execute</code> method is called, thus running the code within our <code class="email">Crud</code> controller action <code class="email">execute</code> method.</p><p class="calibre7">Assuming our <code class="email">Crud</code> controller action execute method does not return nothing, the <code class="email">$result</code> object becomes an instance of <code class="email">Magento\Framework\App\Response\Http\Interceptor</code>, which is wrapped around <code class="email">\Magento\Framework\App\Response\Http</code>.</p><p class="calibre7">Let's imagine our <code class="email">Crud</code> class has been defined as follows:</p><div class="informalexample"><pre class="programlisting">/**
 * @var \Magento\Framework\View\Result\PageFactory
 */
protected $resultPageFactory;

public function __construct(
    \Magento\Framework\App\Action\Context $context,
    \Magento\Framework\View\Result\PageFactory $resultPageFactory
)
{
    $this-&gt;resultPageFactory = $resultPageFactory;
    return parent::__construct($context);
}

public function execute()
{
    $resultPage = $this-&gt;resultPageFactory-&gt;create();
    //...
    return $resultPage;
}</pre></div><p class="calibre7">Debugging the <code class="email">$result</code> variable now shows it's an instance of <code class="email">\Magento\Framework\View\Result\Page\Interceptor</code>. This <code class="email">Interceptor</code> gets dynamically generated by Magento under <code class="email">var/generation/Magento/Framework/View/Result/Page/Interceptor.php</code> and is merely a wrapper for <code class="email">\Magento\Framework\View\Result\Page</code>. This <code class="email">Page</code> class further extends the <code class="email">\Magento\Framework\View\Result\Layout</code> class, and implements <code class="email">\Magento\Framework\App\ResponseInterface</code>.</p><p class="calibre7">Finally, <code class="email">PART-4-4</code> shows the <code class="email">$result</code> object of type <code class="email">\Magento\Framework\View\Result\Page</code> being returned from the <code class="email">FrontController</code> <code class="email">dispatch</code> method.</p><p class="calibre7">To reiterate on<a id="id286" class="calibre1"/> the preceding, the flow of execution as we understand it comes down to the following:</p><div class="book"><ul class="itemizedlist"><li class="listitem"><code class="email">index.php</code></li><li class="listitem"><code class="email">\Magento\Framework\App\Bootstrap</code> <code class="email">-&gt;</code> <code class="email">run</code></li><li class="listitem"><code class="email">\Magento\Framework\App\Http</code> <code class="email">-&gt;</code> <code class="email">launch</code></li><li class="listitem"><code class="email">\Magento\Framework\App\FrontController</code> <code class="email">-&gt;</code> <code class="email">dispatch</code></li><li class="listitem"><code class="email">\Magento\Framework\App\Router\Base</code> <code class="email">-&gt;</code> <code class="email">match</code></li><li class="listitem"><code class="email">\Magento\Framework\App\Action\Action</code> <code class="email">-&gt;</code> <code class="email">dispatch</code></li><li class="listitem"><code class="email">\Magento\Framework\View\Result\Page</code> <code class="email">-&gt;</code> <code class="email">renderResult</code></li><li class="listitem"><code class="email">\Magento\Framework\App\Response\Http</code> <code class="email">-&gt;</code> <code class="email">sendResponse</code></li></ul></div><p class="calibre7">In a nutshell, what we as frontend developers should know is that returning the Page type object from our controller action will automatically call the <code class="email">renderResult</code> method on that object. <code class="email">Page</code> and <code class="email">Layout</code> is where all the theme translations, layout, and template loading are triggering.</p></div></div>

<div id="page" style="height:0pt"/><div class="book" title="View elements"><div class="book" id="1R42S2-818f5224668745eb9070ddf1d85e6bfa"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch08lvl1sec56" class="calibre1"/>View elements</h1></div></div></div><p class="calibre7">Magento's primary<a id="id287" class="calibre1"/> view elements are its UI Components, containers, and blocks. The following is a brief overview of each of them.</p></div>

<div class="book" title="View elements">
<div class="book" title="Ui components"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_1"><a id="ch08lvl2sec21" class="calibre1"/>Ui components</h2></div></div></div><p class="calibre7">Under<a id="id288" class="calibre1"/> the <code class="email">vendor/magento/framework/View/Element/</code> folder, we can find <code class="email">UiComponentInterface</code> and <code class="email">UiComponentFactory</code>. The full set of <code class="email">Ui</code> components is located under the <code class="email">vendor/magento/framework/View/Element/</code> directory. Magento implements <code class="email">UiComponent</code> through a separate module called <code class="email">Magento_Ui</code>. Thus, the components themselves are located under the <code class="email">vendor/magento/module-ui/Component/</code> directory.</p><p class="calibre7">Components<a id="id289" class="calibre1"/> implement <code class="email">UiComponentInterface</code>, which is defined under the <code class="email">vendor/magento/framework/View/Element/UiComponentInterface.php</code> file as follows:</p><div class="informalexample"><pre class="programlisting">namespace Magento\Framework\View\Element;

use Magento\Framework\View\Element\UiComponent\ContextInterface;

interface UiComponentInterface extends BlockInterface
{
    public function getName();
    public function getComponentName();
    public function getConfiguration();
    public function render();
    public function addComponent($name, UiComponentInterface $component);
    public function getComponent($name);
    public function getChildComponents();
    public function getTemplate();
    public function getContext();
    public function renderChildComponent($name);
    public function setData($key, $value = null);
    public function getData($key = '', $index = null);
    public function prepare();
    public function prepareDataSource(array &amp; $dataSource);
    public function getDataSourceData();
}</pre></div><p class="calibre7">Notice how <code class="email">BlockInterface</code> extends <code class="email">BlockInterface</code>, whereas <code class="email">BlockInterface</code> defines only one method requirement as follows:</p><div class="informalexample"><pre class="programlisting">namespace Magento\Framework\View\Element;

interface BlockInterface
{
    public function toHtml();
}</pre></div><p class="calibre7">Since <code class="email">Block</code> is an element of the interface, <code class="email">UiComponent</code> can be looked at as an advanced block. Let's take a quick look at the <code class="email">_renderUiComponent</code> method of the <code class="email">\Magento\Framework\View\Layout</code> class, (partially) defined as follows:</p><div class="informalexample"><pre class="programlisting">protected function _renderUiComponent($name)
{
    $uiComponent = $this-&gt;getUiComponent($name);
    return $uiComponent ? $uiComponent-&gt;toHtml() : '';
}</pre></div><p class="calibre7">This <a id="id290" class="calibre1"/>shows that <code class="email">UiComponent</code> is rendered in the same way as block, by calling the <code class="email">toHtml</code> method on the component. The <code class="email">vendor/magento/module-ui/view/base/ui_component/etc/definition.xml</code> file contains an extensive list of several <code class="email">UiComponents</code> as follows:</p><div class="book"><ul class="itemizedlist"><li class="listitem"><code class="email">dataSource</code>: <code class="email">Magento\Ui\Component\DataSource</code></li><li class="listitem"><code class="email">listing</code>: <code class="email">Magento\Ui\Component\Listing</code></li><li class="listitem"><code class="email">paging</code>: <code class="email">Magento\Ui\Component\Paging</code></li><li class="listitem"><code class="email">filters</code>: <code class="email">Magento\Ui\Component\Filters</code></li><li class="listitem"><code class="email">container</code>: <code class="email">Magento\Ui\Component\Container</code></li><li class="listitem"><code class="email">form</code>: <code class="email">Magento\Ui\Component\Form</code></li><li class="listitem"><code class="email">price</code>: <code class="email">Magento\Ui\Component\Form\Element\DataType\Price</code></li><li class="listitem"><code class="email">image</code>: <code class="email">Magento\Ui\Component\Form\Element\DataType\Media</code></li><li class="listitem"><code class="email">nav</code>: <code class="email">Magento\Ui\Component\Layout\Tabs\Nav</code></li></ul></div><p class="calibre7">… and many more</p><p class="calibre7">These components are mostly used to construct a listing and filters in the admin area. If we do a string search for <code class="email">uiComponent</code> across the entire Magento, we would mostly find entries like the one in <code class="email">vendor/magento/module-cms/view/adminhtml/layout/cms_block_index.xml</code> with content as follows:</p><div class="informalexample"><pre class="programlisting">&lt;page  xsi:noNamespaceSchemaLocation="urn:magento:framework:View/Layout /etc/page_configuration.xsd"&gt;
    &lt;body&gt;
        &lt;referenceContainer name="content"&gt;
            &lt;uiComponent name="cms_block_listing"/&gt;
        &lt;/referenceContainer&gt;
    &lt;/body&gt;
&lt;/page&gt;</pre></div><p class="calibre7">The value <code class="email">cms_block_listing</code> of <code class="email">uiComponent</code>'s <code class="email">name</code> attribute refers to the name of the <code class="email">vendor/magento/module-cms /view/adminhtml/ui_component/cms_block_listing.xml</code> file. Within the <code class="email">cms_block_listing.xml</code> file, we have a listing component defined across more than a few hundreds lines of XML. Listing component then <code class="email">dataSource</code>, <code class="email">container</code>, <code class="email">bookmark</code>, <code class="email">filterSearch</code>, <code class="email">filters</code>, and so on. We will not go into the details of these declarations, as our focus here is on more general frontend bits.</p></div></div>

<div class="book" title="View elements">
<div class="book" title="Containers"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_2"><a id="ch08lvl2sec22" class="calibre1"/>Containers</h2></div></div></div><p class="calibre7">Containers<a id="id291" class="calibre1"/> have no block classes related to them. Container renders all of its children automatically. They allow the configuration of some attributes. Simply attach any element to a container and it will render it automatically. With a container, we can define wrapping tags, CSS classes, and more.</p><p class="calibre7">We cannot create instances of containers because they are an abstract concept, whereas we can create instances of blocks.</p><p class="calibre7">Containers are rendered via the <code class="email">_renderContainer</code> method of the <code class="email">Magento\Framework\View\Layout</code> class, defined as follows:</p><div class="informalexample"><pre class="programlisting">protected function _renderContainer($name)
{
    $html = '';
    $children = $this-&gt;getChildNames($name);
    foreach ($children as $child) {
        $html .= $this-&gt;renderElement($child);
    }
    if ($html == '' || !$this-&gt;structure-&gt;getAttribute($name, Element::CONTAINER_OPT_HTML_TAG)) {
        return $html;
    }

    $htmlId = $this-&gt;structure-&gt;getAttribute($name, Element::CONTAINER_OPT_HTML_ID);
    if ($htmlId) {
        $htmlId = ' id="' . $htmlId . '"';
    }

    $htmlClass = $this-&gt;structure-&gt;getAttribute($name, Element::CONTAINER_OPT_HTML_CLASS);
    if ($htmlClass) {
        $htmlClass = ' class="' . $htmlClass . '"';
    }

    $htmlTag = $this-&gt;structure-&gt;getAttribute($name, Element::CONTAINER_OPT_HTML_TAG);

    $html = sprintf('&lt;%1$s%2$s%3$s&gt;%4$s&lt;/%1$s&gt;', $htmlTag, $htmlId, $htmlClass, $html);

    return $html;
}</pre></div><p class="calibre7">Containers support the following extra attributes: <code class="email">htmlTag</code>, <code class="email">htmlClass</code>, <code class="email">htmlId</code>, and <code class="email">label</code>. To make a little demonstration of a container in action, let us make sure we have a module from <a class="calibre1" title="Chapter 4. Models and Collections" href="part0028_split_000.html#QMFO2-818f5224668745eb9070ddf1d85e6bfa">Chapter 4</a>, <span class="strong"><em class="calibre9">Models and Collections</em></span> in place, and then create the <code class="email">view/frontend/layout/foggyline_office_test_crud.xml</code> file within the module root<a id="id292" class="calibre1"/> folder <code class="email">app/code/Foggyline/Office/</code> with content as follows:</p><div class="informalexample"><pre class="programlisting">&lt;page  layout="1column"
      xsi:noNamespaceSchemaLocation="urn:magento:framework:View /Layout/etc/page_configuration.xsd"&gt;
    &lt;head&gt;
        &lt;title&gt;Office CRUD #layout&lt;/title&gt;
    &lt;/head&gt;
    &lt;body&gt;
        &lt;container name="foobar" htmlTag="div" htmlClass="foo- bar"&gt;
            &lt;block class="Magento\Framework\View\Element\Text" name="foo"&gt;
                &lt;action method="setText"&gt;
                    &lt;argument name="text" xsi:type="string"&gt; &lt;![CDATA[&lt;p&gt;The Foo&lt;/p&gt;]]&gt;&lt;/argument&gt;
                &lt;/action&gt;
            &lt;/block&gt;
            &lt;block class="Magento\Framework\View\Element\Text" name="bar"&gt;
                &lt;action method="setText"&gt;
                    &lt;argument name="text" xsi:type="string"&gt; &lt;![CDATA[&lt;p&gt;The Bar&lt;/p&gt;]]&gt;&lt;/argument&gt;
                &lt;/action&gt;
            &lt;/block&gt;
        &lt;/container&gt;
    &lt;/body&gt;
&lt;/page&gt;</pre></div><p class="calibre7">The preceding XML defines a single container named <code class="email">foobar</code>, and within the container there are two block elements named <code class="email">foo</code> and <code class="email">bar</code>. It should kick in when we open <code class="email">http://{our-shop-url}/index.php/foggyline_office/test/crud/</code> in the browser.</p><p class="calibre7">Notice how the container itself is not nested within any other element, rather directly into the body. We could have easily nested into some other container as shown:</p><div class="informalexample"><pre class="programlisting">&lt;body&gt;
    &lt;referenceContainer name="content"&gt;
        &lt;container name="foobar" htmlTag="div" htmlClass="foo- bar"&gt;</pre></div><p class="calibre7">Either way, we should see the strings <span class="strong"><strong class="calibre8">The Foo</strong></span> and <span class="strong"><strong class="calibre8">The Bar</strong></span> shown in the browser, with a full-page layout loaded, as shown in the following screenshot:</p><div class="mediaobject"><img src="../images/00053.jpeg" alt="Containers" class="calibre10"/></div><p class="calibre11"> </p></div></div>

<div class="book" title="View elements">
<div class="book" title="Blocks"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_3"><a id="ch08lvl2sec23" class="calibre1"/>Blocks</h2></div></div></div><p class="calibre7">Although <a id="id293" class="calibre1"/>containers determine the layout of the page, they do not contain <a id="id294" class="calibre1"/>actual content directly. Pieces that contain the content and are nested within containers are called <span class="strong"><strong class="calibre8">blocks</strong></span>. Each block can contain any number of child content blocks or child containers. Thus, mostly every web page in Magento is formed as a mix of blocks and containers. Layout defines a sequence of blocks on the page, not their location. The look and feel of the blocks is determined by CSS and how the page is rendered. When we speak of blocks, we almost always implicitly refer to templates as well. Templates are the thing that actually draw elements within a page; blocks are the thing that contain the data. In other words, templates are PHTML or HTML files pulling data through variables or methods sent on a linked PHP block class.</p><p class="calibre7">Magento defines the <code class="email">Magento\Framework\View\Result\Page</code> type under <code class="email">app/etc/di.xml</code> as follows:</p><div class="informalexample"><pre class="programlisting">&lt;type name="Magento\Framework\View\Result\Page"&gt;
    &lt;arguments&gt;
        &lt;argument name="layoutReaderPool" xsi:type="object"&gt;pageConfigRenderPool&lt;/argument&gt;
        &lt;argument name="generatorPool" xsi:type="object"&gt;pageLayoutGeneratorPool&lt;/argument&gt;
        &lt;argument name="template" xsi:type="string"&gt;Magento_Theme::root.phtml&lt;/argument&gt;
    &lt;/arguments&gt;
&lt;/type&gt;</pre></div><p class="calibre7">Notice the template argument is set to <code class="email">Magento_Theme::root.phtml</code>. When <code class="email">Page</code> gets initialized, it picks up the <code class="email">vendor/magento/module-theme/view/base/templates/root.phtml</code> file. <code class="email">root.phtml</code> is defined as follows:</p><div class="informalexample"><pre class="programlisting">&lt;!doctype html&gt;
&lt;html &lt;?php echo $htmlAttributes ?&gt;&gt;
    &lt;head &lt;?php echo $headAttributes ?&gt;&gt;
        &lt;?php echo $requireJs ?&gt;
        &lt;?php echo $headContent ?&gt;
        &lt;?php echo $headAdditional ?&gt;
    &lt;/head&gt;
    &lt;body data-container="body" data-mage-init='{"loaderAjax": {}, "loader": { "icon": "&lt;?php echo $loaderIcon; ?&gt;"}}' &lt;?php echo $bodyAttributes ?&gt;&gt;
        &lt;?php echo $layoutContent ?&gt;
    &lt;/body&gt;
&lt;/html&gt;</pre></div><p class="calibre7">Variables <a id="id295" class="calibre1"/>within <code class="email">root.phtml</code> are assigned during the <code class="email">Magento\Framework\View\Result\Page</code> render <a id="id296" class="calibre1"/>method call as (partially) as shown:</p><div class="informalexample"><pre class="programlisting">protected function render(ResponseInterface $response)
{
    $this-&gt;pageConfig-&gt;publicBuild();
    if ($this-&gt;getPageLayout()) {
        $config = $this-&gt;getConfig();
        $this-&gt;addDefaultBodyClasses();
        $addBlock = $this-&gt;getLayout()-&gt;getBlock ('head.additional');
        $requireJs = $this-&gt;getLayout()-&gt;getBlock('require.js');
        $this-&gt;assign([
            'requireJs' =&gt; $requireJs ? $requireJs-&gt;toHtml() : null,
            'headContent' =&gt; $this-&gt;pageConfigRenderer-&gt; renderHeadContent(),
            'headAdditional' =&gt; $addBlock ? $addBlock-&gt;toHtml() : null,
            'htmlAttributes' =&gt; $this-&gt;pageConfigRenderer-&gt; renderElementAttributes($config::ELEMENT_TYPE_HTML),
            'headAttributes' =&gt; $this-&gt;pageConfigRenderer-&gt; renderElementAttributes($config::ELEMENT_TYPE_HEAD),
            'bodyAttributes' =&gt; $this-&gt;pageConfigRenderer-&gt; renderElementAttributes($config::ELEMENT_TYPE_BODY),
            'loaderIcon' =&gt; $this-&gt;getViewFileUrl('images/loader- 2.gif'),
        ]);

        $output = $this-&gt;getLayout()-&gt;getOutput();
        $this-&gt;assign('layoutContent', $output);
        $output = $this-&gt;renderPage();
        $this-&gt;translateInline-&gt;processResponseBody($output);
        $response-&gt;appendBody($output);
    } else {
        parent::render($response);
    }
    return $this;
}</pre></div><p class="calibre7">The expression <code class="email">$this-&gt;assign</code> is what assigns variables like <code class="email">layoutContent</code> to the <code class="email">root.phtml</code> template. <code class="email">layoutContent</code> is generated based on base layouts, together with all layout updates for the current page.</p><p class="calibre7">Whereas base layouts include the following XMLs within <code class="email">vendor/magento/module-theme/view/</code>:</p><div class="book"><ul class="itemizedlist"><li class="listitem"><code class="email">base/page_layout/empty.xml</code></li><li class="listitem"><code class="email">frontend/page_layout/1column.xml</code></li><li class="listitem"><code class="email">frontend/page_layout/2columns-left.xml</code></li><li class="listitem"><code class="email">frontend/page_layout/2columns-right.xml</code></li><li class="listitem"><code class="email">frontend/page_layout/3columns.xml</code></li></ul></div><p class="calibre7">The <a id="id297" class="calibre1"/>expression <code class="email">$this-&gt;getLayout()-&gt;getOutput()</code> is what gets<a id="id298" class="calibre1"/> all blocks marked for output. It basically finds elements in a layout, renders them, and returns the string with its output. Along the way, the event <code class="email">core_layout_render_element</code> gets fired, giving us one possible way of affecting the output result. At this point, most of the elements on the page are rendered. This is important because blocks play a big role here. The rendering system will take <code class="email">empty.xml</code> into account, as it too consists of a list of containers, and every container has some blocks attached to it by other layout updates.</p><div class="informalexample" title="Note"><h3 class="title2"><a id="note16" class="calibre1"/>Note</h3><p class="calibre7">In a nutshell, each container has blocks assigned to it. Each block usually (but not always) renders a template. The template itself may or may not call other blocks, and so on. Blocks are rendered when they are called from the template.</p></div></div></div>

<div class="book" title="View elements">
<div class="book" title="Block architecture and life cycle"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_4"><a id="ch08lvl2sec24" class="calibre1"/>Block architecture and life cycle</h2></div></div></div><p class="calibre7">Blocks<a id="id299" class="calibre1"/> are another one of the primary view elements<a id="id300" class="calibre1"/> in Magento. At the root of the parent tree structure, blocks extend from the <code class="email">Magento\Framework\View\Element\AbstractBlock</code> class and implement <code class="email">Magento\Framework\View\Element\BlockInterface</code>.</p><p class="calibre7"><code class="email">BlockInterface</code> sets only one requirement, the implementation of the <code class="email">toHtml</code> method. This method should return blocks HTML output.</p><p class="calibre7">Looking inside <code class="email">AbstractBlock</code>, we can see it has a number of methods declared. Among the most important ones are the following methods:</p><div class="book"><ul class="itemizedlist"><li class="listitem"><code class="email">_prepareLayout</code>: Prepares a global layout. We can redefine this method in child classes for changing the layout.</li><li class="listitem"><code class="email">addChild</code>: Creates a new block, sets it as a child of the current block, and returns the newly created block.</li><li class="listitem"><code class="email">_toHtml</code>: Returns an empty string. We need to override this method in descendants to produce HTML.</li><li class="listitem"><code class="email">_beforeToHtml</code>: Returns <code class="email">$this</code>. Executes before rendering HTML, but after trying to load a cache.</li><li class="listitem"><code class="email">_afterToHtml</code>: Processing block HTML after rendering. Returns a HTML string.</li><li class="listitem"><code class="email">toHtml:</code> Produces and returns a block's HTML output. This method should not be overridden. We can override the <code class="email">_toHtml</code> method in descendants if needed.</li></ul></div><p class="calibre7">The <code class="email">AbstractBlock</code> execution flow can be described as follows:</p><div class="book"><ul class="itemizedlist"><li class="listitem"><code class="email">_prepareLayout</code></li><li class="listitem"><code class="email">toHtml</code></li><li class="listitem"><code class="email">_beforeToHtml</code></li><li class="listitem"><code class="email">_toHtml</code></li><li class="listitem"><code class="email">_afterToHtml</code></li></ul></div><p class="calibre7">It<a id="id301" class="calibre1"/> starts with <code class="email">_prepareLayout</code> and flows through a<a id="id302" class="calibre1"/> set of methods until it reaches <code class="email">_afterToHtml</code>. This is, in essence, what we need to know about block execution flow.</p><p class="calibre7">The most important block types are:</p><div class="book"><ul class="itemizedlist"><li class="listitem"><code class="email">Magento\Framework\View\Element\Text</code></li><li class="listitem"><code class="email">Magento\Framework\View\Element\Text\ListText</code></li><li class="listitem"><code class="email">Magento\Framework\View\Element\Messages</code></li><li class="listitem"><code class="email">Magento\Framework\View\Element\Template</code></li></ul></div><p class="calibre7">All of these blocks are basically an implementation of an abstract block. Since the <code class="email">_toHtml</code> method in <code class="email">AbstractBlock</code> returns only an empty string, all of these descendants are implementing their own version of the <code class="email">_toHtml</code> method.</p><p class="calibre7">To demonstrate the usage of these blocks, we can use our previously created <code class="email">app/code/Foggyline/Office/view/frontend/layout/foggyline_office_test_crud.xml</code> file.</p><p class="calibre7">The <code class="email">Text</code> block has a <code class="email">setText</code> method we can use to set its content. The way we instantiate the <code class="email">Text</code> block and set its text value through the layout file is shown as follows:</p><div class="informalexample"><pre class="programlisting">&lt;block class="Magento\Framework\View\Element\Text" name="example_1"&gt;
    &lt;action method="setText"&gt;
        &lt;argument name="text" xsi:type="string"&gt;&lt;![CDATA[&lt;p&gt;Text_1&lt;/p&gt;]]&gt;&lt;/argument&gt;
    &lt;/action&gt;
&lt;/block&gt;</pre></div><p class="calibre7">The <code class="email">ListText</code> block extends from <code class="email">Text</code>. However, it does not really support the use of <code class="email">setText</code> to set its content. This is obvious just by looking at its code, where the <code class="email">$this-&gt;setText('')</code> expression is immediately called within its <code class="email">_toHtml</code> method implementation. Instead, what happens is that the <code class="email">_toHtml</code> method loops through any child <a id="id303" class="calibre1"/>blocks it might have and calls the layout's <code class="email">renderElement</code> method on it. Basically, we might compare the <code class="email">ListText</code> block to <code class="email">container</code>, as<a id="id304" class="calibre1"/> it has nearly the same purpose. However, unlike container, block is a class so we can manipulate it from PHP. The following is an example of using <code class="email">ListText</code>, containing a few child <code class="email">Text</code> blocks:</p><div class="informalexample"><pre class="programlisting">&lt;block class="Magento\Framework\View\Element\Text\ListText" name="example_2"&gt;
    &lt;block class="Magento\Framework\View\Element\Text" name="example_2a"&gt;
        &lt;action method="setText"&gt;
            &lt;argument name="text" xsi:type="string"&gt; &lt;![CDATA[&lt;p&gt;Text_2A&lt;/p&gt;]]&gt;&lt;/argument&gt;
        &lt;/action&gt;
    &lt;/block&gt;
    &lt;block class="Magento\Framework\View\Element\Text" name="example_2b"&gt;
        &lt;action method="setText"&gt;
            &lt;argument name="text" xsi:type="string"&gt; &lt;![CDATA[&lt;p&gt;Text_2B&lt;/p&gt;]]&gt;&lt;/argument&gt;
        &lt;/action&gt;
    &lt;/block&gt;
&lt;/block&gt;</pre></div><p class="calibre7">The <code class="email">Messages</code> block supports four methods that we can use to add content to output: <code class="email">addSuccess</code>, <code class="email">addNotice</code>, <code class="email">addWarning</code>, and <code class="email">addError</code>. The following is an example instantiating the <code class="email">Messages</code> block through the layout update file:</p><div class="informalexample"><pre class="programlisting">&lt;block class="Magento\Framework\View\Element\Messages" name="example_3"&gt;
    &lt;action method="addSuccess"&gt;
        &lt;argument name="text" xsi:type="string"&gt; &lt;![CDATA[&lt;p&gt;Text_3A: Success&lt;/p&gt;]]&gt;&lt;/argument&gt;
    &lt;/action&gt;
    &lt;action method="addNotice"&gt;
        &lt;argument name="text" xsi:type="string"&gt; &lt;![CDATA[&lt;p&gt;Text_3B: Notice&lt;/p&gt;]]&gt;&lt;/argument&gt;
    &lt;/action&gt;
    &lt;action method="addWarning"&gt;
        &lt;argument name="text" xsi:type="string"&gt; &lt;![CDATA[&lt;p&gt;Text_3C: Warning&lt;/p&gt;]]&gt;&lt;/argument&gt;
    &lt;/action&gt;
    &lt;action method="addError"&gt;
        &lt;argument name="text" xsi:type="string"&gt; &lt;![CDATA[&lt;p&gt;Text_3D: Error&lt;/p&gt;]]&gt;&lt;/argument&gt;
    &lt;/action&gt;
&lt;/block&gt;</pre></div><p class="calibre7">The preceding <a id="id305" class="calibre1"/>example should be taken with caution, since <a id="id306" class="calibre1"/>calling these setter methods in layout is not the proper way to do it. The default <code class="email">Magento_Theme</code> module already defines the <code class="email">Messages</code> block that uses <code class="email">vendor/magento/module-theme/view/frontend/templates/messages.phtml</code> for message rendering. Thus, for most of the part there is no need to define our own messages block.</p><p class="calibre7">Finally, let's look at the example of the <code class="email">Template</code> block as follows:</p><div class="informalexample"><pre class="programlisting">&lt;block class="Magento\Framework\View\Element\Template"
    name="example_4" template="Foggyline_Office::office /no4/template.phtml"/&gt;</pre></div><p class="calibre7">The preceding XML will instantiate the <code class="email">Template</code> type of block and render the content of the <code class="email">view/frontend/templates/office/no4/template.phtml</code> file within the <code class="email">app/code/Foggyline/Office/</code> directory.</p><p class="calibre7">On the PHP level, instantiating a new block can be accomplished using the layout object, or directly through the object manager. The layout approach is the preferred way. With regard to the previous examples in XML, let's see their alternatives in PHP (assuming <code class="email">$resultPage</code> is an instance of <code class="email">\Magento\Framework\View\Result\PageFactory</code>).</p><p class="calibre7">The following is an example of instantiating the <code class="email">Text</code> type of block and adding it as a child of the content container:</p><div class="informalexample"><pre class="programlisting">$block = $resultPage-&gt;getLayout()-&gt;createBlock(
    'Magento\Framework\View\Element\Text',
    'example_1'
)-&gt;setText(
    '&lt;p&gt;Text_1&lt;/p&gt;'
);

$resultPage-&gt;getLayout()-&gt;setChild(
    'content',
    $block-&gt;getNameInLayout(),
    'example_1_alias'
);</pre></div><p class="calibre7">The <code class="email">ListText</code> version is done in PHP as follows:</p><div class="informalexample"><pre class="programlisting">$blockLT = $resultPage-&gt;getLayout()-&gt;createBlock(
    'Magento\Framework\View\Element\Text\ListText',
    'example_2'
);

$resultPage-&gt;getLayout()-&gt;setChild(
    'content',
    $blockLT-&gt;getNameInLayout(),
    'example_2_alias'
);

$block2A = $resultPage-&gt;getLayout()-&gt;createBlock(
    'Magento\Framework\View\Element\Text',
    'example_2a'
)-&gt;setText(
    '&lt;p&gt;Text_2A&lt;/p&gt;'
);

$resultPage-&gt;getLayout()-&gt;setChild(
    'example_2',
    $block2A-&gt;getNameInLayout(),
    'example_2a_alias'
);

$block2B = $resultPage-&gt;getLayout()-&gt;createBlock(
    'Magento\Framework\View\Element\Text',
    'example_2b'
)-&gt;setText(
    '&lt;p&gt;Text_2B&lt;/p&gt;'
);

$resultPage-&gt;getLayout()-&gt;setChild(
    'example_2',
    $block2B-&gt;getNameInLayout(),
    'example_2b_alias'
);</pre></div><p class="calibre7">Notice <a id="id307" class="calibre1"/>how we first made an instance of the <code class="email">ListText</code> block<a id="id308" class="calibre1"/> and assigned it as a child of an element named content. Then we created two individual <code class="email">Text</code> blocks and assigned them as a child of an element named <code class="email">example_2</code>, which is our <code class="email">ListText</code>.</p><p class="calibre7">Next, let's define the <code class="email">Messages</code> block as follows:</p><div class="informalexample"><pre class="programlisting">$messagesBlock = $resultPage-&gt;getLayout()-&gt;createBlock(
    'Magento\Framework\View\Element\Messages',
    'example_3'
);

$messagesBlock-&gt;addSuccess('Text_3A: Success');
$messagesBlock-&gt;addNotice('Text_3B: Notice');
$messagesBlock-&gt;addWarning('Text_3C: Warning');
$messagesBlock-&gt;addError('Text_3D: Error');

$resultPage-&gt;getLayout()-&gt;setChild(
    'content',
    $messagesBlock-&gt;getNameInLayout(),
    'example_3_alias'
);</pre></div><p class="calibre7">Finally, let's<a id="id309" class="calibre1"/> look at the <code class="email">Template</code> block type, which we<a id="id310" class="calibre1"/> initiate as follows:</p><div class="informalexample"><pre class="programlisting">$templateBlock = $resultPage-&gt;getLayout()-&gt;createBlock(
    'Magento\Framework\View\Element\Template',
    'example_3'
)-&gt;setTemplate(
    'Foggyline_Office::office/no4/template.phtml'
);

$resultPage-&gt;getLayout()-&gt;setChild(
    'content',
    $templateBlock-&gt;getNameInLayout(),
    'example_4_alias'
);</pre></div><p class="calibre7">Whenever possible, we should set our blocks using XML layouts.</p><p class="calibre7">Now that we know how to utilize the most common types of Magento blocks, let's see how we can create our own block type.</p><p class="calibre7">Defining our own <code class="email">block</code> class is as simple as creating a custom class file that extends <code class="email">Template</code>. This <code class="email">block</code> class should be placed under our module <code class="email">Block</code> directory. Using our <code class="email">Foggyline_Office</code> module, let's create a file, <code class="email">Block/Hello.php</code>, with content as follows:</p><div class="informalexample"><pre class="programlisting">namespace Foggyline\Office\Block;

class Hello extends \Magento\Framework\View\Element\Template
{
    public function helloPublic()
    {
        return 'Hello #1';
    }

    protected function helloProtected()
    {
        return 'Hello #2';
    }

    private function helloPrivate()
    {
        return 'Hello #3';
    }
}</pre></div><p class="calibre7">The<a id="id311" class="calibre1"/> preceding code simply creates a new custom block <a id="id312" class="calibre1"/>class. We can then call this <code class="email">block</code> class through our layout file as follows:</p><div class="informalexample"><pre class="programlisting">&lt;block class="Foggyline\Office\Block\Hello"
    name="office.hello" template="office/hello.phtml"/&gt;</pre></div><p class="calibre7">Finally, within our module <code class="email">app/code/Foggyline/Office/</code> directory, we create a template file, <code class="email">view/frontend/templates/office/hello.phtml</code>, with content as follows:</p><div class="informalexample"><pre class="programlisting">&lt;?php /* @var $block Foggyline\Office\Block\Hello */ ?&gt;
&lt;h1&gt;Hello&lt;/h1&gt;
&lt;p&gt;&lt;?php echo $block-&gt;helloPublic() ?&gt;&lt;/p&gt;
&lt;p&gt;&lt;?php //echo $block-&gt;helloProtected() ?&gt;&lt;/p&gt;
&lt;p&gt;&lt;?php //echo $block-&gt;helloPrivate() ?&gt;&lt;/p&gt;</pre></div><p class="calibre7">To further understand what is happening here within the template file, let's take a deeper look at templates themselves.</p></div></div>

<div class="book" title="View elements">
<div class="book" title="Templates"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_5"><a id="ch08lvl2sec25" class="calibre1"/>Templates</h2></div></div></div><p class="calibre7"><span class="strong"><strong class="calibre8">Templates</strong></span> <a id="id313" class="calibre1"/>are snippets of HTML mixed with PHP. The PHP part includes<a id="id314" class="calibre1"/> elements such as variables, expressions, and <code class="email">class</code> method calls. Magento uses the PHTML file extension for template files. Templates are located under an individual module's <code class="email">view/{_area_}/templates/ directory</code>.</p><p class="calibre7">In our previous example, we referred to our module template file with an expression like <code class="email">Foggyline_Office::office/hello.phtml</code>. Since templates can belong to different modules, we should prepend the template with the module name as a best practice. This will help us locate template files and avoid file conflicts.</p><p class="calibre7">A simple naming formula goes like this: we type the name of the module, double single colon, and then the name. Thus making a template path like <code class="email">office/hello.phtml</code> equaling to <code class="email">Foggyline_Office::office/hello.phtml</code>.</p><p class="calibre7">Within the PHTML template file we often have various PHP expressions like <code class="email">$block-&gt;helloPublic()</code>. Notice the block class <code class="email">Foggyline\Office\Block\Hello</code> in the preceding XML. An instance of this block class becomes available to us in <code class="email">hello.phtml</code> through the <code class="email">$block</code> variable. Thus, an expression like <code class="email">$block-&gt;helloPublic()</code> is effectively<a id="id315" class="calibre1"/> calling the <code class="email">helloPublic</code> method from an instance <a id="id316" class="calibre1"/>of the <code class="email">Hello</code> class. The <code class="email">Hello</code> class is not one of the Magento core classes, but it does extend <code class="email">\Magento\Framework\View\Element\Template</code>.</p><p class="calibre7">Our <code class="email">hello.phtml</code> template also has two more expressions: <code class="email">$block-&gt;helloProtected()</code> and <code class="email">$block-&gt;helloPrivate()</code>. However, these are not executed as template files can only see public methods from their <code class="email">$block</code> instances.</p><p class="calibre7">The <code class="email">$this</code> variable is also available within the PHTML template as an instance of the <code class="email">Magento\Framework\View\TemplateEngine\Php</code> class.</p><p class="calibre7">In the preceding template code example, we could have easily replaced <code class="email">$block-&gt;helloPublic()</code> with the <code class="email">$this-&gt;helloPublic()</code> expression. The reason why this would work lies in the template engine <code class="email">Php</code> class, (partially) defined as follows:</p><div class="informalexample"><pre class="programlisting">public function __call($method, $args)
{
    return call_user_func_array([$this-&gt;_currentBlock, $method], $args);
}

public function __isset($name)
{
    return isset($this-&gt;_currentBlock-&gt;{$name});
}

public function __get($name)
{
    return $this-&gt;_currentBlock-&gt;{$name};
}</pre></div><p class="calibre7">Given that templates are included in the context of the engine rather than in the context of the block, <code class="email">__call</code> redirects methods calls to the current block. Similarly, <code class="email">__isset</code> redirects <code class="email">isset</code> calls to the current block and <code class="email">__get</code> allows read access to properties of the current block.</p><p class="calibre7">Though we can use both <code class="email">$block</code> and <code class="email">$this</code> for the same purpose within the template file, we should really opt for using <code class="email">$block</code>.</p><p class="calibre7">Another important aspect of templates is their fallback mechanism. Fallback is the process of defining a full template path given only its relative path. For example, <code class="email">office/hello.phtml</code> falls back to the <code class="email">app/code/Foggyline/Office/view/frontend/templates/office/hello.phtml</code> file.</p><p class="calibre7">Path resolution<a id="id317" class="calibre1"/> starts from the _<code class="email">toHtml</code> method defined on<a id="id318" class="calibre1"/> the <code class="email">Magento\Framework\View\Element\Template</code> class. The _<code class="email">toHtml</code> method then calls <code class="email">getTemplateFile</code> within the same class, which in turn calls <code class="email">getTemplateFileName</code> on <code class="email">resolver</code>, which is an instance of <code class="email">\Magento\Framework\View\Element\Template\File\Resolver</code>. Looking further, resolver's <code class="email">getTemplateFileName</code> further calls <code class="email">getTemplateFileName</code> on <code class="email">_viewFileSystem</code>, which is an instance of <code class="email">\Magento\Framework\View\FileSystem</code>. The method <code class="email">getFile</code> is further called on an instance of <code class="email">\Magento\Framework\View\Design\FileResolution\Fallback\TemplateFile</code>. <code class="email">getFile</code> further triggers the resolve method on the <code class="email">Magento\Framework\View\Design\FileResolution\Fallback\Resolver\Simple</code> instance, which further calls the <code class="email">getRule</code> method on the <code class="email">Magento\Framework\View\Design\Fallback\RulePool</code> instance. The <code class="email">RulePoll</code> class is the final class in the chain here. <code class="email">getRule</code> finally calls the <code class="email">createTemplateFileRule</code> method, which creates the rule that detects where the file is located.</p><p class="calibre7">While running the <code class="email">getRule</code> method, Magento checks against the following types of fallback rules:</p><div class="book"><ul class="itemizedlist"><li class="listitem"><code class="email">file</code></li><li class="listitem"><code class="email">locale</code></li><li class="listitem"><code class="email">template</code></li><li class="listitem"><code class="email">static</code></li><li class="listitem"><code class="email">email</code></li></ul></div><p class="calibre7">It is worth spending some time to study the inner workings of the <code class="email">RulePool</code> class, as it showcases detailed fallbacks for the listed rules.</p></div></div>

<div class="book" title="View elements">
<div class="book" title="Layouts"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_6"><a id="ch08lvl2sec26" class="calibre1"/>Layouts</h2></div></div></div><p class="calibre7">Up to <a id="id319" class="calibre1"/>this<a id="id320" class="calibre1"/> point, we briefly touched on layout XMLs. Layout XML is a tool to build the pages of the Magento application in a modular and flexible manner. It enables us to describe the page layout and content placement. Looking at XML root nodes, we differentiate two types of layouts:</p><div class="book"><ul class="itemizedlist"><li class="listitem"><code class="email">layout</code>: XML wrapped in <code class="email">&lt;layout&gt;</code></li><li class="listitem"><code class="email">page</code>: XML wrapped in <code class="email">&lt;page&gt;</code></li></ul></div><p class="calibre7"><code class="email">Page</code> layouts<a id="id321" class="calibre1"/> represent a full page in HTML, whereas <code class="email">layout</code> layouts represent a part of a page. The <code class="email">layout</code> type is a subset of the <code class="email">page</code> layout type. Both types of layout XML files are validated by the XSD schema found under the <code class="email">vendor/magento/framework/View/Layout/etc/</code> directory:</p><div class="book"><ul class="itemizedlist"><li class="listitem"><code class="email">layout</code> – <code class="email">layout_generic.xsd</code></li><li class="listitem"><code class="email">page</code> – <code class="email">page_configuration.xsd</code></li></ul></div><p class="calibre7">Based on<a id="id322" class="calibre1"/> the application components that provide <code class="email">&lt;layout&gt; </code>and <code class="email">&lt;page&gt; </code>elements , we can further section them as base and theme layouts.</p><p class="calibre7">The base layouts are provided by the modules, usually at the following locations:</p><div class="book"><ul class="itemizedlist"><li class="listitem"><code class="email">&lt;module_dir&gt;/view/frontend/layout</code>: page configuration and generic layout files</li><li class="listitem"><code class="email">&lt;module_dir&gt;/view/frontend/page_layout</code>: page layout files</li></ul></div><p class="calibre7">The theme layouts are provided by the themes, usually at the following locations:</p><div class="book"><ul class="itemizedlist"><li class="listitem"><code class="email">&lt;theme_dir&gt;/&lt;Namespace&gt;_&lt;Module&gt;/layout</code>: page configuration and generic layout files</li><li class="listitem"><code class="email">&lt;theme_dir&gt;/&lt;Namespace&gt;_&lt;Module&gt;/page_layout</code>: page layout files</li></ul></div><p class="calibre7">Magento will load and merge all module and theme XML files on the appropriate page. Once files are merged and XML instructions are processed, the result is rendered and sent to the browser for display. Having two different layout XML files, where both reference the same block, means that the second one with the same name in the sequence will replace the first one.</p><p class="calibre7">When the XML files are loaded, Magento applies an inheritance theme at the same time. We can apply a theme and it will look for the parent until a theme without a parent is reached.</p><p class="calibre7">In addition to the merging of files from each module, layout files from within module directories can also be extended or overridden by themes. Overriding layout XML is not a good practice, but it might be necessary sometimes.</p><p class="calibre7">To <span class="strong"><em class="calibre9">override</em></span> the base layout files provided by the module within the <code class="email">&lt;module_dir&gt;/view/frontend/layout/</code>directory.</p><p class="calibre7">We need to create an XML file with the same name in the <code class="email">app/design/frontend/&lt;vendor&gt;/&lt;theme&gt;/&lt;Namespace_Module&gt;/layout/override/base/</code>directory.</p><p class="calibre7">To <span class="strong"><em class="calibre9">override</em></span> the theme layout files provided by the parent theme within the &lt;<code class="email">parent_theme_dir&gt;/&lt;Namespace&gt;_&lt;Module&gt;/layout/</code>directory.</p><p class="calibre7">We need to create an XML file with the same name in the <code class="email">app/design/frontend/&lt;vendor&gt;/&lt;theme &gt;/&lt;Namespace_Module&gt;/layout/override/theme/&lt;Parent_Vendor&gt;/&lt;parent_theme&gt;/</code>directory.</p><p class="calibre7">Layouts can be both overridden and extended.</p><p class="calibre7">The recommended way to customize layout is to extend it through a custom theme. We can do so by simply adding a custom XML layout file with the same name in the <code class="email">app/design/frontend/{vendorName}/{theme}/{vendorName}_{moduleName}/layout/</code> directory.</p><p class="calibre7">Layouts, as <a id="id323" class="calibre1"/>we saw in previous examples, support a large number <a id="id324" class="calibre1"/>of directives: page page, head, block, and so on. The practical use of these directives and how they mix together is a challenge on its own. Giving full details on each and every directive is beyond the scope of this book. However, what we can do is to show how to figure out the use of an individual directive, which we might need at a given time. For that purpose, it is highly recommended to use an IDE<a id="id325" class="calibre1"/> environment like <span class="strong"><strong class="calibre8">NetBeans PHP</strong></span> or <span class="strong"><strong class="calibre8">PhpStorm</strong></span> that <a id="id326" class="calibre1"/>provide autocomplete on XMLs that include XSD.</p><p class="calibre7">The following is an example of defining an external schema to PhpStorm, where we are simply saying that the <code class="email">urn:magento:framework:View/Layout/etc/page_configuration.xsd</code> alias belongs to the <code class="email">vendor/magento/framework/View/Layout/etc/page_configuration.xsd</code> file:</p><div class="mediaobject"><img src="../images/00054.jpeg" alt="Layouts" class="calibre10"/></div><p class="calibre11"> </p><p class="calibre7">This way, PhpStorm will know how to provide autocomplete while we type around XML files.</p><p class="calibre7">As an example, let's take a look at how we could use the <code class="email">css</code> directive to add an external CSS file to our page. With an IDE that supports autocomplete as soon as we type the <code class="email">css</code> directive within the <code class="email">page</code> | <code class="email">head</code> element, autocomplete might throw out something like the following:</p><div class="mediaobject"><img src="../images/00055.jpeg" alt="Layouts" class="calibre10"/></div><p class="calibre11"> </p><p class="calibre7">A list of <a id="id327" class="calibre1"/>available attributes is shown, such as <code class="email">src</code>, <code class="email">sizes</code>, <code class="email">ie_condtion</code>, <code class="email">src_type</code>, and so on. IDEs like PhpStorm will allow us to right-click an element <a id="id328" class="calibre1"/>or its attribute and <span class="strong"><em class="calibre9">go to the definition</em></span>. Looking into the definition for the <code class="email">src</code> attribute gets us into the <code class="email">vendor/magento/framework/View/Layout/etc/head.xsd</code> file that defines the <code class="email">css</code> element as follows:</p><div class="informalexample"><pre class="programlisting">&lt;xs:complexType name="linkType"&gt;
    &lt;xs:attribute name="src" type="xs:string" use="required"/&gt;
    &lt;xs:attribute name="defer" type="xs:string"/&gt;
    &lt;xs:attribute name="ie_condition" type="xs:string"/&gt;
    &lt;xs:attribute name="charset" type="xs:string"/&gt;
    &lt;xs:attribute name="hreflang" type="xs:string"/&gt;
    &lt;xs:attribute name="media" type="xs:string"/&gt;
    &lt;xs:attribute name="rel" type="xs:string"/&gt;
    &lt;xs:attribute name="rev" type="xs:string"/&gt;
    &lt;xs:attribute name="sizes" type="xs:string"/&gt;
    &lt;xs:attribute name="target" type="xs:string"/&gt;
    &lt;xs:attribute name="type" type="xs:string"/&gt;
    &lt;xs:attribute name="src_type" type="xs:string"/&gt;
&lt;/xs:complexType&gt;</pre></div><p class="calibre7">All of these are attributes we can set on the <code class="email">css</code> element, and as such get their autocomplete as shown:</p><div class="mediaobject"><img src="../images/00056.jpeg" alt="Layouts" class="calibre10"/></div><p class="calibre11"> </p><p class="calibre7">Although it is<a id="id329" class="calibre1"/> not required to use a robust IDE with Magento, it<a id="id330" class="calibre1"/> certainly helps to have one that understands XML and XSD files to the level of providing autocomplete and validation.</p></div></div>

<div class="book" title="View elements">
<div class="book" title="Themes"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_7"><a id="ch08lvl2sec27" class="calibre1"/>Themes</h2></div></div></div><p class="calibre7">By default, Magento <a id="id331" class="calibre1"/>comes<a id="id332" class="calibre1"/> with two themes, named <code class="email">Blank</code> and <code class="email">Luma</code>. If we log in to the Magento admin area, we can see a list of available themes under the <span class="strong"><strong class="calibre8">Content</strong></span> | <span class="strong"><strong class="calibre8">Design</strong></span> | <span class="strong"><strong class="calibre8">Themes</strong></span> menu, as shown in the following screenshot:</p><div class="mediaobject"><img src="../images/00057.jpeg" alt="Themes" class="calibre10"/></div><p class="calibre11"> </p><p class="calibre7">Magento themes support a parent-child relationship, something we noted previously, that is visible on the preceding image within the <span class="strong"><strong class="calibre8">Parent Theme</strong></span> column.</p><div class="book" title="Creating a new theme"><div class="book"><div class="book"><div class="book"><h3 class="title2"><a id="ch08lvl3sec10" class="calibre1"/>Creating a new theme</h3></div></div></div><p class="calibre7">The following<a id="id333" class="calibre1"/> steps outline the process of creating our own theme:</p><div class="book"><ol class="orderedlist"><li class="listitem" value="1">Under <code class="email">{Magento</code> <code class="email">root</code> <code class="email">directory}/app/design/frontend</code>, create a new directory bearing our vendor name, <code class="email">Foggyline</code>.</li><li class="listitem" value="2">Within the <code class="email">vendor</code> directory, create a new directory bearing the theme name, <code class="email">jupiter</code>.</li><li class="listitem" value="3">Within the <code class="email">jupiter</code> directory, create the <code class="email">registration.php</code> file with content as follows:<div class="informalexample"><pre class="programlisting">&lt;?php
\Magento\Framework\Component\ComponentRegistrar::register(
    \Magento\Framework\Component\ComponentRegistrar::THEME,
    'frontend/Foggyline/jupiter',
    __DIR__
);</pre></div></li><li class="listitem" value="4">Copy <code class="email">vendor/magento/theme-frontend-blank/theme.xml</code> into our theme, <code class="email">app/design/frontend/Foggyline/jupiter/theme.xml</code>, changing the content as follows:<div class="informalexample"><pre class="programlisting">&lt;theme  xsi:noNamespaceSchemaLocation="urn:magento: framework:Config/etc/theme.xsd"&gt;
    &lt;title&gt;Foggyline Jupiter&lt;/title&gt;
    &lt;parent&gt;Magento/blank&lt;/parent&gt;
    &lt;media&gt;
        &lt;preview_image&gt;media/preview.jpg&lt;/preview_image&gt;
    &lt;/media&gt;
&lt;/theme&gt;</pre></div></li><li class="listitem" value="5">Create the <code class="email">app/design/frontend/Foggyline/jupiter/media/preview.jpg</code> image file to serve as the theme preview image (the one used in the admin area).</li><li class="listitem" value="6">Optionally, create separate directories for static files such as styles, fonts, JavaScript, and images. These are stored within the <code class="email">web</code> subdirectory of our theme <code class="email">app/design/frontend/Foggyline/jupiter/</code> folder like follows:<div class="book"><ul class="itemizedlist1"><li class="listitem"><code class="email">web/css/</code></li><li class="listitem"><code class="email">web/css/source/</code></li><li class="listitem"><code class="email">web/css/source/components/</code></li><li class="listitem"><code class="email">web/images/</code></li><li class="listitem"><code class="email">web/js/</code></li></ul></div><p class="calibre15">Within the theme <code class="email">web</code> directory, we store general theme static files. If our theme contains module-specific static files, these are stored under the corresponding <code class="email">vendor</code> module subdirectories, like <code class="email">app/design/frontend/Foggyline/jupiter/{vendorName_moduleName}/web/</code>.</p></li><li class="listitem" value="7">Optionally, we can create the theme <code class="email">logo.svg</code> image under our theme <code class="email">web/images/</code> folder.</li></ol><div class="calibre14"/></div><p class="calibre7">Once <a id="id334" class="calibre1"/>we are done with the preceding steps, looking back into the admin area under the <span class="strong"><strong class="calibre8">Content</strong></span> | <span class="strong"><strong class="calibre8">Design</strong></span> | <span class="strong"><strong class="calibre8">Themes</strong></span> menu, we should now see our theme listed as shown in the following screenshot:</p><div class="mediaobject"><img src="../images/00058.jpeg" alt="Creating a new theme" class="calibre10"/></div><p class="calibre11"> </p><p class="calibre7">Whereas clicking on the row in the table next to our theme name would open a screen like the following:</p><div class="mediaobject"><img src="../images/00059.jpeg" alt="Creating a new theme" class="calibre10"/></div><p class="calibre11"> </p><p class="calibre7">Notice<a id="id335" class="calibre1"/> how the previous two screens do not show any options to apply the theme. They are only listing out available themes and some basic information next to each theme. Our custom theme shows an interesting relationship, where a parent and a child theme can belong to different vendors.</p><p class="calibre7">Applying the theme requires the following extra steps:</p><div class="book"><ol class="orderedlist"><li class="listitem" value="1">Make sure our theme appears in the theme list, under the <span class="strong"><strong class="calibre8">Content</strong></span> | <span class="strong"><strong class="calibre8">Design</strong></span> | <span class="strong"><strong class="calibre8">Themes</strong></span> menu.</li><li class="listitem" value="2">Go to <span class="strong"><strong class="calibre8">Stores</strong></span> | <span class="strong"><strong class="calibre8">Settings</strong></span> | <span class="strong"><strong class="calibre8">Configuration</strong></span> | <span class="strong"><strong class="calibre8">General</strong></span> | <span class="strong"><strong class="calibre8">Design</strong></span>.</li><li class="listitem" value="3">In the <span class="strong"><strong class="calibre8">Store View</strong></span> drop-down field, we select the store view where we want to apply the theme, as shown in the upper-left corner of the following image:<div class="mediaobject"><img src="../images/00060.jpeg" alt="Creating a new theme" class="calibre10"/></div><p class="calibre13"> </p></li><li class="listitem" value="4">On the <span class="strong"><strong class="calibre8">Design Theme</strong></span> tab, we select our newly created theme in the <span class="strong"><strong class="calibre8">Design Theme</strong></span> drop-down, as shown on the right-hand side of the preceding image. Click <span class="strong"><strong class="calibre8">Save Config</strong></span>.</li><li class="listitem" value="5">Under <span class="strong"><strong class="calibre8">System</strong></span> | <span class="strong"><strong class="calibre8">Tools</strong></span> | <span class="strong"><strong class="calibre8">Cache Management</strong></span>, select and refresh the invalid cache types and click on the <span class="strong"><strong class="calibre8">Flush Catalog Images Cache</strong></span>, <span class="strong"><strong class="calibre8">Flush JavaScript/CSS Cache</strong></span>, and <span class="strong"><strong class="calibre8">Flush Static Files Cache</strong></span> buttons.</li><li class="listitem" value="6">Finally, to see our changes applied, reload the storefront pages in the browser.</li></ol><div class="calibre14"/></div><p class="calibre7">There is<a id="id336" class="calibre1"/> a lot more to be said about themes that can fit in a book of its own. However, we will move on to the other important bits.</p></div></div></div>

<div class="book" title="View elements">
<div class="book" title="JavaScript"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_8"><a id="ch08lvl2sec28" class="calibre1"/>JavaScript</h2></div></div></div><p class="calibre7">Magento<a id="id337" class="calibre1"/> makes <a id="id338" class="calibre1"/>use <a id="id339" class="calibre1"/>of<a id="id340" class="calibre1"/> quite <a id="id341" class="calibre1"/>a<a id="id342" class="calibre1"/> large<a id="id343" class="calibre1"/> number <a id="id344" class="calibre1"/>of JavaScript<a id="id345" class="calibre1"/> libraries, such <a id="id346" class="calibre1"/>as:</p><div class="book"><ul class="itemizedlist"><li class="listitem">Knockout: <a class="calibre1" href="http://knockoutjs.com">http://knockoutjs.com</a></li><li class="listitem">Ext JS: <a class="calibre1" href="https://www.sencha.com/products/extjs/">https://www.sencha.com/products/extjs/</a></li><li class="listitem">jQuery: <a class="calibre1" href="https://jquery.com/">https://jquery.com/</a></li><li class="listitem">jQuery UI: <a class="calibre1" href="https://jqueryui.com/">https://jqueryui.com/</a></li><li class="listitem">modernizr: <a class="calibre1" href="http://www.modernizr.com/">http://www.modernizr.com/</a></li><li class="listitem">Prototype: <a class="calibre1" href="http://www.prototypejs.org/">http://www.prototypejs.org/</a></li><li class="listitem">RequireJS: <a class="calibre1" href="http://requirejs.org/">http://requirejs.org/</a></li><li class="listitem">script.aculo.us: <a class="calibre1" href="http://script.aculo.us/">http://script.aculo.us/</a></li><li class="listitem">moment.js: <a class="calibre1" href="http://momentjs.com/">http://momentjs.com/</a></li><li class="listitem">Underscore.js: <a class="calibre1" href="http://underscorejs.org/">http://underscorejs.org/</a></li><li class="listitem">gruntjs: <a class="calibre1" href="http://gruntjs.com/">http://gruntjs.com/</a></li><li class="listitem">AngularJS: <a class="calibre1" href="https://angularjs.org/">https://angularjs.org/</a></li><li class="listitem">jasmine: <a class="calibre1" href="http://jasmine.github.io/">http://jasmine.github.io/</a></li></ul></div><p class="calibre7">… and a few others</p><p class="calibre7">Though<a id="id347" class="calibre1"/> a<a id="id348" class="calibre1"/> frontend <a id="id349" class="calibre1"/>developer<a id="id350" class="calibre1"/> is <a id="id351" class="calibre1"/>not required to know the ins and outs of every library, it is recommended to at least have a basic insight into most of them.</p><div class="informalexample" title="Note"><h3 class="title2"><a id="tip14" class="calibre1"/>Tip</h3><p class="calibre7">It is worth running <code class="email">find</code> <code class="email">{MAGENTO-DIR}/</code> <code class="email">-name</code> <code class="email">\*.js</code> <code class="email">&gt;</code> <code class="email">js-list.txt</code> on the console to get a full list of each and every JavaScript file in Magento. Spending a few minutes glossing over the list might serve as a nice future memo when working with JavaScript bits in Magento.</p></div><p class="calibre7">The RequireJS and jQuery libraries are probably the <span class="strong"><em class="calibre9">most interesting</em></span> ones, as they often step into the spotlight during frontend development. RequireJS plays a big role in Magento, as it <a id="id352" class="calibre1"/>loads other JavaScript files. Using a modular script <a id="id353" class="calibre1"/>loader like RequireJS improves the speed of code. Speed improvement comes from removing JavaScript from the header and asynchronously or lazy loading JavaScript resources in the background.</p><p class="calibre7">JavaScript resources can be specified as follows:</p><div class="book"><ul class="itemizedlist"><li class="listitem">Library level for all libraries in the Magento code base (<code class="email">lib/web</code>).</li><li class="listitem">Module level for all libraries in a module (<code class="email">app/code/{vendorName}/{moduleName}/view/{area}/web</code>).</li><li class="listitem">Theme for all libraries in a theme (<code class="email">app/design/{area}/{vendorName}/{theme}/{vendorName}_{moduleName}/web</code>).</li><li class="listitem">All libraries in a theme (<code class="email">app/design/{area}/{vendorName}/{theme}/web</code>). Though possible, it is not recommended using this level to specify JavaScript resources.</li></ul></div><p class="calibre7">It is recommended to specify JavaScript resources in the templates rather than in the layout updates. This way, we ensure processing of the resources through RequireJS.</p><p class="calibre7">To work with the RequireJS library, specify the mapping of JavaScript resources; that is, assign the aliases to resources. Use <code class="email">requires-config.js</code> to create the mapping.</p><p class="calibre7">To make our configurations more precise and specific for different modules/themes, we can identify mapping in the <code class="email">requires-config.js</code> file at several levels depending on our needs. Configurations are collected and executed in the following order:</p><div class="book"><ul class="itemizedlist"><li class="listitem">Library configurations</li><li class="listitem">Configurations at the module level</li><li class="listitem">Configurations at the theme module level for the ancestor themes</li><li class="listitem">Configurations at the theme module level for a current theme</li><li class="listitem">Configurations at the theme level for the ancestor themes</li><li class="listitem">Configurations at the theme level for the current theme</li></ul></div><p class="calibre7">When we speak of JavaScript in Magento, we can hear various terms like component and widget. We can easily divide those terms by describing the type of JavaScript in Magento as per the following list:</p><div class="book"><ul class="itemizedlist"><li class="listitem"><span class="strong"><strong class="calibre8">JavaScript component (JS component)</strong></span>: This can be any single JavaScript file<a id="id354" class="calibre1"/> decorated as an <span class="strong"><strong class="calibre8">AMD</strong></span> (short for <span class="strong"><strong class="calibre8">Asynchronous Module Definition</strong></span>) module</li><li class="listitem"><span class="strong"><strong class="calibre8">Ui component</strong></span>: A <a id="id355" class="calibre1"/>JavaScript component located in the <code class="email">Magento_Ui</code> module</li><li class="listitem"><span class="strong"><strong class="calibre8">jQuery UI widget</strong></span>: A <a id="id356" class="calibre1"/>JavaScript component/widget provided by the jQuery UI library used in Magento</li><li class="listitem"><span class="strong"><strong class="calibre8">jQuery widget</strong></span>: A<a id="id357" class="calibre1"/> custom widget created using jQuery UI Widget Factory and decorated as an AMD module</li></ul></div><p class="calibre7">There are<a id="id358" class="calibre1"/> two ways we can initialize a JavaScript component <a id="id359" class="calibre1"/>in template files:</p><div class="book"><ul class="itemizedlist"><li class="listitem">Using the <code class="email">data-mage-init</code> attribute</li><li class="listitem">Using the <code class="email">&lt;script&gt;</code> tag</li></ul></div><p class="calibre7">The <code class="email">data-mage-init</code> attribute is parsed on a DOM ready event. Since it is initialized on a certain element, the script is called only for that particular element, and is not automatically initialized for other elements of the same type on the page. An example of <code class="email">data-mage-init</code> usage would be something like the following:</p><div class="informalexample"><pre class="programlisting">&lt;div data-mage-init='{ "&lt;componentName&gt;": {...} }'&gt;&lt;/div&gt;</pre></div><p class="calibre7">The <code class="email">&lt;script&gt;</code> tag initialization is done without relation to any specific element, or in relation to a specific element but no direct access to the element. The script tag has to have an attribute, <code class="email">type="text/x-magento-init"</code>. An example of <code class="email">&lt;script&gt;</code> tag initialization would be something like the following:</p><div class="informalexample"><pre class="programlisting">&lt;script type="text/x-magento-init"&gt;
    // specific element but no direct access to the element
    "&lt;element_selector&gt;": {
        "&lt;jsComponent1&gt;": ...,
        "&lt;jsComponent2&gt;": ...
    },
    // without relation to any specific element
    "*": {
        "&lt;jsComponent3"&gt;: ...
    }
&lt;/script&gt;</pre></div><p class="calibre7">Depending on the situation and desired level of expressiveness, we can either opt for usage of <code class="email">data-mage-init</code> or attribute or <code class="email">&lt;script&gt;</code> tag.</p><div class="book" title="Creating a custom JS component"><div class="book"><div class="book"><div class="book"><h3 class="title2"><a id="ch08lvl3sec11" class="calibre1"/>Creating a custom JS component</h3></div></div></div><p class="calibre7">Let's go<a id="id360" class="calibre1"/> through a practical example of creating a JS component within our <code class="email">Foggyline_Office</code> module in a form of the jQuery widget as follows:</p><p class="calibre7">First, we add our entry to <code class="email">app/code/Foggyline/Office/view/frontend/requirejs-config.js</code>, as shown:</p><div class="informalexample"><pre class="programlisting">var config = {
    map: {
        '*': {
            foggylineHello: 'Foggyline_Office/js/foggyline-hello'
        }
    }
};</pre></div><p class="calibre7">Then we add the actual JavaScript <code class="email">app/code/Foggyline/Office/view/frontend/web/js/foggyline-hello.js</code> with content as follows:</p><div class="informalexample"><pre class="programlisting">define([
    "jquery",
    "jquery/ui"
], function($){
    "use strict";

    $.widget('mage.foggylineHello', {
        options: {
        },
        _create: function () {
            alert(this.options);
            //my code here
        }
    });

    return $.mage.foggylineHello;
});</pre></div><p class="calibre7">Finally, we call our JavaScript component within some PHTML template, let's say <code class="email">app/code/Foggyline/Office/view/frontend/templates/office/hello.phtml</code>, as show:</p><div class="informalexample"><pre class="programlisting">&lt;div data-mage-init='{"foggylineHello":{"myVar1": "myValue1", "myVar2": "myValue2"}}'&gt;Foggyline&lt;/div&gt;</pre></div><p class="calibre7">Once we refresh the frontend, we should see the result of <code class="email">alert(this.options)</code> in the browser showing <code class="email">myVar1</code> and <code class="email">myVar2</code>.</p><p class="calibre7">The <code class="email">data-mage-init</code> part basically triggers as soon as the page loads. It is not triggered via some click or similar event on top of the <code class="email">div</code> element; it is triggered on page load.</p><p class="calibre7">If we <a id="id361" class="calibre1"/>don't see the desired result in the browser, we might need to fully clear the cache in the admin area.</p></div></div></div>

<div class="book" title="View elements">
<div class="book" title="CSS"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_9"><a id="ch08lvl2sec29" class="calibre1"/>CSS</h2></div></div></div><p class="calibre7">Magento uses <a id="id362" class="calibre1"/>a PHP port of the official LESS processor to parse the <code class="email">.less</code> files into <code class="email">.css</code> files. LESS is a CSS preprocessor that extends the CSS language by adding various features to it, like variables, mixins, and functions. All of this makes CSS more maintainable, extendable, and easier to theme. Frontend developers are thus expected to write LESS files that Magento then converts to appropriate CSS variants.</p><div class="informalexample" title="Note"><h3 class="title2"><a id="tip15" class="calibre1"/>Tip</h3><p class="calibre7">It is worth running <code class="email">find</code> <code class="email">{MAGENTO-DIR}/</code> <code class="email">-name</code> <code class="email">\*.less</code> <code class="email">&gt;</code> <code class="email">less-list.txt</code> on the console to get a full list of each and every LESS file in Magento. Spending a few minutes glossing over the list might serve as a nice future memo when working with style sheet bits in Magento.</p></div><p class="calibre7">We can customize the storefront look and feel through one of the following approaches:</p><div class="book"><ul class="itemizedlist"><li class="listitem">Override the default LESS files – only if our theme inherits from the default or any other theme, in which case we can override the actual LESS files</li><li class="listitem">Create our own LESS files using the built-in LESS preprocessor</li><li class="listitem">Create our own CSS files, optionally having compiled them using a third-party CSS preprocessor</li></ul></div><p class="calibre7">Within the individual frontend theme directory, we can find style sheets at the following locations:</p><div class="book"><ul class="itemizedlist"><li class="listitem"><code class="email">{vendorName}_{moduleName}/web/css/source/</code></li><li class="listitem"><code class="email">{vendorName}_{moduleName}/web/css/source/module/</code></li><li class="listitem"><code class="email">web/css/</code></li><li class="listitem"><code class="email">web/css/source/</code></li></ul></div><p class="calibre7">CSS files can be included in a page through templates and layout files. A recommended way is to include them through layout files. If we want our style sheets to be available through all pages on the frontend, we can add using the <code class="email">default_head_blocks.xml</code> file. If we look at the <code class="email">blank</code> theme, it uses <code class="email">vendor/magento/theme-frontend-blank/Magento_Theme/layout/default_head_blocks.xml</code> defined as follows:</p><div class="informalexample"><pre class="programlisting">&lt;page  xsi:noNamespaceSchemaLocation="urn:magento:framework:View/Layout /etc/page_configuration.xsd"&gt;
    &lt;head&gt;
        &lt;css src="css/styles-m.css"/&gt;
        &lt;css src="css/styles-l.css" media="screen and (min-width: 768px)"/&gt;
        &lt;css src="css/print.css" media="print"/&gt;
    &lt;/head&gt;
&lt;/page&gt;</pre></div><p class="calibre7">All it takes is for us to copy this file in the same location under our custom theme; assuming it's the <code class="email">jupiter</code> theme from the preceding examples, that would be <code class="email">app/design/frontend/Foggyline/jupiter/Magento_Theme/layout/default_head_blocks.xml</code>. Then we simply modify the file to include our CSS.</p><p class="calibre7">When <a id="id363" class="calibre1"/>run, Magento will try to find the included CSS files. If a CSS file is not found, it then searches for the same filenames with a <code class="email">.less</code> extension. This is part of the built-in preprocessing mechanism.</p></div></div>
<div class="book" title="Summary" id="1S2JE1-818f5224668745eb9070ddf1d85e6bfa"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch08lvl2sec30" class="calibre1"/>Summary</h1></div></div></div><p class="calibre7">In this chapter, we started off by looking into the three aspects of the rendering flow process: the view, result object, and pages. Then we took a detailed look at three primary view elements: <code class="email">ui-components</code>, <code class="email">containers</code>, and <code class="email">blocks</code>. We further studied blocks in depth, looking into their architecture and life cycle. We moved on to templates, looking into their locations, rendering, and fallback. Then came XML layouts, as the glue between blocks and templates. All of this gave us a foundation for further looking into theme structure, JavaScript components, and CSS. Along the way, we did a little bit of hands-on with a custom theme and JavaScript components creation. CSS and JavaScript is merely a fragment of what the Magento frontend is all about. Technology-wise, having a solid understanding of XML and even some PHP is more of a requirement than an exception for frontend-related development.</p><p class="calibre7">The following chapter will introduce us to Magento's web API where we will learn how to authenticate, make API calls, and even build our own APIs.</p></div></body></html>