- en: Chapter 2. Mastering PHP Software Management with the PEAR Installer
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 2 章。使用 PEAR 安装程序精通 PHP 软件管理
- en: In this chapter, we learn how to turn PHP software into distributable PEAR packages.
    In September 2005, version 1.4.0 of the PEAR installer was released. This release
    was a milestone, marking the transformation of PEAR from a niche-market tool for
    installing small libraries distributed by `pear.php.net` to a full-fledged application
    installation tool. For the first time, it is possible to distribute large-scale
    applications, and even complete web-based database-intensive applications can
    be installed and configured in one step.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习如何将 PHP 软件转换为可分发的 PEAR 软件包。2005 年 9 月，PEAR 安装程序的 1.4.0 版本发布。这是一个里程碑，标志着
    PEAR 从 `pear.php.net` 分发的狭小市场工具转变为一个完整的应用程序安装工具。第一次，可以分发大规模的应用程序，甚至完整的基于网络的数据库密集型应用程序也可以一步安装和配置。
- en: 'The PEAR installer now can be used to install traditional web-based applications
    like phpMyAdmin and non-PEAR libraries like the popular Smarty template engine
    (both happen to be installable through the [http://pearified.com](http://pearified.com)
    PEAR channel). Two of the primary design goals of the PEAR installer are to:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: PEAR 安装程序现在可以用来安装传统的基于网络的程序，如 phpMyAdmin 和非 PEAR 库，例如流行的 Smarty 模板引擎（这两个都可以通过
    [http://pearified.com](http://pearified.com) PEAR 频道）安装）。PEAR 安装程序的两个主要设计目标是：
- en: Make it possible to distribute application development across multiple development
    teams (i.e. stop re-inventing the wheel)
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使应用程序开发能够在多个开发团队之间进行分发（即停止重复造轮子）
- en: Prevent conflicting packages from overwriting each other
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 防止冲突的软件包相互覆盖
- en: All of this magic is made possible by the `package.xml` file format. `package.xml`
    is the heart and soul of the PEAR installer, and in order to take full advantage
    of PEAR's power, you need to understand its structure. Contained in `package.xml`
    is a list of files to be installed, information used by the PEAR installer to
    distinguish between different packages and releases, and information that is useful
    to humans, such as a description of what the package is and a changelog. This
    file is in fact all the PEAR installer needs to properly install software. The
    PEAR installer also uses the information in `package.xml` to create an installable
    archive in either `.tar` format or compressed `.tar` (`.tgz`) using the `pear
    package` command.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些魔法都是通过 `package.xml` 文件格式实现的。`package.xml` 是 PEAR 安装程序的核心和灵魂，为了充分利用 PEAR
    的功能，你需要了解其结构。`package.xml` 包含要安装的文件列表，供 PEAR 安装程序区分不同软件包和版本的信息，以及对人类有用的信息，例如软件包的描述和变更日志。实际上，这个文件就是
    PEAR 安装程序正确安装软件所需的一切。PEAR 安装程序还使用 `package.xml` 中的信息，通过 `pear package` 命令创建可安装的存档，格式为
    `.tar` 或压缩的 `.tar`（`.tgz`）。
- en: 'The PEAR installer is not limited to installation of local files, and in fact
    is designed to communicate over the Internet with **PEAR channel servers**. What
    is a channel server? A channel server provides downloadable releases for each
    package, and web service interfaces to meta-information about those packages and
    releases through XML-RPC, REST, or SOAP. Channels are discussed in depth in [Chapter
    5](ch05.html "Chapter 5. Releasing to the World: PEAR Channels"). Now that PEAR
    1.4.0+ and packages like Chiara_PEAR_Server ( [http://pear.chiaraquartet.net/index.php?package=Chiara_PEAR_Server](http://pear.chiaraquartet.net/index.php?package=Chiara_PEAR_Server))
    are available, it is simple to set up your own PEAR channel server and distribute
    libraries and applications with all of the sophistication you''ve come to expect
    from the `pear` command.'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: PEAR 安装程序不仅限于安装本地文件，实际上它是设计用来通过互联网与 **PEAR 频道服务器** 进行通信的。什么是频道服务器？频道服务器为每个软件包提供可下载的版本，并通过
    XML-RPC、REST 或 SOAP 提供关于这些软件包和版本的元信息的网络服务接口。频道在 [第 5 章](ch05.html "第 5 章。向世界发布：PEAR
    频道") 中有深入讨论。现在，随着 PEAR 1.4.0+ 和 Chiara_PEAR_Server（[http://pear.chiaraquartet.net/index.php?package=Chiara_PEAR_Server](http://pear.chiaraquartet.net/index.php?package=Chiara_PEAR_Server)）等软件包的可用，设置自己的
    PEAR 频道服务器并分发库和应用程序变得非常简单，这些都可以通过 `pear` 命令来实现。
- en: Tip
  id: totrans-7
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: '**CLI versus Web/Gtk2 Installer**'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: '**命令行界面（CLI）与 Web/Gtk2 安装程序**'
- en: Some of you reading this have probably installed the Web front end (PEAR_Frontend_Web
    package from `pear.php.net`) or the Gtk2 front end (PEAR_Frontend_Gtk2 package
    from `pear.php.net`). If so, then you have probably noticed that installing packages
    from other channels is even simpler, as the end user simply needs to choose the
    channel to install from, and all packages are listed with the most recent version
    and available upgrades.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 一些阅读此文档的人可能已经安装了Web前端（来自 `pear.php.net` 的 PEAR_Frontend_Web 包）或Gtk2前端（来自 `pear.php.net`
    的 PEAR_Frontend_Gtk2 包）。如果是这样，那么你可能已经注意到，从其他渠道安装包甚至更简单，因为最终用户只需选择要安装的渠道，所有包都会列出最新版本和可用的升级。
- en: We will be working with the command-line (CLI) front end to the PEAR installer
    in the next few chapters, as a much greater level of sophistication is available
    than what is possible through the Web front end, which is designed more for end
    users of PEAR packages than it is for developers of PEAR packages. At the time
    of writing this chapter, the Gtk2 front end is far more sophisticated than the
    Web installer, and is worth using if you are running PHP 5.1.0 or newer.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的几章中，我们将使用命令行（CLI）前端来处理PEAR安装程序，因为与Web前端相比，CLI前端提供了更高级的复杂性，Web前端设计得更多是为了PEAR包的最终用户，而不是PEAR包的开发者。在撰写本章时，Gtk2前端比Web安装程序更复杂，如果你运行的是PHP
    5.1.0或更高版本，那么它值得使用。
- en: 'For example, if your server is `pear.example.com`, and you release a package
    named `Foo`, the only thing your users need to type in order to install your package
    is:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果你的服务器是 `pear.example.com`，并且你发布了一个名为 `Foo` 的包，那么你的用户只需要输入以下内容来安装你的包：
- en: '[PRE0]'
  id: totrans-12
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: However, the most dynamic and important feature of the PEAR installer is the
    sophisticated way in which it handles dependencies on other packages, on PHP version,
    on PHP extensions, and on the system architecture. Through very simple syntax
    in `package.xml`, incredibly complex dependency scenarios can be easily and securely
    managed.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，PEAR安装程序最动态和最重要的功能是它处理对其他包、PHP版本、PHP扩展和系统架构的依赖的复杂方式。通过 `package.xml` 中的非常简单的语法，可以轻松且安全地管理极其复杂的依赖场景。
- en: Before we can get started with the actual work of creating our own packages,
    it is important to understand the core concepts behind the design of the PEAR
    installer and how you will need to shape your software design to best utilize
    its strengths.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始实际创建自己的包的工作之前，了解PEAR安装程序设计背后的核心概念以及你需要如何调整你的软件设计以充分利用其优势是非常重要的。
- en: Distributing Libraries and Applications
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 分发库和应用程序
- en: The most important thing to understand is how the PEAR installer actually installs
    files. Most PHP developers distribute their applications as unzip-and-go archives.
    As such, we tend to assume that files will be in the exact same relative locations
    on the end user's machine that they are on our development machine. PEAR, however,
    is designed to be far more flexible than this.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 最重要的是要理解PEAR安装程序实际上是如何安装文件的。大多数PHP开发者将他们的应用程序作为解压即用的存档进行分发。因此，我们倾向于假设文件将在最终用户机器上的确切相对位置与它们在我们开发机器上的位置相同。然而，PEAR的设计要灵活得多。
- en: For instance, it is common for shared web hosts to install a global copy of
    PEAR, but users can also install local copies and use the `include_path` from
    `php.ini` to choose local packages when available and global ones when they are
    not. In order to make this flexibility possible, PEAR groups and installs files
    by their type or file *role*.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，共享Web主机通常会安装一个全局的PEAR副本，但用户也可以安装本地副本，并使用 `php.ini` 中的 `include_path` 来选择当本地包可用时使用本地包，当不可用时使用全局包。为了使这种灵活性成为可能，PEAR按类型或文件
    *角色* 对组和安装文件。
- en: Each file role has a corresponding configuration entry that defines the location
    at which all files of that file role will be installed. For instance, the php
    file role has a configuration variable named `php_dir` that defines the directory
    into which all PHP files are installed, the data file role has a configuration
    variable named `data_dir`, and so on.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 每个文件角色都有一个相应的配置条目，它定义了所有该文件角色的文件将被安装的位置。例如，PHP文件角色有一个名为 `php_dir` 的配置变量，它定义了所有PHP文件将被安装到的目录，数据文件角色有一个名为
    `data_dir` 的配置变量，依此类推。
- en: This is a radical break from the traditional unzip-and-go philosophy, as it
    allows users to configure the installation locations in any way they desire on
    their own machine. This also means that the use of clever constructs to locate
    installed files such as `dirname(__FILE__)` are dangerous ways to code in a PEAR
    package. Fortunately, there are other clever ways around this that are even more
    flexible and secure.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 这与传统“解压即用”的哲学有着根本性的区别，因为它允许用户根据自己的需求在他们的机器上以任何方式配置安装位置。这也意味着，在 PEAR 包中使用如 `dirname(__FILE__)`
    这样的巧妙构造来定位已安装文件是危险的编码方式。幸运的是，还有其他更灵活、更安全的巧妙方法可以解决这个问题。
- en: Tip
  id: totrans-20
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: '**PEAR Configuration**'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: '**PEAR 配置**'
- en: To retrieve all configuration variables and their values, use the `config-show`
    command. Configuration variables that correspond to file roles generally have
    `_dir` in their name, such as `doc_dir`, and `php_dir`.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 要检索所有配置变量及其值，请使用 `config-show` 命令。与文件角色对应的配置变量通常在其名称中包含 `_dir`，例如 `doc_dir`
    和 `php_dir`。
- en: 'This also changes the development process slightly: instead of testing by running
    code right out of the development directory, the code should first be installed
    via its `package.xml` file and tested as the PEAR equivalent of unzip-and-go.
    For this reason, the most common `pear` command to be used is:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 这也稍微改变了开发过程：不再是直接在开发目录中运行代码进行测试，而是首先通过其 `package.xml` 文件安装代码，并以 PEAR 的解压即用方式测试。因此，最常用的
    `pear` 命令是：
- en: '[PRE1]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: or
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 或者
- en: '[PRE2]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: This command allows the "upgrade" from (for instance) PEAR version 1.5.0a1 to
    PEAR version 1.5.0a1 when a bug has been fixed or a new feature has been added.
    This command in actuality facilitates rapid development by allowing one to quickly
    replace the existing files within a version after having made changes without
    requiring a bump in version number. In other words, if we had to change the version
    every time a minor change was made on a development machine, this would be onerous.
    The `--force` option circumvents this problem.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 此命令允许从（例如）PEAR 版本 1.5.0a1 升级到 PEAR 版本 1.5.0a1，当修复了错误或添加了新功能时。实际上，此命令通过允许在更改后快速替换版本内的现有文件，从而促进了快速开发。换句话说，如果我们每次在开发机器上对微小更改进行更改时都必须更改版本号，这将是非常繁琐的。`--force`
    选项绕过了这个问题。
- en: Although managing installations using PEAR may seem to be more complicated on
    the surface, a quick investigation of *useful* unzip-and-go packages show that
    many unzip-and-go packages actually require a large amount of manual configuration
    that could easily be supplanted by the automated features of the PEAR installer.
    In short, once you get used to it, you'll wonder how you ever developed in PHP
    without using the PEAR installer to manage your packages.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然表面上使用 PEAR 管理安装可能看起来更复杂，但快速调查 *有用的* 解压即用包表明，许多解压即用包实际上需要大量的手动配置，这些配置可以很容易地被
    PEAR 安装程序的自动化功能所取代。简而言之，一旦习惯了它，你就会 wonder 如何在没有使用 PEAR 安装程序来管理你的包的情况下开发 PHP。
- en: Differences between Libraries and Applications from the Installer's Point of
    View
  id: totrans-29
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 从安装程序的角度来看，库和应用程序之间的区别
- en: The acronym **PEAR**means **P***HP***E***xtension*and **A***pplication* **R***epository*,
    but until PEAR version 1.4.0, support for applications was minimal. Most PEAR
    packages are libraries designed to be integrated into other external applications.
    The initial design of the PEAR installer supported this model very effectively,
    but did not provide all of the customization that applications need in order to
    be installed and configured effectively. One of the primary motivations for the
    new features introduced in PEAR version 1.4.0 was better support for application
    installation.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 缩写**PEAR**代表**PHP**扩展和**应用****存****储****库**，但在 PEAR 版本 1.4.0 之前，对应用程序的支持是有限的。大多数
    PEAR 包是设计成可以集成到其他外部应用程序中的库。PEAR 安装程序的初始设计非常有效地支持了这种模式，但并没有提供应用程序安装和配置所需的所有定制化功能。引入
    PEAR 版本 1.4.0 的新功能的主要动机之一是更好地支持应用程序的安装。
- en: In spite of the obvious differences in functionality between libraries and complete
    applications, from the installer's point of view, libraries and applications don't
    need to be handled very differently. Both are distributed using `package.xml`,
    both are stored in the registry in the same way, and the same rules of versioning
    and dependencies are applied. In fact, this is one of PEAR installer's greatest
    strengths, in that it both follows the **KISS** (**Keep It Simple, Stupid**) principle
    and leaves application design to the way `package.xml` is used. Consequently,
    a thorough understanding of the design of `package.xml` is necessary to use its
    capabilities to the fullest for any application or library package.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管库和完整应用程序在功能上存在明显的差异，但从安装程序的角度来看，库和应用程序不需要被非常不同地处理。两者都使用`package.xml`进行分发，都以相同的方式存储在注册表中，并应用相同的版本控制和依赖性规则。实际上，这是PEAR安装程序最大的优势之一，因为它既遵循**KISS**（**Keep
    It Simple, Stupid**）原则，又让应用程序设计取决于`package.xml`的使用方式。因此，为了充分利用其功能，对`package.xml`的设计有深入理解是必要的。
- en: 'New features designed to simplify application development include:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 新特性旨在简化应用程序开发，包括：
- en: Customizable file roles
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可定制的文件角色
- en: Customizable file tasks
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可定制的文件任务
- en: More advanced dependency possibilities and pre-download dependency resolution
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更高级的依赖性可能性和预下载依赖性解析
- en: The ability to bundle several packages into a single tarball
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将多个软件包打包成一个单一的tar包的能力
- en: Static dependencies based on a single release rather than an abstract package
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基于单个发布版本而非抽象包的静态依赖性
- en: After reading this list, if your head is spinning or you're seeing spots resembling
    question marks, fear not — all of these features will be simply and extensively
    explored in the next few sections.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 在阅读完这个列表后，如果你的头脑发晕或者你看到类似问号的斑点，不要担心——所有这些特性将在接下来的几节中简单而详尽地探讨。
- en: Before we launch into the new features, lets take a closer look at some basic
    principles that provide the foundation for best use of the new features.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们深入探讨新特性之前，让我们更仔细地看看一些基本原理，这些原理为最佳使用新特性提供了基础。
- en: Using Versioning and Dependencies to Help Track and Eliminate Bugs
  id: totrans-40
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用版本控制和依赖性帮助跟踪和消除错误
- en: Versioning and dependencies are two features that every enterprise-level distribution
    system must support at a very high level. With both simple dependencies and advanced
    versioning features, the PEAR installer makes depending on external packages safer
    and easier than ever before.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 版本控制和依赖性是每个企业级分发系统必须非常支持的两大特性。有了简单的依赖性和高级版本控制功能，PEAR安装程序使得依赖外部包比以往任何时候都更加安全和容易。
- en: Versioning
  id: totrans-42
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 版本控制
- en: The most basic foundation of the PEAR installer is the concept of versioning.
    Versioning should be familiar to all of us in the form of "Software package version
    X.Y.Z" such as "PHP version 5.1.4". The basic idea is that older versions of software
    have a lower number. In other words, PHP version 4.0.6 is older than PHP version
    4.1.1beta1, which is older than PHP version 4.1.1.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: PEAR安装程序最基本的基础是版本控制的概念。版本控制应该对我们所有人都很熟悉，以“软件包版本X.Y.Z”的形式，例如“PHP版本5.1.4”。基本思想是，软件的旧版本号较低。换句话说，PHP版本4.0.6比PHP版本4.1.1beta1旧，而PHP版本4.1.1beta1又比PHP版本4.1.1旧。
- en: 'How does versioning help track and eliminate bugs? Imagine this scenario:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 版本控制如何帮助跟踪和消除错误？想象以下场景：
- en: You are working on a Wiki, and allowing users to grab the source from your FTP
    site at any time and use it themselves. One of them finds a bug and reports, "It
    is doing this weird thing where it tries to delete all of my files." The user
    can't remember when he or she downloaded the source, as he or she had to restore
    from a backup and the file modification time has been reset. At this point, the
    only way to figure out the problem and whether it still exists in the current
    source is to grab the user project and compare it to the current source line by
    line. At best, this is tedious and at worst completely impossible.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 你正在处理一个Wiki，允许用户随时从你的FTP站点获取源代码并自行使用。其中一位用户发现了一个错误并报告说：“它正在做一件奇怪的事情，试图删除我所有的文件。”用户无法记得他或她何时下载了源代码，因为他或她不得不从备份中恢复，并且文件修改时间已被重置。在这种情况下，唯一确定问题是否存在以及它是否仍然存在于当前源代码中的方法是从用户项目获取并逐行与当前源代码进行比较。在最坏的情况下，这可能是繁琐的，在最坏的情况下是完全不可能的。
- en: Taking a fluid, ever-changing software project and making releases at specific
    times and assigning them a version number makes it much simpler for an end user
    to report a bug. The end user can simply say "Version 1.2.3 of your software package
    does this weird thing where it tries to delete all of my files" and you as the
    developer can ask the user to try the latest version, or the current development
    copy, making bug fixing much simpler.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 对于一个流动的、不断变化的软件项目，在特定时间发布版本并分配版本号，使得最终用户报告错误变得更加简单。最终用户可以简单地说明“您的软件包的 1.2.3
    版本做了这样奇怪的事情，试图删除我所有的文件”，然后您作为开发者可以要求用户尝试最新版本或当前的开发副本，这使得错误修复变得更加简单。
- en: In addition, it is possible to maintain two branches of the same code, a stable
    version, and an unstable version with innovative new features. There are many
    subtle ways of using versioning to provide more information about a software release.
    For instance, the Linux kernel versioning system is described in detail at [http://en.wikipedia.org/wiki/Linux_kernel#Version_Numbering](http://en.wikipedia.org/wiki/Linux_kernel#Version_Numbering).
    In this case, one of the decimal places is used to denote the stability of the
    kernel, such that it is possible to have version 1.2.9 released after 1.3.0.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，还可能维护同一代码的两个分支，一个是稳定版本，另一个是不稳定版本，具有创新的新功能。有许多微妙的方法可以使用版本管理来提供有关软件发布的更多信息。例如，Linux
    内核版本管理系统在 [http://en.wikipedia.org/wiki/Linux_kernel#Version_Numbering](http://en.wikipedia.org/wiki/Linux_kernel#Version_Numbering)
    中有详细描述。在这种情况下，小数点之一用于表示内核的稳定性，因此可以在 1.3.0 之后发布版本 1.2.9。
- en: The PEAR installer takes a more explicit approach to versioning. Rather than
    providing stability information inside the version number, a separate field in
    `package.xml, <stability>`, is used to designate the stability of the code. This
    does not preclude the use of Linux-style versioning, or any other versioning scheme,
    as long as the basic premise (1.3.0 is always newer than 1.2.9) still holds.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: PEAR 安装程序在版本管理上采取了一种更明确的方法。它不是在版本号内部提供稳定性信息，而是在 `package.xml` 中的单独字段 `<stability>`
    中使用来指定代码的稳定性。这并不妨碍使用 Linux 风格的版本管理或任何其他版本管理方案，只要基本前提（1.3.0 总是比 1.2.9 新）仍然成立。
- en: Tip
  id: totrans-49
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: '**Versioning Time versus Absolute Time**'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '**版本时间与绝对时间**'
- en: PEAR's simple versioning rules can actually be kind of confusing in the real
    world. The PEAR installer doesn't particularly care when a version was released
    in real-world time but about its stability and version number.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 在现实世界中，PEAR 的简单版本管理规则实际上可能会有些令人困惑。PEAR 安装程序并不特别关心版本在现实世界中的发布时间，而是关注其稳定性和版本号。
- en: This can mean that, for instance, PEAR 1.3.6 (stable) released on August 18,
    2005 is older than PEAR 1.4.0a1 (alpha) released on February 26, 2005 because
    1.3.6 is less than 1.4.0\. Absolute time has nothing to do with versioning time.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着，例如，2005 年 8 月 18 日发布的 PEAR 1.3.6（稳定版）实际上比 2005 年 2 月 26 日发布的 PEAR 1.4.0a1（alpha
    版）更老，因为 1.3.6 小于 1.4.0。绝对时间与版本时间无关。
- en: The end user can tell the PEAR installer through a configuration variable called
    `preferred_state` how stable packages must be in order to be installed. In our
    hypothetical example, if this variable is set to `stable` or to `beta`, then PEAR
    1.3.6 would be installed instead of 1.4.0a1; otherwise for values less stable
    than beta (`alpha, devel`, and `snapshot`) version 1.4.0a1 would be installed,
    even though version 1.3.6 was released months later, because 1.4.0 is always *newer*
    than 1.3.6 in *versioning time*.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 最终用户可以通过一个名为 `preferred_state` 的配置变量来告诉 PEAR 安装程序，为了安装，必须保证软件包的稳定性。在我们的假设例子中，如果这个变量设置为
    `stable` 或 `beta`，那么将安装 PEAR 1.3.6 而不是 1.4.0a1；否则，对于比 beta 版本稳定性低的值（`alpha`、`devel`
    和 `snapshot`），将安装 1.4.0a1，尽管 1.3.6 版本是在几个月后发布的，因为在版本时间上 1.4.0 总是比 1.3.6 更新。
- en: PEAR Packaging and Strict Version Validation
  id: totrans-54
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: PEAR 打包和严格的版本验证
- en: 'The PEAR package repository at [pear.php.net](http://pear.php.net) uses a strict
    versioning protocol. All package versions are of format X.Y.Z, as in "1.3.0".
    The first digit (X) is used to describe the **Applications Program Interface**
    (**API**) version, the second digit (Y) is used to describe the feature set version,
    and the third digit (Z) is used to describe the bugfix revision level. As examples,
    here are some version numbers and their meaning:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: PEAR 软件包仓库位于 [pear.php.net](http://pear.php.net)，使用严格的版本管理协议。所有软件包版本都是 X.Y.Z
    格式，例如 "1.3.0"。第一个数字（X）用于描述应用程序接口（API）版本，第二个数字（Y）用于描述功能集版本，第三个数字（Z）用于描述错误修复修订级别。以下是一些版本号及其含义的示例：
- en: '| Sample PEAR version numbers and their meanings |   |'
  id: totrans-56
  prefs: []
  type: TYPE_TB
  zh: '| 样例PEAR版本号及其含义 |   |'
- en: '| --- | --- |'
  id: totrans-57
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| Version Number | Meaning |'
  id: totrans-58
  prefs: []
  type: TYPE_TB
  zh: '| 版本号 | 含义 |'
- en: '| --- | --- |'
  id: totrans-59
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| 1.0.0 | Stable API version 1.0, initial stable release of package |'
  id: totrans-60
  prefs: []
  type: TYPE_TB
  zh: '| 1.0.0 | 稳定的API版本1.0，包的初始稳定发布 |'
- en: '| 0.4.5 | Unstable (developing) API, 4th feature set design, 5th bugfix release
    of this feature set |'
  id: totrans-61
  prefs: []
  type: TYPE_TB
  zh: '| 0.4.5 | 不稳定的（开发中）API，第四个功能集设计，该功能集的第五次错误修复发布 |'
- en: '| 2.4.0 | Stable API version 2.0, 4th feature set design, initial release of
    this new feature set |'
  id: totrans-62
  prefs: []
  type: TYPE_TB
  zh: '| 2.4.0 | 稳定的API版本2.0，第四个功能集设计，该新功能集的初始发布 |'
- en: '| 1.3.4 | Stable API version 1.0, 3rd set of new features since the initial
    stable release, 4th bugfix release of this feature set |'
  id: totrans-63
  prefs: []
  type: TYPE_TB
  zh: '| 1.3.4 | 稳定的API版本1.0，自初始稳定发布以来的第三个新功能集，该功能集的第四次错误修复发布 |'
- en: 'At installation time, this information is irrelevant: The PEAR installer will
    install anything it is given, including version numbering schemes like 24.25094.39.430
    or 23.4.0-r1 and so on. However, the validation used when packaging up a package
    via:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 在安装时，此信息是无关紧要的：PEAR安装程序将安装它所提供的任何内容，包括类似于24.25094.39.430或23.4.0-r1等版本编号方案。然而，通过以下方式打包包时使用的验证方式：
- en: '[PRE3]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'is much stricter than that used when downloading a PEAR package. In order to
    assist developers trying to meet the PEAR package repository''s strict coding
    standards, there are a set of validation routines within the PEAR package located
    in `PEAR/Validate.php` that check a number of important aspects of the PEAR coding
    standards, and emit warnings for anything that does not comply. For instance,
    version 1.0.0 must be stable (and not `devel, alpha`, or `beta` stability), and
    so the following snippet from a `package.xml` will cause a warning:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 与下载PEAR包时使用的验证方式相比要严格得多。为了帮助试图满足PEAR包仓库严格编码标准的开发者，PEAR包中位于`PEAR/Validate.php`的验证例程集合会检查PEAR编码标准的多个重要方面，并对任何不符合标准的内容发出警告。例如，版本1.0.0必须是稳定的（而不是`devel,
    alpha`或`beta`稳定性），因此以下来自`package.xml`的片段将导致警告：
- en: '[PRE4]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Specifically, it would look something like this:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 具体来说，它看起来可能像这样：
- en: '**$ pear package**'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '**$ pear package**'
- en: '[PRE5]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Although this is extremely helpful for anyone who wishes to adhere to PEAR''s
    strict coding standards, in some cases this warning is not helpful, but is instead
    annoying or distracting. For instance, a private project may wish to use the Linux
    versioning scheme. Fortunately, there is a way to control the way custom validation
    routines are handled at the packaging, download, or installation phases of the
    PEAR installer. By extending the `PEAR_Validate` class located in `PEAR/Validate.php`,
    a special validator can be created using object-oriented inheritance. To activate
    it, the validator must be associated with a channel. Although this process will
    be discussed in detail in [Chapter 5](ch05.html "Chapter 5. Releasing to the World:
    PEAR Channels"), here is a simple example.'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管这对希望遵守PEAR严格编码标准的人来说非常有帮助，但在某些情况下，这种警告并不有用，反而令人烦恼或分心。例如，一个私有项目可能希望使用Linux版本控制方案。幸运的是，有一种方法可以控制在PEAR安装程序的打包、下载或安装阶段处理自定义验证例程的方式。通过扩展位于`PEAR/Validate.php`中的`PEAR_Validate`类，可以使用面向对象继承创建一个特殊的验证器。要激活它，验证器必须与一个频道相关联。尽管这个过程将在[第5章](ch05.html
    "第5章。向世界发布：PEAR频道")中详细讨论，但这里有一个简单的示例。
- en: 'The developers of PHP extensions at `pecl.php.net` have a much looser version
    validation system, and there is a wide variation of versioning accepted, from
    a two-digit 1.0 to the 7.5.00.26 used by the maxdb package ( [http://pecl.php.net/maxdb](http://pecl.php.net/maxdb))
    to mirror versioning used by MySQL''s MaxDB database. As such, [pecl.php.net](http://pecl.php.net)
    is a separate channel from [pear.php.net](http://pear.php.net), and in its channel
    definition file `channel.xml` (also discussed in depth in [Chapter 5](ch05.html
    "Chapter 5. Releasing to the World: PEAR Channels")) defines a channel validator:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '`pecl.php.net`上的PHP扩展开发者有一个更宽松的版本验证系统，接受的版本控制差异很大，从两位数的1.0到maxdb包（[http://pecl.php.net/maxdb](http://pecl.php.net/maxdb)）使用的7.5.00.26，再到MySQL的MaxDB数据库使用的镜像版本控制。因此，[pecl.php.net](http://pecl.php.net)是[pear.php.net](http://pear.php.net)的一个独立频道，在其频道定义文件`channel.xml`（也在[第5章](ch05.html
    "第5章。向世界发布：PEAR频道")中详细讨论）中定义了一个频道验证器：'
- en: '[PRE6]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'This particular channel validator is distributed with the PEAR installer in
    the file `PEAR/Validator/PECL.php`. This file is both the perfect example of a
    customized channel validator and the simplest, so here it is, in all of its glory:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 这个特定的频道验证器与PEAR安装程序一起分发，在文件`PEAR/Validator/PECL.php`中。这个文件是定制频道验证器的完美示例，也是最简单的，所以在这里，展示其全部的辉煌：
- en: '[PRE7]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: This class simply overrides the strict version validation of its parent, and
    then adds in a PECL-specific check to see if an extension package is claiming
    to distribute a differently-named extension from the package name. In addition,
    it checks for a release candidate with (lower-case) `rc` in the version, as PHP's
    `version_compare()` function ( [http://www.php.net/version_compare](http://www.php.net/version_compare))
    treats this very differently from versions containing (upper-case) `RC`.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 这个类只是简单地覆盖了其父类的严格版本验证，然后添加了一个PECL特定的检查，以查看一个扩展包是否声称分发一个与包名不同名称的扩展。此外，它还会检查版本中是否包含（小写）`rc`作为候选发布版本，因为PHP的`version_compare()`函数（[http://www.php.net/version_compare](http://www.php.net/version_compare)）对此处理方式与包含（大写）`RC`的版本非常不同。
- en: Tip
  id: totrans-77
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: '**Why are pear.php.net and pecl.php.net Separate Channels?**'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '**为什么pear.php.net和pecl.php.net是独立的频道？**'
- en: In earlier PEAR versions, the `pear` command was used to install both PEAR packages
    and **PHP Extension Community Library** (**PECL**) packages. This was changed
    in version 1.4.0 for a number of reasons. First of all, the developers at [pear.php.net](http://pear.php.net)
    are developing packages written in PHP. Developers at [pecl.php.net](http://pecl.php.net)
    are developing packages written in C that are compiled to shared `.dll` or `.so`
    files as internal components (extensions) of PHP itself. There are intrinsic differences
    in the way PEAR-style packages are installed and maintained compared to the PECL-style
    packages.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 在早期的PEAR版本中，`pear`命令用于安装PEAR包和**PHP扩展社区库**（**PECL**）包。由于多个原因，这一变化发生在1.4.0版本中。首先，[pear.php.net](http://pear.php.net)的开发者正在开发用PHP编写的包。而[pecl.php.net](http://pecl.php.net)的开发者正在开发用C编写的包，这些包被编译成共享的`.dll`或`.so`文件，作为PHP本身的内部组件（扩展）。与PECL风格的包相比，PEAR风格的包在安装和维护方面存在固有的差异。
- en: One of these differences is the importance given to proper versioning. PECL
    and PHP extensions can't co-exist with conflicting extensions; only one can run
    at a time. PEAR packages do not have this restriction, as several different versions
    of a PEAR package can co-exist and be loaded interchangeably through the `include_path`,
    so versioning becomes much more important.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 这些差异之一是正确版本的重要性。PECL和PHP扩展不能与冲突的扩展共存；一次只能运行一个。PEAR包没有这种限制，因为多个不同版本的PEAR包可以共存并通过`include_path`进行交替加载，因此版本控制变得尤为重要。
- en: In addition, because of file locking, an extension that is loaded into memory
    cannot be uninstalled, making upgrading PHP extensions impossible unless `php.ini`
    is not used.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，由于文件锁定，加载到内存中的扩展无法卸载，这使得在不使用`php.ini`的情况下升级PHP扩展成为不可能。
- en: There are a number of other small reasons that all added up to the need for
    a split, such as confusion over the function of packages (is this a PHP extension
    or a script written in PHP?) and so now we have both the `pear` and the new `pecl`
    command for managing PECL-packages.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多其他小原因加在一起导致了需要分割，例如对包的功能的混淆（这是一个PHP扩展还是用PHP编写的脚本？），因此现在我们既有`pear`也有新的`pecl`命令来管理PECL包。
- en: Enterprise-Level Dependency Management
  id: totrans-83
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 企业级依赖管理
- en: Dependencies are a natural evolution in software design. If your forum package
    attempts to separate business logic from display by using a template engine, it
    is far better to focus your energies on developing the forum functionality than
    it is to design a new template engine. Not only have the authors of existing template
    engines spent more time working on and thinking about template engines, their
    template engine has been used by thousands of other developers just like you.
    All of the common and most of the unusual problems have been encountered and solved.
    In the event that you do find a new problem, you can report it to the maintainers,
    or even exercise the full strength of open source and fix the problem yourself
    and give the solution back to the maintainers.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 依赖关系是软件设计中的自然演变。如果您的论坛包尝试通过使用模板引擎将业务逻辑与显示分离，那么将精力集中在开发论坛功能上要比设计一个新的模板引擎好得多。不仅现有模板引擎的作者在模板引擎上花费了更多的时间和精力，而且他们的模板引擎已经被成千上万的开发者（就像您一样）使用。所有常见问题和大多数不寻常问题都已被遇到并解决。如果在您发现新的问题时，您可以向维护者报告，甚至可以充分利用开源的力量自行修复问题并将解决方案反馈给维护者。
- en: On the other hand, this requires putting trust in the maintainers of the template
    engine. By using the template engine, you implicitly trust the maintainers to
    effectively manage it, to fix all bugs discovered, and to prevent introducing
    new bugs into future releases. You also trust the maintainers to continue maintaining
    the package and to respond to issues you encounter.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，这需要信任模板引擎的维护者。通过使用模板引擎，您隐含地信任维护者能够有效地管理它，修复发现的全部错误，并防止在未来的版本中引入新的错误。您还信任维护者会继续维护该包，并回应您遇到的问题。
- en: PEAR developers have been around long enough to know that at its worst, this
    trust can be naïve or stupid, as software is still maintained by humans who have
    the capacity to screw up. Fortunately, because of this knowledge, `package.xml`
    provides complete control over the "trust" of a dependency.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: PEAR 开发者已经存在很长时间，知道在最坏的情况下，这种信任可能是天真的或愚蠢的，因为软件仍然由有能力出错的人类维护。幸运的是，由于这种知识，`package.xml`
    提供了对依赖关系“信任”的完全控制。
- en: Tip
  id: totrans-87
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: '**Dependencies in package.xml**'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '**package.xml 中的依赖关系**'
- en: For more details on how dependencies work in `package.xml`, see the section
    *External Dependencies*
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 关于 `package.xml` 中依赖关系的工作方式，请参阅 *外部依赖关系* 部分
- en: 'The simplest dependency tells the installer that a package must be used but
    that we don''t need to check for versioning issues: it is enough that it is installed.
    In `package.xml 2.0`, this dependency looks something like:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 最简单的依赖关系会告诉安装程序必须使用该包，但我们不需要检查版本问题：只要安装即可。在 `package.xml 2.0` 中，这种依赖关系看起来像这样：
- en: '[PRE8]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'A slightly more restrictive dependency might tell the installer to only install
    versions newer than a minimum of version 1.2.0:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 一个稍微更严格的依赖关系可能会告诉安装程序只安装比最小版本 1.2.0 新的版本：
- en: '[PRE9]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Going further, it may be the case that there were a few bungled releases. We
    can tell the installer to ignore specific releases 1.2.0 and 1.4.2, but that every
    other version newer than 1.2.0 is OK to install:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 进一步来说，可能存在一些混乱的发布。我们可以告诉安装程序忽略特定的发布版本 1.2.0 和 1.4.2，但其他所有比 1.2.0 新的版本都可以安装：
- en: '[PRE10]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Finally, we can also tell the installer that we want to strongly recommend
    version 1.4.5, and to never upgrade unless we say it is OK:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们还可以告诉安装程序，我们强烈推荐版本 1.4.5，并且除非我们说可以升级，否则不要升级：
- en: '[PRE11]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: In this last case, we are given a tremendous amount of control over the dependency.
    The end user cannot accidentally break our package by upgrading to a newer release
    of a dependency unless the maintainers of the dependency have worked with you
    on your package and certified its compatibility with another tag,`<compatible>`,
    or you do another release of your package that recommends the newer version.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 在最后一种情况下，我们得到了对依赖关系的大量控制。最终用户在依赖关系的维护者与您合作并认证其与另一个标签 `<compatible>` 的兼容性，或者您发布了一个推荐新版本的包之前，不会意外地通过升级到依赖关系的新版本而破坏我们的包。
- en: The differing levels of trust afforded by dependencies in `package.xml` mean
    you can securely depend on other packages, but this is only the beginning of PEAR's
    dependency features. The other common problem solved by the use of dependencies
    is basic incompatibilities with the end user's computer, operating system, PHP
    version, or enabled extensions in `php.ini`. PEAR provides dependency tags for
    each one of these situations. In addition, optional features or plug-ins can be
    implemented through optional dependencies or dependency groups. The list of possibilities
    is staggering, and yet the syntax in `package.xml` is simple and very easy to
    learn.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '`package.xml` 中依赖项提供的不同信任级别意味着您可以安全地依赖其他软件包，但这只是 PEAR 依赖项功能的开始。依赖项解决的另一个常见问题是与最终用户的计算机、操作系统、PHP
    版本或 `php.ini` 中启用的扩展的基本不兼容性。PEAR 为这些情况中的每一个都提供了依赖项标签。此外，可选功能或插件可以通过可选依赖项或依赖组实现。可能性的列表令人印象深刻，而
    `package.xml` 中的语法简单且易于学习。'
- en: Distribution and Upgrades for the End User
  id: totrans-100
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 最终用户的分发和升级
- en: From the end user's perspective, one of the most complex tasks faced when using
    an unzip-and-go package is upgrading. In the closed-source world, newer versions
    of a package break something that used to work with the old package as a means
    of forcing their users to upgrade, which sometimes requires significant work.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 从最终用户的角度来看，在使用解压即用的软件包时，面临的最复杂任务之一就是升级。在闭源世界中，软件包的新版本会破坏旧版本中曾经正常工作的某些功能，以此来强迫用户升级，这有时需要大量的工作。
- en: In the open-source world, many developers continue to follow this model by introducing
    exciting new features that mean you can no longer use the old version. The actual
    upgrade process usually means overwriting the current version with the new files,
    possibly with new configuration needed. In addition, it opens up the scary prospect
    of completely breaking a live site, prompting the need for some kind of backup
    system.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 在开源世界中，许多开发者通过引入令人兴奋的新功能继续遵循这一模式，这意味着您将无法再使用旧版本。实际的升级过程通常意味着用新文件覆盖当前版本，可能还需要新的配置。此外，它还带来了完全破坏实时网站的可怕前景，这促使需要某种备份系统。
- en: 'By using the PEAR installer, all of these fears and dangers are a thing of
    the past. It is simple to upgrade to a new version by using:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用 PEAR 安装程序，所有这些恐惧和危险都已成为过去。使用以下方法升级到新版本非常简单：
- en: '[PRE12]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'It is just as simple to downgrade to a previous version of the package:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 将软件包降级到旧版本同样简单：
- en: '[PRE13]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: This makes the task of maintaining a live site both easy and secure — a rare
    and wonderful combination. Note that this example assumes the old version of the
    package is `1.2.3`.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 这使得维护一个实时网站既简单又安全——这是一个罕见而美好的组合。请注意，此示例假设软件包的旧版本为 `1.2.3`。
- en: 'In addition, upgrading or installing dependencies is just as easy. Required
    dependencies are always downloaded and installed for packages that make use of
    `package.xml 2.0`, and for packages that use `package.xml 1.0`, dependencies can
    be automatically downloaded and installed with the `--onlyreqdeps` (only required
    dependencies) option like this:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，升级或安装依赖项同样简单。对于使用 `package.xml 2.0` 的软件包，总是下载并安装所需的依赖项，而对于使用 `package.xml
    1.0` 的软件包，可以使用 `--onlyreqdeps`（仅必需依赖项）选项自动下载和安装依赖项，如下所示：
- en: '[PRE14]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Optional dependencies can also be automatically installed using the `--alldeps`
    (all dependencies) option:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用 `--alldeps`（所有依赖项）选项自动安装可选依赖项：
- en: '[PRE15]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'In addition, creating feature groups, or grouping several related packages
    into a single dependency, is easily accomplished with dependency groups, meaning
    users can install feature groups like PEAR''s web installer feature like so:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，通过依赖组创建功能组，或者将几个相关软件包组合成一个单一依赖项，可以轻松实现，这意味着用户可以像安装 PEAR 的网络安装程序功能一样安装功能组：
- en: '[PRE16]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: When configuring a package, there is often a large amount of work that needs
    to be performed to configure file locations, set up databases, and so on. PEAR
    provides some simple ways to automate configuration, and also provides ways to
    standardize any level of complex setup through post-installation scripts.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 当配置一个软件包时，通常需要执行大量工作来配置文件位置、设置数据库等。PEAR 提供了一些简单的方法来自动化配置，同时也提供了通过安装后脚本标准化任何复杂设置的方法。
- en: If you're anything like me, thinking of all the possibilities built into the
    PEAR installer makes your heart race faster with anticipation. Even if you're
    not quite that geeky, I'm sure you will find that the power of the PEAR installer
    will make your programming life easier.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
- en: An Overview of package.xml Structure
  id: totrans-116
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`package.xml` contains all of the information the PEAR installer needs to install
    and configure PEAR packages. By leveraging standards such as XML and XSchema to
    document package structure ( [http://pear.php.net/dtd/package1.xsd](http://pear.php.net/dtd/package1.xsd)
    and [http://pear.php.net/dtd/package2.xsd](http://pear.php.net/dtd/package2.xsd)
    have full definitions of `package.xml 1.0` and `package.xml 2.0` respectively),
    PEAR opens up future programming possibilities that would not be available otherwise.
    For instance, using XSchema allows future extensibility of `package.xml` using
    XML namespaces to provide custom functionality.'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
- en: When discussing `package.xml`, it is important to understand both the commonality
    and the differences between `package.xml 1.0` and `package.xml 2.0`. The `package.xml
    2.0` is a superset of `package.xml 1.0`. In other words, it is possible to represent
    every single possible `package.xml` version 1.0 as a `package.xml 2.0`, but there
    is a large set of `package.xml 2.0` that cannot be reduced to unique `package.xml
    1.0`.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
- en: The best way to get acquainted with the structure of `package.xml 1.0` is to
    peruse the CVS of the PEAR repository at [cvs.php.net](http://cvs.php.net). Each
    subdirectory contains a `package.xml` file. If that `package.xml` file begins
    with`<package version="1.0"...` then it is a `package.xml 1.0`. Many packages
    are already taking advantage of `package.xml 2.0`, using a file named `package2.xml`.
    Also useful is to investigate the PECL repository at [http://cvs.php.net/pecl/](http://cvs.php.net/pecl/)
    and see how PHP extension developers are using `package.xml`.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
- en: 'To explore the equivalent `package.xml 2.0`, there is a convenient PEAR command
    that can be used to convert a `package.xml 1.0` into a `package.xml 2.0`. This
    command is invoked as follows:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: This will parse a file in the current directory named `package.xml` and spit
    out a file named `package2.xml` in the new format.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
- en: In addition, full up-to-date documentation on `package.xml` is always available
    in the PEAR manual at [http://pear.php.net/manual/](http://pear.php.net/manual/).
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
- en: For the purposes of this book, we will be primarily discussing `package.xml
    2.0`, and only mentioning 1.0 to remark on important conceptual changes for those
    who are familiar with the old format.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
- en: Here is a sample `package.xml` file. This one is taken from the PEAR package
    itself, and demonstrates a number of `package.xml's` features that will be explored
    in the sections to come. Feel free to skim this example and then refer back to
    it later on. For now, just absorb the basic structure and the specifics will make
    sense when you read about them later on in this text.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Tags Shared between package.xml 1.0 and 2.0
  id: totrans-127
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you have a basic understanding of `package.xml 1.0` and just want to see
    what has changed in `package.xml 2.0`, it is best to skim the next few sections.
    Differences are always presented at the beginning of each section, followed by
    an in-depth exploration of the reasoning behind the changes.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
- en: Before launching into the advanced new features of `package.xml 2.0`, it is
    important to explore the tags and attributes that have been carried over from
    `package.xml 1.0` that both formats have in common. Most tags are unchanged. A
    few have either added information or changed their name slightly, and others have
    been completely redesigned. Let's get started.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
- en: Package Metadata
  id: totrans-130
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Both `package.xml` versions provide similar package metadata. Some basic information
    that must be present in any package includes:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
- en: Package name/channel
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Maintainers (authors)
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Package description
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Package summary (one-line description)
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Most of this information remains unchanged from release to release. For instance,
    the package name and channel are constant. The package description and summary
    will change rarely. The maintainers may change more frequently, depending on the
    community, so even though this is grouped under package metadata, it is probably
    reasonable to think of this as release-based information.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
- en: Package Name/Channel
  id: totrans-137
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'These two fields are at the beginning of a `package.xml`, and form the heart
    of the PEAR installer''s package differentiation. These are like the primary key
    in a database table: a unique combination of package/channel = a unique package.
    Note that the`<channel>` and`<uri>` tags are only present in `package.xml 2.0`.'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Tip
  id: totrans-140
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Channels and package.xml 1.0**'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
- en: As you learned earlier, the concept of channels is introduced in `package.xml
    2.0`. How does `package.xml 1.0` define the channel when it is not a part of its
    specification?
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
- en: 'PEAR handles this problem in a simple way: all packages packaged using `package.xml
    1.0` are installed as if they had a`<channel>pear.php.net</channel>` tag inserted
    right after the package name declaration. Note that [pecl.php.net](http://pecl.php.net)
    packages that used `package.xml 1.0` are allowed to migrate to the [pecl.php.net](http://pecl.php.net)
    channel when they upgrade to using a `package.xml 2.0`, but all other packages
    must start over with a new channel.'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
- en: 'The package name is declared using the`<name>` tag, and must begin with a letter,
    and otherwise contain only letters, numbers and the underscore character, unless
    the channel-specific validator allows another format for the package name. Channel-specific
    validators are covered in depth in [Chapter 5](ch05.html "Chapter 5. Releasing
    to the World: PEAR Channels"). If you are simply creating a package, you need
    not know anything about channel-specific validators. If your package satisfies
    the requirements for a package, when you run:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Your package will be created without errors. Otherwise, packaging will fail,
    and one or more error messages will be presented describing the reasons for failure.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
- en: The`<channel>` tag cannot co-exist with the`<uri>` tag. A package that uses
    the`<uri>` tag is in fact automatically part of the pseudo-channel `__uri`, a
    channel that does not have a server or protocols associated with it. The `__uri`
    channel is in fact a true magic channel that only serves to act as a namespace
    preventing URI-based packages from conflicting with packages from other channels.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
- en: 'For instance, consider a package whose `package.xml` begins with:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: This package is *not* the same as a package whose `package.xml` begins with
    the following code even if the version number of the package is `1.2.3`.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: URI-based packages are strictly release-based. The`<uri>` tag must be an absolute,
    real-world URI that can be used to access the package. However, the URI should
    not include a `.tgz` or `.tar` file extension, but both should be present. In
    our example above, both [http://pear.php.net/Packagename-1.2.3.tgz](http://pear.php.net/Packagename-1.2.3.tgz)
    and [http://pear.php.net/Packagename-1.2.3.tar](http://pear.php.net/Packagename-1.2.3.tar)
    should exist and be identical except for the use of zlib compression on the `.tgz`.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
- en: Maintainers (Authors)
  id: totrans-153
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The list of maintainers in `package.xml` should serve the same function that
    a traditional `AUTHORS` file serves. However, this list of authors is more than
    just useful information. The`<user>` tag is used by a channel server to match
    up package maintainers with the release of a package, allowing non-channel administrators
    to upload releases of software packages that they maintain. If you are maintaining
    a package that is released through [pear.php.net](http://pear.php.net), for instance,
    the`<user>` tag must contain your PEAR username. For non-channel releases, the
    contents of these tags are informational only, and let end users of your package
    know how to contact you.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
- en: The`<role>` tag in `package.xml 1.0` may only contain the values `lead, developer,
    contributor`, or `helper`. This proves to be impossible to validate using XSchema,
    and so to make things easier, `package.xml 2.0` has taken the contents of the`<role>`
    tag and extracted them out to new tags`<lead>, <developer>, <contributor>`, and`<helper>`.
    In addition, the`<maintainers>` and`<maintainer>` tag have been removed to simplify
    parsing.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
- en: For `package.xml 1.0:`
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: For `package.xml 2.0:`
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Package Description and Summary
  id: totrans-160
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The example summary/description pair below shows how the`<summary>` and`<description>`
    tags should be used in both `package.xml 1.0` and `package.xml 2.0`. These tags
    are strictly informational, and are not used by the installation portions of the
    PEAR installer. If a package is served through a channel, commands like `list-all`
    will display the summary. The description is displayed when a user types commands
    like `info` or `remote-info` to display information about a particular package
    or release.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
- en: Be sure that these tags are clear, concise, and understandable. Too often, I
    have seen summaries like `GBRL` for a package named `File_GBRL` — define your
    acronyms if they are not commonly known!
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Basic Release Metadata
  id: totrans-164
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The rest of `package.xml` is generally release-specific data, with a few exceptions.
    Release-specific data is more apt to change than things like the name of a package.
    Specifically, the areas of release-specific information documented in `package.xml`
    are:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
- en: Package version
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Package stability
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: External dependencies
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Release notes
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Release license
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Changelog
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: File list, or contents of the package
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In `package.xml 1.0`, this data was enclosed in a redundant`<release>` tag.
    This tag has been removed in version 2.0.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
- en: Package Version
  id: totrans-174
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The package version is very important, as this is the primary mechanism used
    by the installer to determine the relative age of different releases. Versions
    are sequential, meaning version 1.3.6 is older than version 1.4.0b1, even if version
    1.3.6 was released a month after 1.4.0b1.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: For `package.xml 2.0:`
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'The API version of a release is strictly for informational purposes. This can,
    however, be used in a `replace` task as follows:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'This reduces redundancy in maintaining versioning inside files. In fact, providing
    API version through an API method is a very good idea. In my packages, I usually
    provide this code:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Upon packaging, the `Foo.php` file containing the above code would look like
    this:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: In other words, all instances of the `@API-VER@` token will be replaced with
    the contents of the`<api>` version tag. Replacement file tasks are used to perform
    this magic.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
- en: Package Stability
  id: totrans-186
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In `package.xml 1.0`, the`<state>` tag was used to describe the stability of
    code. In `package.xml 2.0`, the`<release>` tag inside`<stability>` is used to
    describe the stability of code.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: For `package.xml 2.0:`
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'The PEAR installer uses the release stability in conjunction with an end user''s
    `preferred_state` configuration variable to determine whether a release is stable
    enough to install. If the user wishes to install the `Foo` package, and these
    releases are available:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
- en: '| Version | Stability |'
  id: totrans-192
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  id: totrans-193
  prefs: []
  type: TYPE_TB
- en: '| 1.0.1 | stable |'
  id: totrans-194
  prefs: []
  type: TYPE_TB
- en: '| 1.1.0a1 | alpha |'
  id: totrans-195
  prefs: []
  type: TYPE_TB
- en: '| 1.0.0 | stable |'
  id: totrans-196
  prefs: []
  type: TYPE_TB
- en: '| 0.9.0 | beta |'
  id: totrans-197
  prefs: []
  type: TYPE_TB
- en: '| 0.8.0 | alpha |'
  id: totrans-198
  prefs: []
  type: TYPE_TB
- en: The installer will choose versions to install based on the user's `preferred_state`
    setting.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
- en: '| preferred_state value | Foo version that would be installed |'
  id: totrans-200
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  id: totrans-201
  prefs: []
  type: TYPE_TB
- en: '| stable | 1.0.1 |'
  id: totrans-202
  prefs: []
  type: TYPE_TB
- en: '| beta | 1.0.1 |'
  id: totrans-203
  prefs: []
  type: TYPE_TB
- en: '| alpha | 1.1.0a1 |'
  id: totrans-204
  prefs: []
  type: TYPE_TB
- en: Note that for a `preferred_state` of `beta`, when there is a choice of a newer
    version 1.0.1 `(stable)` and older version 0.9.0 `(beta)`, the installer will
    choose the latest, most stable version — version 1.0.1\. For a `preferred_state`
    of `alpha`, the installer will choose the newer and less stable version 1.1.0a1
    `(alpha)` over the older version 1.0.1 `(stable)`, even though version 1.0.1 was
    released *after* version 1.1.0a1.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
- en: 'The list of legal stabilities for release stability in order of diminishing
    stability is:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
- en: '`stable:` code should be working in all situations.'
  id: totrans-207
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`beta:` code should be working in all situations, and is feature-complete,
    but needs real-world testing.'
  id: totrans-208
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`alpha:` code is in a state of flux, features may change at any time, stability
    is uncertain.'
  id: totrans-209
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`devel:` code is not yet feature-complete, and may not work in most situations.'
  id: totrans-210
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`snapshot:` this is a current copy of development code from source during live
    development in between normal releases.'
  id: totrans-211
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: API stability serves the same informational purpose as API version. It is not
    used by the installer, but can be used to track the rate of change of an API.
    An API marked stable should in fact never change except for adding new features
    — users need to be able to depend upon a stable API in order for package dependencies
    to work. This is a key feature of enterprise-level dependencies.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
- en: 'The list of legal stabilities for API differs slightly in that an API snapshot
    is not allowed. API stability should be thought of as:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
- en: '`stable:` API is set, and will not break backward compatibility.'
  id: totrans-214
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`beta:` API is probably set, and will only change to fix serious bugs in design
    that are encountered during testing.'
  id: totrans-215
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`alpha:` API is fluid, and may change, breaking any existing features, as well
    as adding new ones.'
  id: totrans-216
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`devel:` API is extremely unstable, and may change dramatically at any time.'
  id: totrans-217
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: External Dependencies
  id: totrans-218
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'There are two kinds of dependencies that the PEAR installer recognizes: *required*
    and *optional* dependencies. In addition, there are two classes of dependencies,
    those that restrict installation, and those that describe other resources (packages/extensions)
    used by the primary package. Restrictive dependencies are defined by the`<php>,
    <pearinstaller>, <arch>, <extension>`, and`<os>` dependencies. Resource-based
    dependencies are defined by the`<package>, <subpackage>`, and`<extension>` dependencies.'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
- en: 'Although the `package.xml 1.0` DTD defined several dependency types, only three
    were ever implemented:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
- en: '`pkg:` dependencies on packages'
  id: totrans-221
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ext:` dependencies on extensions'
  id: totrans-222
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`php:` dependencies on PHP versions'
  id: totrans-223
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The structure of dependencies in `package.xml 1.0` was quite simple:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'The legal values of the `rel` attribute are:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
- en: '`has:` the dependency must exist'
  id: totrans-227
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`not:` the dependency must not be present'
  id: totrans-228
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`gt:` in conjunction with `version` attribute, the dependency must have version
    > the required version.'
  id: totrans-229
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ge:` in conjunction with `version` attribute, the dependency must have version
    >= the required version'
  id: totrans-230
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`eq:` in conjunction with `version` attribute, the dependency must have version
    == the required version.'
  id: totrans-231
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`lt:` in conjunction with `version` attribute, the dependency must have version
    < the required version.'
  id: totrans-232
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`le:` in conjunction with `version` attribute, the dependency must have version
    <= the required version.'
  id: totrans-233
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ne:` in conjunction with `version` attribute, the dependency must have version
    != the required version. (PEAR version 1.3.6 only.)'
  id: totrans-234
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Tip
  id: totrans-235
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**How is Version Comparison Done?**'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
- en: The PHP function `version_compare()` is used to determine whether a version-based
    dependency validates. Documentation for `version_compare()` is at [http://www.php.net/version_compare](http://www.php.net/version_compare).
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
- en: 'Only after a great deal of experience did the serious design flaws of this
    approach reveal themselves:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
- en: '*XML validation with tools like xmllint cannot reveal invalid dependencies*.
    Consider the following dependency`<dep type="php" rel="has" version="4.3.0"/>`.
    This dependency is not valid because `rel="has"` ignores the version attribute,
    and so the dependency validation will not be performed — every PEAR installation
    has PHP installed by definition.'
  id: totrans-239
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Trust level of dependency upgrades cannot be controlled*. The PEAR package
    depends upon the Console_Getopt package. At one point, the maintainer of Console_Getopt
    *fixed* a bug that suddenly caused PEAR to stop working upon upgrade. A good deal
    of scrambling resulted in a fix, but the event highlighted the fatal flaw in the
    design of the PEAR installer pre-version 1.4.0: dependencies upon packages are
    inherently unsafe. There is no way to restrict trust of dependencies. The `rel="eq"`
    attribute does not have the desired effect because this prevents upgrading safely
    for any reason, effectively freezing development. In addition, flaws in the validation
    of dependencies meant that even upgrading to a newer package version is forbidden.'
  id: totrans-240
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If the current version has a dependency tag of `<dep type="pkg" rel="eq" version="1.0">Deppackage</dep>`,
    the PEAR installer would look at the dependencies for the new version with `<dep
    type="pkg" rel="eq" version="1.1">Deppackage</dep>` then look on disk to see that
    Deppackage version 1.0 was installed, and fail to upgrade. Even if both the main
    package and Deppackage were passed in, upgrade of Deppackage would fail because
    the installed version of the main package requires version 1.0 of Deppackage.
  id: totrans-241
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: If the current version has a dependency tag of `<dep type="pkg" rel="eq" version="1.0">Deppackage</dep>`,
    the PEAR installer would look at the dependencies for the new version with `<dep
    type="pkg" rel="eq" version="1.1">Deppackage</dep>` then look on disk to see that
    Deppackage version 1.0 was installed, and fail to upgrade. Even if both the main
    package and Deppackage were passed in, upgrade of Deppackage would fail because
    the installed version of the main package requires version 1.0 of Deppackage.
  id: totrans-242
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '*Dependencies on PECL extension-based packages cannot work*. A`<dep type="ext"
    rel="has">peclextension</dep>` will only check for an extension in memory. Most
    PECL extensions can either be built directly into PHP (non-shared), distributed
    with PHP as a shared module, or downloaded and installed. If a PECL extension
    is built into PHP, distributed as a shared module, or installed via PECL, the
    `type="ext"` dependency will work just fine. Unfortunately, in order to upgrade
    the extension using the PEAR installer, `php.ini` must be disabled otherwise file
    locking will prevent overwriting the extension when it is in use by the current
    PHP process. Newer extensions such as PDO have drivers that depend on the PDO
    extension being present for installation. If `php.ini` is disabled, there is no
    way to detect extensions to validate dependencies!'
  id: totrans-243
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Simplifying XML Validation of package.xml
  id: totrans-244
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'In order to make it possible to validate dependencies with external tools,
    the structure needed to be redesigned. Generally, using tags in preference to
    attributes and particularly in preference to attribute values is the approach
    used in `package.xml 2.0`. The dependency examples from `package.xml 1.0` can
    be represented in `package.xml 2.0` with:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Note that attributes `optional="yes"` and the implied `optional="no"` have both
    been extracted out of the`<dep>` tag into the tags`<required>` and`<optional>`.
    In addition, the `type` attribute has been extracted out into the tags`<package>,
    <php>`, and the previously undefined`<pearinstaller>` tag. Finally, both the `rel`
    and the `version` attributes have been completely replaced with a new set of tags.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
- en: 'In `package.xml 1.0`, in order to define a version set for a single dependency,
    multiple`<dep>` tags were needed:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'This can be compared to the `package.xml 2.0` equivalent:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: In fact, this change promotes much simpler debugging of dependency problems
    in complex `package.xml` file. The above dependency easily translates into English
    as "Package PackageName from channel [pear.php.net](http://pear.php.net), minimum
    version 1.2.3, maximum version 2.0.0, excluding versions 1.3.0 and 2.0.0." Not
    only is it easier to detect errors using tools like `xmllint`, it is much easier
    to comprehend complex versioning of dependencies.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
- en: The `rel/version` duo has been effectively made obsolete by the combination
    of`<min>/<max>/<exclude>` tags. These three tags can be thought of as newer implementations
    of `rel's ge, le`, and `ne:`
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
- en: '`<min>1.2.0</min>` =`<dep rel="ge" version="1.2.0">`'
  id: totrans-254
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`<max>1.2.0</max>` =`<dep rel="le" version="1.2.0">`'
  id: totrans-255
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`<exclude>1.2.0</exclude>` =`<dep rel="ne" version="1.2.0">`'
  id: totrans-256
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: With these three tags, we can effectively and simply define any version set
    in a single dependency, without needing to think in terms of mathematical comparison
    operators.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
- en: Managing Trust of Dependencies
  id: totrans-258
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The PEAR installer is extremely lithe, making upgrading to newer versions of
    packages so simple; until PEAR version 1.4.0 its greatest strength was also its
    greatest weakness. The ability to easily upgrade packages, as well as the ability
    to perform batch-automated upgrades with commands like `upgrade-all` and `download-all`
    followed by `upgrade` is one of the key selling points of the installer. However,
    this ease is built upon an implicit trust in the quality of newer versions. By
    depending on packages with a simple`<dep type="pkg" rel="ge" version="X.Y.Z">`,
    this gives a carte blanche to the developers of the dependent package. If a dependent
    package's developer introduces a break with previous releases, whether through
    carelessness or lack of sympathy for your code, your end users are in trouble.
    For this reason, bundling dependencies directly in the code has become a favored
    means of distributing applications. This, however, negates the primary benefit
    of the PEAR installer — the ability to quickly and easily upgrade in case of the
    discovery of serious bugs like functionality failures, or worse, subtle security
    vulnerabilities that open up a site to external attack. This also puts the burden
    of maintaining the bundled dependencies directly upon the application maintainer,
    reducing the efficiency of distributed development and all of its contingent benefits.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
- en: '`package.xml 2.0` solves this dilemma simply and elegantly through the introduction
    of a new dependency concept: recommended version. This dependency can be taken
    from PEAR''s `package.xml:`'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'This instructs the installer to upgrade `Console_Getopt` at will to any release
    of `Console_Getopt`, version `1.2` or newer. By changing the dependency to:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: This changes everything. Now, the installer will not automatically upgrade to
    version 1.3.0 upon release, unless the `--force` or `--loose` option is passed,
    or a`<compatible>` tag is present in the release of `Console_Getopt`.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
- en: 'The syntax of`<compatible>` is simple:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: As in dependencies,`<min>/<max>/<exclude>` is used to define a set of versions
    that the package is guaranteed to be compatible with. Unlike dependencies, the`<max>`
    tag is required to limit the set of versions. In addition, the set of versions
    must be limited to actual existing releases that have been tested.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
- en: In theory, it is still possible for lazy developers to implement a`<compatible>`
    tag that is every bit as dangerous as the old `rel="ge"-based` technique of dependency
    management, but this is both unlikely due to the principle of developer inertia
    and easy to catch and correct for the developer whose application depends on the
    dependency.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  id: totrans-269
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**The Principle of Developer Inertia**'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
- en: Developers, like electrons, will choose the path of least resistance to achieve
    their goals. Make it difficult to write bad code and easy to write good code,
    and developers will write good code.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
- en: Reliably Depending on PECL Packages
  id: totrans-272
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Reliably depending on PECL packages has become possible due to two innovations:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
- en: 'The split of the `pear` script into two scripts: `pear` and `pecl`'
  id: totrans-274
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The introduction of the`<providesextension>` tag
  id: totrans-275
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The primary difference between the `pear` and `pecl` commands can be summarized
    as: "Use `pear` to manage packages written in PHP like those at [pear.php.net](http://pear.php.net),
    and use `pecl` to manage packages extending PHP like those at [pecl.php.net](http://pecl.php.net)."
    Technically, the `pecl` command disables `php.ini`, and defaults to the [pecl.php.net](http://pecl.php.net)
    channel, but otherwise it is identical to the `pear` command. Disabling `php.ini`
    makes it possible to upgrade extensions that are inside `php.ini` without unloading
    them.'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
- en: 'The`<providesextension>` tag is used in dependencies as follows:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  id: totrans-278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'This simple addition instructs the installer to treat the package dependency
    on `PDO` as if it were a combination of these two dependencies:'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  id: totrans-280
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: The installer will first check to see if the `PDO` extension is present in memory,
    version 1.0 or newer, and if it is not, it will check the package registry to
    see if [pecl.php.net/PDO](http://pecl.php.net/PDO) version 1.0 or newer is installed.
    This allows, for instance, installation of production extensions for an Apache-based
    PEAR installation using a CLI-based PEAR installer without requiring the CLI-based
    installer to load each extension into its `php.ini`. In addition, it allows extensions
    like `PDO_mysql` to depend on `PDO` without requiring the `PDO` extension to be
    loaded in memory, greatly simplifying the end user experience.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
- en: Release Notes
  id: totrans-282
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In both `package.xml 1.0` and `package.xml 2.0`, release notes are defined by
    the`<notes>` tag. The format of this tag is any text.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Release License
  id: totrans-285
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The text of the`<license>` tag is not validated — anything may be entered there.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  id: totrans-287
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: In `package.xml 2.0` there are optional attributes `uri` and `filesource` for
    linking a license to an online version and also to a specific license file within
    the package itself.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  id: totrans-289
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Changelog
  id: totrans-290
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The format of changelog in `package.xml 1.0` matches the format of a`<release>`
    tag with the exception that`<filelist>` is not allowed. The changelog is purely
    information for human purposes, and is not processed at all by the installer.
    The format for a changelog in `package.xml 2.0` is very similar to that of `package.xml
    1.0`, and is best illustrated by an example:'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  id: totrans-292
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: Like the release section of `package.xml`, the tags`<version>, <stability>,
    <date>, <license>`, and`<notes>` are all present. This is identical to `package.xml
    1.0`. The only difference is the format of the`<version>, <stability>`, and`<license>`
    tags, which match the changes made in `package.xml 2.0`.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
- en: File List, or Contents of the Package
  id: totrans-294
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The primary purpose of PEAR, and by consequence, `package.xml` is to distribute
    files containing programming code. This is ultimately controlled by the list of
    files that are in a package, as defined by`<filelist>` or`<contents>.`
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
- en: For `package.xml 1.0:`
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  id: totrans-297
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: For `package.xml 2.0:`
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  id: totrans-299
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: This tag is the heart of `package.xml` file. Once our trusty package has weathered
    dependency tests, this is the section of `package.xml` that is actually used during
    installation.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
- en: 'The file listing inside a `package.xml` is used to define the directory structure
    inside a release. It must reflect exactly the relative locations of files as they
    were on the computer of the developer. In other words, if the `package.xml` is
    in directory `/home/frank/mypackage/`, and a file in `package.xml` is located
    at `/home/frank /mypackage/foo/test.php`, it must be listed as:'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  id: totrans-302
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Or, alternately as:'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  id: totrans-304
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: Either alternative will yield the same result. At installation time, PEAR will
    automatically convert all recursive directory trees like the second example into
    a single flat branch like the first example.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
- en: New Tags in package.xml
  id: totrans-306
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`package.xml 2.0` introduced the new tags`<phprelease>, <extsrcrelease>`, and`<extbinrelease>`
    to differentiate between the different kinds of packages the PEAR installer handles.
    `package.xml 2.1` introduces`<zendextsrcrelease>` and `<zendextbinrelease>` in
    order to differentiate between regular PHP extensions and Zend extensions like
    `xdebug` ( [http://pecl.php.net/xdebug](http://pecl.php.net/xdebug)).'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
- en: 'You may have noticed that the primary tag in `package.xml 1.0` is named`<filelist>`,
    whereas the primary tag in `package.xml 2.0` is named`<contents>`. This change
    came about as a result of a simple feature request. When PEAR 1.3.3 was popular,
    the need to customize installations grew; more and more attributes and information
    were crammed into the`<file>` tag. The `platform` attribute tells the installer
    that a file should only be installed on a particular platform, such as UNIX or
    Windows. This is used in the PEAR package in order to install the `pear` command
    using a `schell` script on UNIX, and using a `.bat` batch file on Windows. The
    feature request that came in was to implement an additional `platform="!windows"`
    hack that would tell the installer to install the file on every platform except
    Windows. This introduces a number of problems. As package complexity grows, and
    more systems are supported, it may be necessary to specify a limited list of systems
    a file can be installed on, or different names to install the file as required
    on different systems. Implementation of this would require a sophisticated mapping
    between the `install-as` and the `platform` attributes, something that was not
    anticipated by the designers of `package.xml 1.0`, and something that would introduce
    a miserable mess into a single file tag. Imagine encountering this nightmare and
    trying to debug it:'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  id: totrans-309
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: Do you see the typo buried deep in the install-as attribute?
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
- en: 'One day while working on the problem caused by the spectre of such horribly
    complex features, it struck me that attributes like the `platform` attribute were
    actually kludgy ways of implementing dependencies for a specific file. Suddenly,
    the answer was clear. Far better than extending the attribute''s meaning would
    be abstracting the information into separate release tags. Each release tag would
    have a file list and installation conditions that would define which one should
    be used on an end user''s computer. For instance, instead of:'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  id: totrans-312
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'We would have:'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  id: totrans-314
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'However, the most obvious benefit comes from the horrible "Darwin" example.
    This would translate from:'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  id: totrans-316
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'to:'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  id: totrans-318
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'Here, the potential for simple validation is obvious: the`<os>` install condition
    is limited to a few known possibilities such as `windows, unix, linux, Darwin`,
    and so on. The OS "Darwim" would simply refuse to validate. In addition, the complexity
    of how `Foo.scr` is handled is grouped by OS rather than stuffed into a couple
    of attributes with error-prone non-XML syntax.'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
- en: 'File/Directory Attributes: name, role, and baseinstalldir'
  id: totrans-320
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The`<file>` and`<dir>` tags have a number of options available to them. Both
    tags require a `name` attribute, defining the name of the element as located on
    disk. Unlike an operating system, `package.xml` does not allow empty directories.
    All`<dir>` tags must contain at least one`<file>` tag. As described in the previous
    section, there are two ways to describe the location of a file in `package.xml`,
    either with a complete relative path separated by the UNIX path separator `/:`
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  id: totrans-322
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'Or, alternately as:'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  id: totrans-324
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'All files must have a **role** attribute. This attribute tells the installer
    how to handle a file. The default list of allowed file roles is:'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
- en: '| Default File Roles |   |'
  id: totrans-326
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  id: totrans-327
  prefs: []
  type: TYPE_TB
- en: '| Role | Description |'
  id: totrans-328
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  id: totrans-329
  prefs: []
  type: TYPE_TB
- en: '| php | PHP script files, like "PEAR.php" |'
  id: totrans-330
  prefs: []
  type: TYPE_TB
- en: '| data | Data files used by the script (read-only) |'
  id: totrans-331
  prefs: []
  type: TYPE_TB
- en: '| doc | Documentation files |'
  id: totrans-332
  prefs: []
  type: TYPE_TB
- en: '| test | Test scripts, unit test files |'
  id: totrans-333
  prefs: []
  type: TYPE_TB
- en: '| script | Executable script files `(pear.bat, pear.sh)` |'
  id: totrans-334
  prefs: []
  type: TYPE_TB
- en: '| ext | PHP Extension binaries `(php_mysql.dll)` |'
  id: totrans-335
  prefs: []
  type: TYPE_TB
- en: '| src | PHP Extension source files `(mysql.c)` |'
  id: totrans-336
  prefs: []
  type: TYPE_TB
- en: 'Each file role has a configuration value associated with it. For instance,
    on my Windows XP system, here is what I see when I list configuration values:'
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  id: totrans-338
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'In some cases, especially for subpackages like `HTML_QuickForm_Controller`
    ( [http://pear.php.net/package/HTML_QuickForm_Controller](http://pear.php.net/package/HTML_QuickForm_Controller)),
    all files should be installed into a subdirectory (HTML/QuickForm/Controller in
    our example). In order to reflect this installation path in our file, we would
    need to prepend all files with the full path, like so:'
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  id: totrans-340
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'Or, alternately use`<dir>` tags as follows:'
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  id: totrans-342
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'In addition, our actual development path would need to reflect this. This does
    not fit the "make everything easy for lazy developers" development paradigm very
    well, and so PEAR provides the `baseinstalldir` attribute to simplify things.
    Now, all we need is:'
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  id: totrans-344
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'Or, the far more common:'
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  id: totrans-346
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: Tip
  id: totrans-347
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Path Locations on the Development Machine**'
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
- en: 'Note that as a developer, in order for this to work, the actual paths on disk
    must match the`<dir>/<file>` tags. In our example above, the files should be in:'
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
- en: '`Controller/Action.php Controller.php package.xml`'
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
- en: 'Rather than:'
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
- en: '`HTML/QuickForm/Controller/Action.php HTML/QuickForm/Controller.php package.xml`'
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
- en: Otherwise the PEAR installer will be unable to find the files.
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
- en: 'Generally speaking, if a file is listed in `package.xml` as:'
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  id: totrans-355
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: And `php_dir` is `C:\php4\PEAR`, the file will be installed into `C:\php4\PEAR\Path\To\Foo.php`.
    This is not always advantageous, especially for things like scripts. PEAR, for
    instance, places all of its scripts in the `scripts/` subdirectory for easier
    organization. However, this would mean that if `bin_dir` is `C:\php4`,
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  id: totrans-357
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: will be installed into `C:\php4\scripts\pear.bat`, which may not necessarily
    be in the path. To change the base installation directory in PEAR 1.4.x, you need
    to use an`<install>` tag inside a release tag, In addition, it is possible to
    perform text transformations on the contents of files.
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-359
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we discovered the basics of how the PEAR installer's internals
    work through the lens of `package.xml's` structure. First, we explored the basic
    design philosophies of the PEAR installer, and how PEAR packages differ from the
    old-fashioned unzip-and-go approach. We learned about PEAR's configuration options,
    and the versatile ways in which PEAR deals with libraries versus applications.
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
- en: Next, we explored the importance of versioning in controlling the quality of
    packages installed, and the importance of dependencies, and how the PEAR installer
    manages this important link between libraries and applications. Then, we explored
    how easy it is to upgrade when using the PEAR installer, as compared to upgrading
    traditional unzip-and-go applications.
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
- en: After this, we dove headfirst into the structure of `package.xml`, learning
    how package metadata such as the package name, authors, release notes, and changelog
    are organized. This was coupled with a look at how critical installation data
    such as files, dependencies, and versioning is organized.
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
- en: The next chapter will examine advanced topics, specifically how `package.xml
    2.0` introduces better application support, and how to leverage these new features
    in your own packages.
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
