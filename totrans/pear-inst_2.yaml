- en: Chapter 2. Mastering PHP Software Management with the PEAR Installer
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 2 章。使用 PEAR 安装程序精通 PHP 软件管理
- en: In this chapter, we learn how to turn PHP software into distributable PEAR packages.
    In September 2005, version 1.4.0 of the PEAR installer was released. This release
    was a milestone, marking the transformation of PEAR from a niche-market tool for
    installing small libraries distributed by `pear.php.net` to a full-fledged application
    installation tool. For the first time, it is possible to distribute large-scale
    applications, and even complete web-based database-intensive applications can
    be installed and configured in one step.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习如何将 PHP 软件转换为可分发的 PEAR 软件包。2005 年 9 月，PEAR 安装程序的 1.4.0 版本发布。这是一个里程碑，标志着
    PEAR 从 `pear.php.net` 分发的狭小市场工具转变为一个完整的应用程序安装工具。第一次，可以分发大规模的应用程序，甚至完整的基于网络的数据库密集型应用程序也可以一步安装和配置。
- en: 'The PEAR installer now can be used to install traditional web-based applications
    like phpMyAdmin and non-PEAR libraries like the popular Smarty template engine
    (both happen to be installable through the [http://pearified.com](http://pearified.com)
    PEAR channel). Two of the primary design goals of the PEAR installer are to:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: PEAR 安装程序现在可以用来安装传统的基于网络的程序，如 phpMyAdmin 和非 PEAR 库，例如流行的 Smarty 模板引擎（这两个都可以通过
    [http://pearified.com](http://pearified.com) PEAR 频道）安装）。PEAR 安装程序的两个主要设计目标是：
- en: Make it possible to distribute application development across multiple development
    teams (i.e. stop re-inventing the wheel)
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使应用程序开发能够在多个开发团队之间进行分发（即停止重复造轮子）
- en: Prevent conflicting packages from overwriting each other
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 防止冲突的软件包相互覆盖
- en: All of this magic is made possible by the `package.xml` file format. `package.xml`
    is the heart and soul of the PEAR installer, and in order to take full advantage
    of PEAR's power, you need to understand its structure. Contained in `package.xml`
    is a list of files to be installed, information used by the PEAR installer to
    distinguish between different packages and releases, and information that is useful
    to humans, such as a description of what the package is and a changelog. This
    file is in fact all the PEAR installer needs to properly install software. The
    PEAR installer also uses the information in `package.xml` to create an installable
    archive in either `.tar` format or compressed `.tar` (`.tgz`) using the `pear
    package` command.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些魔法都是通过 `package.xml` 文件格式实现的。`package.xml` 是 PEAR 安装程序的核心和灵魂，为了充分利用 PEAR
    的功能，你需要了解其结构。`package.xml` 包含要安装的文件列表，供 PEAR 安装程序区分不同软件包和版本的信息，以及对人类有用的信息，例如软件包的描述和变更日志。实际上，这个文件就是
    PEAR 安装程序正确安装软件所需的一切。PEAR 安装程序还使用 `package.xml` 中的信息，通过 `pear package` 命令创建可安装的存档，格式为
    `.tar` 或压缩的 `.tar`（`.tgz`）。
- en: 'The PEAR installer is not limited to installation of local files, and in fact
    is designed to communicate over the Internet with **PEAR channel servers**. What
    is a channel server? A channel server provides downloadable releases for each
    package, and web service interfaces to meta-information about those packages and
    releases through XML-RPC, REST, or SOAP. Channels are discussed in depth in [Chapter
    5](ch05.html "Chapter 5. Releasing to the World: PEAR Channels"). Now that PEAR
    1.4.0+ and packages like Chiara_PEAR_Server ( [http://pear.chiaraquartet.net/index.php?package=Chiara_PEAR_Server](http://pear.chiaraquartet.net/index.php?package=Chiara_PEAR_Server))
    are available, it is simple to set up your own PEAR channel server and distribute
    libraries and applications with all of the sophistication you''ve come to expect
    from the `pear` command.'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: PEAR 安装程序不仅限于安装本地文件，实际上它是设计用来通过互联网与 **PEAR 频道服务器** 进行通信的。什么是频道服务器？频道服务器为每个软件包提供可下载的版本，并通过
    XML-RPC、REST 或 SOAP 提供关于这些软件包和版本的元信息的网络服务接口。频道在 [第 5 章](ch05.html "第 5 章。向世界发布：PEAR
    频道") 中有深入讨论。现在，随着 PEAR 1.4.0+ 和 Chiara_PEAR_Server（[http://pear.chiaraquartet.net/index.php?package=Chiara_PEAR_Server](http://pear.chiaraquartet.net/index.php?package=Chiara_PEAR_Server)）等软件包的可用，设置自己的
    PEAR 频道服务器并分发库和应用程序变得非常简单，这些都可以通过 `pear` 命令来实现。
- en: Tip
  id: totrans-7
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: '**CLI versus Web/Gtk2 Installer**'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: '**命令行界面（CLI）与 Web/Gtk2 安装程序**'
- en: Some of you reading this have probably installed the Web front end (PEAR_Frontend_Web
    package from `pear.php.net`) or the Gtk2 front end (PEAR_Frontend_Gtk2 package
    from `pear.php.net`). If so, then you have probably noticed that installing packages
    from other channels is even simpler, as the end user simply needs to choose the
    channel to install from, and all packages are listed with the most recent version
    and available upgrades.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 一些阅读此文档的人可能已经安装了Web前端（来自 `pear.php.net` 的 PEAR_Frontend_Web 包）或Gtk2前端（来自 `pear.php.net`
    的 PEAR_Frontend_Gtk2 包）。如果是这样，那么你可能已经注意到，从其他渠道安装包甚至更简单，因为最终用户只需选择要安装的渠道，所有包都会列出最新版本和可用的升级。
- en: We will be working with the command-line (CLI) front end to the PEAR installer
    in the next few chapters, as a much greater level of sophistication is available
    than what is possible through the Web front end, which is designed more for end
    users of PEAR packages than it is for developers of PEAR packages. At the time
    of writing this chapter, the Gtk2 front end is far more sophisticated than the
    Web installer, and is worth using if you are running PHP 5.1.0 or newer.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的几章中，我们将使用命令行（CLI）前端来处理PEAR安装程序，因为与Web前端相比，CLI前端提供了更高级的复杂性，Web前端设计得更多是为了PEAR包的最终用户，而不是PEAR包的开发者。在撰写本章时，Gtk2前端比Web安装程序更复杂，如果你运行的是PHP
    5.1.0或更高版本，那么它值得使用。
- en: 'For example, if your server is `pear.example.com`, and you release a package
    named `Foo`, the only thing your users need to type in order to install your package
    is:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果你的服务器是 `pear.example.com`，并且你发布了一个名为 `Foo` 的包，那么你的用户只需要输入以下内容来安装你的包：
- en: '[PRE0]'
  id: totrans-12
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: However, the most dynamic and important feature of the PEAR installer is the
    sophisticated way in which it handles dependencies on other packages, on PHP version,
    on PHP extensions, and on the system architecture. Through very simple syntax
    in `package.xml`, incredibly complex dependency scenarios can be easily and securely
    managed.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，PEAR安装程序最动态和最重要的功能是它处理对其他包、PHP版本、PHP扩展和系统架构的依赖的复杂方式。通过 `package.xml` 中的非常简单的语法，可以轻松且安全地管理极其复杂的依赖场景。
- en: Before we can get started with the actual work of creating our own packages,
    it is important to understand the core concepts behind the design of the PEAR
    installer and how you will need to shape your software design to best utilize
    its strengths.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始实际创建自己的包的工作之前，了解PEAR安装程序设计背后的核心概念以及你需要如何调整你的软件设计以充分利用其优势是非常重要的。
- en: Distributing Libraries and Applications
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 分发库和应用程序
- en: The most important thing to understand is how the PEAR installer actually installs
    files. Most PHP developers distribute their applications as unzip-and-go archives.
    As such, we tend to assume that files will be in the exact same relative locations
    on the end user's machine that they are on our development machine. PEAR, however,
    is designed to be far more flexible than this.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 最重要的是要理解PEAR安装程序实际上是如何安装文件的。大多数PHP开发者将他们的应用程序作为解压即用的存档进行分发。因此，我们倾向于假设文件将在最终用户机器上的确切相对位置与它们在我们开发机器上的位置相同。然而，PEAR的设计要灵活得多。
- en: For instance, it is common for shared web hosts to install a global copy of
    PEAR, but users can also install local copies and use the `include_path` from
    `php.ini` to choose local packages when available and global ones when they are
    not. In order to make this flexibility possible, PEAR groups and installs files
    by their type or file *role*.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，共享Web主机通常会安装一个全局的PEAR副本，但用户也可以安装本地副本，并使用 `php.ini` 中的 `include_path` 来选择当本地包可用时使用本地包，当不可用时使用全局包。为了使这种灵活性成为可能，PEAR按类型或文件
    *角色* 对组和安装文件。
- en: Each file role has a corresponding configuration entry that defines the location
    at which all files of that file role will be installed. For instance, the php
    file role has a configuration variable named `php_dir` that defines the directory
    into which all PHP files are installed, the data file role has a configuration
    variable named `data_dir`, and so on.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 每个文件角色都有一个相应的配置条目，它定义了所有该文件角色的文件将被安装的位置。例如，PHP文件角色有一个名为 `php_dir` 的配置变量，它定义了所有PHP文件将被安装到的目录，数据文件角色有一个名为
    `data_dir` 的配置变量，依此类推。
- en: This is a radical break from the traditional unzip-and-go philosophy, as it
    allows users to configure the installation locations in any way they desire on
    their own machine. This also means that the use of clever constructs to locate
    installed files such as `dirname(__FILE__)` are dangerous ways to code in a PEAR
    package. Fortunately, there are other clever ways around this that are even more
    flexible and secure.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 这与传统“解压即用”的哲学有着根本性的区别，因为它允许用户根据自己的需求在他们的机器上以任何方式配置安装位置。这也意味着，在 PEAR 包中使用如 `dirname(__FILE__)`
    这样的巧妙构造来定位已安装文件是危险的编码方式。幸运的是，还有其他更灵活、更安全的巧妙方法可以解决这个问题。
- en: Tip
  id: totrans-20
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: '**PEAR Configuration**'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: '**PEAR 配置**'
- en: To retrieve all configuration variables and their values, use the `config-show`
    command. Configuration variables that correspond to file roles generally have
    `_dir` in their name, such as `doc_dir`, and `php_dir`.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 要检索所有配置变量及其值，请使用 `config-show` 命令。与文件角色对应的配置变量通常在其名称中包含 `_dir`，例如 `doc_dir`
    和 `php_dir`。
- en: 'This also changes the development process slightly: instead of testing by running
    code right out of the development directory, the code should first be installed
    via its `package.xml` file and tested as the PEAR equivalent of unzip-and-go.
    For this reason, the most common `pear` command to be used is:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 这也稍微改变了开发过程：不再是直接在开发目录中运行代码进行测试，而是首先通过其 `package.xml` 文件安装代码，并以 PEAR 的解压即用方式测试。因此，最常用的
    `pear` 命令是：
- en: '[PRE1]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: or
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 或者
- en: '[PRE2]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: This command allows the "upgrade" from (for instance) PEAR version 1.5.0a1 to
    PEAR version 1.5.0a1 when a bug has been fixed or a new feature has been added.
    This command in actuality facilitates rapid development by allowing one to quickly
    replace the existing files within a version after having made changes without
    requiring a bump in version number. In other words, if we had to change the version
    every time a minor change was made on a development machine, this would be onerous.
    The `--force` option circumvents this problem.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 此命令允许从（例如）PEAR 版本 1.5.0a1 升级到 PEAR 版本 1.5.0a1，当修复了错误或添加了新功能时。实际上，此命令通过允许在更改后快速替换版本内的现有文件，从而促进了快速开发。换句话说，如果我们每次在开发机器上对微小更改进行更改时都必须更改版本号，这将是非常繁琐的。`--force`
    选项绕过了这个问题。
- en: Although managing installations using PEAR may seem to be more complicated on
    the surface, a quick investigation of *useful* unzip-and-go packages show that
    many unzip-and-go packages actually require a large amount of manual configuration
    that could easily be supplanted by the automated features of the PEAR installer.
    In short, once you get used to it, you'll wonder how you ever developed in PHP
    without using the PEAR installer to manage your packages.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然表面上使用 PEAR 管理安装可能看起来更复杂，但快速调查 *有用的* 解压即用包表明，许多解压即用包实际上需要大量的手动配置，这些配置可以很容易地被
    PEAR 安装程序的自动化功能所取代。简而言之，一旦习惯了它，你就会 wonder 如何在没有使用 PEAR 安装程序来管理你的包的情况下开发 PHP。
- en: Differences between Libraries and Applications from the Installer's Point of
    View
  id: totrans-29
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 从安装程序的角度来看，库和应用程序之间的区别
- en: The acronym **PEAR**means **P***HP***E***xtension*and **A***pplication* **R***epository*,
    but until PEAR version 1.4.0, support for applications was minimal. Most PEAR
    packages are libraries designed to be integrated into other external applications.
    The initial design of the PEAR installer supported this model very effectively,
    but did not provide all of the customization that applications need in order to
    be installed and configured effectively. One of the primary motivations for the
    new features introduced in PEAR version 1.4.0 was better support for application
    installation.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 缩写**PEAR**代表**PHP**扩展和**应用****存****储****库**，但在 PEAR 版本 1.4.0 之前，对应用程序的支持是有限的。大多数
    PEAR 包是设计成可以集成到其他外部应用程序中的库。PEAR 安装程序的初始设计非常有效地支持了这种模式，但并没有提供应用程序安装和配置所需的所有定制化功能。引入
    PEAR 版本 1.4.0 的新功能的主要动机之一是更好地支持应用程序的安装。
- en: In spite of the obvious differences in functionality between libraries and complete
    applications, from the installer's point of view, libraries and applications don't
    need to be handled very differently. Both are distributed using `package.xml`,
    both are stored in the registry in the same way, and the same rules of versioning
    and dependencies are applied. In fact, this is one of PEAR installer's greatest
    strengths, in that it both follows the **KISS** (**Keep It Simple, Stupid**) principle
    and leaves application design to the way `package.xml` is used. Consequently,
    a thorough understanding of the design of `package.xml` is necessary to use its
    capabilities to the fullest for any application or library package.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管库和完整应用程序在功能上存在明显的差异，但从安装程序的角度来看，库和应用程序不需要被非常不同地处理。两者都使用`package.xml`进行分发，都以相同的方式存储在注册表中，并应用相同的版本控制和依赖性规则。实际上，这是PEAR安装程序最大的优势之一，因为它既遵循**KISS**（**Keep
    It Simple, Stupid**）原则，又让应用程序设计取决于`package.xml`的使用方式。因此，为了充分利用其功能，对`package.xml`的设计有深入理解是必要的。
- en: 'New features designed to simplify application development include:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 新特性旨在简化应用程序开发，包括：
- en: Customizable file roles
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可定制的文件角色
- en: Customizable file tasks
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可定制的文件任务
- en: More advanced dependency possibilities and pre-download dependency resolution
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更高级的依赖性可能性和预下载依赖性解析
- en: The ability to bundle several packages into a single tarball
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将多个软件包打包成一个单一的tar包的能力
- en: Static dependencies based on a single release rather than an abstract package
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基于单个发布版本而非抽象包的静态依赖性
- en: After reading this list, if your head is spinning or you're seeing spots resembling
    question marks, fear not — all of these features will be simply and extensively
    explored in the next few sections.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 在阅读完这个列表后，如果你的头脑发晕或者你看到类似问号的斑点，不要担心——所有这些特性将在接下来的几节中简单而详尽地探讨。
- en: Before we launch into the new features, lets take a closer look at some basic
    principles that provide the foundation for best use of the new features.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们深入探讨新特性之前，让我们更仔细地看看一些基本原理，这些原理为最佳使用新特性提供了基础。
- en: Using Versioning and Dependencies to Help Track and Eliminate Bugs
  id: totrans-40
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用版本控制和依赖性帮助跟踪和消除错误
- en: Versioning and dependencies are two features that every enterprise-level distribution
    system must support at a very high level. With both simple dependencies and advanced
    versioning features, the PEAR installer makes depending on external packages safer
    and easier than ever before.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 版本控制和依赖性是每个企业级分发系统必须非常支持的两大特性。有了简单的依赖性和高级版本控制功能，PEAR安装程序使得依赖外部包比以往任何时候都更加安全和容易。
- en: Versioning
  id: totrans-42
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 版本控制
- en: The most basic foundation of the PEAR installer is the concept of versioning.
    Versioning should be familiar to all of us in the form of "Software package version
    X.Y.Z" such as "PHP version 5.1.4". The basic idea is that older versions of software
    have a lower number. In other words, PHP version 4.0.6 is older than PHP version
    4.1.1beta1, which is older than PHP version 4.1.1.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: PEAR安装程序最基本的基础是版本控制的概念。版本控制应该对我们所有人都很熟悉，以“软件包版本X.Y.Z”的形式，例如“PHP版本5.1.4”。基本思想是，软件的旧版本号较低。换句话说，PHP版本4.0.6比PHP版本4.1.1beta1旧，而PHP版本4.1.1beta1又比PHP版本4.1.1旧。
- en: 'How does versioning help track and eliminate bugs? Imagine this scenario:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 版本控制如何帮助跟踪和消除错误？想象以下场景：
- en: You are working on a Wiki, and allowing users to grab the source from your FTP
    site at any time and use it themselves. One of them finds a bug and reports, "It
    is doing this weird thing where it tries to delete all of my files." The user
    can't remember when he or she downloaded the source, as he or she had to restore
    from a backup and the file modification time has been reset. At this point, the
    only way to figure out the problem and whether it still exists in the current
    source is to grab the user project and compare it to the current source line by
    line. At best, this is tedious and at worst completely impossible.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 你正在处理一个Wiki，允许用户随时从你的FTP站点获取源代码并自行使用。其中一位用户发现了一个错误并报告说：“它正在做一件奇怪的事情，试图删除我所有的文件。”用户无法记得他或她何时下载了源代码，因为他或她不得不从备份中恢复，并且文件修改时间已被重置。在这种情况下，唯一确定问题是否存在以及它是否仍然存在于当前源代码中的方法是从用户项目获取并逐行与当前源代码进行比较。在最坏的情况下，这可能是繁琐的，在最坏的情况下是完全不可能的。
- en: Taking a fluid, ever-changing software project and making releases at specific
    times and assigning them a version number makes it much simpler for an end user
    to report a bug. The end user can simply say "Version 1.2.3 of your software package
    does this weird thing where it tries to delete all of my files" and you as the
    developer can ask the user to try the latest version, or the current development
    copy, making bug fixing much simpler.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 对于一个流动的、不断变化的软件项目，在特定时间发布版本并分配版本号，使得最终用户报告错误变得更加简单。最终用户可以简单地说明“您的软件包的 1.2.3
    版本做了这样奇怪的事情，试图删除我所有的文件”，然后您作为开发者可以要求用户尝试最新版本或当前的开发副本，这使得错误修复变得更加简单。
- en: In addition, it is possible to maintain two branches of the same code, a stable
    version, and an unstable version with innovative new features. There are many
    subtle ways of using versioning to provide more information about a software release.
    For instance, the Linux kernel versioning system is described in detail at [http://en.wikipedia.org/wiki/Linux_kernel#Version_Numbering](http://en.wikipedia.org/wiki/Linux_kernel#Version_Numbering).
    In this case, one of the decimal places is used to denote the stability of the
    kernel, such that it is possible to have version 1.2.9 released after 1.3.0.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，还可能维护同一代码的两个分支，一个是稳定版本，另一个是不稳定版本，具有创新的新功能。有许多微妙的方法可以使用版本管理来提供有关软件发布的更多信息。例如，Linux
    内核版本管理系统在 [http://en.wikipedia.org/wiki/Linux_kernel#Version_Numbering](http://en.wikipedia.org/wiki/Linux_kernel#Version_Numbering)
    中有详细描述。在这种情况下，小数点之一用于表示内核的稳定性，因此可以在 1.3.0 之后发布版本 1.2.9。
- en: The PEAR installer takes a more explicit approach to versioning. Rather than
    providing stability information inside the version number, a separate field in
    `package.xml, <stability>`, is used to designate the stability of the code. This
    does not preclude the use of Linux-style versioning, or any other versioning scheme,
    as long as the basic premise (1.3.0 is always newer than 1.2.9) still holds.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: PEAR 安装程序在版本管理上采取了一种更明确的方法。它不是在版本号内部提供稳定性信息，而是在 `package.xml` 中的单独字段 `<stability>`
    中使用来指定代码的稳定性。这并不妨碍使用 Linux 风格的版本管理或任何其他版本管理方案，只要基本前提（1.3.0 总是比 1.2.9 新）仍然成立。
- en: Tip
  id: totrans-49
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: '**Versioning Time versus Absolute Time**'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '**版本时间与绝对时间**'
- en: PEAR's simple versioning rules can actually be kind of confusing in the real
    world. The PEAR installer doesn't particularly care when a version was released
    in real-world time but about its stability and version number.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 在现实世界中，PEAR 的简单版本管理规则实际上可能会有些令人困惑。PEAR 安装程序并不特别关心版本在现实世界中的发布时间，而是关注其稳定性和版本号。
- en: This can mean that, for instance, PEAR 1.3.6 (stable) released on August 18,
    2005 is older than PEAR 1.4.0a1 (alpha) released on February 26, 2005 because
    1.3.6 is less than 1.4.0\. Absolute time has nothing to do with versioning time.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着，例如，2005 年 8 月 18 日发布的 PEAR 1.3.6（稳定版）实际上比 2005 年 2 月 26 日发布的 PEAR 1.4.0a1（alpha
    版）更老，因为 1.3.6 小于 1.4.0。绝对时间与版本时间无关。
- en: The end user can tell the PEAR installer through a configuration variable called
    `preferred_state` how stable packages must be in order to be installed. In our
    hypothetical example, if this variable is set to `stable` or to `beta`, then PEAR
    1.3.6 would be installed instead of 1.4.0a1; otherwise for values less stable
    than beta (`alpha, devel`, and `snapshot`) version 1.4.0a1 would be installed,
    even though version 1.3.6 was released months later, because 1.4.0 is always *newer*
    than 1.3.6 in *versioning time*.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 最终用户可以通过一个名为 `preferred_state` 的配置变量来告诉 PEAR 安装程序，为了安装，必须保证软件包的稳定性。在我们的假设例子中，如果这个变量设置为
    `stable` 或 `beta`，那么将安装 PEAR 1.3.6 而不是 1.4.0a1；否则，对于比 beta 版本稳定性低的值（`alpha`、`devel`
    和 `snapshot`），将安装 1.4.0a1，尽管 1.3.6 版本是在几个月后发布的，因为在版本时间上 1.4.0 总是比 1.3.6 更新。
- en: PEAR Packaging and Strict Version Validation
  id: totrans-54
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: PEAR 打包和严格的版本验证
- en: 'The PEAR package repository at [pear.php.net](http://pear.php.net) uses a strict
    versioning protocol. All package versions are of format X.Y.Z, as in "1.3.0".
    The first digit (X) is used to describe the **Applications Program Interface**
    (**API**) version, the second digit (Y) is used to describe the feature set version,
    and the third digit (Z) is used to describe the bugfix revision level. As examples,
    here are some version numbers and their meaning:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: PEAR 软件包仓库位于 [pear.php.net](http://pear.php.net)，使用严格的版本管理协议。所有软件包版本都是 X.Y.Z
    格式，例如 "1.3.0"。第一个数字（X）用于描述应用程序接口（API）版本，第二个数字（Y）用于描述功能集版本，第三个数字（Z）用于描述错误修复修订级别。以下是一些版本号及其含义的示例：
- en: '| Sample PEAR version numbers and their meanings |   |'
  id: totrans-56
  prefs: []
  type: TYPE_TB
  zh: '| 样例PEAR版本号及其含义 |   |'
- en: '| --- | --- |'
  id: totrans-57
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| Version Number | Meaning |'
  id: totrans-58
  prefs: []
  type: TYPE_TB
  zh: '| 版本号 | 含义 |'
- en: '| --- | --- |'
  id: totrans-59
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| 1.0.0 | Stable API version 1.0, initial stable release of package |'
  id: totrans-60
  prefs: []
  type: TYPE_TB
  zh: '| 1.0.0 | 稳定的API版本1.0，包的初始稳定发布 |'
- en: '| 0.4.5 | Unstable (developing) API, 4th feature set design, 5th bugfix release
    of this feature set |'
  id: totrans-61
  prefs: []
  type: TYPE_TB
  zh: '| 0.4.5 | 不稳定的（开发中）API，第四个功能集设计，该功能集的第五次错误修复发布 |'
- en: '| 2.4.0 | Stable API version 2.0, 4th feature set design, initial release of
    this new feature set |'
  id: totrans-62
  prefs: []
  type: TYPE_TB
  zh: '| 2.4.0 | 稳定的API版本2.0，第四个功能集设计，该新功能集的初始发布 |'
- en: '| 1.3.4 | Stable API version 1.0, 3rd set of new features since the initial
    stable release, 4th bugfix release of this feature set |'
  id: totrans-63
  prefs: []
  type: TYPE_TB
  zh: '| 1.3.4 | 稳定的API版本1.0，自初始稳定发布以来的第三个新功能集，该功能集的第四次错误修复发布 |'
- en: 'At installation time, this information is irrelevant: The PEAR installer will
    install anything it is given, including version numbering schemes like 24.25094.39.430
    or 23.4.0-r1 and so on. However, the validation used when packaging up a package
    via:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 在安装时，此信息是无关紧要的：PEAR安装程序将安装它所提供的任何内容，包括类似于24.25094.39.430或23.4.0-r1等版本编号方案。然而，通过以下方式打包包时使用的验证方式：
- en: '[PRE3]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'is much stricter than that used when downloading a PEAR package. In order to
    assist developers trying to meet the PEAR package repository''s strict coding
    standards, there are a set of validation routines within the PEAR package located
    in `PEAR/Validate.php` that check a number of important aspects of the PEAR coding
    standards, and emit warnings for anything that does not comply. For instance,
    version 1.0.0 must be stable (and not `devel, alpha`, or `beta` stability), and
    so the following snippet from a `package.xml` will cause a warning:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 与下载PEAR包时使用的验证方式相比要严格得多。为了帮助试图满足PEAR包仓库严格编码标准的开发者，PEAR包中位于`PEAR/Validate.php`的验证例程集合会检查PEAR编码标准的多个重要方面，并对任何不符合标准的内容发出警告。例如，版本1.0.0必须是稳定的（而不是`devel,
    alpha`或`beta`稳定性），因此以下来自`package.xml`的片段将导致警告：
- en: '[PRE4]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Specifically, it would look something like this:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 具体来说，它看起来可能像这样：
- en: '**$ pear package**'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '**$ pear package**'
- en: '[PRE5]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Although this is extremely helpful for anyone who wishes to adhere to PEAR''s
    strict coding standards, in some cases this warning is not helpful, but is instead
    annoying or distracting. For instance, a private project may wish to use the Linux
    versioning scheme. Fortunately, there is a way to control the way custom validation
    routines are handled at the packaging, download, or installation phases of the
    PEAR installer. By extending the `PEAR_Validate` class located in `PEAR/Validate.php`,
    a special validator can be created using object-oriented inheritance. To activate
    it, the validator must be associated with a channel. Although this process will
    be discussed in detail in [Chapter 5](ch05.html "Chapter 5. Releasing to the World:
    PEAR Channels"), here is a simple example.'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管这对希望遵守PEAR严格编码标准的人来说非常有帮助，但在某些情况下，这种警告并不有用，反而令人烦恼或分心。例如，一个私有项目可能希望使用Linux版本控制方案。幸运的是，有一种方法可以控制在PEAR安装程序的打包、下载或安装阶段处理自定义验证例程的方式。通过扩展位于`PEAR/Validate.php`中的`PEAR_Validate`类，可以使用面向对象继承创建一个特殊的验证器。要激活它，验证器必须与一个频道相关联。尽管这个过程将在[第5章](ch05.html
    "第5章。向世界发布：PEAR频道")中详细讨论，但这里有一个简单的示例。
- en: 'The developers of PHP extensions at `pecl.php.net` have a much looser version
    validation system, and there is a wide variation of versioning accepted, from
    a two-digit 1.0 to the 7.5.00.26 used by the maxdb package ( [http://pecl.php.net/maxdb](http://pecl.php.net/maxdb))
    to mirror versioning used by MySQL''s MaxDB database. As such, [pecl.php.net](http://pecl.php.net)
    is a separate channel from [pear.php.net](http://pear.php.net), and in its channel
    definition file `channel.xml` (also discussed in depth in [Chapter 5](ch05.html
    "Chapter 5. Releasing to the World: PEAR Channels")) defines a channel validator:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '`pecl.php.net`上的PHP扩展开发者有一个更宽松的版本验证系统，接受的版本控制差异很大，从两位数的1.0到maxdb包（[http://pecl.php.net/maxdb](http://pecl.php.net/maxdb)）使用的7.5.00.26，再到MySQL的MaxDB数据库使用的镜像版本控制。因此，[pecl.php.net](http://pecl.php.net)是[pear.php.net](http://pear.php.net)的一个独立频道，在其频道定义文件`channel.xml`（也在[第5章](ch05.html
    "第5章。向世界发布：PEAR频道")中详细讨论）中定义了一个频道验证器：'
- en: '[PRE6]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'This particular channel validator is distributed with the PEAR installer in
    the file `PEAR/Validator/PECL.php`. This file is both the perfect example of a
    customized channel validator and the simplest, so here it is, in all of its glory:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 这个特定的频道验证器与PEAR安装程序一起分发，在文件`PEAR/Validator/PECL.php`中。这个文件是定制频道验证器的完美示例，也是最简单的，所以在这里，展示其全部的辉煌：
- en: '[PRE7]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: This class simply overrides the strict version validation of its parent, and
    then adds in a PECL-specific check to see if an extension package is claiming
    to distribute a differently-named extension from the package name. In addition,
    it checks for a release candidate with (lower-case) `rc` in the version, as PHP's
    `version_compare()` function ( [http://www.php.net/version_compare](http://www.php.net/version_compare))
    treats this very differently from versions containing (upper-case) `RC`.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 这个类只是简单地覆盖了其父类的严格版本验证，然后添加了一个PECL特定的检查，以查看一个扩展包是否声称分发一个与包名不同名称的扩展。此外，它还会检查版本中是否包含（小写）`rc`作为候选发布版本，因为PHP的`version_compare()`函数（[http://www.php.net/version_compare](http://www.php.net/version_compare)）对此处理方式与包含（大写）`RC`的版本非常不同。
- en: Tip
  id: totrans-77
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: '**Why are pear.php.net and pecl.php.net Separate Channels?**'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '**为什么pear.php.net和pecl.php.net是独立的频道？**'
- en: In earlier PEAR versions, the `pear` command was used to install both PEAR packages
    and **PHP Extension Community Library** (**PECL**) packages. This was changed
    in version 1.4.0 for a number of reasons. First of all, the developers at [pear.php.net](http://pear.php.net)
    are developing packages written in PHP. Developers at [pecl.php.net](http://pecl.php.net)
    are developing packages written in C that are compiled to shared `.dll` or `.so`
    files as internal components (extensions) of PHP itself. There are intrinsic differences
    in the way PEAR-style packages are installed and maintained compared to the PECL-style
    packages.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 在早期的PEAR版本中，`pear`命令用于安装PEAR包和**PHP扩展社区库**（**PECL**）包。由于多个原因，这一变化发生在1.4.0版本中。首先，[pear.php.net](http://pear.php.net)的开发者正在开发用PHP编写的包。而[pecl.php.net](http://pecl.php.net)的开发者正在开发用C编写的包，这些包被编译成共享的`.dll`或`.so`文件，作为PHP本身的内部组件（扩展）。与PECL风格的包相比，PEAR风格的包在安装和维护方面存在固有的差异。
- en: One of these differences is the importance given to proper versioning. PECL
    and PHP extensions can't co-exist with conflicting extensions; only one can run
    at a time. PEAR packages do not have this restriction, as several different versions
    of a PEAR package can co-exist and be loaded interchangeably through the `include_path`,
    so versioning becomes much more important.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 这些差异之一是正确版本的重要性。PECL和PHP扩展不能与冲突的扩展共存；一次只能运行一个。PEAR包没有这种限制，因为多个不同版本的PEAR包可以共存并通过`include_path`进行交替加载，因此版本控制变得尤为重要。
- en: In addition, because of file locking, an extension that is loaded into memory
    cannot be uninstalled, making upgrading PHP extensions impossible unless `php.ini`
    is not used.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，由于文件锁定，加载到内存中的扩展无法卸载，这使得在不使用`php.ini`的情况下升级PHP扩展成为不可能。
- en: There are a number of other small reasons that all added up to the need for
    a split, such as confusion over the function of packages (is this a PHP extension
    or a script written in PHP?) and so now we have both the `pear` and the new `pecl`
    command for managing PECL-packages.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多其他小原因加在一起导致了需要分割，例如对包的功能的混淆（这是一个PHP扩展还是用PHP编写的脚本？），因此现在我们既有`pear`也有新的`pecl`命令来管理PECL包。
- en: Enterprise-Level Dependency Management
  id: totrans-83
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 企业级依赖管理
- en: Dependencies are a natural evolution in software design. If your forum package
    attempts to separate business logic from display by using a template engine, it
    is far better to focus your energies on developing the forum functionality than
    it is to design a new template engine. Not only have the authors of existing template
    engines spent more time working on and thinking about template engines, their
    template engine has been used by thousands of other developers just like you.
    All of the common and most of the unusual problems have been encountered and solved.
    In the event that you do find a new problem, you can report it to the maintainers,
    or even exercise the full strength of open source and fix the problem yourself
    and give the solution back to the maintainers.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 依赖关系是软件设计中的自然演变。如果您的论坛包尝试通过使用模板引擎将业务逻辑与显示分离，那么将精力集中在开发论坛功能上要比设计一个新的模板引擎好得多。不仅现有模板引擎的作者在模板引擎上花费了更多的时间和精力，而且他们的模板引擎已经被成千上万的开发者（就像您一样）使用。所有常见问题和大多数不寻常问题都已被遇到并解决。如果在您发现新的问题时，您可以向维护者报告，甚至可以充分利用开源的力量自行修复问题并将解决方案反馈给维护者。
- en: On the other hand, this requires putting trust in the maintainers of the template
    engine. By using the template engine, you implicitly trust the maintainers to
    effectively manage it, to fix all bugs discovered, and to prevent introducing
    new bugs into future releases. You also trust the maintainers to continue maintaining
    the package and to respond to issues you encounter.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，这需要信任模板引擎的维护者。通过使用模板引擎，您隐含地信任维护者能够有效地管理它，修复发现的全部错误，并防止在未来的版本中引入新的错误。您还信任维护者会继续维护该包，并回应您遇到的问题。
- en: PEAR developers have been around long enough to know that at its worst, this
    trust can be naïve or stupid, as software is still maintained by humans who have
    the capacity to screw up. Fortunately, because of this knowledge, `package.xml`
    provides complete control over the "trust" of a dependency.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: PEAR 开发者已经存在很长时间，知道在最坏的情况下，这种信任可能是天真的或愚蠢的，因为软件仍然由有能力出错的人类维护。幸运的是，由于这种知识，`package.xml`
    提供了对依赖关系“信任”的完全控制。
- en: Tip
  id: totrans-87
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: '**Dependencies in package.xml**'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '**package.xml 中的依赖关系**'
- en: For more details on how dependencies work in `package.xml`, see the section
    *External Dependencies*
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 关于 `package.xml` 中依赖关系的工作方式，请参阅 *外部依赖关系* 部分
- en: 'The simplest dependency tells the installer that a package must be used but
    that we don''t need to check for versioning issues: it is enough that it is installed.
    In `package.xml 2.0`, this dependency looks something like:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 最简单的依赖关系会告诉安装程序必须使用该包，但我们不需要检查版本问题：只要安装即可。在 `package.xml 2.0` 中，这种依赖关系看起来像这样：
- en: '[PRE8]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'A slightly more restrictive dependency might tell the installer to only install
    versions newer than a minimum of version 1.2.0:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 一个稍微更严格的依赖关系可能会告诉安装程序只安装比最小版本 1.2.0 新的版本：
- en: '[PRE9]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Going further, it may be the case that there were a few bungled releases. We
    can tell the installer to ignore specific releases 1.2.0 and 1.4.2, but that every
    other version newer than 1.2.0 is OK to install:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 进一步来说，可能存在一些混乱的发布。我们可以告诉安装程序忽略特定的发布版本 1.2.0 和 1.4.2，但其他所有比 1.2.0 新的版本都可以安装：
- en: '[PRE10]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Finally, we can also tell the installer that we want to strongly recommend
    version 1.4.5, and to never upgrade unless we say it is OK:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们还可以告诉安装程序，我们强烈推荐版本 1.4.5，并且除非我们说可以升级，否则不要升级：
- en: '[PRE11]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: In this last case, we are given a tremendous amount of control over the dependency.
    The end user cannot accidentally break our package by upgrading to a newer release
    of a dependency unless the maintainers of the dependency have worked with you
    on your package and certified its compatibility with another tag,`<compatible>`,
    or you do another release of your package that recommends the newer version.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 在最后一种情况下，我们得到了对依赖关系的大量控制。最终用户在依赖关系的维护者与您合作并认证其与另一个标签 `<compatible>` 的兼容性，或者您发布了一个推荐新版本的包之前，不会意外地通过升级到依赖关系的新版本而破坏我们的包。
- en: The differing levels of trust afforded by dependencies in `package.xml` mean
    you can securely depend on other packages, but this is only the beginning of PEAR's
    dependency features. The other common problem solved by the use of dependencies
    is basic incompatibilities with the end user's computer, operating system, PHP
    version, or enabled extensions in `php.ini`. PEAR provides dependency tags for
    each one of these situations. In addition, optional features or plug-ins can be
    implemented through optional dependencies or dependency groups. The list of possibilities
    is staggering, and yet the syntax in `package.xml` is simple and very easy to
    learn.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '`package.xml` 中依赖项提供的不同信任级别意味着您可以安全地依赖其他软件包，但这只是 PEAR 依赖项功能的开始。依赖项解决的另一个常见问题是与最终用户的计算机、操作系统、PHP
    版本或 `php.ini` 中启用的扩展的基本不兼容性。PEAR 为这些情况中的每一个都提供了依赖项标签。此外，可选功能或插件可以通过可选依赖项或依赖组实现。可能性的列表令人印象深刻，而
    `package.xml` 中的语法简单且易于学习。'
- en: Distribution and Upgrades for the End User
  id: totrans-100
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 最终用户的分发和升级
- en: From the end user's perspective, one of the most complex tasks faced when using
    an unzip-and-go package is upgrading. In the closed-source world, newer versions
    of a package break something that used to work with the old package as a means
    of forcing their users to upgrade, which sometimes requires significant work.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 从最终用户的角度来看，在使用解压即用的软件包时，面临的最复杂任务之一就是升级。在闭源世界中，软件包的新版本会破坏旧版本中曾经正常工作的某些功能，以此来强迫用户升级，这有时需要大量的工作。
- en: In the open-source world, many developers continue to follow this model by introducing
    exciting new features that mean you can no longer use the old version. The actual
    upgrade process usually means overwriting the current version with the new files,
    possibly with new configuration needed. In addition, it opens up the scary prospect
    of completely breaking a live site, prompting the need for some kind of backup
    system.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 在开源世界中，许多开发者通过引入令人兴奋的新功能继续遵循这一模式，这意味着您将无法再使用旧版本。实际的升级过程通常意味着用新文件覆盖当前版本，可能还需要新的配置。此外，它还带来了完全破坏实时网站的可怕前景，这促使需要某种备份系统。
- en: 'By using the PEAR installer, all of these fears and dangers are a thing of
    the past. It is simple to upgrade to a new version by using:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用 PEAR 安装程序，所有这些恐惧和危险都已成为过去。使用以下方法升级到新版本非常简单：
- en: '[PRE12]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'It is just as simple to downgrade to a previous version of the package:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 将软件包降级到旧版本同样简单：
- en: '[PRE13]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: This makes the task of maintaining a live site both easy and secure — a rare
    and wonderful combination. Note that this example assumes the old version of the
    package is `1.2.3`.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 这使得维护一个实时网站既简单又安全——这是一个罕见而美好的组合。请注意，此示例假设软件包的旧版本为 `1.2.3`。
- en: 'In addition, upgrading or installing dependencies is just as easy. Required
    dependencies are always downloaded and installed for packages that make use of
    `package.xml 2.0`, and for packages that use `package.xml 1.0`, dependencies can
    be automatically downloaded and installed with the `--onlyreqdeps` (only required
    dependencies) option like this:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，升级或安装依赖项同样简单。对于使用 `package.xml 2.0` 的软件包，总是下载并安装所需的依赖项，而对于使用 `package.xml
    1.0` 的软件包，可以使用 `--onlyreqdeps`（仅必需依赖项）选项自动下载和安装依赖项，如下所示：
- en: '[PRE14]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Optional dependencies can also be automatically installed using the `--alldeps`
    (all dependencies) option:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用 `--alldeps`（所有依赖项）选项自动安装可选依赖项：
- en: '[PRE15]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'In addition, creating feature groups, or grouping several related packages
    into a single dependency, is easily accomplished with dependency groups, meaning
    users can install feature groups like PEAR''s web installer feature like so:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，通过依赖组创建功能组，或者将几个相关软件包组合成一个单一依赖项，可以轻松实现，这意味着用户可以像安装 PEAR 的网络安装程序功能一样安装功能组：
- en: '[PRE16]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: When configuring a package, there is often a large amount of work that needs
    to be performed to configure file locations, set up databases, and so on. PEAR
    provides some simple ways to automate configuration, and also provides ways to
    standardize any level of complex setup through post-installation scripts.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 当配置一个软件包时，通常需要执行大量工作来配置文件位置、设置数据库等。PEAR 提供了一些简单的方法来自动化配置，同时也提供了通过安装后脚本标准化任何复杂设置的方法。
- en: If you're anything like me, thinking of all the possibilities built into the
    PEAR installer makes your heart race faster with anticipation. Even if you're
    not quite that geeky, I'm sure you will find that the power of the PEAR installer
    will make your programming life easier.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您像我一样，想到内置在PEAR安装程序中的所有可能性会让您的心跳加速，充满期待。即使您不是那么极客，我也相信您会发现PEAR安装程序的力量会让您的编程生活变得更轻松。
- en: An Overview of package.xml Structure
  id: totrans-116
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`package.xml`结构概述'
- en: '`package.xml` contains all of the information the PEAR installer needs to install
    and configure PEAR packages. By leveraging standards such as XML and XSchema to
    document package structure ( [http://pear.php.net/dtd/package1.xsd](http://pear.php.net/dtd/package1.xsd)
    and [http://pear.php.net/dtd/package2.xsd](http://pear.php.net/dtd/package2.xsd)
    have full definitions of `package.xml 1.0` and `package.xml 2.0` respectively),
    PEAR opens up future programming possibilities that would not be available otherwise.
    For instance, using XSchema allows future extensibility of `package.xml` using
    XML namespaces to provide custom functionality.'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: '`package.xml`包含了PEAR安装程序安装和配置PEAR包所需的所有信息。通过利用XML和XSchema等标准来记录包结构（[http://pear.php.net/dtd/package1.xsd](http://pear.php.net/dtd/package1.xsd)和[http://pear.php.net/dtd/package2.xsd](http://pear.php.net/dtd/package2.xsd)分别提供了`package.xml
    1.0`和`package.xml 2.0`的完整定义），PEAR打开了未来编程的可能性，否则这些可能性将不可用。例如，使用XSchema允许通过XML命名空间扩展`package.xml`，以提供自定义功能。'
- en: When discussing `package.xml`, it is important to understand both the commonality
    and the differences between `package.xml 1.0` and `package.xml 2.0`. The `package.xml
    2.0` is a superset of `package.xml 1.0`. In other words, it is possible to represent
    every single possible `package.xml` version 1.0 as a `package.xml 2.0`, but there
    is a large set of `package.xml 2.0` that cannot be reduced to unique `package.xml
    1.0`.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 讨论到`package.xml`时，理解`package.xml 1.0`和`package.xml 2.0`之间的共性和差异是很重要的。`package.xml
    2.0`是`package.xml 1.0`的超集。换句话说，可以将每个可能的`package.xml`版本1.0表示为`package.xml 2.0`，但有一大批`package.xml
    2.0`不能简化为唯一的`package.xml 1.0`。
- en: The best way to get acquainted with the structure of `package.xml 1.0` is to
    peruse the CVS of the PEAR repository at [cvs.php.net](http://cvs.php.net). Each
    subdirectory contains a `package.xml` file. If that `package.xml` file begins
    with`<package version="1.0"...` then it is a `package.xml 1.0`. Many packages
    are already taking advantage of `package.xml 2.0`, using a file named `package2.xml`.
    Also useful is to investigate the PECL repository at [http://cvs.php.net/pecl/](http://cvs.php.net/pecl/)
    and see how PHP extension developers are using `package.xml`.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 了解`package.xml 1.0`的结构最好的方法是查看PEAR仓库的CVS（[cvs.php.net](http://cvs.php.net)）。每个子目录都包含一个`package.xml`文件。如果该`package.xml`文件以`<package
    version="1.0"...`开头，那么它就是`package.xml 1.0`。许多包已经利用了`package.xml 2.0`，使用名为`package2.xml`的文件。同时，调查PECL仓库[http://cvs.php.net/pecl/](http://cvs.php.net/pecl/)也很有用，看看PHP扩展开发者是如何使用`package.xml`的。
- en: 'To explore the equivalent `package.xml 2.0`, there is a convenient PEAR command
    that can be used to convert a `package.xml 1.0` into a `package.xml 2.0`. This
    command is invoked as follows:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 要探索等效的`package.xml 2.0`，有一个方便的PEAR命令可以将`package.xml 1.0`转换为`package.xml 2.0`。该命令的调用方式如下：
- en: '[PRE17]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: This will parse a file in the current directory named `package.xml` and spit
    out a file named `package2.xml` in the new format.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 这将解析当前目录中名为`package.xml`的文件，并以新格式输出名为`package2.xml`的文件。
- en: In addition, full up-to-date documentation on `package.xml` is always available
    in the PEAR manual at [http://pear.php.net/manual/](http://pear.php.net/manual/).
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，关于`package.xml`的完整最新文档始终可在PEAR手册的[http://pear.php.net/manual/](http://pear.php.net/manual/)中找到。
- en: For the purposes of this book, we will be primarily discussing `package.xml
    2.0`, and only mentioning 1.0 to remark on important conceptual changes for those
    who are familiar with the old format.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 为了这本书的目的，我们将主要讨论`package.xml 2.0`，并且只提及1.0版本，以供熟悉旧格式的人了解重要的概念性变化。
- en: Here is a sample `package.xml` file. This one is taken from the PEAR package
    itself, and demonstrates a number of `package.xml's` features that will be explored
    in the sections to come. Feel free to skim this example and then refer back to
    it later on. For now, just absorb the basic structure and the specifics will make
    sense when you read about them later on in this text.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是一个`package.xml`文件的示例。这个示例是从PEAR包本身取出的，展示了将在后续章节中探讨的`package.xml`的一些功能。您可以随意浏览这个示例，稍后再回来参考。现在，只需吸收基本结构，具体细节将在您阅读文本的后续部分时变得有意义。
- en: '[PRE18]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Tags Shared between package.xml 1.0 and 2.0
  id: totrans-127
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: package.xml 1.0 和 2.0 之间的共享标签
- en: If you have a basic understanding of `package.xml 1.0` and just want to see
    what has changed in `package.xml 2.0`, it is best to skim the next few sections.
    Differences are always presented at the beginning of each section, followed by
    an in-depth exploration of the reasoning behind the changes.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你已经对`package.xml 1.0`有基本的了解，只想查看`package.xml 2.0`中的变化，最好浏览接下来的几节内容。每个部分的差异总是在开头展示，随后深入探讨变化背后的原因。
- en: Before launching into the advanced new features of `package.xml 2.0`, it is
    important to explore the tags and attributes that have been carried over from
    `package.xml 1.0` that both formats have in common. Most tags are unchanged. A
    few have either added information or changed their name slightly, and others have
    been completely redesigned. Let's get started.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 在深入探讨`package.xml 2.0`的高级新功能之前，了解从`package.xml 1.0`继承下来的标签和属性非常重要。这两种格式都有共同的标签。大多数标签没有变化。少数标签增加了信息或稍微更改了名称，而其他标签则被完全重新设计。让我们开始吧。
- en: Package Metadata
  id: totrans-130
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 包元数据
- en: 'Both `package.xml` versions provide similar package metadata. Some basic information
    that must be present in any package includes:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 两个版本的`package.xml`都提供了类似的包元数据。任何包都必须包含的一些基本信息包括：
- en: Package name/channel
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 包名称/频道
- en: Maintainers (authors)
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 维护者（作者）
- en: Package description
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 包描述
- en: Package summary (one-line description)
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 包摘要（单行描述）
- en: Most of this information remains unchanged from release to release. For instance,
    the package name and channel are constant. The package description and summary
    will change rarely. The maintainers may change more frequently, depending on the
    community, so even though this is grouped under package metadata, it is probably
    reasonable to think of this as release-based information.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 这些信息在版本之间通常保持不变。例如，包名称和频道是恒定的。包描述和摘要很少改变。维护者可能会更频繁地改变，这取决于社区，因此尽管这被归类为包元数据，但将其视为基于发布的信息可能是合理的。
- en: Package Name/Channel
  id: totrans-137
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 包名称/频道
- en: 'These two fields are at the beginning of a `package.xml`, and form the heart
    of the PEAR installer''s package differentiation. These are like the primary key
    in a database table: a unique combination of package/channel = a unique package.
    Note that the`<channel>` and`<uri>` tags are only present in `package.xml 2.0`.'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个字段位于`package.xml`的开头，是 PEAR 安装程序区分包的核心。它们就像数据库表中的主键：包/频道 = 唯一的包。请注意，`<channel>`和`<uri>`标签仅在`package.xml
    2.0`中存在。
- en: '[PRE19]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Tip
  id: totrans-140
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: '**Channels and package.xml 1.0**'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: '**频道和package.xml 1.0**'
- en: As you learned earlier, the concept of channels is introduced in `package.xml
    2.0`. How does `package.xml 1.0` define the channel when it is not a part of its
    specification?
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 如你之前所学的，频道的概念是在`package.xml 2.0`中引入的。当它不是其规范的一部分时，`package.xml 1.0`是如何定义频道的呢？
- en: 'PEAR handles this problem in a simple way: all packages packaged using `package.xml
    1.0` are installed as if they had a`<channel>pear.php.net</channel>` tag inserted
    right after the package name declaration. Note that [pecl.php.net](http://pecl.php.net)
    packages that used `package.xml 1.0` are allowed to migrate to the [pecl.php.net](http://pecl.php.net)
    channel when they upgrade to using a `package.xml 2.0`, but all other packages
    must start over with a new channel.'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: PEAR 以一种简单的方式处理这个问题：使用`package.xml 1.0`打包的所有包都被安装，就好像在包名称声明之后立即插入了一个`<channel>pear.php.net</channel>`标签。请注意，[pecl.php.net](http://pecl.php.net)上的使用`package.xml
    1.0`的包在升级到使用`package.xml 2.0`时允许迁移到[pecl.php.net](http://pecl.php.net)频道，但所有其他包必须从新的频道重新开始。
- en: 'The package name is declared using the`<name>` tag, and must begin with a letter,
    and otherwise contain only letters, numbers and the underscore character, unless
    the channel-specific validator allows another format for the package name. Channel-specific
    validators are covered in depth in [Chapter 5](ch05.html "Chapter 5. Releasing
    to the World: PEAR Channels"). If you are simply creating a package, you need
    not know anything about channel-specific validators. If your package satisfies
    the requirements for a package, when you run:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 包名称使用`<name>`标签声明，并且必须以字母开头，否则只能包含字母、数字和下划线字符，除非频道特定的验证器允许包名称采用其他格式。频道特定的验证器在[第5章](ch05.html
    "第5章。向世界发布：PEAR 频道")中有详细说明。如果你只是创建一个包，你不需要了解任何关于频道特定验证器的内容。如果你的包满足包的要求，当你运行：
- en: '[PRE20]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Your package will be created without errors. Otherwise, packaging will fail,
    and one or more error messages will be presented describing the reasons for failure.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 你的包将会无错误地创建。否则，打包将会失败，并且会显示一个或多个错误消息，描述失败的原因。
- en: The`<channel>` tag cannot co-exist with the`<uri>` tag. A package that uses
    the`<uri>` tag is in fact automatically part of the pseudo-channel `__uri`, a
    channel that does not have a server or protocols associated with it. The `__uri`
    channel is in fact a true magic channel that only serves to act as a namespace
    preventing URI-based packages from conflicting with packages from other channels.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: '`<channel>`标签不能与`<uri>`标签共存。使用`<uri>`标签的包实际上是伪频道`__uri`的一部分，这个频道没有与之关联的服务器或协议。`__uri`频道实际上是一个真正的魔法频道，它只用来作为命名空间，防止基于URI的包与其他频道的包冲突。'
- en: 'For instance, consider a package whose `package.xml` begins with:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，考虑一个`package.xml`文件开始的包：
- en: '[PRE21]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: This package is *not* the same as a package whose `package.xml` begins with
    the following code even if the version number of the package is `1.2.3`.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 即使包的版本号为`1.2.3`，这个包与`package.xml`以以下代码开始的包也不相同。
- en: '[PRE22]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: URI-based packages are strictly release-based. The`<uri>` tag must be an absolute,
    real-world URI that can be used to access the package. However, the URI should
    not include a `.tgz` or `.tar` file extension, but both should be present. In
    our example above, both [http://pear.php.net/Packagename-1.2.3.tgz](http://pear.php.net/Packagename-1.2.3.tgz)
    and [http://pear.php.net/Packagename-1.2.3.tar](http://pear.php.net/Packagename-1.2.3.tar)
    should exist and be identical except for the use of zlib compression on the `.tgz`.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 基于URI的包是严格基于发布的。`<uri>`标签必须是一个绝对的真实URI，可以用来访问该包。然而，URI不应该包含`.tgz`或`.tar`文件扩展名，但两者都应该存在。在我们的例子中，[http://pear.php.net/Packagename-1.2.3.tgz](http://pear.php.net/Packagename-1.2.3.tgz)和[http://pear.php.net/Packagename-1.2.3.tar](http://pear.php.net/Packagename-1.2.3.tar)都应该存在，并且除了`.tgz`使用zlib压缩外，两者应该是相同的。
- en: Maintainers (Authors)
  id: totrans-153
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 维护者（作者）
- en: The list of maintainers in `package.xml` should serve the same function that
    a traditional `AUTHORS` file serves. However, this list of authors is more than
    just useful information. The`<user>` tag is used by a channel server to match
    up package maintainers with the release of a package, allowing non-channel administrators
    to upload releases of software packages that they maintain. If you are maintaining
    a package that is released through [pear.php.net](http://pear.php.net), for instance,
    the`<user>` tag must contain your PEAR username. For non-channel releases, the
    contents of these tags are informational only, and let end users of your package
    know how to contact you.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: '`package.xml`中维护者的列表应该起到与传统`AUTHORS`文件相同的作用。然而，这个作者列表不仅仅是有用的信息。《user》标签被频道服务器用来将包维护者与包的发布匹配起来，允许非频道管理员上传他们维护的软件包的发布版本。例如，如果你维护的是通过[pear.php.net](http://pear.php.net)发布的包，那么`<user>`标签必须包含你的PEAR用户名。对于非频道发布，这些标签的内容仅作为信息，让包的最终用户知道如何联系你。'
- en: The`<role>` tag in `package.xml 1.0` may only contain the values `lead, developer,
    contributor`, or `helper`. This proves to be impossible to validate using XSchema,
    and so to make things easier, `package.xml 2.0` has taken the contents of the`<role>`
    tag and extracted them out to new tags`<lead>, <developer>, <contributor>`, and`<helper>`.
    In addition, the`<maintainers>` and`<maintainer>` tag have been removed to simplify
    parsing.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: '`package.xml 1.0`中的`<role>`标签只能包含`lead`、`developer`、`contributor`或`helper`的值。这证明使用XSchema进行验证是不可能的，因此为了简化事情，`package.xml
    2.0`已经将`<role>`标签的内容提取出来，并创建了新的标签`<lead>`、`<developer>`、`<contributor>`和`<helper>`。此外，`<maintainers>`和`<maintainer>`标签已被移除以简化解析。'
- en: For `package.xml 1.0:`
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 对于`package.xml 1.0`：
- en: '[PRE23]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: For `package.xml 2.0:`
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 对于`package.xml 2.0`：
- en: '[PRE24]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Package Description and Summary
  id: totrans-160
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 包描述和摘要
- en: The example summary/description pair below shows how the`<summary>` and`<description>`
    tags should be used in both `package.xml 1.0` and `package.xml 2.0`. These tags
    are strictly informational, and are not used by the installation portions of the
    PEAR installer. If a package is served through a channel, commands like `list-all`
    will display the summary. The description is displayed when a user types commands
    like `info` or `remote-info` to display information about a particular package
    or release.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
- en: Be sure that these tags are clear, concise, and understandable. Too often, I
    have seen summaries like `GBRL` for a package named `File_GBRL` — define your
    acronyms if they are not commonly known!
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Basic Release Metadata
  id: totrans-164
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The rest of `package.xml` is generally release-specific data, with a few exceptions.
    Release-specific data is more apt to change than things like the name of a package.
    Specifically, the areas of release-specific information documented in `package.xml`
    are:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
- en: Package version
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Package stability
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: External dependencies
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Release notes
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Release license
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Changelog
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: File list, or contents of the package
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In `package.xml 1.0`, this data was enclosed in a redundant`<release>` tag.
    This tag has been removed in version 2.0.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
- en: Package Version
  id: totrans-174
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The package version is very important, as this is the primary mechanism used
    by the installer to determine the relative age of different releases. Versions
    are sequential, meaning version 1.3.6 is older than version 1.4.0b1, even if version
    1.3.6 was released a month after 1.4.0b1.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: For `package.xml 2.0:`
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'The API version of a release is strictly for informational purposes. This can,
    however, be used in a `replace` task as follows:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'This reduces redundancy in maintaining versioning inside files. In fact, providing
    API version through an API method is a very good idea. In my packages, I usually
    provide this code:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Upon packaging, the `Foo.php` file containing the above code would look like
    this:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: In other words, all instances of the `@API-VER@` token will be replaced with
    the contents of the`<api>` version tag. Replacement file tasks are used to perform
    this magic.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
- en: Package Stability
  id: totrans-186
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In `package.xml 1.0`, the`<state>` tag was used to describe the stability of
    code. In `package.xml 2.0`, the`<release>` tag inside`<stability>` is used to
    describe the stability of code.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: For `package.xml 2.0:`
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'The PEAR installer uses the release stability in conjunction with an end user''s
    `preferred_state` configuration variable to determine whether a release is stable
    enough to install. If the user wishes to install the `Foo` package, and these
    releases are available:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
- en: '| Version | Stability |'
  id: totrans-192
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  id: totrans-193
  prefs: []
  type: TYPE_TB
- en: '| 1.0.1 | stable |'
  id: totrans-194
  prefs: []
  type: TYPE_TB
- en: '| 1.1.0a1 | alpha |'
  id: totrans-195
  prefs: []
  type: TYPE_TB
- en: '| 1.0.0 | stable |'
  id: totrans-196
  prefs: []
  type: TYPE_TB
- en: '| 0.9.0 | beta |'
  id: totrans-197
  prefs: []
  type: TYPE_TB
- en: '| 0.8.0 | alpha |'
  id: totrans-198
  prefs: []
  type: TYPE_TB
- en: The installer will choose versions to install based on the user's `preferred_state`
    setting.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
- en: '| preferred_state value | Foo version that would be installed |'
  id: totrans-200
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  id: totrans-201
  prefs: []
  type: TYPE_TB
- en: '| stable | 1.0.1 |'
  id: totrans-202
  prefs: []
  type: TYPE_TB
- en: '| beta | 1.0.1 |'
  id: totrans-203
  prefs: []
  type: TYPE_TB
- en: '| alpha | 1.1.0a1 |'
  id: totrans-204
  prefs: []
  type: TYPE_TB
- en: Note that for a `preferred_state` of `beta`, when there is a choice of a newer
    version 1.0.1 `(stable)` and older version 0.9.0 `(beta)`, the installer will
    choose the latest, most stable version — version 1.0.1\. For a `preferred_state`
    of `alpha`, the installer will choose the newer and less stable version 1.1.0a1
    `(alpha)` over the older version 1.0.1 `(stable)`, even though version 1.0.1 was
    released *after* version 1.1.0a1.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，对于 `preferred_state` 为 `beta` 的情况，当可以选择较新版本 1.0.1（稳定）和较旧版本 0.9.0（beta）时，安装程序将选择最新、最稳定的版本——版本
    1.0.1。对于 `preferred_state` 为 `alpha` 的情况，安装程序将选择较新但不太稳定的版本 1.1.0a1（alpha），即使版本
    1.0.1 是在版本 1.1.0a1 之后发布的。
- en: 'The list of legal stabilities for release stability in order of diminishing
    stability is:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 释放稳定性合法稳定性的列表按稳定性递减的顺序是：
- en: '`stable:` code should be working in all situations.'
  id: totrans-207
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`stable:` 代码应在所有情况下都能正常工作。'
- en: '`beta:` code should be working in all situations, and is feature-complete,
    but needs real-world testing.'
  id: totrans-208
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`beta:` 代码应在所有情况下都能正常工作，并且是功能完整的，但需要实际世界的测试。'
- en: '`alpha:` code is in a state of flux, features may change at any time, stability
    is uncertain.'
  id: totrans-209
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`alpha:` 代码处于变化状态，功能可能会随时更改，稳定性不确定。'
- en: '`devel:` code is not yet feature-complete, and may not work in most situations.'
  id: totrans-210
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`devel:` 代码尚未功能完善，可能在大多数情况下无法工作。'
- en: '`snapshot:` this is a current copy of development code from source during live
    development in between normal releases.'
  id: totrans-211
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`snapshot:` 这是正常发布之间的实时开发期间从源代码中获取的开发代码的当前副本。'
- en: API stability serves the same informational purpose as API version. It is not
    used by the installer, but can be used to track the rate of change of an API.
    An API marked stable should in fact never change except for adding new features
    — users need to be able to depend upon a stable API in order for package dependencies
    to work. This is a key feature of enterprise-level dependencies.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: API 稳定性服务于与 API 版本相同的信息目的。它不会被安装程序使用，但可以用来跟踪 API 变化的速率。标记为稳定的 API 实际上除了添加新功能外，不应发生变化——用户需要能够依赖稳定的
    API，以便包依赖项能够正常工作。这是企业级依赖项的关键特性。
- en: 'The list of legal stabilities for API differs slightly in that an API snapshot
    is not allowed. API stability should be thought of as:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: API 合法稳定性的列表略有不同，因为不允许 API 快照。API 稳定性应被视为：
- en: '`stable:` API is set, and will not break backward compatibility.'
  id: totrans-214
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`stable:` API 已设置，不会破坏向后兼容性。'
- en: '`beta:` API is probably set, and will only change to fix serious bugs in design
    that are encountered during testing.'
  id: totrans-215
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`beta:` API 可能已设置，并且只有在测试中遇到设计中的严重错误时才会更改，以修复严重错误。'
- en: '`alpha:` API is fluid, and may change, breaking any existing features, as well
    as adding new ones.'
  id: totrans-216
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`alpha:` API 是流动的，可能会更改，破坏现有功能，以及添加新功能。'
- en: '`devel:` API is extremely unstable, and may change dramatically at any time.'
  id: totrans-217
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`devel:` API 极不稳定，可能随时发生重大变化。'
- en: External Dependencies
  id: totrans-218
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 外部依赖
- en: 'There are two kinds of dependencies that the PEAR installer recognizes: *required*
    and *optional* dependencies. In addition, there are two classes of dependencies,
    those that restrict installation, and those that describe other resources (packages/extensions)
    used by the primary package. Restrictive dependencies are defined by the`<php>,
    <pearinstaller>, <arch>, <extension>`, and`<os>` dependencies. Resource-based
    dependencies are defined by the`<package>, <subpackage>`, and`<extension>` dependencies.'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: PEAR 安装程序识别两种类型的依赖项：*必需* 和 *可选* 依赖项。此外，还有两类依赖项，一类是限制安装的依赖项，另一类是描述主要包使用的其他资源（包/扩展）的依赖项。限制性依赖项由
    `<php>`, `<pearinstaller>`, `<arch>`, `<extension>` 和 `<os>` 依赖项定义。基于资源的依赖项由 `<package>`,
    `<subpackage>` 和 `<extension>` 依赖项定义。
- en: 'Although the `package.xml 1.0` DTD defined several dependency types, only three
    were ever implemented:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然在 `package.xml 1.0` DTD 中定义了多种依赖类型，但只有三种被实现过：
- en: '`pkg:` dependencies on packages'
  id: totrans-221
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`pkg:` 对包的依赖'
- en: '`ext:` dependencies on extensions'
  id: totrans-222
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ext:` 对扩展的依赖'
- en: '`php:` dependencies on PHP versions'
  id: totrans-223
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`php:` 对 PHP 版本的依赖'
- en: 'The structure of dependencies in `package.xml 1.0` was quite simple:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: '`package.xml 1.0` 中依赖项的结构相当简单：'
- en: '[PRE33]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'The legal values of the `rel` attribute are:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: '`rel` 属性的合法值是：'
- en: '`has:` the dependency must exist'
  id: totrans-227
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`has:` 依赖项必须存在'
- en: '`not:` the dependency must not be present'
  id: totrans-228
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`not:` 依赖项必须不存在'
- en: '`gt:` in conjunction with `version` attribute, the dependency must have version
    > the required version.'
  id: totrans-229
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`gt:` 与 `version` 属性结合使用时，依赖项的版本必须大于所需版本。'
- en: '`ge:` in conjunction with `version` attribute, the dependency must have version
    >= the required version'
  id: totrans-230
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ge:` 与 `version` 属性结合使用时，依赖项的版本必须大于或等于所需版本'
- en: '`eq:` in conjunction with `version` attribute, the dependency must have version
    == the required version.'
  id: totrans-231
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`eq:` 与 `version` 属性结合使用时，依赖项必须具有 version == 所需版本。'
- en: '`lt:` in conjunction with `version` attribute, the dependency must have version
    < the required version.'
  id: totrans-232
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`lt:` 与 `version` 属性结合使用时，依赖项必须具有 version < 所需版本。'
- en: '`le:` in conjunction with `version` attribute, the dependency must have version
    <= the required version.'
  id: totrans-233
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`le:` 与 `version` 属性结合使用时，依赖项必须具有 version <= 所需版本。'
- en: '`ne:` in conjunction with `version` attribute, the dependency must have version
    != the required version. (PEAR version 1.3.6 only.)'
  id: totrans-234
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ne:` 与 `version` 属性结合使用时，依赖项必须具有 version != 所需版本。（仅限 PEAR 版本 1.3.6。）'
- en: Tip
  id: totrans-235
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: '**How is Version Comparison Done?**'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: '**版本比较是如何进行的？**'
- en: The PHP function `version_compare()` is used to determine whether a version-based
    dependency validates. Documentation for `version_compare()` is at [http://www.php.net/version_compare](http://www.php.net/version_compare).
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: PHP 函数 `version_compare()` 用于确定基于版本的依赖项是否有效。`version_compare()` 的文档在 [http://www.php.net/version_compare](http://www.php.net/version_compare)。
- en: 'Only after a great deal of experience did the serious design flaws of this
    approach reveal themselves:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 只有在积累了大量经验之后，这种方法的严重设计缺陷才显现出来：
- en: '*XML validation with tools like xmllint cannot reveal invalid dependencies*.
    Consider the following dependency`<dep type="php" rel="has" version="4.3.0"/>`.
    This dependency is not valid because `rel="has"` ignores the version attribute,
    and so the dependency validation will not be performed — every PEAR installation
    has PHP installed by definition.'
  id: totrans-239
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*使用 xmllint 等工具进行 XML 验证无法揭示无效的依赖项*。考虑以下依赖项 `<dep type="php" rel="has" version="4.3.0"/>`。这个依赖项是无效的，因为
    `rel="has"` 忽略了版本属性，因此依赖项验证将不会执行——根据定义，每个 PEAR 安装都安装了 PHP。'
- en: '*Trust level of dependency upgrades cannot be controlled*. The PEAR package
    depends upon the Console_Getopt package. At one point, the maintainer of Console_Getopt
    *fixed* a bug that suddenly caused PEAR to stop working upon upgrade. A good deal
    of scrambling resulted in a fix, but the event highlighted the fatal flaw in the
    design of the PEAR installer pre-version 1.4.0: dependencies upon packages are
    inherently unsafe. There is no way to restrict trust of dependencies. The `rel="eq"`
    attribute does not have the desired effect because this prevents upgrading safely
    for any reason, effectively freezing development. In addition, flaws in the validation
    of dependencies meant that even upgrading to a newer package version is forbidden.'
  id: totrans-240
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*依赖项升级的信任级别无法控制*。 PEAR 包依赖于 Console_Getopt 包。在某个时刻，Console_Getopt 的维护者 *修复*
    了一个突然导致 PEAR 升级后停止工作的错误。经过一番混乱之后才找到了解决方案，但这一事件凸显了 PEAR 安装程序在 1.4.0 版本之前的致命缺陷：对包的依赖本身是不安全的。无法限制对依赖项的信任。`rel="eq"`
    属性没有达到预期的效果，因为这会阻止出于任何原因的安全升级，实际上冻结了开发。此外，依赖项验证中的缺陷意味着即使是升级到较新版本的包也是被禁止的。'
- en: If the current version has a dependency tag of `<dep type="pkg" rel="eq" version="1.0">Deppackage</dep>`,
    the PEAR installer would look at the dependencies for the new version with `<dep
    type="pkg" rel="eq" version="1.1">Deppackage</dep>` then look on disk to see that
    Deppackage version 1.0 was installed, and fail to upgrade. Even if both the main
    package and Deppackage were passed in, upgrade of Deppackage would fail because
    the installed version of the main package requires version 1.0 of Deppackage.
  id: totrans-241
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果当前版本有一个 `<dep type="pkg" rel="eq" version="1.0">Deppackage</dep>` 的依赖项标签，PEAR
    安装程序将查看新版本的依赖项，即 `<dep type="pkg" rel="eq" version="1.1">Deppackage</dep>`，然后查看磁盘上是否已安装
    Deppackage 版本 1.0，并失败升级。即使主包和 Deppackage 都已通过，Deppackage 的升级也会失败，因为主包已安装的版本需要
    Deppackage 的 1.0 版本。
- en: If the current version has a dependency tag of `<dep type="pkg" rel="eq" version="1.0">Deppackage</dep>`,
    the PEAR installer would look at the dependencies for the new version with `<dep
    type="pkg" rel="eq" version="1.1">Deppackage</dep>` then look on disk to see that
    Deppackage version 1.0 was installed, and fail to upgrade. Even if both the main
    package and Deppackage were passed in, upgrade of Deppackage would fail because
    the installed version of the main package requires version 1.0 of Deppackage.
  id: totrans-242
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果当前版本有一个 `<dep type="pkg" rel="eq" version="1.0">Deppackage</dep>` 的依赖项标签，PEAR
    安装程序将查看新版本的依赖项，即 `<dep type="pkg" rel="eq" version="1.1">Deppackage</dep>`，然后查看磁盘上是否已安装
    Deppackage 版本 1.0，并失败升级。即使主包和 Deppackage 都已通过，Deppackage 的升级也会失败，因为主包已安装的版本需要
    Deppackage 的 1.0 版本。
- en: '*Dependencies on PECL extension-based packages cannot work*. A`<dep type="ext"
    rel="has">peclextension</dep>` will only check for an extension in memory. Most
    PECL extensions can either be built directly into PHP (non-shared), distributed
    with PHP as a shared module, or downloaded and installed. If a PECL extension
    is built into PHP, distributed as a shared module, or installed via PECL, the
    `type="ext"` dependency will work just fine. Unfortunately, in order to upgrade
    the extension using the PEAR installer, `php.ini` must be disabled otherwise file
    locking will prevent overwriting the extension when it is in use by the current
    PHP process. Newer extensions such as PDO have drivers that depend on the PDO
    extension being present for installation. If `php.ini` is disabled, there is no
    way to detect extensions to validate dependencies!'
  id: totrans-243
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*基于PECL扩展包的依赖项无法工作*。一个`<dep type="ext" rel="has">peclextension</dep>`标签只会检查内存中的扩展。大多数PECL扩展可以直接构建到PHP中（非共享），作为共享模块与PHP一起分发，或者下载并安装。如果PECL扩展被构建到PHP中，作为共享模块分发，或通过PECL安装，则`type="ext"`依赖项将正常工作。不幸的是，为了使用PEAR安装程序升级扩展，必须禁用`php.ini`，否则文件锁定将防止在当前PHP进程使用时覆盖扩展。较新的扩展，如PDO，有依赖PDO扩展存在的驱动程序。如果禁用`php.ini`，将无法检测扩展以验证依赖项！'
- en: Simplifying XML Validation of package.xml
  id: totrans-244
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 简化package.xml的XML验证
- en: 'In order to make it possible to validate dependencies with external tools,
    the structure needed to be redesigned. Generally, using tags in preference to
    attributes and particularly in preference to attribute values is the approach
    used in `package.xml 2.0`. The dependency examples from `package.xml 1.0` can
    be represented in `package.xml 2.0` with:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使外部工具能够验证依赖项，需要重新设计所需的结构。通常，在`package.xml 2.0`中，优先使用标签而不是属性，尤其是优先使用属性值。`package.xml
    1.0`中的依赖项示例可以用以下方式表示在`package.xml 2.0`中：
- en: '[PRE34]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Note that attributes `optional="yes"` and the implied `optional="no"` have both
    been extracted out of the`<dep>` tag into the tags`<required>` and`<optional>`.
    In addition, the `type` attribute has been extracted out into the tags`<package>,
    <php>`, and the previously undefined`<pearinstaller>` tag. Finally, both the `rel`
    and the `version` attributes have been completely replaced with a new set of tags.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，属性`optional="yes"`和隐含的`optional="no"`都已从`<dep>`标签中提取出来，放入`<required>`和`<optional>`标签中。此外，`type`属性已提取到`<package>`、`<php>`和之前未定义的`<pearinstaller>`标签中。最后，`rel`和`version`属性已被一组新的标签完全取代。
- en: 'In `package.xml 1.0`, in order to define a version set for a single dependency,
    multiple`<dep>` tags were needed:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 在`package.xml 1.0`中，为了定义单个依赖项的版本集，需要多个`<dep>`标签：
- en: '[PRE35]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'This can be compared to the `package.xml 2.0` equivalent:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 这可以与`package.xml 2.0`的等效版本进行比较：
- en: '[PRE36]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: In fact, this change promotes much simpler debugging of dependency problems
    in complex `package.xml` file. The above dependency easily translates into English
    as "Package PackageName from channel [pear.php.net](http://pear.php.net), minimum
    version 1.2.3, maximum version 2.0.0, excluding versions 1.3.0 and 2.0.0." Not
    only is it easier to detect errors using tools like `xmllint`, it is much easier
    to comprehend complex versioning of dependencies.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，这个变化促进了在复杂的`package.xml`文件中更简单地调试依赖项问题。上述依赖项可以简单地翻译为“来自通道[pear.php.net](http://pear.php.net)的PackageName包，最小版本1.2.3，最大版本2.0.0，排除版本1.3.0和2.0.0。”不仅使用像`xmllint`这样的工具检测错误更容易，而且对依赖项的复杂版本控制的理解也更容易。
- en: The `rel/version` duo has been effectively made obsolete by the combination
    of`<min>/<max>/<exclude>` tags. These three tags can be thought of as newer implementations
    of `rel's ge, le`, and `ne:`
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: '`rel/version`对已被`<min>/<max>/<exclude>`标签的组合所淘汰。这三个标签可以被视为`rel`的`ge`、`le`和`ne`的新实现。'
- en: '`<min>1.2.0</min>` =`<dep rel="ge" version="1.2.0">`'
  id: totrans-254
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<min>1.2.0</min>` = `<dep rel="ge" version="1.2.0">`'
- en: '`<max>1.2.0</max>` =`<dep rel="le" version="1.2.0">`'
  id: totrans-255
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<max>1.2.0</max>` = `<dep rel="le" version="1.2.0">`'
- en: '`<exclude>1.2.0</exclude>` =`<dep rel="ne" version="1.2.0">`'
  id: totrans-256
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<exclude>1.2.0</exclude>` = `<dep rel="ne" version="1.2.0">`'
- en: With these three tags, we can effectively and simply define any version set
    in a single dependency, without needing to think in terms of mathematical comparison
    operators.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这三个标签，我们可以在单个依赖项中有效地简单地定义任何版本集，无需考虑数学比较运算符。
- en: Managing Trust of Dependencies
  id: totrans-258
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 管理依赖项的信任度
- en: The PEAR installer is extremely lithe, making upgrading to newer versions of
    packages so simple; until PEAR version 1.4.0 its greatest strength was also its
    greatest weakness. The ability to easily upgrade packages, as well as the ability
    to perform batch-automated upgrades with commands like `upgrade-all` and `download-all`
    followed by `upgrade` is one of the key selling points of the installer. However,
    this ease is built upon an implicit trust in the quality of newer versions. By
    depending on packages with a simple`<dep type="pkg" rel="ge" version="X.Y.Z">`,
    this gives a carte blanche to the developers of the dependent package. If a dependent
    package's developer introduces a break with previous releases, whether through
    carelessness or lack of sympathy for your code, your end users are in trouble.
    For this reason, bundling dependencies directly in the code has become a favored
    means of distributing applications. This, however, negates the primary benefit
    of the PEAR installer — the ability to quickly and easily upgrade in case of the
    discovery of serious bugs like functionality failures, or worse, subtle security
    vulnerabilities that open up a site to external attack. This also puts the burden
    of maintaining the bundled dependencies directly upon the application maintainer,
    reducing the efficiency of distributed development and all of its contingent benefits.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: PEAR安装程序非常灵活，使得升级到包的新版本变得如此简单；直到PEAR版本1.4.0，它的最大优势也是它的最大弱点。轻松升级包的能力，以及使用`upgrade-all`和`download-all`等命令执行批量自动升级的能力，是安装程序的关键卖点之一。然而，这种便利性建立在对新版本质量的隐含信任之上。通过依赖具有简单`<dep
    type="pkg" rel="ge" version="X.Y.Z">`的包，这给了依赖包的开发者一张空白支票。如果依赖包的开发者引入了与先前版本的不兼容，无论是由于疏忽还是对您的代码缺乏同情，您的最终用户就会遇到麻烦。因此，直接在代码中捆绑依赖项已经成为分发应用程序的首选方法。然而，这却否定了PEAR安装程序的主要好处——在发现严重错误，如功能故障，或更糟糕的是，可能导致网站遭受外部攻击的微妙安全漏洞时，能够快速轻松地升级。这也将维护捆绑依赖项的负担直接放在了应用程序维护者身上，降低了分布式开发的效率及其所有相关好处。
- en: '`package.xml 2.0` solves this dilemma simply and elegantly through the introduction
    of a new dependency concept: recommended version. This dependency can be taken
    from PEAR''s `package.xml:`'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: '`package.xml 2.0`通过引入新的依赖概念：推荐版本，简单地优雅地解决了这个困境。这个依赖可以从PEAR的`package.xml`中获取：'
- en: '[PRE37]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'This instructs the installer to upgrade `Console_Getopt` at will to any release
    of `Console_Getopt`, version `1.2` or newer. By changing the dependency to:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 这指示安装程序可以随意升级`Console_Getopt`到任何版本的`Console_Getopt`，版本`1.2`或更高。通过更改依赖项：
- en: '[PRE38]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: This changes everything. Now, the installer will not automatically upgrade to
    version 1.3.0 upon release, unless the `--force` or `--loose` option is passed,
    or a`<compatible>` tag is present in the release of `Console_Getopt`.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 这一切都改变了。现在，安装程序不会在发布时自动升级到1.3.0版本，除非传递了`--force`或`--loose`选项，或者`Console_Getopt`的发布中存在`<compatible>`标签。
- en: 'The syntax of`<compatible>` is simple:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: '`<compatible>`的语法很简单：'
- en: '[PRE39]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: As in dependencies,`<min>/<max>/<exclude>` is used to define a set of versions
    that the package is guaranteed to be compatible with. Unlike dependencies, the`<max>`
    tag is required to limit the set of versions. In addition, the set of versions
    must be limited to actual existing releases that have been tested.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 在依赖项中，`<min>/<max>/<exclude>`用于定义一组包保证与之兼容的版本。与依赖项不同，`<max>`标签是必需的，以限制版本集。此外，版本集必须限制到实际存在的、经过测试的发布版本。
- en: In theory, it is still possible for lazy developers to implement a`<compatible>`
    tag that is every bit as dangerous as the old `rel="ge"-based` technique of dependency
    management, but this is both unlikely due to the principle of developer inertia
    and easy to catch and correct for the developer whose application depends on the
    dependency.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 从理论上讲，懒惰的开发者仍然有可能实现一个与旧`rel="ge"-based`依赖管理技术一样危险的新`<compatible>`标签，但由于开发者惰性原则，这不太可能，而且对于依赖该依赖的应用的开发者来说，也容易捕捉和纠正。
- en: Tip
  id: totrans-269
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: '**The Principle of Developer Inertia**'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: '**开发者惰性原则**'
- en: Developers, like electrons, will choose the path of least resistance to achieve
    their goals. Make it difficult to write bad code and easy to write good code,
    and developers will write good code.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 开发者，就像电子一样，会选择阻力最小的路径来实现他们的目标。让编写糟糕的代码变得困难，让编写好的代码变得容易，开发者就会编写好的代码。
- en: Reliably Depending on PECL Packages
  id: totrans-272
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 可靠地依赖PECL包
- en: 'Reliably depending on PECL packages has become possible due to two innovations:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 由于两个创新，可靠地依赖 PECL 包变得可能：
- en: 'The split of the `pear` script into two scripts: `pear` and `pecl`'
  id: totrans-274
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 `pear` 脚本拆分为两个脚本：`pear` 和 `pecl`
- en: The introduction of the`<providesextension>` tag
  id: totrans-275
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`<providesextension>` 标签的引入'
- en: 'The primary difference between the `pear` and `pecl` commands can be summarized
    as: "Use `pear` to manage packages written in PHP like those at [pear.php.net](http://pear.php.net),
    and use `pecl` to manage packages extending PHP like those at [pecl.php.net](http://pecl.php.net)."
    Technically, the `pecl` command disables `php.ini`, and defaults to the [pecl.php.net](http://pecl.php.net)
    channel, but otherwise it is identical to the `pear` command. Disabling `php.ini`
    makes it possible to upgrade extensions that are inside `php.ini` without unloading
    them.'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: '`pear` 和 `pecl` 命令之间的主要区别可以概括为：“使用 `pear` 来管理像 [pear.php.net](http://pear.php.net)
    上的那样用 PHP 编写的包，并使用 `pecl` 来管理扩展 PHP 的包，如 [pecl.php.net](http://pecl.php.net) 上的那样。”从技术上讲，`pecl`
    命令禁用了 `php.ini`，并默认使用 [pecl.php.net](http://pecl.php.net) 通道，但除此之外，它与 `pear` 命令相同。禁用
    `php.ini` 使得升级 `php.ini` 内部的扩展成为可能，而无需卸载它们。'
- en: 'The`<providesextension>` tag is used in dependencies as follows:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: '`<providesextension>` 标签在依赖项中的使用如下：'
- en: '[PRE40]'
  id: totrans-278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'This simple addition instructs the installer to treat the package dependency
    on `PDO` as if it were a combination of these two dependencies:'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 这个简单的添加指示安装程序将包对 `PDO` 的依赖视为这两个依赖的组合：
- en: '[PRE41]'
  id: totrans-280
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: The installer will first check to see if the `PDO` extension is present in memory,
    version 1.0 or newer, and if it is not, it will check the package registry to
    see if [pecl.php.net/PDO](http://pecl.php.net/PDO) version 1.0 or newer is installed.
    This allows, for instance, installation of production extensions for an Apache-based
    PEAR installation using a CLI-based PEAR installer without requiring the CLI-based
    installer to load each extension into its `php.ini`. In addition, it allows extensions
    like `PDO_mysql` to depend on `PDO` without requiring the `PDO` extension to be
    loaded in memory, greatly simplifying the end user experience.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 安装程序将首先检查内存中是否存在 `PDO` 扩展，版本为 1.0 或更高版本，如果不存在，它将检查包注册表以查看是否安装了 [pecl.php.net/PDO](http://pecl.php.net/PDO)
    版本 1.0 或更高版本。这允许，例如，使用基于 CLI 的 PEAR 安装程序安装基于 Apache 的 PEAR 安装的生产扩展，而无需要求基于 CLI
    的安装程序将每个扩展加载到其 `php.ini` 中。此外，它允许像 `PDO_mysql` 这样的扩展依赖于 `PDO`，而无需在内存中加载 `PDO`
    扩展，极大地简化了最终用户的使用体验。
- en: Release Notes
  id: totrans-282
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 发布说明
- en: In both `package.xml 1.0` and `package.xml 2.0`, release notes are defined by
    the`<notes>` tag. The format of this tag is any text.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `package.xml 1.0` 和 `package.xml 2.0` 中，发布说明由 `<notes>` 标签定义。此标签的格式为任何文本。
- en: '[PRE42]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Release License
  id: totrans-285
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 发布许可
- en: The text of the`<license>` tag is not validated — anything may be entered there.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: '`<license>` 标签的文本不会进行验证——可以输入任何内容。'
- en: '[PRE43]'
  id: totrans-287
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: In `package.xml 2.0` there are optional attributes `uri` and `filesource` for
    linking a license to an online version and also to a specific license file within
    the package itself.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `package.xml 2.0` 中，有可选的 `uri` 和 `filesource` 属性，用于将许可证链接到在线版本，以及链接到包本身内的特定许可证文件。
- en: '[PRE44]'
  id: totrans-289
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Changelog
  id: totrans-290
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 变更日志
- en: 'The format of changelog in `package.xml 1.0` matches the format of a`<release>`
    tag with the exception that`<filelist>` is not allowed. The changelog is purely
    information for human purposes, and is not processed at all by the installer.
    The format for a changelog in `package.xml 2.0` is very similar to that of `package.xml
    1.0`, and is best illustrated by an example:'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: '`package.xml 1.0` 中的变更日志格式与 `<release>` 标签的格式相匹配，唯一的区别是 `<filelist>` 不允许。变更日志纯粹是供人类使用的纯信息，安装程序不会对其进行任何处理。`package.xml
    2.0` 中的变更日志格式与 `package.xml 1.0` 非常相似，以下是一个示例：'
- en: '[PRE45]'
  id: totrans-292
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: Like the release section of `package.xml`, the tags`<version>, <stability>,
    <date>, <license>`, and`<notes>` are all present. This is identical to `package.xml
    1.0`. The only difference is the format of the`<version>, <stability>`, and`<license>`
    tags, which match the changes made in `package.xml 2.0`.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 与 `package.xml` 的发布部分一样，`<version>`、`<stability>`、`<date>`、`<license>` 和 `<notes>`
    标签都存在。这与 `package.xml 1.0` 相同。唯一的区别是 `<version>`、`<stability>` 和 `<license>` 标签的格式，它们与
    `package.xml 2.0` 中所做的更改相匹配。
- en: File List, or Contents of the Package
  id: totrans-294
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 文件列表，或包的内容
- en: The primary purpose of PEAR, and by consequence, `package.xml` is to distribute
    files containing programming code. This is ultimately controlled by the list of
    files that are in a package, as defined by`<filelist>` or`<contents>.`
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: PEAR 的主要目的，以及由此产生的 `package.xml`，是分发包含编程代码的文件。这最终由包中定义的文件列表控制，由 `<filelist>`
    或 `<contents>` 定义。
- en: For `package.xml 1.0:`
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 `package.xml 1.0:`
- en: '[PRE46]'
  id: totrans-297
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: For `package.xml 2.0:`
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: '对于 `package.xml 2.0:` '
- en: '[PRE47]'
  id: totrans-299
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: This tag is the heart of `package.xml` file. Once our trusty package has weathered
    dependency tests, this is the section of `package.xml` that is actually used during
    installation.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 这个标签是 `package.xml` 文件的核心。一旦我们可靠的包通过了依赖性测试，这就是 `package.xml` 在安装过程中实际使用的部分。
- en: 'The file listing inside a `package.xml` is used to define the directory structure
    inside a release. It must reflect exactly the relative locations of files as they
    were on the computer of the developer. In other words, if the `package.xml` is
    in directory `/home/frank/mypackage/`, and a file in `package.xml` is located
    at `/home/frank /mypackage/foo/test.php`, it must be listed as:'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: '`package.xml` 内的文件列表用于定义发布中的目录结构。它必须精确反映文件在开发者计算机上的相对位置。换句话说，如果 `package.xml`
    在 `/home/frank/mypackage/` 目录中，并且 `package.xml` 中的一个文件位于 `/home/frank /mypackage/foo/test.php`，它必须列出为：'
- en: '[PRE48]'
  id: totrans-302
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Or, alternately as:'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，作为替代：
- en: '[PRE49]'
  id: totrans-304
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: Either alternative will yield the same result. At installation time, PEAR will
    automatically convert all recursive directory trees like the second example into
    a single flat branch like the first example.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 任何一种选择都会得到相同的结果。在安装时，PEAR 会自动将像第二个例子那样的所有递归目录树转换成像第一个例子那样的单个扁平分支。
- en: New Tags in package.xml
  id: totrans-306
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: package.xml 中的新标签
- en: '`package.xml 2.0` introduced the new tags`<phprelease>, <extsrcrelease>`, and`<extbinrelease>`
    to differentiate between the different kinds of packages the PEAR installer handles.
    `package.xml 2.1` introduces`<zendextsrcrelease>` and `<zendextbinrelease>` in
    order to differentiate between regular PHP extensions and Zend extensions like
    `xdebug` ( [http://pecl.php.net/xdebug](http://pecl.php.net/xdebug)).'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: '`package.xml 2.0` 引入了新的标签 `<phprelease>`, `<extsrcrelease>` 和 `<extbinrelease>`，以区分
    PEAR 安装器处理的包的不同类型。`package.xml 2.1` 引入了 `<zendextsrcrelease>` 和 `<zendextbinrelease>`，以便区分常规
    PHP 扩展和像 `xdebug` ( [http://pecl.php.net/xdebug](http://pecl.php.net/xdebug))
    这样的 Zend 扩展。'
- en: 'You may have noticed that the primary tag in `package.xml 1.0` is named`<filelist>`,
    whereas the primary tag in `package.xml 2.0` is named`<contents>`. This change
    came about as a result of a simple feature request. When PEAR 1.3.3 was popular,
    the need to customize installations grew; more and more attributes and information
    were crammed into the`<file>` tag. The `platform` attribute tells the installer
    that a file should only be installed on a particular platform, such as UNIX or
    Windows. This is used in the PEAR package in order to install the `pear` command
    using a `schell` script on UNIX, and using a `.bat` batch file on Windows. The
    feature request that came in was to implement an additional `platform="!windows"`
    hack that would tell the installer to install the file on every platform except
    Windows. This introduces a number of problems. As package complexity grows, and
    more systems are supported, it may be necessary to specify a limited list of systems
    a file can be installed on, or different names to install the file as required
    on different systems. Implementation of this would require a sophisticated mapping
    between the `install-as` and the `platform` attributes, something that was not
    anticipated by the designers of `package.xml 1.0`, and something that would introduce
    a miserable mess into a single file tag. Imagine encountering this nightmare and
    trying to debug it:'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经注意到，`package.xml 1.0` 中的主要标签被命名为 `<filelist>`，而 `package.xml 2.0` 中的主要标签被命名为
    `<contents>`。这种变化是由于一个简单的功能请求而产生的。当 PEAR 1.3.3 流行时，定制安装的需求增长；越来越多的属性和信息被塞进了 `<file>`
    标签。`platform` 属性告诉安装器一个文件应该只安装在一个特定的平台上，例如 UNIX 或 Windows。这在 PEAR 包中用于在 UNIX 上使用
    shell 脚本安装 `pear` 命令，在 Windows 上使用 `.bat` 批处理文件。提交的功能请求是实施一个额外的 `platform="!windows"`
    漏洞，告诉安装器除了 Windows 之外的所有平台上安装文件。这引入了一系列问题。随着包的复杂性增加，支持更多的系统，可能需要指定一个文件可以安装的有限系统列表，或者在不同系统上安装文件的不同名称。实施这一点将需要在
    `install-as` 和 `platform` 属性之间进行复杂的映射，这是 `package.xml 1.0` 的设计者没有预料到的，并且会在单个文件标签中引入一个糟糕的混乱。想象一下遇到这个噩梦并试图调试它：
- en: '[PRE50]'
  id: totrans-309
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: Do you see the typo buried deep in the install-as attribute?
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 你是否看到了安装为属性中埋藏的错别字？
- en: 'One day while working on the problem caused by the spectre of such horribly
    complex features, it struck me that attributes like the `platform` attribute were
    actually kludgy ways of implementing dependencies for a specific file. Suddenly,
    the answer was clear. Far better than extending the attribute''s meaning would
    be abstracting the information into separate release tags. Each release tag would
    have a file list and installation conditions that would define which one should
    be used on an end user''s computer. For instance, instead of:'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 有一次，在处理由这些复杂特性引起的难题时，我突然意识到像`platform`属性这样的属性实际上是实现特定文件依赖关系的笨拙方式。突然，答案变得清晰。比扩展属性的意义更好的是，将信息抽象成单独的发布标签。每个发布标签都会有一个文件列表和安装条件，这将定义在最终用户的计算机上应该使用哪一个。例如，而不是：
- en: '[PRE51]'
  id: totrans-312
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'We would have:'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将会有：
- en: '[PRE52]'
  id: totrans-314
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'However, the most obvious benefit comes from the horrible "Darwin" example.
    This would translate from:'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，最明显的益处来自于那个糟糕的“Darwin”示例。这会翻译成：
- en: '[PRE53]'
  id: totrans-316
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'to:'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 到：
- en: '[PRE54]'
  id: totrans-318
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'Here, the potential for simple validation is obvious: the`<os>` install condition
    is limited to a few known possibilities such as `windows, unix, linux, Darwin`,
    and so on. The OS "Darwim" would simply refuse to validate. In addition, the complexity
    of how `Foo.scr` is handled is grouped by OS rather than stuffed into a couple
    of attributes with error-prone non-XML syntax.'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，简单的验证的潜力是明显的：`<os>`安装条件限制为几个已知的可能性，如`windows、unix、linux、Darwin`等。操作系统“Darwim”将简单地拒绝验证。此外，如何处理`Foo.scr`的复杂性是根据操作系统分组，而不是放入几个具有易出错的非XML语法的属性中。
- en: 'File/Directory Attributes: name, role, and baseinstalldir'
  id: totrans-320
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 文件/目录属性：name、role和baseinstalldir
- en: The`<file>` and`<dir>` tags have a number of options available to them. Both
    tags require a `name` attribute, defining the name of the element as located on
    disk. Unlike an operating system, `package.xml` does not allow empty directories.
    All`<dir>` tags must contain at least one`<file>` tag. As described in the previous
    section, there are two ways to describe the location of a file in `package.xml`,
    either with a complete relative path separated by the UNIX path separator `/:`
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: '`<file>`和`<dir>`标签都有许多可用的选项。这两个标签都需要一个`name`属性，用于定义元素在磁盘上的名称。与操作系统不同，`package.xml`不允许空目录。所有`<dir>`标签都必须包含至少一个`<file>`标签。如前所述，在`package.xml`中描述文件位置有两种方式，要么使用完整的相对路径，由UNIX路径分隔符`/:`分隔。'
- en: '[PRE55]'
  id: totrans-322
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'Or, alternately as:'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，也可以这样：
- en: '[PRE56]'
  id: totrans-324
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'All files must have a **role** attribute. This attribute tells the installer
    how to handle a file. The default list of allowed file roles is:'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 所有文件都必须有一个**角色**属性。此属性告诉安装程序如何处理文件。允许的文件角色默认列表如下：
- en: '| Default File Roles |   |'
  id: totrans-326
  prefs: []
  type: TYPE_TB
  zh: '| 默认文件角色 |   |'
- en: '| --- | --- |'
  id: totrans-327
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| Role | Description |'
  id: totrans-328
  prefs: []
  type: TYPE_TB
  zh: '| 角色 | 描述 |'
- en: '| --- | --- |'
  id: totrans-329
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| php | PHP script files, like "PEAR.php" |'
  id: totrans-330
  prefs: []
  type: TYPE_TB
  zh: '| php | PHP脚本文件，例如"PEAR.php" |'
- en: '| data | Data files used by the script (read-only) |'
  id: totrans-331
  prefs: []
  type: TYPE_TB
  zh: '| 数据 | 脚本使用的数据文件（只读） |'
- en: '| doc | Documentation files |'
  id: totrans-332
  prefs: []
  type: TYPE_TB
  zh: '| doc | 文档文件 |'
- en: '| test | Test scripts, unit test files |'
  id: totrans-333
  prefs: []
  type: TYPE_TB
  zh: '| test | 测试脚本，单元测试文件 |'
- en: '| script | Executable script files `(pear.bat, pear.sh)` |'
  id: totrans-334
  prefs: []
  type: TYPE_TB
  zh: '| script | 可执行脚本文件（例如pear.bat, pear.sh） |'
- en: '| ext | PHP Extension binaries `(php_mysql.dll)` |'
  id: totrans-335
  prefs: []
  type: TYPE_TB
  zh: '| ext | PHP扩展二进制文件（例如php_mysql.dll） |'
- en: '| src | PHP Extension source files `(mysql.c)` |'
  id: totrans-336
  prefs: []
  type: TYPE_TB
  zh: '| src | PHP扩展源文件（例如mysql.c） |'
- en: 'Each file role has a configuration value associated with it. For instance,
    on my Windows XP system, here is what I see when I list configuration values:'
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 每个文件角色都与其关联一个配置值。例如，在我的Windows XP系统上，当我列出配置值时，我看到如下内容：
- en: '[PRE57]'
  id: totrans-338
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'In some cases, especially for subpackages like `HTML_QuickForm_Controller`
    ( [http://pear.php.net/package/HTML_QuickForm_Controller](http://pear.php.net/package/HTML_QuickForm_Controller)),
    all files should be installed into a subdirectory (HTML/QuickForm/Controller in
    our example). In order to reflect this installation path in our file, we would
    need to prepend all files with the full path, like so:'
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，特别是对于像`HTML_QuickForm_Controller`（[http://pear.php.net/package/HTML_QuickForm_Controller](http://pear.php.net/package/HTML_QuickForm_Controller)）这样的子包，所有文件都应该安装到子目录中（在我们的例子中是HTML/QuickForm/Controller）。为了在我们的文件中反映这个安装路径，我们需要将所有文件的前缀设置为完整路径，如下所示：
- en: '[PRE58]'
  id: totrans-340
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'Or, alternately use`<dir>` tags as follows:'
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，也可以这样使用`<dir>`标签：
- en: '[PRE59]'
  id: totrans-342
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'In addition, our actual development path would need to reflect this. This does
    not fit the "make everything easy for lazy developers" development paradigm very
    well, and so PEAR provides the `baseinstalldir` attribute to simplify things.
    Now, all we need is:'
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们的实际开发路径也需要反映这一点。这并不符合“让懒惰的开发者一切变得简单”的开发模式，因此 PEAR 提供了`baseinstalldir`属性来简化事情。现在，我们只需要：
- en: '[PRE60]'
  id: totrans-344
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'Or, the far more common:'
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，更常见的：
- en: '[PRE61]'
  id: totrans-346
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: Tip
  id: totrans-347
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: '**Path Locations on the Development Machine**'
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: '**开发机上的路径位置**'
- en: 'Note that as a developer, in order for this to work, the actual paths on disk
    must match the`<dir>/<file>` tags. In our example above, the files should be in:'
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，作为一个开发者，为了使这生效，磁盘上的实际路径必须与`<dir>/<file>`标签匹配。在我们上面的例子中，文件应该位于：
- en: '`Controller/Action.php Controller.php package.xml`'
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: '`Controller/Action.php Controller.php package.xml`'
- en: 'Rather than:'
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 而不是：
- en: '`HTML/QuickForm/Controller/Action.php HTML/QuickForm/Controller.php package.xml`'
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: '`HTML/QuickForm/Controller/Action.php HTML/QuickForm/Controller.php package.xml`'
- en: Otherwise the PEAR installer will be unable to find the files.
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 否则，PEAR 安装程序将无法找到这些文件。
- en: 'Generally speaking, if a file is listed in `package.xml` as:'
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 一般而言，如果一个文件在`package.xml`中被列出：
- en: '[PRE62]'
  id: totrans-355
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: And `php_dir` is `C:\php4\PEAR`, the file will be installed into `C:\php4\PEAR\Path\To\Foo.php`.
    This is not always advantageous, especially for things like scripts. PEAR, for
    instance, places all of its scripts in the `scripts/` subdirectory for easier
    organization. However, this would mean that if `bin_dir` is `C:\php4`,
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 并且`php_dir`是`C:\php4\PEAR`，文件将被安装到`C:\php4\PEAR\Path\To\Foo.php`。这并不总是有优势，尤其是对于像脚本这样的东西。例如，PEAR
    将所有脚本放在`scripts/`子目录中以方便组织。然而，这意味着如果`bin_dir`是`C:\php4`，
- en: '[PRE63]'
  id: totrans-357
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: will be installed into `C:\php4\scripts\pear.bat`, which may not necessarily
    be in the path. To change the base installation directory in PEAR 1.4.x, you need
    to use an`<install>` tag inside a release tag, In addition, it is possible to
    perform text transformations on the contents of files.
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 将被安装到`C:\php4\scripts\pear.bat`，这不一定在路径中。要在 PEAR 1.4.x 中更改基本安装目录，您需要在发布标签内使用`<install>`标签，此外，还可以对文件内容执行文本转换。
- en: Summary
  id: totrans-359
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we discovered the basics of how the PEAR installer's internals
    work through the lens of `package.xml's` structure. First, we explored the basic
    design philosophies of the PEAR installer, and how PEAR packages differ from the
    old-fashioned unzip-and-go approach. We learned about PEAR's configuration options,
    and the versatile ways in which PEAR deals with libraries versus applications.
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们通过`package.xml`的结构，了解了 PEAR 安装程序内部工作原理的基础。首先，我们探讨了 PEAR 安装程序的基本设计理念，以及
    PEAR 包与传统的解压缩并运行方法的不同。我们学习了 PEAR 的配置选项，以及 PEAR 处理库与应用程序的灵活方式。
- en: Next, we explored the importance of versioning in controlling the quality of
    packages installed, and the importance of dependencies, and how the PEAR installer
    manages this important link between libraries and applications. Then, we explored
    how easy it is to upgrade when using the PEAR installer, as compared to upgrading
    traditional unzip-and-go applications.
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们探讨了版本控制对控制安装包质量的重要性，以及依赖关系的重要性，以及 PEAR 安装程序如何管理库和应用程序之间的重要链接。然后，我们探讨了使用
    PEAR 安装程序升级的便利性，与传统的解压缩并运行应用程序的升级方式相比。
- en: After this, we dove headfirst into the structure of `package.xml`, learning
    how package metadata such as the package name, authors, release notes, and changelog
    are organized. This was coupled with a look at how critical installation data
    such as files, dependencies, and versioning is organized.
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，我们一头扎进了`package.xml`的结构，学习如何组织包元数据，如包名、作者、发布说明和变更日志。这伴随着对关键安装数据（如文件、依赖关系和版本控制）如何组织的考察。
- en: The next chapter will examine advanced topics, specifically how `package.xml
    2.0` introduces better application support, and how to leverage these new features
    in your own packages.
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 下一章将探讨高级主题，特别是`package.xml 2.0`如何引入更好的应用程序支持，以及如何在您的包中利用这些新特性。
