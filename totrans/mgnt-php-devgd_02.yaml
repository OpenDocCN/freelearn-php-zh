- en: Chapter 2. ORM and Data Collections
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Collections and models are the bread and butter of everyday Magento development.
    In this chapter, we will introduce the reader to the Magento ORM system, and we
    will learn how to work with data collections and the EAV system properly. As most
    modern systems, Magento implements an **object-relational mapping** (**ORM**)
    system.
  prefs: []
  type: TYPE_NORMAL
- en: '*Object-relational mapping (ORM, O/RM, and O/R mapping) in computer software
    is a programming technique for converting data between incompatible type systems
    in object-oriented programming languages. This creates, in effect, a "virtual
    object database" that can be used from within the programming language.*'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Magento Models
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Anatomy of a Magento Data Model
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: EAV and EAV models
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Working with Direct SQL queries
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We will also be working with several snippets of code to provide an easy framework
    to experiment and play around with Magento.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The interactive examples in this chapter assume you are working either with
    the default Magento installation inside the VagrantBox or a Magento installation
    with sample data.
  prefs: []
  type: TYPE_NORMAL
- en: 'For this purpose, I have created the Magento IMC (Interactive Magento Console),
    which is a shell script specially created for this book and inspired by Ruby''s
    IRB (Interactive Ruby Console). To get started, follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: The first thing we will need to do is install the IMC to download the source
    files from [https://github.com/amacgregor/mdg_imc](https://github.com/amacgregor/mdg_imc)
    and extract them under your Magento test installation. The IMC is a simple Magento
    shell script that will allow to test our code in real time.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Once you extract the script, log into the shell of your VirtualBox.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Next, we will need to navigate to our Magento root folder. If you are using
    the default vagrant box and installation provided, the root folder is located
    under `/srv/www/ce1720/public_html`. We navigate to it by running this command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Finally, we can start the IMC by running the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: If everything is installed successfully, we will see a new line starting with
    `magento >`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Magento Model anatomy
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As we learned in the previous chapter, Magento data models are used to manipulate
    and access the data. The model layer is divided into two fundamental types, simple
    models and EAV:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Simple models**: These model implementations are a simple mapping of one
    object to one table, meaning our object attributes match each field and our table
    structure.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Entity Attribute Value models**: This type of models, known as EAV models,
    are used to describe entities with a dynamic number of attributes.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: It is important to clarify that not all Magento models extend or make use of
    the ORM. Observers are a clear example of simpler model classes that are not mapped
    to a specific database table or entity.
  prefs: []
  type: TYPE_NORMAL
- en: 'In addition to that, each Model type is formed by the following layers:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Model class**: This is where most of our business logic resides. Models are
    used to manipulate the data, but they don''t access it directly.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Resource Model class**: Resource Models are used to interact with the database
    on behalf of our models. They are in charge of the actual CRUD operations.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Model Collection class**: Each Data Model has a collection class. Collections
    are objects that hold a number of individual Magento Model instances.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: CRUD stands for the four basic types of database operations, namely create,
    read, update, and delete.
  prefs: []
  type: TYPE_NORMAL
- en: Magento Models don't contain any logic to communicate with the database; they
    are database agnostic. Instead, this code resides in the Resource Model layer.
  prefs: []
  type: TYPE_NORMAL
- en: 'This gives Magento the capacity to support different types of databases and
    platforms. Although currently, only MySQL is officially supported, it is entirely
    possible to write a new resource class for a new database without touching any
    of the Model logic:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Magento Model anatomy](img/4172_02_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Let''s experiment now by instantiating a product object and setting some of
    its properties:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Start the Magento interactive console running under your Magento staging installation
    root:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Our first step is to create a new product object instance by typing the following
    code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We can confirm this is a blank instance of the product class by running the
    following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We should see the following as a successful output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'If we want to know more about the class methods, we can run the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'This will return an array with all the available methods inside the class.
    Let''s try to run the following code snippet and modify a product''s price and
    name:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: On the first line of code, we instantiate a specific object and then proceed
    to retrieve the name attribute from the object. Next, we set the price and name,
    and finally, we save the object.
  prefs: []
  type: TYPE_NORMAL
- en: If we open our Magento product class `Mage_Catalog_Model_Product`, the first
    thing we will notice is that while both `getName()` and `getPrice()` are defined
    inside our class, the `setPrice()` and `setName()` functions are not defined anywhere.
  prefs: []
  type: TYPE_NORMAL
- en: However, why, and more importantly how, is Magento *magically* defining each
    of the product object setter and getter methods? While `getPrice()` and `getName()`
    are indeed defined, there is no definition for any of the getter and setter methods
    for product attributes such as color or manufacturer.
  prefs: []
  type: TYPE_NORMAL
- en: It's magic – methods
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Well it so happens that the Magento ORM system is indeed magic. To be precise,
    one of PHP's more powerful features is to implement its getters and setters, the
    magic `__call()` method. Magic methods are used inside Magento to set, unset,
    check, or retrieve data.
  prefs: []
  type: TYPE_NORMAL
- en: When we try to call a method that does not actually exist in our corresponding
    class, PHP will look into each of the parent classes for a declaration of that
    method. If it can't find the function on any of the parent classes, it will use
    its last resort and try to use a `__call()` method. If found, Magento (or PHP
    for that matter) will call the magic method, passing the requested method name
    and its arguments.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, the Product model doesn''t have a `__call()` method defined, but it gets
    one from the `Varien_Object` that most Magento models inherit from. The inheritance
    tree for the `Mage_Catalog_Model_Product` class is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![It''s magic – methods](img/4172_02_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Most Magento Models inherit from the `Varien_Object` class.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take a closer look at the `Varien_Object` class:'
  prefs: []
  type: TYPE_NORMAL
- en: Open the file located in `magento_root/lib/Varien/Object.php`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `Varien_Object` class not only has a **__call()** method but also has two
    deprecated methods, **__set()** and **__get()**. Both of these are replaced by
    the **__call()** method and are no longer used.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Inside the `__call()` method, we have a switch that will handle not only getters
    and setters but also the `unset` and `has` functions.
  prefs: []
  type: TYPE_NORMAL
- en: If we start a debugger and follow the calls of our snippet code to the `__call()`
    method, we will see that it receives two arguments, the method name (for example
    `setName()`) and the arguments from the original call.
  prefs: []
  type: TYPE_NORMAL
- en: 'Interestingly, Magento tries to match the corresponding method type based on
    the first three letters of the method being called. This is done with the switch
    case argument by calling the substring function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: The first thing that is called inside each case is the `_underscore()` function,
    which takes as parameter anything after the first three characters in the method
    name. Following our example, the argument passed will be `Name`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `__underscore()` function returns a data key. This key is then used by
    each of the cases to manipulate the data. There are four basic data operations,
    each is used on the corresponding switch case:'
  prefs: []
  type: TYPE_NORMAL
- en: '`setData` (`$parameters`)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`getData` (`$parameters`)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`unsetData` (`$parameters`)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`isset` (`$parameters`)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Each of these functions will interact with the `Varien_Object` data array and
    manipulate it accordingly. In most cases, a magic set/get method will be used
    to interact with our object attributes. Only in a few exceptions, where additional
    business logic is required, getters and setters will be defined. In our example,
    this would be `getName()` and `getPrice()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'We will not get into details of what the price function is actually doing,
    but it clearly illustrates that additional logic may be required for certain parts
    of the models:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: On the other hand, the `getName()` getter wasn't declared because of the need
    to implement special logic but by the need to optimize a crucial part of Magento.
    The `Mage_Catalog_Model_Product` `getName()` function, which can potentially be
    called hundreds of times per page load, is one of the most commonly used functions
    across all Magento. After all, what kind of e-commerce platform would it be if
    it was not centered around products?
  prefs: []
  type: TYPE_NORMAL
- en: Frontend and backend will both call the `getName()` function at one point or
    another. For example, loading a category page with 24 products. That's 24 separate
    calls to the `getName()` function. Having each of these calls look for a `getName()`
    method on each of the parent classes and then trying to use the magic `__call()`
    method will result in losing precious milliseconds.
  prefs: []
  type: TYPE_NORMAL
- en: '**Resource Models** contain all the database-specific logic and they instantiate
    specific read-and-write adapters for their corresponding data source. Let''s go
    back to our example of working with products and take a look the product Resource
    Model located in `Mage_Catalog_Model_Resource_Product`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![It''s magic – methods](img/4172_02_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Resource Models come in two different types, Entity and Resource. The latter
    is a pretty standard one-table/one-model association, while the former is far
    more complicated.
  prefs: []
  type: TYPE_NORMAL
- en: The EAV model
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: EAV stands for entity, attribute, and value and is probably the most difficult
    concept for new Magento developers to grasp. While the EAV concept is not unique
    to Magento, it is rarely implemented on modern systems. Additionally, a Magento
    implementation is not a simple one.
  prefs: []
  type: TYPE_NORMAL
- en: '![The EAV model](img/4172_02_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: What is EAV?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In order to understand what EAV is and what its role within Magento is, we
    need to break down parts of the EAV model:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Entity**: This represents the data items (objects) inside Magento products,
    customers, categories, and orders. Each entity is stored in the database with
    a unique ID.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Attribute**: These are our object properties. Instead of having one column
    per attribute on the product table, attributes are stored on separate sets of
    tables.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Value**: As the name implies, it is simply the value link to a particular
    attribute.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This data model is the secret behind Magento's flexibility and power, allowing
    entities to add and remove new properties without having to make any changes to
    the code, templates, or the database schema.
  prefs: []
  type: TYPE_NORMAL
- en: This model can be seen as a vertical way of growing our database (new attributes
    and more rows), while the traditional model involves a horizontal growth pattern
    (new attributes and more columns), which would result in a schema redesign every
    time new attributes are added.
  prefs: []
  type: TYPE_NORMAL
- en: The **EAV** model not only allows for the fast evolution of our database, but
    is also more effective because it only works with non-empty attributes, avoiding
    the need to reserve additional space in the database for null values.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If you are interested in exploring and learning more about the Magento database
    structure, I highly recommend visiting [www.magereverse.com](http://www.magereverse.com).
  prefs: []
  type: TYPE_NORMAL
- en: Adding a new product attribute is as simple going to the Magento backend and
    specifying the new attribute type, be it color, size, brand, or anything else.
    The opposite is true as well and we can get rid of unused attributes on our products
    or customer models.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: For more information on managing attributes, visit [http://www.magentocommerce.com/knowledge-base/entry/how-do-attributes-work-in-magento](http://www.magentocommerce.com/knowledge-base/entry/how-do-attributes-work-in-magento).
  prefs: []
  type: TYPE_NORMAL
- en: 'The Magento community edition currently has eight different types of EAV objects:'
  prefs: []
  type: TYPE_NORMAL
- en: Customer
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Customer Address
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Products
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Product Categories
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Orders
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Invoices
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Credit Memos
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Shipments
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The Magento Enterprise Edition has one additional type called **RMA** item,
    which is part of the **Return Merchandise Authorization** (**RMA**) system.
  prefs: []
  type: TYPE_NORMAL
- en: All this flexibility and power is not free; there is a price to pay. Implementing
    the EAV model results in having our entity data distributed on a large number
    of tables. For example, just the Product Model is distributed to around 40 different
    tables.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following diagram only shows a few of the tables involved in saving the
    information of Magento products:'
  prefs: []
  type: TYPE_NORMAL
- en: '![What is EAV?](img/4172_02_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Other major downsides of **EAV** are the loss of performance while retrieving
    large collections of **EAV** objects and an increase in the database query complexity.
    As the data is more fragmented (stored in more tables), selecting a single record
    involves several joins.
  prefs: []
  type: TYPE_NORMAL
- en: One way Magento works around this downside of EAV is by making use of indexes
    and flat tables. For example, Magento can save all the product information into
    the `flat_catalog` table for easier and faster access.
  prefs: []
  type: TYPE_NORMAL
- en: Let's continue using Magento products as our example and manually build the
    query to retrieve a single product.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If you have **phpmyadmin** or **MySQL** **Workbench** installed on your development
    environment, you can experiment with the following queries. Each can be downloaded
    on the **PHPMyAdmin** website at [http://www.phpmyadmin.net/](http://www.phpmyadmin.net/)
    and the **MySQL Workbench** website at [http://www.mysql.com/products/workbench/](http://www.mysql.com/products/workbench/).
  prefs: []
  type: TYPE_NORMAL
- en: 'The first table that we need to use is the `catalog_product_entity` table.
    We canconsider this our main product **EAV** table*since it contains the main
    entity records for our products*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![What is EAV?](img/4172_02_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Let''s query the table by running the following SQL query:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'The table contains the following fields:'
  prefs: []
  type: TYPE_NORMAL
- en: '`entity_id`: This is our product unique identifier that is used internally
    by Magento.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`entity_type_id`: Magento has several different types of EAV models. Products,
    customers, and orders are just some of them. Identifying each of these by type
    allows Magento to retrieve the attributes and values from the appropriate tables.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`attribute_set_id`: Product attributes can be grouped locally into attribute
    sets. Attribute sets allow even further flexibility on the product structure as
    products are not forced to use all available attributes.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`type_id`: There are several different types of products in Magento: simple,
    configurable, bundled, downloadable, and grouped products; each with unique settings
    and functionality.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`sku`: This stands for Stock Keeping Unit and is a number or code used to identify
    each unique product or item for sale in a store. This is a user-defined value.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`has_options`: This is used to identify if a product has custom options.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`required_options`: This is used to identify if any of the custom options that
    are required.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`created_at`: This is the row creation date.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`updated_at`: This is the last time the row was modified.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now we have a basic understanding of the product entity table. Each record represents
    a single product in our Magento store, but we don't have much information about
    that product beyond the SKU and the product type.
  prefs: []
  type: TYPE_NORMAL
- en: So, where are the attributes stored? And how does Magento know the difference
    between a product attribute and a customer attribute?
  prefs: []
  type: TYPE_NORMAL
- en: 'For this, we need to take a look into the `eav_attribute` table by running
    the following SQL query:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'As a result, we will not only see the product attributes, but also the attributes
    corresponding to the customer model, order model, and so on. Fortunately, we already
    have a key to filter the attributes from this table. Let''s run the following
    query:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'This query tells the database to only retrieve the attributes where the `entity_type_id`
    column is equal to the product `entity_type_id(4)`. Before moving, let''s analyze
    the most important fields inside the `eav_attribute` table:'
  prefs: []
  type: TYPE_NORMAL
- en: '`attribute_id`: This is the unique identifier for each attribute and primary
    key of the table.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`entity_type_id`: This relates each attribute to a specific eav model type.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`attribute_code`: This is the name or key of our attribute and is used to generate
    the getters and setters for our magic methods.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`backend_model`: These manage loading and storing data into the database.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`backend_type`: This specifies the type of value stored in the backend (database).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`backend_table`: This is used to specify if the attribute should be stored
    on a special table instead of the default EAV table.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`frontend_model`: These handle the rendering of the attribute element into
    a web browser.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`frontend_input`: Similar to the frontend model, the frontend input specifies
    the type of input field the web browser should render.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`frontend_label`: This is the label/name of the attribute as it should be rendered
    by the browser.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`source_model`: These are used to populate an attribute with possible values.
    Magento comes with several predefined source models for countries, yes or no values,
    regions, and so on.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Retrieving the data
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: At this point, we have successfully retrieved a product entity and the specific
    attributes that apply to that entity. Now it's time to start retrieving the actual
    values. In order to simplify the example (and the query) a little, we will only
    try to retrieve the name attribute of our products.
  prefs: []
  type: TYPE_NORMAL
- en: 'How do we know which table our attribute values are stored on? Well, thankfully,
    Magento follows a naming convention to name the tables. If we inspect our database
    structure, we will notice that there are several tables using the `catalog_product_entity`
    prefix:'
  prefs: []
  type: TYPE_NORMAL
- en: '`catalog_product_entity`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`catalog_product_entity_datetime`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`catalog_product_entity_decimal`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`catalog_product_entity_int`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`catalog_product_entity_text`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`catalog_product_entity_varchar`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`catalog_product_entity_gallery`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`catalog_product_entity_media_gallery`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`catalog_product_entity_tier_price`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Wait! How do we know which is the right table to query for our name attribute
    values? If you were paying attention, I already gave you the answer. Remember
    that the `eav_attribute` table had a column called `backend_type`?
  prefs: []
  type: TYPE_NORMAL
- en: 'Magento EAV stores each attribute on a different table based on the backend
    type of that attribute. If we want to confirm the backend type of our name attribute,
    we can do so by running the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'As a result, we should see that the backend type is varchar and that the values
    for this attribute are stored in the `catalog_product_entity_varchar` table. Let''s
    inspect this table:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Retrieving the data](img/4172_02_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The `catalog_product_entity_varchar` table is formed by only 6 columns:'
  prefs: []
  type: TYPE_NORMAL
- en: '`value_id`: This is the attribute value unique identifier and primary key'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`entity_type_id`: This is the entity type ID to which this value belongs'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`attribute_id`: This is the foreign key that relates the value to our `eav_entity`
    table'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`store_id`: This is the foreign key matching an attribute value with a storeview'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`entity_id`: This is the foreign key relating to the corresponding entity table,
    in this case, `catalog_product_entity`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`value`: This is the actual value that we want to retrieve'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Depending on the attribute configuration, we can have it as a global value,
    meaning, it applies across all store views or a value per storeview.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we finally have all the tables that we need to retrieve the product
    information, we can build our query:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: '![Retrieving the data](img/4172_02_08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: From our query, we should see a result set with three columns, `product_id`,
    `product_name`, and `product_sku`. So let's step back for a second in order to
    get product names with SKUs with raw SQL. We had to write a five-line SQL query,
    and we only retrieved two values from our products, from one single EAV value
    table if we want to retrieve a numeric field such as price or a text-value-like
    product.
  prefs: []
  type: TYPE_NORMAL
- en: If we didn't have an **ORM** in place, maintaining Magento would be almost impossible.
    Fortunately, we do have an ORM in place, and most likely, you will never need
    to deal with raw SQL to work with Magento.
  prefs: []
  type: TYPE_NORMAL
- en: 'That said, let''s see how we can retrieve the same product information by using
    the Magento ORM:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Our first step is going to be to instantiate a product collection:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then we will specifically tell Magento to select the name attribute:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then, we will ask it to sort the collection by name:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Finally, we will tell Magento to load the collection:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The end result is a collection of all products in the store sorted by name.
    We can inspect the actual SQL query by running the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In just three lines of code, we are telling Magento to grab all the products
    in the store, to specifically select the name, and finally order the products
    by name.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The last line `$collection->getSelect()->__toString();` allows to see the actual
    query that Magento is executing in our behalf.
  prefs: []
  type: TYPE_NORMAL
- en: 'The actual query being generated by Magento is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: As we can see, the ORM and the EAV models are wonderful tools that not only
    put a lot of power and flexibility in the hands of the developers, but they also
    do it in a way that is comprehensive and easy to use.
  prefs: []
  type: TYPE_NORMAL
- en: Working with Magento collections
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you look back at the previous code example, you will notice that I'm not
    only instantiating a product model, but I'm also calling the `getCollection()`
    method. The `getCollection()` method is part of the `Mage_Core_Model_Abstract`
    class, meaning, every single model inside Magento can call this method.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: All collections inherit from `Varien_Data_Collection`.
  prefs: []
  type: TYPE_NORMAL
- en: A Magento collection is basically a model that contains other models. So instead
    of using an array to hold a collection of products, we will use a product collection.
    Collections not only provide a convenient data structure to group models, they
    also provide special methods that we can use to manipulate and work with a collection
    of entities.
  prefs: []
  type: TYPE_NORMAL
- en: 'Some of the most useful collection methods are:'
  prefs: []
  type: TYPE_NORMAL
- en: '`addAttributeToSelect`: To add an attribute to the entities in a collection;
    `*` can be used as a wildcard to add all the available attributes'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`addFieldToFilter`: To add an attribute filter to a collection; this function
    is used on regular non-EAV models or to filter attributes that are part of the
    master product table like SKU'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`addAttributeToFilter`: This method is used to filter a collection of EAV entities'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`addAttributeToSort`: This method is used to add an attribute to the sort order'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`addStoreFilter`: This method is used to add a store filter to the current
    collection. It might not be available on all object types'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`addWebsiteFilter`: This method is used to add a website filter to a collection'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`addCategoryFilter`: This method is used to specify a category filter for a
    product collection'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`addUrlRewrite`: This method is used to add URL rewrite data to the product
    collection'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`setOrder`: This method is used to set the sorting order of a collection'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These are just a few of the collection methods available. Each collection implements
    different unique methods depending on the entity type they correspond to. For
    example, the customer collection `Mage_Customer_Model_Resource_Customer_Collection`
    has a unique method called `groupByEmail()`, which, as the name correctly implies,
    groups the entities inside a collection by e-mail.
  prefs: []
  type: TYPE_NORMAL
- en: As with previous examples, we will continue working with the product models,
    and in this case, the product collection.
  prefs: []
  type: TYPE_NORMAL
- en: '![Working with Magento collections](img/4172_02_09.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'In order to better illustrate how we can use the collection, will be working
    on the following common product scenarios:'
  prefs: []
  type: TYPE_NORMAL
- en: Get a product collection only from a specific category
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Get new products since date *X*
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Get bestseller products
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Filter product collections by visibility
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Filter products without image
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add multiple sort orders
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Get product collections only from a specific category
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The first thing most developers try to do when starting with Magento is load
    a product collection with products only from a specific category. While I have
    seen many approaches by using `addCategoryFilter()` or `addAttributeToFilter()`,
    the reality is that for most cases, the approach is much simpler and a bit contra-intuitive
    to what we have learned so far.
  prefs: []
  type: TYPE_NORMAL
- en: 'The easiest way of doing this is not getting a product collection first and
    then filtering by a category, but actually instantiating our target category and
    getting the product collection from there, let''s run the following code snippet
    on IMC:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'We can find the `getProductCollection()` method declaration inside the `Mage_Catalog_Model_Category`
    class. Let''s take a closer look at this method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: As we can see, the function does nothing more than instantiate Resource Model
    for the product collection, set the store to the current store ID, and pass the
    current category to the `addCategoryFilter()`.
  prefs: []
  type: TYPE_NORMAL
- en: This is one of those decisions that was taken to optimize Magento's performance
    and frankly, to simplify the life of the developers working with it, as in most
    cases, a category is going to be available one way or the other.
  prefs: []
  type: TYPE_NORMAL
- en: Get new products added since X date
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'So now that we know how to get a product collection from a specific category,
    let''s say we are able to apply filters to the resulting products and we only
    the retrieve the ones matching our conditions. In this particular case, we will
    request all products added after December 2012\. Following our previous example
    code, we can filter our collection by product creation date by running the following
    code on IMC:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'It''s that simple! We could even add any additional conditions and get the
    products added between two dates. Let''s say we only want to retrieve the products
    that were created in the month of December:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Magento `addFieldToFilter` supports the following conditions:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Attribute code | SQL condition |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `eq` | = |'
  prefs: []
  type: TYPE_TB
- en: '| `neq` | != |'
  prefs: []
  type: TYPE_TB
- en: '| `like` | LIKE |'
  prefs: []
  type: TYPE_TB
- en: '| `nlike` | NOT LIKE |'
  prefs: []
  type: TYPE_TB
- en: '| `in` | IN () |'
  prefs: []
  type: TYPE_TB
- en: '| `nin` | NOT IN () |'
  prefs: []
  type: TYPE_TB
- en: '| `is` | IS |'
  prefs: []
  type: TYPE_TB
- en: '| `notnull` | NOT NULL |'
  prefs: []
  type: TYPE_TB
- en: '| `null` | NULL |'
  prefs: []
  type: TYPE_TB
- en: '| `moreq` | >= |'
  prefs: []
  type: TYPE_TB
- en: '| `gt` | > |'
  prefs: []
  type: TYPE_TB
- en: '| `lt` | < |'
  prefs: []
  type: TYPE_TB
- en: '| `gteq` | >= |'
  prefs: []
  type: TYPE_TB
- en: '| `lteq` | <= |'
  prefs: []
  type: TYPE_TB
- en: We can try other types of filters. For example, let's use the following code
    on IMC after adding our creation date filter. So we can retrieve only visible
    products.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'The visibility attribute is a special attribute used by products to control
    where products are shown. It has the following values:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Not visible individually**: This has a value of 1'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Catalog**: This has a value of 2'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Search**: This has a value of 3'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Catalog and Search**: This has a value of 4'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Get bestseller products
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To try and get the bestseller products for a specific category, we will need
    to step up our game and join with the `sales_order` table. Retrieving bestseller
    products will come in handy later to create a special category or custom reporting.
    We can run the following code on IMC:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Let's analyze what's happening on the third line of our snippet. `getSelect()`
    is a method inherited directly from `Varien_Data_Collection_Db`, which returns
    the variable where the select statement is stored. Additionally, collections provide
    methods to specify a join and a group without actually having to write any SQL.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is not the only way of adding a join to a collection. There is, in fact,
    another way of doing this by using the `joinField()` function which will result
    in a simpler query. Let''s rewrite our previous code to make use of this function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: Filter the product collection by visibility
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This is extremely easy to do with the help of `addAttributeToFilter`. Magento
    products have a system attribute called visibility, which has four possible number
    values ranging from one to four. We are only interested in showing products that
    have a visibility of four, meaning they can be seen both in the search results
    and the catalog. Let''s run the following code in IMC:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: If we change the visibility code, we can compare the different collection results.
  prefs: []
  type: TYPE_NORMAL
- en: Filter products without images
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Filtering products without images comes in handy when you are dealing with
    any third-party import system, which can at times be unreliable. As with everything
    we have done so far, product images are attributes of our product:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'By adding that extra filter, we are requiring products to have a small image
    specified. By default, Magento has three product image types, thumbnail, `small_image`,
    and image. These three types are used on different parts of the application. We
    could even set up a stricter rule for products if we wanted to:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: Only products that have all of three types of images will be included in our
    collection. Try experimenting by filter with the different image types.
  prefs: []
  type: TYPE_NORMAL
- en: Add multiple sort orders
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Finally, let''s take our collection and sort it first by stock status and then
    by price from highest to lowest. In order to retrieve the stock status information,
    we will use a method unique to the stock status Resource Model called `addStockStatusToSelect()`,
    which will take care of generating the corresponding SQL for our collection query:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: Inside this query, Magento will sort products by the salable status, which is
    either true or false, and by price. The end result is where all the available
    products show in the order of first ordered, from most expensive to cheapest,
    and then the out-of-stock products will show from most expensive to cheapest.
  prefs: []
  type: TYPE_NORMAL
- en: Experiment with different sort order combinations to see how Magento organizes
    and orders the product collections.
  prefs: []
  type: TYPE_NORMAL
- en: Using Direct SQL
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So far we have learned how Magento data models and ORM systems provide a clean
    and simple way to access, store, and manipulate our data. Before we jump right
    into this section and learn about the Magento database adapters and how to run
    raw SQL queries, I feel it is important that we understand why you should avoid
    using what you are about to learn in this section as much as possible.
  prefs: []
  type: TYPE_NORMAL
- en: Magento is an extremely **complex system**, and as we've also learned in the
    previous chapter, a framework driven in part by events. Just saving a product
    will trigger half a dozen different events, each doing a different task. This
    will not happen if you decide to just create a query and update a product directly.
    So, as developers, we must be extremely careful and be sure there is a justifiable
    reason to go outside the ORM.
  prefs: []
  type: TYPE_NORMAL
- en: That said, there are of course scenarios when being able to work with the database
    directly comes in extremely handy and is actually simpler than working with the
    Magento models. For example, when updating the product attribute globally or changing
    a product collection status, we could load a product collection and loop through
    each of the individual products, updating and saving them. While this will work
    fine on smaller collections, as soon we start growing and working with a larger
    dataset, our performance starts dropping and the script takes several seconds
    to execute.
  prefs: []
  type: TYPE_NORMAL
- en: On the other hand, a Direct SQL query will execute much faster (usually under
    one second) depending on the size of the dataset and the query being executed.
  prefs: []
  type: TYPE_NORMAL
- en: Out-of-the-box Magento will take care of all the heavy lifting of having to
    establish a connection to the database by using the `Mage_Core_Model_Resource`
    model. Magento makes three types of connections available to us, `core_read`,
    `core_setup` and `core_write`. For now, we will only focus on `core_read` and
    `core_write`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s start by instantiating a Resource Model and two connections, one to
    read and the other to write:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: Even if we are working with Direct SQL queries, thanks to Magento, we don't
    have to worry about setting up the connection to the DB beyond instantiating a
    Resource Model and the proper type of connection.
  prefs: []
  type: TYPE_NORMAL
- en: Reading
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s test our read connection by executing the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: Although this query works and it will return all the products in the `catalog_product_entity`
    table, what will happen if we try to run this same code on a Magento installation
    that uses table prefixes? Or what if Magento suddenly changes the table name in
    the next upgrade? This code is not portable or easily maintainable. Fortunately,
    the Resource Model provides another handy method called `getTableName()`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `getTableName()` method will take a factory name as a parameter, and based
    on the configuration established by the config.xml, it will not only find the
    right table, but will also verify if the table exists in the DB. Let''s update
    our code to use `getTableName()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'We are also using the `fetchAll()` method that will return all the rows returned
    by our query as an array, but this is not the only available method. We also have
    `fetchCol()` and `fetchOne()` at our disposition:'
  prefs: []
  type: TYPE_NORMAL
- en: '`fetchAll`: This retrieves all the rows returned by the original query.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`fetchOne`: This returns only the values from the first database row returned
    by the query.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`fetchCol`: This returns all the columns returned by the query but only the
    first row. This is useful if you only want to retrieve a single column with unique
    identifiers such products IDs or SKUs.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Writing
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As we mentioned before, saving a model in Magento, be it a product, category,
    customer, or anything else, can be relatively slow due to the amount of observers
    and events triggered in the backend.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, if we are only looking to update simple static values, updating large
    collections can be a painfully slow process if done through the Magento ORM. Let''s
    say that, for example, we want to make all the products on the site out of stock.
    Instead of doing this through the Magento backend or creating a custom script
    that iterates through a collection of all the products, we can simply do as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we have learned about Magento models, their inheritance and
    purpose, and how Magento uses resources and collections to implement its own ORM.
  prefs: []
  type: TYPE_NORMAL
- en: We also learned about EAV models and how they are structured to provide Magento
    with data flexibility and extensibility that both merchants and developers can
    take advantage of.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we saw how developers can access the database directly by writing DirectSQL
    and using the Magento resource adapters.
  prefs: []
  type: TYPE_NORMAL
- en: The chapters so far have been more theory than practice. This has been done
    with the intention of guiding you through the complexity of Magento and providing
    you with the tools and knowledge that you require for the rest of the book. For
    the remaining chapters of the book, we will take a more hands-on approach and
    start building extensions, incrementally applying all the concepts we have learned
    so far.
  prefs: []
  type: TYPE_NORMAL
- en: Our next chapter is called *Frontend Development* where we will start getting
    our feet wet and develop our first Magento extension.
  prefs: []
  type: TYPE_NORMAL
