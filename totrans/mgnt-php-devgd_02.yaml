- en: Chapter 2. ORM and Data Collections
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第二章：ORM 和数据集合
- en: Collections and models are the bread and butter of everyday Magento development.
    In this chapter, we will introduce the reader to the Magento ORM system, and we
    will learn how to work with data collections and the EAV system properly. As most
    modern systems, Magento implements an **object-relational mapping** (**ORM**)
    system.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 集合和模型是日常 Magento 开发的基础。在本章中，我们将向读者介绍 Magento ORM 系统，我们将学习如何正确地处理数据集合和 EAV 系统。与大多数现代系统一样，Magento
    实现了一个 **对象关系映射**（**ORM**）系统。
- en: '*Object-relational mapping (ORM, O/RM, and O/R mapping) in computer software
    is a programming technique for converting data between incompatible type systems
    in object-oriented programming languages. This creates, in effect, a "virtual
    object database" that can be used from within the programming language.*'
  id: totrans-2
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*在计算机软件中，对象关系映射（ORM、O/RM 和 O/R mapping）是一种编程技术，用于在面向对象的编程语言中将数据在不可兼容的类型系统之间进行转换。实际上，它创建了一个“虚拟对象数据库”，可以在编程语言中使用。*'
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Magento Models
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Magento 模型
- en: Anatomy of a Magento Data Model
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Magento 数据模型的解剖结构
- en: EAV and EAV models
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: EAV 和 EAV 模型
- en: Working with Direct SQL queries
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用直接 SQL 查询
- en: We will also be working with several snippets of code to provide an easy framework
    to experiment and play around with Magento.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将使用几个代码片段来提供一个易于实验和玩耍的框架。
- en: Note
  id: totrans-9
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The interactive examples in this chapter assume you are working either with
    the default Magento installation inside the VagrantBox or a Magento installation
    with sample data.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中的交互式示例假设你正在使用 VagrantBox 内的默认 Magento 安装或带有样本数据的 Magento 安装。
- en: 'For this purpose, I have created the Magento IMC (Interactive Magento Console),
    which is a shell script specially created for this book and inspired by Ruby''s
    IRB (Interactive Ruby Console). To get started, follow these steps:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 为了这个目的，我创建了 Magento IMC（交互式 Magento 控制台），这是一个专门为这本书创建的 shell 脚本，灵感来源于 Ruby 的
    IRB（交互式 Ruby 控制台）。要开始，请按照以下步骤操作：
- en: The first thing we will need to do is install the IMC to download the source
    files from [https://github.com/amacgregor/mdg_imc](https://github.com/amacgregor/mdg_imc)
    and extract them under your Magento test installation. The IMC is a simple Magento
    shell script that will allow to test our code in real time.
  id: totrans-12
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们首先需要做的是安装 IMC，从 [https://github.com/amacgregor/mdg_imc](https://github.com/amacgregor/mdg_imc)
    下载源文件，并在你的 Magento 测试安装下提取它们。IMC 是一个简单的 Magento shell 脚本，它将允许我们在实时测试我们的代码。
- en: Once you extract the script, log into the shell of your VirtualBox.
  id: totrans-13
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦提取了脚本，请登录到你的 VirtualBox 的 shell。
- en: 'Next, we will need to navigate to our Magento root folder. If you are using
    the default vagrant box and installation provided, the root folder is located
    under `/srv/www/ce1720/public_html`. We navigate to it by running this command:'
  id: totrans-14
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们需要导航到我们的 Magento 根目录。如果你使用的是默认的 vagrant 盒子和安装，根目录位于 `/srv/www/ce1720/public_html`
    之下。我们可以通过运行此命令来导航到它：
- en: '[PRE0]'
  id: totrans-15
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Finally, we can start the IMC by running the following command:'
  id: totrans-16
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们可以通过运行以下命令来启动 IMC：
- en: '[PRE1]'
  id: totrans-17
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: If everything is installed successfully, we will see a new line starting with
    `magento >`.
  id: totrans-18
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果一切安装成功，我们将看到以 `magento >` 开头的新行。
- en: Magento Model anatomy
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Magento 模型解剖
- en: 'As we learned in the previous chapter, Magento data models are used to manipulate
    and access the data. The model layer is divided into two fundamental types, simple
    models and EAV:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在上一章中学到的，Magento 数据模型用于操作和访问数据。模型层分为两种基本类型，简单模型和 EAV：
- en: '**Simple models**: These model implementations are a simple mapping of one
    object to one table, meaning our object attributes match each field and our table
    structure.'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**简单模型**：这些模型实现是将一个对象映射到一个表，意味着我们的对象属性与每个字段匹配，我们的表结构也是如此。'
- en: '**Entity Attribute Value models**: This type of models, known as EAV models,
    are used to describe entities with a dynamic number of attributes.'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**实体属性值模型**：这类模型，称为 EAV 模型，用于描述具有动态属性数量的实体。'
- en: Note
  id: totrans-23
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: It is important to clarify that not all Magento models extend or make use of
    the ORM. Observers are a clear example of simpler model classes that are not mapped
    to a specific database table or entity.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 需要明确的是，并非所有 Magento 模型都扩展或使用 ORM。观察者是一个清晰的例子，它是简单的模型类，没有映射到特定的数据库表或实体。
- en: 'In addition to that, each Model type is formed by the following layers:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，每种模型类型由以下层次组成：
- en: '**Model class**: This is where most of our business logic resides. Models are
    used to manipulate the data, but they don''t access it directly.'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**模型类**：这是我们大部分业务逻辑所在的地方。模型用于操作数据，但它们不直接访问数据。'
- en: '**Resource Model class**: Resource Models are used to interact with the database
    on behalf of our models. They are in charge of the actual CRUD operations.'
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**资源模型类**：资源模型用于代表我们的模型与数据库进行交互。它们负责实际的CRUD操作。'
- en: '**Model Collection class**: Each Data Model has a collection class. Collections
    are objects that hold a number of individual Magento Model instances.'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**模型集合类**：每个数据模型都有一个集合类。集合是包含多个单独的Magento模型实例的对象。'
- en: Note
  id: totrans-29
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: CRUD stands for the four basic types of database operations, namely create,
    read, update, and delete.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: CRUD代表数据库操作的四种基本类型，即创建(create)、读取(read)、更新(update)和删除(delete)。
- en: Magento Models don't contain any logic to communicate with the database; they
    are database agnostic. Instead, this code resides in the Resource Model layer.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: Magento模型不包含与数据库通信的逻辑；它们是数据库无关的。相反，这段代码位于资源模型层。
- en: 'This gives Magento the capacity to support different types of databases and
    platforms. Although currently, only MySQL is officially supported, it is entirely
    possible to write a new resource class for a new database without touching any
    of the Model logic:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 这使得Magento能够支持不同类型的数据库和平台。尽管目前只官方支持MySQL，但完全可以为新的数据库编写一个新的资源类，而不需要触及任何模型逻辑：
- en: '![Magento Model anatomy](img/4172_02_01.jpg)'
  id: totrans-33
  prefs: []
  type: TYPE_IMG
  zh: '![Magento模型解剖图](img/4172_02_01.jpg)'
- en: 'Let''s experiment now by instantiating a product object and setting some of
    its properties:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们现在通过实例化一个产品对象并设置其一些属性来实验：
- en: 'Start the Magento interactive console running under your Magento staging installation
    root:'
  id: totrans-35
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在您的Magento测试安装根目录下启动Magento交互式控制台：
- en: '[PRE2]'
  id: totrans-36
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Our first step is to create a new product object instance by typing the following
    code:'
  id: totrans-37
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们的第一步是通过输入以下代码创建一个新的产品对象实例：
- en: '[PRE3]'
  id: totrans-38
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'We can confirm this is a blank instance of the product class by running the
    following code:'
  id: totrans-39
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过运行以下代码，我们可以确认这是一个产品类的空实例：
- en: '[PRE4]'
  id: totrans-40
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'We should see the following as a successful output:'
  id: totrans-41
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们应该看到以下作为成功的输出：
- en: '[PRE5]'
  id: totrans-42
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'If we want to know more about the class methods, we can run the following code:'
  id: totrans-43
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果我们想了解更多关于类方法的信息，我们可以运行以下代码：
- en: '[PRE6]'
  id: totrans-44
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'This will return an array with all the available methods inside the class.
    Let''s try to run the following code snippet and modify a product''s price and
    name:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 这将返回一个包含类中所有可用方法的数组。让我们尝试运行以下代码片段并修改产品的价格和名称：
- en: '[PRE7]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: On the first line of code, we instantiate a specific object and then proceed
    to retrieve the name attribute from the object. Next, we set the price and name,
    and finally, we save the object.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 在代码的第一行，我们实例化了一个特定的对象，然后继续从对象中检索名称属性。接下来，我们设置价格和名称，最后保存对象。
- en: If we open our Magento product class `Mage_Catalog_Model_Product`, the first
    thing we will notice is that while both `getName()` and `getPrice()` are defined
    inside our class, the `setPrice()` and `setName()` functions are not defined anywhere.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们打开我们的Magento产品类`Mage_Catalog_Model_Product`，我们首先会注意到，虽然`getName()`和`getPrice()`在我们的类中都有定义，但`setPrice()`和`setName()`函数在任何地方都没有定义。
- en: However, why, and more importantly how, is Magento *magically* defining each
    of the product object setter and getter methods? While `getPrice()` and `getName()`
    are indeed defined, there is no definition for any of the getter and setter methods
    for product attributes such as color or manufacturer.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，为什么以及更重要的是，如何让Magento神奇地定义每个产品对象setter和getter方法？虽然`getPrice()`和`getName()`确实被定义了，但产品属性如颜色或制造商的getter和setter方法都没有定义。
- en: It's magic – methods
  id: totrans-50
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 真的是神奇的——方法
- en: Well it so happens that the Magento ORM system is indeed magic. To be precise,
    one of PHP's more powerful features is to implement its getters and setters, the
    magic `__call()` method. Magic methods are used inside Magento to set, unset,
    check, or retrieve data.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，事实是Magento的ORM系统确实是神奇的。更准确地说，PHP更强大的功能之一是实现其getter和setter，即神奇的`__call()`方法。魔法方法在Magento中用于设置、取消设置、检查或检索数据。
- en: When we try to call a method that does not actually exist in our corresponding
    class, PHP will look into each of the parent classes for a declaration of that
    method. If it can't find the function on any of the parent classes, it will use
    its last resort and try to use a `__call()` method. If found, Magento (or PHP
    for that matter) will call the magic method, passing the requested method name
    and its arguments.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们尝试调用在相应类中实际上不存在的方法时，PHP会检查每个父类以查找该方法的声明。如果它在任何父类中找不到该函数，它将使用最后的手段并尝试使用`__call()`方法。如果找到，Magento（或PHP）将调用魔法方法，传递请求的方法名及其参数。
- en: 'Now, the Product model doesn''t have a `__call()` method defined, but it gets
    one from the `Varien_Object` that most Magento models inherit from. The inheritance
    tree for the `Mage_Catalog_Model_Product` class is as follows:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，产品模型没有定义`__call()`方法，但它从大多数Magento模型继承的`Varien_Object`中获取一个。`Mage_Catalog_Model_Product`类的继承树如下：
- en: '![It''s magic – methods](img/4172_02_02.jpg)'
  id: totrans-54
  prefs: []
  type: TYPE_IMG
  zh: '![它是神奇的 – 方法](img/4172_02_02.jpg)'
- en: Tip
  id: totrans-55
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: Most Magento Models inherit from the `Varien_Object` class.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数Magento模型都继承自`Varien_Object`类。
- en: 'Let''s take a closer look at the `Varien_Object` class:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更仔细地看看`Varien_Object`类：
- en: Open the file located in `magento_root/lib/Varien/Object.php`.
  id: totrans-58
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开位于`magento_root/lib/Varien/Object.php`的文件。
- en: The `Varien_Object` class not only has a **__call()** method but also has two
    deprecated methods, **__set()** and **__get()**. Both of these are replaced by
    the **__call()** method and are no longer used.
  id: totrans-59
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Varien_Object`类不仅有一个`**__call()**`方法，还有两个已弃用的方法，`**__set()**`和`**__get()**`。这两个方法都被`**__call()**`方法所取代，并且不再使用。'
- en: '[PRE8]'
  id: totrans-60
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Inside the `__call()` method, we have a switch that will handle not only getters
    and setters but also the `unset` and `has` functions.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 在`__call()`方法内部，我们有一个switch语句，它不仅处理getters和setters，还处理`unset`和`has`函数。
- en: If we start a debugger and follow the calls of our snippet code to the `__call()`
    method, we will see that it receives two arguments, the method name (for example
    `setName()`) and the arguments from the original call.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们启动调试器并跟踪我们的代码片段对`__call()`方法的调用，我们会看到它接收两个参数，即方法名（例如`setName()`）和原始调用中的参数。
- en: 'Interestingly, Magento tries to match the corresponding method type based on
    the first three letters of the method being called. This is done with the switch
    case argument by calling the substring function:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 有趣的是，Magento尝试根据被调用方法的第一个三个字母来匹配相应的方法类型。这是通过调用子字符串函数来完成的：
- en: '[PRE9]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The first thing that is called inside each case is the `_underscore()` function,
    which takes as parameter anything after the first three characters in the method
    name. Following our example, the argument passed will be `Name`.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 在每个情况中首先被调用的函数是`_underscore()`，它将方法名中的前三个字符之后的内容作为参数。按照我们的例子，传递的参数将是`Name`。
- en: 'The `__underscore()` function returns a data key. This key is then used by
    each of the cases to manipulate the data. There are four basic data operations,
    each is used on the corresponding switch case:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '`__underscore()`函数返回一个数据键。然后，每个case使用这个键来操作数据。有四种基本的数据操作，每个操作都用于相应的switch case：'
- en: '`setData` (`$parameters`)'
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`setData` (`$parameters`)'
- en: '`getData` (`$parameters`)'
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`getData` (`$parameters`)'
- en: '`unsetData` (`$parameters`)'
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`unsetData` (`$parameters`)'
- en: '`isset` (`$parameters`)'
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`isset` (`$parameters`)'
- en: 'Each of these functions will interact with the `Varien_Object` data array and
    manipulate it accordingly. In most cases, a magic set/get method will be used
    to interact with our object attributes. Only in a few exceptions, where additional
    business logic is required, getters and setters will be defined. In our example,
    this would be `getName()` and `getPrice()`:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 这些函数中的每一个都会与`Varien_Object`数据数组交互并相应地操作它。在大多数情况下，将使用魔法set/get方法来与我们的对象属性交互。只有在少数需要额外业务逻辑的例外情况下，才会定义getters和setters。在我们的例子中，这将包括`getName()`和`getPrice()`：
- en: '[PRE10]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'We will not get into details of what the price function is actually doing,
    but it clearly illustrates that additional logic may be required for certain parts
    of the models:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不会深入探讨价格函数实际上在做什么，但它清楚地表明，模型的一些部分可能需要额外的逻辑：
- en: '[PRE11]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: On the other hand, the `getName()` getter wasn't declared because of the need
    to implement special logic but by the need to optimize a crucial part of Magento.
    The `Mage_Catalog_Model_Product` `getName()` function, which can potentially be
    called hundreds of times per page load, is one of the most commonly used functions
    across all Magento. After all, what kind of e-commerce platform would it be if
    it was not centered around products?
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，`getName()`获取器没有被声明，是因为需要实现特殊逻辑，但也是因为需要优化Magento的关键部分。`Mage_Catalog_Model_Product`的`getName()`函数，在页面加载时可能会被调用数百次，是所有Magento中最常用的函数之一。毕竟，如果它不以产品为中心，那将是什么样的电子商务平台呢？
- en: Frontend and backend will both call the `getName()` function at one point or
    another. For example, loading a category page with 24 products. That's 24 separate
    calls to the `getName()` function. Having each of these calls look for a `getName()`
    method on each of the parent classes and then trying to use the magic `__call()`
    method will result in losing precious milliseconds.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 前端和后端都会在某个时候调用`getName()`函数。例如，加载包含24个产品的类别页面。这是对`getName()`函数的24次单独调用。如果每个调用都在每个父类上查找`getName()`方法，然后尝试使用魔法`__call()`方法，将会导致失去宝贵的毫秒。
- en: '**Resource Models** contain all the database-specific logic and they instantiate
    specific read-and-write adapters for their corresponding data source. Let''s go
    back to our example of working with products and take a look the product Resource
    Model located in `Mage_Catalog_Model_Resource_Product`:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '**资源模型**包含所有数据库特定的逻辑，并为它们对应的数据源实例化特定的读写适配器。让我们回到我们处理产品的例子，看看位于`Mage_Catalog_Model_Resource_Product`的产品资源模型：'
- en: '![It''s magic – methods](img/4172_02_03.jpg)'
  id: totrans-78
  prefs: []
  type: TYPE_IMG
  zh: '![它很神奇 - 方法](img/4172_02_03.jpg)'
- en: Resource Models come in two different types, Entity and Resource. The latter
    is a pretty standard one-table/one-model association, while the former is far
    more complicated.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 资源模型有两种类型，实体和资源。后者是一个相当标准的单表/单模型关联，而前者则更为复杂。
- en: The EAV model
  id: totrans-80
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: EAV模型
- en: EAV stands for entity, attribute, and value and is probably the most difficult
    concept for new Magento developers to grasp. While the EAV concept is not unique
    to Magento, it is rarely implemented on modern systems. Additionally, a Magento
    implementation is not a simple one.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: EAV代表实体、属性和值，可能是新Magento开发者最难理解的概念。虽然EAV概念并非仅限于Magento，但在现代系统中很少实现。此外，Magento的实现也不是简单的。
- en: '![The EAV model](img/4172_02_04.jpg)'
  id: totrans-82
  prefs: []
  type: TYPE_IMG
  zh: '![EAV模型](img/4172_02_04.jpg)'
- en: What is EAV?
  id: totrans-83
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 什么是EAV？
- en: 'In order to understand what EAV is and what its role within Magento is, we
    need to break down parts of the EAV model:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 为了理解EAV是什么以及它在Magento中的作用，我们需要分解EAV模型的部分：
- en: '**Entity**: This represents the data items (objects) inside Magento products,
    customers, categories, and orders. Each entity is stored in the database with
    a unique ID.'
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**实体**：这代表Magento产品、客户、类别和订单内部的数据项（对象）。每个实体都存储在数据库中，并具有一个唯一的ID。'
- en: '**Attribute**: These are our object properties. Instead of having one column
    per attribute on the product table, attributes are stored on separate sets of
    tables.'
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**属性**：这些是我们的对象属性。在产品表中，我们不是为每个属性设置一个列，而是将属性存储在单独的表集中。'
- en: '**Value**: As the name implies, it is simply the value link to a particular
    attribute.'
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**值**：正如其名，它只是与特定属性关联的值。'
- en: This data model is the secret behind Magento's flexibility and power, allowing
    entities to add and remove new properties without having to make any changes to
    the code, templates, or the database schema.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 这种数据模型是Magento灵活性和强大的秘密所在，允许实体在不修改代码、模板或数据库模式的情况下添加和删除新的属性。
- en: This model can be seen as a vertical way of growing our database (new attributes
    and more rows), while the traditional model involves a horizontal growth pattern
    (new attributes and more columns), which would result in a schema redesign every
    time new attributes are added.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 这个模型可以看作是数据库垂直扩展的方式（新的属性和更多的行），而传统的模型涉及水平扩展模式（新的属性和更多的列），每次添加新属性时都会导致模式重设计。
- en: The **EAV** model not only allows for the fast evolution of our database, but
    is also more effective because it only works with non-empty attributes, avoiding
    the need to reserve additional space in the database for null values.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '**EAV**模型不仅允许我们的数据库快速进化，而且更有效，因为它只处理非空属性，避免了在数据库中为空值预留额外空间的需要。'
- en: Tip
  id: totrans-91
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: If you are interested in exploring and learning more about the Magento database
    structure, I highly recommend visiting [www.magereverse.com](http://www.magereverse.com).
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你对探索和学习更多关于Magento数据库结构感兴趣，我强烈推荐访问[www.magereverse.com](http://www.magereverse.com)。
- en: Adding a new product attribute is as simple going to the Magento backend and
    specifying the new attribute type, be it color, size, brand, or anything else.
    The opposite is true as well and we can get rid of unused attributes on our products
    or customer models.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 添加新的产品属性就像进入Magento后端并指定新的属性类型一样简单，无论是颜色、尺寸、品牌还是其他任何东西。反之亦然，我们也可以在我们的产品或客户模型上删除未使用的属性。
- en: Note
  id: totrans-94
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: For more information on managing attributes, visit [http://www.magentocommerce.com/knowledge-base/entry/how-do-attributes-work-in-magento](http://www.magentocommerce.com/knowledge-base/entry/how-do-attributes-work-in-magento).
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 更多关于管理属性的信息，请访问[http://www.magentocommerce.com/knowledge-base/entry/how-do-attributes-work-in-magento](http://www.magentocommerce.com/knowledge-base/entry/how-do-attributes-work-in-magento)。
- en: 'The Magento community edition currently has eight different types of EAV objects:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: Magento社区版目前有八种不同的EAV对象类型：
- en: Customer
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 客户
- en: Customer Address
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 客户地址
- en: Products
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 产品
- en: Product Categories
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 产品分类
- en: Orders
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 订单
- en: Invoices
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 发票
- en: Credit Memos
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 信用备忘录
- en: Shipments
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 货运
- en: Note
  id: totrans-105
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The Magento Enterprise Edition has one additional type called **RMA** item,
    which is part of the **Return Merchandise Authorization** (**RMA**) system.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: Magento企业版有一个额外的类型称为**RMA**项目，它是**退货商品授权**（**RMA**）系统的一部分。
- en: All this flexibility and power is not free; there is a price to pay. Implementing
    the EAV model results in having our entity data distributed on a large number
    of tables. For example, just the Product Model is distributed to around 40 different
    tables.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些灵活性和强大功能并非免费，需要付出代价。实施EAV模型会导致我们的实体数据分布在大量表中。例如，仅产品模型就分布在约40个不同的表中。
- en: 'The following diagram only shows a few of the tables involved in saving the
    information of Magento products:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图表仅显示了保存Magento产品信息涉及的一些表：
- en: '![What is EAV?](img/4172_02_05.jpg)'
  id: totrans-109
  prefs: []
  type: TYPE_IMG
  zh: '![什么是EAV？](img/4172_02_05.jpg)'
- en: Other major downsides of **EAV** are the loss of performance while retrieving
    large collections of **EAV** objects and an increase in the database query complexity.
    As the data is more fragmented (stored in more tables), selecting a single record
    involves several joins.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: '**EAV**的另一个主要缺点是在检索大量**EAV**对象时性能下降，以及数据库查询复杂性的增加。由于数据更加碎片化（存储在更多表中），选择单个记录需要多个连接。'
- en: One way Magento works around this downside of EAV is by making use of indexes
    and flat tables. For example, Magento can save all the product information into
    the `flat_catalog` table for easier and faster access.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: Magento解决EAV这一缺点的一种方法是通过使用索引和平坦表。例如，Magento可以将所有产品信息保存到`flat_catalog`表中，以便更容易和更快地访问。
- en: Let's continue using Magento products as our example and manually build the
    query to retrieve a single product.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续以Magento产品为例，手动构建查询以检索单个产品。
- en: Tip
  id: totrans-113
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: If you have **phpmyadmin** or **MySQL** **Workbench** installed on your development
    environment, you can experiment with the following queries. Each can be downloaded
    on the **PHPMyAdmin** website at [http://www.phpmyadmin.net/](http://www.phpmyadmin.net/)
    and the **MySQL Workbench** website at [http://www.mysql.com/products/workbench/](http://www.mysql.com/products/workbench/).
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你已经在你的开发环境中安装了**phpmyadmin**或**MySQL** **Workbench**，你可以尝试以下查询。每个查询都可以在**PHPMyAdmin**网站[http://www.phpmyadmin.net/](http://www.phpmyadmin.net/)和**MySQL
    Workbench**网站[http://www.mysql.com/products/workbench/](http://www.mysql.com/products/workbench/)上下载。
- en: 'The first table that we need to use is the `catalog_product_entity` table.
    We canconsider this our main product **EAV** table*since it contains the main
    entity records for our products*:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要使用的第一个表是`catalog_product_entity`表。我们可以将其视为我们的主要产品**EAV**表，因为它包含我们产品的主体记录：
- en: '![What is EAV?](img/4172_02_06.jpg)'
  id: totrans-116
  prefs: []
  type: TYPE_IMG
  zh: '![什么是EAV？](img/4172_02_06.jpg)'
- en: 'Let''s query the table by running the following SQL query:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过运行以下SQL查询来查询该表：
- en: '[PRE12]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The table contains the following fields:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 该表包含以下字段：
- en: '`entity_id`: This is our product unique identifier that is used internally
    by Magento.'
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`entity_id`：这是我们产品的唯一标识符，由Magento内部使用。'
- en: '`entity_type_id`: Magento has several different types of EAV models. Products,
    customers, and orders are just some of them. Identifying each of these by type
    allows Magento to retrieve the attributes and values from the appropriate tables.'
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`entity_type_id`：Magento有几种不同的EAV模型类型。产品、客户和订单只是其中的一些。通过类型识别每个这些模型允许Magento从适当的表中检索属性和值。'
- en: '`attribute_set_id`: Product attributes can be grouped locally into attribute
    sets. Attribute sets allow even further flexibility on the product structure as
    products are not forced to use all available attributes.'
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`attribute_set_id`：产品属性可以本地分组到属性集中。属性集允许在产品结构上具有更大的灵活性，因为产品不必使用所有可用的属性。'
- en: '`type_id`: There are several different types of products in Magento: simple,
    configurable, bundled, downloadable, and grouped products; each with unique settings
    and functionality.'
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`type_id`：在Magento中存在多种不同类型的产品：简单产品、可配置产品、捆绑产品、可下载产品和分组产品；每种都有独特的设置和功能。'
- en: '`sku`: This stands for Stock Keeping Unit and is a number or code used to identify
    each unique product or item for sale in a store. This is a user-defined value.'
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`sku`：这代表库存单位，是一个用于识别商店中每个独特产品或商品的数字或代码。这是一个用户定义的值。'
- en: '`has_options`: This is used to identify if a product has custom options.'
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`has_options`：这用于识别产品是否有自定义选项。'
- en: '`required_options`: This is used to identify if any of the custom options that
    are required.'
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`required_options`：这用于识别是否需要任何自定义选项。'
- en: '`created_at`: This is the row creation date.'
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`created_at`：这是行创建日期。'
- en: '`updated_at`: This is the last time the row was modified.'
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`updated_at`：这是行最后一次被修改的时间。'
- en: Now we have a basic understanding of the product entity table. Each record represents
    a single product in our Magento store, but we don't have much information about
    that product beyond the SKU and the product type.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们对产品实体表有了基本的了解。每条记录代表我们Magento商店中的一个单独产品，但我们关于该产品的信息并不多，除了SKU和产品类型。
- en: So, where are the attributes stored? And how does Magento know the difference
    between a product attribute and a customer attribute?
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，属性存储在哪里？Magento是如何区分产品属性和客户属性的？
- en: 'For this, we need to take a look into the `eav_attribute` table by running
    the following SQL query:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个，我们需要通过运行以下SQL查询来查看`eav_attribute`表：
- en: '[PRE13]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'As a result, we will not only see the product attributes, but also the attributes
    corresponding to the customer model, order model, and so on. Fortunately, we already
    have a key to filter the attributes from this table. Let''s run the following
    query:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们将不仅看到产品属性，还会看到与客户模型、订单模型等对应的属性。幸运的是，我们已经有了一个从该表中筛选属性的关键。让我们运行以下查询：
- en: '[PRE14]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'This query tells the database to only retrieve the attributes where the `entity_type_id`
    column is equal to the product `entity_type_id(4)`. Before moving, let''s analyze
    the most important fields inside the `eav_attribute` table:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 这个查询告诉数据库只检索`entity_type_id`列等于产品`entity_type_id(4)`的属性。在移动之前，让我们分析一下`eav_attribute`表中最重要的字段：
- en: '`attribute_id`: This is the unique identifier for each attribute and primary
    key of the table.'
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`attribute_id`：这是每个属性的唯一标识符和表的键。'
- en: '`entity_type_id`: This relates each attribute to a specific eav model type.'
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`entity_type_id`：这将每个属性与特定的eav模型类型相关联。'
- en: '`attribute_code`: This is the name or key of our attribute and is used to generate
    the getters and setters for our magic methods.'
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`attribute_code`：这是我们属性的名称或键，用于生成我们的魔术方法的获取器和设置器。'
- en: '`backend_model`: These manage loading and storing data into the database.'
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`backend_model`：这些用于管理将数据加载和存储到数据库中。'
- en: '`backend_type`: This specifies the type of value stored in the backend (database).'
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`backend_type`：这指定了后端（数据库）中存储的值的类型。'
- en: '`backend_table`: This is used to specify if the attribute should be stored
    on a special table instead of the default EAV table.'
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`backend_table`：这用于指定属性是否应该存储在特殊表中而不是默认的EAV表中。'
- en: '`frontend_model`: These handle the rendering of the attribute element into
    a web browser.'
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`frontend_model`：这些处理将属性元素渲染到网页浏览器中。'
- en: '`frontend_input`: Similar to the frontend model, the frontend input specifies
    the type of input field the web browser should render.'
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`frontend_input`：与前端模型类似，前端输入指定了网页浏览器应该渲染的输入字段的类型。'
- en: '`frontend_label`: This is the label/name of the attribute as it should be rendered
    by the browser.'
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`frontend_label`：这是浏览器应该渲染的属性标签/名称。'
- en: '`source_model`: These are used to populate an attribute with possible values.
    Magento comes with several predefined source models for countries, yes or no values,
    regions, and so on.'
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`source_model`：这些用于填充属性的可能值。Magento自带了几个预定义的源模型，用于国家、是或否值、地区等。'
- en: Retrieving the data
  id: totrans-146
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 检索数据
- en: At this point, we have successfully retrieved a product entity and the specific
    attributes that apply to that entity. Now it's time to start retrieving the actual
    values. In order to simplify the example (and the query) a little, we will only
    try to retrieve the name attribute of our products.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经成功检索到了产品实体及其适用的特定属性。现在是我们开始检索实际值的时候了。为了简化示例（以及查询），我们只会尝试检索我们产品的名称属性。
- en: 'How do we know which table our attribute values are stored on? Well, thankfully,
    Magento follows a naming convention to name the tables. If we inspect our database
    structure, we will notice that there are several tables using the `catalog_product_entity`
    prefix:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 我们如何知道我们的属性值存储在哪个表中？幸运的是，Magento遵循一个命名约定来命名表。如果我们检查我们的数据库结构，我们会注意到有几个表使用 `catalog_product_entity`
    前缀：
- en: '`catalog_product_entity`'
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`catalog_product_entity`'
- en: '`catalog_product_entity_datetime`'
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`catalog_product_entity_datetime`'
- en: '`catalog_product_entity_decimal`'
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`catalog_product_entity_decimal`'
- en: '`catalog_product_entity_int`'
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`catalog_product_entity_int`'
- en: '`catalog_product_entity_text`'
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`catalog_product_entity_text`'
- en: '`catalog_product_entity_varchar`'
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`catalog_product_entity_varchar`'
- en: '`catalog_product_entity_gallery`'
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`catalog_product_entity_gallery`'
- en: '`catalog_product_entity_media_gallery`'
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`catalog_product_entity_media_gallery`'
- en: '`catalog_product_entity_tier_price`'
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`catalog_product_entity_tier_price`'
- en: Wait! How do we know which is the right table to query for our name attribute
    values? If you were paying attention, I already gave you the answer. Remember
    that the `eav_attribute` table had a column called `backend_type`?
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 等等！我们如何知道哪个是查询名称属性值的正确表？如果你注意到了，我已经给你答案了。记住，`eav_attribute` 表有一个名为 `backend_type`
    的列？
- en: 'Magento EAV stores each attribute on a different table based on the backend
    type of that attribute. If we want to confirm the backend type of our name attribute,
    we can do so by running the following code:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: Magento EAV根据属性的后端类型将每个属性存储在不同的表中。如果我们想确认我们名称属性的后端类型，我们可以通过运行以下代码来做到：
- en: '[PRE15]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'As a result, we should see that the backend type is varchar and that the values
    for this attribute are stored in the `catalog_product_entity_varchar` table. Let''s
    inspect this table:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们应该看到后端类型是 varchar，并且此属性的值存储在 `catalog_product_entity_varchar` 表中。让我们检查这个表：
- en: '![Retrieving the data](img/4172_02_07.jpg)'
  id: totrans-162
  prefs: []
  type: TYPE_IMG
  zh: '![检索数据](img/4172_02_07.jpg)'
- en: 'The `catalog_product_entity_varchar` table is formed by only 6 columns:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: '`catalog_product_entity_varchar` 表仅由 6 列组成：'
- en: '`value_id`: This is the attribute value unique identifier and primary key'
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`value_id`：这是属性值唯一标识符和主键'
- en: '`entity_type_id`: This is the entity type ID to which this value belongs'
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`entity_type_id`：这是此值所属的实体类型 ID'
- en: '`attribute_id`: This is the foreign key that relates the value to our `eav_entity`
    table'
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`attribute_id`：这是将值与我们的 `eav_entity` 表相关联的外键'
- en: '`store_id`: This is the foreign key matching an attribute value with a storeview'
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`store_id`：这是匹配商店视图的属性值的外键'
- en: '`entity_id`: This is the foreign key relating to the corresponding entity table,
    in this case, `catalog_product_entity`'
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`entity_id`：这是与相应实体表（在这种情况下为 `catalog_product_entity`）相关联的外键'
- en: '`value`: This is the actual value that we want to retrieve'
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`value`：这是我们想要检索的实际值'
- en: Tip
  id: totrans-170
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: Depending on the attribute configuration, we can have it as a global value,
    meaning, it applies across all store views or a value per storeview.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 根据属性配置，我们可以将其作为全局值，这意味着它适用于所有商店视图，或者每个商店视图一个值。
- en: 'Now that we finally have all the tables that we need to retrieve the product
    information, we can build our query:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们终于有了所有需要检索产品信息的表，我们可以构建我们的查询：
- en: '[PRE16]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '![Retrieving the data](img/4172_02_08.jpg)'
  id: totrans-174
  prefs: []
  type: TYPE_IMG
  zh: '![检索数据](img/4172_02_08.jpg)'
- en: From our query, we should see a result set with three columns, `product_id`,
    `product_name`, and `product_sku`. So let's step back for a second in order to
    get product names with SKUs with raw SQL. We had to write a five-line SQL query,
    and we only retrieved two values from our products, from one single EAV value
    table if we want to retrieve a numeric field such as price or a text-value-like
    product.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 从我们的查询中，我们应该看到一个包含三个列的结果集，`product_id`、`product_name` 和 `product_sku`。所以让我们退后一步，用原始
    SQL 获取带有 SKU 的产品名称。我们不得不写一个五行的 SQL 查询，如果我们想检索一个数值字段，如价格，或者一个类似产品的文本值，我们只从我们的产品中检索了两个值，从一个单一的
    EAV 值表中。
- en: If we didn't have an **ORM** in place, maintaining Magento would be almost impossible.
    Fortunately, we do have an ORM in place, and most likely, you will never need
    to deal with raw SQL to work with Magento.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们没有设置 **ORM**，维护 Magento 几乎是不可能的。幸运的是，我们确实有一个 ORM，而且你很可能永远不需要处理原始 SQL 来与
    Magento 一起工作。
- en: 'That said, let''s see how we can retrieve the same product information by using
    the Magento ORM:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 话虽如此，让我们看看如何使用 Magento ORM 获取相同的产品信息：
- en: 'Our first step is going to be to instantiate a product collection:'
  id: totrans-178
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们的第一步将是实例化一个产品集合：
- en: '[PRE17]'
  id: totrans-179
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Then we will specifically tell Magento to select the name attribute:'
  id: totrans-180
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们将特别告诉 Magento 选择名称属性：
- en: '[PRE18]'
  id: totrans-181
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Then, we will ask it to sort the collection by name:'
  id: totrans-182
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们将要求它按名称对集合进行排序：
- en: '[PRE19]'
  id: totrans-183
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Finally, we will tell Magento to load the collection:'
  id: totrans-184
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们将告诉 Magento 加载集合：
- en: '[PRE20]'
  id: totrans-185
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'The end result is a collection of all products in the store sorted by name.
    We can inspect the actual SQL query by running the following code:'
  id: totrans-186
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最终结果是按名称排序的商店中所有产品的集合。我们可以通过运行以下代码来检查实际的 SQL 查询：
- en: '[PRE21]'
  id: totrans-187
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: In just three lines of code, we are telling Magento to grab all the products
    in the store, to specifically select the name, and finally order the products
    by name.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 在仅仅三行代码中，我们告诉 Magento 捕获商店中的所有产品，特别选择名称，并最终按名称对产品进行排序。
- en: Tip
  id: totrans-189
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: The last line `$collection->getSelect()->__toString();` allows to see the actual
    query that Magento is executing in our behalf.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一条 `$collection->getSelect()->__toString();` 允许我们看到 Magento 代表我们执行的查询。
- en: 'The actual query being generated by Magento is as follows:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: Magento 实际生成的查询如下：
- en: '[PRE22]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: As we can see, the ORM and the EAV models are wonderful tools that not only
    put a lot of power and flexibility in the hands of the developers, but they also
    do it in a way that is comprehensive and easy to use.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，ORM 和 EAV 模型是出色的工具，它们不仅将大量权力和灵活性交到开发者手中，而且是以全面且易于使用的方式做到的。
- en: Working with Magento collections
  id: totrans-194
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 与 Magento 集合一起工作
- en: If you look back at the previous code example, you will notice that I'm not
    only instantiating a product model, but I'm also calling the `getCollection()`
    method. The `getCollection()` method is part of the `Mage_Core_Model_Abstract`
    class, meaning, every single model inside Magento can call this method.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你回顾之前的代码示例，你会注意到我不仅实例化了一个产品模型，而且还调用了 `getCollection()` 方法。`getCollection()`
    方法是 `Mage_Core_Model_Abstract` 类的一部分，这意味着 Magento 中的每个模型都可以调用此方法。
- en: Tip
  id: totrans-196
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: All collections inherit from `Varien_Data_Collection`.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 所有集合都继承自 `Varien_Data_Collection`。
- en: A Magento collection is basically a model that contains other models. So instead
    of using an array to hold a collection of products, we will use a product collection.
    Collections not only provide a convenient data structure to group models, they
    also provide special methods that we can use to manipulate and work with a collection
    of entities.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: Magento 集合基本上是一个包含其他模型的模型。因此，我们不会使用数组来保存产品集合，而是会使用产品集合。集合不仅提供了一个方便的数据结构来分组模型，还提供了我们可以用来操作和与实体集合一起工作的特殊方法。
- en: 'Some of the most useful collection methods are:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 一些最有用的集合方法包括：
- en: '`addAttributeToSelect`: To add an attribute to the entities in a collection;
    `*` can be used as a wildcard to add all the available attributes'
  id: totrans-200
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`addAttributeToSelect`：向集合中的实体添加属性；`*` 可以用作通配符以添加所有可用的属性'
- en: '`addFieldToFilter`: To add an attribute filter to a collection; this function
    is used on regular non-EAV models or to filter attributes that are part of the
    master product table like SKU'
  id: totrans-201
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`addFieldToFilter`：向集合添加属性过滤器；此函数用于常规非 EAV 模型或用于过滤主产品表（如 SKU）中的属性'
- en: '`addAttributeToFilter`: This method is used to filter a collection of EAV entities'
  id: totrans-202
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`addAttributeToFilter`：此方法用于过滤 EAV 实体的集合'
- en: '`addAttributeToSort`: This method is used to add an attribute to the sort order'
  id: totrans-203
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`addAttributeToSort`：此方法用于添加排序顺序的属性'
- en: '`addStoreFilter`: This method is used to add a store filter to the current
    collection. It might not be available on all object types'
  id: totrans-204
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`addStoreFilter`：此方法用于向当前集合添加商店过滤器。它可能不是所有对象类型都可用'
- en: '`addWebsiteFilter`: This method is used to add a website filter to a collection'
  id: totrans-205
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`addWebsiteFilter`：此方法用于向集合添加网站过滤器'
- en: '`addCategoryFilter`: This method is used to specify a category filter for a
    product collection'
  id: totrans-206
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`addCategoryFilter`：此方法用于为产品集合指定类别过滤器'
- en: '`addUrlRewrite`: This method is used to add URL rewrite data to the product
    collection'
  id: totrans-207
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`addUrlRewrite`：此方法用于向产品集合添加 URL 重写数据'
- en: '`setOrder`: This method is used to set the sorting order of a collection'
  id: totrans-208
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`setOrder`：此方法用于设置集合的排序顺序'
- en: These are just a few of the collection methods available. Each collection implements
    different unique methods depending on the entity type they correspond to. For
    example, the customer collection `Mage_Customer_Model_Resource_Customer_Collection`
    has a unique method called `groupByEmail()`, which, as the name correctly implies,
    groups the entities inside a collection by e-mail.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 这些只是可用的集合方法中的一小部分。每个集合根据它们对应的实体类型实现不同的独特方法。例如，客户集合 `Mage_Customer_Model_Resource_Customer_Collection`
    有一个名为 `groupByEmail()` 的独特方法，正如其名称正确暗示的那样，它根据电子邮件将集合内的实体分组。
- en: As with previous examples, we will continue working with the product models,
    and in this case, the product collection.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 与之前的示例一样，我们将继续使用商品模型，在这种情况下，是商品集合。
- en: '![Working with Magento collections](img/4172_02_09.jpg)'
  id: totrans-211
  prefs: []
  type: TYPE_IMG
  zh: '![使用 Magento 集合](img/4172_02_09.jpg)'
- en: 'In order to better illustrate how we can use the collection, will be working
    on the following common product scenarios:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更好地说明我们如何使用集合，我们将处理以下常见的商品场景：
- en: Get a product collection only from a specific category
  id: totrans-213
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 仅从特定类别获取商品集合
- en: Get new products since date *X*
  id: totrans-214
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 自从日期 *X* 获取新产品
- en: Get bestseller products
  id: totrans-215
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 获取畅销产品
- en: Filter product collections by visibility
  id: totrans-216
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过可见性过滤商品集合
- en: Filter products without image
  id: totrans-217
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 过滤不带图片的产品
- en: Add multiple sort orders
  id: totrans-218
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加多个排序顺序
- en: Get product collections only from a specific category
  id: totrans-219
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 仅从特定类别获取商品集合
- en: The first thing most developers try to do when starting with Magento is load
    a product collection with products only from a specific category. While I have
    seen many approaches by using `addCategoryFilter()` or `addAttributeToFilter()`,
    the reality is that for most cases, the approach is much simpler and a bit contra-intuitive
    to what we have learned so far.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数开发者开始使用 Magento 时尝试做的第一件事是加载一个只包含特定类别商品的商品集合。虽然我见过许多使用 `addCategoryFilter()`
    或 `addAttributeToFilter()` 的方法，但现实是，对于大多数情况，这种方法要简单得多，并且与我们迄今为止学到的有些相反。
- en: 'The easiest way of doing this is not getting a product collection first and
    then filtering by a category, but actually instantiating our target category and
    getting the product collection from there, let''s run the following code snippet
    on IMC:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 做这件事最简单的方法不是先获取一个商品集合，然后按类别过滤，而是实际上实例化我们的目标类别，并从那里获取商品集合，让我们在 IMC 上运行以下代码片段：
- en: '[PRE23]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'We can find the `getProductCollection()` method declaration inside the `Mage_Catalog_Model_Category`
    class. Let''s take a closer look at this method:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在 `Mage_Catalog_Model_Category` 类中找到 `getProductCollection()` 方法的声明。让我们更仔细地看看这个方法：
- en: '[PRE24]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: As we can see, the function does nothing more than instantiate Resource Model
    for the product collection, set the store to the current store ID, and pass the
    current category to the `addCategoryFilter()`.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，该函数所做的不仅仅是实例化产品集合的资源模型，将商店设置为当前商店 ID，并将当前类别传递给 `addCategoryFilter()`。
- en: This is one of those decisions that was taken to optimize Magento's performance
    and frankly, to simplify the life of the developers working with it, as in most
    cases, a category is going to be available one way or the other.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一种为了优化 Magento 的性能而做出的决定，坦白说，也是为了简化与它一起工作的开发者的生活，因为在大多数情况下，一个类别无论如何都是可用的。
- en: Get new products added since X date
  id: totrans-227
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 自从 X 日期添加的新产品
- en: 'So now that we know how to get a product collection from a specific category,
    let''s say we are able to apply filters to the resulting products and we only
    the retrieve the ones matching our conditions. In this particular case, we will
    request all products added after December 2012\. Following our previous example
    code, we can filter our collection by product creation date by running the following
    code on IMC:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们已经知道了如何从特定类别获取商品集合，比如说我们能够对结果商品应用过滤器，并且只检索符合我们条件的商品。在这种情况下，我们将请求自 2012 年
    12 月之后添加的所有商品。根据我们之前的示例代码，我们可以在 IMC 上通过运行以下代码来通过商品创建日期过滤我们的集合：
- en: '[PRE25]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'It''s that simple! We could even add any additional conditions and get the
    products added between two dates. Let''s say we only want to retrieve the products
    that were created in the month of December:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 简单到这种程度！我们甚至可以添加任何额外的条件，并获取在两个日期之间添加的产品。比如说我们只想检索在 12 月份创建的产品：
- en: '[PRE26]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Magento `addFieldToFilter` supports the following conditions:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: Magento 的 `addFieldToFilter` 支持以下条件：
- en: '| Attribute code | SQL condition |'
  id: totrans-233
  prefs: []
  type: TYPE_TB
  zh: '| 属性代码 | SQL 条件 |'
- en: '| --- | --- |'
  id: totrans-234
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `eq` | = |'
  id: totrans-235
  prefs: []
  type: TYPE_TB
  zh: '| `eq` | = |'
- en: '| `neq` | != |'
  id: totrans-236
  prefs: []
  type: TYPE_TB
  zh: '| `neq` | != |'
- en: '| `like` | LIKE |'
  id: totrans-237
  prefs: []
  type: TYPE_TB
  zh: '| `like` | LIKE |'
- en: '| `nlike` | NOT LIKE |'
  id: totrans-238
  prefs: []
  type: TYPE_TB
  zh: '| `nlike` | NOT LIKE |'
- en: '| `in` | IN () |'
  id: totrans-239
  prefs: []
  type: TYPE_TB
  zh: '| `in` | IN () |'
- en: '| `nin` | NOT IN () |'
  id: totrans-240
  prefs: []
  type: TYPE_TB
  zh: '| `nin` | NOT IN () |'
- en: '| `is` | IS |'
  id: totrans-241
  prefs: []
  type: TYPE_TB
  zh: '| `is` | IS |'
- en: '| `notnull` | NOT NULL |'
  id: totrans-242
  prefs: []
  type: TYPE_TB
  zh: '| `notnull` | NOT NULL |'
- en: '| `null` | NULL |'
  id: totrans-243
  prefs: []
  type: TYPE_TB
  zh: '| `null` | NULL |'
- en: '| `moreq` | >= |'
  id: totrans-244
  prefs: []
  type: TYPE_TB
  zh: '| `moreq` | >= |'
- en: '| `gt` | > |'
  id: totrans-245
  prefs: []
  type: TYPE_TB
  zh: '| `gt` | > |'
- en: '| `lt` | < |'
  id: totrans-246
  prefs: []
  type: TYPE_TB
  zh: '| `lt` | < |'
- en: '| `gteq` | >= |'
  id: totrans-247
  prefs: []
  type: TYPE_TB
  zh: '| `gteq` | >= |'
- en: '| `lteq` | <= |'
  id: totrans-248
  prefs: []
  type: TYPE_TB
  zh: '| `lteq` | <= |'
- en: We can try other types of filters. For example, let's use the following code
    on IMC after adding our creation date filter. So we can retrieve only visible
    products.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以尝试其他类型的过滤器。例如，在添加我们的创建日期过滤器后，让我们在 IMC 上使用以下代码。这样我们就可以检索仅可见的产品。
- en: '[PRE27]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'The visibility attribute is a special attribute used by products to control
    where products are shown. It has the following values:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 可见性属性是产品用来控制产品显示位置的特殊属性。它有以下值：
- en: '**Not visible individually**: This has a value of 1'
  id: totrans-252
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**不可单独显示**：这个值是 1'
- en: '**Catalog**: This has a value of 2'
  id: totrans-253
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**目录**：这个值是 2'
- en: '**Search**: This has a value of 3'
  id: totrans-254
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**搜索**：这个值是 3'
- en: '**Catalog and Search**: This has a value of 4'
  id: totrans-255
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**目录和搜索**：这个值是 4'
- en: Get bestseller products
  id: totrans-256
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 获取热销产品
- en: 'To try and get the bestseller products for a specific category, we will need
    to step up our game and join with the `sales_order` table. Retrieving bestseller
    products will come in handy later to create a special category or custom reporting.
    We can run the following code on IMC:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 为了尝试获取特定类别的热销产品，我们需要提高我们的游戏水平，并与 `sales_order` 表进行连接。检索热销产品将在创建特殊类别或自定义报告时非常有用。我们可以在
    IMC 上运行以下代码：
- en: '[PRE28]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Let's analyze what's happening on the third line of our snippet. `getSelect()`
    is a method inherited directly from `Varien_Data_Collection_Db`, which returns
    the variable where the select statement is stored. Additionally, collections provide
    methods to specify a join and a group without actually having to write any SQL.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们分析一下我们的代码片段的第三行发生了什么。`getSelect()` 是直接从 `Varien_Data_Collection_Db` 继承的方法，它返回存储选择语句的变量。此外，集合提供方法来指定连接和分组，而无需实际编写任何
    SQL。
- en: 'This is not the only way of adding a join to a collection. There is, in fact,
    another way of doing this by using the `joinField()` function which will result
    in a simpler query. Let''s rewrite our previous code to make use of this function:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 这不是向集合添加连接的唯一方法。实际上，还有另一种方法，即使用 `joinField()` 函数，这将导致查询更简单。让我们重写我们之前的代码以使用此函数：
- en: '[PRE29]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Filter the product collection by visibility
  id: totrans-262
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 通过可见性过滤产品集合
- en: 'This is extremely easy to do with the help of `addAttributeToFilter`. Magento
    products have a system attribute called visibility, which has four possible number
    values ranging from one to four. We are only interested in showing products that
    have a visibility of four, meaning they can be seen both in the search results
    and the catalog. Let''s run the following code in IMC:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 这在 `addAttributeToFilter` 的帮助下做起来非常简单。Magento 产品有一个名为可见性的系统属性，它有四个可能的数值，范围从一到四。我们只对显示可见性为四的产品感兴趣，这意味着它们可以在搜索结果和目录中看到。让我们在
    IMC 上运行以下代码：
- en: '[PRE30]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: If we change the visibility code, we can compare the different collection results.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们更改可见性代码，我们可以比较不同的集合结果。
- en: Filter products without images
  id: totrans-266
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 过滤无图片的产品
- en: 'Filtering products without images comes in handy when you are dealing with
    any third-party import system, which can at times be unreliable. As with everything
    we have done so far, product images are attributes of our product:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 当你处理任何第三方导入系统时，过滤无图片的产品非常有用，有时这些系统可能不可靠。与我们迄今为止所做的一切一样，产品图像是产品属性：
- en: '[PRE31]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'By adding that extra filter, we are requiring products to have a small image
    specified. By default, Magento has three product image types, thumbnail, `small_image`,
    and image. These three types are used on different parts of the application. We
    could even set up a stricter rule for products if we wanted to:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 通过添加那个额外的过滤器，我们要求产品必须指定一个小图像。默认情况下，Magento 有三种产品图像类型，缩略图、`small_image` 和图像。这三种类型在不同的应用程序部分中使用。如果我们想对产品设置更严格的规则，我们可以这样做：
- en: '[PRE32]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Only products that have all of three types of images will be included in our
    collection. Try experimenting by filter with the different image types.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 只有包含三种图像类型的产品将被包含在我们的集合中。通过使用不同的图像类型进行过滤尝试实验。
- en: Add multiple sort orders
  id: totrans-272
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 添加多个排序顺序
- en: 'Finally, let''s take our collection and sort it first by stock status and then
    by price from highest to lowest. In order to retrieve the stock status information,
    we will use a method unique to the stock status Resource Model called `addStockStatusToSelect()`,
    which will take care of generating the corresponding SQL for our collection query:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，让我们先按库存状态对集合进行排序，然后按价格从高到低排序。为了检索库存状态信息，我们将使用一个独特的库存状态资源模型方法 `addStockStatusToSelect()`，它将为我们的集合查询生成相应的
    SQL：
- en: '[PRE33]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Inside this query, Magento will sort products by the salable status, which is
    either true or false, and by price. The end result is where all the available
    products show in the order of first ordered, from most expensive to cheapest,
    and then the out-of-stock products will show from most expensive to cheapest.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个查询中，Magento 会根据可售状态（是或否）和价格对产品进行排序。最终结果是所有可用的产品按顺序显示，从最贵到最便宜，然后缺货产品将从最贵到最便宜显示。
- en: Experiment with different sort order combinations to see how Magento organizes
    and orders the product collections.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试不同的排序组合，看看 Magento 如何组织和排序产品集合。
- en: Using Direct SQL
  id: totrans-277
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用直接 SQL
- en: So far we have learned how Magento data models and ORM systems provide a clean
    and simple way to access, store, and manipulate our data. Before we jump right
    into this section and learn about the Magento database adapters and how to run
    raw SQL queries, I feel it is important that we understand why you should avoid
    using what you are about to learn in this section as much as possible.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经学习了如何使用 Magento 数据模型和 ORM 系统提供一种干净、简单的方式来访问、存储和操作我们的数据。在我们直接跳入这一节学习
    Magento 数据库适配器和如何运行原始 SQL 查询之前，我认为了解为什么你们应该尽可能避免使用本节将要学习的内容是非常重要的。
- en: Magento is an extremely **complex system**, and as we've also learned in the
    previous chapter, a framework driven in part by events. Just saving a product
    will trigger half a dozen different events, each doing a different task. This
    will not happen if you decide to just create a query and update a product directly.
    So, as developers, we must be extremely careful and be sure there is a justifiable
    reason to go outside the ORM.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: Magento 是一个非常**复杂的系统**，正如我们在上一章中学习到的，它部分由事件驱动的框架。仅仅保存一个产品就会触发半打不同的事件，每个事件都执行不同的任务。如果你决定只创建一个查询并直接更新产品，这种情况就不会发生。因此，作为开发者，我们必须非常小心，确保有合理的理由跳出
    ORM。
- en: That said, there are of course scenarios when being able to work with the database
    directly comes in extremely handy and is actually simpler than working with the
    Magento models. For example, when updating the product attribute globally or changing
    a product collection status, we could load a product collection and loop through
    each of the individual products, updating and saving them. While this will work
    fine on smaller collections, as soon we start growing and working with a larger
    dataset, our performance starts dropping and the script takes several seconds
    to execute.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 话虽如此，当然也有一些场景，直接与数据库交互会非常方便，实际上比使用 Magento 模型更简单。例如，当全局更新产品属性或更改产品集合状态时，我们可以加载一个产品集合，然后遍历每个单独的产品，更新并保存它们。虽然这在较小的集合上可以正常工作，但当我们开始增长并处理更大的数据集时，我们的性能开始下降，脚本执行需要几秒钟。
- en: On the other hand, a Direct SQL query will execute much faster (usually under
    one second) depending on the size of the dataset and the query being executed.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，直接 SQL 查询将根据数据集的大小和执行的查询速度非常快（通常在一秒以内）。
- en: Out-of-the-box Magento will take care of all the heavy lifting of having to
    establish a connection to the database by using the `Mage_Core_Model_Resource`
    model. Magento makes three types of connections available to us, `core_read`,
    `core_setup` and `core_write`. For now, we will only focus on `core_read` and
    `core_write`.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，Magento 会通过使用 `Mage_Core_Model_Resource` 模型来处理所有建立数据库连接的繁重工作。Magento 为我们提供了三种类型的连接，分别是
    `core_read`、`core_setup` 和 `core_write`。目前，我们将只关注 `core_read` 和 `core_write`。
- en: 'Let''s start by instantiating a Resource Model and two connections, one to
    read and the other to write:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先实例化一个资源模型和两个连接，一个用于读取，另一个用于写入：
- en: '[PRE34]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Even if we are working with Direct SQL queries, thanks to Magento, we don't
    have to worry about setting up the connection to the DB beyond instantiating a
    Resource Model and the proper type of connection.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 即使我们在处理直接 SQL 查询，也多亏了 Magento，我们不需要担心设置数据库连接，而只需实例化资源模型和适当的连接类型。
- en: Reading
  id: totrans-286
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 阅读
- en: 'Let''s test our read connection by executing the following code:'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过执行以下代码来测试我们的读取连接：
- en: '[PRE35]'
  id: totrans-288
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Although this query works and it will return all the products in the `catalog_product_entity`
    table, what will happen if we try to run this same code on a Magento installation
    that uses table prefixes? Or what if Magento suddenly changes the table name in
    the next upgrade? This code is not portable or easily maintainable. Fortunately,
    the Resource Model provides another handy method called `getTableName()`.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这个查询是有效的，并且它将返回 `catalog_product_entity` 表中的所有产品，但如果我们尝试在使用表前缀的 Magento 安装上运行相同的代码会发生什么？或者如果
    Magento 在下一次升级中突然更改表名，会发生什么？这段代码是不可移植的或难以维护的。幸运的是，资源模型提供了一个名为 `getTableName()`
    的便捷方法。
- en: 'The `getTableName()` method will take a factory name as a parameter, and based
    on the configuration established by the config.xml, it will not only find the
    right table, but will also verify if the table exists in the DB. Let''s update
    our code to use `getTableName()`:'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: '`getTableName()` 方法将接受一个工厂名称作为参数，并根据由 config.xml 建立的配置，它不仅会找到正确的表，还会验证该表是否存在于数据库中。让我们更新我们的代码以使用
    `getTableName()`：'
- en: '[PRE36]'
  id: totrans-291
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'We are also using the `fetchAll()` method that will return all the rows returned
    by our query as an array, but this is not the only available method. We also have
    `fetchCol()` and `fetchOne()` at our disposition:'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还使用了 `fetchAll()` 方法，该方法将返回查询返回的所有行作为数组，但这并不是唯一可用的方法。我们还有 `fetchCol()` 和 `fetchOne()`
    可用：
- en: '`fetchAll`: This retrieves all the rows returned by the original query.'
  id: totrans-293
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`fetchAll`：此方法检索原始查询返回的所有行。'
- en: '`fetchOne`: This returns only the values from the first database row returned
    by the query.'
  id: totrans-294
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`fetchOne`：此方法仅返回查询返回的第一数据库行的值。'
- en: '`fetchCol`: This returns all the columns returned by the query but only the
    first row. This is useful if you only want to retrieve a single column with unique
    identifiers such products IDs or SKUs.'
  id: totrans-295
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`fetchCol`：此方法返回查询返回的所有列，但仅限于第一行。如果你只想检索具有唯一标识符的单个列，如产品 ID 或 SKU，这很有用。'
- en: Writing
  id: totrans-296
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 写作
- en: As we mentioned before, saving a model in Magento, be it a product, category,
    customer, or anything else, can be relatively slow due to the amount of observers
    and events triggered in the backend.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们之前提到的，由于后端触发的观察者和事件数量，在 Magento 中保存模型（无论是产品、类别、客户还是其他任何东西），可能会相对较慢。
- en: 'However, if we are only looking to update simple static values, updating large
    collections can be a painfully slow process if done through the Magento ORM. Let''s
    say that, for example, we want to make all the products on the site out of stock.
    Instead of doing this through the Magento backend or creating a custom script
    that iterates through a collection of all the products, we can simply do as follows:'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果我们只想更新简单的静态值，如果通过 Magento ORM 进行更新，那么更新大量集合可能会非常缓慢。比如说，如果我们想将网站上所有产品的库存状态设置为无货。而不是通过
    Magento 后端或创建一个遍历所有产品集合的定制脚本，我们可以简单地这样做：
- en: '[PRE37]'
  id: totrans-299
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Summary
  id: totrans-300
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we have learned about Magento models, their inheritance and
    purpose, and how Magento uses resources and collections to implement its own ORM.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了 Magento 模型、它们的继承和目的，以及 Magento 如何使用资源和集合来实现其自己的 ORM。
- en: We also learned about EAV models and how they are structured to provide Magento
    with data flexibility and extensibility that both merchants and developers can
    take advantage of.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还了解了 EAV 模型及其结构，以及它们如何为 Magento 提供数据灵活性和可扩展性，让商家和开发者都能从中受益。
- en: Finally, we saw how developers can access the database directly by writing DirectSQL
    and using the Magento resource adapters.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们看到了开发者如何通过编写 DirectSQL 并使用 Magento 资源适配器直接访问数据库。
- en: The chapters so far have been more theory than practice. This has been done
    with the intention of guiding you through the complexity of Magento and providing
    you with the tools and knowledge that you require for the rest of the book. For
    the remaining chapters of the book, we will take a more hands-on approach and
    start building extensions, incrementally applying all the concepts we have learned
    so far.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止的章节更多地是理论而非实践。这样做是为了引导你通过 Magento 的复杂性，并为你提供本书剩余部分所需的工具和知识。对于本书的剩余章节，我们将采取更实际的方法，并开始构建扩展，逐步应用我们迄今为止学到的所有概念。
- en: Our next chapter is called *Frontend Development* where we will start getting
    our feet wet and develop our first Magento extension.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 我们下一章的标题是 *前端开发*，我们将开始涉足其中，并开发我们的第一个 Magento 扩展。
