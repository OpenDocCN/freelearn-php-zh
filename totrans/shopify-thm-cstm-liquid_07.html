<html><head></head><body><div id="sbo-rt-content"><div id="_idContainer064">
			<h1 id="_idParaDest-98"><em class="italic"><a id="_idTextAnchor097"/></em><a href="B17606_05_Final_PD_ePub.xhtml#_idTextAnchor097"><em class="italic">Chapter 5</em></a>: Diving into Liquid Core with Filters</h1>
			<p>In the previous two chapters, we learned about all the different Liquid tags and objects, and now, we will be focusing on the last of the Liquid Core features, which is <strong class="bold">filters</strong>. We have referenced filters on a few occasions now, but <em class="italic">what exactly is the purpose of filters?</em> Filters are methods denoted by a pipe character, <strong class="source-inline">|</strong>, through which we can manipulate different data types, including strings, numbers, variables, or even objects, making it a compelling feature. </p>
			<p>We can split the chapter into the following topics:</p>
			<ul>
				<li>HTML and URL filters</li>
				<li>Enhancing the product media gallery</li>
				<li>Building product accordions</li>
				<li>Math and money filters</li>
				<li>Exploring the additional filters</li>
			</ul>
			<p>By the time we complete this chapter, we will precisely understand how much power filters provide us. Similarly, as with the previous chapter, instead of simply listing and going through all of the filters, we will only explain some essential filters through a series of small projects.</p>
			<p>First, we will learn about generating HTML elements through <strong class="bold">HTML and URL filters</strong>. Second, understanding <strong class="bold">media filters</strong> will help us with the product media gallery, one of Shopify's latest additions and one of the most sought-after features. Third, by working on the product accordions project, we will learn how to manipulate the string and array types of data through their respective filters. Lastly, working on a product price discount project will provide us with the necessary knowledge of <strong class="bold">math and money filters</strong>.</p>
			<h1 id="_idParaDest-99"><a id="_idTextAnchor098"/>Technical requirements</h1>
			<p>While we will explain each topic and present it with accompanying screenshots, you will need an internet connection to follow the steps outlined in this chapter, considering that Shopify is a hosted service.</p>
			<p>The code for this chapter is available on GitHub: <a href="https://github.com/PacktPublishing/Shopify-Theme-Customization-with-Liquid/tree/main/Chapter05">https://github.com/PacktPublishing/Shopify-Theme-Customization-with-Liquid/tree/main/Chapter05</a>.</p>
			<p>The Code in Action video for the chapter can be found here: <a href="https://bit.ly/3zmum4j">https://bit.ly/3zmum4j</a></p>
			<h1 id="_idParaDest-100"><a id="_idTextAnchor099"/>Working with HTML and URL filters</h1>
			<p>In the previous chapter, we had the chance to see a type of URL filter when we worked on outputting <a id="_idIndexMarker342"/>the product images, <strong class="source-inline">{{ image | img_url: "400x400" }}</strong>. <em class="italic">However, what exactly are URL filters?</em></p>
			<p><strong class="bold">URL filters</strong> are methods <a id="_idIndexMarker343"/>that allow us to output a direct path to the assets on Shopify's <strong class="bold">Content Delivery Network</strong> (<strong class="bold">CDN</strong>). We can use URL filters in many ways. However, URL filters alone only provide a string path to the requested asset. Therefore, to find <a id="_idIndexMarker344"/>them helpful, we must pair them with HTML tags, such as the <strong class="source-inline">image</strong> tag, inside which we can add the string path to a specific asset as the <strong class="source-inline">href</strong> attribute. Alternatively, we can combine URL filters with <strong class="bold">HTML filters</strong> to automatically <a id="_idIndexMarker345"/>generate the necessary HTML element <a id="_idIndexMarker346"/>with the necessary attributes. Let's see them in action now.</p>
			<p>In <a href="B17606_01_Final_PD_ePub.xhtml#_idTextAnchor015"><em class="italic">Chapter 1</em></a>, <em class="italic">Getting Started with Shopify</em>, we learned about the <strong class="source-inline">Assets</strong> directory inside our theme files and how it contains all of the internal assets that our theme requires, such as stylesheets, JavaScript files, font files, and images. However, we will first need to load these files within our theme, by following the next steps, since they will not automatically be accessible to us by simply uploading them within the <strong class="source-inline">Assets</strong> directory:</p>
			<ol>
				<li>We can retrieve the path to a file within the <strong class="source-inline">Assets</strong> directory by encapsulating the file's name within quotation marks, followed by a pipeline, followed by the <strong class="source-inline">asset_url</strong> filter:<p class="source-code">{{ "theme.css" | asset_url }}</p></li>
				<li>In the previous example, we have used the name of the stylesheet file within our store in combination with <strong class="source-inline">asset_url</strong>, which will provide us with the string path toward this specific file: <a href="https://cdn.shopify.com/s/files/1/0559/0089/7434/t/4/assets/theme.css?v=10188701410004355449">https://cdn.shopify.com/s/files/1/0559/0089/7434/t/4/assets/theme.css?v=10188701410004355449</a></li>
				<li>Now that we have recovered the path toward our location, as previously mentioned, we have two choices. The first option is to use an HTML <strong class="source-inline">link</strong> tag to link the CSS file with our theme:<p class="source-code">&lt;link rel="stylesheet" href="<strong class="bold">{{ "theme.css" | asset_url }}</strong>"&gt;</p><p>Our theme <a id="_idIndexMarker347"/>will now have full access to the <strong class="source-inline">theme.css</strong> file and its rules with the <strong class="source-inline">link</strong> tag in place:</p><p class="source-code">&lt;link rel="stylesheet" href="//cdn.shopify.com/s/files/1/0559/0089/7434/t/4/assets/theme.css?v=10188701410004355449"&gt;</p></li>
				<li>However, as we <a id="_idIndexMarker348"/>have previously mentioned, besides using the HTML <strong class="source-inline">link</strong> tag, we can also combine URL filters with an HTML filter to generate the necessary HTML attributes:<p class="source-code">{{ "theme.css" | asset_url | <strong class="bold">stylesheet_tag</strong> }}</p></li>
			</ol>
			<p>In the previous example, we used the asset name whose path we are looking to recover, followed by the <strong class="source-inline">asset_url</strong> filter, which would usually only return the string path. However, pairing it with <strong class="source-inline">stylesheet_tag</strong> will automatically generate the HTML <strong class="source-inline">link</strong> tag with all the necessary attributes:</p>
			<p class="source-code">&lt;link href="//cdn.shopify.com/s/files/1/0559/0089/7434/t/4/assets/theme.css?v=10188701410004355449" rel="stylesheet" type="text/css" media="all"&gt;</p>
			<p>Besides being a lot cleaner, the main difference between the two approaches is that <strong class="source-inline">stylesheet_tag</strong> does not accept additional parameters. So, for example, if we were looking to change the <strong class="source-inline">rel</strong> attribute to preload, modify the <strong class="source-inline">media</strong> attribute, or even include the <strong class="source-inline">defer</strong> attribute, we would have to use the first approach and include the asset file using the HTML <strong class="source-inline">link</strong> tag.</p>
			<p>We have now learned how to connect our theme file with the necessary stylesheet. However, note that we will be using a different type of HTML filter depending on which file we are looking to access.</p>
			<p>For example, if we <a id="_idIndexMarker349"/>were looking to output the content of the <strong class="source-inline">theme.js</strong> file into <a id="_idIndexMarker350"/>our theme, we would use a similar approach, the theme filename followed by <strong class="source-inline">asset_url</strong> to get its path, but instead of using <strong class="source-inline">stylesheet_tag</strong>, we will use <strong class="source-inline">script_tag</strong>:</p>
			<p class="source-code">{{ "theme.js" | asset_url | <strong class="bold">script_tag</strong> }}</p>
			<p>Using <strong class="source-inline">script_tag</strong>, we will automatically generate and include the HTML <strong class="source-inline">script</strong> tag in our theme. However, do note that similarly as with <strong class="source-inline">stylesheet_tag</strong>, <strong class="source-inline">script_tag</strong> also does not accept any parameters:</p>
			<p class="source-code">&lt;script src="//cdn.shopify.com/s/files/1/0559/0089/7434 /t/4/assets/theme.js?v=2017768116492187958" type="text/javascript"&gt;&lt;/script&gt;</p>
			<p>Besides <strong class="source-inline">stylesheet_tag</strong> and <strong class="source-inline">script_tag</strong>, we also have access to <strong class="source-inline">img_tag</strong>. Accessing an image file within the assets can be done using the name of the image file, followed by <strong class="source-inline">asset_url</strong>, followed by <strong class="source-inline">img_tag</strong>:</p>
			<p class="source-code">{{ "ajax-loader.gif" | asset_url | img_tag }}</p>
			<p>The crucial difference between <strong class="source-inline">img_tag</strong> and the previous two filters is that <strong class="source-inline">img_tag</strong> does accept additional parameters.</p>
			<p>In <a href="B17606_04_Final_PD_ePub.xhtml#_idTextAnchor079"><em class="italic">Chapter 4</em></a>, <em class="italic">Diving into Liquid Core with Objects</em>, we had the chance to see the <strong class="source-inline">img_url</strong> filter in action by using it to return the product image URL string, which we combined with the HTML <strong class="source-inline">img</strong> tag to output the product image to our storefront:</p>
			<p class="source-code">&lt;img src="{{ product | img_url: "300x300" }}"/&gt;</p>
			<p>Notice that besides the <strong class="source-inline">img_url</strong> filter, we have also used the <strong class="source-inline">size</strong> parameter to set the limit size of our image, which is one of the three parameters that we can use with the <strong class="source-inline">img_url</strong> and <strong class="source-inline">img_tag</strong> filters. However, note that both types of filters use different parameters, which we will explain shortly through the following mini project.</p>
			<h2 id="_idParaDest-101"><a id="_idTextAnchor100"/>Building a product gallery</h2>
			<p>Inside this <a id="_idIndexMarker351"/>mini project, we will learn how to <a id="_idIndexMarker352"/>output the necessary elements for the product gallery:</p>
			<ol>
				<li value="1">Let's start by creating a new page named <strong class="source-inline">Product Gallery</strong> and a new page template named <strong class="source-inline">product-gallery</strong>, which we will assign to the previously created page.</li>
				<li>Once we have created the page and assigned the appropriate template, we should identify one product with more than one image and recover its handle. We will use gardening gloves for our selection, which is one of the products that we previously imported from the <strong class="source-inline">product-data.csv</strong> file in <a href="B17606_03_Final_PD_ePub.xhtml#_idTextAnchor047"><em class="italic">Chapter 3</em></a>, <em class="italic">Diving into Liquid Core with Tags</em>. We can retrieve the product handle by previewing the product page and copying the page handle from the page URL. Alternatively, we can retrieve it by navigating to the product page inside the admin section and copying the page handle from the page URL link at the bottom of the page.</li>
				<li>Now that we have recovered the product handle, let's start by creating a product object through its handle and assigning it to a variable. To achieve this, we can use the previously learned method of accessing the page object through its handle. However, compared to the previous chapters, where we learned how to access the product object through its collection, accessing the product object directly using its handle is slightly different.<p>Instead of pluralizing the product object name, we will be using a global object tag named <strong class="source-inline">all_products</strong>, which gives us access to all products in our store.</p><p class="callout-heading">Important note:</p><p class="callout">While <strong class="source-inline">all_products</strong> is quite a practical method that allows us to access any product directly through its handle, it comes with a limitation that we can only run it 20 times per page. This means that if we need to recover more than 20 specific products on a single page, we will need to recover them by looping over a collection.</p></li>
				<li>We can access the product object through its handle by using the <strong class="source-inline">all_products</strong> global object, followed by the handle of the product we are trying to access. For our example, we will be using square brackets, <strong class="source-inline">[]</strong>. However, we could have also used the dot (<strong class="source-inline">.</strong>) annotation:<p class="source-code">{% assign product_object = <strong class="bold">all_products["gardening-  gloves"]</strong> %}</p></li>
				<li>With this, we now have access to the gardening gloves product object. To access all images attached to a product, we will use the <strong class="source-inline">product_object</strong> variable as our object, followed by the <strong class="source-inline">images</strong> attribute, to recover the array of images for the specific product. Since we are dealing with an array, we will have to use the <strong class="source-inline">for</strong> tag to loop over them:<p class="source-code">{% assign product_object = all_products["gardening-  gloves"] %}</p><p class="source-code">{% for image_item in <strong class="bold">product_object.images</strong> %}</p><p class="source-code">  &lt;img src="{{ image_item | img_url }}"/&gt;</p><p class="source-code">{% endfor %}</p></li>
			</ol>
			<p>We have now successfully extracted an array of product images, which we can use to create powerful <a id="_idIndexMarker353"/>galleries using various slider plugins. However, notice that the size of the images we have on our storefront is relatively small.</p>
			<p>This is <a id="_idIndexMarker354"/>because Liquid always defaults to a size of <strong class="source-inline">100x100</strong> if we do not introduce the <strong class="source-inline">size</strong> parameter. Let's introduce the <strong class="source-inline">size</strong> parameter by limiting the image dimension to 300 px in width and 300 px in height:</p>
			<p class="source-code">{% assign product_object = all_products["gardening-gloves"] %}</p>
			<p class="source-code">{% for image_item in product_object.images %}</p>
			<p class="source-code">  &lt;img src="{{ image_item | img_url<strong class="bold">: "300x300" </strong>}}"/&gt;</p>
			<p class="source-code">{% endfor %}</p>
			<p>Notice that our images now have 300 px in width but only 200 px in height even though we have specified that we would like 300 px in height. This is because the <strong class="source-inline">size</strong> parameter can only limit the image size by decreasing its size to match the assigned values. It cannot change the image aspect, nor can it increase the size of the image beyond the original image size. </p>
			<p>In the previous example, we have used <strong class="source-inline">"300x300"</strong> to limit our product images in both width and height. However, we can also limit only one side by using <strong class="source-inline">"300x"</strong> to set the image width to 300 px or <strong class="source-inline">"x300"</strong> to limit the height to 300 px. If we only specify one of the two values, Shopify will automatically calculate the dimension of the image while maintaining the image aspect.</p>
			<p>The second <a id="_idIndexMarker355"/>parameter we can use with the <strong class="source-inline">img_url</strong> filter is the <strong class="source-inline">crop</strong> parameter, which allows us to crop the image to the specified <a id="_idIndexMarker356"/>size when combined with the <strong class="source-inline">size</strong> parameter. The <strong class="source-inline">crop</strong> parameter can have five different values:</p>
			<ul>
				<li><strong class="source-inline">top</strong></li>
				<li><strong class="source-inline">center</strong></li>
				<li><strong class="source-inline">bottom</strong></li>
				<li><strong class="source-inline">left</strong></li>
				<li><strong class="source-inline">right</strong></li>
			</ul>
			<p>Using the correct option, we can specify which side of the image we would like to crop out. For our example, we can use the <strong class="source-inline">center</strong> option to ensure that the image is cropped equally from each side:</p>
			<p class="source-code">{% assign product_object = all_products["gardening-gloves"] %}</p>
			<p class="source-code">{% for image_item in product_object.images %}</p>
			<p class="source-code">  &lt;img src="{{ image_item | img_url: "300x300"<strong class="bold">, crop:     "center" </strong>}}"/&gt;</p>
			<p class="source-code">{% endfor %}</p>
			<p>By changing the image size using the <strong class="source-inline">crop</strong> parameter, we have also changed the image's aspect, as all the images are now exactly 300 px in width and 300 px in height. </p>
			<p>The last two parameters that we can use with the <strong class="source-inline">img_url</strong> filter are <strong class="source-inline">scale</strong>, which allows us to specify the pixel density of the image using the <strong class="source-inline">2</strong> and <strong class="source-inline">3</strong> as its option values, and <strong class="source-inline">format</strong>, which is a quite interesting parameter that allows us to specify the format of the displayed image. The two acceptable values for the <strong class="source-inline">format</strong> parameter are <strong class="source-inline">jpg</strong> and <strong class="source-inline">pjpg</strong>.</p>
			<p>Using <strong class="source-inline">pjpg</strong>, we can <a id="_idIndexMarker357"/>convert the image format to <strong class="bold">Progressive JPEG</strong>, automatically loading a full-size image and increasing its quality gradually instead of loading the image from top to bottom like a traditional JPEG (we can read more about the Progressive JPEG at the following link: <a href="https://en.wikipedia.org/wiki/JPEG#JPEG_compression">https://en.wikipedia.org/wiki/JPEG#JPEG_compression</a>):</p>
			<p class="source-code">{% assign product_object = all_products["gardening-gloves"] %}</p>
			<p class="source-code">{% for image_item in product_object.images %}</p>
			<p class="source-code">  &lt;img src="{{ image_item | img_url: "300x300", crop:     "center"<strong class="bold">, format: "pjpg" </strong>}}"/&gt;</p>
			<p class="source-code">{% endfor %}</p>
			<p>Now that we <a id="_idIndexMarker358"/>have familiarized ourselves with the <a id="_idIndexMarker359"/>parameters that are accessible using the <strong class="source-inline">img_url</strong> filter, it is time to learn more about the parameters available with the <strong class="source-inline">img_tag</strong> filter. Let's start by modifying our last example to use <strong class="source-inline">img_tag</strong> to generate the HTML tag:</p>
			<p class="source-code">{% assign product_object = all_products["gardening-gloves"] %}</p>
			<p class="source-code">{% for image_item in product_object.images %}</p>
			<p class="source-code">  <strong class="bold">{{ image_item | img_tag }}</strong></p>
			<p class="source-code">{% endfor %}</p>
			<p>Note that when we first mentioned <strong class="source-inline">img_tag</strong>, we used it in combination with <strong class="source-inline">asset_url</strong> to recover the URL string of the image location inside the <strong class="source-inline">Assets</strong> directory. However, since we are not accessing the <strong class="source-inline">Assets</strong> directory but the product images, whose array of URL strings we already have from using <strong class="source-inline">product_object.images</strong>, we do not need to use any additional filters besides <strong class="source-inline">img_tag</strong>. </p>
			<p>By reviewing the results, we can see that we have successfully created the HTML <strong class="source-inline">img</strong> tag for each image within the image array. Since we haven't declared the image size, Shopify has by default resized our images to <strong class="source-inline">100x100</strong>.</p>
			<p><strong class="source-inline">img_tag</strong> accepts only three parameters. Contrary to <strong class="source-inline">img_url</strong>, where we can apply only the parameter we need, for <strong class="source-inline">img_tag</strong>, we need to apply all parameters in a specific order. This means that we would first have to use the other parameters if we would like to use the <strong class="source-inline">class</strong> and <strong class="source-inline">alt</strong> tag parameters.</p>
			<p>Since we need to add all parameters in a specific order, the parameters require no representation. We only need to assign their values. The first value is alt text, inside of which we can use a fixed string value or a Liquid value, such as <strong class="source-inline">image_item.alt</strong>, to recover the actual <a id="_idIndexMarker360"/>image alt text. The second parameter <a id="_idIndexMarker361"/>we can use to assign specific classes to each image tag, while only in the third parameter can we assign the size value:</p>
			<p class="source-code">{% assign product_object = all_products["gardening-gloves"] %}</p>
			<p class="source-code">{% for image_item in product_object.images %}</p>
			<p class="source-code">  {{ image_item | img_tag<strong class="bold">: image_item.alt, "class1 class2",     </strong><strong class="bold">"300x300"</strong> }}</p>
			<p class="source-code">{% endfor %}</p>
			<p>As we have had the chance to see, both the <strong class="source-inline">image_url</strong> and <strong class="source-inline">img_tag</strong> filters have their helpful parameters, and while <strong class="source-inline">img_tag</strong> is cleaner, it has limitations as we are limited in the number of attributes we can include in the generated HTML <strong class="source-inline">img</strong> tag.</p>
			<p>Suppose we were looking to extract an image file from the <strong class="source-inline">Assets</strong> directory with the appropriate <strong class="source-inline">size</strong> parameter applied to apply it as a background image. We cannot use <strong class="source-inline">img_tag</strong>, as previously mentioned, as that would return an HTML <strong class="source-inline">img</strong> tag. We also cannot use <strong class="source-inline">asset_url</strong> alone, as <strong class="source-inline">asset_url</strong> does not accept any additional parameters, including the <strong class="source-inline">size</strong> parameter.</p>
			<p>Similarly, as with <strong class="source-inline">stylesheet_tag</strong> and <strong class="source-inline">script_tag</strong>, we have access to the special <strong class="source-inline">asset_img_url</strong> filter, which allows us to include the <strong class="source-inline">size</strong> parameter to recover the images from the <strong class="source-inline">Assets</strong> directory:</p>
			<p class="source-code">{{ "ajax-loader.gif" | asset_img_url: "300x300", scale: 2,   crop: "center" }}</p>
			<p>Note that <strong class="source-inline">asset_img_url</strong> allows us to include the <strong class="source-inline">size</strong> parameter and other parameters previously available with the <strong class="source-inline">img_url</strong> filter, including <strong class="source-inline">size</strong>, <strong class="source-inline">crop</strong>, <strong class="source-inline">scale</strong>, and <strong class="source-inline">format</strong>.</p>
			<p>So far, we have learned how to access different types of files within the <strong class="source-inline">Assets</strong> directory and generate the appropriate HTML tag for each of them. We have also learned how to work with the <strong class="source-inline">img_url</strong> filter by working through a small project of outputting the <a id="_idIndexMarker362"/>necessary elements to create a <a id="_idIndexMarker363"/>basic product gallery. While we have not gone over all of the URL and HTML filters that Liquid offers, we have now set the proper groundwork for working with HTML and URL filters, knowledge of which is essential in Liquid and will be of great help to our future work.</p>
			<p class="callout-heading">Tip:</p>
			<p class="callout">For additional <a id="_idIndexMarker364"/>information on all the available HTML filters, we can refer to <a href="https://shopify.dev/docs/themes/liquid/reference/filters/html-filters">https://shopify.dev/docs/themes/liquid/reference/filters/html-filters</a>, and for additional <a id="_idIndexMarker365"/>information on the available URL filters, we can refer to <a href="https://shopify.dev/docs/themes/liquid/reference/filters/html-filters">https://shopify.dev/docs/themes/liquid/reference/filters/url-filters</a>.</p>
			<h1 id="_idParaDest-102"><a id="_idTextAnchor101"/>Enhancing the product media gallery</h1>
			<p>In the previous exercise, we learned how to output the image elements needed to output the <a id="_idIndexMarker366"/>necessary elements to create a basic product gallery that contains only images. In the following project, we will learn how to use media objects and filters to create a multifunctional gallery that will support images, 3D models, and internal videos hosted on Shopify. Additionally, we will also embed external video links to some of the most popular video platforms, Vimeo and YouTube, and autogenerate the appropriate video player for both.</p>
			<p>Most of the newest themes today already contain a product media gallery. However, many stores still use outdated theme files, so it is essential to know how to create the feature from scratch.</p>
			<p>Let's start by navigating to the <strong class="source-inline">Product Gallery</strong> page we created in the previous <em class="italic">Building a product gallery</em> subsection, located under the <em class="italic">Working with HTML and URL filters</em> section, and revise the previously included code to accept additional media types besides images:</p>
			<p class="source-code">{% assign product_object = all_products["gardening-gloves"] %}</p>
			<p class="source-code">{% for image_item in product_object.images %}</p>
			<p class="source-code">  {{ image_item | img_tag: image_item.alt, "class1 class2",     "300x300" }}</p>
			<p class="source-code">{% endfor %}</p>
			<p>Initially, we have used the <strong class="source-inline">product_object</strong> variable to capture the product object of the gardening gloves product, after which we have used a <strong class="source-inline">for</strong> tag to loop over the array of images received from <strong class="source-inline">product_object.images</strong>. Considering that we are dealing with <a id="_idIndexMarker367"/>various media types, we will need to use a <strong class="source-inline">media</strong> attribute to recover the media array and replace the <strong class="source-inline">image_item</strong> variable with <strong class="source-inline">media</strong> to keep everything cohesive:</p>
			<p class="source-code">{% assign product_object = all_products["gardening-gloves"] %}</p>
			<p class="source-code">{% for <strong class="bold">media</strong> in product_object.<strong class="bold">media</strong> %}</p>
			<p class="source-code">  {{ <strong class="bold">media</strong> | img_tag: <strong class="bold">media</strong>.alt, "class1 class2", "300x300" }}</p>
			<p class="source-code">{% endfor %}</p>
			<p>Using the <strong class="source-inline">media</strong> attribute, we have now recovered an array of all the different media objects, which can contain the following media types:</p>
			<ul>
				<li><strong class="source-inline">image</strong></li>
				<li><strong class="source-inline">external_video</strong></li>
				<li><strong class="source-inline">video</strong></li>
				<li><strong class="source-inline">model</strong></li>
			</ul>
			<p>However, having an array of media types also means that we now have a mixed array of objects, so we need to filter them out before anything.</p>
			<p>We will use the <strong class="source-inline">case/when</strong> tags combined with the <strong class="source-inline">media_type</strong> attribute, a part of the media object that will allow us to create a <strong class="source-inline">switch</strong> statement to recover an array of all media of a specific type. We can remind ourselves of <strong class="source-inline">case/when</strong> tags by visiting the <em class="italic">Controlling the flow of Liquid</em> section, which we can find in <a href="B17606_03_Final_PD_ePub.xhtml#_idTextAnchor047"><em class="italic">Chapter 3</em></a>, <em class="italic">Diving into Liquid Core with Tags</em>.</p>
			<p>Let's create a <strong class="source-inline">case</strong> tag to filter out <strong class="source-inline">media_type</strong> and write a <strong class="source-inline">switch</strong> statement for each media type:</p>
			<p class="source-code">{% assign product_object = all_products["gardening-gloves"] %}</p>
			<p class="source-code">{% for media in product_object.media %}</p>
			<p class="source-code">  <strong class="bold">{% case media.media_type %}</strong></p>
			<p class="source-code">    <strong class="bold">{% when "image" %}</strong></p>
			<p class="source-code">    <strong class="bold">{% when "external_video" %}</strong></p>
			<p class="source-code">    <strong class="bold">{% when "video" %}</strong></p>
			<p class="source-code">    <strong class="bold">{% when "model" %}</strong></p>
			<p class="source-code">    <strong class="bold">{% else %}</strong></p>
			<p class="source-code">  <strong class="bold">{% endcase %}</strong></p>
			<p class="source-code">  {{ media | img_tag: media.alt, "class1 class2", "300x300" }}</p>
			<p class="source-code">{% endfor %}</p>
			<p>With the <strong class="source-inline">case/when</strong> tags in place, we have successfully filtered out the media types and have <a id="_idIndexMarker368"/>gained access to each media type object we will need to output the media tags.</p>
			<p>If we look at our code, we will notice that the code we have previously used to output the images in our previous example is still there. Since we now have access to the <strong class="source-inline">image</strong> object within the first <strong class="source-inline">switch</strong> statement, we can simply reposition the code inside, which will be the first step in outputting the image media files:</p>
			<p class="source-code">{% assign product_object = all_products["gardening-gloves"] %}</p>
			<p class="source-code">{% for media in product_object.media %}</p>
			<p class="source-code">  {% case media.media_type %}</p>
			<p class="source-code">    {% when "image" %}</p>
			<p class="source-code">      <strong class="bold">{{ media | img_tag: media.alt, "class1 class2", </strong>            <strong class="bold">"300x300" }}</strong></p>
			<p class="source-code">    {% when "external_video" %}</p>
			<p class="source-code">    {% when "video" %}</p>
			<p class="source-code">    {% when "model" %}</p>
			<p class="source-code">    {% else %}</p>
			<p class="source-code">  {% endcase %}</p>
			<p class="source-code">{% endfor %}</p>
			<p>With <strong class="source-inline">img_tag</strong> in place, we have now successfully outputted all the image files for our product. However, we still lack tags for other media types. So, let's proceed with the external video.</p>
			<p>The <strong class="source-inline">external_video</strong> object provides us with information about Vimeo or YouTube videos associated <a id="_idIndexMarker369"/>with a specific product. Similarly, as with image objects, to output the <strong class="source-inline">external_video</strong> media types, we will need to use <strong class="source-inline">external_video_tag</strong> to generate the necessary <strong class="source-inline">iframe</strong> element, whether for Vimeo or YouTube:</p>
			<p class="source-code">{% assign product_object = all_products["gardening-gloves"] %}</p>
			<p class="source-code">{% for media in product_object.media %}</p>
			<p class="source-code">  {% case media.media_type %}</p>
			<p class="source-code">    {% when "image" %}</p>
			<p class="source-code">      {{ media | img_tag: media.alt, "class1 class2",             "300x300"}}</p>
			<p class="source-code">    {% when "external_video" %}</p>
			<p class="source-code">      <strong class="bold">{{ media | external_video_tag }}</strong></p>
			<p class="source-code">    {% when "video" %}</p>
			<p class="source-code">    {% when "model" %}</p>
			<p class="source-code">    {% else %}</p>
			<p class="source-code">  {% endcase %}</p>
			<p class="source-code">{% endfor %}</p>
			<p>With <strong class="source-inline">external_video_tag</strong> in place, we will automatically generate an iframe with all the necessary <a id="_idIndexMarker370"/>attributes for each <strong class="source-inline">external_video</strong> media type, so let's give it a quick test:</p>
			<ol>
				<li value="1">To test out whether <strong class="source-inline">external_video_tag</strong> works, we will first need to include either a Vimeo or YouTube video on our product page media. </li>
				<li>We will need to click on the <strong class="bold">Products</strong> section in our admin sidebar and navigate to the product whose media files we are currently viewing to do this. In our case, that product is gardening gloves.</li>
				<li>After opening the specific product page, we will need to scroll down to the <strong class="bold">Media</strong> section, where in the top-right corner, we will find a drop-down link named <strong class="bold">Add media from URL</strong>, which we should click to reveal the drop-down options. Inside the dropdown, we will find two options, the first one allowing us to add an external image to our product, and the second one allowing us to embed either a Vimeo or YouTube video.<div id="_idContainer056" class="IMG---Figure"><img src="Images/Figure_5.01_B17606.jpg" alt="Figure 5.1 – Example of embedding external assets to a product media&#13;&#10;" width="757" height="386"/></div><p class="figure-caption">Figure 5.1 – Example of embedding external assets to a product media</p></li>
				<li>We should proceed by clicking on <strong class="bold">Embed video</strong>, which will trigger a popup where we <a id="_idIndexMarker371"/>can include the URL of either a Vimeo or YouTube video. After pasting the link, click on the <strong class="bold">Embed video</strong> button to complete the process. After a few seconds of processing, the media video will be visible in the <strong class="bold">Media</strong> section.</li>
			</ol>
			<div>
				<div id="_idContainer057" class="IMG---Figure">
					<img src="Images/Figure_5.02_B17606.jpg" alt="Figure 5.2 – Example of various media files on the product admin page&#13;&#10;" width="551" height="338"/>
				</div>
			</div>
			<p class="figure-caption">Figure 5.2 – Example of various media files on the product admin page</p>
			<p>With the video now successfully loaded within the product media assets, all that is left is to test whether <strong class="source-inline">external_video_tag</strong> works well.</p>
			<p>By clicking on the media video asset, we will trigger a popup with a preview on one side and the option to include alt text on the other. Additionally, in the top-right corner, we can see three icons. The first one is a trash icon, which will allow us to delete the specific media. The middle icon, represented by three dots, when clicked will reveal a drop-down menu with the <strong class="bold">Replace thumbnail</strong> option.</p>
			<p>Clicking this option will allow us to upload a thumbnail visible as a poster image for the iframe video <a id="_idIndexMarker372"/>and avoid having the first frame of the video as a poster. Note that the icon represented with three dots is only visible on video assets and will not be visible on regular image assets.</p>
			<div>
				<div id="_idContainer058" class="IMG---Figure">
					<img src="Images/Figure_5.03_B17606.jpg" alt="Figure 5.3 – Example of video media asset pop-up tools&#13;&#10;" width="563" height="310"/>
				</div>
			</div>
			<p class="figure-caption">Figure 5.3 – Example of video media asset pop-up tools</p>
			<p>Previewing the <strong class="bold">Product Gallery</strong> page shows us that we have correctly generated the iframe video with all the necessary attributes. First, however, let's look closely at all the attributes included with the <strong class="source-inline">iframe</strong> element:</p>
			<p class="source-code">&lt;iframe frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen="allowfullscreen" src="https://www.youtube.com/embed/neFK-pv2sKY?controls=1&amp;amp;enablejsapi=1&amp;amp;modestbranding=1&amp;amp;origin=https%3A%2F%2Flearn-liquid-with-packt.myshopify.com&amp;amp;playsinline=1&amp;amp;rel=0" title="Gardening Gloves"&gt;&lt;/iframe&gt;</p>
			<p>As we can see, by default, there are many attributes included in our YouTube video embedding, such as visible controls and branding. <em class="italic">But what if we wanted to modify those attributes or include some new ones?</em></p>
			<p>To modify existing external video attributes or include new ones, we will need to introduce a <a id="_idIndexMarker373"/>new media filter, <strong class="source-inline">external_video_url</strong>. By including the <strong class="source-inline">external_video_url</strong> filter, in combination with <strong class="source-inline">external_video_tag</strong>, we will be able to modify any attribute of the YouTube embedding:</p>
			<p class="source-code">{% assign product_object = all_products["gardening-gloves"] %}</p>
			<p class="source-code">{% for media in product_object.media %}</p>
			<p class="source-code">  {% case media.media_type %}</p>
			<p class="source-code">    {% when "image" %}</p>
			<p class="source-code">      {{ media | img_tag: media.alt, "class1 class2",             "300x300" }}</p>
			<p class="source-code">    {% when "external_video" %}</p>
			<p class="source-code">      {{ media <strong class="bold">| external_video_url: controls: 0, color: </strong>            <strong class="bold">"white"</strong> | external_video_tag }}</p>
			<p class="source-code">    {% when "video" %}</p>
			<p class="source-code">    {% when "model" %}</p>
			<p class="source-code">    {% else %}</p>
			<p class="source-code">  {% endcase %}</p>
			<p class="source-code">{% endfor %}</p>
			<p>As we can see, we can include any number of attributes from the official YouTube documentation. While helpful for YouTube video embeddings, the attributes we have included will not help us when dealing with Vimeo videos, considering that Vimeo uses different attributes based on its own documentation.</p>
			<p>In order to differentiate which embedding link belongs to YouTube and which belongs to Vimeo, we will need to introduce the <strong class="source-inline">host</strong> attribute through the <strong class="source-inline">external_video</strong> object, which returns one of two values:</p>
			<ul>
				<li><strong class="source-inline">youtube</strong></li>
				<li><strong class="source-inline">vimeo</strong></li>
			</ul>
			<p>Using the <strong class="source-inline">host</strong> attribute in combination with an <strong class="source-inline">if</strong> statement, we can easily distinguish <a id="_idIndexMarker374"/>the two <strong class="source-inline">iframe</strong> elements and apply the appropriate attributes to each of them:</p>
			<p class="source-code">{% assign product_object = all_products["gardening-gloves"] %}</p>
			<p class="source-code">{% for media in product_object.media %}</p>
			<p class="source-code">  {% case media.media_type %}</p>
			<p class="source-code">    {% when "image" %}</p>
			<p class="source-code">      {{ media | img_tag: media.alt, "class1 class2",             "300x300" }}</p>
			<p class="source-code">    {% when "external_video" %}</p>
			<p class="source-code">      <strong class="bold">{% if media.host == "youtube" %}</strong></p>
			<p class="source-code">        {{ media | external_video_url: controls: 0, color:                 "white" | external_video_tag }}</p>
			<p class="source-code">      <strong class="bold">{% else %}</strong></p>
			<p class="source-code">        {{ media | external_video_url: loop: 1, muted: 1 |                 external_video_tag }}</p>
			<p class="source-code">      <strong class="bold">{% endif %}</strong></p>
			<p class="source-code">    {% when "video" %}</p>
			<p class="source-code">    {% when "model" %}</p>
			<p class="source-code">    {% else %}</p>
			<p class="source-code">  {% endcase %}</p>
			<p class="source-code">{% endfor %}</p>
			<p>With the introduction of the <strong class="source-inline">host</strong> attribute, we have ensured that each type of external video embedding will receive the appropriate attributes based on its documentation. </p>
			<p class="callout-heading">Tip:</p>
			<p class="callout">For available attributes for YouTube videos, refer to <a href="https://developers.google.com/youtube/player_parameters#Parameters">https://developers.google.com/youtube/player_parameters#Parameters</a>.</p>
			<p class="callout">For available attributes for Vimeo videos, refer to <a href="https://vimeo.zendesk.com/hc/en-us/articles/360001494447-Using-Player-Parameters">https://vimeo.zendesk.com/hc/en-us/articles/360001494447-Using-Player-Parameters</a>.</p>
			<p>We have now learned how to include both types of external videos and include any attributes for each type. Now we can move on to the following <strong class="source-inline">switch</strong> statement and learn how to output a video hosted on the Shopify platform itself. </p>
			<p>Uploading a <a id="_idIndexMarker375"/>video as a product media asset is the same as uploading an image. To upload a video, click on the <strong class="bold">Products</strong> section within the admin sidebar and select the product for which we are uploading the video asset. Once inside, scroll down to the <strong class="bold">Media</strong> section and click on the <strong class="bold">Add Media</strong> button to start the uploading process.</p>
			<p class="callout-heading">Important note:</p>
			<p class="callout">Aside from external videos, uploading assets to the Shopify platform has specific limitations for all assets, including images and videos. Besides the specific types of formats that we can use, an image file cannot exceed the resolution of 20 MP, 20 MB in size, and must be in either <strong class="source-inline">.jpeg</strong> or <strong class="source-inline">.png</strong> format, whereas video files are limited to a maximum length of 60 seconds, 20 MB in size, and must be in either <strong class="source-inline">.mp4</strong> or <strong class="source-inline">.mov</strong> video format.</p>
			<p>Once we have uploaded the video, we can also add optional information by including alt text and a poster image in the same way as for external media.</p>
			<p>To output the video uploaded to product media files, we will need to use <strong class="source-inline">video_tag</strong>, accessible through the <strong class="source-inline">video</strong> object:</p>
			<p class="source-code">{% assign product_object = all_products["gardening-gloves"] %}</p>
			<p class="source-code">{% for media in product_object.media %}</p>
			<p class="source-code">  {% case media.media_type %}</p>
			<p class="source-code">    {% when "image" %}</p>
			<p class="source-code">      {{ media | img_tag: media.alt, "class1 class2",             "300x300" }}</p>
			<p class="source-code">    {% when "external_video" %}</p>
			<p class="source-code">      {% if media.host == "youtube" %}</p>
			<p class="source-code">        {{ media | external_video_url: controls: 0, color:                 "white" | external_video_tag }}</p>
			<p class="source-code">      {% else %}</p>
			<p class="source-code">        {{ media | external_video_url: loop: 1, muted: 1 |                 external_video_tag }}</p>
			<p class="source-code">      {% endif %}</p>
			<p class="source-code">    {% when "video" %}</p>
			<p class="source-code">      <strong class="bold">{{ media | video_tag }}</strong></p>
			<p class="source-code">    {% when "model" %}</p>
			<p class="source-code">    {% else %}</p>
			<p class="source-code">  {% endcase %}</p>
			<p class="source-code">{% endfor %}</p>
			<p>By previewing <a id="_idIndexMarker376"/>the <strong class="bold">Product Gallery</strong> page, we will notice that in the place where the video should be, we only have a static image, a relatively small static image. If we inspect the results we have received, we will notice that we have correctly generated the HTML <strong class="source-inline">video</strong> tag. However, since we haven't enabled the controls, they have been hidden by default. Additionally, if we look closer, we will notice that the URL for the <strong class="source-inline">poster</strong> attribute within the HTML <strong class="source-inline">video</strong> tag has a small size, which is why the image on the storefront is small.</p>
			<p>As we recall from when learning about image filters, if we try to output an image without defining the image size, Shopify will automatically resize the image to <strong class="source-inline">100x100</strong>.</p>
			<p>With <strong class="source-inline">video_tag</strong>, we can include any number of attributes that we could use with the regular HTML <strong class="source-inline">video</strong> tag, including the <strong class="source-inline">image_size</strong> parameter, allowing us to modify the video <strong class="source-inline">poster</strong> attribute size. Let's modify <strong class="source-inline">video_tag</strong> to make the controls visible, set the poster <a id="_idIndexMarker377"/>image size, and set the video size to <strong class="source-inline">300x</strong> to match the poster size:</p>
			<p class="source-code">{% assign product_object = all_products["gardening-gloves"] %}</p>
			<p class="source-code">{% for media in product_object.media %}</p>
			<p class="source-code">  {% case media.media_type %}</p>
			<p class="source-code">    {% when "image" %}</p>
			<p class="source-code">      {{ media | img_tag: media.alt, "class1 class2",             "300x300" }}</p>
			<p class="source-code">    {% when "external_video" %}</p>
			<p class="source-code">      {% if media.host == "youtube" %}</p>
			<p class="source-code">        {{ media | external_video_url: controls: 0, color:                 "white" | external_video_tag:                         class: "youtube_video" }}</p>
			<p class="source-code">      {% else %}</p>
			<p class="source-code">        {{ media | external_video_url: loop: 1, muted: 1 |                 external_video_tag: class: "vimeo_video" }}</p>
			<p class="source-code">      {% endif %}</p>
			<p class="source-code">    {% when "video" %}</p>
			<p class="source-code">      {{ media | video_tag<strong class="bold">: controls: true, image_size: </strong>            <strong class="bold">"300x300", width: "300x"</strong> }}</p>
			<p class="source-code">    {% when "model" %}</p>
			<p class="source-code">    {% else %}</p>
			<p class="source-code">  {% endcase %}</p>
			<p class="source-code">{% endfor %}</p>
			<p>With the additional attributes included, we have now successfully generated the HTML <strong class="source-inline">video</strong> tag while retaining the ability to modify any attribute as we see fit.</p>
			<p>The following <a id="_idIndexMarker378"/>media type that we need to look into is the 3D model, which we can output using <strong class="source-inline">model_viewer_tag</strong>, accessible through the <strong class="source-inline">model</strong> object. Simply including <strong class="source-inline">model_viewer_tag</strong> with the <strong class="source-inline">media</strong> object will automatically generate the appropriate model viewer:</p>
			<p class="source-code">{% assign product_object = all_products["gardening-gloves"] %}</p>
			<p class="source-code">{% for media in product_object.media %}</p>
			<p class="source-code">  {% case media.media_type %}</p>
			<p class="source-code">    {% when "image" %}</p>
			<p class="source-code">      {{ media | img_tag: media.alt, "class1 class2",             "300x300" }}</p>
			<p class="source-code">    {% when "external_video" %}</p>
			<p class="source-code">      {% if media.host == "youtube" %}</p>
			<p class="source-code">        {{ media | external_video_url: controls: 0, color:                 "white" | external_video_tag:                         class: "youtube_video" }}</p>
			<p class="source-code">      {% else %}</p>
			<p class="source-code">        {{ media | external_video_url: loop: 1, muted: 1 |                 external_video_tag: class: "vimeo_video" }}</p>
			<p class="source-code">      {% endif %}</p>
			<p class="source-code">    {% when "video" %}</p>
			<p class="source-code">      {{ media | video_tag: controls: true, image_size:             "300x300", width: "300x" }}</p>
			<p class="source-code">    {% when "model" %}</p>
			<p class="source-code">      <strong class="bold">{{ media | model_viewer_tag }}</strong></p>
			<p class="source-code">    {% else %}</p>
			<p class="source-code">  {% endcase %}</p>
			<p class="source-code">{% endfor %}</p>
			<p>Note that the model viewer will automatically include specific attributes by default as with the previous <strong class="source-inline">media</strong> tags. Although, if we choose so, we can easily update or even include new <a id="_idIndexMarker379"/>attributes by following the same format mentioned with the previous <strong class="source-inline">media</strong> tags.</p>
			<p>With <strong class="source-inline">model_viewer_tag</strong> in place, we have covered all four media types and ensured that we would represent each media type with an appropriate <strong class="source-inline">media</strong> tag. However, notice that we still have one final <strong class="source-inline">switch</strong> statement without any <strong class="source-inline">media</strong> tag.</p>
			<p>We can consider the final <strong class="source-inline">switch</strong> statement as a failsafe if, for some reason, any of the previous <strong class="source-inline">switch</strong> statements or media fail to produce results, and we will use it with <strong class="source-inline">media_tag</strong>.</p>
			<p>The <strong class="source-inline">media_tag</strong> filter is somewhat of a special kind of filter as this particular filter will automatically generate the appropriate <strong class="source-inline">media</strong> tag for any of the four previously mentioned media types. <em class="italic">So, if we can use</em> <strong class="source-inline">media_tag</strong> <em class="italic">to generate all the </em><strong class="source-inline">media</strong><em class="italic"> tags automatically,</em> <em class="italic">why don't we use</em> <strong class="source-inline">media_tag</strong> <em class="italic">to generate all the media files? Why did we bother to learn about all the </em><strong class="source-inline">media</strong><em class="italic"> tags until now?</em></p>
			<p>While it is correct that <strong class="source-inline">media_tag</strong> will automatically detect each type of media type and render the appropriate <strong class="source-inline">media</strong> tag for it, by using <strong class="source-inline">media_tag</strong>, we will lose the ability to assign custom class names and attributes to specific media types. For this reason, we should never use <strong class="source-inline">media_tag</strong> as the primary option for rendering media assets. Instead, we should use it as a failsafe to correctly render the media assets on the storefront:</p>
			<p class="source-code">{% assign product_object = all_products["gardening-gloves"] %}</p>
			<p class="source-code">{% for media in product_object.media %}</p>
			<p class="source-code">  {% case media.media_type %}</p>
			<p class="source-code">    {% when "image" %}</p>
			<p class="source-code">      {{ media | img_tag: media.alt, "class1 class2",             "300x300" }}</p>
			<p class="source-code">    {% when "external_video" %}</p>
			<p class="source-code">      {% if media.host == "youtube" %}</p>
			<p class="source-code">        {{ media | external_video_url: controls: 0, color:                 "white" | external_video_tag:                         class: "youtube_video" }}</p>
			<p class="source-code">      {% else %}</p>
			<p class="source-code">        {{ media | external_video_url: loop: 1, muted: 1 |                 external_video_tag: class: "vimeo_video" }}</p>
			<p class="source-code">      {% endif %}</p>
			<p class="source-code">    {% when "video" %}</p>
			<p class="source-code">      {{ media | video_tag: controls: true, image_size:             "300x300", width: "300x" }}</p>
			<p class="source-code">    {% when "model" %}</p>
			<p class="source-code">      {{ media | model_viewer_tag }}</p>
			<p class="source-code">    {% else %}</p>
			<p class="source-code">    <strong class="bold">{{ media | media_tag }}</strong></p>
			<p class="source-code">  {% endcase %}</p>
			<p class="source-code">{% endfor %}</p>
			<p>So far, we have learned how to output image type media files, differentiate between different types of external media assets, render the media tag for a video hosted on the Shopify platform, and generate the appropriate media tag for 3D models. Finally, with <strong class="source-inline">media_tag</strong>, we have covered every media type Shopify currently covers and have ensured that we will correctly present each media asset on our storefront.</p>
			<p>Now that we have all the necessary assets to create the media gallery, the only thing left to do is to refine our code by including some HTML elements to format it properly. Besides the code format, we can also use some slider plugins, such as <strong class="bold">Slick</strong>, depending on the gallery <a id="_idIndexMarker380"/>we are looking to create. To keep everything concise and to the point, we will not be covering the media gallery's style and functionality. However, we can find the necessary suggestions on styling and functionality in the following Shopify article for those looking to test their skills by finishing the project (<a href="https://shopify.dev/tutorials/add-theme-support-for-rich-media-3d-and-video">https://shopify.dev/tutorials/add-theme-support-for-rich-media-3d-and-video</a>).</p>
			<p>Inside the article, we can find information such as using the aspect ratio box to create responsiveness or answers to some of the frequently asked questions on functionality, such as connecting the thumbnail images to the main gallery or the variant themselves.</p>
			<p class="callout-heading">Tip:</p>
			<p class="callout">For additional information on all the available media filters, we can refer to <a href="https://shopify.dev/docs/themes/liquid/reference/filters/media-filters">https://shopify.dev/docs/themes/liquid/reference/filters/media-filters</a>.</p>
			<p>While working on this project, we created a fundamental version of the product media gallery, allowing us to output any type of product media to any page. While it might not look impressive, the knowledge we have learned with this project has taught us how to create one of the most sought-after features today, and it will be of great help to us in creating more advanced functionalities as our knowledge grows further.</p>
			<h1 id="_idParaDest-103"><a id="_idTextAnchor102"/>Building product accordions</h1>
			<p>In the following project, we will be learning about the string and array filters by working with and <a id="_idIndexMarker381"/>creating the product accordions feature. <em class="italic">But, before we proceed with the project, what exactly do string and array filters do?</em></p>
			<p><strong class="bold">String filters</strong> are methods <a id="_idIndexMarker382"/>that allow us to manipulate the output of Liquid code or the variable itself as long as the variable is a string type, whereas array filters allow us to manipulate the output of arrays.</p>
			<p>For this project, we will first find one product with a lengthy description. To save some time, we already included the necessary description in the <strong class="bold">Black Armchairs</strong> product that we previously imported from the <strong class="source-inline">product-data.csv</strong> file in <a href="B17606_03_Final_PD_ePub.xhtml#_idTextAnchor047"><em class="italic">Chapter 3</em></a>, <em class="italic">Diving into Liquid Core with Tags</em>.</p>
			<div>
				<div id="_idContainer059" class="IMG---Figure">
					<img src="Images/Figure_5.04_B17606.jpg" alt="Figure 5.4 – Example of a long product description&#13;&#10;" width="1003" height="691"/>
				</div>
			</div>
			<p class="figure-caption">Figure 5.4 – Example of a long product description</p>
			<p>As we can see from the previous screenshot, having a lengthy product description can be quite inefficient as it takes up a lot of space. While we can easily format the product description <a id="_idIndexMarker383"/>code to include the necessary HTML tags to create product accordions, manually adjusting the code for each product would be a long process. Maintaining it is even worse. Luckily, by using string and array filters, we can easily manipulate the product description output to break it up and format it in any way we need:</p>
			<ol>
				<li value="1">First, let's begin by identifying the piece of code that is rendering the current product description. We can find the product description inside <strong class="source-inline">product-template.liquid</strong> under the <strong class="source-inline">Sections</strong> directory, which we are currently rendering using <strong class="source-inline">product.description</strong>:<p class="source-code">&lt;div class="product-single__description rte"&gt;</p><p class="source-code">  <strong class="bold">{{ product.description }}</strong></p><p class="source-code">&lt;/div&gt;</p></li>
				<li>Since we are looking to create reusable code, the first thing we should do is to create a variable that will hold the <strong class="source-inline">product.description</strong> output, so that we can avoid calling <strong class="source-inline">product.description</strong> multiple times:<p class="source-code">&lt;div class="product-single__description rte"&gt;</p><p class="source-code">  <strong class="bold">{% assign productDescription = product.description%}</strong></p><p class="source-code">&lt;/div&gt;</p></li>
			</ol>
			<p>Now that we have the variable in place, we should outline what exactly we are trying to achieve. Again, looking over the current product description, we can clearly see that we have three solid blocks, so let's say that we are looking to separate the entire product description into three or even more distinctive product accordions.</p>
			<p>Now that <a id="_idIndexMarker384"/>we know <em class="italic">what</em>, we need to think of <em class="italic">how</em>. While we can easily hardcode the product accordion titles, such as <strong class="bold">Description</strong>, <strong class="bold">Ingredients</strong>, and <strong class="bold">Instructions</strong>, we are looking to create a dynamic feature that allows us to easily include any number of product accordions without modifying the code itself. We'll use the following steps to do so:</p>
			<ul>
				<li>Start by navigating to the <strong class="bold">Black Armchairs</strong> product on the admin page and include the words <strong class="source-inline">Description</strong>, <strong class="source-inline">Ingredients</strong>, and <strong class="source-inline">Instructions</strong> as h6 headings, one before each text block. To do this, we can use the headings to include any number of product tab titles and set the proper markings for later.</li>
				<li>Then, we can apply the headings using the rich text editor by simply highlighting the text we are looking to format and clicking the <strong class="bold">A</strong> button, which will trigger a dropdown where we can select the h6 heading we need:</li>
			</ul>
			<div>
				<div id="_idContainer060" class="IMG---Figure">
					<img src="Images/Figure_5.05_B17606.jpg" alt="Figure 5.5 – Example of applying headings inside the product description&#13;&#10;" width="746" height="448"/>
				</div>
			</div>
			<p class="figure-caption">Figure 5.5 – Example of applying headings inside the product description</p>
			<p>With the headings in place, we now have proper markup that we can use to separate the text blocks <a id="_idIndexMarker385"/>into separate blocks, which we can do using the following string filter, <strong class="source-inline">split</strong>.</p>
			<h2 id="_idParaDest-104"><a id="_idTextAnchor103"/>The split filter</h2>
			<p>The <strong class="source-inline">split</strong> filter uses a single substring as a parameter, which acts as a delimiter, dividing the string into an array whose items we can later output using array filters. <em class="italic">But how exactly does it work?</em></p>
			<p class="source-code">{% assign methods = "Strings and Filters" %}</p>
			<p>In this example, we have created a variable named <strong class="source-inline">methods</strong> and assigned a string message to it. Let's now use the <strong class="source-inline">split</strong> filter to divide the string message into an array and call it immediately to see the results:</p>
			<p class="source-code">{% assign methods = "Strings and Filters" | split: " and " %}</p>
			<p class="source-code">{{ methods }}</p>
			<p class="source-code">StringsFilters</p>
			<p>As we can see, after applying the <strong class="source-inline">split</strong> filter, the substring that we used as a delimiter was removed entirely from the initial string, and we have ended up with an array result. Therefore, any value assigned to the <strong class="source-inline">split</strong> filter substring parameter will not only serve as a markup delimiter but will also automatically remove any occurrence of the substring value from the string.</p>
			<p>After using the <strong class="source-inline">split</strong> filter, we have now modified the <strong class="source-inline">methods</strong> variable into an array. However, this is not obvious since we have also included empty space within the delimiter, so as a result, we have two words written next to each other without any space. To test <a id="_idIndexMarker386"/>whether our <strong class="source-inline">methods</strong> variable is an array, we need to run it through a loop using the <strong class="source-inline">for</strong> tag. <em class="italic">However, what if we wanted to avoid using a loop since we only have two items inside the array?</em></p>
			<p>This is where the <strong class="source-inline">first</strong> array filter comes to help. As we recall, we previously mentioned both the <strong class="source-inline">first</strong> and <strong class="source-inline">last</strong> filters in the previous chapter when we worked on the <strong class="source-inline">Product Customization</strong> project. Using the <strong class="source-inline">first</strong> or <strong class="source-inline">last</strong> filter will automatically recover the first or last element inside the array. Since our array only has two elements after using the <strong class="source-inline">split</strong> filter, it is a perfect fit. Otherwise, we would need to include a <strong class="source-inline">for</strong> tag to loop over the array to recover the proper values. Let's see it in action by recovering only data before the delimiter:</p>
			<p class="source-code">{% assign methods = "Strings and Filters" | split: " and "   <strong class="bold">| first</strong> %}</p>
			<p class="source-code"><strong class="bold">{{ methods }}</strong></p>
			<p class="source-code">Strings</p>
			<p>We can now see that we have successfully modified the initial string type variable into an array type and have successfully recovered only the first item of the array. While this specific method might look non-important, the knowledge we have gained will be of great use in our future work.</p>
			<p>Before we move on to our project, let's take one more example:</p>
			<p class="source-code">{% assign message  = "This is a short string message." <strong class="bold">|   split: " " </strong>%}</p>
			<p>In this example, we have assigned a short string inside the <strong class="source-inline">message</strong> variable. We have then applied the <strong class="source-inline">split</strong> filter and set its substring to an empty space value, meaning that we are looking to divide the initial string for every empty space occurrence. Let's create a short loop to confirm whether the <strong class="source-inline">message</strong> variable is now an array type:</p>
			<p class="source-code">{% assign message  = "This is a short string message." |   split: " " %}</p>
			<p class="source-code"><strong class="bold">{% for item in message %}</strong></p>
			<p class="source-code">  <strong class="bold">{{ item }}</strong></p>
			<p class="source-code"><strong class="bold">{% endfor %}</strong></p>
			<p class="source-code">This</p>
			<p class="source-code">is</p>
			<p class="source-code">a</p>
			<p class="source-code">short</p>
			<p class="source-code">string</p>
			<p class="source-code">message.</p>
			<p>As we can see, by introducing the <strong class="source-inline">split</strong> filter, we have successfully divided the initial string message <a id="_idIndexMarker387"/>using the substring parameter and created an array, which we have confirmed using the <strong class="source-inline">for</strong> tag. Let's now return to our project and use our newfound knowledge to divide the product description into three separate blocks.</p>
			<p>Since we are looking to create a dynamic feature, we will need to set the substring parameter to a value that we know will be present in each product description. Remember that we have previously added the headings, formatted using the <strong class="source-inline">h6</strong> heading. So, let's use the <strong class="source-inline">split</strong> filter and set the substring value to the opening <strong class="source-inline">h6</strong> heading:</p>
			<p class="source-code">&lt;div class="product-single__description rte"&gt;</p>
			<p class="source-code">  {% assign productDescription = product.description <strong class="bold">|     split: "&lt;h6&gt;"</strong> %}</p>
			<p class="source-code">&lt;/div&gt;</p>
			<p>To make sense of using the <strong class="source-inline">h6</strong> heading as a substring parameter, we will first need to look over the current HTML format of our product description. If we were to inspect the product description before using the <strong class="source-inline">split</strong> filter, we would notice the following HTML format:</p>
			<p class="source-code">&lt;h6&gt;Description&lt;/h6&gt;</p>
			<p class="source-code">&lt;p&gt;Lorem ipsum content&lt;p&gt;</p>
			<p class="source-code">&lt;h6&gt;Ingredients&lt;/h6&gt;</p>
			<p class="source-code">&lt;p&gt;Lorem ipsum content&lt;p&gt;</p>
			<p class="source-code">&lt;h6&gt;Instructions&lt;/h6&gt;</p>
			<p class="source-code">&lt;p&gt;Lorem ipsum content&lt;p&gt;</p>
			<p>As the markup <a id="_idIndexMarker388"/>shows, each heading is located just above the text block, providing perfect markup. Using the opening <strong class="source-inline">h6</strong> heading as a delimiter, we should have four items inside our array. Let's now see what happens when we apply the <strong class="source-inline">split</strong> filter using the opening <strong class="source-inline">h6</strong> heading as a delimiter:</p>
			<p class="source-code">&lt;div class="product-single__description rte"&gt;</p>
			<p class="source-code">  {% assign productDescription = product.description |     split: "&lt;h6&gt;" %}</p>
			<p class="source-code">{% for item in productDescription %}</p>
			<p class="source-code">  &lt;div class="product-single__description-item"&gt;</p>
			<p class="source-code">    {{ item }}</p>
			<p class="source-code">  &lt;/div&gt;</p>
			<p class="source-code">{% endfor %}</p>
			<p class="source-code">&lt;/div&gt;</p>
			<p>Based on our markup, after applying the <strong class="source-inline">split</strong> filter with the opening <strong class="source-inline">h6</strong> heading as a delimiter, the first item in our array should be empty, as there is no content before the first occurrence of our delimiter. The other three should contain both the heading and any content between the first and the following delimiter occurrence:</p>
			<p class="source-code">&lt;div class="product-single__description-item"&gt;&lt;/div&gt;</p>
			<p class="source-code">&lt;div class="product-single__description-item"&gt;</p>
			<p class="source-code">&lt;span&gt;Description&lt;/span&gt;</p>
			<p class="source-code">&lt;p&gt;Lorem ipsum content&lt;p&gt;</p>
			<p class="source-code">&lt;/div&gt;</p>
			<p class="source-code">&lt;div class="product-single__description-item"&gt;</p>
			<p class="source-code">&lt;span&gt;Ingredients&lt;/span&gt;</p>
			<p class="source-code">&lt;p&gt;Lorem ipsum content&lt;p&gt;</p>
			<p class="source-code">&lt;/div&gt;</p>
			<p class="source-code">&lt;div class="product-single__description-item"&gt;</p>
			<p class="source-code">&lt;span&gt;Instructions&lt;/span&gt;</p>
			<p class="source-code">&lt;p&gt;Lorem ipsum content&lt;p&gt;</p>
			<p class="source-code">&lt;/div&gt;</p>
			<p>Looking over <a id="_idIndexMarker389"/>the results, we can see that we were successful in extracting each product description block. However, there are still a few things to cover. For example, we will have one empty <strong class="source-inline">div</strong>, which we can quickly resolve by introducing the <strong class="source-inline">offset</strong> parameter and setting its value to <strong class="source-inline">1</strong>, allowing us to skip the first iteration within the <strong class="source-inline">for</strong> loop. We can remind ourselves of the <strong class="source-inline">offset</strong> parameter by visiting the <em class="italic">Iterations tags</em> section located in <a href="B17606_03_Final_PD_ePub.xhtml#_idTextAnchor047"><em class="italic">Chapter 3</em></a>, <em class="italic">Diving into Liquid Core with Tags</em>:</p>
			<p class="source-code">&lt;div class="product-single__description rte"&gt;</p>
			<p class="source-code">  {% assign productDescription = product.description |     split: "&lt;h6&gt;" %}</p>
			<p class="source-code">{% for item in productDescription <strong class="bold">offset: 1</strong> %}</p>
			<p class="source-code">  &lt;div class="product-single__description-item"&gt;</p>
			<p class="source-code">    {{ item }}</p>
			<p class="source-code">  &lt;/div&gt;</p>
			<p class="source-code">{% endfor %}</p>
			<p class="source-code">&lt;/div&gt;</p>
			<p>Adding the <strong class="source-inline">offset</strong> parameter to the <strong class="source-inline">for</strong> tag will skip the first iteration, otherwise returning an empty value. Additionally, we have ensured that our array only contains the three <a id="_idIndexMarker390"/>product description blocks we initially intended. However, let's take a closer look at the current results of our array after applying the <strong class="source-inline">offset</strong> parameter:</p>
			<p class="source-code">&lt;div class="product-single__description-item"&gt;</p>
			<p class="source-code">&lt;span&gt;Description&lt;/span&gt;</p>
			<p class="source-code">&lt;p&gt;Lorem ipsum content&lt;p&gt;</p>
			<p class="source-code">&lt;/div&gt;</p>
			<p class="source-code">&lt;div class="product-single__description-item"&gt;</p>
			<p class="source-code">&lt;span&gt;Ingredients&lt;/span&gt;</p>
			<p class="source-code">&lt;p&gt;Lorem ipsum content&lt;p&gt;</p>
			<p class="source-code">&lt;/div&gt;</p>
			<p class="source-code">&lt;div class="product-single__description-item"&gt;</p>
			<p class="source-code">&lt;span&gt;Instructions&lt;/span&gt;</p>
			<p class="source-code">&lt;p&gt;Lorem ipsum content&lt;p&gt;</p>
			<p class="source-code">&lt;/div&gt;</p>
			<p>As we recall, by using the opening <strong class="source-inline">h6</strong> heading as a substring to the <strong class="source-inline">split</strong> filter, we will automatically remove any opening <strong class="source-inline">h6</strong> heading within the initial string. However, notice that we have not only removed the opening <strong class="source-inline">h6</strong> tag but we have also removed the closing <strong class="source-inline">h6</strong> tag.</p>
			<p>Technically, the closing <strong class="source-inline">h6</strong> tag is still there, located after the closing <strong class="source-inline">span</strong> tag. However, since we have removed the opening <strong class="source-inline">h6</strong> tag, the browser interpreted this as an error and automatically removed the closing <strong class="source-inline">h6</strong> tag. So, instead of relying on the browser to clean up, let's use the closing <strong class="source-inline">h6</strong> tag to divide our three blocks further.</p>
			<p>Currently, each item variable inside the <strong class="source-inline">for</strong> loop contains both the heading and the content text. By applying the <strong class="source-inline">split</strong> filter using the closing <strong class="source-inline">h6</strong> heading, we will modify the <strong class="source-inline">item</strong> variable into <a id="_idIndexMarker391"/>an array of its own, containing the heading and the content. So, instead of using another <strong class="source-inline">for</strong> loop to loop over those, let's recall the <strong class="source-inline">first</strong> and <strong class="source-inline">last</strong> filters that we previously mentioned and use them here to recover each value separately:</p>
			<p class="source-code">&lt;div class="product-single__description rte"&gt;</p>
			<p class="source-code">  {% assign productDescription = product.description |     split: "&lt;h6&gt;" %}</p>
			<p class="source-code">{% for item in productDescription offset: 1 %}</p>
			<p class="source-code">  &lt;div class="product-single__description--item"&gt;</p>
			<p class="source-code">    <strong class="bold">&lt;div class="product-single__description-title"&gt;</strong></p>
			<p class="source-code">      <strong class="bold">{{ item | split: "&lt;/h6&gt;" | first }}</strong></p>
			<p class="source-code">    <strong class="bold">&lt;/div&gt;</strong></p>
			<p class="source-code">    <strong class="bold">&lt;div class="product-single__description-content"&gt;</strong></p>
			<p class="source-code">      <strong class="bold">{{ item | split: "&lt;/h6&gt;" | last }}</strong></p>
			<p class="source-code">    <strong class="bold">&lt;/div&gt;</strong></p>
			<p class="source-code">  &lt;/div&gt;</p>
			<p class="source-code">{% endfor %}</p>
			<p class="source-code">&lt;/div&gt;</p>
			<p>By applying the <strong class="source-inline">split</strong> filter again, we have removed the leftover closing <strong class="source-inline">h6</strong> tag. Additionally, we have separated the content more clearly, allowing us to use the results to complete our mini project more easily.</p>
			<p>At this point, we possess all the necessary elements to finalize the product accordions project. The only thing left is to include some styling and introduce the script to handle the on-input animation. To keep everything concise, we will not cover the styling and functionality within this project. However, we will provide the final expectation to help us visualize a clear goal that we should work on, as it will serve as an excellent practice for future work:</p>
			<div>
				<div id="_idContainer061" class="IMG---Figure">
					<img src="Images/Figure_5.06_B17606.jpg" alt="Figure 5.6 – Example of a complete product accordions project&#13;&#10;" width="623" height="343"/>
				</div>
			</div>
			<p class="figure-caption">Figure 5.6 – Example of a complete product accordions project</p>
			<p>So far, we have <a id="_idIndexMarker392"/>learned how to manipulate string variables by turning them into an array type variable and using them to create the product accordions feature. In addition, we have learned about the <strong class="source-inline">split</strong> and <strong class="source-inline">first</strong>/<strong class="source-inline">last</strong> filters that we included using the pipeline character. However, specific filters, such as <strong class="source-inline">size</strong>, can be used with pipeline and dot annotation, depending on the situation:</p>
			<p class="source-code">{% assign message  = "This is a short string message." %}</p>
			<p class="source-code">{{ message | size }}</p>
			<p class="source-code">{% if message.size &gt;= 10 %}</p>
			<p class="source-code">  This message contains more than 10 characters.</p>
			<p class="source-code">{% endif %}</p>
			<p>In the previous example, we have created a <strong class="source-inline">message</strong> variable and have assigned a short string to it. Using the <strong class="source-inline">size</strong> filter with the <strong class="source-inline">message</strong> variable, we will render the total number of characters within the message string. However, by using the size with the dot annotation, we gained the ability to use the <strong class="source-inline">size</strong> filter as part of Liquid logic:</p>
			<p class="source-code">31</p>
			<p class="source-code">This message contains more than 10 characters.</p>
			<p>We can also use the <strong class="source-inline">size</strong> filter to improve our product accordions by including an <strong class="source-inline">if</strong> statement that will check whether the product description has more than <strong class="source-inline">1</strong> block of code and render <a id="_idIndexMarker393"/>the product accordions if it does. Otherwise, it should simply output the regular product description:</p>
			<p class="source-code">&lt;div class="product-single__description rte"&gt;</p>
			<p class="source-code">  {% assign productDescription = product.description |     split: "&lt;h6&gt;" %}</p>
			<p class="source-code"><strong class="bold">{% if productDescription.size &gt; 1 %}</strong></p>
			<p class="source-code">  {% for item in productDescription offset: 1 %}</p>
			<p class="source-code">    &lt;div class="product-single__description--item"&gt;</p>
			<p class="source-code">      &lt;div class="product-single__description-title"&gt;</p>
			<p class="source-code">        {{ item | split: "&lt;/h6&gt;" | first }}</p>
			<p class="source-code">      &lt;/div&gt;</p>
			<p class="source-code">      &lt;div class="product-single__description-content"&gt;</p>
			<p class="source-code">        {{ item | split: "&lt;/h6&gt;" | last }}</p>
			<p class="source-code">      &lt;/div&gt;</p>
			<p class="source-code">    &lt;/div&gt;</p>
			<p class="source-code">  {% endfor %}</p>
			<p class="source-code"><strong class="bold">{% else %}</strong></p>
			<p class="source-code">  <strong class="bold">&lt;div class="rte"&gt;{{ product.description }}&lt;/div&gt;</strong></p>
			<p class="source-code"><strong class="bold">{% endif %}</strong></p>
			<p class="source-code">&lt;/div&gt;</p>
			<p>With the introduction of the <strong class="source-inline">size</strong> filter, we have made our code a lot cleaner and more optimized, as we will not run a <strong class="source-inline">for</strong> loop for a single item inside the array type variable.</p>
			<p>As we can see, by simply using everyday filters, we can improve our code significantly. For example, <em class="italic">what if we wanted to split the product description and render the content into various places and not simply output them all at once?</em> For this, we will need to use <a id="_idIndexMarker394"/>a combination of the <strong class="source-inline">split</strong>, <strong class="source-inline">first</strong>/<strong class="source-inline">last</strong>, and <strong class="source-inline">index</strong> filters. We have already covered the <strong class="source-inline">split</strong> and <strong class="source-inline">first</strong>/<strong class="source-inline">last</strong> filters, <em class="italic">but what does the </em><strong class="source-inline">index</strong><em class="italic"> filter do?</em></p>
			<h2 id="_idParaDest-105"><a id="_idTextAnchor104"/>The index filter</h2>
			<p>As its name suggests, the <strong class="source-inline">index</strong> filters allow us to access a specific array using its index location, starting from 0. Let's try to apply the index location to our product accordions project. Note that we will no longer have any need for the <strong class="source-inline">for</strong> tag, as we will be accessing the <strong class="source-inline">productDescription</strong> variable directly through the <strong class="source-inline">index</strong> filter:</p>
			<p class="source-code">&lt;div class="product-single__description rte"&gt;</p>
			<p class="source-code">  {% assign productDescription = product.description |     split: "&lt;h6&gt;" %}</p>
			<p class="source-code">  &lt;div class="product-single__description--item"&gt;</p>
			<p class="source-code">    &lt;div class="product-single__description-title"&gt;</p>
			<p class="source-code">      {{ <strong class="bold">item[1]</strong> | split: "&lt;/h6&gt;" | first }}</p>
			<p class="source-code">    &lt;/div&gt;</p>
			<p class="source-code">    &lt;div class="product-single__description-content"&gt;</p>
			<p class="source-code">      {{ <strong class="bold">item[1]</strong> | split: "&lt;/h6&gt;" | last }}</p>
			<p class="source-code">    &lt;/div&gt;</p>
			<p class="source-code">  &lt;/div&gt;</p>
			<p class="source-code">&lt;/div&gt;</p>
			<p>The previous code will return the first heading and block of text from our product description. However, we have mentioned that the index position starts at <strong class="source-inline">0</strong>, <em class="italic">so why is position</em> <strong class="source-inline">1</strong> <em class="italic">returning the results of the first block?</em></p>
			<p>As we recall, since we have used the opening <strong class="source-inline">h6</strong> tag as a delimiter to our <strong class="source-inline">split</strong> filter, the first item in our array is empty. Previously we skipped the first item inside the array by including the <strong class="source-inline">offset</strong> parameter, whereas now we will simply skip the <em class="italic">first index position</em>, which is <strong class="source-inline">0</strong>. The downside of this method is that we will have to repeat the code to recover <a id="_idIndexMarker395"/>each block separately. However, on the plus side, we gain the flexibility of positioning them at the place of our choosing, which sometimes will be necessary.</p>
			<p class="callout-heading">Tip:</p>
			<p class="callout">For additional information on all the available string filters, we can refer to <a href="https://shopify.dev/docs/themes/liquid/reference/filters/string-filters">https://shopify.dev/docs/themes/liquid/reference/filters/string-filters</a>.</p>
			<p class="callout">For additional information on all the available array filters, we can refer to <a href="https://shopify.dev/docs/themes/liquid/reference/filters/array-filters">https://shopify.dev/docs/themes/liquid/reference/filters/array-filters</a>.</p>
			<p>We saw how somewhat insignificant filters could be a powerful tool that will allow us to create complex features that merchants regularly seek. Through this type of learning process, we gain valuable lessons by working on a real-life project, but we also learn how to deal with various types of filters, which is a lot more essential than simply listing them all.</p>
			<h1 id="_idParaDest-106"><a id="_idTextAnchor105"/>Math and money filters</h1>
			<p>In the previous <a id="_idIndexMarker396"/>chapter, we had a chance to see money filters in action while working on the <strong class="source-inline">Custom collections</strong> project. <strong class="bold">Money filters</strong> are simple types <a id="_idIndexMarker397"/>of filters whose only task is to format the number value based on the currency formatting options, <em class="italic">but what exactly does this mean?</em></p>
			<p>To better understand, let's navigate to our admin page and click on the <strong class="bold">Settings</strong> button in the bottom-left corner. Consequently, click on the <strong class="bold">General</strong> option to open where we will be able to update the store's basic information. Once inside, scroll down until you have reached the section named <strong class="bold">Store currency</strong>. This is where we can change the store's default currency, which our customers will use to make their purchases. Instead of changing the store currency, let's click on the <strong class="bold">Change formatting</strong> button.</p>
			<div>
				<div id="_idContainer062" class="IMG---Figure">
					<img src="Images/Figure_5.07_B17606.jpg" alt="Figure 5.7 – Location of the store currency formatting&#13;&#10;" width="811" height="354"/>
				</div>
			</div>
			<p class="figure-caption">Figure 5.7 – Location of the store currency formatting</p>
			<p>By clicking the <strong class="bold">Change formatting</strong> button, we will reveal additional currency formatting <a id="_idIndexMarker398"/>options where we can define the global markup for the currency formatting <a id="_idIndexMarker399"/>that the money filter will later use to format any number value.</p>
			<p>If we were to apply the money filter to any number value, based on the formatting settings, the only change that we would see is that we would see a dollar sign before the price and USD after the price. So, let's try to modify these two fields to include some more helpful markup.</p>
			<p>We can edit the first two fields named <strong class="bold">HTML with currency</strong> and <strong class="bold">HTML without currency</strong> by wrapping the current values inside the <strong class="source-inline">span</strong> tag with the <strong class="source-inline">money</strong> class. However, note that when writing a <strong class="source-inline">money</strong> class, we should not include quote marks. Otherwise, we risk breaking the currency formatting.</p>
			<div>
				<div id="_idContainer063" class="IMG---Figure">
					<img src="Images/Figure_5.08_B17606.jpg" alt="Figure 5.8 – Example of updating the store currency formatting&#13;&#10;" width="806" height="541"/>
				</div>
			</div>
			<p class="figure-caption">Figure 5.8 – Example of updating the store currency formatting</p>
			<p>By including the <strong class="source-inline">span</strong> tag with the <strong class="source-inline">money</strong> class inside the currency formatting, we have now <a id="_idIndexMarker400"/>ensured that each pricing element in our store will contain the <a id="_idIndexMarker401"/>same selector, which will help if we need to update the pricing dynamically.</p>
			<p>On the other hand, <strong class="bold">math filters</strong> are self-explanatory, as they allow us to perform specific mathematical tasks. Similarly, as with the string and array filters, we can chain multiple math filters inside one line, in which case, the filters will apply in order from left to right.</p>
			<p>Now that we have familiarized ourselves with the money and math filters, let's see them in action and start working on our next mini project.</p>
			<h2 id="_idParaDest-107"><a id="_idTextAnchor106"/>Product discount price</h2>
			<p>In the <a id="_idIndexMarker402"/>following project, we will be learning about the <a id="_idIndexMarker403"/>math and money filters by working on one of the projects we started in <a href="B17606_04_Final_PD_ePub.xhtml#_idTextAnchor079"><em class="italic">Chapter 4</em></a>, <em class="italic">Diving into Liquid Core with Objects</em>, which is <strong class="source-inline">Custom collection</strong>, located under the <em class="italic">Global Objects</em> section. </p>
			<p>We aim to create the product discount price and update the sale badge to display an actual percentage discount. Let's start by navigating to the location of the code that we have previously developed.</p>
			<p>We created the <strong class="source-inline">Custom collection</strong> feature by including the <strong class="source-inline">collection-form.liquid</strong> snippet <a id="_idIndexMarker404"/>inside the <strong class="source-inline">collection.liquid</strong> file, located <a id="_idIndexMarker405"/>under the <strong class="source-inline">Templates</strong> directory. Inside the <strong class="source-inline">collection-form.liquid</strong> snippet, we will see the following code:</p>
			<p class="source-code">{% if product.compare_at_price != blank %}</p>
			<p class="source-code">&lt;div class="custom-collection--item"&gt;</p>
			<p class="source-code">  &lt;a href="{{ product.url }}"&gt;</p>
			<p class="source-code">    &lt;img src="{{ product | img_url: "300x300" }}"/&gt;</p>
			<p class="source-code">    &lt;p class="h4 custom-collection--title"&gt;{{ product.title         }}&lt;/p&gt;</p>
			<p class="source-code">    <strong class="bold">&lt;p class="custom-collection--price"&gt;</strong></p>
			<p class="source-code">      <strong class="bold">{{ product.price | money }}</strong></p>
			<p class="source-code">      <strong class="bold">&lt;span&gt;{{ product.compare_at_price | money }}&lt;/span&gt;</strong></p>
			<p class="source-code">    <strong class="bold">&lt;/p&gt;</strong></p>
			<p class="source-code">    &lt;span class="custom-collection--sale-badge"&gt;sale&lt;/span&gt;</p>
			<p class="source-code">  &lt;/a&gt;</p>
			<p class="source-code">  {% form "product", product %}</p>
			<p class="source-code">    &lt;input type="hidden" name="id" value="{{         product.first_available_variant.id }}" /&gt;</p>
			<p class="source-code">    &lt;input type="submit" value="Add to Cart"/&gt;</p>
			<p class="source-code">  {% endform %}</p>
			<p class="source-code">&lt;/div&gt;</p>
			<p class="source-code">{% endif %}</p>
			<p>With the current setup, we display both the regular price and the comparison price, so let's start by modifying the comparison price and replacing it with the actual discount price. To output the discount between the two prices, it should be relatively straightforward as we only need to subtract the regular price from the comparison price.</p>
			<p>To subtract the regular price from the comparison price, we will need to use the <strong class="source-inline">minus</strong> math filter:</p>
			<p class="source-code">&lt;p class="custom-collection--price"&gt;</p>
			<p class="source-code">  {{ product.price | money }}</p>
			<p class="source-code">  &lt;span&gt;{{ product.compare_at_price | minus: product.price     }}&lt;/span&gt;</p>
			<p class="source-code">&lt;/p&gt;</p>
			<p>Notice that with the introduction of the <strong class="source-inline">minus</strong> filter, we had to remove the <strong class="source-inline">money</strong> filter entirely. As previously mentioned, we can only use math filters if all the values are number values. If we were to include <strong class="source-inline">money</strong> filters, we would turn both values into a string due to our previously set currency formatting. </p>
			<p>Now that we <a id="_idIndexMarker406"/>have successfully applied the <strong class="source-inline">minus</strong> filter, we need <a id="_idIndexMarker407"/>to think of a way to include the <strong class="source-inline">money</strong> filter. With the current setup, we have received a number value without any currency formatting. However, as mentioned, if we were to apply the <strong class="source-inline">money</strong> filter to any of the two values, even after <strong class="source-inline">product.price</strong>, the <strong class="source-inline">money</strong> filter would only affect <strong class="source-inline">product.price</strong>, not the final results. Consequently, the math filter would no longer work.</p>
			<p>To resolve this, we would need to introduce a variable using an <strong class="source-inline">assign</strong> or <strong class="source-inline">capture</strong> keywords to calculate the difference between the two numbers and later call the variable with the <strong class="source-inline">money</strong> filter:</p>
			<p class="source-code">&lt;p class="custom-collection--price"&gt;</p>
			<p class="source-code">  {{ product.price | money }}</p>
			<p class="source-code">  {% assign discount-price = product.compare_at_price |     minus: product.price %}</p>
			<p class="source-code">  &lt;span&gt;{{ discount-price | money }}&lt;/span&gt;</p>
			<p class="source-code">&lt;/p&gt;</p>
			<p>If we preview our collection page now, we will see that we have correctly performed both the discount price calculations and the currency formatting. So now we can move to the second <a id="_idIndexMarker408"/>part of our project, which is replacing the <a id="_idIndexMarker409"/>sale badge with an actual percentage value discount.</p>
			<p>We can find the sale badge HTML code within the same <strong class="source-inline">collection-form.liquid</strong> snippet file:</p>
			<p class="source-code">{% if product.compare_at_price != blank %}</p>
			<p class="source-code">&lt;div class="custom-collection--item"&gt;</p>
			<p class="source-code">  &lt;a href="{{ product.url }}"&gt;</p>
			<p class="source-code">    &lt;img src="{{ product | img_url: "300x300" }}"/&gt;</p>
			<p class="source-code">    &lt;p class="custom-collection--price"&gt;</p>
			<p class="source-code">      {{ product.price | money }}</p>
			<p class="source-code">      {% assign discount-price = product.compare_at_price |             minus: product.price %}</p>
			<p class="source-code">      &lt;span&gt;Save {{ discount-price | money }}&lt;/span&gt;</p>
			<p class="source-code">    &lt;/p&gt;</p>
			<p class="source-code">    <strong class="bold">&lt;span class="custom-collection--sale-badge"&gt;sale&lt;/span&gt;</strong></p>
			<p class="source-code">  &lt;/a&gt;</p>
			<p class="source-code">  {% form "product", product %}</p>
			<p class="source-code">    &lt;input type="hidden" name="id" value="{{         product.first_available_variant.id }}" /&gt;</p>
			<p class="source-code">    &lt;input type="submit" value="Add to Cart"/&gt;</p>
			<p class="source-code">  {% endform %}</p>
			<p class="source-code">&lt;/div&gt;</p>
			<p class="source-code">{% endif %}</p>
			<p>To calculate the discounted percentage, we can use the following formula, which will return the discounted percentage:</p>
			<p class="source-code">{{ product.compare_at_price | minus: product.price | times: 100 | divided_by: product.compare_at_price }}</p>
			<p>In the previous example, we had to include the calculation inside a variable so that later we could <a id="_idIndexMarker410"/>apply the <strong class="source-inline">money</strong> filter. However, since this <a id="_idIndexMarker411"/>time we do not need money, we can simply include the calculation with the addition of the percentage string at the end. Let's put it all together now:</p>
			<p class="source-code">{% if product.compare_at_price != blank %}</p>
			<p class="source-code">&lt;div class="custom-collection--item"&gt;</p>
			<p class="source-code">  &lt;a href="{{ product.url }}"&gt;</p>
			<p class="source-code">    &lt;img src="{{ product | img_url: "300x300" }}"/&gt;</p>
			<p class="source-code">    &lt;p class="h4 custom-collection--title"&gt;{{ product.title         }}&lt;/p&gt;</p>
			<p class="source-code">    &lt;p class="custom-collection--price"&gt;</p>
			<p class="source-code">      {{ product.price | money }}</p>
			<p class="source-code">      {% assign discount-price = product.compare_at_price |             minus: product.price %}</p>
			<p class="source-code">      &lt;span&gt;Save {{ discount-price | money }}&lt;/span&gt;</p>
			<p class="source-code">    &lt;/p&gt;</p>
			<p class="source-code">    <strong class="bold">&lt;span class="custom-collection--sale-badge"&gt;{{ </strong>        <strong class="bold">product.compare_at_price | minus: product.price | </strong>                <strong class="bold">times: 100 | divided_by: product.compare_</strong>                        <strong class="bold">at_price }}%&lt;/span&gt;</strong></p>
			<p class="source-code">  &lt;/a&gt;</p>
			<p class="source-code">  {% form "product", product %}</p>
			<p class="source-code">    &lt;input type="hidden" name="id" value="{{         product.first_available_variant.id }}" /&gt;</p>
			<p class="source-code">    &lt;input type="submit" value="Add to Cart"/&gt;</p>
			<p class="source-code">  {% endform %}</p>
			<p class="source-code">&lt;/div&gt;</p>
			<p class="source-code">{% endif %}</p>
			<p>As we had the chance to see, similarly as with the string filters, we could chain multiple math filters easily to perform the calculations we needed. However, it is worth mentioning that besides only working with number values, math filters do not accept any type of brackets, which we would usually use to perform math calculations in specific priority.</p>
			<p>If we need <a id="_idIndexMarker412"/>to perform calculations, we have two choices. The first one is that we let Liquid perform math calculations from left to right. On the <a id="_idIndexMarker413"/>other hand, if we need to perform calculations in a specific order, we will need to split the formula into multiple variables and combine the results later.</p>
			<p class="callout-heading">Tip:</p>
			<p class="callout">For additional <a id="_idIndexMarker414"/>information on all the available math filters, we can refer to <a href="https://shopify.dev/docs/themes/liquid/reference/filters/math-filters">https://shopify.dev/docs/themes/liquid/reference/filters/math-filters</a>.</p>
			<p class="callout">For additional <a id="_idIndexMarker415"/>information on all the available money filters, we can refer to <a href="https://shopify.dev/docs/themes/liquid/reference/filters/money-filters">https://shopify.dev/docs/themes/liquid/reference/filters/money-filters</a>.</p>
			<p>While we have not covered all the math and money filter types, we have gained a solid understanding of how both math and money filters work through this project. This type of knowledge will serve as a stepping stone for the features that we will be working on as Shopify experts.</p>
			<h1 id="_idParaDest-108"><a id="_idTextAnchor107"/>Exploring the additional filters</h1>
			<p>The <strong class="bold">additional filters</strong> are a <a id="_idIndexMarker416"/>set of filters that do not fit under any <a id="_idIndexMarker417"/>other filter groups. However, this does not make them any less important. While there are many types of filters that we can name here, we will only mention three of them that are the most essential as we will be using them regularly.</p>
			<h2 id="_idParaDest-109"><a id="_idTextAnchor108"/>The default filter</h2>
			<p>As its name suggests, the <strong class="bold">default filter</strong> allows us to set a default value for any variable, whether it <a id="_idIndexMarker418"/>is a string, array, or hash type. Note that we can only return the default value if the variable returns <strong class="source-inline">nil</strong>, <strong class="source-inline">false</strong>, or an empty string. If the variable contains whitespace characters, we will not be able to return the <strong class="source-inline">default</strong> value:</p>
			<p class="source-code">Hello {{ customer.name | default: "customer" }}</p>
			<p>By introducing the <strong class="source-inline">default</strong> value in the previous example, we have ensured that we will not end up with a broken string even if the customer has not provided us with their name. Additionally, we also make our code look a lot cleaner. Without the <strong class="source-inline">default</strong> filter, we would have to use an <strong class="source-inline">if</strong> statement to check whether <strong class="source-inline">customer.name</strong> exists, and depending on the results, output the value.</p>
			<h2 id="_idParaDest-110"><a id="_idTextAnchor109"/>The t (translation) filter</h2>
			<p>The <strong class="bold">t filter</strong> is a translation <a id="_idIndexMarker419"/>key that allows us to access the currently active store language file under the <strong class="source-inline">Locales</strong> directory. If we navigate to the <strong class="source-inline">Locales</strong> directory, we will notice a large number of files. However, one of them will contain the string default, which is the currently active language in our store. </p>
			<p>Let's look over one of our previous projects, <strong class="source-inline">Custom collections</strong>, which we worked on in <a href="B17606_04_Final_PD_ePub.xhtml#_idTextAnchor079"><em class="italic">Chapter 4</em></a>, <em class="italic">Diving into Liquid Core with Objects</em>, in the <em class="italic">Working with global objects</em> section, where we developed a submit button whose value we hardcoded with the text <strong class="bold">Add to Cart</strong>. This works well for now, <em class="italic">but what if we changed our store language?</em> We would have to update any occurrence of the <strong class="bold">Add to Cart</strong> string manually for the entire theme. </p>
			<p>Using the <strong class="source-inline">t</strong> filter, we can update any string value through our entire theme by updating a single value. The first thing that we need to do is to define the three-level JSON inside the currently active language file using the Shopify naming and grouping guidelines. Since we are looking to modify the submit button of a product, we can set the first level to product, the second to something more specific, which is the form itself, and finally, the third level points to the string we are looking to translate:</p>
			<p class="source-code">{</p>
			<p class="source-code">  "product": {</p>
			<p class="source-code">    "form": {</p>
			<p class="source-code">      "submit": "Add to Cart"</p>
			<p class="source-code">    }</p>
			<p class="source-code">  }</p>
			<p class="source-code">}</p>
			<p>Once we have <a id="_idIndexMarker420"/>successfully created the JSON inside the language file, all that is left is to use the <strong class="source-inline">t</strong> filter to read the translated key value and render it on the storefront:</p>
			<p class="source-code">{{ product.form.submit | t }}</p>
			<p>By implementing a <strong class="source-inline">t</strong> filter on all product forms, we will gain the ability to automatically translate all the strings without having to search for them throughout our files manually. Additionally, using the same JSON naming and grouping inside the other language files will allow us to quickly translate our entire theme by simply changing the store language.</p>
			<p>The <strong class="source-inline">t</strong> filter is a powerful tool that allows us to pass multiple arguments by separating them with commas and interpolating them:</p>
			<p class="source-code">{{ header.general.customer | t: customer: customer.name }}</p>
			<p>In the previous example, we are trying to access the customer string inside the language file. However, we have also passed the <strong class="source-inline">customer.name</strong> value as an argument, which we have then interpolated inside the language JSON file:</p>
			<p class="source-code">{</p>
			<p class="source-code">  "header": {</p>
			<p class="source-code">    "general": {</p>
			<p class="source-code">      "customer": "Welcome {{ customer }}!"</p>
			<p class="source-code">    }</p>
			<p class="source-code">  }</p>
			<p class="source-code">}</p>
			<p>Besides providing <a id="_idIndexMarker421"/>us with the ability to interpolate the variables, we can also escape the translated content, include the HTML in translation keys, and pluralize translation keys, making it a pretty powerful tool at our disposal.</p>
			<p class="callout-heading">Tip:</p>
			<p class="callout">For additional <a id="_idIndexMarker422"/>information on the <strong class="source-inline">t</strong> filter naming and grouping guidelines, we can refer to <a href="https://shopify.dev/tutorials/develop-theme-localization-organize-translation-keys">https://shopify.dev/tutorials/develop-theme-localization-organize-translation-keys</a>.</p>
			<p class="callout">For additional information on all the available arguments for the <strong class="source-inline">t</strong> filter, we can refer to <a href="https://shopify.dev/tutorials/develop-theme-localization-use-translation-keys">https://shopify.dev/tutorials/develop-theme-localization-use-translation-keys</a>.</p>
			<p>Once we have created the necessary translation keys, we can also update the translation by navigating to our admin page and clicking on <strong class="bold">Themes</strong> located inside the expanded <strong class="bold">Online store</strong> option within the sidebar. Clicking on the <strong class="bold">Actions</strong> button on the theme file will trigger a dropdown, whereby clicking on <strong class="bold">Edit Language</strong> will quickly update any translation inside the language JSON file.</p>
			<h2 id="_idParaDest-111"><a id="_idTextAnchor110"/>The JSON filter</h2>
			<p>The JSON filter, as its <a id="_idIndexMarker423"/>name suggests, allows us to convert strings into JSON, and more importantly, will make Liquid code readable by JavaScript:</p>
			<p class="source-code">var product_JSON = {{ product | json }};</p>
			<p class="source-code">var cart_JSON = {{ cart | json }};</p>
			<p>Note that when using the JSON filter on Liquid output, there is no need to include quotations marks, as the JSON filter will include them automatically. However, note that specific values, such as the <strong class="source-inline">inventory_quantity</strong> and <strong class="source-inline">inventory_policy</strong> fields, are not something that we can return via JSON, as Shopify has deprecated these fields due to security reasons.</p>
			<p class="callout-heading">Tip:</p>
			<p class="callout">For additional <a id="_idIndexMarker424"/>information on all the available additional filters, we can refer to <a href="https://shopify.dev/docs/themes/liquid/reference/filters/additional-filters">https://shopify.dev/docs/themes/liquid/reference/filters/additional-filters</a>.</p>
			<h1 id="_idParaDest-112"><a id="_idTextAnchor111"/>Summary</h1>
			<p>In this chapter, we have learned how using something trivial such as a filter to manipulate different data types can create powerful features. We have learned how using URL and HTML filters can provide us with access to the various types of assets throughout Shopify and help us generate them in the storefront using their respective HTML tags.</p>
			<p>Working on the product media gallery project has provided us with a deeper understanding of media objects and filters, which every developer needs to be familiar with. The product accordions project taught us how to easily manipulate data using string and array filters to create unique page content elements that are clean and easily maintainable. Moving on to the math and money filters, we have gained much-needed insight into performing complex calculations through Shopify and formatting the prices according to the currency formatting set in our store.</p>
			<p>Lastly, we learned about the additional filters, which provided us with essential knowledge on how we can assign default value variables with no assigned values and make Liquid code readable by JavaScript. By understanding how to use the translation keys, we now have the necessary knowledge to quickly update any value across our theme without manually updating each value.</p>
			<p>The knowledge that we have attained through this chapter will be especially helpful in the next chapter, where we will learn more about the JSON settings and how we can use them to create settings that merchants can access using the theme editor.</p>
			<h1 id="_idParaDest-113"><a id="_idTextAnchor112"/>Questions</h1>
			<ol>
				<li value="1">Suppose that we have an array named <strong class="source-inline">product_handles</strong> with handles of 30 products. What issue in the following code would prevent us from outputting the images of all 30 products successfully?<p class="source-code">{% for handle in product_handles %}</p><p class="source-code">  {% assign product_object = all_products[handle] %}</p><p class="source-code">  {% for image_item in product_object.images %}</p><p class="source-code">    &lt;img src="{{ image_item | img_url }}"/&gt;</p><p class="source-code">  {% endfor %}</p><p class="source-code">{% endfor %}</p></li>
				<li>Why is only using the <strong class="source-inline">model_viewer_tag</strong> tag not recommended when creating the product media gallery?<p class="source-code">{% for media in product_object.media %}</p><p class="source-code">  {% case media.media_type %}</p><p class="source-code">    {{ media | model_viewer_tag }}</p><p class="source-code">  {% endcase %}</p><p class="source-code">{% endfor %}</p></li>
				<li>Which filter could we use if we were looking to access an item at a specific location inside the array?</li>
				<li>What filter can we use to quickly update any occurrence of a string value inside the theme files?</li>
			</ol>
			<h1 id="_idParaDest-114"><a id="_idTextAnchor113"/>Practice makes perfect</h1>
			<h2 id="_idParaDest-115"><a id="_idTextAnchor114"/>Project 3</h2>
			<p>In one of our previous exercises, we learned how to create basic and complex product galleries by outputting all types of product media types. <em class="italic">However, what if we only needed to output several images related to the specific variant at a time?</em></p>
			<p>For our third project, we will be working on rendering a product media gallery with distinctive markings that will allow us to show only the thumbnails of the currently selected variant. </p>
			<p>Here are the instructions for the assets:</p>
			<ol>
				<li value="1">Create a new page template using the name <strong class="source-inline">variant-thumbnails.liquid</strong>.</li>
				<li>Create a new page named <strong class="source-inline">Product Variant Thumbnails</strong>.</li>
				<li>Create a new layout file with the name <strong class="source-inline">alternate.liquid</strong>.</li>
				<li>Create a new product with at least three color variants and upload at least three media assets to represent each variant. When creating a new product, we should set the product status to Active and not leave it to Draft. Otherwise, we will not be able to access it later.</li>
				<li>Create two new asset files, a stylesheet with the name <strong class="source-inline">custom.css</strong> and a script file with the name <strong class="source-inline">script.js</strong>.</li>
				<li>Create a new snippet file with the name <strong class="source-inline">custom-media</strong>.</li>
			</ol>
			<p>The following are the steps for the assignment:</p>
			<ol>
				<li value="1">Edit the new layout file by including two asset files that we have previously used throughout this project.</li>
				<li>Include the layout file to the previously created page template and assign the new page template to the newly created page.</li>
				<li>Navigate to the <strong class="bold">Products</strong> section inside the admin page, find the product that we have previously created, and edit the alt text of each image to include the name of the variant in lowercase and the actual image alt text, all separated with an underscore. For example, <strong class="source-inline">red_This</strong> is an image description. Repeat the process for all images. Note that each variant should have at least three images to it.</li>
				<li>Inside <strong class="source-inline">variant-thumbnails.liquid</strong>, create a variable that we will use to access the previously created product object using the product handle.</li>
				<li>Using a <strong class="source-inline">for</strong> loop, access the product media object, and pass the media object inside the <strong class="source-inline">custom-media</strong> snippet as a parameter.</li>
				<li>Inside the snippet, using the case-control flow tag and the object that we have passed as a parameter, create code that will output each media file type.</li>
				<li>Edit each <strong class="source-inline">media</strong> tag to include three attributes. The first one, <strong class="source-inline">data-variant</strong>, will contain the first part of the media alt text before the underscore. The second attribute, <strong class="source-inline">alt</strong>, will contain the second part of the media alt text. Finally, the third attribute, named <strong class="source-inline">index</strong>, will contain the index position value of the media file. If we are having trouble calling the <strong class="source-inline">forloop</strong> object's index value directly inside the snippet, we might want to pass it as a parameter through the snippet.</li>
			</ol>
			<p>With the attributes in place, we should have all the necessary elements needed to filter out product media files and only display the thumbnails related to the currently selected color variant using the <strong class="source-inline">data-variant</strong> attribute value.</p>
			<p>For those looking to finalize the project, follow these steps:</p>
			<ol>
				<li value="1">Apply the necessary styling inside <strong class="source-inline">custom.css</strong> and the necessary script inside <strong class="source-inline">script.js</strong> that will hide or display only the media files with the correct <strong class="source-inline">data-attribute</strong> value.</li>
				<li>Additionally, we can create a new <strong class="source-inline">for</strong> loop that will serve as a primary media gallery.</li>
				<li>Include any type of slider plugin, such as a Slick slider, and connect it to the primary media gallery.</li>
				<li>Clicking on the thumbnail media asset should automatically make the primary slider scroll to the selected asset.</li>
			</ol>
		</div>
	</div></body></html>