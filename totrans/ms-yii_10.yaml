- en: Chapter 10. Testing with Codeception
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'An important but often overlooked aspect of software development is testing
    our application to ensure that it performs as expected. There are three basic
    ways in which we can test our applications:'
  prefs: []
  type: TYPE_NORMAL
- en: Unit testing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Functional testing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Acceptance testing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Unit testing** enables us to test individual sections of code before coupling
    it with our application. **Functional testing** allows us to test the functional
    aspects of code within a simulated browser, and **acceptance testing** allows
    us to test our application within a real browser and verify that it does what
    we built it to do. With Yii2, we can use a tool called Codeception to create and
    execute unit, functional, and acceptance testing for our application. In this
    chapter, we''ll cover how to create and run unit, functional, and acceptance testing
    in Yii2\. In addition to these three types of testing, we can mock our data using
    fixtures, which we can use to bring our application to a fixed state before testing.'
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As we work through this chapter, we'll be using much of the code from previous
    chapters. For your convenience, the source code for this chapter is provided on
    GitHub at [https://github.com/masteringyii/chapter10](https://github.com/masteringyii/chapter10)
    and is broken into three distinct branches. We'll use the `unit` branch in the
    unit testing section, the `functional_and_acceptance` branch in the functional
    and acceptance testing section, and the `fixture` branch in the fixtures section.
  prefs: []
  type: TYPE_NORMAL
- en: Reasons for testing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Most software developers will admit that testing is a good thing, but many
    developers don''t write tests for their application for a variety of reasons,
    such as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: The fear of testing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Not knowing how to write tests
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Thinking that their application is too small for testing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Not having enough time
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Budgetary reasons
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'While many of these reasons are valid, testing can have a profound effect on
    your application and can drastically improve the quality of your code. The following
    list provides several reasons why tests should be added to your codebase:'
  prefs: []
  type: TYPE_NORMAL
- en: Testing can reduce bugs as new features are added
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Testing verifies that your code does what you think it does
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Testing verifies that your code does what your client wants
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Features can be constrained by testing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Testing forces us to slow down and break our applications into small, manageable
    components with constraining features
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Testing reduces the cost of change by ensuring that a change to a single feature
    doesn't break another feature
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Testing provides documentation of what our code is supposed to do
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Testing reduces the fear that a change will break something in our application
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to approach testing
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There are many factors that go into modern development, costs and development
    time being the chief among them. There are several realistic approaches that we
    can take for testing in order to work around these constraints.
  prefs: []
  type: TYPE_NORMAL
- en: Testing manually
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The most rudimentary approach to testing we can take is to test manually as
    we're writing code. Whether you realize it or not, every time you make a code
    change and reload your browser, you're testing your code. At a cursory glance,
    manual testing lets us verify new features and bug fixes that are working, but
    it requires us to manually verify the state of our applications after every change.
    Furthermore, manual testing requires us to remember every test case we've created.
    Automated testing with a tool such as Codeception can reduce this cognitive burden
    and free up our time to perform other tasks.
  prefs: []
  type: TYPE_NORMAL
- en: Testing a few core components
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A better approach to testing is to automate the testing of just the core components
    of our applications. With this approach, we add tests for only the critical paths
    in our application, which enables us to verify the important bits of our application
    at the cost of reduced tests elsewhere. In situations where time and budget are
    constrained but you want to automate the verification of important flows and paths,
    this approach is a realistic alternative to no testing whatsoever.
  prefs: []
  type: TYPE_NORMAL
- en: Test-driven development
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Test-driven development** (**TDD**) is the philosophy that we should create
    tests for our application as we''re building it. The primary idea behind TDD is
    that we can verify that our code is working by writing a test for it beforehand.
    With TDD, we generally write a test beforehand (which will fail), then we write
    code in order to make it pass the test, and then we continuously iterate between
    tests and code until our feature is completed and our test passes. TDD also forces
    us to ensure that we write usable code by passing tests before checking it into
    our versioning system, which then encourages us to write good tests.'
  prefs: []
  type: TYPE_NORMAL
- en: With TDD, our goal is to have a test for every feature and component and have
    many tests that thoroughly cover our application. In an ideal world, TDD is the
    best approach to take when working with testing at the cost of requiring more
    time and budget to implement.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring Codeception with Yii2
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Before we can use Codeception to test our code, we first need to configure
    Codeception to work with Yii2:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The preferred way to set up Codeception with Yii2 is to install both the `yii2-codeception`
    package and the Codeception base package via Composer:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: The `--dev` flag on our composer command ensures that development packages are
    not installed in our production environment. Packages installed with `–dev` will
    be added to the `require-dev` section of our `composer.json` file. Storing Codeception
    and other testing code reduces the dependencies we need in production and makes
    our code more secure.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The first package contains the Codeception binary that we'll use to generate
    and execute our tests, while the second package contains Yii2-specific helpers
    and bindings that Codeception will use to tightly integrate into Yii2.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: This process may take a long time as Codeception is dependent upon many different
    packages, including PHPUnit.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'After installing Codeception, we can execute the command by running the following
    command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: By itself, `codecept` will output all the available commands that Codeception
    has to offer.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Configuring Codeception with Yii2](img/00040.jpeg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: 'After verifying that Codeception is installed, we need to bootstrap Codeception
    by running the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '![Configuring Codeception with Yii2](img/00041.jpeg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: The bootstrap process will create several files. The first file is called `codeception.yml`
    and lives within the root of our application. The remaining files exist within
    the `tests` folder and will be the directory to which we add our `tests`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Next, we need to configure Codeception to work with the Yii2 Codeception module
    in our `codeception.yml` file. The required additions are highlighted in the following
    code block:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Additionally, we need to tell Codeception to autoload our composer dependencies
    and Yii2\. We can do this by updating the `tests/_bootstrap.php` file. To ensure
    that we test our application in a manner similar to our `web/index.php` loads
    data, we should add the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'With Codeception now configured, we can run all of our tests by running the
    following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The run command will output the following:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Configuring Codeception with Yii2](img/00042.jpeg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: Unit testing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The most basic type of tests we can create are called unit tests. As the name
    suggests, **unit tests** are designed to test a unit of work (whether that be
    a single method, function, or a larger work unit), and then check a single assumption
    about that unit of work. A good unit test will be composed of the following components:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Fully automated**: A good unit test is a test that can be fully automated
    without human intervention.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Thorough**: Thorough unit tests provide good coverage of the code block they
    are testing.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Independent**: Good unit tests can be run in any order, and their output
    should have no effect or side effect on other tests that occur. Furthermore, each
    unit test should only test a single logical unit of code. Tests that fail should
    pinpoint the exact section of code that failed.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Consistent and repeatable**: Unit tests should always produce the same result
    and should be dependent upon static data as opposed to generated or random data.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Fast**: Unit tests need to execute quickly. Long tests mean that fewer tests
    will be run in a given amount of time, and tests that take too long to execute
    will encourage developers to either write fewer tests or skip writing tests altogether.
    As unit tests are intended to test small individual units of code, long-running
    tests can also be an indicator of a bad or incomplete test.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Readable**: Good unit tests should be readable and should be either self-explanatory
    or thoroughly documented if they require additional explanation.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Maintainable**: Finally, good unit tests should be maintainable. A test we
    don''t maintain is a test that we don''t use or work with.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this section, we'll be using the source code in the `unit` branch located
    at [https://github.com/masteringyii/chapter10](https://github.com/masteringyii/chapter10).
  prefs: []
  type: TYPE_NORMAL
- en: Generating unit tests
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If you're familiar with PHPUnit, writing tests in Codeception should feel very
    familiar. For unit testing, Codeception can generate a PHPUnit-like test, but
    it can also generate a Codeception-specific unit test that doesn't require PHPUnit
    to execute.
  prefs: []
  type: TYPE_NORMAL
- en: 'To generate PHPUnit-specific tests, we can run the following command, which
    will generate a PHPUnit unit test called `Example`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Alternatively, we can generate a Codeception-specific test called `Example`
    by running the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Unless you have a specific need for PHPUnit-like tests, Codeception unit tests
    should be preferred.
  prefs: []
  type: TYPE_NORMAL
- en: 'After generating our Codeception test, a file called `tests/unit/ExampleTest.php`
    will be generated, and it will contain the following code. Before we start writing
    unit tests for our application, let''s explore the basic structure of a Codeception
    unit test class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: By default, our Codeception unit tests will extend `\Codeception\TestCase\Test`,
    and will implement two protected methods (`_before()` and `_after()`) and a protected
    property called `$tester` for Codeception to use internally. The `_before()` and
    `_after()` methods are intended to set up and tear down tasks that execute immediately
    before and after each of our predefined tests within our class.
  prefs: []
  type: TYPE_NORMAL
- en: 'After the `_before()` and `_after()` methods, we have all of the tests that
    we want to run. In general, any test that we want to run should be in a public
    method with a method name prefix of `test`. Any public method with this signature
    will be executed as a test. As a brief example, let''s modify our `testMe()` method
    to make a simple assertion (a statement of whether a given predicate (a function,
    method, or variable) evaluates to a boolean value which we can verify is true):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Using this simple assertion as an example, we can verify our tests run by running
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Alternatively, we can just run our unit tests by running the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: '![Generating unit tests](img/00043.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'As you can see from the previous screenshot, our unit test case executed successfully.
    We can add extra unit tests by defining additional test methods, as shown in the
    following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Running a second test will then show up in our Codeception output.
  prefs: []
  type: TYPE_NORMAL
- en: '![Generating unit tests](img/00044.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Unit test examples
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now that we know the basics of unit testing with Codeception, let's explore
    a couple of examples we can test within applications we've built previously. Starting
    with the source code we developed in [Chapter 9](part0052_split_000.html#1HIT82-ad3e09b384df46aea690d9c8897d5fe7
    "Chapter 9. RESTful APIs"), *RESTful APIs*, let's write a few unit tests for our
    models.
  prefs: []
  type: TYPE_NORMAL
- en: Testing User model methods
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Our User model is a significant part of our application. Since we''ve added
    both custom code and custom validators, we can write unit tests to verify that
    our validators are accurate and that our custom code works as expected. To get
    started, let''s create a new unit test for our User model:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Since we''re testing our User model, we need to explicitly specify that we
    want to use that model within our test:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, let''s define a method to test that our `app\models\User::setFullName()`
    method works:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: After executing our tests, we can verify our newly passed test case by viewing
    the output.![Testing User model methods](img/00045.jpeg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: The test cases illustrated here are very rudimentary. Try expanding upon this
    test case to ensure complete code coverage of this method.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Let''s write another test to the `app\models\User::validatePassword()` method
    that correctly validates the password of an existing user:'
  prefs: []
  type: TYPE_NORMAL
- en: 'For this test case, we''ll be relying upon the data supplied by our migrations.
    Before creating the test, ensure that you migrate the database:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, we''ll add a test case that will load our four default users and verify
    that their passwords match, as we expect:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: In this case, information about our users is being loaded from our migrations,
    which in some cases makes sense if we want to provide our end users with sensible
    defaults. Later on in this chapter, we'll explore how we can use fixtures to create
    and populate defaults for testing, which will eliminate the need to have these
    defaults as part of our migration file.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: After running our unit tests, we should see the following output:![Testing User
    model methods](img/00046.jpeg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Note how in the previous test case, we tested both the expected result and the
    several results that we were expecting to fail. An important part of unit testing
    is verifying that both the expected passing cases pass and invalid or wrong input
    is not accepted. This ensures that our application does what we want, while not
    allowing rogue or bad inputs to be accepted.
  prefs: []
  type: TYPE_NORMAL
- en: 'Have you gotten the hang of unit testing yet? Before moving on to functional
    testing, let''s write a test case to verify that our validators are working:'
  prefs: []
  type: TYPE_NORMAL
- en: Since the validator for our `User` model validates several different attributes,
    we're going check whether our `app\models\User::validate()` method returns the
    expected `true` or `false` result and whether the appropriate validator is called.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'To make our test output more readable, we can include the `codeception/specify`
    composer module in our project, which will allow us to specify what the expected
    result for each test section in the output of our tests is in the event that a
    test fails. This package can be installed by running the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'To use `specify`, we need to use it inside our `UserTest` class, as shown in
    the following example:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`specify` can then be used as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now if we run our test case, we should see the following output indicate specifically
    that our "false is false" test case has failed:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now that we know how to use the specify module, let''s write several test cases
    for our validator:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: After running our unit tests, we should see the following output, indicating
    that our tests have passed. If our tests fail at any point, the specify module
    will output the first parameter, indicating what specific part of the test failed.
    As our test passes, we will see the following output:![Testing User model methods](img/00047.jpeg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: Yii2 already has a test case for `yii\db\ActiveRecord::validate()`. Adding our
    own test case isn't to verify that this method works but rather to verify that
    we have the correct validators in place.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: For more information on the specify module, refer to [https://github.com/Codeception/Specify](https://github.com/Codeception/Specify).
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Functional testing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The next type of tests that we can generate are called functional tests. **Functional
    tests** allow us to emulate our application without running it through a web server.
    This provides us with a way to quickly test the output of our application without
    introducing the overhead of a web server.
  prefs: []
  type: TYPE_NORMAL
- en: This emulation process is achieved by directly manipulating the `$_REQUEST`,
    `$_POST`, and `$_GET` parameters before executing our application. As a side effect
    of this behavior, however, certain variables, such as `$_SESSION` and `$_COOKIE`,
    as well as headers, can result in `junk` errors being thrown, which wouldn't necessarily
    be thrown in a real environment. Moreover, with Codeception, our functional tests
    will be executing within a single memory container, which may result in a test
    failing when run as part of a group as opposed to running a single test. Additionally,
    unlike acceptance testing, functional testing can't emulate JavaScript and Ajax
    requests.
  prefs: []
  type: TYPE_NORMAL
- en: Overall, functional testing provides us with a fast and easy way to prove that
    the output of our code does both what we programmed it to do and what our end
    users and customers expect it to do. Despite the minor issues functional testing
    brings up, at a high level, the report it provides can give us confidence that
    our code works as expected and that future changes in our codebase won't change
    our application significantly. In this section, we'll go over how to generate
    and run functional tests within our application.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this section, we'll be using the source code in the `functional_and_acceptance`
    branch located at [https://github.com/masteringyii/chapter10](https://github.com/masteringyii/chapter10).
  prefs: []
  type: TYPE_NORMAL
- en: Setting up functional tests
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Since functional testing and API don''t really make sense, we''ll be writing
    our functional tests using the code we wrote earlier in [Chapter 6](part0039_split_000.html#1565U2-ad3e09b384df46aea690d9c8897d5fe7
    "Chapter 6. Asset Management"), *Asset Management*, as the code outlined in that
    chapter has several good components we can test. Functional tests behave quite
    differently from unit tests, so before we can start writing test code, we need
    to make a few changes to our test configuration:'
  prefs: []
  type: TYPE_NORMAL
- en: 'To get started with functional tests, we first need to make sure that Codeception
    is initially installed and configured. This process is identical to what we performed
    in the previous section:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Install the required composer dependencies:'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: 'Install Bootstrap Codeception:'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: 'Add the required configuration to `tests/_bootstrap.php`. Note that because
    we''re emulating a complete request flow, we need to prepopulate several variables,
    such as `$_SERVER[''SCRIPT_FILENAME'']` and `$_SERVER[''SCRIPT_NAME'']`. The relevant
    sections are highlighted as follows:'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: 'Verify that Codeception is running:'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: 'The first change we need to make is the inclusion of the Yii2 Codeception module.
    This module will enable us to take advantage of Yii2-specific bindings within
    our test that will help us test our Yii2 application better. Rather than enabling
    our module for all of our test types, we can just enable it for our functional
    tests by adding the following to `tests/functional.suite.yml`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, we need to disable cross-site request forgery (CSRF) validation on our
    forms. Rather than making a global configuration change to our `config/web.php`
    file, we can create a custom configuration in `tests/config/functional.php` that
    includes our `config/web.php` file and disables CSRF validation in that file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, we need to enable our Yii2 module. To enable a new module in Codeception,
    we simply need to run the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '![Setting up functional tests](img/00048.jpeg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: 'Finally, we can execute the run command of Codeception to verify that our changes
    took place:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: If successful, we should see output similar to what is shown in the following
    figure:![Setting up functional tests](img/00049.jpeg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Generating functional tests
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Unlike unit tests, functional tests are not executed within a generated class.
    Instead, they run within a plain PHP file within the `tests/functional` folder.
    To get started with generating functional tests, we need to use the `generate:cept`
    command once again:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Our functional test will then be generated in `tests/functional/PageCept.php`
    and will contain the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Now if we execute our tests again, we should see the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Generating functional tests](img/00050.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Examples of functional tests
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now that we know how to generate functional tests, let''s explore a few examples
    of functional testing. If you remember from [Chapter 6](part0039_split_000.html#1565U2-ad3e09b384df46aea690d9c8897d5fe7
    "Chapter 6. Asset Management"), *Asset Management*, our home page looks as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Examples of functional tests](img/00051.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Let''s write a quick functional test to verify that our home page loads and
    contains the elements we see on screen:'
  prefs: []
  type: TYPE_NORMAL
- en: 'With Yii2''s Codeception binding, we have several ways to navigate to and load
    the data from a page. Within our `tests/functional/PageCept.php` test, we can
    write the following to verify that the home page loads. We can do this using the
    `FunctionalTester::amOnPage()` method, which verifies that `FunctionalTester`
    was able to access the given page:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: As you can see, we can load the home page either by querying the root URI or
    the `site/index` action either as a string or an array. If we use the array syntax,
    we can pass additional parameters to our page as GET parameters.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now that we''ve verified that we''re on the home page, let''s verify that the
    `''Now you''re thinking with widgets!''` string is displayed. With Codeception,
    this is exceptionally easy with the following line of code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We can additionally verify that the `''Home''`, `''Register''`, and `''Login''`
    link text is displayed using the `FunctionalTester::see()` method, which scans
    the requested document for the presence of the provided text:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now let''s run our functional tests. As an alternative to running both our
    unit and acceptance tests with every run, we can just run our functional tests
    by specifying the test type we want to run, as shown in the following example:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '![Examples of functional tests](img/00052.jpeg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: Tip
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Even though we''re running several different tests, Codeception will only report
    a pass or fail result for the entire test file we created. To gain more insight
    into what Codeception is doing, we can tell Codeception to be more verbose by
    passing the "-v" flag to our command. Additional verbosity can be added by adding
    more "v" flags to our verbose flag (for example, "-vv" or even "-vvv"):'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '![Examples of functional tests](img/00053.jpeg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: 'Since we''re creating a new test, we should first create a new functional test
    file for us to work with. Running the following command will generate a test file
    at `tests/functional/LoginCept.php`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'First, let''s write a test to verify that we can click on the "Login" link
    on our home page and navigate to our login page:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'After verifying that our tests pass, we can verify that the form is present
    and that there aren''t any errors using the `seeElement()` and `dontSeeElement()`
    methods:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then, after verifying that we can see the form elements on the page, let''s
    test whether our form works by first submitting an invalid username and password
    and then submitting a valid username and password combination:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now let''s run our Login test. We can run this test independently of all other
    tests by calling it directly, as shown in the following example:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: As shown in the following screenshot, our functional test iterates through all
    of our test and verifies that the login form flow works as expected:![Examples
    of functional tests](img/00054.jpeg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The Yii2 module provides several methods that can be used when running both
    functional and unit tests. For a complete list of the methods provided by the
    Yii2 Codeception module, ensure that you refer to the Yii2 Codeception module
    page at [http://codeception.com/docs/modules/Yii2](http://codeception.com/docs/modules/Yii2).
  prefs: []
  type: TYPE_NORMAL
- en: Acceptance testing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The last type of testing we can automate with Codeception is called acceptance
    testing. It is very similar to functional testing, with the exception that your
    application is tested using a real browser rather than a simulated one. This gives
    the advantage of being able to completely simulate end user behavior. Acceptance
    testing doesn't have many of the limitations of functional testing, such as memory
    limitations, `$_COOKIE`, `$_SESSION`, and header limitations. Moreover, acceptance
    testing can be done by anyone on your team, as what is tested using acceptance
    testing replicates the work you would do to test manually. In fact, one of the
    only downsides of running acceptance tests is that due to the entire browser flow,
    acceptance tests can be extremely slow for specific tests. In this section, we'll
    cover how to set up and run acceptance testing with Codeception.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this section, we'll be using the source code on the `functional_and_acceptance`
    branch located at [https://github.com/masteringyii/chapter10](https://github.com/masteringyii/chapter10).
  prefs: []
  type: TYPE_NORMAL
- en: Setting up acceptance testing
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Like functional testing, acceptance testing requires some setup in order to
    get working with Yii2:'
  prefs: []
  type: TYPE_NORMAL
- en: 'To get started, we first need to specify the browser we want to use. In our
    case, we''ll be using a combination of PHP and browser. To do this, we first need
    to add the following to our `tests/acceptance.suite.yml` file. Additionally, since
    we want to take advantage of Yii2-specific plugins, we''ll enable the Yii2 module
    as well:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: 'If we want to use a real browser, we can do that by enabling the WebDriver
    module by adding the following to our `modules:enabled` section:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, we need to rebuild our tests to include the added modules:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then, we need to configure our `tests/acceptance/_bootstrap.php` file so that
    we can load our Yii2 app in our tests. Fortunately, this is more or less the same
    as our functional test bootstrap file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, we need to define our `tests/config/acceptance.php` file as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then, we need to generate our first acceptance test using the `generate:cept`
    command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Finally, we can run our newly created test by running the run command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '![Setting up acceptance testing](img/00055.jpeg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: Tip
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: Note that we're passing the required `APPLICATION_ENV` variable to our built-in
    server. Additionally, we're using a `8082` high port, as defined previously in
    our `tests/acceptance.suite.yml` file. The high port number is to avoid the need
    to run PHP's built-in server with root access, which is required for ports under
    `1024`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Examples of acceptance tests
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Since acceptance tests are extremely similar to functional tests, we can reuse
    a lot of the same tools and methods we used in the previous section. For instance,
    we can write an acceptance test to check the home page for the links and text
    we looked for earlier in our functional tests, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that the only substantial difference here is the usage of `AcceptanceTester`
    instead of `FunctionalTester`. Running our tests in the verbose mode now will
    reveal the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: '![Examples of acceptance tests](img/00056.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Fixtures
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The last testing component we'll talk about in this chapter is fixtures. **Fixtures**
    are an important part of testing as they enable us to set up our application state
    to a known and precise state before running our unit tests. Unlike these other
    test types, however, fixtures are provided directly by Yii2 and integrate into
    Codeception via the Yii2 Codeception module.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this section, we'll be using the source code on the `fixtures` branch located
    at [https://github.com/masteringyii/chapter10](https://github.com/masteringyii/chapter10).
  prefs: []
  type: TYPE_NORMAL
- en: Creating fixtures
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To get started with using fixtures, we first need to install the required composer
    dependencies and then add some configuration to our `config/console.php` file:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we need to make sure that the `yii2-faker composer` package is installed:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Alternatively, the `yii2-faker` extension can be installed by adding the following
    to the `require-dev` section of `composer.json` and then by executing `composer
    update`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then, we need to add the relevant section to our console configuration file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Finally, we need to define a configuration file for our unit tests to load
    from `tests/config/unit.php`. To keep things simple, we''ll just load our web
    configuration file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'With the required extension installed, we can create and load fixtures into
    our app via the `./yii` command-line tool:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: '![Creating fixtures](img/00057.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Defining fixtures
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To define new fixtures, we can either extend `yii\test\Fixture` (for general
    fixtures) or `yii\test\ActiveFixture` (for ActiveRecord entries) and place our
    newly created classes in the `tests/fixtures` folder of our application. After
    defining a new fixture, we''ll then want to declare the model class we''ll want
    to use for fixtures. As an example, let''s create a fixture of our `app\models\User`
    class, as shown in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that we''ve defined our fixture class, we need to create the data that
    our fixture will populate. When using `yii\test\ActiveFixture`, we''ll want to
    place our data files in `@tests/fixtures/data/<database_table_name>.php` or `@tests/fixtures/data/user.php`,
    in our case. In this fixture file, we''ll provide all the required mock data that
    we want to test against:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'Our fixtures can be loaded by calling the `fixture` command with the appropriate
    namespace:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'Fixtures can then be unloaded using the `fixture/unload` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'By default, Yii2 will try to load our fixtures from the `@app/tests/unit/fixtures`
    folder. In the previous examples, we overwrote this behavior by supplying the
    `--namespace` parameter. To avoid having to write this each time, we can modify
    our console configuration file as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: With this change, we can load and unload our fixtures without the need to specify
    a namespace.
  prefs: []
  type: TYPE_NORMAL
- en: Using fixtures in unit tests
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now that we know how to create and load fixtures, let''s explore how to load
    them as part of our tests. To get started with testing with fixtures, we first
    need to create a new unit test for our fixtures to run in. As a reminder, new
    unit tests in Codeception can be generated as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: 'After creating our unit test, we need to modify our newly created `UserFixtureTest`
    in `tests/unit/UnitFixtureTest.php` with several changes:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we need to properly namespace our test and include our `UserFixture`
    class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, we need to have our `UserFixtureTest` extend `\yii\codeception\DbTestCase`
    and include the unit test configuration file that we created previously:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Finally, we need to tell our test case to load our `UserFixture` class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, after every test we create within our newly created `UserFixtureTest`
    class, our previously created fixtures will be loaded into our database before
    each test and then removed after the test is complete. For instance, we can create
    the following test to verify that password verification works:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: 'Our newly created tests and fixtures can then be run with the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: '![Using fixtures in unit tests](img/00058.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: At the beginning of this test, our fixtures will be loaded, and then our tests
    will run. After our test runs, our fixtures will be unloaded, and then we can
    run another test. The use of fixtures in this case prevents the results of one
    test from affecting the results of another.
  prefs: []
  type: TYPE_NORMAL
- en: Automatic change testing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: An important aspect of testing is ensuring that your tests are run regularly
    and often. If you're following the test-driven development philosophy, you should
    be writing your tests before writing code and adapting your tests as new code
    is added. While this will give you a good idea of what is working and what isn't,
    it can be extremely time-consuming, and it doesn't cover cases where team members
    make changes but either don't write tests or don't run them before committing
    and pushing them to your DCVS repository.
  prefs: []
  type: TYPE_NORMAL
- en: The best way to ensure that your tests are run after every change is to use
    a third-party service, such as Travis CI. A tool such as Travis CI will add a
    webbook to your repository, and after every commit, it can be configured to run
    all your tests and notify you if and when your tests ever start failing.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In general, you should always verify that your code runs and that your tests
    pass before committing it to your repository.
  prefs: []
  type: TYPE_NORMAL
- en: 'Using Travis CI as an example, let''s add our repository to Travis CI and enable
    automated builds:'
  prefs: []
  type: TYPE_NORMAL
- en: To get started with Travis CI, we first need to log in to [https://travis-ci.org](https://travis-ci.org)
    with our GitHub account and then navigate to our profile at [https://travis-ci.org/profile](https://travis-ci.org/profile).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: Travis CI has tight coupling with GitHub and does not work with other services,
    such as GitLab or Bitbucket. The service is free only for public repositories.
    There are many other services, however, that can perform the same service as Travis
    CI, such as Atlassian Bamboo, drone.io, circleci.com, GitLab CI, and others. Before
    using a continuous integration tool, ensure that you do your research to determine
    what is best for your team. For projects that you don't mind being public, Travis
    CI provides a good free option.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: After navigating to your profile, you need to enable Travis CI for your repository.
    Thanks to the tight coupling Travis CI has with GitHub, this is as simple as toggling
    a single switch.![Automatic change testing](img/00059.jpeg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'After establishing your connection to Travis CI, you need to create a `.travis.yml`
    file in your repository. This file contains instructions on how to build and test
    your project. While there are many different possible configurations and matrices
    that Travis CI can work with, we''ll be using a relatively simple one, as shown
    in the next section:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Our `.travis.yml` file contains several sections:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `language` section defines what language we want to use when Travis CI runs
    our build.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The `cache` option exists simply to speed up our build and test process. At
    the end of each successful build, Travis CI will cache the contents of our `vendor/folder`,
    which will reduce the time it takes for Composer to install all the required dependencies.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The `php` section lists all the PHP versions we want to test against. Generally,
    we want to test against the current and next versions of PHP so that when that
    version comes out, we're ready to start using it. Testing against future versions
    of PHP allows us to quickly adapt our code to take advantage of new performance
    enhancements of new PHP versions.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The `install` section allows us to define software that needs to be installed
    before our build runs. In this section, we define things such as the composer-asset-plugin
    and our composer dependencies.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The `before_script` section defines things that should occur before our `build/test`
    script executes.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Finally, the `script` section defines what we want to build or test.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: After defining our `.travis.yml` file, we need to simply commit the file to
    our repository. Since we've already linked Travis CI to our GitHub project, pushing
    our project will automatically trigger a build that we can view on Travis CI.
    On Travis CI, we can view a history of all the builds that have occurred for our
    project. In the event that someone pushes code to our repository that breaks our
    build, we will receive a notification and can notify the person who broke our
    tests to fix their code before trying again. Additionally, we can view a complete
    build output for each commit, which gives us insight into what is happening in
    each build.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: As an example, the repository for this chapter was linked to Travis CI. You
    can see builds in action by navigating to [https://travis-ci.org/masteringyii](https://travis-ci.org/masteringyii).
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We learned quite a bit about testing in this chapter! We first covered how to
    set up and configure Codeception to run within our project. We then covered how
    to set up unit, functional, and acceptance testing in order to ensure that we
    had adequate test coverage of our code base. Next, we covered how to create and
    use fixtures to mock data so that our tests run with a consistent test base. Finally,
    we covered how to automate the testing of our code with Travis CI, a third-party
    continuous integration service.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we'll cover how to use Yii2's internationalization and
    localization features to make our applications capable of running in multiple
    languages.
  prefs: []
  type: TYPE_NORMAL
