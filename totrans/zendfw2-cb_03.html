<html><head></head><body><div class="chapter" title="Chapter&#xA0;3.&#xA0;Handling and Decorating Forms"><div class="titlepage"><div><div><h1 class="title"><a id="ch03"/>Chapter 3. Handling and Decorating Forms</h1></div></div></div><p>In this chapter we will cover:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Creating forms</li><li class="listitem" style="list-style-type: disc">Using form view helpers</li><li class="listitem" style="list-style-type: disc">Creating a custom form element and form view helper</li></ul></div><div class="section" title="Introduction"><div class="titlepage"><div><div><h1 class="title"><a id="ch03lvl1sec19"/>Introduction</h1></div></div></div><p>In this chapter we will be discussing forms, and specifically the generation and manipulation of them. Forms<a id="id167" class="indexterm"/> are a very important part in the communication with the user, as it is one of the ways to receive information from the user. It is also a great way to use forms to do a lot of validation of the elements by combining JavaScript and PHP. If we then can make it so that it looks great as well, why would we not do that?</p></div></div>
<div class="section" title="Creating forms"><div class="titlepage"><div><div><h1 class="title"><a id="ch03lvl1sec20"/>Creating forms</h1></div></div></div><p>This recipe<a id="id168" class="indexterm"/> involves different ways of creating forms, and after that we will talk about how elements are added to the form. In the last part of this recipe we will discuss how to validate forms, and the best way of accomplishing this.</p><div class="section" title="Getting ready…"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec36"/>Getting ready…</h2></div></div></div><p>A basic <a id="id169" class="indexterm"/>ZF2 skeleton application, with at least one module where we can work in, is necessary to create and output forms.</p><p>If we want to use form annotations, we also require <code class="literal">Doctrine\Common</code> to be initiated in the skeleton as it has the parsing engine to parse the annotations. If we are using composer (which comes with the Zend Framework 2 skeleton) we can simply update our <code class="literal">composer.json</code> by adding the following line to the required section:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>"doctrine/common": "&gt;=2.1",</strong></span>
</pre></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip06"/>Tip</h3><p>Make sure the comma on the end of the line is only there when there are still lines beneath it. If there are no lines coming after this line except for a closing brace, please refrain from adding the comma as it will fail the process.</p></div></div><p>Next is to run the composer update to make sure it gets installed, by using a command like the following:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>php composer.phar update</strong></span>
</pre></div><p>If we are not <a id="id170" class="indexterm"/>using a composer we are best off looking at the Doctrine project website (<a class="ulink" href="http://www.doctrine-project.org/projects/common.html">http://www.doctrine-project.org/projects/common.html</a>) to find more information on how to install this.</p></div><div class="section" title="How to do it…"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec37"/>How to do it…</h2></div></div></div><p>We'll first be talking about creating forms and elements, after that we'll talk about adding filters and validations.</p><div class="section" title="Creating a basic form"><div class="titlepage"><div><div><h3 class="title"><a id="ch03lvl3sec50"/>Creating a basic form</h3></div></div></div><p>A form always <a id="id171" class="indexterm"/>needs to be one of the following:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">A class that is extended from the <code class="literal">Zend\Form</code> class</li><li class="listitem" style="list-style-type: disc">A class that is using the <code class="literal">Zend\Form\Annotation</code> defining method</li></ul></div></div><div class="section" title="Defining a form that is extended from Zend\Form"><div class="titlepage"><div><div><h3 class="title"><a id="ch03lvl3sec51"/>Defining a form that is extended from Zend\Form</h3></div></div></div><p>We will start with defining a <a id="id172" class="indexterm"/>form from the first method, by extending it from the <code class="literal">Zend\Form</code> class. This is probably the easiest way to begin if we are new in Zend Framework 2 (ZF2).</p><p>The basic idea is that our form class should extend from the <code class="literal">Zend\Form</code> class, and has at least a <code class="literal">__construct</code> method that defines our elements.</p><p>Let's take a look at the following example in the <code class="literal">/module/Application/src/Application/Form/NormalForm.php</code> file:</p><div class="informalexample"><pre class="programlisting">&lt;?php

// We define our namespace here
namespace Application\Form; 

// We need to use this to create an extend 
use Zend\Form\Form; 

// Starting class definition, extending from Zend\Form
class NormalForm extends Form 
{
  // Define our constructor that sets up our elements 
  public function __construct($name = null) 
  {
    // Create the form with the following name/id
    parent::__construct($name);
  }
}</pre></div><p>If we now go to our <a id="id173" class="indexterm"/>controller, say <code class="literal">IndexController</code> of the <code class="literal">Application</code> module we can output the form to View by doing the following in file <code class="literal">/module/Application/src/Application/Controller/IndexController.php</code>:</p><div class="informalexample"><pre class="programlisting">&lt;?php

// Namespace of the controller
namespace Application\Controller;

// Use the following classes at a minimum
use Zend\Mvc\Controller\AbstractActionController;
use Application\Form\NormalForm;
use Zend\View\Model\ViewModel;

// Begin our class definition
class IndexController extends AbstractActionController
{
  // Set up our indexAction,  in which we want to 
  // display our form.
  public function indexAction()
  {
    // Initialize our form
    $form = new NormalForm();
    
    // Return the view model to the user, with the 
    // attached form
    return new ViewModel(array(
        'form' =&gt;  $form
    ));
  }
}</pre></div><p>If we now take a look at<a id="id174" class="indexterm"/> our view script, we can see that we have the variable available. We will now output the form actually to the screen by the following example (<code class="literal">/module/Application/view/application/index/index.phtml</code>):</p><div class="informalexample"><pre class="programlisting">&lt;?php
  // Output the opening FORM tag: &lt;form&gt;
  echo $this-&gt;form()-&gt;openTag($this-&gt;form); 
  
  // Output the formatted elements of the form
  echo $this-&gt;formCollection($this-&gt;form);
  
  // Output the closing FROM tag &lt;/form&gt;
  echo $this-&gt;form()-&gt;closeTag();</pre></div><p>The output of this code example will be somewhat like the following:</p><div class="informalexample"><pre class="programlisting">&lt;form action="" method="POST" name="normalform" id="normalform"&gt;&lt;/form&gt;</pre></div><p>This tells us that the instantiating went well, and that it is fully functional. As we also can see the name that we defined (<code class="literal">"normalform"</code>) is coming back as the <code class="literal">name</code> and <code class="literal">id</code> of the form.</p></div><div class="section" title="Defining a form that uses the Zend\Form\Annotation"><div class="titlepage"><div><div><h3 class="title"><a id="ch03lvl3sec52"/>Defining a form that uses the Zend\Form\Annotation</h3></div></div></div><p>Let's take a look at an <a id="id175" class="indexterm"/>empty form (<code class="literal">/module/Application/src/Application/Form/AnnotationForm.php</code>) in an annotated form:</p><div class="informalexample"><pre class="programlisting">&lt;?php

// We first define our namespace as usual
namespace Application\Form;

// We need to use this otherwise it will not parse the 
// elements correctly.
use Zend\Form\Annotation;

/**
 * We want to name this form annotationform, which is 
 * why we use the tag below, defining the name. 
 *
 * @Annotation\Name("annotationform")
 * 
 * A hydrator makes sure our framework can 'read' the 
 * properties in our object, in this case we tell our 
 * annotation engine that we have an object that needs 
 * its properties read. There is probably a more 
 * technical, accurate way of explaining it, but let's 
 * just keep it to this for now. 
 *
* @Annotation\Hydrator(
 *     "Zend\Stdlib\Hydrator\ObjectProperty
 * ")
*/
class AnnotationForm
{
  /**
   * If we want to exclude properties in our form just 
   * use the Exclude annotation.
   * 
   * @Annotation\Exclude()
   */
  public $id;
}</pre></div><p>If we now want to <a id="id176" class="indexterm"/>begin outputting our form to our user we can do that in a similar way to the normal form (luckily). The first thing we need to do for that is actually assigning the form to the View (<code class="literal">/module/Application/src/Application/Controller/IndexController.php</code>) again, which is the only thing that is a bit different to the normal form creation.</p><div class="informalexample"><pre class="programlisting">&lt;?php

// Namespace of the controller
namespace Application\Controller;

// Use the following classes at a minimum
use Zend\Mvc\Controller\AbstractActionController;
use Application\Form\AnnotationForm;
use Zend\Form\Annotation\AnnotationBuilder;
use Zend\View\Model\ViewModel;

// Begin our class definition
class IndexController extends AbstractActionController
{

  // Set up our indexAction,  in which we want to 
  // display our form.
  public function indexAction()
  {
    // Set up the output model
    $viewModel = new ViewModel;

    // Instantiate the AnnotationBuilder which will 
    // create the actual form object
    $builder = new AnnotationBuilder();

    // Instantiate our annotated form
    $annotationForm = new AnnotationForm();

    // Now let the annotation builder create the form 
    // from scratch
    $form = $builder-&gt;createForm($annotationForm);

    // Set our form to be the form variable in the view
    $viewModel-&gt;setVariable('form', $form);
    
    // Return the view model to the user
    return $viewModel;
  }
}</pre></div><p>If we now <a id="id177" class="indexterm"/>want to output the form to our View (file <code class="literal">/module/Application/view/application/index/index.phtml</code>), we can simply do the same as we did with the other form:</p><div class="informalexample"><pre class="programlisting">&lt;?php
  // Output the opening FORM tag: &lt;form&gt;
  echo $this-&gt;form()-&gt;openTag($this-&gt;form); 
  
  // Output the formatted elements of the form
  echo $this-&gt;formCollection($this-&gt;form);
  
  // Output the closing FROM tag &lt;/form&gt;
  echo $this-&gt;form()-&gt;closeTag();</pre></div><p>The HTML <a id="id178" class="indexterm"/>output of this example would result in the following:</p><div class="informalexample"><pre class="programlisting">&lt;form action="" method="POST" name="annotationform" id="annotationform"&gt;&lt;/form&gt;</pre></div></div><div class="section" title="Adding elements to a Zend\Form extend form"><div class="titlepage"><div><div><h3 class="title"><a id="ch03lvl3sec53"/>Adding elements to a Zend\Form extend form</h3></div></div></div><p>Creating<a id="id179" class="indexterm"/> elements in<a id="id180" class="indexterm"/> this kind of form is pretty simple, let's see what it looks like with a short example (file <code class="literal">/module/Application/src/Form/NormalForm.php</code>):</p><div class="informalexample"><pre class="programlisting">// Adding a simple input text field
public function __construct($name = null) 
{
  // Create the form with the following name/id
  parent::__construct($name); 

  $this-&gt;add(array( 	
    // Specifying the name of the field
    'name' =&gt; 'name', 
  
    // The type of field we want to show
    'type' =&gt; 'Zend\Form\Element\Text', 
      
    // Any extra attributes we can give the element
    'attributes' =&gt; array( 
      // If there is no text we will display the 
      // placeholder
      'placeholder' =&gt; 'Your name here...', 
        
      // Tell the validator if the element is required 
      // or not
      'required' =&gt; 'required', 
    ), 
      
    // Any extra options we can define
    'options' =&gt; array(  
      // What is the label we want to give this element
      'label' =&gt; 'What is your name?', 
    ), 
  )); 
}</pre></div></div><div class="section" title="Adding elements to an annotated form"><div class="titlepage"><div><div><h3 class="title"><a id="ch03lvl3sec54"/>Adding elements to an annotated form</h3></div></div></div><p>Let's take an <a id="id181" class="indexterm"/>example <a id="id182" class="indexterm"/>of an annotated element creation:</p><div class="informalexample"><pre class="programlisting">class AnnotationForm
{
 /**
   * Add two filters to this element.
   *
   * @Annotation\Filter({"name": "StringTrim"})
   * @Annotation\Filter({"name": "StripTags"})

   * Add a validator to make sure the string length 
   * isn't going to be longer than 50, but also not 
   * smaller than 5.
   *
   * @Annotation\Validator({
   *    "name": "StringLength", 
   *    "options":{
   *        "min": 5, 
   *        "max": 50, 
   *        "encoding": "UTF-8"
   * }})
   *

   * Set this element to be required.
   * 
   * @Annotation\Required(true)

   * Set the attributes for the element
   *
   * @Annotation\Attributes({
   *     "type": "text", 
   *     "placeholder": "Your name here...", 
   * })

   * Set the options of this element.
   *
   * @Annotation\Options({
   *    "label": "What is your name?"
   * })
   */
  public $name;</pre></div></div><div class="section" title="Validating form input"><div class="titlepage"><div><div><h3 class="title"><a id="ch03lvl3sec55"/>Validating form input</h3></div></div></div><p>One of the most important <a id="id183" class="indexterm"/>things of having forms is to use the data in our application, because why else would we have forms to begin with?</p><p>Let's go and create a simple model (<code class="literal">/module/Application/src/Application/Model/SampleModel.php</code>) that we can use for an example later on, but has absolutely no other use for this recipe at all.</p><div class="informalexample"><pre class="programlisting">&lt;?php

namespace Application\Model;

class SampleModel
{
  public function doStuff($array) { 
    return true; 
  }
}</pre></div><p>As we can see this model doesn't do anything at all, but we need it later on.</p><p>We have now created our own form extension, so it is time to create our <code class="literal">InputFilter</code> class which will filter and validate the values that we are going to put in the form, and attach to our form through <code class="literal">setInputFilter</code> later on (we'll edit the file <code class="literal">/module/Application/src/Application/Form/NormalFormValidator.php</code>):</p><div class="informalexample"><pre class="programlisting">&lt;?php

// Of course our namespace first
namespace Application\Form; 

// As this will be an input filter, we need the 
// following imports to make it work
use Zend\InputFilter\Factory as InputFilterFactory; 
use Zend\InputFilter\InputFilter; 
use Zend\InputFilter\InputFilterAwareInterface; 
use Zend\InputFilter\InputFilterInterface; 

// Create our class, which should be implementing the 
// InputFilterAwareInterface if we want to attach it to 
// the form later on
class NormalFormValidator implements 
InputFilterAwareInterface
{ 
  // This is the input filter that we will create
  protected $inputFilter; 

  // This method is required by the implementation, but 
  // we will just throw an exception instead of setting 
  //the input filter as we don't want anyone to override 
  // us
  public function setInputFilter(InputFilterInterface $inputFilter) 
  { 
    // We want to make sure that we cannot set an input 
    // filter, as we already do that ourselves
    throw new \Exception("Cannot set input filter."); 
  } </pre></div><p>We have now<a id="id184" class="indexterm"/> started creating our input filter class, and already created one of the two required methods of <code class="literal">InputFilterAwareInterface</code>. Now, let's continue further to the point where we implement the second method, and construct the actual filter:</p><div class="informalexample"><pre class="programlisting">// This is the second method that is required by the 
// interface
public function getInputFilter() 
{ 
  // If our input filter doesn't exist yet, create one
  if ($this-&gt;inputFilter === null) {
    // Create the input filter which we will put in our 
    // property later
    $inputFilter = new InputFilter(); 

    // Also instantiate our factory so we can get more 
    // filters at ease
    $factory = new InputFilterFactory(); 

    // Let's add a filter for our name Element in our 
    // form
    $inputFilter-&gt;add($factory-&gt;createInput(array(
      // This is the element is applies to
      'name' =&gt; 'name', 

      // We want no one to skip this field, we need it
      'required' =&gt; true, 

      // Now we are defining the filters, which make 
      // sure that no malicious or invalid characters 
      // are supplied
      'filters' =&gt; array( 
        // Make sure no tags are in our value, which 
        // could make our system vulnerable for hacks
        array('name' =&gt; 'StripTags'), 

        // We want to make sure our string doesn't 
        // have any leading or trailing spaced	
        array('name' =&gt; 'StringTrim'), 
      ), 

      // Validators make the form generate errors when 
      // the data is invalid, filters only filter	
      'validators' =&gt; array( 
        array ( 
          // We want to add a validator that checks the 
          // length of the string received
          'name' =&gt; 'StringLength', 
          'options' =&gt; array( 
            // Check if the string is in UTF-8 encoding  
            // and between the 5 and 50 characters long
            'encoding' =&gt; 'UTF-8', 
            'min' =&gt; '5', 
            'max' =&gt; 50', 
          ), 
        ), 
      ), 
    )));</pre></div><p>We just added a simple validator that makes sure the length of the string is not smaller than 5 and not longer than 50 characters, and of course in our case we also want <code class="literal">UTF-8</code> characters, but obviously we can either drop this or change the character set if we need to.</p><p>We'll add a<a id="id185" class="indexterm"/> simple password field validator and filter now, but the next one after that checks if the <code class="literal">repeat_password</code> field is identical in value to our password field. Personally, I really like that validator because of its simplicity and yet being powerful enough to take away some manual labor.</p><div class="informalexample"><pre class="programlisting">    // We are doing the same trick again for the 
    // password, so we can just skip over this, as this 
    // was just necessary for the one after this one.
    $inputFilter-&gt;add($factory-&gt;createInput(array(
      'name' =&gt; 'password', 
      'filters' =&gt; array( 
        array('name' =&gt; 'StripTags'), 
        array('name' =&gt; 'StringTrim'), 
      ), 
      'validators' =&gt; array( 
        array ( 
          'name' =&gt; 'StringLength', 
          'options' =&gt; array( 
            'encoding' =&gt; 'UTF-8', 
            'min' =&gt; '5', 
          ), 
        ), 
      ), 
    )));

    // And here is the great piece of validation we 
    // wanted to show off. This validator checks if the 
    // value of the given element is identical to 
    // another fields value. This way we don't have to 
    // manually check if the password is the same as the 
    // repeat password field.
    $inputFilter-&gt;add($factory-&gt;createInput(array(
      'name' =&gt; 'password_verify', 
      'filters' =&gt; array( 
        // The usual filters, as we almost always want 
        // to be sure it contains no tags or 
        //trailing/leading spaces
        array('name' =&gt; 'StripTags'), 
        array('name' =&gt; 'StringTrim'), 
      ), 
      'validators' =&gt; array( 
        array( 
          'name' =&gt; 'identical', 
          'options' =&gt; array( 
            'token' =&gt; 'password', 
          ), 
        ), 
      ), 
    )));</pre></div><p>After that<a id="id186" class="indexterm"/> nifty validator we will now add a simple e-mail validator, which will also have a not empty validator that checks if the field is empty or not. We will use the following code for e-mail validation:</p><div class="informalexample"><pre class="programlisting">// Email validator works perfectly, especially if we 
// don't want to trust any client side validation 
// (which we shouldn't)
$inputFilter-&gt;add($factory-&gt;createInput(array(
  'name' =&gt; 'email', 
  'filters' =&gt; array( 
     array('name' =&gt; 'StripTags'), 
     array('name' =&gt; 'StringTrim'), 
  ), 
  'validators' =&gt; array( 
    array ( 
       'name' =&gt; 'StringLength', 
       'options' =&gt; array( 
       'encoding' =&gt; 'UTF-8', 
       'min' =&gt; '5', 
       'max' =&gt; '250', 
        ), 
      ), 
      array( 
        // Don't you hate it when you get email 
        // addresses that are not valid? Well, no 
        // more as we can simply validate on that 
        // as well.
        'name' =&gt; 'EmailAddress', 
        'options' =&gt; array( 
        'messages' =&gt; array( 
            // We can even leave a neat little error 
            // message to display
            'emailAddressInvalidFormat' =&gt; 'Your email seems to be invalid', 
          ) 
        ), 
      ), 
      array( 
        // This validator makes sure the email 
        // address is not left empty. And although we 
        // can simply say this field is required, 
        // this will give us the opportunity to leave 
        // a nice error message that is relevant to 
        // the user as well
        'name' =&gt; 'NotEmpty', 
        'options' =&gt; array( 
        'messages' =&gt; array( 
            // This message is displayed when the 
            // field is empty, instead of a 'field 
            // required' message as we didn't make 
            // the field required
            'isEmpty' =&gt; 'I am sorry, your email is required', 
          ) 
        ), 
      ), 
    ), 
  )));</pre></div><p>Even dates<a id="id187" class="indexterm"/> are not a problem for validation, and we can make it even this good that we are only allowed to select ranges of dates as well, which in some cases (for example 18+ websites) is nice to have.</p><div class="informalexample"><pre class="programlisting">      $inputFilter-&gt;add($factory-&gt;createInput(array(
        'name' =&gt; 'birthdate', 
        'required' =&gt; true, 
        'filters' =&gt; array( 
          array('name' =&gt; 'StripTags'), 
          array('name' =&gt; 'StringTrim'), 
        ), 
        'validators' =&gt; array( 
          array(
            'name' =&gt; 'Between',
            'options' =&gt; array(
              // We can define the ranges of dates 
              // here, min and max are both optional, 
              // as long as one of them at least exists
              'min' =&gt; '1900-01-01', 
              'max' =&gt; '2013-01-01', 
            ),
          ),
        ), 
      )));

      // Set the property
      $this-&gt;inputFilter = $inputFilter;
    }
  
    // End of our method, just return our created input 
    // filter now
    return $this-&gt;inputFilter;
  } 
}</pre></div><p>Let's jump in <a id="id188" class="indexterm"/>immediately and take a look at a simple example that uses our <code class="literal">normalform</code> like before (<code class="literal">/module/Application/src/Application/Controller/IndexController.php</code>):</p><div class="informalexample"><pre class="programlisting">&lt;?php

// Define the namespace of our controller
namespace Application\Controller;

// We need to use the following classes
use Zend\Mvc\Controller\AbstractActionController;
use Zend\View\Model\ViewModel;
use Application\Form\NormalForm;
use Application\Form\NormalFormValidator;
use Application\Model\SampleModel;

// Set up our class definition
class IndexController extends AbstractActionController
{
  // We want to parse/display our form on the index
  public function indexAction()
  {
    // Initialize our form
    $form = new NormalForm(); 
    
    // Set our request in a local variable for easier
    // access
    $request = $this-&gt;getRequest();

    if ($request-&gt;isPost() === true) {
      // Create a new form validator
      $formValidator = new NormalFormValidator();

      // Set the input filter of the form to the form
      // validator
      $form-&gt;setInputFilter(
          $formValidator-&gt;getInputFilter()
      );
        
      // Set the data from the post to the form
      $form-&gt;setData($request-&gt;getPost());

      // Check with the form validator if the form is 
      // valid or not
      if ($form-&gt;isValid() === true) { 
        // Do some Model stuff, like saving, this is 
        // just an empty model we created to show what 
        // probably would happen after a validation 
        // success.
        $user = new SampleModel();
        
        // Get *only* the filtered data from the form
        $user-&gt;doStuff($form-&gt;getData());
        
        // Done with this, unset it
        unset($user);
      }
    }
  
    // Return the view model to the user
    return newViewModel(array(
        'form' =&gt; $form
    ));
  }
}</pre></div></div></div><div class="section" title="How it works…"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec38"/>How it works…</h2></div></div></div><p>Let's understand how we achieved what we achieved.</p><div class="section" title="Setting up a basic form"><div class="titlepage"><div><div><h3 class="title"><a id="ch03lvl3sec56"/>Setting up a basic form</h3></div></div></div><p>The preceding first <a id="id189" class="indexterm"/>example, creating a form class that extended from <code class="literal">Zend\Form</code> is the bare minimum to set a form up. As we can see, this form doesn't have any elements or properties set up at the moment, the only thing it defines is the <code class="literal">name/id</code> of the DOM element of the form object. What we did after that is first initialize the form, and then assign the <code class="literal">ViewModel</code> to it as that will be the View that is going to be outputted to the screen.</p><p>The only thing that we did in the example is output the <code class="literal">&lt;form&gt;</code> tag first—with all its properties, such as <code class="literal">method</code>, <code class="literal">action</code>, and <code class="literal">etcetera</code>. The second thing is that we do output all the elements in the form (which in this case are none), and as a last thing that we do is we output the end form tag <code class="literal">&lt;/form&gt;</code>, which now ends our form declaration.</p><p>If we open up a browser and look at our code, we will see no much different than we saw before, probably an empty page. However, when we open out the source code of that page (in Firefox this is right-clicking on the page and clicking on <span class="strong"><strong>View Page Source</strong></span>) we see that we actually did instantiate the form properly in HTML.</p><p>Our basic form instantiation is now concluded, if we want a more advanced, but more attractive as well, way of defining our form, we should continue reading the next bit as well.</p></div><div class="section" title="Setting up an annotated form"><div class="titlepage"><div><div><h3 class="title"><a id="ch03lvl3sec57"/>Setting up an annotated form</h3></div></div></div><p>Defining an <a id="id190" class="indexterm"/>annotated form is a bit different than a normal form, the main difference being that an annotated form is just a class with properties, which isn't extended from any other class, while the other method requires us to extend from the <code class="literal">Zend\Form</code> class. In the preceding example, we first created a very simple and empty form using the annotation method. We can also see that we require a Hydrator to make the Annotation Engine understand what we are on about, but we do not need to extend the class, so we are free to do what we want there.</p><p>The only thing we should be wary about is that every element that we require in our form, should have the property access set to public, otherwise technically the Annotation Engine can't pick it up. We don't have to make getters/setters for the properties (unless we want to use it for ourselves), as the Annotation Engine just uses the public properties directly.</p><p>Using the <a id="id191" class="indexterm"/>form in a controller is slightly different then a normal form, because when we would just instantiate the class and use that as a form it would end up as an error. The class needs to go through <code class="literal">AnnotationBuilder</code> first to actually build up the form. That is why we need to do <code class="literal">createForm()</code>, which then outputs a form.</p><p>This will output nothing visible, but if we then look at the page source code (in Firefox this is achieved by right-clicking on the page and then clicking on <span class="strong"><strong>View Page Source</strong></span>) we see that we have a new form opening tag <code class="literal">&lt;form&gt;</code> and a form closing tag <code class="literal">&lt;/form&gt;</code>. In between those tags you can see that our form, which was named <code class="literal">annotationform</code> is now set as the <code class="literal">name</code> and the <code class="literal">id</code> of the form.</p><p>Some developers find this way of defining a form a bit overdone, because in the end it might seem that we are not adding a lot of usability, which in all fairness is a bit true. It all depends on the situation when something is better than other methods, but in all fairness it is a pretty slick way of defining forms!</p></div><div class="section" title="Adding elements to the form"><div class="titlepage"><div><div><h3 class="title"><a id="ch03lvl3sec58"/>Adding elements to the form</h3></div></div></div><p>If we have set up<a id="id192" class="indexterm"/> the forms in the same way as the previous method then <a id="id193" class="indexterm"/>we have two ways of defining elements to the form. The first one will be the normal method of defining a form, which is an extension of <code class="literal">Zend\Form\Form</code>, just like the form example in the <span class="emphasis"><em>How to do it...</em></span> section, and the annotation form of it, like the second example of an <code class="literal">AnnotationForm</code> in the <span class="emphasis"><em>How to do it...</em></span> section.</p><p>The first example assumes that we are defining <code class="literal">__construct()</code> in a form that has been extended from <code class="literal">Zend\Form\Form</code>. What it does is call the <code class="literal">add()</code> method of <code class="literal">Zend\Form\Form</code> where we give the method an array of methods (yes, you can just as well create the whole form in a configuration file!).</p><p>It is as simple as that to add an element. Obviously, there are more elements available, and all of them have their own options and attributes, but we won't go into all of those as it would be way too long to discuss.</p><p>Adding elements to an annotated form is both easy and complicated. It is easy because in the most basic idea it only requires you to add a property to the class, which is simple enough. But if you want to go further than that, and add validations or filters, it requires you to add Annotation comments above the property.</p><p>As we could see in the preceding example, the way of defining elements through annotation isn't particularly difficult, it is just that we need to know which <code class="literal">@Annotation</code> to use. When<a id="id194" class="indexterm"/> setting attributes/options or sometimes other annotations, we <a id="id195" class="indexterm"/>will see the two curly braces <code class="literal">{}</code>, which represent an object in JavaScript and is used for JSON.</p><p>Obviously, it isn't that difficult, but it requires us to have a bit of a different train of thought.</p></div><div class="section" title="Forms, filtering, and validation"><div class="titlepage"><div><div><h3 class="title"><a id="ch03lvl3sec59"/>Forms, filtering, and validation</h3></div></div></div><p>A normal form<a id="id196" class="indexterm"/> that extends from <code class="literal">Zend\Form\Form</code> creates the elements by looking into <code class="literal">$this-&gt;elements</code> of the form, where all the form elements will be stored. Once it triggers the form renderer, all these elements will be decorated into real HTML tags. In an annotated form the process of transforming the class into HTML requires one more step, which is put simply transforming the annotated class into a frame that looks like a <code class="literal">Zend\Form\Form</code> extended class. That way we can use the build form from the annotated class just like a real form object.</p><p>When we post the<a id="id197" class="indexterm"/> form (you don't necessarily need to specify a post as it is already a <code class="literal">POST</code> by default), we let the form check if the values are correct, and more importantly we want to make sure that we are getting the values that we expect.</p><p>Not only is validating forms important security wise but also filtering wise. If we put multiple filters on our elements (for example, string trim and strip tags), we would like to have that all ready for us to use instead of using the filters afterwards again. Obviously, the bigger issue is having our application protected from malicious users, and to validate the input of the user.</p><p>As we can see in the very <a id="id198" class="indexterm"/>last preceding code example, we first create the form and we will then look if the user tried posting the form. If this is true, we will set up our form validator that we created specifically for that form. We then assign the request data (this is what the user filled in our form) to the form. After we assigned the data to the form we call <code class="literal">isValid()</code> <a id="id199" class="indexterm"/>to see if the data is valid or not. If it is, we assign the filtered data with<a id="id200" class="indexterm"/> <code class="literal">getData()</code> to our sample model to save it.</p><p>Lastly, we will assign the form to the view again so we can display any validation errors that happened through the validation process. Easy!</p></div></div><div class="section" title="There's more…"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec39"/>There's more…</h2></div></div></div><p>We can also define a form solely through the configuration, this is called form creation by factory and we encourage you to see how that works, as it is also a great way of creating forms.</p><p>To add some form security, one would be looking to add a <code class="literal">Zend\Form\Element\Csrf</code> element to our form, which looks at the source of the form to make sure no Cross-site Request Forgeries (CSRF) are done. This is a unique key that is added to the form that is used in the validation process. We would even go as far as to say that it is recommended to create a base form that has the CSRF element already added to it, so that we don't have to worry that we forgot or not, as long as we extend from the base form.</p></div></div>
<div class="section" title="Using form view helpers"><div class="titlepage"><div><div><h1 class="title"><a id="ch03lvl1sec21"/>Using form view helpers</h1></div></div></div><p>Instead of the <a id="id201" class="indexterm"/>Zend Framework 1 Decorators (where it was a key in the creation and rendering of forms) we now know in Zend Framework 2 that it is better to use different view helpers and renderers to render the forms.</p><div class="section" title="How to do it…"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec40"/>How to do it…</h2></div></div></div><p>View helpers are very important tools to a developer, here we will discuss how to use them in our code.</p><div class="section" title="Form"><div class="titlepage"><div><div><h3 class="title"><a id="ch03lvl3sec60"/>Form</h3></div></div></div><p>We do the following<a id="id202" class="indexterm"/> alterations to a <a id="id203" class="indexterm"/>view script called <code class="literal">example-viewscript.phtml</code>:</p><div class="informalexample"><pre class="programlisting">&lt;?php

// Just open and close the form tag
echo $this-&gt;form()-&gt;openTag();
echo $this-&gt;form()-&gt;closeTag();


// Use a form to pull the attributes from
echo $this-&gt;form()-&gt;openTag($formObject);


/** Do stuff in between **/

// Close the tag again with no form object attached
echo $this-&gt;form-&gt;closeTag();</pre></div><p>The rendered output of this would be the following:</p><div class="informalexample"><pre class="programlisting">&lt;form&gt;&lt;/form&gt;</pre></div></div><div class="section" title="FormButton"><div class="titlepage"><div><div><h3 class="title"><a id="ch03lvl3sec61"/>FormButton</h3></div></div></div><p>We do the<a id="id204" class="indexterm"/> following <a id="id205" class="indexterm"/>alterations to a view script called <code class="literal">example-viewscript.phtml</code>:</p><div class="informalexample"><pre class="programlisting">&lt;?php

// First we create a simple button (this is better done 
// inside a form/controller or model of course)
$buttonElement = new \Zend\Form\Element\Button(
  // This is the name of the button
  'somebutton'
);

// Render the button immediately through the button 
// element
echo $this-&gt;formButton($buttonElement);

// Render the button in 3 steps:
// Step 1, the opening tag: Can be called without a 
// parameter, and array of attributes or an instance of
// Zend\Form\Element
echo $this-&gt;formButton()-&gt;openTag($buttonElement);

// Step 2, the inner HTML: Output our custom inner HTML 
// here, like the label of the button
echo '&lt;span&gt;Life is short, click now!&lt;/span&gt;';

// Step 3, the closing tag: Close the tag again.
echo $this-&gt;formButton()-&gt;closeTag();</pre></div><p>If we now look at the rendered output, it should look like the following:</p><div class="informalexample"><pre class="programlisting">&lt;button name="somebutton"&gt;&lt;span&gt;Life is short, click now!&lt;/span&gt;&lt;/button&gt;</pre></div></div><div class="section" title="FormCaptcha"><div class="titlepage"><div><div><h3 class="title"><a id="ch03lvl3sec62"/>FormCaptcha</h3></div></div></div><p>We do the following <a id="id206" class="indexterm"/>alterations <a id="id207" class="indexterm"/>to a view script called <code class="literal">example-viewscript.phtml</code>:</p><div class="informalexample"><pre class="programlisting">&lt;?php
$captchaElement = new \Zend\Form\Element\Captcha(array(
  // What is the name of the element
  'name' =&gt; 'captcha',
  // Now add some captcha specific configuration
  'captcha' =&gt; array(
    // The class is necessary for the factory to know 
    // what kind of captcha we want. The options are 
    // Dumb, Figlet, Image and the famous ReCaptcha
    'class' =&gt; 'Dumb',
  )
));


// That's all folks, the $captchaElement needs to be of 
// the instance Zend\Captcha\AdapterInterface to make it 
// work
echo $this-&gt;formCaptcha($captchaElement);</pre></div></div><div class="section" title="FormCheckbox"><div class="titlepage"><div><div><h3 class="title"><a id="ch03lvl3sec63"/>FormCheckbox</h3></div></div></div><p>We do the following <a id="id208" class="indexterm"/>alterations <a id="id209" class="indexterm"/>to a view script called <code class="literal">example-viewscript.phtml</code>:</p><div class="informalexample"><pre class="programlisting">&lt;?php
// Create a simple checkbox with the name someCheckbox
$checkboxElement = new \Zend\Form\Element\Checkbox('someCheckbox');

// The $checkboxElement needs to be of the instance 
// Zend\Form\Element\Checkbox to make it work
echo $this-&gt;formCheckbox($checkboxElement);</pre></div><p>The rendered output would be something like the following:</p><div class="informalexample"><pre class="programlisting">&lt;input type="checkbox" name="someCheckbox" /&gt;</pre></div></div><div class="section" title="FormCollection"><div class="titlepage"><div><div><h3 class="title"><a id="ch03lvl3sec64"/>FormCollection</h3></div></div></div><p>We do the following <a id="id210" class="indexterm"/>alterations <a id="id211" class="indexterm"/>to a view script called <code class="literal">example-viewscript.phtml</code>:</p><div class="informalexample"><pre class="programlisting">&lt;?php

$object = new \Zend\Form\Element\Collection(
  // The name of the collection
  'someCollection', 

  // Some additional options
  array(
    // The label we want to display
    'label' =&gt; 'collectionSample',

    // Should the collection create a template of our 
    // template element so that we easily duplicate it
    'should_create_template' =&gt; true,
    
    // Are we allowed to add new elements
    'allow_add' =&gt; true,

    // And how many elements do we want to render
    'count' =&gt; 2,

    // Define the target element to render
    'target_element' =&gt;array(
      'type' =&gt; 'Zend\Form\Element\Text'
    ),
));

// The $object can be of any class that implements the 
// Zend\Form\ElementInterface
echo $this-&gt;formCollection($object);</pre></div><p>This has the incredibly vague rendered output like the following:</p><div class="informalexample"><pre class="programlisting">&lt;fieldset&gt;&lt;legend&gt;collectionSample&lt;/legend&gt;&lt;span data-template="&amp;lt;input type=&amp;quot;text&amp;quot; name=&amp;quot;__index__&amp;quot; value=&amp;quot;&amp;quot;&amp;gt;"&gt;&lt;/span&gt;</pre></div><p>This is enough for the collection to know what it needs to do, as in this case it holds the template of our <code class="literal">input</code> field.</p></div><div class="section" title="FormColor"><div class="titlepage"><div><div><h3 class="title"><a id="ch03lvl3sec65"/>FormColor</h3></div></div></div><p>We do the following<a id="id212" class="indexterm"/> alterations<a id="id213" class="indexterm"/> to a view script called <code class="literal">example-viewscript.phtml</code>:</p><div class="informalexample"><pre class="programlisting">&lt;?php

// We want a simple text field for our color
$color = new \Zend\Form\Element\Color('someColor');

// The $color can be of any class that implements the 
// Zend\Form\ElementInterface
echo $this-&gt;formColor($color);</pre></div></div><div class="section" title="FormDate, FormDateTime, and FormDateTimeLocal"><div class="titlepage"><div><div><h3 class="title"><a id="ch03lvl3sec66"/>FormDate, FormDateTime, and FormDateTimeLocal</h3></div></div></div><p>We<a id="id214" class="indexterm"/> do <a id="id215" class="indexterm"/>the<a id="id216" class="indexterm"/> following<a id="id217" class="indexterm"/> alterations to a view<a id="id218" class="indexterm"/> script<a id="id219" class="indexterm"/> called <code class="literal">example-viewscript.phtml</code>:</p><div class="informalexample"><pre class="programlisting">&lt;?php
// Create a date element
$date = new \Zend\Form\Element\Date('someDateElement');

// The $date can be of any class that implements the 
// Zend\Form\ElementInterface
echo $this-&gt;formDate($date);
echo $this-&gt;formDateTime($date);
echo $this-&gt;formDateTimeLocal($date);</pre></div></div><div class="section" title="FormEmail"><div class="titlepage"><div><div><h3 class="title"><a id="ch03lvl3sec67"/>FormEmail</h3></div></div></div><p>We do the following<a id="id220" class="indexterm"/> alterations to a <a id="id221" class="indexterm"/>view script called <code class="literal">example-viewscript.phtml</code>:</p><div class="informalexample"><pre class="programlisting">&lt;?php
// Add a simple text field
$element = new \Zend\Form\Element\Text('someElement');

// The $email can be of any class that implements the 
// Zend\Form\ElementInterface
echo $this-&gt;formEmail($email);</pre></div></div><div class="section" title="FormFile"><div class="titlepage"><div><div><h3 class="title"><a id="ch03lvl3sec68"/>FormFile</h3></div></div></div><p>We do the following<a id="id222" class="indexterm"/> alterations<a id="id223" class="indexterm"/> to a view script called <code class="literal">example-viewscript.phtml</code>:</p><div class="informalexample"><pre class="programlisting">&lt;?php

// The $file can be of any class that implements the 
// Zend\Form\ElementInterface
echo $this-&gt;formFile($file);</pre></div></div><div class="section" title="FormHidden"><div class="titlepage"><div><div><h3 class="title"><a id="ch03lvl3sec69"/>FormHidden</h3></div></div></div><p>We do the following <a id="id224" class="indexterm"/>alterations <a id="id225" class="indexterm"/>to a view script called <code class="literal">example-viewscript.phtml</code>:</p><div class="informalexample"><pre class="programlisting">&lt;?php

// The $hidden can be of any class that implements the 
// Zend\Form\ElementInterface
echo $this-&gt;formHidden($hidden);</pre></div></div><div class="section" title="FormImage"><div class="titlepage"><div><div><h3 class="title"><a id="ch03lvl3sec70"/>FormImage</h3></div></div></div><p>We do the<a id="id226" class="indexterm"/> following <a id="id227" class="indexterm"/>alterations to a view script called <code class="literal">example-viewscript.phtml</code>:</p><div class="informalexample"><pre class="programlisting">&lt;?php

// The $image can be of any class that implements the 
// Zend\Form\ElementInterface
$image-&gt;setAttrib('src', '/our/image.jpg');

echo $this-&gt;formImage($image);</pre></div></div><div class="section" title="FormInput"><div class="titlepage"><div><div><h3 class="title"><a id="ch03lvl3sec71"/>FormInput</h3></div></div></div><p>We do the following <a id="id228" class="indexterm"/>alterations <a id="id229" class="indexterm"/>to a view script called <code class="literal">example-viewscript.phtml</code>:</p><div class="informalexample"><pre class="programlisting">&lt;?php

// The $input can be of any class that implements the 
// Zend\Form\ElementInterface
echo $this-&gt;formInput($input);</pre></div></div><div class="section" title="FormLabel"><div class="titlepage"><div><div><h3 class="title"><a id="ch03lvl3sec72"/>FormLabel</h3></div></div></div><p>We do the following <a id="id230" class="indexterm"/>alterations<a id="id231" class="indexterm"/> to a view script called <code class="literal">example-viewscript.phtml</code>:</p><div class="informalexample"><pre class="programlisting">&lt;?php
// Create a simple text input
$element = new \Zend\Form\Element\Text('someElement');

// 1. This will declare the label immediately. The
// $element can be of any class that implements
// the Zend\Form\ElementInterface

echo $this-&gt;formLabel($element);

// 2. Or we can declare the formLabel like this
echo $this-&gt;formLabel()-&gt;openTag(array(
    'for' =&gt; 'someElement',
));

// We are putting some html in between the 
// &lt;label&gt;&lt;/label&gt; tags
echo "Some output in between!";
// Close the tag again
echo $this-&gt;formLabel()-&gt;closeTag();

// 3. Or as a last method, there is still some other way 
// to define the element. This will prepend 
// $someOtherElement with our $element's label. Instead 
// of prepend we can also use append.
echo $this-&gt;formLabel(
    $element, 
    $someOtherElement, 
    'prepend'
);</pre></div></div><div class="section" title="FormElementErrors"><div class="titlepage"><div><div><h3 class="title"><a id="ch03lvl3sec73"/>FormElementErrors</h3></div></div></div><p>We do the <a id="id232" class="indexterm"/>following <a id="id233" class="indexterm"/>alterations to a view script called <code class="literal">example-viewscript.phtml</code>:</p><div class="informalexample"><pre class="programlisting">&lt;?php

// Create a simple text box
$element = new \Zend\Form\Element\Text('someInput');

// 1. Just display the element errors, with the optional 
// attributes added as the second parameter.
// The $element can be of any class that implements the 
// Zend\Form\ElementInterface
echo $this-&gt;formElementErrors($element, array(
    'class' =&gt; 'element-error',
    'id' =&gt; 'error_three'
));

// 2. Custom formatted validation error messages.
echo $this-&gt;formElementErrors()
          -&gt;setMessageOpenFormat('&lt;a href="/help-me"&gt;')
          -&gt;setMessageSeparatorString(
                   '&lt;/a&gt;&lt;a href="/help-me"&gt;'
         )-&gt;setMessageCloseString('&lt;/a&gt;')
          -&gt;render($element);</pre></div></div></div><div class="section" title="How it works…"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec41"/>How it works…</h2></div></div></div><p>The form element view helpers are a great way to render your form elements. In the previous version of Zend Framework this was done by form decorators, which were different to view helpers in ZF2 because they were used before the form reached the view script. The way it now works is that a form is still in its original state when it reaches the view script, which means we can fully manipulate the form to the way our layout looks. This creates a more dynamic output where we can define layouts per view script (something that was very hard to achieve in ZF1).</p><p>Because the form element view helpers are in charge of the rendering of the element in the view script, they can also be more in touch with the requirements of the developer. All in all, this is a great way to create a form that looks and works brilliantly.</p><p>Various view helpers and/or renderers can be used in order to create the perfect layout. There are a lot of standard view helpers that can be used in order to mark up your form.</p><div class="section" title="Form"><div class="titlepage"><div><div><h3 class="title"><a id="ch03lvl3sec74"/>Form</h3></div></div></div><p>This helper renders<a id="id234" class="indexterm"/> your <code class="literal">&lt;form /&gt;</code> tag, which can—if wanted—pull some attributes out of our <code class="literal">Zend\Form</code> object to use as attributes.</p><p>The attributes the form helper (by parsing the form) supports is <code class="literal">accept-charset</code>, <code class="literal">action</code>, <code class="literal">autocomplete</code>, <code class="literal">enctype</code>, <code class="literal">method</code>, <code class="literal">name</code>, <code class="literal">novalidate</code>, and <code class="literal">target</code>.</p></div><div class="section" title="FormButton"><div class="titlepage"><div><div><h3 class="title"><a id="ch03lvl3sec75"/>FormButton</h3></div></div></div><p>We can<a id="id235" class="indexterm"/> render our <code class="literal">&lt;button /&gt;</code> tag with this helper, and obviously it can work in different ways, just like we want it to. It can either render the button through <code class="literal">Zend\Form\Element</code> or do it in a three-step way, where we can make up our own stuff in between.</p><p>The attributes the <code class="literal">FormButton</code> helper (by parsing the <code class="literal">Element</code>) supports are <code class="literal">name</code>, <code class="literal">autofocus</code>, <code class="literal">disabled</code>, <code class="literal">form</code>, <code class="literal">formaction</code>, <code class="literal">formenctype</code>, <code class="literal">formmethod</code>, <code class="literal">formnovalidate</code>, <code class="literal">formtarget</code>, <code class="literal">type</code>, and <code class="literal">value</code>.</p></div><div class="section" title="FormCaptcha"><div class="titlepage"><div><div><h3 class="title"><a id="ch03lvl3sec76"/>FormCaptcha</h3></div></div></div><p>
<code class="literal">Captcha</code> is used to <a id="id236" class="indexterm"/>prevent users from submitting forms without validating that they are human. Occasionally, we will get forms that will be spammed with ridiculous amounts of spam. That is why we, nowadays, have this little tool that generates a small image, which is an automated Turing test to find out if we are human or not.</p><p>This helper can only be rendered through a <code class="literal">Zend\Element\Captcha</code> object, so there is not a lot to further explain on that.</p></div><div class="section" title="FormCheckbox"><div class="titlepage"><div><div><h3 class="title"><a id="ch03lvl3sec77"/>FormCheckbox</h3></div></div></div><p>This helper will render<a id="id237" class="indexterm"/> two elements by default:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The <code class="literal">&lt;input /&gt;</code> element of type <code class="literal">checkbox</code></li><li class="listitem" style="list-style-type: disc">An <code class="literal">&lt;input /&gt;</code> element of type <code class="literal">hidden</code>, with the value of the checkbox state</li></ul></div><p>It creates the hidden input because a checkbox will not get posted if it is left unchecked, so we can imagine the consequences of form validation when an element is not there. That is why there is always a hidden field that is rendered before the checkbox element to make sure at least something is posted.</p><p>Also, the checkbox element has some other cool options such as using a hidden field. For the developers out there that have any experience with checkboxes, they can sigh in relief as an unchecked checkbox is never posted by the browser in a form.</p><p>That is why a hidden field is placed before the checkbox element with the same name as the checkbox element, but filled with the unchecked value. This means that whenever the checkbox isn't checked, it will send the hidden field's value, otherwise the checkbox checked value would override that.</p></div><div class="section" title="FormCollection"><div class="titlepage"><div><div><h3 class="title"><a id="ch03lvl3sec78"/>FormCollection</h3></div></div></div><p>This helper is <a id="id238" class="indexterm"/>used, for example, when we want to render a complete form in one instance. If we use a <code class="literal">Zend\Form</code> object as parameter to this helper, we will get a completely rendered HTML form returned. If we use <code class="literal">Zend\Form\Element\Collection</code> on the other hand, we will get a fully rendered HTML collection back, with template if required.</p></div><div class="section" title="FormColor"><div class="titlepage"><div><div><h3 class="title"><a id="ch03lvl3sec79"/>FormColor</h3></div></div></div><p>This is a <a id="id239" class="indexterm"/>HTML5 element, which is a <code class="literal">&lt;input /&gt;</code> element with the type color. It creates an input form in which the user can select a color, or when used in a non HTML5 compatible browsers, it will simply display an input field.</p></div><div class="section" title="FormDate, FormDateTime, and FormDateTimeLocal"><div class="titlepage"><div><div><h3 class="title"><a id="ch03lvl3sec80"/>FormDate, FormDateTime, and FormDateTimeLocal</h3></div></div></div><p>Another <a id="id240" class="indexterm"/>HTML5<a id="id241" class="indexterm"/> element that outputs an <code class="literal">&lt;input /&gt;</code> element with the <a id="id242" class="indexterm"/>type <code class="literal">date</code> is <code class="literal">FormDate</code>. In an HTML5 compatible browser it will usually output a calendar dropdown where the user can select the date they like, in a non-compatible browser it again just shows a text input field.</p></div><div class="section" title="FormEmail"><div class="titlepage"><div><div><h3 class="title"><a id="ch03lvl3sec81"/>FormEmail</h3></div></div></div><p>This HTML5 <a id="id243" class="indexterm"/>field is a nice field that ships in an HTML5 compatible browser with a nifty validation which checks if the typed value is an actual e-mail address or not. It is best not to rely on that too much and still validate the values ourselves just in case the user isn't using an HTML5 compatible browser.</p><p>The attributes that can be set on a <code class="literal">FormEmail</code> are <code class="literal">name</code>, <code class="literal">autocomplete</code>, <code class="literal">autofocus</code>, <code class="literal">disabled</code>, <code class="literal">form</code>, <code class="literal">list</code>, <code class="literal">maxlength</code>, <code class="literal">multiple</code>, <code class="literal">pattern</code>, <code class="literal">placeholder</code>, <code class="literal">readonly</code>, <code class="literal">required</code>, <code class="literal">size</code>, <code class="literal">type</code>, and <code class="literal">value</code>.</p></div><div class="section" title="FormFile"><div class="titlepage"><div><div><h3 class="title"><a id="ch03lvl3sec82"/>FormFile</h3></div></div></div><p>The <code class="literal">FormFile</code> <a id="id244" class="indexterm"/>helper is helpful for displaying an <code class="literal">&lt;input /&gt;</code> with the type file. Not only does it show the input element, but it can also prepare the element for any upload progress we want to monitor. Like many other element helpers, this helper also supports the attributes: <code class="literal">name</code>, <code class="literal">accept</code>, <code class="literal">autofocus</code>, <code class="literal">disabled</code>, <code class="literal">form</code>, <code class="literal">multiple</code>, <code class="literal">required</code>, <code class="literal">type</code>, and <code class="literal">value</code>.</p></div><div class="section" title="FormHidden"><div class="titlepage"><div><div><h3 class="title"><a id="ch03lvl3sec83"/>FormHidden</h3></div></div></div><p>The <a id="id245" class="indexterm"/>hidden <code class="literal">&lt;input /&gt;</code> field is handy for posting information to the application without requiring user input. Nothing fancy about this helper, but it does support the <code class="literal">name</code>, <code class="literal">disabled</code>, <code class="literal">form</code>, <code class="literal">type</code>, and <code class="literal">value</code> attributes.</p></div><div class="section" title="FormImage"><div class="titlepage"><div><div><h3 class="title"><a id="ch03lvl3sec84"/>FormImage</h3></div></div></div><p>The<a id="id246" class="indexterm"/> <code class="literal">FormImage</code> <code class="literal">&lt;input /&gt;</code> tag is mainly used as a replacement for a <span class="strong"><strong>Submit</strong></span> button in a form. It is simple to use and only requires the <code class="literal">src</code> attribute (the location of the image). It also supports the <code class="literal">name</code>, <code class="literal">alt</code> (recommended), <code class="literal">autofocus</code>, <code class="literal">disabled</code>, <code class="literal">form</code>, <code class="literal">formaction</code>, <code class="literal">formenctype</code>, <code class="literal">formmethod</code>, <code class="literal">formnovalidate</code>, <code class="literal">formtarget</code>, <code class="literal">height</code>, <code class="literal">type</code>, and <code class="literal">width</code> attributes.</p></div><div class="section" title="FormInput"><div class="titlepage"><div><div><h3 class="title"><a id="ch03lvl3sec85"/>FormInput</h3></div></div></div><p>A <code class="literal">FormInput</code> is <a id="id247" class="indexterm"/>a simple <code class="literal">&lt;input /&gt;</code> element that renders an element for us by naturally selecting the type. Not necessarily recommended to use this one as it is pretty generic and would have its flaws (for example, when it isn't an <code class="literal">input</code> tag that is required).</p></div><div class="section" title="FormLabel"><div class="titlepage"><div><div><h3 class="title"><a id="ch03lvl3sec86"/>FormLabel</h3></div></div></div><p>If we want to <a id="id248" class="indexterm"/>display a <code class="literal">&lt;label /&gt;</code>, then using this helper is the perfect thing, as we can declare the position of the label (<code class="literal">FormLabel::APPEND</code> or <code class="literal">FormLabel::PREPEND</code>) and we can also add the content of the label. It only supports <code class="literal">for</code> and <code class="literal">form</code> as attributes.</p></div><div class="section" title="FormElementErrors"><div class="titlepage"><div><div><h3 class="title"><a id="ch03lvl3sec87"/>FormElementErrors</h3></div></div></div><p>This helper is used for <a id="id249" class="indexterm"/>displaying form validation errors. By default, this will be displayed underneath the form element, but with this helper we can customize the display of this error a bit more.</p></div></div></div>
<div class="section" title="Creating a custom form element and form view helper"><div class="titlepage"><div><div><h1 class="title"><a id="ch03lvl1sec22"/>Creating a custom form element and form view helper</h1></div></div></div><p>Once we keep on <a id="id250" class="indexterm"/>developing in Zend Framework 2, and our application keeps on growing, the more it is necessary to stop copy-pasting and just replace all those replicating bits by a class that simply outputs what we want. In ZF2 this can be done easily through view helpers.</p><div class="section" title="How to do it…"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec42"/>How to do it…</h2></div></div></div><p>In this recipe we'll create our own form element, and corresponding view helper to display it.</p><div class="section" title="Creating the new element"><div class="titlepage"><div><div><h3 class="title"><a id="ch03lvl3sec88"/>Creating the new element</h3></div></div></div><p>All we have to do is set the type of the element, and that's it. We do the following alterations to the <code class="literal">/module/Application/src/Application/Form/Element/Video.php</code> file, let's take a look on what the code should look like:</p><div class="informalexample"><pre class="programlisting">&lt;?php

// Set our namespace just right
namespace Application\Form\Element;

// We need to extend from the base element
use Zend\Form\Element;

// Set the class name, and make sure we extend from the 
// base element
class Video extends Element
{
  // The type of the element is video, 'nuff said.
  protected $attributes = array(
      'type' =&gt; 'video',
  );
}</pre></div><p>As we can see this is a pretty easy job to do, and we have now successfully created a new element to use in ZF2.</p><div class="section" title="Creating the new view helper"><div class="titlepage"><div><div><h4 class="title"><a id="ch03lvl1sec222"/>Creating the new view helper</h4></div></div></div><p>The view helper will <a id="id251" class="indexterm"/>create the HTML element that we just declared, so let's take a look on how the view helper should look like in the <code class="literal">/module/Application/src/Application/Form/View/Helper/FormVideo.php</code> file:</p><div class="informalexample"><pre class="programlisting">&lt;?php

namespace Application\Form\View\Helper;

use Zend\Form\View\Helper\AbstractHelper;
use Zend\Form\ElementInterface;
use Zend\Form\Exception;

class FormVideo extends AbstractHelper
{
  /**
   * Attributes valid for the video tag
   *
   * @var array
   */
  protected $validTagAttributes = array(
    'autoplay' =&gt; true,
    'controls' =&gt; true,
    'height' =&gt; true,
    'loop' =&gt; true,
    'muted' =&gt; true,
    'poster' =&gt; true,
    'preload' =&gt; true,
    'src' =&gt; true,
    'width' =&gt; true,
  );</pre></div><p>First, we added the attributes that this element can have, this is necessary to make sure we are not declaring attributes that don't exist (although that would in most cases not be that much of a problem).</p><div class="informalexample"><pre class="programlisting">  /**
   * Invoke helper as functor
   *
   * Proxies to {@link render()}.
   *
   * @param ElementInterface|null $element
   * @return string|FormInput
   */
  public function __invoke(ElementInterface $element = null)
  {
    if (!$element) {
      return $this;
    }

    return $this-&gt;render($element);
  }</pre></div><p>The preceding <code class="literal">__invoke</code> <a id="id252" class="indexterm"/>method is created so that we don't have to initialize the class before we want to call the view helper. This way we can use it in the view scripts by using <code class="literal">formVideo()</code>, instead of instantiating a new <code class="literal">FormVideo()</code> first.</p><div class="informalexample"><pre class="programlisting">  /**
   * Creates the &lt;source&gt; element for use in the &lt;video&gt;
   * element.
   * 
   * @param array|string $src	Can either be an 
   *                           array of strings, or a 
   *                           string alone.
   * @return string
   */
  protected function createSourcesString($src) 
  {
    $retval = '';
    
    if (is_array($src) === true) {
      foreach ($src as $tmpSrc) {
        $retval .= $this-&gt;createSourcesString($tmpSrc);
      }
    } else {
     $retval = sprintf(
       '&lt;source src="%s"&gt;',
       $src
     );
    }
    
    return $retval;
  }</pre></div><p>The <code class="literal">createSourcesString</code> method gets the <a id="id253" class="indexterm"/>string or array containing all our video URLs. As said this can be either a string or an array, which in the last case will just iterate through the array and output the string with the source tags.</p><div class="informalexample"><pre class="programlisting">  /**
   * Render a form &lt;video /&gt; element from the provided 
   * $element
   *
   * @param ElementInterface $element
   * @throws Exception\DomainException
   * @return string
   */
  public function render(ElementInterface $element)
  {
    // Get the src attribute of the element
    $src = $element-&gt;getAttribute('src');
    
    // Check if the src is null or empty, in that case 
    // throw an error as we can 't play a video without 
    // a video link!
    if ($src === null || $src === '') {
      throw new Exception\DomainException(sprintf(
        '%s requires that the element has an assigned'.   
        'src; none discovered',
        __METHOD__
      ));
    }

    // Get the attributes from the element
    $attributes = $element-&gt;getAttributes();

    // Unset the src as we don't need it right here as 
    // we render it separately
    unset($attributes['src']);
    
    // Return our rendered object
    return sprintf(
        '&lt;video %s&gt;%s&lt;/video&gt;',
        $this-&gt;createAttributesString($attributes),
        $this-&gt;createSourcesString($src)
    );
  }
}</pre></div></div></div><div class="section" title="Adding view helper to the configuration"><div class="titlepage"><div><div><h3 class="title"><a id="ch03lvl3sec89"/>Adding view helper to the configuration</h3></div></div></div><p>Now we need to add the<a id="id254" class="indexterm"/> view helper to the module configuration<a id="id255" class="indexterm"/> to make sure the view helper can be found in the view scripts. We can simply do this by adding another method to our <code class="literal">/module/Application/Module.php</code> as shown in the following code:</p><div class="informalexample"><pre class="programlisting">class Module 
{
  public function getViewHelperConfig()   
  {
    return array(
        'invokables' =&gt; array(
        // Add our extra view helper to render our video
        'formVideo' =&gt; 'Application\Form\View\Helper\FormVideo',
      )
    );
  }
}</pre></div><p>We didn't put the whole class in there, as that would be too much useless information for this example. The idea however is that we can simply put this method in our <code class="literal">Module.php</code> to make sure our view helper will be located.</p></div><div class="section" title="Displaying the new element"><div class="titlepage"><div><div><h3 class="title"><a id="ch03lvl3sec90"/>Displaying the new element</h3></div></div></div><p>We do the<a id="id256" class="indexterm"/> following alterations to the <code class="literal">/module/Application/view/application/index/video.phtml</code> file:</p><div class="informalexample"><pre class="programlisting">&lt;?php
use Application\Form\Element\Video;
  
// Declare a new video element
$video = new Video();
  
// Set the attribute src for this element
$video-&gt;setAttribute('src', array(
// These are some public video urls from 
// w3schools.com
  'http://www.w3schools.com/html/mov_bbb.mp4',
  'http://www.w3schools.com/html/mov_bbb.ogg',
  ));
  
// We also want to begin auto playing once loaded
$video-&gt;setAttribute('autoplay', true);

// Output the formatted element
echo $this-&gt;formVideo($video);</pre></div><p>We have now created a new form element, and a new form view helper!</p></div></div><div class="section" title="How it works…"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec43"/>How it works…</h2></div></div></div><div class="section" title="Creating the element"><div class="titlepage"><div><div><h3 class="title"><a id="ch03lvl3sec91"/>Creating the element</h3></div></div></div><p>First of all we <a id="id257" class="indexterm"/>need to create the new element before we work with it within ZF2. This can be easily done by extending from the base element of <code class="literal">Zend\Form\Element</code>.</p><p>Next up is the view helper as we want to make sure that our element is also rendered correctly to the user. As our element is not of any existing type (otherwise this would be a very boring recipe) we need to make sure that we create a view helper for ourselves.</p><p>The last bit of our code is creating the actual render method, which—as the name tells us—renders the actual HTML object.</p><p>In our case, we want to trigger an exception whenever the <code class="literal">src</code> has not been defined, as without it, this would be a pretty useless HTML element. Now, we have everything set up, we can use the element either in a form, or on its own in the view script. In the last example, we just declared the form element in the view script to show how it can work; however using logic in the view script is not something that is advised to do as we want to keep the view as clean as possible, and only output code with it. Anything remotely unrelated to <a id="id258" class="indexterm"/>HTML or the output to the user should go in the controller or models.</p></div><div class="section" title="What did we do"><div class="titlepage"><div><div><h3 class="title"><a id="ch03lvl3sec92"/>What did we do</h3></div></div></div><p>What we did is create a new form element, which was supposed to be a <code class="literal">&lt;video /&gt;</code> tag, a new HTML5 element. This video tag can have several attributes, one of it being an <code class="literal">src</code>. The <code class="literal">src</code> in this case tells the video element where we can find the video that we want to play.</p><p>A good reason to create our own view helper would be if we have a piece of HTML that is constantly recurring throughout our application (think of a tool tip or a help text), and which only needs to be copy-pasted and changed some properties for it to work. To save us time and space (code and readability wise), we would transform this into a simple view helper class that replicates the exact object, which we can transform by adding options to it.</p><p>In the end, we simply use the <code class="literal">formVideo</code> view helper in the view script to actually render the object for us, which takes a bit of a load off our hands by rendering a piece of code that is easy to replicate.</p></div></div></div></body></html>