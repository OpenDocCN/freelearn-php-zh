<html><head></head><body>
        <section>

                            <header>
                    <h1 class="header-title">Web Services</h1>
                </header>
            
            <article>
                
<p class="mce-root">Drupal 8 ships with the RESTful web servers functionality to implement web services to interact with your application. This chapter shows you how to enable these features and build your API, covering the following topics:</p>
<ul>
<li class="mce-root">Enabling RESTful interfaces</li>
<li class="mce-root">Using POST to create data</li>
<li class="mce-root">Using PATCH to update data</li>
<li class="mce-root">Using Views to provide custom data sources</li>
<li class="mce-root">Authentication</li>
<li>Using JSON API</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Introduction</h1>
                </header>
            
            <article>
                
<p>There are several modules provided by Drupal 8 that enable the ability to turn it into a web service provider. The Serialization module provides a means of serializing data to or deserializing from formats such as JSON and XML. The RESTful web services module then exposes entities and other APIs through Web APIs. Operations done through RESTful resource endpoints use the same create, edit, delete, and view permissions that would be used in a non-API format.</p>
<p>The HAL module serializes entities using the <strong>Hypertext Application Language</strong> (<strong>HAL</strong>) format. HAL is an Internet Draft standard convention used to hyperlink between resources in an API. HAL+JSON is required when working with POST and PATCH methods. For authentication, the HTTP Basic Authentication module provides a simple authentication via HTTP headers.</p>
<p>There is a community-lead effort to implement the JSON API specification with Drupal, using the JSON API module, covered in the <em>Using JSON API</em> recipe of this chapter. Like HAL, it provides specifications not only on how data should be represented, but also on how it should be sorted and filtered via request parameters.</p>
<p>This chapter covers how to work with the RESTful Web Services module and the supporting modules around developing a RESTful API powered by Drupal 8. We will cover how to use the GET, POST, and PATCH HTTP methods to manipulate content on the website. Additionally, we will cover how to use views to provide custom content that lists endpoints. Finally, we will cover how to handle custom authentication for our API.</p>
<div class="mce-root packt_infobox">In an article, <em>Putting off PUT</em>, the team behind the Web services initiative chose not to implement PUT and only support PATCH. For more information, refer to the original article at <a href="https://groups.drupal.org/node/284948">https://groups.drupal.org/node/284948</a>.<br/>
<br/>
However, the API is open for contributed modules to add the PUT support for core resources or their own.</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Enabling RESTful interfaces</h1>
                </header>
            
            <article>
                
<p>The RESTful Web Services module provides routes that expose endpoints for your RESTful API. It utilizes the Serialization module to handle the normalization to a response and denormalization of data from requests. Endpoints support specific formats and authentication providers. Upon installation, the RESTful Web Services module does not provide any default configured endpoints.</p>
<p>There is one caveat: RESTful Web Services does not provide a user interface to configure available endpoints. Enabling resource endpoints can be done by manually editing configuration or the <strong>REST UI</strong> module. We will use the REST UI module in this recipe.</p>
<p>In this recipe, we will install RESTful Web Services and enable the proper permissions to allow the retrieval of nodes via REST to receive our formatted JSON.</p>
<div class="packt_infobox">We will cover using GET, POST, PATCH, and DELETE in later recipes. This recipe covers the installation and configuration of the base modules to enable Web services.</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Getting ready</h1>
                </header>
            
            <article>
                
<p>There is a configuration change that might be required if you are running PHP 5.6: the <kbd>always_populate_raw_post_data</kbd> setting. If you try to enable the RESTful Web Services module without changing the default setting, you will see the following error message on installation:</p>
<p class="mce-root">The <kbd>always_populate_raw_post_data</kbd> PHP setting should be set to <kbd>-1</kbd> in PHP version 5.6. Please check the PHP manual for information on how to correct this. (Currently using <kbd>always_populate_raw_post_data</kbd> PHP setting version not set to -1.)</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<ol>
<li>First, we must add the REST UI module to our Drupal site so that we can easily configure our endpoints:</li>
</ol>
<pre style="padding-left: 60px">cd /path/to/drupal8<br/>composer require drupal/restui</pre>
<ol start="2">
<li>Go to <span class="packt_screen">Extend</span> from the administrative toolbar and install the following Web services modules: <span class="packt_screen">Serialization</span>, <span class="packt_screen">RESTful Web Services</span>, and <span class="packt_screen">REST UI</span>:</li>
</ol>
<div class="CDPAlignCenter CDPAlign"><img class="image-border" src="assets/9b148a49-0009-4a45-a9af-06bfc1bd82cf.png"/></div>
<ol start="3">
<li>Go to <span class="packt_screen">Configuration</span> and click on <span class="packt_screen">REST</span> under <span class="packt_screen">Web Services</span> to configure the available endpoints.</li>
</ol>
<p> </p>
<ol start="4">
<li>Click on the <span class="packt_screen">Enable</span> button for the <span class="packt_screen">Content</span> row:</li>
</ol>
<div class="mce-root CDPAlignCenter CDPAlign"><img class="image-border" src="assets/ef337a85-00c7-4438-8538-5f2c8c8cd21c.png"/></div>
<ol start="5">
<li>With the endpoint enabled, it must be configured. Check the <span class="packt_screen">GET</span> method checkbox to allow GET requests. Then, check the <span class="packt_screen">json</span> checkbox so that data can be returned as JSON. All endpoints require a selected authentication provider. Check the <span class="packt_screen">cookie</span> checkbox, and then save it:</li>
</ol>
<div class="mce-root CDPAlignCenter CDPAlign"><img height="391" width="457" class="image-border" src="assets/03616b74-74d3-45fe-9a79-ac8297eae48a.png"/></div>
<ol start="6">
<li>Any RESTful resource endpoint enabled will use the same create, update, delete, and view permissions that have been already configured for the entity type. In order to allow anonymous access over GET for content, ensure that anonymous users have the <strong>View published content permission</strong>.</li>
<li>Using cURL on the command line, a piece of content can now be retrieved using the RESTful endpoint. You must pass <kbd>?_format=json</kbd> to ensure that the proper format is returned:</li>
</ol>
<pre style="padding-left: 60px">curl http://127.0.0.1:8888/node/1?_format=json<br/><br/>{"nid":[{"value":1}],"uuid":[{"value":"9a473f09-fa61-42c9-b4ad-f24b857d04f6"}],"vid":[{"value":51}],"langcode":[{"value":"en"}],"type":[{"target_id":"page","target_type":"node_type","target_uuid":"8a8ad160-69dc-453f-bc11-86775040465e"}],"status":[{"value":true}],"title":[{"value":"Example node"}],"uid":[{"target_id":0,"target_type":"user","target_uuid":"e31b3de2-2195-48c6-9a5e-ab0553461c93","url":"\/user\/0"}],"created":[{"value":1500650071}],"changed":[{"value":1500650374}],"promote":[{"value":true}],"sticky":[{"value":false}],"revision_timestamp":[{"value":1500650374}],"revision_uid":[{"target_id":1,"target_type":"user","target_uuid":"2d7ee3ef-6f8a-4feb-a99a-4af8cfd24402","url":"\/user\/1"}],"revision_log":[],"revision_translation_affected":[{"value":true}],"default_langcode":[{"value":true}],"path":[],"body":[{"value":"Defui dolor elit jus luptatum. Ad augue causa hos loquor luctus minim singularis sino utinam. ","format":"plain_text","summary":""}]}</pre>
<div class="packt_infobox">The RESTful Web Services module will return the entire entity object with each field the user has access to view.</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How it works...</h1>
                </header>
            
            <article>
                
<p>The <strong>RESTful Web Services</strong> module works by implementing an event subscriber service, <kbd>rest.resource_routes</kbd>, that adds routes to Drupal based on implementations of its <kbd>RestResource</kbd> plugin. Each plugin returns the available routes based on HTTP methods that are enabled for the resource.</p>
<p>When routes are built, the <kbd>\Drupal\rest\Routing\ResourceRoutes</kbd> class uses the <kbd>RestResource</kbd> plugin manager to retrieve all the available definitions. The endpoint configuration objects are loaded and inspected. If the resource plugin provides an HTTP method that is enabled in the configuration definitions, it begins to build a new route. Verification is done against the defined supported formats and supported auth definitions. If the basic validation passes, the new route is added to the <kbd>RouteCollection</kbd> and returned.</p>
<p>If you provide a <kbd>supported_formats</kbd> or <kbd>supported_auth</kbd> value that is not available, the endpoint will still be created. There will be an error, however, if you attempt to use the route with the invalid plugin. This cannot occur when using the REST UI module, but manually providing and managing the configuration.</p>
<p>The default routes provided by the base class for resource plugins, <kbd>\Drupal\rest\Plugin\ResourceBase</kbd> class, set <kbd>\Drupal\rest\RequestHandler::handle</kbd> as the controller and method for the route. This method checks the passed <kbd>_format</kbd> parameter against the configured plugin. If the format is valid, the data is passed to the appropriate serializer. The serialized data is then returned in the request with appropriate content headers.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">There's more...</h1>
                </header>
            
            <article>
                
<p>The RESTful Web Services module provides a robust API that has some additional items to make a note of. We will explore these in the next recipe.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Using _format instead of the Accept header</h1>
                </header>
            
            <article>
                
<p>Earlier in the Drupal 8 life cycle, up until 8.0.0-beta12, Drupal supported the use of the <kbd>Accept</kbd> header instead of the <kbd>_format</kbd> parameter. Unfortunately, there were issues with external caches. Drupal was serving HTML and other formats on the same path, only using different <kbd>Accept</kbd> headers. CDNs and reverse proxies do not invalidate cache based on this header alone. The only solution to prevent cache poisoning on these external caches, such as <kbd>Varnish</kbd>, was to ensure the implementation of the <kbd>Vary: Accept</kbd> header. There were, however, too many issues regarding CDNs and variance of implementation, so the <kbd>_format</kbd> parameter was introduced instead of appending extensions (<kbd>.json</kbd> and <kbd>.xml</kbd>) to paths.</p>
<p>A detail of the problem can be found on the following core issues:</p>
<ul>
<li>Refer to external caches mix up response formats on URLs where content negotiation is in use at <a href="https://www.drupal.org/node/2364011">https://www.drupal.org/node/2364011</a></li>
<li>Check how to implement query parameter-based content negotiation as an alternative to extensions at <a href="https://www.drupal.org/node/2481453">https://www.drupal.org/node/2481453</a></li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">RestResource plugin to expose data through RESTful Web Services</h1>
                </header>
            
            <article>
                
<p>The RESTful Web Services module defines a <kbd>RestResource</kbd> plugin. This plugin is used to define resource endpoints. They are discovered in a module's <kbd>Plugin/rest/resource</kbd> namespace and need to implement the <kbd>\Drupal\rest\Plugin\ResourceInterface</kbd> interface. Drupal 8 provides two implementations of the <kbd>RestResource</kbd> plugin. The first is the <kbd>EntityResource</kbd> class that is provided by the RESTful Web Services module. It implements a driver class that allows it to represent each entity type. The second is the <strong>Database Logging</strong> module that provides its own <kbd>RestResource</kbd> plugin, as well. It allows you to retrieve logged messages by IDs. The <kbd>\Drupal\rest\Plugin\ResourceBase</kbd> class provides an abstract base class that can be extended for the <kbd>RestResource</kbd> plugin implementations. If the child class provides a method that matches the available HTTP methods, it will support them. For example, if a class has only a GET method, you can only interact with that endpoint through HTTP <kbd>GET</kbd> requests. On the other hand, you can provide a trace method that allows an endpoint to support HTTP <kbd>TRACE</kbd> requests.</p>
<p>Drupal 8 provides two implementations of the <kbd>RestResource</kbd> plugin. The first is the <kbd>EntityResource</kbd> class that is provided by the RESTful Web Services module. It implements a <kbd>deriver</kbd> class that allows it to represent each entity type. The second is the Database Logging module that provides its own <kbd>RestResource</kbd> plugin. It allows you to retrieve logged messages by IDs.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Rate limiting your API</h1>
                </header>
            
            <article>
                
<p>Many APIs implement a rate limit to prevent abuse of public APIs. When you have publicly exposed APIs, you will need to control the amount of traffic hitting the service and prevent abusers from slowing down or stopping your service.</p>
<p>The <strong>Rate Limiter</strong> module implements multiple ways to control access to your public APIs. There is an option to control the rate limit on specific requests, IP address-based limiting, and IP whitelisting.</p>
<p>You can find the Rate Limiter module at <a href="https://www.drupal.org/project/rate_limiter">https://www.drupal.org/project/rate_limiter</a>.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Using the HAL format</h1>
                </header>
            
            <article>
                
<p>When installed, the HAL module can format the entity returned to provide links to related entities, such as the user or revision or any other entity reference field. When the HAL module is installed, you can add it as a supported format, then do a request with <kbd>_format=hal_json</kbd>. The response from the recipe would come back with a <kbd>_links</kbd> parameter:</p>
<pre>   "_links" : {<br/>      "http://127.0.0.1:8888/rest/relation/node/page/revision_uid" : [<br/>         {<br/>            "href" : "http://127.0.0.1:8888/user/1?_format=hal_json"<br/>         }<br/>      ],<br/>      "self" : {<br/>         "href" : "http://127.0.0.1:8888/node/1?_format=hal_json"<br/>      },<br/>      "http://127.0.0.1:8888/rest/relation/node/page/uid" : [<br/>         {<br/>            "lang" : "en",<br/>            "href" : "http://127.0.0.1:8888/user/0?_format=hal_json"<br/>         }<br/>      ],<br/>      "type" : {<br/>         "href" : "http://127.0.0.1:8888/rest/type/node/page"<br/>      }<br/>   },</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">See also</h1>
                </header>
            
            <article>
                
<ul>
<li>Refer to the Drupal.org documentation for the RESTful Web Services module at <a href="https://www.drupal.org/documentation/modules/rest">https://www.drupal.org/documentation/modules/rest</a></li>
<li><span>Refer to</span> <em>Change record: Accept header based routing got replaced by a query parameter</em>, <a href="https://www.drupal.org/node/2501221">https://www.drupal.org/node/2501221</a></li>
<li><span>Refer to</span> <a href="3994173f-3d31-4f01-b808-99e01368564b.xhtml"><em>Chapter 7</em></a>, <em>Plug and Play with Plugins</em></li>
<li>Refer to the <em>Rate Limiter module</em> at <a href="https://www.drupal.org/project/rate_limiter">https://www.drupal.org/project/rate_limiter</a></li>
<li>Refer to the <em>REST UI module</em> at <a href="https://www.drupal.org/project/restui">https://www.drupal.org/project/restui</a></li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Using POST to create data</h1>
                </header>
            
            <article>
                
<p>When working with RESTful Web Services, the HTTP POST method is used to create new entities. We will use the <strong>HTTP Basic Authentication</strong> to authenticate a user and create a new node.</p>
<p>In this recipe, we will use the exposed node endpoint to create a new piece of article content through the RESTful Web Services module. We will use the <kbd>json</kbd> format. In the <em>There's more...</em> section, we will discuss how to use the HAL module for the <kbd>hal_json</kbd> format.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Getting ready</h1>
                </header>
            
            <article>
                
<p>You will use the <kbd>Article</kbd> content type provided by the standard installation. Following the preceding recipe, <em>Enabling RESTful interfaces</em>, you should have the <strong>REST UI</strong> module added to your Drupal installation using Composer. This can be done with the following command:</p>
<pre>cd /path/to/drupal8<br/>composer require drupal/restui</pre>
<p>In this recipe, the Drupal 8 installation is accessible through <kbd>http://127.0.0.1:8888</kbd>. Use the appropriate URL for your Drupal 8 site.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<ol>
<li>Go to <span class="packt_screen">Extend</span> from the administrative toolbar and install the following Web Services modules: <span class="packt_screen">Serialization</span>, <span class="packt_screen">RESTful Web Services</span>, <span class="packt_screen">REST UI</span>, and <span class="packt_screen">HTTP Basic Authentication</span>:</li>
</ol>
<div class="CDPAlignCenter CDPAlign"><img class="image-border" src="assets/34895758-9c1f-4d70-bc3f-29fb29064b88.png"/></div>
<ol start="2">
<li>Go to <span class="packt_screen">Configuration</span> and click on <span class="packt_screen">REST</span> under <span class="packt_screen">Web Services</span> to configure the available endpoints.</li>
<li>Click on the <span class="packt_screen">Enable</span> button for the <span class="packt_screen">Content</span> row:</li>
</ol>
<div class="CDPAlignCenter CDPAlign"><img class="image-border" src="assets/6eef4dca-6ac0-4c91-9f30-ad1896460e74.png"/></div>
<ol start="4">
<li>With the endpoint enabled, it must be configured. Check the <span class="packt_screen">GET</span> and <span class="packt_screen">POST</span> methods checkbox to allow GET and POST requests. Then, check the <span class="packt_screen">json</span> checkbox so that data can be returned as JSON. Check the <span class="packt_screen">basic_auth</span> checkbox, and then save it:</li>
</ol>
<div class="CDPAlignCenter CDPAlign"><img height="604" width="581" class="image-border" src="assets/1280dbfe-c1e5-45fe-9e22-979038943da6.png"/></div>
<ol start="5">
<li>We create our JSON payload to match the field structure expected by Drupal:</li>
</ol>
<pre style="padding-left: 60px">{<br/>  "type": "article",<br/>  "status": {"value": true},<br/>  "title": {"value": "Testing via REST!"},<br/>  "body": {"value": "This article was created using a RESTful endpoint"}<br/>}</pre>
<ol start="6">
<li>Before we send our JSON payload, we will need to retrieve a CSRF token. We do this by performing a <kbd>GET</kbd> request against <kbd>/session/token</kbd>. We'll use the returned value in our POST request header:</li>
</ol>
<pre style="padding-left: 60px">curl -X GET http://127.0.0.1:8888/session/token</pre>
<ol start="7">
<li>We can send the request containing our body payload to the <kbd>/entity/node?_format=json</kbd> endpoint path through an HTTP POST request to create our node. Ensure that you pass a valid user login where <kbd>admin:admin</kbd> is used:</li>
</ol>
<pre style="padding-left: 60px">curl -X POST \<br/>  'http://127.0.0.1:8888/entity/node?_format=json' \<br/>  -u admin:admin \<br/>  -H 'content-type: application/json' \<br/>  -H 'x-csrf-token: K5UW756_nWJxjX8Lt5NXXrE0xYSAqCn8MPKLbgE6Gps' \<br/>  -d '{<br/>  "type": "article",<br/>  "status": {"value": true},<br/>  "title": {"value": "Testing via REST!"},<br/>  "body": {"value": "This article was created using a RESTful endpoint"}<br/>}<br/>'</pre>
<ol start="8">
<li>A successful request will return a <kbd>201</kbd> header code and the full values of the created node, including its identifier.</li>
<li>View your Drupal site and verify that the node was created, by going to <kbd>/node/{nid}</kbd>, using the node ID from the request response:</li>
</ol>
<div class="CDPAlignCenter CDPAlign"><img class="image-border" src="assets/164085a1-8cd5-4816-b439-3153931668e2.png"/></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How it works...</h1>
                </header>
            
            <article>
                
<p>When working with content entities and the POST method, the endpoint is different to the one used for GET requests. The <kbd>\Drupal\rest\Plugin\rest\resource\EntityResource</kbd> class extends the <kbd>\Drupal\rest\Plugin\ResourceBase</kbd> base class, which provides a route method. If a resource plugin provides an <kbd>https://www.drupal.org/link-relations/create</kbd> link template, then that path will be used for the POST path.</p>
<p>The <kbd>EntityResource</kbd> class defines <kbd>/entity/{entity_type}</kbd> as the create link template. It then overrides the <kbd>getBaseRoute</kbd> method to ensure that the <kbd>entity_type</kbd> parameter is properly populated from the definition.</p>
<p>The <kbd>EntityResource</kbd> class will run a set of conditions for the request. First, it will validate the POST request by checking whether the entity is <kbd>null</kbd>. Then, the current user is authorized to create the entity type if the current user also has access to edit all fields provided, and finally, it checks whether an identifier was passed or not. The last condition is important, as updates are only to be made through a PATCH request.</p>
<p>If the entity is validated, it will be saved. On a successful save, an empty HTTP 201 response will be returned.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">There's more...</h1>
                </header>
            
            <article>
                
<p>Working with POST requests requires some specific formatting that will be explained in the next recipe.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Using HAL and understanding _links requirements</h1>
                </header>
            
            <article>
                
<p>When using the HAL module and the <kbd>hal_json</kbd> format, you must provide relationships for the entity. This is done through the <kbd>_links</kbd> parameter in the request. This is done to ensure that the entity is properly created with any relationships it requires, such as the entity type for a content entities bundle. Another example will be to create a comment over a RESTful interface. You will need to provide a <kbd>_links</kbd> entry for the user owning the comment.</p>
<p>The <kbd>rest.link_manager</kbd> service uses the <kbd>rest.link_manager.type</kbd> and <kbd>rest.link_manager.relation</kbd> and is responsible for returning the URIs for types and relations. By default, a bundle will have a path that resembles <kbd>/rest/type/{entity_type}/{bundle}</kbd> and its relations will resemble <kbd>/rest/relation/{entity_type}/{bundle}/{field_name}</kbd>.</p>
<p>Taking a user reference as an example, we will have to populate a <kbd>uid</kbd> field, as follows:</p>
<pre>{<br/>  "_links": {<br/>    "type": {<br/>      "href": "http://127.0.0.1:8888/rest/type/node/page"<br/>    },<br/>    "http://127.0.0.1:8888/rest/relation/node/article/uid": [<br/>      {<br/>        "href": "http://127.0.0.1:8888/user/1?_format=hal_json",<br/>        "lang": "en"<br/>      }<br/>    ]<br/>  }<br/>}</pre>
<p>Unfortunately, the documentation is sparse, and the best way to learn what <kbd>_links</kbd> are required is to perform a GET request and study the returned <kbd>_links</kbd> from the HAL JSON.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Working with images</h1>
                </header>
            
            <article>
                
<p>Most RESTful APIs utilize <kbd>base64</kbd> encoding of files to support POST operations to upload an image. Unfortunately, this is not supported in the Drupal core. Although there is a <kbd>serializer.normalizer.file_entity.hal</kbd> service that serializes file entities into HAL JSON, it does not currently work as of 8.3, but is hopefully slated for 8.4.</p>
<p>The <kbd>\Drupal\hal\Normalizer\FileEntityNormalizer</kbd> class supports denormalization; however, it does not handle <kbd>base64</kbd> and expects binary data.</p>
<p>There is a Drupal core issue for this problem, which is available at <a href="https://www.drupal.org/node/1927648">https://www.drupal.org/node/1927648</a>.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Using Cross-Site Request Forgery tokens</h1>
                </header>
            
            <article>
                
<p>When working with a POST request, you will need to pass a <strong>Cross-Site Request Forgery</strong> (<strong>CSRF</strong>) token if you are authenticating with a session cookie. The X-CSRF-Token header is required when using a session cookie to prevent accidental API requests.</p>
<p>If you are using the cookie provider for authentication, you will need to request a CSRF token from the <kbd>/session/token</kbd> route:</p>
<pre>curl -X GET http://127.0.0.1:8888/session/token</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">See also</h1>
                </header>
            
            <article>
                
<ul>
<li>Refer to how to serialize file content (<kbd>base64</kbd>) to support REST GET/POST/PATCH<br/>
on file entity at <a href="https://www.drupal.org/node/1927648">https://www.drupal.org/node/1927648</a></li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Using PATCH to update data</h1>
                </header>
            
            <article>
                
<p>When working with RESTful Web Services, the HTTP PATCH method is used to update entities. We will use the HTTP Basic Authentication to authenticate our user and update a node.</p>
<p>In this recipe, we will use the exposed node endpoint to create a new piece of article content through the RESTful Web Services module.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Getting ready</h1>
                </header>
            
            <article>
                
<p>We will use the <kbd>Article</kbd> content type provided by the standard installation. Following the <em>Enabling RESTful interfaces</em> recipe, you should have the REST UI module added to your Drupal installation using Composer. This can be done with the following command:</p>
<pre>cd /path/to/drupal8<br/>composer require drupal/restui</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<ol>
<li>Go to <span class="packt_screen">Extend</span> from the administrative toolbar and install the following Web Services modules: <span class="packt_screen">Serialization</span>, <span class="packt_screen">RESTful Web Services</span>, <span class="packt_screen">REST UI</span>, and <span class="packt_screen">HTTP Basic Authentication</span>:</li>
</ol>
<div class="CDPAlignCenter CDPAlign"><img class="image-border" src="assets/855e2758-aa42-405c-bfd2-a9fe8887f66e.png"/></div>
<ol start="2">
<li>Go to <span class="packt_screen">Configuration</span> and click on <span class="packt_screen">REST</span> under <span class="packt_screen">Web Services</span> to configure the available endpoints.</li>
</ol>
<p> </p>
<ol start="3">
<li>Click on the <span class="packt_screen">Enable</span> button for the <span class="packt_screen">Content</span> row:</li>
</ol>
<div class="CDPAlignCenter CDPAlign"><img class="image-border" src="assets/77fd5bab-7b56-491a-b8dc-5875449c4327.png"/></div>
<ol start="4">
<li>With the endpoint enabled, it must be configured. Check the <span class="packt_screen">GET</span>, <span class="packt_screen">POST</span>, and <span class="packt_screen">PATCH</span> methods checkbox to allow the GET, POST, and PATCH requests. Then, check the <span class="packt_screen">json</span> checkbox so that data can be sent as JSON. Check the <span class="packt_screen">basic_auth</span> checkbox and then save it:</li>
</ol>
<div class="CDPAlignCenter CDPAlign"><img height="484" width="969" class="image-border" src="assets/89afd28a-d7a4-41ee-9172-c673fe67a83d.png"/></div>
<ol start="5">
<li>Create a sample <kbd>Article</kbd> node on your Drupal site that you will modify using the REST endpoint. Ensure that you note its path. You will use the same path later in our request (for example, <kbd>/node/4</kbd>). This will also show you the node's ID:</li>
</ol>
<div class="CDPAlignCenter CDPAlign"><img height="604" width="787" class="image-border" src="assets/07ed6ccb-b637-4132-b79f-cc95b5d73dcd.png"/></div>
<ol start="6">
<li>Then, start building your JSON payload. You must provide the identifier (<kbd>nid</kbd>) value for the existing node and the content type (<kbd>type</kbd>) value. Ensure that you provide the value of <kbd>nid</kbd>, which matches your current node:</li>
</ol>
<pre style="padding-left: 60px">{<br/>   "nid" : {<br/>      "value" : 4<br/>   },<br/>   "body" : {<br/>      "value" : "This article was updated using the RESTful API endpoint!"<br/>   },<br/>   "type" : "article"<br/>}</pre>
<ol start="7">
<li>Before you send your JSON payload, you will need to retrieve a CSRF token. You can do this by performing a GET request against <kbd>/session/token</kbd>. Then, use the returned value in your POST request header:</li>
</ol>
<pre style="padding-left: 60px">curl -X GET http://127.0.0.1:8888/session/token</pre>
<ol start="8">
<li>You can send the request that contains your body payload to the <kbd>/node/4?_format=json</kbd>, where <kbd>/node/4</kbd> matches the path of the node you would like to edit, path through an HTTP PATCH request to create our node:</li>
</ol>
<pre style="padding-left: 60px">curl -X PATCH \<br/>  'http://127.0.0.1:8888/node/4?_format=json' \<br/>  -u admin:admin \<br/>  -H 'x-csrf-token: MAjbBsIUmzrwHQGNlXxvGMZQJzQCDZbmtecstzbk5UQ' \<br/>  -d '{<br/>  "type": "article",<br/>  "nid": {"value": 4},<br/>  "body": {"value": "This article was updated using the RESTful API endpoint!!"}<br/>}<br/>'</pre>
<ol start="9">
<li>A successful request will return a <kbd>200</kbd> header code and the full values of the updated node.</li>
</ol>
<p> </p>
<ol start="10">
<li>View your Drupal site and verify that the node was created, by going to <kbd>/node/{nid}</kbd>, using the node ID from the request response:</li>
</ol>
<div class="CDPAlignCenter CDPAlign"><img class="image-border" src="assets/eb4923ad-10ef-4e19-82d5-07f7e583f04d.png"/></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How it works…</h1>
                </header>
            
            <article>
                
<p>When working with content entities and the PATCH method, the endpoint is the same as the GET method path. The current user's access is checked to see whether they have the permission to update the entity type and each of the submitted fields provided in the request body.</p>
<p>Each field provided will be updated on the entity and then validated. If the entity is validated, it will be saved. On a successful save, an HTTP 200 response will be returned with the entire updated entity's content.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Using Views to provide custom data sources</h1>
                </header>
            
            <article>
                
<p>The RESTful Web Services module provides Views plugins that allow you to expose data over Views for your RESTful API. This allows you to create a view that has a path and outputs data using a serializer plugin. You can use this to output entities, such as JSON, HAL JSON, or XML, and it can be sent with appropriate headers.</p>
<p>In this recipe, we will create a view that outputs the users of the Drupal site, providing their username, email, and picture if provided.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How to do it…</h1>
                </header>
            
            <article>
                
<ol>
<li>Got o <span class="packt_screen">Extend</span> from the administrative toolbar and install the following Web Services modules: <span class="packt_screen">Serialization</span> and <span class="packt_screen">RESTful Web Services</span>:</li>
</ol>
<div class="CDPAlignCenter CDPAlign"><img class="image-border" src="assets/9ea0b910-a0ed-48c5-9bbd-91dcd7ff8fce.png"/></div>
<ol start="2">
<li>Go to <span class="packt_screen">Structure</span> and then to <span class="packt_screen">Views</span>. Click on <span class="packt_screen">Add view</span>. Name the view <strong>API Users</strong> and make it show <span class="packt_screen">Users</span>.</li>
<li>Check the <span class="packt_screen">Provide a REST export</span> checkbox, and type in the <kbd>api/users</kbd> path. This is where requests will be made:</li>
</ol>
<div class="CDPAlignCenter CDPAlign"><img height="164" width="470" class="image-border" src="assets/5be46af4-ec3b-4ad4-b1ca-6315371b7f4e.png"/></div>
<ol start="4">
<li>Click on <span class="packt_screen">Save and edit</span>.</li>
<li>Change the format of the row plugin from <span class="packt_screen">Entity</span> to <span class="packt_screen">Fields</span> instead so that we can control the specific output.</li>
<li>Ensure that your view has the following user entity fields: <span class="packt_screen">Name</span>, <span class="packt_screen">Email</span>, and <span class="packt_screen">Picture</span>.</li>
<li>Change the <span class="packt_screen">User: Name</span> field to a plain text formatter and do not link it to the user, so the response does not contain any HTML.</li>
<li>Change the <span class="packt_screen">User: Picture</span> field to use URL to image formatter so that only a URL is returned and not HTML.</li>
<li>Save your view.</li>
<li>Access your view by visiting <kbd>/api/users</kbd>; you will receive a JSON response containing the user information:</li>
</ol>
<pre style="padding-left: 60px">[<br/>  {<br/>    <span>"name"</span><span>: </span><span>"spuvest"</span><span>,<br/></span><span>    </span><span>"mail"</span><span>: </span><span>"spuvest@example.com"</span><span>,<br/></span><span>    </span><span>"user_picture"</span><span>: </span><span>"</span><span>\/</span><span>sites</span><span>\/</span><span>default</span><span>\/</span><span>files</span><span>\/</span><span>pictures</span><span>\/</span><span>2017-07</span><span>\/</span><span>generateImage_xIQkfx.jpg"<br/></span><span>  </span>}<span>,<br/></span><span>  </span>{<br/>    <span>"name"</span><span>: </span><span>"crepathuslus"</span><span>,<br/></span><span>    </span><span>"mail"</span><span>: </span><span>"crepathuslus@example.com"</span><span>,<br/></span><span>    </span><span>"user_picture"</span><span>: </span><span>"</span><span>\/</span><span>sites</span><span>\/</span><span>default</span><span>\/</span><span>files</span><span>\/</span><span>pictures</span><span>\/</span><span>2017-07</span><span>\/</span><span>generateImage_eauTko.gif"<br/></span><span>  </span>}<span>,<br/></span><span>  </span>{<br/>    <span>"name"</span><span>: </span><span>"veradabufrup"</span><span>,<br/></span><span>    </span><span>"mail"</span><span>: </span><span>"veradabufrup@example.com"</span><span>,<br/></span><span>    </span><span>"user_picture"</span><span>: </span><span>"</span><span>\/</span><span>sites</span><span>\/</span><span>default</span><span>\/</span><span>files</span><span>\/</span><span>pictures</span><span>\/</span><span>2017-07</span><span>\/</span><span>generateImage_HsEjKW.png"<br/></span><span>  </span>}<br/>]</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How it works</h1>
                </header>
            
            <article>
                
<p>The RESTful Web Services module provides display, row, and format plugins that allows you to export content entities to a serialized format. The REST Export display plugin allows you to specify a path to access the RESTful endpoint and properly assigns the Content-Type header for the requested format.</p>
<p>The Serializer style is provided as the only supported style plugin for the REST export display. This style plugin only supports row plugins that identify themselves as data display types. It expects data from the row plugin to be raw so that it can be passed to the appropriate serializer.</p>
<p>You then have the option of using the data entity or data field row plugins. Instead of returning a render array from their render method, they return raw data that will be serialized into the proper format.</p>
<p>With the row plugins returning raw format data and the data serialized by the style plugin, the display plugin will then return the response that is converted into the proper format via the Serialization module.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">There's more...</h1>
                </header>
            
            <article>
                
<p style="margin-bottom: .0001pt" class="NormalPACKT">Views provide a way to deliver specific RESTful endpoints. We will explore some additional features in the next recipe.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Controlling the key name in JSON output</h1>
                </header>
            
            <article>
                
<p>The Data fields row plugin allows you to configure field aliases. When the data is returned to the view, it will have Drupal's machine names. This means that custom fields will look something like <kbd>field_my_field</kbd>, which may not make sense to the consumer.</p>
<p>By clicking on <span class="packt_screen">Settings</span> next to <span class="packt_screen">Fields</span>, you can set aliases in the modal form:</p>
<div class="CDPAlignCenter CDPAlign"><img class="image-border" src="assets/886a4cce-5590-41f2-a4d8-8a309ff7fb54.png"/></div>
<p>When you provide an alias, the fields will match. For example, <kbd>user_picture</kbd> can be changed to <kbd>avatar</kbd> and the mail key can be changed to <kbd>email</kbd>:</p>
<pre>[{<br/>  "name": "veradabufrup",<br/>  "email": "veradabufrup@example.com",<br/>  "avatar": "\/sites\/default\/files\/pictures\/2017-07\/generateImage_HsEjKW.png"<br/>}]</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Controlling access to RESTful Views</h1>
                </header>
            
            <article>
                
<p>When you create a RESTful endpoint with Views, you are not using the same permissions created by the RESTful Web Services module. You will need to define the route permissions within the view, allowing you to specify specific roles or permissions for the request.</p>
<p>The default GET method provided by the <kbd>EntityResource</kbd> plugin does not provide a way to list entities and allows any entity to be retrieved by an ID. Using Views, you can provide a list of entities, limiting them to specific bundles.</p>
<p>Using Views, you can even provide a new endpoint to retrieve a specific entity. Using Contextual filters, you can add route parameters and filters to limit and validate entity IDs. For example, you may want to expose the article content over the API, but not pages.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Authentication</h1>
                </header>
            
            <article>
                
<p>Using the RESTful Web Services module, we define specific supported authentication providers for an endpoint. The Drupal core provides a cookie provider, which authenticates through a valid cookie, such as your regular login experience. Then, there is the HTTP Basic Authentication module to support HTTP authentication headers.</p>
<p>There are alternatives that provide more robust authentication methods. With cookie-based authentication, you will need to use CSRF tokens to prevent unrequested page loads by an unauthorized party. When you use the HTTP authentication, you are sending a password for each request in the request header.</p>
<p><strong>OAuth</strong> is a popular and open authorization framework. It is a proper authentication method that uses tokens and not passwords. In this recipe, we will implement the Simple OAuth module to provide OAuth 2.0 authentication for GET and POST requests.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Getting ready</h1>
                </header>
            
            <article>
                
<p>If you are not familiar with OAuth or OAuth 2.0, it is a standard for authorization. The implementation of OAuth revolves around the usage of tokens sent in HTTP headers. Refer to the OAuth home page for more information at <a href="http://oauth.net/">http://oauth.net/</a>.</p>
<p>By following the <em>Enabling RESTful interfaces</em> recipe, you should have the <strong>REST UI</strong> module added to your Drupal installation using Composer. This can be done with the following command:</p>
<pre>cd /path/to/drupal8<br/>composer require drupal/restui</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How to do it</h1>
                </header>
            
            <article>
                
<ol>
<li>First, we must add the Simple OAuth module to our Drupal site:</li>
</ol>
<pre style="padding-left: 60px">cd /path/to/drupal8<br/>composer require drupal/simple_oauth</pre>
<ol start="2">
<li>Go to <span class="packt_screen">Extend</span> from the administrative toolbar and install the following Web Services modules: <span class="packt_screen">Serialization</span>, <span class="packt_screen">RESTful Web Services</span>, <span class="packt_screen">REST UI</span>, and <span class="packt_screen">Simple OAuth</span>:</li>
</ol>
<div class="CDPAlignCenter CDPAlign"><img height="358" width="539" class="image-border" src="assets/389b25fd-4aba-40de-be34-07c45e9f57bc.png"/></div>
<ol start="3">
<li>Go to <span class="packt_screen">Configuration</span> and click on <span class="packt_screen">REST</span> under <span class="packt_screen">Web Services</span> to configure the available endpoints.</li>
<li>Click on the <span class="packt_screen">Enable</span> button for the <span class="packt_screen">Content</span> row:</li>
</ol>
<div class="CDPAlignCenter CDPAlign"><img class="image-border" src="assets/9976d9f5-9df6-4e82-99ea-43dc82563d88.png"/></div>
<ol start="5">
<li>With the endpoint enabled, it must be configured. Check the <span class="packt_screen">GET</span> and <span class="packt_screen">POST</span> methods checkbox to allow GET and POST requests. Then, check the <span class="packt_screen">json</span> checkbox so that data can be returned as JSON. Check the <span class="packt_screen">oauth2</span> checkbox and then save it.</li>
<li>Before we can configure the Simple OAuth module, we have to generate a pair of keys to encrypt the OAuth tokens. Generate these in a path accessible to Drupal, but not available through the web server:</li>
</ol>
<pre style="padding-left: 60px">openssl genrsa -out private.key 2048<br/>openssl rsa -in private.key -pubout &gt; public.key</pre>
<ol start="7">
<li>With the keys generated, go to the <span class="packt_screen">Configuration</span> page and then to <span class="packt_screen">Simple OAuth</span>. Enter in the paths to your private and public key that were just generated and click on <span class="packt_screen">Save configuration:</span></li>
</ol>
<div class="CDPAlignCenter CDPAlign"><img height="420" width="452" class="image-border" src="assets/b43152d1-044a-4fc9-9d09-d76b01e9b2df.png"/></div>
<ol start="8">
<li>From the Simple OAuth configuration form, click on <span class="packt_screen">Add client</span>. Provide a label for the client and select the <span class="packt_screen">Administrator</span> scope. Click on <span class="packt_screen">Save</span> to create the client.</li>
<li>Next, we will generate a token through the <kbd>/oauth/token</kbd> endpoint. You will need the ID from the client you just created. We must pass <kbd>grant_type</kbd>, <kbd>client_id</kbd>, <kbd>username</kbd>, and <kbd>password</kbd>. The <kbd>grant_type</kbd> is <kbd>password</kbd>, the <kbd>client_id</kbd> is the ID from the created client, and then the <kbd>username</kbd> and <kbd>password</kbd> of the account you wish to use:</li>
</ol>
<pre style="padding-left: 60px">curl -X POST \<br/>  http://127.0.0.1:8888/oauth/token \<br/>  -H 'content-type: application/x-www-form-urlencoded' \<br/>  -d 'grant_type=password&amp;client_id=3ec55f70-18cd-422f-9abd-2223f6ca3636&amp;username=admin&amp;password=admin'</pre>
<div class="packt_infobox">At the time of writing this book, the endpoint did not accept a JSON body, but only form-encoded values.</div>
<ol start="10">
<li>The response will contain an <kbd>access_token</kbd> property. This is to be used as your token when making API requests.</li>
<li>Request a node over REST with the <kbd>Authorization: Bearer [token]</kbd> header:</li>
</ol>
<pre style="padding-left: 60px">curl -X GET \ <br/>    'http://127.0.0.1:8888/node/1?_format=json' \<br/>    -H 'accept: application/json' \<br/>    -H 'authorization: Bearer JT9zgBgMEDlk2QIF0ecpZEOcsYC7-x649Bovo83HXQM'</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How it works</h1>
                </header>
            
            <article>
                
<p><span>The Simple OAuth module is built using the <kbd>League\OAuth2</kbd> PHP library, a community de facto library for OAuth2 implementation.</span></p>
<p>In a typical authentication request, there is an authentication manager that uses the <kbd>authentication_collector</kbd> service to collect all the tagged authentication provider servers. Based on the provider's set priority, each service is invoked to check whether it applies to the current request. Each applied authentication provider then gets invoked to see whether the authentication is invalid.</p>
<p>For the RESTful Web Services module, the process is more explicit. The providers identified in the <kbd>supported_auth</kbd> definition for the endpoint are the only services that run through the <em>applies</em> and <em>authenticates</em> process.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">There's more…</h1>
                </header>
            
            <article>
                
<p>We will explore more information on working with authentication providers and the RESTful Web Services module in the next section.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Authentication provider services</h1>
                </header>
            
            <article>
                
<p>When working with the RESTful Web Services module endpoints, the <kbd>supported_auth</kbd> values reference services tagged with <kbd>authentication_provider</kbd>. Out of the box, Drupal supports cookie authentication. The following code is provided by the <kbd>basic_auth</kbd> module to support the HTTP header authentication:</p>
<pre><span>services:<br/></span><span>  basic_auth.authentication.basic_auth:<br/></span><span>    class: </span>Drupal\basic_auth\Authentication\Provider\BasicAuth<br/>    <span>arguments: </span>[<span>'@config.factory'</span>, <span>'@user.auth'</span>, <span>'@flood'</span>, <span>'@entity.manager'</span>]<br/>    <span>tags:<br/></span><span>      </span>- { <span>name: </span>authentication_provider, <span>provider_id: </span><span>'basic_auth'</span>, <span>priority: </span>100 }</pre>
<p>An authentication provider can be created by creating a class in your module's <kbd>Authentication\Provider</kbd> namespace and implementing the <kbd>\Drupal\Core\Authentication\AuthenticationProviderInterface</kbd> interface. Then, register the class as a service in your module's <kbd>services.yml</kbd>.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Page cache request policies and authenticated Web service requests</h1>
                </header>
            
            <article>
                
<p>When working with data that expects authenticated users, the authentication service provider should also provide a page cache service handler. Services that are tagged with <kbd>page_cache_request_policy</kbd> have the ability to check whether the content is cached or not. This prevents authorization requests from being cached.</p>
<p>The following code is taken from the <kbd>basic_auth</kbd> module:</p>
<pre><span>basic_auth.page_cache_request_policy.disallow_basic_auth_requests:<br/></span><span>    class: </span>Drupal\basic_auth\PageCache\DisallowBasicAuthRequests<br/>    <span>public: </span>false<br/>    <span>tags:<br/></span><span>      </span>- { <span>name: </span>page_cache_request_policy }</pre>
<p>The <kbd>\Drupal\basic_auth\PageCache\DisallowBasicAuthRequests</kbd> class implements the <kbd>\Drupal\Core\PageCache\RequestPolicyInterface</kbd> interface. The check method allows the page cache policy to explicitly deny or remain neutral on a page's ability to be cached. The <kbd>basic_auth</kbd> module checks whether the default authentication headers are present. For the <kbd>simple_oauth</kbd> module, it checks whether a valid token is present.</p>
<div class="packt_infobox">
<p>This is an important security measure if you are implementing your own authentication services.</p>
</div>
<p>A page cache policy service can be implemented by creating a class in your module's <kbd>PageCache</kbd> namespace and implementing the <kbd>\Drupal\Core\PageCache\ResponsePolicyInterface</kbd> interface. Then, we need to register the class as a service in your module's <kbd>services.yml</kbd>.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The IP Authentication provider</h1>
                </header>
            
            <article>
                
<p>Some APIs that implement server-to-server communication will authenticate using IP address whitelists. For this use case, we have the IP Consumer Auth module. Whitelisted IP addresses are controlled by a form that saves a configuration value.</p>
<p>If an IP address is whitelisted, the user is authenticated as an anonymous user. While this may not be recommended for POST, PATCH, and DELETE requests, it can provide a simple way to control specific GET endpoints in a private network.</p>
<p>You can download IP Consumer Auth from its project page at <a href="https://www.drupal.org/project/ip_consumer_auth">https://www.drupal.org/project/ip_consumer_auth</a>.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">See also</h1>
                </header>
            
            <article>
                
<ul>
<li>Refer to the OAuth Community Site at <a href="http://oauth.net/">http://oauth.net/</a></li>
<li>Refer to the OAuth module for OAuth 1.0 support at <a href="https://www.drupal.org/project/oauth">https://www.drupal.org/project/oauth</a></li>
<li>Refer to the simple OAuth module for OAuth 2.0 support at <a href="https://www.drupal.org/project/simple_oauth">https://www.drupal.org/project/simple_oauth</a></li>
<li>Refer to the IP Consumer Auth module at <a href="https://www.drupal.org/project/ip_consumer_auth">https://www.drupal.org/project/ip_consumer_auth</a></li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Using JSON API</h1>
                </header>
            
            <article>
                
<p>When developing a backend API for frontend consumers, there is often much debate on naming conventions and returned value structures. In comes <kbd>{json:api}</kbd>, an open source specification set to standardize and simplify the building of APIs, which consume and return JSON payloads. The specification and documentation can be found at <a href="http://jsonapi.org/">http://jsonapi.org/</a>.</p>
<p>For Drupal, there is a community-lead effort to provide a robust JSON API specification implementation to turn Drupal into a streamlined API server. This recipe will install the JSON API module and show how to enable resources.</p>
<p>Just like the RESTful Web Services module provided by Drupal core, the JSON API module does not provide a user interface. It also enables all content to be available over the API automatically (given that users have permissions configured to access the endpoint.) The JSON API Extra module changes that, and this will be covered in the <em>There's more...</em> section of this recipe.</p>
<p>The JSON API module can be found at <a href="https://www.drupal.org/project/jsonapi">https://www.drupal.org/project/jsonapi</a></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Getting ready</h1>
                </header>
            
            <article>
                
<p>Create sample content using the <kbd>Article</kbd> content type provided by the standard Drupal installation. This will make testing the GET methods much easier.</p>
<p>When making requests, all endpoint paths are prefixed with <kbd>jsonapi</kbd>.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How to do it</h1>
                </header>
            
            <article>
                
<ol>
<li>First, we must add the JSON API module to our Drupal site:</li>
</ol>
<pre style="padding-left: 60px">cd /path/to/drupal8<br/>composer require drupal/jsonapi</pre>
<ol start="2">
<li>Install the <span class="packt_screen">JSON API</span> and <span class="packt_screen">Serialization</span> module. Once the module is installed, the API endpoints will be active.:</li>
</ol>
<div class="CDPAlignCenter CDPAlign"><img class="image-border" src="assets/d3e32ab7-f92b-44c0-9f8d-32120d746e96.png"/></div>
<ol start="3">
<li>To perform a request, you must pass an Accept header with the value <kbd>application/vnd.api+json</kbd>.</li>
<li>For the JSON API specification, every resource must have a unique type name, and JSON API derives this from the entity type and its bundle. The endpoint for retrieving Article nodes will be:</li>
</ol>
<pre style="padding-left: 60px">http://127.0.0.1:8888/jsonapi/node/article</pre>
<ol start="5">
<li>The entire request can be executed with the following command:</li>
</ol>
<pre style="padding-left: 60px">curl -X GET \<br/>  http://127.0.0.1:8888/jsonapi/node/article \<br/>  -H 'accept: application/vnd.api+json'</pre>
<ol start="6">
<li>The response will resemble the following. The content values will be in the attributes property:</li>
</ol>
<pre style="padding-left: 60px">{<br/>  <span>"data"</span><span>: </span>[<br/>    {<br/>      <span>"type"</span><span>: </span><span>"node--article"</span><span>,<br/></span><span>      </span><span>"id"</span><span>: </span><span>"c897acba-eb81-454a-94ed-13107fd205cf"</span><span>,<br/></span><span>      </span><span>"attributes"</span><span>: </span>{...}<span>,<br/></span><span>      </span><span>"relationships"</span><span>: </span>{...}<span>,<br/></span><span>      </span><span>"links"</span><span>: </span>{<br/>        <span>"self"</span><span>: </span><span>"http://127.0.0.1:8888/jsonapi/node/article/c897acba-eb81-454a-94ed-13107fd205cf"<br/></span><span>      </span>}<br/>    }<br/>  ]<span>,<br/></span><span>  </span><span>"links"</span><span>: </span>{<br/>    <span>"self"</span><span>: </span><span>"http://127.0.0.1:8888/jsonapi/node/article"</span><span>,<br/></span><span>  </span>}<br/>}</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How it works...</h1>
                </header>
            
            <article>
                
<p>The JSON API module implements the <kbd>{json:api}</kbd> specification. Like the RESTful Web Services module provided by Drupal core, it exposes data over various endpoints. It builds on top of Drupal's existing routing system to work with non-HTML formats. The major difference is it follows a community-driven specification on how the data should be formatted, linked, filtered, sorted, and more.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">There's more...</h1>
                </header>
            
            <article>
                
<p>Next, we'll cover filtering, paging, sorting, and the JSON API Extras module.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Paginating, filtering, and sorting requests</h1>
                </header>
            
            <article>
                
<p>The request in the recipe will return all available Article nodes in the system. These can be paginated, filtered, and sorted. Each of these operations is done through query parameters, which contain an array of values.</p>
<p>Pagination is done by appending a <kbd>page</kbd> query parameter. To limit the request to 10 nodes, we would append <kbd>?page[limit]=10</kbd>. To access the next set of results, we would also pass <kbd>page[offset]=10</kbd>.</p>
<p>The following is an example of returning the first and second pages of results:</p>
<pre>http://127.0.0.1:8888/jsonapi/node/article?page[limit]=10<br/>http://127.0.0.1:8888/jsonapi/node/article?page[offset]=10&amp;page[limit]=10</pre>
<p>Each request contains a links property; this will also contain the next and previous links when using a paginated result.</p>
<p>Filtering is done by appending a <kbd>filter</kbd> query parameter. The following is an example for requesting all nodes that have been promoted to the front page:</p>
<pre>http://127.0.0.1:8888/jsonapi/node/article?filter[promoted][path]=promote&amp;filter[promoted][value]=1&amp;filter[promoted][operator]==</pre>
<p>Each filter is defined by a name--in the preceding example, it is <kbd>promoted</kbd>. The filter then takes <kbd>path</kbd>, which is the field to filter on. The <kbd>value</kbd> and <kbd>operator</kbd> decide how to filter.</p>
<p>Sorting is the simplest operation. A sort query parameter is added. The field name value is the field to sort by, and to sort in descending order, you add a minute symbol in front of the field name. The following examples show how to sort by the <kbd>nid</kbd> in ascending and descending order, respectively:</p>
<pre>http://127.0.0.1:8888/jsonapi/node/article?sort=nid<br/>http://127.0.0.1:8888/jsonapi/node/article?sort=-nid</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Installing the JSON API Extras module</h1>
                </header>
            
            <article>
                
<p>The JSON API Extras module provides a user interface for additional customization. The JSON API Extras module should be added to your Drupal installation like all other modules, using Composer:</p>
<pre>cd /path/to/drupal8<br/>composer require drupal/jsonapi_extras</pre>
<p>Once the module is installed in Drupal, you will have the ability to enable or disable endpoints, change resource names, alter resource paths, disable fields, alias field names, and enhance field outputs.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Changing the API path prefix</h1>
                </header>
            
            <article>
                
<p>The API path prefix can be changed from <kbd>jsonapi</kbd> to <kbd>api</kbd> or any other prefix using the extras module.</p>
<p>From the administrative toolbar, navigate to <span class="packt_screen">Configuration</span>. Under the <span class="packt_screen">Web services</span> section, click on <span class="packt_screen">JSON API Overwrites</span> to customize the JSON API implementation. The <span class="packt_screen">Settings</span> tab allows modification of the API path prefix:</p>
<div class="CDPAlignCenter CDPAlign"><img class="image-border" src="assets/4b4ec93f-c4d3-4312-b274-064987cc096c.png"/></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Disabling and enhancing returned entity fields</h1>
                </header>
            
            <article>
                
<p>The JSON API Extras module allows overwriting endpoints automatically exposed by the JSON API module. This allows disabling fields from being returned. It also allows using enhancers to simplify the structure of a field property.</p>
<p>From the administrative toolbar, go to <span class="packt_screen">Configuration</span>. Under the <span class="packt_screen">Web services</span> section, click on <span class="packt_screen">JSON API Overwrites</span> to customize the JSON API implementation.</p>
<p>To disable an endpoint, click on <span class="packt_screen">Overwrite</span> on any endpoint. Check the <span class="packt_screen">Disabled</span> checkbox to turn off that specific endpoint:</p>
<div class="CDPAlignCenter CDPAlign"><img height="243" width="510" class="image-border" src="assets/467d2d17-7adc-4448-8020-6802ac5546ba.png"/></div>
<p>To disable, alias, or use an enhancer, click on <span class="packt_screen">Overwrite</span> on any endpoint. The checkbox will allow you to prevent a field from being used in the API. The enhancers allow you to simplify fields when returned or used in POST/PATCH requests:</p>
<div class="CDPAlignCenter CDPAlign"><img class="image-border" src="assets/de9a7553-27da-4a7e-8fca-182561faa36d.png"/></div>
<p>In this example, the <kbd>created</kbd> and <kbd>changed</kbd> fields will no longer return Unix timestamps, but RFC ISO8601-formatted timestamps. The <kbd>promote</kbd> and <kbd>sticky</kbd> fields will return their value directly, not nested under a <kbd>value</kbd> property. Finally, no revision information fields will be returned.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Contenta CMS</h1>
                </header>
            
            <article>
                
<p>Contenta CMS is a decoupled, API-driven Drupal distribution built using the JSON API. It is being built through the same community initiative pushing forward the JSON API module. The project's home page can be found at <a href="http://www.contentacms.org/.">http://www.contentacms.org/.</a></p>
<p>It provides many preconfigured options, including customizations to default endpoints. It also provides Simple OAuth to set up decoupled authentication with your frontend consumer and the API backend.</p>
<p>On top of delivering a distribution, the community contributors have developed various frontend consumers as examples:</p>
<ul>
<li><strong>Angular</strong>: <a href="https://github.com/contentacms/contenta_angular">https://github.com/contentacms/contenta_angular</a></li>
<li><strong>Vue/Nuxt</strong>: <a href="https://github.com/contentacms/contenta_vue_nuxt">https://github.com/contentacms/contenta_vue_nuxt</a></li>
<li><strong>Ember.js</strong>: <a href="https://github.com/contentacms/contenta_ember">https://github.com/contentacms/contenta_ember</a></li>
<li><strong>Ionic</strong>: <a href="https://github.com/contentacms/contenta_ionic">https://github.com/contentacms/contenta_ionic</a></li>
<li><strong>React</strong>: <a href="https://github.com/contentacms/contenta_react">https://github.com/contentacms/contenta_react</a></li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">See also</h1>
                </header>
            
            <article>
                
<ul>
<li>JSON API project page at <a href="https://www.drupal.org/project/jsonapi">https://www.drupal.org/project/jsonapi</a></li>
<li>JSON API Extras page <span>at</span> <a href="https://www.drupal.org/project/jsonapi_extras">https://www.drupal.org/project/jsonapi_extras</a></li>
<li>JSON API module documentation <span>at</span> <a href="https://www.drupal.org/docs/8/modules/json-api/json-api">https://www.drupal.org/docs/8/modules/json-api/json-api</a></li>
<li>JSON API module video tutorials <span>at</span> <a href="https://www.youtube.com/playlist?list=PLZOQ_ZMpYrZsyO-3IstImK1okrpfAjuMZ">https://www.youtube.com/playlist?list=PLZOQ_ZMpYrZsyO-3IstImK1okrpfAjuMZ</a></li>
<li>The <kbd>{json:api}</kbd> specification documentation <span>at</span> <a href="http://jsonapi.org/">http://jsonapi.org/</a></li>
</ul>


            </article>

            
        </section>
    </body></html>