- en: Plug and Play with Plugins
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 插件即插即用
- en: 'In this chapter, we will dive into the new Plugin API provided in Drupal 8:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将深入探讨 Drupal 8 中提供的新插件 API：
- en: Creating blocks using plugins
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用插件创建块
- en: Creating a custom field type
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建自定义字段类型
- en: Creating a custom field widget
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建自定义字段小部件
- en: Creating a custom field formatter
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建自定义字段格式化器
- en: Creating a custom plugin type
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建自定义插件类型
- en: Introduction
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简介
- en: Drupal 8 introduces plugins. Plugins power many items in Drupal, such as blocks,
    field types, and field formatters. Plugins and plugin types are provided by modules.
    They provide a swappable and specific functionality. Breakpoints, as discussed
    in *[Chapter 5](991ad206-3a73-4c3a-b6b7-c680a0a74a53.xhtml)*, *Front End for the
    Win*, are plugins. In this chapter, we will discuss how plugins work in Drupal
    8 and show you how to create blocks, fields, and custom plugin types.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: Drupal 8 引入了插件。插件在 Drupal 中驱动许多项目，例如块、字段类型和字段格式化器。插件和插件类型由模块提供。它们提供可交换和特定的功能。正如在*[第
    5 章](991ad206-3a73-4c3a-b6b7-c680a0a74a53.xhtml)*，*前端为王*中讨论的，断点也是插件。在本章中，我们将讨论插件在
    Drupal 8 中的工作方式，并展示如何创建块、字段和自定义插件类型。
- en: Each version of Drupal has subsystems, which provided pluggable components and
    contributed modules. However, the implementation and management of these subsystems
    presented a problem. Blocks, fields, and image styles each had an entirely different
    system to be learned and understood. The Plugin API exists in Drupal 8 to mitigate
    this problem and provide a base API to implement pluggable components. This has
    greatly improved the developer experience when working with Drupal core's subsystems.
    In this chapter, we will implement a block plugin. We will use the Plugin API
    to provide a custom field type along with a widget and formatter for the field.
    The last recipe will show you how to create and use a custom plugin type.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 每个版本的 Drupal 都有子系统，它们提供了可插拔的组件和贡献模块。然而，这些子系统的实现和管理带来了问题。块、字段和图像样式各自有不同的系统需要学习和理解。插件
    API 存在于 Drupal 8 中，以减轻这个问题并提供一个基础 API 来实现可插拔组件。这大大提高了与 Drupal 核心子系统一起工作的开发者体验。在本章中，我们将实现一个块插件。我们将使用插件
    API 来提供自定义字段类型以及字段的部件和格式化器。最后一个食谱将向您展示如何创建和使用自定义插件类型。
- en: Creating blocks using plugins
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用插件创建块
- en: In Drupal, a block is a piece of content that can be placed in a region provided
    by a theme. Blocks are used to present specific kinds of content, such as a user
    login form, a snippet of text, and many more.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Drupal 中，块是可以放置在主题提供的区域中的内容片段。块用于展示特定类型的内容，例如用户登录表单、文本片段等等。
- en: Blocks are annotated plugins. Annotated plugins use documentation blocks to
    provide details of the plugin. They are discovered in the module's `Plugin` class
    namespace. Each class in the `Plugin/Block` namespace will be discovered by the
    Block module's plugin manager.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 块是注解插件。注解插件使用文档块来提供插件的详细信息。它们在模块的 `Plugin` 类命名空间中被发现。`Plugin/Block` 命名空间中的每个类都将被块模块的插件管理器发现。
- en: In this recipe, we will define a block that will display a copyright snippet
    and the current year and place it in the footer region.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在本食谱中，我们将定义一个块，该块将显示版权片段和当前年份，并将其放置在页脚区域：
- en: Getting ready
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: Create a new module like the one shown in this recipe, with a defined `info.yml`
    so that it can be discovered by Drupal. We will refer to the module as `mymodule`
    throughout the recipe. Use your module's appropriate name.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个新模块，如本食谱中所示，并定义 `info.yml` 以便 Drupal 能够发现它。在整个食谱中，我们将把该模块称为 `mymodule`。请使用您模块的适当名称。
- en: How to do it...
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作...
- en: Create a `src/Plugin/Block` directory in your module. This will translate the
  id: totrans-17
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在您的模块中创建一个 `src/Plugin/Block` 目录。这将翻译
- en: '`\Drupal\mymodule\Plugin\Block` namespace and allow a block plugin discovery.'
  id: totrans-18
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`\Drupal\mymodule\Plugin\Block` 命名空间并允许块插件发现。'
- en: 'Create a `Copyright.php` file in the newly created folder so that we can define
    the `Copyright` class for our block:'
  id: totrans-19
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在新创建的文件夹中创建一个 `Copyright.php` 文件，以便我们可以为我们的块定义 `Copyright` 类：
- en: '![](img/3132c724-4b2f-492d-8390-5ececa50251f.png)'
  id: totrans-20
  prefs: []
  type: TYPE_IMG
  zh: '![](img/3132c724-4b2f-492d-8390-5ececa50251f.png)'
- en: 'The `Copyright` class will extend the `\Drupal\Core\Block\BlockBase` class:'
  id: totrans-21
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Copyright` 类将扩展 `\Drupal\Core\Block\BlockBase` 类：'
- en: '[PRE0]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: We will extend the `BlockBase` class, which implements `\Drupal\Core\Block\BlockPluginInterface`
    and provides us with an implementation of nearly all of the interface's methods.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将扩展实现 `\Drupal\Core\Block\BlockPluginInterface` 的 `BlockBase` 类，并为我们提供接口几乎所有方法的实现。
- en: 'We will provide the block''s identifier, administrative label, and category:'
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将提供块的标识符、管理标签和类别：
- en: '[PRE1]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The annotation document block of the class identifies the type of plugin through
    `@Block`. Drupal will parse this and initiate the plugin with the properties defined
    inside it. The `id` is the internal machine name, the `admin_label` is displayed
    on the block listing page, and `category` shows up in the block select list.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 类的注释文档块通过 `@Block` 识别插件类型。Drupal 将解析此信息并使用其中定义的属性启动插件。`id` 是内部机器名称，`admin_label`
    在块列表页面上显示，而 `category` 则出现在块选择列表中。
- en: 'We will need to provide a `build` method to satisfy the `\Drupal\Core\Block\BlockPluginInterface`
    interface. This returns the output to be displayed:'
  id: totrans-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要提供一个 `build` 方法以满足 `\Drupal\Core\Block\BlockPluginInterface` 接口。这个方法返回要显示的输出：
- en: '[PRE2]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The `build` method returns a render array that uses Drupal's `t` function to
    substitute `@year` for the `\DateTime` object's output that is formatted as a
    full year.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: '`build` 方法返回一个使用 Drupal 的 `t` 函数替换 `@year` 的渲染数组，该数组是格式化为完整年份的 `\DateTime`
    对象的输出。'
- en: Since PHP 5.4, a warning will be displayed if you have not set a timezone explicitly
    in your PHP's configuration.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 自 PHP 5.4 以来，如果您在 PHP 的配置中没有明确设置时区，将会显示警告。
- en: Install your module if it has not yet been installed by going to the Extend
    page. If you have already installed your module, go to the Performance page and
    rebuild Drupal's caches.
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果您的模块尚未安装，请通过访问扩展页面来安装您的模块。如果您已经安装了您的模块，请转到性能页面并重新构建 Drupal 的缓存。
- en: Go to the Black layout page from Structure in the administrative menu. In the
    Footer fourth region, click on Place block.
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从管理菜单中的结构进入黑色布局页面。在页脚第四区域中，点击放置块。
- en: 'Review the block list and add the custom block to your regions, for instance,
    the footer region. Find the Copyright block, and click on Place block:'
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 审查块列表，并将自定义块添加到您的区域中，例如页脚区域。找到版权块，并点击放置块：
- en: '![](img/6b474e7f-89bf-4305-b45f-c8cd2074cd38.png)'
  id: totrans-34
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/6b474e7f-89bf-4305-b45f-c8cd2074cd38.png)'
- en: Uncheck the Display title checkbox so that only our block's content can be rendered.
    Click on Save block and accept all of the other defaults.
  id: totrans-35
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 取消选择显示标题复选框，以便只渲染我们的块内容。点击保存块并接受所有其他默认设置。
- en: 'View your Drupal site, and verify that the copyright statement will always
    keep the year dynamic:'
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 查看您的 Drupal 网站，并验证版权声明将始终保持年份动态：
- en: '![](img/f48f78d9-fe2d-4b93-a6d8-3f26380c114b.png)'
  id: totrans-37
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/f48f78d9-fe2d-4b93-a6d8-3f26380c114b.png)'
- en: How it works...
  id: totrans-38
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The plugin system works through plugin definitions and plugin managers for those
    definitions. The `\Drupal\Core\Block\BlockManager` class defines the block plugins
    that need be located in the `Plugin/Block` namespace. It also defines the base
    interface that needs to be implemented along with the `Annotation` class, which
    is to be used when parsing the class's document block.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 插件系统通过插件定义和插件管理器来实现。`\Drupal\Core\Block\BlockManager` 类定义了需要位于 `Plugin/Block`
    命名空间中的块插件。它还定义了需要实现的基接口，以及用于解析类的文档块的 `Annotation` 类。
- en: When Drupal's cache is rebuilt, all available namespaces are scanned to check
    whether classes exist in the given plugin namespace. The definitions, via annotation,
    will be processed, and the information will be cached.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 当 Drupal 的缓存重新构建时，所有可用的命名空间都会被扫描以检查在给定的插件命名空间中是否存在类。通过注释处理定义，并将信息缓存起来。
- en: Blocks are then retrieved from the manager, manipulated, and their methods are
    invoked. When viewing the `Block layout` page to manage blocks, the `\Drupal\Core\Block\BlockBase`
    class's `label` method is invoked to display the human-readable name. When a block
    is displayed on a rendered page, the `build` method is invoked and passed to the
    theming layer to be output.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 然后从管理器检索块，对其进行操作，并调用其方法。在查看 `块布局` 页面以管理块时，会调用 `\Drupal\Core\Block\BlockBase`
    类的 `label` 方法以显示可读名称。当一个块在渲染的页面上显示时，会调用 `build` 方法并将其传递给主题层以输出。
- en: There's more...
  id: totrans-42
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更多...
- en: There are more in-depth items that can be used when creating a block plugin.
    We will cover those in the following sections.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建块插件时，可以使用更多深入的项目。我们将在以下部分中介绍这些内容。
- en: Altering blocks
  id: totrans-44
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 修改块
- en: 'Blocks can be altered in three different ways: the plugin definition can be
    altered, the build array, or the view array out.'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 块可以通过三种不同的方式修改：修改插件定义、修改构建数组或修改视图数组。
- en: 'A module can implement `hook_block_alter` in its `.module` file and modify
    the annotation definitions of all the discovered blocks. This will allow a module
    to change the default `user_login_block` from user login to `Login`:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 一个模块可以在其 `.module` 文件中实现 `hook_block_alter` 并修改所有发现的块的注释定义。这将允许模块将默认的 `user_login_block`
    从用户登录更改为 `Login`：
- en: '[PRE3]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'A module can implement `hook_block_build_alter` and modify the build information
    of a block. The hook is passed through the build array and the `\Drupal\Core\Block\BlockPluginInterface`
    instance for the current block. Module developers can use this to add cache contexts
    or alter the cache ability of the metadata:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 一个模块可以实现 `hook_block_build_alter` 并修改块的构建信息。钩子通过构建数组和当前块的 `\Drupal\Core\Block\BlockPluginInterface`
    实例传递。模块开发者可以使用此功能添加缓存上下文或更改元数据的缓存能力：
- en: '[PRE4]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: You can test the modification of the cache metadata by altering the recipe's
    block to output a timestamp. With caching enabled, you will see that the value
    persists on the same URL, but it will be different across each page.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过更改食谱的块以输出时间戳来测试缓存元数据的修改。启用缓存后，您将看到值在相同的URL上持续存在，但每个页面的值将不同。
- en: 'Finally, a module can implement `hook_block_view_alter` in order to modify
    the output to be rendered. A module can add content to be rendered or removed.
    This can be used to remove the `contextual_links` item, which allows inline editing
    on the front page of a site:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，一个模块可以实现 `hook_block_view_alter` 以修改要渲染的输出。模块可以添加要渲染的内容或删除内容。这可以用来删除 `contextual_links`
    项，这允许在网站的首页上进行内联编辑：
- en: '[PRE5]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Block settings forms
  id: totrans-53
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 块设置表单
- en: Blocks can provide a `setting` form. This recipe provides the text *My Company*
    for the copyright text. Instead, this can be defined through a text field in the
    block's setting form.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 块可以提供一个 `setting` 表单。本菜谱为版权文本提供了文本 *My Company*。相反，这可以通过块设置表单中的文本字段来定义。
- en: Let's readdress the `Copyright.php` file that holds our block's class. We will
    override methods provided by our base class. The following methods will be added
    to the class written in this recipe.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们重新审视包含我们块类的 `Copyright.php` 文件。我们将覆盖基类提供的方法。以下方法将被添加到本食谱中编写的类中。
- en: 'A block can override the default `defaultConfiguration` method, which returns
    an array of setting keys and their default values. The `blockForm` method can
    then override the `\Drupal\Core\Block\BlockBase` empty array implementation to
    return a Form API array to represent the settings form:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 一个块可以覆盖默认的 `defaultConfiguration` 方法，该方法返回一个设置键及其默认值的数组。然后 `blockForm` 方法可以覆盖
    `\Drupal\Core\Block\BlockBase` 的空数组实现，以返回一个表单API数组来表示设置表单：
- en: '[PRE6]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The `blockSubmit` method must then be implemented, which updates the block''s
    configuration:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，必须实现 `blockSubmit` 方法，该方法更新块的配置：
- en: '[PRE7]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Finally, the `build` method can be updated to use the new configuration item:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，可以将 `build` 方法更新为使用新的配置项：
- en: '[PRE8]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: You can now return to the `Block layout` form, and click on Configure in the
    Copyright block. The new setting will be available in the block instance's configuration
    form.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 您现在可以返回到 `块布局` 表单，并在版权块上单击配置。新的设置将在块实例的配置表单中可用。
- en: Defining access to a block
  id: totrans-63
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 定义块的访问权限
- en: 'Blocks, by default, are rendered for all users. The default access method can
    be overridden. This allows a block to only be displayed to authenticated users
    or based on a specific permission:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，块会为所有用户渲染。默认访问方法可以被覆盖。这允许块只对认证用户或基于特定权限的用户显示：
- en: '[PRE9]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The preceding code is taken from the `user_login_block`. It allows access to
    the block if the user is logged out and is not in the login or logout page. The
    access is cached based on the current route name and the user's current role being
    anonymous. If these are not passed, the access returned is forbidden and the block
    is not built.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码来自 `user_login_block`。它允许在用户注销且不在登录或注销页面时访问块。访问基于当前路由名称和用户当前角色为匿名者进行缓存。如果没有传递这些，则返回的访问被禁止，并且块不会被构建。
- en: 'Other modules can implement `hook_block_access` to override the access of a
    block:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 其他模块可以实现 `hook_block_access` 以覆盖块的访问权限：
- en: '[PRE10]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: A module implementing the preceding hook will deny access to our Copyright block
    if it is not placed in the footer region.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 实现上述钩子的模块将阻止我们的版权块在没有放置在页脚区域时访问。
- en: See also
  id: totrans-70
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参见
- en: Refer to the *Creating a custom plugin type* recipe of this chapter
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 参考本章的 *创建自定义插件类型* 菜谱
- en: Refer to annotations-based plugins at [https://www.drupal.org/docs/8/api/plugin-api/annotations-based-plugins](https://www.drupal.org/docs/8/api/plugin-api/annotations-based-plugins)
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 请参考基于注释的插件文档，链接为[https://www.drupal.org/docs/8/api/plugin-api/annotations-based-plugins](https://www.drupal.org/docs/8/api/plugin-api/annotations-based-plugins)
- en: Information on `block.api.php` is available at [https://api.drupal.org/api/drupal/core%21modules%21block%21block.api.php/8](https://api.drupal.org/api/drupal/core%21modules%21block%21block.api.php/8)
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 关于`block.api.php`的信息可在[https://api.drupal.org/api/drupal/core%21modules%21block%21block.api.php/8](https://api.drupal.org/api/drupal/core%21modules%21block%21block.api.php/8)找到
- en: Creating a custom field type
  id: totrans-74
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建自定义字段类型
- en: Field types are defined using the plugin system. Each field type has its own
    class and definition. A new field type can be defined through a custom class that
    will provide schema and property information.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 字段类型是通过插件系统定义的。每种字段类型都有自己的类和定义。可以通过自定义类来定义新的字段类型，该类将提供模式和属性信息。
- en: In this example, we will create a simple field type called *real name* to store
    the first and last names.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 在本例中，我们将创建一个简单的字段类型，称为*真实姓名*，用于存储姓氏和名字。
- en: Field types define ways in which data can be stored and handled through the
    Field API. Field widgets provides means for editing a field type in the user interface.
    Field formatters provide means for displaying the field data to users. Both are
    plugins and will be covered in later recipes.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 字段类型定义了通过Field API存储和处理数据的方式。字段小部件提供了在用户界面中编辑字段类型的方法。字段格式化器提供了向用户显示字段数据的方法。两者都是插件，将在后续食谱中介绍。
- en: Getting ready
  id: totrans-78
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: Create a new module like the one shown in this recipe, with a defined `info.yml`
    so that it can be discovered by Drupal. We will refer to the module as `mymodule`
    throughout the recipe. Use your module's appropriate name.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个新模块，类似于本食谱中展示的模块，并定义一个`info.yml`文件，以便Drupal能够发现它。在整个食谱中，我们将把这个模块称为`mymodule`。请使用你模块的适当名称。
- en: How to do it...
  id: totrans-80
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作...
- en: We will need to create the `src/Plugin/Field/FieldType` directory in the module's
    base location. The `Field` module discovers field types in the `Plugin\Field\FieldType`
    namespace.
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要在模块的基本位置创建`src/Plugin/Field/FieldType`目录。`Field`模块在`Plugin\Field\FieldType`命名空间中查找字段类型。
- en: 'We will create a `RealName.php` file in the newly created directory so that
    we can define the `RealName` class. This will provide our `realname` field for
    the first and last names:'
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将在新创建的目录中创建一个`RealName.php`文件，以便我们可以定义`RealName`类。这将为我们提供用于姓氏和名字的`realname`字段：
- en: '![](img/78b1e92a-3bef-4f77-a5c9-468f1afbf8f1.png)'
  id: totrans-83
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/78b1e92a-3bef-4f77-a5c9-468f1afbf8f1.png)'
- en: 'The `RealName` class will extend the `\Drupal\Core\Field\FieldItemBase` class:'
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`RealName`类将扩展`\Drupal\Core\Field\FieldItemBase`类：'
- en: '[PRE11]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The `\Drupal\Core\Field\FieldItemBase` satisfies methods defined by inherited
    interfaces, except for `schema` and `propertyDefinitions`.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '`\Drupal\Core\Field\FieldItemBase`满足继承接口定义的方法，除了`schema`和`propertyDefinitions`。'
- en: 'Field types are annotated plugins. Annotated plugins use documentation blocks
    to provide details of the plugin. We will provide the field type''s identifier,
    label, description, category, and default widget and formatter:'
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 字段类型是注释插件。注释插件使用文档块来提供插件详情。我们将提供字段类型的标识符、标签、描述、类别和默认小部件和格式化器：
- en: '[PRE12]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The `@FieldType` tells Drupal that this is a `FieldType` plugin. The following
    properties are defined:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '`@FieldType`告诉Drupal这是一个`FieldType`插件。以下属性被定义：'
- en: '`Id`: This is the plugin''s machine name'
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Id`：这是插件的机器名'
- en: '`Label`: This is the human-readable name for the field'
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Label`：这是字段的可读性名称'
- en: '`description`: This is the human-readable description of the field'
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`description`：这是字段的可读性描述'
- en: '`category`: This is the category where the field shows up in the user interface'
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`category`：这是字段在用户界面中显示的类别'
- en: '`default_widget`: This is the default form widget to be used for editing'
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`default_widget`：这是用于编辑的默认表单小部件'
- en: '`default_formatter`: This is the default formatter with which you can display
    the field'
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`default_formatter`：这是可以用来显示字段的默认格式化器'
- en: The `RealName` class needs to implement the `schema` method defined in the
  id: totrans-96
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`RealName`类需要实现定义在'
- en: '`\Drupal\Core\Field\FieldItemInterface`. This returns an array of the database
    API schema information. Add the following method to your class:'
  id: totrans-97
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`\Drupal\Core\Field\FieldItemInterface`。这返回一个数据库API模式信息的数组。请向你的类中添加以下方法：'
- en: '[PRE13]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The `schema` method defines the columns in the field's data table. We will define
    a column to hold the `first_name` and `last_name` values.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '`schema`方法定义了字段数据表中的列。我们将定义一个列来存储`first_name`和`last_name`值。'
- en: 'We will also need to implement the `propertySchema` method to satisfy `\Drupal\Core\TypedData\ComplexDataDefinitionInterface`.
    This returns a typed definition of the values defined in the `schema` method.
    Add the following method to your class:'
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们还需要实现 `propertySchema` 方法以满足 `\Drupal\Core\TypedData\ComplexDataDefinitionInterface`。此方法返回
    `schema` 方法中定义的值的类型化定义。将以下方法添加到您的类中：
- en: '[PRE14]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: This method returns an array that is keyed with the same column names provided
    in `schema`. It returns a typed data definition to handle the field type's values.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法返回一个数组，其键与`schema`中提供的列名相同。它返回一个类型化数据定义来处理字段类型的值。
- en: Install your module, if it has not yet been installed, by going to the Extend
    page. If you have already installed your module, go to the Performance page and
    rebuild Drupal's caches.
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果尚未安装，请通过访问扩展页面来安装您的模块。如果您已经安装了您的模块，请转到性能页面并重新构建 Drupal 的缓存。
- en: 'The field will now appear on the field type management screen. To use it, go
    to Structure and then to Comment Types. You can now go to Manage Fields and click
    on Add field to add a real name entry for your comments:'
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 字段现在将出现在字段类型管理屏幕上。要使用它，请转到结构，然后转到评论类型。现在您可以转到管理字段并点击添加字段来为您的评论添加真实姓名条目：
- en: '![](img/c00a768d-b6f6-4957-83be-500e1ceb4343.png)'
  id: totrans-105
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/c00a768d-b6f6-4957-83be-500e1ceb4343.png)'
- en: How it works...
  id: totrans-106
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Drupal core defines a `plugin.manager.field.field_type` service. By default,
    this is handled through the `\Drupal\Core\Field\FieldTypePluginManager` class.
    This plugin manager defines the field type plugins that should be in the `Plugin/Field/FieldType`
    namespace, and all the classes in this namespace will be loaded and assumed to
    be field type plugins.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: Drupal 核心定义了一个 `plugin.manager.field.field_type` 服务。默认情况下，这是通过 `\Drupal\Core\Field\FieldTypePluginManager`
    类来处理的。此插件管理器定义了应位于 `Plugin/Field/FieldType` 命名空间中的字段类型插件，并且该命名空间中的所有类都将被加载并假定是字段类型插件。
- en: The manager's definition also sets `\Drupal\Core\Field\FieldItemInterface` as
    the expected interface that all the field type plugins will implement. This is
    why most field types extend `\Drupal\Core\Field\FieldItemBase` to meet these method
    requirements.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 管理器的定义还设置了 `\Drupal\Core\Field\FieldItemInterface` 作为所有字段类型插件将实现的预期接口。这就是为什么大多数字段类型都扩展
    `\Drupal\Core\Field\FieldItemBase` 以满足这些方法要求。
- en: As field types are annotated plugins, the manager provides `\Drupal\Core\Field\Annotation\FieldType`
    as the class that fulfills the annotation definition.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 由于字段类型是注解插件，管理器提供了 `\Drupal\Core\Field\Annotation\FieldType` 作为满足注解定义的类。
- en: When the user interface defines the available fields, the `plugin.manager.field.field_type`
    service is invoked to retrieve a list of available field types.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户界面定义可用的字段时，将调用 `plugin.manager.field.field_type` 服务以检索可用字段类型的列表。
- en: There's more...
  id: totrans-111
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: Existing field types can be altered to modify their definitions, and custom
    field types can implement a method to define whether the value is empty or not.
    We will cover these in the next sections.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 可以修改现有的字段类型以修改它们的定义，并且自定义字段类型可以实现一个方法来定义值是否为空。我们将在下一节中介绍这些内容。
- en: Altering field types
  id: totrans-113
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 修改字段类型
- en: 'The `\Drupal\Core\Field\FieldTypePluginManager` class defines the `alter` method
    as `field_info.` Modules that implement `hook_field_info_alter` in their `.module`
    files have the ability to modify field type definitions discovered by the manager:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '`\Drupal\Core\Field\FieldTypePluginManager` 类将 `alter` 方法定义为 `field_info`。实现
    `.module` 文件中的 `hook_field_info_alter` 的模块有权修改由管理器发现的字段类型定义：'
- en: '[PRE15]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The preceding `alter` method will change the human-readable label for the email
    field to **E-mail address** when selecting the field in the user interface.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的 `alter` 方法将在用户界面中选择字段时将电子邮件字段的易读标签更改为 **电子邮件地址**。
- en: Defining whether a field is empty
  id: totrans-117
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 定义字段是否为空
- en: The `\Drupal\Core\TypedDate\ComplexDataInterface` interface provides an `isEmpty`
    method. This method is used to check whether the field's value is empty, for example,
    when verifying that the required field has data. The `\Drupal\Core\TypedData\Plugin\DataType\Map`
    class implements the method. By default, the method ensures that the values are
    not empty.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: '`\Drupal\Core\TypedDate\ComplexDataInterface` 接口提供了一个 `isEmpty` 方法。此方法用于检查字段值是否为空，例如，在验证所需字段是否有数据时。`\Drupal\Core\TypedData\Plugin\DataType\Map`
    类实现了此方法。默认情况下，此方法确保值不为空。'
- en: Field types can provide their own implementations to provide a more robust verification.
    For instance, the field can validate that the first name can be entered but not
    the last name, or the field can require both the first and the last name.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 字段类型可以提供它们自己的实现以提供更健壮的验证。例如，字段可以验证可以输入第一个名称但不能输入最后一个名称，或者字段可以要求输入第一个和最后一个名称。
- en: See also
  id: totrans-120
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参见
- en: Refer to the *Creating blocks using plugins* recipe of this chapter
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 参考本章的 *使用插件创建块* 配方
- en: Creating a custom field widget
  id: totrans-122
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建自定义字段小部件
- en: Field widgets provide the form interface to edit a field. These integrate with
    the Form API to define how a field can be edited and the way in which the data
    can be formatted before it is saved. Field widgets are chosen and customized through
    the form display interface.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 字段小部件提供了编辑字段的表单界面。这些与表单 API 集成，以定义字段如何编辑以及数据在保存之前如何格式化。字段小部件通过表单显示界面进行选择和定制。
- en: In this recipe, we will create a widget for the field created in the *Creating
    a custom field type* recipe in this chapter. The field widget will provide two
    text fields for entering the first and last name items.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 在本配方中，我们将创建一个用于本章中 *创建自定义字段类型* 配方中创建的字段的表单小部件。字段小部件将为输入第一个和最后一个名称项提供两个文本字段。
- en: Getting ready
  id: totrans-125
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: Create a new module, such as the one from the *Creating a custom field type*
    recipe. We will refer to the module as `mymodule` throughout the recipe. Use your
    module's appropriate name.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个新的模块，例如来自 *创建自定义字段类型* 的配方。在整个配方中，我们将把该模块称为 `mymodule`。使用您模块的适当名称。
- en: How to do it...
  id: totrans-127
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作...
- en: We will need to create the `src/Plugin/Field/FieldWidget` directory in the module's
    base location. The `Field` module discovers field widgets in the `Plugin\Field\FieldWidget`
    namespace.
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要在模块的基本位置创建 `src/Plugin/Field/FieldWidget` 目录。`Field` 模块在 `Plugin\Field\FieldWidget`
    命名空间中查找字段小部件。
- en: 'Create a `RealNameDefaultWidget.php` file in the newly created directory so
    that we can define the `RealNameDefaultWidget` class. This will provide a custom
    form element to edit the first and last name values of our field:'
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在新创建的目录中创建一个 `RealNameDefaultWidget.php` 文件，以便我们可以定义 `RealNameDefaultWidget`
    类。这将提供一个自定义表单元素来编辑我们字段的第一个和最后一个名称值：
- en: '![](img/a85a2ae6-6ff9-4201-83f1-dc8324210c62.png)'
  id: totrans-130
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/a85a2ae6-6ff9-4201-83f1-dc8324210c62.png)'
- en: 'The `RealNameDefaultWidget` class will extend the `\Drupal\Core\Field\WidgetBase`
    class:'
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`RealNameDefaultWidget` 类将扩展 `\Drupal\Core\Field\WidgetBase` 类：'
- en: '[PRE16]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'We will provide the field widget''s identifier, label, and supported field
    types in the plugin''s annotation:'
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将在插件的注解中提供字段小部件的标识符、标签和支持的字段类型：
- en: '[PRE17]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The `@FieldWidget` tells Drupal that this is a field widget plugin. It defines
    `id` to represent the machine name, the human-readable name as `label`, and the
    field types that the widget interacts with.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: '`@FieldWidget` 告诉 Drupal 这是一个字段小部件插件。它定义了 `id` 来表示机器名，可读名称为 `label`，以及小部件交互的字段类型。'
- en: 'We will need to implement the `formElement` method to satisfy the remaining
    `interface` methods after extending `\Drupal\Core\Field\WidgetBase`. Add the following
    method to your class:'
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要实现 `formElement` 方法以满足在扩展 `\Drupal\Core\Field\WidgetBase` 后剩余的 `interface`
    方法。将以下方法添加到您的类中：
- en: '[PRE18]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The `formElement` method returns a Form API array that represents the widget
    to be set and edits the field data.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: '`formElement` 方法返回一个表示要设置的表单 API 数组的数组，并编辑字段数据。'
- en: 'Next, we will need to modify our original `RealName` field type plugin class
    to use the default widget that we created. Modify the `src/Plugin/FieldType/RealName.php`
    file, and update the `default_widget` annotation property as `realname_default`:'
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们需要修改我们的原始 `RealName` 字段类型插件类，以使用我们创建的默认小部件。修改 `src/Plugin/FieldType/RealName.php`
    文件，并将 `default_widget` 注解属性更新为 `realname_default`：
- en: '[PRE19]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Rebuild Drupal's cache so that the plugin system can discover the new field
    widget.
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 重建 Drupal 的缓存，以便插件系统可以发现新的字段小部件。
- en: 'Add a `Real name` field and use the new `Real name` widget. For example, add
    it to a comment type:'
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个 `Real name` 字段并使用新的 `Real name` 小部件。例如，将其添加到评论类型中：
- en: '![](img/94d856c2-3142-4ca5-bd1f-fd39fbf6d075.png)'
  id: totrans-143
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/94d856c2-3142-4ca5-bd1f-fd39fbf6d075.png)'
- en: How it works...
  id: totrans-144
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工作原理...
- en: Drupal core defines a `plugin.manager.field.widget` service. By default, this
    is handled through the `\Drupal\Core\Field\FieldWidgetPluginManager` class. This
    plugin manager defines the field widget plugins that should be in the `Plugin/Field/FieldWidget`
    namespace, and all the classes in this namespace will be loaded and assumed to
    be field widget plugins.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: Drupal 核心定义了一个 `plugin.manager.field.widget` 服务。默认情况下，这是通过 `\Drupal\Core\Field\FieldWidgetPluginManager`
    类处理的。这个插件管理器定义了应在 `Plugin/Field/FieldWidget` 命名空间中的字段小部件插件，并且这个命名空间中的所有类都将被加载并被假定是字段小部件插件。
- en: The manager's definition also sets `\Drupal\Core\Field\FieldWidgetInterface`
    as the expected interface that all the field widget plugins will implement. This
    is why most field types extend `\Drupal\Core\Field\WidgetBase` to meet these method
    requirements.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 管理器的定义也将 `\Drupal\Core\Field\FieldWidgetInterface` 设置为所有字段小部件插件应实现的预期接口。这就是为什么大多数字段类型都扩展
    `\Drupal\Core\Field\WidgetBase` 来满足这些方法要求。
- en: As field widgets are annotated plugins, the manager provides `\Drupal\Core\Field\Annotation\FieldWidget`
    as the class that fulfills the annotation definition.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 由于字段小部件是注解插件，管理器提供 `\Drupal\Core\Field\Annotation\FieldWidget` 作为满足注解定义的类。
- en: The entity form display system uses the `plugin.manager.field.widget` service
    to load field definitions and add the field's element returned from the `formElement`
    method to the entity form.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 实体表单显示系统使用 `plugin.manager.field.widget` 服务来加载字段定义并将从 `formElement` 方法返回的字段元素添加到实体表单中。
- en: There's more...
  id: totrans-149
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更多...
- en: Field widgets have additional methods to provide more information; they are
    covered in the next section.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 字段小部件有额外的方法来提供更多信息；它们将在下一节中介绍。
- en: Field widget settings and summary
  id: totrans-151
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 字段小部件设置和摘要
- en: 'The `\Drupal\Core\Field\WidgetInterface` interface defines three methods that
    can be overridden to provide a settings form and a summary of the current settings:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: '`\Drupal\Core\Field\WidgetInterface` 接口定义了三个可以被重写的方法，用于提供设置表单和当前设置的摘要：'
- en: '`defaultSettings`: This returns an array of the setting keys and default values'
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`defaultSettings`：这个方法返回一个设置键和默认值的数组'
- en: '`settingsForm`: This returns a Form API array that is used for the settings
    form'
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`settingsForm`：这个方法返回一个用于设置表单的 Form API 数组'
- en: '`settingsSummary`: This allows an array of strings to be returned and displayed
    on the manage display form for the field'
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`settingsSummary`：这个方法允许返回并显示在字段管理显示表单上的字符串数组'
- en: Widget settings can be used to alter the form presented to the user. A setting
    can be created that allows the field element to be limited to only enter the first
    or last name with one text field.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用小部件设置来更改用户看到的表单。可以创建一个设置，允许字段元素仅通过一个文本字段输入姓名的首字母或最后一个字母。
- en: See also
  id: totrans-157
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参见
- en: The *Creating a custom plugin type* recipe of this chapter
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 本章的 *创建自定义插件类型* 食谱
- en: Creating a custom field formatter
  id: totrans-159
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建自定义字段格式化器
- en: Field formatters define the way in which a field type will be presented. These
    formatters return the render array information to be processed by the theming
    layer. Field formatters are configured on the display mode interfaces.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 字段格式化器定义了字段类型将被呈现的方式。这些格式化器返回由主题层处理的渲染数组信息。字段格式化器在显示模式接口上进行配置。
- en: In this recipe, we will create a formatter for the field created in the *Creating
    a custom field type* recipe in this chapter. The field formatter will display
    the first and last names with some settings.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 在本食谱中，我们将创建一个格式化器，用于本章中 *创建自定义字段类型* 食谱中创建的字段。字段格式化器将显示一些设置下的姓名的首字母和最后一个字母。
- en: Getting ready
  id: totrans-162
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: Create a new module like the one existing in the first recipe. We will refer
    to the module as `mymodule` throughout the recipe. Use your module's appropriate
    name.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个新的模块，就像第一个食谱中已有的那样。在本食谱中，我们将把模块称为 `mymodule`。使用你模块的适当名称。
- en: How to do it...
  id: totrans-164
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作...
- en: We will need to create the `src/Plugin/Field/FieldFormatter` directory in the
    module's base location. The `Field` module discovers field formatters in the `Plugin\Field\FieldFormatter`
    namespace.
  id: totrans-165
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要在模块的基础位置创建 `src/Plugin/Field/FieldFormatter` 目录。`Field` 模块在 `Plugin\Field\FieldFormatter`
    命名空间中查找字段格式化器。
- en: 'Create a `RealNameFormatter.php` file in the newly created directory so that
    we can define the `RealNameFormatter` class. This will provide a custom form element
    to display the field''s values:'
  id: totrans-166
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在新创建的目录中创建一个 `RealNameFormatter.php` 文件，以便我们可以定义 `RealNameFormatter` 类。这将提供一个自定义表单元素来显示字段的值：
- en: '![](img/4a0f7c40-5b64-43e7-a563-d521dfe719ce.png)'
  id: totrans-167
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/4a0f7c40-5b64-43e7-a563-d521dfe719ce.png)'
- en: 'The `RealNameFormatter` class will extend the `\Drupal\Core\Field\FormatterBase`
    class:'
  id: totrans-168
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`RealNameFormatter` 类将扩展 `\Drupal\Core\Field\FormatterBase` 类：'
- en: '[PRE20]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'We will provide the field widget''s identifier, label, and supported field
    types:'
  id: totrans-170
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将提供字段小部件的标识符、标签和支持的字段类型：
- en: '[PRE21]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'We will need to implement the `viewElements` method to satisfy the `\Drupal\Core\Field\FormatterInferface`
    interface. This is used to render the field data. Add the following method to
    your class:'
  id: totrans-172
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要实现 `viewElements` 方法以满足 `\Drupal\Core\Field\FormatterInferface` 接口。这用于渲染字段数据。将以下方法添加到您的类中：
- en: '[PRE22]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Next, we will need to modify our original `RealName` field type''s `plugin`
    class to use the default formatter that we created. Open the `src/Plugin/FieldType/RealName.php`
    file, and update the `default_formatter` annotation property as `realname_one_line`:'
  id: totrans-174
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们需要修改我们原始的 `RealName` 字段类型的 `plugin` 类，以使用我们创建的默认格式化器。打开 `src/Plugin/FieldType/RealName.php`
    文件，并将 `default_formatter` 注解属性更新为 `realname_one_line`：
- en: '[PRE23]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Rebuild Drupal's cache so that the plugin system can discover the new field
    widget.
  id: totrans-176
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 重建Drupal的缓存，以便插件系统可以发现新的字段小部件。
- en: 'Update an entity view mode with a `Real name` field to use the Real name (one
    line) formatter:'
  id: totrans-177
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更新一个具有 `Real name` 字段的实体视图模式，以使用真实姓名（单行）格式化器：
- en: '![](img/33d64166-03d6-4a18-b099-a13b7d85cf40.png)'
  id: totrans-178
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/33d64166-03d6-4a18-b099-a13b7d85cf40.png)'
- en: How it works...
  id: totrans-179
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Drupal core defines a `plugin.manager.field.formatter` service. By default,
    this is handled through the `\Drupal\Core\Field\FormatterPluginManager` class.
    This plugin manager defines the field formatter plugins that should be in the
    `Plugin/Field/FieldFormatter` namespace, and all the classes in this namespace
    will be loaded and assumed to be field formatter plugins.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: Drupal核心定义了一个 `plugin.manager.field.formatter` 服务。默认情况下，这是通过 `\Drupal\Core\Field\FormatterPluginManager`
    类处理的。此插件管理器定义了应在 `Plugin/Field/FieldFormatter` 命名空间中的字段格式化器插件，并且该命名空间中的所有类都将被加载并假定是字段格式化器插件。
- en: The manager's definition also sets `\Drupal\Core\Field\FormatterInterface` as
    the expected interface that all field formatter plugins will implement. This is
    why most field formatters extend `\Drupal\Core\Field\FormatterBase` to meet these
    method requirements.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 管理器的定义也将 `\Drupal\Core\Field\FormatterInterface` 设置为所有字段格式化器插件将实现的预期接口。这就是为什么大多数字段格式化器都扩展
    `\Drupal\Core\Field\FormatterBase` 来满足这些方法要求。
- en: As field formatters are annotated plugins, the manager provides `\Drupal\Core\Field\Annotation\FieldFormatter`
    as the class that fulfills the annotation definition.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 由于字段格式化器是注解插件，管理器提供 `\Drupal\Core\Field\Annotation\FieldFormatter` 作为满足注解定义的类。
- en: The entity view display system uses the `plugin.manager.field.formatter` service
    to load field definitions and add the field's render array, returned from the
    `viewElements` method, to the entity view render array.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 实体视图显示系统使用 `plugin.manager.field.formatter` 服务来加载字段定义并将从 `viewElements` 方法返回的字段渲染数组添加到实体视图渲染数组中。
- en: There's more...
  id: totrans-184
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: Field formatters have additional methods to provide more information; they are
    covered in the next section.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 字段格式化器有额外的方法来提供更多信息；它们将在下一节中介绍。
- en: Formatter settings and summary
  id: totrans-186
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 格式化器设置和摘要
- en: 'The `\Drupal\Core\Field\FormatterInterface` interface defines three methods
    that can be overridden to provide a settings form and a summary of the current
    settings:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: '`\Drupal\Core\Field\FormatterInterface` 接口定义了三个可以重写的方法，以提供设置表单和当前设置的摘要：'
- en: '`defaultSettings`: This returns an array of the setting keys and default values'
  id: totrans-188
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`defaultSettings`: 这返回一个设置键和默认值的数组'
- en: '`settingsForm`: This returns a Form API array that is used for the settings
    form'
  id: totrans-189
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`settingsForm`: 这返回一个用于设置表单的表单API数组'
- en: '`settingsSummary`: This allows an array of strings to be returned and displayed
    on the manage display form for the field'
  id: totrans-190
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`settingsSummary`: 这允许返回并显示在字段管理显示表单上的字符串数组'
- en: Settings can be used to alter how the formatter displays information. For example,
    these methods can be implemented to provide settings to hide or display the first
    or last name.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 设置可以用来改变格式化器显示信息的方式。例如，可以实现这些方法来提供设置以隐藏或显示姓名的首字母或最后一个字母。
- en: See also
  id: totrans-192
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参见
- en: Refer to the *Creating a custom plugin type* recipe of this chapter.
  id: totrans-193
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 参考本章的 *创建自定义插件类型* 菜谱。
- en: Creating a custom plugin type
  id: totrans-194
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建自定义插件类型
- en: The plugin system provides a means to create specialized objects in Drupal that
    do not require the data storage features of the entity system.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 插件系统提供了一种在Drupal中创建专用对象的方法，这些对象不需要实体系统的数据存储功能。
- en: This recipe is based on the **GeoIP API** module port to Drupal 8 that was started
    by the author. The **GeoIP API** module provides a way to get the country from
    a website visitor's IP address.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 本食谱基于作者启动的将**GeoIP API**模块移植到Drupal 8的项目。**GeoIP API**模块提供了一种从网站访问者的IP地址获取国家的方法。
- en: In this recipe, we will create a new plugin type called `GeoLocator` that will
    return the country code for a given IP address. We will create a plugin manager,
    a default plugin interface, a plugin annotation definition, and provide a default
    plugin to find the country via the website's CDN.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 在本食谱中，我们将创建一个名为`GeoLocator`的新插件类型，该类型将返回给定IP地址的国家代码。我们将创建一个插件管理器、默认插件接口、插件注解定义，并提供一个默认插件，通过网站的CDN查找国家。
- en: Getting ready
  id: totrans-198
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: We will use the `geoip` namespace and module name in this recipe.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 在本食谱中，我们将使用`geoip`命名空间和模块名称。
- en: How to do it...
  id: totrans-200
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作...
- en: All plugins need to have a service that acts as a plugin manager. Create a new
    file in your module's `src` directory called `GeoLocatorManager.php`. This will
    hold the `GeoLocatorManager` class.
  id: totrans-201
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 所有插件都需要有一个作为插件管理器的服务。在你的模块的`src`目录中创建一个新文件，命名为`GeoLocatorManager.php`。这将保存`GeoLocatorManager`类。
- en: 'Create the `GeoLocatorManager` class by extending the `\Drupal\Core\Plugin\DefaultPluginManager`
    class:'
  id: totrans-202
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过扩展`\Drupal\Core\Plugin\DefaultPluginManager`类创建`GeoLocatorManager`类：
- en: '[PRE24]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'When creating a new plugin type, it is recommended that the plugin manager
    provides a set of defaults for new plugins, in case an item is missing from the
    definition:'
  id: totrans-204
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当创建一个新的插件类型时，建议插件管理器为新插件提供一组默认值，以防定义中缺少项目：
- en: '[PRE25]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Next, we will need to override the `\Drupal\Core\Plugin|DefaultPluginManager`
    class constructor to define the module handler and cache backend:'
  id: totrans-206
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们需要覆盖`\Drupal\Core\Plugin\DefaultPluginManager`类的构造函数以定义模块处理程序和缓存后端：
- en: '[PRE26]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: We override the constructor so that we can specify a specific cache key. This
    allows plugin definitions to be cached and cleared properly; otherwise, our plugin
    manager will continuously read the disk to find plugins.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 我们覆盖构造函数，以便可以指定特定的缓存键。这允许插件定义被正确缓存和清除；否则，我们的插件管理器将不断从磁盘读取以查找插件。
- en: 'The next step will be to create a `geoip.services.yml` file in our module''s
    root directory. This will describe our plugin manager to Drupal, allowing a plugin
    discovery:'
  id: totrans-209
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下一步将在我们模块的根目录下创建一个`geoip.services.yml`文件。这将描述我们的插件管理器给Drupal，允许插件发现：
- en: '[PRE27]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Drupal utilizes services and dependency injection. By defining our class as
    a service, we are telling the application container how to initiate our class.
    We can use the `parent` definition to tell the container to use the same arguments
    as the `default_plugin_manager` definition.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: Drupal利用服务和依赖注入。通过将我们的类定义为服务，我们告诉应用程序容器如何初始化我们的类。我们可以使用`parent`定义来告诉容器使用与`default_plugin_manager`定义相同的参数。
- en: 'All annotation-based plugins must provide a class, which serves as the annotation
    definition. Create `GeoLocator.php` in `src/Annotation` to provide the `GeoLocator`
    annotation class:'
  id: totrans-212
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 所有基于注解的插件都必须提供一个类，该类作为注解定义。在`src/Annotation`目录下创建`GeoLocator.php`文件以提供`GeoLocator`注解类：
- en: '[PRE28]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Each property is an item that can be defined in the plugin's annotation. The
    annotated definition will start with `@GeoLocator` for our plugins.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 每个属性都是可以在插件注解中定义的项目。对于我们的插件，注解定义将始于`@GeoLocator`。
- en: 'Next, we will define the plugin interface that we defined in the plugin manager.
    The plugin manager will validate the `GeoLocator` plugins that implement this
    interface. Create a `GeoLocatorInterface.php` file in our module''s `src/Plugin/GeoLocator`
    directory to hold the interface:'
  id: totrans-215
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将定义在插件管理器中定义的插件接口。插件管理器将验证实现此接口的`GeoLocator`插件。在我们的模块的`src/Plugin/GeoLocator`目录下创建一个`GeoLocatorInterface.php`文件以保存接口：
- en: '[PRE29]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: We provide an interface so that we can guarantee that we have these expected
    methods when working with a `GeoLocator` plugin, and that we have an output, regardless
    of the logic behind each method.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 我们提供了一个接口，以确保在处理`GeoLocator`插件时，我们有这些预期的方法，并且无论每个方法背后的逻辑如何，都有输出。
- en: 'Next, we will create a default plugin, which returns the country code from
    CDN headers, if available. In `src/Plugin/GeoLocator`, create a `Cdn.php` file
    for our `Cdn` plugin class:'
  id: totrans-218
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将创建一个默认插件，如果可用，则从CDN头中返回国家代码。在`src/Plugin/GeoLocator`目录下创建一个`Cdn.php`文件以创建我们的`Cdn`插件类：
- en: '[PRE30]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: The `GeoLocator` plugin type is now set, with a default CDN-based plugin.
  id: totrans-220
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`GeoLocator`插件类型现在已设置，并带有默认的基于CDN的插件。'
- en: How it works...
  id: totrans-221
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Drupal 8 implements a service container, a concept adopted from the Symfony
    framework. In order to implement a plugin, there needs to be a manager who can
    discover and process plugin definitions. This manager is defined as a service
    in a module's `services.yml` with its required constructor parameters. This allows
    the service container to initiate the class when it is required.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: Drupal 8 实现了一个服务容器，这是一个从 Symfony 框架中采用的概念。为了实现一个插件，需要有一个可以发现和处理插件定义的管理器。这个管理器在模块的
    `services.yml` 文件中定义为一个服务，并带有其所需的构造函数参数。这允许服务容器在需要时启动类。
- en: In our example, the `GeoLocatorManager` plugin manager discovers the `GeoLocator`
    plugin definitions through annotated plugin discovery. After the first discovery,
    all the known plugin definitions are then cached under the `geolocator_plugins`
    cache key.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的示例中，`GeoLocatorManager` 插件管理器通过注解插件发现来发现 `GeoLocator` 插件定义。在第一次发现之后，所有已知的插件定义都将在
    `geolocator_plugins` 缓存键下缓存。
- en: Plugin managers also provide a method to return these definitions or create
    an object instance based on an available definition. For the CDN plugin, this
    would be a full instantiated `Cdn` class object.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 插件管理器还提供了一个方法来返回这些定义或基于可用定义创建一个对象实例。对于 CDN 插件，这将是一个完整的实例化的 `Cdn` 类对象。
- en: 'Let''s consider the following example:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们考虑以下示例：
- en: '[PRE31]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: There's more...
  id: totrans-227
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: There are many additional items for creating a custom plugin type; we will discuss
    some of them in the following sections.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 创建自定义插件类型有许多附加项；我们将在以下章节中讨论其中的一些。
- en: Specifying an alter hook
  id: totrans-229
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 指定一个修改钩子
- en: 'Plugin managers have the ability to define an alter hook. The following line
    of code will be added to the `GeoLocatorManager` class''s constructor to provide
    `hook_geolocator_plugins_alter`. This is passed to the module handler service
    for invocations:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 插件管理器有定义一个修改钩子的能力。以下代码行将被添加到 `GeoLocatorManager` 类的构造函数中，以提供 `hook_geolocator_plugins_alter`。这将被传递给模块处理服务以进行调用：
- en: '[PRE32]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Modules implementing `hook_geolocator_plugins_alter` in the `.module` file have
    the ability to modify all the discovered plugin definitions. They also have the
    ability to remove defined plugin entries or alter any information provided for
    the annotation definition.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 实现 `.module` 文件中的 `hook_geolocator_plugins_alter` 的模块具有修改所有发现插件定义的能力。它们还具有删除定义的插件条目或修改为注解定义提供的任何信息的功能。
- en: Using a cache backend
  id: totrans-233
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用缓存后端
- en: Plugins can use a cache backend to improve performance. This can be done by
    specifying a cache backend with the `setCacheBackend` method in the manager's
    constructor. The following line of code will allow the `Unit` plugins to be cached
    and only discovered on a cache rebuild.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 插件可以使用缓存后端来提高性能。这可以通过在管理器的构造函数中使用 `setCacheBackend` 方法来指定缓存后端来实现。以下代码行将允许 `Unit`
    插件被缓存，并且只在缓存重建时被发现。
- en: The `$cache_backend` variable is passed to the constructor. The second parameter
    provides the cache key. The cache key will have the current language code added
    as a suffix.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: '`$cache_backend` 变量传递给构造函数。第二个参数提供缓存键。缓存键将添加当前语言代码作为后缀。'
- en: There is an optional third parameter that takes an array of strings to represent
    cache tags that will cause the plugin definitions to be cleared. This is an advanced
    feature, and plugin definitions should normally be cleared through the manager's
    `clearCachedDefinitions` method. The cache tags allow the plugin definitions to
    be cleared when a relevant cache is cleared as well.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 有一个可选的第三个参数，它接受一个字符串数组，表示将导致插件定义被清除的缓存标签。这是一个高级功能，插件定义通常应通过管理器的 `clearCachedDefinitions`
    方法来清除。缓存标签允许在相关缓存被清除时清除插件定义。
- en: Accessing plugins through the manager
  id: totrans-237
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通过管理器访问插件
- en: 'Plugins are loaded through the manager service, which should always be accessed
    through the service container. The following line of code will be used in your
    module''s hooks or classes to access the plugin manager:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 插件通过管理服务加载，应始终通过服务容器来访问。以下代码行将在您的模块的钩子或类中使用，以访问插件管理器：
- en: '[PRE33]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Plugin managers have various methods for retrieving plugin definitions, which
    are as follows:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 插件管理器有各种方法来检索插件定义，如下所示：
- en: '`getDefinitions`: This method will return an array of plugin definitions. It
    first makes an attempt to retrieve cached definitions, if any, and sets the cache
    of discovered definitions before returning them.'
  id: totrans-241
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`getDefinitions`：此方法将返回一个插件定义数组。它首先尝试检索缓存的定义（如果有），然后在返回之前设置已发现定义的缓存。'
- en: '`getDefinition`: This takes an expected plugin ID and returns its definition.'
  id: totrans-242
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`getDefinition`: 这接受一个预期的插件ID并返回其定义。'
- en: '`createInstance`: This takes an expected plugin ID and returns an initiated
    class for the plugin.'
  id: totrans-243
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`createInstance`: 这接受一个预期的插件ID并返回该插件的初始化类。'
- en: '`getInstance`: This takes an array that acts as a plugin definition and returns
    an initiated class from the definition.'
  id: totrans-244
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`getInstance`: 这接受一个充当插件定义的数组，并从定义中返回一个初始化类。'
- en: See also
  id: totrans-245
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参见
- en: Refer to services and dependency injection at [https://www.drupal.org/node/2133171](https://www.drupal.org/node/2133171)
  id: totrans-246
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 请参阅[https://www.drupal.org/node/2133171](https://www.drupal.org/node/2133171)中的服务和依赖注入
