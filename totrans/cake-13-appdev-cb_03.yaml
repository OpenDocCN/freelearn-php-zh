- en: Chapter 3. Pushing the Search
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第3章。推动搜索
- en: 'In this chapter, we will cover:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖：
- en: Performing GROUP and COUNT queries
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 执行GROUP和COUNT查询
- en: Using virtual fields
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用虚拟字段
- en: Building queries with ad-hoc JOINs
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用临时JOIN构建查询
- en: Searching for all items that match search terms
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 搜索所有匹配搜索词的项目
- en: Implementing a custom find type
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现自定义查找类型
- en: Paginating a custom find type
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 分页自定义查找类型
- en: Implementing AJAX-based pagination
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现基于AJAX的分页
- en: Introduction
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简介
- en: Using models to fetch data is one of the most important aspects of any CakePHP
    application. As such, a good use of the find functions the framework provides
    can certainly guarantee the success of our application, and as importantly ensure
    that our code is readable and maintainable.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 使用模型获取数据是任何CakePHP应用程序最重要的方面之一。因此，合理使用框架提供的查找函数可以确保我们应用程序的成功，并且同样重要的是确保我们的代码可读性和可维护性。
- en: 'CakePHP provides the following basic find types:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: CakePHP提供了以下基本查找类型：
- en: '`all`: To find all records that match the given find options.'
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`all`：用于查找所有匹配给定查找选项的记录。'
- en: '`count`: To count how many records match the given options.'
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`count`：用于计算匹配给定选项的记录数量。'
- en: '`first`: To find the first record that matches the given find options.'
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`first`：用于查找匹配给定查找选项的第一个记录。'
- en: '`list`: To find all records that match the given find options, and formats
    them as a list, using the format provided.'
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`list`：用于查找所有匹配给定查找选项的记录，并使用提供的格式格式化。'
- en: '`neighbors`: To find the previous and after records of a matching record, based
    on the value of a particular field.'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`neighbors`：根据特定字段的值查找匹配记录的前一个和后一个记录。'
- en: '`threaded`: To finds a set of results, and return them in a hierarchy, based
    on the value of a field named `parent_id`.'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`threaded`：查找一组结果，并根据名为`parent_id`的字段值返回它们作为层次结构。'
- en: Mastering these types is as easy as understanding the available find options
    all types deal with. In this chapter, we have several recipes to make the most
    out of these options, and to resort to manual SQL based queries when the need
    arises.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 掌握这些类型就像理解所有类型都处理的可用查找选项一样简单。在本章中，我们有几个食谱来充分利用这些选项，并在需要时手动执行基于SQL的查询。
- en: CakePHP also lets us define our custom find types that will extend the three
    basic ones, allowing our code to be even more readable. The last recipes in this
    chapter show us how to create our own find type, with pagination support.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: CakePHP还允许我们定义自己的自定义查找类型，这将扩展三个基本类型，使我们的代码更加易于阅读。本章的最后几个食谱展示了如何创建自己的查找类型，并支持分页。
- en: Performing GROUP and COUNT queries
  id: totrans-20
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 执行GROUP和COUNT查询
- en: This recipe shows how to use CakePHP's built-in find types to perform relatively
    complex `GROUP` and `COUNT` queries, including the combination of both.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 这个食谱展示了如何使用CakePHP的内置查找类型来执行相对复杂的`GROUP`和`COUNT`查询，包括两者的组合。
- en: Getting ready
  id: totrans-22
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: To go through this recipe we need some sample tables to work with.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 为了完成这个食谱，我们需要一些示例表来操作。
- en: 'Create a table named `users`, using the following SQL statement:'
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下SQL语句创建一个名为`users`的表：
- en: '[PRE0]'
  id: totrans-25
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Create a table named `blogs`, using the following SQL statement:'
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下SQL语句创建一个名为`blogs`的表：
- en: '[PRE1]'
  id: totrans-27
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Create a table named `posts`, using the following SQL statement:'
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下SQL语句创建一个名为`posts`的表：
- en: '[PRE2]'
  id: totrans-29
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Add some sample data, using the following SQL statements:'
  id: totrans-30
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下SQL语句添加一些示例数据：
- en: '[PRE3]'
  id: totrans-31
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'We proceed now to create the required model. Create the model `Post` in a file
    named `post.php` and place it in your `app/models` folder with the following contents:'
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们现在继续创建所需的模型。在名为`post.php`的文件中创建模型`Post`，并将其放置在您的`app/models`文件夹中，内容如下：
- en: '[PRE4]'
  id: totrans-33
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'We will put all our example code in the `index()` method of a controller. Create
    a file named `posts_controller.php` and place it in your `app/controllers` folder
    with the following contents:'
  id: totrans-34
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将所有示例代码放入控制器的`index()`方法中。创建一个名为`posts_controller.php`的文件，并将其放置在您的`app/controllers`文件夹中，内容如下：
- en: '[PRE5]'
  id: totrans-35
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Now, create a folder named `posts` and place it in your `app/views` folder.
    Inside this newly created folder, create a file named `index.ctp`, with the following
    contents:'
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，创建一个名为`posts`的文件夹，并将其放置在您的`app/views`文件夹中。在这个新创建的文件夹内，创建一个名为`index.ctp`的文件，内容如下：
- en: '[PRE6]'
  id: totrans-37
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: How to do it...
  id: totrans-38
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Grouping rows by a certain field is as simple as specifying the group setting
    when issuing a `find` operation. For example, the following statement, while not
    exactly practical by itself, shows how to use the setting:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 通过指定`find`操作时的分组设置，按某个字段对行进行分组就像简单一样。例如，以下语句虽然本身并不实用，但展示了如何使用设置：
- en: '[PRE7]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'If we also want to obtain the number of rows for each grouped set, which in
    our case means the number of posts per blog, we would do:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们还想获取每个分组集的行数，在我们的例子中意味着每个博客的帖子数，我们会这样做：
- en: '[PRE8]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The preceding query will return the following data structure:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的查询将返回以下数据结构：
- en: '[PRE9]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Let us now make sure that every time we have a calculated field (which come
    in the index `0` of each resulting row), they become part of the resulting model,
    for easier readability. To do so, we override the `afterFind()` method. If you
    don''t have one already, create a file named `app_model.php` in your `app/` folder.
    Make sure your `AppModel` class includes the following contents:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们确保每次我们有一个计算字段（这些字段在每个结果行的索引`0`中），它们都成为结果模型的一部分，以便更容易阅读。为此，我们覆盖`afterFind()`方法。如果您还没有，请确保在您的`app/`文件夹中创建一个名为`app_model.php`的文件。确保您的`AppModel`类包含以下内容：
- en: '[PRE10]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Note
  id: totrans-47
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Whenever you override a model method, such as `beforeFind()` or `afterFind()`,
    make sure you call the parent implementation by using the `parent` keyword.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 每次覆盖模型方法，如`beforeFind()`或`afterFind()`，请确保通过使用`parent`关键字调用父实现。
- en: 'As a result, the previous query, which uses `GROUP` and `COUNT`, will now look
    like a much more readable result set:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，之前使用`GROUP`和`COUNT`的查询现在将看起来像一个非常可读的结果集：
- en: '[PRE11]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'If we want to subdivide the post counts for each blog according to the month
    they were created on, we would have to add another level of grouping:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想要根据创建月份细分每个博客的帖子数，我们必须添加另一个分组级别：
- en: '[PRE12]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Considering our `afterFind` implementation, the preceding query would produce
    the following results:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到我们的`afterFind`实现，前面的查询将产生以下结果：
- en: '[PRE13]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: How it works...
  id: totrans-55
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: We use the `group` find setting to specify what fields will be used for grouping
    the resulting rows. That setting is given as an array, where each element is a
    field to group in. When we specify more than one field, such as the last example
    in the recipe, grouping of rows occurs in the given order of grouping fields.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`group`查找设置来指定将用于对结果行进行分组的字段。该设置以数组的形式给出，其中每个元素是要分组的字段。当我们指定多个字段时，例如菜谱中的最后一个示例，行分组将按照分组字段的给定顺序进行。
- en: 'Calculated fields, that is, expressions that result in a value (such as the
    `COUNT(*) AS total` expression used throughout the recipe) are placed in the index
    `0` of each resulting row, because they are not real fields defined in the model.
    Because of that, we overrode the `afterFind()` method, executed after a result
    for a find operation is obtained, and with some basic logic we make sure those
    calculated fields get included in the resulting row within a much more readable
    index: the model name.'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 计算字段，即产生值的表达式（如菜谱中使用的`COUNT(*) AS total`表达式），放置在每个结果行的索引`0`中，因为它们不是在模型中定义的真实字段。正因为如此，我们覆盖了`afterFind()`方法，在获取查找操作的结果后执行，并使用一些基本逻辑确保这些计算字段被包含在结果行中，以一个更可读的索引：模型名称。
- en: The last example in the recipe shows not only how to group on more than one
    field, but how to properly use some SQL methods (such as `MONTH` and `YEAR`) with
    an alias, so we can easily return the value of that expression and also use it
    to group or optionally order the rows.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 菜谱中的最后一个示例不仅展示了如何在多个字段上进行分组，而且还展示了如何正确使用一些SQL方法（如`MONTH`和`YEAR`）以及别名，这样我们就可以轻松返回该表达式的值，并使用它来分组或可选地排序行。
- en: See also
  id: totrans-59
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 参见
- en: '*Using virtual fields*'
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*使用虚拟字段*'
- en: Using virtual fields
  id: totrans-61
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*使用虚拟字段*'
- en: In the recipe, *Performing GROUP and COUNT queries*, we learnt how to add computed
    SQL expressions to a `find` operation. Some of these expressions may be needed
    regularly for a model, introducing the need for virtual fields.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 在菜谱中，*执行GROUP和COUNT查询*，我们学习了如何将计算SQL表达式添加到`find`操作中。其中一些表达式可能需要定期用于模型，从而引入了虚拟字段的需求。
- en: Using virtual fields, we get the resulting values of our SQL expressions as
    if they were real fields of our models. They allow us to get the same results
    shown in the previous recipe in a much more transparent way, without needing the
    override of `afterFind`.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 使用虚拟字段，我们可以得到SQL表达式的结果值，就像它们是我们模型的真实字段一样。这使我们能够以前更透明的方式得到之前菜谱中显示的相同结果，而不需要覆盖`afterFind`。
- en: Getting ready
  id: totrans-64
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: We need some sample models and data to work with. Follow the *Getting ready*
    section of the recipe, *Performing GROUP and COUNT queries*.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要一些示例模型和数据来工作。遵循菜谱中的*准备工作*部分，*执行GROUP和COUNT查询*。
- en: How to do it...
  id: totrans-66
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Open the `Post` model and add the `virtualfields` definition shown as follows:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 打开`Post`模型并添加以下所示的`virtualfields`定义：
- en: '[PRE14]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'To obtain a count of all the posts per blog, grouped by the period they were
    created, we do:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 要获取按创建周期分组的每篇博客的所有帖子计数，我们执行以下操作：
- en: '[PRE15]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Using our sample data, the preceding query will result in the following array
    structure, which is exactly the same result as the one obtained in the last example
    shown in the recipe *Performing GROUP and COUNT queries*:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 使用我们的示例数据，前面的查询将产生以下数组结构，这与在*执行GROUP和COUNT查询*的最后一个示例中获得的完全相同的结果：
- en: '[PRE16]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Virtual fields are always obtained when issuing a `find` operation on the model.
    The only real way to avoid including them is specifying a list of fields to obtain
    in the find, and omitting the virtual fields:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 在对模型执行`find`操作时，总是获取虚拟字段。唯一真正避免包含它们的方法是指定要获取的字段列表，并省略虚拟字段：
- en: '[PRE17]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Note
  id: totrans-75
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The `schema()` model function returns the list of real fields in the model,
    with information about each field, such as data type, and length.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '`schema()`模型函数返回模型中的实际字段列表，包括每个字段的信息，例如数据类型和长度。'
- en: 'We will now add a way for us to manage which virtual fields, if any, are returned.
    To do so, we override the `beforeFind()` and `afterFind()` model methods. If you
    don''t have one already, create a file named `app_model.php` in your `app/` folder.
    Make sure your `AppModel` class includes the following contents:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在将添加一种方法，使我们能够管理哪些虚拟字段（如果有的话）被返回。为此，我们重写`beforeFind()`和`afterFind()`模型方法。如果您还没有，请确保在您的`app/`文件夹中创建一个名为`app_model.php`的文件。确保您的`AppModel`类包含以下内容：
- en: '[PRE18]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'If we want to disable virtual fields when issuing a `find` operation, we can
    easily do so by specifying the `virtualFields` find setting to `false`. We can
    also set it to the list of virtual fields we want to include. For example, to
    only include the `period` virtual field, we do:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想在执行`find`操作时禁用虚拟字段，我们可以通过指定`virtualFields`查找设置为`false`来轻松实现。我们也可以将其设置为想要包含的虚拟字段列表。例如，要仅包含`period`虚拟字段，我们执行以下操作：
- en: '[PRE19]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: How it works...
  id: totrans-81
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: CakePHP treats virtual fields almost as if they were real model fields. They
    are not exactly like real fields because we cannot specify a value for a virtual
    field when creating / editing a model record. However, in regards to `find` operations,
    they are treated like any other field.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: CakePHP将虚拟字段几乎视为真实模型字段。它们并不完全像真实字段，因为我们不能在创建/编辑模型记录时为虚拟字段指定一个值。然而，在`find`操作方面，它们被像任何其他字段一样对待。
- en: Virtual fields are included on every `find` operation performed against the
    model to which they belong. However, there are times were we don't want or need
    certain virtual fields. This is particularly important when we include virtual
    fields that depend on grouping expressions, such as `COUNT`, as they affect the
    number of rows returned. In these cases, we want to be able to specify what, or
    even if, virtual fields should be returned.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 虚拟字段在针对它们所属的模型执行每个`find`操作时都会被包含。然而，有时我们不想或不需要某些虚拟字段。这在我们包含依赖于分组表达式（如`COUNT`）的虚拟字段时尤为重要，因为它们会影响返回的行数。在这些情况下，我们希望能够指定应该返回什么，甚至是否应该返回虚拟字段。
- en: To allow us to control virtual fields returned from a `find` operation, we add
    a new find setting by overriding the `beforeFind` and `afterFind` model callbacks.
    In the `beforeFind` callback, executed before a `find` operation is executed,
    we check for the existence of a `virtualFields` setting. If such setting is defined,
    we use its value to check if virtual fields should be returned or not.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 为了允许我们控制从`find`操作返回的虚拟字段，我们通过重写`beforeFind`和`afterFind`模型回调添加一个新的查找设置。在执行`find`操作之前执行的`beforeFind`回调中，我们检查是否存在`virtualFields`设置。如果定义了此设置，我们使用其值来检查是否应该返回虚拟字段。
- en: Based on these setting values, we alter the real value of the model `virtualFields`
    property. We backup its original value, and then restore it after the `find` operation
    is completed, that is, in the `afterFind` callback.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 根据这些设置值，我们更改模型`virtualFields`属性的真正值。我们备份其原始值，然后在`find`操作完成后恢复，即在`afterFind`回调中。
- en: See also
  id: totrans-86
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: '*Performing GROUP and COUNT queries*'
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*执行GROUP和COUNT查询*'
- en: Building queries with ad-hoc JOINs
  id: totrans-88
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用临时的JOIN构建查询
- en: CakePHP has a very easy way to handle bindings, and through the use of the `Containable`
    behavior, as shown in several recipes in [Chapter 2](ch02.html "Chapter 2. Model
    Bindings"), *Model Bindings*, we have a lot of flexibility when dealing with bindings.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: CakePHP有一个非常简单的方式来处理绑定，并且通过使用`Containable`行为，正如在第2章[模型绑定](ch02.html "第2章。模型绑定")中几个配方所展示的，我们在处理绑定时拥有很多灵活性。
- en: However, there are times where we need to fall outside of a normal find operation
    and perform queries that join several models, without using normal binding operations,
    to save us some valuable queries. In this recipe, we will see how to specify `JOIN`
    operations when performing a find on a model.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，有时我们需要超出正常的查找操作，执行连接多个模型的查询，而不使用正常的绑定操作，以节省一些宝贵的查询。在这个配方中，我们将看到如何在执行模型查找时指定`JOIN`操作。
- en: Getting ready
  id: totrans-91
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: We need some sample models and data to work with. Follow the *Getting ready*
    section of the recipe, *Performing GROUP and COUNT queries*.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要一些示例模型和数据来工作。遵循配方中的*准备工作*部分，*执行GROUP和COUNT查询*。
- en: To illustrate the difference between normal binding operations and what is shown
    in this recipe, we need the `Containable` behavior. Create a file named `app_model.php`
    and place it in your `app/` folder, with the following contents. If you already
    have one, make sure that, either you add the `actsAs` property shown as follows,
    or your `actsAs` property includes `Containable`.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 为了说明正常绑定操作与这个配方中展示的内容之间的区别，我们需要`Containable`行为。创建一个名为`app_model.php`的文件，并将其放置在您的`app/`文件夹中，内容如下。如果您已经有了，请确保您添加了以下所示的`actsAs`属性，或者您的`actsAs`属性包括`Containable`。
- en: '[PRE20]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'We also need the `Blog` model. Create a file named `blog.php` and place it
    in your `app/models` folder with the following contents:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要`Blog`模型。创建一个名为`blog.php`的文件，并将其放置在您的`app/models`文件夹中，内容如下：
- en: '[PRE21]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: How to do it...
  id: totrans-97
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'We want to obtain the first post with the `Blog` it belongs to, and the `User`
    information that owns the `Blog`. Using `Containable` (refer to the recipe *Limiting
    the bindings returned in a find* in [Chapter 2](ch02.html "Chapter 2. Model Bindings"),
    *Model Bindings* for more information), we do:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望获取属于`Blog`的第一篇帖子及其所属的`User`信息。使用`Containable`（有关更多信息，请参阅第2章[模型绑定](ch02.html
    "第2章。模型绑定")中的配方*限制find操作返回的绑定*），我们执行以下操作：
- en: '[PRE22]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'This operation is performed by CakePHP using three SQL queries:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 这个操作是由CakePHP使用三个SQL查询来执行的：
- en: '[PRE23]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'We can save some of these queries if we `JOIN` the relevant tables into one
    single operation. We specify these `JOIN` statements using the appropriate join
    find setting:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们将相关的表合并到一个单一的操作中，我们可以节省一些这些查询。我们使用适当的连接查找设置来指定这些`JOIN`语句：
- en: '[PRE24]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'The preceding statement will produce the following SQL query:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的语句将生成以下SQL查询：
- en: '[PRE25]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: How it works...
  id: totrans-106
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The `joins` find setting allows us to define which `JOIN` statements to add
    to the generated SQL query. We have full control when defining the operation,
    being able to change the `type` (one of `left, right`, and `inner`), the `table`
    to which to join, the `alias` to use, and the `conditions` used when joining.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '`joins`查找设置允许我们定义要添加到生成的SQL查询中的`JOIN`语句。在定义操作时，我们有完全的控制权，能够更改`type`（`left,
    right`和`inner`之一），要连接的`table`，要使用的`alias`，以及连接时使用的`conditions`。'
- en: 'We used this setting to join the `Post` model with two models: `Blog`, by means
    of its table and required condition, and `User`, using its appropriate table and
    condition. As the `Post` model `belongsTo` the `Blog` model, CakePHP will automatically
    try to do a `LEFT JOIN` with it, unless we tell it not to.'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用此设置将`Post`模型与两个模型连接起来：通过其表和必需条件与`Blog`连接，以及使用其适当的表和条件与`User`连接。由于`Post`模型`belongsTo``Blog`模型，CakePHP将自动尝试与它进行`LEFT
    JOIN`，除非我们告诉它不要这样做。
- en: We therefore set `recursive` to `-1`, forcing CakePHP to only use our defined
    `JOIN`. If the recursive statement is removed, we would have to choose a different
    `alias` for our `Blog JOIN` definition, as it would conflict with CakePHP's built-in
    binding.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们将`recursive`设置为`-1`，强制CakePHP只使用我们定义的`JOIN`。如果移除递归语句，我们就必须为我们的`Blog JOIN`定义选择一个不同的`别名`，因为它将与CakePHP的内置绑定冲突。
- en: See also
  id: totrans-110
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: '*Adding Containable* in [Chapter 2](ch02.html "Chapter 2. Model Bindings"),
    *Model Bindings*'
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在[第2章](ch02.html "第2章。模型绑定")的*模型绑定*中添加*可包含*功能
- en: Searching for all items that match search terms
  id: totrans-112
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 搜索所有匹配搜索条件的项目
- en: Finding records that match a set of search terms is almost a must-have on most
    web applications. Even when there is a good number of more in-depth, complex search
    solutions, sometimes a simple search is all we need.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 在大多数网络应用程序中，查找与一组搜索词匹配的记录几乎是必不可少的。即使有大量更深入、更复杂的搜索解决方案，有时我们只需要简单的搜索。
- en: This recipe shows how to implement a `LIKE-based` search to find records that
    match some terms.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 这个配方展示了如何实现基于 `LIKE` 的搜索来查找匹配某些词的记录。
- en: Getting ready
  id: totrans-115
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: We need some sample models and data to work with. Follow the *Getting ready*
    section of the recipe, *Performing GROUP and COUNT queries*.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要一些示例模型和数据来工作。遵循配方中的 *准备工作* 部分，*执行 GROUP 和 COUNT 查询*。
- en: How to do it...
  id: totrans-117
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'If we want to find all posts that have the word `Post 1` or the word `Post
    2`, either in its title, or post, we do:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想要找到所有包含单词 `Post 1` 或单词 `Post 2` 的帖子，无论是标题还是帖子内容，我们这样做：
- en: '[PRE26]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'The preceding statement will produce the following result:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的语句将产生以下结果：
- en: '[PRE27]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: How it works...
  id: totrans-122
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: '`LIKE-based` conditions are like any other model find condition, except that
    they are specified in a special form: they become part of the key of the condition
    and use the character `?` to tell where the actual value will be inserted, the
    value being an actual `LIKE` expression. Therefore, the following condition:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: '`LIKE-based` 条件类似于任何其他模型查找条件，除了它们以特殊形式指定：它们成为条件键的一部分，并使用字符 `?` 来指示实际值将被插入的位置，该值是一个实际的
    `LIKE` 表达式。因此，以下条件：'
- en: '[PRE28]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'will be evaluated to SQL like so:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 将被评估为类似 SQL 的如下：
- en: '[PRE29]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: As the `LIKE` expression is specified as an array index, it's important to note
    that we need to wrap each expression in an array of its own, avoiding the override
    of a previous expression. To illustrate this, let us add another condition for
    the `Post.title` field.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 `LIKE` 表达式被指定为数组索引，需要注意的是，我们需要将每个表达式包裹在其自己的数组中，以避免覆盖先前的表达式。为了说明这一点，让我们为 `Post.title`
    字段添加另一个条件。
- en: '[PRE30]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'This would be translated to the following SQL expression:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 这将翻译成以下 SQL 表达式：
- en: '[PRE31]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Naturally, the second index is overriding the first, because they are both
    the same. We therefore have to wrap both expressions in an array, to avoid overriding
    the already used indexes:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 自然地，第二个索引覆盖了第一个，因为它们都是相同的。因此，我们必须将两个表达式都包裹在数组中，以避免覆盖已使用的索引：
- en: '[PRE32]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'which would be translated to the following SQL statement:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 这将翻译成以下 SQL 语句：
- en: '[PRE33]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: See also
  id: totrans-135
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: '*Implementing a custom find type*'
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*实现自定义查找类型*'
- en: Implementing a custom find type
  id: totrans-137
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现自定义查找类型
- en: The recipe, *Searching for all items that match search terms*, gives us a great
    starting point to create a custom find type. Custom find types allow us to extend
    the basic find types any model has, allowing our code to become more readable
    and extensible.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 配方，*搜索所有与搜索词匹配的项目*，为我们提供了一个很好的起点来创建自定义查找类型。自定义查找类型允许我们扩展任何模型都有的基本查找类型，使我们的代码更易于阅读和扩展。
- en: This recipe shows how to create a custom find type to allow the `Post` model
    to be searched against a set of terms, thus extending the functionality shown
    in the previous recipe.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 这个配方展示了如何创建一个自定义查找类型，允许 `Post` 模型对一组词进行搜索，从而扩展了前一个配方中展示的功能。
- en: Getting ready
  id: totrans-140
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: We need some sample models and data to work with. Follow the *Getting ready*
    section of the recipe, *Performing GROUP and COUNT queries*.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要一些示例模型和数据来工作。遵循配方中的 *准备工作* 部分，*执行 GROUP 和 COUNT 查询*。
- en: How to do it...
  id: totrans-142
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: Open the `post.php` file and add the `search` find type to the list of find
    methods using the `_findMethods` property, together with the actual implementation
    of the `_findSearch()` method.
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 `post.php` 文件，并将 `search` 查找类型添加到 `_findMethods` 属性的查找方法列表中，同时添加 `_findSearch()`
    方法的实际实现。
- en: '[PRE34]'
  id: totrans-144
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'We can now use these custom find types by specifying the list of terms to search
    with using the `search` find setting:'
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们现在可以通过指定要搜索的词列表来使用这些自定义查找类型：
- en: '[PRE35]'
  id: totrans-146
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: If we now browse to `http://localhost/posts`, we get the `id` and `title` fields
    for four posts, as it is partially shown in the following screenshot:![How to
    do it...](img/1926_03_01.jpg)
  id: totrans-147
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果我们现在浏览到 `http://localhost/posts`，我们会得到四个帖子的 `id` 和 `title` 字段，如下面的截图部分所示：![如何做到这一点...](img/1926_03_01.jpg)
- en: 'Let us now also allow the execution of count operations for custom find types.
    Because we want a generic solution, we will add this to `AppModel`. Open the file
    `app_model.php` in your `app/` folder (create it if you don''t have one), and
    override the `find()` method as shown below:'
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们现在也允许自定义查找类型的计数操作。因为我们想要一个通用的解决方案，所以我们将此添加到 `AppModel` 中。打开你的 `app/` 文件夹中的
    `app_model.php` 文件（如果没有，则创建它），并按照以下方式重写 `find()` 方法：
- en: '[PRE36]'
  id: totrans-149
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Now edit your `app/models/post.php` file and make the following changes to
    the `_findSearch()` method:'
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在编辑你的 `app/models/post.php` 文件，并对 `_findSearch()` 方法进行以下更改：
- en: '[PRE37]'
  id: totrans-151
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'If we wanted to obtain the number of posts that match a set of terms, we would
    do:'
  id: totrans-152
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果我们想要获取匹配一组术语的帖子数量，我们会这样做：
- en: '[PRE38]'
  id: totrans-153
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Which would correctly return 4.
  id: totrans-154
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这将正确返回 4。
- en: How it works...
  id: totrans-155
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Custom find types are defined in the model `_findMethods` property. We add types
    by adding the name of the find type to the property as its index, and setting
    `true` as its value in the model that contains the find type.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 自定义查找类型在模型的 `_findMethods` 属性中定义。我们通过将查找类型的名称添加到属性中作为其索引，并在包含查找类型的模型中将其值设置为
    `true` 来添加类型。
- en: 'The method responsible for dealing with the actual find type is named using
    the following syntax: `_findType()`, where `Type` is the find type name, with
    its first case in uppercase. For a find type of name popular, the method would
    be named `_findPopular()`.'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 负责处理实际查找类型的方法定名为以下语法：`_findType()`，其中 `Type` 是查找类型名称，首字母大写。对于一个名为 `popular`
    的查找类型，方法将被命名为 `_findPopular()`。
- en: 'Every find type method receives three arguments:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 每个查找类型方法接收三个参数：
- en: '`state`: The state at which the `find` operation is currently on. This can
    be `before` (used right before the find operation is to be executed), or `after`
    (executed after the find operation is finished, and the perfect place to modify
    the obtained results.) The `before` state is where we change the query parameters
    to meet our needs.'
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`state`: `find` 操作当前所处的状态。这可以是 `before`（在查找操作执行之前使用），或者 `after`（在查找操作完成后执行，这是修改获取到的结果的完美位置。）`before`
    状态是我们更改查询参数以满足需求的地方。'
- en: '`query`: The data for the query, containing typical find settings (such as
    `fields` or `conditions`), and any extra settings specified in the `find` operation
    (in our case, `terms`).'
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`query`: 查询的数据，包含典型的查找设置（例如 `fields` 或 `conditions`），以及 `find` 操作中指定的任何额外设置（在我们的案例中，`terms`）。'
- en: '`results`: Only applicable when the state is set to `after`, and includes the
    result of the `find` operation.'
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`results`: 仅在状态设置为 `after` 时适用，并包含 `find` 操作的结果。'
- en: When the state of the find is set to `before`, the custom find type implementation
    needs to return the query, as an array of find settings. Therefore, in our implementation,
    we look for a custom find setting named `terms`. If there are terms specified,
    we use them to add `LIKE-` based conditions to a fixed list of fields. Once we
    are done, we return the modified query.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 当查找状态设置为 `before` 时，自定义查找类型实现需要返回查询，作为一个查找设置的数组。因此，在我们的实现中，我们寻找一个名为 `terms`
    的自定义查找设置。如果有指定的术语，我们使用它们向一组固定的字段添加基于 `LIKE` 的条件。一旦完成，我们返回修改后的查询。
- en: When the state is set to `after`, the implementation needs to return the results.
    This is the opportunity to modify the resulting rows, if needed, before returning
    them. In our implementation, we simply return them as they were sent to us.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 当状态设置为 `after` 时，实现需要返回结果。这是在返回之前修改结果行（如果需要）的机会。在我们的实现中，我们简单地按收到的样子返回它们。
- en: 'The last part of the recipe shows us how to add count support for our custom
    find types. This is something that CakePHP does not offer out of the box, so we
    implement our own solution. We do so by overriding the `find()` method and checking
    to make sure a set of conditions are met:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 菜单的最后部分展示了如何为我们的自定义查找类型添加计数支持。这是 CakePHP 默认不提供的功能，因此我们实现了自己的解决方案。我们通过重写 `find()`
    方法并确保满足一系列条件来实现这一点：
- en: The `find` operation being executed is set to `count`
  id: totrans-165
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 正在执行的 `find` 操作设置为 `count`
- en: There's a `type` setting specified in the query
  id: totrans-166
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 查询中指定了 `type` 设置
- en: The `type` setting is in fact a valid custom find type
  id: totrans-167
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`type` 设置实际上是一个有效的自定义查找类型'
- en: When these conditions are met, we add a new query parameter named `operation`,
    setting it to `count`, and we then call the parent `find()` implementation using
    the custom find type. This way, our find implementation can check for the `operation`
    find setting, and when it is set to `count`, it forces the `fields` find setting
    to `COUNT(*)` in the `before` state, and correctly gets the result of the count
    operation in the `after` state.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 当这些条件满足时，我们添加一个名为 `operation` 的新查询参数，将其设置为 `count`，然后使用自定义查找类型调用父 `find()` 实现方法。这样，我们的查找实现可以检查
    `operation` 查找设置，当它设置为 `count` 时，它将强制 `fields` 查找设置在 `before` 状态下为 `COUNT(*)`，并在
    `after` 状态下正确获取计数操作的结果。
- en: See also
  id: totrans-169
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 相关内容
- en: '*Paginating a custom find type*'
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*分页自定义查找类型*'
- en: '*Searching for all items that match search terms*'
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*搜索所有匹配搜索词的项目*'
- en: Paginating a custom find type
  id: totrans-172
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 分页自定义查找类型
- en: The recipe, *Implementing a custom find type*, showed us the power of extending
    the built-in model find types, including support to use the implemented custom
    types for fetching records or counting them.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 配方，*实现自定义查找类型*，展示了扩展内置模型查找类型的力量，包括支持使用实现的自定义类型来获取记录或计数。
- en: Now that we know how to fetch and count custom find types, we can easily paginate
    a set of resulting rows. This recipe shows how to use CakePHP's built-in pagination
    support to paginate a set of rows that come as a result of a custom find type.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们知道了如何获取和计数自定义查找类型，我们可以轻松地分页一组结果行。这个配方展示了如何使用 CakePHP 内置的分页支持来分页一组作为自定义查找类型结果出现的行。
- en: Getting ready
  id: totrans-175
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: We need some sample models and data to work with, and we need the override of
    the `find()` method in `AppModel` to allow `count` operations on custom find types.
    Therefore, make sure you follow the entire recipe, *Implementing a custom find
    type*, including its *Getting ready* section.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要一些示例模型和数据来工作，并且我们需要在 `AppModel` 中覆盖 `find()` 方法以允许在自定义查找类型上执行 `count` 操作。因此，请确保你遵循整个配方，*实现自定义查找类型*，包括其
    *准备工作* 部分。
- en: How to do it...
  id: totrans-177
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Create a file named `posts_controller.php` in your `app/controllers` folder.
    If you already have one, make sure its `index()` method is as follows:'
  id: totrans-178
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在你的 `app/controllers` 文件夹中创建一个名为 `posts_controller.php` 的文件。如果你已经有了，请确保它的 `index()`
    方法如下：
- en: '[PRE39]'
  id: totrans-179
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Create the view for the `index` action. If you don''t have a folder named `posts`
    in your `app/views` folder, create it. Next, create a file named `index.ctp` in
    your `app/views` folder with the following contents:'
  id: totrans-180
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为 `index` 动作创建视图。如果你的 `app/views` 文件夹中没有名为 `posts` 的文件夹，请创建它。接下来，在你的 `app/views`
    文件夹中创建一个名为 `index.ctp` 的文件，内容如下：
- en: '[PRE40]'
  id: totrans-181
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE40]'
- en: If we now browse to `http://localhost/posts`, we see a paginated list of matching
    posts, showing the first three posts out of two pages, as shown in the following
    screenshot:![How to do it...](img/1926_03_02.jpg)
  id: totrans-182
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果我们现在浏览到 `http://localhost/posts`，我们会看到一个分页的匹配帖子列表，显示两页中的前三个帖子，如下截图所示：![如何操作...](img/1926_03_02.jpg)
- en: How it works...
  id: totrans-183
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理...
- en: 'To paginate a custom find type, we need to specify the name of the find type
    as the value for index `0` of the pagination settings (or the first value if no
    index is defined). We can then pass any custom find settings as part of the pagination
    settings, as shown in the following code snippet:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 要分页自定义查找类型，我们需要指定查找类型的名称作为分页设置的索引 `0` 的值（或如果没有定义索引，则为第一个值）。然后我们可以将任何自定义查找设置作为分页设置的一部分传递，如下代码片段所示：
- en: '[PRE41]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: CakePHP's `paginate()` method will first issue a `count` (specifying the find
    type name in the `type` find setting) to get the total number of rows, and then
    a `find` operation using the custom find type to get the rows for the current
    page.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: CakePHP 的 `paginate()` 方法首先会发出一个 `count`（在 `type` 查找设置中指定查找类型名称）来获取总行数，然后使用自定义查找类型执行
    `find` 操作来获取当前页面的行。
- en: See also
  id: totrans-187
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 相关内容
- en: '*Implementing AJAX based pagination*'
  id: totrans-188
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*实现基于 AJAX 的分页*'
- en: Implementing AJAX based pagination
  id: totrans-189
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现基于 AJAX 的分页
- en: The previous recipe, *Paginating a custom find type*, showed us how to paginate
    a custom find type. Each page link changes the browser location, forcing the reload
    of all the elements in the page.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的配方，*分页自定义查找类型*，展示了如何分页自定义查找类型。每个页面链接都会更改浏览器位置，强制重新加载页面上的所有元素。
- en: This recipe allows us to use AJAX (using the `jQuery javascript library`) to
    only load what is really needed, so that every time a page is changed, only the
    set of rows is changed without having to load a whole new page.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 这个配方允许我们使用 AJAX（使用 `jQuery javascript 库`）只加载真正需要的内容，因此每次页面更改时，只有行集会更改，而不需要加载整个新页面。
- en: Getting ready
  id: totrans-192
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: We need some sample models and data to work with, and we need a fully working
    pagination of a custom find type. Follow the entire recipe, *Paginating a custom
    find type*, including its *Getting ready* section.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要一些示例模型和数据来工作，并且需要一个自定义查找类型的完整分页功能。遵循整个配方，包括其*准备就绪*部分，即*分页自定义查找类型*。
- en: How to do it...
  id: totrans-194
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: We start by adding the `jQuery javascript` library to our layout. If you don't
    have one already, create a file named `default.ctp` in your `app/views/layouts`
    directory. Make sure you add the link to the jQuery library (here we are using
    the Google-hosted one), the place holder for a loading message (to be shown when
    an AJAX connection is in progress), and that you wrap the view content with a
    DIV with an ID set to `content`.
  id: totrans-195
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们首先将`jQuery javascript`库添加到我们的布局中。如果你还没有，请在你的`app/views/layouts`目录中创建一个名为`default.ctp`的文件。确保你添加了jQuery库的链接（这里我们使用的是Google托管版本），一个用于显示加载信息的占位符（在AJAX连接进行时显示），并且将视图内容包裹在一个ID设置为`content`的DIV中。
- en: '[PRE42]'
  id: totrans-196
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Open the `PostsController` and add the `RequestHandler` component, and the
    `Jquery` helper engine (the rest of the controller remains unmodified:'
  id: totrans-197
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`PostsController`并添加`RequestHandler`组件，以及`Jquery`助手引擎（控制器其余部分保持不变）：
- en: '[PRE43]'
  id: totrans-198
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Now let the `Paginator` helper know that we are using AJAX-based pagination.
    Edit the view file `app/views/posts/index.ctp` and add the highlighted lines:'
  id: totrans-199
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让`Paginator`助手知道我们正在使用基于AJAX的分页。编辑视图文件`app/views/posts/index.ctp`并添加以下高亮行：
- en: '[PRE44]'
  id: totrans-200
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE44]'
- en: How it works...
  id: totrans-201
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: When the update setting is specified to the `options()` method of the `Paginator`
    helper, the `Paginator` knows it is dealing with an AJAX-based pagination. The
    update setting points to the ID of the DOM element holding the content that changes
    when each pagination link is clicked. In our case, that DOM element is a DIV with
    an ID set to `content`, defined in the layout.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 当更新设置指定给`Paginator`助手的`options()`方法时，`Paginator`知道它正在处理基于AJAX的分页。更新设置指向当每个分页链接被点击时内容发生变化的DOM元素的ID。在我们的例子中，这个DOM元素是一个ID设置为`content`的DIV，它在布局中定义。
- en: The other option we specify to the `Paginator` helper is `evalScripts`, which
    tells the helper to evaluate any Javascript code that is being obtained as a result
    of an AJAX request. That way, when a page with results is being obtained through
    AJAX, the Javascript code that is automatically added by the JQuery engine will
    be executed. Similarly, we need to print out this generated code, and we do so
    by calling the `writeBuffer()` method at the end of the `index.ctp` view.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 我们指定给`Paginator`助手的另一个选项是`evalScripts`，它告诉助手评估任何作为AJAX请求结果获得的JavaScript代码。这样，当通过AJAX获取结果页面时，JQuery引擎自动添加的JavaScript代码将被执行。同样，我们需要打印出这段生成的代码，我们通过在`index.ctp`视图的末尾调用`writeBuffer()`方法来实现。
- en: The other two options we use are `before`, and `complete`, which are sent directly
    to the AJAX operation. The `before` option, executed before an AJAX request is
    made, is an ideal place for us to show the loading DIV. The `complete` option,
    executed after an AJAX operation is completed, is utilized to hide the loading
    DIV.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用的另外两个选项是`before`和`complete`，它们直接发送到AJAX操作。`before`选项在AJAX请求之前执行，是我们显示加载DIV的理想位置。`complete`选项在AJAX操作完成后执行，用于隐藏加载DIV。
- en: 'We could also specify Javascript code to the `before` and `complete` options,
    rather than utilizing the helper methods provided by the jQuery engine. The same
    effect could be achieved by changing the options as follows:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以将JavaScript代码指定给`before`和`complete`选项，而不是使用jQuery引擎提供的助手方法。可以通过以下方式更改选项来达到相同的效果：
- en: '[PRE45]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
