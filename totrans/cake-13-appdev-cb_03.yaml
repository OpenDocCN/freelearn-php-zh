- en: Chapter 3. Pushing the Search
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover:'
  prefs: []
  type: TYPE_NORMAL
- en: Performing GROUP and COUNT queries
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using virtual fields
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Building queries with ad-hoc JOINs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Searching for all items that match search terms
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing a custom find type
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Paginating a custom find type
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing AJAX-based pagination
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Using models to fetch data is one of the most important aspects of any CakePHP
    application. As such, a good use of the find functions the framework provides
    can certainly guarantee the success of our application, and as importantly ensure
    that our code is readable and maintainable.
  prefs: []
  type: TYPE_NORMAL
- en: 'CakePHP provides the following basic find types:'
  prefs: []
  type: TYPE_NORMAL
- en: '`all`: To find all records that match the given find options.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`count`: To count how many records match the given options.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`first`: To find the first record that matches the given find options.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`list`: To find all records that match the given find options, and formats
    them as a list, using the format provided.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`neighbors`: To find the previous and after records of a matching record, based
    on the value of a particular field.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`threaded`: To finds a set of results, and return them in a hierarchy, based
    on the value of a field named `parent_id`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Mastering these types is as easy as understanding the available find options
    all types deal with. In this chapter, we have several recipes to make the most
    out of these options, and to resort to manual SQL based queries when the need
    arises.
  prefs: []
  type: TYPE_NORMAL
- en: CakePHP also lets us define our custom find types that will extend the three
    basic ones, allowing our code to be even more readable. The last recipes in this
    chapter show us how to create our own find type, with pagination support.
  prefs: []
  type: TYPE_NORMAL
- en: Performing GROUP and COUNT queries
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This recipe shows how to use CakePHP's built-in find types to perform relatively
    complex `GROUP` and `COUNT` queries, including the combination of both.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To go through this recipe we need some sample tables to work with.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a table named `users`, using the following SQL statement:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create a table named `blogs`, using the following SQL statement:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create a table named `posts`, using the following SQL statement:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add some sample data, using the following SQL statements:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We proceed now to create the required model. Create the model `Post` in a file
    named `post.php` and place it in your `app/models` folder with the following contents:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We will put all our example code in the `index()` method of a controller. Create
    a file named `posts_controller.php` and place it in your `app/controllers` folder
    with the following contents:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, create a folder named `posts` and place it in your `app/views` folder.
    Inside this newly created folder, create a file named `index.ctp`, with the following
    contents:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How to do it...
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Grouping rows by a certain field is as simple as specifying the group setting
    when issuing a `find` operation. For example, the following statement, while not
    exactly practical by itself, shows how to use the setting:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'If we also want to obtain the number of rows for each grouped set, which in
    our case means the number of posts per blog, we would do:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding query will return the following data structure:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Let us now make sure that every time we have a calculated field (which come
    in the index `0` of each resulting row), they become part of the resulting model,
    for easier readability. To do so, we override the `afterFind()` method. If you
    don''t have one already, create a file named `app_model.php` in your `app/` folder.
    Make sure your `AppModel` class includes the following contents:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Whenever you override a model method, such as `beforeFind()` or `afterFind()`,
    make sure you call the parent implementation by using the `parent` keyword.
  prefs: []
  type: TYPE_NORMAL
- en: 'As a result, the previous query, which uses `GROUP` and `COUNT`, will now look
    like a much more readable result set:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'If we want to subdivide the post counts for each blog according to the month
    they were created on, we would have to add another level of grouping:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Considering our `afterFind` implementation, the preceding query would produce
    the following results:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We use the `group` find setting to specify what fields will be used for grouping
    the resulting rows. That setting is given as an array, where each element is a
    field to group in. When we specify more than one field, such as the last example
    in the recipe, grouping of rows occurs in the given order of grouping fields.
  prefs: []
  type: TYPE_NORMAL
- en: 'Calculated fields, that is, expressions that result in a value (such as the
    `COUNT(*) AS total` expression used throughout the recipe) are placed in the index
    `0` of each resulting row, because they are not real fields defined in the model.
    Because of that, we overrode the `afterFind()` method, executed after a result
    for a find operation is obtained, and with some basic logic we make sure those
    calculated fields get included in the resulting row within a much more readable
    index: the model name.'
  prefs: []
  type: TYPE_NORMAL
- en: The last example in the recipe shows not only how to group on more than one
    field, but how to properly use some SQL methods (such as `MONTH` and `YEAR`) with
    an alias, so we can easily return the value of that expression and also use it
    to group or optionally order the rows.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*Using virtual fields*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using virtual fields
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the recipe, *Performing GROUP and COUNT queries*, we learnt how to add computed
    SQL expressions to a `find` operation. Some of these expressions may be needed
    regularly for a model, introducing the need for virtual fields.
  prefs: []
  type: TYPE_NORMAL
- en: Using virtual fields, we get the resulting values of our SQL expressions as
    if they were real fields of our models. They allow us to get the same results
    shown in the previous recipe in a much more transparent way, without needing the
    override of `afterFind`.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We need some sample models and data to work with. Follow the *Getting ready*
    section of the recipe, *Performing GROUP and COUNT queries*.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Open the `Post` model and add the `virtualfields` definition shown as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'To obtain a count of all the posts per blog, grouped by the period they were
    created, we do:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Using our sample data, the preceding query will result in the following array
    structure, which is exactly the same result as the one obtained in the last example
    shown in the recipe *Performing GROUP and COUNT queries*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Virtual fields are always obtained when issuing a `find` operation on the model.
    The only real way to avoid including them is specifying a list of fields to obtain
    in the find, and omitting the virtual fields:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `schema()` model function returns the list of real fields in the model,
    with information about each field, such as data type, and length.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will now add a way for us to manage which virtual fields, if any, are returned.
    To do so, we override the `beforeFind()` and `afterFind()` model methods. If you
    don''t have one already, create a file named `app_model.php` in your `app/` folder.
    Make sure your `AppModel` class includes the following contents:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'If we want to disable virtual fields when issuing a `find` operation, we can
    easily do so by specifying the `virtualFields` find setting to `false`. We can
    also set it to the list of virtual fields we want to include. For example, to
    only include the `period` virtual field, we do:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: CakePHP treats virtual fields almost as if they were real model fields. They
    are not exactly like real fields because we cannot specify a value for a virtual
    field when creating / editing a model record. However, in regards to `find` operations,
    they are treated like any other field.
  prefs: []
  type: TYPE_NORMAL
- en: Virtual fields are included on every `find` operation performed against the
    model to which they belong. However, there are times were we don't want or need
    certain virtual fields. This is particularly important when we include virtual
    fields that depend on grouping expressions, such as `COUNT`, as they affect the
    number of rows returned. In these cases, we want to be able to specify what, or
    even if, virtual fields should be returned.
  prefs: []
  type: TYPE_NORMAL
- en: To allow us to control virtual fields returned from a `find` operation, we add
    a new find setting by overriding the `beforeFind` and `afterFind` model callbacks.
    In the `beforeFind` callback, executed before a `find` operation is executed,
    we check for the existence of a `virtualFields` setting. If such setting is defined,
    we use its value to check if virtual fields should be returned or not.
  prefs: []
  type: TYPE_NORMAL
- en: Based on these setting values, we alter the real value of the model `virtualFields`
    property. We backup its original value, and then restore it after the `find` operation
    is completed, that is, in the `afterFind` callback.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*Performing GROUP and COUNT queries*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Building queries with ad-hoc JOINs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: CakePHP has a very easy way to handle bindings, and through the use of the `Containable`
    behavior, as shown in several recipes in [Chapter 2](ch02.html "Chapter 2. Model
    Bindings"), *Model Bindings*, we have a lot of flexibility when dealing with bindings.
  prefs: []
  type: TYPE_NORMAL
- en: However, there are times where we need to fall outside of a normal find operation
    and perform queries that join several models, without using normal binding operations,
    to save us some valuable queries. In this recipe, we will see how to specify `JOIN`
    operations when performing a find on a model.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We need some sample models and data to work with. Follow the *Getting ready*
    section of the recipe, *Performing GROUP and COUNT queries*.
  prefs: []
  type: TYPE_NORMAL
- en: To illustrate the difference between normal binding operations and what is shown
    in this recipe, we need the `Containable` behavior. Create a file named `app_model.php`
    and place it in your `app/` folder, with the following contents. If you already
    have one, make sure that, either you add the `actsAs` property shown as follows,
    or your `actsAs` property includes `Containable`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'We also need the `Blog` model. Create a file named `blog.php` and place it
    in your `app/models` folder with the following contents:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We want to obtain the first post with the `Blog` it belongs to, and the `User`
    information that owns the `Blog`. Using `Containable` (refer to the recipe *Limiting
    the bindings returned in a find* in [Chapter 2](ch02.html "Chapter 2. Model Bindings"),
    *Model Bindings* for more information), we do:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'This operation is performed by CakePHP using three SQL queries:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'We can save some of these queries if we `JOIN` the relevant tables into one
    single operation. We specify these `JOIN` statements using the appropriate join
    find setting:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding statement will produce the following SQL query:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `joins` find setting allows us to define which `JOIN` statements to add
    to the generated SQL query. We have full control when defining the operation,
    being able to change the `type` (one of `left, right`, and `inner`), the `table`
    to which to join, the `alias` to use, and the `conditions` used when joining.
  prefs: []
  type: TYPE_NORMAL
- en: 'We used this setting to join the `Post` model with two models: `Blog`, by means
    of its table and required condition, and `User`, using its appropriate table and
    condition. As the `Post` model `belongsTo` the `Blog` model, CakePHP will automatically
    try to do a `LEFT JOIN` with it, unless we tell it not to.'
  prefs: []
  type: TYPE_NORMAL
- en: We therefore set `recursive` to `-1`, forcing CakePHP to only use our defined
    `JOIN`. If the recursive statement is removed, we would have to choose a different
    `alias` for our `Blog JOIN` definition, as it would conflict with CakePHP's built-in
    binding.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*Adding Containable* in [Chapter 2](ch02.html "Chapter 2. Model Bindings"),
    *Model Bindings*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Searching for all items that match search terms
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Finding records that match a set of search terms is almost a must-have on most
    web applications. Even when there is a good number of more in-depth, complex search
    solutions, sometimes a simple search is all we need.
  prefs: []
  type: TYPE_NORMAL
- en: This recipe shows how to implement a `LIKE-based` search to find records that
    match some terms.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We need some sample models and data to work with. Follow the *Getting ready*
    section of the recipe, *Performing GROUP and COUNT queries*.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'If we want to find all posts that have the word `Post 1` or the word `Post
    2`, either in its title, or post, we do:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding statement will produce the following result:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`LIKE-based` conditions are like any other model find condition, except that
    they are specified in a special form: they become part of the key of the condition
    and use the character `?` to tell where the actual value will be inserted, the
    value being an actual `LIKE` expression. Therefore, the following condition:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'will be evaluated to SQL like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: As the `LIKE` expression is specified as an array index, it's important to note
    that we need to wrap each expression in an array of its own, avoiding the override
    of a previous expression. To illustrate this, let us add another condition for
    the `Post.title` field.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'This would be translated to the following SQL expression:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Naturally, the second index is overriding the first, because they are both
    the same. We therefore have to wrap both expressions in an array, to avoid overriding
    the already used indexes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'which would be translated to the following SQL statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*Implementing a custom find type*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing a custom find type
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The recipe, *Searching for all items that match search terms*, gives us a great
    starting point to create a custom find type. Custom find types allow us to extend
    the basic find types any model has, allowing our code to become more readable
    and extensible.
  prefs: []
  type: TYPE_NORMAL
- en: This recipe shows how to create a custom find type to allow the `Post` model
    to be searched against a set of terms, thus extending the functionality shown
    in the previous recipe.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We need some sample models and data to work with. Follow the *Getting ready*
    section of the recipe, *Performing GROUP and COUNT queries*.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Open the `post.php` file and add the `search` find type to the list of find
    methods using the `_findMethods` property, together with the actual implementation
    of the `_findSearch()` method.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We can now use these custom find types by specifying the list of terms to search
    with using the `search` find setting:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: If we now browse to `http://localhost/posts`, we get the `id` and `title` fields
    for four posts, as it is partially shown in the following screenshot:![How to
    do it...](img/1926_03_01.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Let us now also allow the execution of count operations for custom find types.
    Because we want a generic solution, we will add this to `AppModel`. Open the file
    `app_model.php` in your `app/` folder (create it if you don''t have one), and
    override the `find()` method as shown below:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now edit your `app/models/post.php` file and make the following changes to
    the `_findSearch()` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'If we wanted to obtain the number of posts that match a set of terms, we would
    do:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Which would correctly return 4.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Custom find types are defined in the model `_findMethods` property. We add types
    by adding the name of the find type to the property as its index, and setting
    `true` as its value in the model that contains the find type.
  prefs: []
  type: TYPE_NORMAL
- en: 'The method responsible for dealing with the actual find type is named using
    the following syntax: `_findType()`, where `Type` is the find type name, with
    its first case in uppercase. For a find type of name popular, the method would
    be named `_findPopular()`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Every find type method receives three arguments:'
  prefs: []
  type: TYPE_NORMAL
- en: '`state`: The state at which the `find` operation is currently on. This can
    be `before` (used right before the find operation is to be executed), or `after`
    (executed after the find operation is finished, and the perfect place to modify
    the obtained results.) The `before` state is where we change the query parameters
    to meet our needs.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`query`: The data for the query, containing typical find settings (such as
    `fields` or `conditions`), and any extra settings specified in the `find` operation
    (in our case, `terms`).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`results`: Only applicable when the state is set to `after`, and includes the
    result of the `find` operation.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When the state of the find is set to `before`, the custom find type implementation
    needs to return the query, as an array of find settings. Therefore, in our implementation,
    we look for a custom find setting named `terms`. If there are terms specified,
    we use them to add `LIKE-` based conditions to a fixed list of fields. Once we
    are done, we return the modified query.
  prefs: []
  type: TYPE_NORMAL
- en: When the state is set to `after`, the implementation needs to return the results.
    This is the opportunity to modify the resulting rows, if needed, before returning
    them. In our implementation, we simply return them as they were sent to us.
  prefs: []
  type: TYPE_NORMAL
- en: 'The last part of the recipe shows us how to add count support for our custom
    find types. This is something that CakePHP does not offer out of the box, so we
    implement our own solution. We do so by overriding the `find()` method and checking
    to make sure a set of conditions are met:'
  prefs: []
  type: TYPE_NORMAL
- en: The `find` operation being executed is set to `count`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: There's a `type` setting specified in the query
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `type` setting is in fact a valid custom find type
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When these conditions are met, we add a new query parameter named `operation`,
    setting it to `count`, and we then call the parent `find()` implementation using
    the custom find type. This way, our find implementation can check for the `operation`
    find setting, and when it is set to `count`, it forces the `fields` find setting
    to `COUNT(*)` in the `before` state, and correctly gets the result of the count
    operation in the `after` state.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*Paginating a custom find type*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Searching for all items that match search terms*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Paginating a custom find type
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The recipe, *Implementing a custom find type*, showed us the power of extending
    the built-in model find types, including support to use the implemented custom
    types for fetching records or counting them.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we know how to fetch and count custom find types, we can easily paginate
    a set of resulting rows. This recipe shows how to use CakePHP's built-in pagination
    support to paginate a set of rows that come as a result of a custom find type.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We need some sample models and data to work with, and we need the override of
    the `find()` method in `AppModel` to allow `count` operations on custom find types.
    Therefore, make sure you follow the entire recipe, *Implementing a custom find
    type*, including its *Getting ready* section.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Create a file named `posts_controller.php` in your `app/controllers` folder.
    If you already have one, make sure its `index()` method is as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create the view for the `index` action. If you don''t have a folder named `posts`
    in your `app/views` folder, create it. Next, create a file named `index.ctp` in
    your `app/views` folder with the following contents:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: If we now browse to `http://localhost/posts`, we see a paginated list of matching
    posts, showing the first three posts out of two pages, as shown in the following
    screenshot:![How to do it...](img/1926_03_02.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To paginate a custom find type, we need to specify the name of the find type
    as the value for index `0` of the pagination settings (or the first value if no
    index is defined). We can then pass any custom find settings as part of the pagination
    settings, as shown in the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: CakePHP's `paginate()` method will first issue a `count` (specifying the find
    type name in the `type` find setting) to get the total number of rows, and then
    a `find` operation using the custom find type to get the rows for the current
    page.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*Implementing AJAX based pagination*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing AJAX based pagination
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The previous recipe, *Paginating a custom find type*, showed us how to paginate
    a custom find type. Each page link changes the browser location, forcing the reload
    of all the elements in the page.
  prefs: []
  type: TYPE_NORMAL
- en: This recipe allows us to use AJAX (using the `jQuery javascript library`) to
    only load what is really needed, so that every time a page is changed, only the
    set of rows is changed without having to load a whole new page.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We need some sample models and data to work with, and we need a fully working
    pagination of a custom find type. Follow the entire recipe, *Paginating a custom
    find type*, including its *Getting ready* section.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We start by adding the `jQuery javascript` library to our layout. If you don't
    have one already, create a file named `default.ctp` in your `app/views/layouts`
    directory. Make sure you add the link to the jQuery library (here we are using
    the Google-hosted one), the place holder for a loading message (to be shown when
    an AJAX connection is in progress), and that you wrap the view content with a
    DIV with an ID set to `content`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Open the `PostsController` and add the `RequestHandler` component, and the
    `Jquery` helper engine (the rest of the controller remains unmodified:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now let the `Paginator` helper know that we are using AJAX-based pagination.
    Edit the view file `app/views/posts/index.ctp` and add the highlighted lines:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When the update setting is specified to the `options()` method of the `Paginator`
    helper, the `Paginator` knows it is dealing with an AJAX-based pagination. The
    update setting points to the ID of the DOM element holding the content that changes
    when each pagination link is clicked. In our case, that DOM element is a DIV with
    an ID set to `content`, defined in the layout.
  prefs: []
  type: TYPE_NORMAL
- en: The other option we specify to the `Paginator` helper is `evalScripts`, which
    tells the helper to evaluate any Javascript code that is being obtained as a result
    of an AJAX request. That way, when a page with results is being obtained through
    AJAX, the Javascript code that is automatically added by the JQuery engine will
    be executed. Similarly, we need to print out this generated code, and we do so
    by calling the `writeBuffer()` method at the end of the `index.ctp` view.
  prefs: []
  type: TYPE_NORMAL
- en: The other two options we use are `before`, and `complete`, which are sent directly
    to the AJAX operation. The `before` option, executed before an AJAX request is
    made, is an ideal place for us to show the loading DIV. The `complete` option,
    executed after an AJAX operation is completed, is utilized to hide the loading
    DIV.
  prefs: []
  type: TYPE_NORMAL
- en: 'We could also specify Javascript code to the `before` and `complete` options,
    rather than utilizing the helper methods provided by the jQuery engine. The same
    effect could be achieved by changing the options as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
