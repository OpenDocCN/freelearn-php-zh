<html><head></head><body>
        <section>

                            <header>
                    <h1 class="header-title">Creating Custom MySQL Database Tables</h1>
                </header>
            
            <article>
                
<p>In this chapter, we will cover the following topics around the creation of custom database tables:</p>
<ul>
<li>Creating new database tables</li>
<li>Deleting custom tables on plugin removal</li>
<li>Updating custom table structure on plugin upgrade</li>
<li>Displaying custom table data on an admin page</li>
<li>Inserting and updating records in custom tables</li>
<li>Deleting records from custom tables</li>
<li>Displaying custom database table data in shortcodes</li>
<li>Implementing a search function to retrieve custom table data</li>
<li>Importing data from a user file into custom tables</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Introduction</h1>
                </header>
            
            <article>
                
<p>As seen in <a href="6298bc2b-19d5-4e3a-833c-3c4b667b22e5.xhtml" target="_blank"><span class="ChapterrefPACKT">Chapter 4</span></a>, <em>The Power of Custom Post Types</em>, custom post types provide a very powerful and easy way to create and manage custom content in a WordPress installation. That being said, if the new items that you wish to create do not benefit from having access to the built-in text editor and have a large amount of data fields that need to be stored in the system, storing them using custom post types can actually become cumbersome. More specifically, each custom field requires a separate function call to be associated with a custom post. Also, custom fields have limited functionality, since they store all their information in simple text fields, making it difficult to perform ordered queries based on special data types, such as dates.</p>
<p>An alternative solution to manage custom content is to create new tables in the website's database and offer a custom interface to manage these new items.</p>
<p>While working directly with the website database might sound like a tall order, and should really only be done if custom post types don't work as desired, WordPress actually offers a utility class that makes it very easy to create new database tables, store information in these new structures, and perform data retrieval queries. While having a basic level of <strong>Structured Query Language</strong> (<strong>SQL</strong>) knowledge will help understand all of the recipes in this chapter while we create a bug tracking system, each recipe thoroughly explains how each command works to produce the end result.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Creating new database tables</h1>
                </header>
            
            <article>
                
<p>The first step in the creation of custom data elements to be stored in a custom database table is to create the table itself. This is done by preparing a standard SQL command that specifies the name of the table and its desired structure and then getting WordPress to execute it on the website's database.</p>
<p>This recipe shows how to prepare and execute a query that creates a table to hold bug reports.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Getting ready</h1>
                </header>
            
            <article>
                
<p>You should have access to a WordPress development environment, either on your local computer or on a remote server, where you will be able to load your new plugin files.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<ol>
<li>Navigate to the WordPress plugin directory of your development installation.</li>
<li>Create a new directory called <kbd>ch8-bug-tracker</kbd>.</li>
<li>Navigate to the directory and create a text file called <kbd>ch8-bug-tracker.php</kbd>.</li>
<li>Open the new file in a code editor and add an appropriate header at the top of the plugin file, naming the plugin <kbd>Chapter 8 - Bug Tracker</kbd>.</li>
<li>Add the following line of code to register a function to be called on plugin activation:</li>
</ol>
<pre style="padding-left: 60px">register_activation_hook( __FILE__, 'ch8bt_activation' ); </pre>
<ol start="6">
<li>Add the following code segment to provide an implementation for the <kbd>ch8bt_activation</kbd> function:</li>
</ol>
<pre style="padding-left: 60px">function ch8bt_activation() { <br/>    // Get access to global database access class <br/>    global $wpdb; <br/>     <br/>    // Create table on main blog in network mode or single blog <br/>    ch8bt_create_table( $wpdb-&gt;get_blog_prefix() ); <br/>} </pre>
<ol start="7">
<li>Insert the following code to provide an implementation for the <kbd>ch8bt_create_table</kbd> function responsible for the actual table creation:</li>
</ol>
<pre style="padding-left: 60px">function ch8bt_create_table( $prefix ) { <br/>    // Prepare SQL query to create database table <br/>    // using function parameter <br/> <br/>    $creation_query = 'CREATE TABLE IF NOT EXISTS ' . <br/>                      $prefix . 'ch8_bug_data ( <br/>                      `bug_id` int(20) NOT NULL AUTO_INCREMENT, <br/>                      `bug_description` text, <br/>                      `bug_version` varchar(10) DEFAULT NULL, <br/>                      `bug_report_date` date DEFAULT NULL, <br/>                      `bug_status` int(3) NOT NULL DEFAULT 0, <br/>                      PRIMARY KEY (`bug_id`) <br/>                      );'; <br/>     <br/>    global $wpdb; <br/>    $wpdb-&gt;query( $creation_query ); <br/>} </pre>
<ol start="8">
<li>Save and close the plugin file.</li>
</ol>
<p>Â </p>
<ol start="9">
<li>Navigate to the <span class="packt_screen">Plugins</span> management page and <span class="packt_screen">Activate</span> the <kbd>Chapter 8 - Bug Tracker</kbd> plugin.</li>
<li>Using <kbd>phpMyAdmin</kbd>, connect to your MySQL database to see that a new table was created when the plugin was activated:</li>
</ol>
<div class="CDPAlignCenter CDPAlign"><img height="166" width="181" class="image-border" src="assets/d3f91e48-7f30-472a-8994-50ac88cf7c4c.png"/></div>
<div style="margin-left: 2em"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How it works...</h1>
                </header>
            
            <article>
                
<p>Similar to the creation of configuration options that we covered back in the <em>Creating default user settings on plugin initialization</em> recipe from <a href="0346c3c6-27ee-45fb-bfd6-df398e04b2b4.xhtml" target="_blank">Chapter 3</a>, <em>User Settings and Administration Pages</em>, custom database tables are typically created when a plugin is activated in a WordPress installation. By using the activation hook, we register code to be executed when the plugin is first activated and when upgrades are performed. When the callback is executed, we will have our first encounter with the global <kbd>wpdb</kbd> class. This utility class is instantiated by WordPress and gives us access to a number of methods that can be used to interact with the underlying MySQL website database, as well as to help prevent data-related security risks. These methods vary in complexity, ranging from simple calls that will quickly insert or update records to more complex member functions that require knowledge of SQL commands to produce the expected results.</p>
<p>Before making the call to create the actual table, the activation function makes a call to the <kbd>get_blog_prefix</kbd> method of the <kbd>wpdb</kbd> class to retrieve the table prefix associated with the website (set to <kbd>wp_</kbd> in a default installation). On retrieval, this prefix is immediately sent to the <kbd>ch8bt_create_table</kbd> function to build an SQL command designed to create a new table.</p>
<p>While the SQL command has multiple lines, we can see that it is actually quite simple if we break it down into small sections. The first line of the command specifies that a new table named <kbd>&lt;prefix&gt;ch8_bug_data</kbd> should be created if it does not exist already on the server. If the creation takes place, the following five lines specify the name and data type for each field, along with information indicating whether the field can contain a <kbd>NULL</kbd> value and what the default value should be in some cases. There is also a special command associated with the <kbd>bug_id</kbd> field, called the <kbd>AUTO_INCREMENT</kbd> command, which tells the system to automatically populate this field with auto-incrementing values when new records are added to the table. Last, but not least, the last line of the code indicates that the primary key for the table is the <kbd>bug_id</kbd> field.</p>
<p>Once the query is ready, it is stored in a variable and executed by calling the <kbd>query</kbd> method of the <kbd>wpdb</kbd> object. This method executes any SQL command on the website database and returns a numeric value indicating how many rows were affected by the query.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">There's more...</h1>
                </header>
            
            <article>
                
<p>While the previous code is relatively manageable, things might get a bit more complicated when dealing with a larger number of fields or with network WordPress installation.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Using phpMyAdmin to simplify code creation</h1>
                </header>
            
            <article>
                
<p>Instead of writing the table creation code from scratch, the <kbd>phpMyAdmin</kbd> database management tool can come in handy to prepare this code:</p>
<div class="CDPAlignCenter CDPAlign"><img height="211" width="566" class="image-border" src="assets/88164da6-fbd1-4306-a578-df51fbdae148.png"/></div>
<p>For example, to create the table that was used in this recipe, follow these steps:</p>
<ol>
<li>Select the <kbd>wordpressdev</kbd> database in <kbd>phpMyAdmin</kbd>.</li>
<li>Under the Create table section, enter <kbd>wpdev_ch8_bug_data</kbd> in the <span class="packt_screen">Name</span> field and the number <kbd>5</kbd> as Number of fields.</li>
<li>Click on the <span class="packt_screen">Go</span> button.</li>
<li>In the table creation grid that is displayed, set the name of each <span class="packt_screen">Field</span> based on the Column names listed in the previous screenshot.</li>
<li>Set the <span class="packt_screen">Type</span> of each Field based on the Type column in the previous screenshot.</li>
<li>For items that have a value in parentheses next to their Type, use the numeric value to indicate the <span class="packt_screen">Length/Values</span> of these items.</li>
<li>Set the <span class="packt_screen">Default</span> value for each field based on the previous screenshot. You can select <span class="packt_screen">NULL</span> from the drop-down list for the items that have a <span class="packt_screen">NULL</span> default. For items that have a specific value, select <span class="packt_screen">As defined</span><span class="packt_screen">:</span> in the drop-down and indicate the value in the adjacent field.</li>
<li>For items that are allowed to have a <span class="packt_screen">NULL</span> value (shown with a Yes in the previous screenshot), make sure that the <span class="packt_screen">Null</span> box is checked.</li>
</ol>
<p>Â </p>
<ol start="9">
<li>Select <span class="packt_screen">PRIMARY</span> under the Index drop-down list for the <kbd>bug_id</kbd> field to indicate that it will be the primary key for the table. Then, click on <span class="packt_screen">Go</span> in the index creation pop-up dialog that appears.</li>
<li>Check the <span class="packt_screen">A_I</span> box for the <span class="packt_screen">bug_id</span> field to indicate that it should auto-increment when new values are inserted in the table.</li>
<li>Click on the <span class="packt_screen">Save</span> button to complete the table creation process.</li>
</ol>
<p>At this time, phpMyAdmin will create the table on the server. To access the SQL command used to create the table, click on the <span class="packt_screen">Export</span> tab and click on <span class="packt_screen">Go</span> to download a text file containing the SQL code. While the export file will contain some extra information, the important section is the actual CREATE TABLE segment that, as you will see, looks very similar to the code written in this recipe.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Create tables in network installation</h1>
                </header>
            
            <article>
                
<p>One of WordPress's many strengths is the ability to create and manage multiple websites from a single installation. In these situations, each site has its own set of tables in the MySQL database. Therefore, when preparing a plugin that creates custom tables and may be used in network installations, extra code must be put in place to create the new tables under each site's structure.</p>
<p>The first changes are done in the <kbd>ch8bt_activation</kbd> function, where we check whether we are dealing with a multisite installation. If that is the case, we will cycle through each existing site and make a call to create the new table, as we saw in the main recipe code:</p>
<pre>function ch8bt_activation() { <br/>    // Get access to global database access class <br/>    global $wpdb; <br/> <br/>    // Check to see if WordPress installation is a network <br/>    if ( is_multisite() ) { <br/>        // If it is, cycle through all blogs, switch to them <br/>        // and call function to create plugin table <br/>        if ( !empty( $_GET['networkwide'] ) ) { <br/>            $start_blog = $wpdb-&gt;blogid; <br/>            $blog_list =<br/>                $wpdb-&gt;get_col( 'SELECT blog_id FROM ' . $wpdb-&gt;blogs );<br/>            foreach ( $blog_list as $blog ) {<br/>                switch_to_blog( $blog ); <br/>                // Send blog table prefix to creation function<br/>                ch8bt_create_table( $wpdb-&gt;get_blog_prefix() );<br/>            } <br/>            switch_to_blog( $start_blog );<br/>            return;<br/>        }<br/>    }<br/> <br/>    // Create table on main blog in network mode or single blog<br/>    ch8bt_create_table( $wpdb-&gt;get_blog_prefix() );<br/>} </pre>
<p>While this will handle creating custom tables in all the existing network sites when the plugin is activated, additional code needs to be put in place to create the additional table when new sites are created:</p>
<pre>// Register function to be called when new blogs are added<br/>// to a network site <br/>add_action( 'wpmu_new_blog', 'ch8bt_new_network_site' );<br/><br/>function ch8bt_new_network_site( $blog_id ) {  <br/>    global $wpdb; <br/> <br/>    // Check if this plugin is active when new blog is created<br/>    // Include plugin functions if it is<br/>    if ( !function_exists( 'is_plugin_active_for_network' ) ) {<br/>        require_once( ABSPATH . '/wp-admin/includes/plugin.php' ); <br/>    }<br/><br/>    // Select current blog, create new table and switch back<br/>    if ( is_plugin_active_for_network( plugin_basename( __FILE__ ) ) ) {<br/>        $start_blog = $wpdb-&gt;blogid; <br/>        switch_to_blog( $blog_id ); <br/> <br/>        // Send blog table prefix to table creation function <br/>        ch8bt_create_table( $wpdb-&gt;get_blog_prefix() ); <br/>        switch_to_blog( $start_blog ); <br/>    } <br/>} </pre>
<p>The <kbd>ch8bt_create_table</kbd> function itself does not require any modifications, since it was already designed to receive a table prefix from other functions and use it to build a query.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Deleting custom tables on plugin removal</h1>
                </header>
            
            <article>
                
<p>It is always a good practice for plugins to provide an uninstallation procedure to remove content that they added to a website's database or filesystem. When dealing with custom database tables, all records should be dropped along with the table itself when a website administrator decides to delete a plugin.</p>
<p>This recipe shows how to implement a data removal script to delete the bug storage table that was created in the previous recipe.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Getting ready</h1>
                </header>
            
            <article>
                
<p>You should have already followed the <em>Creating new database tables</em> recipe to have an existing table to remove. Alternatively, you can get the resulting code (<kbd>Chapter 8/ch8-bug-tracker/ch8-bug-tracker-v1-1.php</kbd>) from the code bundle and rename the file as <kbd>ch8-bug-tracker.php</kbd>.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<ol>
<li>Navigate to the WordPress plugin directory of your development installation.</li>
<li>Create a text file called <kbd>uninstall.php</kbd> in the <kbd>ch8-bug-tracker</kbd> directory and open it in a code editor.</li>
<li>Start the new script with the standard <kbd>&lt;?php</kbd> opening tags.</li>
<li>Implement a new function called <kbd>ch8bt_drop_table</kbd> by adding this code to the file:</li>
</ol>
<pre style="padding-left: 60px">function ch8bt_drop_table( $prefix ) { <br/>    global $wpdb;     <br/>    $wpdb-&gt;query( 'DROP TABLE ' . $prefix . 'ch8_bug_data' );     <br/>} </pre>
<ol start="5">
<li>Add the following code to perform the deletion of tables created to store bugs from a single or network WordPress installation:</li>
</ol>
<pre style="padding-left: 60px">// Check that file was called from WordPress admin <br/>if( !defined( 'WP_UNINSTALL_PLUGIN' ) ) {<br/>    exit();<br/>}<br/> <br/>global $wpdb; <br/> <br/>// Check if site is configured for network installation <br/>if ( is_multisite() ) { <br/>    if ( !empty( $_GET['networkwide'] ) ) { <br/>        // Get blog list and cycle through all blogs <br/>        $start_blog = $wpdb-&gt;blogid; <br/>        $blog_list = $wpdb-&gt;get_col( 'SELECT blog_id FROM ' .<br/>                                     $wpdb-&gt;blogs ); <br/>        foreach ( $blog_list as $blog ) { <br/>            switch_to_blog( $blog ); <br/>            // Call function to delete bug table with prefix <br/>            ch8bt_drop_table( $wpdb-&gt;get_blog_prefix() ); <br/>        } <br/>        switch_to_blog( $start_blog ); <br/>        return; <br/>    }     <br/>}  <br/> <br/>ch8bt_drop_table( $wpdb-&gt;prefix ); </pre>
<ol start="6">
<li>Save and close the code file.</li>
<li>Navigate to the <span class="packt_screen">Plugins</span> management page and <span class="packt_screen">Deactivate</span> the <span class="packt_screen">Chapter 8 - Bug Tracker</span> plugin.</li>
<li>Make a copy of the entire plugin directory before performing the next step, to avoid deleting all of your work.</li>
<li>Click on the plugin's <span class="packt_screen">Delete</span> link and then click <span class="packt_screen">OK</span> in the dialog that asks for confirmation before deleting the plugin and its data.</li>
<li>Using <kbd>phpMyAdmin</kbd>, connect to your MySQL database to verify that the bug data table has been deleted.</li>
</ol>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How it works...</h1>
                </header>
            
            <article>
                
<p>As we saw in <a href="f7395811-9e4a-4913-8a02-cc68875d0071.xhtml" target="_blank"><span class="ChapterrefPACKT">Chapter 2</span></a>, <em>Plugin Framework Basics</em>, all of the code contained in a file called <kbd>uninstall.php</kbd> gets executed when a plugin is deleted. In this case, our code's main purpose is to run a query against the website database to remove the bug table.</p>
<p>Before doing so, the first few lines of the file check for the presence of a variable (<kbd>WP_UNINSTALL_PLUGIN</kbd>) to confirm that the code has been called as part of the plugin deletion process and not by an external user.</p>
<p>Once the legitimacy of the execution has been confirmed, the code that runs is similar to the table creation code, where we first get access to the WordPress database management class, followed by a check to see whether the WordPress installation is a single site or a network installation. In the first case, we make a single call to the <kbd>ch8bt_drop_table</kbd> function to drop the bug table, while we make multiple calls to that function for every existing site under a network environment.</p>
<p>The query to remove the table is actually quite simple, making a call to the <kbd>query</kbd> method of the <kbd>wpdb</kbd> class to execute a <kbd>DROP TABLE</kbd> SQL command.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">See also</h1>
                </header>
            
            <article>
                
<ul>
<li>The <em>Creating new database tables</em> recipe</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Updating custom table structure on plugin upgrade</h1>
                </header>
            
            <article>
                
<p>Over the lifetime of a plugin, as it gets expanded to provide additional functionality, there may be a need to store more data than was originally intended in custom database tables. As you may know, WordPress itself makes regular changes to its own database structure during the upgrade process to store new information. To do this, it uses a simple function called <kbd>dbDelta</kbd>, which we can also access from our plugin's code.</p>
<p>This recipe shows how to alter the previous table creation code to load the WordPress upgrade API and use the database upgrade function to add an extra field to the existing bug storage table.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Getting ready</h1>
                </header>
            
            <article>
                
<p>You should have already followed the <em>Creating new database tables</em> recipe to have the creation code to modify. Alternatively, you can get the resulting code (<kbd>Chapter 8/ch8-bug-tracker/ch8-bug-tracker-v1-1.php</kbd>) from the code bundle and rename the file <kbd>ch8-bug-tracker.php</kbd>.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<ol>
<li>Navigate to the WordPress plugin directory of your development installation.</li>
<li>Navigate to the <kbd>ch8-bug-tracker</kbd> directory and edit <kbd>ch8-bug-tracker.php</kbd>.</li>
<li>Locate the <kbd>ch8bt_create_table</kbd> function.</li>
<li>Remove the <kbd>IF NOT EXISTS</kbd> text on the first line of the table creation query.</li>
<li>Add an extra line to the table creation code to add a field to hold the bug title, shown as follows in bold:</li>
</ol>
<pre style="padding-left: 60px">$creation_query = 'CREATE TABLE ' . $prefix . <br/>                  'ch8_bug_data ( <br/>                  `bug_id` int(20) NOT NULL AUTO_INCREMENT, <br/>                  `bug_description` text, <br/>                  `bug_version` varchar(10) DEFAULT NULL, <br/>                  `bug_report_date` date DEFAULT NULL, <br/>                  `bug_status` int(3) NOT NULL DEFAULT 0, <br/>                  <strong>`bug_title` VARCHAR( 128 ) NULL</strong>, <br/>                  PRIMARY KEY (`bug_id`) <br/>                  );'; </pre>
<ol start="6">
<li>Locate the following lines of code:</li>
</ol>
<pre style="padding-left: 60px">global $wpdb; <br/>wpdb-&gt;query( $creation_query ); </pre>
<p style="padding-left: 60px">They should be replaced with the following lines of code:</p>
<pre style="padding-left: 60px">require_once( ABSPATH . 'wp-admin/includes/upgrade.php' ); <br/>dbDelta( $creation_query ); </pre>
<ol start="7">
<li>Save and close the plugin file.</li>
<li>Navigate to the <span class="packt_screen">Plugins</span> management page.</li>
<li><span class="packt_screen">Deactivate</span> and re-<span class="packt_screen">Activate</span> the <span class="packt_screen">Chapter 8 - Bug Tracker</span> plugin.</li>
</ol>
<p>Â </p>
<ol start="10">
<li>Using phpMyAdmin, connect to your MySQL database to see that the new <kbd>bug_title</kbd> field has been added to the bug storage table:</li>
</ol>
<div class="CDPAlignCenter CDPAlign"><img height="184" width="187" class="image-border" src="assets/b836d06e-3b12-4a3c-b790-99d7c992bc8c.png"/></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How it works...</h1>
                </header>
            
            <article>
                
<p>The <kbd>dbDelta</kbd> function is part of the utility functions that WordPress calls when performing version upgrades. When called, it parses the table creation SQL command that it receives and figures out the difference between the table structure that it describes and the current table, if the table exists. Once that difference has been established, it performs the necessary changes to align the two structures.</p>
<p>If both the structures are identical, it leaves the table as it is. With this approach in place, any changes to the structure can simply be implemented by altering the table creation query. As such, the <kbd>dbDelta</kbd> function can actually be used from the first version of a plugin to ensure an easy upgrade path.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">See also</h1>
                </header>
            
            <article>
                
<ul>
<li>The <em>Creating new database tables</em> recipe</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Displaying custom table data on an admin page</h1>
                </header>
            
            <article>
                
<p>After creating one or more custom database tables to store data, the next step in the creation of a custom item management system is to build an interface to populate them. While custom post types have a very organized structure to edit entries, creating an interface for custom tables is much more similar to creating plugin configuration panels, as we saw in <a href="0346c3c6-27ee-45fb-bfd6-df398e04b2b4.xhtml"><span class="ChapterrefPACKT">Chapter 3</span></a>, <em>User Settings and Administration Pages</em>.</p>
<p>This recipe shows how to create an interface that will display a list of bugs stored in the system, provide a link to create new entries, and offer a way to edit existing entries.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Getting ready</h1>
                </header>
            
            <article>
                
<p>You should have already followed the <em>Updating custom table structure on plugin upgrade</em> recipe to have a custom table in place with the required structure. Alternatively, you can get the resulting code (<kbd>Chapter 8/ch8-bug-tracker/ch8-bug-tracker-v2.php</kbd>) from the code bundle and rename the file <kbd>ch8-bug-tracker.php</kbd>.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<ol>
<li>Navigate to the WordPress plugin directory of your development installation.</li>
<li>Navigate to the <kbd>ch8-bug-tracker</kbd> directory and edit <kbd>ch8-bug-tracker.php</kbd>.</li>
<li>Insert the following line of code to register a function to be called when the administration menu is being built:</li>
</ol>
<pre style="padding-left: 60px">add_action( 'admin_menu', 'ch8bt_settings_menu' ); </pre>
<ol start="4">
<li>Add the following code to provide an implementation for the <kbd>ch8bt_settings_menu</kbd> function:</li>
</ol>
<pre style="padding-left: 60px">function ch8bt_settings_menu() { <br/>    add_options_page( 'Bug Tracker Data Management',   <br/>                      'Bug Tracker',<br/>                      'manage_options', 'ch8bt-bug-tracker',<br/>                      'ch8bt_config_page' ); <br/>} </pre>
<ol start="5">
<li>Append the following block of code to provide an implementation for the <kbd>ch8bt_config_page</kbd> function responsible to render the configuration page:</li>
</ol>
<pre style="padding-left: 60px">function ch8bt_config_page() { <br/>    global $wpdb;  <br/>    ?&gt; <br/> <br/>    &lt;!-- Top-level menu --&gt; <br/>    &lt;div id="ch8bt-general" class="wrap"&gt; <br/>    &lt;h2&gt;Bug Tracker &lt;a class="add-new-h2" href="&lt;?php echo <br/>         add_query_arg( array( 'page' =&gt; 'ch8bt-bug-tracker', <br/>                               'id' =&gt; 'new' ),  <br/>                        admin_url('options-general.php') ); ?&gt;"&gt; <br/>    Add New Bug&lt;/a&gt;&lt;/h2&gt; <br/>     <br/>    &lt;!-- Display bug list if no parameter sent in URL --&gt; <br/>    &lt;?php if ( empty( $_GET['id'] ) ) { <br/>        $bug_query = 'select * from ' . $wpdb-&gt;get_blog_prefix();<br/>        $bug_query .= 'ch8_bug_data ORDER by bug_report_date DESC';<br/>        $bug_items = $wpdb-&gt;get_results( $bug_query, ARRAY_A );<br/>    ?&gt; <br/> <br/>    &lt;h3&gt;Manage Bug Entries&lt;/h3&gt; <br/> <br/>    &lt;table class="wp-list-table widefat fixed"&gt; <br/>    &lt;thead&gt;&lt;tr&gt;&lt;th style="width: 80px"&gt;ID&lt;/th&gt; <br/>    &lt;th style="width: 300px"&gt;Title&lt;/th&gt;<br/>    &lt;th&gt;Version&lt;/th&gt;&lt;/tr&gt;&lt;/thead&gt;<br/> <br/>    &lt;?php  <br/>        // Display bugs if query returned results <br/>        if ( $bug_items ) {             <br/>            foreach ( $bug_items as $bug_item ) { <br/>                echo '&lt;tr style="background: #FFF"&gt;'; <br/>                echo '&lt;td&gt;' . $bug_item['bug_id'] . '&lt;/td&gt;';<br/>                echo '&lt;td&gt;&lt;a href="'; <br/>                echo add_query_arg( array(  <br/>                    'page' =&gt; 'ch8bt-bug-tracker', <br/>                    'id' =&gt; $bug_item['bug_id'] ), <br/>                    admin_url( 'options-general.php' ) ); <br/>                echo '"&gt;' . $bug_item['bug_title'] . '&lt;/a&gt;&lt;/td&gt;'; <br/>                echo '&lt;td&gt;' . $bug_item['bug_version'];<br/>                echo '&lt;/td&gt;&lt;/tr&gt;';                     <br/>            } <br/>        } else {<br/>            echo '&lt;tr style="background: #FFF"&gt;'; <br/>            echo '&lt;td colspan="3"&gt;No Bug Found&lt;/td&gt;&lt;/tr&gt;'; <br/>        }        <br/>    ?&gt; <br/>    &lt;/table&gt;&lt;br /&gt; <br/>    &lt;?php } ?&gt; <br/>    &lt;/div&gt; <br/>&lt;?php } </pre>
<ol start="6">
<li>Save and close the plugin file.</li>
<li>Navigate to the new <span class="packt_screen">Bug</span> <span class="packt_screen">Tracker</span> item under the administration page's <span class="packt_screen">Settings</span> menu to see the newly created page, showing that there are currently no bugs stored in the system:</li>
</ol>
<div class="CDPAlignCenter CDPAlign"><img height="147" width="638" class="image-border" src="assets/09494f30-ba92-4fb9-9e7c-a6ddb17b5012.png"/></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How it works...</h1>
                </header>
            
            <article>
                
<p>The first few steps of the recipe use functions that were previously covered in <a href="0346c3c6-27ee-45fb-bfd6-df398e04b2b4.xhtml" target="_blank"><span class="ChapterrefPACKT">Chapter 3</span></a>, <em>User Settings and Administration Pages</em>, to register a callback that will add a menu to the Settings section of the admin menu. When the new menu page is visited, the <kbd>ch8bt_config_page</kbd> function is called to render the page contents, using a mix of HTML and PHP code.</p>
<p>After rendering the page title, along with a link that will be used to create new bugs, the page display code checks to see whether the page address contains a variable called <kbd>id</kbd>. This ID will be used in subsequent recipes to indicate whether the user wants to create or edit bugs. It will not be set when a visitor clicks on the <span class="packt_screen">Bug Tracker</span> menu item, resulting in the current recipe code getting called.</p>
<p>The next section uses the <kbd>get_results</kbd> method of the <kbd>wpdb</kbd> database management class to retrieve information from the database. In this call, the first parameter is an SQL query, whereas the second argument indicates the desired format to be used to return data. While we specified that we want an associative array in this case, other options are to return a numerically indexed array (<kbd>ARRAY_N</kbd>), an object (<kbd>OBJECT</kbd>), or an array of objects (<kbd>OBJECT_K</kbd>).</p>
<p>The <kbd>SELECT *</kbd> command in the query indicates that we want all the fields in the table to be returned, while the <kbd>ORDER</kbd> command specifies the field that should be used to order results and the order direction (<kbd>ASC</kbd> or <kbd>DESC</kbd>).</p>
<p>Once the <kbd>get_results</kbd> method has been executed, we will check to see whether any data was retrieved from the database, and proceed to perform a <kbd>foreach</kbd> loop through all the records to display them in a standard HTML table if data is found. If no records are returned by the query, we will display a short message indicating that no bugs were found.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">See also</h1>
                </header>
            
            <article>
                
<ul>
<li>The <em>Creating an administration page menu item in the Settings menu</em> recipe in <a href="0346c3c6-27ee-45fb-bfd6-df398e04b2b4.xhtml" target="_blank"><span class="ChapterrefPACKT">Chapter 3</span></a>, <em>User Settings and Administration Pages</em></li>
<li>The <em>Rendering the admin page contents using HTML</em> recipe in <a href="0346c3c6-27ee-45fb-bfd6-df398e04b2b4.xhtml" target="_blank"><span class="ChapterrefPACKT">Chapter 3</span></a>, <em>User Settings and Administration Pages</em></li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Inserting and updating records in custom tables</h1>
                </header>
            
            <article>
                
<p>Now that we have a basic infrastructure in place to display existing bugs, the next logical step is to create a form that will be used to insert and update records in a custom table.</p>
<p>This recipe shows how to add a form to manage bugs when users select an entry in the bug tracking list or indicate that they want to create a new entry by using the appropriate link.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Getting ready</h1>
                </header>
            
            <article>
                
<p>You should have already followed the <em>Displaying custom table data in an admin page</em> recipe to have an existing framework in place. Alternatively, you can get the resulting code (<kbd>Chapter 8/ch8-bug-tracker/ch8-bug-tracker-v3.php</kbd>) from the code bundle and rename the file <kbd>ch8-bug-tracker.php</kbd>.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<ol>
<li>Navigate to the WordPress plugin directory of your development installation.</li>
<li>Navigate to the <kbd>ch8-bug-tracker</kbd> directory and edit <kbd>ch8-bug-tracker.php</kbd>.</li>
<li>Find the <kbd>ch8bt_config_page</kbd> function and locate the bracket that closes out the <kbd>if</kbd> statement (<kbd>&lt;?php } ?&gt;</kbd>) situated toward the end of its body.</li>
<li>Insert the following code block right before the closing bracket from the <kbd>if</kbd> statement identified in the previous step:</li>
</ol>
<pre style="padding-left: 60px">&lt;?php } elseif ( isset( $_GET['id'] ) &amp;&amp;<br/>                 ( 'new' == $_GET['id'] ||  <br/>                   is_numeric( $_GET['id'] ) ) ) {                  <br/>    $bug_id = intval( $_GET['id'] ); <br/>    $mode = 'new'; <br/>         <br/>    // Query database if numeric id is present <br/>    if ( $bug_id &gt; 0 ) { <br/>        $bug_query = 'select * from ' . $wpdb-&gt;get_blog_prefix(); <br/>        $bug_query .= 'ch8_bug_data where bug_id = %d'; <br/> <br/>        $bug_data =<br/>            $wpdb-&gt;get_row( $wpdb-&gt;prepare( $bug_query, $bug_id ), <br/>                            ARRAY_A ); <br/> <br/>        // Set variable to indicate page mode <br/>        if ( $bug_data ) {<br/>            $mode = 'edit'; <br/>        }<br/>    } <br/><br/>    if ( 'new' == $mode ) {<br/>        $bug_data = array(<br/>            'bug_title' =&gt; '', 'bug_description' =&gt; '',<br/>            'bug_version' =&gt; '', 'bug_status' =&gt; ''<br/>        ); <br/>    }<br/> <br/>    // Display title based on current mode <br/>    if ( 'new' == $mode ) { <br/>        echo '&lt;h3&gt;Add New Bug&lt;/h3&gt;'; <br/>    } elseif ( 'edit' == $mode ) { <br/>        echo '&lt;h3&gt;Edit Bug #' . $bug_data['bug_id'] . ' - '; <br/>        echo $bug_data['bug_title'] . '&lt;/h3&gt;'; <br/>    } <br/>    ?&gt; <br/>  <br/>    &lt;form method="post"  <br/>          action="&lt;?php echo admin_url( 'admin-post.php' ); ?&gt;"&gt; <br/>    &lt;input type="hidden" name="action" value="save_ch8bt_bug" /&gt; <br/>    &lt;input type="hidden" name="bug_id" <br/>           value="&lt;?php echo $bug_id; ?&gt;" /&gt; <br/> <br/>    &lt;!-- Adding security through hidden referrer field --&gt; <br/>    &lt;?php wp_nonce_field( 'ch8bt_add_edit' ); ?&gt; <br/> <br/>    &lt;!-- Display bug editing form --&gt; <br/>    &lt;table&gt; <br/>        &lt;tr&gt; <br/>            &lt;td style="width: 150px"&gt;Title&lt;/td&gt; <br/>            &lt;td&gt;&lt;input type="text" name="bug_title" size="60"<br/>                       value="&lt;?php echo esc_html( <br/>                       $bug_data['bug_title'] ); ?&gt;"/&gt;&lt;/td&gt; <br/>        &lt;/tr&gt; <br/>        &lt;tr&gt; <br/>            &lt;td&gt;Description&lt;/td&gt; <br/>            &lt;td&gt;&lt;textarea name="bug_description"  <br/>            cols="60"&gt;&lt;?php echo<br/>esc_textarea( $bug_data['bug_description'] ); ?&gt;&lt;/textarea&gt;&lt;/td&gt; <br/>        &lt;/tr&gt; <br/>        &lt;tr&gt; <br/>            &lt;td&gt;Version&lt;/td&gt; <br/>            &lt;td&gt;&lt;input type="text" name="bug_version" <br/>                       value="&lt;?php echo esc_html( <br/>                       $bug_data['bug_version'] ); ?&gt;" /&gt;&lt;/td&gt; <br/>        &lt;/tr&gt; <br/>        &lt;tr&gt; <br/>            &lt;td&gt;Status&lt;/td&gt; <br/>            &lt;td&gt; <br/>                &lt;select name="bug_status"&gt; <br/>                &lt;?php  <br/>                // Display drop-down list of bug statuses<br/>                $bug_statuses = array( 0 =&gt; 'Open', 1 =&gt; 'Closed',<br/>                                       2 =&gt; 'Not-a-Bug' );<br/>                foreach( $bug_statuses as $status_id =&gt; $status ) { <br/>                    // Add selected tag when entry matches <br/>                    echo '&lt;option value="' . $status_id . '" '; <br/>                    selected( $bug_data['bug_status'], <br/>                              $status_id ); <br/>                    echo '&gt;' . $status; <br/>                } <br/>                ?&gt; <br/>                &lt;/select&gt; <br/>            &lt;/td&gt; <br/>        &lt;/tr&gt; <br/>    &lt;/table&gt; <br/>    &lt;input type="submit" value="Submit" class="button-primary" /&gt; <br/>&lt;/form&gt; </pre>
<ol start="5">
<li>Add the following line of code to register a function that will be called on the initialization of the administration page:</li>
</ol>
<pre style="padding-left: 60px">add_action( 'admin_init', 'ch8bt_admin_init' ); </pre>
<ol start="6">
<li>Add the following block of code at the end of the plugin file to register a function to be called when bugs are created or updated:</li>
</ol>
<pre style="padding-left: 60px">function ch8bt_admin_init() { <br/>    add_action( 'admin_post_save_ch8bt_bug', 'process_ch8bt_bug' ); <br/>} </pre>
<ol start="7">
<li>Append the following block of code to process user-submitted data and store it in the website database:</li>
</ol>
<pre style="padding-left: 60px">function process_ch8bt_bug() {  <br/>    if ( !current_user_can( 'manage_options' ) ) {<br/>        wp_die( 'Not allowed' );<br/>    }<br/> <br/>    // Check if nonce field is present for security <br/>    check_admin_referer( 'ch8bt_add_edit' ); <br/>    global $wpdb;<br/><br/>    // Place all user submitted values in an array (or empty <br/>    // strings if no value was sent) <br/>    $bug_data = array(); <br/>    $bug_data['bug_title'] = ( isset( $_POST['bug_title'] ) ?<br/>        sanitize_text_field( $_POST['bug_title'] ) : '' ); <br/> <br/>    $bug_data['bug_description'] =<br/>        ( isset( $_POST['bug_description'] ) ? <br/>          sanitize_text_field( $_POST['bug_description'] ) : '' ); <br/>  <br/>    $bug_data['bug_version'] = ( isset( $_POST['bug_version'] ) ? <br/>        sanitize_text_field( $_POST['bug_version'] ) : '' ); <br/> <br/>    // Set bug report date as current date <br/>    $bug_data['bug_report_date'] = date( 'Y-m-d' ); <br/> <br/>    // Set status of all new bugs to 0 (Open) <br/>    $bug_data['bug_status'] = ( isset( $_POST['bug_status'] ) ? <br/>        intval( $_POST['bug_status'] ) : 0 ); <br/> <br/>    // Call the wpdb insert or update method based on value <br/>    // of hidden bug_id field <br/>    if ( isset( $_POST['bug_id'] ) &amp;&amp; 0 == $_POST['bug_id'] ) { <br/>        $wpdb-&gt;insert( $wpdb-&gt;get_blog_prefix() . 'ch8_bug_data', <br/>                       $bug_data ); <br/>    } elseif ( isset( $_POST['bug_id'] ) &amp;&amp; <br/>               $_POST['bug_id'] &gt; 0 ) { <br/>        $wpdb-&gt;update( $wpdb-&gt;get_blog_prefix() . 'ch8_bug_data',  <br/>            $bug_data, <br/>            array( 'bug_id' =&gt; intval( $_POST['bug_id'] ) ) ); <br/>    } <br/> <br/>    // Redirect the page to the user submission form<br/>    wp_redirect( add_query_arg( 'page', 'ch8bt-bug-tracker', <br/>                     admin_url( 'options-general.php' ) ) ); <br/>    exit; <br/>} </pre>
<ol start="8">
<li>Save and close the plugin file.</li>
<li>Navigate to the new <span class="packt_screen">Bug</span> <span class="packt_screen">Tracker</span> item under the administration page's <span class="packt_screen">Settings</span> menu and click on the <span class="packt_screen">Add</span> <span class="packt_screen">New</span> <span class="packt_screen">Bug</span> link to create an entry:</li>
</ol>
<div class="CDPAlignCenter CDPAlign"><img height="216" width="442" class="image-border" src="assets/144e94fb-dba1-496b-9d16-79da36051edd.png"/></div>
<ol start="10">
<li>Click on <span class="packt_screen">Submit</span> to store the new bug in the website database. The newly created bug will appear in the bug listing created in the previous recipe.</li>
<li>Click on the new entry's name to review its information and update it.</li>
</ol>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How it works...</h1>
                </header>
            
            <article>
                
<p>If you tried clicking on the <span class="packt_screen">Add New Bug</span> link created in the previous recipe, you would have been presented with a page that only contained the panel's title. This is due to the fact that we had not implemented the code to display a bug creation and editing form when the <kbd>id</kbd> variable is present in the website address.</p>
<p>The first few steps of this recipe aim to rectify this by checking for the presence of a variable called <kbd>id</kbd> in the page URL with a value set to the text <kbd>new</kbd> or a numeric value.</p>
<p>While both of these situations will result in displaying a bug edition form, the second condition first performs a database query using the <kbd>wpdb</kbd> object's <kbd>get_row</kbd> method to try to retrieve a bug with the designated ID. The <kbd>get_row</kbd> method is similar to the <kbd>get_results</kbd> method used in the previous recipe, but will only return a single row, even if more than one result is found by the query. As part of our <kbd>get_row</kbd> call, we also use the <kbd>$wpdb</kbd> class's prepare method. This method will parse the second argument it receives for security and then use it to replace the placeholder placed in our query. If the query is successful, the values that were retrieved are used to customize the form title and set initial field values.</p>
<p>The form itself is a standard HTML form that includes many of the elements that we have seen in previous recipes, such as a call to <kbd>wp_nonce_field</kbd> to provide security from external attacks. We have also added a hidden field containing the bug ID that was found in the page URL to facilitate data processing when a bug is submitted.</p>
<p>Once the form is in place, we make a call to <kbd>add_action</kbd> to register a callback that will be executed when the newly created form is submitted.</p>
<p>The callback, named <kbd>process_ch8bt_bug</kbd>, starts off by doing a bit of validation. Namely, it checks to see whether the current user has administrative rights and if the nonce field that should be part of the form data is present. If both of these conditions are met, a data array is created from user post data, the current system date, and a hardcoded status value.</p>
<p>The resulting array is stored in the website database using one of two <kbd>wpdb</kbd> object methods, <kbd>insert</kbd> or <kbd>update</kbd>, based on the value found in the hidden <kbd>bug_id</kbd> field. Both methods expect to receive the name of the target table, along with an associative array containing the names and values of each table field to be stored. Additionally, the <kbd>update</kbd> method requires a third parameter that indicates the field name and value to be used to locate the field to be updated. In both cases, you will notice that the <kbd>bug_id</kbd> field is not specified in the array of new values, since it gets automatically set to an incremental value by the database server.</p>
<p>The last step in this function is to build a clean URL to the plugin configuration page and use the resulting address in a call to <kbd>wp_redirect</kbd>.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">See also</h1>
                </header>
            
            <article>
                
<ul>
<li>The <em>Displaying custom table data in an admin page</em> recipe</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Deleting records from custom tables</h1>
                </header>
            
            <article>
                
<p>After adding data to custom tables, website administrators are likely to delete some of these entries down the road. Since we have been building an interface to view, create, and modify database entries, the task of selecting items to be deleted also falls under our responsibility. Thankfully, we can easily expand the existing bug display list to add checkboxes for selection and a button to trigger the actual deletion.</p>
<p>This recipe shows how to add deletion capabilities to our bug tracking system.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Getting ready</h1>
                </header>
            
            <article>
                
<p>You should have already followed the <em>Inserting and updating records in custom tables</em> recipe to have an existing framework to augment. Alternatively, you can get the resulting code (<kbd>Chapter 8/ch8-bug-tracker/ch8-bug-tracker-v4.php</kbd>) from the code bundle and rename the file <kbd>ch8-bug-tracker.php</kbd>.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<ol>
<li>Navigate to the WordPress plugin directory of your development installation.</li>
<li>Navigate to the <kbd>ch8-bug-tracker</kbd> directory and edit <kbd>ch8-bug-tracker.php</kbd>.</li>
<li>Find the <kbd>ch8bt_config_page</kbd> function and locate the <kbd>Manage Bug Entries h3</kbd> header in its content.</li>
<li>Insert the following highlighted lines of code right after the header to create a form:</li>
</ol>
<pre style="padding-left: 60px">&lt;h3&gt;Manage Bug Entries&lt;/h3&gt; <br/> <br/><strong>&lt;form method="post"<br/>      action="&lt;?php echo admin_url( </strong><strong>'admin-post.php' ); ?&gt;"&gt; </strong><br/><strong>&lt;input type="hidden" name="action" </strong><strong>value="delete_ch8bt_bug" /&gt; </strong> <br/><strong>&lt;!-- Adding security through hidden referrer field -</strong><strong>-&gt; </strong><br/><strong>&lt;?php wp_nonce_field( 'ch8bt_deletion' ); ?&gt;</strong> </pre>
<ol start="5">
<li>A few lines down, add an empty column in the table header, before the <kbd>ID</kbd> field, as highlighted in the following line of code:</li>
</ol>
<pre style="padding-left: 60px">&lt;thead&gt;&lt;tr&gt;<strong>&lt;th style="width: 50px"&gt;&lt;/th&gt;</strong><br/>       &lt;th style='width: 80px'&gt;ID&lt;/th&gt;</pre>
<ol start="6">
<li>Within the main bug list display loop, insert the following highlighted code segments to add a checkbox in front of each item:</li>
</ol>
<pre style="padding-left: 60px">echo '&lt;tr style="background: #FFF"&gt;'; <br/><strong>echo '&lt;td&gt;&lt;input type="checkbox" name="bugs[]" </strong><strong>value="'; </strong><br/><strong>echo intval( $bug_item['bug_id'] ) . '" /&gt;&lt;/td&gt;';</strong> <br/>echo '&lt;td&gt;' . $bug_item['bug_id'] . '&lt;/td&gt;';</pre>
<ol start="7">
<li>A few lines down, change the value of the <kbd>colspan</kbd> table row parameter from <kbd>3</kbd> to <kbd>4</kbd>:</li>
</ol>
<pre style="padding-left: 60px">echo '&lt;td colspan="<strong>4</strong>"&gt;No Bug Found&lt;/td&gt;&lt;/tr&gt;'; </pre>
<ol start="8">
<li>Append the following highlighted lines of code after the <kbd>table</kbd> close tag to display a deletion button and terminate the form section:</li>
</ol>
<pre style="padding-left: 60px">&lt;/table&gt;&lt;br /&gt; <br/> <br/><strong>&lt;input type="submit" value="Delete Selected"   </strong><br/><strong>       class="button-primary"/&gt; </strong><br/><strong>&lt;/form&gt;</strong> </pre>
<ol start="9">
<li>Find the <kbd>ch8bt_admin_init</kbd> function and add the following function call at the end of its body:</li>
</ol>
<pre style="padding-left: 60px">add_action( 'admin_post_delete_ch8bt_bug', 'delete_ch8bt_bug' ); </pre>
<ol start="10">
<li>Navigate to the bottom of the file and add the following code block to provide an implementation for the <kbd>delete_ch8bt_bug</kbd> function responsible for processing deletion requests generated by the new form:</li>
</ol>
<pre style="padding-left: 60px">function delete_ch8bt_bug() { <br/>    // Check that user has proper security level <br/>    if ( !current_user_can( 'manage_options' ) ) {<br/>        wp_die( 'Not allowed' );<br/>    }<br/><br/>    // Check if nonce field is present <br/>    check_admin_referer( 'ch8bt_deletion' );<br/><br/>    // If bugs are present, cycle through array and call SQL <br/>    // command to delete entries one by one<br/>    if ( !empty( $_POST['bugs'] ) ) { <br/>        // Retrieve array of bugs IDs to be deleted <br/>        $bugs_to_delete = $_POST['bugs'];         <br/>        global $wpdb;<br/><br/>        foreach ( $bugs_to_delete as $bug_to_delete ) { <br/>            $query = 'DELETE from ' . $wpdb-&gt;get_blog_prefix(); <br/>            $query .= 'ch8_bug_data WHERE bug_id = %d'; <br/>            $wpdb-&gt;query( $wpdb-&gt;prepare( $query,<br/>                          intval( $bug_to_delete ) ) ); <br/>        }         <br/>    }<br/><br/>    // Redirect the page to the user submission form <br/>    wp_redirect( add_query_arg( 'page', 'ch8bt-bug-tracker', <br/>                 admin_url( 'options-general.php' ) ) ); <br/>    exit;   <br/>} </pre>
<ol start="11">
<li>Save and close the plugin file.</li>
<li>Navigate to the new <span class="packt_screen">Bug</span> <span class="packt_screen">Tracker</span> item under the administration page's <span class="packt_screen">Settings</span> menu to see the new interface elements that were added to the bug listing.</li>
</ol>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How it works...</h1>
                </header>
            
            <article>
                
<p>While the actual deletion of data from our custom table can be done with a single call to run the <kbd>DELETE</kbd> SQL command, we first need the user to indicate which entries need to be removed. This selection interface can be easily added to the existing bug listing created in an earlier recipe.</p>
<p>This recipe starts in familiar territory with the creation of a standard HTML form to surround the original bug listing. In addition to the bug list, the form also includes a hidden field to indicate the name of the action to be called when the user submits the form, along with a nonce field to ensure that access to the deletion process is secure.</p>
<p>With this initial code in place, the next section of the recipe modifies the original table listing to add a checkbox at the front of every row. As can be seen in the code, the <kbd>name</kbd> property of the checkbox is a bit different than regular HTML syntax, ending with two square parentheses. This syntax, used in conjunction with each item's <kbd>bug_id</kbd>, results in the creation of an array of checked items and ID numbers that are sent to the form processing function on submission.</p>
<p>The last change that is done in the bug listing display code is to add a deletion button and to close the form.</p>
<p>To associate a callback with the newly created form, the next addition made by the recipe is a call to <kbd>add_action</kbd> to associate the <kbd>admin_post_&lt;actionname&gt;</kbd> variable action name with the <kbd>delete_ch8bt_bug</kbd> function.</p>
<p>When called, the bug deletion function, like most other submission processing code that we have created before, first starts with a few verifications to make sure that the user has appropriate permissions and that the hidden security fields that were placed in the form are present. When both of these formalities are confirmed, the code goes on to check for the presence of a bug array and proceeds to cycle through all the entries if one was found. In that loop, we get access to the global <kbd>wpdb</kbd> class and we can use it to build and execute SQL queries that delete a single database row at a time using the <kbd>bug_id</kbd> numbers that were submitted.</p>
<p>As an added security measure, notice the use of the <kbd>intval</kbd> function in front of the <kbd>$bug_to_delete</kbd> variable to make sure that no one is trying to get external commands to be processed in an attempt to corrupt or hijack the database.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">See also</h1>
                </header>
            
            <article>
                
<ul>
<li>The <em>Inserting and updating records in custom tables</em> recipe</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Displaying custom database table data in shortcodes</h1>
                </header>
            
            <article>
                
<p>The purpose of creating custom tables is often to store information to be shared with website visitors. As such, it is important to give users the ability to easily display their new content stored in custom tables on their website. The most straightforward method to achieve this goal is to create one or more shortcodes that can be inserted on any post or page to render the desired information.</p>
<p>This recipe shows how to implement a new shortcode that will be used to display a bug listing on a page.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Getting ready</h1>
                </header>
            
            <article>
                
<p>You should have already followed the <em>Deleting records from custom tables</em> recipe to have an existing framework to augment. Alternatively, you can get the resulting code (<kbd>Chapter 8/ch8-bug-tracker/ch8-bug-tracker-v5.php</kbd>) from the code bundle and rename the file <kbd>ch8-bug-tracker.php</kbd>.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<ol>
<li>Navigate to the WordPress plugin directory of your development installation.</li>
<li>Navigate to the <kbd>ch8-bug-tracker</kbd> directory and edit <kbd>ch8-bug-tracker.php</kbd>.</li>
<li>Add the following line of code at the bottom of the file to declare a new shortcode and its associated display function:</li>
</ol>
<pre style="padding-left: 60px">add_shortcode( 'bug-tracker-list', 'ch8bt_shortcode_list' ); </pre>
<ol start="4">
<li>Insert the following code block right after the section header to implement the <kbd>ch8bt_shortcode_list</kbd> function that is responsible for displaying a bug listing:</li>
</ol>
<pre style="padding-left: 60px">function ch8bt_shortcode_list() { <br/>    global $wpdb;<br/><br/>    // Prepare query to retrieve bugs from database <br/>    $bug_query = 'select * from ' . $wpdb-&gt;get_blog_prefix();<br/>    $bug_query .= 'ch8_bug_data ';<br/>    $bug_query .= 'ORDER by bug_id DESC';                <br/>    $bug_items = $wpdb-&gt;get_results( $bug_query, ARRAY_A );<br/><br/>    // Prepare output to be returned to replace shortcode<br/>    $output = '';<br/>    $output .= '&lt;div class="bug-tracker-list"&gt;&lt;table&gt;';<br/><br/>    // Check if any bugs were found <br/>    if ( !empty( $bug_items ) ) { <br/>        $output .= '&lt;tr&gt;&lt;th style="width: 80px"&gt;ID&lt;/th&gt;'; <br/>        $output .= '&lt;th style="width: 300px"&gt;Title / Desc&lt;/th&gt;'; <br/>        $output .= '&lt;th&gt;Version&lt;/th&gt;&lt;/tr&gt;';<br/><br/>        // Create row in table for each bug <br/>        foreach ( $bug_items as $bug_item ) { <br/>            $output .= '&lt;tr style="background: #FFF"&gt;'; <br/>            $output .= '&lt;td&gt;' . $bug_item['bug_id'] . '&lt;/td&gt;'; <br/>            $output .= '&lt;td&gt;' . $bug_item['bug_title'] . '&lt;/td&gt;'; <br/>            $output .= '&lt;td&gt;' . $bug_item['bug_version'] . '&lt;/td&gt;'; <br/>            $output .= '&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;/td&gt;&lt;td colspan="2"&gt;'; <br/>            $output .= $bug_item['bug_description']; <br/>            $output .= '&lt;/td&gt;&lt;/tr&gt;'; <br/>        } <br/>    } else { <br/>        // Message displayed if no bugs are found <br/>        $output .= '&lt;tr style="background: #FFF"&gt;'; <br/>        $output .= '&lt;td colspan="3"&gt;No Bugs to Display&lt;/td&gt;'; <br/>    }             <br/>    $output .= '&lt;/table&gt;&lt;/div&gt;';<br/><br/>    // Return data prepared to replace shortcode on page/post <br/>    return $output; <br/>} </pre>
<ol start="5">
<li>Save and close the plugin file.</li>
<li>Create a new page and insert the newly created shortcode <kbd>[bug-tracker-list]</kbd> in the page body.</li>
</ol>
<p>Â </p>
<ol start="7">
<li>View the page to see a list of bugs stored in the system:</li>
</ol>
<div class="CDPAlignCenter CDPAlign"><img height="169" width="414" class="image-border" src="assets/2650036b-5f68-4c0b-ada9-a1417b3821f4.png"/></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How it works...</h1>
                </header>
            
            <article>
                
<p>Creating a new shortcode to display custom table data is done in a very similar way as in previous recipes. First, we declare the new code, along with the name of the function that will be called to generate text to replace it when found in posts or pages. Then, we create a display function to prepare all the output and return it to WordPress.</p>
<p>The only distinction here is in the way we query the information. The recipe uses the <kbd>get_results</kbd> method of the <kbd>wpdb</kbd> class to query all the bugs that exist in the custom database table using the <kbd>SELECT</kbd> SQL command. After this call is executed, all the items found are returned in an associative array that can easily be displayed in table form using a <kbd>foreach</kbd> loop.</p>
<p>If no entries were found, the recipe displays a simple message to inform the visitor.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">See also</h1>
                </header>
            
            <article>
                
<ul>
<li>The <em>Deleting records from custom tables</em> recipe</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Implementing a search function to retrieve custom table data</h1>
                </header>
            
            <article>
                
<p>While content created using custom post types can be automatically searched by the built-in WordPress search engine, custom database tables don't benefit from the same treatment. Instead, plugin developers choosing this mechanism to store information must build their own search functionality.</p>
<p>This recipe shows how to add a search box to the bug listing created in the previous section and how to use the resulting query data to narrow down the list of bugs that are displayed by the shortcode.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Getting ready</h1>
                </header>
            
            <article>
                
<p>You should have already followed the recipe titled <em>Displaying custom database table data in shortcodes</em> to have an existing framework to augment. Alternatively, you can get the resulting code (<kbd>Chapter 8/ch8-bug-tracker/ch8-bug-tracker-v6.php</kbd>) from the code bundle and rename the file <kbd>ch8-bug-tracker.php</kbd>.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<ol>
<li>Navigate to the WordPress plugin directory of your development installation.</li>
<li>Navigate to the <kbd>ch8-bug-tracker</kbd> directory and edit <kbd>ch8-bug-tracker.php</kbd>.</li>
<li>Find the <kbd>ch8bt_shortcode_list</kbd> function and add the following highlighted code after the initial <kbd>global $wpdb</kbd> call to check whether a search string was entered by a visitor:</li>
</ol>
<pre style="padding-left: 60px">global $wpdb; <br/> <br/><strong>if ( !empty( $_GET['searchbt'] ) ) { </strong><br/><strong>    $search_string = sanitize_text_field( </strong><strong>$_GET['searchbt'] ); </strong><br/><strong>    $search_mode = true; </strong><br/><strong>} else { </strong><br/><strong>    $search_string = "Search..."; </strong><br/><strong>    $search_mode = false; </strong><br/><strong>}</strong> </pre>
<ol start="4">
<li>Insert the following highlighted lines of code in the middle of the existing query string to add the <kbd>where</kbd> parameters using the user search text, if present:</li>
</ol>
<pre style="padding-left: 60px">$bug_query = 'select * from ' . $wpdb-&gt;get_blog_prefix(); <br/>$bug_query .= 'ch8_bug_data ';<br/><br/><strong>// Add search string in query if present </strong><br/><strong>if ( $search_mode ) { </strong><br/><strong>    $search_term = '%'. $search_string . '%'; </strong><br/><strong>    $bug_query .= "where bug_title like '%s' "; </strong><br/><strong>    $bug_query .= "or bug_description like '%s' "; </strong><br/><strong>} else { </strong><br/><strong>    $search_term = ''; </strong><br/><strong>}<br/><br/></strong>$bug_query .= 'ORDER by bug_id DESC'; </pre>
<ol start="5">
<li>Locate the following line of code:</li>
</ol>
<pre style="padding-left: 60px">$bug_items = $wpdb-&gt;get_results( $bug_query, ARRAY_A );</pre>
<p style="padding-left: 60px">Replace it to the following code:</p>
<pre style="padding-left: 60px">if ( $search_mode ) {<br/>    $bug_items = $wpdb-&gt;get_results( $wpdb-&gt;prepare(  <br/>                     $bug_query, $search_term, $search_term ), <br/>                     ARRAY_A );<br/>} else {<br/>    $bug_items = $wpdb-&gt;get_results( $bug_query, ARRAY_A );<br/>}</pre>
<ol start="6">
<li>Add the following code block, before the table starts rendering, to display a simple search form:</li>
</ol>
<pre style="padding-left: 60px">$output = '';<br/><br/><strong>$output .= '&lt;div class="ch8_bt_search"&gt;';</strong><br/><strong>$output .= '&lt;form method="get" </strong><strong>id="ch8_bt_search"&gt;'; </strong><br/><strong>$output .= '&lt;div&gt;Search bugs '; </strong><br/><strong>$output .= '&lt;input type="text" </strong><strong>onfocus="this.value=\'\'" '; </strong><br/><strong>$output .= 'value="' . esc_html( $search_string ) . </strong><strong>'" '; </strong><br/><strong>$output .= 'name="searchbt" /&gt;'; </strong><br/><strong>$output .= '&lt;input type="submit" value="Search" /&gt;'; </strong><br/><strong>$output .= '&lt;/div&gt;'; </strong><br/><strong>$output .= '&lt;/form&gt;&lt;/div&gt;'; </strong><br/> <br/>$output .= '&lt;div class="bug-tracker-list"&gt;&lt;table&gt;'; </pre>
<ol start="7">
<li>Save and close the plugin file.</li>
<li>Visit the bug display page that was previously created to see the new search form. Enter a search string and click on the <span class="packt_screen">Search</span> button to see a list of results:</li>
</ol>
<div class="CDPAlignCenter CDPAlign"><img height="196" width="379" class="image-border" src="assets/56d31f5c-4553-43c5-940a-704ad8d9398b.png"/></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How it works...</h1>
                </header>
            
            <article>
                
<p>This recipe implements a simple search engine by displaying a short form and capturing a user search string using the standard HTML <kbd>GET</kbd> method. If a search string is found in the page address, we will modify the bug retrieval query that was in place by adding a <kbd>where</kbd> clause that looks for the search string anywhere in the <kbd>bug_title</kbd> or <kbd>bug_description</kbd> fields.</p>
<p>While it might seem natural to insert the search string directly in the query and execute it, we use the <kbd>wpdb</kbd> class' <kbd>prepare</kbd> method to assemble the query and validate the search string to avoid malicious intent. This method works in a very similar way to the standard PHP <kbd>sprintf</kbd> function, with placeholders to represent the places where variables should be substituted.</p>
<p>The remainder of the shortcode display function remains identical, displaying a list of varying length depending on the presence of a search string and the number of entries that match the query.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">See also</h1>
                </header>
            
            <article>
                
<ul>
<li>The <em>Displaying custom database table data in shortcodes</em> recipe</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Importing data from a user file into custom tables</h1>
                </header>
            
            <article>
                
<p>To avoid long data entry sessions, a nice addition to a system, such as the Bug Tracker that we have been putting in place in this chapter, would be to provide users with the ability to import large amounts of entries from an external file in a single operation. To accomplish this task, the <strong>Comma-Separated Values</strong> (<strong>CSV</strong>) file format is very convenient, since it can be edited by most spreadsheet editors and can be read using standard PHP function calls.</p>
<p>This recipe implements a CSV-based import function in our bug tracking system.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Getting ready</h1>
                </header>
            
            <article>
                
<p>You should have already followed the <em>Implementing a search function to retrieve custom table data</em> recipe to have an existing framework to augment. Alternatively, you can get the resulting code (<kbd>Chapter 8/ch8-bug-tracker/ch8-bug-tracker-v7.php</kbd>) from the code bundle and rename the file <kbd>ch8-bug-tracker.php</kbd>.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<ol>
<li>Navigate to the WordPress plugin directory of your development installation.</li>
<li>Navigate to the <kbd>ch8-bug-tracker</kbd> directory and edit <kbd>ch8-bug-tracker.php</kbd>.</li>
<li>Find the <kbd>ch8bt_config_page</kbd> function and add the following highlighted code block at the end of the bug listings section after the end of the existing deletion form:</li>
</ol>
<pre style="padding-left: 60px">&lt;input type="submit" value="Delete Selected"<br/>       class="button-primary"/&gt; <br/>&lt;/form&gt;<br/><br/><strong>&lt;!-- Form to upload new bugs in csv format --&gt; </strong><br/><strong>&lt;form method="post"  </strong><br/><strong>      action="&lt;?php echo admin_url( 'admin-post.php' ); ?</strong><strong>&gt;"   </strong><br/><strong>      enctype="multipart/form-data"&gt;<br/></strong><strong><br/>&lt;input type="hidden" name="action" </strong><strong>value="import_ch8bt_bug" /&gt; </strong>  <br/><strong>&lt;!-- Adding security through hidden referrer field -</strong><strong>-&gt; </strong><br/><strong>&lt;?php wp_nonce_field( 'ch8bt_import' ); ?&gt;<br/><br/></strong><strong>&lt;h3&gt;Import Bugs&lt;/h3&gt; </strong><br/><strong>&lt;div class="import_data"&gt;Import Bugs from CSV File </strong><br/><strong>    (&lt;a href="&lt;?php echo plugins_url( '</strong><strong>importtemplate.csv', <br/></strong><strong>                                      __FILE__ ); ?</strong><strong>&gt;"&gt;Template&lt;/a&gt;) </strong><br/><strong>    &lt;input name="import_bugs_file" type="file" /&gt;&lt;/div&gt; </strong><br/><strong>&lt;input type="submit" value="Import" class="button-</strong><strong>primary"/&gt; </strong><br/><strong>&lt;/form&gt;</strong> </pre>
<ol start="4">
<li>Locate the <kbd>ch8bt_admin_init</kbd> function and add the following line of code at the end of its body to register a function to process submissions of the bug import form:</li>
</ol>
<pre style="padding-left: 60px">add_action( 'admin_post_import_ch8bt_bug', 'import_ch8bt_bug' );</pre>
<ol start="5">
<li>Insert the following block of code to provide an implementation for the <kbd>import_ch8bt_bug</kbd> function:</li>
</ol>
<pre style="padding-left: 60px">function import_ch8bt_bug() { <br/>    // Check that user has proper security level <br/>    if ( !current_user_can( 'manage_options' ) ) {<br/>        wp_die( 'Not allowed' );<br/>    }<br/><br/>    // Check if nonce field is present <br/>    check_admin_referer( 'ch8bt_import' );<br/><br/>    // Check if file has been uploaded <br/>    if( array_key_exists( 'import_bugs_file', $_FILES ) ) { <br/>        // If file exists, open it in read mode <br/>        $handle =<br/>            fopen( $_FILES['import_bugs_file']['tmp_name'], 'r' );<br/><br/>        // If file is successfully open, extract a row of data <br/>        // based on comma separator, and store in $data array <br/>        if ( $handle ) { <br/>            while ( FALSE !== <br/>                    ( $data = fgetcsv( $handle, 5000, ',' ) ) ) { <br/>                $row += 1;<br/><br/>                // If row count is ok and row is not header row <br/>                // Create array and insert in database <br/>                if ( count( $data ) == 4 &amp;&amp; $row != 1 ) { <br/>                    $new_bug = array( <br/>                        'bug_title' =&gt; $data[0], <br/>                        'bug_description' =&gt; $data[1], <br/>                        'bug_version' =&gt; $data[2], <br/>                        'bug_status' =&gt; $data[3], <br/>                        'bug_report_date' =&gt; date( 'Y-m-d' ) );<br/><br/>                    global $wpdb;         <br/>                    $wpdb-&gt;insert( $wpdb-&gt;get_blog_prefix() . <br/>                                   'ch8_bug_data', $new_bug ); <br/>                } <br/>            } <br/>        } <br/>    }<br/><br/>    // Redirect the page to the user submission form <br/>    wp_redirect( add_query_arg( 'page', 'ch8bt-bug-tracker', <br/>                     admin_url( 'options-general.php' ) ) ); <br/>    exit; <br/>} </pre>
<ol start="6">
<li>Save and close the plugin file.</li>
<li>Create a new text file in the plugin directory called <kbd>importtemplate.csv</kbd> and open it in a text editor.</li>
<li>Insert the following text in the newly created file to provide an example bug to import:</li>
</ol>
<pre style="padding-left: 60px">"Title","Description","Version","Status"<br/>"Test Import Bug","This is a test import bug","1.0","0"</pre>
<ol start="9">
<li>Save and close the CSV text file.</li>
<li>Navigate to the new <span class="packt_screen">Bug</span> <span class="packt_screen">Tracker</span> item under the administration page's <span class="packt_screen">Settings</span> menu to see the new <span class="packt_screen">Import</span> <span class="packt_screen">Bugs</span> section.</li>
<li>Use the file import dialog to locate the <kbd>importtemplate.csv</kbd>.</li>
<li>Import the list of bugs in the system to see its content added to the database:</li>
</ol>
<div class="CDPAlignCenter CDPAlign"><img height="94" width="429" class="image-border" src="assets/0961800c-9225-40f3-97e6-9464a77da1ef.png"/></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How it works...</h1>
                </header>
            
            <article>
                
<p>This recipe creates a small form on the <span class="packt_screen">Bug</span> <span class="packt_screen">Tracker</span> management page that is solely responsible for uploading one or more bugs to the database. By editing the content of the <kbd>importtemplate.csv</kbd> file and selecting it in the import dialog, users can quickly populate the system by loading data straight to the custom database table that was created by the plugin when it was first installed.</p>
<p>In addition to the file upload field, the form contains the usual hidden nonce and action name fields. It also features an <kbd>enctype</kbd> property to allow files to be uploaded.</p>
<p>When the user submits a file to be uploaded, the registered callback function first checks to see whether the user who made the submission has appropriate rights and whether the nonce security fields were present as part of the post data. If both of these conditions are met, the recipe goes on to check whether a file has been correctly uploaded to the web server using the <kbd>array_key_exists</kbd> function to search through the standard PHP <kbd>$_FILES</kbd> global variable. As you can see, the text that it searches for is the name of the file upload field from the form.</p>
<p>If a file has been uploaded, the <kbd>fopen</kbd> function opens it and stores a pointer to it in a local variable. After a quick verification of the pointer's existence, the code moves to a <kbd>while</kbd> loop to process each line of the incoming file with the <kbd>fgetcsv</kbd> function. This function reads one line of the file at a time, analyzes its content to find all of the comma-separated fields that are present, and stores the resulting data in a numeric array.</p>
<p>The rest of the <kbd>import</kbd> function creates an array with the imported data and stores it in the database using the <kbd>wpdb</kbd> class' <kbd>insert</kbd> method, as we have seen in a previous recipe.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">See also</h1>
                </header>
            
            <article>
                
<ul>
<li>The <em>Inserting and updating records in custom tables</em> recipe</li>
</ul>


            </article>

            
        </section>
    </body></html>