<html><head></head><body><div class="chapter" title="Chapter&#xA0;7.&#xA0;Authentication and Security"><div class="titlepage"><div><div><h1 class="title"><a id="ch07"/>Chapter 7. Authentication and Security</h1></div></div></div><p>In this chapter, we will improve the application we built in <a class="link" href="ch03.html" title="Chapter 3. Your First Application">Chapter 3</a>, <span class="emphasis"><em>Your First Application</em></span>, by adding a simple authentication mechanism and addressing any security issues with the existing code base. In doing so, you will learn about:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Configuring and using the authentication service</li><li class="listitem" style="list-style-type: disc">Middleware and how to apply it to specific routes</li><li class="listitem" style="list-style-type: disc">Data validation and form requests</li><li class="listitem" style="list-style-type: disc">The most common security vulnerabilities in web applications</li><li class="listitem" style="list-style-type: disc">How Laravel can help you write more secure code</li></ul></div><div class="section" title="Authenticating users"><div class="titlepage"><div><div><h1 class="title"><a id="ch07lvl1sec45"/>Authenticating users</h1></div></div></div><p>Allowing users to register and <a id="id242" class="indexterm"/>sign in is an extremely common feature in web applications. Yet, PHP does not dictate how it should be done, nor does it give you any helpers to implement it. This has led to the creation of disparate, and sometimes insecure, methods of authenticating users and restricting access to specific pages. In that respect, Laravel provides you with different tools to make these features more secure and easier to integrate. It does so with the help of its authentication service and functionality that we have not covered yet—<span class="strong"><strong>middleware</strong></span>.</p><div class="section" title="Creating the user model"><div class="titlepage"><div><div><h2 class="title"><a id="ch07lvl2sec63"/>Creating the user model</h2></div></div></div><p>First of all, we need to <a id="id243" class="indexterm"/>define the model that will be used to represent the users of our application. Laravel already provides you with sensible defaults inside <code class="literal">config/auth.php</code>, where you can change the model or table that is used to store your user accounts.</p><p>It also comes with an existing <code class="literal">User</code> model inside <code class="literal">app/User.php</code>. For the purposes of this application, we are going to simplify it slightly, remove certain class variables, and add new methods so that it can interact with the <code class="literal">Cat</code> model as follows:</p><div class="informalexample"><pre class="programlisting">namespace App;

use Illuminate\Auth\Authenticatable;
use Illuminate\Database\Eloquent\Model;
use Illuminate\Auth\Passwords\CanResetPassword;
use Illuminate\Contracts\Auth\Authenticatable as uthenticableContract;
use Illumunate\Contracts\Auth\CanResetPassword as CanResetPasswordContract;
use App\Cat;

class User extends Model implements AuthenticatableContract, CanResetPasswordContract {
  use Authenticable, CanResetPassword;
  public function cats() {
    return $this-&gt;hasMany('App\Cat');
  }
<span class="strong"><strong>  public function owns(Cat $cat) {</strong></span>
<span class="strong"><strong>    return $this-&gt;id == $cat-&gt;user_id;</strong></span>
<span class="strong"><strong>  }</strong></span>
<span class="strong"><strong>  public function canEdit(Cat $cat) {</strong></span>
<span class="strong"><strong>    return $this-&gt;is_admin || $this-&gt;owns($cat);</strong></span>
<span class="strong"><strong>  }</strong></span>
}</pre></div><p>The first thing to note is that this model implements the <code class="literal">Authenticable</code> interface. Remember that an interface does not give any implementation details. It is nothing more than a <span class="strong"><strong>contract</strong></span> that specifies <a id="id244" class="indexterm"/>the names of the methods that a class should define when it implements the interface. In this case, the <code class="literal">Authenticable</code> interface mandates that the following methods be implemented:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">getAuthIdentifier</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">getAuthPassword</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">getRememberToken</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">setRememberToken</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">getRememberTokenName</code></li></ul></div><p>If you open the <code class="literal">app/User.php</code> file, you might wonder where these methods are. These methods are actually provided by the <code class="literal">Authenticable</code> trait. You can see the trait being included after the <code class="literal">User</code> class's opening brace:</p><div class="informalexample"><pre class="programlisting">use Authenticable, CanResetPassword;</pre></div><p>Traits allow the reuse of code within classes. This is to make up for a shortcoming of the PHP language, which does not allow <span class="strong"><strong>multiple inheritance</strong></span> in classes. So, as a workaround, you can compose methods that may be dropped into multiple classes that might already be extending another base class.</p><p>In our <code class="literal">User</code> model, the <code class="literal">cats()</code> method simply defines the <code class="literal">hasMany</code> relationship with the <code class="literal">Cat</code> model. The last two methods will be used to check whether a given <code class="literal">Cat</code> instance is owned or is editable by the current <code class="literal">User</code> instance.</p><p>Finally, let's create a <a id="id245" class="indexterm"/>helper method on the <code class="literal">User</code> model that will allow us to check whether we have an administrator or not. This method will be suitably named <code class="literal">isAdministrator</code> as shown here:</p><div class="informalexample"><pre class="programlisting">public function isAdministrator()
{
  return $this-&gt;getAttribute('is_admin');
}</pre></div><p>If using MySQL, this will return a string of either <code class="literal">0</code> or <code class="literal">1</code> (as MySQL doesn't have a native Boolean data type). We can, however, cast this model attribute to be a Boolean to make value checking a bit better. At the top of your model, add the following code:</p><div class="informalexample"><pre class="programlisting">protected $casts = [
  'is_admin' =&gt; 'boolean',
];</pre></div><p>In this array, we define the attribute and what data type we actually want. Then, when we retrieve an attribute from the model, it will be cast to the specified data type.</p><p>Other data types that model attributes can be cast to are as follows:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">string</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">integer</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">real</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">float</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">double</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">array</code></li></ul></div><p>The <code class="literal">array</code> type can be used for columns that contain a serialized JSON string, which will de-serialize the data and present it as a plain PHP array.</p><p>The <code class="literal">is_admin</code> attribute doesn't exist in our <code class="literal">users</code> table currently, so let's fix that.</p></div><div class="section" title="Creating the necessary database schema"><div class="titlepage"><div><div><h2 class="title"><a id="ch07lvl2sec64"/>Creating the necessary database schema</h2></div></div></div><p>As well as a <code class="literal">User</code> <a id="id246" class="indexterm"/>model, Laravel also comes pre-packaged with two migration files: one for creating the <code class="literal">users</code> table and the other to create the <code class="literal">password_resets</code> table.</p><p>By default, the user's table migration creates a table with columns for each user's ID, name, password, remember token, as well as the created at and updated at timestamps. We need to extend that table by adding a new column designating whether each user is an administrator of our application or not.</p><p>To do this, we can create another migration. Migrations can be used to alter existing tables as well as creating entirely new ones. In this instance, we're going to create a migration to add a Boolean column named <code class="literal">is_admin</code> to the <code class="literal">users</code> table.</p><p>Run the <a id="id247" class="indexterm"/>following command to create the migration file in <code class="literal">database/migrations</code>:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ php artisan make:migration add_is_admin_column_to_users</strong></span>
</pre></div><p>Then change the <code class="literal">up</code> method as follows to contain the schema change:</p><div class="informalexample"><pre class="programlisting">public function up() {
  Schema::table('users', function(Blueprint $table) {
    $table-&gt;boolean('is_admin')-&gt;default(false)
      -&gt;after('password');
  }
}
</pre></div><p>We set the default value to <code class="literal">false</code> so that we have to explicitly set it to <code class="literal">true</code> for any users we want to be administrators, rather than every new user (and any existing users in the database table) automatically being granted administrator privileges on creation.</p><p>As with any other migration, we also have to provide the <code class="literal">down</code> method to revert any changes. As we've created a column, we need to remove it if a user decides to roll back the migration:</p><div class="informalexample"><pre class="programlisting">public function down() {
  Schema::table('users', function(Blueprint $table) {
    $table-&gt;dropColumn('is_admin');
  });
}</pre></div><p>Now, we also need to update the <code class="literal">cats</code> database table to add a column associating it with a user. By following the preceding steps, we create a new schema, as follows, describing the change:</p><div class="informalexample"><pre class="programlisting">$ php artisan make:migration add_user_id_column_to_cats
</pre></div><p>We then complete the methods as follows:</p><div class="informalexample"><pre class="programlisting">public function up() {
  Schema::table('cats', function(Blueprint $table) {
    $table-&gt;integer('user_id')-&gt;unsigned();
    $table-&gt;foreign('user_id')-&gt;references('id')-&gt;on('users')
      -&gt;onDelete('cascade');
  });
}
</pre></div><p>With the preceding code, we alter the <code class="literal">cats</code> table to have a <code class="literal">user_id</code> column that stores the <code class="literal">id</code> of the <code class="literal">Cat</code> owner. After creating the column, we create a <span class="strong"><strong>foreign key constraint</strong></span> on the table so that a <a id="id248" class="indexterm"/>
<code class="literal">user_id</code> value has to match the primary key of a record in the <code class="literal">users</code> table. Foreign keys help you to enforce the consistency of data (for example, you will not be able to assign <code class="literal">Cat</code> to a nonexistent user). Cascading deletes also means that when a user is deleted, their associated cat records will be deleted too; otherwise, the database will end up containing cats that no longer have any owners!</p><p>The code to <a id="id249" class="indexterm"/>reverse this migration will simply remove the foreign key constraint and the column and then drop the <code class="literal">user_id</code> column:</p><div class="informalexample"><pre class="programlisting">public function down() {
  Schema::table('cats', function(Blueprint $table) {
    $table-&gt;dropForeign('cats_user_id_foreign');
    $table-&gt;dropColumn('user_id');
  });
}</pre></div><p>Next, we prepare a database seeder to create two users for our application, one of which will be an administrator.</p><div class="informalexample"><pre class="programlisting">Use App\User;

class UsersTableSeeder extends Seeder {
  public function run() {
    User::create([
      'username' =&gt;'admin',
      'password' =&gt; bcrypt('hunter2'),
      'is_admin' =&gt; true, 
    ]);

    User::create([
      'username' =&gt; 'scott',
      'password' =&gt; bcrypt('tiger'),
      'is_admin' =&gt; false,
    ]);
  }
}</pre></div><p>Once you have saved this code inside a new file named <code class="literal">database/seeds/UsersTableSeeder.php</code>, do not forget to call it inside the main <code class="literal">DatabaseSeeder</code> class.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note07"/>Note</h3><p>Laravel expects all passwords to be hashed with the <code class="literal">bcrypt</code> helper, which uses the <span class="strong"><strong>Bcrypt</strong></span> algorithm to <a id="id250" class="indexterm"/>create a strong hash. You should never store passwords in <span class="emphasis"><em>cleartext</em></span> or hash them with weak algorithms, such as <code class="literal">md5</code> or <code class="literal">sha1</code>.</p></div></div><p>To run the migration <a id="id251" class="indexterm"/>and seed the database at the same time, enter the following command:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ php artisan migrate --seed</strong></span>
</pre></div></div><div class="section" title="Authentication routes and views"><div class="titlepage"><div><div><h2 class="title"><a id="ch07lvl2sec65"/>Authentication routes and views</h2></div></div></div><p>We have mentioned <a id="id252" class="indexterm"/>earlier that PHP has no standard way to authenticate users, but this is not true of Laravel. Laravel realizes that the most modern <a id="id253" class="indexterm"/>web applications will require users to register and log in, so it comes with controllers, routes, and views to facilitate this from the get-go. You can find <a id="id254" class="indexterm"/>the main authentication controller at <code class="literal">app/Http/Controllers/Auth/AuthController.php</code>. If you open the file, you will see that all it contains is <a id="id255" class="indexterm"/>a constructor because like the <code class="literal">User</code> model, it uses a trait to provide functionality, in this case, <code class="literal">AuthenticatesAndRegistersUsers</code>:</p><div class="informalexample"><pre class="programlisting">namespace App\Http\Controllers\Auth;

use App\Http\Controllers\Controller;
use Illuminate\Contracts\Auth\Guard;
use Illuminate\Contracts\Auth\Registrar;
<span class="strong"><strong>use Illuminate\Foundation\Auth\AuthenticatesAndRegistersUsers;</strong></span>

class AuthController extends Controller {

  <span class="strong"><strong>use AuthenticatesAndRegistersUsers;</strong></span>

  public function __construct(Guard $auth, Registrar $registrar) {
    $this-&gt;auth = $auth;
    $this-&gt;registrar = $registrar;

    $this-&gt;middleware('guest', ['except' =&gt; 'getLogout']);
  }
}</pre></div><p>The <code class="literal">middleware</code> method will apply the guest middleware to all actions in the controller, except the <code class="literal">getLogout()</code> action. We'll look at middleware in more depth later in this chapter.</p><p>This controller (as well as the controller used for handling password resets) can be found in the application's routes file:</p><div class="informalexample"><pre class="programlisting">$router-&gt;controllers([
  'auth' =&gt; 'Auth\AuthController',
  'password' =&gt; 'Auth\PasswordController',
]);</pre></div><p>Laravel also includes two views, <code class="literal">login.blade.php</code> and <code class="literal">register.blade.php</code>, at <code class="literal">resources/views/auth</code>.</p><p>Let's look at integrating <a id="id256" class="indexterm"/>Laravel's <code class="literal">auth</code> views into our application. We will start <a id="id257" class="indexterm"/>by amending our master layout (<code class="literal">resources/views/layouts/master.blade.php</code>) to display the login link to guests and the logout link to users <a id="id258" class="indexterm"/>who are logged in. To check <a id="id259" class="indexterm"/>whether a visitor is logged in, we use the <code class="literal">Auth::check()</code> method:</p><div class="informalexample"><pre class="programlisting">&lt;div class="container"&gt;
  &lt;div class="page-header"&gt;
    &lt;div class="text-right"&gt;
      @if (Auth::check())
        Logged in as 
        &lt;strong&gt;{{ Auth::user()-&gt;username }}&lt;/strong&gt;
        {!! link_to('auth/logout', 'Log Out') !!}
      @else
        {!! link_to('auth/login', 'Log In') !!}
      @endif
    &lt;/div&gt;
  @yield('header')
  &lt;/div&gt;
  @if (Session::has('message'))
    &lt;div class="alert alert-success"&gt;
      {{ Session::get('message') }}
    &lt;/div&gt;
  @endif

  @if (Session::has('error'))
    &lt;div class="alert alert-warning"&gt;
      {{ Session::get('error') }}
    &lt;/div&gt;
  @endif
  @yield('content')
&lt;/div&gt;</pre></div><p>We can replace the login view, inside <code class="literal">resources/views/auth/login.blade.php</code>, with a simpler form:</p><div class="informalexample"><pre class="programlisting">@extends('layouts.master')
@section('header')&lt;h2&gt;Log In&lt;/h2&gt;@stop
@section('main')
  {!! Form::open(['url' =&gt; 'auth/login') !!}
  &lt;div class="form-group"&gt;
    {!! Form::label('username', 'Username', ['class' =&gt; 
      'control-label') !!}
    &lt;div class="form-controls"&gt;
      {!! Form::text('username', null, ['class' =&gt; 
        'form-control']) !!}
    &lt;/div&gt;
  &lt;/div&gt;
  &lt;div class="form-group"&gt;
    {!! Form::label('Password') !!}
    &lt;div class="form-controls"&gt;
      {!! Form::password('password', ['class' =&gt; 
      'form-control']) !!}
    &lt;/div&gt;
  &lt;/div&gt;
  {!! Form::submit('Log in', ['class' =&gt; 'btn btn-primary') !!}
  {!! Form::close() !!}
@stop
</pre></div><p>We use the Blade syntax to <a id="id260" class="indexterm"/>get the raw value (<code class="literal">{!! $value !!}</code>) from the HTML and <a id="id261" class="indexterm"/>Form helpers because they return HTML mark-up, and if <a id="id262" class="indexterm"/>we were to use the default <a id="id263" class="indexterm"/>syntax (<code class="literal">{{ $value }}</code>) to render these, we'd instead get the HTML string printed to the screen.</p></div><div class="section" title="Middleware"><div class="titlepage"><div><div><h2 class="title"><a id="ch07lvl2sec66"/>Middleware</h2></div></div></div><p>If you refer back to the <code class="literal">AuthController</code>, you will notice the following line in the constructor method:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$this-&gt;middleware('auth', ['except' =&gt; 'getLogout']);</strong></span>
</pre></div><p>Middleware includes <a id="id264" class="indexterm"/>classes that can be attached to requests coming <a id="id265" class="indexterm"/>into your application, and used to alter the results of those requests. Middleware are a replacement for <span class="strong"><strong>route filters</strong></span> that were found in Laravel 4.</p><p>Middleware can be registered either when defining routes, or in controllers as mentioned earlier. The preceding example attaches the <code class="literal">auth</code> middleware to all requests that will be handled by the <code class="literal">AuthController</code>, except for requests to the <code class="literal">getLogout</code> method.</p><p>Middleware classes can be found in the <code class="literal">app/Http/Middleware</code> directory. In here, you can find the default <code class="literal">Authentication</code> middleware class, as well as two others: <code class="literal">RedirectIfAuthenticated</code>, and <code class="literal">VerifyCsrfToken</code>. We can inspect the <code class="literal">Authentication</code> class to see how a middleware class works:</p><div class="informalexample"><pre class="programlisting">public function __construct(Guard $auth) {
  $this-&gt;auth = $auth;
}

public function handle($request, Closure $next) {
  if ($this-&gt;auth-&gt;guest()) {
    if ($request-&gt;ajax()) {
      return response('Unauthorized', 401);
    } else {
      return redirect()-&gt;guest('auth/login');
    }
  }
  return $next($request);
}</pre></div><p>There are two methods: the <code class="literal">constructor</code> and the <code class="literal">handle</code> methods. In the preceding example, the class is checking whether the current user is authenticated (using the <code class="literal">guest()</code> method on the <code class="literal">Guard</code> class) and if they are a guest, returning a response if the request was made via AJAX, or redirecting the user to the login form. Because the response is returned <a id="id266" class="indexterm"/>then and there, the request will not be processed any <a id="id267" class="indexterm"/>further.</p><p>We can use this approach to not only check if users have authenticated, but also to check whether they are administrators. We can use the in-built Artisan generator to create a new middleware class as follows:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ php artisan make:middleware IsAdministrator</strong></span>
</pre></div><p>This will create a new file at <code class="literal">app/Http/Middleware/IsAdministrator.php</code>. Like the <code class="literal">Authentication</code> class, we need the <code class="literal">Guard</code> implementation, so add a constructor that type-hints the dependency so that the service container automatically injects it:</p><div class="informalexample"><pre class="programlisting">public function __construct(Guard $auth) {$this-&gt;auth = $auth;}</pre></div><p>We'll also need to import the full namespace at the top of the file as follows:</p><div class="informalexample"><pre class="programlisting">use Illuminate\Contracts\Auth\Guard;</pre></div><p>Now we have a <code class="literal">Guard</code> instance and we assign it to a class property; we can now flesh out the <code class="literal">handle</code> method as follows:</p><div class="informalexample"><pre class="programlisting">public function handle($request, \Closure $next) {
  if ( ! $this-&gt;auth-&gt;user()-&gt;isAdministrator()) {
    if ($this-&gt;request-&gt;ajax()) {
      return response('Forbidden.', 403);
    } else {
      throw new AccessDeniedHttpException;
    }
  }
}</pre></div><p>This time, we get the current user from the <code class="literal">Guard</code> (which will yield a <code class="literal">User</code> Eloquent model instance). We can then call any methods on this model. In the preceding example, we call our <code class="literal">isAdministrator()</code> method, which will return a Boolean value as to whether the user should be treated as an administrator or not. If not—like the <code class="literal">Authenticated</code> class—we return a simple string response (and the appropriate HTTP status code) if the request was made via AJAX; otherwise, we throw an <code class="literal">AccessDeniedHttpException</code>. This exception is actually part of the Symfony <code class="literal">HttpKernel</code> library, so we need to import the class's full namespace at the top of the file:</p><div class="informalexample"><pre class="programlisting">use Symfony\Component\HttpKernel\Exception\AccessDeniedHttpException;</pre></div><p>The final step in creating a middleware is to tell the HTTP <code class="literal">Kernel</code> class about it. You can find this file at <code class="literal">app/Http/Kernel.php</code>. By opening the file, you will see two properties defined: <code class="literal">$middleware</code> and <code class="literal">$routeMiddleware</code>. Adding the class's full namespace to the <code class="literal">$middleware</code> array would add the middleware to every request. We don't want to do <a id="id268" class="indexterm"/>this because if we did, no one would be able to access the <a id="id269" class="indexterm"/>login page as they'd be unauthenticated at this point! Instead, we want to add an entry to the <code class="literal">$routeMiddleware</code> array as follows:</p><div class="informalexample"><pre class="programlisting">protected $routeMiddleware = [
  'auth' =&gt; 'App\Core\Http\Middleware\Authenticate',
  'auth.basic' =&gt; Illuminate\Auth\Middleware\AuthenticateWithBasicAuth',
  'guest' =&gt; 'App\Core\Http\Middleware\RedirectIfAuthenticated',
  'admin' =&gt; 'App\Http\Middleware\IsAdministrator',
];</pre></div><p>The key in the array is what we can then use on routes and in controllers, and the corresponding class will be applied when requesting the specified resource.</p><p>The following is an example applying it to a route:</p><div class="informalexample"><pre class="programlisting">Route::get('admin/dashboard', [
  'middleware' =&gt; ['auth', 'admin'],
  'uses' =&gt; '\Admin\DashboardController@index',
]);</pre></div><p>As you can see, you can specify multiple middleware classes to apply to a single request. In the previous route example, first the <code class="literal">Authenticated</code> middleware class will be called; if all is good (and the user wasn't redirected to the login page), it will then be passed to the <code class="literal">IsAdministrator</code> <a id="id270" class="indexterm"/>middleware class, which will check whether the currently logged in user is an administrator.</p></div><div class="section" title="Validating user input"><div class="titlepage"><div><div><h2 class="title"><a id="ch07lvl2sec67"/>Validating user input</h2></div></div></div><p>Our application still <a id="id271" class="indexterm"/>has a major flaw—it does not perform any validation on the data submitted by users. While you might end up with a series of conditions with regular expressions here and there if you were to do this in plain PHP, Laravel offers a far more straightforward and robust way to achieve this.</p><p>Validation is performed by passing an array with the input data and an array with the validation rules to the <code class="literal">Validator::make($data, $rules)</code> method. In the case of our application, here are the rules we could write:</p><div class="informalexample"><pre class="programlisting">$rules = [
  'name' =&gt; 'required|min:3', // Required, &gt; 3 characters
  'date_of_birth' =&gt; ['required, 'date'] // Must be a date
];</pre></div><p>Multiple validation rules can be separated by either pipes or passed as an array (examples of both are shown in the preceding code). Laravel provides over 30 different validation rules, and they are all documented in here:</p><p>
<a class="ulink" href="http://laravel.com/docs/validation#available-validation-rules">http://laravel.com/docs/validation#available-validation-rules</a>
</p><p>Here is how we will <a id="id272" class="indexterm"/>check these rules with the data submitted in the form:</p><div class="informalexample"><pre class="programlisting">$validator = Validator::make($rules, Input::all());</pre></div><p>You can then make your application act based on the output of <code class="literal">$validator-&gt;fails()</code>. If this method call returns <code class="literal">true</code>, you will retrieve an object containing all error messages with <code class="literal">$validator-&gt;messages()</code>. If you were validating data in a controller action, you could attach this object to a redirection that sends the user back to the form:</p><div class="informalexample"><pre class="programlisting">return redirect()
  -&gt;back()
  -&gt;with('errors, $validatior-&gt;messages());</pre></div><p>Since each field can have zero or more validation errors, you will use a condition and a loop with the following methods to display those messages:</p><div class="informalexample"><pre class="programlisting">if ($errors-&gt;has('name')) {
<span class="strong"><strong>  foreach ($errors-&gt;get('name') as $error) {</strong></span>
<span class="strong"><strong>    echo $error;</strong></span>
  }
}</pre></div><p>You might also use a tool such as Ardent, which extends Eloquent and lets you to write validation rules directly inside <a id="id273" class="indexterm"/>the model. You can download <a id="id274" class="indexterm"/>Ardent from the following link:</p><p>
<a class="ulink" href="https://github.com/laravelbook/ardent">https://github.com/laravelbook/ardent</a>
</p><div class="section" title="Form requests"><div class="titlepage"><div><div><h3 class="title"><a id="ch07lvl3sec07"/>Form requests</h3></div></div></div><p>In Laravel 4, you <a id="id275" class="indexterm"/>were free to place validation anywhere you wanted. This led to developers implementing validation in a myriad of ways, including in the controller or as a validation service. In version 5, Laravel introduced a way of standardizing how validation was performed on submitted data, via <span class="strong"><strong>form requests</strong></span>.</p><p>Form requests are classes that <a id="id276" class="indexterm"/>wrap the standard <code class="literal">Request</code> class in Laravel, but implements a trait named <code class="literal">ValidatesWhenResolved</code>. This trait contains a <code class="literal">Validator</code> instance, and uses rules you define in your form request class to validate the data in the request. If the validator passes, then the controller action it was applied to will be executed as normal. If the validator fails, then the user is redirected to the previous URL with the errors in the session. This means you don't need to define validation routines in your controller actions, and you can even re-use them across controller actions where the same data can be submitted but in different scenarios.</p><p>Let's create a form request for saving a cat's details. Again, Artisan comes with a generator to create a new form request class for us:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ php artisan make:request SaveCatRequest</strong></span>
</pre></div><p>This will create the file at <code class="literal">app/Http/Requests/SaveCatRequest.php</code>. Inside the file, you will find two methods: <code class="literal">authorize</code> and <code class="literal">rules</code>.</p><p>Before validation is performed, the form request authorizes the current request. The implementation detail is up to you. You might want the current user to be logged in, or to be an administrator. You can define that logic in this method. By default, it simply returns <code class="literal">false</code>. This isn't ideal as it means <span class="emphasis"><em>no one</em></span> would be able to perform this request. Since we're handling user authentication via middleware, we can simply switch this to return <code class="literal">true</code> instead.</p><p>The second method, <code class="literal">rules</code>, is where we supply the array of validation rules to be fed to the <code class="literal">Validator</code> instance. Taking the preceding <code class="literal">Validator</code> example, this can be changed to the following code:</p><div class="informalexample"><pre class="programlisting">public function rules() {
  return [
    'name' =&gt; 'required|min:3',
    'date_of_birth' =&gt; 'required|date',
  ];
}</pre></div><p>The reason rules are defined in a method and not simply as a class property is to allow for conditional validation. There may be times when you only want to validate a certain field, for example, if a value is provided in another field. Imagine a checkout form in an e-commerce website that asks a user for a billing address and an optional shipping address if it's different from the billing address. Most online stores will have a checkbox that when checked, will <a id="id277" class="indexterm"/>display the fields to enter the shipping address. If <a id="id278" class="indexterm"/>we were to create the validation for this scenario, then it may look something like the following code:</p><div class="informalexample"><pre class="programlisting">public function rules() {
  $rules = [
    'billing_address' =&gt; 'required',
  ];
  if ($request-&gt;has('shipping_address_different') {
    $rules['shipping_address'] = 'required';
  }
  return $rules;
}</pre></div><p>The preceding example checks whether a field with <code class="literal">shipping_address_different</code> (the checkbox) is present and, if so, appends a validation rule to specify that <code class="literal">shipping_address</code> is required. As you can see, this makes validation in form requests very powerful.</p><p>Form request classes are instantiated by specifying them as a parameter to the controller action you want them to apply. In our case of saving cats, this will apply to both the <code class="literal">create</code> and <code class="literal">update</code> methods in our <code class="literal">CatsController</code> class:</p><div class="informalexample"><pre class="programlisting">public function create(SaveCatRequest $request) {
  // method body
}

public function update(SaveCatRequest $request) {
  // method body
}</pre></div><p>Now, whenever either of these actions is requested, the <code class="literal">SaveCatRequest</code> class will first be called and checked to see whether the data is valid. This means our controller methods can stay lean, and only deal with the actual persisting of the new data to the database.</p></div></div></div></div>
<div class="section" title="Securing your application"><div class="titlepage"><div><div><h1 class="title"><a id="ch07lvl1sec46"/>Securing your application</h1></div></div></div><p>Before you deploy your <a id="id279" class="indexterm"/>application in a hostile environment, full of merciless bots and malicious users, there are a number of security considerations that you must keep in mind. In this section, we are going to cover several common attack vectors for web applications and learn about how Laravel protects your application against them. Since a framework cannot protect you against everything, we will also look at the common pitfalls to avoid.</p><div class="section" title="Cross-site request forgery"><div class="titlepage"><div><div><h2 class="title"><a id="ch07lvl2sec68"/>Cross-site request forgery</h2></div></div></div><p>
<span class="strong"><strong>Cross-site request forgery</strong></span> (<span class="strong"><strong>CSRF</strong></span>) attacks are conducted by targeting a URL that has side effects (that is, it is performing an action and not just displaying information). We have already partly <a id="id280" class="indexterm"/>mitigated CSRF attacks by avoiding the use of <code class="literal">GET</code> for routes that have permanent effects such as <code class="literal">DELETE/cats/1</code>, since it is not reachable from a simple link or embeddable in an <code class="literal">&lt;iframe&gt;</code> element. However, if an attacker is able to send his victim to a page that he <a id="id281" class="indexterm"/>controls, he can easily make the victim submit a form to the target domain. If the victim is already logged in on the target domain, the application would have no way of verifying the authenticity of the request.</p><p>The most efficient countermeasure is to issue a token whenever a form is displayed and then check that token when the form is submitted. <code class="literal">Form::open</code> and <code class="literal">Form::model</code> both automatically insert a hidden <code class="literal">_token</code> input element, and middleware is applied to check the supplied token on incoming requests to see whether it matches the expected value.</p></div><div class="section" title="Escaping content to prevent cross-site scripting (XSS)"><div class="titlepage"><div><div><h2 class="title"><a id="ch07lvl2sec69"/>Escaping content to prevent cross-site scripting (XSS)</h2></div></div></div><p>
<span class="strong"><strong>Cross-site scripting</strong></span> (<span class="strong"><strong>XSS</strong></span>) attacks happen when attackers are able to place client-side JavaScript code in a <a id="id282" class="indexterm"/>page viewed by other users. In our <a id="id283" class="indexterm"/>application, assuming that the name of our cat is not escaped, if we enter the following snippet of code as the value for the name, every visitor will be greeted with an alert message everywhere the name of our cat is displayed:</p><div class="informalexample"><pre class="programlisting">Evil Cat &lt;script&gt;alert('Meow!')&lt;/script&gt;</pre></div><p>While this is a rather harmless script, it would be very easy to insert a longer script or link to an external script that steals the session or cookie values. To avoid this kind of attack, you should never trust any user-submitted data or escape any dangerous characters. You should favor the double-brace syntax (<code class="literal">{{ $value }}</code>) in your Blade templates, and only use the <code class="literal">{!! $value !!}</code> syntax, where you're certain the data is safe to display in its raw format.</p></div><div class="section" title="Avoiding SQL injection"><div class="titlepage"><div><div><h2 class="title"><a id="ch07lvl2sec70"/>Avoiding SQL injection</h2></div></div></div><p>An <span class="strong"><strong>SQL injection</strong></span> <a id="id284" class="indexterm"/>vulnerability exists when an application <a id="id285" class="indexterm"/>inserts arbitrary and unfiltered user input in an SQL query. This user input can come from cookies, server variables, or, most frequently, through <code class="literal">GET</code> or <code class="literal">POST</code> input values. These attacks are conducted to access or modify data that is not normally available and sometimes to disturb the normal functioning of the application.</p><p>By default, Laravel will protect you against this type of attack since both the query builder and Eloquent use <span class="strong"><strong>PHP Data Objects</strong></span> (<span class="strong"><strong>PDO</strong></span>) class behind the scenes. PDO uses <span class="strong"><strong>prepared statements</strong></span>, which allows you to safely pass any parameters without having to escape and sanitize them.</p><p>In some cases, you might <a id="id286" class="indexterm"/>want to write more complex or database-specific queries in SQL. This is possible using the <code class="literal">DB::raw</code> method. When using this method, you must be very careful not to create any vulnerable queries like the following one:</p><div class="informalexample"><pre class="programlisting">Route::get('sql-injection-vulnerable', function() {
  $name = "'Bobby' OR 1=1";
  return DB::select( 
    DB::raw("SELECT * FROM cats WHERE name = $name"));
});</pre></div><p>To protect this query from SQL injection, you need to rewrite it by replacing the parameters with question marks in the query and then pass the values in an array as a second argument to the <code class="literal">raw</code> method:</p><div class="informalexample"><pre class="programlisting">Route::get('sql-injection-not-vulnerable', function() {
  $name = "'Bobby' OR 1=1";
  return DB::select(
    DB::raw("SELECT * FROM cats WHERE name = ?", [$name]));
});</pre></div><p>The preceding query is known as a <span class="strong"><strong>prepared statement</strong></span>, as we define the query and what parameters are expected, and any harmful parameters that would alter the query or data in the database in an unintended way are sanitized.</p></div><div class="section" title="Using mass assignment with care"><div class="titlepage"><div><div><h2 class="title"><a id="ch07lvl2sec71"/>Using mass assignment with care</h2></div></div></div><p>In <a id="id287" class="indexterm"/>
<a class="link" href="ch03.html" title="Chapter 3. Your First Application">Chapter 3</a>, <span class="emphasis"><em>Your First Application</em></span>, we used mass assignment, a convenient feature that <a id="id288" class="indexterm"/>allows us to create a model based on the form input without having to assign each value individually.</p><p>This feature should, however, be used carefully. A malicious user could alter the form on the client side and add a new input to it:</p><div class="informalexample"><pre class="programlisting">&lt;input name="is_admin" value="1" /&gt;</pre></div><p>Then, when the form is submitted, we attempt to create a new model using the following code:</p><div class="informalexample"><pre class="programlisting">Cat::create(Request::all())</pre></div><p>Thanks to the <code class="literal">$fillable</code> array, which defines a white list of fields that can be filled through mass assignment, this method call will throw a mass assignment exception.</p><p>It is also possible to do the opposite and define a blacklist with the <code class="literal">$guarded</code> property. However, this option <a id="id289" class="indexterm"/>can be potentially dangerous since you might forget to <a id="id290" class="indexterm"/>update it when adding new fields to the model.</p></div><div class="section" title="Cookies – secure by default"><div class="titlepage"><div><div><h2 class="title"><a id="ch07lvl2sec72"/>Cookies – secure by default</h2></div></div></div><p>Laravel makes it very easy to create, read, and expire cookies with its <code class="literal">Cookie</code> class.</p><p>You will also be pleased to <a id="id291" class="indexterm"/>know that all cookies are automatically signed and encrypted. This means that if they are tampered with, Laravel will automatically discard them. This also means that you will not be able to read them from the client side using JavaScript.</p></div><div class="section" title="Forcing HTTPS when exchanging sensitive data"><div class="titlepage"><div><div><h2 class="title"><a id="ch07lvl2sec73"/>Forcing HTTPS when exchanging sensitive data</h2></div></div></div><p>If you are serving <a id="id292" class="indexterm"/>your application over HTTP, you need to bear in mind that every bit of information that is exchanged, including <a id="id293" class="indexterm"/>passwords, is sent in <span class="emphasis"><em>cleartext</em></span>. An attacker on the same network could therefore intercept private information, such as session variables, and log in as the victim. The only way we can prevent this is to use HTTPS. If you already have an SSL certificate installed on your web server, Laravel comes with a number of helpers to switch between <code class="literal">http://</code> and <code class="literal">https://</code> and restrict access to certain routes. You can, for instance, define an <code class="literal">https</code> filter that will redirect the visitor to the secure route as shown in the following code snippet:</p><div class="informalexample"><pre class="programlisting">Route::filter('https', function() { 
  if ( ! Request::secure()) 
    return Redirect::secure(URI::current()); 
});</pre></div></div></div>
<div class="section" title="Summary"><div class="titlepage"><div><div><h1 class="title"><a id="ch07lvl1sec47"/>Summary</h1></div></div></div><p>In this chapter, we learned how to make use of many of Laravel's tools to add authentication features to a website, validate data, and avoid common security problems. You should now have all the necessary information to create a Laravel application, test them, and secure them.</p><p>In the <a class="link" href="apa.html" title="Appendix A. An Arsenal of Tools">Appendix</a>, <span class="emphasis"><em>An Arsenal of Tools</em></span>, you will be presented with a handy reference for many of the other helpful features that Laravel offers out of the box.</p></div></body></html>