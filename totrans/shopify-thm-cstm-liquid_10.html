<html><head></head><body><div id="sbo-rt-content"><div id="_idContainer108">
			<h1 id="_idParaDest-131"><em class="italic"><a id="_idTextAnchor131"/></em><a href="B17606_07_Final_PD_ePub.xhtml#_idTextAnchor131"><em class="italic">Chapter 7</em></a>: Working with Static and Dynamic Sections</h1>
			<p>In the previous chapter, we familiarized ourselves with the different types of inputs, whether they're basic or specialized, and how we can use them to create global settings that we can easily configure through the theme editor.</p>
			<p>In this chapter, we will not only get to use the previously mentioned inputs, but we will also learn how to create easily configurable and reusable sections that we can use to change the page or even templates' layouts easily.</p>
			<p>We will learn about the following topics in this chapter:</p>
			<ul>
				<li>Static versus dynamic sections</li>
				<li>Working with the section schema</li>
				<li>Building with blocks</li>
				<li>Enhancing pages with JSON templates</li>
				<li>Exploring section-specific tags</li>
			</ul>
			<p>By the time we complete this chapter, we will understand what sections are, when to use them, and how to create one. We will also learn about the difference between static and dynamic sections, and how we can configure them through the theme editor.</p>
			<p>By learning about the section schema and the different attributes that we can use, we will also learn how to create reusable block modules within a section that we can use to repeat and receive different results. After familiarizing ourselves with sections and blocks, we will learn how to improve these concepts by learning about JSON templates and built-in metafields. Lastly, we will learn about the different types of specialized tags that we can use within section files, which will help us create reusable and dynamic modules.</p>
			<h1 id="_idParaDest-132"><a id="_idTextAnchor132"/>Technical requirements</h1>
			<p>While we will explain each topic and have it presented with the accompanying graphics, we will need an internet connection to follow the steps outlined in this chapter, considering that Shopify is a hosted service.</p>
			<p>The code for this chapter is available on GitHub: <a href="https://github.com/PacktPublishing/Shopify-Theme-Customization-with-Liquid/tree/main/Chapter07">https://github.com/PacktPublishing/Shopify-Theme-Customization-with-Liquid/tree/main/Chapter07</a>.</p>
			<p>The Code in Action video for the chapter can be found here: <a href="https://bit.ly/3hQzhVg">https://bit.ly/3hQzhVg</a></p>
			<h1 id="_idParaDest-133"><a id="_idTextAnchor133"/>Static versus dynamic sections</h1>
			<p>In <a href="B17606_01_Final_PD_ePub.xhtml#_idTextAnchor015"><em class="italic">Chapter 1</em></a>, <em class="italic">Getting Started with Shopify</em>, while discussing the theme structure, we briefly mentioned section files, <em class="italic">but what exactly are sections?</em></p>
			<p>Besides being the name of one of the directories in the theme file, a <strong class="bold">section</strong> is a type of file that allows<a id="_idIndexMarker552"/> us to create reusable modules that we can customize using the theme editor, as we learned previously. However, as opposed to the global settings that we have learned about, the major difference is that the JSON settings for sections are defined inside each section file and are section-specific.</p>
			<p>Section-specific settings allow us to reuse<a id="_idIndexMarker553"/> the same section module multiple times on the page and select a different set of options for each occurrence, making it a pretty powerful feature. For example, we can create a featured collections section and repeat it three times to display three products from three separate collections.</p>
			<p>Before we proceed, let's navigate to the theme editor by clicking the <strong class="bold">Customize</strong> button from the code editor and see the section files in action. Clicking the <strong class="bold">Customize</strong> button will automatically open the theme editor and position us on the home page, with the page preview on the right-hand side and a sidebar on the left. Within the sidebar, we can see several sections that are available on this specific page:</p>
			<div>
				<div id="_idContainer094" class="IMG---Figure">
					<img src="Images/Figure_7.01_B17606.jpg" alt="Figure 7.1 – Example of page sections within the theme editor&#13;&#10;" width="280" height="527"/>
				</div>
			</div>
			<p class="figure-caption">Figure 7.1 – Example of page sections within the theme editor</p>
			<p>At first glance, we can see that the <strong class="bold">Header</strong> and <strong class="bold">Footer</strong> sections are separated from the rest of the sections by a thin border. This tells us that the <strong class="bold">Header</strong> and <strong class="bold">Footer</strong> sections are static sections whose positions we cannot change from within the theme editor.</p>
			<p>Similarly, as with snippet files, <strong class="bold">static sections</strong> are sections that we can<a id="_idIndexMarker554"/> manually insert within the theme files, which we can do using the <strong class="source-inline">section</strong> theme tag:</p>
			<p class="source-code">{% section "name-of-the-file" %}</p>
			<p>By including the <strong class="source-inline">section</strong> tag, we will<a id="_idIndexMarker555"/> automatically render the content of the section to the position where we have included the tag and be able to customize it further using its JSON settings. Note that since this is a static section that we have manually included within the theme files, any settings that we apply to this specific section through the theme editor will be visible across all the pages where we have included this section.</p>
			<p>For example, the theme developers have included the header and footer section files inside the <strong class="source-inline">theme.liquid</strong> layout file, which is our theme master file, meaning that the header and footer sections will be visible on any page on our store. On the other hand, if we were to navigate to a different page within our theme editor, we would see a header, a footer, and an entirely different set of sections between those two than those we previously saw on the home page.</p>
			<p>By including the header<a id="_idIndexMarker556"/> and footer sections inside the <strong class="source-inline">theme.liquid</strong> file, we have made them visible across the entire theme on any page. However, we will not include all the sections within the <strong class="source-inline">theme.liquid</strong> file as they are not needed. Instead, we will include certain template-specific sections inside their respective template files so that they can only be accessed when visiting pages with the specific template assigned.</p>
			<p>Let's say that we wanted<a id="_idIndexMarker557"/> to include the related products section on the product pages. Here, we would navigate to the <strong class="source-inline">product.liquid</strong> template and include the <strong class="source-inline">section</strong> tag at any position, which would make the related products section visible on any product that uses this particular template.</p>
			<p>As we recall from <a href="B17606_04_Final_PD_ePub.xhtml#_idTextAnchor079"><em class="italic">Chapter 4</em></a>, <em class="italic">Diving into Liquid Core with Objects</em>, in <em class="italic">The Please apply P-Italics here content_for_layout object</em> section, we mentioned that the <strong class="source-inline">content_for_layout</strong> object allows us to connect the other templates to the <strong class="source-inline">theme.liquid</strong> file by loading the dynamically generated content, including the section files from other templates, into the <strong class="source-inline">theme.liquid</strong> file.</p>
			<p>Since <strong class="source-inline">content_for_layout</strong> outputs the content of all other templates, by placing it between the header and footer sections, we have ensured that we will position all the section files from other template files in between the header and footer sections. Let's look at the <strong class="source-inline">theme.liquid</strong> layout file; we will notice that we positioned <strong class="source-inline">content_for_layout</strong> between the <strong class="source-inline">header</strong> and <strong class="source-inline">footer</strong> sections, as depicted in the following block of code:</p>
			<p class="source-code">{% section 'header' %}</p>
			<p class="source-code">  &lt;div class="page-container drawer-page-content" </p>
			<p class="source-code">    id="PageContainer"&gt;</p>
			<p class="source-code">    &lt;main class="main-content js-focus-hidden"         id="MainContent" role="main" tabindex="-1"&gt;</p>
			<p class="source-code">      <strong class="bold">{{ content_for_layout }}</strong></p>
			<p class="source-code">    &lt;/main&gt;</p>
			<p class="source-code">    {% section 'footer' %}</p>
			<p>Note that including the same<a id="_idIndexMarker558"/> section file across multiple templates will result in the same content being visible across all templates. By configuring the static section from the theme editor, we can save the selected data inside the <strong class="source-inline">settings_data.json</strong> file, which will return the exact data for any occurrence of the same section.</p>
			<p>If we need to repeat the static section multiple times with different content, we would need to create a new section file using a different name:</p>
			<p class="source-code">{% section "related-product-1" %}</p>
			<p class="source-code">{% section "related-product-2" %}</p>
			<p>So far, we have seen what static sections are and how to use them to create a template-based configurable layout. But we also have access to dynamic sections, which we do not have to include every time we want to reposition a section manually.</p>
			<p>As the name suggests, <strong class="bold">dynamic sections</strong> are a set of sections<a id="_idIndexMarker559"/> that we can add, remove, reposition, or repeat<a id="_idIndexMarker560"/> any number of times with different content, without touching a single line of code, all from the theme editor. Let's return to the home page within the theme editor and look at some of the existing dynamic sections:</p>
			<div>
				<div id="_idContainer095" class="IMG---Figure">
					<img src="Images/Figure_7.02_B17606.jpg" alt="Figure 7.2 – Example of page sections within the theme editor&#13;&#10;" width="504" height="167"/>
				</div>
			</div>
			<p class="figure-caption">Figure 7.2 – Example of page sections within the theme editor</p>
			<p>We can easily distinguish the static section from the dynamic section by simply hovering over the section itself. We will notice two icons to the right of the dynamic section's name – an <em class="italic">eye</em> icon and <em class="italic">six dots</em> – by hovering over it. The eye icon will allow us to toggle the section's visibility on and off. By clicking and holding onto the six dots icon, we can reposition the section by moving it above or below the other sections. </p>
			<p>Additionally, at the bottom of the dynamic sections, we will notice an <strong class="bold">Add section</strong> button, which, once clicked, will show a dropdown that we can use to include any number of sections that exist in our store by simply clicking on them. Any section that's added to the theme via the <strong class="bold">Add section</strong> button will allow us to include different content for any occurrence, and we can repeat this as many times as we want.</p>
			<p>Until recently, the home page was the only place where we could use dynamic sections. For all other templates, we had to rely on using static sections. However, since the Shopify Unite 2021 event, Shopify has introduced JSON type templates, which we briefly mentioned in <a href="B17606_01_Final_PD_ePub.xhtml#_idTextAnchor015"><em class="italic">Chapter 1</em></a>, <em class="italic">Getting Started with Shopify</em>. JSON templates, which we will learn more about later in this chapter, add dynamic sections to any page and bring the store's entire functionality to a whole new level.</p>
			<p>Now that we have learned<a id="_idIndexMarker561"/> about what sections are and how we can<a id="_idIndexMarker562"/> use them, it is time to learn how to create them. </p>
			<h1 id="_idParaDest-134"><a id="_idTextAnchor134"/>Working with the section schema</h1>
			<p>In the previous chapter, we learned<a id="_idIndexMarker563"/> how to use JSON to create global settings, which has a similar format to the JSON for section files. However, sectional JSON comes with a few distinct differences.</p>
			<p>The first major difference is that we need to define JSON inside the section file instead of the <strong class="source-inline">settings_schema.json</strong> file. To do this, we will need to introduce the <strong class="source-inline">schema</strong> tag:</p>
			<p class="source-code">{% schema %}{% endschema %}</p>
			<p>The <strong class="source-inline">schema</strong> tag is a Liquid tag that does not have any output on its own. It simply allows us to write JSON code inside the section files. Note that each section file can only contain a single <strong class="source-inline">schema</strong> tag, which must stand on its own. It cannot be nested inside any kind of other Liquid tags.</p>
			<p>Once we have the <strong class="source-inline">schema</strong> tag in place, we are ready to familiarize ourselves with the types of attributes that we can use within the <strong class="source-inline">schema</strong> tags. </p>
			<h2 id="_idParaDest-135"><a id="_idTextAnchor135"/>The name attribute</h2>
			<p>As its name suggests, the <strong class="source-inline">name</strong> attribute allows<a id="_idIndexMarker564"/> us to set the section name, which we will<a id="_idIndexMarker565"/> use to identify the section inside the theme editor later:</p>
			<p class="source-code">{% schema %}</p>
			<p class="source-code">{</p>
			<p class="source-code">  <strong class="bold">"name": "Announcement bar"</strong></p>
			<p class="source-code">}</p>
			<p class="source-code">{% endschema %}</p>
			<p>With that, we have learned how to define the name of the section file, <em class="italic">but what if we wanted to create an international store where we can easily translate not only the store content, but also the store setting labels, inside the theme editor?</em></p>
			<p>We can easily translate most of the attributes inside the <strong class="source-inline">schema</strong> tag by including the translation keys in the <strong class="source-inline">name</strong> attribute value:</p>
			<p class="source-code">{% schema %}</p>
			<p class="source-code">{</p>
			<p class="source-code">  "name": <strong class="bold">{</strong></p>
			<p class="source-code">    <strong class="bold">"cs": "Panel oznámení",</strong></p>
			<p class="source-code">    <strong class="bold">"da": "Meddelelseslinje",</strong></p>
			<p class="source-code">    <strong class="bold">"de": "Ankündigungsbereich",</strong></p>
			<p class="source-code">    <strong class="bold">"en": "Announcement bar"</strong></p>
			<p class="source-code">  <strong class="bold">}</strong></p>
			<p class="source-code">}</p>
			<p class="source-code">{% endschema %}</p>
			<p>The first value represents the name of the file inside the <strong class="source-inline">Locales</strong> directory, whereas the second one represents the translated value. By introducing the translating keys, we have ensured that as soon as we change our store language, the <strong class="source-inline">name</strong> value will automatically adjust and present the value of the currently selected language file.  </p>
			<p>Note that we can include the translation keys for different kinds of attributes, including some of the input settings that we learned about in the previous chapter. The attributes that we can use the translation keys with include <strong class="source-inline">name</strong>, <strong class="source-inline">info</strong>, <strong class="source-inline">label</strong>, <strong class="source-inline">group</strong>, <strong class="source-inline">placeholder</strong>, <strong class="source-inline">unit</strong>, <strong class="source-inline">content</strong>, and <strong class="source-inline">category</strong>.</p>
			<p>Note that <strong class="source-inline">name</strong> is a mandatory<a id="_idIndexMarker566"/> attribute. However, the <strong class="source-inline">name</strong> attribute<a id="_idIndexMarker567"/> does not have to be unique compared to the other sections, so we should pay attention when creating new sections to avoid confusion.</p>
			<h2 id="_idParaDest-136"><a id="_idTextAnchor136"/>The class attribute</h2>
			<p><strong class="source-inline">class</strong> is a simple attribute that<a id="_idIndexMarker568"/> allows us to add additional classes to the <strong class="source-inline">div</strong> element, which<a id="_idIndexMarker569"/> wraps around the section content:</p>
			<p class="source-code">{% schema %}</p>
			<p class="source-code">{</p>
			<p class="source-code">  "name": {</p>
			<p class="source-code">    "cs": "Panel oznámení",</p>
			<p class="source-code">    "da": "Meddelelseslinje",</p>
			<p class="source-code">    "de": "Ankündigungsbereich",</p>
			<p class="source-code">    "en": "Announcement bar"</p>
			<p class="source-code">  },</p>
			<p class="source-code"><strong class="bold">  </strong><strong class="bold">"class": "homepage-section desktop-only"</strong></p>
			<p class="source-code">}</p>
			<p class="source-code">{% endschema %}</p>
			<p>Through this optional attribute, we can easily include any number of classes in the parent element wrapping around our section, as shown in the following code block:</p>
			<p class="source-code">&lt;div id="shopify-section-[id]" <strong class="bold">class="homepage-section   desktop-only"</strong>&gt;</p>
			<p class="source-code">&lt;/div&gt;</p>
			<p>Note that while we can include<a id="_idIndexMarker570"/> any number of classes, we cannot dynamically modify them since the <strong class="source-inline">class</strong> attribute only<a id="_idIndexMarker571"/> accepts string values.</p>
			<h2 id="_idParaDest-137"><a id="_idTextAnchor137"/>The settings attribute</h2>
			<p>Using the <strong class="source-inline">settings</strong> attribute, we can create<a id="_idIndexMarker572"/> section-specific settings, which allows<a id="_idIndexMarker573"/> us to configure the section using the theme editor:</p>
			<p class="source-code">{% schema %}</p>
			<p class="source-code">{</p>
			<p class="source-code">  "name": {</p>
			<p class="source-code">    "cs": "Panel oznámení",</p>
			<p class="source-code">    "da": "Meddelelseslinje",</p>
			<p class="source-code">    "de": "Ankündigungsbereich",</p>
			<p class="source-code">    "en": "Announcement bar"</p>
			<p class="source-code">  },</p>
			<p class="source-code">  "class": "homepage-section desktop-only",</p>
			<p class="source-code"><strong class="bold">  "settings": [</strong></p>
			<p class="source-code"><strong class="bold">  ]</strong></p>
			<p class="source-code">}</p>
			<p class="source-code">{% endschema %}</p>
			<p>Once we have defined the <strong class="source-inline">settings</strong> attribute, we can start including any input settings, whether they're basic or specialized, that we have previously learned about to create the flow that we need. Since we are working on creating an announcement bar, we can include the following inputs:</p>
			<p class="source-code">{% schema %}</p>
			<p class="source-code">{</p>
			<p class="source-code">  "name": {</p>
			<p class="source-code">    "cs": "Panel oznámení",</p>
			<p class="source-code">    "da": "Meddelelseslinje",</p>
			<p class="source-code">    "de": "Ankündigungsbereich",</p>
			<p class="source-code">    "en": "Announcement bar"</p>
			<p class="source-code">  },</p>
			<p class="source-code">  "class": "homepage-section desktop-only",</p>
			<p class="source-code">  "settings": [</p>
			<p class="source-code">    {</p>
			<p class="source-code">      "type": "text",</p>
			<p class="source-code">      "id": "announcement-text",</p>
			<p class="source-code">      "label": "Text"</p>
			<p class="source-code">    },</p>
			<p class="source-code">    {</p>
			<p class="source-code">      "type": "color",</p>
			<p class="source-code">      "id": "announcement-text-color",</p>
			<p class="source-code">      "label": "Text color",</p>
			<p class="source-code">      "default": "#000000"</p>
			<p class="source-code">    }</p>
			<p class="source-code">  ]</p>
			<p class="source-code">}</p>
			<p class="source-code">{% endschema %}</p>
			<p>With the introduction of <strong class="source-inline">settings</strong> and input settings, we have successfully created the first section, whose text and text color<a id="_idIndexMarker574"/> values can be adjusted within<a id="_idIndexMarker575"/> the theme editor. If we were to try and include this section as a static section, the two input settings that we created previously would immediately be visible under the respective section:</p>
			<p class="source-code">{% section "section-file-name" %}</p>
			<p>However, if we were to navigate to the home page and include the announcement section via the <strong class="bold">Add section</strong> button, we would<a id="_idIndexMarker576"/> not find it. We are still missing<a id="_idIndexMarker577"/> one attribute, which we need to create a section that we can dynamically add to the home page. </p>
			<h2 id="_idParaDest-138"><a id="_idTextAnchor138"/>The presets attribute</h2>
			<p>The <strong class="source-inline">presets</strong> attribute allows<a id="_idIndexMarker578"/> us to define the default configuration of a section, which<a id="_idIndexMarker579"/> makes the section accessible from the <strong class="bold">Add section</strong> dropdown. The <strong class="source-inline">presets</strong> attribute can contain the following attributes:</p>
			<ul>
				<li>The <strong class="source-inline">name</strong> attribute is mandatory and will define how the section will appear under the <strong class="bold">Add section</strong> dropdown.</li>
				<li>The <strong class="source-inline">category</strong> attribute is not mandatory. We can use it to group different sections under a single category for more straightforward navigation.</li>
			</ul>
			<p>Note that it is advisable to use a unique name for the <strong class="source-inline">presets</strong> section to avoid confusion, even though Shopify does not strictly require it. Otherwise, we might end up with multiple sections with similar names: </p>
			<p class="source-code">{% schema %}</p>
			<p class="source-code">{</p>
			<p class="source-code">  "name": {</p>
			<p class="source-code">    "cs": "Panel oznámení",</p>
			<p class="source-code">    "da": "Meddelelseslinje",</p>
			<p class="source-code">    "de": "Ankündigungsbereich",</p>
			<p class="source-code">    "en": "Announcement bar"</p>
			<p class="source-code">  },</p>
			<p class="source-code">  "class": "homepage-section desktop-only",</p>
			<p class="source-code">  "settings": [</p>
			<p class="source-code">    {</p>
			<p class="source-code">      "type": "text",</p>
			<p class="source-code">      "id": "announcement-text",</p>
			<p class="source-code">      "label": "Text"</p>
			<p class="source-code">    },</p>
			<p class="source-code">    {</p>
			<p class="source-code">      "type": "color",</p>
			<p class="source-code">      "id": "announcement-text-color",</p>
			<p class="source-code">      "label": "Text color",</p>
			<p class="source-code">      "default": "#000000"</p>
			<p class="source-code">    }</p>
			<p class="source-code">  ],</p>
			<p class="source-code"><strong class="bold">  "presets": [</strong></p>
			<p class="source-code"><strong class="bold">    {</strong></p>
			<p class="source-code"><strong class="bold">      "name": "Announcement bar",</strong></p>
			<p class="source-code"><strong class="bold">      "category": "Text"</strong></p>
			<p class="source-code"><strong class="bold">    }</strong></p>
			<p class="source-code"><strong class="bold">  ]</strong></p>
			<p class="source-code">}</p>
			<p class="source-code">{% endschema %}</p>
			<p>Note that we should only include the <strong class="source-inline">presets</strong> attribute for dynamic sections. If we plan on using it as a static section, we should remove the <strong class="source-inline">presets</strong> attribute.</p>
			<p>If we were to open<a id="_idIndexMarker580"/> the theme editor now and click on the <strong class="bold">Add section</strong> button on<a id="_idIndexMarker581"/> the home page, we would see the <strong class="bold">Announcement Bar</strong> section, with the text and color settings that we defined earlier. </p>
			<p>Accessing the section-specific JSON input values is relatively similar to how we access the settings inside the <strong class="source-inline">settings_schema.json</strong> file. The only difference is that the only way to access the section's <strong class="source-inline">settings</strong> object is through the <strong class="source-inline">section</strong> object:</p>
			<p class="source-code">{{ <strong class="bold">section</strong>.settings.announcement-text }}</p>
			<p class="source-code">{{ <strong class="bold">section</strong>.settings.announcement-text-color }}</p>
			<p>For additional<a id="_idIndexMarker582"/> information on the <strong class="source-inline">section</strong> object, please refer to <a href="https://shopify.dev/api/liquid/objects/section">https://shopify.dev/api/liquid/objects/section</a>.</p>
			<p>So far, we have learned what sections are, the differences between static and dynamic sections, and how to use them. However, looking over the announcement section project that we have<a id="_idIndexMarker583"/> worked on, it is clear that the entire section is pretty<a id="_idIndexMarker584"/> basic as it only allows us to create a single announcement.</p>
			<p>We can include a few more text input options that we can use to create multiple announcements, but that would require us to manually edit the JSON code every time we need to include an additional announcement. <em class="italic">What if we're looking to create a section that would allow us to add any number of announcements, without modifying the JSON code every time we need to include an additional announcement?</em> For this, we can use the <strong class="source-inline">blocks</strong> attribute.</p>
			<h1 id="_idParaDest-139"><a id="_idTextAnchor139"/>Building with blocks</h1>
			<p>The <strong class="source-inline">blocks</strong> attribute is one of the most potent tools in Shopify. By using them, we can create modules that we can<a id="_idIndexMarker585"/> reuse any number of times and reorder the section content from within the theme editor. At this point, this might be confusing as it sounds similar to what we just learned about regarding dynamic sections. However, the key difference is that <strong class="source-inline">blocks</strong> sections allow us to reorder the content within the section, not the sections themselves, which allows us to create more complex features.</p>
			<p>Additionally, we can combine the <strong class="source-inline">blocks</strong> attributes with static sections to create a dynamic section functionality that's similar to what we currently have on the home page, and then include it on any page. However, instead of rearranging sections, we will be rearranging the blocks.</p>
			<p>The <strong class="source-inline">blocks</strong> attribute allows us to create different types of blocks using the object format, under which each object type will act as a unique module. Here, we can include a different set of input<a id="_idIndexMarker586"/> settings options under each of those modules.</p>
			<p>Here are the steps for creating and using a <strong class="source-inline">blocks</strong> module:</p>
			<ol>
				<li>Let's learn how to modify the previously created announcement bar section by introducing the <strong class="source-inline">blocks</strong> attribute. Additionally, we will remove certain features, such as translation keys and the <strong class="source-inline">class</strong> attributes, for the code to remain concise and readable:<p class="source-code">{% schema %}</p><p class="source-code">{</p><p class="source-code">  "name": "Announcement Bar",</p><p class="source-code">  "settings": [</p><p class="source-code">    {</p><p class="source-code">      "type": "text",</p><p class="source-code">      "id": "announcement-text",</p><p class="source-code">      "label": "Text"</p><p class="source-code">    },</p><p class="source-code">    {</p><p class="source-code">      "type": "color",</p><p class="source-code">      "id": "announcement-text-color",</p><p class="source-code">      "label": "Text color",</p><p class="source-code">      "default": "#000000"</p><p class="source-code">    }</p><p class="source-code">  ],</p><p class="source-code">  <strong class="bold">"blocks": [</strong></p><p class="source-code">  <strong class="bold">],</strong></p><p class="source-code">  "presets": [</p><p class="source-code">    {</p><p class="source-code">      "name": "Announcement bar",</p><p class="source-code">      "category": "Text"</p><p class="source-code">    }</p><p class="source-code">  ]</p><p class="source-code">}</p><p class="source-code">{% endschema %}</p><p>Like creating a section, the <strong class="source-inline">blocks</strong> attribute has its own set of attributes that we need to use to create different modules:</p><ul><li>The <strong class="source-inline">name</strong> attribute<a id="_idIndexMarker587"/> allows us to set the name of the <strong class="source-inline">blocks</strong> module and decide how the block will appear in the theme editor. The <strong class="source-inline">name</strong> attribute is mandatory.</li><li>The <strong class="source-inline">type</strong> attribute is a mandatory attribute that accepts a string value where we can define the block type. Note that the <strong class="source-inline">type</strong> attribute does not have a predefined set of values. Instead, we can use any string value to define the block type.</li><li>Using the <strong class="source-inline">limit</strong> attribute, we can limit how many times we can repeat a particular block type. The <strong class="source-inline">limit</strong> attribute is optional and only accepts a <strong class="source-inline">number</strong> type value.</li><li>The <strong class="source-inline">settings</strong> attribute allows us to include <strong class="source-inline">blocks</strong> module-specific settings. The <strong class="source-inline">settings</strong> attribute is optional.</li></ul><p>Note that the <strong class="source-inline">name</strong> and <strong class="source-inline">type</strong> attributes of the <strong class="source-inline">blocks</strong> module need to remain unique within the section, whereas the <strong class="source-inline">id</strong> attribute needs to remain unique within the <strong class="source-inline">blocks</strong> modules. Otherwise, we will end up with invalid JSON code.</p></li>
				<li>Now, let's learn how to include the previously mentioned <strong class="source-inline">blocks</strong> module attributes inside the section schema. Note that we will only show the code that's inside the <strong class="source-inline">blocks</strong> attribute to keep the code concise and to the point:<p class="source-code">"blocks": [</p><p class="source-code"><strong class="bold">  {</strong></p><p class="source-code"><strong class="bold">    "name": "Announcement",</strong></p><p class="source-code"><strong class="bold">    "type": "announcement",</strong></p><p class="source-code"><strong class="bold">    "limit": 3,</strong></p><p class="source-code"><strong class="bold">    "settings": [</strong></p><p class="source-code"><strong class="bold">    ]</strong></p><p class="source-code"><strong class="bold">  }</strong></p><p class="source-code"><strong class="bold">]</strong></p><p>In the previous example, we created a <strong class="source-inline">blocks</strong> module with the <strong class="source-inline">name</strong> attribute set to <strong class="source-inline">Announcement</strong>, the <strong class="source-inline">type</strong> attribute set to <strong class="source-inline">announcement</strong>, and the <strong class="source-inline">limit</strong> attribute set to <strong class="source-inline">3</strong>, which limits the <strong class="source-inline">blocks</strong> module to a maximum of <strong class="source-inline">3</strong> repetitions.</p></li>
				<li>Now that we have all the<a id="_idIndexMarker588"/> necessary attributes in place, all we need to do is populate the <strong class="source-inline">settings</strong> attribute with the necessary input settings. Since we have already created the text and text color input settings, we can simply migrate the text input setting inside the <strong class="source-inline">blocks</strong> module:<p class="source-code">"blocks": [</p><p class="source-code"><strong class="bold">  {</strong></p><p class="source-code"><strong class="bold">    "name": "Announcement",</strong></p><p class="source-code"><strong class="bold">    "type": "announcement",</strong></p><p class="source-code"><strong class="bold">    "limit": 3,</strong></p><p class="source-code"><strong class="bold">    "settings": [</strong></p><p class="source-code">      {</p><p class="source-code">        "type": "text",</p><p class="source-code">        "id": "announcement-text",</p><p class="source-code">        "label": "Text"</p><p class="source-code">      }</p><p class="source-code"><strong class="bold">    ]</strong></p><p class="source-code"><strong class="bold">  }</strong></p><p class="source-code"><strong class="bold">]</strong></p><p>With the text input inside the <strong class="source-inline">blocks</strong> module, we can dynamically repeat the entire block up to three times, consequently creating three separate announcements.</p></li>
				<li>Let's see what this looks<a id="_idIndexMarker589"/> like by navigating to the theme editor and clicking on the <strong class="bold">Add section</strong> button to include the <strong class="bold">Announcement Bar</strong> section on the home page. The first thing that we will notice is the <strong class="bold">Text color</strong> option, which we have left inside the section <strong class="source-inline">settings</strong> object:<div id="_idContainer096" class="IMG---Figure"><img src="Images/Figure_7.03_B17606.jpg" alt="Figure 7.3 – Example of a section inside the theme editor&#13;&#10;" width="605" height="145"/></div><p class="figure-caption">Figure 7.3 – Example of a section inside the theme editor</p><p>Since we have only migrated the text input and left the text color input inside the section <strong class="source-inline">settings</strong> object, we can use it to style the text color of all the blocks at once. Let's click on the arrow to the left of the <strong class="bold">Announcement Bar</strong> title to return to the previous section and see our <strong class="source-inline">blocks</strong> module in action.</p><p>We will notice that besides the <strong class="bold">Add section</strong> button, we also have an <strong class="bold">Add Announcement</strong> button under the <strong class="bold">Announcement Bar</strong> section that we created:</p><div id="_idContainer097" class="IMG---Figure"><img src="Images/Figure_7.04_B17606.jpg" alt="Figure 7.4 – Example of a section block module&#13;&#10;" width="662" height="167"/></div><p class="figure-caption">Figure 7.4 – Example of a section block module</p></li>
				<li>Clicking <strong class="bold">Announcement Bar</strong> will return us to the previous page, where we can configure the settings inside the section <strong class="source-inline">settings</strong> object, whereby clicking on the <strong class="bold">Add Announcement</strong> button will automatically include a single <strong class="source-inline">blocks</strong> module and immediately position us inside the block. Here, we can define the announcement text input.</li>
				<li>After defining<a id="_idIndexMarker590"/> all the inputs inside the <strong class="source-inline">blocks</strong> module's object settings, we can click on the arrow on the left-hand side of the <strong class="bold">Announcement</strong> title to return to the previous page, where we can include additional <strong class="source-inline">blocks</strong> modules. However, note that since we have introduced a <strong class="source-inline">limit</strong> attribute with a value of <strong class="source-inline">3</strong>, we can only repeat the <strong class="bold">Announcement</strong> block up to 3 times, as shown here:</li>
			</ol>
			<div>
				<div id="_idContainer098" class="IMG---Figure">
					<img src="Images/Figure_7.05_B17606.jpg" alt="Figure 7.5 – Example of a limited number of section block modules&#13;&#10;" width="400" height="256"/>
				</div>
			</div>
			<p class="figure-caption">Figure 7.5 – Example of a limited number of section block modules</p>
			<p>Once we have included the maximum number of modules, as per the defined value, the <strong class="bold">Add Announcement</strong> button will turn gray, signaling that we have reached the maximum number of <strong class="source-inline">blocks</strong> modules. Similarly, as with the dynamic sections, hovering over the <strong class="source-inline">blocks</strong> modules will reveal two icons. These will allow us to hide the currently selected block or rearrange the block's order using the drag-and-drop feature.</p>
			<p>Now that we have learned how to create and use a <strong class="source-inline">blocks</strong> module, we need to learn how to output the values of the <strong class="source-inline">blocks</strong> module's input settings:</p>
			<ol>
				<li value="1">We can access the <strong class="source-inline">blocks</strong> module's object settings similar to how we accessed the <strong class="source-inline">section</strong> object: we will need to use a <strong class="source-inline">section</strong> object in combination with the <strong class="source-inline">blocks</strong> attribute. This combination of the <strong class="source-inline">section</strong> object and the <strong class="source-inline">blocks</strong> attribute will return an array of sections blocks that we can access using a simple <strong class="source-inline">for</strong> loop:<p class="source-code">{% for block in <strong class="bold">section.blocks</strong> %}</p><p class="source-code">{% endfor %}</p></li>
				<li>Once we have created the <strong class="source-inline">for</strong> loop, the only thing left to do is output the values of each block, as we did with the sections. The only difference is that this time, we will use the variable that we defined in the <strong class="source-inline">for</strong> loop instead of using the <strong class="source-inline">sections</strong> keyword:<p class="source-code">{% for block in section.blocks %}</p><p class="source-code">  <strong class="bold">{{ block.settings.announcement-text }}</strong></p><p class="source-code">{% endfor %}</p></li>
			</ol>
			<p>So far, we have learned<a id="_idIndexMarker591"/> how to create the entire section schema, through which we can create static and dynamic sections and build <strong class="source-inline">blocks</strong> modules. We have also learned how to output the values of both the <strong class="source-inline">sections</strong> and <strong class="source-inline">blocks</strong> modules' input settings. However, in the previous example, we only had one type of block; <em class="italic">what if we had multiple block types?</em></p>
			<p>The true power of section blocks<a id="_idIndexMarker592"/> is that we can create multiple <strong class="source-inline">blocks</strong> module types inside a single <strong class="source-inline">section</strong> element, which we can do by simply creating multiple section <strong class="source-inline">blocks</strong> objects with different type values:</p>
			<p class="source-code">"blocks": [</p>
			<p class="source-code"><strong class="bold">  {</strong></p>
			<p class="source-code"><strong class="bold">    "name": "Product",</strong></p>
			<p class="source-code"><strong class="bold">    "type": "product",</strong></p>
			<p class="source-code"><strong class="bold">    </strong><strong class="bold">"settings": [</strong></p>
			<p class="source-code">      {</p>
			<p class="source-code">        "type": "product",</p>
			<p class="source-code">        "id": "featured-product",</p>
			<p class="source-code">        "label": "Product"</p>
			<p class="source-code">      }</p>
			<p class="source-code"><strong class="bold">    ]</strong></p>
			<p class="source-code"><strong class="bold">  },</strong></p>
			<p class="source-code"><strong class="bold">  {</strong></p>
			<p class="source-code"><strong class="bold">    "name": "Collection",</strong></p>
			<p class="source-code"><strong class="bold">    </strong><strong class="bold">"type": "collection",</strong></p>
			<p class="source-code"><strong class="bold">    "settings": [</strong></p>
			<p class="source-code">      {</p>
			<p class="source-code">        "type": "collection",</p>
			<p class="source-code">        "id": "featured-collection",</p>
			<p class="source-code">        "label": "collection"</p>
			<p class="source-code">      }</p>
			<p class="source-code"><strong class="bold">    ]</strong></p>
			<p class="source-code"><strong class="bold">  }</strong></p>
			<p class="source-code"><strong class="bold">]</strong></p>
			<p>Note that all of the <strong class="source-inline">name</strong> and <strong class="source-inline">type</strong> attribute values need to be unique across the entire section, whereas the <strong class="source-inline">id</strong> attributes of the input settings only need to be unique inside a single block.</p>
			<p>As we can see, creating multiple <strong class="source-inline">blocks</strong> module elements is relatively simple. While we have only created two simple <strong class="source-inline">blocks</strong> modules in our example, we can create any number of <strong class="source-inline">blocks</strong> modules that we can rearrange through the theme editor to create complex layouts:</p>
			<div>
				<div id="_idContainer099" class="IMG---Figure">
					<img src="Images/Figure_7.6_B17606.jpg" alt="Figure 7.6 – Example of multiple blocks modules inside a section&#13;&#10;" width="1046" height="771"/>
				</div>
			</div>
			<p class="figure-caption">Figure 7.6 – Example of multiple blocks modules inside a section</p>
			<p>As we can see from our example, we have<a id="_idIndexMarker593"/> four different types of blocks (<strong class="bold">Text</strong>, <strong class="bold">Collection</strong>, <strong class="bold">Image</strong>, and <strong class="bold">Video</strong>) that we can use to create a layout that the store owners can easily configure, without having to modify the code themselves.</p>
			<p>Previously, we learned how to loop over the array of blocks by using the <strong class="source-inline">for</strong> tags that <strong class="source-inline">section.blocks</strong> returns. However, if we have more than one <strong class="source-inline">blocks</strong> module type, we will need to introduce an additional step.</p>
			<p>Suppose that, as in the preceding example, we had a section with four types of blocks. <em class="italic">How would we recognize the block types and know what layout we should output for which block?</em> To solve this problem, we can use the <strong class="source-inline">block</strong> object paired with the <strong class="source-inline">type</strong> attribute, which will allow us to recover the block type value.</p>
			<p>For additional information<a id="_idIndexMarker594"/> on the <strong class="source-inline">block</strong> object, please refer to <a href="https://shopify.dev/api/liquid/objects/block">https://shopify.dev/api/liquid/objects/block</a>.</p>
			<p>Once we have identified each block type, we can use an <strong class="source-inline">if</strong> statement or <strong class="source-inline">case/when</strong> control flow tags to execute the correct code for the respective value. Suppose we need to remind ourselves how to use statements or <strong class="source-inline">case/when</strong> control tags; we can revisit <a href="B17606_03_Final_PD_ePub.xhtml#_idTextAnchor047"><em class="italic">Chapter 3</em></a>, <em class="italic">Diving into Liquid Code with Tags</em>, and consult the <em class="italic">Controlling the flow of Liquid</em> section for this, where we outlined the process of using control flow tags:</p>
			<p class="source-code">{% for block in section.blocks %}</p>
			<p class="source-code">  <strong class="bold">{% case block.type %}</strong></p>
			<p class="source-code">    <strong class="bold">{% when "collection" %}</strong></p>
			<p class="source-code">      {% render "block-collection ", collection: block %}</p>
			<p class="source-code">    <strong class="bold">{% when "image" %}</strong></p>
			<p class="source-code">      {% render "block-image", image: block %}</p>
			<p class="source-code">    <strong class="bold">{% when "video" %}</strong></p>
			<p class="source-code">      {% render "block-video", video: block %}</p>
			<p class="source-code">  <strong class="bold">{% endcase %}</strong></p>
			<p class="source-code">{% endfor %}</p>
			<p>In the previous example, we used the <strong class="source-inline">case/when</strong> control flow tags in combination with <strong class="source-inline">block.type</strong> to identify the types of blocks that we are currently looping over. After identifying the block type, we rendered the snippet file containing the correct layout for the respective block.</p>
			<p>Note that we have passed the <strong class="source-inline">block</strong> object to each snippet. As you may recall, the snippet files are the only type of files that can access the variables defined in the parent directory. However, even the snippet files cannot automatically access these variables. Instead, we need to pass the values as parameters.</p>
			<p>Suppose we need to remind ourselves how to pass values to snippet files; we can revisit <a href="B17606_03_Final_PD_ePub.xhtml#_idTextAnchor047"><em class="italic">Chapter 3</em></a>, <em class="italic">Diving into Liquid Code with Tags</em>, and consult the <em class="italic">The render tag</em> section, located under the <em class="italic">Theme tags</em> section, where we outlined the process of working with snippet files.</p>
			<p>Besides learning how to<a id="_idIndexMarker595"/> create <strong class="source-inline">blocks</strong> modules, we learned about the <strong class="source-inline">limit</strong> attribute, which we can use to limit how many times we can repeat a particular type of <strong class="source-inline">blocks</strong> module. This worked well when we had a single type block. <em class="italic">However, what if we wanted to create a limitation so that we can have a maximum number of any combination of blocks inside a section?</em></p>
			<h2 id="_idParaDest-140"><a id="_idTextAnchor140"/>The max_blocks attribute</h2>
			<p>The <strong class="source-inline">max_blocks</strong> attribute, similar to the <strong class="source-inline">limit</strong> attribute, allows us to limit how many <strong class="source-inline">blocks</strong> modules<a id="_idIndexMarker596"/> we can create inside a section. However, they have<a id="_idIndexMarker597"/> one significant difference: the <strong class="source-inline">limit</strong> attribute only allows us to limit the number of times we can repeat a particular block type, whereas the <strong class="source-inline">max_blocks</strong> attribute allows us to limit a specific section to a maximum number of any type of block.</p>
			<p>Note that the <strong class="source-inline">max_blocks</strong> attribute is optional and only accepts number data as its value:</p>
			<p class="source-code">{% schema %}</p>
			<p class="source-code">{</p>
			<p class="source-code">  "name": "Footer",</p>
			<p class="source-code">  <strong class="bold">"max_blocks": 5,</strong></p>
			<p class="source-code">  "settings": [</p>
			<p class="source-code">  ],</p>
			<p class="source-code">  "blocks": [</p>
			<p class="source-code">  ]</p>
			<p class="source-code">}</p>
			<p class="source-code">{% endschema %}</p>
			<p>The most common use of the <strong class="source-inline">max_blocks</strong> attribute is inside the footer section. With it, the store owner can easily rearrange the blocks in any order, whether by repeating a single block five times or by using five different blocks, all while ensuring that the layout of the entire section maintains the proper flow.</p>
			<p>Previously, we learned how to create <strong class="source-inline">blocks</strong> modules, as well as how to identify different types of block types and access each block object accordingly. Now that we have learned how we can use <strong class="source-inline">max_blocks</strong> to limit the number of products inside a section, we have all the necessary knowledge to build any type of <strong class="source-inline">blocks</strong> module.</p>
			<p>As we saw, blocks<a id="_idIndexMarker598"/> are quite powerful and allow us to create anything from basic<a id="_idIndexMarker599"/> text features to complex layout features, intertwined with different types of blocks that store owners can use to tell the story of their products.</p>
			<p>With that, we have learned about the differences between static sections, which we can manually embed on any page, and dynamic sections, which allow us to add any number of sections to the home page dynamically. However, as we mentioned at the beginning of this chapter, Shopify has recently provided us with the means to include sections on any page through JSON templates dynamically. By using JSON templates, we can combine the static and dynamic sections into a new feature that we can control from within the theme editor.</p>
			<h1 id="_idParaDest-141"><a id="_idTextAnchor141"/>Enhancing pages with JSON templates</h1>
			<p>In <a href="B17606_01_Final_PD_ePub.xhtml#_idTextAnchor015"><em class="italic">Chapter 1</em></a>, <em class="italic">Getting Started with Shopify</em>, while discussing the theme structure, we briefly mentioned JSON templates, <em class="italic">but what exactly are they?</em></p>
			<p>The <strong class="source-inline">.json</strong> type templates<a id="_idIndexMarker600"/> generally have the same purpose<a id="_idIndexMarker601"/> as their counterpart <strong class="source-inline">.liquid</strong> templates, as they both allow us to create and manage the look of multiple pages through a single template. However, the significant difference between the two is that while the <strong class="source-inline">.liquid</strong> type template serves only as a markup file, the <strong class="source-inline">.json</strong> file serves as a data type file, which allows us to easily add, remove, or rearrange the sections on any page, similar to what we can do on the home page.</p>
			<p>The <strong class="source-inline">.json</strong> type templates also share similarities with the <strong class="source-inline">Section</strong> directory files, where we need to include a valid schema setting inside the section file. The <strong class="source-inline">.json</strong> type template needs to be a valid <strong class="source-inline">.json</strong> file, with the JSON code defined inside the template. While we can create any number of <strong class="source-inline">.json</strong> type files, the template files' names must be unique in the <strong class="source-inline">.liquid</strong> or <strong class="source-inline">.json</strong> file. For example, if we create a <strong class="source-inline">product.json</strong> file template, we cannot create a <strong class="source-inline">product.liquid</strong> file as well.</p>
			<p>Additionally, JSON files<a id="_idIndexMarker602"/> have one limitation. We can render<a id="_idIndexMarker603"/> a maximum of 20 sections per template with up to 16 blocks per section, which is a reasonably high number, but we should probably rethink our page layout if we ever reach this limit.</p>
			<p>Now that we have some general knowledge of what JSON type templates are and how they work, let's learn how to create our first JSON type file.</p>
			<h2 id="_idParaDest-142"><a id="_idTextAnchor142"/>Building a JSON template structure</h2>
			<p>Instead of simply listing<a id="_idIndexMarker604"/> the necessary attributes for creating the file, we will learn how to create a JSON template by migrating the current <strong class="source-inline">product.liquid</strong> type template into a JSON template.</p>
			<p>Let's begin by creating a JSON-type template by opening the <strong class="source-inline">Templates</strong> directory and clicking the <strong class="bold">Add a new template</strong> button. A popup will appear, where we can select which page we are creating the template name for, the template type, and the filename. For our purposes, we'll select the <strong class="bold">product</strong> page from the page selection dropdown and select the <strong class="bold">JSON</strong> radio button for <strong class="bold">Template type</strong>. As for <strong class="bold">File name</strong>, we can leave it as the default; that is, <strong class="source-inline">alternate</strong>:</p>
			<div>
				<div id="_idContainer100" class="IMG---Figure">
					<img src="Images/Figure_7.07_B17606.jpg" alt="Figure 7.7 – Example of creating a new JSON type template&#13;&#10;" width="627" height="425"/>
				</div>
			</div>
			<p class="figure-caption">Figure 7.7 – Example of creating a new JSON type template</p>
			<p>Once we have created a new JSON file, Shopify will automatically redirect us to the newly created file. We will see an almost empty file containing only two attributes. So, let's start creating the necessary attributes and begin our migration process.</p>
			<p>As we mentioned previously, a JSON<a id="_idIndexMarker605"/> template must be a valid JSON file whose root is an object that can contain some of the following attributes:</p>
			<ul>
				<li>The <strong class="source-inline">name</strong> attribute is a mandatory string type attribute where, as its name suggests, we can define the template's name:<p class="source-code">{</p><p class="source-code">  <strong class="bold">"name": "JSON product template"</strong></p><p class="source-code">}</p></li>
				<li>The <strong class="source-inline">layout</strong> attribute is an optional attribute that accepts two types of values, a string or false, depending on what we are trying to achieve. The string value should represent the name of the layout file, without the <strong class="source-inline">.liquid</strong> extension that we would like to use with this specific template. If you need to learn more about layout files, please revisit <a href="B17606_03_Final_PD_ePub.xhtml#_idTextAnchor047"><em class="italic">Chapter 3</em></a>, <em class="italic">Diving into Liquid Core with Tags</em>, where we learned about <strong class="source-inline">layout</strong> tags in the <em class="italic">Theme tags</em> sections. Note that if we do not include the <strong class="source-inline">layout</strong> attribute, Shopify will default to the <strong class="source-inline">theme.liquid</strong> layout. However, for learning<a id="_idIndexMarker606"/> purposes, we will manually add and select the <strong class="source-inline">theme</strong> layout:<p class="source-code">{</p><p class="source-code">  "name": "JSON product template",</p><p class="source-code">  <strong class="bold">"layout": "theme"</strong></p><p class="source-code">}</p></li>
				<li>The <strong class="source-inline">wrapper</strong> attribute is a string type attribute that allows us to select the type of HTML wrapper we would like to include around each section inside the template. We can use the following HTML tags here:<ul><li><strong class="source-inline">div</strong></li><li><strong class="source-inline">main</strong></li><li><strong class="source-inline">section</strong></li></ul><p>Note that besides selecting the HTML wrapper's type, we can also include any additional attributes that we may need, such as <strong class="source-inline">class</strong>, <strong class="source-inline">id</strong>, or <strong class="source-inline">data</strong>. Note that the <strong class="source-inline">wrapper</strong> attribute is entirely optional:</p><p class="source-code">{</p><p class="source-code">  "name": "JSON product template",</p><p class="source-code">  "layout": "theme",</p><p class="source-code">  <strong class="bold">"wrapper": "div.product-wrapper[data-type=product]"</strong></p><p class="source-code">}</p></li>
				<li>The <strong class="source-inline">sections</strong> attribute is a mandatory object type attribute that uses the names of the sections as keys and the <strong class="source-inline">section</strong> data as values. Inside the <strong class="source-inline">sections</strong> object, we can define which sections we would like to include inside our page:<p class="source-code">{</p><p class="source-code">  "name": "JSON product template",</p><p class="source-code">  "layout": "theme",</p><p class="source-code">  "wrapper": "div.product-wrapper[data-type=product]",</p><p class="source-code">  <strong class="bold">"sections": {</strong></p><p class="source-code">  <strong class="bold">}</strong></p><p class="source-code">}</p><p>We might be wondering<a id="_idIndexMarker607"/> why we need to manually select which sections we would like to include since the whole point of dynamic sections is to avoid this.</p><p>The <strong class="source-inline">sections</strong> object allows us to include a mandatory static section, similar to our main page content, that is more page-specific. First, we will need to set a unique ID representing each static section that we are looking to include:</p><p class="source-code">{</p><p class="source-code">  "name": "JSON product template",</p><p class="source-code">  "layout": "theme",</p><p class="source-code">  "wrapper": "div.product-wrapper[data-type=product]",</p><p class="source-code">  "sections": {</p><p class="source-code">    <strong class="bold">"main-block": {</strong></p><p class="source-code">    <strong class="bold">},</strong></p><p class="source-code">    <strong class="bold">"different-block": {</strong></p><p class="source-code">    <strong class="bold">}</strong></p><p class="source-code">  }</p><p class="source-code">}</p><p>Considering that the <strong class="source-inline">sections</strong> attribute uses the same format as the <strong class="source-inline">section</strong> attribute that we learned about previously, we will also need to include some additional attributes inside the <strong class="source-inline">sections</strong> object. For example, we will need to include the <strong class="source-inline">type</strong> attribute, whose value should have the name of the section we are looking to include, and<a id="_idIndexMarker608"/> if needed, the <strong class="source-inline">settings</strong> or <strong class="source-inline">blocks</strong> attribute:</p><p class="source-code">{</p><p class="source-code">  "name": "JSON product template",</p><p class="source-code">  "layout": "theme",</p><p class="source-code">  "wrapper": "div.product-wrapper[data-type=product]",</p><p class="source-code">  "sections": {</p><p class="source-code">    "main-block": {</p><p class="source-code">      <strong class="bold">"type": "name-of-the-section",</strong></p><p class="source-code">    },</p><p class="source-code">    "different-block": {</p><p class="source-code">      <strong class="bold">"type": "name-of-another-section"</strong></p><p class="source-code">    }</p><p class="source-code">  }</p><p class="source-code">}</p><p>However, note that the <strong class="source-inline">settings</strong> or <strong class="source-inline">blocks</strong> attribute should not contain the input type settings. Instead, we should set the key value to the ID of the existing input inside each section, as well as the value of the <strong class="source-inline">settings</strong> input value that we wish to set:</p><p class="source-code">{</p><p class="source-code">  "name": "JSON product template",</p><p class="source-code">  "layout": "theme",</p><p class="source-code">  "wrapper": "div.product-wrapper[data-type=product]",</p><p class="source-code">  "sections": {</p><p class="source-code">    "main-block": {</p><p class="source-code">      "type": "name-of-the-section",</p><p class="source-code">      "settings": {</p><p class="source-code">        <strong class="bold">"show_discount": true,</strong></p><p class="source-code">        <strong class="bold">"gallery_type": "slider"</strong></p><p class="source-code">      },</p><p class="source-code">      "blocks": {</p><p class="source-code">      }</p><p class="source-code">    },</p><p class="source-code">    "different-block": {</p><p class="source-code">      "type": "name-of-another-section"</p><p class="source-code">    }</p><p class="source-code">  }</p><p class="source-code">}</p><p>Now, let's update the previous<a id="_idIndexMarker609"/> example and include the actual static sections we are currently using inside our default Liquid-type product template:</p><p class="source-code">{</p><p class="source-code">  "name": "JSON product template",</p><p class="source-code">  "layout": "theme",</p><p class="source-code">  "wrapper": "div.product-wrapper[data-type=product]",</p><p class="source-code">  "sections": {</p><p class="source-code">    "<strong class="bold">main</strong>": {</p><p class="source-code">      "type": "<strong class="bold">product-template</strong>"</p><p class="source-code">    },</p><p class="source-code">    "<strong class="bold">recommendations</strong>": {</p><p class="source-code">      "type": "<strong class="bold">product-recommendations</strong>"</p><p class="source-code">    }</p><p class="source-code">  }</p><p class="source-code">}</p><p>Note that the names of the sections that we have used (<strong class="source-inline">main</strong> and <strong class="source-inline">recommendations</strong>) are not preset values and that we can change their names to any values we like. </p><p>When dealing<a id="_idIndexMarker610"/> with the <strong class="source-inline">sections</strong> object, there are three crucial things that we need to keep in mind:</p><ul><li>We need to have at least one block set inside the <strong class="source-inline">sections</strong> object.</li><li>All block names must be unique across the entire <strong class="source-inline">sections</strong> object.</li><li>The value of the <strong class="source-inline">type</strong> attribute needs to match the name of the section we are looking to include.</li></ul><p>By including the <strong class="source-inline">main</strong> and <strong class="source-inline">recommendations</strong> sections in our new JSON template, we have ensured that these two sections will always be visible inside the theme editor when previewing the page with the specific JSON type template assigned. However, while these sections are considered static, we can hide them and rearrange them, similar to dynamic sections.</p></li>
				<li>The last attribute is the <strong class="source-inline">order</strong> attribute, which is a mandatory attribute. The <strong class="source-inline">order</strong> attribute is an array-type attribute. Here, we can include the IDs of the <strong class="source-inline">sections</strong> blocks that we previously set inside the <strong class="source-inline">sections</strong> object and arrange them:<p class="source-code">{</p><p class="source-code">  "name": "JSON product template",</p><p class="source-code">  "layout": "theme",</p><p class="source-code">  "wrapper": "div.product-wrapper[data-type=product]",</p><p class="source-code">  "sections": {</p><p class="source-code">    "main": {</p><p class="source-code">      "type": "product-template"</p><p class="source-code">    },</p><p class="source-code">    "recommendations": {</p><p class="source-code">      "type": "product-recommendations"</p><p class="source-code">    }</p><p class="source-code">  },</p><p class="source-code">  <strong class="bold">"order": [</strong></p><p class="source-code">    <strong class="bold">"main",</strong></p><p class="source-code">    <strong class="bold">"recommendations"</strong></p><p class="source-code">  <strong class="bold">]</strong></p><p class="source-code">}</p></li>
			</ul>
			<p>And with the <strong class="source-inline">order</strong> attribute in place, our JSON template is ready! Let's navigate to the theme editor and test it out.</p>
			<p>To test the new product<a id="_idIndexMarker611"/> template, follow these steps:</p>
			<ol>
				<li value="1">Navigate to <strong class="bold">Products</strong> from the admin dashboard.</li>
				<li>Click on any product and then select the new template name from the <strong class="bold">Template suffix</strong> drop-down menu, which is located under the <strong class="bold">Theme templates</strong> area.<p class="callout-heading">Important note:</p><p class="callout">The <strong class="bold">Template suffix</strong> drop-down menu can only read values from the current live theme. What this means is that the newly created template file will not be visible in our admin dashboard until we either publish or duplicate them live, or until we create the same template file within our currently live team. If we opt for the latter choice, note that we need to create the file with the same name; we do not have to make any changes to the file's content.</p></li>
			</ol>
			<p>However, with this<a id="_idIndexMarker612"/> new type of template, we also have a new way to preview templates. Note that the following method only allows us to preview the template. We still need to assign the template by navigating to the admin dashboard's product page and selecting the template from inside the dropdown:</p>
			<ol>
				<li value="1">Let's begin by navigating to the theme editor, clicking on the dropdown in the middle of the screen, and selecting the <strong class="bold">product</strong> option. This will show you the templates we currently have under the theme that we are currently working on. Let's select the new JSON type template that we created by clicking on it:<div id="_idContainer101" class="IMG---Figure"><img src="Images/Figure_7.08_B17606.jpg" alt="Figure 7.8 – Example of selecting a template through the theme editor&#13;&#10;" width="511" height="304"/></div><p class="figure-caption">Figure 7.8 – Example of selecting a template through the theme editor</p></li>
				<li>Clicking on the <strong class="bold">alternate</strong> template will automatically redirect us to a random product, allowing us to preview the template that we have selected.<p class="callout-heading">Important note:</p><p class="callout">Similar to the dynamic sections on the home page, only sections with preset attributes present inside the sections schema will be visible under the <strong class="bold">Add section</strong> dropdown.</p><p>If we have done everything correctly, we should see two sections and the <strong class="bold">Add section</strong> button in the left sidebar:</p><div id="_idContainer102" class="IMG---Figure"><img src="Images/Figure_7.09_B17606.jpg" alt="Figure 7.9 – Example of previewing the JSON type template inside the theme editor&#13;&#10;" width="305" height="460"/></div><p class="figure-caption">Figure 7.9 – Example of previewing the JSON type template inside the theme editor</p></li>
				<li>Now, try<a id="_idIndexMarker613"/> and click on any of the two sections, update any settings, or add a new section through the <strong class="bold">Add section</strong> button and press the <strong class="bold">Save</strong> button in the top-right corner. Next, return to the code editor, close the new <strong class="source-inline">.json</strong> type template we created by clicking on the <strong class="bold">X</strong> next to its name, and then open it again.<p>We will notice that <strong class="bold">Shopify</strong> has updated the template file and that it now contains all the settings and their values. </p><p>Since we can find all of the settings and their values inside the template file, if we assign the JSON template file to multiple products, they will use the layout with the same settings. If we wanted to create an additional JSON template that would allow us to create a different layout, we could manually create a new JSON template and copy the code or do this through the theme editor.</p></li>
				<li>Let's return to the theme editor, click on the dropdown in the middle of the screen, and select the <strong class="bold">product</strong> option. But this time, we will click on the <strong class="bold">Create template</strong> button, which will cause the following popup to appear:</li>
			</ol>
			<div>
				<div id="_idContainer103" class="IMG---Figure">
					<img src="Images/Figure_7.10_B17606.jpg" alt="Figure 7.10 – Example of creating a new JSON type template through the theme editor&#13;&#10;" width="805" height="390"/>
				</div>
			</div>
			<p class="figure-caption">Figure 7.10 – Example of creating a new JSON type template through the theme editor</p>
			<p>As we can see, inside<a id="_idIndexMarker614"/> the popup, we can easily set a new template name and select the JSON template whose content we should copy.</p>
			<p>With that, we have learned how to create any number of templates for any number of pages, <em class="italic">but what if we wanted to use the same layout for multiple pages and only use different content for each page?</em> This is where metafields come to the rescue!</p>
			<h2 id="_idParaDest-143"><a id="_idTextAnchor143"/>Upgrading a JSON template with metafields</h2>
			<p>As you may recall from <a href="B17606_04_Final_PD_ePub.xhtml#_idTextAnchor079"><em class="italic">Chapter 4</em></a>, <em class="italic">Diving into Liquid Core with Objects</em>, while going through the <em class="italic">Improving the workflow with metafields</em> section, we mentioned that Shopify has introduced<a id="_idIndexMarker615"/> a feature that allows us to use metafields<a id="_idIndexMarker616"/> without having to rely on third-party apps.</p>
			<p>Besides allowing us to create metafields within the dashboard, Shopify has provided us with a whole new set of different types of metafields that we can create:</p>
			<ol>
				<li value="1">Start by navigating to the <strong class="bold">Settings</strong> options inside our dashboard, located at the bottom-left corner of our screen, and click on the <strong class="bold">Metafields</strong> options.</li>
				<li>Once inside, we will see that we have no metafields set and that we can only use products and variants metafields; the others are still pending. Let's proceed by clicking on the <strong class="bold">Products</strong> metafield link.</li>
				<li>Considering that we have no metafields currently set, we can immediately click on the <strong class="bold">Add definition</strong> button. This will<a id="_idIndexMarker617"/> redirect us to a page where we can create<a id="_idIndexMarker618"/> a metafield definition. While most of the fields should be familiar from when you learned about metafields in <a href="B17606_04_Final_PD_ePub.xhtml#_idTextAnchor079"><em class="italic">Chapter 4</em></a>, <em class="italic">Diving into Liquid Core with Objects</em>, we now have a new field. Let's click on the <strong class="bold">Select content type</strong> field, which will show us a dropdown containing all the available types of metafields we can create:<div id="_idContainer104" class="IMG---Figure"><img src="Images/Figure_7.11_B17606.jpg" alt="Figure 7.11 – Example of the available metafields type fields&#13;&#10;" width="889" height="392"/></div><p class="figure-caption">Figure 7.11 – Example of the available metafields type fields</p><p>Note that each type of metafield will create a selector inside the dashboard of our product page. We can select the text input, which will automatically show us an additional set of settings. However, we won't be changing those now. </p></li>
				<li>After selecting the text type of the metafield, all we need to do is set its name. For our purposes, we will select one of the predefined metafield values by clicking on the <strong class="bold">Name</strong> field and selecting <strong class="bold">Product subtitle</strong>, which will automatically fill in all the other fields. Note that we will need to press the <strong class="bold">Save</strong> button to save the newly created metafield:<div id="_idContainer105" class="IMG---Figure"><img src="Images/Figure_7.12_B17606.jpg" alt="Figure 7.12 – Example of the metafields inside the product dashboard&#13;&#10;Figure 7.12 – Example of the metafields inside the product dashboard&#13;&#10;" width="601" height="148"/></div><p class="figure-caption">Figure 7.12 – Example of the metafields inside the product dashboard</p></li>
				<li>Now that we have created a product metafield, let's click on the <strong class="bold">Products</strong> link located in the top-left corner<a id="_idIndexMarker619"/> of our admin dashboard and click<a id="_idIndexMarker620"/> on any product of our choosing. If we scroll down to the bottom of the page, we will notice that the metafield we created is now part of our product pages.</li>
				<li>As we can see, by simply creating a product metafield definition, we have automatically added the same metafield to every product, allowing us to update the metafield's values a lot easier than when using a third-party app. Let's update the metafield's value by adding any string value and pressing the <strong class="bold">Save</strong> button.</li>
				<li>Now, return to the theme editor, navigate to the JSON template, and find any text input type from the sections that we have available. For our purposes, we have added a new section named <strong class="source-inline">Image with text</strong>.</li>
				<li>Looking through this section, we will notice new icons next to specific types of fields:<div id="_idContainer106" class="IMG---Figure"><img src="Images/Figure_7.13_B17606.jpg" alt="" width="657" height="403"/></div><p class="figure-caption">Figure 7.13 – Example of the metafields icon inside the theme editor</p><p>Clicking on the bottom<a id="_idIndexMarker621"/> icon next to the <strong class="bold">Heading</strong> text input<a id="_idIndexMarker622"/> will promptly show us a list of all the metafields that we can pull from this particular product.</p></li>
				<li>Select the <strong class="bold">Product subtitle</strong> metafield that we selected previously and click the <strong class="bold">Insert</strong> button. This will automatically add the value of the selected metafield and output it in the input field that we have selected:</li>
			</ol>
			<div>
				<div id="_idContainer107" class="IMG---Figure">
					<img src="Images/Figure_7.14_B17606.jpg" alt="" width="603" height="370"/>
				</div>
			</div>
			<p class="figure-caption">Figure 7.14 – Example of the metafields icon inside the theme editor</p>
			<p>With that, we have learned<a id="_idIndexMarker623"/> how to dynamically update the values<a id="_idIndexMarker624"/> of the sections settings by using metafields, without having to create a new JSON template for each product. The only thing we have to do now is create the proper layout by arranging the necessary sections inside the JSON template. </p>
			<p>Note that by using metafields, we can update all kinds of inputs, such as images, URLs, or even color swatches. However, we should create an appropriate metafield to ensure that the metafield value and the input-type value match.</p>
			<p>As we saw previously, sections alone are pretty powerful. Mixing sections with JSON templates and metafields makes them even more impressive. It allows merchants to easily configure each page differently, without having to create new templates for each page or manually inserting sections.</p>
			<p>Besides what we have learned so far, we know that Shopify also provides us with some additional section-specific tags that we can use to create even more powerful elements.</p>
			<h1 id="_idParaDest-144"><a id="_idTextAnchor144"/>Exploring section-specific tags</h1>
			<p>While we can easily define styling<a id="_idIndexMarker625"/> or include the JavaScript code inside the theme's respective asset files, Shopify provides us with three types of tags that we can use to include CSS and JavaScript directly in the section file.</p>
			<h2 id="_idParaDest-145"><a id="_idTextAnchor145"/>The stylesheet tag</h2>
			<p>Similar to the <strong class="source-inline">schema</strong> tag, the <strong class="source-inline">stylesheet</strong> tag is a Liquid tag that does not have any output on its own. It simply allows<a id="_idIndexMarker626"/> us to write CSS code inside the section files. Note that each<a id="_idIndexMarker627"/> section file can only contain a single <strong class="source-inline">stylesheet</strong> tag, which must stand on its own. It cannot be nested inside any other kind of Liquid tag:</p>
			<p class="source-code">{% stylesheet %}</p>
			<p class="source-code">{% endstylesheet %}</p>
			<p>Although this might not look like a great idea at first, since we end up having CSS code spread over multiple files, Shopify will automatically collect all the CSS files from the different section files, combine them into one stylesheet file, and inject it into the theme file through the <strong class="source-inline">content_for_header</strong> global object.</p>
			<p class="callout-heading">Important note:</p>
			<p class="callout">The <strong class="source-inline">stylesheet</strong> tag only accepts CSS values. We cannot include Liquid code inside the tag.</p>
			<p>Note that bundled assets are not section- or block-specific. For section- and block-specific stylesheets, we will need to use the <strong class="source-inline">style</strong> tag.</p>
			<h2 id="_idParaDest-146"><a id="_idTextAnchor146"/>The style tag</h2>
			<p>The <strong class="source-inline">style</strong> tag works similarly<a id="_idIndexMarker628"/> to the <strong class="source-inline">stylesheet</strong> tag as it allows<a id="_idIndexMarker629"/> us to write CSS code directly into the section file. However, the <strong class="source-inline">style</strong> tag has two significant differences compared to the <strong class="source-inline">stylesheet</strong> tag:</p>
			<ul>
				<li>The first difference is that the <strong class="source-inline">style</strong> tag is equal to using an HTML <strong class="source-inline">&lt;style&gt;</strong> tag, meaning that Shopify will not collect and bundle the CSS code that we included through the <strong class="source-inline">style</strong> tag. Instead, Shopify will render the HTML <strong class="source-inline">style</strong> tag and its content in the same place where we have included it:<p class="source-code">{% style %}</p><p class="source-code">{% endstyle %}</p></li>
				<li>The second and more important<a id="_idIndexMarker630"/> difference is that the <strong class="source-inline">style</strong> tag allows us to include<a id="_idIndexMarker631"/> Liquid code, which we can use to modify the CSS content by using the theme editor dynamically:<p class="source-code">{% style %}</p><p class="source-code">.featured-wrapper { </p><p class="source-code">  background-color: {{ section.settings.background-    color }};</p><p class="source-code">}</p><p class="source-code">{% for block in section.blocks %}</p><p class="source-code">  <strong class="bold">{% case block.type %}</strong></p><p class="source-code">    <strong class="bold">{% when "product" %}</strong></p><p class="source-code"><strong class="bold">      .featured-product {</strong></p><p class="source-code"><strong class="bold">        font-size: {{ block.settings.product-font-size }}          px;</strong></p><p class="source-code"><strong class="bold">      }</strong></p><p class="source-code">    <strong class="bold">{% when "collection" %}</strong></p><p class="source-code"><strong class="bold">      .featured-collection {</strong></p><p class="source-code"><strong class="bold">        font-size: {{ block.settings.collection-font-                size }}px;</strong></p><p class="source-code"><strong class="bold">      </strong><strong class="bold">}</strong></p><p class="source-code"><strong class="bold">  {% endcase %}</strong></p><p class="source-code"><strong class="bold">{% endfor %}</strong></p><p class="source-code">{% endstyle %}</p></li>
			</ul>
			<p>Note that as opposed to the input settings defined inside the <strong class="source-inline">settings_schema.json</strong> file, whose values can be accessed globally within any file, the section and block input values can only be accessed inside the section file itself or within the snippet file, after we pass the value as a parameter.</p>
			<p>In the previous example, we saw how to output the section input values and use them to modify the CSS code dynamically. However, in our example, we have used a static class, meaning that the <strong class="source-inline">background-color</strong> CSS we applied will affect every single section and block similarly. <em class="italic">But what if we wanted to apply a different color to each section or block?</em></p>
			<p>To apply a unique styling<a id="_idIndexMarker632"/> to a specific element, we will need to use a <strong class="source-inline">section</strong> or <strong class="source-inline">block</strong> object, combined<a id="_idIndexMarker633"/> with the <strong class="source-inline">id</strong> attribute, to create a unique identifier that we can call later:</p>
			<p class="source-code">&lt;div class="featured-wrapper <strong class="bold">featured-wrapper-{{ section.id </strong></p>
			<p class="source-code"><strong class="bold">  </strong><strong class="bold">}}</strong>"&gt;&lt;/div&gt;</p>
			<p class="source-code">{% for block in section.blocks %}</p>
			<p class="source-code">  &lt;div class="featured-collection <strong class="bold">featured-collection-{{     block.id }}</strong>"&gt;&lt;/div&gt;</p>
			<p class="source-code">{% endfor %}</p>
			<p>Note that <strong class="source-inline">section.id</strong> will return a dynamically generated ID for dynamic sections and a section filename, without the Liquid extension for static sections. <strong class="source-inline">block.id</strong> will always return a dynamically generated ID.</p>
			<p>Now that we have generated unique selectors, all we need to do is include the same selectors inside the <strong class="source-inline">style</strong> tag:</p>
			<p class="source-code">{% style %}</p>
			<p class="source-code">.featured-wrapper<strong class="bold">-{{ section.id }}</strong> {</p>
			<p class="source-code">  background-color: {{ section.settings.background-color}};</p>
			<p class="source-code">}</p>
			<p class="source-code">{% for block in section.blocks %}</p>
			<p class="source-code">  {% case block.type %}</p>
			<p class="source-code">    {% when "collection" %}</p>
			<p class="source-code">      .featured-collection-<strong class="bold">{{ block.id }} </strong>{</p>
			<p class="source-code">        font-size: {{ block.settings.collection-font-size                 }}px;</p>
			<p class="source-code">      }</p>
			<p class="source-code">  {% endcase %}</p>
			<p class="source-code">{% endfor %}</p>
			<p class="source-code">{% endstyle %}</p>
			<p>Now that we know how to generate<a id="_idIndexMarker634"/> and call unique selectors, we can easily<a id="_idIndexMarker635"/> create different styling for both section and block elements. Note that it is also possible to include CSS with dynamic values in HTML using the <strong class="source-inline">style</strong> attribute.</p>
			<h2 id="_idParaDest-147"><a id="_idTextAnchor147"/>The javascript tag</h2>
			<p>The <strong class="source-inline">javascript</strong> tag works<a id="_idIndexMarker636"/> in the same way as the <strong class="source-inline">stylesheet</strong> tag. The tag does<a id="_idIndexMarker637"/> not have any output on its own; it simply allows us to write JavaScript code directly inside the section files. We can only include a single <strong class="source-inline">javascript</strong> tag in a section, which must stand on its own, and it cannot be nested inside other Liquid tags:</p>
			<p class="source-code">{% javascript %}</p>
			<p class="source-code">{% endjavascript %}</p>
			<p>Similarly, as with the <strong class="source-inline">stylesheet</strong> tag, the <strong class="source-inline">javascript</strong> tag only accepts JavaScript code. We cannot include any Liquid code inside the tag. Additionally, Shopify will automatically bundle any code inside the <strong class="source-inline">javascript</strong> tag and inject it into the theme file through the <strong class="source-inline">content_for_header</strong> global object.</p>
			<p>Since we cannot use Liquid code inside the <strong class="source-inline">javascript</strong> tag, one way to apply section-specific JavaScript<a id="_idIndexMarker638"/> would be to use data attributes, which will output the specific input value<a id="_idIndexMarker639"/> and recover the value with JavaScript later:</p>
			<p class="source-code">&lt;div class="rotating-announcement" <strong class="bold">data-speed="{{   </strong><strong class="bold">section.settings.speed }}</strong>"&gt;&lt;/div&gt;</p>
			<p class="source-code"><strong class="bold">{% javascript %}</strong></p>
			<p class="source-code">  var rotationSpeed = parseInt(document.querySelector     ('.rotating-announcement').dataset.speed);</p>
			<p class="source-code"><strong class="bold">{% endjavascript %}</strong></p>
			<p>Considering that bundled assets are not section- or block-specific, if we needed to create some section- or block-specific JavaScript code, we would need to use an HTML <strong class="source-inline">&lt;script&gt;</strong> tag. Note that currently, Shopify does not have a Liquid tag that accepts Liquid code.</p>
			<p>With the HTML <strong class="source-inline">&lt;script&gt;</strong> tag, we can now write section- and block-specific JavaScript and directly include the input settings values. However, note that when directly including the input settings values inside the JavaScript, you should include the values with whitespace control to ensure no extra whitespaces are included:</p>
			<p class="source-code">{{- section.settings.speed -}}</p>
			<p>If you need to remind yourself how to use whitespace control, please revisit <a href="B17606_02_Final_PD_ePub.xhtml#_idTextAnchor030"><em class="italic">Chapter 2</em></a>, <em class="italic">The Basic Flow of Liquid</em>, and consult the <em class="italic">Controlling whitespace</em> section, where we outlined the process of controlling whitespace.</p>
			<h1 id="_idParaDest-148"><a id="_idTextAnchor148"/>Summary</h1>
			<p>In this chapter, we learned how to combine our previously attained knowledge of basic and specialized inputs with the section schema. This allows us to create everything from simple to complex layouts that we can easily configure throughout the theme editor.</p>
			<p>By learning the difference between static and dynamic sections, we learned how to extend a section's functionality and make it accessible on any type of page. Additionally, besides learning how to create different types of sections, we have also gained knowledge of how to create different types of <strong class="source-inline">blocks</strong> modules, which will allow us to rearrange the layouts of a single section to make it easy to configure.</p>
			<p>Lastly, we learned about the different types of section-specific tags that we can use to develop the content of the section further, as well as creating a unique experience for specific sections or even <strong class="source-inline">blocks</strong> modules.</p>
			<p>In the next chapter, we will learn about what Shopify Ajax is and how we can utilize it to implement advanced functionalities and make a store more dynamic.</p>
			<h1 id="_idParaDest-149"><a id="_idTextAnchor149"/>Questions</h1>
			<ol>
				<li value="1">What is the main difference between the static and dynamic sections?</li>
				<li>What object can we use to access the block input value? Write some code that will allow us to access the specific <strong class="source-inline">blocks</strong> module input value.</li>
				<li>What is the difference between the <strong class="source-inline">limit</strong> and <strong class="source-inline">max_blocks</strong> attributes?</li>
				<li>How can we apply section-specific CSS styling?</li>
			</ol>
			<h1 id="_idParaDest-150"><a id="_idTextAnchor150"/>Practice makes perfect</h1>
			<p>As with the projects in the previous chapters, this project will contain detailed information about what we need to do and the appropriate instructions to help you achieve the results.</p>
			<p>We recommend working on each project independently from the previous chapters since this will ensure you have truly understood what you have learned so far.</p>
			<p>Not a single project has a correct or incorrect solution. However, if by any chance you get stuck, you can always consult the project solution, which can be found at the end of this book.</p>
			<h2 id="_idParaDest-151"><a id="_idTextAnchor151"/>Project 4</h2>
			<p>For our fourth project, we will work on creating a section schema with multiple block types. While we can include any number of block types, we should make sure to include the following types:</p>
			<ul>
				<li>The text type, which will render a single rich text input</li>
				<li>The product type, which will render a single product element with a product name, price, image, and link</li>
				<li>The list type, which will render a one-level navigation list configurable from the Navigation admin section</li>
				<li>The video type, which will render a video from either the YouTube or Vimeo video platform</li>
			</ul>
			<p>Here are the instructions for the assets:</p>
			<ol>
				<li value="1">Create a new section file called <strong class="source-inline">featured-content.liquid</strong>.</li>
				<li>Create a separate snippet file for each section while also passing the proper object to each snippet.</li>
			</ol>
			<p>The following are the instructions for this assignment:</p>
			<ol>
				<li value="1">Include all the necessary attributes that we need for a dynamic section.</li>
				<li>Create the four block modules according to the specification provided.</li>
				<li>Limit the video block type to a maximum of two repetitions, where all the other blocks should be limited to one occurrence.</li>
				<li>The total number of blocks present at any time should not exceed four blocks.</li>
				<li>We should configure each block's width separately by using the predefined drop-down values and apply the selected width to each block via a class, not by directly applying the value. The values are 100%, 50%, 33.33%, and 25%.</li>
				<li>Only include the section or block-specific CSS inside the section file. We should include all other CSS stylings inside the theme's respective CSS file.</li>
				<li>Define the following input settings inside the section block settings for each snippet file: <strong class="source-inline">font-size</strong>, <strong class="source-inline">font-family</strong>, text <strong class="source-inline">color</strong>, and <strong class="source-inline">background-color</strong>. We should be able to select the font family from the Shopify <strong class="source-inline">font</strong> library.</li>
				<li>Create a text input element inside the section, which we will use to define the H1 heading for the entire section. If the input field is empty, we should hide the h1 HTML element.</li>
				<li>Migrate the entire project into a <strong class="source-inline">.json</strong> page type template.</li>
			</ol>
		</div>
	</div></body></html>