<html><head></head><body>
<div id="page" style="height:0pt"/><div class="book" title="Chapter&#xA0;7.&#xA0;Testing Web Applications"><div class="book" id="1T1402-edcc22b134104d5db0bf3aa086c86851"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch07" class="calibre1"/>Chapter 7. Testing Web Applications</h1></div></div></div><p class="calibre8">We are pretty sure you have heard the term "bug" when speaking about applications. Sentences such as "We found a bug in the application that…" followed by some very undesirable behavior are more common than you think. Writing code is not the only task of a developer; testing it is crucial too. You should not release a version of your application that has not been tested. However, could you imagine having to test your entire application every time you change a line? It would be a nightmare!</p><p class="calibre8">Well, we are not the first ones to have this issue, so, luckily enough, developers have already found a pretty good solution to this problem. In fact, they found more than one solution, turning testing into a very hot topic of discussion. Even being a test developer has become quite a common role. In this chapter, we will introduce you to one of the approaches of testing your code: unit tests.</p><p class="calibre8">In this chapter, you will learn about:</p><div class="book"><ul class="itemizedlist"><li class="listitem">How unit tests work</li><li class="listitem">Configuring PHPUnit to test your code</li><li class="listitem">Writing tests with assertions, data providers, and mocks</li><li class="listitem">Good and bad practices when writing unit tests</li></ul></div></div>

<div class="book" title="Chapter&#xA0;7.&#xA0;Testing Web Applications">
<div class="book" title="The necessity for tests"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_1"><a id="ch07lvl1sec58" class="calibre1"/>The necessity for tests</h1></div></div></div><p class="calibre8">When <a id="id564" class="calibre1"/>you work on a project, chances are that you are not the only developer who will work with this code. Even in the case where you are the only one who will ever change it, if you do this a few weeks after creating it, you will probably not remember all the places that this piece of code is affected. Okay, let's assume that you are the only developer and your memory is beyond limits; would you be able to verify that a change on a frequently used object, such as a request, will always work as expected? More importantly, would you like to do it every single time you make a tiny change?</p></div></div>

<div class="book" title="Chapter&#xA0;7.&#xA0;Testing Web Applications">
<div class="book" title="The necessity for tests">
<div class="book" title="Types of tests"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_2"><a id="ch07lvl2sec110" class="calibre1"/>Types of tests</h2></div></div></div><p class="calibre8">While <a id="id565" class="calibre1"/>writing your application, making changes to the existing code, or adding new features, it is very important to get good <span class="strong"><em class="calibre12">feedback</em></span>. How do you know that the feedback you get is good enough? It should accomplish the AEIOU principles:</p><div class="book"><ul class="itemizedlist"><li class="listitem"><span class="strong"><strong class="calibre2">Automatic</strong></span>: Getting<a id="id566" class="calibre1"/> the feedback should be as painless as possible. Getting it by running just one command is always preferable to having to test your application manually.</li><li class="listitem"><span class="strong"><strong class="calibre2">Extensive</strong></span>: We <a id="id567" class="calibre1"/>should be able to cover as many use cases as possible, including edge cases that are difficult to foresee when writing code.</li><li class="listitem"><span class="strong"><strong class="calibre2">Immediate</strong></span>: You<a id="id568" class="calibre1"/> should get it as soon as possible. This means that the feedback that you get just after introducing a change is way better than the feedback that you get after your code is in production.</li><li class="listitem"><span class="strong"><strong class="calibre2">Open</strong></span>: The results <a id="id569" class="calibre1"/>should be transparent, and also, the tests should give us insight to other developers as to how to integrate or operate with the code.</li><li class="listitem"><span class="strong"><strong class="calibre2">Useful</strong></span>: It should <a id="id570" class="calibre1"/>answer questions such as "Will this change work?", "Will it break the application unexpectedly?", or "Is there any edge case that does not work properly?".</li></ul></div><p class="calibre8">So, even though the concept is quite weird at the beginning, the best way to test your code is… with more code. Exactly! We will write code with the goal of testing the code of our application. Why? Well, it is the best way we know to satisfy all the AEIU principles, and it has the following advantages:</p><div class="book"><ul class="itemizedlist"><li class="listitem">We can execute the tests by just running one command from our command line or even from our favorite IDE. There is no need to manually test your application via a browser continually.</li><li class="listitem">We need to write the test just once. At the beginning, it may be a bit painful, but once the code is written, you will not need to repeat it again and again. This means that after some work, we will be able to test every single case effortlessly. If we had to test it manually, along with all the use cases and edge cases, it would be a nightmare.</li><li class="listitem">You do not need to have the whole application working in order to know whether your code works. Imagine that you are writing your router: in order to know whether it works, you will have to wait until your application works in a browser. Instead, you can write your tests and run them as soon as you finish your class.</li><li class="listitem">When writing your tests, you will be provided with feedback on what is failing. This is very useful to know when a specific function of the router does not work and the reason for the failure, which is better than getting a 500 error on our browser.</li></ul></div><p class="calibre8">We hope that by <a id="id571" class="calibre1"/>now we have sold you on the idea that writing tests is indispensable. This was the easy part, though. The problem is that we know several different approaches. Do we write tests that test the entire application or tests that test specific parts? Do we isolate the tested area from the rest? Do we want to interact with the database or with other external resources while testing? Depending on your answers, you will decide on which type of tests you want to write. Let's discuss the three main approaches that developers agree with:</p><div class="book"><ul class="itemizedlist"><li class="listitem"><span class="strong"><strong class="calibre2">Unit tests</strong></span>: These are <a id="id572" class="calibre1"/>tests that have a very focused scope. Their aim is to <a id="id573" class="calibre1"/>test a single class or method, isolating them from the rest of code. Take your <code class="email">Sale</code> domain class as an example: it has some logic regarding the addition of books, right? A unit test might just instantiate a new sale, add books to the object, and verify that the array of books is valid. Unit tests are super fast due to their reduced scope, so you can have several different scenarios of the same functionality easily, covering all the edge cases you can imagine. They are also isolated, which means that we will not care too much about how all the pieces of our application are integrated. Instead, we will make sure that each piece works perfectly fine.</li><li class="listitem"><span class="strong"><strong class="calibre2">Integration tests</strong></span>: These <a id="id574" class="calibre1"/>are tests with a wider scope. Their aim is to <a id="id575" class="calibre1"/>verify that all the pieces of your application work together, so their scope is not limited to a class or function but rather includes a set of classes or the whole application. There is still some isolation in case we do not want to use a real database or depend on some other external web service. An example in our application would be to simulate a <code class="email">Request</code> object, send it to the router, and verify that the response is as expected.</li><li class="listitem"><span class="strong"><strong class="calibre2">Acceptance tests</strong></span>: These are<a id="id576" class="calibre1"/> tests with an even wider scope. They try to <a id="id577" class="calibre1"/>test a whole functionality from the user's point of view. In web applications, this means that we can launch a browser and simulate the clicks that the user would make, asserting the response in the browser each time. And yes, all of this through code! These tests are slower to run, as you can imagine, because their scope is larger and working with a browser slows them down quite a lot too.</li></ul></div><p class="calibre8">So, with all these types of tests, which one should you write? The answer is all of them. The trick is to know when and how many of each type you should write. One good approach is to write a lot of unit tests, covering absolutely everything in your code, then writing fewer integration tests to make sure that all the components of your application work together, and finally writing acceptance tests but testing only the main flows of your application. The following test<a id="id578" class="calibre1"/> pyramid represents this idea:</p><div class="mediaobject"><img src="../images/00029.jpeg" alt="Types of tests" class="calibre9"/></div><p class="calibre10"> </p><p class="calibre8">The reason is simple: your real feedback will come from your unit tests. They will tell you if you messed up something with your changes as soon as you finish writing them because executing unit tests is easy and fast. Once you know that all your classes and functions behave as expected, you need to verify that they can work together. However, for this, you do not need to test all the edge cases again; you already did this when writing unit tests. Here, you need to write just a few integration tests that confirm that all the pieces communicate properly. Finally, to make sure that not only that the code works but also the user experience is the desired one, we will write acceptance tests that emulate a user going through the different views. Here, tests are very slow and only possible once the flow is complete, so the feedback comes later. We will add acceptance tests to make sure that the main flows work, but we do not need to test every single scenario as we already did this with integration and unit tests.</p></div></div></div>

<div class="book" title="Chapter&#xA0;7.&#xA0;Testing Web Applications">
<div class="book" title="The necessity for tests">
<div class="book" title="Unit tests and code coverage"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_3"><a id="ch07lvl2sec111" class="calibre1"/>Unit tests and code coverage</h2></div></div></div><p class="calibre8">Now that you know what tests are, why <a id="id579" class="calibre1"/>we need them, and which types of tests we have, we will focus the rest of the chapter on writing good unit tests as they will be the ones that will occupy most of your time.</p><p class="calibre8">As we explained before, the idea of a unit test is to make sure that a piece of code, usually a class or method, works as expected. As the amount of code that a method contains should be small, running the test should take almost no time. Taking advantage of this, we will run several tests, trying to cover as many use cases as possible.</p><p class="calibre8">If this is not the first time you've heard about unit tests, you might know the concept of <a id="id580" class="calibre1"/>
<span class="strong"><strong class="calibre2">code coverage</strong></span>. This concept refers to the amount of code that our tests execute, that is, the percentage of tested code. For example, if your application has 10,000 lines and your tests test a total of 7,500 lines, your code coverage is 75%. There are tools that show marks on your code to indicate whether a certain line is tested or not, which is very useful in order to identify which parts of your application are not tested and thus warn you that it is more dangerous to change them.</p><p class="calibre8">However, code coverage is a double-edge sword. Why is this so? This is because developers tend to get obsessed with code coverage, aiming for a 100% coverage. However, you should be aware that code coverage is just a consequence, not your goal. Your goal is to write unit tests that verify all the use cases of certain pieces of code in order to make you feel safer each time that you have to change this code. This means that for a given method, it might not be enough to write one test because the same line with different input values may behave differently. However, if your focus was on code coverage, writing one test would satisfy it, and you might not need to write any more tests.</p></div></div></div>

<div id="page" style="height:0pt"/><div class="book" title="Integrating PHPUnit"><div class="book" id="1TVKI2-edcc22b134104d5db0bf3aa086c86851"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch07lvl1sec59" class="calibre1"/>Integrating PHPUnit</h1></div></div></div><p class="calibre8">Writing tests is a task that you could do by yourself; you just need to write code that throws exceptions when conditions are not met and then run the script any time you need. Luckily, other developers were not satisfied with this manual process, so they implemented tools to help us automate this process and get good feedback. The most used in PHP is <span class="strong"><strong class="calibre2">PHPUnit</strong></span>. PHPUnit is <a id="id581" class="calibre1"/>a framework that provides a set of tools to write tests in an easier manner, gives us the ability to run tests automatically, and delivers useful feedback to the developer.</p><p class="calibre8">In order to use PHPUnit, traditionally, we <a id="id582" class="calibre1"/>installed it on our laptop. In doing so, we added the classes of the framework to include the path of PHP and also the executable to run the tests. This was less than ideal as we forced developers to install one more tool on their development machine. Nowadays, Composer (refer to <a class="calibre1" title="Chapter 6. Adapting to MVC" href="part0056_split_000.html#1LCVG1-edcc22b134104d5db0bf3aa086c86851">Chapter 6</a>, <span class="strong"><em class="calibre12">Adapting to MVC</em></span>, in order to refresh your memory) helps us in including PHPUnit as a dependency of the project. This means that running Composer, which you will do for sure in order to get the rest of the dependencies, will get PHPUnit too. Add, then, the following into <code class="email">composer.json</code>:</p><div class="informalexample"><pre class="programlisting">{
//...
    "require": {
        "monolog/monolog": "^1.17",
        "twig/twig": "^1.23"
    },
<span class="strong"><strong class="calibre2">    "require-dev": {</strong></span>
<span class="strong"><strong class="calibre2">        "phpunit/phpunit": "5.1.3"</strong></span>
<span class="strong"><strong class="calibre2">    },</strong></span>
    "autoload": {
        "psr-4": {
            "Bookstore\\": "src"
        }
    }
}</pre></div><p class="calibre8">Note that this dependency is added as <code class="email">require-dev</code>. This means that the dependency will be downloaded only when we are on a development environment, but it will not be part of the application that we will deploy on production as we do not need to run tests there. To get the dependency, as always, run <code class="email">composer update</code>.</p><p class="calibre8">A different approach <a id="id583" class="calibre1"/>is to install PHPUnit globally so that all the projects on your development environment can use it instead of installing it locally each time. You can read about how to<a id="id584" class="calibre1"/> install tools globally with Composer at <a class="calibre1" href="https://akrabat.com/global-installation-of-php-tools-with-composer/">https://akrabat.com/global-installation-of-php-tools-with-composer/</a>.</p></div>

<div class="book" title="Integrating PHPUnit">
<div class="book" title="The phpunit.xml file"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_1"><a id="ch07lvl2sec112" class="calibre1"/>The phpunit.xml file</h2></div></div></div><p class="calibre8">PHPUnit needs<a id="id585" class="calibre1"/> a <code class="email">phpunit.xml</code> file in order to define the way we want to run the tests. This file defines a set of rules like where the tests are, what code are the tests testing, and so on. Add the following file in your root directory:</p><div class="informalexample"><pre class="programlisting">&lt;?xml version="1.0" encoding="UTF-8"?&gt;

&lt;phpunit backupGlobals="false"
         backupStaticAttributes="false"
         colors="true"
         convertErrorsToExceptions="true"
         convertNoticesToExceptions="true"
         convertWarningsToExceptions="true"
         processIsolation="false"
         stopOnFailure="false"
         syntaxCheck="false"
<span class="strong"><strong class="calibre2">         bootstrap="vendor/autoload.php"</strong></span>
&gt;
&lt;testsuites&gt;
&lt;testsuite name="Bookstore Test Suite"&gt;
<span class="strong"><strong class="calibre2">&lt;directory&gt;./tests/&lt;/directory&gt;</strong></span>
&lt;/testsuite&gt;
&lt;/testsuites&gt;
&lt;filter&gt;
&lt;whitelist&gt;
<span class="strong"><strong class="calibre2">&lt;directory&gt;./src&lt;/directory&gt;</strong></span>
&lt;/whitelist&gt;
&lt;/filter&gt;
&lt;/phpunit&gt;</pre></div><p class="calibre8">This file defines quite<a id="id586" class="calibre1"/> a lot of things. The most important are explained as follows:</p><div class="book"><ul class="itemizedlist"><li class="listitem">Setting <code class="email">convertErrorsToExceptions</code>, <code class="email">convertNoticesToExceptions</code>, and <code class="email">convertWarningsToExceptions</code> to <code class="email">true</code> will make your tests fail if there is a PHP error, warning, or notice. The goal is to make sure that your code does not contain minor errors on edge cases, which are always the source of potential problems.</li><li class="listitem">The <code class="email">stopOnFailure</code> tells PHPUnit whether it should continue executing the rest of tests or not when there is a failed test. In this case, we want to run all of them to know how many tests are failing and why.</li><li class="listitem">The <code class="email">bootstrap</code> defines which file we should execute before starting to run the tests. The most common usage is to include the autoloader, but you could also include a file that initializes some dependencies, such as databases or configuration readers.</li><li class="listitem">The <code class="email">testsuites</code> defines the directories where PHPUnit will look for tests. In our case, we defined <code class="email">./tests</code>, but we could add more if we had them in different directories.</li><li class="listitem">The <code class="email">whitelist</code> defines the list of directories that contain the code that we are testing. This can be useful to generate output related to the code coverage.</li></ul></div><p class="calibre8">When running the tests with PHPUnit, just make sure that you run the command from the same directory where the <code class="email">phpunit.xml</code> file is. We will show you how in the next section.</p></div></div>

<div class="book" title="Integrating PHPUnit">
<div class="book" title="Your first test"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_2"><a id="ch07lvl2sec113" class="calibre1"/>Your first test</h2></div></div></div><p class="calibre8">Right, that's enough preparations and <a id="id587" class="calibre1"/>theory; let's write some code. We will write tests for the basic customer, which is a domain object with little logic. First of all, we need to refactor the <code class="email">Unique</code> trait as it still contains some unnecessary code after integrating our application with MySQL. We are talking about the ability to assign the next available ID, which is now handled by the autoincremental field. Remove it, leaving the code as follows:</p><div class="informalexample"><pre class="programlisting">&lt;?php

namespace Bookstore\Utils;

trait Unique {
    protected $id;

    public function setId(int $id) {
        $this-&gt;id = $id;
    }

    public function getId(): int {
        return $this-&gt;id;
    }
}</pre></div><p class="calibre8">The tests will be inside the <code class="email">tests/</code> directory. The <a id="id588" class="calibre1"/>structure of directories should be the same as in the <code class="email">src/</code> directory so that it is easier to identify where each test should be. The file and the class names need to end with <code class="email">Test</code> so that PHPUnit knows that a file contains tests. Knowing this, our test should be in <code class="email">tests/Domain/Customer/BasicTest.php</code>, as follows:</p><div class="informalexample"><pre class="programlisting">&lt;?php

namespace Bookstore\Tests\Domain\Customer;

use Bookstore\Domain\Customer\Basic;
use PHPUnit_Framework_TestCase;

<span class="strong"><strong class="calibre2">class BasicTest extends PHPUnit_Framework_TestCase {</strong></span>
    public function testAmountToBorrow() {
        $customer = new Basic(1, 'han', 'solo', 'han@solo.com');

<span class="strong"><strong class="calibre2">        $this-&gt;assertSame(</strong></span>
            3,
            $customer-&gt;getAmountToBorrow(),
            'Basic customer should borrow up to 3 books.'
        );
    }
}</pre></div><p class="calibre8">As you can note, the <code class="email">BasicTest</code> class extends from <code class="email">PHPUnit_Framework_TestCase</code>. All test classes have to extend from this class. This class comes with a set of methods that allow you to make assertions. An assertion in PHPUnit is just a check performed on a value. Assertions can be comparisons to other values, a verification of some attributes of the values, and so on. If an assertion is not true, the test will be marked as failed, outputting the proper error message to the developer. The example shows an assertion using the <code class="email">assertSame</code> method, which will compare two values, expecting that both of them are exactly the same. The third argument is an error message that the assertion will show in case it fails.</p><p class="calibre8">Also, note that the function <a id="id589" class="calibre1"/>names that start with <code class="email">test</code> are the ones executed with PHPUnit. In this example, we have one unique test named <code class="email">testAmountToBorrow</code> that instantiates a basic customer and verifies that the amount of books that the customer can borrow is 3. In the next section, we will show you how to run this test and get feedback from it.</p><p class="calibre8">Optionally, you could use any function name if you add the <code class="email">@test</code> annotation in the method's DocBlock, as follows:</p><div class="informalexample"><pre class="programlisting">/**
<span class="strong"><strong class="calibre2"> * @test</strong></span>
 */
<span class="strong"><strong class="calibre2">public function thisIsATestToo() {</strong></span>
  //...
}</pre></div></div></div>

<div class="book" title="Integrating PHPUnit">
<div class="book" title="Running tests"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_3"><a id="ch07lvl2sec114" class="calibre1"/>Running tests</h2></div></div></div><p class="calibre8">In order to run the<a id="id590" class="calibre1"/> tests you wrote, you need to execute the script that Composer generated in <code class="email">vendor/bin</code>. Remember always to run from the root directory of the project so that PHPUnit can find your <code class="email">phpunit.xml</code> configuration file. Then, type <code class="email">./vendor/bin/phpunit</code>.</p><div class="mediaobject"><img src="../images/00030.jpeg" alt="Running tests" class="calibre9"/></div><p class="calibre10"> </p><p class="calibre8">When executing this program, we will get the feedback given by the tests. The output shows us that there is one test (one method) and one assertion and whether these were satisfactory. This output is what you would like to see every time you run your tests, but you will get more failed tests than you would like. Let's take a look at them by adding the following test:</p><div class="informalexample"><pre class="programlisting">public function testFail() {
    $customer = new Basic(1, 'han', 'solo', 'han@solo.com');

    $this-&gt;assertSame(
        4,
        $customer-&gt;getAmountToBorrow(),
        'Basic customer should borrow up to 3 books.'
    );
}</pre></div><p class="calibre8">This test will fail as we <a id="id591" class="calibre1"/>are checking whether <code class="email">getAmountToBorrow</code> returns 4, but you know that it always returns 3. Let's run the tests and take a look at what kind of output we get.</p><div class="mediaobject"><img src="../images/00031.jpeg" alt="Running tests" class="calibre9"/></div><p class="calibre10"> </p><p class="calibre8">We can quickly note that the output is not good due to the red color. It shows us that there is a failure, pointing to the class and test method that failed. The feedback points out the type of failure (as 3 is not identical to 4) and optionally, the error message we added when <a id="id592" class="calibre1"/>invoking the <code class="email">assert</code> method.</p></div></div>

<div id="page" style="height:0pt"/><div class="book" title="Writing unit tests"><div class="book" id="1UU542-edcc22b134104d5db0bf3aa086c86851"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch07lvl1sec60" class="calibre1"/>Writing unit tests</h1></div></div></div><p class="calibre8">Let's start digging<a id="id593" class="calibre1"/> into all the features that PHPUnit offers us in order to write tests. We will divide these features in different subsections: setting up a test, assertions, exceptions, and data providers. Of course, you do not need to use all of these tools each time you write a test.</p></div>

<div class="book" title="Writing unit tests">
<div class="book" title="The start and end of a test"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_1"><a id="ch07lvl2sec115" class="calibre1"/>The start and end of a test</h2></div></div></div><p class="calibre8">PHPUnit gives<a id="id594" class="calibre1"/> you the opportunity to set up a common scenario for each test in a <a id="id595" class="calibre1"/>class. For this, you need to use the <code class="email">setUp</code> method, which, if present, is executed each time that a test of this class is executed. The instance of the class that invokes the <code class="email">setUp</code> and <code class="email">test</code> methods is the same, so you can use the properties of the class to save the context. One common use would be to create the object that we will use for our tests in case this is always the same. For an example, write the following code in <code class="email">tests/Domain/Customer/BasicTest.php</code>:</p><div class="informalexample"><pre class="programlisting">&lt;?php

namespace Bookstore\Tests\Domain\Customer;

use Bookstore\Domain\Customer\Basic;
use PHPUnit_Framework_TestCase;

class BasicTest extends PHPUnit_Framework_TestCase {
    private $customer;

<span class="strong"><strong class="calibre2">    public function setUp() {</strong></span>
<span class="strong"><strong class="calibre2">        $this-&gt;customer = new Basic(</strong></span>
<span class="strong"><strong class="calibre2">            1, 'han', 'solo', 'han@solo.com'</strong></span>
<span class="strong"><strong class="calibre2">        );</strong></span>
<span class="strong"><strong class="calibre2">    }</strong></span>

    public function testAmountToBorrow() {
        $this-&gt;assertSame(
            3,
            $this-&gt;customer-&gt;getAmountToBorrow(),
            'Basic customer should borrow up to 3 books.'
        );
    }
}</pre></div><p class="calibre8">When <code class="email">testAmountToBorrow</code> is invoked, the <code class="email">$customer</code> property is already initialized through the execution of the <code class="email">setUp</code> method. If the class had more than one test, the <code class="email">setUp</code> method would be executed each time.</p><p class="calibre8">Even though it is less common to use, there is another method used to clean up the scenario after the test is executed: <code class="email">tearDown</code>. This works in the same way, but it is executed after each <a id="id596" class="calibre1"/>test of this class is executed. Possible uses would be to clean up <a id="id597" class="calibre1"/>database data, close connections, delete files, and so on.</p></div></div>

<div class="book" title="Writing unit tests">
<div class="book" title="Assertions"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_2"><a id="ch07lvl2sec116" class="calibre1"/>Assertions</h2></div></div></div><p class="calibre8">You have already been introduced to the <a id="id598" class="calibre1"/>concept of assertions, so let's just list the most common ones in this section. For the full list, we recommend you to visit the official<a id="id599" class="calibre1"/> documentation at <a class="calibre1" href="https://phpunit.de/manual/current/en/appendixes.assertions.html">https://phpunit.de/manual/current/en/appendixes.assertions.html</a> as it is quite extensive; however, to be honest, you will probably not use many of them.</p><p class="calibre8">The first type of assertion that we will see is the Boolean assertion, that is, the one that checks whether a value is <code class="email">true</code> or <code class="email">false</code>. The methods are as simple as <code class="email">assertTrue</code> and <code class="email">assertFalse</code>, and they expect one parameter, which is the value to assert, and optionally, a text to display in case of failure. In the same <code class="email">BasicTest</code> class, add the following test:</p><div class="informalexample"><pre class="programlisting">public function testIsExemptOfTaxes() {
<span class="strong"><strong class="calibre2">    $this-&gt;assertFalse(</strong></span>
<span class="strong"><strong class="calibre2">        $this-&gt;customer-&gt;isExemptOfTaxes(),</strong></span>
<span class="strong"><strong class="calibre2">        'Basic customer should be exempt of taxes.'</strong></span>
<span class="strong"><strong class="calibre2">    );</strong></span>
}</pre></div><p class="calibre8">This test makes sure that a basic customer is never exempt of taxes. Note that we could do the same assertion by writing the following:</p><div class="informalexample"><pre class="programlisting">$this-&gt;assertSame(
    $this-&gt;customer-&gt;isExemptOfTaxes(),
    false,
    'Basic customer should be exempt of taxes.'
);</pre></div><p class="calibre8">A second group of assertions would be the comparison assertions. The most famous ones are <code class="email">assertSame</code> and <code class="email">assertEquals</code>. You have already used the first one, but are you sure of its meaning? Let's add another test and run it:</p><div class="informalexample"><pre class="programlisting">public function testGetMonthlyFee() {
<span class="strong"><strong class="calibre2">    $this-&gt;assertSame(</strong></span>
<span class="strong"><strong class="calibre2">        5,</strong></span>
<span class="strong"><strong class="calibre2">        $this-&gt;customer-&gt;getMonthlyFee(),</strong></span>
<span class="strong"><strong class="calibre2">        'Basic customer should pay 5 a month.'</strong></span>
<span class="strong"><strong class="calibre2">    );</strong></span>
}</pre></div><p class="calibre8">The result of the test is <a id="id600" class="calibre1"/>shown in the following screenshot:</p><div class="mediaobject"><img src="../images/00032.jpeg" alt="Assertions" class="calibre9"/></div><p class="calibre10"> </p><p class="calibre8">The test failed! The reason is that <code class="email">assertSame</code> is the equivalent to comparing using identity, that is, without using type juggling. The result of the <code class="email">getMonthlyFee</code> method is always a float, and we will compare it with an integer, so it will never be the same, as the error message tells us. Change the assertion to <code class="email">assertEquals</code>, which compares using equality, and the test will pass now.</p><p class="calibre8">When working with objects, we can use an assertion to check whether a given object is an instance of the expected class or not. When doing so, remember to send the full name of the class as this is a quite common mistake. Even better, you could get the class name using <code class="email">::class</code>, for example, <code class="email">Basic::class</code>. Add the following test in <code class="email">tests/Domain/Customer/CustomerFactoryTest.php</code>:</p><div class="informalexample"><pre class="programlisting">&lt;?php

namespace Bookstore\Tests\Domain\Customer;

use Bookstore\Domain\Customer\CustomerFactory;
use PHPUnit_Framework_TestCase;

class CustomerFactoryTest extends PHPUnit_Framework_TestCase {
    public function testFactoryBasic() {
        $customer = CustomerFactory::factory(
            'basic', 1, 'han', 'solo', 'han@solo.com'
        );

<span class="strong"><strong class="calibre2">        $this-&gt;assertInstanceOf(</strong></span>
<span class="strong"><strong class="calibre2">Basic::class,</strong></span>
<span class="strong"><strong class="calibre2">            $customer,</strong></span>
<span class="strong"><strong class="calibre2">            'basic should create a Customer\Basic object.'</strong></span>
<span class="strong"><strong class="calibre2">        );</strong></span>
    }
}</pre></div><p class="calibre8">This test creates a <a id="id601" class="calibre1"/>customer using the <code class="email">customer</code> factory. As the type of customer was <code class="email">basic</code>, the result should be an instance of <code class="email">Basic</code>, which is what we are testing with <code class="email">assertInstanceOf</code>. The first argument is the expected class, the second is the object that we are testing, and the third is the error message. This test also helps us to note the behavior of comparison assertions with objects. Let's create a basic <code class="email">customer</code> object as expected and compare it with the result of the factory. Then, run the test, as follows:</p><div class="informalexample"><pre class="programlisting">$expectedBasicCustomer = new Basic(1, 'han', 'solo', 'han@solo.com');

<span class="strong"><strong class="calibre2">$this-&gt;assertSame(</strong></span>
    $customer,
    $expectedBasicCustomer,
    'Customer object is not as expected.'
);</pre></div><p class="calibre8">The result of this test is shown in the following screenshot:</p><div class="mediaobject"><img src="../images/00033.jpeg" alt="Assertions" class="calibre9"/></div><p class="calibre10"> </p><p class="calibre8">The test failed because <a id="id602" class="calibre1"/>when you compare two objects with identity comparison, you comparing the object reference, and it will only be the same if the two objects are exactly the same instance. If you create two objects with the same properties, they will be equal but never identical. To fix the test, change the assertion as follows:</p><div class="informalexample"><pre class="programlisting">$expectedBasicCustomer = new Basic(1, 'han', 'solo', 'han@solo.com');

<span class="strong"><strong class="calibre2">$this-&gt;assertEquals(</strong></span>
    $customer,
    $expectedBasicCustomer,
    'Customer object is not as expected.'
);</pre></div><p class="calibre8">Let's now write the tests for the <code class="email">sale</code> domain object at <code class="email">tests/Domain/SaleTest.php</code>. This class is very easy to test and allows us to use some new assertions, as follows:</p><div class="informalexample"><pre class="programlisting">&lt;?php

namespace Bookstore\Tests\Domain\Customer;

use Bookstore\Domain\Sale;
use PHPUnit_Framework_TestCase;

class SaleTest extends PHPUnit_Framework_TestCase {
    public function testNewSaleHasNoBooks() {
        $sale = new Sale();

<span class="strong"><strong class="calibre2">        $this-&gt;assertEmpty(</strong></span>
<span class="strong"><strong class="calibre2">            $sale-&gt;getBooks(),</strong></span>
<span class="strong"><strong class="calibre2">            'When new, sale should have no books.'</strong></span>
<span class="strong"><strong class="calibre2">        );</strong></span>
    }

    public function testAddNewBook() {
        $sale = new Sale();
        $sale-&gt;addBook(123);

<span class="strong"><strong class="calibre2">        $this-&gt;assertCount(</strong></span>
<span class="strong"><strong class="calibre2">            1,</strong></span>
<span class="strong"><strong class="calibre2">            $sale-&gt;getBooks(),</strong></span>
<span class="strong"><strong class="calibre2">            'Number of books not valid.'</strong></span>
<span class="strong"><strong class="calibre2">        );</strong></span>
<span class="strong"><strong class="calibre2">        $this-&gt;assertArrayHasKey(</strong></span>
<span class="strong"><strong class="calibre2">            123,</strong></span>
<span class="strong"><strong class="calibre2">            $sale-&gt;getBooks(),</strong></span>
<span class="strong"><strong class="calibre2">            'Book id could not be found in array.'</strong></span>
<span class="strong"><strong class="calibre2">        );</strong></span>
        $this-&gt;assertSame(
            $sale-&gt;getBooks()[123],
            1,
            'When not specified, amount of books is 1.'
        );
    }
}</pre></div><p class="calibre8">We added two tests <a id="id603" class="calibre1"/>here: one makes sure that for a new <code class="email">sale</code> instance, the list of books associated with it is empty. For this, we used the <code class="email">assertEmpty</code> method, which takes an array as an argument and will assert that it is empty. The second test is adding a book to the sale and then making sure that the list of books has the correct content. For this, we will use the <code class="email">assertCount</code> method, which verifies that the array, that is, the second argument, has as many elements as the first argument provided. In this case, we expect that the list of books has only one entry. The second assertion of this test is verifying that the array of books contains a specific key, which is the ID of the book, with the <code class="email">assertArrayHasKey</code> method, in which the first argument is the key, and the second one is the array. Finally, we will check with the already known <code class="email">assertSame</code> method that the amount of books inserted is 1.</p><p class="calibre8">Even though these two new assertion methods are useful sometimes, all the three assertions of the last test can be replaced by just an <code class="email">assertSame</code> method, comparing the whole array of books with the expected one, as follows:</p><div class="informalexample"><pre class="programlisting">$this-&gt;assertSame(
    [123 =&gt; 1],
    $sale-&gt;getBooks(),
    'Books array does not match.'
);</pre></div><p class="calibre8">The suite of tests for the <code class="email">sale</code> domain object would not be enough if we were not testing how the class behaves when adding multiple books. In this case, using <code class="email">assertCount</code> and <code class="email">assertArrayHasKey</code> would make the test unnecessarily long, so let's just compare the array with an expected one <a id="id604" class="calibre1"/>via the following code:</p><div class="informalexample"><pre class="programlisting">public function testAddMultipleBooks() {
    $sale = new Sale();
    $sale-&gt;addBook(123, 4);
    $sale-&gt;addBook(456, 2);
    $sale-&gt;addBook(456, 8);

    $this-&gt;assertSame(
        [123 =&gt; 4, 456 =&gt; 10],
        $sale-&gt;getBooks(),
        'Books are not as expected.'
    );
}</pre></div></div></div>

<div class="book" title="Writing unit tests">
<div class="book" title="Expecting exceptions"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_3"><a id="ch07lvl2sec117" class="calibre1"/>Expecting exceptions</h2></div></div></div><p class="calibre8">Sometimes, a <a id="id605" class="calibre1"/>method is expected to throw an exception for certain unexpected use cases. When this happens, you could try to capture this exception inside the test or take advantage of another tool that PHPUnit offers: <span class="strong"><strong class="calibre2">expecting exceptions</strong></span>. To mark a test to expect a given exception, just add the <code class="email">@expectedException</code> annotation followed by the exception's class full name. Optionally, you can use <code class="email">@expectedExceptionMessage</code> to assert the message of the exception. Let's add the following tests to our <code class="email">CustomerFactoryTest</code> class:</p><div class="informalexample"><pre class="programlisting">/**
<span class="strong"><strong class="calibre2"> * @expectedException \InvalidArgumentException</strong></span>
<span class="strong"><strong class="calibre2"> * @expectedExceptionMessage Wrong type.</strong></span>
 */
public function testCreatingWrongTypeOfCustomer() {
    $customer = CustomerFactory::factory(
        'deluxe', 1, 'han', 'solo', 'han@solo.com'

   );
}</pre></div><p class="calibre8">In this test we will try to create a deluxe customer with our factory, but as this type of customer does not exist, we will get an exception. The type of the expected exception is <code class="email">InvalidArgumentException</code>, and the error message is "Wrong type". If you run the tests, you will see that they pass.</p><p class="calibre8">If we defined an expected exception and the exception is never thrown, the test will fail; expecting exceptions is just another type of assertion. To see this happen, add the following to your test and run it; you will get a failure, and PHPUnit will complain saying that it expected the<a id="id606" class="calibre1"/> exception, but it was never thrown:</p><div class="informalexample"><pre class="programlisting">/**
 * @expectedException \InvalidArgumentException
 */
public function testCreatingCorrectCustomer() {
    $customer = CustomerFactory::factory(
        'basic', 1, 'han', 'solo', 'han@solo.com'
    );
}</pre></div></div></div>

<div class="book" title="Writing unit tests">
<div class="book" title="Data providers"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_4"><a id="ch07lvl2sec118" class="calibre1"/>Data providers</h2></div></div></div><p class="calibre8">If you think about the flow of a<a id="id607" class="calibre1"/> test, most of the time, we invoke a method with an input and expect an output. In order to cover all the edge cases, it is natural that we will repeat the same action with a set of inputs and expected outputs. PHPUnit gives us the ability to do so, thus removing a lot of duplicated code. This feature is called<a id="id608" class="calibre1"/> <span class="strong"><strong class="calibre2">data providing</strong></span>.</p><p class="calibre8">A data provider is a public method defined in the <code class="email">test</code> class that returns an array with a specific schema. Each entry of the array represents a test in which the key is the name of the test—optionally, you could use numeric keys—and the value is the parameter that the test needs. A test will declare that it needs a data provider with the <code class="email">@dataProvider</code> annotation, and when executing tests, the data provider injects the arguments that the test method needs. Let's consider an example to make it easier. Write the following two methods in your <code class="email">CustomerFactoryTest</code> class:</p><div class="informalexample"><pre class="programlisting">public function providerFactoryValidCustomerTypes() {
    return [
        'Basic customer, lowercase' =&gt; [
            'type' =&gt; 'basic',
            'expectedType' =&gt; '\Bookstore\Domain\Customer\Basic'
        ],
        'Basic customer, uppercase' =&gt; [
            'type' =&gt; 'BASIC',
            'expectedType' =&gt; '\Bookstore\Domain\Customer\Basic'
        ],
        'Premium customer, lowercase' =&gt; [
            'type' =&gt; 'premium',
            'expectedType' =&gt; '\Bookstore\Domain\Customer\Premium'
        ],
        'Premium customer, uppercase' =&gt; [
            'type' =&gt; 'PREMIUM',
            'expectedType' =&gt; '\Bookstore\Domain\Customer\Premium'
        ]
    ];
}

/**
<span class="strong"><strong class="calibre2"> * @dataProvider providerFactoryValidCustomerTypes</strong></span>
 * @param string $type
 * @param string $expectedType
 */
public function testFactoryValidCustomerTypes(
<span class="strong"><strong class="calibre2">    string $type,</strong></span>
<span class="strong"><strong class="calibre2">    string $expectedType</strong></span>
) {
    $customer = CustomerFactory::factory(
        $type, 1, 'han', 'solo', 'han@solo.com'
    );
    $this-&gt;assertInstanceOf(
        $expectedType,
        $customer,
        'Factory created the wrong type of customer.'
    );
}</pre></div><p class="calibre8">The test here is <code class="email">testFactoryValidCustomerTypes</code>, which expects two arguments: <code class="email">$type</code> and <code class="email">$expectedType</code>. The <a id="id609" class="calibre1"/>test uses them to create a customer with the factory and verify the type of the result, which we already did by hardcoding the types. The test also declares that it needs the <code class="email">providerFactoryValidCustomerTypes</code> data provider. This data provider returns an array of four entries, which means that the test will be executed four times with four different sets of arguments. The name of each test is the key of each entry—for example, "Basic customer, lowercase". This is very useful in case a test fails because it will be displayed as part of the error messages. Each entry is a map with two values, <code class="email">type</code> and <code class="email">expectedType</code>, which are the names of the arguments of the <code class="email">test</code> method. The values of these entries are the values that the <code class="email">test</code> method will get.</p><p class="calibre8">The bottom line is that the code we wrote would be the same as if we wrote <code class="email">testFactoryValidCustomerTypes</code> four times, hardcoding <code class="email">$type</code> and <code class="email">$expectedType</code> each time. Imagine now that the <code class="email">test</code> method contains tens of lines of code or we want to repeat the same test with tens of datasets; do<a id="id610" class="calibre1"/> you see how powerful it is?</p></div></div>

<div id="page" style="height:0pt"/><div class="book" title="Testing with doubles"><div class="book" id="1VSLM2-edcc22b134104d5db0bf3aa086c86851"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch07lvl1sec61" class="calibre1"/>Testing with doubles</h1></div></div></div><p class="calibre8">So far, we tested classes that are<a id="id611" class="calibre1"/> quite isolated; that is, they do not have much interaction with other classes. Nevertheless, we have classes that use several classes, such as controllers. What can we do with these interactions? The idea of unit tests is to test a specific method and not the whole code base, right?</p><p class="calibre8">PHPUnit allows you to mock these dependencies; that is, you can provide fake objects that look similar to the dependencies that the tested class needs, but they do not use code from those classes. The goal of this is to provide a dummy instance that the class can use and invoke its methods without the side effect of what these invocations might have. Imagine as an example the case of the models: if the controller uses a real model, then when invoking methods from it, the model would access the database each time, making the tests quite unpredictable.</p><p class="calibre8">If we use a mock as the model instead, the controller can invoke its methods as many times as needed without any side effect. Even better, we can make assertions of the arguments that the mock received or force it to return specific values. Let's take a look at how to use them.</p></div>

<div class="book" title="Testing with doubles">
<div class="book" title="Injecting models with DI"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_1"><a id="ch07lvl2sec119" class="calibre1"/>Injecting models with DI</h2></div></div></div><p class="calibre8">The first thing we<a id="id612" class="calibre1"/> need to understand is that if we create objects using<a id="id613" class="calibre1"/> <code class="email">new</code> inside the controller, we will not be able to mock them. This means that we need to inject all the dependencies—for example, using a dependency injector. We will do this for all of the dependencies but one: the models. In this section, we will test the <code class="email">borrow</code> method of the <code class="email">BookController</code> class, so we will show the changes that this method needs. Of course, if you want to test the rest of the code, you should apply these same changes to the rest of the controllers.</p><p class="calibre8">The first thing to do is to add the <code class="email">BookModel</code> instance to the dependency injector in our <code class="email">index.php</code> file. As this class also has a dependency, <code class="email">PDO</code>, use the same dependency injector to get an instance of it, as follows:</p><div class="informalexample"><pre class="programlisting">$di-&gt;set('BookModel', new BookModel($di-&gt;get('PDO')));</pre></div><p class="calibre8">Now, in the <code class="email">borrow</code> method of the <code class="email">BookController</code> class, we will change the new instantiation of the model to the following:</p><div class="informalexample"><pre class="programlisting">public function borrow(int $bookId): string {
<span class="strong"><strong class="calibre2">    $bookModel = $this-&gt;di-&gt;get('BookModel');</strong></span>

    try {
//...</pre></div></div></div>

<div class="book" title="Testing with doubles">
<div class="book" title="Customizing TestCase"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_2"><a id="ch07lvl2sec120" class="calibre1"/>Customizing TestCase</h2></div></div></div><p class="calibre8">When writing your<a id="id614" class="calibre1"/> unit test's suite, it is quite common to have a customized <code class="email">TestCase</code> class from which all tests extend. This class always extends from <code class="email">PHPUnit_Framework_TestCase</code>, so we still get all the assertions and other methods. As all tests have to import this class, let's change our autoloader so that it can recognize namespaces from the <code class="email">tests</code> directory. After this, run <code class="email">composer update</code>, as follows:</p><div class="informalexample"><pre class="programlisting">"autoload": {
    "psr-4": {
<span class="strong"><strong class="calibre2">        "Bookstore\\Tests\\": "tests",</strong></span>
        "Bookstore\\": "src"
    }
}</pre></div><p class="calibre8">With this change, we will tell Composer that all the namespaces starting with <code class="email">Bookstore\Tests</code> will be located under the <code class="email">tests</code> directory, and the rest will follow the previous rules.</p><p class="calibre8">Let's add now our customized <code class="email">TestCase</code> class. The only helper method we need right now is one to create mocks. It is not really necessary, but it makes things cleaner. Add the following class in <code class="email">tests/AbstractTestClase.php</code>:</p><div class="informalexample"><pre class="programlisting">&lt;?php

namespace Bookstore\Tests;

use PHPUnit_Framework_TestCase;
use InvalidArgumentException;

abstract class AbstractTestCase extends PHPUnit_Framework_TestCase {
    protected function mock(string $className) {
        if (strpos($className, '\\') !== 0) {
            $className = '\\' . $className;
        }

        if (!class_exists($className)) {
            $className = '\Bookstore\\' . trim($className, '\\');

            if (!class_exists($className)) {
                throw new InvalidArgumentException(
                    "Class $className not found."
                );
            }
        }

        return $this-&gt;getMockBuilder($className)
            -&gt;disableOriginalConstructor()
            -&gt;getMock();
    }
}</pre></div><p class="calibre8">This method takes the <a id="id615" class="calibre1"/>name of a class and tries to figure out whether the class is part of the <code class="email">Bookstore</code> namespace or not. This will be handy when mocking objects of our own codebase as we will not have to write <code class="email">Bookstore</code> each time. After figuring out what the real full class name is, it uses the mock builder from PHPUnit to create one and then returns it.</p><p class="calibre8">More helpers! This time, they are for controllers. Every single controller will always need the same dependencies: logger, database connection, template engine, and configuration reader. Knowing this, let's create a <code class="email">ControllerTestCase</code> class from where all the tests covering controllers will extend. This class will contain a <code class="email">setUp</code> method that creates all the common mocks and sets them in the dependency injector. Add it as your <code class="email">tests/ControllerTestCase.php</code> file, as follows:</p><div class="informalexample"><pre class="programlisting">&lt;?php

namespace Bookstore\Tests;

use Bookstore\Utils\DependencyInjector;
use Bookstore\Core\Config;
use Monolog\Logger;
use Twig_Environment;
use PDO;

abstract class ControllerTestCase extends AbstractTestCase {
    protected $di;

    public function setUp() {
        $this-&gt;di = new DependencyInjector();
        $this-&gt;di-&gt;set('PDO', $this-&gt;mock(PDO::class));
        $this-&gt;di-&gt;set('Utils\Config', $this-&gt;mock(Config::class));
        $this-&gt;di-&gt;set(
            'Twig_Environment',
            $this-&gt;mock(Twig_Environment::class)
        );
        $this-&gt;di-&gt;set('Logger', $this-&gt;mock(Logger::class));
    }
}</pre></div></div></div>

<div class="book" title="Testing with doubles">
<div class="book" title="Using mocks"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_3"><a id="ch07lvl2sec121" class="calibre1"/>Using mocks</h2></div></div></div><p class="calibre8">Well, we've had enough of the<a id="id616" class="calibre1"/> helpers; let's start with the tests. The difficult part here is how to play with mocks. When you create one, you can add some expectations and return values. The methods are:</p><div class="book"><ul class="itemizedlist"><li class="listitem"><code class="email">expects</code>: This specifies the amount of times the mock's method is invoked. You can send <code class="email">$this-&gt;never()</code>, <code class="email">$this-&gt;once()</code>, or <code class="email">$this-&gt;any()</code> as an argument to specify 0, 1, or any invocations.</li><li class="listitem"><code class="email">method</code>: This is used to specify the method we are talking about. The argument that it expects is just the name of the method.</li><li class="listitem"><code class="email">with</code>: This is a method used to set the expectations of the arguments that the mock will receive when it is invoked. For example, if the mocked method is expected to get <code class="email">basic</code> as the first argument and <code class="email">123</code> as the second, the <code class="email">with</code> method will be invoked as <code class="email">with("basic", 123)</code>. This method is optional, but if we set it, PHPUnit will throw an error in case the mocked method does not get the expected arguments, so it works as an assertion.</li><li class="listitem"><code class="email">will</code>: This is used to define what the mock will return. The two most common usages are <code class="email">$this-&gt;returnValue($value)</code> or <code class="email">$this-&gt;throwException($exception)</code>. This method is also optional, and if not invoked, the mock will always return null.</li></ul></div><p class="calibre8">Let's add the first test to see how it would work. Add the following code to the <code class="email">tests/Controllers/BookControllerTest.php</code> file:</p><div class="informalexample"><pre class="programlisting">&lt;?php

namespace Bookstore\Tests\Controllers;

use Bookstore\Controllers\BookController;
use Bookstore\Core\Request;
use Bookstore\Exceptions\NotFoundException;
use Bookstore\Models\BookModel;
use Bookstore\Tests\ControllerTestCase;
use Twig_Template;

class BookControllerTest extends ControllerTestCase {
    private function getController(
        Request $request = null
    ): BookController {
        if ($request === null) {
            $request = $this-&gt;mock('Core\Request');
        }
        return new BookController($this-&gt;di, $request);
    }

    public function testBookNotFound() {
        $bookModel = $this-&gt;mock(BookModel::class);
<span class="strong"><strong class="calibre2">        $bookModel</strong></span>
<span class="strong"><strong class="calibre2">            -&gt;expects($this-&gt;once())</strong></span>
<span class="strong"><strong class="calibre2">            -&gt;method('get')</strong></span>
<span class="strong"><strong class="calibre2">            -&gt;with(123)</strong></span>
<span class="strong"><strong class="calibre2">            -&gt;will(</strong></span>
<span class="strong"><strong class="calibre2">                $this-&gt;throwException(</strong></span>
<span class="strong"><strong class="calibre2">                    new NotFoundException()</strong></span>
<span class="strong"><strong class="calibre2">                )</strong></span>
<span class="strong"><strong class="calibre2">            );</strong></span>
        $this-&gt;di-&gt;set('BookModel', $bookModel);

        $response = "Rendered template";
        $template = $this-&gt;mock(Twig_Template::class);
<span class="strong"><strong class="calibre2">        $template</strong></span>
<span class="strong"><strong class="calibre2">            -&gt;expects($this-&gt;once())</strong></span>
<span class="strong"><strong class="calibre2">            -&gt;method('render')</strong></span>
<span class="strong"><strong class="calibre2">            -&gt;with(['errorMessage' =&gt; 'Book not found.'])</strong></span>
<span class="strong"><strong class="calibre2">            -&gt;will($this-&gt;returnValue($response));</strong></span>
<span class="strong"><strong class="calibre2">        $this-&gt;di-&gt;get('Twig_Environment')</strong></span>
<span class="strong"><strong class="calibre2">            -&gt;expects($this-&gt;once())</strong></span>
<span class="strong"><strong class="calibre2">            -&gt;method('loadTemplate')</strong></span>
<span class="strong"><strong class="calibre2">            -&gt;with('error.twig')</strong></span>
<span class="strong"><strong class="calibre2">            -&gt;will($this-&gt;returnValue($template));</strong></span>

        $result = $this-&gt;getController()-&gt;borrow(123);

        $this-&gt;assertSame(
            $result,
            $response,
            'Response object is not the expected one.'
        );
    }
}</pre></div><p class="calibre8">The first thing the test does<a id="id617" class="calibre1"/> is to create a mock of the <code class="email">BookModel</code> class. Then, it adds an expectation that goes like this: the <code class="email">get</code> method will be called once with one argument, <code class="email">123</code>, and it will throw <code class="email">NotFoundException</code>. This makes sense as the test tries to emulate a scenario in which we cannot find the book in the database.</p><p class="calibre8">The second part of the test consists of adding the expectations of the template engine. This is a bit more complex as there are two mocks involved. The <code class="email">loadTemplate</code> method of <code class="email">Twig_Environment</code> is expected to be called once with the <code class="email">error.twig</code> argument as the template name. This mock should return <code class="email">Twig_Template</code>, which is another mock. The <code class="email">render</code> method of this second mock is expected to be called once with the correct error message, returning the response, which is a hardcoded string. After all the dependencies are defined, we just need to invoke the <code class="email">borrow</code> method of the controller and expect a response.</p><p class="calibre8">Remember that this test does not have only one assertion, but four: the <code class="email">assertSame</code> method and the three mock expectations. If any of them are not accomplished, the test will fail, so we can say that this method is quite robust.</p><p class="calibre8">With our first test, we<a id="id618" class="calibre1"/> verified that the scenario in which the book is not found works. There are two more scenarios that fail as well: when there are not enough copies of the book to borrow and when there is a database error when trying to save the borrowed book. However, you can see now that all of them share a piece of code that mocks the template. Let's extract this code to a <code class="email">protected</code> method that generates the mocks when it is given the template name, the parameters are sent to the template, and the expected response is received. Run the following:</p><div class="informalexample"><pre class="programlisting">protected function mockTemplate(
    string $templateName,
    array $params,
    $response
) {
    $template = $this-&gt;mock(Twig_Template::class);
    $template
        -&gt;expects($this-&gt;once())
        -&gt;method('render')
        -&gt;with($params)
        -&gt;will($this-&gt;returnValue($response));
    $this-&gt;di-&gt;get('Twig_Environment')
        -&gt;expects($this-&gt;once())
        -&gt;method('loadTemplate')
        -&gt;with($templateName)
        -&gt;will($this-&gt;returnValue($template));
}

public function testNotEnoughCopies() {
    $bookModel = $this-&gt;mock(BookModel::class);
    $bookModel
        -&gt;expects($this-&gt;once())
        -&gt;method('get')
        -&gt;with(123)
        -&gt;will($this-&gt;returnValue(new Book()));
<span class="strong"><strong class="calibre2">    $bookModel</strong></span>
<span class="strong"><strong class="calibre2">        -&gt;expects($this-&gt;never())</strong></span>
<span class="strong"><strong class="calibre2">        -&gt;method('borrow');</strong></span>
    $this-&gt;di-&gt;set('BookModel', $bookModel);

    $response = "Rendered template";
    $this-&gt;mockTemplate(
        'error.twig',
        ['errorMessage' =&gt; 'There are no copies left.'],
        $response
    );

    $result = $this-&gt;getController()-&gt;borrow(123);

    $this-&gt;assertSame(
        $result,
        $response,
        'Response object is not the expected one.'
    );
}

public function testErrorSaving() {
    $controller = $this-&gt;getController();
    $controller-&gt;setCustomerId(9);

    $book = new Book();
    $book-&gt;addCopy();
    $bookModel = $this-&gt;mock(BookModel::class);
    $bookModel
        -&gt;expects($this-&gt;once())
        -&gt;method('get')
        -&gt;with(123)
        -&gt;will($this-&gt;returnValue($book));
    $bookModel
        -&gt;expects($this-&gt;once())
        -&gt;method('borrow')
        -&gt;with(new Book(), 9)
        -&gt;will($this-&gt;throwException(new DbException()));
    $this-&gt;di-&gt;set('BookModel', $bookModel);

    $response = "Rendered template";
    $this-&gt;mockTemplate(
        'error.twig',
        ['errorMessage' =&gt; 'Error borrowing book.'],
        $response
    );

    $result = $controller-&gt;borrow(123);

    $this-&gt;assertSame(
        $result,
        $response,
        'Response object is not the expected one.'
    );
}</pre></div><p class="calibre8">The only novelty here is when we expect that the <code class="email">borrow</code> method is never invoked. As we do not expect it to be invoked, there is no reason to use the <code class="email">with</code> nor <code class="email">will</code> method. If the code actually invokes this method, PHPUnit will mark the test as failed.</p><p class="calibre8">We already tested and found that all the scenarios that can fail have failed. Let's add a test now where a user can successfully borrow a book, which means that we will return valid books and customers from the database, the <code class="email">save</code> method will be invoked correctly, and the template will get all the<a id="id619" class="calibre1"/> correct parameters. The test looks as follows:</p><div class="informalexample"><pre class="programlisting">public function testBorrowingBook() {
    $controller = $this-&gt;getController();
    $controller-&gt;setCustomerId(9);

    $book = new Book();
    $book-&gt;addCopy();
    $bookModel = $this-&gt;mock(BookModel::class);
    $bookModel
        -&gt;expects($this-&gt;once())
        -&gt;method('get')
        -&gt;with(123)
        -&gt;will($this-&gt;returnValue($book));
    $bookModel
        -&gt;expects($this-&gt;once())
        -&gt;method('borrow')
        -&gt;with(new Book(), 9);
    $bookModel
        -&gt;expects($this-&gt;once())
        -&gt;method('getByUser')
        -&gt;with(9)
        -&gt;will($this-&gt;returnValue(['book1', 'book2']));
    $this-&gt;di-&gt;set('BookModel', $bookModel);

    $response = "Rendered template";
    $this-&gt;mockTemplate(
        'books.twig',
        [
            'books' =&gt; ['book1', 'book2'],
            'currentPage' =&gt; 1,
            'lastPage' =&gt; true
        ],
        $response
    );

    $result = $controller-&gt;borrow(123);

    $this-&gt;assertSame(
        $result,
        $response,
        'Response object is not the expected one.'
    );
}</pre></div><p class="calibre8">So this is it. You have written one of the most complex tests you will need to write during this book. What do you think of it? Well, as you do not have much experience with tests, you might be quite satisfied with the result, but let's try to analyze it a bit further.</p></div></div>
<div class="book" title="Database testing"><div class="book" id="20R682-edcc22b134104d5db0bf3aa086c86851"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch07lvl1sec62" class="calibre1"/>Database testing</h1></div></div></div><p class="calibre8">This will be the <a id="id620" class="calibre1"/>most controversial of the sections of this chapter by far. When it comes to database testing, there are different schools of thought. Should we use the database or not? Should we use our development database or one in memory? It is quite out of the scope of the book to explain how to mock the database or prepare a fresh one for each test, but we will try to summarize some of the techniques here:</p><div class="book"><ul class="itemizedlist"><li class="listitem">We will mock the database connection and write expectations to all the interactions between the model and the database. In our case, this would mean that we would inject a mock of the <code class="email">PDO</code> object. As we will write the queries manually, chances are that we might introduce a wrong query. Mocking the connection would not help us detect this error. This solution would be good if we used ORM instead of writing the queries manually, but we will leave this topic out of the book.</li><li class="listitem">For each test, we will create a brand new database in which we add the data we would like to have for the specific test. This approach might take a lot of time, but it assures you that you will be testing against a real database and that there is no unexpected data that might make our tests fail; that is, the tests are fully isolated. In most of the cases, this would be the preferable approach, even though it might not be the one that performs faster. To solve this inconvenience, we will create in-memory databases.</li><li class="listitem">Tests run against an already existing database. Usually, at the beginning of the test we start a transaction that we roll back at the end of the test, leaving the database without any change. This approach emulates a real scenario, in which we can find all sorts of data and our code should always behave as expected. However, using a shared database always has some side effects; for example, if we want to introduce changes to the database schema, we will have to apply them to the database before running the tests, but the rest of the applications or developers that use the database are not yet ready for these changes.</li></ul></div><p class="calibre8">In order to keep things <a id="id621" class="calibre1"/>small, we will try to implement a mixture of the second and third options. We will use our existing database, but after starting the transaction of each test, we will clean all the tables involved with the test. This looks as though we need a <code class="email">ModelTestCase</code> to handle this. Add the following into <code class="email">tests/ModelTestCase.php</code>:</p><div class="informalexample"><pre class="programlisting">&lt;?php

namespace Bookstore\Tests;

use Bookstore\Core\Config;
use PDO;

abstract class ModelTestCase extends AbstractTestCase {
    protected $db;
    protected $tables = [];

    public function setUp() {
        $config = new Config();

        $dbConfig = $config-&gt;get('db');
        $this-&gt;db = new PDO(
            'mysql:host=127.0.0.1;dbname=bookstore',
            $dbConfig['user'],
            $dbConfig['password']
        );
        $this-&gt;db-&gt;beginTransaction();
        $this-&gt;cleanAllTables();
    }

    public function tearDown() {
        $this-&gt;db-&gt;rollBack();
    }

    protected function cleanAllTables() {
        foreach ($this-&gt;tables as $table) {
            $this-&gt;db-&gt;exec("delete from $table");
        }
    }
}</pre></div><p class="calibre8">The <code class="email">setUp</code> method creates<a id="id622" class="calibre1"/> a database connection with the same credentials found in the <code class="email">config/app.yml</code> file. Then, we will start a transaction and invoke the <code class="email">cleanAllTables</code> method, which iterates the tables in the <code class="email">$tables</code> property and deletes all the content from them. The <code class="email">tearDown</code> method rolls back the transaction.</p><div class="informalexample" title="Note"><h3 class="title2"><a id="note17" class="calibre1"/>Note</h3><p class="calibre8">
<span class="strong"><strong class="calibre2">Extending from ModelTestCase</strong></span>
</p><p class="calibre8">If you write a test extending from this class that needs to implement either the <code class="email">setUp</code> or <code class="email">tearDown</code> method, always remember to invoke the ones from the parent.</p></div><p class="calibre8">Let's write tests for the <code class="email">borrow</code> method of the <code class="email">BookModel</code> class. This method uses books and customers, so we would like to clean the tables that contain them. Create the <code class="email">test</code> class and save it in <code class="email">tests/Models/BookModelTest.php</code>:</p><div class="informalexample"><pre class="programlisting">&lt;?php

namespace Bookstore\Tests\Models;

use Bookstore\Models\BookModel;
use Bookstore\Tests\ModelTestCase;

class BookModelTest extends ModelTestCase {
    protected $tables = [
        'borrowed_books',
        'customer',
        'book'
    ];
    protected $model;

    public function setUp() {
        parent::setUp();

        $this-&gt;model = new BookModel($this-&gt;db);
    }
}</pre></div><p class="calibre8">Note how we also overrode the <code class="email">setUp</code> method, invoking the one in the parent and creating the model instance that all tests will use, which is safe to do as we will not keep any context on this object. Before adding the tests though, let's add some more helpers to <code class="email">ModelTestCase</code>: one to create book objects given an array of parameters and two to save books and customers in the database. Run the following code:</p><div class="informalexample"><pre class="programlisting">protected function buildBook(array $properties): Book {
    $book = new Book();
    $reflectionClass = new ReflectionClass(Book::class);

    foreach ($properties as $key =&gt; $value) {
        $property = $reflectionClass-&gt;getProperty($key);
        $property-&gt;setAccessible(true);
        $property-&gt;setValue($book, $value);
    }

    return $book;
}

protected function addBook(array $params) {
    $default = [
        'id' =&gt; null,
        'isbn' =&gt; 'isbn',
        'title' =&gt; 'title',
        'author' =&gt; 'author',
        'stock' =&gt; 1,
        'price' =&gt; 10.0,
    ];
    $params = array_merge($default, $params);

    $query = &lt;&lt;&lt;SQL
insert into book (id, isbn, title, author, stock, price)
values(:id, :isbn, :title, :author, :stock, :price)
SQL;
    $this-&gt;db-&gt;prepare($query)-&gt;execute($params);
}

protected function addCustomer(array $params) {
    $default = [
        'id' =&gt; null,
        'firstname' =&gt; 'firstname',
        'surname' =&gt; 'surname',
        'email' =&gt; 'email',
        'type' =&gt; 'basic'
    ];
    $params = array_merge($default, $params);

    $query = &lt;&lt;&lt;SQL
insert into customer (id, firstname, surname, email, type)
values(:id, :firstname, :surname, :email, :type)
SQL;
    $this-&gt;db-&gt;prepare($query)-&gt;execute($params);
}</pre></div><p class="calibre8">As you can note, we added default values for all the fields, so we are not forced to define the whole book/customer each time we want to save one. Instead, we just sent the relevant fields and merged them to the default ones.</p><p class="calibre8">Also, note that the <code class="email">buildBook</code> method used <a id="id623" class="calibre1"/>a new concept, <span class="strong"><strong class="calibre2">reflection</strong></span>, to access the private properties of an instance. This is <a id="id624" class="calibre1"/>way beyond the scope of the <a id="id625" class="calibre1"/>book, but if you are interested, you can read more at <a class="calibre1" href="http://php.net/manual/en/book.reflection.php">http://php.net/manual/en/book.reflection.php</a>.</p><p class="calibre8">We are now ready to start writing tests. With all these helpers, adding tests will be very easy and clean. The <code class="email">borrow</code> method has different use cases: trying to borrow a book that is not in the database, trying to use a customer not registered, and borrowing a book successfully. Let's add them as follows:</p><div class="informalexample"><pre class="programlisting">/**
 * @expectedException \Bookstore\Exceptions\DbException
 */
public function testBorrowBookNotFound() {
    $book = $this-&gt;buildBook(['id' =&gt; 123]);
    $this-&gt;model-&gt;borrow($book, 123);
}

/**
 * @expectedException \Bookstore\Exceptions\DbException
 */
public function testBorrowCustomerNotFound() {
    $book = $this-&gt;buildBook(['id' =&gt; 123]);
    $this-&gt;addBook(['id' =&gt; 123]);

    $this-&gt;model-&gt;borrow($book, 123);
}

public function testBorrow() {
    $book = $this-&gt;buildBook(['id' =&gt; 123, 'stock' =&gt; 12]);
    $this-&gt;addBook(['id' =&gt; 123, 'stock' =&gt; 12]);
    $this-&gt;addCustomer(['id' =&gt; 123]);

    $this-&gt;model-&gt;borrow($book, 123);
}</pre></div><p class="calibre8">Impressed? Compared to the controller tests, these tests are way simpler, mainly because their code performs only one action, but also thanks to all the methods added to <code class="email">ModelTestCase</code>. Once you need to work with other objects, such as <code class="email">sales</code>, you can add <code class="email">addSale</code> or <code class="email">buildSale</code> to this same class to make things cleaner.</p></div>

<div id="page" style="height:0pt"/><div class="book" title="Test-driven development"><div class="book" id="21PMQ2-edcc22b134104d5db0bf3aa086c86851"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch07lvl1sec63" class="calibre1"/>Test-driven development</h1></div></div></div><p class="calibre8">You might<a id="id626" class="calibre1"/> realize already that there is no unique way to do things when talking about developing an application. It is out of the scope of this book to show you all of them—and by the time you are done reading these lines, more techniques will have been incorporated already—but there is one approach that is very useful when it comes to writing good, testable code: <span class="strong"><strong class="calibre2">test-driven development</strong></span> (<span class="strong"><strong class="calibre2">TDD</strong></span>).</p><p class="calibre8">This methodology consists of writing the unit tests before writing the code itself. The idea, though, is not to write all the tests at once and then write the class or method but rather to do it in a progressive way. Let's consider an example to make it easier. Imagine that your <code class="email">Sale</code> class is yet to be implemented and the only thing we know is that we have to be able to add books. Rename your <code class="email">src/Domain/Sale.php</code> file to <code class="email">src/Domain/Sale2.php</code> or just delete it so that the application does not know about it.</p><div class="informalexample" title="Note"><h3 class="title2"><a id="note18" class="calibre1"/>Note</h3><p class="calibre8">
<span class="strong"><strong class="calibre2">Is all this verbosity necessary?</strong></span>
</p><p class="calibre8">You will note in this example that we will perform an excessive amount of steps to come up with a very simple piece of code. Indeed, they are too many for this example, but there will be times when this amount is just fine. Finding these moments comes with experience, so we recommend you to practice first with simple examples. Eventually, it will come naturally to you.</p></div><p class="calibre8">The mechanics of TDD consist of four steps, as follows:</p><div class="book"><ol class="orderedlist"><li class="listitem" value="1">Write a test for some functionality that is not yet implemented.</li><li class="listitem" value="2">Run the unit tests, and they should fail. If they do not, either your test is wrong, or your code already implements this functionality.</li><li class="listitem" value="3">Write the minimum amount of code to make the tests pass.</li><li class="listitem" value="4">Run the unit tests again. This time, they should pass.</li></ol><div class="calibre13"/></div><p class="calibre8">We do not have the <code class="email">sale</code> domain object, so the first thing, as we should start from small things and then move on to bigger things, is to assure that we can instantiate the <code class="email">sale</code> object. Write the following unit test in <code class="email">tests/Domain/SaleTest.php</code> as we will write all the existing tests, but using TDD; you can remove the existing tests in this file.</p><div class="informalexample"><pre class="programlisting">&lt;?php

namespace Bookstore\Tests\Domain;

use Bookstore\Domain\Sale;
use PHPUnit_Framework_TestCase;

class SaleTest extends PHPUnit_Framework_TestCase {
    public function testCanCreate() {
        $sale = new Sale();
    }
}</pre></div><p class="calibre8">Run the tests to make <a id="id627" class="calibre1"/>sure that they are failing. In order to run one specific test, you can mention the file of the test when running PHPUnit, as shown in the following script:</p><div class="mediaobject"><img src="../images/00034.jpeg" alt="Test-driven development" class="calibre9"/></div><p class="calibre10"> </p><p class="calibre8">Good, they are failing. That means that PHP cannot find the object to instantiate it. Let's now write the minimum amount of code required to make this test pass. In this case, creating the class would be enough, and you can do this through the following lines of code:</p><div class="informalexample"><pre class="programlisting">&lt;?php

namespace Bookstore\Domain;

class Sale {
}</pre></div><p class="calibre8">Now, run the tests to make sure that there are no errors.</p><div class="mediaobject"><img src="../images/00035.jpeg" alt="Test-driven development" class="calibre9"/></div><p class="calibre10"> </p><p class="calibre8">This is easy, right? So, what we<a id="id628" class="calibre1"/> need to do is repeat this process, adding more functionality each time. Let's focus on the books that a sale holds; when created, the book's list should be empty, as follows:</p><div class="informalexample"><pre class="programlisting">public function testWhenCreatedBookListIsEmpty() {
    $sale = new Sale();

    $this-&gt;assertEmpty($sale-&gt;getBooks());
}</pre></div><p class="calibre8">Run the tests to make sure that they fail—they do. Now, write the following method in the class:</p><div class="informalexample"><pre class="programlisting">public function getBooks(): array {
return [];
}</pre></div><p class="calibre8">Now, if you run... wait, what? We are forcing the <code class="email">getBooks</code> method to return an empty array always? This is not the implementation that we need—nor the one we deserve—so why do we do it? The reason is the wording of step 3: "Write the minimum amount of code to make the tests pass.". Our test suite should be extensive enough to detect this kind of problem, and this is our way to make sure it does. This time, we will write bad code on purpose, but next time, we might introduce a bug unintentionally, and our unit tests should be able to detect it as soon as possible. Run the tests; they will pass.</p><p class="calibre8">Now, let's discuss the next functionality. When adding a book to the list, we should see this book with amount 1. The test should be as follows:</p><div class="informalexample"><pre class="programlisting">public function testWhenAddingABookIGetOneBook() {
    $sale = new Sale();
    $sale-&gt;addBook(123);

    $this-&gt;assertSame(
        $sale-&gt;getBooks(),
        [123 =&gt; 1]
    );
}</pre></div><p class="calibre8">This test is very useful. Not only<a id="id629" class="calibre1"/> does it force us to implement the <code class="email">addBook</code> method, but also it helps us fix the <code class="email">getBooks</code> method—as it is hardcoded right now—to always return an empty array. As the <code class="email">getBooks</code> method now expects two different results, we cannot trick the tests any more. The new code for the class should be as follows:</p><div class="informalexample"><pre class="programlisting">class Sale {
    private $books = [];

    public function getBooks(): array {
        return $this-&gt;books;
    }

    public function addBook(int $bookId) {
        $this-&gt;books[123] = 1;
    }
}</pre></div><p class="calibre8">A new test we can write is the one that allows you to add more than one book at a time, sending the amount as the second argument. The test would look similar to the following:</p><div class="informalexample"><pre class="programlisting">public function testSpecifyAmountBooks() {
    $sale = new Sale();
    $sale-&gt;addBook(123, 5);

    $this-&gt;assertSame(
        $sale-&gt;getBooks(),
        [123 =&gt; 5]
    );
}</pre></div><p class="calibre8">Now, the tests do not pass, so we need to fix them. Let's refactor <code class="email">addBook</code> so that it can accept a second argument as the amount :</p><div class="informalexample"><pre class="programlisting">public function addBook(int $bookId, int $amount = 1) {
    $this-&gt;books[123] = $amount;
}</pre></div><p class="calibre8">The next functionality we would like to add is the same book invoking the method several times, keeping track of the total amount of books added. The test could be as follows:</p><div class="informalexample"><pre class="programlisting">public function testAddMultipleTimesSameBook() {
    $sale = new Sale();
    $sale-&gt;addBook(123, 5);
    $sale-&gt;addBook(123);
    $sale-&gt;addBook(123, 5);

    $this-&gt;assertSame(
        $sale-&gt;getBooks(),
        [123 =&gt; 11]
    );
}</pre></div><p class="calibre8">This test will fail as the current<a id="id630" class="calibre1"/> execution will not add all the amounts but will instead keep the last one. Let's fix it by executing the following code:</p><div class="informalexample"><pre class="programlisting">public function addBook(int $bookId, int $amount = 1) {
    if (!isset($this-&gt;books[123])) {
        $this-&gt;books[123] = 0;
    }
    $this-&gt;books[123] += $amount;
}</pre></div><p class="calibre8">Well, we are almost there. There is one last test we should add, which is the ability to add more than one different book. The test is as follows:</p><div class="informalexample"><pre class="programlisting">public function testAddDifferentBooks() {
    $sale = new Sale();
    $sale-&gt;addBook(123, 5);
    $sale-&gt;addBook(456, 2);
    $sale-&gt;addBook(789, 5);

    $this-&gt;assertSame(
        $sale-&gt;getBooks(),
        [123 =&gt; 5, 456 =&gt; 2, 789 =&gt; 5]
    );
}</pre></div><p class="calibre8">This test fails due to the hardcoded book ID in our implementation. If we did not do this, the test would have already passed. Let's fix it then; run the following:</p><div class="informalexample"><pre class="programlisting">public function addBook(int $bookId, int $amount = 1) {
    if (!isset($this-&gt;books[$bookId])) {
        $this-&gt;books[$bookId] = 0;
    }
    $this-&gt;books[$bookId] += $amount;
}</pre></div><p class="calibre8">We are done! Does it <a id="id631" class="calibre1"/>look familiar? It is the same code we wrote on our first implementation except for the rest of the properties. You can now replace the <code class="email">sale</code> domain object with the previous one, so you have all the functionalities needed.</p></div>

<div class="book" title="Test-driven development">
<div class="book" title="Theory versus practice"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_1"><a id="ch07lvl2sec122" class="calibre1"/>Theory versus practice</h2></div></div></div><p class="calibre8">As mentioned before, this is a<a id="id632" class="calibre1"/> quite long and verbose process that very few experienced developers follow from start to end but one that most of them encourage people to follow. Why is this so? When you write all your code first and leave the unit tests for the end, there are two problems:</p><div class="book"><ul class="itemizedlist"><li class="listitem">Firstly, in too many cases developers are lazy enough to skip tests, telling themselves that the code already works, so there is no need to write the tests. You already know that one of the goals of tests is to make sure that future changes do not break the current features, so this is not a valid reason.</li><li class="listitem">Secondly, the tests written after the code usually test the code rather than the functionality. Imagine that you have a method that was initially meant to perform an action. After writing the method, we will not perform the action perfectly due to a bug or bad design; instead, we will either do too much or leave some edge cases untreated. When we write the test after writing the code, we will test what we see in the method, not what the original functionality was!</li></ul></div><p class="calibre8">If you instead force yourself to write the tests first and then the code, you make sure that you always have tests and that they test what the code is meant to do, leading to a code that performs as expected and is fully covered. Also, by doing it in small intervals, you get quick feedback and don't have to wait for hours to know whether all the tests and code you wrote make sense at all. Even though this idea is quite simple and makes a lot of sense, many novice developers find it hard to implement.</p><p class="calibre8">Experienced developers have written code for several years, so they have already internalized all of this. This is the reason why some of them prefer to either write several tests before starting with the code or the other way around, that is, writing code and then testing it as they are more productive this way. However, if there is something that all of them have in<a id="id633" class="calibre1"/> common it is that their applications will always be full of tests.</p></div></div>
<div class="book" title="Summary" id="22O7C1-edcc22b134104d5db0bf3aa086c86851"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch07lvl1sec64" class="calibre1"/>Summary</h1></div></div></div><p class="calibre8">In this chapter, you learned the importance of testing your code using unit tests. You now know how to configure PHPUnit on your application so that you can not only run your tests but also get good feedback. You got a good introduction on how to write unit tests properly, and now, it is safer for you to introduce changes in your application.</p><p class="calibre8">In the next chapter, we will study some existing frameworks, which you can use instead of writing your own every time you start an application. In this way, not only will you save time and effort, but also other developers will be able to join you and understand your code easily.</p></div></body></html>