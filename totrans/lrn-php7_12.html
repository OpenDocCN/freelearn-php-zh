<html><head></head><body>
<div id="page" style="height:0pt"/><div class="book" title="Chapter&#xA0;10.&#xA0;Behavioral Testing"><div class="book" id="2JTHG2-edcc22b134104d5db0bf3aa086c86851"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch10" class="calibre1"/>Chapter 10. Behavioral Testing</h1></div></div></div><p class="calibre8">In <a class="calibre1" title="Chapter 7. Testing Web Applications" href="part0064_split_000.html#1T1402-edcc22b134104d5db0bf3aa086c86851">Chapter 7</a>, <span class="strong"><em class="calibre12">Testing Web Applications</em></span>, you learned how to write unit tests in order to test small pieces of code in an isolated way. Even though this is a must, it is not enough alone to make sure your application works as it should. The scope of your test could be so small that even though the algorithm that you test makes sense, it would not be what the business asked you to create.</p><p class="calibre8">Acceptance tests were born in order to add this level of security to the business side, complementing the already existing unit tests. In the same way, BDD originated from TDD in order to write code based on these acceptance tests in an attempt to involve business and managers in the development process. As PHP is one of the favorite languages of web developers, it is just natural to find powerful tools to implement BDD in your projects. You will be positively surprised by what you can do with <a id="id840" class="calibre1"/>
<span class="strong"><strong class="calibre2">Behat</strong></span> and <a id="id841" class="calibre1"/>
<span class="strong"><strong class="calibre2">Mink</strong></span>, the two most popular BDD frameworks at the moment.</p><p class="calibre8">In this chapter, you will learn about:</p><div class="book"><ul class="itemizedlist"><li class="listitem">Acceptance tests and BDD</li><li class="listitem">Writing features with Gherkin</li><li class="listitem">Implementing and running tests with Behat</li><li class="listitem">Writing tests against browsers with Mink</li></ul></div></div>

<div class="book" title="Chapter&#xA0;10.&#xA0;Behavioral Testing">
<div class="book" title="Behavior-driven development"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_1"><a id="ch10lvl1sec83" class="calibre1"/>Behavior-driven development</h1></div></div></div><p class="calibre8">We already<a id="id842" class="calibre1"/> exposed in <a class="calibre1" title="Chapter 7. Testing Web Applications" href="part0064_split_000.html#1T1402-edcc22b134104d5db0bf3aa086c86851">Chapter 7</a>, <span class="strong"><em class="calibre12">Testing Web Applications</em></span>, the different tools we can use in order to make our applications bug-free, such as automated tests. We described what unit tests are and how they can help us achieve our goals, but this is far from enough. In this section, we will describe the process of creating a real-world application, how unit tests are not enough, and what other techniques we can include in this life cycle in order to succeed in our task—in this case, behavioral tests.</p></div></div>

<div class="book" title="Chapter&#xA0;10.&#xA0;Behavioral Testing">
<div class="book" title="Behavior-driven development">
<div class="book" title="Introducing continuous integration"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_2"><a id="ch10lvl2sec164" class="calibre1"/>Introducing continuous integration</h2></div></div></div><p class="calibre8">There is a huge <a id="id843" class="calibre1"/>difference between developing a small web application by yourself and being part of a big team of developers, managers, marketing people, and so on, that works around the same big web application. Working on an application used by thousands or millions of users has a clear risk: if you mess it up, there will be a huge number of unhappy affected users, which may translate into sales going down, partnerships terminated, and so on.</p><p class="calibre8">From this scenario, you can imagine that people would be scared when they have to change anything in production. Before doing so, they will make sure that everything works perfectly fine. For this reason, there is always a heavy process around all the changes affecting a web application in production, including loads of tests of all kinds.</p><p class="calibre8">Some think that by reducing the number of times they deploy to production, they can reduce the risk of failure, which ends up with them having releases every several months with an uncountable number of changes.</p><p class="calibre8">Now, imagine releasing the result of two or three months of code changes at once and something mysteriously fails in production: do you know where to even start looking for the cause of the problem? What if your team is good enough to make perfect releases, but the end result is not what the market needs? You might end up wasting months of work!</p><p class="calibre8">Even though there are different approaches and not all companies use them, let's try to describe one of the most famous ones from the last few years: <span class="strong"><strong class="calibre2">continuous integration</strong></span> (<span class="strong"><strong class="calibre2">CI</strong></span>). The idea is to integrate small pieces of work often rather than big ones every once in a while. Of course, releasing is still a constraint in your system, which means that it takes a lot of time and resources. CI tries to automatize this process as much as possible, reducing the amount of time and resources that you need to invest. There are huge benefits with this approach, which are as follows:</p><div class="book"><ul class="itemizedlist"><li class="listitem">Releases do not take forever to be done, and there isn't an entire team focused on releasing as this is done automatically.</li><li class="listitem">You can release changes one by one as they come. If something fails, you know exactly what the change was and where to start looking for the error. You can even revert the changes easily if you need to.</li><li class="listitem">As you release so often, you can get quick feedback from everyone. You will be able to change your plans in time if you need to instead of waiting for months to get any feedback and wasting all the effort you put on this release.</li></ul></div><p class="calibre8">The idea seems perfect, but how do we implement it? First, let's focus on the manual part of the process: developing the features using <a id="id844" class="calibre1"/>a <span class="strong"><strong class="calibre2">version control system</strong></span> (<span class="strong"><strong class="calibre2">VCS</strong></span>). The following diagram shows a very common approach:</p><div class="mediaobject"><img src="../images/00047.jpeg" alt="Introducing continuous integration" class="calibre9"/></div><p class="calibre10"> </p><p class="calibre8">As we already mentioned, a <a id="id845" class="calibre1"/>VCS allows developers to work on the same codebase, tracking all the changes that everyone makes and helping on the resolution of conflicts. A VCS usually allows you to have different branches; that is, you can<a id="id846" class="calibre1"/> diverge from the main line of development and continue to do work without messing with it. The previous graph shows you how to use branches to write new features and can be explained as follows:</p><div class="book"><ul class="itemizedlist"><li class="listitem"><span class="strong"><strong class="calibre2">A</strong></span>: A team needs to start working on feature A. They create a new branch from the master, in which they will add all the changes for this feature.</li><li class="listitem"><span class="strong"><strong class="calibre2">B</strong></span>: A different team also needs to start working on a feature. They create a new branch from master, same as before. At this point, they are not aware of what the first team is doing as they do it on their own branch.</li><li class="listitem"><span class="strong"><strong class="calibre2">C</strong></span>: The second team finishes their job. No one else changed master, so they can merge their changes straight away. At this point, the CI process will start the release process.</li><li class="listitem"><span class="strong"><strong class="calibre2">D</strong></span>: The first team finishes the feature. In order to merge it to master, they need to first rebase their branch with the new changes of master and solve any conflicts that might take place. The older the branch is the more chances of getting conflicts you will have, so you can imagine that smaller and faster features are preferred.</li></ul></div><p class="calibre8">Now, let's take a look at how the automated side of the process looks. The following graph shows you all the steps from the merging into master to production deployment:</p><div class="mediaobject"><img src="../images/00048.jpeg" alt="Introducing continuous integration" class="calibre9"/></div><p class="calibre10"> </p><p class="calibre8">Until you merge your code into master, you are in the development environment. The CI tool will listen to all the changes on the master branch of your project, and for each of them, it will trigger a job. This job will take care of building the project if necessary and then run all the tests. If there is any error or test failure, it will let everyone now, and the team that triggered this job should take care of fixing it. The master branch is considered unstable at this point.</p><p class="calibre8">If all tests pass, the <a id="id847" class="calibre1"/>CI tool will deploy your code into staging. Staging is an environment that emulates production as much as possible; that is, it has the same server configuration, database structure, and so on. Once the application is here, you can run all the tests that you need until you are confident to continue the deployment to production. As you make small changes, you do not need to manually test absolutely everything. Instead, you can test your changes and the main use cases of your application.</p></div></div></div>

<div class="book" title="Chapter&#xA0;10.&#xA0;Behavioral Testing">
<div class="book" title="Behavior-driven development">
<div class="book" title="Unit tests versus acceptance tests"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_3"><a id="ch10lvl2sec165" class="calibre1"/>Unit tests versus acceptance tests</h2></div></div></div><p class="calibre8">We said that the goal <a id="id848" class="calibre1"/>of CI is to have a process as automatized as<a id="id849" class="calibre1"/> possible. However, we still need to manually test the application in staging, right? Acceptance tests to the rescue!</p><p class="calibre8">Writing unit tests is nice and a must, but they test only small pieces of code in an isolated way. Even if your entire unit tests suite passes, you cannot be sure that your application works at all as you might not integrate all the parts properly because you are missing functionalities or the functionalities that you built were not what the business needed. Acceptance tests test the entire flow of a specific use case.</p><p class="calibre8">If your application is a website, acceptance tests will probably launch a browser and emulate user actions, such as clicking and typing, in order to assert that the page returns what is expected. Yes, from a few lines of code, you can execute all the tests that were previously manual in an automated way.</p><p class="calibre8">Now, imagine that you wrote acceptance tests for all the features of your application. Once the code is in staging, the CI tool can automatically run all of these tests and make sure that the new code does not break any existing functionality. You can even run them using as many different browsers as you need to make sure that your application works fine in all of them. If a test fails, the CI tool will notify the team responsible, and they will have to fix it. If all the tests pass, the CI tool can automatically deploy your code into production.</p><p class="calibre8">Why do we need to write unit tests then, if acceptance tests test what the business really cares about? There are several reasons to keep both acceptance and unit tests; in fact, you should have way more unit tests than acceptance tests.</p><div class="book"><ul class="itemizedlist"><li class="listitem">Unit tests <a id="id850" class="calibre1"/>check small pieces of code, which <a id="id851" class="calibre1"/>make them orders-of-magnitude faster than acceptance tests, which test the whole flow against a browser. That means that you can run all your unit tests in a few seconds or minutes, but it will take much longer to run all your acceptance tests.</li><li class="listitem">Writing acceptance tests that cover absolutely all the possible combinations of use cases is virtually impossible. Writing unit tests that cover a high percentage of use cases for a given method or piece of code is rather easy. You should have loads of unit tests testing as many edge cases as possible but only some acceptance tests testing the main use cases.</li></ul></div><p class="calibre8">When should you run each type of test then? As unit tests are faster, they should be executed during the first stages of deployment. Only once we know that they all have passed do we want to spend time deploying to staging and running acceptance tests.</p></div></div></div>

<div class="book" title="Chapter&#xA0;10.&#xA0;Behavioral Testing">
<div class="book" title="Behavior-driven development">
<div class="book" title="TDD versus BDD"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_4"><a id="ch10lvl2sec166" class="calibre1"/>TDD versus BDD</h2></div></div></div><p class="calibre8">In <a class="calibre1" title="Chapter 7. Testing Web Applications" href="part0064_split_000.html#1T1402-edcc22b134104d5db0bf3aa086c86851">Chapter 7</a>, <span class="strong"><em class="calibre12">Testing Web Applications</em></span>, you learned that TDD or test-driven development is the <a id="id852" class="calibre1"/>practice of writing first the unit tests and then the code in an <a id="id853" class="calibre1"/>attempt to write testable and cleaner code and to make sure that your test suite is always up to date. With the appearance of acceptance tests, TDD evolved to BDD or behavior-driven development.</p><p class="calibre8">BDD is quite similar to TDD, in that you should write the tests first and then the code that makes these tests pass. The only difference is that with BDD, we write tests that specify the desired behavior of the code, which can be translated to acceptance tests. Even though it will always depend on the situation, you should write acceptance tests that test a very specific part of the application rather than long use cases that contain several steps. With BDD, as with TDD, you want to get quick feedback, and if you write a broad test, you will have to write a lot of code in order to make it pass, which is not the goal that BDD wants to achieve.</p></div></div></div>

<div class="book" title="Chapter&#xA0;10.&#xA0;Behavioral Testing">
<div class="book" title="Behavior-driven development">
<div class="book" title="Business writing tests"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_5"><a id="ch10lvl2sec167" class="calibre1"/>Business writing tests</h2></div></div></div><p class="calibre8">The whole point of <a id="id854" class="calibre1"/>acceptance tests and BDD is to make sure that your application works as expected, not only your code. Acceptance tests, then, should not be written by developers but by the business itself. Of course, you cannot expect that managers and executives will learn how to code in order to create acceptance tests, but there is a bunch of tools that allow you to translate plain English instructions or <span class="strong"><strong class="calibre2">behavioral specifications</strong></span>
<a id="id855" class="calibre1"/> into acceptance tests' code. Of course, these instructions have to follow some patterns. Behavioral specifications have the following parts:</p><div class="book"><ul class="itemizedlist"><li class="listitem">A title, which describes briefly, but in a very clear way, what use case the behavioral specification covers.</li><li class="listitem">A narrative, which specifies who performs the test, what the business value is, and what the expected outcome is. Usually the format of the narrative is the following:<div class="informalexample"><pre class="programlisting">In order to &lt;business value&gt;
As a &lt;stakeholder&gt;
I want to &lt;expected outcome&gt;</pre></div></li><li class="listitem">A set of scenarios, which is a description and a set of steps of each specific use case that we want to cover. Each scenario has a description and a list of instructions in the <code class="email">Given</code>-<code class="email">When</code>-<code class="email">Then</code> format; we will discuss more on this in the next section. A common patterns is:<div class="informalexample"><pre class="programlisting">Scenario: &lt;short description&gt;
Given &lt;set up scenario&gt;
When &lt;steps to take&gt;
Then &lt;expected outcome&gt;</pre></div></li></ul></div><p class="calibre8">In the next two sections, we will discover two tools in PHP that you can use in order to understand behavioral scenarios and run them as acceptance tests.</p></div></div></div>

<div id="page" style="height:0pt"/><div class="book" title="BDD with Behat"><div class="book" id="2KS222-edcc22b134104d5db0bf3aa086c86851"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch10lvl1sec84" class="calibre1"/>BDD with Behat</h1></div></div></div><p class="calibre8">The first of the tools we will introduce is <a id="id856" class="calibre1"/>Behat. Behat <a id="id857" class="calibre1"/>is a PHP framework that can transform behavioral scenarios into acceptance tests and then run them, providing feedback similar to PHPUnit. The idea is to match each of the steps in English with the scenarios in a PHP function that performs some action or asserts some results.</p><p class="calibre8">In this section, we will try to add some acceptance tests to our application. The application will be a simple database migration script that will allow us to keep track of the changes that we will add to our schema. The idea is that each time that you want to change your database, you will write the changes on a migration file and then execute the script. The application will check what was the last migration executed and will perform new ones. We will first write the acceptance tests and then introduce the code progressively as BDD suggests.</p><p class="calibre8">In order to install Behat on your development environment, you can use Composer. The command is as follows:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong class="calibre2">$ composer require behat/behat</strong></span>
</pre></div><p class="calibre8">Behat actually does not come with any set of assertion functions, so you will have to either implement your own by writing conditionals and throwing exceptions or you could integrate any library that provides them. Developers usually choose PHPUnit for this as they are already used to its assertions. Add it, then, to your project via the following:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong class="calibre2">$ composer require phpunit/phpunit</strong></span>
</pre></div><p class="calibre8">As with PHPUnit, Behat <a id="id858" class="calibre1"/>needs to know where your test suite is located. You can either have a configuration file stating this and other configuration options, which is similar to the <code class="email">phpunit.xml</code> configuration file for PHPUnit, or you could follow the conventions that Behat sets and skip the configuration step. If you choose the second option, you can let Behat create the folder structure and PHP <code class="email">test</code> class for you with the following command:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong class="calibre2">$ ./vendor/bin/behat --init</strong></span>
</pre></div><p class="calibre8">After running this command, you should have a <code class="email">features/bootstrap/FeatureContext.php</code> file, which is where you need to add the steps of the PHP functions' matching scenarios. More on this shortly, but first, let's find out how to write behavioral specifications so that Behat can understand them.</p></div>

<div class="book" title="BDD with Behat">
<div class="book" title="Introducing the Gherkin language"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_1"><a id="ch10lvl2sec168" class="calibre1"/>Introducing the Gherkin language</h2></div></div></div><p class="calibre8">Gherkin<a id="id859" class="calibre1"/> is the language, or rather the format, that behavioral specifications have to follow. Using Gherkin naming, each behavioral specification is a <a id="id860" class="calibre1"/>
<span class="strong"><strong class="calibre2">feature</strong></span>. Each feature is added to the <code class="email">features</code> directory and should have the <code class="email">.feature</code> extension. Feature files should start with the <code class="email">Feature</code> keyword followed by the title and the narrative in the same format that we already mentioned before—that is, the <span class="strong"><em class="calibre12">In order to–As a–I need to</em></span> structure. In fact, Gherkin will only print these lines, but keeping it consistent will help your developers and business know what they are trying to achieve.</p><p class="calibre8">Our application will have two features: one for the setup of our database to allow the migrations tool to work, and the other one for the correct behavior when adding migrations to the database. Add the following content to the <code class="email">features/setup.feature</code> file:</p><div class="informalexample"><pre class="programlisting">Feature: Setup
  In order to run database migrations
  As a developer
  I need to be able to create the empty schema and migrations table.</pre></div><p class="calibre8">Then, add the following feature definition to the <code class="email">features/migrations.feature</code> file:</p><div class="informalexample"><pre class="programlisting">Feature: Migrations
  In order to add changes to my database schema
  As a developer
  I need to be able to run the migrations script</pre></div></div></div>

<div class="book" title="BDD with Behat">
<div class="book" title="Defining scenarios"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_2"><a id="ch10lvl2sec169" class="calibre1"/>Defining scenarios</h2></div></div></div><p class="calibre8">The title and<a id="id861" class="calibre1"/> narrative of features does not really do anything more than give information to the person who runs the tests. The real work is done in scenarios, which are specific use cases with a set of steps to take and some assertions. You can add as many scenarios as you need to each feature file as long as they represent different use cases of the same feature. For example, for <code class="email">setup.feature</code>, we can add a couple of scenarios: one where it is the first time that the user runs the script, so the application will have to set up the database, and one where the user already executed the script previously, so the application does not need to go through the setup process.</p><p class="calibre8">As Behat needs to be able to translate the scenarios written in plain English to PHP functions, you will have to follow some conventions. In fact, you will see that they are very similar to the ones that we already mentioned in the behavioral specifications section.</p><div class="book" title="Writing Given-When-Then test cases"><div class="book"><div class="book"><div class="book"><h3 class="title2"><a id="ch10lvl3sec36" class="calibre1"/>Writing Given-When-Then test cases</h3></div></div></div><p class="calibre8">A scenario must <a id="id862" class="calibre1"/>start with the <code class="email">Scenario</code> keyword followed by <a id="id863" class="calibre1"/>a short description of what use case the scenario covers. Then, you need to add the list of steps and assertions. Gherkin allows you to use four keywords for this: <code class="email">Given</code>, <code class="email">When</code>, <code class="email">Then</code>, and <code class="email">And</code>. In fact, they all have the same meaning when it comes to code, but they add a lot of semantic value to your scenarios. Let's consider an example; add the following scenario at the end of your <code class="email">setup.feature</code> file:</p><div class="informalexample"><pre class="programlisting">Scenario: Schema does not exist and I do not have migrations
  Given I do not have the "bdd_db_test" schema
  And I do not have migration files
  When I run the migrations script
  Then I should have an empty migrations table
  And I should get:
    """
    Latest version applied is 0.
    """</pre></div><p class="calibre8">This scenario tests what happens when we do not have any schema information and run the migrations script. First, it describes the state of the scenario: <span class="strong"><em class="calibre12">Given I do not have the bdd_db_test schema And I do not have migration files</em></span>. These two lines will be translated to one method each, which will remove the schema and all migration files. Then, the scenario describes what the user will do: <span class="strong"><em class="calibre12">When I run the migrations script</em></span>. Finally, we set the expectations for this scenario: <span class="strong"><em class="calibre12">Then I should have an empty migrations table And I should get Latest version applied is 0.</em></span>.</p><p class="calibre8">In general, the same step will always start by the same keyword—that is, <span class="strong"><em class="calibre12">I run the migrations script</em></span> will always be preceded by <code class="email">When</code>. The <code class="email">And</code> keyword is a special one as it matches all the three keywords; its only purpose is to have steps as English-friendly as possible; although if you prefer, you could write <span class="strong"><em class="calibre12">Given I do not have migration files</em></span>.</p><p class="calibre8">Another thing to <a id="id864" class="calibre1"/>note in this example is the use of arguments as part<a id="id865" class="calibre1"/> of the step. The line <span class="strong"><em class="calibre12">And I should get</em></span> is followed by a string enclosed by <code class="email">"""</code>. The PHP function will get this string as an argument, so you can have one unique step definition—that is, the function—for a wide variety of situations just using different strings.</p></div><div class="book" title="Reusing parts of scenarios"><div class="book"><div class="book"><div class="book"><h3 class="title2"><a id="ch10lvl3sec37" class="calibre1"/>Reusing parts of scenarios</h3></div></div></div><p class="calibre8">It is quite common that for a <a id="id866" class="calibre1"/>given feature, you always start from the same scenario. For example, <code class="email">setup.feature</code> has a scenario in which we can run the migrations for the first time without any migration file, but we will also add another scenario in which we want to run the migrations script for the first time with some migration files to make sure that it will apply all of them. Both scenarios have in common one thing: they do not have the database set up.</p><p class="calibre8">Gherkin allows you to define some steps that will be applied to all the scenarios of the feature. You can use the <code class="email">Background</code> keyword and a list of steps, usually <code class="email">Given</code>. Add these two lines between the <code class="email">feature</code> narrative and <code class="email">scenario</code> definition:</p><div class="informalexample"><pre class="programlisting">Background:
  Given I do not have the "bdd_db_test" schema</pre></div><p class="calibre8">Now, you can remove the first step from the existing scenario as <code class="email">Background</code> will take care of it.</p></div></div></div>

<div class="book" title="BDD with Behat">
<div class="book" title="Writing step definitions"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_3"><a id="ch10lvl2sec170" class="calibre1"/>Writing step definitions</h2></div></div></div><p class="calibre8">So far, we <a id="id867" class="calibre1"/>have written features using the Gherkin language, but we still have not considered how any of the steps in each scenario is translated to actual code. The easiest way to note this is by asking Behat to run the acceptance tests; as the steps are not defined anywhere, Behat will print out all the functions that you need to add to your <code class="email">FeatureContext</code> class. To run the tests, just execute the following command:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong class="calibre2">$ ./vendor/bin/behat</strong></span>
</pre></div><p class="calibre8">The following <a id="id868" class="calibre1"/>screenshot shows the output that you should get if you have no step definitions:</p><div class="mediaobject"><img src="../images/00049.jpeg" alt="Writing step definitions" class="calibre9"/></div><p class="calibre10"> </p><p class="calibre8">As you can note, Behat<a id="id869" class="calibre1"/> complained about some missing steps and then printed in yellow the methods that you could use in order to implement them. Copy and paste them into your autogenerated <code class="email">features/bootstrap/FeatureContext.php</code> file. The following <code class="email">FeatureContext</code> class has already implemented all of them:</p><div class="informalexample"><pre class="programlisting">&lt;?php

use Behat\Behat\Context\Context;
use Behat\Behat\Context\SnippetAcceptingContext;
use Behat\Gherkin\Node\PyStringNode;

require_once __DIR__ . '/../../vendor/phpunit/phpunit/src/Framework/Assert/Functions.php';

class FeatureContext implements Context, SnippetAcceptingContext
{
    private $db;
    private $config;
    private $output;

    public function __construct() {
        $configFileContent = file_get_contents(
            __DIR__ . '/../../config/app.json'
        );
        $this-&gt;config = json_decode($configFileContent, true);
    }

    private function getDb(): PDO {
        if ($this-&gt;db === null) {
            $this-&gt;db = new PDO(
                "mysql:host={$this-&gt;config['host']}; "
                    . "dbname=bdd_db_test",
                $this-&gt;config['user'],
                $this-&gt;config['password']
            );
        }

        return $this-&gt;db;
    }

    /**
     * @Given I do not have the "bdd_db_test" schema
     */
    public function iDoNotHaveTheSchema()
    {
        $this-&gt;executeQuery('DROP SCHEMA IF EXISTS bdd_db_test');
    }

    /**
     * @Given I do not have migration files
     */
    public function iDoNotHaveMigrationFiles()
    {
        exec('rm db/migrations/*.sql &gt; /dev/null 2&gt;&amp;1');
    }

    /**
     * @When I run the migrations script
     */
    public function iRunTheMigrationsScript()
    {
        exec('php migrate.php', $this-&gt;output);
    }

    /**
     * @Then I should have an empty migrations table
     */
    public function iShouldHaveAnEmptyMigrationsTable()
    {
        $migrations = $this-&gt;getDb()
            -&gt;query('SELECT * FROM migrations')
            -&gt;fetch();
        assertEmpty($migrations);
    }

    private function executeQuery(string $query)
    {
        $removeSchemaCommand = sprintf(
            'mysql -u %s %s -h %s -e "%s"',
            $this-&gt;config['user'],
            empty($this-&gt;config['password'])
                ? '' : "-p{$this-&gt;config['password']}",
            $this-&gt;config['host'],
            $query
        );

        exec($removeSchemaCommand);
    }
}</pre></div><p class="calibre8">As you can note, we <a id="id870" class="calibre1"/>read the configuration from the <code class="email">config/app.json</code> file. This is the same configuration file that the application will use, and it contains the database's credentials. We also instantiated a <code class="email">PDO</code> object to access the database so that we could add or remove tables or take a look at what the script did.</p><p class="calibre8">Step definitions are a set of methods with a comment on each of them. This comment is an annotation as it starts with <code class="email">@</code> and is basically a regular expression matching the plain English step defined in the feature. Each of them has its implementation: either removing a database or migration files, executing the migrations script, or checking what the migrations table contains.</p><div class="book" title="The parameterization of steps"><div class="book"><div class="book"><div class="book"><h3 class="title2"><a id="ch10lvl3sec38" class="calibre1"/>The parameterization of steps</h3></div></div></div><p class="calibre8">In the <a id="id871" class="calibre1"/>previous <code class="email">FeatureContext</code> class, we intentionally missed the <code class="email">iShouldGet</code> method. As you might recall, this step has a string argument identified by a string enclosed between <code class="email">"""</code>. The implementation for this method looks as follows:</p><div class="informalexample"><pre class="programlisting">/**
 * @Then I should get:
 */
public function iShouldGet(PyStringNode $string)
{
    assertEquals(implode("\n", $this-&gt;output), $string);
}</pre></div><p class="calibre8">Note how the regular expression does not contain the string. This happens when using long strings with <code class="email">"""</code>. Also, the argument is an instance of <code class="email">PyStringNode</code>, which is a bit more complex than a normal string. However, fear not; when you compare it with a string, PHP will look for the <code class="email">__toString</code> method, which just prints the content of the string.</p></div></div></div>

<div class="book" title="BDD with Behat">
<div class="book" title="Running feature tests"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_4"><a id="ch10lvl2sec171" class="calibre1"/>Running feature tests</h2></div></div></div><p class="calibre8">In the previous sections, we <a id="id872" class="calibre1"/>wrote acceptance tests using Behat, but we have not written a single line of code yet. Before running them, though, add the <code class="email">config/app.json</code> configuration file with the credentials of your database user so that the <code class="email">FeatureContext</code> constructor can find it, as follows:</p><div class="informalexample"><pre class="programlisting">{
  "host": "127.0.0.1",
  "schema": "bdd_db_test",
  "user": "root",
  "password": ""
}</pre></div><p class="calibre8">Now, let's run the acceptance tests, expecting them to fail; otherwise, our tests will not be valid at all. The output should be something similar to this:</p><div class="mediaobject"><img src="../images/00050.jpeg" alt="Running feature tests" class="calibre9"/></div><p class="calibre10"> </p><p class="calibre8">As expected, the <code class="email">Then</code> steps<a id="id873" class="calibre1"/> failed. Let's implement the minimum code necessary in order to make the tests pass. For starters, add the autoloader into your <code class="email">composer.json</code> file and run <code class="email">composer update</code>:</p><div class="informalexample"><pre class="programlisting">"autoload": {
    "psr-4": {
        "Migrations\\": "src/"
    }
}</pre></div><p class="calibre8">We would like to implement a <code class="email">Schema</code> class that contains the helpers necessary to set up a database, run migrations, and so on. Right now, the feature is only concerned about the setup of the database—that is, creating the database, adding the empty migrations table to keep track of all the migrations added, and the ability to get the latest migration registered as successful. Add the following code as <code class="email">src/Schema.php</code>:</p><div class="informalexample"><pre class="programlisting">&lt;?php

namespace Migrations;

use Exception;
use PDO;

class Schema {

    const SETUP_FILE = __DIR__ . '/../db/setup.sql';
    const MIGRATIONS_DIR = __DIR__ . '/../db/migrations/';

    private $config;
    private $connection;

    public function __construct(array $config)
    {
        $this-&gt;config = $config;
    }

    

    private function getConnection(): PDO
    {
        if ($this-&gt;connection === null) {
            $this-&gt;connection = new PDO(
                "mysql:host={$this-&gt;config['host']};"
                    . "dbname={$this-&gt;config['schema']}",
                $this-&gt;config['user'],
                $this-&gt;config['password']
            );
        }

        return $this-&gt;connection;
    }
}</pre></div><p class="calibre8">Even though the focus of this <a id="id874" class="calibre1"/>chapter is to write acceptance tests, let's go through the different implemented methods:</p><div class="book"><ul class="itemizedlist"><li class="listitem">The constructor and <code class="email">getConnection</code> just read the configuration file in <code class="email">config/app.json</code> and instantiated the <code class="email">PDO</code> object.</li><li class="listitem">The <code class="email">createSchema</code> executed <code class="email">CREATE SCHEMA IF NOT EXISTS</code>, so if the schema already exists, it will do nothing. We executed the command with <code class="email">exec</code> instead of <code class="email">PDO</code> as <code class="email">PDO</code> always needs to use an existing database.</li><li class="listitem">The <code class="email">getLatestMigration</code> will first check whether the migrations table exists; if not, we will create it using <code class="email">setup.sql</code> and then fetch the last successful migration.</li></ul></div><p class="calibre8">We also need to add the <code class="email">migrations/setup.sql</code> file with the query to create the migrations table, as follows:</p><div class="informalexample"><pre class="programlisting">CREATE TABLE IF NOT EXISTS migrations(
  version INT UNSIGNED NOT NULL,
  `time` TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,
  status ENUM('success', 'error'),
  PRIMARY KEY (version, status)
);</pre></div><p class="calibre8">Finally, we need to add the <code class="email">migrate.php</code> file, which is the one that the user will execute. This file will get the configuration, instantiate the <code class="email">Schema</code> class, set up the database, and retrieve the last migration applied. Run the following code:</p><div class="informalexample"><pre class="programlisting">&lt;?php

require_once __DIR__ . '/vendor/autoload.php';

$configFileContent = file_get_contents(__DIR__ . '/config/app.json');
$config = json_decode($configFileContent, true);

$schema = new Migrations\Schema($config);

$schema-&gt;createSchema();

$version = $schema-&gt;getLatestMigration();
echo "Latest version applied is $version.\n";</pre></div><p class="calibre8">You are now good to run the<a id="id875" class="calibre1"/> tests again. This time, the output should be similar to this screenshot, where all the steps are in green:</p><div class="mediaobject"><img src="../images/00051.jpeg" alt="Running feature tests" class="calibre9"/></div><p class="calibre10"> </p><p class="calibre8">Now that our acceptance test is passing, we need to add the rest of the tests. To make things quicker, we will add all the scenarios, and then we will implement the necessary code to make them pass, but<a id="id876" class="calibre1"/> it would be better if you add one scenario at a time. The second scenario of <code class="email">setup.feature</code> could look as follows (remember that the feature contains a <code class="email">Background</code> section, in which we clean the database):</p><div class="informalexample"><pre class="programlisting">Scenario: Schema does not exists and I have migrations
  Given I have migration file 1:
    """
    CREATE TABLE test1(id INT);
    """
  And I have migration file 2:
    """
    CREATE TABLE test2(id INT);
    """
  When I run the migrations script
  Then I should only have the following tables:
    | migrations |
    | test1      |
    | test2      |
  And I should have the following migrations:
    | 1 | success |
    | 2 | success |
  And I should get:
    """
    Latest version applied is 0.
    Applied migration 1 successfully.
    Applied migration 2 successfully.
    """</pre></div><p class="calibre8">This scenario is important as it used parameters inside the step definitions. For example, the <span class="strong"><em class="calibre12">I have migration file</em></span> step is presented twice, each time with a different migration file number. The implementation of this step is as follows:</p><div class="informalexample"><pre class="programlisting">/**
 * @Given I have migration file :version:
 */
public function iHaveMigrationFile(
    string $version,
    PyStringNode $file
) {
    $filePath = __DIR__ . "/../../db/migrations/$version.sql";
    file_put_contents($filePath, $file-&gt;getRaw());
}</pre></div><p class="calibre8">The annotation of this method, which is a regular expression, used <code class="email">:version</code> as a wildcard. Any step that starts with <span class="strong"><em class="calibre12">Given I have migration file</em></span> followed by something else will match this step definition, and the "something else" bit will be received as the <code class="email">$version</code> argument as a string.</p><p class="calibre8">Here, we introduced yet another type of argument: tables. The <span class="strong"><em class="calibre12">Then I should only have the following tables</em></span> step<a id="id877" class="calibre1"/> defined a table of two rows of one column each, and the <span class="strong"><em class="calibre12">Then I should have the following migrations</em></span> bit sent a table of two rows of two columns each. The implementation for the new steps is as follows:</p><div class="informalexample"><pre class="programlisting">/**
 * @Then I should only have the following tables:
 */
public function iShouldOnlyHaveTheFollowingTables(TableNode $tables) {
    $tablesInDb = $this-&gt;getDb()
        -&gt;query('SHOW TABLES')
        -&gt;fetchAll(PDO::FETCH_NUM);

    assertEquals($tablesInDb, array_values($tables-&gt;getRows()));
}

/**
 * @Then I should have the following migrations:
 */
public function iShouldHaveTheFollowingMigrations(
    TableNode $migrations
) {
    $query = 'SELECT version, status FROM migrations';
    $migrationsInDb = $this-&gt;getDb()
        -&gt;query($query)
        -&gt;fetchAll(PDO::FETCH_NUM);

    assertEquals($migrations-&gt;getRows(), $migrationsInDb);
}</pre></div><p class="calibre8">The tables are received as <code class="email">TableNode</code> arguments. This class contains a <code class="email">getRows</code> method that returns an array with the rows defined in the feature file.</p><p class="calibre8">The other feature that we would like to add is <code class="email">features/migrations.feature</code>. This feature will assume that the user already has the database set up, so we will add a <code class="email">Background</code> section with this step. We will add one scenario in which the migration file numbers are not consecutive, in which case the application should stop at the last consecutive migration file. The other scenario will make sure that when there is an error, the application does not <a id="id878" class="calibre1"/>continue the migration process. The feature should look similar to the following:</p><div class="informalexample"><pre class="programlisting">Feature: Migrations
  In order to add changes to my database schema
  As a developer
  I need to be able to run the migrations script

  Background:
    Given I have the bdd_db_test

  Scenario: Migrations are not consecutive
    Given I have migration 3
    And I have migration file 4:
      """
      CREATE TABLE test4(id INT);
      """
    And I have migration file 6:
      """
      CREATE TABLE test6(id INT);
      """
    When I run the migrations script
    Then I should only have the following tables:
      | migrations |
      | test4      |
    And I should have the following migrations:
      | 3 | success |
      | 4 | success |
    And I should get:
      """
      Latest version applied is 3.
      Applied migration 4 successfully.
      """

  Scenario: A migration throws an error
    Given I have migration file 1:
      """
      CREATE TABLE test1(id INT);
      """
    And I have migration file 2:
      """
      CREATE TABLE test1(id INT);
      """
    And I have migration file 3:
      """
      CREATE TABLE test3(id INT);
      """
    When I run the migrations script
    Then I should only have the following tables:
      | migrations |
      | test1      |
    And I should have the following migrations:
      | 1 | success |
      | 2 | error   |
    And I should get:
      """
      Latest version applied is 0.
      Applied migration 1 successfully.
      Error applying migration 2: Table 'test1' already exists.
      """</pre></div><p class="calibre8">There aren't any new <a id="id879" class="calibre1"/>Gherkin features. The two new step implementations look as follows:</p><div class="informalexample"><pre class="programlisting">/**
* @Given I have the bdd_db_test
*/
public function iHaveTheBddDbTest()
{
    $this-&gt;executeQuery('CREATE SCHEMA bdd_db_test');
}

/**
 * @Given I have migration :version
 */
public function iHaveMigration(string $version)
{
    $this-&gt;getDb()-&gt;exec(
        file_get_contents(__DIR__ . '/../../db/setup.sql')
    );

    $query = &lt;&lt;&lt;SQL
INSERT INTO migrations (version, status)
VALUES(:version, 'success')
SQL;
    $this-&gt;getDb()
        -&gt;prepare($query)
        -&gt;execute(['version' =&gt; $version]);
}</pre></div><p class="calibre8">Now, it is time to add the needed implementation to make the tests pass. There are only two changes needed. The first one is an <code class="email">applyMigrationsFrom</code> method in the <code class="email">Schema</code> class that, given a version number, will try to apply the migration file for this number. If the migration is successful, it will add a row in the migrations table, with the new version added successfully. If the migration failed, we would add the record in the migrations table as a failure and then throw an exception so that the script is aware of it. Finally, if the migration file does not<a id="id880" class="calibre1"/> exist, the returning value will be <code class="email">false</code>. Add this code to the <code class="email">Schema</code> class:</p><div class="informalexample"><pre class="programlisting">public function applyMigrationsFrom(int $version): bool
{
    $filePath = self::MIGRATIONS_DIR . "$version.sql";

    if (!file_exists($filePath)) {
        return false;
    }

    $connection = $this-&gt;getConnection();
    if ($connection-&gt;exec(file_get_contents($filePath)) === false) {
        $error = $connection-&gt;errorInfo()[2];
        $this-&gt;registerMigration($version, 'error');
        throw new Exception($error);
    }

    $this-&gt;registerMigration($version, 'success');
    return true;
}

private function registerMigration(int $version, string $status)
{
    $query = &lt;&lt;&lt;SQL
INSERT INTO migrations (version, status)
VALUES(:version, :status)
SQL;
    $params = ['version' =&gt; $version, 'status' =&gt; $status];

    $this-&gt;getConnection()-&gt;prepare($query)-&gt;execute($params);
}</pre></div><p class="calibre8">The other bit missing is in the <code class="email">migrate.php</code> script. We need to call the newly created <code class="email">applyMigrationsFrom</code> method with consecutive versions starting from the latest one, until we get either a <code class="email">false</code> value or an exception. We also want to print out information about what is going on so that the user is aware of what migrations were added. Add the following code at the end of the <code class="email">migrate.php</code> script:</p><div class="informalexample"><pre class="programlisting">do {
    $version++;

    try {
        $result = $schema-&gt;applyMigrationsFrom($version);
        if ($result) {
            echo "Applied migration $version successfully.\n";
        }
    } catch (Exception $e) {
        $error = $e-&gt;getMessage();
        echo "Error applying migration $version: $error.\n";
        exit(1);
    }
} while ($result);</pre></div><p class="calibre8">Now, run the tests and voilà! They all pass. You now have a library that manages database migrations, and<a id="id881" class="calibre1"/> you are 100% sure that it works thanks to your acceptance tests.</p></div></div>

<div id="page" style="height:0pt"/><div class="book" title="Testing with a browser using Mink" id="2LQIK1-edcc22b134104d5db0bf3aa086c86851"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch10lvl1sec85" class="calibre1"/>Testing with a browser using Mink</h1></div></div></div><p class="calibre8">So far, we have been able<a id="id882" class="calibre1"/> to write acceptance tests for a script, but most of you are reading this book in order to write nice and shiny web applications. How can you take advantage of acceptance tests then? It is time to introduce the second PHP tool of this chapter: Mink.</p><p class="calibre8">Mink is actually an extension of Behat, which adds implementations of several steps related to web browser testing. For example, if you add Mink to your application, you will be able to add scenarios where Mink will launch a browser and click or type as requested, saving you a lot of time and effort in manual testing. However, first, let's take a look at how Mink can achieve this.</p></div>

<div class="book" title="Testing with a browser using Mink" id="2LQIK1-edcc22b134104d5db0bf3aa086c86851">
<div class="book" title="Types of web drivers"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_1"><a id="ch10lvl2sec172" class="calibre1"/>Types of web drivers</h2></div></div></div><p class="calibre8">Mink makes use <a id="id883" class="calibre1"/>of web drivers—that is, libraries that have an API that allows you to interact with a browser. You can send commands, such as <span class="strong"><em class="calibre12">go to this page</em></span>, <span class="strong"><em class="calibre12">click on this link</em></span>, <span class="strong"><em class="calibre12">fill this input field with this text</em></span>, and so on, and the web driver will translate this into the correct instruction for your browser. There are several web drivers, each of them implemented following a different approach. It is for this reason that depending on the web driver, you will have some features or others.</p><p class="calibre8">Web drivers can be divided into two groups depending on how they work:</p><div class="book"><ul class="itemizedlist"><li class="listitem"><span class="strong"><strong class="calibre2">Headless browsers</strong></span>: These drivers do not really launch a browser; they only try to emulate one. They actually request for the web page and render the HTML and JavaScript code, so they are aware of how the page looks, but they do not display it. They have a huge benefit: they are easy to install and manage, and as they do not have to build the graphical representation, they are extremely fast. The disadvantage is that they have severe restrictions in terms of CSS and some JavaScript functionalities, especially AJAX.</li><li class="listitem"><span class="strong"><strong class="calibre2">Web drivers that launch real browsers like a user would do</strong></span>: These web drivers can do almost anything and are way more powerful than headless browsers. The problem is that they can be a bit tricky to install and are very, very slow—as slow as a real user trying to go through the scenarios.</li></ul></div><p class="calibre8">So, which one should you choose? As always, it will depend on what your application is. If you have an application that does not make heavy use of CSS and JavaScript and it is not critical for your business, you could use headless browsers. Instead, if the application is the cornerstone of your business and you need to be absolutely certain that all the UI features work as expected, you might want to go for web drivers that launch browsers.</p></div></div>

<div class="book" title="Testing with a browser using Mink" id="2LQIK1-edcc22b134104d5db0bf3aa086c86851">
<div class="book" title="Installing Mink with Goutte"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_2"><a id="ch10lvl2sec173" class="calibre1"/>Installing Mink with Goutte</h2></div></div></div><p class="calibre8">In this <a id="id884" class="calibre1"/>chapter, we will use <span class="strong"><strong class="calibre2">Goutte</strong></span>, a headless web driver<a id="id885" class="calibre1"/> written by the same guys that worked on <span class="strong"><strong class="calibre2">Symfony</strong></span>, to add<a id="id886" class="calibre1"/> some acceptance tests to the repositories page of GitHub. The required<a id="id887" class="calibre1"/> components of your project will be Behat, Mink, and the Goutte driver. Add them with Composer via the following commands:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong class="calibre2">$ composer require behat/behat</strong></span>
<span class="strong"><strong class="calibre2">$ composer require behat/mink-extension</strong></span>
<span class="strong"><strong class="calibre2">$ composer require behat/mink-goutte-driver</strong></span>
</pre></div><p class="calibre8">Now, execute the following line to ask Behat to create the basic directory structure:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong class="calibre2">$ ./vendor/bin/behat –init</strong></span>
</pre></div><p class="calibre8">The only change we will add to the <code class="email">FeatureContext</code> class is where it extends from. This time, we will use <code class="email">MinkContext</code> in order to get all the step definitions related to web testing. The <code class="email">FeatureContext</code> class should look similar to this:</p><div class="informalexample"><pre class="programlisting">&lt;?php

use Behat\MinkExtension\Context\MinkContext;

require __DIR__ . '/../../vendor/autoload.php';

class FeatureContext extends MinkContext {
}</pre></div><p class="calibre8">Mink also needs <a id="id888" class="calibre1"/>some configuration in order to let Behat know which <a id="id889" class="calibre1"/>web driver we want to use or what the base URL<a id="id890" class="calibre1"/> for our tests is. Add the following information to <code class="email">behat.yml</code>:</p><div class="informalexample"><pre class="programlisting">default:
  extensions:
    Behat\MinkExtension:
      base_url: "https://github.com"
      sessions:
        default_session:
          goutte: ~</pre></div><p class="calibre8">With this configuration, we let Behat know that we are using the Mink extension, that Mink will use Goutte in all the sessions (you could actually define different sessions with different web drivers if necessary), and that the base URL for these tests is the GitHub one. Behat is already instructed to look for the <code class="email">behat.yml</code> file in the same directory that we executed it in, so there is nothing else that we need to do.</p></div></div>

<div class="book" title="Testing with a browser using Mink" id="2LQIK1-edcc22b134104d5db0bf3aa086c86851">
<div class="book" title="Interaction with the browser"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_3"><a id="ch10lvl2sec174" class="calibre1"/>Interaction with the browser</h2></div></div></div><p class="calibre8">Now, let's look at the magic. If <a id="id891" class="calibre1"/>you know the steps to use, writing acceptance tests with Mink will be like a game. First, add the following feature in <code class="email">feature/search.feature</code>:</p><div class="informalexample"><pre class="programlisting">Feature: Search
  In order to find repositories
  As a website user
  I need to be able to search repositories by name

  Background:
    Given I am on "/picahielos"
    And I follow "Repositories"

  Scenario: Searching existing repository
    When I fill in "zap" for "q"
    And I press "Search"
    Then I should see "picahielos/zap"

  Scenario: Searching non-existing repository
    When I fill in "yolo" for "q"
    And I press "Search"
    Then I should not see "picahielos/yolo"</pre></div><p class="calibre8">The first thing to note is that we have a <code class="email">Background</code> section. This section assumes that the user visited the <a class="calibre1" href="https://github.com/picahielos">https://github.com/picahielos</a> page and clicked on the <span class="strong"><strong class="calibre2">Repositories</strong></span> link. Using <span class="strong"><em class="calibre12">I follow</em></span> with some string is the equivalent of trying to find a link with this string and clicking on it.</p><p class="calibre8">The first scenario used the <span class="strong"><em class="calibre12">When I fill &lt;field&gt; with &lt;value&gt;</em></span> step, which basically tries to find the input field on the<a id="id892" class="calibre1"/> page (you can either specify the ID or name), and types the value for you. In this case, the <code class="email">q</code> field was the search bar, and we typed <code class="email">zap</code>. Then, similar to when clicking on the links, the <span class="strong"><em class="calibre12">I press &lt;button&gt;</em></span> line will try to find the button by name, ID, or value, and will click on it. Finally, <span class="strong"><em class="calibre12">Then I should see</em></span> followed by a string will assert that the given string could be found on the page. In short, the test launched a browser, going to the specified URL, clicking on the <span class="strong"><strong class="calibre2">Repositories</strong></span> link, searching for the <code class="email">zap</code> repository, and asserting that it could find it. In a similar way, the second scenario tried to find a repository that does not exist.</p><p class="calibre8">If you run the tests, they should pass, but you will not see any browser. Remember that Goutte is a headless browser web driver. However, check how fast these tests are executed; in my laptop, it took less than 3 seconds! Can you imagine anyone performing these two tests manually in less than this time?</p><p class="calibre8">One last thing: having a cheat sheet of predefined Mink steps is one of the handiest things to have near your desk; you can find one at <a class="calibre1" href="http://blog.lepine.pro/images/2012-03-behat-cheat-sheet-en.pdf">http://blog.lepine.pro/images/2012-03-behat-cheat-sheet-en.pdf</a>. As you can see, we did not write a single line of code, and we still have two tests making sure that the website works as expected. Also, if you need to add a fancier step, do not worry; you can still implement your step definitions as we did in Behat previously while taking advantage of the web driver's interface that Mink provides. We recommend you to go through the official documentation in order to take a look at the complete list of things that you can do with Mink.</p></div></div>
<div class="book" title="Summary" id="2MP361-edcc22b134104d5db0bf3aa086c86851"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch10lvl1sec86" class="calibre1"/>Summary</h1></div></div></div><p class="calibre8">In this concluding chapter, you learned how important it is to coordinate the business with the application. For this, you saw what BDD is and how to implement it with your PHP web applications using Behat and Mink. This also gives you the ability to test the UI with web drivers, which you could not do it with unit tests and PHPUnit. Now, you can make sure that not only is your application bug-free and secure, but also that it does what the business needs it to do.</p><p class="calibre8">Congratulations on reaching the end of the book! You started as an inexperienced developer, but now you are able to write simple and complex websites and REST APIs with PHP and have an extensive knowledge of good test practices. You have even worked with a couple of famous PHP frameworks, so you are ready to either start a new project with them or join a team that uses one of them.</p><p class="calibre8">Now, you might be wondering: what do I do next? You already know the theory—well, some of it—so we would recommend that you practice a lot. There are several ways you can do this: by creating your own application, joining a team working on open source projects, or working for a company. Try to keep up to date with new releases of the language or the tools and frameworks, discover a new framework from time to time, and never stop reading. Expanding your set of skills is always a great idea!</p><p class="calibre8">If you run out of ideas on what to read next, here are some hints. We did not go through the frontend part too much, so you might be interested in reading about CSS and specially JavaScript. JavaScript has become the main character in these last few years, so do not miss it out. If you are rather interested in the backend side and how to manage applications properly, try discovering new technologies, such as continuous integration tools similar to Jenkins. Finally, if you prefer to focus on the theory and "science" side, you can read about how to write quality code with <span class="strong"><em class="calibre12">Code Complete</em></span>, <span class="strong"><em class="calibre12">Steve McConnell</em></span>, or how to make good use of design patterns with <span class="strong"><em class="calibre12">Design Patterns: Elements of Reusable Object-Oriented Software</em></span>, <span class="strong"><em class="calibre12">Erich Gamma, John Vlissides, Ralph Johnson, and Richard Helm</em></span>, a gang of four.</p><p class="calibre8">Always enjoy and have fun when developing. Always!</p></div></body></html>