<html><head></head><body>
		<div id="_idContainer142">
			<h1 id="_idParaDest-165"><em class="italic"><a id="_idTextAnchor166"/>Chapter 9</em>: Configuring Entities and Rendering Data</h1>
			<p>In the previous chapter, we learned how the <strong class="bold">model-view-controller</strong> (<strong class="bold">MVC</strong>) development pattern works and then learned what views and model controllers are. We have also seen how the Pimcore routing system works and how to create relationships between elements. Finally, we saw how to modify the content of our entities, adding images, text, and date fields.</p>
			<p>In this chapter, we're going to create a blog, and we will cover the following topics:</p>
			<ul>
				<li>Defining blog classes</li>
				<li>Creating blog Users and Roles</li>
				<li>Routing</li>
				<li>Editing the Controller for our blog</li>
				<li>Rendering blog views</li>
				<li>Differences between Pimcore and WordPress</li>
			</ul>
			<p>By the end of this chapter, we will have built our first blog with Pimcore, with articles grouped by categories and authors. We will have also learned how to create suitable templates for each page, inserting the necessary code to display the content created.</p>
			<h1 id="_idParaDest-166"><a id="_idTextAnchor167"/>Technical requirements</h1>
			<p>As with the previous chapters, there is a demonstration that you can find on our GitHub repository, which you can access here: </p>
			<p><a href="https://github.com/PacktPublishing/Modernizing-Enterprise-CMS-using-Pimcore/">https://github.com/PacktPublishing/Modernizing-Enterprise-CMS-using-Pimcore/</a></p>
			<p>All you need to do to run the demo connected with this chapter is to navigate to the <strong class="source-inline">Full Demo</strong> folder and start the Docker environment.</p>
			<p>To read this chapter, the only requirement is to have an up-and-running Pimcore installation and be able to access it via the command line. </p>
			<p>If you have installed Pimcore with Docker, just run these simple instructions:</p>
			<ol>
				<li>Run Docker with the following command:<p class="source-code"><strong class="bold">docker-compose up</strong></p></li>
				<li>Restore the local installation settings by running this command:<p class="source-code"><strong class="bold">docker-compose exec php bash restore.sh</strong></p></li>
				<li>Navigate to <strong class="source-inline">http://localhost/admin</strong> and log in with your admin/pimcore credentials.</li>
			</ol>
			<p>You are now ready to put into practice all the aspects related to this chapter.</p>
			<h1 id="_idParaDest-167"><a id="_idTextAnchor168"/>Defining blog classes</h1>
			<p>As we<a id="_idIndexMarker573"/> said, a blog is made up of articles and categories, so the first step we need to do is to create two classes relating to these. In addition to these two classes, we have to create a third class: <strong class="source-inline">BlogAuthor</strong>. </p>
			<p>All the field types that we are going to use in our classes have already been seen and described in depth in <a href="B17073_05_ePub_RK.xhtml#_idTextAnchor093"><em class="italic">Chapter 5</em></a>, <em class="italic">Exploring Objects and Classes</em>, so what interests us in this chapter is to define them with their name and type. </p>
			<p>The only new element we use is the <strong class="source-inline">slug</strong> field, which for this reason we will briefly describe.</p>
			<p>A <strong class="bold">slug</strong> is <a id="_idIndexMarker574"/>a part of a <strong class="bold">Uniform Resource Locator</strong> (<strong class="bold">URL</strong>) that identifies a particular page on<a id="_idIndexMarker575"/> a website in an easy-to-read way. In other words, it's a part of a URL that explains a page's content—for example, for a URL of <a href="https://demo.pimcore.fun/slug">https://demo.pimcore.fun/slug</a>, the slug simply is <strong class="source-inline">/slug</strong>.</p>
			<p>Using a slug thus allows us to identify a page through a readable and more identifiable text, compared—for example—to its <a id="_idIndexMarker576"/>numeric <strong class="bold">identifier</strong> (<strong class="bold">ID</strong>). Furthermore, this improves the indexing of a page by search engines, which prefer text-based URLs<a id="_idIndexMarker577"/> rather than URLs with numbers.</p>
			<p>Let's take a look at each class we plan to create now.</p>
			<h2 id="_idParaDest-168"><a id="_idTextAnchor169"/>Defining a BlogArticle class</h2>
			<p>The <strong class="source-inline">BlogArticle</strong> class is<a id="_idIndexMarker578"/> where we will generate articles for our blog. The creation of this class has already been discussed in <a href="B17073_04_ePub_RK.xhtml#_idTextAnchor083"><em class="italic">Chapter 4</em></a>, <em class="italic">Creating Documents in Pimcore</em>; the fields in the following list are standard for any article, but nothing prevents you from adding more as needed:</p>
			<ul>
				<li><strong class="source-inline">Title</strong>: An <a id="_idIndexMarker579"/>input field</li>
				<li><strong class="source-inline">Content</strong>: A <strong class="bold">what you see is what you get</strong> (<strong class="bold">WYSIWYG</strong>) component</li>
				<li><strong class="source-inline">Category</strong>: A many-to-one relation of the <strong class="source-inline">BlogCategory</strong> class</li>
				<li><strong class="source-inline">Slug</strong>: A slug field</li>
				<li><strong class="source-inline">Author</strong>: A many-to-one relation with the <strong class="source-inline">BlogAuthor</strong> class</li>
				<li><strong class="source-inline">Image</strong>: An image component</li>
			</ul>
			<p>Let's jump directly to what our created class will look like. For convenience, we have grouped the fields in tabs, to make data entry more linear. In the next screenshot, here's what the newly created class looks like:</p>
			<div>
				<div id="_idContainer132" class="IMG---Figure">
					<img src="image/Figure_9.01_B17073.jpg" alt="Figure 9.1: BlogArticle class&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 9.1: BlogArticle class</p>
			<p>As you can see <a id="_idIndexMarker580"/>in the preceding screenshot, all fields are organized and are easy to recognize thanks to their respective icons.</p>
			<h2 id="_idParaDest-169"><a id="_idTextAnchor170"/>Defining a BlogCategory class</h2>
			<p>The category<a id="_idIndexMarker581"/> class is relatively simple—it is, as we said, a container of articles. It is used to group articles by topic, so only a few simple fields will be needed, as follows:</p>
			<ul>
				<li><strong class="source-inline">Title</strong>: An input field</li>
				<li><strong class="source-inline">Slug</strong>: A slug field</li>
				<li><strong class="source-inline">Description</strong>: A text-area field</li>
				<li><strong class="source-inline">Image</strong>: An image component</li>
			</ul>
			<p>We will see how to link articles with categories in the <em class="italic">Putting it all together</em> section.</p>
			<h2 id="_idParaDest-170"><a id="_idTextAnchor171"/>Defining a BlogAuthor class</h2>
			<p>As we said, an <a id="_idIndexMarker582"/>article is written by a person—or user, in computer terms—so, each article will have an author; that is, it must be associated with the user who wrote it. And in fact, in the <strong class="source-inline">Article</strong> class, we created an <strong class="source-inline">Author</strong> relationship field for just that.</p>
			<p>In Pimcore, on the other hand, user management is minimal and does not allow us to extend the user directly. Instead, it allows us to create a relation between a user and one or more Pimcore objects. This can be used to add information to a user or to associate one or more objects directly with a system user.</p>
			<p>To do this, we then create an additional class, <strong class="source-inline">BlogAuthor</strong>, so that we can extend the Pimcore user with other properties, such as <strong class="source-inline">FirstName</strong> and <strong class="source-inline">LastName</strong>, a photo, and a biography.</p>
			<p>The <strong class="source-inline">BlogAuthor</strong> class is composed of the following fields, whose names are already self-describing:</p>
			<ul>
				<li><strong class="source-inline">FirstName</strong>: A text field</li>
				<li><strong class="source-inline">LastName</strong>: A text field</li>
				<li><strong class="source-inline">User</strong>: A user field</li>
				<li><strong class="source-inline">Slug</strong>: A slug field</li>
				<li><strong class="source-inline">Bio</strong>: A text-area field</li>
				<li><strong class="source-inline">Photo</strong>: An image component</li>
				<li><strong class="source-inline">User</strong>: A user field</li>
			</ul>
			<p>A small clarification should be made for the <strong class="source-inline">User</strong> field. This field uses a component of Pimcore—the <strong class="source-inline">User</strong> type. In the next screenshot, we thus see what the <strong class="source-inline">User</strong> field looks like:</p>
			<div>
				<div id="_idContainer133" class="IMG---Figure">
					<img src="image/Figure_9.02_B17073.jpg" alt="Figure 9.2: User type field&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 9.2: User type field</p>
			<p>As you can see<a id="_idIndexMarker583"/> from the preceding screenshot, the configuration is not particularly complicated, and in fact, the only fields that we can populate will be the name and title of the field itself.</p>
			<p>When creating an object instance of the member class, you can see the input widget for the user property. This is a combo box where a user can be selected from all available Pimcore users. Let's see how to associate an author with a Pimcore user. The following screenshot illustrates the process:</p>
			<div>
				<div id="_idContainer134" class="IMG---Figure">
					<img src="image/Figure_9.03_B17073.jpg" alt="Figure 9.3: Linking author to Pimcore system use&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 9.3: Linking author to Pimcore system use</p>
			<p>In this example, the user <strong class="source-inline">Bob</strong> was selected. </p>
			<p>Now that we<a id="_idIndexMarker584"/> have created all the necessary classes for our blog, we still have to configure Pimcore with the users and roles necessary to ensure that the articles can be associated with their respective authors.</p>
			<h1 id="_idParaDest-171"><a id="_idTextAnchor172"/>Creating blog Users and Roles</h1>
			<p>The creation <a id="_idIndexMarker585"/>of users and roles has already been explained in <a href="B17073_07_ePub_RK.xhtml#_idTextAnchor129"><em class="italic">Chapter 7</em></a>, <em class="italic">Administrating Pimcore Sites</em>, so we just have to go back to the notions learned in that chapter to create the necessary users and roles. </p>
			<p>For this example, we can create two users, our dear <strong class="source-inline">Bob</strong> and <strong class="source-inline">Tom</strong> (our authors), and an author role to be assigned to our users.</p>
			<h2 id="_idParaDest-172"><a id="_idTextAnchor173"/>Creating an Author Role</h2>
			<p>First, we <a id="_idIndexMarker586"/>will create a role for the authors. The role configuration is shown in the next screenshot:</p>
			<div>
				<div id="_idContainer135" class="IMG---Figure">
					<img src="image/Figure_9.04_B17073.jpg" alt="Figure 9.4: BlogAuthor role configuration&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 9.4: BlogAuthor role configuration</p>
			<p>As you can see <a id="_idIndexMarker587"/>from the preceding screenshot, we have assigned the creation permission for the three classes of the blog: <strong class="source-inline">BlogArticle</strong>, <strong class="source-inline">BlogCategory</strong>, and <strong class="source-inline">BlogAuthor</strong>. This is because we need to allow users who are part of this role to manage these objects. In the <strong class="bold">Permissions</strong> section (which in <em class="italic">Figure 9.4</em> is compressed for reasons of space), we have selected the following items: <strong class="bold">Assets</strong>, <strong class="bold">Classes</strong>, <strong class="bold">Objects</strong>, and <strong class="bold">Users</strong>. This will allow users to upload images for their articles, and view the categories and articles created. </p>
			<p>A final configuration for the role, as you can see in the next screenshot, is the permissions for each class inside the <strong class="bold">Workspaces</strong> tab:</p>
			<div>
				<div id="_idContainer136" class="IMG---Figure">
					<img src="image/Figure_9.05_B17073.jpg" alt="Figure 9.5: BlogAuthors role workspace configuration&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 9.5: BlogAuthors role workspace configuration</p>
			<p>As you can see in the preceding screenshot, which represents the configuration of the role for each <a id="_idIndexMarker588"/>class, it will be necessary to set the permissions for users—in particular, for the possibility of creating articles, uploading or selecting images, or being able to see a list of authors and categories.</p>
			<h2 id="_idParaDest-173"><a id="_idTextAnchor174"/>Creating Users </h2>
			<p>Now that the<a id="_idIndexMarker589"/> configuration is complete, we can move on to create the actual entities, based on the classes we created. </p>
			<p>First, we need to create users <strong class="source-inline">Bob</strong> and <strong class="source-inline">Tom</strong> and assign them the author role. We have already learned how to create users and roles in <a href="B17073_07_ePub_RK.xhtml#_idTextAnchor129"><em class="italic">Chapter 7</em></a>, <em class="italic">Administrating Pimcore Sites</em>, so all we have to do is repeat the same operations already done.</p>
			<p>Once that's done, let's create authors. The creation of an author, as well as an article or a category, is done from the Pimcore interface, in the <strong class="bold">Data Objects</strong> section. </p>
			<p>For convenience, we have grouped the created objects into folders and subfolders, as you can see in the next screenshot:</p>
			<div>
				<div id="_idContainer137" class="IMG---Figure">
					<img src="image/Figure_9.06_B17073.jpg" alt="Figure 9.6: List of data objects and author Bob configuration&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 9.6: List of data objects and author Bob configuration</p>
			<p>As you can see <a id="_idIndexMarker590"/>in the preceding screenshot, we have created three folders that must contain the objects we are going to create. In particular, the <strong class="source-inline">Blog</strong>/<strong class="source-inline">Authors</strong> folder will contain all the authors we will create, the <strong class="source-inline">Blog</strong>/<strong class="source-inline">Categories</strong> folder will contain all the blog categories, and the <strong class="source-inline">Blog</strong>/<strong class="source-inline">Articles</strong> folder will contain all the articles written by the authors.</p>
			<p>In <em class="italic">Figure 9.6</em>, we can also see that the <strong class="source-inline">User</strong> field is a selection box, where it is possible to associate a user, and in our case, we have selected the system user <strong class="source-inline">Bob</strong>. We then finished filling in the <strong class="source-inline">FirstName</strong>, <strong class="source-inline">LastName</strong>, <strong class="source-inline">Slug</strong>, and <strong class="source-inline">Photo</strong> fields and completed a short biography in the <strong class="source-inline">Bio</strong> field. These fields will be displayed on the author page. </p>
			<h2 id="_idParaDest-174"><a id="_idTextAnchor175"/>Putting it all together</h2>
			<p>Once we have <a id="_idIndexMarker591"/>created classes for the blog, user, and author, we need to create data objects to represent on the pages: categories and articles. The creation of objects has already been seen in detail in <a href="B17073_04_ePub_RK.xhtml#_idTextAnchor083"><em class="italic">Chapter 4</em></a><em class="italic">,</em> <em class="italic">Creating Documents in Pimcore, </em>and <a href="B17073_05_ePub_RK.xhtml#_idTextAnchor093"><em class="italic">Chapter 5</em></a>, <em class="italic">Exploring Objects and Classes</em>, so it will not be necessary on this occasion to go into detail on how to do this. For our blog, however, we have created author categories and also uploaded the necessary images for the categories and articles. In the following example screenshot, we see the creation of a first article, with the necessary information and relationships:</p>
			<div>
				<div id="_idContainer138" class="IMG---Figure">
					<img src="image/Figure_9.07_B17073.jpg" alt="Figure 9.7: Creating our first article&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 9.7: Creating our first article</p>
			<p>As you can see in the previous screenshot, all the elements have been created, and therefore it is possible to create an article and assign it an author, a category, and an image previously loaded into the asset. The arrow drawn in <em class="italic">Figure 9.7</em> identifies the drag-and-drop operation of the category in the <strong class="source-inline">Category</strong> field of the article. The same drag-and-drop method can also be used to link the author and image to the corresponding fields in the article.</p>
			<p>It is also possible to see how we have grouped objects and assets in different folders. Organizing the directory structure is not mandatory, but it certainly helps to keep the objects we create grouped by type. As you can see from the next screenshot, it is possible to create folders to organize our items by right-clicking on <strong class="bold">Home</strong> or any other folder already created:</p>
			<div>
				<div id="_idContainer139" class="IMG---Figure">
					<img src="image/Figure_9.08_B17073.jpg" alt="Figure 9.8: Creating our first article&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 9.8: Creating our first article</p>
			<p>In the preceding screenshot, you see how we organized our folders, starting from the <strong class="source-inline">Blog</strong> folder, and<a id="_idIndexMarker592"/> inside it creating folders for articles, authors, and categories.</p>
			<p>The next step we must do is define the rules for navigation around our blog—or, in other words, the routing.</p>
			<h1 id="_idParaDest-175"><a id="_idTextAnchor176"/>Routing</h1>
			<p>Routing is a <a id="_idIndexMarker593"/>key part <a id="_idIndexMarker594"/>of setting up our blog and was discussed in detail in the previous chapter, <a href="B17073_08_ePub_RK.xhtml#_idTextAnchor139"><em class="italic">Chapter 8</em></a>, <em class="italic">Creating Custom CMS Pages</em>. We will therefore go on to create hardcoded routes, going directly to the <strong class="source-inline">routing.yml</strong> file to modify this.</p>
			<p>Let's create a set of rules that are needed in order to identify articles, categories, and author pages. In addition, we want pages to be accessed by using either our ID or our slug.  </p>
			<p>As an example, we report the two routing rules related to the article, in this following piece of code: </p>
			<p class="source-code"><strong class="bold">blog_article_by_id</strong>:</p>
			<p class="source-code">    <strong class="bold">path</strong>:      /blog/article/{page}</p>
			<p class="source-code">    <strong class="bold">controller</strong>: BlogBundle\Controller\BlogController:articleAction</p>
			<p class="source-code">    <strong class="bold">requirements</strong>:</p>
			<p class="source-code">      <strong class="bold">path</strong>: '.*?'</p>
			<p class="source-code">      <strong class="bold">page</strong>: <strong class="bold">'\d+'</strong></p>
			<p class="source-code"><strong class="bold">blog_article_by_slug</strong>:</p>
			<p class="source-code">    <strong class="bold">path</strong>:      /blog/article/{page}</p>
			<p class="source-code">    <strong class="bold">controller</strong>: BlogBundle\Controller\BlogController:articleAction</p>
			<p class="source-code">    <strong class="bold">requirements</strong>:</p>
			<p class="source-code">      <strong class="bold">path</strong>: '.*?'</p>
			<p class="source-code">      <strong class="bold">page</strong>: <strong class="bold">'[\w-]+'</strong></p>
			<p>As you can <a id="_idIndexMarker595"/>see in the preceding code snippet, we have defined a path for the<a id="_idIndexMarker596"/> display of an article, and we have also set the controller and the parameters needed to identify the article by the ID (<strong class="source-inline">blog_article_by_id</strong>) or by the slug (<strong class="source-inline">blog_article_by_slug</strong>). </p>
			<p>By analyzing the two rules, we can see that they differ only in the <strong class="source-inline">path</strong> parameter. In the case of the rule to identify the article by ID, in the path we have to search for an integer, which is the<a id="_idIndexMarker597"/> ID of the article. This is possible through the use of <strong class="bold">regular expressions</strong> (<strong class="bold">regexes</strong>). The regular expression that filters an integer is <strong class="source-inline">\d+</strong>. In the case of the rule that identifies the page through its slug, we must identify a string, and to do this we use the regex defined as <strong class="source-inline">[\w-]+</strong>. This last regex filters all strings composed of words, divided by the minus sign.</p>
			<p class="callout-heading">Important note</p>
			<p class="callout">A regular regular expression, also called a regex is a method of matching patterns in text—for example, a regular expression can describe the pattern of email addresses, URLs, telephone numbers, employee identification numbers, social security numbers, or credit card numbers, and of course routes to pages on a site. The use of regular expressions is standard practice in many system and scripting languages. Regular expressions can be simple or very complex. There are hundreds of guides on the subject, easily available on the internet, simply by looking for <strong class="source-inline">regex</strong> on any web search engine.</p>
			<p>We have seen how the rules for articles are defined. The <strong class="source-inline">routing.yml</strong> file also contains routing rules for categories and authors, which are defined in exactly the same way, except for the actions to be called on the <strong class="source-inline">BlogController</strong> controller.</p>
			<p>Now that we <a id="_idIndexMarker598"/>have completed the routing configuration, we must create actions <a id="_idIndexMarker599"/>on the controller so that our pages can contain and display the data that interests us. </p>
			<p>Let's go now to see how <strong class="source-inline">BlogController</strong> and its actions are written, which we have up to now seen in the routing rules. </p>
			<h1 id="_idParaDest-176"><a id="_idTextAnchor177"/>Editing the Controller for our blog</h1>
			<p>Everything <a id="_idIndexMarker600"/>about the controller has been explained in the previous chapter, <a href="B17073_08_ePub_RK.xhtml#_idTextAnchor139"><em class="italic">Chapter 8</em></a>, <em class="italic">Creating Custom CMS Pages</em>, and therefore in this chapter, we limit the scope to just see which changes we need to make for the blog to work properly. </p>
			<p>What we are interested in doing now is to create actions that correspond to the rules we have just finished configuring in the previous section. In fact, if we look at the configuration, we can see that the <strong class="source-inline">Controller</strong> field contains the name of the bundle (<strong class="source-inline">BlogBundle</strong>), followed by the <strong class="source-inline">Controller</strong> keyword, followed by the name of the controller (<strong class="source-inline">BlogController</strong>). The last part is the name of the action (<strong class="source-inline">articleAction</strong>) to be called when the browser URL matches the routing rule.</p>
			<p>To clarify these ideas, imagine we write this URL in our browser: <a href="https://myblog.com/blog/article/my-first-article">https://myblog.com/blog/article/my-first-article</a>. We uniquely identify a <strong class="source-inline">blog_article_by_slug</strong> rule. This rule, written in the configuration, indicates that the <strong class="source-inline">articleAction</strong> action is called in the <strong class="source-inline">BlogController</strong> controller of the <strong class="source-inline">BlogBundle</strong> bundle. So, with the URL that we have just written, we have identified an action that is called, which is the <strong class="source-inline">ArticleAction</strong> action. So, let's see how this action is written. </p>
			<h2 id="_idParaDest-177"><a id="_idTextAnchor178"/>Action for an article (ArticleAction)</h2>
			<p>As we have<a id="_idIndexMarker601"/> just mentioned, this action is called when the URL identifies the route that must display an article, by the ID or the slug. The first thing to do, therefore, will be to retrieve the article, based on the input parameter, as illustrated in the following code snippet:</p>
			<p class="source-code">/**</p>
			<p class="source-code"> *  Get detail of article. route: /blog/article/id|slug</p>
			<p class="source-code"> * @Template() </p>
			<p class="source-code"> */   </p>
			<p class="source-code">public function articleAction(Request $request,<strong class="bold">$page</strong>) {</p>
			<p class="source-code"><strong class="bold">  if (intval($page))</strong> { // by id</p>
			<p class="source-code">    $article = DataObject\BlogArticle::getById($page);</p>
			<p class="source-code">  }</p>
			<p class="source-code">  else { // by slug</p>
			<p class="source-code"><strong class="bold">    $slug = UrlSlug::resolveSlug("/$page");</strong></p>
			<p class="source-code">    if ($slug instanceof UrlSlug) {</p>
			<p class="source-code">      $id = $slug-&gt;getObjectId();</p>
			<p class="source-code">      if (intval($id) &amp;&amp; $id &gt; 0) {</p>
			<p class="source-code">        $article =  DataObject\BlogArticle::getById($id);</p>
			<p class="source-code">      }</p>
			<p class="source-code">    }         </p>
			<p class="source-code">  }</p>
			<p class="source-code">  if ( !( $article instanceof DataObject\BlogArticle ||   $article-&gt;isPublished() ) ) {</p>
			<p class="source-code">    // article not found, redirect to blog</p>
			<p class="source-code">    return $this-&gt;redirect('/blog');</p>
			<p class="source-code">  }</p>
			<p class="source-code">  return $this-&gt;renderTemplate(</p>
			<p class="source-code">    '<strong class="bold">@Blog/Blog/article.html.twig</strong>',array(</p>
			<p class="source-code">        // get all categories for widget</p>
			<p class="source-code">        'categories' =&gt; $this-&gt;getAllCategories(), </p>
			<p class="source-code">        'article' =&gt; $article</p>
			<p class="source-code">  ));</p>
			<p class="source-code">}</p>
			<p>As you can see from the preceding code snippet, the <strong class="source-inline">articleAction</strong> function takes two parameters: <strong class="source-inline">request</strong> and <strong class="source-inline">page</strong>. The <strong class="source-inline">page</strong> parameter is what interests us, to understand whether we have an ID or a slug in the URL. </p>
			<p>First of all, we <a id="_idIndexMarker602"/>need to check whether the input parameter in the <strong class="source-inline">$page</strong> variable is of the integer type and retrieve the value it represents. To read an integer from a string, we can use the <strong class="source-inline">intval</strong> function of the PHP language, which gets the integer value of a variable. If the <strong class="source-inline">intval</strong> function returns us an integer value, it means we have an ID. To retrieve an object through its ID, you can use the <strong class="source-inline">getById</strong> function, which Pimcore makes available in all objects. If instead, the <strong class="source-inline">$page</strong> variable is not an integer, then free text has been entered in the URL, which can be the slug of the article. We must then retrieve the object ID via the slug, and once retrieved, we are able to retrieve the object via its ID, exactly as we have just done.</p>
			<p>Once the object has been retrieved, we verify that it is an object of type <strong class="source-inline">article</strong>. This is done with the following <strong class="source-inline">if</strong> statement:</p>
			<p class="source-code">if ( !( $article instanceof DataObject\BlogArticle || $article-&gt;isPublished() ) ) {</p>
			<p>The first part, the <strong class="source-inline">instanceof</strong> construct, is useful for checking whether an object is of the <strong class="source-inline">BlogArticle</strong> type; the second part of the <strong class="source-inline">if</strong> statement uses a specific Pimcore function, <strong class="source-inline">isPublished()</strong>, which checks whether the document is published. At this point, if everything is correct, we just have to call the <strong class="source-inline">RenderTemplate</strong> function, a function that accepts two parameters: first, the path of the Twig template file, and second, an array of objects to pass to the view. In our example, we passed the path to the article page template (<strong class="source-inline">@Blog/Blog/article.html.twig</strong>) and an array with the two objects necessary for rendering the page view: the article and the list of categories (we will see shortly how to use these variables in the view). For further details on how the MVC pattern<a id="_idIndexMarker603"/> works, and about the passage of data from routing to the controller and from the controller to the view, please read <a href="B17073_08_ePub_RK.xhtml#_idTextAnchor139"><em class="italic">Chapter 8</em></a>, <em class="italic">Creating Custom CMS Pages</em>.</p>
			<h2 id="_idParaDest-178"><a id="_idTextAnchor179"/>Other Actions</h2>
			<p>We have just seen how to write an <strong class="source-inline">ArticleAction</strong> action, linked to the routing rules. The other rules that are present in the <strong class="source-inline">routing.yml</strong> file, which identify the categories and authors, will have their actions, which are written exactly like the action article just seen. </p>
			<p>Inspecting the <strong class="source-inline">BlogController</strong> code, we can easily see that all actions have the same structure because they perform the same operations. The purpose of these operations is to identify an object by its ID. The only thing that changes is the object that is recovered, which in one case is the article, in another the category, and in yet another, the author. </p>
			<p>Since the<a id="_idIndexMarker604"/> code<a id="_idIndexMarker605"/> for each<a id="_idIndexMarker606"/> action is very similar between actions, it is not necessary to see in detail the other actions, but we only report a list of actions that must be present in the controller, outlined as follows:</p>
			<ul>
				<li><strong class="source-inline">blogAction</strong></li>
				<li><strong class="source-inline">articleAction</strong></li>
				<li><strong class="source-inline">categoryAction</strong></li>
				<li><strong class="source-inline">authorAction</strong></li>
			</ul>
			<p>All the files used for this demo—such as <strong class="source-inline">routing.yml</strong>, <strong class="source-inline">BlogController.php</strong>, and all the <strong class="source-inline">*.html.twig</strong> files of the views—can be downloaded from our Git repository related to this book: <a href="https://github.com/PacktPublishing/Modernizing-Enterprise-CMS-using-Pimcore/">https://github.com/PacktPublishing/Modernizing-Enterprise-CMS-using-Pimcore/</a>. </p>
			<p>We have seen how routes are defined and what the actions related to them are within the controller. Now, let's go through the files and the code needed to view the data we have recovered in this section.</p>
			<h1 id="_idParaDest-179"><a id="_idTextAnchor180"/>Rendering blog views</h1>
			<p>Once we have <a id="_idIndexMarker607"/>identified which page a visitor requested, through the routing rules seen before, and after the data has been extracted and passed to the view through the controller, it remains for this to be displayed correctly on the page. In Pimcore, this can be done using a templating<a id="_idIndexMarker608"/> system called <strong class="bold">Twig</strong>, which as we said in <a href="B17073_04_ePub_RK.xhtml#_idTextAnchor083"><em class="italic">Chapter 4</em></a>,<em class="italic"> Creating Documents in Pimcore</em>, is the solution with which Pimcore keeps the business logic separate from the presentation logic.</p>
			<p>Briefly, Twig is a modern template engine for PHP supported by Symfony (and therefore by Pimcore) that allows you to process code directly in the view page, through its own syntax. The official page of the project, from which it is possible to read the complete documentation, can be reached here: <a href="https://twig.symfony.com/">https://twig.symfony.com/</a>.</p>
			<p>The template is useful and necessary because it is possible to create a single view for different <a id="_idIndexMarker609"/>content. In other words, the templating allows us to create a single HTML page to view all the articles of our blog, whether they are a few or in the millions. The view of the page will be the same for everyone—only the content will change. This saves us from having to create a page for each article, which would be a long and useless job.</p>
			<p>So, there are four templates we need to create, as follows:</p>
			<ol>
				<li value="1"><strong class="source-inline">blog</strong>: This is the main page of the blog, which will contain a list of categories.</li>
				<li><strong class="source-inline">category</strong>: This is the category page, which will contain all the articles under this category.</li>
				<li><strong class="source-inline">article</strong>: The actual article page, where the user can read the article content.</li>
				<li><strong class="source-inline">author</strong>: A page containing information about the author, with a name and photo, and a list of their articles.</li>
			</ol>
			<p>We will talk about these four templates shortly; however, first, we will mention how the pages were<a id="_idIndexMarker610"/> created in HTML and <strong class="bold">Cascading Style Sheets</strong> (<strong class="bold">CSS</strong>).</p>
			<h2 id="_idParaDest-180"><a id="_idTextAnchor181"/>Stylization and layout of HTML pages with Bootstrap</h2>
			<p>Before<a id="_idIndexMarker611"/> talking about the <a id="_idIndexMarker612"/>blog template page, we need to <a id="_idIndexMarker613"/>understand how the pages were made. The pages were written in <strong class="bold">HTML</strong>, with some Twig code snippets, while using Bootstrap for graphic <a id="_idIndexMarker614"/>styles and layouts. <strong class="bold">Bootstrap</strong> is a collection of graphic, stylistic, and layout tools that allow you to have a large number of features and styles that can be modified and adapted according to your needs. You can learn more about this framework <a id="_idIndexMarker615"/>on the official project page here: <a href="https://getbootstrap.com/">https://getbootstrap.com/</a>.</p>
			<p>The main component of <a id="_idIndexMarker616"/>Bootstrap is the <strong class="bold">Grid System</strong>. This component allows you to create layouts, dividing the space into <strong class="bold">rows</strong> and <strong class="bold">columns</strong>. These layouts will be the starting point for building our template. In addition to the classes for creating a layout, Bootstrap provides a set of CSS classes that stylize the elements of the HTML, such as titles, paragraphs, tables, buttons, and so on. Then, there are the other JavaScript components—that is, elements such as drop-down menus, tab interfaces, tooltips, alerts, accordion menus, sliders, and navigation banners. </p>
			<p>After this brief but necessary introduction to Bootstrap, let's get back to our blog. Using the Bootstrap system grid, we have created some layouts, dividing the pages into columns. In the next screenshot, you can see the three types of layouts we used:</p>
			<div>
				<div id="_idContainer140" class="IMG---Figure">
					<img src="image/Figure_9.09_B17073.jpg" alt="Figure 9.9: Template layouts&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 9.9: Template layouts</p>
			<p>As you can see, we have three different layouts for the page, outlined as follows:</p>
			<ul>
				<li>In the first layout, the content has not been divided, and therefore we have a column that occupies twelve-twelfths of the space. </li>
				<li>In the second layout, the content has been divided into two columns—one with four-twelfths of space and the other with eight-twelfths. </li>
				<li>In the third layout, as in the previous layout, the content is divided into two columns of different sizes, but in reverse order compared to the second layout.</li>
			</ul>
			<p>We used the first layout with no division for the main blog page, the second with the small column on the left for the author page, and the third for the article and category pages.</p>
			<p>Let's see how this<a id="_idIndexMarker617"/> was done in the <a id="_idIndexMarker618"/>HTML page. To <a id="_idIndexMarker619"/>make the layout, we used Bootstrap classes to define the size of the columns. For the first layout, we have the following:</p>
			<p class="source-code"> &lt;!-- Page Blog Content --&gt;</p>
			<p class="source-code">  &lt;div class="container"&gt;</p>
			<p class="source-code">    &lt;div class="row"&gt;</p>
			<p class="source-code">      &lt;!-- Post Content Column --&gt;</p>
			<p class="source-code">      &lt;div class="<strong class="bold">col-lg-12</strong>"&gt;… here the content</p>
			<p class="source-code">      &lt;/div&gt;</p>
			<p class="source-code">    &lt;/div&gt; &lt;!-- row --&gt;</p>
			<p class="source-code">  &lt;/div&gt; &lt;!-- container --&gt;</p>
			<p> For the second layout, we have the following:</p>
			<p class="source-code">&lt;!-- Page Content --&gt;</p>
			<p class="source-code">  &lt;div class="container"&gt;</p>
			<p class="source-code">    &lt;div class="row"&gt;</p>
			<p class="source-code">      &lt;!-- Post Content Column --&gt;</p>
			<p class="source-code">      &lt;div class="<strong class="bold">col-md-4</strong>"&gt;… here the content</p>
			<p class="source-code">      &lt;/div&gt;</p>
			<p class="source-code">      &lt;!-- Sidebar Widgets Column --&gt;</p>
			<p class="source-code">      &lt;div class="<strong class="bold">col-lg-8</strong>"&gt;… here the content</p>
			<p class="source-code">      &lt;/div&gt;</p>
			<p class="source-code">    &lt;/div&gt; &lt;!-- row --&gt;</p>
			<p class="source-code">  &lt;/div&gt; &lt;!-- container --&gt;</p>
			<p>Finally, for<a id="_idIndexMarker620"/> the third<a id="_idIndexMarker621"/> layout, we have the <a id="_idIndexMarker622"/>following:</p>
			<p class="source-code">&lt;!-- Page Content --&gt;</p>
			<p class="source-code">  &lt;div class="container"&gt;</p>
			<p class="source-code">    &lt;div class="row"&gt;</p>
			<p class="source-code">      &lt;!-- Post Content Column --&gt;</p>
			<p class="source-code">      &lt;div class="<strong class="bold">col-lg-8</strong>"&gt;… here the content</p>
			<p class="source-code">      &lt;/div&gt;</p>
			<p class="source-code">      &lt;!-- Sidebar Widgets Column --&gt;</p>
			<p class="source-code">      &lt;div class="<strong class="bold">col-md-4</strong>"&gt;… here the content</p>
			<p class="source-code">      &lt;/div&gt;</p>
			<p class="source-code">    &lt;/div&gt; &lt;!-- row --&gt;</p>
			<p class="source-code">  &lt;/div&gt; &lt;!-- container --&gt;</p>
			<p>In this section, we have briefly but clearly seen how the layouts for our template were created. In the next section, we will see how to write the code inside the view files that make up our template.</p>
			<h2 id="_idParaDest-181"><a id="_idTextAnchor182"/>Templating</h2>
			<p>The template<a id="_idIndexMarker623"/> files are <strong class="source-inline">*.html.twig</strong> files, and with Twig, we are able to insert <a id="_idIndexMarker624"/>the data coming from the controller. The layout and graphic style part is done via Bootstrap, as we saw in the previous section. We can report the four templates we have already defined as the following list, with the route to which they respond and the corresponding template file:</p>
			<ol>
				<li value="1">Blog: <ul><li>Route: <strong class="source-inline">/blog</strong></li><li>Twig file path: <strong class="source-inline">BlogBundle/Resources/views/Blog/blog.html.twig</strong></li></ul></li>
				<li>Category: <ul><li>Route: <strong class="source-inline">/blog/category/{page}</strong></li><li>Twig file path: <strong class="source-inline">BlogBundle/Resources/views/Blog/category.html.twig</strong></li></ul></li>
				<li>Article: <ul><li>Route: <strong class="source-inline">/blog/article/{page}</strong></li><li>Twig file path: <strong class="source-inline">BlogBundle/Resources/views/Blog/article.html.twig</strong></li></ul></li>
				<li>Author:<ul><li>Route: <strong class="source-inline">/blog/author/{page}</strong></li><li>Twig file path: <strong class="source-inline">BlogBundle/Resources/views/Blog/author.html.twig</strong></li></ul></li>
			</ol>
			<p>So, let's see how a complete template is made. As an example, we will take the template of the article.</p>
			<h2 id="_idParaDest-182"><a id="_idTextAnchor183"/>Inspecting the Article view</h2>
			<p>In order to <a id="_idIndexMarker625"/>understand how the template was made, the best thing is to report the code and describe the parts one piece at a time. So, let's start with the complete template code of the <strong class="source-inline">article.html.twig</strong> file, as follows:</p>
			<p class="source-code">{% <strong class="bold">extends '@Blog/Layout/layout.html.twig'</strong> %}</p>
			<p class="source-code"><strong class="bold">{% block content %}</strong></p>
			<p class="source-code">  {% <strong class="bold">include '@Blog/Layout/header.html.twig'</strong> %}</p>
			<p class="source-code">  &lt;!-- Page Content --&gt;</p>
			<p class="source-code">  &lt;div class="container"&gt;</p>
			<p class="source-code">    &lt;div class="row"&gt;</p>
			<p class="source-code">      &lt;!-- Post Content Column --&gt;</p>
			<p class="source-code">      &lt;div class="col-lg-8"&gt;</p>
			<p class="source-code">        &lt;!-- Title --&gt;</p>
			<p class="source-code">        &lt;h1 class="mt-4<strong class="bold">"&gt;{{article.getTitle()}}</strong>&lt;/h1&gt;</p>
			<p class="source-code">        &lt;!-- Author --&gt;</p>
			<p class="source-code">        &lt;p class="lead"&gt;</p>
			<p class="source-code">          by &lt;a href="/blog/author<strong class="bold">{{article.getAuthor().          getSlug()[0].getSlug()}}"&gt;{{article.getAuthor().          getFirstName()}}</strong>&lt;/a&gt;</p>
			<p class="source-code">        &lt;/p&gt;</p>
			<p class="source-code">        &lt;hr&gt;</p>
			<p class="source-code">        &lt;!-- Date/Time --&gt;</p>
			<p class="source-code">        &lt;p&gt;Posted on <strong class="bold">{{article.getModificationDate() | date("F         jS \\a\\t g:ia") }}</strong>&lt;/p&gt;</p>
			<p class="source-code">        &lt;hr&gt;</p>
			<p class="source-code">        &lt;!-- Preview Image --&gt;</p>
			<p class="source-code">        &lt;img class="img-fluid rounded" src<strong class="bold">="{{article.        getImage()}}</strong>" alt=""&gt;</p>
			<p class="source-code">        &lt;hr&gt;</p>
			<p class="source-code">        &lt;!-- Post Content --&gt;</p>
			<p class="source-code">        <strong class="bold">{{article.getContent() | raw}}  </strong></p>
			<p class="source-code">        &lt;hr&gt;</p>
			<p class="source-code">      &lt;/div&gt;</p>
			<p class="source-code">      &lt;!-- Sidebar Widgets Column --&gt;</p>
			<p class="source-code">      &lt;div class="col-md-4"&gt;</p>
			<p class="source-code"><strong class="bold">         {% include '@Blog/Widget/widget.html.twig' %}</strong></p>
			<p class="source-code">      &lt;/div&gt;</p>
			<p class="source-code">    &lt;/div&gt;</p>
			<p class="source-code">    &lt;!-- /.row --&gt;</p>
			<p class="source-code">  &lt;/div&gt;</p>
			<p class="source-code">  &lt;!-- /.container --&gt;</p>
			<p class="source-code"><strong class="bold">{% endblock %}</strong></p>
			<p>Let's start with <a id="_idIndexMarker626"/>the first line: the <strong class="source-inline">extends</strong> command indicates to Twig that the page extends the page identified by the <strong class="source-inline">@Blog/Layout/layout.html.twig</strong> path. Extending a page is like saying that the current page is somehow included within the page it extends. In this case, the <strong class="source-inline">layout.html.twig</strong> file contains the definition of the <strong class="source-inline">block</strong> <strong class="source-inline">content</strong> that we find in the <strong class="source-inline">article.html.twig</strong> file we are analyzing. We've already talked about blocks in <a href="B17073_04_ePub_RK.xhtml#_idTextAnchor083"><em class="italic">Chapter 4</em></a>, <em class="italic">Creating Documents in Pimcore</em>, so we can go further and describe the next lines. </p>
			<p>Immediately after the start of the content block, we have another <strong class="source-inline">include</strong> statement, which is used to load the content of the <strong class="source-inline">@Blog/Layout/header.html.twig</strong> file. In this file, we find the HTML for the construction of the site header—that is, the image at the top and the title.</p>
			<p>Scrolling the file, we see the data relating to the article in the main column: this data is retrieved through the <strong class="source-inline">getTitle()</strong>, <strong class="source-inline">getAuthor()</strong>, <strong class="source-inline">getModificationDate()</strong>, <strong class="source-inline">getSlug()</strong>, and <strong class="source-inline">getImage()</strong> functions. These elements are rendered using Twig commands, which we will see in more detail in the next section of this chapter. However, we can see how all the data is extracted from the <strong class="source-inline">article</strong> variable, which as we recall was passed to the view by the controller in the <strong class="source-inline">RenderTemplate</strong> command.</p>
			<p>The other templates differ slightly from this one just seen, and therefore we will not describe them, but<a id="_idIndexMarker627"/> all the files are available in the repository related to this book, at <a href="https://github.com/PacktPublishing/Modernizing-Enterprise-CMS-using-Pimcore">https://github.com/PacktPublishing/Modernizing-Enterprise-CMS-using-Pimcore</a>.</p>
			<h2 id="_idParaDest-183"><a id="_idTextAnchor184"/>Rendering the Categories Widget</h2>
			<p>As we<a id="_idIndexMarker628"/> saw in <em class="italic">Figure 9.9</em>, we have created three types of layouts, two of which have two columns of different sizes. We thought of inserting a component in the narrower <a id="_idIndexMarker629"/>columns, called a <strong class="bold">widget</strong>, which would contain a list of categories. In the next screenshot, you can see how the <strong class="bold">Categories</strong> widget is displayed on the right of the page:</p>
			<div>
				<div id="_idContainer141" class="IMG---Figure">
					<img src="image/Figure_9.10_B17073.jpg" alt="Figure 9.10: Template layouts&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 9.10: Template layouts</p>
			<p>As you can see from the preceding screenshot, the <strong class="bold">Categories</strong> widget contains a list of all the blog categories, with the number of articles within each category in parentheses.</p>
			<p>The <strong class="bold">Categories</strong> widget is a recurring element in the various pages, and since it is a recurring element, we have placed it in a separate template under the <strong class="source-inline">Widget</strong> folder. The inclusion of the widget is done through Twig's <strong class="source-inline">include</strong> command. The <strong class="source-inline">include</strong> command expects at least one parameter, which is the path of the file to include, as you can see in the<a id="_idIndexMarker630"/> following code snippet:</p>
			<p class="source-code">&lt;!-- Sidebar Widgets Column --&gt;</p>
			<p class="source-code">&lt;div class="col-md-4"&gt;</p>
			<p class="source-code">  {% <strong class="bold">include</strong> '<strong class="bold">@Blog/Widget/widget.html.twig</strong>' %}</p>
			<p class="source-code">&lt;/div&gt;</p>
			<p>The function to retrieve the list of categories is written in the <strong class="source-inline">BlogController</strong> controller, as can be seen in the following code snippet:</p>
			<p class="source-code">/**</p>
			<p class="source-code"> * get a complete list of categories for blog</p>
			<p class="source-code"> */</p>
			<p class="source-code">public  function <strong class="bold">getAllCategories</strong>() {</p>
			<p class="source-code">  $categories = new DataObject\BlogCategory\Listing();</p>
			<p class="source-code">  foreach ($categories as $category) {   </p>
			<p class="source-code">    $articles = new DataObject\BlogArticle\Listing();</p>
			<p class="source-code">    $articles-&gt;setCondition('Category__id = ' . $category-    &gt;getId());       </p>
			<p class="source-code">    <strong class="bold">$category-&gt;ArticleCount</strong> = $articles-&gt;getTotalCount();<strong class="bold"> </strong></p>
			<p class="source-code">    if( !empty( $category-&gt;getSlug()[0]-&gt;getSlug()) ) {</p>
			<p class="source-code"><strong class="bold">      $category-&gt;link</strong> = $category-&gt;getSlug()[0]-&gt;getSlug();</p>
			<p class="source-code">   }</p>
			<p class="source-code">  }</p>
			<p class="source-code">  return $categories;</p>
			<p class="source-code">}</p>
			<p>Inside the widget file, we created a bulleted list of all the categories through the <strong class="source-inline">for</strong> Twig statement, as illustrated in the following code snippet:</p>
			<p class="source-code">&lt;ul class="list-unstyled mb-0"&gt;</p>
			<p class="source-code">     {% <strong class="bold">for</strong> cat in categories %}</p>
			<p class="source-code">     &lt;li&gt;</p>
			<p class="source-code">          &lt;a href="/blog{{cat.link}}" &gt;</p>
			<p class="source-code">               {{cat.<strong class="source-inline">getTitle()</strong>}} ({{cat.<strong class="bold">ArticleCount</strong>}})</p>
			<p class="source-code">          &lt;/a&gt;</p>
			<p class="source-code">     &lt;/li&gt;</p>
			<p class="source-code">     {% <strong class="bold">endfor</strong> %}</p>
			<p class="source-code">&lt;/ul&gt;</p>
			<p>To get the<a id="_idIndexMarker631"/> data, we used the <strong class="source-inline">getTitle()</strong> function, and we read the <strong class="source-inline">ArticleCount</strong> property we created and passed to the view in the controller. We have not used the <strong class="bold">Category Description</strong> field, but we leave this as an exercise to you to retrieve this field and display it on the page.</p>
			<h2 id="_idParaDest-184"><a id="_idTextAnchor185"/>Understanding Twig filters</h2>
			<p>Filters are <a id="_idIndexMarker632"/>functions that change the value of a variable—for example, think of all those PHP functions that transform the value of a string: <strong class="source-inline">strtoupper</strong>, <strong class="source-inline">strtolower</strong>, and so on. In Twig, they are used through the <strong class="source-inline">pipe, |</strong>, and some arguments are accepted. Here are some examples:</p>
			<p class="source-code">{{textWithsomeCharUpperCase <strong class="bold">| lower</strong>}}</p>
			<p class="source-code">{{arrayOfStrings <strong class="bold">| join (',')</strong>}}</p>
			<p>The first example converts the value of the string to lowercase, while the second prints the contents of the <strong class="source-inline">arrayOfStrings</strong> array by separating the elements with a comma. You <a id="_idIndexMarker633"/>can consult a list of filters in the official documentation here: <a href="https://twig.symfony.com/doc/">https://twig.symfony.com/doc/</a>.</p>
			<p>Now, let's see in detail the filters we used to create our templates.</p>
			<h3>Formatting dates with the date filter</h3>
			<p>The <strong class="source-inline">date</strong> filter <a id="_idIndexMarker634"/>formats a date to a given format. Here's<a id="_idIndexMarker635"/> how we used this filter:</p>
			<p class="source-code">&lt;p&gt;Posted on {{article.getModificationDate() <strong class="bold">|</strong> <strong class="bold">date("F jS \\a\\t g:ia")</strong> }}&lt;/p&gt;</p>
			<p>As you can see from the preceding code snippet, we used an <strong class="source-inline">F jS \\a\\t g:</strong> <strong class="source-inline">ia</strong> date format. The <strong class="source-inline">F jS</strong> part indicates how we want to format the date, while <strong class="source-inline">g:</strong> <strong class="source-inline">ia</strong> indicates the time format. The middle text, <strong class="source-inline">\\a\\t</strong>, is just there to write "<em class="italic">at</em>" between the date and time. For all possible formatting types for the date and time, you can consult the PHP online <a id="_idIndexMarker636"/>guide at <a href="https://www.php.net/manual/en/datetime.format.php">https://www.php.net/manual/en/datetime.format.php</a>.</p>
			<h3>Content ellipsed with the slice filter</h3>
			<p>In some <a id="_idIndexMarker637"/>cases, the text we have to display is too<a id="_idIndexMarker638"/> long, such as in the article list, where we want to display only an image of the article and the first two or three lines of the content. What we would like is to truncate the text and replace the cut text with three ellipses, to make the visitor understand that the article is not complete. To do this, we use the <strong class="source-inline">slice</strong> filter. The <strong class="source-inline">slice</strong> filter extracts a slice of a sequence, an array, or a string. Here's how we used this filter:</p>
			<p class="source-code">{% set <strong class="bold">content</strong> = cat.getContent() <strong class="bold">|</strong> <strong class="bold">length</strong> &gt; 100 ? cat.getContent() | <strong class="bold">slice</strong>(0, 100) <strong class="bold">~</strong> ' ...' : cat.getContent()  %}</p>
			<p class="source-code">…</p>
			<p class="source-code">&lt;div class="card-body"&gt;</p>
			<p class="source-code">  …</p>
			<p class="source-code">  &lt;p class="card-text"&gt;{{ <strong class="bold">content</strong> | raw }}&lt;/p&gt;</p>
			<p class="source-code">&lt;/div&gt;</p>
			<p>As you can see from the preceding code snippet, we have set a <strong class="source-inline">content</strong> variable, which we will then use in the content of the template, with the value of the article content, applying a condition and a filter on the length. In particular, if the text exceeds <strong class="source-inline">100</strong> characters, we apply the <strong class="source-inline">slice</strong> filter and take the first <strong class="source-inline">100</strong> characters, and concatenate the three continuation points to the string. If instead, the content is not more than <strong class="source-inline">100</strong> characters, we take it in its entirety. We also used the <strong class="source-inline">length</strong> filter to get the length <a id="_idIndexMarker639"/>of the string in characters. One <a id="_idIndexMarker640"/>last trick: we used the tilde character (<strong class="source-inline">~</strong>) to concatenate the string.</p>
			<h3>Rendering text with the raw filter</h3>
			<p>The <strong class="source-inline">raw</strong> filter <a id="_idIndexMarker641"/>marks the value as being "safe," which <a id="_idIndexMarker642"/>means that in an environment with automatic escaping enabled, this variable will not be escaped if <strong class="source-inline">raw</strong> is the last filter applied to text. As we have just seen, we used the <strong class="source-inline">raw</strong> filter to view the article content, as illustrated here:</p>
			<p class="source-code">&lt;p class="card-text"&gt;{{ content | <strong class="bold">raw</strong> }}&lt;/p&gt;</p>
			<p>If you want to see exactly how the <strong class="source-inline">raw</strong> filter behaves, you can try removing the <strong class="source-inline">raw</strong> filter from the content of an article, and see the result.</p>
			<p>Filters are very useful tools because they allow us to modify data directly during the presentation phase. In this section, we have seen some of the filters available and how to use them. For all the other filters, it is possible to go to the official page of the Twig project, following this link: <a href="https://twig.symfony.com/doc/">https://twig.symfony.com/doc/</a>. </p>
			<h1 id="_idParaDest-185"><a id="_idTextAnchor186"/>Differences between Pimcore and WordPress</h1>
			<p>We have<a id="_idIndexMarker643"/> seen<a id="_idIndexMarker644"/> how to create a blog with Pimcore. However, some may wonder whether making a blog using Pimcore<a id="_idIndexMarker645"/> is the right choice. There are many <strong class="bold">content management systems</strong> (<strong class="bold">CMSes</strong>) that already do this job—WordPress, above all.</p>
			<p>We mentioned WordPress because, for those who don't know of it yet, this is a powerful open source software solution that you can use easily and freely to create blogs. It is certainly the most popular CMS, due to its ease of installation and configuration. Almost all website-hosting solutions offer the option of having WordPress pre-installed in your domain. Even the use of it does not require any special knowledge—it is very intuitive and comes with a simple and effective administration page. It is also possible to extend its functionality through the installation of plugins, and for the frontend, it is possible to download and install thousands of graphic themes with nothing more than a click. All these features have made WordPress the preferred choice for 40% of the sites currently online on the web.</p>
			<p>So, why use Pimcore to create a blog, instead of WordPress? If, as we said, WordPress is the reference blog <a id="_idIndexMarker646"/>CMS, what are the reasons that can lead us to use<a id="_idIndexMarker647"/> Pimcore? Let's try to analyze the advantages and disadvantages (if any) of this choice.</p>
			<p>Unlike WordPress, Pimcore is based on an MVC development pattern, and this allows the decoupling of business logic with presentation logic. In the view part, in addition, Pimcore uses a rendering engine (Twig) that facilitates the insertion of data into the pages, without having to use PHP code. Among other things, this simplifies <strong class="bold">user interface</strong> (<strong class="bold">UI</strong>) changes (with a much lower development cost) because the data is passed to the view by the controller, rather than extracted and processed inside the view itself.</p>
			<p>Another aspect in favor of Pimcore is the fact of being able to have structured data, while in WordPress, the metadata linked to entities (articles, categories, users...) is not typed. In order to have typed data, it is necessary to install one of the many plugins available. The downside is that plugins store data and typing configuration in their metadata, so if—for example—we want to change or remove a plugin, we will also lose the data we saved with it.</p>
			<p>Another thing to take into consideration in our choice is that Pimcore is a complete framework, so it is possible to create features inside it. In WordPress, everything is feasible too, but only with the use of plugins.</p>
			<p>Someone will rightly think: <em class="italic">But WordPress already has all the elements to create a blog—articles, users, categories, tags.</em> True. But it is also true that the effort to create the same structure of a blog in Pimcore, seen in this chapter, is minimal. And once you invest the time it takes to create a blog, the rewards become substantial because at this point, we will have the functionality of WordPress, but with the ability to customize and modify every aspect at will to make it suitable for our needs. Let's take an example: if we want to add the <strong class="source-inline">work</strong> field to the user, what should we do? Well, on Pimcore, as we created the other fields, we just have to add one, and we did. On WordPress? It is obviously possible to do this on WordPress, but by installing a plugin.</p>
			<p>We have talked several times about plugins for WordPress. We don't need to know how they work, but what we are interested in saying is that there are thousands of plugins, suitable for all purposes. Many of them are paid, almost all will do many more things than needed, and in general, installing plugins on WordPress requires attention to any conflicts between plugins, as well as configuration, updating, and maintenance. Being created by third-party developers, a plugin is not necessarily up to date; maybe it is not compatible with the latest version of WordPress, or a developer may decide to abandon it. In other words, it is always better and more advantageous to do the development directly inside the platform than to use external third-party tools.</p>
			<p>Now, let's see the additional features that Pimcore offers. First of all, it is possible to create multilingual <a id="_idIndexMarker648"/>sites. WordPress still does not allow this, so to do <a id="_idIndexMarker649"/>this it is necessary once again to install a plugin.</p>
			<p>Pimcore allows you to create multisites—that is, manage multiple sites and multiple domains in the same Pimcore installation. Even on WordPress, it is possible to create multisites but only on third levels, so not on different domains. For example, in a multisite WordPress installation, it is possible to manage <strong class="source-inline">mysite.domain.com</strong> and <strong class="source-inline">mysite2.domain.com</strong>, but it is not possible to manage <strong class="source-inline">mysite.com</strong> and <strong class="source-inline">mysite2.com</strong> in the same WordPress installation—a limitation that could be annoying for the management of a site with many connected domains.</p>
			<p>Pimcore allows you to easily create perspectives, to limit access to parts of the administrative backend, based on the profile or roles of the user who accesses them. On WordPress, this is not possible, and often access to the administrative area by users must be done through ad hoc views, and therefore without being able to reuse the WordPress backend.</p>
			<p>The advantages of having Pimcore, regardless of whether we will use it as a blog or not, will still be greater <a id="_idIndexMarker650"/>than using WordPress because <a id="_idIndexMarker651"/>with Pimcore, we will have support for business functions such as <strong class="bold">product information management</strong> (<strong class="bold">PIM</strong>), which we will see in <a href="B17073_12_ePub_RK.xhtml#_idTextAnchor211"><em class="italic">Chapter 12</em></a>, <em class="italic">Implementing Product Information Management,</em> or <strong class="bold">digital asset management</strong> (<strong class="bold">DAM</strong>), seen in <a href="B17073_06_ePub_RK.xhtml#_idTextAnchor112"><em class="italic">Chapter 6</em></a>, <em class="italic">Using Digital Asset Management</em>.</p>
			<p>With this, we are not saying that Pimcore is better than WordPress, but we are just evaluating<a id="_idIndexMarker652"/> and <a id="_idIndexMarker653"/>comparing the two systems and what they can do. This will surely help the end user in adopting the most suitable platform for their purposes.</p>
			<h1 id="_idParaDest-186"><a id="_idTextAnchor187"/>Summary</h1>
			<p>In this chapter, we have seen how to build a blog, which classes we need to create, how to create files for the pages, how they should be structured as HTML, and how it is possible to render the data thanks to the Twig framework. We have also seen how the routes of a site are built and how it is possible to choose which content to display based on the request, through the use of the <strong class="source-inline">routing.yml</strong> file and the <strong class="source-inline">BlogController</strong> controller. Finally, we learned how to build Bootstrap layouts for our site and learned how to create templates with the Bootstrap framework.</p>
			<p>In the next chapter, we will learn how to build reusable components called <strong class="bold">Bricks</strong> that can be placed in CMS or <strong class="bold">Multiple Virtual Storage</strong> (<strong class="bold">MVS</strong>) pages and, moreover, can be ported from project to project using bundles.</p>
		</div>
	</body></html>