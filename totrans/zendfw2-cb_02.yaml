- en: Chapter 2. Translating and Mail Handling
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter we will cover:'
  prefs: []
  type: TYPE_NORMAL
- en: Translating your application
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Localizing your application
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Sending mail
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Receiving mail
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: An application wouldn't be an application if it couldn't react to the users.
    One simple but effective way of reacting is obviously displaying text and sending
    e-mails. Over the last couple of years internationalization (i18n) and localization
    (l10n) have become increasingly important. Nowadays users expect to be greeted
    in their language, and even receive automated e-mails from applications in a normal
    day's work.
  prefs: []
  type: TYPE_NORMAL
- en: Translating your application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe we will be using the **Zend Framework 2** skeleton as a base,
    but we will create a new module to show how it all works.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For this recipe, we assume that you have a working Zend Framework 2 application/skeleton
    in place. To ensure that we can actually run the code that we produce in the recipe,
    we need to make sure that the `intl` and `gettext` extensions in PHP are enabled.
  prefs: []
  type: TYPE_NORMAL
- en: For translating the strings we will be using **Poedit**, a cross-platform open
    source application used for translating `gettext` catalogs. The current version
    is 1.5.5 and can be found at [http://www.poedit.net/](http://www.poedit.net/)
    website. We are using gettext as this is a widely used internationalization and
    localization system for writing multilingual applications. The files generated
    by Poedit have the extensions `.po` or `.mo`. The `.po` file is used for editing;
    let's say this is an uncompiled translation file. The `.mo` file is the compiled
    translation file, which is used in our application.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this recipe we will talk about getting our application translated, something
    that is of much use in applications nowadays.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up and checking the essentials
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We will assume that we have at least a basic module set up, containing a simple
    `IndexController` that outputs a simple View.
  prefs: []
  type: TYPE_NORMAL
- en: 'First thing we want to do is make sure we have a language directory in our
    module structure as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'In this directory all the `gettext` files will be stored, which will make it
    easier for us to control them. Now, we have set up a simple folder structure,
    we need to make sure the module configuration also knows what we are doing. Now,
    we open up the `module.config.php` and add the following lines to the array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: With the above configuration we have set up our module exactly the way we need
    it to look That's it; our module is now set up to use i18n.
  prefs: []
  type: TYPE_NORMAL
- en: Translating strings in the controller
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Once we have set up the translator, translating strings couldn''t be simpler.
    In the following example (file: `/module/Application/src/Application/Controller/IndexController.php`)
    we will translate the strings in the controller, but this is not good practice
    if used in the real world and is only shown here as an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Translating strings in the View
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Translation in the view is even simpler than the controller (and that was pretty
    simple already). The only thing we need is the string that we want to translate,
    and that''s it. We do the following alterations to the `index.phtml` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Translating strings with Poedit
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Once we have installed Poedit, we need to set a couple of settings before we
    can start translating strings. Gettext works with files that are called catalogs.
    Catalogs are files that represent the source and translated text for one specific
    language.
  prefs: []
  type: TYPE_NORMAL
- en: First of all we should create a new catalog. After typing the first tab with
    the project name and language we want to translate (for example, nl-NL), we should
    go to the second tab called sources paths. That path should contain the path to
    the sources we would like to translate and is most likely per module, which means
    the base path should be the module directory.
  prefs: []
  type: TYPE_NORMAL
- en: In the third tab there should be a couple of identifiers to which Poedit can
    identify which strings should be translated or not. Because we will be using the
    `translate()` method, we need to make sure that at least the word 'translate'
    is in the list, we can keep the rest in there however as they won't do any harm.
  prefs: []
  type: TYPE_NORMAL
- en: After we have done all that we can, click on **OK** and choose a location to
    save our file. This file needs to be saved in the languages directory within the
    module, and should have a name pattern, for example, `nl_NL.po`, `en_GB.po`, `en_US.po`.
    The naming convention for the file is `[language]_[COUNTRY]`; some countries (for
    example, Belgium and Canada) have multiple state languages which also need to
    be defined.
  prefs: []
  type: TYPE_NORMAL
- en: Once saved, press the **Update** button, which will result in the code being
    scanned for translatable strings. Now a new list appears with all the strings
    that can be translated. We can easily put our translation in the **Translation**
    box and save.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we have done all that, our screen might look similar to the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Translating strings with Poedit](img/4841OS_02_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Congratulations, we have now successfully created an i18n application!
  prefs: []
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There are multiple ways of translating strings in ZF2, and all of them are relatively
    easy to do.
  prefs: []
  type: TYPE_NORMAL
- en: Basic set up of translation in your module
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Although the `Application` module has an already set up translation functionality,
    this might not be what we want to use throughout our application. For instance,
    if we are (and we will be) using different modules, we wouldn't like to use the
    translation file in the `Application` module as that would make it less dynamic.
  prefs: []
  type: TYPE_NORMAL
- en: If we would use the same `gettext` file in all our modules, and store that in
    the `Application` module, this would mean that if we don't use a specific module,
    the translations would be loaded in anyway. Of course this would mean more memory
    use which we shouldn't have used.
  prefs: []
  type: TYPE_NORMAL
- en: That is why it is a good idea to set up translation for every module separately.
  prefs: []
  type: TYPE_NORMAL
- en: Translation within ZF2 works, obviously, because of the `Zend\I18n\Translator\Translator`
    class. This class then looks at the configuration and loads up the relevant `Zend\I18n\Translator\Loader`
    which we require. If found, it will look what the current selected locale, (which
    we have set through `setLocale()`) is (for example, `nl_NL`, `en_GB`, `en_US`,
    and so on) and then parse the relevant translation file—`.mo` for gettext, `.ini`
    for INI, `.php` for PHP Array, and so on—and let is parse through the loader.
  prefs: []
  type: TYPE_NORMAL
- en: Once we call the `translate()` or `translatePlural()` method, the translator
    will search for the relevant untranslated string in the session. If found, it
    can easily return the translated string, but in the case of a string which isn't
    translated, it will just return the untranslated string.
  prefs: []
  type: TYPE_NORMAL
- en: There's more…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Instead of using gettext, there are also several other methods that can be
    used as translation files. By default ZF2 has the option to use one of the following
    formats:'
  prefs: []
  type: TYPE_NORMAL
- en: PHP array
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Although this is a viable and easy method of translating, personally I wouldn't
    recommend it. My personal experience is that the usage of this method limits the
    use of the translation files to PHP. For example, gettext is an industry standard,
    which can be used by many platforms and applications.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the language directory we would name the PHP files in the format `[language]_[COUNTRY].php`,
    for example `nl_NL.php`. Our `module.config.php` would need an entry as shown
    in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'When this is defined in the `module.config.php` file, the translation itself
    will work exactly the same, the translation files (for example, `nl_NL.php`) will
    look similar as in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Gettext
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We used this format in the preceding examples, and as we could see they are
    easily editable by an application such as Poedit. According to Wikipedia, the
    most commonly used implementation of gettext is GNU gettext. Editing a gettext
    file is done in a so-called `.po` file where po stands for **portable object**
    , and once the files are compiled for use they will be placed in a `.mo` file
    where mo stands for **machine object**.
  prefs: []
  type: TYPE_NORMAL
- en: We can find the translation tool Poedit on the [http://www.poedit.net/](http://www.poedit.net/)
    website.
  prefs: []
  type: TYPE_NORMAL
- en: Ini
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The way this `ini` works is basically the same as any other method described
    earlier. The files in the language directory can be named `[locale].ini` (for
    example, `nl_NL.ini`), and in the `module.config.php` we would have an entry something
    like shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'As we can see we have defined two locales in our configuration, which means
    that these two are our available i18n''s, but our `en_US` is our fallback locale.
    The fallback locale is used when no suitable locale can be found. Our translation
    files (`nl_NL.ini`) would then be looking something like the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: We would always start a translation with `translation.X`, where `X` is a number
    which isn't used before. We should think of this as an INI array, similar to how
    it would work in PHP.
  prefs: []
  type: TYPE_NORMAL
- en: Localizing your application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we will explain localization and its uses. Localization differs
    from internationalization in the way that localization refers to, for example,
    numeric, date and time formats, and the use of currency.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this recipe we will be discussing the ever so important localization of our
    application.
  prefs: []
  type: TYPE_NORMAL
- en: So it begins
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When a user hits our website, we most likely want the user to automatically
    go to the right language. Although, there are several methods of doing this, we
    will be using a manual check to see if the language the user prefers is also in
    our list of languages.
  prefs: []
  type: TYPE_NORMAL
- en: 'We do this by a couple of simple tricks:'
  prefs: []
  type: TYPE_NORMAL
- en: First, we are getting the `Accept-Language` headers from the HTTP request
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Then we iterate through them and see if one of the languages mentioned in the
    header matches the language we have
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Lastly, we set the language to the language we have found, or if nothing is
    found, the fallback language is set
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let''s see how this looks in our `Module.php` code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: First, we need to start off by declaring the namespace (in our case `Application`)
    as we want the framework to know where to find our code. We then want to make
    sure we always put all the required classes in the use declaration so that we
    preload these before we go further in the code.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'In the `retrieveLocales()` method we are parsing through the languages directory
    and assume our filenames are called `en_GB.ext`. This way we can parse all the
    languages easily into one array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: As we can see in the previous code, what we try to achieve is to see if we have
    an exact match with any of the language (`en_GB`, `nl_NL`) that we support. If
    we don't have an exact match we already made sure our fallback language (`en_US`)
    is being used.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Please make sure that the `intl` extension of PHP is enabled in the configuration,
    otherwise this example will not work correctly.
  prefs: []
  type: TYPE_NORMAL
- en: Localizing currencies
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In Zend Framework 2 localizing currencies within a View can be done through
    the i18n view helper, which comes standard with ZF2\. The view helper, which is
    called `CurrencyFormat`, can easily be used in the view by the following method
    call. We do the following alterations to the `sometemplate.phtml` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: This piece of code will give the output `45.312,56 €`, as we specified to localize
    to a Euro currency symbol with a Dutch localization format, which in this case
    is dot for thousands and a comma for decimal separation. We can also leave the
    locale `nl_NL` out, and then the `CurrencyFormat` view helper will automatically
    select the default locale of the application.
  prefs: []
  type: TYPE_NORMAL
- en: Localizing date/times
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: To format any dates and times in our applications we can use the `DateFormat`
    view helper, which is just as easy to use as the currency view helper, but has
    a few more options to use. We do the following alterations to the `sometemplate.phtml`
    file.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code will only display the date, which is going to be formatted
    as `Monday, May 14, 2012 AD`. We can omit giving any parameters, but then nothing
    will be displayed as the default options are `IntlDateFormatter::NONE`.
  prefs: []
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Localization (l10n) is like internationalization (i18n), a very important aspect
    of a public application. We spoke about how to make sure your application can
    be translatable in the last recipe, but now it is time to make sure that we are
    able to find out how to use any l10n.
  prefs: []
  type: TYPE_NORMAL
- en: Zend Framework 2 works closely together with the i18n/l10n functionality that
    is already built in PHP. Although, we could use the `Locale` class of PHP separately
    of the ZF2 classes, it is not recommended as the ZF2 already use the Locale from
    PHP itself, but provide a much nicer and quicker interface to it.
  prefs: []
  type: TYPE_NORMAL
- en: In the background, however, ZF2 communicates directly with the `Locale` of PHP
    itself, but if we want to use the more robust functionalities, we should use the
    ZF2 libraries (which are handy when we are creating multilingual web applications).
  prefs: []
  type: TYPE_NORMAL
- en: Identifying the client language
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The previous example code relies on the client browser sending the `Accept-Language`
    header. Although most modern browsers do this, it's still something that might
    not always work. Overall it is a pretty good tool to preselect any languages.
  prefs: []
  type: TYPE_NORMAL
- en: Instead of making everything ourselves like shown previously, there is also
    a very nifty module called `SlmLocale` made by *Jurian Sluiman* ([https://github.com/juriansluiman/SlmLocale](https://github.com/juriansluiman/SlmLocale))
    which we can recommend for detecting and selecting the default locale.
  prefs: []
  type: TYPE_NORMAL
- en: Localizing currencies and dates
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Localizing currencies and dates are usually done in View, as it basically is
    only formatting a piece of information. You can do it somewhere else but we should
    always be wary to make sure we won't localize anything in, for example, models,
    as they only should contain logic. In most cases the language is not part of the
    logic, but simply a nice way of making the view a bit more user friendly.
  prefs: []
  type: TYPE_NORMAL
- en: Sending mail
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Sending e-mail through `sendmail` is usually a pretty standard way of working,
    as it is probably one of the most used ways of transporting e-mail (or proxying
    the e-mail to an SMTP server) on a Linux-based system. On most Linux servers `sendmail`
    is already installed and therefore it's very easy to start sending e-mail with
    that.
  prefs: []
  type: TYPE_NORMAL
- en: That is why we will be discussing this method of sending e-mail first, so that
    we can start off easy.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this recipe we will discuss the method of sending mail from within our application.
  prefs: []
  type: TYPE_NORMAL
- en: Transport\Sendmail
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Let''s take a look at the following example of sending an e-mail through `sendmail`,
    and although this functionality is placed in a controller, in real life this needs
    to stay far away from that and be placed safely away in a model:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: No configuration is usually required for setting up e-mail to be sent through
    `sendmail`, as it is a mail transport application on the local host only.
  prefs: []
  type: TYPE_NORMAL
- en: Transport\Smtp
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We can easily send our e-mail through SMTP if we want (if we know our SMTP
    server details obviously):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Transport\File
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Let's take a look at an example of how to send our e-mail in to files…
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: After sending the e-mail the file transporter will create a file which might
    look something like `mail_453421020.txt`. We have given `/tmp` as the directory
    to where this file should be saved, we should look there to see if our file exists.
  prefs: []
  type: TYPE_NORMAL
- en: Of course we can do anything in the callback function, for example, we can check
    if a certain file exists, or pull a name from the database. The options are endless.
  prefs: []
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Zend Framework 2 needs a minimum of two objects to make the sending of e-mails
    work. First is the `Zend\Mail\Message` object, which is used to completely define
    the message that needs to be sent. We can define `to`, `cc`, `bcc`, and `from`
    addresses in this object. The object is also used to set the body of the message;
    this can be either HTML or plain-text, completely depending on our own requirements.
  prefs: []
  type: TYPE_NORMAL
- en: Then as a second object we need a class that implements the `Zend\Mail\Transport\TransportInterface`
    class that handles the actual sending of the e-mail. This class only (at the moment
    anyway) has a `send(Mail\Message $message)` method defined that needs to be added
    when we implement the transport.
  prefs: []
  type: TYPE_NORMAL
- en: What happens after defining the two objects is that we give our `Message` object
    to our `Transport` object and tell it to send it off. How the sending is handled,
    is obviously determined by the `Transport` object.
  prefs: []
  type: TYPE_NORMAL
- en: Sending mail through SMTP
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Transporting mail through SMTP might not sound familiar to us, but it is a common
    method of sending e-mail through another system. Think about a desktop e-mail
    client that retrieves our e-mail from another server. When we send off an e-mail
    from that same e-mail client, it could very well be that we will be using SMTP
    to send it off. In a nutshell, SMTP is sending an e-mail to another mail server
    that then handles our mail transportation for us.
  prefs: []
  type: TYPE_NORMAL
- en: Sending mail through files
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Although not used often, there are e-mail senders that simply pick up clear
    text files with the complete message which needs sending from a specific directory,
    and send them off. And obviously if we have no way of testing our actual e-mail
    sending, this is also a great way of testing if the system works.
  prefs: []
  type: TYPE_NORMAL
- en: Receiving mail
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now, let's deal with the part of receiving mails.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this recipe we will be giving examples on the different methods of connecting
    to mailbox through ZF2, and therefore it would be nice if we had access to a mailbox
    we connect to. Of course this is not required, but it sure adds to the fun to
    have an actual working mailbox.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We will now discuss receiving e-mail within an application, which can be useful
    on some occasions.
  prefs: []
  type: TYPE_NORMAL
- en: Connecting to an IMAP mail server
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The first method of connecting to a mail server is through IMAP. The protocol
    basically lets us connect to the mail server, and looking in the different folders
    on the server if there are unread e-mails.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take a look at our example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Connecting to a POP3 mail server
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Let''s take a look at our simple connection example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Working with flags on IMAP or Maildir connections
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Flags are attributes that are attached to a message in which we can see the
    specific property of a message. To put it simpler, it can tell us, for example,
    if a message is read or answered. We can either get the flags from a message by
    using the `getFlags()` method, or by using the `hasFlag()` method. The flags that
    can be used are to be found in the `Zend\Mail\Storage` class.
  prefs: []
  type: TYPE_NORMAL
- en: Maildir++ Quota system
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Let''s take a look at the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Keeping a connection alive
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The following is an example of the use of NOOP:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: The tricky part here is when to use `noop()`, as sometimes it is really hard
    to predict which process is taking the longest. That is why we created a special
    example to show you how easy it is to make sure that `noop()` is being carried
    out regularly, until we are done with our process.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can do this by utilizing `register_tick_function`, which enables us to call
    a specific process on every tick. What we''ll do is create a class that handles
    `noop()`, and executes it every 5 minutes until we say it should stop:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'If we now are at a piece of code that requires us to execute for a long time,
    we can easily call the `start()` method to do the NOOP''ing for us as shown in
    the following line of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'And when we are done, we simply `stop()` the NOOP''ing again as shown in the
    following line of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Mailboxes are being connected to; however we will see them in ZF2 as storage
    objects. Because of this we can easily parse through all the messages, and in
    some cases are able to manipulate messages on the storage, such as copying or
    moving them. We need to remember that messages are always read only, and storages
    are the ones that can be manipulated. It is possible, for example, to create and
    delete a folder, but never edit an existing message.
  prefs: []
  type: TYPE_NORMAL
- en: The only writeable functionality we have for manipulating a message is `appendMessage()`,
    which appends a message to the storage. But when it is stored, we are not able
    to edit it again.
  prefs: []
  type: TYPE_NORMAL
- en: Connecting to a POP3 server
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Connecting with a POP3 server is very similar to using an IMAP server (handy,
    isn't it?). The only major difference is normally with a POP3 server the messages
    disappear from the mail server after retrieving them, unless we specifically tell
    the server otherwise.
  prefs: []
  type: TYPE_NORMAL
- en: About the Maildir++ Quota system
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Maildir++ is an extended version of Maildir, but still compatible with the normal
    Maildir routine and supports quota systems. This is a very useful system because
    of its quota and how it stores messages (on filesystem). This is used in a lot
    of companies, but obviously it comes with its own troubles. For example, when
    trying to write/copy a message on a Maildir++ server, it can be that this will
    throw an exception because we are over the system quota.
  prefs: []
  type: TYPE_NORMAL
- en: That is why that – unless you know for certain Maildir++ isn't used – to implement
    a check for the quota before trying to do any write-based functionality.
  prefs: []
  type: TYPE_NORMAL
- en: Keeping the connection alive
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Once a connection has been opened and parsing through messages is instantiated,
    the connection has a fair chance of closing once too much time has passed. At
    that point it is always wise to implement a `No Operation` command, or NOOP. This
    will tell the mail server that we are still there, but are just doing something
    else at the moment.
  prefs: []
  type: TYPE_NORMAL
- en: There's more…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There is obviously a lot more to tell about retrieving e-mails from a mail
    server, and it would be a great adventure to find them all out. Unfortunately,
    going in for all the advanced details would almost be a book in itself, so we
    have put down a couple of subjects which are worth exploring:'
  prefs: []
  type: TYPE_NORMAL
- en: Caching instances (see also [Chapter 8](ch08.html "Chapter 8. Optimizing Performance"),
    *Optimizing Performance*)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Reading HTML messages, or multi part messages with attachments
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Advanced use of folders on IMAP/Maildir/Mbox
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Protocol class extensions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Setting up e-mail box settings through the configuration
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
