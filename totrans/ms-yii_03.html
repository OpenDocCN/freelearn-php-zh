<html><head></head><body>
<div id="page" style="height:0pt"/><div class="book" title="Chapter&#xA0;3.&#xA0;Migrations, DAO, and Query Building" id="LTSU1-ad3e09b384df46aea690d9c8897d5fe7"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch03" class="calibre1"/>Chapter 3. Migrations, DAO, and Query Building</h1></div></div></div><p class="calibre9">One of the most fundamental aspects of writing modern web application is working with databases. Through PHP's PDO driver, Yii2, can work with many different kinds of relational databases. In <a id="id82" class="calibre1"/>this chapter, we'll cover how to connect to different databases, write database migrations to instantiate our databases, use <span class="strong"><strong class="calibre2">database access objects</strong></span> (<span class="strong"><strong class="calibre2">DAO</strong></span>), and use Yii2's built-in Query Builder. We'll also cover the basics of powerful tools such as data providers and data widgets as well as how to use Yii2 to replicate and load balance access to our databases.</p></div>

<div class="book" title="Chapter&#xA0;3.&#xA0;Migrations, DAO, and Query Building" id="LTSU1-ad3e09b384df46aea690d9c8897d5fe7">
<div class="book" title="Connecting to databases"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_1"><a id="ch03lvl1sec17" class="calibre1"/>Connecting to databases</h1></div></div></div><p class="calibre9">The <a id="id83" class="calibre1"/>primary component required in order to work with databases is the <code class="email">yii\db\Connection</code> class. Through this class, we can connect to a variety of different database types, ranging from local SQLite databases to clustered MySQL databases. The simplest way to establish a connection to a database is to create a SQLite database connection, as follows:</p><div class="note"><pre class="programlisting">$connection = new \yii\db\Connection([
    'dsn' =&gt; 'sqlite:/' . \Yii::getAlias('@app') . '/runtime/db.sqlite',
    'charset' =&gt; 'utf8'
]);

$connection-&gt;open();</pre></div><p class="calibre9">Normally, however, we'll want to use a single database connection across our entire application. We can keep our application <span class="strong"><em class="calibre13">DRY</em></span> by putting our database configuration into the <code class="email">db</code> component of our web or console configuration file. Following the examples laid out in the previous chapters, this component will reference the <code class="email">config/env/&lt;ENV&gt;/db.php</code> file. As an example, establishing a SQLite connection in this file will be done as follows:</p><div class="note"><pre class="programlisting">&lt;?php return [
    'dsn' =&gt; 'sqlite:/' . \Yii::getAlias('@app') . '/runtime/db.sqlite',
    'class' =&gt; 'yii\db\Connection',
    'charset' =&gt; 'utf8'
];</pre></div><p class="calibre9">By storing <a id="id84" class="calibre1"/>our database configuration in the <code class="email">db</code> component of our application, it can easily be shared between both our web and console applications without any additional effort on our part. Furthermore, since Yii2 loads components only when required, it can keep our application lean and performant.</p><div class="note" title="Note"><h3 class="title2"><a id="tip24" class="calibre1"/>Tip</h3><p class="calibre9">In Yii2, components <a id="id85" class="calibre1"/>are only loaded when required. This process is often called <span class="strong"><strong class="calibre2">lazy loading</strong></span>. Unless a component is preloaded, Yii2 will not create an instance of that component until it is first used. After being initially instantiated, Yii will then reuse the same component across your application rather than creating multiple instances of that component. Lazy loading is one of the primary reasons Yii is so performant.</p></div><p class="calibre9">With our database configuration stored within our configuration file, we can now access the database connection, as follows:</p><div class="note"><pre class="programlisting">\Yii::$app-&gt;db;</pre></div><p class="calibre9">This connection will also be shared to any Active Record models used in our application, which we'll discuss in <a class="calibre1" title="Chapter 4. Active Record, Models, and Forms" href="part0030_split_000.html#SJGS2-ad3e09b384df46aea690d9c8897d5fe7">Chapter 4</a>, <span class="strong"><em class="calibre13">Active Record, Models, and Forms</em></span>.</p><p class="calibre9">As stated earlier, Yii2 can connect to several different database types. As Yii2 binds on top of PHP's PDO library, it can connect to the same sources a native PDO driver can connect to. A <a id="id86" class="calibre1"/>few examples of the <span class="strong"><strong class="calibre2">data source names</strong></span> (<span class="strong"><strong class="calibre2">DSNs</strong></span>) that Yii2 supports are listed here:</p><div class="note"><table border="1" class="calibre16"><colgroup class="calibre17"><col class="calibre18"/><col class="calibre18"/></colgroup><thead class="calibre19"><tr class="calibre20"><th valign="bottom" class="calibre21">
<p class="calibre22">Database Type</p>
</th><th valign="bottom" class="calibre21">
<p class="calibre22">DSN Scheme</p>
</th></tr></thead><tbody class="calibre23"><tr class="calibre20"><td valign="top" class="calibre24">
<p class="calibre22">MySQL, Percona, MariaDB, and so on</p>
</td><td valign="top" class="calibre24">
<p class="calibre22">
<code class="literal">mysql:host=localhost;dbname=mydatabase</code>
</p>
</td></tr><tr class="calibre20"><td valign="top" class="calibre24">
<p class="calibre22">SQLite</p>
</td><td valign="top" class="calibre24">
<p class="calibre22">
<code class="literal">sqlite:/path/to/database/file.sqlite</code>
</p>
</td></tr><tr class="calibre20"><td valign="top" class="calibre24">
<p class="calibre22">PostgreSQL</p>
</td><td valign="top" class="calibre24">
<p class="calibre22">
<code class="literal">pgsql:host=localhost;port=5432;dbname=mydatabase</code>
</p>
</td></tr><tr class="calibre20"><td valign="top" class="calibre24">
<p class="calibre22">CUBRID</p>
</td><td valign="top" class="calibre24">
<p class="calibre22">
<code class="literal">cubrid:dbname=demodb;host=localhost;port=33000</code>
</p>
</td></tr><tr class="calibre20"><td valign="top" class="calibre24">
<p class="calibre22">MS SQL Server (via the sqlsrv driver)</p>
</td><td valign="top" class="calibre24">
<p class="calibre22">
<code class="literal">sqlsrv:Server=localhost;Database=mydatabase</code>
</p>
</td></tr><tr class="calibre20"><td valign="top" class="calibre24">
<p class="calibre22">MS SQL Server (via the dblib driver)</p>
</td><td valign="top" class="calibre24">
<p class="calibre22">
<code class="literal">dblib:host=localhost;dbname=mydatabase</code>
</p>
</td></tr><tr class="calibre20"><td valign="top" class="calibre24">
<p class="calibre22">MS SQL Server (via the mssql driver)</p>
</td><td valign="top" class="calibre24">
<p class="calibre22">
<code class="literal">mssql:host=localhost;dbname=mydatabase</code>
</p>
</td></tr><tr class="calibre20"><td valign="top" class="calibre24">
<p class="calibre22">Oracle</p>
</td><td valign="top" class="calibre24">
<p class="calibre22">
<code class="literal">oci:dbname=//localhost:1521/mydatabase</code>
</p>
</td></tr></tbody></table></div><div class="note" title="Note"><h3 class="title2"><a id="tip25" class="calibre1"/>Tip</h3><p class="calibre9">If you're connecting to a MS SQL server, you'll need to have either the sqlsrv, dblib or mssql PHP drivers installed on your system. More information on these base<a id="id87" class="calibre1"/> drivers can be found within the PHP manual at <a class="calibre1" href="https://php.net/manual/en/pdo.drivers.php">https://php.net/manual/en/pdo.drivers.php</a>.</p><p class="calibre9">Additionally, Oracle connections will require the installation of Oracle's OCI8 driver. More<a id="id88" class="calibre1"/> information on this driver can be found in the PHP manual at <a class="calibre1" href="https://php.net/manual/en/book.oci8.php">https://php.net/manual/en/book.oci8.php</a>.</p><p class="calibre9">Note that Yii2 will not be able to connect to any database unless the appropriate PHP drivers are properly installed and configured. If you aren't certain which drivers you have installed, the native <code class="email">phpinfo()</code> function can output a list of all the currently installed PHP extensions.</p></div><p class="calibre9">In <a id="id89" class="calibre1"/>addition to the base drivers listed earlier, Yii2 can also connect<a id="id90" class="calibre1"/> to databases over <span class="strong"><strong class="calibre2">Open Database Connectivity</strong></span> (<span class="strong"><strong class="calibre2">ODBC</strong></span>). When connecting to a database via ODBC, you'll need to specify the <code class="email">$driverName</code> property within your <code class="email">db</code> connection component so that Yii2 can properly connect to your database:</p><div class="note"><pre class="programlisting">'components' =&gt; [
    // [...]
    'db' =&gt; [
        'class' =&gt; 'yii\db\Connection',
        <span class="strong"><strong class="calibre2">'driverName' =&gt; 'mysql',</strong></span> 'dsn' =&gt; 'odbc:Driver={MySQL};Server=localhost;Database=test',
        'username' =&gt; 'username',
      'password' =&gt; 'password',
  ]
]</pre></div><p class="calibre9">As shown previously, some database configurations may require you to specify a username or password to connect to them. Within the <code class="email">db</code> component, simply specify the <code class="email">username</code> and <code class="email">password</code> attributes that are appropriate for your database.</p></div></div>

<div class="book" title="Chapter&#xA0;3.&#xA0;Migrations, DAO, and Query Building" id="LTSU1-ad3e09b384df46aea690d9c8897d5fe7">
<div class="book" title="Connecting to databases">
<div class="book" title="Additional configuration options"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_2"><a id="ch03lvl2sec30" class="calibre1"/>Additional configuration options</h2></div></div></div><p class="calibre9">In<a id="id91" class="calibre1"/> addition to the basic <code class="email">db</code> component options listed previously, Yii2 also provides several additional options that can be used to either enhance the performance of your application or deal with a known issue within the native PHP drivers. While many of these options can be found in the Yii guide and the API documentation, some of them will most likely be used more often than others. These properties are <code class="email">$emulatePrepare</code>, <code class="email">$enableQueryCache</code>, and <code class="email">$enableSchemaCache</code>.</p><div class="note" title="Note"><h3 class="title2"><a id="tip26" class="calibre1"/>Tip</h3><p class="calibre9">A <a id="id92" class="calibre1"/>complete list of the available methods and properties for the <code class="email">yii\db\Connection</code> class can be found at <a class="calibre1" href="http://www.yiiframework.com/doc-2.0/yii-db-connection.html">http://www.yiiframework.com/doc-2.0/yii-db-connection.html</a>.</p></div><p class="calibre9">The first common attribute, <code class="email">$emulatePrepare</code>, can be used to alleviate common issues identified by the Yii team when preparing database statements. By default, Yii2 will try to use the native prepare support built into the native PDO driver. To help alleviate issues with a few of the native PDO drivers (mainly, the MS SQL drivers), the <code class="email">$emulatePrepare</code> attribute may need to be set to <code class="email">true</code> in order to allow Yii2 to handle the prepare statements.</p><p class="calibre9">The next common property often enabled in our <code class="email">db</code> component is <code class="email">$enableQueryCache</code>. To improve the performance of our application, we can set this value to <code class="email">true</code> and allow Yii to cache commonly executed queries. In an application that mostly performs read actions, enabling this attribute can greatly increase the performance of your application.</p><p class="calibre9">To completely enable this component, however, the additional properties we'll mention now must be set as well. The first property, <code class="email">$queryCache</code>, specifies the named cache object that the query cache should use. If unset, this will simply default to the cache component in our application. The second property is <code class="email">$queryCacheDuration</code>, and it determines how long any database query result will be cached for. By default, the query cache will be valid for 3,600 seconds, or 60 minutes:</p><div class="note"><pre class="programlisting">'components' =&gt; [
  //[...
  'db' =&gt; [
        'dsn' =&gt; 'sqlite:/' . \Yii::getAlias('@app') . '/runtime/db.sqlite',
        'class' =&gt; 'yii\db\Connection',
        'charset' =&gt; 'utf8',
<span class="strong"><strong class="calibre2">        'enableQueryCache' =&gt; true,</strong></span>
<span class="strong"><strong class="calibre2">        'queryCache' =&gt; 'filecache',</strong></span>
<span class="strong"><strong class="calibre2">        'queryCacheDuration' =&gt; 60</strong></span>
    ],
    'filecache' =&gt; [
        'class' =&gt; 'yii\caching\FileCache',
    ],
]</pre></div><p class="calibre9">The final <a id="id93" class="calibre1"/>common property that often will be added to our <code class="email">db</code> component is <code class="email">$enableSchemaCache</code>. Before Yii accesses the database, it will often need to determine the database schema. This schema information is used to assist Yii when running validators and working with relational models, such as related Active Record models. Rather than having Yii try to determine our database schema on every request, we can tell it that our schema isn't changing by setting <code class="email">$enableSchemaCache</code> to <code class="email">true</code>.</p><p class="calibre9">Similar to the <code class="email">$enableCache</code> parameter outlined previously, we'll also need to define the <code class="email">$schemaCache</code> parameter, which will tell Yii what cache component to use. We'll also need to define the <code class="email">$schemaCacheDuration</code> parameter so that Yii2 knows how long the schema cache is valid for in seconds:</p><div class="note"><pre class="programlisting">'components' =&gt; [
  // [...]
  'db' =&gt; [
        'dsn' =&gt; 'sqlite:/' . \Yii::getAlias('@app') . '/runtime/db.sqlite',
        'class' =&gt; 'yii\db\Connection',
        'charset' =&gt; 'utf8',
<span class="strong"><strong class="calibre2">        'enableSchemaCache' =&gt; true,</strong></span>
<span class="strong"><strong class="calibre2">        'schemaCache' =&gt; 'filecache',</strong></span>
<span class="strong"><strong class="calibre2">        'schemaCacheDuration' =&gt; 3600</strong></span>
    ],
    'filecache' =&gt; [
        'class' =&gt; 'yii\caching\FileCache',
    ],
]</pre></div><p class="calibre9">As the majority of our controller actions will most likely result in a database operation, enabling these properties can greatly improve the performance of our application.</p><div class="note" title="Note"><h3 class="title2"><a id="tip27" class="calibre1"/>Tip</h3><p class="calibre9">Remember that because <code class="email">$enableSchemaCache</code> and <code class="email">$enableQueryCache</code> are enabled, Yii2 will not perform common checks against the database. Any change to the underlying data or schema in your database may cause your application to return bad data or crash entirely. If you change the data in your database directly rather than through Yii2, or if you change the database schema, ensure <a id="id94" class="calibre1"/>that you flush the relevant cache components defined by <code class="email">$enableSchemaCache</code> or <code class="email">$enableQueryCache</code> to ensure that your application functions correctly.</p></div></div></div></div>

<div id="page" style="height:0pt"/><div class="book" title="Writing database migrations"><div class="book" id="MSDG2-ad3e09b384df46aea690d9c8897d5fe7"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch03lvl1sec18" class="calibre1"/>Writing database migrations</h1></div></div></div><p class="calibre9">When <a id="id95" class="calibre1"/>building and maintaining modern web applications, the underlying structure of our database may need to change to account for changes in requirements or scopes. To ensure that our database schema can evolve in tandem with our source code, Yii2 provides built-in support to manage database migrations. Using database migrations, we can treat our database as an extension of the source code and easily change it when our source code changes.</p></div>

<div class="book" title="Writing database migrations">
<div class="book" title="An overview of schema"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_1"><a id="ch03lvl2sec31" class="calibre1"/>An overview of schema</h2></div></div></div><p class="calibre9">When <a id="id96" class="calibre1"/>working with database migrations, we'll often be working with the <code class="email">yii\db\Schema</code> class. When paired properly, we can often write our migrations in a way that enables them to be run across a variety of database types. For example, when working locally, we might need to use a local SQLite database even if our application will ultimately run on a MySQL database.</p><p class="calibre9">At the heart of this class is a variety of different schema types that Yii2 will be able to properly map to the appropriate data type within our database. These include data types such as <code class="email">INT</code>, <code class="email">DATETIME</code>, and <code class="email">TEXT</code>.</p><div class="note" title="Note"><h3 class="title2"><a id="tip28" class="calibre1"/>Tip</h3><p class="calibre9">For a <a id="id97" class="calibre1"/>complete list of the available constants made available by the Schema class, ensure that you refer to the Yii2 guide at <a class="calibre1" href="http://www.yiiframework.com/doc-2.0/yii-db-schema.html#constants">http://www.yiiframework.com/doc-2.0/yii-db-schema.html#constants</a>.</p></div><p class="calibre9">Within our migrations, we can call any of these constants by running this:</p><div class="note"><pre class="programlisting">Schema::&lt;CONSTANT&gt;</pre></div><p class="calibre9">In the example of an integer, we can use this:</p><div class="note"><pre class="programlisting">Schema::TYPE_INTEGER</pre></div><p class="calibre9">Using these constants in our migration, we can ensure that our migrations map to the appropriate<a id="id98" class="calibre1"/> data type within our database and work across a variety of database types.</p></div></div>

<div class="book" title="Writing database migrations">
<div class="book" title="Writing migrations"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_2"><a id="ch03lvl2sec32" class="calibre1"/>Writing migrations</h2></div></div></div><p class="calibre9">As shown in<a id="id99" class="calibre1"/> the previous chapter, we can create a new migration by invoking the <code class="email">migrate/create</code> command from the <code class="email">yii</code> command-line tool. Using the source code from the previous chapter as a starting point, we'll do this by running the following from the command line:</p><div class="note"><pre class="programlisting"><span class="strong"><strong class="calibre2">./yii migrate/create init</strong></span>
</pre></div><div class="mediaobject"><img src="../images/00008.jpeg" alt="Writing migrations" class="calibre10"/></div><p class="calibre11"> </p><p class="calibre9">Running this command will create a new migration in the <code class="email">migrations</code> folder of our application.</p><div class="note" title="Note"><h3 class="title2"><a id="tip29" class="calibre1"/>Tip</h3><p class="calibre9">Depending upon the file permissions on your system, Yii2 may not be able to create the <code class="email">migrations</code> folder if it does not exist. If the <code class="email">migrations</code> folder doesn't exist yet, ensure that you create it before running the <code class="email">migrate/create</code> command.</p></div><p class="calibre9">When running migrations, Yii2 will execute them in the order in which they were created. To determine this order, Yii2 will look at the filename or the migration that contains the name of the migration specified from the <code class="email">migrate/create</code> command as well as the exact timestamp the migration was created at.</p><p class="calibre9">In our case, the filename is <code class="email">m150523_194158_init.php</code>, which means that this migration was created on May 23, 2015 at 7:41:58 PM UTC.</p><div class="note" title="Note"><h3 class="title2"><a id="tip30" class="calibre1"/>Tip</h3><p class="calibre9">Because of this naming convention, any migration that you create will have a distinct and unique filename. If you're following along, ensure that you're working in the file that was created from the <code class="email">./yii</code> command.</p></div><p class="calibre9">After running the <code class="email">migrate/create</code> command, Yii2 provides us with a skeleton migration that will look similar to the following code block:</p><div class="note"><pre class="programlisting">&lt;?php

use yii\db\Schema;
use yii\db\Migration;

class m150523_194158_init extends Migration
{
    public function up() {}

    public function down()
    {
        echo "m150523_194158_init cannot be reverted.\n";
        return false;
    }
    
    /*
    // Use safeUp/safeDown to run migration code within a transaction
    public function safeUp() {}
    
    public function safeDown() {}
    */
}</pre></div><p class="calibre9">Migrations<a id="id100" class="calibre1"/> in Yii2 can operate in one of these two ways: we can either bring a migration up, or we can bring it down. These two operations correspond to one of four functions: <code class="email">up()</code>, <code class="email">safeUp()</code>, <code class="email">down()</code>, and <code class="email">safeDown()</code>. The <code class="email">up()</code> and <code class="email">down()</code> methods are the base methods required to run migrations and will execute any database command issued inside them even if there is an error. Alternatively, we can use the <code class="email">safeUp()</code> and <code class="email">safeDown()</code> methods, which are functionally identical to the <code class="email">up()</code> and <code class="email">down()</code> methods, with the exception that the entire operation is wrapped within a transaction. If our database supports transactions, running our migrations from the safe methods can help us catch migration errors at runtime before an error can cause problems with our entire database.</p><div class="note" title="Note"><h3 class="title2"><a id="tip31" class="calibre1"/>Tip</h3><p class="calibre9">Because of the additional safety they offer, <code class="email">safeUp()</code> and <code class="email">safeDown()</code> should be our go-to methods when writing migrations. Additionally, if <code class="email">safeUp()</code> or <code class="email">safeDown()</code> are used, the unsafe methods cannot be used.</p></div><p class="calibre9">Let's start by adding a simple table to our database in order to store our users. We'll start by simply storing an ID, an email address, a password, the username, and some timestamp <a id="id101" class="calibre1"/>metadata indicating when our user was created and last updated. Within our migration, we can write this as follows:</p><div class="note"><pre class="programlisting">class m150523_194158_init extends Migration
{
    public function safeUp()
    {
         return $this-&gt;createTable('user', [
            'id'           =&gt; Schema::TYPE_PK, // $this-&gt;primaryKey()
            'email'        =&gt; Schema::TYPE_STRING, // $this-&gt;string(255) // String with 255 characters
            'password'     =&gt; Schema::TYPE_STRING,
            'name'         =&gt; Schema::TYPE_STRING,
            'created_at'   =&gt; Schema::TYPE_INTEGER, // $this-&gt;integer()
            'updated_at'   =&gt; Schema::TYPE_INTEGER
        ]);
    }
    
    public function safeDown()
    {
        return $this-&gt;dropTable('user');
    }
}</pre></div><div class="note" title="Note"><h3 class="title2"><a id="tip32" class="calibre1"/>Tip</h3><p class="calibre9">As illustrated previously, Yii2 supports two different ways to declare schema types for columns. We can either directly use the constants defined by the <code class="email">Schema</code> class, or we can use the native migration methods, such as <code class="email">primaryKey()</code>, <code class="email">integer()</code>, <code class="email">string()</code>, and <code class="email">text()</code>. Using the migration methods is preferred because it permits us to add additional attributes to our column, such as the column size and length. For a complete list of methods offered by the migration class, refer to the Yii2 guide at <a class="calibre1" href="http://www.yiiframework.com/doc-2.0/yii-db-migration.html">http://www.yiiframework.com/doc-2.0/yii-db-migration.html</a>.</p></div><p class="calibre9">In the previous<a id="id102" class="calibre1"/> example, we outlined two methods: <code class="email">createTable()</code>, which will create a new database table within our application, and <code class="email">dropTable()</code>, which will drop the table from our database.</p><div class="note" title="Note"><h3 class="title2"><a id="tip33" class="calibre1"/>Tip</h3><p class="calibre9">A common convention when working with a database is to write field names with underscores and use singular names for table and column names. While Yii2 is smart enough to work with any field names you specify, following this convention<a id="id103" class="calibre1"/> will make your code more readable and working with your databases less complicated. While you don't have to explicitly follow this convention, following a convention can save you a lot of time in the future.</p></div></div></div>

<div class="book" title="Writing database migrations">
<div class="book" title="Running migrations"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_3"><a id="ch03lvl2sec33" class="calibre1"/>Running migrations</h2></div></div></div><p class="calibre9">Running <a id="id104" class="calibre1"/>our migrations can be done through the <code class="email">yii</code> command, as shown in the previous chapter:</p><div class="note"><pre class="programlisting"><span class="strong"><strong class="calibre2">./yii migrate/up</strong></span>
</pre></div><div class="mediaobject"><img src="../images/00009.jpeg" alt="Running migrations" class="calibre10"/></div><p class="calibre11"> </p><p class="calibre9">Since we're using a SQLite database in our example, we can easily explore what just happened when we ran the <code class="email">migrate/up</code> command. Using the <code class="email">sqlite</code> command-line tool, we can explore our SQLite database:</p><div class="note"><pre class="programlisting"><span class="strong"><strong class="calibre2">sqlite3 /path/to/runtime/db.sqlite</strong></span>
</pre></div><div class="note" title="Note"><h3 class="title2"><a id="tip34" class="calibre1"/>Tip</h3><p class="calibre9">If your <a id="id105" class="calibre1"/>package manager does not provide sqlite3, you can download the binary executables from <a class="calibre1" href="https://www.sqlite.org/download.html">https://www.sqlite.org/download.html</a>.</p></div><p class="calibre9">By running the <code class="email">.tables</code> command from our SQLite prompt, we can see that two tables were created when we ran the <code class="email">migrate/up</code> command, <code class="email">migration</code> and <code class="email">user</code>:</p><div class="note"><pre class="programlisting"><span class="strong"><strong class="calibre2">sqlite&gt; .tables</strong></span>
</pre></div><div class="mediaobject"><img src="../images/00010.jpeg" alt="Running migrations" class="calibre10"/></div><p class="calibre11"> </p><p class="calibre9">The first<a id="id106" class="calibre1"/> table, <code class="email">migration</code>, contains a list of all the applied migrations as well as the time at which they were applied.</p><div class="mediaobject"><img src="../images/00011.jpeg" alt="Running migrations" class="calibre10"/></div><p class="calibre11"> </p><p class="calibre9">The second table, <code class="email">user</code>, shows the resulting schema that was created by Yii from our migration class.</p><div class="mediaobject"><img src="../images/00012.jpeg" alt="Running migrations" class="calibre10"/></div><p class="calibre11"> </p><p class="calibre9">For instance, by specifying the <code class="email">TYPE_PK</code> schema for our <code class="email">ID</code> attribute, Yii2 knew that it needed to add <code class="email">AUTOINCRIMENT</code> and <code class="email">NOT NULL</code> attributes to our SQLite schema.</p><div class="note" title="Note"><h3 class="title2"><a id="tip35" class="calibre1"/>Tip</h3><p class="calibre9">While database migrations are suited for most database changes, running them against<a id="id107" class="calibre1"/> large datasets may result in your database being unavailable to your application, resulting in downtime. Make sure that before you run a database migration through Yii2, your application should be able to handle temporary downtime. If even temporary downtime is not appropriate for your application, you may need to consider migrating your data to an updated schema in other ways.</p></div></div></div>

<div class="book" title="Writing database migrations">
<div class="book" title="Altering a database schema"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_4"><a id="ch03lvl2sec34" class="calibre1"/>Altering a database schema</h2></div></div></div><p class="calibre9">When <a id="id108" class="calibre1"/>developing locally, we can simply use the <code class="email">migrate/down</code> command to undo a specific migration (assuming we implemented a <code class="email">down()</code> or <code class="email">safeDown()</code> method). However, after committing and pushing our code to our DCVS system, such as Git or SVN, others may be using or working with our code. In this instance, we want to change our migrations without causing harm to their local instance; we can create new migrations that users of our code can apply in order to bring their applications up to date.</p><p class="calibre9">Take, for instance, the user schema that was created for us:</p><div class="note"><pre class="programlisting">CREATE TABLE `user` (
        `id` integer PRIMARY KEY AUTOINCREMENT NOT NULL,
        `email` varchar(255),
        `password` varchar(255),
        `name` varchar(255),
        `created_at` integer,
        `updated_at` integer
);</pre></div><p class="calibre9">Rather than having a single field for our username, we may want to have two fields: one for their first name and one for their last name. We may also want to make a few changes to other fields, such as our <code class="email">email</code> field, to prevent them from being <code class="email">NULL</code>. We can do this by writing a new migration and altering the schema of the database itself.</p><p class="calibre9">We'll start by creating a new migration:</p><div class="note"><pre class="programlisting"><span class="strong"><strong class="calibre2">./yii migrate/create name_change --interactive=0</strong></span>
</pre></div><div class="note" title="Note"><h3 class="title2"><a id="tip36" class="calibre1"/>Tip</h3><p class="calibre9">Remember, the <code class="email">--interactive=0</code> flag tells Yii to run our console command without prompts.</p></div><p class="calibre9">Within our new <code class="email">migrations/…name_change.php</code> migration, we can write a <code class="email">safeUp()</code> method to alter these columns for us:</p><div class="note"><pre class="programlisting">public function safeUp()
{
    $this-&gt;renameColumn('user', 'name', 'first_name');
    $this-&gt;alterColumn('user', 'first_name', SCHEMA::TYPE_STRING);
    $this-&gt;addColumn('user', 'last_name', SCHEMA::TYPE_STRING);
    $this-&gt;alterColumn('user', 'email', SCHEMA::TYPE_STRING . ' NOT NULL');
    $this-&gt;createIndex('user_unique_email', 'user', 'email', true);
}</pre></div><p class="calibre9">In Yii2, migration commands are self-explanatory in what they do. For instance, the first method, <code class="email">renameColumn()</code>, will simply rename the <code class="email">name</code> column to <code class="email">first_name</code>. In the same <a id="id109" class="calibre1"/>vein, <code class="email">addColumn()</code> will add a new column with the specified name and schema to our database, <code class="email">alterColumn()</code> will alter the schema for the named column, and <code class="email">createIndex()</code> will create a unique index on the email field in our database, which will ensure that no two users will share the same email address.</p><div class="note" title="Note"><h3 class="title2"><a id="tip37" class="calibre1"/>Tip</h3><p class="calibre9">A <a id="id110" class="calibre1"/>complete list of commands that can be run within the migration calls can be found in the Yii2 guide at <a class="calibre1" href="http://www.yiiframework.com/doc-2.0/yii-db-migration.html">http://www.yiiframework.com/doc-2.0/yii-db-migration.html</a>.</p></div><p class="calibre9">If we try to run these migrations against our SQLite database, however, we would be presented with an error similar to the following, indicating that SQLite doesn't have support for these methods:</p><div class="note"><pre class="programlisting"><span class="strong"><strong class="calibre2">./yii migrate/up</strong></span>
</pre></div><p class="calibre9">Here's the output:</p><div class="note"><pre class="programlisting"><span class="strong"><strong class="calibre2">*** applying m150523_203944_name_change</strong></span>
<span class="strong"><strong class="calibre2">    &gt; rename column name in table user to first_name \</strong></span>
<span class="strong"><strong class="calibre2">...Exception: yii\db\sqlite\QueryBuilder::renameColumn is not \</strong></span>
<span class="strong"><strong class="calibre2">   supported by SQLite. \</strong></span>
<span class="strong"><strong class="calibre2">(/var/www/ch3/vendor/yiisoft/yii2/db/sqlite/QueryBuilder.php:201)</strong></span>
</pre></div><p class="calibre9">While the previously listed migration would work on MySQL or PostgreSQL, our SQLite driver doesn't provide support for these commands. Since we're using SQLite, however, we'd have to<a id="id111" class="calibre1"/> rewrite our initial migration command and notify users of our application about the change. For SQLite, we can rewrite our newly created <code class="email">migrations/…name_change.php</code> migration as follows:</p><div class="note"><pre class="programlisting">public function safeUp()
{
    $this-&gt;dropTable('user');
    
    $this-&gt;createTable('user', [
        'id'           =&gt; Schema::TYPE_PK,
        'email'        =&gt; Schema::TYPE_STRING . ' NOT NULL',
        'password'     =&gt; Schema::TYPE_STRING . ' NOT NULL',
        'first_name'   =&gt; Schema::TYPE_STRING,
        'last_name'    =&gt; Schema::TYPE_STRING,
        'created_at'   =&gt; Schema::TYPE_INTEGER,
        'updated_at'   =&gt; Schema::TYPE_INTEGER
    ]);
    
    $this-&gt;createIndex('user_unique_email', 'user', 'email', true);
}

public function safeDown()
{
    return true;
}</pre></div><div class="note" title="Note"><h3 class="title2"><a id="tip38" class="calibre1"/>Tip</h3><p class="calibre9">
<code class="email">yii\db\Migration</code> does not have a <code class="email">query()</code> method that we can use to retrieve data. Consequently, if we need to query data within a migration, we will need to use Yii2's Query Builder to do this, which we'll cover later in this chapter. If our application has widespread adoption, it might be better to query for all of our users with Query Builder and store them temporarily in the memory (or a temporary store if we have a large number of records). Then, after creating our new table schema for our users table,  we could then reinsert them into our database using the <code class="email">insert()</code> method.</p></div><p class="calibre9">After updating our new migration, we can rerun our migration command. Since our first migration was already applied, that migration will be skipped when the migrate/up command is executed, and only our <code class="email">migrations/m150523_203944_change.php</code> migration will be run:</p><div class="note"><pre class="programlisting"><span class="strong"><strong class="calibre2">./yii migrate/up</strong></span>
</pre></div><div class="mediaobject"><img src="../images/00013.jpeg" alt="Altering a database schema" class="calibre10"/></div><p class="calibre11"> </p><p class="calibre9">After<a id="id112" class="calibre1"/> running our migration, we can query our database to see what our full schema looks like within SQLite:</p><div class="note"><pre class="programlisting"><span class="strong"><strong class="calibre2">sqlite3 /path/to/runtime/db.sqlite</strong></span>
</pre></div><div class="mediaobject"><img src="../images/00014.jpeg" alt="Altering a database schema" class="calibre10"/></div><p class="calibre11"> </p><div class="note" title="Note"><h3 class="title2"><a id="tip39" class="calibre1"/>Tip</h3><p class="calibre9">Migrations <a id="id113" class="calibre1"/>in Yii2 are extremely powerful. Take a look at the<a id="id114" class="calibre1"/> Yii2 documentation at <a class="calibre1" href="http://www.yiiframework.com/doc-2.0/yii-db-migration.html">http://www.yiiframework.com/doc-2.0/yii-db-migration.html</a> to see everything that you can do with <code class="email">yii\db\Migration</code>.</p></div></div></div>

<div id="page" style="height:0pt"/><div class="book" title="Database access objects"><div class="book" id="NQU22-ad3e09b384df46aea690d9c8897d5fe7"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch03lvl1sec19" class="calibre1"/>Database access objects</h1></div></div></div><p class="calibre9">Yii database<a id="id115" class="calibre1"/> access objects, commonly referred to as DAO, provide a powerful object-oriented API to work with a relational database. As the foundation for more complex database access, such as Query Builder and Active Record, DAO enables us to work directly with our database through SQL statements and PHP arrays. Consequently, it is significantly more performant to work with DAO statements than it is to work with either Active Record or Query Builder.</p><p class="calibre9">At the core of DAO is our <code class="email">yii\db\Connection</code> class, or more commonly, our <code class="email">db</code> component <code class="email">\Yii::$app-&gt;db</code>. Since our <code class="email">db</code> component is already properly configured for SQLite, we'll use it moving forward. With DAO, there are two general types of queries that we can run: queries that return data, such as <code class="email">SELECT</code> queries, and queries that execute data, such as <code class="email">DELETE</code> or <code class="email">UPDATE</code>.</p><div class="note" title="Note"><h3 class="title2"><a id="tip40" class="calibre1"/>Tip</h3><p class="calibre9">If you use the <code class="email">yii\db\Connection</code> class directly, you'll need to explicitly call the <code class="email">open()</code> method before you can run any queries against that connection.</p></div></div>

<div class="book" title="Database access objects">
<div class="book" title="Querying for data"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_1"><a id="ch03lvl2sec35" class="calibre1"/>Querying for data</h2></div></div></div><p class="calibre9">The first <a id="id116" class="calibre1"/>way in which we can use DAO is to query for data. There are four main methods that are used to query for data: <code class="email">queryAll()</code>, <code class="email">queryOne()</code>, <code class="email">queryScalar()</code>, and <code class="email">queryColumn()</code>.</p><p class="calibre9">The first method, <code class="email">queryAll()</code>, is used to query for all the data in a specific table based upon the SQL statement used within the <code class="email">createCommand()</code> method. Using our user table as an example, we can query for all the users in our database by running the following command:</p><div class="note"><pre class="programlisting">$users = \Yii::$app-&gt;db
        -&gt;createCommand('SELECT * FROM user;')
        -&gt;queryAll();</pre></div><p class="calibre9">After running this command, our <code class="email">$users</code> variable will be populated with an array of users:</p><div class="note"><pre class="programlisting">Array
(
    [0] =&gt; Array
    (
        [id] =&gt; 1
        [email] =&gt; test@example.com
        [password] =&gt; test123
        [first_name] =&gt; test
        [last_name] =&gt; user
        [created_at] =&gt; 0
        [updated_at] =&gt; 0
    )
)</pre></div><p class="calibre9">The next <a id="id117" class="calibre1"/>method, <code class="email">queryOne()</code>, is used to fetch a single record from the database.</p><div class="note"><pre class="programlisting">$user = \Yii::$app-&gt;db
        -&gt;createCommand('SELECT * FROM user WHERE id = 1;')
        -&gt;queryOne();</pre></div><p class="calibre9">The <code class="email">queryOne()</code> method returns an array of data for a single element. In the event that no data is found, this method will return <code class="email">false</code>:</p><div class="note"><pre class="programlisting">Array
(
    [id] =&gt; 1
    [email] =&gt; test@example.com
    [password] =&gt; test123
    [first_name] =&gt; test
    [last_name] =&gt; user
    [created_at] =&gt; 0
    [updated_at] =&gt; 0
)</pre></div><p class="calibre9">The third method, <code class="email">queryScalar()</code>, is used to return the result of a <code class="email">SELECT</code> query that returns a single value. For instance, if we want to count the number of users in our database, we can use <code class="email">queryScalar()</code> to get the value:</p><div class="note"><pre class="programlisting">$count = \Yii::$app-&gt;db
        -&gt;createCommand('SELECT COUNT(*) FROM user;')
        -&gt;queryScalar();</pre></div><p class="calibre9">After running this command, our <code class="email">$count</code> variable will be populated with the number of users in our database.</p><p class="calibre9">The final method, <code class="email">queryColumn()</code>, is used to query a specific column in our database. For instance, if we want to know the email addresses of all the users in our database, we can use <code class="email">queryAll()</code> to fetch all that data, or we can use <code class="email">queryColumn()</code>, which would be significantly more efficient to use as it would query for less data:</p><div class="note"><pre class="programlisting">$user = \Yii::$app-&gt;db
        -&gt;createCommand('SELECT email FROM user;')
        -&gt;queryColumn();</pre></div><p class="calibre9">Like <code class="email">queryAll()</code>, <code class="email">queryColumn()</code> will return an array of results:</p><div class="note"><pre class="programlisting">Array
(
    [0] =&gt; test@example.com
)</pre></div><p class="calibre9">In the <a id="id118" class="calibre1"/>event that no results are found, <code class="email">queryColumn()</code> will return an empty array.</p><p class="calibre9">With our knowledge of these methods, as an exercise, let's go back to our previous migrations and rewrite them to preserve our users across our schema change:</p><div class="book"><ol class="orderedlist"><li class="listitem" value="1">First, let's roll back our migrations to properly simulate the scenario:<div class="note"><pre class="programlisting"><span class="strong"><strong class="calibre2">./yii migrate/down</strong></span>
</pre></div></li><li class="listitem" value="2">Then, we'll migrate our initial migration using the <code class="email">migrate/to</code> command:<div class="note"><pre class="programlisting"><span class="strong"><strong class="calibre2">./yii migrate/to m150523_194158_init</strong></span>
</pre></div></li><li class="listitem" value="3">Next, let's seed our database with some test data:<div class="note"><pre class="programlisting"><span class="strong"><strong class="calibre2">sqlite3 /path/to/runtime/db.sqlite INSERT INTO user (email, password, name) VALUES ('test@example.com', 'test1', 'test user');</strong></span>
<span class="strong"><strong class="calibre2">INSERT INTO user (email, password, name) VALUES ('test2@example.com', 'test2', 'test user 2');</strong></span>
</pre></div></li><li class="listitem" value="4">If we take a look at our database, we'll see that the initial schema and data is now in place.<div class="mediaobject"><img src="../images/00015.jpeg" alt="Querying for data" class="calibre10"/></div><p class="calibre25"> </p></li><li class="listitem" value="5">Then, let's rewrite our <code class="email">migrations/…name_change.php</code> migration to fetch our users from the database before running the initial migration that we created,<a id="id119" class="calibre1"/> and then reinsert our users back into our database. We'll do this using the <code class="email">queryAll()</code> DAO method to fetch the data and the <code class="email">insert()</code> method of <code class="email">yii\db\Migration</code> to put it back into the database. The new code blocks have been highlighted for easy viewing:<div class="note"><pre class="programlisting">public function safeUp()
{
    <span class="strong"><strong class="calibre2">$users = \Yii::$app-&gt;db</strong></span>
              <span class="strong"><strong class="calibre2">-&gt;createCommand('SELECT * FROM user')</strong></span>
              <span class="strong"><strong class="calibre2">-&gt;queryAll();</strong></span>
          
    $this-&gt;dropTable('user');
    
    $this-&gt;createTable('user', [
        'id'           =&gt; Schema::TYPE_PK,
        'email'        =&gt; Schema::TYPE_STRING . ' NOT NULL',
        'password'     =&gt; Schema::TYPE_STRING . ' NOT NULL',
        'first_name'   =&gt; Schema::TYPE_STRING,
        'last_name'    =&gt; Schema::TYPE_STRING,
        'created_at'   =&gt; Schema::TYPE_INTEGER,
        'updated_at'   =&gt; Schema::TYPE_INTEGER
    ]);
    
    $this-&gt;createIndex('user_unique_email', 'user', 'email', true);

    <span class="strong"><strong class="calibre2">foreach ($users as $user)</strong></span>
    <span class="strong"><strong class="calibre2">{</strong></span>
        <span class="strong"><strong class="calibre2">$this-&gt;insert('user', [</strong></span>
            <span class="strong"><strong class="calibre2">'id'         =&gt; $user['id'],</strong></span>
            <span class="strong"><strong class="calibre2">'email'      =&gt; $user['email'],</strong></span>
            <span class="strong"><strong class="calibre2">'password'   =&gt; $user['password'],</strong></span>
            <span class="strong"><strong class="calibre2">'first_name' =&gt; $user['name'],</strong></span>
            <span class="strong"><strong class="calibre2">'created_at' =&gt; $user['created_at'],</strong></span>
            <span class="strong"><strong class="calibre2">'updated_at' =&gt; $user['updated_at']</strong></span>
        <span class="strong"><strong class="calibre2">]);</strong></span>
    <span class="strong"><strong class="calibre2">}</strong></span>
}</pre></div></li><li class="listitem" value="6">Now we can rerun our migration. If successful, we should see our original migration<a id="id120" class="calibre1"/> run and an insert call executed for each user in our database.<div class="note"><pre class="programlisting"><span class="strong"><strong class="calibre2">./yii migrate/up –interactive=0</strong></span>
</pre></div><div class="mediaobject"><img src="../images/00016.jpeg" alt="Querying for data" class="calibre10"/></div><p class="calibre25"> </p></li><li class="listitem" value="7">Finally, we can query our SQLite database to preview the updated schema and see our updated users:<div class="note"><pre class="programlisting"><span class="strong"><strong class="calibre2">sqlite3 /path/to/runtime/db.sqlite</strong></span>
</pre></div><div class="mediaobject"><img src="../images/00017.jpeg" alt="Querying for data" class="calibre10"/></div><p class="calibre25"> </p></li></ol><div class="calibre15"/></div><p class="calibre9">As you can see, DAO's query method provides us with the ability to quickly and efficiently <a id="id121" class="calibre1"/>fetch data from our database.</p><div class="book" title="Quoting table and column names"><div class="book"><div class="book"><div class="book"><h3 class="title2"><a id="ch03lvl3sec06" class="calibre1"/>Quoting table and column names</h3></div></div></div><p class="calibre9">When <a id="id122" class="calibre1"/>writing database-agnostic SQL queries, properly quoting field names can be problematic. To avoid this problem, Yii2 provides the ability to automatically quote table and column names for you using the correct quoting rule for the specific database in use.</p><p class="calibre9">To automatically quote a column name, simply enclose the column name in square brackets:</p><div class="note"><pre class="programlisting">[[column name]]</pre></div><p class="calibre9">To automatically quote a table, simply enclose the table name in curly brackets:</p><div class="note"><pre class="programlisting">{{table name}}</pre></div><p class="calibre9">An example of both of these tools in action is shown as follows:</p><div class="note"><pre class="programlisting">$result = \Yii::$app-&gt;db
          -&gt;createCommand("SELECT COUNT([[id]]) FROM {{user}}")
          -&gt;queryScalar();</pre></div></div></div></div>

<div class="book" title="Database access objects">
<div class="book" title="Executing queries"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_2"><a id="ch03lvl2sec36" class="calibre1"/>Executing queries</h2></div></div></div><p class="calibre9">While<a id="id123" class="calibre1"/> the query methods provide the ability to select data from our database, we often need to execute <code class="email">UPDATE</code> or <code class="email">DELETE</code> commands, which do not return data. To execute these commands, we can use the <code class="email">execute()</code> method in general:</p><div class="note"><pre class="programlisting">\Yii::$app-&gt;db
    -&gt;createCommand('INSERT INTO user (email, password) VALUES ("test3@example.com", "test3");')
    -&gt;execute();</pre></div><p class="calibre9">If successful, the <code class="email">execute()</code> method will return with <code class="email">true</code>, whereas if it fails, it will return <code class="email">false</code>.</p><p class="calibre9">Yii2 also provides convenient wrappers for <code class="email">insert()</code>, <code class="email">update()</code>, and <code class="email">delete()</code>, which enables us to write commands without having to write raw SQL. These methods properly escape and quote table and column names and bind parameters on your behalf.</p><p class="calibre9">For instance, we can insert a new user into a database as follows:</p><div class="note"><pre class="programlisting"><span class="strong"><strong class="calibre2">// INSERT ( tablename, [ attributes =&gt; attr ] )</strong></span>
\Yii::$app-&gt;db
    -&gt;createCommand()
    -&gt;insert('user', [
      'email'      =&gt; 'test4@example.com',
      'password'   =&gt; 'changeme7',
      'first_name' =&gt; 'Test',
      'last_name'  =&gt; 'User',
      'created_at' =&gt; time(),
      'updated_at' =&gt; time()
    ])
   -&gt;execute();</pre></div><p class="calibre9">We can<a id="id124" class="calibre1"/> update all the users in our database using the <code class="email">update()</code> method:</p><div class="note"><pre class="programlisting"><span class="strong"><strong class="calibre2">// UPDATE (tablename, [ attributes =&gt; attr ], condition )</strong></span>
\Yii::$app-&gt;db
    -&gt;createCommand()
    -&gt;update('user', [
        'updated_at' =&gt; time()
    ], '1 = 1')
   -&gt;execute();</pre></div><div class="note" title="Note"><h3 class="title2"><a id="tip41" class="calibre1"/>Tip</h3><p class="calibre9">The last argument listed in our update command defines the <code class="email">where</code> condition of our query command, which we'll cover in more detail later in the chapter. <code class="email">1=1</code> is a common SQL idiom to update all records.</p></div><p class="calibre9">We can also delete a user in our database using the <code class="email">delete()</code> method:</p><div class="note"><pre class="programlisting"><span class="strong"><strong class="calibre2">// DELETE ( tablename, condition )</strong></span>
\Yii::$app-&gt;db
    -&gt;createCommand()
    -&gt;delete('user', 'id = 3')
    -&gt;execute();</pre></div><p class="calibre9">Additionally, if you need to insert several rows at the same time, you can use the <code class="email">batchInsert()</code> method, which can be significantly more efficient than inserting a single row at a time:</p><div class="note"><pre class="programlisting"><span class="strong"><strong class="calibre2">// batchInsert( tablename, [ properties ], [ rows ] )</strong></span>
\Yii::$app-&gt;db
    -&gt;createCommand()
    -&gt;batchInsert('user', ['email', 'password', 'first_name', 'last_name', 'created_at', 'updated_at'], 
    [
        ['james.franklin@example.com', 'changeme7', 'James', 'Franklin', time(), time()],
        ['linda.marks@example.com', 'changeme7', 'Linda', 'Marks', time(), time()]
        ['roger.martin@example.com', 'changeme7', 'Roger', 'Martin', time(), time()]
    ])
    -&gt;execute();</pre></div><div class="note" title="Note"><h3 class="title2"><a id="tip42" class="calibre1"/>Tip</h3><p class="calibre9">Yii2 does<a id="id125" class="calibre1"/> not provide a <code class="email">batchUpdate()</code> or <code class="email">batchDelete()</code> method as bulk updates and deletes can be handled by the <code class="email">update()</code> and <code class="email">delete()</code> methods using a normal SQL.</p></div></div></div>

<div class="book" title="Database access objects">
<div class="book" title="Parameter binding"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_3"><a id="ch03lvl2sec37" class="calibre1"/>Parameter binding</h2></div></div></div><p class="calibre9">The number<a id="id126" class="calibre1"/> one rule when working with user-submitted data is to never trust user-submitted data. Any data that passes through our databases and has come from an end user needs to be validated, sanitized, and properly bound to our statements before they are executed against our database.</p><p class="calibre9">Take, for instance, the following query:</p><div class="note"><pre class="programlisting">\Yii::$app-&gt;db
    -&gt;createCommand("UPDATE user SET first_name = 'Tom' WHERE id  = " . $_GET['id'])
    -&gt;execute();</pre></div><p class="calibre9">Under normal circumstances, Yii would generate the following SQL, assuming <code class="email">$_GET['id']</code> had a value of <code class="email">1</code>:</p><div class="note"><pre class="programlisting">UPDATE user SET first_name = 'Tom' WHERE id = 1;</pre></div><p class="calibre9">While this is innocent enough, any user who can manipulate the <code class="email">$_GET['id']</code> variable can rewrite our query to something much more dangerous. For instance, they could drop our entire user table simply by substituting <code class="email">$_GET['id']</code> with <code class="email">1; DROP TABLE user; --</code>:</p><div class="note"><pre class="programlisting">UPDATE user SET first_name = 'Tom' WHERE id = <span class="strong"><strong class="calibre2">1; DROP TABLE user; --</strong></span>
</pre></div><p class="calibre9">This kind of attack is called SQL injection. To help protect against SQL injection, Yii2 offers several different ways to bind parameters to our queries in a way that will filter our injected SQL. These<a id="id127" class="calibre1"/> three methods are <code class="email">bindValue()</code>, <code class="email">bindValues()</code>, and <code class="email">bindParam()</code>.</p><p class="calibre9">The first method, <code class="email">bindValue()</code>, is used to bind a single parameter to a token within our SQL statement. For example, we can rewrite the previous query as follows:</p><div class="note"><pre class="programlisting">\Yii::$app-&gt;db
    -&gt;createCommand("UPDATE user SET first_name = :name WHERE id  = :id)
    -&gt;bindValue(':name', 'Tom')
    -&gt;bindValue(':id', $_GET['id'])
    -&gt;execute();</pre></div><p class="calibre9">Alternatively, we can use the <code class="email">bindValues()</code> method to bind several parameters into a single call:</p><div class="note"><pre class="programlisting">\Yii::$app-&gt;db
    -&gt;createCommand("UPDATE user SET first_name = :name WHERE id  = :id)
    -&gt;bindValues([ ':name' =&gt; 'Tom', ':id' =&gt; $_GET['id'] ])
    -&gt;execute();</pre></div><p class="calibre9">For convenience, the previous query can be rewritten so that the parameters are in line with the <code class="email">createCommand()</code> method:</p><div class="note"><pre class="programlisting">$params = [ ':name' =&gt; 'Tom', ':id' =&gt; $_GET['id'] ];
\Yii::$app-&gt;db
    -&gt;createCommand("UPDATE user SET first_name = :name WHERE id  = :id, $params)
    -&gt;execute();</pre></div><p class="calibre9">The final method, <code class="email">bindParam()</code>, is valued to bind parameters by reference rather than by value:</p><div class="note"><pre class="programlisting">$id = 1;
$name = 'Tom';
$q = \Yii::$app-&gt;db
    -&gt;createCommand("UPDATE user SET first_name = :name WHERE id  = :id)
    -&gt;bindParam(':name', $name)
    -&gt;bindParam(':id', $id);</pre></div><p class="calibre9">Because <code class="email">bindParam()</code> binds parameters by reference, we can change the bounded values to execute multiple queries. Following the previous example, we can write the following to update<a id="id128" class="calibre1"/> multiple users without having to rewrite our query each time:</p><div class="note"><pre class="programlisting">$q-&gt;execute();
$id = 2;
$name = 'Kevin';
$q-&gt;execute();</pre></div><div class="note" title="Note"><h3 class="title2"><a id="tip43" class="calibre1"/>Tip</h3><p class="calibre9">Remember, the most important rule of working with user data is to never trust user-submitted data. Even in cases where you're 100% certain that SQL injection cannot happen, it's recommended that you use parameter binding rather than writing in line SQL. This will protect you against future changes to your code.</p></div></div></div>

<div class="book" title="Database access objects">
<div class="book" title="Transactions"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_4"><a id="ch03lvl2sec38" class="calibre1"/>Transactions</h2></div></div></div><p class="calibre9">When <a id="id129" class="calibre1"/>running multiple queries in a sequence, we often want to ensure that our database state remains consistent across these queries. Most modern databases support the use of transactions to accomplish this. In a transaction, changes are written to the database in such a way that they can be committed if everything went well or rolled back without consequence if any given query within the transaction failed. In Yii2, this looks as follows:</p><div class="note"><pre class="programlisting">$transaction = \Yii::$app-&gt;db-&gt;beginTransaction();

try {
    \Yii::$app-&gt;db-&gt;createCommand($sql)-&gt;execute();
    \Yii::$app-&gt;db-&gt;createCommand($sql)-&gt;execute();
    //[ … more queries …]
    $transaction-&gt;commit();
} catch (\Exception $e) {
    $transaction-&gt;rollBack();
}</pre></div></div></div>

<div id="page" style="height:0pt"/><div class="book" title="Query Builder"><div class="book" id="OPEK2-ad3e09b384df46aea690d9c8897d5fe7"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch03lvl1sec20" class="calibre1"/>Query Builder</h1></div></div></div><p class="calibre9">Building<a id="id130" class="calibre1"/> on top of the foundations laid by DAO is Yii's Query Builder. Yii's Query Builder allows us to write database-agnostic queries in a programmatic way. Consequently, queries written through the Query Builder are significantly more readable than their DAO counterparts.</p><p class="calibre9">The basics of Query Builder involve the creation an instance of <code class="email">yii\db\Query</code>, the construction of a statement, and then the execution of that query statement. For example, we could simply query for all the users in our database in Query Builder using the following code:</p><div class="note"><pre class="programlisting">$users = (new \yii\db\Query())
    -&gt;select(['id', 'email'])
    -&gt;from('user')
    -&gt;all();</pre></div><div class="note" title="Note"><h3 class="title2"><a id="tip44" class="calibre1"/>Tip</h3><p class="calibre9">When working with Query Builder, we're actually using the <code class="email">yii\db\Query</code> class rather than <code class="email">yii\db\QueryBuilder</code>. While <code class="email">yii\db\QueryBuilder</code> can generate SQL statements similar to those generated by <code class="email">yii\db\Query</code>, <code class="email">yii\db\Query</code> enables these statements to be database-agnostic. In general, you'll want to work with <code class="email">yii\db\Query</code> when using Query Builder.</p></div></div>

<div class="book" title="Query Builder">
<div class="book" title="Query construction methods"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_1"><a id="ch03lvl2sec39" class="calibre1"/>Query construction methods</h2></div></div></div><p class="calibre9">The <a id="id131" class="calibre1"/>basics of Query Builder involve the chaining of multiple query methods together. These method names directly correspond with the SQL segment that they are named after. When working with Query Builder, the most common methods that you'll use will be the <code class="email">select()</code>, <code class="email">from()</code>, and <code class="email">where()</code> methods.</p><p class="calibre9">Moving forward, we'll use the following variable to represent our query builder object:</p><div class="note"><pre class="programlisting">$query = (new \yii\db\Query());</pre></div></div></div>

<div class="book" title="Query Builder">
<div class="book" title="The select method"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_2"><a id="ch03lvl2sec40" class="calibre1"/>The select method</h2></div></div></div><p class="calibre9">The <code class="email">select()</code> method <a id="id132" class="calibre1"/>directly corresponds to the <code class="email">SELECT</code> segment <a id="id133" class="calibre1"/>of our SQL query and accepts either a string of column names or an array of columns to specify the columns that we would want to select from our database. For instance, the following queries are identical:</p><div class="note"><pre class="programlisting">$query-&gt;select('id, first_name)-&gt;from('user');
$query-&gt;select(['id', 'last_name'])-&gt;from('user');</pre></div><div class="note" title="Note"><h3 class="title2"><a id="tip45" class="calibre1"/>Tip</h3><p class="calibre9">When using the <code class="email">select()</code> method, the array format is generally easy to read and work with. If you choose to list the column names as a string, ensure that you do that consistently throughout your application. In the following examples, we'll use the array format.</p></div><p class="calibre9">The <code class="email">select()</code> method also supports column aliases and table prefixes, as shown in the next example:</p><div class="note"><pre class="programlisting">$query-&gt;select([
    'id' =&gt; 'user_id', 
    'user.first_name' =&gt; 'fName']
)-&gt;from('user');</pre></div><p class="calibre9">In addition to column names, the <code class="email">select</code> method also provides support for expressions. For instance, if we want to retrieve the user's complete name as a single field, we can execute the following query:</p><div class="note"><pre class="programlisting">$query-&gt;select([
    "id", 
    "CONCACT(first_name, ' ', last_name)" =&gt; 'full_name'
])-&gt;from('user'); </pre></div><p class="calibre9">The <code class="email">select</code> method can also be used to execute subqueries, such as <code class="email">COUNT()</code>:</p><div class="note"><pre class="programlisting">$query-&gt;select('COUNT(*)')-&gt;from('user');</pre></div><p class="calibre9">Finally, the <code class="email">select</code> statement can be chained with the <code class="email">distinct()</code> method to retrieve unique records. For instance, if we want to list all the first names of our user's database, we can execute the following query:</p><div class="note"><pre class="programlisting">$query-&gt;select('first_name')-&gt;distinct()-&gt;from('user');</pre></div><div class="note" title="Note"><h3 class="title2"><a id="tip46" class="calibre1"/>Tip</h3><p class="calibre9">Omitting the <code class="email">select()</code> method from your query will result in a <code class="email">SELECT *</code> query being performed.</p></div><div class="book" title="The from method"><div class="book"><div class="book"><div class="book"><h3 class="title2"><a id="ch03lvl3sec07" class="calibre1"/>The from method</h3></div></div></div><p class="calibre9">Our previous<a id="id134" class="calibre1"/> examples have already illustrated the basic usage of the <code class="email">from()</code> method. The <code class="email">from()</code> method can also be used to specify a table alias, as shown in the following example:</p><div class="note"><pre class="programlisting">$query-&gt;select('first_name')-&gt;from(['u' =&gt; 'users']);</pre></div><div class="note" title="Note"><h3 class="title2"><a id="tip47" class="calibre1"/>Tip</h3><p class="calibre9">Like the <code class="email">select()</code> method, the <code class="email">from()</code> method can also accept strings as an input rather than an array. The preceding query can be rewritten as <code class="email">$query-&gt;select('first_name')-&gt;from(['users u');</code>.</p></div></div><div class="book" title="The where method"><div class="book"><div class="book"><div class="book"><h3 class="title2"><a id="ch03lvl3sec08" class="calibre1"/>The where method</h3></div></div></div><p class="calibre9">The <code class="email">where</code>() method <a id="id135" class="calibre1"/>specifies the <code class="email">where</code> segment of our SQL query <a id="id136" class="calibre1"/>and can be used either in a string format, hash format, or operator format.</p><div class="book" title="The string format"><div class="book"><div class="book"><div class="book"><h4 class="title3"><a id="ch03lvl4sec01" class="calibre1"/>The string format</h4></div></div></div><p class="calibre9">The<a id="id137" class="calibre1"/> string format of the <code class="email">where()</code> method should always be chained with the <code class="email">addParams()</code> method in order to prevent SQL injection:</p><div class="note"><pre class="programlisting">$query-&gt;select(['first_name', 'last_name'])
           -&gt;from('user')
      -&gt;where('id = :id')
      -&gt;addParams([':id' =&gt; 1]);</pre></div><p class="calibre9">Alternatively, the parameters can be rewritten as the second argument to the <code class="email">where()</code> method:</p><div class="note"><pre class="programlisting">$query-&gt;select(['first_name', 'last_name'])
      -&gt;from('user')
      -&gt;where('id = :id', [':id' =&gt; 1]);</pre></div><div class="note" title="Note"><h3 class="title2"><a id="tip48" class="calibre1"/>Tip</h3><p class="calibre9">Remember to avoid adding PHP variables inline in your <code class="email">where()</code> method in order to avoid SQL injection.</p></div></div><div class="book" title="The hash format"><div class="book"><div class="book"><div class="book"><h4 class="title3"><a id="ch03lvl4sec02" class="calibre1"/>The hash format</h4></div></div></div><p class="calibre9">The hash <a id="id138" class="calibre1"/>format provides an even better way to chain multiple <code class="email">AND</code> conditions together in the <code class="email">where</code> statement. Rather than passing a string as a parameter, we can instead pass an array of key values representing the column name and value. When using the hash format, the selected fields will be joined together with the SQL <code class="email">AND</code>.</p><p class="calibre9">For example, we can find all the users in our database with the first name of John who were in their 20s and who didn't have a listed pet name by running the following query:</p><div class="note"><pre class="programlisting">$query-&gt;from('user')
      -&gt;where([
       'first_name' =&gt; 'John',
       'pets_name' =&gt; NULL,
       'age' =&gt; [20, 21, 22, 23, 24, 25, 26, 27, 28, 29],
       ]);</pre></div><div class="note" title="Note"><h3 class="title2"><a id="tip49" class="calibre1"/>Tip</h3><p class="calibre9">Our database currently doesn't have an <code class="email">age</code> or <code class="email">pets_name</code> field. We will have to adjust our schema with a migration to add these fields to our database.</p></div><p class="calibre9">This <a id="id139" class="calibre1"/>would result in the following query:</p><div class="note"><pre class="programlisting">SELECT * 
FROM user 
WHERE first_name = "John" AND 
        pets_name IS NULL AND 
        age IN (20, 21, 22, 23, 24, 25, 26, 27, 28, 29);</pre></div><div class="note" title="Note"><h3 class="title2"><a id="tip50" class="calibre1"/>Tip</h3><p class="calibre9">As illustrated previously, the hash format allows you to generate more complex <code class="email">WHERE</code> queries, such as those that use <code class="email">IN</code> when specifying an array of values and <code class="email">IS NULL</code> when passing null as the array value.</p></div></div><div class="book" title="The operator format"><div class="book"><div class="book"><div class="book"><h4 class="title3"><a id="ch03lvl4sec03" class="calibre1"/>The operator format</h4></div></div></div><p class="calibre9">The last <a id="id140" class="calibre1"/>way to use the <code class="email">where()</code> method is to use the operator format. The operator format allows us to build more complex SQL queries containing conditionals such as <code class="email">LIKE</code>, <code class="email">OR</code>, <code class="email">BETWEEN</code>, and <code class="email">EXISTS</code>, just to name a few examples.</p><p class="calibre9">In general, the <code class="email">operator</code> format takes the following format:</p><div class="note"><pre class="programlisting">where([ operator, condition1, condition2 ]);</pre></div><p class="calibre9">For example, if we want to fetch all users from our database who had the first name of John or Jill, we can execute this:</p><div class="note"><pre class="programlisting">$query-&gt;where(['or', 'John', 'Jill']);</pre></div><div class="note" title="Note"><h3 class="title2"><a id="tip51" class="calibre1"/>Tip</h3><p class="calibre9">For a complete list of all the available operators that the operator format supports, check<a id="id141" class="calibre1"/> out the Yii2 API documentation at <a class="calibre1" href="http://www.yiiframework.com/doc-2.0/yii-db-query.html#where()-detail">http://www.yiiframework.com/doc-2.0/yii-db-query.html#where()-detail</a>.</p></div><p class="calibre9">As you can imagine, the <code class="email">where()</code> method can quickly become very bulky and complicated. Rather<a id="id142" class="calibre1"/> than using the operator, you may find your code more readable by using the <code class="email">andWhere()</code> or <code class="email">orWhere()</code> methods to chain multiple conditions together:</p><div class="note"><pre class="programlisting">$query-&gt;andWhere(['in', 'id', [1,2,3,4,5]);</pre></div></div></div><div class="book" title="Ordering results"><div class="book"><div class="book"><div class="book"><h3 class="title2"><a id="ch03lvl3sec09" class="calibre1"/>Ordering results</h3></div></div></div><p class="calibre9">Query<a id="id143" class="calibre1"/> builder can also sort results by a given field using the <code class="email">orderBy()</code> method. For example, to sort all of our users in our database by age, we can construct the following query:</p><div class="note"><pre class="programlisting">$query-&gt;from('user')
      -&gt;orderBy('age ASC');</pre></div></div><div class="book" title="Limiting and offsetting data"><div class="book"><div class="book"><div class="book"><h3 class="title2"><a id="ch03lvl3sec10" class="calibre1"/>Limiting and offsetting data</h3></div></div></div><p class="calibre9">Commonly<a id="id144" class="calibre1"/> used with the <code class="email">where()</code> method are the <code class="email">limit()</code> and <code class="email">offset()</code> methods, which are used to limit the number of results and offset our results <a id="id145" class="calibre1"/>by a given number of results. When properly used together, these two methods form the basics of paginating through results:</p><div class="note"><pre class="programlisting">$query-&gt;from('user')
      -&gt;limit(5)
      -&gt;offset(5);</pre></div></div><div class="book" title="Grouping and having"><div class="book"><div class="book"><div class="book"><h3 class="title2"><a id="ch03lvl3sec11" class="calibre1"/>Grouping and having</h3></div></div></div><p class="calibre9">Often when working with diverse datasets, we'll need to perform some analysis on our data. Aggregate<a id="id146" class="calibre1"/> functions such as <code class="email">GROUP BY</code> and <code class="email">HAVING</code> can<a id="id147" class="calibre1"/> greatly assist in extracting additional information from our data. Yii2 supports these methods via the <code class="email">groupBy()</code> and <code class="email">having()</code> methods.</p><p class="calibre9">For example, if we want to list the number of users in our database in each age group, we can execute the following query:</p><div class="note"><pre class="programlisting">$query-&gt;select(['age', 'COUNT(*)' =&gt; 'users'])
      -&gt;from('user')
      -&gt;groupBy('age');</pre></div><p class="calibre9">This will generate the following SQL statement:</p><div class="note"><pre class="programlisting">SELECT age, COUNT(*) AS users FROM user GROUP BY age;</pre></div><p class="calibre9">The <code class="email">groupBy()</code> method behaves similar to the <code class="email">select()</code> method in that it accepts either an array or a string as an argument; however, when using database expressions, you'll need to use the array syntax.</p><p class="calibre9">After grouping our results with <code class="email">groupBy()</code>, we can then filter our results with the <code class="email">having()</code> method, which behaves the same as the <code class="email">where()</code> method. The following example will <a id="id148" class="calibre1"/>only show the number of users in our dataset who<a id="id149" class="calibre1"/> are over a specified age:</p><div class="note"><pre class="programlisting">$query-&gt;select(['age', 'COUNT(*)' =&gt; 'users'])
      -&gt;from('user')
      -&gt;groupBy('age')
      -&gt;having('&gt;', 'age', 30');</pre></div></div><div class="book" title="Joins and unions"><div class="book"><div class="book"><div class="book"><h3 class="title2"><a id="ch03lvl3sec12" class="calibre1"/>Joins and unions</h3></div></div></div><p class="calibre9">When <a id="id150" class="calibre1"/>working across multiple tables, you may often need to perform a join or union on your datasets. Joins and unions can be performed through query builder using the <code class="email">join()</code> and <code class="email">union()</code> methods.</p><p class="calibre9">The join method has the following method syntax:</p><div class="note"><pre class="programlisting">$query-&gt;join( $type, $table, $on, $params );</pre></div><p class="calibre9">The first parameter, <code class="email">$type</code>, specifies the join type you'd like to execute (for example, <code class="email">INNER JOIN</code>, <code class="email">LEFT JOIN</code>, or <code class="email">OUTER JOIN</code>). The <code class="email">$table</code> parameter specifies the table to be joined. The third parameter, <code class="email">$on</code>, specifies the conditions on which the table should be joined and takes the syntax of the <code class="email">where()</code> method, and the <code class="email">$params</code> parameter specifies optional parameters to be bound to the join.</p><p class="calibre9">For example, suppose we had a posts and users table. We could join them as follows using the <code class="email">join()</code> method:</p><div class="note"><pre class="programlisting">$query-&gt;join('LEFT JOIN', 'post', 'post.user_id = user.id');</pre></div><p class="calibre9">Assuming our database had both a user and post table, this would return a return containing a join of all users and their posts. The result would include all users joined with all the posts that they owned.</p><p class="calibre9">Joins can also be performed by type using the shortcut methods <code class="email">rightJoin()</code>, <code class="email">leftJoin()</code>, and <code class="email">innerJoin()</code>.</p><p class="calibre9">In the same<a id="id151" class="calibre1"/> vein, unions of two different queries can be constructed by first building two separate <code class="email">yii\db\Query</code> objects and then using the <code class="email">union()</code> method on them, as follows:</p><div class="note"><pre class="programlisting">$query1-&gt;union($query2);</pre></div></div><div class="book" title="Executing queries"><div class="book"><div class="book"><div class="book"><h3 class="title2"><a id="ch03lvl3sec13" class="calibre1"/>Executing queries</h3></div></div></div><p class="calibre9">After <a id="id152" class="calibre1"/>constructing our query with Query Builder, we'll need to specify the execution of our query. Yii2 provides the following query methods to execute queries built with Query Builder. The query methods are simply chained to the existing <code class="email">$query</code> object, which will immediately result in their execution.</p><p class="calibre9">Most of the times when working with Query Builder, we'll want to fetch all the records in our database. This can be done by chaining the <code class="email">all()</code> methods to our query object, which will retrieve all the records that fulfill the requirements of our <code class="email">$query</code> object:</p><div class="note"><pre class="programlisting">$results = $query-&gt;all();</pre></div><p class="calibre9">The <code class="email">$result</code> variable will then be populated with an array of rows, with each row containing an associated array of name-value key pairs for the resulting data.</p><div class="note" title="Note"><h3 class="title2"><a id="tip52" class="calibre1"/>Tip</h3><p class="calibre9">Carefully consider using the <code class="email">all()</code> method if you have a large dataset, as the resulting query execution could take a long time to complete, and it could either hang or cause an error in your application.</p></div><p class="calibre9">In other instances, it may be more beneficial just to fetch the first row of a query. To fetch the first row, we can use the <code class="email">one()</code> method:</p><div class="note"><pre class="programlisting">$row = $query-&gt;one();</pre></div><p class="calibre9">At other times, we may just want to know whether a query would result in any data. To achieve this, we can use the <code class="email">exists()</code> method, which will return either <code class="email">true</code> or <code class="email">false</code>, indicating that data would be returned from the resulting query.</p><p class="calibre9">For example, if we want to know whether we have any users in our database, we can use the <code class="email">exists()</code> query to check whether we had users before we performed any more complex queries:</p><div class="note"><pre class="programlisting">$areUsersInDb = (new \yii\db\Query)
              -&gt;from('user')
              -&gt;exists();</pre></div><p class="calibre9">Alternatively, we can use the <code class="email">count()</code> method to determine how many users exist in our database before running our query. The <code class="email">count()</code> method will execute a <code class="email">COUNT(*)</code> method within the <code class="email">SELECT</code> fragment, and it will return a scalar value:</p><div class="note"><pre class="programlisting">$count = (new \yii\db\Query)
       -&gt;from('user')
       -&gt;count();</pre></div><p class="calibre9">When working with database expressions, such as <code class="email">MIN()</code> and <code class="email">MAX()</code>, or even more complex queries, you may find it useful to retrieve scalar values from query builder rather than an<a id="id153" class="calibre1"/> associative array. To fetch scalar values with query builder, we can use the <code class="email">scalar()</code> method. For instance, if we want to know how old the oldest user is in our database using the <code class="email">MAX()</code> SQL method, we can use the following code to return an integer representing their age:</p><div class="note"><pre class="programlisting">$age = (new \yii\db\Query)
     -&gt;select('MAX(age)')
     -&gt;from('user')
     -&gt;scalar();</pre></div><p class="calibre9">Finally, we may find it beneficial to retrieve the first column of our database results, such as in the instance of using the <code class="email">groupBy()</code> or <code class="email">having()</code> methods. To fetch the first row of our results, we can use the <code class="email">column()</code> method:</p><div class="note"><pre class="programlisting">$result = (new \yii\db\Query)
        -&gt;from('user')
        -&gt;column();</pre></div><p class="calibre9">In the previous example, the first column of our user table is the <code class="email">ID</code> field. Consequently, an array of all IDs in our database will be returned.</p><div class="note" title="Note"><h3 class="title2"><a id="tip53" class="calibre1"/>Tip</h3><p class="calibre9">Selecting all columns (<code class="email">*</code>) will result in all records being loaded into the memory, which, depending upon the size of the table, could result in performance degradation. It's important to remember when querying for data that you only query for the data you need. If you need all data, you query for it in iterative way such as to limit the memory required for each query.</p></div></div><div class="book" title="Examining queries"><div class="book"><div class="book"><div class="book"><h3 class="title2"><a id="ch03lvl3sec14" class="calibre1"/>Examining queries</h3></div></div></div><p class="calibre9">After<a id="id154" class="calibre1"/> building a query, you may want to examine the resulting query. To achieve this, the <code class="email">createCommand()</code> method can be used to convert the Query Builder object into a DAO command:</p><div class="note"><pre class="programlisting">$command = $query-&gt;select(['first_name', 'last_name'])
                 -&gt;from('user')
                 -&gt;where('id = :id', [':id' =&gt; 1])
                 -&gt;createCommand();

// Show the generated SQL statement
echo $command-&gt;sql;

// Show the bound parameters
var_dump($command-&gt;params);

// Execute the query via normal DAO commands
$rows = $command-&gt;queryAll();</pre></div></div><div class="book" title="Iterating over query results"><div class="book"><div class="book"><div class="book"><h3 class="title2"><a id="ch03lvl3sec15" class="calibre1"/>Iterating over query results</h3></div></div></div><p class="calibre9">Often <a id="id155" class="calibre1"/>when working with large datasets, the resulting datasets may be too large to load into the memory. To keep the memory consumption low and to prevent our application from hanging, we can use either the <code class="email">batch()</code> or <code class="email">each()</code> method. By default, both methods will fetch 100 rows from the database. To change the number of rows to be fetched, simply change the first parameter of each method:</p><div class="note"><pre class="programlisting">$query-&gt;from('user');

// $users will ben an array of 100 or fewer rows from the database
foreach ($query-&gt;batch() as $users) {}

// Whereas the each() method allows you to iterate over the first 50 or fewer users one by one
foreach ($query-&gt;each(50) as $user) {}</pre></div><p class="calibre9">A <code class="email">batch()</code> method supports fetching the data in batches, which can keep the memory down. Think of this method as a query appended with a limit and an offset parameter, which will restrict the number of returned rows. Each iteration of the <code class="email">batch()</code> query will contain multiple results. Like the <code class="email">batch()</code> method, the <code class="email">each()</code> method can be used to reduce memory consumption as well, but it will iterate over the query row-by-row instead, which means that each iteration of the method will result in a single instance of our data.</p></div></div></div>
<div class="book" title="Data providers and data widgets"><div class="book" id="PNV62-ad3e09b384df46aea690d9c8897d5fe7"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch03lvl1sec21" class="calibre1"/>Data providers and data widgets</h1></div></div></div><p class="calibre9">In Yii2, data<a id="id156" class="calibre1"/> providers are helper classes that are used to extract<a id="id157" class="calibre1"/> data via Query Builder to be passed to a data widget. The benefit of using data providers and data widgets over queries built via Query Builder is that they provide an interface to automatically deal with sorting and pagination.</p><p class="calibre9">The most common way to work with data providers is to use the <code class="email">yii\data\ActiveDataProvider</code> class. Typically, <code class="email">yii\data\ActiveDataProvider</code> will be used with Active Record models:</p><div class="note"><pre class="programlisting">$provider = new ActiveDataProvider([
    'query' =&gt; User::find(),
    'pagination' =&gt; [
        'pageSize' =&gt; 20,
    ],
]);</pre></div><div class="note" title="Note"><h3 class="title2"><a id="tip54" class="calibre1"/>Tip</h3><p class="calibre9">We'll cover how to create and use Active Record and models in <a class="calibre1" title="Chapter 4. Active Record, Models, and Forms" href="part0030_split_000.html#SJGS2-ad3e09b384df46aea690d9c8897d5fe7">Chapter 4</a>, <span class="strong"><em class="calibre13">Active Record, Models, and Forms</em></span>.</p></div><p class="calibre9">Active data providers can also be populated through Query Builder, as shown in the following example:</p><div class="note"><pre class="programlisting">$query = new yii\db\Query();
$provider = new ActiveDataProvider([
    'query' =&gt; $query-&gt;from('user'),
    'pagination' =&gt; [
        'pageSize' =&gt; 20,
    ],
]);</pre></div><div class="note" title="Note"><h3 class="title2"><a id="note13" class="calibre1"/>Note</h3><p class="calibre9">Yii2 provides<a id="id158" class="calibre1"/> two additional data provider types: <code class="email">yii\data\ActiveDataProvider</code> and <code class="email">yii\data\SqlDataProvider</code>. For more information on these data providers, check out the Yii2 guide at <a class="calibre1" href="http://www.yiiframework.com/doc-2.0/guide-output-data-providers.html">http://www.yiiframework.com/doc-2.0/guide-output-data-providers.html</a>.</p></div><p class="calibre9">Once we have fetched our data with a data provider, we can pass the resulting data to a data widget. Data widgets in Yii2 are reusable building blocks used within views to create complex interfaces to interact with data. The most common data widgets are <code class="email">DetailView</code>, <code class="email">ListView</code>, and <code class="email">GridView</code>, which behave similar to their Yii1 counterparts.</p><p class="calibre9">For instance, we can take our previous data provider and output it in <code class="email">GridView</code>, as follows:</p><div class="note"><pre class="programlisting">$query = new yii\db\Query();
$provider = new yii\data\ActiveDataProvider([
    'query' =&gt; $query-&gt;from('user'),
    'pagination' =&gt; [
        'pageSize' =&gt; 2, 
    ],  
]);

echo yii\grid\GridView::widget([
    'dataProvider' =&gt; $provider
]);</pre></div><p class="calibre9">By itself, our<a id="id159" class="calibre1"/> resulting <code class="email">GridView</code> widget will display all the fields in our<a id="id160" class="calibre1"/> database table. In some instances, there may be sensitive data that we don't want to display on this page. Alternatively, there could simply be too much data to display in <code class="email">GridView</code>. To restrict the number of fields to display in our <code class="email">GridView</code> widget, we can use the <code class="email">columns</code> attribute:</p><div class="note"><pre class="programlisting">echo yii\grid\GridView::widget([
    'dataProvider' =&gt; $provider,
    'columns' =&gt; [
        'id',
        'email',
        'first_name',
        'last_name',
        'created_at',
        'updated_at'
    ]
]);</pre></div><div class="mediaobject"><img src="../images/00018.jpeg" alt="Data providers and data widgets" class="calibre10"/></div><p class="calibre11"> </p><p class="calibre9">We can further enhance our data providers using the <code class="email">yii\data\Sort</code> class, which provides sorting capabilities to our data providers. To add sorting to our data provider, we'll need to specify the sort parameter within <code class="email">yii\data\ActiveDataProvider</code> with an instance of <code class="email">yii\data\Sort</code>, which specifies the attributes that can be sorted against:</p><div class="note"><pre class="programlisting">$query = new yii\db\Query();
$provider = new yii\data\ActiveDataProvider([
    'query' =&gt; $query-&gt;from('user'),
    <span class="strong"><strong class="calibre2">'sort' =&gt; new yii\data\Sort([</strong></span>
        <span class="strong"><strong class="calibre2">'attributes' =&gt; [</strong></span>
            <span class="strong"><strong class="calibre2">'email',</strong></span>
            <span class="strong"><strong class="calibre2">'first_name',</strong></span>
            <span class="strong"><strong class="calibre2">'last_name'</strong></span>
        <span class="strong"><strong class="calibre2">]</strong></span>
    <span class="strong"><strong class="calibre2">]),</strong></span>
    'pagination' =&gt; [
        'pageSize' =&gt; 2,
    ],  
]);</pre></div><div class="mediaobject"><img src="../images/00019.jpeg" alt="Data providers and data widgets" class="calibre10"/></div><p class="calibre11"> </p><p class="calibre9">As<a id="id161" class="calibre1"/> illustrated, the listed attributes within the <code class="email">sort</code> attribute are now<a id="id162" class="calibre1"/> clickable and sortable through our data provider.</p><div class="note" title="Note"><h3 class="title2"><a id="tip55" class="calibre1"/>Tip</h3><p class="calibre9">More<a id="id163" class="calibre1"/> information on output data widgets can be found in the Yii2 guide at <a class="calibre1" href="http://www.yiiframework.com/doc-2.0/guide-output-data-widgets.html">http://www.yiiframework.com/doc-2.0/guide-output-data-widgets.html</a>.</p></div><p class="calibre9">While some widgets, such as <code class="email">GridView</code>, allow us to work with and display multiple rows, we can also use data providers and data widgets to display information for a single row. With the <code class="email">DetailView</code> widget, we can dynamically configure a simple interface to display the information for a particular user in our database. The <code class="email">getModels()</code> method of our data provider splits our data provider into individual models that our <code class="email">DetailView</code> widget can understand:</p><div class="note"><pre class="programlisting">echo yii\widgets\DetailView::widget([
    'model' =&gt; $user,    
    'attributes' =&gt; [
        'id',               
        'first_name',
        'last_name',
        'email',
        // Format the updated dates as datetime object
        // Rather than an integer
        'updated_at:datetime'
    ]
]);</pre></div><div class="note" title="Note"><h3 class="title2"><a id="tip56" class="calibre1"/>Tip</h3><p class="calibre9">Typically<a id="id164" class="calibre1"/> when working with the <code class="email">DetailView</code> widget, we'll<a id="id165" class="calibre1"/> supply it with an Active Record instance rather than a generated model from our data provider, which we'll cover in <a class="calibre1" title="Chapter 4. Active Record, Models, and Forms" href="part0030_split_000.html#SJGS2-ad3e09b384df46aea690d9c8897d5fe7">Chapter 4</a>, <span class="strong"><em class="calibre13">Active Record, Models, and Forms</em></span>.</p></div><p class="calibre9">This will be displayed on our screen:</p><div class="mediaobject"><img src="../images/00020.jpeg" alt="Data providers and data widgets" class="calibre10"/></div><p class="calibre11"> </p><p class="calibre9">In addition to simply displaying results from a database, the <code class="email">DetailView</code> widget also supports the custom formatting of certain rows. In our previous example, we were able to format our Unix timestamp stored in the <code class="email">updated_at</code> field as human-readable date and time fields by specifying the <code class="email">:datetime</code> formatter in our updated field:</p><div class="note"><pre class="programlisting">'attributes' =&gt; [
    [...],
    'updated_at:datetime'
]</pre></div><div class="note" title="Note"><h3 class="title2"><a id="tip57" class="calibre1"/>Tip</h3><p class="calibre9">The formatter listed here is a powerful tool that allows us to quickly convert raw data into useful human-readable information. More information on the formatter can <a id="id166" class="calibre1"/>be found at <a class="calibre1" href="http://www.yiiframework.com/doc-2.0/yii-i18n-formatter.html">http://www.yiiframework.com/doc-2.0/yii-i18n-formatter.html</a>.</p></div></div>
<div class="book" title="Data replication and load balancing" id="QMFO1-ad3e09b384df46aea690d9c8897d5fe7"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch03lvl1sec22" class="calibre1"/>Data replication and load balancing</h1></div></div></div><p class="calibre9">As we <a id="id167" class="calibre1"/>start working with larger and larger systems, we often find the <a id="id168" class="calibre1"/>need to build an additional redundancy into our system in order to enable high availability and protection against unexpected downtime. When working with large systems, we will split our database into a read-and-write master and a read-only slave of a set of slaves. Typically, our applications are unaware of our database architecture, which can introduce problems when required to migrate from a new master. With Yii2, we can configure our database connection to not only be aware of our master-slave database configuration, but also intelligently handle slave unavailability.</p><p class="calibre9">In Yii2, we can configure a single master and multiple slaves using the following database configuration. This will result in all writes going to our declared master and all reads going to one of our declared slaves:</p><div class="note"><pre class="programlisting">$config = [
    'class' =&gt; 'yii\db\Connection',

    // configuration for the master
    'dsn' =&gt; '&lt;master_dns&gt;',
    'username' =&gt; 'master',
    'password' =&gt; '&lt;master_password&gt;',

    // common configuration for slaves
    'slaveConfig' =&gt; [
        'username' =&gt; 'slave',
        'password' =&gt; '&lt;slave_password&gt;',
        'attributes' =&gt; [
            // Use a small connection timeout
            PDO::ATTR_TIMEOUT =&gt; 10,
        ],
    ],

    // List of slave configurations.
    'slaves' =&gt; [
        ['dsn' =&gt; '&lt;slave1_dsn&gt;'],
        ['dsn' =&gt; '&lt;slave2_dsn&gt;'],
        ['dsn' =&gt; '&lt;slave3_dsn&gt;'],
    ]
];

$db = Yii::createObject($config);

// Would execute against an available slave
$users = $db-&gt;createCommand('SELECT * FROM user')-&gt;queryAll();

// Would execute against the master
$db-&gt;createCommand('UPDATE user SET updated_at = NOW()')-&gt;execute();</pre></div><div class="note" title="Note"><h3 class="title2"><a id="tip58" class="calibre1"/>Tip</h3><p class="calibre9">In general, queries executed with the <code class="email">execute()</code> method will run against the master, whereas all other queries will run against one of the slaves.</p></div><p class="calibre9">In this <a id="id169" class="calibre1"/>configuration, Yii will execute write queries (such as <code class="email">UPDATE</code>, <code class="email">INSERT</code>, and <code class="email">DELETE</code>) against the master and run a read query (such as <code class="email">SELECT</code>) against <a id="id170" class="calibre1"/>one of the available slaves. When working with slaves, Yii will attempt to connect to slaves in the list until a slave responds and load balance queries against each of the available slaves. By setting <code class="email">PDO::ATTR_TIMEOUT</code> equal to 10 seconds, Yii will abort trying to retrieve data from a slave if it receives no response within 10 seconds, and it will remember the state of the slave for the duration that the configuration is in effect.</p><p class="calibre9">Alternatively, using the following configuration, we can configure our application to work with both multiple masters and multiple slaves. When using multiple masters, Yii will execute writes against any available master and will load balance writes between the available masters:</p><div class="note"><pre class="programlisting">$config = [
    'class' =&gt; 'yii\db\Connection',
    'masterConfig' =&gt; [
        'username' =&gt; 'master',
        'password' =&gt; '&lt;master_password&gt;',
        'attributes' =&gt; [
            // use a smaller connection timeout
            PDO::ATTR_TIMEOUT =&gt; 10,
        ],
    ],

    // list of master configurations
    'masters' =&gt; [
        ['dsn' =&gt; '&lt;master1_dsn&gt;'],
        ['dsn' =&gt; '&lt;master2_dsn&gt;'],
    ],

    'slaveConfig' =&gt; [...],
    'slaves' =&gt; [...]
];</pre></div><div class="note" title="Note"><h3 class="title2"><a id="tip59" class="calibre1"/>Tip</h3><p class="calibre9">If Yii2 is unable to connect to any of the available masters, an exception will be thrown.</p></div><p class="calibre9">When <a id="id171" class="calibre1"/>working<a id="id172" class="calibre1"/> with a master-slave topology, we may want to issue a read query against one of our masters. To do that, we would need to explicitly tell Yii2 to run our query against our master rather than our slaves:</p><div class="note"><pre class="programlisting">$rows = $db-&gt;useMaster(function ($db) {
    return $db-&gt;createCommand('SELECT * FROM user')-&gt;queryAll();
});</pre></div><p class="calibre9">When working with transactions, Yii2 will try to run transactions against our master by default. If we need to issue a transaction against a slave, we will need to explicitly begin the transaction on a slave, as follows:</p><div class="note"><pre class="programlisting">$transaction = $db-&gt;slave-&gt;beginTransaction();</pre></div></div>
<div class="book" title="Summary" id="RL0A1-ad3e09b384df46aea690d9c8897d5fe7"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch03lvl1sec23" class="calibre1"/>Summary</h1></div></div></div><p class="calibre9">In this chapter, we covered the foundations of working with databases in Yii2. By working with database access objects, we showed how we can execute raw SQL statements to run against our database and how we can use transactions to protect our database integrity. We also illustrated the use of Query Builder, which can enable us to write database-agnostic queries in a programmatic way. We then discovered how we can use Query Builder to construct intelligent data providers, which are used to supply data to reusable data widgets. Finally, we learned how to configure Yii2 to be aware of master-slave and multi-master database cluster configurations and how to load balance between these connections.</p><p class="calibre9">In the next chapter, we discover the capstone of working with databases in Yii2—Active Record—which is a powerful tool used to work with our data and model our database structure. We'll also dive into Active Records relatives, basic models, and forms, and we'll learn how we can use a powerful tool called Gii to automate the construction of much of the code our modern applications will work with.</p></div></body></html>