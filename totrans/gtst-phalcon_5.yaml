- en: Chapter 5. Using Phalcon's Features
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It's time to add some features to our blog and learn more about Phalcon's functionality
    in the process. There is still a lot to do to get our blog up-to-speed. Users'
    passwords are still in plain text, and anyone, whether they are a user or not,
    can browse to a user's page and view the passwords. So, we need to set up at least
    some sort of security and user-access control. We have a comments table, yet we
    don't have any way to comment. And a blog is not a blog without an RSS feed and
    the ability to ping feed aggregators.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: How to hash passwords with Phalcon
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to use view helpers and view partials
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to set cookies
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to control the user's access
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to cache data in our application
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to use Phalcon's event manager
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to route application requests
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Hashing passwords with Phalcon
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: First, let's at least get the passwords hashed. Hashing is a process by which
    a password is converted into a fixed length bit string or a hash that cannot be
    reverse-engineered to retrieve the password, but any change in the entered password
    will change the resulting hash. So, for a more secure application, we are going
    to generate a hash from the password that a user enters and store that value in
    the database. Then, when the user tries to log in again, we will generate a hash
    from the entered password and compare it to the value of the hash in the database.
  prefs: []
  type: TYPE_NORMAL
- en: Fortunately, this is easy to do with Phalcon. The security component is automatically
    loaded in the Phalcon services' container. So, open up the `UsersController.php`
    file and find the `createAction` function; then, find the line where the password
    is set.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, simply replace it with the following two lines of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Now, when we create a user, the password will be hashed and saved to the database.
    We also want to save the password again as a hash if we edit. So, we find the
    same line of code in the `saveAction` function and replace it with the previous
    two lines of code to hash the password.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, all we need to do is edit our `loginAction` function. Our initial function
    was kind of clunky. So, we are going to replace it with something a little more
    streamlined. The new `loginAction` function will look like the following code
    snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Instead of searching for the user in the database, we try to instantiate the
    user using the `findFirstByFieldname` function, where `Fieldname` can be replaced
    with the column in the database we are querying. If we do find a user by searching
    for the username, we use security services' `checkHash` function to compare the
    hash in the database with the hash we just generated off of the entered password.
    If there is a match, we go through the process of setting the `user_id` variable
    in the session and creating a welcome message.
  prefs: []
  type: TYPE_NORMAL
- en: The Phalcon security component uses the bcrypt hash algorithm, which gives us
    a high level of security. This component is loaded in Phalcon by default, but
    it can also be configured manually to tweak the "slowness" of the bcrypt algorithm.
    You can learn more about this component at [http://docs.phalconphp.com/en/latest/reference/security.html](http://docs.phalconphp.com/en/latest/reference/security.html).
  prefs: []
  type: TYPE_NORMAL
- en: Using Phalcon view helpers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We can also add some security by changing the password fields on the forms
    to true password fields. So, find the following files in the `users` folder located
    at `app/views`:'
  prefs: []
  type: TYPE_NORMAL
- en: '`new.volt`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`index.volt`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`edit.volt`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'And find the following line of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Replace the preceding code with the following line of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Now, passwords will be masked when they are entered in the field.
  prefs: []
  type: TYPE_NORMAL
- en: As we learned in [Chapter 3](ch03.html "Chapter 3. Using Phalcon Models, Views,
    and Controllers"), *Using Phalcon Models, Views, and Controllers*, the Volt template
    engine is a very thin wrapper that is wrapped around PHP code, which Phalcon compiles
    to the actual PHP code. To call a Phalcon tag helper in Volt, we just use the
    uncamelized version of the function.
  prefs: []
  type: TYPE_NORMAL
- en: Using dynamic title tags
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s replace some of the HTML markup we wrote with some view helpers. A powerful
    view helper is the one for the document title. Right now, we have a hardcoded
    `title` tag in our main layout which gives the same title to every page. So, open
    up the `index.volt` file located at `app/views` and find the following line of
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Replace the preceding code with the following line of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, the only problem is that our page has no title because we haven''t set
    it yet. It would probably be a good idea to keep the title of our blog on every
    page. We could hardcode that or open up the `ControllerBase.php` file located
    at `app/controllers` and add the following function to the `ControllerBase` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we have our global title back again. But we want each blog post to have
    the title of the post in the title also. So, if we have a blog post called Hello
    World, we want our title to be Hello World: Phalcon Blog. It''s easy to do this.
    Open up the `PostController.php` file located at `app/controllers` and add the
    following line of code to the end of the `showAction` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: The title of a blog post is displayed before the blog title if you visit a blog
    post page. Now, if you want, you can add your own title to each action in each
    controller.
  prefs: []
  type: TYPE_NORMAL
- en: Setting the doctype
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'By setting the document type with Phalcon, you affect all the tags that it
    generates with tag helpers, so they conform to your chosen standard. We are going
    to use HTML5\. Add the following line of code to the `initialize` function in
    the `ControllerBase.php` file located at `app/controllers`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, the document type will be set globally in each controller. Find the following
    line of code at the top of the `index.html` file located at `app/views`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'And replace the preceding code with the following line of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Now, you can be sure that Phalcon will output tags that follow whatever standard
    you choose. To learn about the other document standards, you can visit [http://docs.phalconphp.com/en/latest/reference/tags.html#document-type-of-content](http://docs.phalconphp.com/en/latest/reference/tags.html#document-type-of-content).
  prefs: []
  type: TYPE_NORMAL
- en: Adding JavaScript and CSS with view helpers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We originally just hardcoded the CSS and JavaScript links in the head of our
    main layout file. This works for now, but if we move our project, we may have
    to change these links. Phalcon has script and CSS tag helpers that will make our
    job a little easier. We can replace the CSS links in the head of the `index.phtml`
    file located at `app/views` with the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'We put the JavaScript links at the bottom of the file with the following lines
    of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: We will explore more view helpers as we read through this chapter. To learn
    more about Phalcon tag helpers, visit [http://docs.phalconphp.com/en/latest/api/Phalcon_Tag.html](http://docs.phalconphp.com/en/latest/api/Phalcon_Tag.html).
  prefs: []
  type: TYPE_NORMAL
- en: Setting cookies
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now we can log in and have secure passwords, but every time the browser is closed,
    we have to log in again. It would be nice to be able to log in to our blog and
    stay logged in for a few days at least. It is time to set a cookie.
  prefs: []
  type: TYPE_NORMAL
- en: 'We are going to change the way we do this as we go through this chapter, but
    for now, it is very easy to set a cookie that will keep us logged in with very
    little code. First, we need to set up an encryption key because we will want to
    decrypt a cookie before setting it and decrypt it while retrieving it. We want
    to keep it that way, but in order to do this, we need to give it a key. So, go
    to [http://randomkeygen.com/](http://randomkeygen.com/) to generate a random string
    of digits. Then, open up the `config.ini` file located at `app/config` and add
    your key in the application section and call it `encryptKey`, shown as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, open up the `services.php` file located at `app/config` and add the following
    code snippet to the bottom of the file in order to set the encryption key:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, our cookies are ready to go. They were available earlier, but had we used
    them, they would have thrown an error about requiring an encryption key. Now,
    find the `loginAction` function in the `UsersController.php` file located at `app/controllers`
    and add the following line of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Add it right after you set the `user_id` variable in the session:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, open up the `PostsController.php` file located at `app/controllers` and
    find the part of the `createAction` function where we check the `user_id` variable
    in the session. Now, we are going to check for cookies first and then set the
    `user_id` variable in the session if we find a `user_id` cookie:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: And that's about all that we have to do to retrofit our code to add cookies.
    To learn more about cookie management with Phalcon, see [http://docs.phalconphp.com/en/latest/reference/cookies.html](http://docs.phalconphp.com/en/latest/reference/cookies.html).
  prefs: []
  type: TYPE_NORMAL
- en: Now, we should be able to log out and log in again, close the browser, and still
    be logged in. However, this is not really all that we want when it comes to controlling
    users. We want to be able to seamlessly control everything they access. Currently,
    our application has holes, and to plug them, we need to copy and paste code to
    implement the same `user_id` variable check everywhere we need it's functionality.
    Fortunately, we won't have to do this. Phalcon provides a service that helps us
    control user access.
  prefs: []
  type: TYPE_NORMAL
- en: Controlling user access
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'An **access control list** (**ACL**) uses roles to control access to resources.
    `Phalcon\Acl` provides this functionality for us. With it, we can assign roles
    to the different types of visitors on our blog, and then use these roles to set
    up permissions on each action in each of our controllers. For our purposes, we
    are only going to create two roles, users and guests. A user will simply be a
    visitor that is logged in, a guest, or anyone else. We are only going to give
    guest access to perform the following actions:'
  prefs: []
  type: TYPE_NORMAL
- en: 'View the index page:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: View the posts' index page
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Comment on a post
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: View the users' index, which will be a login page, when a visitor is not logged
    in
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Log in
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A logged in user can do everything. To put `Phalcon\Acl` to use in our application,
    we are going to create a simple Phalcon plugin. Phalcon Developer Tools already
    added our `plugins` folder and created the `pluginsDir` setting in the `config.ini`
    file. However, we still need to add the `plugins` directory to our loader. Open
    the `loader.php` file located at `app/config` and add the `plugins` directory
    to your loader.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'What we want to create is a plugin that will hook into Phalcon''s event manager.
    Using the event manager, we can attach listeners to various Phalcon events. Create
    a new file called `Security.php` in the `app/plugins` folder and add the following
    code snippet at the top of the file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: We extend `Phalcon\Plugin`. Our constructor must accept a dependency injector
    instance. Then, we need to create a function that will add our ACL to our persistent
    variables. We will call it `getAcl`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: First, the code checks if we already have an ACL instance. If not, we create
    one. We then set the `DefaultAction` function to deny access for security reasons.
    The next bit of code creates the roles, that is, users and guests, in our ACL.
    We then load all of the resources we want to be private into a variable and then
    add them all as resources. We will do the same for the resources that we want
    to be public. Then, we loop through the roles, giving both the roles access to
    the public resources. Then, we loop through the private resources and give access
    to users but not to guests. Finally, we set our new ACL to be persistent and return
    it.
  prefs: []
  type: TYPE_NORMAL
- en: 'This function just builds the structure of our ACL. We still need to actually
    control the access, and we will do that with a function that will fire before
    dispatch. Add the following function at the bottom of the file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: This function accepts an event instance and a dispatcher instance. We check
    if the visitor is logged in and set their role. Then, we set a variable to our
    controller name and one to the action name. We call our `getAcl` function to get
    our ACL, and we also call `$acl->isAllowed()`, passing the role of the visitor
    and the names of our controller and action. This will return true if the role
    is allowed access to the current resource. If the user is not allowed access,
    we set an error message and forward them to the index of our blog.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we need to hook into the standard dispatcher, attach this new `Security`
    plugin to our events manager, and set this as the event manager for our dispatcher.
    Open the `services.php` file located at `app/config` and add the following code
    snippet to the bottom of the file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: To learn more about using `Phalcon\Acl`, visit [http://docs.phalconphp.com/en/latest/reference/acl.html](http://docs.phalconphp.com/en/latest/reference/acl.html).
    And to learn more about Phalcon's event manager, visit [http://docs.phalconphp.com/en/latest/reference/events.html](http://docs.phalconphp.com/en/latest/reference/events.html).
  prefs: []
  type: TYPE_NORMAL
- en: Applying the finishing touches to our application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Phalcon Developer Tools can help out a lot, but let's face it, most of the code
    you are going to write for your application is from scratch. Our blog still doesn't
    have comments or a feed, so it is really not much of a blog. Adding these is going
    to be a manual job, but Phalcon makes it easy.
  prefs: []
  type: TYPE_NORMAL
- en: Adding comments
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now, let's give visitors the ability to comment on our posts. Earlier, we needed
    a user-access control so that we could limit moderating comments to logged-in
    users. But now, we need a place to do it. We are going to build a very simple
    comment-moderation system. We could use Phalcon Developer Tools or Phalcon web
    tools to generate our CRUD scaffolding for us, but in this case, we would almost
    be taking out more of the generated code than we'd be leaving in, but we can use
    the other controllers and views we generated as a guide.
  prefs: []
  type: TYPE_NORMAL
- en: For comments, we need to add a form to comment on the posts showing an action
    view, and we also need to display comments that have been published under each
    post. We also need a place to list all comments, and a form to edit them and set
    them to be published.
  prefs: []
  type: TYPE_NORMAL
- en: 'Comments are already related to posts. We just need to modify a few things
    to make this relationship functional. Open the `show.volt` file located at `app/views/posts`.
    At the bottom of the file, add the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Right below the post, we loop through the comments that are related to that
    post, and if we set them to publish, we print the comment. Below that, we have
    the comment form, making sure that we have a hidden field that picks up the ID
    of the post. We make this form post to posts/comment, which means that we now
    need a `commentAction` function in our `Posts` controller. Open the `PostsController.php`
    file located at `app/controllers` and add the following function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: It's pretty simple. We create an instance of the `Comments` object from the
    `POST` variable, set the submitted date, and set the publish value to 0, which
    will represent false in our database. Then, we set a success message and forward
    the user back to the `Posts` show action, setting the ID to the ID of the post
    that was just commented on.
  prefs: []
  type: TYPE_NORMAL
- en: Now, we need a way to moderate our comments. First, we need a `Comments` controller.
    So, create a `CommentsController.php` file at `app/controllers` and make sure
    to include `Paginator`, because we will be using it.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Then, we need our `CommentsController` class.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: And inside the `CommentsController` class, we need actions for indexing, editing,
    saving, and deleting. Our `indexAction` function returns a paginated result of
    all comments.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Our `editAction` function prepares a single comment for use in the edit form,
    when we are moderating a comment, by setting it to be published.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: The `saveAction` function saves an edited comment after we moderate it.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: The `deleteAction` function gets rid of our comment spam.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we just need views. First, we need the view for our `indexAction` function.
    So, create a file called `index.volt` in the `comments` folder located at `app/views`
    and insert the following code snippet in it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, the view that will be used when we edit our posts. Save the following
    code snippet as `edit.volt` at `app/views/comments`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: Now, we can comment on posts and moderate them if we are logged in as a user.
  prefs: []
  type: TYPE_NORMAL
- en: Adding feeds
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A blog is not really a blog without a way to syndicate our posts. Fortunately,
    it is going to be pretty simple to add a feed to our blog. Let''s put our feed
    at `http://localhost/phalconBlog/posts/feed`. This means that we need a new `feedAction`
    function in our posts controller. So, open the `PostsController.php` file located
    at `app/controllers` and add the following function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we retrieve only 10 posts ordered by the published date in descending
    order using `Posts::find`. As the date format in an RSS feed is very specific
    and doesn''t match the MySQL datetime format, we loop through our records, converting
    the published date and adding this date to each `post` object. We then send the
    array of objects to the view. At the end of the function, we set the render level
    of the view. In this case, we don''t want our main layout or post layout to render.
    We only want the specialized template that we are about to create to render, so
    we set our level to `LEVEL_ACTION_VIEW`. The following six levels are available:'
  prefs: []
  type: TYPE_NORMAL
- en: '`LEVEL_NO_RENDER`: This does not render any view'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`LEVEL_ACTION_VIEW`: This renders the view associated with the action'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`LEVEL_BEFORE_TEMPLATE`: This generates the views before the controller''s
    layout'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`LEVEL_LAYOUT`: This generates the controller''s layout'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`LEVEL_AFTER_TEMPLATE`: This generates the views after the controller is laid
    out'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`LEVEL_MAIN_LAYOUT`: This generates the main layout'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Create a new file in the `posts` folder at `app/views`, call it `feed.volt`,
    and insert the following code snippet inside the `feed.volt` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: We wrap the XML tag at the top of the Volt template tag to hide `<?` from the
    Volt template engine. We add some necessary RSS elements including a title, description,
    and a link for our blog. Note that since we loaded our configuration into the
    DI container, we have access to the settings we created there for our blog's title
    and URL. The next step is to loop through the posts. This part is similar to the
    code in the `index.volt` file. But you may notice `|e` behind the title and the
    excerpt of the post. This is the Phalcon HTML escaping filter being called from
    Volt so that our feed will remain valid with any characters that may be in our
    content. We are generating XML and using the `rss_date` attribute that we created
    in our `feedAction` function.
  prefs: []
  type: TYPE_NORMAL
- en: 'The last step we need to do is add the link for RSS autodiscovery to the head
    of our pages. So, open the `index.volt` file located at `app/views` and add the
    following code snippet between the head tags:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: Here, we use the generic `tagHtml()` tag helper to generate the link for us,
    which becomes `tag_html()` in Volt. The first parameter is the name of the tag.
    The second parameter is an array of the tag's attributes. Note that the `href`
    parameter uses the `baseUri` configuration setting and `~`, which is a character
    used in Volt to concatenate strings together. The third parameter is a Boolean
    we set to true because we want this to be a self-closing tag. We set the fourth
    parameter to true because we only want to generate the start tag. Finally, we
    set the fifth parameter to true because we want an end-of-line character generated
    after the tag.
  prefs: []
  type: TYPE_NORMAL
- en: Now, we can start telling the rest of the Internet about our new blog.
  prefs: []
  type: TYPE_NORMAL
- en: Sending update pings
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In order to ping sites such as [http://weblogs.com](http://weblogs.com) and
    notify them that we have a new post, we are going to do a little more refactoring.
    It seems we used the title of our blog in the HTML title tag. We have to use it
    again in the function that we''ll write to ping. So, instead of hardcoding the
    title in two places that have to be edited, if we change the title, it would be
    better to create a configuration setting. So, add the following code snippet to
    the `config.ini` file located at `app/config`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'As we are now going to use this setting in a controller, we need to have access
    to it there. To do this, we can add it to the Dependency Injection container.
    This can be done by adding these lines of code to the bottom of the `services.php`
    file located at `app/config`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: Now, we can open the `ControllerBase.php` file located at `app/controllers`
    and set our title tag with our configuration setting.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: We can create a new function in our `PostsController.php` file to ping the feed
    aggregator sites for us.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: The `$request` variable is the XML we are going to post to the services. Now
    that we've added the configuration settings to our Dependency Injection container,
    we can access the blog's title setting with `$this->config->blog->title` and the
    URL setting with `$this->config->blog->url`. The `$ping_urls` array contains the
    URLs of services we are going to ping. You can add more services to this array
    if you like. Then, we use PHP `curl` to ping.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, in the `createAction` function, find the following line of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'Add the following line of code before the preceding code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: Another feature we could add to this function is a way of logging the results
    of our pings, so we then have a way of debugging what is actually happening as
    our function doesn't return a status.
  prefs: []
  type: TYPE_NORMAL
- en: Now, it's time to add another variable to the application section of the configuration
    file.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we need to add a service to log the results of our pings in the Dependency
    Injection container. Open up the `services.php` file located at `app/config` and
    add the following lines of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: This will enable us to access our `pingLogger` service in the `sendPings` function
    we just created. So, after we set the `$result` variable, we can then log the
    URL we pinged along with the response we received. We check if the result is false,
    indicating that `curl` failed, and then change the `$result` variable to reflect
    that error.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: Using view partials
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have explored layouts and cascading views. We also have the option to use
    partials in Phalcon. Using partial templates allows us to reuse the same functionality
    in various parts of our application. A couple of places in which we may want to
    use partials are the navigation bar and the sidebar. Right now, our main layout
    does a lot of stuff. There is not much on the navigation bar or the sidebar. But
    as we add more functionalities, they might become more complex, and keeping them
    in separate files will help us to organize and simplify our code.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can create a folder to hold your partial views wherever you choose. You
    can even put them in your `views` folder located at `app` if you choose. But,
    to keep our templates more organized, let''s create a folder called `partials`
    inside of the `views` folder located at `app`. Now, open the `index.volt` file
    located at `app/views`. We are going to cut the sidebar out of this file and paste
    it in a new file called `sidebar.volt`, which we are going to save in our new
    `partials` folder. The content of that file should look like the following code
    snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'We will replace this in the `index.volt` file with the following line of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: This is the code we would use with Volt. If we were using PHP templates, we
    would use `<?php $this->partial("partials/sidebar"); ?>`. Note that we don't add
    the file extension to the `path` parameter. Make sure to do this with your `partials`
    folder. Adding the extension will cause an error.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, you can cut the `div` tag with the `navbar` class in the `index.phtml`
    file located at `app/views`, paste it into a file called `navbar.volt`, save it
    in your `partials` folder, and replace the `div` tag with the following line of
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: Now, the different types of functionalities are separated in your application.
    You may find other places in your application where you may want to use partials,
    such as in the header or the footer. To learn more about Phalcon, visit [http://docs.phalconphp.com/en/latest/index.html](http://docs.phalconphp.com/en/latest/index.html).
  prefs: []
  type: TYPE_NORMAL
- en: Caching in Phalcon
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Caching can speed up and save resources on a site that gets a lot of traffic
    or does a lot of intense repeatable database queries, but this should only be
    implemented where actually needed. In other words, our blog, in its current iteration,
    probably doesn't need a cache, but we are going to take a look at caching in Phalcon
    and add caching to a part of our blog just to get a handle on how it works.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up a cache service
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In Phalcon, the cache consists of two parts, a frontend cache that handles cache
    expiration and transformation, and the backend cache that handles the reads and
    writes when requested to by the frontend. Here is an example of a cache service.
    We could simply add this to our `service.php` file located at `app/config`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: We are pretty used to setting up new Phalcon services by now. In this new service,
    we use the configuration variable so that it can use our cache directory setting.
    We give the frontend cache a lifetime of one day and feed this variable to our
    backend cache along with the location of our cache directory.
  prefs: []
  type: TYPE_NORMAL
- en: 'We used a file-based cache in this service. It is not the fastest of caching
    mechanisms and is probably the slowest, but it is easy to set up and requires
    no other software. However, you are not limited to file-based backends with Phalcon.
    As long as you have the required software and PHP extensions installed, you can
    use any one of the following as a backend cache in Phalcon:'
  prefs: []
  type: TYPE_NORMAL
- en: File
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Memcached
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: APC
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: MongoDB
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Xcache
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Phalcon has a variety of frontend cache adapters too. In the code for our cache
    service, we specified a data adapter that serializes our data before saving it,
    but you can also use one of the following frontend adapters:'
  prefs: []
  type: TYPE_NORMAL
- en: Output
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: JSON
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: IgBinary
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Base64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: None
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using a Phalcon cache
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now that we have our cache service set up, we can use it wherever we need it.
    First, you need a cache key. All Phalcon caches use a key to store and access
    cached data. It needs to be unique to that piece of data. A good place for a function
    to generate keys for the cache in our application would be in the `ControllerBase.php`
    file located at `app/controllers`. We can add the following function to the `ControllerBase`
    class so that all of our controllers inherit it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'This function will simply create a unique key for us. So, now we test the function
    using our cache by opening up the `PostController.php` file located at `app/controllers`
    and modifying the `showAction` function. We can access the cache service we created
    by adding the following line of code at the beginning of the function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, by executing the following line of code, you can access the cached content
    or start the cache:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: Then, we check if we have content, and if we don't, we get it from the database
    and save it in the cache using our key.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: The rest of the function remains the same.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: Open up one of your blog's posts in the browser and refresh the page. You will
    find the cache file in the `cache` folder located at `app`. Inside the file, serialized
    data will be present, representing the `$post` object. To learn more about using
    caching in Phalcon, visit [http://docs.phalconphp.com/en/latest/reference/cache.html](http://docs.phalconphp.com/en/latest/reference/cache.html).
  prefs: []
  type: TYPE_NORMAL
- en: You can also cache data at the model level. The mechanism is the same. Try to
    access the cached data by a key. Check if there is data. If not, execute the database
    call to retrieve the data and cache it. Then, return the result. To learn about
    caching in the ORM, visit [http://docs.phalconphp.com/en/latest/reference/models-cache.html](http://docs.phalconphp.com/en/latest/reference/models-cache.html).
  prefs: []
  type: TYPE_NORMAL
- en: Routing in Phalcon
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Before we take a look at other application structures in Phalcon, especially
    the micro application, we should take a look at routing. Up to now, we just have
    the routes in our application; just magically map to our controllers and the actions
    in them and let Phalcon do all of the thinking about routing for us. This is because
    with the single MVC structure that we are using, the routing is in MVC mode. We
    also have the option of match-only mode. You will notice that our blog application
    has an index page that does nothing. It still has the default Phalcon message.
    The bulk of our site currently resides at `http://localhost/phalconBlog/posts`.
    Well, a hacky way to fix this that we are going to use to learn about routing
    in Phalcon is to use a router. So, we need to add another service to our Dependency
    Injection container. Open up the `services.php` file located at `app/config` and
    add the following lines of code at the bottom:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: When we add a route to the MVC router, the first parameter is the path and the
    second is any array that maps this path to a module, controller, and an action.
  prefs: []
  type: TYPE_NORMAL
- en: Match-only mode routing is used in the micro application example coming up.
    To learn more about routing in Phalcon, visit [http://docs.phalconphp.com/en/latest/reference/routing.html](http://docs.phalconphp.com/en/latest/reference/routing.html).
  prefs: []
  type: TYPE_NORMAL
- en: Other project types of Phalcon
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We created one type of application in Phalcon, a single MVC application. But,
    the type of application structure does not fit all types of projects. We will
    now take a look at a few other types of applications you can build with Phalcon.
    Of course, Phalcon being a very loosely-coupled framework, you are not limited
    by just these structures, and you can structure your projects however you choose.
  prefs: []
  type: TYPE_NORMAL
- en: Multimodule applications
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As an application grows in size, it may be easy to organize the code into modules.
    Instead of an `app` folder in a project, you have multiple folders under an `apps`
    folder, each having their own sets of models, views, and controllers. Routing
    in MVC mode is already set up to handle modules. There are only a few extra steps
    involved. To learn more about Phalcon multimodule applications, visit [http://docs.phalconphp.com/en/latest/reference/applications.html#multi-module](http://docs.phalconphp.com/en/latest/reference/applications.html#multi-module).
  prefs: []
  type: TYPE_NORMAL
- en: Micro applications
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'For even simpler applications than the one we wrote, using a micro framework
    structure may make more sense. A micro application in Phalcon can be as simple
    as the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: There is not much to this application. First, we create an instance of `Phalcon\MVC\Micro`
    and then we defined our routes. So, when a visitor visits the `/user/Stephan`
    page of the application, they are greeted with **Hi Stephan**. The second route
    shows one of the perfect uses of a micro application for an API. Most simple APIs
    don't need complex controllers. This example is here to show you how small a working
    Phalcon application can be. It uses routing in the match-only mode. As a micro
    application grows in size, you can use more of the features it supports, including
    models, redirects, and services. To learn more about Phalcon micro applications,
    visit [http://docs.phalconphp.com/en/latest/reference/micro.html](http://docs.phalconphp.com/en/latest/reference/micro.html).
  prefs: []
  type: TYPE_NORMAL
- en: Command-line applications
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Sometimes, you may not need a complete web application to get the job done.
    For scripts that you run from a command line or cron, you just need a simple structure
    to organize the functionality of your code. A Phalcon command-line application''s
    structure can start as small as the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: The bootstrap file is `cli.php`, and it starts out in pretty much the same manner
    that all command-line applications start in Phalcon.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: All that bootstrap file has to do is process commands and choose the right task
    and action. We are storing our tasks in the `tasks` folder. A command-line application
    must have at least a `mainTask` and `mainAction`. So, we can add this file to
    the `tasks` folder and name it `MainTask.php`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'The `mainAction` function of the main task will be run while executing the
    following command line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'To call a specific task and action, just assign the task as the first parameter,
    the action as the second, and any of the parameters (`tom`, `dick`, and `harry`)
    can be handled by the action function called `Executing`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: To learn more about creating command-line applications with Phalcon, visit [http://docs.phalconphp.com/en/latest/reference/cli.html](http://docs.phalconphp.com/en/latest/reference/cli.html).
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we learned more about what we can do with the Phalcon framework
    while adding features to our blog application. It is not the most feature-packed
    blog, but we showed how to use Phalcon tag helpers to set our document type and
    generate dynamic titles for our pages. We also explained how to control user access,
    hash passwords, and set cookies in Phalcon. Then, we broke up our views into reusable
    bit-sized pieces using view partials. Just in case our blog ever gets any traffic,
    we dabbled a bit with caching in Phalcon. We also learned how to use routing in
    Phalcon. Finally, we learned other structures we can use for a Phalcon application.
    To learn more about Phalcon, visit [http://phalconphp.com](http://phalconphp.com).
  prefs: []
  type: TYPE_NORMAL
