- en: '4'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Extending Drupal with Custom Code
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The greatest component of Drupal is its extensibility through modules. In this
    chapter, we will explore how to create a custom module that can be installed on
    your Drupal site. This chapter will explain how PSR-4 autoloading works with extensions
    and how to leverage class autoloading. You will be able to create a controller
    for a custom page and specify additional permissions to check whether the user
    has them. You will also understand what hooks and events in Drupal are, and how
    to interact with them. This chapter also lays the foundations for the following
    chapters.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following recipes will be covered in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Creating a module
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Providing configuration settings for your module
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Defining permissions and checking whether a user has access
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Hooking into Drupal to react to entity changes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating an event subscriber to react to events
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a custom Drush command
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You can find the full code used in this chapter on GitHub: [https://github.com/PacktPublishing/Drupal-10-Development-Cookbook/tree/main/chp04](https://github.com/PacktPublishing/Drupal-10-Development-Cookbook/tree/main/chp04)'
  prefs: []
  type: TYPE_NORMAL
- en: Creating a module
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The first step to extending Drupal is to create a custom module. Although the
    task sounds daunting, it can be accomplished in a few simple steps. Modules can
    provide functionalities and customizations for functionalities provided by other
    modules, or they can be used as a way to contain the configuration and a site’s
    state.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we will create a module by defining its `modulename.info.yml`
    file, a file containing information that Drupal uses to discover extensions and
    install the module.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In your `web/modules` directory, create a new directory called `custom` and
    then another directory named `mymodule` inside it. This will be your module’s
    directory. Using the command line, you may create the directory with the following
    command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This will create the required directories.
  prefs: []
  type: TYPE_NORMAL
- en: Create a `mymodule.info.yml` file in your module’s directory. This will contain
    the metadata that identifies the module to Drupal.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add a line to the `mymodule.info.yml` file to provide a name for the module
    with the `name` key:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We must define the type of extension with the key type. Drupal does not assume
    the extension type just by directory location alone:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The `description` key allows you to provide extra information about your module,
    which will be displayed on the module’s list page:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Extensions are required to provide a `core_version_requirement` that identifies
    what versions of Drupal core the module is compatible with, using a semantic versioning
    constraint:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Save the `mymodule.info.yml` file, which looks as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Next, create a file named `mymodule.module` in your `module` file. This is the
    extension file that will allow us to add hook definitions. It is a regular PHP
    file, but the file extension matches its extension type of module.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'For this example, we will provide a hook that renders a message on each payload:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This implements `hook_page_top`, which is called whenever a page is rendered.
    It uses the messenger service to add a status message to the page.
  prefs: []
  type: TYPE_NORMAL
- en: 'Install your module using Drush:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Visit your Drupal site. The `Hello world!` message will be added to each page:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 4.1 – Drupal page displaying Hello world!](img/Figure_4.01_B18548.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.1 – Drupal page displaying Hello world!
  prefs: []
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Drupal utilizes `info.yml` files to define extensions. Drupal has an extension
    discovery system that locates these files and parses them to discover modules.
    The extension discovery will scan your entire Drupal code base, giving the Drupal
    core directory priority.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we provided `>=10` for the `core_version_requirement` constraint.
    This constraint allows your module to work with a minimum of Drupal 10.0.0 but
    also be compatible with Drupal 11 or greater, simplifying maintenance when the
    next major version of Drupal core is released. If you know your code is not compatible
    with a previous minor version, it could be updated to `>=10.1.0` or even a specific
    patch value of `>=10.2.1`.
  prefs: []
  type: TYPE_NORMAL
- en: One method to integrate with Drupal is through its hook system. During runtime,
    other modules may invoke a hook that other modules can implement to perform actions
    or modify data. Our recipe implemented the `hook_page_top` hook. This hook is
    part of the page rendering life cycle and allows you to add renderable content
    at the very top of the page.
  prefs: []
  type: TYPE_NORMAL
- en: Module namespaces
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Drupal uses the PSR-4 standard developed by the **PHP Framework Interoperability
    Group** (**PHP-FIG**). The PSR-4 standard is for package-based PHP namespace autoloading
    of classes and is used by most libraries and frameworks, including Laravel and
    Symfony. It defines a standard to understand how to automatically include classes
    based on a namespace and class name. Drupal modules have their own namespaces
    under the Drupal root namespace.
  prefs: []
  type: TYPE_NORMAL
- en: Using the module from the recipe, our PHP namespace will be `Drupal\mymodule`,
    which represents the `web/modules/mymodule/src` folder.
  prefs: []
  type: TYPE_NORMAL
- en: With PSR-4, files need to contain only one class, interface, or trait. These
    files need to have the same filename as the containing class, interface, or trait
    name. This allows a class loader to resolve a namespace as a directory path and
    know the class’s filename. The file can then be automatically loaded when it is
    used in a file.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a composer.json file
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If you are writing a custom module that will only be used on your site, this
    is not necessary. However, if you plan to contribute your code to Drupal.org and
    distribute it, you should provide a `composer.json` file.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: 'Projects on Drupal.org are not required to create a `composer.json` file. If
    a project does not, one will be automatically generated for it based on the contents
    of its `info.yml` file. That is why it is recommended to create one: to be explicit.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a `composer.json` file in your module directory. It will look similar
    to the `mymodule.info.yml` file but as JSON:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: The `name` key should be prefixed with `drupal/` to identify it is in the Drupal
    package namespace. The type is prefixed with `drupal-` for compatibility with
    the Composer Installers package, which we covered in [*Chapter 1*](B18548_01.xhtml#_idTextAnchor020),
    *Up and Running* *with Drupal*.
  prefs: []
  type: TYPE_NORMAL
- en: '`core_version_requirement` is converted into Composer’s dependency definition
    and targets the `drupal/core` package.'
  prefs: []
  type: TYPE_NORMAL
- en: There’s more…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There are more details about Drupal modules and the module `info.yml` files
    that we can explore.
  prefs: []
  type: TYPE_NORMAL
- en: Module dependencies
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Modules can define dependencies to ensure that those modules are installed before
    your module can be installed.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is an example from the `info.yml` file for the `Pathauto` module:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: The `dependencies` key specifies that the `ctools` path from Drupal core and
    `token` module must be installed first before the `Pathauto` module can be installed.
    In the *Adding and managing modules and themes with Composer* recipe from [*Chapter
    1*](B18548_01.xhtml#_idTextAnchor020), *Up and Running with Drupal*, they were
    automatically installed when we installed the `Pathauto` module.
  prefs: []
  type: TYPE_NORMAL
- en: Drupal has always supported modules that contain additional submodules, an uncommon
    practice in other systems. As Drupal adopted Composer, it enforced namespaced
    dependencies in the `info.yml` file. This identifies the root package and the
    specific module it contains to be installed.
  prefs: []
  type: TYPE_NORMAL
- en: If your module has dependencies and you plan to contribute it, remember to create
    a `composer.json` file and define your dependencies so that they will be downloaded
    with Composer.
  prefs: []
  type: TYPE_NORMAL
- en: See more…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Refer to the *PSR-4: Autoloading* *specification*: [https://www.php-fig.org/psr/psr-4/](https://www.php-fig.org/psr/psr-4/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Changing a record by adding `core_version_requirement` and the reasonings behind
    its addition: [https://www.drupal.org/node/3070687](https://www.drupal.org/node/3070687)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Drupal.org](http://Drupal.org) documentation for creating a module: [https://www.drupal.org/docs/creating-custom-modules](https://www.drupal.org/docs/creating-custom-modules)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Providing configuration settings for your module
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Modules can leverage configuration settings to allow end users to modify how
    they operate. These pieces of configuration are YAML files. Modules can also provide
    default configuration for other modules when they are installed. Once the module
    has been installed, the default configuration it provides is imported into Drupal.
    Modules may also modify existing configurations programmatically through an installation
    hook or update hooks.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we will provide a configuration that creates a new contact form
    and then manipulates it through an update hook.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This recipe requires a custom module, like the one created in the first recipe.
    We will refer to the module as `mymodule` throughout this recipe. Use your module’s
    appropriate name where necessary.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Create a `config` folder in your module’s directory. Then, in that directory,
    create an `install` directory. Drupal looks for YAML configuration in this installation
    directory:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In the `install` directory, create a `contact.form.contactus.yml` file to store
    the YAML definition of the contact form, `Contact Us`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the following YAML content to the `contact.form.contactus.yml` file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE23]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE24]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE25]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE26]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE27]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE28]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE29]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE30]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This YAML file represents the exported configuration object for a contact form.
    `id` is the contact form’s machine name and `label` is the human display name
    for the user interface. The `recipients` key is a YAML array of valid email addresses.
    The `reply` key is a string of text for the `Auto-reply` message. Finally, `weight`
    defines the ordering of the form on the administrative list.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Normally, you do not manually write configuration YAML like this. You will generally
    export it individually from the Drupal site if needed.
  prefs: []
  type: TYPE_NORMAL
- en: 'Install the module using Drush:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The **Contact Us** form will now be located on the **Contact forms** overview
    page, located under **Structure**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a `mymodule.post_update.php` file in the module’s directory. This file
    contains update hooks to be run after schema changes.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We will create a function called `mymodule_post_update_change_contactus_reply()`
    that will be executed by the update system to modify the contact form’s configuration:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE33]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE34]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE35]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE36]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE37]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE38]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE39]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE40]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE41]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE42]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE43]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This function uses the entity’s class to load the contact form entity object.
    It loads the **Contact Us** contact form, which our module has provided, and sets
    the reply property to its new value.
  prefs: []
  type: TYPE_NORMAL
- en: 'Run updates for the Drupal site using Drush:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Drush will list the updates to be applied, including the one you just wrote.
    The function comment of an `update` function will be output in the list of updates
    to be applied. After reviewing the changes, you can tell Drush to proceed by entering
    `yes` on the command line.
  prefs: []
  type: TYPE_NORMAL
- en: Review the **Contact Us** form settings and verify that the reply message has
    been set.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Drupal’s `moduler_installer` service, provided through `\Drupal\Core\Extension\ModuleInstaller`,
    ensures that configuration items defined in the module’s `config` folder are processed
    on installation. When a module is installed, the `config.installer` service, provided
    through `\Drupal\Core\Config\ConfigInstaller`, is called to process the module’s
    default configuration.
  prefs: []
  type: TYPE_NORMAL
- en: If the `config.installer` service attempts to import configuration from a module’s
    `config/install` folder that already exists, an exception will be thrown. Modules
    cannot provide duplicated configuration or modify existing configuration objects
    via the YAML files.
  prefs: []
  type: TYPE_NORMAL
- en: 'Since modules cannot adjust configuration objects through YAML files provided
    to Drupal, they can utilize the update system to modify the configuration. The
    update system has two update processes: schema updates and post updates. Since
    we did not make schema-level changes, we used the post-update process. This allows
    us to make modifications to existing configuration objects.'
  prefs: []
  type: TYPE_NORMAL
- en: In [*Chapter 7*](B18548_07.xhtml#_idTextAnchor240), *Creating Forms with the
    Form API*, we will create a form for modifying configuration settings.
  prefs: []
  type: TYPE_NORMAL
- en: There’s more…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We will now dive into some important notes when working with modules and configurations.
  prefs: []
  type: TYPE_NORMAL
- en: Configuration subdirectories
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'There are three directories that the configuration management system will inspect
    in a module’s `config` folder, which are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`install`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`optional`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`schema`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The `install` folder specifies the configuration that will be imported. If
    the configuration object exists, the installation will fail. The `optional` folder
    contains the configuration that will be installed if the following conditions
    are met:'
  prefs: []
  type: TYPE_NORMAL
- en: The configuration does not already exist
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It is a configuration entity
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Its dependencies can be met
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If any one of the conditions fails, the configuration will not be installed,
    but it will not halt the module’s installation process. The `schema` folder provides
    configuration object definitions.
  prefs: []
  type: TYPE_NORMAL
- en: Modifying the existing configuration on installation
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The configuration management system does not allow modules to provide configuration
    on an installation that already exists. For example, if a module tries to provide
    `system.site` and defines the site’s name, it would fail to install. This is because
    the `system` module provides this configuration object when you first install
    Drupal.
  prefs: []
  type: TYPE_NORMAL
- en: Modules may also have a `.install` file, such as `mymodule.install` for our
    recipe’s module. This file is where modules may implement the `hook_install` hook
    provided by Drupal, along with schema update hooks.
  prefs: []
  type: TYPE_NORMAL
- en: '`hook_install()` is executed during the module’s installation process. The
    following code will update the site’s title to `Drupal Development Cookbook`!
    on the module’s installation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: Configurable objects are immutable by default, meaning they cannot be changed
    or saved when loaded by the default `config` service. To modify a configuration
    object, you will need to use the configuration factory to receive an editable
    instance of a configuration object. This object can have `set` and `save` methods
    that are executed to update the configuration in a configuration object.
  prefs: []
  type: TYPE_NORMAL
- en: Schema update hooks
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This recipe mentioned schema update hooks. These are intended to be used to
    make changes to any database schema or entity field definitions. When the update
    system runs, the schema hooks are run first; then, post-updates are executed.
  prefs: []
  type: TYPE_NORMAL
- en: The schema update hooks are defined as `hook_update_N`, where `N` is a numeric
    schema version value. When schema update hooks are executed, they are run in order
    of their schema version. Generally, the base schema version is based on the major
    version of Drupal core or the module’s versioning. In custom code, it can be anything
    you wish.
  prefs: []
  type: TYPE_NORMAL
- en: 'The naming conventions for schema updates have been under discussion since
    Drupal 8 regarding the support of semantic versioning in contributed projects.
    These naming conventions are discussed in the following issues:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://www.drupal.org/project/drupal/issues/3106712](https://www.drupal.org/project/drupal/issues/3106712)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://www.drupal.org/project/drupal/issues/3010334](https://www.drupal.org/project/drupal/issues/3010334)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Update API documentation on Drupal.org: [https://www.drupal.org/docs/drupal-apis/update-api](https://www.drupal.org/docs/drupal-apis/update-api)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[*Chapter 7*](B18548_07.xhtml#_idTextAnchor240), *Creating Forms with the*
    *Form API*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Defining permissions and checking whether a user has access
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In Drupal, roles and permissions are used to define robust access control lists
    for users. Modules use permissions to check whether the current user has access
    to perform an action, view specific items, or do other operations. Modules then
    define the permissions that are used so that Drupal is aware of them. Developers
    can then construct roles, which are made up of enabled permissions.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we will define new permission(s) in a module that is used to
    check if the user can mark content as promoted to the front page or sticky at
    the top of lists. This permission will be used in an entity field access hook
    to deny access to the fields if the user is missing the permission.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Create a new module, as we did in the first recipe. We will refer to the module
    as `mymodule` throughout this recipe. Use your module’s name in the following
    recipe as appropriate.
  prefs: []
  type: TYPE_NORMAL
- en: Create a new Drupal user with the Content editor role. Drupal bypasses access
    checks for the first user. The secondary user will be required to demonstrate
    the permission.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Permissions are stored in a `permissions.yml` file. Add a `mymodule.permissions.yml`
    file to the base directory of your module.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'First, we will need to define the internal string used to identify this permission,
    such as `can` `promote nodes`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Each permission is a YAML array of data. We will need to provide a `title`
    key that will be displayed on the permissions page:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE48]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Permissions have a `description` key to provide details of the permission on
    the permissions page:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE50]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE51]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE52]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Save your `mymodule.permissions.yml` file and edit the module’s `mymodule.module`
    file so that we may write our hook to use the permission.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In your `mymodule.module` file, add a function named `mymodule_entity_field_access`
    to implement `hook_entity_field_access`. This is invoked to control access at
    a granular level per field on entity forms:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE54]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE55]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE56]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE57]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE58]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE59]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE60]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Drupal uses access result value objects to handle access results. Access results
    may be neutral, forbidden, or allowed. Hooks implementing `hook_entity_field_access`
    must return an access result and cannot return `null`.
  prefs: []
  type: TYPE_NORMAL
- en: 'In our hook, we will check the field name being checked. If the field name
    is `promote` or `sticky`, we will check whether the user has the `can promote
    nodes` permission and return that access result:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE62]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE63]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE64]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE65]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE66]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE67]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE68]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE69]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE70]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE71]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE72]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE73]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE74]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE75]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE76]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The access result object has an `allowedIf` method that returns an appropriate
    result based on the parameter provided. In this case, it will return `AccessResult::allowed()`
    if the user has the permission or `AccessResult::neutral()` if not.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Drupal’s access system requires explicit allowance. If an access result is neutral,
    the system will keep processing access results. If an access result is returned
    as forbidden or allowed, the access checks stop, and that result is used. If the
    ending result is neutral, access is not granted since it was not explicitly allowed.
  prefs: []
  type: TYPE_NORMAL
- en: 'New permissions are not granted to roles automatically. In another browser
    or guest tab, log in as a user with the Content editor role and create a piece
    of content. The **Promotion options** section of the sidebar will be missing since
    we do not have field access:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 4.2 – Promotion options are hidden due to missing permissions](img/Figure_4.02_B18548.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.2 – Promotion options are hidden due to missing permissions
  prefs: []
  type: TYPE_NORMAL
- en: 'As your administrative user, go to **People** and then to **Permissions** to
    add your permission for the Content editor role in the **My** **Module** section:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 4.3 – Adding the permission to the Content editor role](img/Figure_4.03_B18548.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.3 – Adding the permission to the Content editor role
  prefs: []
  type: TYPE_NORMAL
- en: 'Using your Content editor user, try and create a piece of content once more.
    The **Promotion options** section in the sidebar will be present:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 4.4 – The Promotion options section appears once the permission has
    been granted](img/Figure_4.04_B18548.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.4 – The Promotion options section appears once the permission has been
    granted
  prefs: []
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Permissions and roles are provided by the `User` module. The `user.permissions`
    service discovers the `permissions.yml` file provided by installed modules. By
    default, the service is defined through the `\``Drupal\user\PermissionHandler`
    class.
  prefs: []
  type: TYPE_NORMAL
- en: Drupal does not save a list of all available permissions. The permissions for
    a system are loaded when the permissions page is loaded. Roles contain an array
    of permissions.
  prefs: []
  type: TYPE_NORMAL
- en: When checking a user’s access for permission, Drupal checks all the user’s roles
    to see whether they support that permission.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: You can pass undefined permissions to a user access check and not receive an
    error. The access check will simply fail unless the user is UID 1, which bypasses
    access checks. In Drupal, user UID 1 is the root user and is not beholden to security
    checks or permissions. Be careful when granting access to that account or using
    user 1 in testing.
  prefs: []
  type: TYPE_NORMAL
- en: There’s more…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We will cover more ways to work with permissions in your modules in the upcoming
    sections.
  prefs: []
  type: TYPE_NORMAL
- en: Restricting access flag for permissions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Permissions can be flagged as having a security risk if enabled; this can be
    done via the restrict access flag. When this flag is set to `restrict access:
    TRUE`, it will add a warning to the permission’s description.'
  prefs: []
  type: TYPE_NORMAL
- en: 'This allows module developers to provide more context regarding the amount
    of control a permission may give a user:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.5 – Example of permissions with the restrict access flag](img/Figure_4.05_B18548.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.5 – Example of permissions with the restrict access flag
  prefs: []
  type: TYPE_NORMAL
- en: 'The permission definition from our recipe would look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: Defining permissions programmatically
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Permissions can be defined by a module programmatically or statically in a YAML
    file. A module needs to provide a `permission_callbacks` key in its `permissions.yml`
    file that contains either an array of callable methods or functions to define
    permissions dynamically.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, the `Filter` module provides granular permissions based on the
    different text filters created in Drupal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: This tells the `user_permissions` service to execute the permissions method
    of the `\Drupal\Filter\FilterPermissions` class. The method is expected to return
    an array that matches the same structure as that of the `permissions.yml` file.
  prefs: []
  type: TYPE_NORMAL
- en: See also…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[*Chapter 5*](B18548_05.xhtml#_idTextAnchor172), *Creating* *Custom Pages*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Hooking into Drupal to react to entity changes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One of the most common integration points is hooking into Drupal to react to
    the create, read, update, and delete operations of an entity. The entity system
    also has hooks to provide default values when instantiating a new entity and modifying
    it before it is saved.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we will create a hook that runs whenever new content is published
    and send an email to the site’s email address as a notification of the new content.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: First, create a file called `mymodule.module` in your `module` file. This is
    the module extension file that stores hook implementations.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Next, we will implement a hook to listen for new node entities being inserted.
    Create a function named `mymodule_node_insert`, which is an implementation of
    the `hook_ENTITY_TYPE_insert` hook:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE80]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE81]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE82]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In our `insert` hook, we will check if the node was saved as published. If
    it was, we will send an email notification:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE84]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE85]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE86]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE87]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE88]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE89]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE90]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE91]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE92]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE93]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE94]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE95]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE96]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE97]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE98]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE99]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE100]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE101]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: First, we check if the node has been published. The node entity type implements
    `EntityPublishedInterface`, which provides the `isPublished` method. If the node
    has been published, we fetch the site’s email address from the configuration.
    To send an email, we need to fetch the mail manager service. With the mail manager
    service, we invoke the `mail` method. The `module` and `key` parameters are used
    to invoke another hook in the module to generate the email’s content. The `to`
    parameter is where the email should be sent. `langcode` represents what language
    the email should be sent in. Finally, the `params` parameter provides context
    values to the hook, which generates the email content.
  prefs: []
  type: TYPE_NORMAL
- en: 'We want to add a hook that listens when nodes are updated, as they may have
    first been saved as unpublished. Create a function named `mymodule_node_update`
    so that we can implement the `hook_ENTITY_TYPE_update` hook:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE102]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE103]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE104]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In our `update` hook, we will check if the unchanged version of the node was
    published or not. We do not want to send duplicate emails. We only send an email
    if the node was previously unpublished and then became published:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE105]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE106]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE107]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE108]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE109]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE110]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE111]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE112]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE113]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE114]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE115]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE116]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE117]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE118]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE119]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE120]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE121]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE122]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE123]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE124]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE125]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE126]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: As you can see, this hook is nearly the same as our `insert` hook, but we check
    the values of the original node object. The entity storage sets the original property
    on an entity that has unchanged values from the database. This allows us to compare
    the previous values to the newly modified ones. In our hook, we verify that the
    original node was not already published before sending our email.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: This hook uses the `node_published_update` key so that we can use different
    email text.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we need to create a function named `mymodule_mail` that implements `hook_mail`.
    This will allow us to define the content for our email notifications:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE127]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE128]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The `key` and `params` parameters are the values we passed to the mail manager’s
    `mail` method and how we can identify what content to generate. The `message`
    property is an array that represents the email to be sent, such as who the email
    is being sent to and its content.
  prefs: []
  type: TYPE_NORMAL
- en: 'In our `mail` hook, we will provide a different subject based on whether the
    email is sent for a newly published node or an `update` node that became published,
    along with a message:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE129]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE130]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE131]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE132]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE133]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE134]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE135]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE136]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE137]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE138]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE139]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE140]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE141]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE142]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE143]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE144]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE145]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE146]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE147]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE148]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE149]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE150]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We check the `key` value and set an appropriate email subject based on the keys
    we have defined. The `body` key in the message expects an array of text, which
    Drupal will convert into new lines.
  prefs: []
  type: TYPE_NORMAL
- en: Now, whenever nodes are published, an email will be sent to the site’s email
    address, notifying the site administrator of the newly published content.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The entity system in Drupal has various hooks that it triggers to interact with
    entities when they are loaded, created (instantiation for a new entity), saved,
    or deleted. In this recipe, we listened to two post-save hooks. Once an entity
    has been saved, the entity storage’s post-save process invokes the `insert` hook
    for new entities or the `update` hook for existing entities.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we used hooks that targeted a specific entity type. This allowed
    us to be more concise in our code and also type-hint the appropriate entity interface
    in our hooks. Each entity operation hook can also be implemented generically.
    If we were to use `hook_entity_insert` or `hook_entity_update`, they would be
    fired for any entity type, such as taxonomy terms or blocks. When using the more
    generic hook implementation, you need to use `\Drupal\Entity\EntityInterface`
    for your type hint and use the `getEntityTypeId` method to check the entity’s
    type.
  prefs: []
  type: TYPE_NORMAL
- en: 'The available hooks for the create, read, update, and delete operations of
    entities are documented on Drupal.org, along with details about each hook and
    examples: [https://api.drupal.org/api/drupal/core%21lib%21Drupal%21Core%21Entity%21entity.api.php/group/entity_crud/10.0.x](https://api.drupal.org/api/drupal/core%21lib%21Drupal%21Core%21Entity%21entity.api.php/group/entity_crud/10.0.x).'
  prefs: []
  type: TYPE_NORMAL
- en: There’s more…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This recipe covered hooking into the post-save hooks. In the following section,
    we will explore the other hooks that are available.
  prefs: []
  type: TYPE_NORMAL
- en: Changing values before an entity is saved
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `insert` and `update` hooks are triggered after an entity has been saved.
    There is also a pre-save hook that allows you to manipulate the entity before
    it is saved.
  prefs: []
  type: TYPE_NORMAL
- en: This hook is often used to populate empty values or ensure values match an expected
    state. For example, in the *Creating an editorial workflow with content moderation*
    recipe in [*Chapter 2*](B18548_02.xhtml#_idTextAnchor059), *Content Building Experience*,
    we used the `Content Moderation` module. The `Content Moderation` module uses
    the `hook_entity_presave()` hook to ensure the content is marked as published
    or unpublished based on the workflow’s state.
  prefs: []
  type: TYPE_NORMAL
- en: Creating an event subscriber to react to events
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Drupal has two ways of integrating various parts of the system: using hooks
    or events. Hooks have been a part of Drupal for its entire lifespan and events
    were introduced in Drupal 8\. Unlike the hook system, which has implicit registration,
    the event dispatch system uses explicit registration for an event.'
  prefs: []
  type: TYPE_NORMAL
- en: The events dispatcher system comes from the Symfony framework and allows components
    to easily interact with one another. Within Drupal, and integrated Symfony components,
    events are dispatched, and event subscribers can listen to the events and react
    to changes or other processes.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we will subscribe to the `RequestEvent` event, which fires when
    a request is first handled. If the user is not logged in, we will navigate them
    to the login page.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Create `src/EventSubscriber/RequestSubscriber.php` in your module.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Define the `RequestSubscriber` class, which implements the `EventSubscriberInterface`
    interface:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE151]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE152]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE153]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE154]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE155]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE156]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE157]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'To satisfy the interface requirements, we must add a `getSubscribedEvents`
    method. This tells the system which events we are subscribing to and the method
    that needs to be invoked:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE158]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE159]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE160]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE161]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE162]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE163]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE164]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE165]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE166]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE167]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE168]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE169]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE170]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE171]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE172]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE173]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE174]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Event names are derived from the PHP class name for the event object. In the
    `getSubscribedEvent` method, we construct an associative array to be returned.
    The event class name is the key and our class method to invoke when that event
    is dispatched.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Priorities will be discussed in the *How it works...* section. It is provided
    in the example to resolve possible conflicts when the `dynamic_page_cache` module
    is enabled.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create the `doAnonymousRedirect` method we specified, which will receive the
    `RequestEvent` object for the current request:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE175]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE176]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE177]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE178]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE179]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE180]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE181]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE182]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE183]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE184]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE185]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE186]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE187]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE188]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE189]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE190]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE191]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE192]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE193]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE194]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE195]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE196]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE197]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE198]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE199]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE200]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE201]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE202]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE203]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE204]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE205]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE206]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE207]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE208]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE209]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE210]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE211]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE212]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE213]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE214]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE215]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE216]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE217]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE218]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: To prevent a redirect loop, we will use the `RouteMatch` service to get the
    current route object and verify that we are not already on the `user.login` route
    page.
  prefs: []
  type: TYPE_NORMAL
- en: Then, we check whether the user is anonymous and, if they are, set the event’s
    response to a redirect response.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have created our class, create a `mymodule.services.yml` file in
    your module’s directory.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We must register our class with the service container so that Drupal recognizes
    that it will act as an event subscriber:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE219]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE220]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE221]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE222]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE223]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE224]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The `event_subscriber` tag tells the container to invoke the `getSubscribedEvents`
    method and register its methods.
  prefs: []
  type: TYPE_NORMAL
- en: Install the module or rebuild Drupal’s caches if it has been already installed.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Navigate to any page as an anonymous user – you will be redirected to the login
    form.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Throughout Drupal and Symfony, component events can be passed to the event dispatcher.
    The `event_dispatcher` service in Drupal is an optimized version of the one provided
    by Symfony but is completely interoperable and provides backward compatibility
    layers with Symfony. When the container is built, all services tagged as `event_subscriber`
    are gathered. They are then registered into the `event_dispatcher` service, keyed
    by the events returned in the `getSubscribedEvents` method.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Symfony 4.3 changed how events are dispatched. Previously, events were identified
    only by name, with the event object serving as a value object. With Symfony 4.3,
    the event name was made optional. This also aligns with the PSR-14 Event Dispatcher
    by the PHP-FIG.
  prefs: []
  type: TYPE_NORMAL
- en: When the `event_dispatcher` service is told to dispatch an event, it invokes
    the registered methods on all subscribed services. Drupal still primarily uses
    named events over event objects, as many events leverage the same event object
    class.
  prefs: []
  type: TYPE_NORMAL
- en: The `\Symfony\Component\HttpKernel\KernelEvents` class documents the events
    available to interact with the request life cycle to become a response and even
    after the response is sent, as we did with `RequestEvent`. Then, there are events,
    such as `ConfigEvents::SAVE` and `ConfigEvents::DELETE`, that are dispatched and
    allow you to react to a configuration being saved or deleted but are not able
    to adjust the configuration entity directly through the event object.
  prefs: []
  type: TYPE_NORMAL
- en: There’s more…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Event subscribers require knowledge of creating services, registering them,
    and even dependency injection. We’ll discuss this some more in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Using dependency injection
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Drupal utilizes a service container that allows you to declare classes and services
    and define their dependencies. For services, a dependency is an argument that
    must be passed to its constructor. Dependency injection is a software design concept,
    and at its base level, it provides a means to use a class without having to directly
    reference it. In our example, we retrieved services multiple times using the `\Drupal`
    global static class. This is convenient but is a bad practice within services.
    It can make testing more difficult.
  prefs: []
  type: TYPE_NORMAL
- en: 'To implement dependency injection, first, we will add a constructor to our
    class that accepts the services used (`current_route_match` and `current_user`)
    and matches protected properties to store them:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE225]'
  prefs: []
  type: TYPE_PRE
- en: 'We can then replace any calls to `\Drupal::` with `$this->`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE226]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we will update `mymodule.services.yml` to specify our constructor
    arguments so that they will be injected when the container runs our event subscriber:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE227]'
  prefs: []
  type: TYPE_PRE
- en: Dependency injection feels and seems magical at first. However, with use and
    practice, it will begin to make more sense and become second nature when developing
    with Drupal.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'PSR-14 Event Dispatcher by PHP-FIG: [https://www.php-fig.org/psr/psr-14/](https://www.php-fig.org/psr/psr-14/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a custom Drush command
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Throughout this book, we have used Drush to perform operations on a Drupal site
    from the command line. Custom commands for Drush can be provided by modules. This
    allows developers to create commands that help them manage their Drupal sites.
    Drush requires modules to provide a `composer.json` file that instructs them where
    to load a services file that will register Drush commands.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we will create a new Drush command for a custom module that
    prints the location of where Drupal is installed.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Drush provides a command to generate the required files for creating a command
    file for custom commands. To begin, run the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE228]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: You will be prompted to provide a value for the `Module` machine name; type
    `mymodule` for the name of our module.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Next, press *Enter* to skip converting a legacy Drush command file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The command output will display the files that have been created or updated:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 4.6 – Output from the command file generator](img/Figure_4.06_B18548.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.6 – Output from the command file generator
  prefs: []
  type: TYPE_NORMAL
- en: The `composer.json` file contains information about `drush.services.yml`. The
    `drush.services.yml` file is a service definition file that contains classes and
    their arguments. It has an initial definition for the created `MymoduleCommands`
    class. The `MymoduleCommands` class is generated with sample commands as well.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `drush.services.yml` file is important. It is a services definition file
    that tags services as `drush.command` so that classes are collected by Drush:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE229]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE230]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE231]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE232]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE233]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Commands are defined as class methods in a command file. Open the `src/Commands/MymoduleCommands.php`
    file to create a new command.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create a new method called `helloWorld`, which we will use to provide the `hello-world`
    command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE234]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE235]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, add the following code to the command to output a message and display
    the directory of the Drupal site:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE236]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE237]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE238]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE239]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE240]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE241]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE242]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE243]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This method uses the `io()` method to get the input/output helper to write content
    back to the terminal. The code then gets the current site alias from the alias
    manager. Drush supports using aliases to connect to remote Drupal sites, with
    the “self” alias being the current local Drupal site. The code then calls the
    `root` method to display the directory of the Drupal code base.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, we need to provide annotations in the document block of the method.
    This is how Drush interprets the command name:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE244]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE245]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE246]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE247]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE248]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE249]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE250]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE251]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE252]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE253]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE254]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, we can execute the command. First, we must clear the cache so that Drupal
    and Drush can register the new command. Then, we can execute it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE255]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE256]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The Drush command line bootstraps Drupal when it is launched. During that launch,
    it takes the Drupal service container and adds and registers the `\Drush\Drupal\FindCommandsCompilerPass`
    compiler pass. This compiler pass scans the `services.yml` files collected by
    Drupal and finds services tagged with `drush.command`. This is why modules must
    have a `drush.services.yml` file. This defines the services and tags them appropriately
    to be discovered by Drush.
  prefs: []
  type: TYPE_NORMAL
- en: 'Since Drush wraps around Drupal, command files may also have other services
    injected into them as dependencies. Here is an example of a `drush.services.yml`
    file using dependency injection from the `Pathauto` module:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE257]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Drush command authoring documentation: [https://www.drush.org/latest/commands/](https://www.drush.org/latest/commands/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
