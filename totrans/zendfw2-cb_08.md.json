["```php\n<?php\nreturn array(\n  // Look for this ke y in the configuration array.\n  'module_listener_options' => array(\n\n    // Enable the config cache.\n    'config_cache_enabled' => true,\n\n    // If we want to give the cache a special filename\n    // we can just type a name here.\n    'config_cache_key' => 'configuration'\n\n    // The directory where we want to write the cache \n    // to. Don't forget that we need read/write access \n    // to this directory by the process running the app, which in \n    // most cases is the web server process!\n    'cache_dir' => 'data/cache/',\n  ),\n);\n```", "```php\n<?php\nreturn array(\n  // We need to define the ServiceManager\n  'service_manager' => array(\n    // We will call it cache-service\n    'cache-service' => function () {\n      // Return a new cache adapter\n      return \\Zend\\Cache\\StorageFactory::factory(array(\n        'adapter' => array(\n          // We want to use the cache that is being \n          // stored on the filesystem\n          'name' => 'filesystem',\n          'options' => array(\n            'cache_dir' => 'data/cache/',\n\n            // This is the amount in minutes the cache is valid\n            'ttl' => 100\n          ),\n        ),\n      ));\n    },\n  },\n);\n```", "```php\n<?php\n// Don't forget the namespace (obviously)\nnamespace SomeModule;\n\n// We need this event for the onBootstrap event\nuse Zend\\Mvc\\MvcEvent;\n\n// Begin our module class\nclass Module\n{\n  // This is going to be run at bootstrap, and will thus \n  // create our events that will create our cached \n  // output\n  public function onBootstrap(MvcEvent $e)\n  {\n    // We will need a list of routes that we deem \n    // cacheable\n    $routes = array('blog/pages', 'blog/archives');\n\n    $eventManager = $e->getApplication()->getEventManager();\n    $serviceManager = $e->getApplication()->getServiceManager();\n\n    $eventManager->attach(\n         MvcEvent::EVENT_ROUTE, \n         function($e) use ($serviceManager)\n    {\n      $route = $e->getRouteMatch()\n                 ->getMatchedRouteName();\n\n      // Check if this is a page that we want to cache, \n      // if not then just exit this method\n      if (!in_array($route, $routes)) {\n        return;\n      }\n\n      // Get the cache-service from the configuration\n      $cache = $serviceManager->get('cache-service');\n\n      // Define a unique key that we use for the route\n      $key = 'route-'. $route;\n\n      // Check if our cache has the key with our route \n      // content \n      if ($cache->hasItem($key)) {\n        // Handle response\n        $response = $e->getResponse();\n\n        // Set the content to our cached content\n        $response->setContent($cache->getItem($key));\n\n        // Return the response, because when we return \n        // the response from a route event, the \n        // application will output that response.\n        return $response;\n      }\n    }, \n    // Make this priority super low to make sure this \n    // route has already happened\n    -1000); \n\n    // Now we create an trigger for the render event \n    // which will come after the route event. This means \n    // that we didn't have a valid cache, and we will \n    // now use this opportunity to create a cache of our \n    // rendered content.\n    $eventManager->attach(\n      MvcEvent::EVENT_RENDER, \n      function($e) use ($serviceManager, $routes) \n    {\n      // Get the current route name \n      $route = $e->getRouteMatch()\n                 ->getMatchedRouteName();\n\n      // Check if this is a page that we want to cache, \n      // if not then just exit this method\n      if (!in_array($route, $routes))\n        return;\n\n      // Apparently we want to cache the content, so \n      // here we go!\n      $response = $e->getResponse(); \n\n      // Get the cache service from the ServiceManager\n      $cache = $serviceManager->get('cache-service');\n\n      // Build up our unique cache key\n      $key = 'route-'. $route;\n\n      // And now set the cache item\n      $cache->setItem($key, $response->getContent());\n    }, \n    // Again the lowest priority to make sure rendering \n    // already has happened.\n    -1000);\n  }\n}\n```", "```php\n<?php\nreturn array(\n  // Look for this key in the configuration array.\n  'module_listener_options' => array(\n\n    // Enable the module map cache.\n    'module_map_cache_enabled' => true,\n\n    // If we want to give the cache a special filename\n    // we can just type a name here.\n    'module_map_cache_key' => 'classmap\n\n    // The directory where we want to write the cache \n    // to. Don't forget that we need read/write access  \n    // to this directory!\n    'cache_dir' => 'data/cache/',\n  ),\n);\n```", "```php\nif ($factor && mt_rand(1, $factor) == 1) {\n     $storage->clearExpired();\n}\n```", "```php\nif ($factor && mt_rand(1, $factor) == 1) {\n     $storage->clearExpired();\n}\n```", "```php\n<?php\n\n// Use the following libraries for our example\nuse Zend\\Cache\\Storage\\Plugin\\Serializer;\nuse Zend\\Cache\\Storage\\Adapter\\FileSystem;\n\n// Initialize our Serializer plugin\n$plugin = new Serializer();\n\n// Initialize our FileSystem adapter\n$adapter = new FileSystem();\n\n// Now bind the two together\n$adapter->addPlugin($plugin);\n```", "```php\n<?php\n\n// Don't forget to set our namespace\nnamespace Application\\Controller;\n\n// Use the following classes \nuse Zend\\Mvc\\Controller\\AbstractActionController;\nuse Zend\\View\\Model\\ViewModel;\n\n// Define our class name and extend\nclass IndexController extends AbstractActionController\n{\n  // We will just use the index for this\n  public function indexAction()\n  {\n    // Initialize our LongOutput class\n    $output = new \\Application\\Model\\LongOutput();\n\n    // echo our stupidly long output \n    echo '<!-- '. $output->run(1500). ' -->';\n\n    // Just return a view model, it doesn't affect us\n    return new ViewModel();\n  }\n}\n```", "```php\n$ ab -c 4 -n 10 http://localhost/\n\n```", "```php\nTime taken for tests:   18.111 seconds\n\n```", "```php\n<?php\n// Lets add our options to the configuration array, \n// please be aware that we don't show any other options \n// here that could very well be in the configuration \n// already.\nreturn array(\n  // We should add our options inside this array key\n  'module_listener_options' => array(\n    // Enable the config cache\n    'config_cache_enabled' => true,\n\n    // Give the config cache a file name like module-\n    // config-cache.config.php\n    'config_cache_key' => 'config',\n\n    // Enable the class map caching\n    'module_map_cache_enabled' => true,\n\n    // Give the class map cache a file name like module-\n    // classmap-cache.classmap.php\n    'module_map_cache_key' => 'classmap',\n\n    // Use our data/cache as the cache directory \n    // (remember this directory need to be writeable for \n    // the web server).\n    'cache_dir' => 'data/cache',\n    // We don't want to check the module dependencies as \n    // that is the job of the developer, it just takes \n    // time to do this and is pretty much useless.\n    'check_dependencies' => false,\n  ),\n);\n```", "```php\nTime taken for tests:   15.428 seconds\n\n```", "```php\nCall to undefined method Closure::__set_state() in your_configuration_cache.php on line XX\n```", "```php\n<?php\nreturn array(\n  // We are configuring the service manager\n  'service_manager' => array(\n    'factories' => array(\n      // Initialize our file system storage\n      'Zend\\Cache\\StorageFactory' => function() {\n        return Zend\\Cache\\StorageFactory::factory(\n          array(\n            'adapter' => array(\n              'name' => 'filesystem',\n              'options' => array(\n                // Define the directory to store the \n                // cache in \n                'cacheDir' => 'data/cache',\n              ),\n            ),\n            // For the file system storage we need to \n            // have the serializer plugin enabled, \n            // otherwise thing just go wrong when we  \n            // want to storage a class or so\n            'plugins' => array('serializer'),\n          ),\n        );\n      }\n    ),\n    // We want to call our cache with the 'cache' key\n    'aliases' => array(\n      'cache' => 'Zend\\Cache\\StorageFactory',\n    ),\n  ),\n);\n```", "```php\n<?php\n\n// Set the namespace\nnamespace Application\\Controller;\n\n// Define the imports\nuse Zend\\Mvc\\Controller\\AbstractActionController;\nuse Zend\\View\\Model\\ViewModel;\n\n// Define the class name and extend\nclass IndexController extends AbstractActionController\n{\n\n  // Begin our index action again\n  public function indexAction()\n  {\n    // This time we want to make sure our class is \n    // loaded in to the ClassCache pattern so that we \n    // can eventually cache the output of our class \n    // method    \n    $pattern = \\Zend\\Cache\\PatternFactory::factory(\n           'class', array(\n      'storage' => $this->getServiceLocator()->get('cache'),\n      'class' => '\\Application\\Model\\LongOutput'\n    ));\n\n    // Now call our method through the ClassCache \n    // pattern with the same arguments as the previous \n    // test\n    echo '<!-- '. $pattern->call('run', array(1500)). '-->';\n\n    // Return the view model again because we don't \n    // actually do anything with it\n    return new ViewModel();\n  }\n}\n```", "```php\nTime taken for tests:   14.956 seconds\n\n```", "```php\n<?php\n// We need to assume that we have stripped the previous \n// configuration out of here and it is back to the \n// default configuration file\nreturn array(\n  'service_manager' => array(\n    // Instantiate the cache through our storage cache \n    // factory. It will look for the 'cache' key to \n    // initialize the cache\n    'factories' => array(\n        'cache' => '\\Zend\\Cache\\Service\\StorageCacheFactory',\n    ),\n  ),\n\n  // And here we go, initializing the cache\n  'cache' => array(\n    // We want to use the filesystem adapter\n    'adapter' => 'Filesystem',\n    'options' => array(\n      // Of course we need to set the directory to cache \n      // in\n      'cache_dir' => 'data/cache'\n    ),\n\n    // We also want the serializer otherwise it will \n    // throw an exception\n    'plugins' => array('Serializer'),\n  ),\n);\n```", "```php\nTime taken for tests:   14.303 seconds\n\n```"]