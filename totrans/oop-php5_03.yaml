- en: Chapter 3. More OOP
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第3章。更多面向对象编程
- en: The previous chapter creates a basis for us to kick-start OOP with PHP. This
    chapter will deal with some advanced features in more detail. For example, we
    will learn about class information functions by which we can investigate details
    about any class. We will then learn about some handy object-oriented information
    functions and also one of the great new features in PHP5, which is exception handling.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 前一章为我们创建了一个基础，以便我们可以用PHP启动面向对象编程。这一章将更详细地处理一些高级功能。例如，我们将学习关于类信息函数，通过这些函数我们可以调查任何类的详细信息。然后我们将学习一些实用的面向对象信息函数，以及PHP5中的一个伟大新特性，即异常处理。
- en: This chapter will also introduce us to the Iterators for easier array access.
    To store any object for later use, we need to use a special feature in OOP which
    is called serialization, we will also learn about this here. As a whole this chapter
    will strengthen your base in OOP.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章还将介绍迭代器以简化数组访问。为了存储任何对象以供以后使用，我们需要使用面向对象编程中的特殊功能，即序列化，我们也将在这里学习这一点。总的来说，本章将加强你在面向对象编程方面的基础。
- en: Class Information Functions
  id: totrans-3
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 类信息函数
- en: If you want to investigate and gather more information regarding any class,
    these functions will be your light in the dark. These functions can retrieve almost
    any information regarding a class. But there is an improved version of these functions
    and is introduced as a totally new set of API in PHP5\. That API is called **reflection**.
    We will learn about reflection API in Chapter 5.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要调查和收集有关任何类的更多信息，这些函数将是你的光明。这些函数可以检索有关类的几乎所有信息。但是，这些函数有一个改进版本，并在PHP5中作为全新的API集引入。这个API被称为**反射**。我们将在第5章学习关于反射API的内容。
- en: Checking if a Class Already Exists
  id: totrans-5
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 检查类是否已存在
- en: 'When you need to check if any class already exists in the current scope, you
    can use a function named `class_exists()`. Have a look at the following example:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 当你需要检查当前作用域中是否存在任何类时，你可以使用一个名为`class_exists()`的函数。看看以下例子：
- en: '[PRE0]'
  id: totrans-7
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The best way to use the `class_exists()` function is to first check if a class
    is already available. You can then create an instance of that class if it is available.
    This will make your code much more stable.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`class_exists()`函数的最佳方式是首先检查类是否已经存在。如果类存在，你可以创建该类的实例，这将使你的代码更加稳定。
- en: '[PRE1]'
  id: totrans-9
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Finding Currently Loaded Classes
  id: totrans-10
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 查找当前加载的类
- en: In some cases you may need to investigate which classes are loaded in the current
    scope. You can do it pretty fine with the `get_declared_classes()` function. This
    function will return an array with currently available classes.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，你可能需要调查当前作用域中加载了哪些类。你可以使用`get_declared_classes()`函数来完成这项工作。这个函数将返回一个包含当前可用类的数组。
- en: '[PRE2]'
  id: totrans-12
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: You will see a list of currently available classes on the screen.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 你将在屏幕上看到当前可用的类列表。
- en: Finding out if Methods and Properties Exists
  id: totrans-14
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 查找方法和属性是否存在
- en: To find out if a property and/or a method is available inside the class, you
    can use the `method_exists()` and `property_exists()` functions. Please note,
    these functions will return true only if the properties and methods are defined
    in public scope.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 要找出类内部是否有属性和/或方法可用，你可以使用`method_exists()`和`property_exists()`函数。请注意，这些函数只有在属性和方法在公共作用域中定义时才会返回true。
- en: Checking the Type of Class
  id: totrans-16
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 检查类的类型
- en: 'There is a function called `is_a()` that you can use to check the type of class.
    Take a look at the following example:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 有一个名为`is_a()`的函数，你可以用它来检查类的类型。看看以下例子：
- en: '[PRE3]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'You will find the output as follows:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 你将看到以下输出：
- en: '[PRE4]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Finding Out the Class Name
  id: totrans-21
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 查找类名
- en: In the previous example we checked the class if it's a type of a known one.
    What if we need to get the original name of the class itself? No worry, we have
    the `get_class()` function to help us.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，我们检查了类是否是已知类型。如果我们需要获取类的原始名称呢？不用担心，我们有`get_class()`函数来帮助我们。
- en: '[PRE5]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: As an output, you should get `ChildClass`. Now take a look at the following
    example, which "brjann" enlisted as unexpected behaviour in the PHP manual user
    note section.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 作为输出，你应该得到`ChildClass`。现在看看以下例子，这是“brjann”在PHP手册用户备注部分中提到的意外行为。
- en: '[PRE6]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: If you run this code, you will see `ParentClass` as the output. But why? You
    are calling the method for a `Child`. Is it unexpected? Well, no. Take a serious
    look at the code. Though the `Child` extended the `ParentClass` object, it didn't
    override the method `getClass()`. So the method is still running under a `ParentClass`
    scope. That's why it returns the result `ParentClass`.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你运行这段代码，你会看到输出为 `ParentClass`。但是为什么？你是在调用 `Child` 类的方法。这是意外的吗？好吧，不是的。认真看看代码。虽然
    `Child` 扩展了 `ParentClass` 对象，但它没有重写 `getClass()` 方法。所以方法仍然在 `ParentClass` 的作用域下运行。这就是为什么它返回
    `ParentClass` 的结果。
- en: So what actually happened to the following piece of code? Why is it returning
    `Child`?
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 所以实际上发生了什么？为什么它返回 `Child`？
- en: '[PRE7]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: In the `ParentClass` object, the `get_class()` function returns `$this` object,
    which clearly holds a reference of `Child` class. That's why you are getting `Child`
    as your output.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `ParentClass` 对象中，`get_class()` 函数返回 `$this` 对象，它明显持有 `Child` 类的引用。这就是为什么你得到
    `Child` 作为输出。
- en: Exception Handling
  id: totrans-30
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 异常处理
- en: One of the most improved features in PHP5 is that you can now use exceptions,
    like other OOP languages out there. PHP5 introduces these exception objects to
    simplify your error management.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: PHP5 中最改进的特性之一是现在你可以使用异常，就像其他现有的面向对象编程语言一样。PHP5 引入了这些异常对象来简化你的错误管理。
- en: 'Let''s see how these exceptions occur and how to handle them. Take a look at
    the following class, which simply connects to a PostgreSQL server. In the case
    of failing to connect to the server, let''s see what it usually returns:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看这些异常是如何发生的以及如何处理它们。看看以下类，它简单地连接到 PostgreSQL 服务器。在无法连接到服务器的情况下，让我们看看它通常会返回什么：
- en: '[PRE8]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The output is the following.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下。
- en: '[PRE9]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'How are you going to handle it in PHP4? Generally, by using something similar
    to the following shown below:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 你如何在 PHP4 中处理它？通常，可以通过以下类似的方式：
- en: '[PRE10]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Now let's see how we can solve it with exception.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们看看如何使用异常来解决它。
- en: '[PRE11]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The output will be something like this:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 输出将类似于以下内容：
- en: '[PRE12]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: So you get a lot of things in this exception class. You can catch all the errors
    using this try-catch block. You can use try-catch inside another try-catch block.
    Take a look at the following example. Here we developed two of our own exception
    objects to make the error handling more structured.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 所以你在这个异常类中得到了很多内容。你可以使用这个 try-catch 块来捕获所有错误。你可以在另一个 try-catch 块中使用 try-catch。看看以下示例。这里我们开发了两个自己的异常对象，使错误处理更加结构化。
- en: '[PRE13]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Now, if the code cannot connect to DB, it catches the error and displays that
    **Sorry, couldn''t connect to PostgreSQL server**: message. If the connection
    is successful but the problem is in the query, it will display the proper information.
    If you check the code, then you will find that for a connection failure we throw
    a `PGSQLConnectionException` object, and for a query failure we just throw a `PGSQLQueryException`
    object. We can custom develop these objects by extending the core Exception class
    of PHP5\. Let''s take a look at the code. The first one is the `PGSQLConnectionException`
    class.'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果代码无法连接到数据库，它会捕获错误并显示“**抱歉，无法连接到 PostgreSQL 服务器**”的消息。如果连接成功但问题出在查询上，它将显示适当的信息。如果你检查代码，你会发现对于连接失败，我们抛出一个
    `PGSQLConnectionException` 对象，而对于查询失败，我们只抛出一个 `PGSQLQueryException` 对象。我们可以通过扩展
    PHP5 的核心 Exception 类来自定义开发这些对象。让我们看看代码。第一个是 `PGSQLConnectionException` 类。
- en: '[PRE14]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: And here comes `PGSQLQueryException` class
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 现在出现了 `PGSQLQueryException` 类
- en: '[PRE15]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: That's it!
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 就这样！
- en: Collecting all PHP Errors as Exception
  id: totrans-49
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 收集所有 PHP 错误作为异常
- en: 'If you want to collect all PHP errors (except the FATAL errors) as exception,
    you can use the following code:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要收集所有 PHP 错误（除了 FATAL 错误）作为异常，你可以使用以下代码：
- en: '[PRE16]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The credit of the above code piece goes to `<[fjoggen@gmail.com](mailto:fjoggen@gmail.com)>`,
    which I collected from the PHP manual user notes.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码片段的功劳归功于 `<[fjoggen@gmail.com](mailto:fjoggen@gmail.com)>`，这是我从 PHP 手册用户笔记中收集的。
- en: Iterators
  id: totrans-53
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 迭代器
- en: 'An Iterator is a new command introduced in PHP5 to help traversing through
    any object. Check out the following example to understand what Iterators are actually
    used for. In PHP4 you could iterate through an array as shown in the following
    example, using `foreach` statement:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 迭代器是 PHP5 中引入的一个新命令，用于帮助遍历任何对象。查看以下示例，了解迭代器实际上用于什么。在 PHP4 中，你可以像以下示例那样使用 `foreach`
    语句遍历数组：
- en: '[PRE17]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: You could also perform a `foreach` operation over an object, let's take a look
    at the following example.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以对对象执行 `foreach` 操作，让我们看看以下示例。
- en: '[PRE18]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'This code will output the following:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码将输出以下内容：
- en: '[PRE19]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Please note that it can only iterate through the public properties. But what
    if we want just the valid email addresses as the output? Well, in PHP5 that's
    possible by implementing the `Iterator` and `IteratorAggregator` interface. Let
    us see using the following example. In this example, we create a `QueryIterator`,
    which can iterate through a valid PostgreSQL query result and returns one row
    per Iteration.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，它只能遍历公共属性。但是，如果我们只想得到有效的电子邮件地址作为输出呢？在PHP5中，通过实现`Iterator`和`IteratorAggregator`接口是可能的。让我们通过以下示例来看看。在这个例子中，我们创建了一个`QueryIterator`，它可以遍历有效的PostgreSQL查询结果，并在每次迭代中返回一行。
- en: '[PRE20]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Let's see the code in action.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看代码的实际应用。
- en: '[PRE21]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'For example, if there are two records in our table `users`, you will get the
    following output:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果我们的`users`表中有两个记录，您将得到以下输出：
- en: '[PRE22]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Quite handy, don't you think?
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 非常方便，不是吗？
- en: ArrayObject
  id: totrans-67
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: ArrayObject
- en: 'Another useful object introduced in PHP5 is `ArrayObject` that wraps the regular
    PHP array and gives it an OO flavor. You can programmatically access the array
    in an OO style. You can create an `ArrayObject` object by simply passing to `ArrayObject`
    constructor. `ArrayObject` has the following useful methods:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 在PHP5中引入的另一个有用的对象是`ArrayObject`，它包装了常规的PHP数组并给它添加了面向对象的特性。您可以通过简单地将数组传递给`ArrayObject`构造函数来创建一个`ArrayObject`对象。`ArrayObject`有以下有用的方法：
- en: '**append()**'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '**append()**'
- en: This method can add any value at the end of the collection.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法可以在集合的末尾添加任何值。
- en: '**getIterator()**'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '**getIterator()**'
- en: This method simply creates an `Iterator` object and return so that you can perform
    iteration using an Iterator style. This is a very useful method for getting an
    `Iterator` object from any array.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法简单地创建一个`Iterator`对象并返回，这样您就可以使用迭代器风格进行迭代。这是一个非常有用的方法，可以从任何数组中获取`Iterator`对象。
- en: '**offsetExists()**'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '**offsetExists()**'
- en: This method can determine whether the specified offset exists in the collection.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法可以确定指定的偏移量是否存在于集合中。
- en: '**offsetGet()**'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '**offsetGet()**'
- en: This method returns the value for specified offset.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法返回指定偏移量的值。
- en: '**offsetSet()**'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '**offsetSet()**'
- en: Like `offsetGet()`, this method can set any value to the specified `index()`.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 与`offsetGet()`类似，此方法可以将任何值设置到指定的`index()`。
- en: '**offsetUnset()**'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '**offsetUnset()**'
- en: This method can unset the element at specified index.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法可以取消指定索引处的元素。
- en: 'Let us see some examples of `ArrayObject`:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看`ArrayObject`的一些示例：
- en: '[PRE23]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Array to Object
  id: totrans-83
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 数组到对象
- en: We can access any array element by its key, for example `$array[$key]`. However,
    what if we want to access it like this, `$array->key` style? It's very easy and
    we can do it by extending `ArrayObject`. Let's see using the following example.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过其键来访问任何数组元素，例如`$array[$key]`。然而，如果我们想以`$array->key`的方式访问它呢？这非常简单，我们可以通过扩展`ArrayObject`来实现。让我们通过以下示例来看看。
- en: '[PRE24]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Now let''s see it in action:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来看看它的实际应用：
- en: '[PRE25]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'It will output the email address associated with the key `afif`, as follows:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 它将输出与键`afif`关联的电子邮件地址，如下所示：
- en: '[PRE26]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: This example may come in handy if you want to convert the array of any known
    format into an object.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想将任何已知格式的数组转换为对象，这个示例可能会很有用。
- en: Accessing Objects in Array Style
  id: totrans-91
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 以数组风格访问对象
- en: In the previous section we learned how to access any array in OO style. What
    if we want to access any object in array style? Well, PHP provides that facility
    too. All you have to do is implement `ArrayAccess` interface in your class.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的章节中，我们学习了如何以面向对象的方式访问任何数组。如果我们想以数组风格访问任何对象怎么办？PHP提供了这样的功能。您只需要在您的类中实现`ArrayAccess`接口。
- en: '`ArrayAccess` interface has four methods, which you must implement in the class.
    The methods are `offsetExists()`, `offsetGet()`, `offsetSet()`, `offsetUnset()`.
    Let''s create a sample class implementing `ArrayAccess` interface.'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '`ArrayAccess`接口有四个方法，您必须在类中实现这些方法。这些方法是`offsetExists()`、`offsetGet()`、`offsetSet()`、`offsetUnset()`。让我们创建一个实现`ArrayAccess`接口的示例类。'
- en: '[PRE27]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: The output will be `mayflower@phpxperts.net`.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 输出将是`mayflower@phpxperts.net`。
- en: Serialization
  id: totrans-96
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 序列化
- en: So far we have learned how we can create objects and manipulate them. Now what
    happens if you need to save any state of the object and retrieve it later exactly
    in that form? In PHP, you can achieve this functionality by serialization.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经学习了如何创建对象并操作它们。现在，如果您需要保存对象的状态并在稍后以完全相同的形式检索它，会发生什么？在PHP中，您可以通过序列化来实现此功能。
- en: 'Serialization is a process of persisting the state of an object in any location,
    either physical files or in variables. To retrieve the state of that object, another
    process is used which is called "unserialization". You can serialize any object
    using `serialize()` function. Let''s see how we can serialize an object:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 序列化是将对象的状态持久化在任何位置的过程，无论是物理文件还是变量中。为了检索该对象的状态，另一个过程被使用，这被称为“反序列化”。您可以使用 `serialize()`
    函数序列化任何对象。让我们看看我们如何序列化一个对象：
- en: '[PRE28]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: The script will output a string, which PHP understands how to unserialize.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 脚本将输出一个字符串，PHP知道如何反序列化它。
- en: Now it's time to retrieve our serialized object and convert into a usable PHP
    object. Please bear in mind that the class file you are unserializng must be loaded
    first.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候检索我们的序列化对象并将其转换为可用的PHP对象了。请记住，您正在反序列化的类文件必须首先加载。
- en: '[PRE29]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'What do you think the output will be? Take a look:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 你认为输出会是什么？看看：
- en: '[PRE30]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: It's now a regular PHP object; the same as it was just before serializing. Please
    note that all variables keep their values, which were set before serializing,
    except the static one. You cannot save the state of a static variable by serializing.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 现在它是一个常规的PHP对象；与序列化之前完全相同。请注意，所有变量都保留了它们在序列化之前设置的值，除了静态变量。您不能通过序列化来保存静态变量的状态。
- en: 'What if we didn''t include the class file by `include_once` before unserializing?
    Let''s just comment out the first line, which includes the class file and then
    run the example code. You will get the following output:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们在反序列化之前没有使用 `include_once` 包含类文件，会怎样？让我们只注释掉第一行，包含类文件的行，然后运行示例代码。你会得到以下输出：
- en: '[PRE31]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: At this point, you can't use it as the object again.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 到这一点，您不能再将其用作对象了。
- en: Magic Methods in Serialization
  id: totrans-109
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 序列化中的魔法方法
- en: Do you remember we overloaded properties and methods using some magic methods
    like `__get`, `__set`, and `__call`? For serialization, you are allowed to use
    some magic methods to hook into the process of serialization. PHP5 provides two
    magic methods for this purpose named `__sleep` and `__awake`. These methods give
    some control over the whole process.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 你还记得我们使用一些魔法方法如 `__get`、`__set` 和 `__call` 重载属性和方法吗？对于序列化，您可以使用一些魔法方法来挂钩序列化过程。PHP5
    提供了两个名为 `__sleep` 和 `__awake` 的魔法方法来达到这个目的。这些方法在整个过程中提供了一些控制。
- en: Let's develop all the static variables of a process using these magic methods,
    which we generally won't be able to do without a hack. Normally it's not possible
    to serialize the values of any static variables and return the object in same
    state with that static variable. However, we can make it happen, let's see the
    following code.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用这些魔法方法来开发一个进程的所有静态变量，通常我们无法不通过黑客手段做到这一点。通常情况下，无法序列化任何静态变量的值，并返回具有该静态变量的对象处于相同状态。然而，我们可以让它发生，让我们看看下面的代码。
- en: '[PRE32]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: What happens if we serialize the object, write it into the file and then later
    retrieve the state? You will find the static value still persists the last value
    assigned to it.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们序列化对象，将其写入文件，然后稍后检索状态会发生什么？你会发现静态值仍然保持最后分配给它的值。
- en: Let's discuss the code for a second. The `__sleep` function performs all the
    necessary operations. It searches for public properties with values and stores
    the variable's name when it finds one into a private variable `staticvars`. Later
    when someone tries to unserialize the object, it retrieves each value from the
    `staticvars` and writes it to the property itself. Pretty handy, don't you agree?
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们讨论一下代码。`__sleep` 函数执行所有必要的操作。它搜索具有值的公共属性，并在找到时将变量的名称存储到一个私有变量 `staticvars`
    中。当有人尝试反序列化对象时，它会从 `staticvars` 中检索每个值并将其写入属性本身。非常方便，不是吗？
- en: 'You will notice that we haven''t used a hack, with the exception of the theoretical
    capability of the `__sleep()` and `__wakeup()` functions. So what are these two
    functions useful for? Where can we use them in practice? This is actually fairly
    simple. For example, if your class has any resource object associated with it
    (a live DB connection, a reference of an open file) in `sleep` function you can
    properly close them as they are no longer usable when someone unserializes it.
    Please remember that in an unserialized state someone may still use those resource
    pointers. So in the `__wakeup()` function you can open those DB connections, or
    file pointers, to give it an exact shape as it was before. Let us see using the
    following example:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 您会注意到，除了 `__sleep()` 和 `__wakeup()` 函数的理论能力之外，我们没有使用任何技巧。那么这两个函数有什么用？我们可以在实践中在哪里使用它们？这实际上相当简单。例如，如果您的类与其相关联任何资源对象（一个活动的数据库连接，一个打开文件的引用）在
    `sleep` 函数中，您可以适当地关闭它们，因为当有人反序列化时它们将不再可用。请记住，在反序列化状态下，有人仍然可能使用那些资源指针。所以，在 `__wakeup()`
    函数中，您可以打开那些数据库连接或文件指针，使其恢复到之前的确切形状。让我们通过以下示例来看看：
- en: '[PRE33]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: This object, when being serialized, will free the memory that was consumed by
    `$resource`. Later, when it will be unserialized, it will open the connection
    again using the DSN string. So now, after unserialization, everything is as it
    was before. That's the clue!
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 当这个对象被序列化时，它将释放 `$resource` 消耗的内存。稍后，当它将被反序列化时，它将使用 DSN 字符串再次打开连接。所以现在，在反序列化之后，一切如故。这就是关键！
- en: Object Cloning
  id: totrans-118
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 对象克隆
- en: PHP5 introduces a new approach while copying objects from one into another,
    which is quite different to PHP4\. In PHP4 when you copy an object to another,
    it performs a deep copy. This means it just makes a completely new object, which
    retains the properties of the object being copied. However, changing anything
    in the new object will not affect the main object.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: PHP5 在从一个对象复制到另一个对象时引入了一种新的方法，这与 PHP4 完全不同。在 PHP4 中，当您将一个对象复制到另一个对象时，它执行深度复制。这意味着它只是创建了一个全新的对象，该对象保留了被复制对象的属性。然而，对新的对象所做的任何更改都不会影响主对象。
- en: PHP5 is different from this in the way it makes a shallow copy when you copy
    an object from one to another. To clearly understand the situation, you need to
    understand the following code.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: PHP5 在复制对象时创建浅复制的方式与这个不同。为了清楚地理解这种情况，您需要理解以下代码。
- en: '[PRE34]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: If you run the above code in PHP5 can you guess what will you get as the result?
    `Hasin` or `Afif`? Surprisingly, the output is `Afif`. As I mentioned earlier,
    PHP5 performs a shallow copy while copying an object; `$sample2` is just a reference
    to `$sample1`. So whenever you perform any change to `$sample1` object or `$sample2`
    object, it will affect both.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您在 PHP5 中运行上述代码，您能猜到您会得到什么结果？`Hasin` 还是 `Afif`？令人惊讶的是，输出是 `Afif`。正如我之前提到的，PHP5
    在复制对象时执行浅复制；`$sample2` 只是 `$sample1` 的引用。所以，无论何时您对 `$sample1` 对象或 `$sample2` 对象进行任何更改，它都会影响两者。
- en: In PHP4 it works differently; it will output `Hasin`, as both are different
    from each other.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 在 PHP4 中，它的工作方式不同；它将输出 `Hasin`，因为它们彼此不同。
- en: If you want to perform the same in PHP5, you have to use the `clone` keyword.
    Let's take a look at the following example
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想在 PHP5 中执行相同的操作，您必须使用 `clone` 关键字。让我们看看以下示例
- en: '[PRE35]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: The output now would be `Hasin`.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 现在的输出将是 `Hasin`。
- en: Autoloading Classes or Classes on Demand
  id: totrans-127
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 按需自动加载类或类
- en: While working with big projects, another very good practice is loading classes
    only when you need it. That means you shouldn't over consume the memory by loading
    unnecessary classes all the time.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 在处理大型项目时，另一个非常好的实践是在需要时才加载类。这意味着您不应该通过不断加载不必要的类来过度消耗内存。
- en: 'In our examples, you have seen that we include the original class file before
    making them available in our script. Unless you include the class file, you can''t
    create an instance of it. PHP5 introduces a feature to auto load your class files
    so that you don''t have to bother to include them manually. Usually, this feature
    is helpful in big applications where you have to deal with lots of classes and
    don''t want to bother to call `include` all the time. Take a look at the following
    example:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的示例中，您已经看到我们在将它们在我们的脚本中可用之前，包括原始类文件。除非您包括类文件，否则您无法创建其实例。PHP5 引入了一个自动加载类文件的功能，这样您就不必麻烦地手动包含它们。通常，这个特性在大型应用程序中非常有用，在这些应用程序中，您必须处理大量的类，并且不想每次都调用
    `include`。
- en: '[PRE36]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: When you execute the script shown above, note that we didn't include any class
    file for the `Emailer` class. Because of this `__autoload()` function, PHP5 will
    auto load a file named `class.emailer.php` in the current directory. So you need
    not worry about including the class yourself.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 当你执行上面的脚本时，请注意我们没有包含`Emailer`类的任何类文件。正因为有这个`__autoload()`函数，PHP5会自动加载当前目录下名为`class.emailer.php`的文件。所以你不需要担心自己包含类。
- en: Method Chaining
  id: totrans-132
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 方法链式调用
- en: 'Method chaining is another process introduced in PHP5 by which you can directly
    access the methods and attributes of an object when it is returned by any function.
    It is something like the following:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 方法链式调用是PHP5中引入的另一种过程，通过它可以直接访问由任何函数返回的对象的方法和属性。它有点像以下这样：
- en: '[PRE37]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: The above code means that `$someObject` class has a method named `getObjectOne()`
    which returns an object named `$objectOne`. This `$objectOne` has another method
    named `getObjectTwo()` which returns an object whose method is called by the final
    call.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码表示`$someObject`类有一个名为`getObjectOne()`的方法，它返回一个名为`$objectOne`的对象。这个`$objectOne`还有一个名为`getObjectTwo()`的方法，它返回一个对象，其方法是通过最后的调用调用的。
- en: 'So who is going to use such things? Let''s take a look at the following code;
    it makes you understand beautifully how a method chain can be used in real life:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，谁会使用这样的东西呢？让我们看看下面的代码；它完美地展示了方法链在现实生活中的使用：
- en: '[PRE38]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Do you find the above code meaningful and readable? The code returns a row
    from the `user` table containing the ID and email where the value of ID is equal
    to 1\. Have you ever wondered how to design such a DB manager object? Let''s take
    a look at this great example below:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 你觉得上面的代码有意义且易于阅读吗？该代码从`user`表中返回一行，包含ID和电子邮件，其中ID的值为1。你有没有想过如何设计这样的DB管理器对象？让我们看看下面的这个优秀的例子：
- en: '[PRE39]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'The output is:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE40]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'The class automatically builds the query. So how does this work? Well, in PHP5
    you can return objects; so using this feature we return the object on each method
    that we want to be part of the chain. Now, it''s just a matter of a few minutes
    to execute that query and return the result. Surprising, you can also execute
    the following code which generates the same result:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 该类会自动构建查询。那么它是如何工作的呢？嗯，在PHP5中，你可以返回对象；所以利用这个特性，我们在每个我们希望成为链式的一部分的方法上返回对象。现在，只需几分钟就可以执行那个查询并返回结果。令人惊讶的是，你还可以执行以下代码，它会产生相同的结果：
- en: '[PRE41]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: This is the beauty of PHP5; it's amazingly powerful.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是PHP5的美丽之处；它非常强大。
- en: Life Cycle of an Object in PHP and Object Caching
  id: totrans-145
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: PHP中对象的生命周期和对象缓存
- en: If you are interested in understanding the lifecycle of an object, then an object
    is live until the script ends. As soon as the script finishes executing, any object
    instantiated by this script also dies. Unlike web tier in Java, there is no global
    or application-level scope in PHP. So you cannot persist the object normally.
    If you want to persist an object, you can serialize it and later unserialize it
    when necessary. Manually handling this serialization and unserialization process
    may seem boring sometimes. It would really be nice to store the object somewhere
    and retrieve it later (well, the same as serialization/unserialization process,
    but with more flexibly).
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你感兴趣于了解对象的生命周期，那么对象在脚本结束时是活跃的。一旦脚本执行完毕，由该脚本实例化的任何对象也会死亡。与Java中的Web层不同，PHP中没有全局或应用级别的范围。因此，你不能正常地持久化对象。如果你想持久化一个对象，你可以将其序列化，并在必要时反序列化它。手动处理这个序列化和反序列化过程有时可能显得无聊。如果能在某处存储对象并在以后检索它（嗯，就像序列化和反序列化过程一样，但更灵活）那就真的很好了。
- en: There is some object caching technology available for PHP, which is very efficient
    indeed. The most successful among them is **memcached**. PHP has an extension
    to memcached API, which is available to download from PECL. Memcached runs as
    a standalone server and caches objects directly into memory. Memcached server
    listens in a port. PHP memcached API understands how to talk to the memcached
    server, hence it saves and retrieves an object with its help. In this section
    we will demonstrate how to work with memcached, but we will not go into too much
    detail.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: PHP中确实有一些对象缓存技术可用，效率非常高。其中最成功的是**memcached**。PHP有一个扩展名为memcached API，可以从PECL下载。Memcached作为一个独立的服务器运行，并将对象直接缓存到内存中。Memcached服务器监听一个端口。PHP
    memcached API理解如何与memcached服务器通信，因此借助它保存和检索对象。在本节中，我们将演示如何使用memcached，但不会过多地深入细节。
- en: You can download the memcached server from [http://danga.com/memcached](http://danga.com/memcached).
    If you are using Linux you have to compile it by your own. With some distro you
    will find the memcached package. You will find a `win32` binary version of memcached
    1.2.1 server from [http://jehiah.cz/projects/memcached-win32/](http://jehiah.cz/projects/memcached-win32/)
    which is developed by kronuz (`<[kronuz@users.sourceforge.net](mailto:kronuz@users.sourceforge.net)>`).
    After getting the executable, give the following command in the console. It will
    start the memcached server.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以从[http://danga.com/memcached](http://danga.com/memcached)下载memcached服务器。如果你使用Linux，你必须自己编译它。在一些发行版中，你会找到memcached包。你可以在[http://jehiah.cz/projects/memcached-win32/](http://jehiah.cz/projects/memcached-win32/)找到memcached
    1.2.1服务器的`win32`二进制版本，该版本由kronuz开发（`<[kronuz@users.sourceforge.net](mailto:kronuz@users.sourceforge.net)>`）。获取可执行文件后，在控制台输入以下命令。这将启动memcached服务器。
- en: '[PRE42]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: This will install memcached as a service.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 这将把memcached安装为服务。
- en: '[PRE43]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: This will start the daemon/service.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 这将启动守护进程/服务。
- en: Now it's time to store some objects into the memcached server and retrieve it.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候将一些对象存储到memcached服务器中并检索它们了。
- en: '[PRE44]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'When you execute the code above, the memcache server saves the object `$tmp_object`
    against the key `obj` for five minutes. After five minutes this object will not
    exist. By this time, if you need to restore that object, you can execute the following
    code:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 当你执行上面的代码时，memcache服务器会将对象`$tmp_object`与键`obj`关联存储五分钟。五分钟后，这个对象将不再存在。到那时，如果你需要恢复该对象，你可以执行以下代码：
- en: '[PRE45]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: That's it. Memcache is so popular that it has Perl, Python, Ruby, Java, and
    Dot Net, and C port.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 就这样。Memcache非常流行，它有Perl、Python、Ruby、Java和Dot Net以及C语言的端口。
- en: Summary
  id: totrans-158
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter we learned how to use some advanced OOP concepts in PHP. We
    learned how to retrieve information from any object, and learned about ArrayAccess,
    ArrayObject, Iterators, and some other native objects which simplifies the life
    of a developer. Another very important thing we learned from this chapter is Exception
    Handling.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了如何在PHP中使用一些高级面向对象编程（OOP）概念。我们学习了如何从任何对象中检索信息，并了解了ArrayAccess、ArrayObject、迭代器和一些其他简化开发者生活的原生对象。本章我们从中学到的另一件非常重要的事情是异常处理。
- en: In next chapter we will learn about design patterns and how to use them in PHP.
    Untill then, happy exploring…
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将学习设计模式以及如何在PHP中使用它们。在此之前，祝大家探索愉快…
