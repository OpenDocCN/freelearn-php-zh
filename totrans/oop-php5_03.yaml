- en: Chapter 3. More OOP
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The previous chapter creates a basis for us to kick-start OOP with PHP. This
    chapter will deal with some advanced features in more detail. For example, we
    will learn about class information functions by which we can investigate details
    about any class. We will then learn about some handy object-oriented information
    functions and also one of the great new features in PHP5, which is exception handling.
  prefs: []
  type: TYPE_NORMAL
- en: This chapter will also introduce us to the Iterators for easier array access.
    To store any object for later use, we need to use a special feature in OOP which
    is called serialization, we will also learn about this here. As a whole this chapter
    will strengthen your base in OOP.
  prefs: []
  type: TYPE_NORMAL
- en: Class Information Functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you want to investigate and gather more information regarding any class,
    these functions will be your light in the dark. These functions can retrieve almost
    any information regarding a class. But there is an improved version of these functions
    and is introduced as a totally new set of API in PHP5\. That API is called **reflection**.
    We will learn about reflection API in Chapter 5.
  prefs: []
  type: TYPE_NORMAL
- en: Checking if a Class Already Exists
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'When you need to check if any class already exists in the current scope, you
    can use a function named `class_exists()`. Have a look at the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The best way to use the `class_exists()` function is to first check if a class
    is already available. You can then create an instance of that class if it is available.
    This will make your code much more stable.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Finding Currently Loaded Classes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In some cases you may need to investigate which classes are loaded in the current
    scope. You can do it pretty fine with the `get_declared_classes()` function. This
    function will return an array with currently available classes.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: You will see a list of currently available classes on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: Finding out if Methods and Properties Exists
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To find out if a property and/or a method is available inside the class, you
    can use the `method_exists()` and `property_exists()` functions. Please note,
    these functions will return true only if the properties and methods are defined
    in public scope.
  prefs: []
  type: TYPE_NORMAL
- en: Checking the Type of Class
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There is a function called `is_a()` that you can use to check the type of class.
    Take a look at the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'You will find the output as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Finding Out the Class Name
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the previous example we checked the class if it's a type of a known one.
    What if we need to get the original name of the class itself? No worry, we have
    the `get_class()` function to help us.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: As an output, you should get `ChildClass`. Now take a look at the following
    example, which "brjann" enlisted as unexpected behaviour in the PHP manual user
    note section.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: If you run this code, you will see `ParentClass` as the output. But why? You
    are calling the method for a `Child`. Is it unexpected? Well, no. Take a serious
    look at the code. Though the `Child` extended the `ParentClass` object, it didn't
    override the method `getClass()`. So the method is still running under a `ParentClass`
    scope. That's why it returns the result `ParentClass`.
  prefs: []
  type: TYPE_NORMAL
- en: So what actually happened to the following piece of code? Why is it returning
    `Child`?
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: In the `ParentClass` object, the `get_class()` function returns `$this` object,
    which clearly holds a reference of `Child` class. That's why you are getting `Child`
    as your output.
  prefs: []
  type: TYPE_NORMAL
- en: Exception Handling
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One of the most improved features in PHP5 is that you can now use exceptions,
    like other OOP languages out there. PHP5 introduces these exception objects to
    simplify your error management.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s see how these exceptions occur and how to handle them. Take a look at
    the following class, which simply connects to a PostgreSQL server. In the case
    of failing to connect to the server, let''s see what it usually returns:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: The output is the following.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'How are you going to handle it in PHP4? Generally, by using something similar
    to the following shown below:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Now let's see how we can solve it with exception.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'The output will be something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: So you get a lot of things in this exception class. You can catch all the errors
    using this try-catch block. You can use try-catch inside another try-catch block.
    Take a look at the following example. Here we developed two of our own exception
    objects to make the error handling more structured.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, if the code cannot connect to DB, it catches the error and displays that
    **Sorry, couldn''t connect to PostgreSQL server**: message. If the connection
    is successful but the problem is in the query, it will display the proper information.
    If you check the code, then you will find that for a connection failure we throw
    a `PGSQLConnectionException` object, and for a query failure we just throw a `PGSQLQueryException`
    object. We can custom develop these objects by extending the core Exception class
    of PHP5\. Let''s take a look at the code. The first one is the `PGSQLConnectionException`
    class.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: And here comes `PGSQLQueryException` class
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: That's it!
  prefs: []
  type: TYPE_NORMAL
- en: Collecting all PHP Errors as Exception
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'If you want to collect all PHP errors (except the FATAL errors) as exception,
    you can use the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: The credit of the above code piece goes to `<[fjoggen@gmail.com](mailto:fjoggen@gmail.com)>`,
    which I collected from the PHP manual user notes.
  prefs: []
  type: TYPE_NORMAL
- en: Iterators
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'An Iterator is a new command introduced in PHP5 to help traversing through
    any object. Check out the following example to understand what Iterators are actually
    used for. In PHP4 you could iterate through an array as shown in the following
    example, using `foreach` statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: You could also perform a `foreach` operation over an object, let's take a look
    at the following example.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'This code will output the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Please note that it can only iterate through the public properties. But what
    if we want just the valid email addresses as the output? Well, in PHP5 that's
    possible by implementing the `Iterator` and `IteratorAggregator` interface. Let
    us see using the following example. In this example, we create a `QueryIterator`,
    which can iterate through a valid PostgreSQL query result and returns one row
    per Iteration.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Let's see the code in action.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'For example, if there are two records in our table `users`, you will get the
    following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Quite handy, don't you think?
  prefs: []
  type: TYPE_NORMAL
- en: ArrayObject
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Another useful object introduced in PHP5 is `ArrayObject` that wraps the regular
    PHP array and gives it an OO flavor. You can programmatically access the array
    in an OO style. You can create an `ArrayObject` object by simply passing to `ArrayObject`
    constructor. `ArrayObject` has the following useful methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '**append()**'
  prefs: []
  type: TYPE_NORMAL
- en: This method can add any value at the end of the collection.
  prefs: []
  type: TYPE_NORMAL
- en: '**getIterator()**'
  prefs: []
  type: TYPE_NORMAL
- en: This method simply creates an `Iterator` object and return so that you can perform
    iteration using an Iterator style. This is a very useful method for getting an
    `Iterator` object from any array.
  prefs: []
  type: TYPE_NORMAL
- en: '**offsetExists()**'
  prefs: []
  type: TYPE_NORMAL
- en: This method can determine whether the specified offset exists in the collection.
  prefs: []
  type: TYPE_NORMAL
- en: '**offsetGet()**'
  prefs: []
  type: TYPE_NORMAL
- en: This method returns the value for specified offset.
  prefs: []
  type: TYPE_NORMAL
- en: '**offsetSet()**'
  prefs: []
  type: TYPE_NORMAL
- en: Like `offsetGet()`, this method can set any value to the specified `index()`.
  prefs: []
  type: TYPE_NORMAL
- en: '**offsetUnset()**'
  prefs: []
  type: TYPE_NORMAL
- en: This method can unset the element at specified index.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let us see some examples of `ArrayObject`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Array to Object
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We can access any array element by its key, for example `$array[$key]`. However,
    what if we want to access it like this, `$array->key` style? It's very easy and
    we can do it by extending `ArrayObject`. Let's see using the following example.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Now let''s see it in action:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'It will output the email address associated with the key `afif`, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: This example may come in handy if you want to convert the array of any known
    format into an object.
  prefs: []
  type: TYPE_NORMAL
- en: Accessing Objects in Array Style
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous section we learned how to access any array in OO style. What
    if we want to access any object in array style? Well, PHP provides that facility
    too. All you have to do is implement `ArrayAccess` interface in your class.
  prefs: []
  type: TYPE_NORMAL
- en: '`ArrayAccess` interface has four methods, which you must implement in the class.
    The methods are `offsetExists()`, `offsetGet()`, `offsetSet()`, `offsetUnset()`.
    Let''s create a sample class implementing `ArrayAccess` interface.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: The output will be `mayflower@phpxperts.net`.
  prefs: []
  type: TYPE_NORMAL
- en: Serialization
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So far we have learned how we can create objects and manipulate them. Now what
    happens if you need to save any state of the object and retrieve it later exactly
    in that form? In PHP, you can achieve this functionality by serialization.
  prefs: []
  type: TYPE_NORMAL
- en: 'Serialization is a process of persisting the state of an object in any location,
    either physical files or in variables. To retrieve the state of that object, another
    process is used which is called "unserialization". You can serialize any object
    using `serialize()` function. Let''s see how we can serialize an object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: The script will output a string, which PHP understands how to unserialize.
  prefs: []
  type: TYPE_NORMAL
- en: Now it's time to retrieve our serialized object and convert into a usable PHP
    object. Please bear in mind that the class file you are unserializng must be loaded
    first.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'What do you think the output will be? Take a look:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: It's now a regular PHP object; the same as it was just before serializing. Please
    note that all variables keep their values, which were set before serializing,
    except the static one. You cannot save the state of a static variable by serializing.
  prefs: []
  type: TYPE_NORMAL
- en: 'What if we didn''t include the class file by `include_once` before unserializing?
    Let''s just comment out the first line, which includes the class file and then
    run the example code. You will get the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: At this point, you can't use it as the object again.
  prefs: []
  type: TYPE_NORMAL
- en: Magic Methods in Serialization
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Do you remember we overloaded properties and methods using some magic methods
    like `__get`, `__set`, and `__call`? For serialization, you are allowed to use
    some magic methods to hook into the process of serialization. PHP5 provides two
    magic methods for this purpose named `__sleep` and `__awake`. These methods give
    some control over the whole process.
  prefs: []
  type: TYPE_NORMAL
- en: Let's develop all the static variables of a process using these magic methods,
    which we generally won't be able to do without a hack. Normally it's not possible
    to serialize the values of any static variables and return the object in same
    state with that static variable. However, we can make it happen, let's see the
    following code.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: What happens if we serialize the object, write it into the file and then later
    retrieve the state? You will find the static value still persists the last value
    assigned to it.
  prefs: []
  type: TYPE_NORMAL
- en: Let's discuss the code for a second. The `__sleep` function performs all the
    necessary operations. It searches for public properties with values and stores
    the variable's name when it finds one into a private variable `staticvars`. Later
    when someone tries to unserialize the object, it retrieves each value from the
    `staticvars` and writes it to the property itself. Pretty handy, don't you agree?
  prefs: []
  type: TYPE_NORMAL
- en: 'You will notice that we haven''t used a hack, with the exception of the theoretical
    capability of the `__sleep()` and `__wakeup()` functions. So what are these two
    functions useful for? Where can we use them in practice? This is actually fairly
    simple. For example, if your class has any resource object associated with it
    (a live DB connection, a reference of an open file) in `sleep` function you can
    properly close them as they are no longer usable when someone unserializes it.
    Please remember that in an unserialized state someone may still use those resource
    pointers. So in the `__wakeup()` function you can open those DB connections, or
    file pointers, to give it an exact shape as it was before. Let us see using the
    following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: This object, when being serialized, will free the memory that was consumed by
    `$resource`. Later, when it will be unserialized, it will open the connection
    again using the DSN string. So now, after unserialization, everything is as it
    was before. That's the clue!
  prefs: []
  type: TYPE_NORMAL
- en: Object Cloning
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: PHP5 introduces a new approach while copying objects from one into another,
    which is quite different to PHP4\. In PHP4 when you copy an object to another,
    it performs a deep copy. This means it just makes a completely new object, which
    retains the properties of the object being copied. However, changing anything
    in the new object will not affect the main object.
  prefs: []
  type: TYPE_NORMAL
- en: PHP5 is different from this in the way it makes a shallow copy when you copy
    an object from one to another. To clearly understand the situation, you need to
    understand the following code.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: If you run the above code in PHP5 can you guess what will you get as the result?
    `Hasin` or `Afif`? Surprisingly, the output is `Afif`. As I mentioned earlier,
    PHP5 performs a shallow copy while copying an object; `$sample2` is just a reference
    to `$sample1`. So whenever you perform any change to `$sample1` object or `$sample2`
    object, it will affect both.
  prefs: []
  type: TYPE_NORMAL
- en: In PHP4 it works differently; it will output `Hasin`, as both are different
    from each other.
  prefs: []
  type: TYPE_NORMAL
- en: If you want to perform the same in PHP5, you have to use the `clone` keyword.
    Let's take a look at the following example
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: The output now would be `Hasin`.
  prefs: []
  type: TYPE_NORMAL
- en: Autoloading Classes or Classes on Demand
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: While working with big projects, another very good practice is loading classes
    only when you need it. That means you shouldn't over consume the memory by loading
    unnecessary classes all the time.
  prefs: []
  type: TYPE_NORMAL
- en: 'In our examples, you have seen that we include the original class file before
    making them available in our script. Unless you include the class file, you can''t
    create an instance of it. PHP5 introduces a feature to auto load your class files
    so that you don''t have to bother to include them manually. Usually, this feature
    is helpful in big applications where you have to deal with lots of classes and
    don''t want to bother to call `include` all the time. Take a look at the following
    example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: When you execute the script shown above, note that we didn't include any class
    file for the `Emailer` class. Because of this `__autoload()` function, PHP5 will
    auto load a file named `class.emailer.php` in the current directory. So you need
    not worry about including the class yourself.
  prefs: []
  type: TYPE_NORMAL
- en: Method Chaining
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Method chaining is another process introduced in PHP5 by which you can directly
    access the methods and attributes of an object when it is returned by any function.
    It is something like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: The above code means that `$someObject` class has a method named `getObjectOne()`
    which returns an object named `$objectOne`. This `$objectOne` has another method
    named `getObjectTwo()` which returns an object whose method is called by the final
    call.
  prefs: []
  type: TYPE_NORMAL
- en: 'So who is going to use such things? Let''s take a look at the following code;
    it makes you understand beautifully how a method chain can be used in real life:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'Do you find the above code meaningful and readable? The code returns a row
    from the `user` table containing the ID and email where the value of ID is equal
    to 1\. Have you ever wondered how to design such a DB manager object? Let''s take
    a look at this great example below:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'The class automatically builds the query. So how does this work? Well, in PHP5
    you can return objects; so using this feature we return the object on each method
    that we want to be part of the chain. Now, it''s just a matter of a few minutes
    to execute that query and return the result. Surprising, you can also execute
    the following code which generates the same result:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: This is the beauty of PHP5; it's amazingly powerful.
  prefs: []
  type: TYPE_NORMAL
- en: Life Cycle of an Object in PHP and Object Caching
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you are interested in understanding the lifecycle of an object, then an object
    is live until the script ends. As soon as the script finishes executing, any object
    instantiated by this script also dies. Unlike web tier in Java, there is no global
    or application-level scope in PHP. So you cannot persist the object normally.
    If you want to persist an object, you can serialize it and later unserialize it
    when necessary. Manually handling this serialization and unserialization process
    may seem boring sometimes. It would really be nice to store the object somewhere
    and retrieve it later (well, the same as serialization/unserialization process,
    but with more flexibly).
  prefs: []
  type: TYPE_NORMAL
- en: There is some object caching technology available for PHP, which is very efficient
    indeed. The most successful among them is **memcached**. PHP has an extension
    to memcached API, which is available to download from PECL. Memcached runs as
    a standalone server and caches objects directly into memory. Memcached server
    listens in a port. PHP memcached API understands how to talk to the memcached
    server, hence it saves and retrieves an object with its help. In this section
    we will demonstrate how to work with memcached, but we will not go into too much
    detail.
  prefs: []
  type: TYPE_NORMAL
- en: You can download the memcached server from [http://danga.com/memcached](http://danga.com/memcached).
    If you are using Linux you have to compile it by your own. With some distro you
    will find the memcached package. You will find a `win32` binary version of memcached
    1.2.1 server from [http://jehiah.cz/projects/memcached-win32/](http://jehiah.cz/projects/memcached-win32/)
    which is developed by kronuz (`<[kronuz@users.sourceforge.net](mailto:kronuz@users.sourceforge.net)>`).
    After getting the executable, give the following command in the console. It will
    start the memcached server.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: This will install memcached as a service.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: This will start the daemon/service.
  prefs: []
  type: TYPE_NORMAL
- en: Now it's time to store some objects into the memcached server and retrieve it.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'When you execute the code above, the memcache server saves the object `$tmp_object`
    against the key `obj` for five minutes. After five minutes this object will not
    exist. By this time, if you need to restore that object, you can execute the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: That's it. Memcache is so popular that it has Perl, Python, Ruby, Java, and
    Dot Net, and C port.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter we learned how to use some advanced OOP concepts in PHP. We
    learned how to retrieve information from any object, and learned about ArrayAccess,
    ArrayObject, Iterators, and some other native objects which simplifies the life
    of a developer. Another very important thing we learned from this chapter is Exception
    Handling.
  prefs: []
  type: TYPE_NORMAL
- en: In next chapter we will learn about design patterns and how to use them in PHP.
    Untill then, happy exploring…
  prefs: []
  type: TYPE_NORMAL
