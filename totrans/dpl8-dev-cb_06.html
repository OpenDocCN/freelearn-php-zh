<html><head></head><body>
        <section>

                            <header>
                    <h1 class="header-title">Creating Forms with  the Form API</h1>
                </header>
            
            <article>
                
<p>In this chapter, we will explore the various recipes to work with forms in Drupal:</p>
<ul>
<li>Creating a form</li>
<li>Using new HTML5 elements</li>
<li>Validating form data</li>
<li>Processing submitted form data</li>
<li>Altering other forms</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Introduction</h1>
                </header>
            
            <article>
                
<p>Drupal provides a robust API for creating and managing forms without writing any HTML. Drupal handles form building, validation, and submission. Drupal handles the request to either build the form or process the HTTP POST request. This allows developers to simply define the elements in a form, provide any additional validation if needed, and then handle a successful submission through specific methods.</p>
<p>This chapter contains various recipes to work with forms in Drupal through the Form API. In Drupal 8, forms and form states are objects.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Creating a form</h1>
                </header>
            
            <article>
                
<p>In this recipe, we will create a form, which will be accessible from a menu path. This will involve creating a route that tells Drupal to invoke our form and display it to the end user.</p>
<p>Forms are defined as classes, which implement <kbd>\Drupal\Core\Form\FormInterface</kbd>. The <kbd>\Drupal\Core\Form\FormBase</kbd> serves as a utility class that is intended to be extended. We will extend this class to create a new form.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Getting ready</h1>
                </header>
            
            <article>
                
<p>Since we will write the code, you will want to have a custom module. Creating a custom module in Drupal is simple: create a folder and an <kbd>info.yml</kbd> file. For this recipe, we will create a folder under <kbd>/modules</kbd> in your Drupal folder called <kbd>drupalform</kbd>.</p>
<p>In the <kbd>drupalform</kbd> folder, create <kbd>drupalform.info.yml</kbd>. <span>Drupal will parse t</span>he <kbd>info.yml</kbd> file to discover modules. An example of a module's <kbd>info.yml</kbd> file is as follows:</p>
<pre>name: Drupal form example 
description: Create a basic Drupal form, accessible from a route 
type: module 
version: 1.0 
core: 8.x </pre>
<p>The name will be your module's name, and the description will be listed on the <span class="packt_screen">Extend</span> page. Specifying the core tells Drupal what version of Drupal it is built for. <a href="a634af62-2148-4382-9121-b8500df169ed.xhtml"><em><span class="ChapterrefPACKT">Chapter 4</span></em></a>, <em>Extending Drupal</em>, covers how to create a module in depth.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<ol>
<li>Create an <kbd>src</kbd> folder in your module directory. In this directory, create a <kbd>Form</kbd> directory, which will hold the class that defines your form.</li>
<li>Next, create a file called <kbd>ExampleForm.php</kbd> in your module's <kbd>src/Form</kbd> directory.</li>
</ol>
<div class="packt_infobox">Drupal utilizes PSR4 to discover and autoload classes. For brevity, this defines that there should be one class per file, with each filename matching the class name. The folder structure will also mimic the namespace expected.</div>
<ol start="3">
<li>We will edit the <kbd>ExampleForm.php</kbd> file and add the proper PHP namespace, classes used, and the class itself:</li>
</ol>
<pre>&lt;?php 
 
namespace Drupal\drupalform\Form; 
 
use Drupal\Core\Form\FormBase; 
use Drupal\Core\Form\FormStateInterface; 
 
class ExampleForm extends FormBase { 
 
} </pre>
<p style="padding-left: 60px">The <kbd>namespace</kbd> defines the class in your module's <kbd>Form</kbd> directory. The <kbd>autoloader</kbd> will now look at the <kbd>drupalform</kbd> module path and load the <kbd>ExampleForm</kbd> class from the <kbd>src/Form</kbd> directory.</p>
<p style="padding-left: 60px">The use statement allows us to use just the class name when referencing <kbd>FormBase</kbd>, and, in the next steps, <kbd>FormStateInterface</kbd>. Otherwise, we would be forced to use the fully qualified namespace path for each class whenever it is used.</p>
<ol start="4">
<li>The <kbd>\Drupal\Core\Form\FormBase</kbd> is an abstract class and requires us to implement four remaining interface methods: <kbd>getFormId</kbd>, <kbd>buildForm</kbd>, <kbd>validateForm</kbd>, and <kbd>submitForm</kbd>. The latter two will be covered in the following recipes; however, we will need to define the method stubs:</li>
</ol>
<pre style="padding-left: 60px"> 
class ExampleForm extends FormBase { 
 
  /** 
   * {@inheritdoc} 
   */ 
  public function getFormId() { 
    return 'drupalform_example_form'; 
  } 
 
  /** 
   * {@inheritdoc} 
   */ 
  public function buildForm(array $form, FormStateInterface $form_state) { 
     // Return array of Form API elements. 
  } 
 
  /** 
   * {@inheritdoc} 
   */ 
  public function validateForm(array &amp;$form,  FormStateInterface $form_state) { 
    // Validation covered in later recipe, required to satisfy interface. 
  } 
 
  /** 
   * {@inheritdoc} 
   */ 
  public function submitForm(array &amp;$form,  FormStateInterface $form_state) { 
    // Validation covered in later recipe, required to satisfy interface. 
  } 
} </pre>
<p style="padding-left: 60px">This code flushes out the initial class definition from the preceding step. <kbd>FormBase</kbd> provides <kbd>utility</kbd> methods and does not satisfy the interface requirements for <kbd>FormStateInterface</kbd>. We define those here, as they are unique across each form definition.</p>
<p style="padding-left: 60px">The <kbd>getFormId</kbd> method returns a unique string to identify the form, for example, <kbd>site_information</kbd>. You may encounter some forms that append <kbd>_form</kbd> to the end of their form ID. This is not required, and it is just a naming convention often found in previous versions of Drupal.</p>
<div class="packt_infobox">The <kbd>buildForm</kbd> method is covered in the following steps. The <kbd>validateForm</kbd> and <kbd>submitForm</kbd> methods are both called during the Form API processes and are covered in later recipes.</div>
<ol start="5">
<li>The <kbd>buildForm</kbd> method will be invoked to return Form API elements that are rendered to the end user. We will add a simple text field to ask for a company name and a <span class="packt_screen">submit</span> button:</li>
</ol>
<pre style="padding-left: 60px">/** 
 * {@inheritdoc} 
 */ 
public function buildForm(array $form, FormStateInterface $form_state) { 
  $form['company_name'] = [ 
    '#type' =&gt; 'textfield', 
    '#title' =&gt; $this-&gt;t('Company name'), 
  ]; 
  $form['submit'] = [ 
    '#type' =&gt; 'submit', 
    '#value' =&gt; $this-&gt;t('Save'), 
  ]; 
  return $form; 
} </pre>
<p style="padding-left: 60px">We added a form element definition to the <kbd>form</kbd> array. Form elements are defined with a minimum of a type to specify what the element is and a title to act as the label. The title uses the <kbd>t</kbd> method to ensure that it is translatable.</p>
<p style="padding-left: 60px">Adding a <span class="packt_screen">submit</span> button is done by providing an element with the type submit.</p>
<ol start="6">
<li>To access the form, we will create <kbd>drupalform.routing.yml</kbd> in the module's folder. A route entry will be created to instruct Drupal to use <kbd>\Drupal\Core\Form\FormBuilder</kbd> to create and display our form:</li>
</ol>
<pre style="padding-left: 60px">drupalform.form: 
  path: '/drupal-example-form' 
  defaults: 
    _title: 'Example form' 
    _form: '\Drupal\drupalform\Form\ExampleForm' 
  requirements: 
    _access: 'TRUE' </pre>
<p style="padding-left: 60px">In Drupal, all routes have a name, and this example defines it as <kbd>drupalform.form</kbd>. Routes then define a path attribute and override default variables. This route definition has altered the route's title, specified it as a form, and given the fully qualified namespace path to this form's class.</p>
<p style="padding-left: 60px">Routes need to be passed a <kbd>requirements</kbd> property with specifications, or else the route will be denied access.</p>
<ol start="7">
<li>Go to the <span class="packt_screen">Extend</span> page and install the Drupal form example module that we created.</li>
</ol>
<p> </p>
<ol start="8">
<li>Go to <kbd>/drupal-example-form</kbd>, and the form should be now visible, as shown in the following screenshot:</li>
</ol>
<div class="packt_figure CDPAlignCenter CDPAlign"><img class=" image-border" src="assets/a2e8c515-0e51-4f70-bf4f-9f8416de7216.png"/></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How it works...</h1>
                </header>
            
            <article>
                
<p>This recipe creates a route to display the form. By passing the <kbd>_form</kbd> variable in the defaults section of our route entry, we are telling the route controller how to render our route's content. The fully qualified class name, which includes the namespace, is passed to a method located in the form builder. The route controller will invoke <kbd>\Drupal::formBuilder()-&gt;getForm</kbd> (<kbd>\Drupal\drupalform\Form\ExampleForm</kbd>) based on the recipe. At the same time, this can be manually called to embed the form elsewhere.</p>
<p>A form builder instance that implements <kbd>\Drupal\Core\Form\FormBuilderInterface</kbd> will then process the form by calling <kbd>buildForm</kbd> and initiate the rendering process. The <kbd>buildForm</kbd> method is expected to return an array of form elements and other API options. This will be sent to the render system to output the form as HTML.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">There's more...</h1>
                </header>
            
            <article>
                
<p>Many components make up a form created through Drupal's Form API. We will explore a few of them in depth.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Form element definitions</h1>
                </header>
            
            <article>
                
<p>A form is a collection of form elements, which are types of plugin in Drupal 8. Plugins are small pieces of swappable functionalities in Drupal 8. Plugins and plugin development are covered in <a href="3994173f-3d31-4f01-b808-99e01368564b.xhtml"><em><span class="ChapterrefPACKT">Chapter 7</span></em></a>, <em>Plug and Play with Plugins</em>.</p>
<p>Here are some of the most common element properties that can be used:</p>
<ul>
<li><kbd>weight</kbd>: This is used to alter the position of a form element in a form. By default, elements will be displayed in the order in which they were added to the form array. Defining a weight allows a developer to control element positions.</li>
<li><kbd>default_value</kbd>: This gives a developer the ability to prefill the element with a value, for example, when building configuration forms that have existing data or when editing an entity.</li>
<li><kbd>placeholder</kbd>: This is new to Drupal 8. Drupal 8 provides a new HTML5 support, and this attribute will set the placeholder attribute on the HTML input.</li>
</ul>
<div class="packt_infobox">For a complete reference of available form elements and their properties, check out the Drupal.org API documentation page at <a href="https://api.drupal.org/api/drupal/elements/">https://api.drupal.org/api/drupal/elements/</a>.</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The form state</h1>
                </header>
            
            <article>
                
<p>The <kbd>\Drupal\Core\Form\FormStateInterface</kbd> object represents the current state of the form and its data. The form state contains user-submitted data for the form along with build state information. Redirection after the form submission is handled through the<br/>
form state, as well. You will interact more with the form state during the validation and submission recipes.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The form cache</h1>
                </header>
            
            <article>
                
<p>Drupal utilizes a cache table for forms. This holds the build table, as identified by form build identifiers. This allows Drupal to validate forms during AJAX requests and easily build them when required. It is important to keep the form cache in persistent storage; otherwise, there may be repercussions, such as loss of form data or invalidating forms.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">See also</h1>
                </header>
            
            <article>
                
<ul>
<li>Form API in Drupal 8 at <a href="https://www.drupal.org/node/2117411"><span class="URLPACKT">https://www.drupal.org/node/2117411</span></a></li>
<li>The Drupal 8 Form API reference at <a href="https://api.drupal.org/api/drupal/elements/">https://api.drupal.org/api/drupal/elements/</a></li>
<li><span class="ChapterrefPACKT">Refer to <a href="a634af62-2148-4382-9121-b8500df169ed.xhtml"><em>Chapter 4</em></a></span>, <em>Extending Drupal</em></li>
<li><span>Refer to</span> <a href="3994173f-3d31-4f01-b808-99e01368564b.xhtml"><em>Chapter 7</em></a>, <em>Plug and Play with Plugins</em>, to learn more about derivatives</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Using new HTML5 elements</h1>
                </header>
            
            <article>
                
<p>With the release of Drupal 8, Drupal has finally entered into the realm of HTML5. The Form API now allows utilization of HTML5 input elements out of the box. These include the following element types:</p>
<ul>
<li><kbd>tel</kbd></li>
<li><kbd>email</kbd></li>
<li><kbd>number</kbd></li>
<li><kbd>date</kbd></li>
<li><kbd>url</kbd></li>
<li><kbd>search</kbd></li>
<li><kbd>range</kbd></li>
</ul>
<p>This allows your forms in Drupal to leverage native device input methods along with native validation support.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Getting ready</h1>
                </header>
            
            <article>
                
<p>This recipe will walk you through adding elements to a Drupal form. You will need to have a custom form implemented through a module, such as the one created in the <em>Creating a form</em> recipe of this chapter.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<ol>
<li>To use the telephone input, you will need to add a new <kbd>form</kbd> element definition of the <kbd>tel</kbd> type to your <kbd>buildForm</kbd> method:</li>
</ol>
<pre style="padding-left: 60px">$form['phone'] = [ 
  '#type' =&gt; 'tel', 
  '#title' =&gt; $this-&gt;t('Phone'), 
]; </pre>
<ol start="2">
<li>To use the email input, you will need to add a new <kbd>form</kbd> element definition of the <kbd>email</kbd> type to your <kbd>buildForm</kbd> method. It will validate the format of email addresses in the Form API:</li>
</ol>
<pre style="padding-left: 60px">$form['email'] = [ 
  '#type' =&gt; 'email', 
  '#title' =&gt; $this-&gt;t('Email'), 
]; </pre>
<ol start="3">
<li>To use the number input, you will need to add a new <kbd>form</kbd> element definition of the number type to your <kbd>buildForm</kbd> method. It will validate the range and format of the number:</li>
</ol>
<pre style="padding-left: 60px">$form['integer'] = [ 
  '#type' =&gt; 'number', 
  '#title' =&gt; $this-&gt;t('Some integer'), 
  // The increment or decrement amount 
  '#step' =&gt; 1, 
  // Miminum allowed value 
  '#min' =&gt; 0, 
  // Maxmimum allowed value 
  '#max' =&gt; 100, 
];</pre>
<ol start="4">
<li>To use the date input, you will need to add a new <kbd>form</kbd> element definition of the <kbd>date</kbd> type to your <kbd>buildForm</kbd> method. You can also pass the <kbd>#date_date_format</kbd> option to alter the format used by the input:</li>
</ol>
<pre style="padding-left: 60px">$form['date'] = [ 
  '#type' =&gt; 'date', 
  '#title' =&gt; $this-&gt;t('Date'), 
  '#date_date_format' =&gt; 'Y-m-d', 
]; </pre>
<ol start="5">
<li>To use the URL input, you will need to add a new <kbd>form</kbd> element definition of the <kbd>url</kbd> type to your <kbd>buildForm</kbd> method. The element has a validator to check the format of the URL:</li>
</ol>
<pre style="padding-left: 60px">$form['website'] = [ 
  '#type' =&gt; 'url', 
  '#title' =&gt; $this-&gt;t('Website'), 
]; </pre>
<ol start="6">
<li>To use the search input, you will need to add a new <kbd>form</kbd> element definition of the <kbd>search</kbd> type to your <kbd>buildForm</kbd> method. You can specify a route name that the search field will query for autocomplete options:</li>
</ol>
<pre style="padding-left: 60px">$form['search'] = [ 
  '#type' =&gt; 'search', 
  '#title' =&gt; $this-&gt;t('Search'), 
  '#autocomplete_route_name' =&gt; FALSE, 
]; </pre>
<ol start="7">
<li>To use the <kbd>range</kbd> input, you will need to add a new <kbd>form</kbd> element definition of the <kbd>range</kbd> type to your <kbd>buildForm</kbd> method. It is an extension of the number element and accepts <kbd>min</kbd>, <kbd>max</kbd>, and <kbd>step</kbd> properties to control the values of the range input:</li>
</ol>
<pre style="padding-left: 60px">$form['range'] = [ 
  '#type' =&gt; 'range', 
  '#title' =&gt; $this-&gt;t('Range'), 
  '#min' =&gt; 0, 
  '#max' =&gt; 100, 
  '#step' =&gt; 1, 
]; </pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How it works...</h1>
                </header>
            
            <article>
                
<p>Each type references an extended class of <kbd>\Drupal\Core\Render\Element\FormElement</kbd>. It provides the element's definition and additional functions. Each element defines a <kbd>prerender</kbd> method in the class that defines the <kbd>input</kbd> type attribute along with other additional attributes.</p>
<p>Each input defines its theme as <kbd>input__TYPE</kbd>, allowing you to copy the <kbd>input.html.twig</kbd> base to <kbd>input.TYPE.html.twig</kbd> for templating. The template then parses the attributes and renders the HTML.</p>
<p>Some elements, such as emails, provide validators for the element. The email element defines the <kbd>validateEmail</kbd> method. Here is an example of the code from <kbd>\Drupal\Core\Render\Element\Email::valdateEmail</kbd>:</p>
<pre>  /** 
   * Form element validation handler for #type 'email'. 
   * 
   * Note that #maxlength and #required is validated by _form_validate() already. 
   */ 
  public static function validateEmail(&amp;$element, FormStateInterface $form_state, &amp;$complete_form) { 
    $value = trim($element['#value']); 
    $form_state-&gt;setValueForElement($element, $value); 
 
    if ($value !== '' &amp;&amp; !\Drupal::service('email.validator')-&gt;isValid($value)) { 
      $form_state-&gt;setError($element, t('The email address %mail is not valid.', array('%mail' =&gt; $value))); 
    } 
  } </pre>
<p>This code will be executed on form submission and validate the provider's email. It does this by taking the current value and trimming any whitespaces and using the form state object to update the value. The <kbd>email.validator</kbd> service is invoked to validate the email. If this method returns <kbd>false</kbd>, the form state is invoked to mark the element as the one that has an error. If the element has an error, the form builder will prevent form submission, returning the user to the form to fix the value.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">There's more...</h1>
                </header>
            
            <article>
                
<p>Elements are provided through Drupal's plugin system and are explored in detail in the upcoming sections.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Specific element properties</h1>
                </header>
            
            <article>
                
<p>Elements can have their own unique properties along with individual validation methods. You can refer to the available elements through the Drupal.org API documentation page at <a href="https://api.drupal.org/api/drupal/elements/">https://api.drupal.org/api/drupal/elements/</a>. However, the classes can also be examined, and the definition method can be read to learn about the properties of each element. These classes are under the <kbd>\Drupal\Core\Render\Element</kbd> namespace located in <kbd>/core/lib/Drupal/Core/Render/Element</kbd>:</p>
<div class="packt_figure CDPAlignCenter CDPAlign"><img height="319" width="340" class=" image-border" src="assets/554d8884-2cf5-42cf-bad9-000f07982ef5.png"/></div>
<div class="packt_figure"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Creating new elements</h1>
                </header>
            
            <article>
                
<p>Each element used in the Form API extends the <kbd>\Drupal\Core\Render\Element\FormElement</kbd> class, which is a plugin. Modules can provide new element types by adding classes to their <kbd>Plugins/Element</kbd> namespace. Refer to <em><a href="3994173f-3d31-4f01-b808-99e01368564b.xhtml"><span class="ChapterrefPACKT">Chapter 7</span></a></em>, <em>Plug and Play with Plugins</em>, for more information on how to implement a plugin.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">See also</h1>
                </header>
            
            <article>
                
<ul>
<li>Form API in Drupal 8 at <a href="https://www.drupal.org/node/2117411"><span class="URLPACKT">https://www.drupal.org/node/2117411</span></a></li>
<li>Refer to <a href="3994173f-3d31-4f01-b808-99e01368564b.xhtml"><em>Chapter 7</em></a>, Plug and Play with Plugins</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Validating form data</h1>
                </header>
            
            <article>
                
<p>All forms must implement the <kbd>\Drupal\Core\Form\FormInterface</kbd>. The interface defines a <kbd>validation</kbd> method. The <kbd>validateForm</kbd> method is invoked once a form has been submitted and provides a way to validate the data and halt the processing of the data if required. The form state object provides methods for marking specific fields as having the error, providing a user experience tool to alert your users to <span>specify</span> the problem input.</p>
<p>In this recipe, we will be validating the length of the submitted field.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Getting ready</h1>
                </header>
            
            <article>
                
<p>This recipe will use the module and custom form created in the first <em>Creating a form</em> recipe.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<ol>
<li>Open and edit the <kbd>\Drupal\drupalform\Form\ExampleForm</kbd> class in the <kbd>src/Form</kbd> directory of the module.</li>
</ol>
<p> </p>
<ol start="2">
<li>Before validating the <kbd>company_name</kbd> value, we will need to check whether the value is empty using the <kbd>isValueEmpty()</kbd> method from the <kbd>\Drupal\Core\Form\FormStateInterface</kbd> object:</li>
</ol>
<pre style="padding-left: 60px">/** 
 * {@inheritdoc} 
 */ 
public function validateForm(array &amp;$form,  FormStateInterface $form_state) { 
  if (!$form_state-&gt;isValueEmpty('company_name')) { 
    // Value is set, perform validation. 
  } 
} </pre>
<ol start="3">
<li>The <kbd>\Drupal\Form\FormStateInterface::isValueEmpty</kbd> method takes the key name of the form element; for example, <kbd>$form['company_name']</kbd> from the <kbd>buildForm</kbd> method is referenced through <kbd>company_name</kbd> in the <kbd>isValueEmpty</kbd> method.</li>
</ol>
<ol start="4">
<li>Next, we will check whether the value's length is greater than five:</li>
</ol>
<pre style="padding-left: 60px">/**               
 * {@inheritdoc} 
 */ 
public function validateForm(array &amp;$form,  FormStateInterface $form_state) { 
  if (!$form_state-&gt;isValueEmpty('company_name')) { 
    if (strlen($form_state-&gt;getValue('company_name')) &lt;= 5) { 
      // Set validation error. 
    } 
  } 
} </pre>
<ol start="5">
<li>The <kbd>getValue</kbd> takes a form element's key and returns the value. Since we have already verified that the value is not empty, we can retrieve the value.</li>
</ol>
<div class="packt_infobox">If you had any experience with previous versions of Drupal, note that the form state is now an object and not an array.</div>
<ol start="6">
<li>If the logic check finds a value with a length of five or fewer characters, it will throw a form error to prevent submission:</li>
</ol>
<pre style="padding-left: 60px">/** 
 * {@inheritdoc} 
 */ 
public function validateForm(array &amp;$form,  FormStateInterface $form_state) { 
  if (!$form_state-&gt;isValueEmpty('company_name')) { 
    if (strlen($form_state-&gt;getValue('company_name')) &lt;= 5) { 
<strong>      $form_state-&gt;setErrorByName('company_name', t('Company name is less than 5 characters'));</strong> 
    } 
  } 
} </pre>
<p style="padding-left: 60px">We can place the <kbd>setErrorByName</kbd> method in our <kbd>strlen</kbd> logic check. If the string is fewer than five characters, an error is set on the element. The first parameter is the element's key, and the second parameter is the message to be presented to the user.</p>
<ol start="7">
<li>When the form is submitted, the <span class="packt_screen">Company name</span> text field will have more than five characters or be empty to be submitted.</li>
</ol>
<div class="packt_figure CDPAlignCenter CDPAlign"><img class=" image-border" src="assets/ad84a16b-4eaf-4895-9dc9-b60c62ad867d.png"/></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How it works...</h1>
                </header>
            
            <article>
                
<p>Before the form builder service invokes the form object's <kbd>submitForm</kbd> method, it invokes the object's <kbd>validateForm</kbd> method. In the validation method, the form state can be used to check values and perform logic checks. In the event that an item is deemed <em>invalid</em> and an error is set on an element, the form cannot be submitted and will show errors to the user.</p>
<p>When an error is added to an element, an overall counter for the number of errors on the form is incremented. If the form has any errors, the form builder service will not execute the submit method.</p>
<p>This process is executed through the <kbd>\Drupal\Core\Form\FormValidator</kbd> class, which is run through the form builder service.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">There's more...</h1>
                </header>
            
            <article>
                
<p>Form validation can be done through multiple handlers and at the element level. The following sections will cover those.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Multiple validation handlers</h1>
                </header>
            
            <article>
                
<p>A form can have multiple validation handlers. By default, all forms come with at least one validator, which is its own <kbd>validateForm</kbd> method. There is more that can be added. However, by default, the form will merely execute <kbd>::validateForm</kbd> and all element validators. This allows you to invoke methods on other classes or other forms.</p>
<p>If a class provides <kbd>method1</kbd> and <kbd>method2</kbd>, which it would like to execute as well, the following code can be added to the <kbd>buildForm</kbd> method:</p>
<pre>$form_state-&gt;setValidateHandlers([ 
  ['::validateForm'], 
  ['::method1'], 
  [$this, 'method2'], 
]); </pre>
<p>This sets the validator array to execute the default <kbd>validateForm</kbd> method and the two additional methods. You can reference a method in the current class using two colons (<kbd>::</kbd>) and the method name. Alternatively, you can use an array that consists of a class instance and the method to be invoked.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Accessing multidimensional array values</h1>
                </header>
            
            <article>
                
<p>Forms support nested form elements in the form array. The default <kbd>\Drupal\Core\Form\FormStateInterface</kbd> implementation, <kbd>\Drupal\Core\Form\FormState</kbd>, supports accessing multidimensional array values. Instead of passing a string, you can pass an array that represents the parent array structure in the form array.</p>
<p>If the element is defined as <kbd>in $form['company']['company_name']</kbd>, then we will pass <kbd>['company', 'company_name']</kbd> to the form state's methods.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Element validation methods</h1>
                </header>
            
            <article>
                
<p>Form elements can have their own validators. The form state will aggregate all of the element validation methods and pass them to the form validation service. This will run with the form's validation.</p>
<p>There is a <kbd>limit_validation_errors</kbd> option, which can be set to allow selected invalid errors to be passed. This option allows you to bypass validation on specific elements in your form. This is useful if a form has two submit buttons and each intends to validate and submit specific data. This attribute is defined in the submit button, also known as the <em>triggering</em> element in the form state. It is an array value consisting of form element keys.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Processing submitted form data</h1>
                </header>
            
            <article>
                
<p>A form's purpose is to collect data and do something with the data that was submitted. All forms need to implement the <kbd>\Drupal\Core\Form\FormInterface</kbd> interface. The interface defines a submit method. Once the Form API has invoked the class's validation method, the submit method can be run.</p>
<p>This recipe will be based on the custom module and form created in the <em>Creating a form</em> recipe of this chapter. We will convert the form to <kbd>\Drupal\Core\FormConfigBaseForm</kbd>, allowing us to save our configuration and reuse code provided by Drupal core.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Getting ready</h1>
                </header>
            
            <article>
                
<p>In this recipe, we will use the module and custom form created in the first <em>Creating a form</em> recipe.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<ol>
<li>In your module's directory, create a <kbd>config</kbd> directory, and then create a directory inside it named <kbd>install</kbd>.</li>
</ol>
<ol start="2">
<li>Create a file named <kbd>drupalform.schema.yml</kbd> . This file will tell Drupal about the configuration item that we want to save.</li>
</ol>
<ol start="3">
<li>Add the following configuration schema definition to <kbd>drupalform.schema.yml</kbd>:</li>
</ol>
<pre>  drupalform.company: 
    type: config_object 
    label: 'Drupal form settings' 
    mapping: 
      company_name: 
        type: string 
        label: 'A company name' </pre>
<p style="padding-left: 60px">This tells Drupal that we have the configuration with the name <kbd>drupalform.company</kbd>, and it has a valid option of <kbd>company_name</kbd>. We will cover this in more detail in <em><a href="b2659986-a8dc-4503-a043-6071ab7b6722.xhtml">Chapter 9</a></em>, <em>Configuration Management - Deploying in Drupal 8</em>.</p>
<ol start="4">
<li>Next, edit the module's <kbd>src/Form/ExampleForm.php</kbd> file. Replace the <kbd>FormBase</kbd> use statement to use the <kbd>ConfigFormBase</kbd> class:</li>
</ol>
<pre style="padding-left: 60px">&lt;?php 
 
namespace Drupal\drupalform\Form; 
 
<strong>use Drupal\Core\Form\ConfigFormBase;</strong> 
use Drupal\Core\Form\FormStateInterface; </pre>
<ol start="5">
<li>Update the <kbd>ExampleForm</kbd> class to extend <kbd>ConfigFormBase</kbd> instead, to harness its existing methods and provided code:</li>
</ol>
<pre style="padding-left: 60px">&lt;?php <br/><br/>namespace Drupal\drupalform\Form; <br/><br/>use Drupal\Core\Form\ConfigFormBase; <br/>use Drupal\Core\Form\FormStateInterface; <br/><br/><strong>class ExampleForm extends ConfigFormBase {</strong><br/>...<br/>}</pre>
<p style="padding-left: 60px">This allows us to reuse methods from the <kbd>ConfigFormBase</kbd> class and write less about our own implementation.</p>
<ol start="6">
<li>For <kbd>ExampleForm</kbd> to implement <kbd>ConfigFormBase</kbd>, the <kbd>getEditableConfigNames</kbd> method needs to be implemented to satisfy the <kbd>\Drupal\Core\Form\ConfigBaseTrait</kbd> trait. This method can be added anywhere in the class:</li>
</ol>
<pre style="padding-left: 60px">&lt;?php <br/><br/>namespace Drupal\drupalform\Form; <br/><br/>use Drupal\Core\Form\ConfigFormBase; <br/>use Drupal\Core\Form\FormStateInterface; <br/><br/>class ExampleForm extends ConfigFormBase {<br/>...<br/><strong>  /** </strong><br/><strong>   * {@inheritdoc} </strong><br/><strong>   */ </strong><br/><strong>  protected function getEditableConfigNames() { </strong><br/><strong>    return ['drupalform.company']; </strong><br/><strong>  }</strong> <br/>...<br/>}</pre>
<p style="padding-left: 60px">This function defines the configuration names, which will be editable by the form. This brings all the attributes under the <kbd>drupalform.company</kbd> object to be editable when accessed through the form with the <kbd>config</kbd> method provided by <kbd>ConfigFormBaseTrait</kbd>.</p>
<ol start="7">
<li>We will remove the submit form element (<kbd>$form['submit']</kbd>) and update the <kbd>buildForm</kbd> method to return data from the parent's method rather than from <kbd>$form</kbd> itself. We will also need to add a <kbd>#default_value</kbd> option to <kbd>company_name</kbd> so that it uses an existing value the next time our form is loaded:</li>
</ol>
<pre style="padding-left: 60px">/** 
 * {@inheritdoc} 
 */ 
public function buildForm(array $form, FormStateInterface $form_state) { 
  $form['company_name'] = [ 
    '#type' =&gt; 'textfield', 
    '#title' =&gt; $this-&gt;t('Company name'), 
<strong>    '#default_value' =&gt; $this-&gt;config('drupalform.company')-&gt;get('company_name'),</strong> 
  ]; 
<strong>  return parent::buildForm($form, $form_state);</strong> 
} </pre>
<p style="padding-left: 60px">The <kbd>ConfigFormBase</kbd> class implements the <kbd>buildForm</kbd> method to provide a reusable submit button. It also unifies the presentation across Drupal configuration forms:</p>
<div class="packt_figure CDPAlignCenter CDPAlign"><img class=" image-border" src="assets/dd77562a-7943-43c1-9143-1d0b05ff0047.png"/></div>
<ol start="8">
<li>The <kbd>ConfigFormBase</kbd> provides a configuration factory method. We will add a <kbd>default_value</kbd> property to our element with the currently saved item:</li>
</ol>
<pre style="padding-left: 60px">/** 
 * {@inheritdoc} 
 */ 
public function buildForm(array $form, FormStateInterface $form_state) { 
  $form['company_name'] = [ 
    '#type' =&gt; 'textfield', 
    '#title' =&gt; $this-&gt;t('Company name'), 
    '#default_value' =&gt; $this-&gt;config('drupalform.company')-&gt;get('name'), 
  ]; 
  return parent::buildForm($form, $form_state); 
} </pre>
<p style="padding-left: 60px">The <kbd>#default_value</kbd> key is added to the element's definition. It invokes the <kbd>config</kbd> method provided by <kbd>ConfigFormBaseTrait</kbd> to load our configuration group and access a specific configuration value.</p>
<ol start="9">
<li>The final step is to save the configuration in the <kbd>submitForm</kbd> method. Add the following method to your class:</li>
</ol>
<pre style="padding-left: 60px">/** 
 * {@inheritdoc} 
 */ 
public function submitForm(array &amp;$form, FormStateInterface $form_state) { 
  parent::submitForm($form, $form_state); 
  $this-&gt;config('drupalform.company')-&gt;set('name', $form_state-&gt;getValue('company_name')); 
} </pre>
<p style="padding-left: 60px">The <kbd>config</kbd> method is invoked by specifying our configuration group. We will then use the set method to define the name as the value of the <kbd>company name</kbd> text field.</p>
<ol start="10">
<li>Your form class should resemble the following when complete:</li>
</ol>
<pre style="padding-left: 60px" class="mce-root">&lt;?php<br/><br/>namespace Drupal\drupalform\Form;<br/><br/>use Drupal\Core\Form\ConfigFormBase;<br/>use Drupal\Core\Form\FormStateInterface;<br/><br/>class ExampleForm extends ConfigFormBase {<br/><br/>  /**<br/>   * {@inheritdoc}<br/>   */<br/>  protected function getEditableConfigNames() {<br/>      return ['drupalform.company'];<br/>  }<br/><br/>  /**<br/>   * {@inheritdoc}<br/>   */<br/>  public function getFormId() {<br/>    return 'drupalform_example_form';<br/>  }<br/><br/>  /**<br/>   * {@inheritdoc}<br/>   */<br/>  public function buildForm(array $form, FormStateInterface $form_state) {<br/>    $form['company_name'] = array(<br/>      '#type' =&gt; 'textfield',<br/>      '#title' =&gt; t('Company name'),<br/>      '#default_value' =&gt; $this-&gt;config('drupalform.company')-&gt;get('name'),<br/>    );<br/>    return parent::buildForm($form, $form_state);<br/>  }<br/><br/>  /**<br/>   * {@inheritdoc}<br/>   */<br/>  public function validateForm(array &amp;$form, FormStateInterface $form_state) {<br/>    if (!$form_state-&gt;isValueEmpty('company_name')) {<br/>      if (strlen($form_state-&gt;getValue('company_name')) &lt;= 5) {<br/>        $form_state-&gt;setErrorByName('company_name', t('Company name is less than 5 characters'));<br/>      }<br/>    }<br/>  }<br/>  /**<br/>   * {@inheritdoc}<br/>   */<br/>  public function submitForm(array &amp;$form, FormStateInterface $form_state) {<br/>    parent::submitForm($form, $form_state);<br/>    $this-&gt;config('drupalform.company')-&gt;set('name', $form_state-&gt;getValue('company_name'));<br/>  }<br/>}</pre>
<ol start="11">
<li>When you edit your form and click on the <span class="packt_screen">Submit</span> button, the value that you entered in the <span class="packt_screen">Company name</span> field will now be saved in the configuration.</li>
</ol>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How it works...</h1>
                </header>
            
            <article>
                
<p>The <kbd>ConfigFormBase</kbd> utilizes the <kbd>ConfigFormBaseTrait</kbd> to provide easy access to a configuration factory. The class's implementation of <kbd>buildForm</kbd> also adds a <kbd>submit</kbd> button and theme styling to forms. The submit handler displays a configuration saved message, but relies on implementing a module to save the configuration.</p>
<p>The form saves its data under the <kbd>drupalform.company</kbd> namespace. The company name value is stored as <kbd>name</kbd> and can be accessed as <kbd>drupalform.company.name</kbd>. Note that the configuration name does not have to match the form element's key.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">There's more...</h1>
                </header>
            
            <article>
                
<p>In the next section, we will cover how to handle multiple submit callbacks.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Multiple submit handlers</h1>
                </header>
            
            <article>
                
<p>A form can have multiple submit handlers. By default, all forms implement a submit handler, which is its own <kbd>submitForm</kbd> method. The form will execute <kbd>::submitForm</kbd> automatically and any other methods defined on the triggering element. There is more that can be added. However, this allows you to invoke <kbd>static</kbd> methods on other classes or other forms.</p>
<p>If a class provides <kbd>method1</kbd> and <kbd>method2</kbd>, which it would like to execute as well, the following code can be added to the <kbd>buildForm</kbd> method:</p>
<pre>$form_state-&gt;setSubmitHandlers([ 
  ['::submitForm'], 
  ['::method1'], 
  [$this, 'method2'] 
]); </pre>
<p>This sets the submit handler array to execute the default <kbd>submitForm</kbd> method and two additional methods. You can reference a method in the current class using two colons (<kbd>::</kbd>) and the method name. Alternatively, you can use an array consisting of a class instance and the method to be invoked.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">See also</h1>
                </header>
            
            <article>
                
<ul>
<li>Refer to <a href="b2659986-a8dc-4503-a043-6071ab7b6722.xhtml"><em><span class="ChapterrefPACKT">Chapter 9</span></em></a>, <em>Configuration Management- Deploying in Drupal 8</em></li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Altering other forms</h1>
                </header>
            
            <article>
                
<p>Drupal's Form API does not just provide a way to create forms. There are ways to alter forms through a custom module that allows you to manipulate the core and contributed forms. Using this technique, new elements can be added, default values can be changed, or elements can even be hidden from view to simplify the user experience.</p>
<p>The altering of a form does not happen in a custom class; this is a hook defined in the module file. In this recipe, we will use the <kbd>hook_form_FORM_ID_alter()</kbd> hook to add a telephone field to the site's configuration form.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Getting ready</h1>
                </header>
            
            <article>
                
<p>This recipe assumes that you have a custom module to add the code to.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<ol>
<li>In the <kbd>modules</kbd> folder of your Drupal site, create a folder named <kbd>mymodule</kbd>.</li>
</ol>
<ol start="2">
<li>In the <kbd>mymodule</kbd> folder, create a <kbd>mymodule.info.yml</kbd>, containing the following code:</li>
</ol>
<pre style="padding-left: 60px">name: My module 
description: Custom module that uses a form alter 
type: module 
core: 8.x 
 </pre>
<ol start="3">
<li>Next, create a <kbd>mymodule.module</kbd> file in your module's directory:</li>
</ol>
<pre style="padding-left: 60px">&lt;?php 
<br/>/** 
 * @file 
 * Custom module that alters forms. 
 */</pre>
<ol start="4">
<li>Add the <kbd>mymodule_form_system_site_information_settings_alter()</kbd> hook. The form ID can be found by viewing the form's class and reviewing the <kbd>getFormId</kbd> method:</li>
</ol>
<pre style="padding-left: 60px">/** 
 * Implements hook_form_FORM_ID_alter(). 
 */ 
function  mymodule_form_system_site_information_settings_alter(&amp;$form, \Drupal\Core\Form\FormStateInterface $form_state) { 
  // Code to alter form or form state here <br/>}</pre>
<p style="padding-left: 60px"><br/>
Drupal will call this hook and pass the current form array and its form state object. The form array is passed by reference, allowing our hook to modify the array without returning any values. This is why the <kbd>$form</kbd> parameter has the ampersand (<kbd>&amp;</kbd>) before it. In PHP, all objects are passed by reference, which is why we have no ampersand (<kbd>&amp;</kbd>) before <kbd>$form_state</kbd>.</p>
<div style="padding-left: 60px" class="packt_infobox"><span>When calling a class in a normal file, such as the module file, you will need to either use the fully qualified class name or add a use statement at the beginning of the file. In this example, we can add</span> <kbd>\Drupal\Core\Form\FormStateInterface</kbd><span>.</span></div>
<ol start="5">
<li>Next, we add our <kbd>telephone</kbd> field to the form so that it can be displayed and saved:</li>
</ol>
<pre style="padding-left: 60px">/** 
 * Implements hook_form_FORM_ID_alter(). 
 */ 
function  mymodule_form_system_site_information_settings_alter(&amp;$form, \Drupal\Core\Form\FormStateInterface $form_state) { 
  $form['site_phone'] = [ 
    '#type' =&gt; 'tel', 
    '#title' =&gt; t('Site phone'), 
    '#default_value' =&gt; Drupal::config('system.site')-&gt;get('phone'), 
  ]; 
} </pre>
<p style="padding-left: 60px">We retrieve the current phone value from <kbd>system.site</kbd> so that it can be modified if already set.</p>
<ol start="6">
<li>Go to the <span class="packt_screen">Extend</span> page and install the module <span class="packt_screen">My module</span> that we created.</li>
</ol>
<ol start="7">
<li>Note the <span class="packt_screen">Basic site settings</span> form under <span class="packt_screen">Configuration</span>, and test setting the site telephone number:
<div class="packt_figure CDPAlignCenter CDPAlign"><img class=" image-border" src="assets/78bcb6ee-530d-47ac-8dad-96d3cad03fc9.png"/></div>
</li>
<li>We then need to add a submit handler in order to save the configuration for our new field. We will need to add a submit handler to the form and a submit handler callback:</li>
</ol>
<pre style="padding-left: 60px">/** 
 * Implements hook_form_FORM_ID_alter(). 
 */ 
function  mymodule_form_system_site_information_settings_alter(&amp;$form, \Drupal\Core\Form\FormStateInterface $form_state) { 
  $form['site_phone'] = [ 
   '#type' =&gt; 'tel', 
   '#title' =&gt; t('Site phone'), 
   '#default_value' =&gt; Drupal::config('system.site')-&gt;get('phone'), 
  ]; 
  $form['#submit'][] = 'mymodule_system_site_information_phone_submit'; 
} 
 
/** 
 * Form callback to save site_phone 
 * @param array $form 
 * @param \Drupal\Core\Form\FormStateInterface $form_state 
*/ 
function mymodule_system_site_information_phone_submit(array &amp;$form,  \Drupal\Core\Form\FormStateInterface $form_state) { 
  $config = Drupal::configFactory()-&gt;getEditable('system.site'); 
  $config 
  -&gt;set('phone', $form_state-&gt;getValue('site_phone')) 
  -&gt;save(); 
} 
The $form['#submit'] modification adds our callback to the form's submit handlers. This allows our module to interact with the form once it has been submitted. 
The mymodule_system_site_information_phone_submit callback is passed the form array and form state. We load the current configuration factory to receive the configuration that can be edited. We then load system.site and save phone based on the value from the form state. </pre>
<ol start="9">
<li>Submit the form, and verify that the data has been saved.</li>
</ol>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How it works...</h1>
                </header>
            
            <article>
                
<p>The <kbd>\Drupal\system\Form\SiteInformationForm</kbd> class extends <kbd>\Drupal\Core\Form\ConfigFormBase</kbd> to handle the writing of form elements as individual configuration values. However, it does not write the values automatically to the form state. In this recipe, we needed to add a submit handler to manually save our added field via a procedural function in our <kbd>mymodule.module</kbd> file.</p>
<p>The form array is passed by reference, allowing modifications to be made in the hook to alter the original data. This allows us to add an element or even modify existing items, such as titles or descriptions.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">There's more...</h1>
                </header>
            
            <article>
                
<p>We will discuss how to add additional handlers to other forms using form alters.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Adding additional validate handlers</h1>
                </header>
            
            <article>
                
<p>Using a form alter hook, we can add additional validators to a form. The proper way to do this is to load the current validators and add the new one to the array and reset the validators in the form state:</p>
<pre>$validators = $form_state-&gt;getValidateHandlers(); 
$validators[] = 'mymodule_form_validate'; 
$form_state-&gt;setValidateHandlers($validators); </pre>
<p>First, we will receive all of the currently set validators from the form state as the <kbd>$validators</kbd> variable. We then append a new callback to the end of the array. Once the <kbd>$validators</kbd> variable has been modified, we will override the form state's validator array by executing the <kbd>setValidateHandlers</kbd> method.</p>
<div class="packt_infobox">You can also use PHP array manipulation functions to add your validators in different execution orders. For example, <kbd>array_unshift</kbd> will place your validator at the beginning of the array so that it can run first.</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Adding additional submit handlers</h1>
                </header>
            
            <article>
                
<p>Using a form alter hook, we can add additional submit handlers to a form. The proper way to do this is to load the current submit handlers, add the new one to the array, and reset the validators in the form state:</p>
<pre>$submit_handlers = $form_state-&gt;getSubmitHandlers(); 
$submit_handlers[] = 'mymodule_form_submit'; 
$form_state-&gt;setSubmitHandlers($submit_handlers ); </pre>
<p>First, we will receive all of the currently set submit handlers from the form state as the <kbd>$submit_handlers</kbd> variable. We then append a new callback to the end of the array.<br/>
Once the <kbd>$submit_handlers</kbd> variable has been modified, we will override the form state's submit handler array by executing the <kbd>setSubmitHandlers</kbd> method.</p>
<div class="packt_infobox">You can also use PHP array manipulation functions to add your callback in different execution orders. For example, <kbd>array_unshift</kbd> will place your callback at the beginning of the array so that it can run first.</div>


            </article>

            
        </section>
    </body></html>