<html><head></head><body>
        <section>

                            <header>
                    <h1 class="header-title">Adding New Widgets to the WordPress Library</h1>
                </header>
            
            <article>
                
<p>In this chapter, you will learn how to create your own widget through the following topics:</p>
<ul>
<li>Creating a new widget in WordPress</li>
<li>Displaying configuration options</li>
<li>Validating configuration options</li>
<li>Implementing the widget display function</li>
<li>Adding a custom dashboard widget</li>
<li>Adding a custom widget to the network dashboard</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Introduction</h1>
                </header>
            
            <article>
                
<p>Widgets have been present in WordPress from the early days of the platform. They allow users to easily populate sidebars or other areas of their website theme with blocks of content that are provided by WordPress itself (post or page data), or by any plugins that have been installed (for example, bug tracking system information). Looking at a WordPress installation, the default set of widgets include the Archives widget, which lists monthly post archives, and the Recent Comments widget, which provides an easy way to display visitor comments stored on your WordPress website.</p>
<p>Following its open design, WordPress provides functions that allow plugin developers to create new widgets that users will be able to add to their page design. This chapter shows how to use the widget class to create a custom widget. It also covers the second type of widget, the dashboard widget, which can be used to display plugin-specific information on the front page of the administrative area.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Creating a new widget in WordPress</h1>
                </header>
            
            <article>
                
<p>The first step in creating a custom widget is to define its name and indicate which class contains all of its implementation functions. Once the new element has been registered with the system, it will immediately appear in the widget list, where users will be able to drag and drop it to their sidebars.</p>
<p>This recipe defines a new widget that displays recent book reviews from the custom post type category created in <a href="6298bc2b-19d5-4e3a-833c-3c4b667b22e5.xhtml"><span class="ChapterrefPACKT">Chapter 4</span></a>, <em>The Power of Custom Post Types</em>.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Getting ready</h1>
                </header>
            
            <article>
                
<p>You should have already followed the <em>Updating page title to include custom post data using plugin filters</em> recipe from <a href="">Chapter 4</a>, <em>The Power of Custom Post Types</em>, to have a starting point for this recipe. Alternatively, you can get the resulting code (<kbd>Chapter 4/ch4-book-reviews/ch4-book-reviews-v11.php</kbd>) from the code bundle and activate the <kbd>Chapter 4 - Book Reviews</kbd> plugin.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<ol>
<li>Navigate to the WordPress plugin directory of your development installation.</li>
<li>Create a new directory called <kbd>ch10-book-review-widget</kbd>.</li>
<li>Navigate to the directory and create a text file called <kbd>ch10-book-review-widget.php</kbd>.</li>
<li>Open the new file in a code editor and add an appropriate header at the top of the plugin file, naming the plugin <kbd>Chapter 10 - Book Review Widget</kbd>.</li>
<li>Add the following line of code to register a function to be called when widgets are initialized:</li>
</ol>
<pre style="padding-left: 60px">add_action( 'widgets_init', 'ch10brw_create_widgets' ); </pre>
<ol start="6">
<li>Add the following code segment to provide an implementation for the <kbd>ch10brw_create_widgets</kbd> function:</li>
</ol>
<pre style="padding-left: 60px">function ch10brw_create_widgets() { <br/>    register_widget( 'Book_Reviews' ); <br/>} </pre>
<ol start="7">
<li>Insert the following block of code to declare the <kbd>Book_Reviews</kbd> class along with its constructor method:</li>
</ol>
<pre style="padding-left: 60px">class Book_Reviews extends WP_Widget { <br/>    // Construction function <br/>    function __construct () { <br/>        parent::__construct( 'book_reviews', 'Book Reviews',<br/>            array( 'description' =&gt;                                     <br/>                   'Displays list of recent book reviews' ) ); <br/>    } <br/>} </pre>
<ol start="8">
<li>Save and close the plugin file.</li>
<li>Navigate to the <span class="packt_screen">Plugins</span> management page and <span class="packt_screen">Activate</span> the <kbd>Chapter 10 - Book Review Widget</kbd> plugin.</li>
<li>Visit the <span class="packt_screen">Widgets</span> section of the <span class="packt_screen">Appearance</span> administration page to see the newly created <span class="packt_screen">Book Reviews</span> widget appear as part of the list of <span class="packt_screen">Available Widgets</span>.</li>
<li>Drag and drop the new widget to one of the available sidebars listed on the right-hand side to create a widget instance, and see that the widget currently has no available options to configure it:</li>
</ol>
<div class="CDPAlignCenter CDPAlign"><img height="180" width="529" class="image-border" src="assets/32e68aaf-3f26-4409-af25-a9f363411243.png"/></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How it works...</h1>
                </header>
            
            <article>
                
<p>The <kbd>widgets_init</kbd> action hook is used to register a function to be executed when widgets are being created by WordPress. When the callback occurs, we create a new widget by calling the simple <kbd>register_widget</kbd> function. As can be seen in the recipe, this function requires a single argument that indicates the name of the class that contains the widget definition.</p>
<p>The rest of the recipe declares the widget implementation class, which extends the WordPress <kbd>WP_Widget</kbd> class. While the class has many potential member methods, this recipe only defines the class constructor, which initializes the object instance by specifying a unique identifier, a title, and a description embedded within an array of optional parameters. As with any other functions declared in plugins, it is important to give unique names to the widget class and widget identifier in order to avoid conflict with other plugins.</p>
<p>When the plugin is activated, users can see the new widget immediately and are able to add one or more instances of the new element as part of a sidebar's content. However, the new widget will not render anything other than an error message on website pages until its <kbd>widget</kbd> method is implemented in a later recipe in this chapter.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">There's more...</h1>
                </header>
            
            <article>
                
<p>As you may have noticed, this recipe creates a separate plugin file and directory from the main book review plugin created in <a href="6298bc2b-19d5-4e3a-833c-3c4b667b22e5.xhtml"><span class="ChapterrefPACKT">Chapter 4</span></a>, <em>The Power of Custom Post Types</em>.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Plugins extending other plugins</h1>
                </header>
            
            <article>
                
<p>While we could have placed the widget creation code in the same file as the book review plugin, placing it in a separate file is just as valid. Some plugins distributed on the official <a href="http://wordpress.org"><span class="URLPACKT">wordpress.org</span></a> repository actually use that technique to break up their functionality into more manageable code segments. The only thing to be careful of with this technique is to be sure that all the elements that a secondary plugin is dependent upon are loaded before referring to them in callback functions.</p>
<p>In this case, since widgets are created late in the WordPress initialization process, the custom post type that will be required by the widget will be available.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">See also</h1>
                </header>
            
            <article>
                
<ul>
<li>The <em>Updating page title to include custom post data using plugin filters</em> recipe in <a href="6298bc2b-19d5-4e3a-833c-3c4b667b22e5.xhtml"><span class="ChapterrefPACKT">Chapter 4</span></a>, <em>The Power of Custom Post Types</em></li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Displaying configuration options</h1>
                </header>
            
            <article>
                
<p>Similar to the plugin configuration pages, widgets can have one or more options to allow users to specify how some aspects of the component will behave. These options can be configured individually for each instance of a widget that is added to a website layout. To handle all of the logistics around multiple possible widget instances, WordPress actually takes care of most of the data handling and storage tasks.</p>
<p>This recipe shows how to add a new method to the book review widget class to display configuration options.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Getting ready</h1>
                </header>
            
            <article>
                
<p>You should have already followed the <em>Creating a new widget in WordPress</em> recipe to have a starting point for this recipe. Alternatively, you can get the resulting code (<kbd>Chapter 10/ch10-book-review-widget/ch10-book-review-widget-v1.php</kbd>) from the code bundle and rename the file as <kbd>ch10-book-review-widget.php</kbd>.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<ol>
<li>Navigate to the WordPress plugin directory of your development installation.</li>
<li>Navigate to the <kbd>ch10-book-review-widget</kbd> directory and edit <kbd>ch10-book-review-widget.php</kbd>.</li>
<li>Find the <kbd>Book_Reviews</kbd> class and add the following block of code within the class to define the <kbd>form</kbd> method:</li>
</ol>
<pre style="padding-left: 60px">function form( $instance ) { <br/>    // Retrieve previous values from instance <br/>    // or set default values if not present <br/>    $render_widget = ( !empty( $instance['render_widget'] ) ? <br/>                       $instance['render_widget'] : 'true' ); <br/> <br/>    $nb_book_reviews = ( !empty( $instance['nb_book_reviews'] ) ? <br/>                         $instance['nb_book_reviews'] : 5 ); <br/> <br/>    $widget_title = ( !empty( $instance['widget_title'] ) ?  <br/>                      esc_attr( $instance['widget_title'] ) : <br/>                      'Book Reviews' );            <br/>    ?&gt;<br/> <br/>    &lt;!-- Display fields to specify title and item count --&gt; <br/>    &lt;p&gt; <br/>        &lt;label for="&lt;?php echo  <br/>                    $this-&gt;get_field_id( 'render_widget' ); ?&gt;"&gt; <br/>        &lt;?php echo 'Display Widget'; ?&gt;             <br/>        &lt;select id="&lt;?php echo <br/>                     $this-&gt;get_field_id( 'render_widget' ); ?&gt;"<br/>                name="&lt;?php echo <br/>                $this-&gt;get_field_name( 'render_widget' ); ?&gt;"&gt; <br/>            &lt;option value="true" <br/>                &lt;?php selected( $render_widget, 'true' ); ?&gt;&gt; <br/>            Yes&lt;/option&gt; <br/>            &lt;option value="false" <br/>                &lt;?php selected( $render_widget, 'false' ); ?&gt;&gt; <br/>            No&lt;/option&gt; <br/>        &lt;/select&gt;                     <br/>        &lt;/label&gt; <br/>    &lt;/p&gt; <br/>    &lt;p&gt; <br/>        &lt;label for="&lt;?php echo  <br/>                    $this-&gt;get_field_id( 'widget_title' ); ?&gt;"&gt; <br/>        &lt;?php echo 'Widget Title:'; ?&gt;             <br/>        &lt;input type="text"  <br/>               id="&lt;?php echo <br/>                    $this-&gt;get_field_id( 'widget_title' );?&gt;"<br/>               name="&lt;?php<br/>               echo $this-&gt;get_field_name( 'widget_title' ); ?&gt;" <br/>               value="&lt;?php echo $widget_title; ?&gt;" /&gt;             <br/>        &lt;/label&gt; <br/>    &lt;/p&gt;  <br/>    &lt;p&gt; <br/>        &lt;label for="&lt;?php echo  <br/>                    $this-&gt;get_field_id( 'nb_book_reviews' ); ?&gt;"&gt; <br/>        &lt;?php echo 'Number of reviews to display:'; ?&gt;             <br/>        &lt;input type="text"  <br/>               id="&lt;?php echo <br/>                   $this-&gt;get_field_id( 'nb_book_reviews' ); ?&gt;"<br/>               name="&lt;?php echo <br/>               $this-&gt;get_field_name( 'nb_book_reviews' ); ?&gt;" <br/>               value="&lt;?php echo $nb_book_reviews; ?&gt;" /&gt;             <br/>        &lt;/label&gt; <br/>    &lt;/p&gt; <br/>&lt;?php } </pre>
<ol start="4">
<li>Save and close the plugin file.</li>
<li>Refresh the <span class="packt_screen">Appearance</span> | <span class="packt_screen">Widgets</span> administration page and expand the <span class="packt_screen">Book Reviews</span> widget instance to see the newly created options.</li>
<li>Change the widget options and click on <span class="packt_screen">Save</span> to update its configuration:</li>
</ol>
<div class="CDPAlignCenter CDPAlign"><img height="212" width="353" class="image-border" src="assets/508cf006-79e8-4c98-b823-8fcb7ff4525a.png"/></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How it works...</h1>
                </header>
            
            <article>
                
<p>When users create a new widget instance, WordPress automatically manages configuration options for that element using an array variable. It also calls the widget class' <kbd>form</kbd> method, if present, to render the widget instance's options in a configuration panel.</p>
<p>The first few lines of code in the <kbd>form</kbd> method verify that the <kbd>instance</kbd> array contains proper values that specify whether the widget should be displayed, the number of book reviews to be shown, and the title that should be displayed at the beginning of the widget. If any of these options are missing, we use the PHP ternary conditional operator (<kbd>?:</kbd>) to assign default values to the <kbd>render_widget</kbd>, <kbd>nb_book_reviews</kbd>, and <kbd>widget_title</kbd> functions. This operator expects three expressions, ordered as follows: <kbd>(expr1)?(expr2):(expr3)</kbd>. It will then return <kbd>expr2</kbd> if <kbd>expr1</kbd> is true and <kbd>expr3</kbd> if it's false.</p>
<p>With these variables in place, the rest of the <kbd>form</kbd> method's code uses a mix of HTML and PHP code to render the configuration fields that are shown in the widget editor. The <kbd>get_field_id</kbd> and <kbd>get_field_name</kbd> methods, seen throughout this code, are used to generate unique identifiers that will help WordPress to store data separately for all widget instances.</p>
<p>As can be seen in this recipe, the widget class is able to automatically process and save widget configuration parameters. However, it should be noted that allowing WordPress to handle this task by itself means that no validation will be performed on the data entered. This could cause problems if a user enters text instead of the number of reviews to be displayed. The next recipe shows how to handle data validation.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">See also</h1>
                </header>
            
            <article>
                
<ul>
<li>The <em>Creating a new widget in WordPress</em> recipe</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Validating configuration options</h1>
                </header>
            
            <article>
                
<p>The widget configuration panel that was put in place in the previous recipe was functional, allowing users to change options and save updated values in the website database. That being said, all WordPress does by default when the user saves a widget is store values directly to the site database. Since accepting user data blindly can lead to functionality problems and security risks if wrong or malicious values are entered, it is preferable to add data validation rules through the creation of an <kbd>update</kbd> method that will be able to verify configuration data before it is saved. This recipe shows how to implement a widget's <kbd>update</kbd> method.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Getting ready</h1>
                </header>
            
            <article>
                
<p>You should have already followed the <em>Displaying configuration options</em> recipe to have a starting point for this recipe. Alternatively, you can get the resulting code (<kbd>Chapter 10/ch10-book-review-widget/ch10-book-review-widget-v2.php</kbd>) from the code bundle and rename the file as <kbd>ch10-book-review-widget.php</kbd>.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<ol>
<li>Navigate to the WordPress plugin directory of your development installation.</li>
<li>Navigate to the <kbd>ch10-book-review-widget</kbd> directory and edit <kbd>ch10-book-review-widget.php</kbd>.</li>
<li>Find the <kbd>Book_Reviews</kbd> class and add the following block of code within the class to define the <kbd>update</kbd> method:</li>
</ol>
<pre style="padding-left: 60px">function update( $new_instance, $instance ) { <br/>    // Only allow numeric values <br/>    if ( is_numeric ( $new_instance['nb_book_reviews'] ) ) {<br/>        $instance['nb_book_reviews'] =<br/>            intval( $new_instance['nb_book_reviews'] );<br/>    } else {<br/>        $instance['nb_book_reviews'] =<br/>            $instance['nb_book_reviews'];<br/>    }<br/>         <br/>    $instance['widget_title'] =<br/>        sanitize_text_field( $new_instance['widget_title'] ); <br/> <br/>    $instance['render_widget'] = <br/>        sanitize_text_field( $new_instance['render_widget'] );      <br/> <br/>    return $instance; <br/>}    </pre>
<ol start="4">
<li>Save and close the plugin file.</li>
<li>Visit the <span class="packt_screen">Widgets</span> section of the <span class="packt_screen">Appearance</span> administration page and expand the <span class="packt_screen">Book Reviews</span> widget instance.</li>
<li>Enter a textual value in the <span class="packt_screen">Number of reviews to display</span> field and save the widget. You will see that the field's value reverts to the last valid number saved for this field.</li>
</ol>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How it works...</h1>
                </header>
            
            <article>
                
<p>The <kbd>update</kbd> method receives two arrays of data and must return a single array to be saved in the website database. The two incoming arrays contain the new option values entered by the user and the values that were previously stored for the widget, respectively.</p>
<p>To start from known values, the method's implementation starts by making a copy of the old values to a new variable called <kbd>$instance</kbd>. It follows this initialization by calling the <kbd>sanitize_text_field</kbd> function to remove potentially harmful HTML or PHP tags from text fields, saving the return value in the <kbd>$instance</kbd> array. It also calls the PHP <kbd>is_numeric</kbd> and <kbd>intval</kbd> functions on entry, indicating the number of reviews to be displayed to make sure that it's a numeric value. If anything other than a number is entered, the previous field value will be saved and displayed back to the user. Unfortunately, it is not possible to display an error message when this type of validation of widget options is performed.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">See also</h1>
                </header>
            
            <article>
                
<ul>
<li>The <em>Displaying configuration options</em> recipe</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Implementing the widget display function</h1>
                </header>
            
            <article>
                
<p>For all of the widget creation work that we have done so far, our new creation does not display any content on the website yet. When displaying an area that contains widgets, WordPress tries to call a method named <kbd>widget</kbd> for each user-selected widget to output the desired content to the browser.</p>
<p>This recipe shows how to implement a <kbd>widget</kbd> method to display a list of recent book reviews when the widget is instantiated in a sidebar.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Getting ready</h1>
                </header>
            
            <article>
                
<p>You should have already followed the <em>Validating configuration options</em> recipe to have a starting point for this recipe. Alternatively, you can get the resulting code (<kbd>Chapter 10/ch10-book-review-widget/ch10-book-review-widget-v3.php</kbd>) from the code bundle and rename the file as <kbd>ch10-book-review-widget.php</kbd>.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<ol>
<li>Navigate to the WordPress plugin directory of your development installation.</li>
<li>Navigate to the <kbd>ch10-book-review-widget</kbd> directory and edit <kbd>ch10-book-review-widget.php</kbd>.</li>
<li>Find the <kbd>Book_Reviews</kbd> class and add the following block of code within the class to define the <kbd>widget</kbd> method:</li>
</ol>
<pre style="padding-left: 60px">function widget( $args, $instance ) { <br/>    if ( 'true' == $instance['render_widget'] ) { <br/>        // Extract members of args array as individual variables <br/>        extract( $args );<br/> <br/>        // Retrieve widget configuration options <br/>        $nb_book_reviews = <br/>             ( !empty( $instance['nb_book_reviews'] ) ? <br/>                       $instance['nb_book_reviews'] : 5 ); <br/> <br/>        $widget_title = ( !empty( $instance['widget_title'] ) ?  <br/>                          esc_attr( $instance['widget_title'] ) : <br/>                          'Book Reviews' ); <br/> <br/>        // Preparation of query string to retrieve book reviews <br/>        $query_array = array( 'post_type' =&gt; 'book_reviews', <br/>                              'post_status' =&gt; 'publish', <br/>                              'posts_per_page' =&gt; <br/>                                  $nb_book_reviews ); <br/> <br/>        // Execution of post query <br/>        $book_review_query = new WP_Query(); <br/>        $book_review_query-&gt;query( $query_array );  <br/> <br/>        // Display widget title <br/>        echo $before_widget . $before_title; <br/>        echo apply_filters( 'widget_title', $widget_title ); <br/>        echo $after_title;  <br/> <br/>        // Check if any posts were returned by query <br/>        if ( $book_review_query-&gt;have_posts() ) {             <br/>            // Display posts in unordered list layout <br/>            echo '&lt;ul&gt;'; <br/> <br/>            // Cycle through all items retrieved <br/>            while ( $book_review_query-&gt;have_posts() ) { <br/>                $book_review_query-&gt;the_post(); <br/>                echo '&lt;li&gt;&lt;a href="' . get_permalink() . '"&gt;'; <br/>                echo get_the_title( get_the_ID() ) . '&lt;/a&gt;&lt;/li&gt;'; <br/>            } <br/>            echo '&lt;/ul&gt;';  <br/>        } <br/>        wp_reset_query(); <br/>        echo $after_widget; <br/>    } <br/>} </pre>
<ol start="4">
<li>Save and close the plugin file.</li>
<li>Visit the website's front page to see the newly added widget contents displayed in the sidebar:</li>
</ol>
<div class="mce-root CDPAlignCenter CDPAlign"><img height="175" width="243" class="image-border" src="assets/eb74f96f-d123-4879-b1e6-1eaa960a94d0.png"/></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How it works...</h1>
                </header>
            
            <article>
                
<p>Similar to action hooks that we have seen in the earlier chapters, the <kbd>widget</kbd> method is meant to directly output HTML code to the browser that will be displayed when an instance of the new widget has been created in a sidebar.</p>
<p>The <kbd>widget</kbd> method starts by checking whether or not the widget should be displayed. If it should, it continues by calling the standard PHP <kbd>extract</kbd> function on the first parameter received, an array named <kbd>$args</kbd>. Calling this function parses the array and creates variables for each element found, making it easier for the following code to access the elements that should be placed before and after the widget title and widget content.</p>
<p>After this initial statement, the recipe continues by retrieving the number of items to display and the widget title from the <kbd>$instance</kbd> array, which has been received as the second method parameter using the same technique that was shown when implementing the <kbd>form</kbd> method.</p>
<p>The rest of the code is very similar to the book review shortcode created in <a href="6298bc2b-19d5-4e3a-833c-3c4b667b22e5.xhtml"><em><span class="ChapterrefPACKT">Chapter</span> <span class="ChapterrefPACKT">4</span></em></a>, <em>The Power of Custom Post Types</em> (displaying custom post type data in shortcodes), where we assemble a query string that indicates the type and maximum quantity of data that we want to retrieve from the database. The resulting query is executed by creating a new instance of the WordPress <kbd>WP_Query</kbd> object. If results are found, the following recipe code cycles through all the entries and outputs code to render an unordered list of all the items found. Last, but not least, the recipe formats the widget content by outputting the values of the <kbd>$before_widget</kbd>, <kbd>$after_widget</kbd>, <kbd>$before_title</kbd>, and <kbd>$after_title</kbd> widget class variables, and the user-specified widget title in the right places.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">See also</h1>
                </header>
            
            <article>
                
<ul>
<li>The <em>Creating a new widget in WordPress</em> recipe</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Adding a custom dashboard widget</h1>
                </header>
            
            <article>
                
<p>While widgets are primarily used by website administrators to easily add content to their front-facing websites, WordPress contains another type of widget that plugin developers can use to enhance user experience. Dashboard plugins are sections that appear on the front page of a website's administration area. These sections can offer any kind of functionality, from simple information displays indicating how much data is stored in a plugin to forms that allow website administrators to quickly perform configuration tasks.</p>
<p>This recipe shows how to add a new dashboard widget that indicates how many book reviews are stored in the system, along with links to quickly access them.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Getting ready</h1>
                </header>
            
            <article>
                
<p>You should have already followed the <em>Updating page title to include custom post data using plugin filters</em> recipe from <a href="6298bc2b-19d5-4e3a-833c-3c4b667b22e5.xhtml"><span class="ChapterrefPACKT">Chapter</span> <span class="ChapterrefPACKT">4</span></a>, <em>The Power of Custom Post Types</em>, to have a starting point for this recipe. Alternatively, you can get the resulting code (<kbd>Chapter 4/ch4-book-reviews/ch4-book-reviews-v11.php</kbd>) from the code bundle and activate the <kbd>Chapter 4 - Book Reviews</kbd> plugin.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<ol>
<li>Navigate to the WordPress plugin directory of your development installation.</li>
<li>Create a new directory called <kbd>ch10-book-review-dashboard-widget</kbd>.</li>
<li>Navigate to the directory and create a text file called <kbd>ch10-book-review-dashboard-widget.php</kbd>.</li>
<li>Open the new file in a code editor and add an appropriate header at the top of the plugin file, naming the plugin <kbd>Chapter 10 - Book Review Dashboard Widget</kbd>.</li>
<li>Add the following line of code to register a function to be called when the dashboard contents are being prepared:</li>
</ol>
<pre style="padding-left: 60px">add_action( 'wp_dashboard_setup', <br/>            'ch10brdw_add_dashboard_widget' ); </pre>
<ol start="6">
<li>Add the following code segment to provide an implementation for the <kbd>ch10brdw_add_dashboard_widget</kbd> function:</li>
</ol>
<pre style="padding-left: 60px">function ch10brdw_add_dashboard_widget() { <br/>    wp_add_dashboard_widget( 'book_reviews_dashboard_widget', <br/>                             'Book Reviews', <br/>                             'ch10brdw_dashboard_widget' ); <br/>} </pre>
<ol start="7">
<li>Insert the following block of code to implement the <kbd>ch10brdw_dashboard_widget</kbd> function declared in the previous step:</li>
</ol>
<pre style="padding-left: 60px">function ch10brdw_dashboard_widget() {  <br/>    $book_review_count = wp_count_posts( 'book_reviews' ); <br/>    if ( !empty( (array) $book_review_count ) ) {<br/>    ?&gt; <br/>    &lt;a href="&lt;?php echo add_query_arg( array(  <br/>                                  'post_status' =&gt; 'publish', <br/>                                  'post_type' =&gt; 'book_reviews' ), <br/>                                  admin_url( 'edit.php' ) ); ?&gt;"&gt; <br/>    &lt;strong&gt; <br/>          &lt;?php echo $book_review_count-&gt;publish; ?&gt; <br/>    &lt;/strong&gt; Published <br/>    &lt;/a&gt; <br/>    &lt;br /&gt; <br/>    &lt;a href="&lt;?php echo add_query_arg( array(  <br/>                                  'post_status' =&gt; 'draft', <br/>                                  'post_type' =&gt; 'book_reviews' ),  <br/>                                  admin_url( 'edit.php' ) ); ?&gt;"&gt; <br/>    &lt;strong&gt; <br/>        &lt;?php echo $book_review_count-&gt;draft; ?&gt; <br/>    &lt;/strong&gt; Draft <br/>    &lt;/a&gt; <br/>&lt;?php }<br/>}</pre>
<ol start="8">
<li>Save and close the plugin file.</li>
<li>Navigate to the <span class="packt_screen">Plugins</span> management page and <span class="packt_screen">Activate</span> the <kbd>Chapter 10 - Book Review Dashboard Widget</kbd> plugin.</li>
<li>Navigate to the website's <span class="packt_screen">Dashboard</span> to see the new <span class="packt_screen">Book Reviews</span> widget at the bottom of the page, as shown in the following screenshot:</li>
</ol>
<div class="CDPAlignCenter CDPAlign"><img height="109" width="354" class="image-border" src="assets/af35d77c-3218-493a-a65e-4da723b1f0e4.png"/></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How it works...</h1>
                </header>
            
            <article>
                
<p>Any plugin can register its own dashboard widget when WordPress is putting together content for this administrative landing page. After registering a function to be called during the dashboard setup phase, our recipe makes a call to the <kbd>wp_add_dashboard_widget</kbd> function to add our own element to the website when the callback is executed. The <kbd>wp_add_dashboard_widget</kbd> function requires three parameters that need to provide a unique identifier for the new item, a title to be displayed at the top of the widget, and a function that will be responsible for generating the widget's contents. The <kbd>wp_add_dashboard_widget</kbd> function also has an optional fourth parameter that can be used when the widget needs to process form data as part of the dashboard widget contents.</p>
<p>As can be seen in the previous screenshot, dashboard widgets are displayed using WordPress meta boxes, where any HTML code echoed by the content display function directly appears in the box.</p>
<p>While the display function is mostly composed of HTML code, we also make a call to the <kbd>wp_count_posts</kbd> utility function, which easily returns the number of posts for a given post type.</p>
<p>The new widget can be hidden and moved to a new location on the Dashboard, like any other built-in widget. Just like the front-facing widget plugin created earlier in this chapter, it should be noted that all the code in this plugin is in a separate file to the original book review plugin, to organize its code separately from the original plugin file created in <a href="6298bc2b-19d5-4e3a-833c-3c4b667b22e5.xhtml"><span class="ChapterrefPACKT">Chapter 4</span></a>, <em>The Power of Custom Post Types</em>.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">See also</h1>
                </header>
            
            <article>
                
<ul>
<li>The <em>Updating page title to include custom post data using plugin filters</em> recipe in <a href="6298bc2b-19d5-4e3a-833c-3c4b667b22e5.xhtml"><span class="ChapterrefPACKT">Chapter 4</span></a>, <em>The Power of Custom Post Types</em></li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Adding a custom widget to the network dashboard</h1>
                </header>
            
            <article>
                
<p>As discussed in the recipe titled <em>Creating network-level admin pages</em> back in <a href="0346c3c6-27ee-45fb-bfd6-df398e04b2b4.xhtml"><em>Chapter 3</em></a>, <em>User Settings and Administration Pages</em>, WordPress offers a very powerful mode called Network mode, which allows for multiple websites to be served from a single installation of the platform. When creating a plugin, developers need to think if it would make sense for their plugin to offer a dashboard widget that would only be seen in the network administrator's dashboard instead of being seen in individual website dashboards, or if their plugin's scope is really more relevant at each website's level. The following recipe shows how to modify the dashboard widget defined in the previous recipe so that it appears in the network administration panel on network installations, while still appearing in the administration dashboard in single site installations.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Getting ready</h1>
                </header>
            
            <article>
                
<p>You should have already followed the <em>Adding a custom dashboard widget</em> recipe to have a starting point for this recipe. Alternatively, you can get the resulting code (<kbd>Chapter 10/ch10-book-review-dashboard-widget/ch10-book-review-dashboard-widget-v1.php</kbd>) from the code bundle and rename the file <kbd>ch10-book-review-dashboard-widget.php</kbd>. You should also have access to a network site configured as a Network to test all of this plugin's functionality.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<ol>
<li>Navigate to the WordPress plugin directory of your development installation.</li>
<li>Create a new directory called <kbd>ch10-book-review-dashboard-widget</kbd> and edit <span><kbd>ch10-book-review-dashboard-widget.php</kbd>.</span></li>
<li>Locate the <kbd>add_action</kbd> call that was first added at the top of the plugin and add the following highlighted lines of code around the existing function call:</li>
</ol>
<pre style="padding-left: 60px"><strong>if ( is_multisite() ) {</strong><br/><strong>    add_action( 'wp_network_dashboard_setup',<br/>                'ch10brdw_add_dashboard_widget' );</strong><br/><strong>} else {</strong><br/>    add_action( 'wp_dashboard_setup', <br/>                'ch10brdw_add_dashboard_widget' );<br/><strong>}</strong></pre>
<ol start="4">
<li>Locate the <kbd>ch10brdw_dashboard_widget</kbd> function and add the following code to the function around the existing implementation of the function. The new lines of code are shown in bold:</li>
</ol>
<pre style="padding-left: 60px">function ch10brdw_dashboard_widget() { <br/>    <strong>if ( is_multisite() ) {</strong><br/><strong>        $sites_list = get_sites();</strong><br/><strong>    } else {</strong><br/><strong>        $sites_list = array( 'blog_id' =&gt; 1 );</strong><br/><strong>    }</strong><br/> <br/><strong>    foreach( $sites_list as $site ) {</strong><br/><strong>        if ( is_multisite() ) {</strong><br/><strong>            switch_to_blog( $site-&gt;blog_id );</strong><br/><strong>        }</strong><br/><strong>        $site_name = get_bloginfo( 'name' );</strong><br/><strong>        echo '&lt;div&gt;' . $site_name . '&lt;/div&gt;'; </strong>  <br/>        $book_review_count = wp_count_posts( 'book_reviews' ); <br/>        ?&gt; <br/>        // REST OF PREVIOUS CODE GOES HERE<br/>        &lt;?php }<br/>    <strong>}</strong><br/><strong>    if ( is_multisite() ) {</strong><br/><strong>        restore_current_blog();</strong><br/><strong>    }</strong><br/>} </pre>
<ol start="5">
<li>Save and close the plugin file.</li>
<li>Navigate to the website <span class="packt_screen">Dashboard</span> (on a single site installation) or to the Network-level <span class="packt_screen">Dashboard</span> (in a network installation) to see the same widget as before or to see the network-level dashboard, respectively:</li>
</ol>
<div class="CDPAlignCenter CDPAlign"><img height="227" width="382" class="image-border" src="assets/4e8d787f-500a-42bb-a603-67ade585273a.png"/></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How it works...</h1>
                </header>
            
            <article>
                
<p>The initial change made in this recipe is to check whether the plugin is running on a single site or network installation of WordPress and associate a callback function with the appropriate action hook depending on the result. As you can see, we use the same callback function in both cases, since the widget registering function should call <kbd>wp_add_dashboard_widget</kbd> to register a widget with the system in either case.</p>
<p>The widget rendering function is also shared between both modes. When running in a network installation, the rendering code first gets a list of all sites using the <kbd>get_sites</kbd> function, then cycles through the list of sites and uses the <kbd>switch_to_blog</kbd> function to access data from each site's database tables. Once all the blogs have been processed, we use the <kbd>restore_current_blog</kbd> function to go back to the original site that is configured as the top-level site in the network.</p>
<div class="packt_infobox">It is important to restore the current blog to avoid leaving some internal variables pointing to the wrong site.</div>
<p>When running on a single site installation of WordPress, we create a dummy list of sites that contains a single entry to allow us to use the same <kbd>foreach</kbd> loop control structure. We then avoid calling the functions that are related to network site operations when WordPress is not configured in the multisite mode. Otherwise, the actual code that queries how many book reviews are present and displays them is identical between both versions of the widget.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">See also</h1>
                </header>
            
            <article>
                
<ul>
<li>The <em>Adding a custom dashboard widget</em> recipe</li>
</ul>
<p>Â </p>


            </article>

            
        </section>
    </body></html>