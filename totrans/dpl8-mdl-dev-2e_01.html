<html><head></head><body>
        <section>

                            <header>
                    <h1 class="header-title">Developing for Drupal 8</h1>
                </header>
            
            <article>
                
<p>Drupal is a web-based <strong>Content Management System</strong> (<strong>CMS</strong>). While it is useful out of the box, it is designed with developers in mind. The purpose of this book is to explain how Drupal can be extended in many ways and for many purposes. To this end, the version we will use will be the latest one at the time of writing this book—Drupal 8.7.</p>
<p>In this book, we will cover a wide range of development topics. We'll discuss how to create a Drupal 8 module, and as we go through the chapters, many concepts and tips that will help you build what you need. The goal is not only to explain how things work but also to go through some examples in order to demonstrate them. Since no book can contain everything, I hope that after reading this book, you'll be able to expand on this knowledge on your own using the resources I reference and by looking into the Drupal core code itself. As helpful as such a book can be for learning any kind of software development, if you really want to progress, you will need to apply the knowledge you learned and explore the source code yourself. Only by doing this will you be able to understand complex systems with many dependencies and layers.</p>
<p>This chapter introduces the terminology, tools, and processes for developing Drupal 8. While subsequent chapters focus on code, this chapter focuses on concepts. We'll talk about the architecture of Drupal and how you can hook into Drupal at strategic places to extend it for accomplishing new tasks.</p>
<p>The following are the major topics we will be covering in this chapter:</p>
<ul>
<li>An introduction to Drupal development</li>
<li>Drupal 8 architecture</li>
<li>The major subsystems of Drupal</li>
<li>Tools for developing in Drupal</li>
</ul>
<p>By the end of this chapter, you will understand the architectural aspects of Drupal and be ready to start writing code.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Introducing Drupal (for developers)</h1>
                </header>
            
            <article>
                
<p>Out of the box, Drupal traditionally has all the standard functions of a web-based content management system:</p>
<ul>
<li>Visitors can view published information on the site, navigate through menus, view listings, and individual pages and so on</li>
<li>Users can create accounts and leave comments</li>
<li>Administrators can manage the site configuration and control the permissions of users</li>
<li>Editors can create, preview, and then publish content when it is ready</li>
<li>Content can be syndicated to RSS, where feed readers can pick up new articles as they are published</li>
<li>With several built-in themes, even the look and feel of the site can be easily changed</li>
</ul>
<p>However, Drupal 8 improved on these and introduced some more powerful capabilities. For example, advanced multilingual support, content moderation, layout building, REST API and many other features are now available out of the box.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Developing for Drupal 8</h1>
                </header>
            
            <article>
                
<p>As fantastic as these features are, they will certainly not satisfy the needs of all users. To that end, Drupal's capabilities can be easily extended with modules, themes, and installation profiles. Take a look at Drupal's main website, (<a href="http://drupal.org"><span class="URLPACKT">http://drupal.org</span></a>), and you will find thousands of modules that provide new features and thousands of themes that transform the look and feel of the application or website.</p>
<p>The flexible way Drupal can be extended and transformed through the module and theme mechanisms has led many to claim that Drupal isn't just a CMS, but a <strong>Content Management Framework</strong> (<strong>CMF</strong>) capable of being re-tooled to specific needs and functional requirements. This is particularly the case with Drupal 8—the latest version of Drupal and the focus of this book—as great progress has been made on the extensibility front as well.</p>
<p>Establishing whether Drupal is rightly called a CMS or CMF is beyond our purpose here, but it is certain that Drupal's most tremendous asset is its extensibility. Want to use a directory server for authentication? There's a Drupal module for that. Want to export data to <strong>Comma-separated Version</strong> (<strong>CSV</strong>) files? There are several modules for that (depending on what data you want to export). Interested in Facebook support, integration with Twitter, or adding a Share This button? Yup, there are modules for those too—all of which are available on Drupal.org and provided by developers like you.</p>
<p>Want to integrate Drupal with that custom tool you wrote to solve your special business needs? There may not be a module for that, but with a little bit of code, you can write your own. In fact, that is the subject of this book—providing you with the knowledge and tools to achieve your own goals.</p>
<p>In summary, the purpose of this book is to get you ramped up (as quickly as possible) for Drupal 8 module development. As we move chapter by chapter, we will cover the APIs and tools that you will use to build custom Drupal sites, and we won't stick to theory. Most chapters provide working, practically-oriented example code designed to show you how to implement the concepts we will be talking about. We will follow Drupal coding conventions and utilize Drupal design patterns in an effort to illustrate the correct way to write code within the Drupal development context.</p>
<p>While I certainly can't write the exact code to meet your needs, my hope is that the code mentioned in these chapters can serve as a foundation for your bigger and better applications.</p>
<p>So let's get started with a few preliminary matters to better understand Drupal.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Technologies that drive Drupal</h1>
                </header>
            
            <article>
                
<p>Installing Drupal 8 in the traditional way is documented both on <a href="http://Drupal.org">Drupal.org</a> and in the <kbd>INSTALL.txt</kbd> file found inside the <kbd>/core</kbd> folder of the installation, so I won't go into it here. I will, however, mention that a better way of installing Drupal 8, especially for developers, is by using the accepted Composer template for Drupal 8 projects found on GitHub (<a href="https://github.com/drupal-composer/drupal-project"><span class="URLPACKT">https://github.com/drupal-composer/drupal-project</span></a>). However, the instructions for setting up your site are well covered there as well.</p>
<p>Instead, let's talk a bit about the technologies that power (or are needed by) Drupal 8.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">PHP</h1>
                </header>
            
            <article>
                
<p>Drupal is written in the PHP programming language. PHP is a widely supported, multiplatform, and web-centric scripting language. Since Drupal is written in PHP, this book will largely feature code written in PHP, albeit with Drupal standard practices being kept in mind.</p>
<p>It is very important to note that the minimum version of PHP required for Drupal 8 to run (and install via Composer) is 7.1. Therefore PHP 5 is no longer supported, neither by Drupal nor by the PHP community at large. By the time you read this book, you should probably be running Drupal on PHP 7.3 or at least 7.2</p>
<p>Regarding the style of PHP, a very important change compared to Drupal 7 is the heavy use of object-oriented code and design patterns. Granted, many procedural style approaches remain throughout the Drupal 8 code base, but the use of a good number of popular external libraries (such as Symfony components) has pushed the overall Drupal code to be more modern. For this reason, it is also quite important that you have at least some basic understanding of <strong>Object-Oriented Programming</strong> (<strong>OOP</strong>), especially PHP-related, if you want to do Drupal 8 development.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Databases and MySQL</h1>
                </header>
            
            <article>
                
<p>In the past, Drupal has supported two databases—MySQL and PostgreSQL. Drupal 7 and 8 have moved beyond this. Drupal now uses the powerful <strong>PHP Data Objects</strong> (<strong>PDO</strong>) library that is standard in PHP 7. This library is an abstraction layer that allows developers to support numerous databases, including MySQL, PostgreSQL, SQLite, and MariaDB.</p>
<p>The minimum database versions for Drupal 8.7 are as follows:</p>
<ul>
<li>MySQL 5.5.3/MariaDB 5.5.20/Percona Server 5.5.8 or higher with PDO and an InnoDB-compatible primary storage engine</li>
<li>PostgreSQL 9.1.2 or higher with PDO SQLite 3.7.11 or higher</li>
<li>SQLite 3.7.11 or higher</li>
</ul>
<p>Additionally, Drupal provides a powerful database API along with SQL coding conventions that make it easy to interact with your database—which, combined, allow you to write safe and portable SQL. However, more and more abstractions have been made at different levels, removing the need for SQL writing almost completely. However, we will still see some examples just so your toolbox does not miss anything, as well as cover all the tools at your disposal for querying your database.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The web server</h1>
                </header>
            
            <article>
                
<p>Apache has long been the predominant web server, but it is by no means the only server. While Drupal was originally written with Apache in mind, many other web servers (including IIS, Lighttpd, and NGINX) can run Drupal.</p>
<p>We do not explicitly cover the web server layer anywhere in this book, primarily because development rarely requires working at that low level. However, Drupal expects a fair amount of processing from the web server layer, including the handling of URL rewriting. For more information on what you can expect, you can consult the relevant documentation page at <a href="https://www.drupal.org/docs/8/system-requirements/web-server"><span class="URLPACKT">https://www.drupal.org/docs/8/system-requirements/web-server</span></a>.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">HTML, CSS, and JavaScript</h1>
                </header>
            
            <article>
                
<p>The de facto web data format is HTML styled with <strong>Cascading Style Sheets</strong> (<strong>CSS</strong>). Client-side interactive components are scripted with JavaScript. As Drupal developers, we will encounter all three of these technologies in this book. Although you don't need to be a JavaScript ninja to understand the code here, you will get the most from this book if you are comfortable with these three technologies.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Drupal architecture</h1>
                </header>
            
            <article>
                
<p>In the preceding section, we introduced the technologies that drive Drupal. However, how do they all fit together? How is Drupal code organized? In this section, we provide an overview of Drupal's architecture, with a focus on Drupal 8.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Drupal core, modules, and themes</h1>
                </header>
            
            <article>
                
<p>From an architectural standpoint, we can break up Drupal into three pieces: its core, modules and themes.</p>
<p>When we discuss Drupal 8 core, we can interpret it in two ways. A more restrictive interpretation sees it as the functionality covered by all the code it ships with, excluding modules and themes. The more widespread interpretation sees it as the total code base it ships with (<em>out of the box</em>).</p>
<p>Although the most widespread interpretation is the latter (not least because it differentiates all the functionalities its standard installation contains versus all others provided by contributed modules and themes), it is interesting to consider the first one as well, even if just for a minute. Because in doing so we can distinguish, architecturally speaking, the base code from the modules and themes that provide various functionalities and layouts. And why is this distinction interesting? Because at the bridge between the two comes into play the hooks and events that will also allow us to inject ties to our own functionality.</p>
<p>The core libraries are made up of code belonging to the Drupal project and those from the wider PHP community, which Drupal borrows under open source licensing. This latter approach is new in Drupal 8 and has been regarded by many as a positive shift toward getting off the Drupal island and embracing outside libraries, frameworks, and communities.</p>
<p>Essentially, the core libraries provide the functions and services used throughout Drupal. For example, helpers for interacting with the database, translating between languages, sanitizing user data, building forms, encoding data, and many such utilities are found in Drupal's core libraries.</p>
<p>The modules (both core and contributed) are where most of the actual business logic is encapsulated. If enabled, they can provide functionality or extend the existing one. Most of the core modules are needed and cannot be disabled due to their importance in the standard Drupal installation. However, contributed ones can be installed and uninstalled as needed.</p>
<p>The themes (both core and contributed) are an important part of the theme system and are used by the presentation layer. They provide HTML templates within which content and data can be rendered to the user, as well as CSS styling and even client-side scripting for some nice visual interactions. Themes can extend other themes and can also contain some PHP logic to process the data before being rendered.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Hooks, plugins, and events</h1>
                </header>
            
            <article>
                
<p>Now that we have seen what the core libraries, modules, and themes do, let's talk briefly about hooks and events to understand how they are all connected.</p>
<p>Hooks are a very typical Drupal procedural concept that allows Drupal core and modules to gather data from other modules and themes (or expose it). By doing this, the latter can provide new functionality or alter existing ones. It is the responsibility of the code that <em>invokes</em> the hook to make use of whatever the hook <em>implementations</em> return. The format for whatever the latter need to return is usually described in the hook documentation.</p>
<p>Concretely, hooks work by scanning installed modules and themes and looking for a function that follows a specific naming pattern (in other words, a <em>hook implementation</em>). This is, in most cases, in the following format—<kbd>module_name_hook_name</kbd>. Additionally, there are also <em>alter</em> hooks, which have the word alter tacked on the end of the function name and are used to change data passed as a reference to the hook implementation. We will see examples of hooks later in the book.</p>
<div class="packt_infobox">Developers with a background in OOP or with a strong knowledge of design patterns might recognize this as being similar to the event handling paradigm captured in the Passive Observer pattern. When some particular event occurs, Drupal allows modules the opportunity to respond to that event.</div>
<p>In previous versions of Drupal, hooks were KING. Yes, I wrote this in capital letters<span><span>;</span></span> my <em>Caps Lock</em> did not get stuck. This is because they were the way to add or extend functionality in modules. As such, they were the single most important aspect of Drupal programming. In Drupal 8, however, although still important, they took a backseat to new concepts, such as plugins and events.</p>
<p>In Drupal 8, I dare to say that plugins are king. Much of the logic that used to be tied to Drupal via hooks is now added in through <strong>plugins</strong> (not to be confused with WordPress plugins). Drupal 8 plugins are discoverable bits of the functionality centralized by a manager and that are used for certain tasks and features. We will see more about plugins and provide many examples later in the book.</p>
<p>A third extension point introduced in Drupal 8 is the event system. Unlike the first two, however, this is not specific to Drupal, but is, in fact, the actual Symfony <kbd>EventDispatcher</kbd> component (<a href="http://symfony.com/doc/current/components/event_dispatcher.html"><span class="URLPACKT">http://symfony.com/doc/current/components/event_dispatcher.html</span></a>). Events are primarily used in Drupal to intercept certain actions or flows in order to either stop or modify them. Many <em>request to response</em> tasks that were handled via hooks in the past are now being handled by dispatching events to check whether any modules are interested in, for example, delivering the response to the user.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Services and the dependency injection container</h1>
                </header>
            
            <article>
                
<p>Another architecturally important element of Drupal 8 is the Symfony dependency injection component (<a href="http://symfony.com/doc/current/components/dependency_injection.html"><span class="URLPACKT">http://symfony.com/doc/current/components/dependency_injection.html</span></a>), specifically represented by the service container.</p>
<p>This component is a staple of modern OOP PHP programming and as such has become foundational to Drupal 8. It allows us to create <em>services</em> that can be injected in various places of our code in order to handle certain functional (and oftentimes swappable) tasks. Additionally, they can also be used as an extension point because the service container is able to group services that have very specific responsibilities and use them for that automatically. In other words, simply by defining a simple service, we can provide our own functionality or even change existing logic.</p>
<p>We will encounter many services, and we will see how we can declare our own later in this book.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">From request to response</h1>
                </header>
            
            <article>
                
<p>Now that we have listed the most important architectural pieces of Drupal, let's briefly see how these are used in delivering responses to the requests a user makes on a Drupal 8 website. To this end, we will analyze a simplified example of a request as it is handled on a Drupal 8 website:</p>
<ol>
<li>A user accesses the <kbd>http://example.com/node/123</kbd> URL in a web browser.</li>
<li>The browser contacts the web server at <kbd>example.com</kbd> and requests the resource at <kbd>/node/123</kbd>.</li>
<li>The web server recognizes that the request must be handled by PHP and starts up (or contacts) a PHP environment to handle the request.</li>
<li>PHP executes Drupal's front controller file (<kbd>index.php</kbd>), which then creates a new <kbd>Request</kbd> object from the resource that was requested.</li>
<li>Symfony's HTTPKernel handles this request object by dispatching a number of events, such as <kbd>kernel.request</kbd>, <kbd>kernel.controller</kbd>, <kbd>kernel.response</kbd>, and <kbd>kernel.view</kbd>.</li>
<li>The route that maps to that request is identified through the <kbd>kernel.request</kbd> event.</li>
<li>The route controller is identified, and the <kbd>kernel.controller</kbd> event is used to perform any alterations on the responsible controller, as well as to resolve the arguments that need to be passed to it. In our case, this route is registered by the Node module through the main Entity system, which identifies the entity ID, loads it, and builds the markup to be returned as part of the response.</li>
</ol>
<ol start="8">
<li>If the respective controller (or handler) returns something other than a response object, the <kbd>kernel.view</kbd> event is dispatched to check whether there is any code that can transform that into a Response object. In most cases, in Drupal 8, we typically return render arrays, which are transformed into Response objects.</li>
<li>Once a Response is created, the front controller returns it to the browser and terminates the request.</li>
</ol>
<p>In this context, as Drupal 8 module developers, we spend most of our time inside controllers and services, trying to figure out what we need to return to the page. We then rely on Drupal to transform our render array into a proper response to the user, but we can also return one ourselves directly. Moreover, the theme system comes into play here, as well as the block system, because our content gets wrapped into a block that is placed in a region surrounded by other regions that contain other blocks. If it sounds complicated now, don't worry<span><span>;</span></span> we will cover in detail all these aspects with examples, and it will become clear in no time.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Drupal's major subsystems</h1>
                </header>
            
            <article>
                
<p>In the previous  we took a bird's-eye view of Drupal's architecture. Now, we will refine our perspective a bit. We will walk through the major subsystems that Drupal 8 has to offer.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Routing</h1>
                </header>
            
            <article>
                
<p>It all starts with a route, doesn't it? Most interactions with a Drupal 8 website begin with a user (or system) accessing a certain path (or resource). This translates into a route, which maps that resource to a flow that (hopefully) returns a successful response back or at least a graceful failure.</p>
<p>The Drupal 8 routing system is a major shift away from how it used to be in its previous versions. In Drupal 7 and before, the routing system was a very Drupal-specific thing (a <em>drupalism</em>, if you will). Many of us remember <kbd>hook_menu</kbd> as a staple hook each Drupal developer had to know very well. All of that has been abandoned in Drupal 8 in favor of the Symfony Routing component (<span class="URLPACKT"><a href="http://symfony.com/doc/current/components/routing.html">http:/</a><a href="http://symfony.com/doc/current/components/routing.html">/</a><a href="http://symfony.com/doc/current/components/routing.html">symfony.</a><a href="http://symfony.com/doc/current/components/routing.html">com/</a><a href="http://symfony.com/doc/current/components/routing.html">doc/</a><a href="http://symfony.com/doc/current/components/routing.html">current/</a><a href="http://symfony.com/doc/current/components/routing.html">components/</a><a href="http://symfony.com/doc/current/components/routing.html">routing.</a><a href="http://symfony.com/doc/current/components/routing.html">html</a></span>). Also, since I mentioned <kbd>hook_menu</kbd>, I will also mention that its other main functions have also been taken over in Drupal 8 by other subsystems, such as plugins.</p>
<p>In <span class="MsoHyperlink"><a href="601b4dd0-c521-459e-9342-2645a109642c.xhtml">Chapter 2</a>, </span><em>Creating Your First Module</em>, we will see how we can define our own route and map it to a controller that will render our page. We will cover a few of the more important route options and take a look at how we can control access to these routes.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Entities</h1>
                </header>
            
            <article>
                
<p>Progressively, entities have become a very powerful way of modeling data and content in Drupal. The most famous type of entity has always been the Node, and it has been historically the cornerstone of content storage and display. In Drupal 8, the entire entity system has been revamped to make other entity types potentially just as important. They have been brought to the forefront and have been properly connected with other systems.</p>
<p>All entity types can have multiple <kbd>bundles</kbd>, which are different <em>variations</em> of the same entity type and can have different fields on them (while sharing some base fields).</p>
<p>Drupal core still ships with the Node entity type, with a few bundles such as Basic Page and Article in its standard installation profile. In addition, it comes with a few other entity types, such as <kbd>User</kbd>, <kbd>Comment</kbd>, and <kbd>File</kbd>. However, creating your own entity type in Drupal 8 has become much more standardized compared to Drupal 7 where contributed modules had to be brought into play.</p>
<p>These are not the only types of entities we have in Drupal 8. The aforementioned examples are all content entity types. Drupal 8, however, also introduced the configuration entity types. The former are for modeling content, but in reality, they are for anything that holds data that can be stored in the database and is specific to that environment. They are not used for storing configuration, though. Users and content are great examples, as they do not need to be (usually) deployable from one environment to another. The latter, on the other hand, are exportable items of configuration, of which there can be more than one. For example, a content entity <em>bundle</em> is a great example because there can be more than one bundle for a certain entity type; they have some metadata and information stored that can differ from bundle to bundle, and they need to be deployed on all environments. That is, they are fundamental to the correct functioning of the site.</p>
<p>Understanding the entity system is indispensable for doing development in Drupal 8 because it provides a powerful way to model custom data and content. Nodes are not the only tool for the job and in my opinion, they were used in previous Drupal versions way past their purpose due to the lack of a proper entity architecture.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Fields</h1>
                </header>
            
            <article>
                
<p>Now that we have an idea of what entities are, let's take a look at how data is actually stored on these entities.</p>
<p>I have alluded in the preceding section to how certain entity bundles can have various fields. This means that each entity type bundle can have any number of fields that are responsible for holding data. Additionally, each entity type itself can have fields for storing data. Okay, but what? Let's break this down.</p>
<p>There are two types of fields in Drupal 8—base fields and configurable fields. The former are fields that are defined in the code for each entity type, whereas the latter are usually created and configured in the UI and attached to a <em>bundle</em> of that entity type (and exported via configuration).</p>
<p>Fields can also be of multiples types, depending on the data they store. You can have string (or text) fields, numeric fields, date fields, email fields, and so on. As developers, we can create our own field types if the existing ones are not good enough for our data.</p>
<p>In this book, we will take a look at how we can define base fields on a certain entity type and create our own field type with its own data input widget and output formatter. Site builders can then use this field type on any entity type.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Menus</h1>
                </header>
            
            <article>
                
<p>Any site needs some sort of navigation, right? Drupal not only maintains content, but also provides details about how the site itself is organized. That is, it keeps a structure of how content is related.</p>
<p>The principal way that it does this is through the menu subsystem. The latter provides APIs to generate, retrieve, and modify elements that describe the site structure. Put in common parlance, it handles the system's navigational menus.</p>
<p>Menus are hierarchical, that is, they have a tree-like structure. A menu item can have multiple children, each of which may have their own children, and so on. In this way, we can use the menu system to structure our site into sections and subsections.</p>
<p>In this book, we will see how we can work programmatically with menus and menu links.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Views</h1>
                </header>
            
            <article>
                
<p>Listing content and data is always an important capability content management systems covet; and this is what Views does in Drupal 8. And it does it well.</p>
<p>If you've been building (not even necessarily developing) sites in previous versions of Drupal, you'll understand everything with this simple phrase—Views is now in Drupal core.</p>
<p>If you haven't, Views has always been a staple Drupal contributed module used on probably all Drupal installations (to a certain extent) and is an indispensable tool for site builders and even developers.</p>
<p>The purpose of the Views module is to expose data and content in a way that allows the creation of configurable listings. It includes things such as filters, sorts, display options, and many other features. As developers, we often find a need to write our own field or filter plugin to work with Views or expose data from our custom entities or external data sources.</p>
<p>Views is a core Drupal 8 module tied to the general architecture and used for most list pages (especially, admin pages) provided by Drupal core. Although it's a very site building-oriented tool, in this book, we will take a look at how we can create plugins that extend its capabilities to offer site builders even more.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Forms</h1>
                </header>
            
            <article>
                
<p>Unless your site has three pages and five paragraphs of text, the likelihood that you will need to capture user input via some type of form is very high. Also, if you've been coding PHP applications you know how forms have always been a pain from the point of view of securely and efficiently rendering and processing the submitted data. As soon as you use a PHP framework such as Symfony or Laravel, you will note that an API is in place to take much of that load off your shoulders.</p>
<p>The same goes with Drupal 8 and its powerful Form API. Historically, it has been a great abstraction over having to output your own form elements and deal with posted values. It allows you to define your own form definition in OOP and handle validation and submission in a logical way. Its rendering and processing is taken care of by Drupal securely, so you don't have to worry about any of that. In Drupal 8, theming form elements has become much easier than in previous versions.</p>
<p>In this book, we will encounter some forms and see how they actually work in practice.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Configuration</h1>
                </header>
            
            <article>
                
<p>One of the major pet-peeves of Drupal developers (and developers of other popular CMSes for that matter) has always been the way configuration is handled and deployed from one environment to the next. Drupal 7 stored most of its configuration in the database, so various solutions had to be concocted by developers to get that moved up the ladder as development progressed.</p>
<p>In Drupal 8, great advancements have been made in this respect with the introduction of a centralized configuration system. Although it stores all configuration in the database, it allows it all to be exported into YML files (and then reimported). So, from a development point of view, we have a much better experience if certain features depend on configuration (for example, a new field).</p>
<p>Configuration is also of two kinds—simple and complex (configuration entities we noted in the <em>Entities</em> section). The difference between the two is that the former is always singular. In other words, there is only one instance of itself. For example, the site name and email address are stored inside such a configuration item. You wouldn't expect the need for more than one instance of it. However, in the case of the latter, you would. For example, a View definition is such a configuration entity because it follows a certain schema and we can have multiple View definitions. Makes sense doesn't it?</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Plugins</h1>
                </header>
            
            <article>
                
<p>Plugins are new to Drupal 8 and are an elegant solution to an important problem— encapsulating functionality. Right off the bat, you should not confuse them with things such as the WordPress plugins, which are more akin to Drupal modules. Instead, you should think of plugins as components of reusable code that can be used and managed by a central system. Typically, they are used when a system handles a task in a certain way (plugin A) but allows other modules to provide different ways to handle that task (plugin B or C).</p>
<p>You can also look at plugins as being opposite to entities: not used for data storage, but for functionality. Instead of creating a type of data that gets stored, you create a type of functionality that is used. The two usually work hand in hand, especially when it comes to manipulating the data in different ways.</p>
<p>An important aspect of how they work is their discoverability. Most plugin types (but definitely not all) are discovered via something called <em>Annotations</em>. Annotations are a form of DocBlock comments, borrowed from the Doctrine library (<span class="URLPACKT"><a href="http://docs.doctrine-project.org/projects/doctrine-common/en/latest/reference/annotations.html">http:/</a><a href="http://docs.doctrine-project.org/projects/doctrine-common/en/latest/reference/annotations.html">/</a><a href="http://docs.doctrine-project.org/projects/doctrine-common/en/latest/reference/annotations.html">docs.</a><a href="http://docs.doctrine-project.org/projects/doctrine-common/en/latest/reference/annotations.html">doctrine-</a><a href="http://docs.doctrine-project.org/projects/doctrine-common/en/latest/reference/annotations.html">project.</a><a href="http://docs.doctrine-project.org/projects/doctrine-common/en/latest/reference/annotations.html">org/</a><a href="http://docs.doctrine-project.org/projects/doctrine-common/en/latest/reference/annotations.html">projects/</a><a href="http://docs.doctrine-project.org/projects/doctrine-common/en/latest/reference/annotations.html">doctrine-</a><a href="http://docs.doctrine-project.org/projects/doctrine-common/en/latest/reference/annotations.html">common/</a><a href="http://docs.doctrine-project.org/projects/doctrine-common/en/latest/reference/annotations.html">en/</a><a href="http://docs.doctrine-project.org/projects/doctrine-common/en/latest/reference/annotations.html">latest/</a><a href="http://docs.doctrine-project.org/projects/doctrine-common/en/latest/reference/annotations.html">reference/</a><a href="http://docs.doctrine-project.org/projects/doctrine-common/en/latest/reference/annotations.html">annotations.</a><a href="http://docs.doctrine-project.org/projects/doctrine-common/en/latest/reference/annotations.html">html</a></span>), by which we can describe classes, methods, and even properties with certain metadata. This metadata is then read to determine what that item is without the need for instantiating the class. In Drupal 8, we use annotations only at a class level to denote that it is a plugin implementation with certain characteristics. That is how most plugins are discovered in Drupal 8.</p>
<p>The second most common discoverability method for plugins is via a YAML file, and a popular example of those are menu links (as we will see later in the book). However, for now, you should know that plugins are very widely used, and we will create quite a few plugins in this book.</p>
<p>Plugins are a great new extension point for developers to add their own functionality and are a critical subsystem in Drupal 8. Every Drupal 8 developer needs to be comfortable with the plugin system.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The theme system</h1>
                </header>
            
            <article>
                
<p>The responsibility for theming a given piece of data is spread out over the Drupal core, modules, and the themes themselves. So, as a module developer, it is important to know that both modules and themes can theme data or content.</p>
<p>In this book, we will focus on the aspects that happen at the module level. We will not concern ourselves with styling, but work primarily with theming definitions and templates that are needed within the module. Typically, it is best practice to ensure that modules are able to theme their data. If done right, themes can then come into play to style the output or override that theming to change the presentation altogether.</p>
<p>A major shift in Drupal 8 compared to older versions is the move to the open source Twig templating system (<span class="URLPACKT"><a href="https://twig.sensiolabs.org/">https:/</a><a href="https://twig.sensiolabs.org/">/</a><a href="https://twig.sensiolabs.org/">twig.</a><a href="https://twig.sensiolabs.org/">sensiolabs.</a><a href="https://twig.sensiolabs.org/">org/</a></span>). This makes the separation of logic from a presentation that much clearer and makes frontend developers jobs much easier, not to mention more secure.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Caching</h1>
                </header>
            
            <article>
                
<p>The last major subsystem that I will include here is the caching layer. Drupal 8 has gone to great lengths to improve the performance of building pages and rendering data. To this end, the caching system has become an important part to consider whenever we either do complex or heavy calculations or render content.</p>
<p>From a module developer's perspective, there are two main pillars of the caching system. The first one provides developers with a cache backend to store the results of complex data calculations. This can be read in the next requests to avoid the need for reprocessing that task. This goes hand in hand with the cache invalidation that happens when something in the system changes that would require the calculations to be redone. The second pillar is the render cache, which allows developers to wrap their output with metadata that describes when the cache of that output needs to be invalidated.</p>
<p>We will see these in action in a later chapter dedicated to caching.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Other subsystems</h1>
                </header>
            
            <article>
                
<p>There are other subsystems in Drupal 8 of varying importance. I chose to include the previous ones because I deemed them to be the most important to be introduced up front and especially from the point of view of a module developer. However, as we progress through the book, we will definitely encounter others.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Tools for developing in Drupal</h1>
                </header>
            
            <article>
                
<p>Drupal is a sophisticated platform, and from the glimpse provided in this chapter, we can already see that there are numerous systems and structures to keep track of. In this section, I will provide tools that simplify or streamline the development process.</p>
<p>Going forward, I assume that you have your own web server stack and your own PHP development tools. However, if you are just getting started, you may want to look at Acquia Dev Desktop from Acquia (<span class="URLPACKT"><a href="http://acquia.com/">http:/</a><a href="http://acquia.com/">/</a><a href="http://acquia.com/">acquia.</a><a href="http://acquia.com/">com</a></span>). It offers entire application stacks to get you started on Windows, Linux, or macOS X. Alternatively, if you are even just a bit more advanced, you can consider the Drupal VM (<span class="URLPACKT"><a href="https://www.drupalvm.com/">https:/</a><a href="https://www.drupalvm.com/">/</a><a href="https://www.drupalvm.com/">www.</a><a href="https://www.drupalvm.com/">drupalvm.</a><a href="https://www.drupalvm.com/">com/</a></span>), a Vagrant and Ansible-based local development environment ready for Drupal.</p>
<p>Finally, the most flexible development environment in my opinion is the Docker-based one. You can easily get started with a pre-made and well documented stack here: <span class="URLPACKT"><a href="https://github.com/wodby/docker4drupal">https://github.com/wodby/docker4drupal</a></span>.</p>
<p>As for a code editor, I personally use PhpStorm (as many others do), but you are free to use whatever IDE you want because Drupal itself doesn't require anything special. Do, however, use some sort of an IDE because it will make your life much easier.</p>
<p>Additionally, while running a PHP debugger is certainly not necessary, you may find running Xdebug or the Zend Debugger to be useful. I personally recommend a PHP debugger wholeheartedly, not only for debugging itself, but also for understanding the processes that happen under the hood.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Version control</h1>
                </header>
            
            <article>
                
<p>Any software development needs to happen through a version-controlled environment. By now, Drupal is universally using Git. So, you should make sure that you have Git installed locally, even if just to be able to check out the code examples we write in this book, which are hosted on GitHub.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Composer</h1>
                </header>
            
            <article>
                
<p>As I alluded to earlier, installing Drupal 8 is best done via the Composer template project. However, you may also install it straight from Git by checking out the latest tag or commit in the <a href="http://Drupal.org">Drupal.org</a> Git repository (<a href="https://www.drupal.org/project/drupal/git-instructions"><span class="URLPACKT">https://www.drupal.org/project/drupal/git-instructions</span></a>). If you do this, you will need to install its dependencies via Composer, and Drupal has many.</p>
<p>To this end, you will need to have Composer available on your development environment and have a basic understanding of how to use it.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The API site and coding standards</h1>
                </header>
            
            <article>
                
<p>A lot of background knowledge is required for writing good Drupal code. Of course, the aim of a book such as this is to try to provide as much of that background knowledge as possible. However, self-documentation and research still remain key, and there are a number of resources that a Drupal developer should have on-hand.</p>
<p>The first is the official online API documentation. Just about every function in Drupal is documented using inline code documentation. The Doxygen program is then used to extract that documentation and format it. You can access the full API documentation online at <a href="http://api.drupal.org"><span class="URLPACKT">http://api.drupal.org</span></a>.</p>
<p>Along with using the Drupal APIs, we strive to comply with Drupal's coding conventions. Best practices in software development include keeping code clean, consistent, and readable. One aspect of this is removing nuances in code formatting by following a fixed standard.</p>
<p>This is particularly important on a platform such as Drupal, where thousands of developers all contribute to the code. Without coding standards, the code would become a cluttered mishmash of styles, and valuable development time will be spent merely deciphering code instead of working on it.</p>
<p>The Drupal site has a manual on coding standards that each Drupal developer needs to become familiar with (<a href="https://www.drupal.org/docs/develop/standards/coding-standards"><span class="URLPACKT">https://www.drupal.org/docs/develop/standards/coding-standards</span></a>). It won't happen overnight; you will get better with experience, but you can also configure your IDE to, for instance, flag any issues with your code formatting.</p>
<p>A third resource for developers new to Drupal 8, but who have experience with Drupal 7, is the change records database (<a href="https://www.drupal.org/list-changes/drupal"><span class="URLPACKT">https://www.drupal.org/list-changes/drupal</span></a>). On this page, you'll find an inventory of the most important API and usage changes with some handy explanations that will be extremely helpful for Drupal 7 developers looking up how certain functions have been changed.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The developer (Devel) module</h1>
                </header>
            
            <article>
                
<p>On your development environment, you can install a handy module called Devel (<a href="http://drupal.org/project/devel"><span class="URLPACKT">http://drupal.org/project/devel</span></a>), which provides several sophisticated tools designed to help developers create and debug Drupal code.</p>
<p>The following are a few of the features of this module:</p>
<ul>
<li>Functions used for dumping objects and arrays into formatted Drupal output</li>
<li>Tools for analyzing database usage and performance</li>
<li>A content generator for quickly populating your site with testing content</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Drush (the Drupal shell)</h1>
                </header>
            
            <article>
                
<p>Sometimes, it is much easier to run some tasks with a single command in a console. Drush (<a href="http://drupal.org/project/drush"><span class="URLPACKT">http://drupal.org/project/drush</span></a>) provides a command-line Drupal interface and it can be used to execute tasks with a few keystrokes at the console.</p>
<p>When developing, we often have to clear caches, run specific tasks, or deploy data to a remote server. Drush can help accomplish tasks like these. Additionally, we can write our own Drush commands that perform various custom tasks, for example, to be used in cron jobs. So having Drush installed is a must for any serious Drupal developer.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Drupal Console</h1>
                </header>
            
            <article>
                
<p>If Drush is a tool that has been around for many years, the Drupal Console (<a href="https://drupalconsole.com/"><span class="URLPACKT">https://drupalconsole.com/</span></a>) project is new to Drupal 8. Its purpose is similar to that of Drush, and in this way, it complements it, if at times even overlaps with it. However, one thing is clear—its scope is much broader, especially in its handy commands that generate boilerplate code, which can get quite lengthy.</p>
<p>Although we won't be using this tool in this book, it's recommended that you install it as you progress with learning Drupal 8 module development and start generating certain code structures faster. That being said, I advise caution in using it at the expense of actually understanding what the code it generates actually does. Always strive to understand what you are doing, and never give in to blindly copying and pasting code from Stack Overflow or any other resource without grasping fully what it does.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Developer settings</h1>
                </header>
            
            <article>
                
<p>While doing local development, it's beneficial to (sometimes) disable things such as caching in order to be quicker. Drupal 8 takes caching to a whole new level, so many hook implementations, for example, get cached. To circumvent this, we can use some local settings that disable caching, prevent CSS and JavaScript file aggregation, and do similar things.</p>
<p>These settings are found inside the <kbd>example.settings.local.php</kbd> file in the <kbd>/sites</kbd> folder of the installation. To benefit from these, you will need to make sure that they are included in your main <kbd>settings.php</kbd> file (either by copying them inside or including a file such as this).</p>
<p>A word of caution—do keep in mind that by developing with caching disabled at all times, you run the risk of overlooking certain aspects that won't work properly with caching enabled (such as invalidations). So, do try to toggle these settings on or off to ensure a production-like environment will work just as well as under your development conditions.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Summary</h1>
                </header>
            
            <article>
                
<p>This chapter has been an overview of Drupal 8 for developers. We saw what technologies Drupal uses. We took a look at Drupal's architecture. We took a cursory glance at several prominent subsystems of Drupal. We also got a feel for which developer-oriented tools are to be used while working with Drupal.</p>
<p>Starting with the next chapter, we will be working with code. In fact, each of the subsequent chapters will focus on practical aspects of working with Drupal.</p>
<p>In the next chapter, we will create our first Drupal 8 module with the obligatory Hello World example.</p>


            </article>

            
        </section>
    </body></html>