- en: Chapter 9. The History API – Not Forgetting Where We Are
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapter, we introduced Ajax, a collection of web techniques
    to update parts of the screen in web applications without having to create a link
    to a physically different page, have the browser request that new page from the
    server, and load it. Modern websites use this technique all over the place, as
    do their developers; Ajax is a common practice, a commodity almost.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
- en: The concept is, however, difficult to grasp by both the marketing people you
    have to work with and the visitors of your site. Doesn't it often occur that your
    marketing person asks you to add a page to the website and then wants to know
    what the URL is? It is **index.php**, honey, it always is. Visitors of your site
    who navigate through the menus will, when they hit the browser's back button,
    expect to look at the screen they just left. Instead they will be taken back to
    the website they were visiting before coming to yours, unless you use the techniques
    we are going to teach you in this chapter.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
- en: We will first describe the problem we are trying to solve; next, we will explain
    what the solution is in HTML5, as well as in HTML4 country.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
- en: The problem we are trying to solve
  id: totrans-4
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Imagine a horizontal navigation menu where the visitor clicks on a menu item,
    just like the example we used in the previous chapter. In a classical website,
    the browser takes the visitor to a different page, for example, `galleries.php`,
    with its URL displayed by the browser. However, an Ajax-based site will simply
    update a part of the screen and not do anything with the URL bar each time the
    visitor clicks a menu item. No matter how many items they choose, once they push
    the browser's *BACK* button, they will find themselves back at the previous page,
    which will be the previous true page, and typically, a different website, and
    this is not where he expects to be.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
- en: We will solve this problem by using a technique that will restore the website
    to its previous state, as we cannot take it to the previous page. Before we go
    through the details, let's discuss a thing or two about **pushing** and **popping**
    states.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
- en: The self-service restaurant
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The best way to describe the technologies we are about to learn is to compare
    them with what you can find in any self-service restaurant. In such restaurants,
    you start by picking up a tray, and when you are done eating, you put the tray
    back. Now imagine a slightly different scenario. You are going to clean the tray
    before you put it back so that you can put it back on top of the same stack where
    you took it. The other difference you have to imagine is that, instead of having
    a multitude of trays that are all equally boring because they all look identical,
    every tray will have a different picture on it.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
- en: So, all these trays are part of a single stack. When you approach the stack,
    you can only see the picture that is on the top tray. If you add a tray to the
    stack, that picture will disappear as it is replaced by the one from the tray
    we place on top. We call that action **push**. Some old fashioned stacks have
    built-in springs, so you really have to push the tray down until it stays in place.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，所有这些托盘都是单个堆栈的一部分。当你接近堆栈时，你只能看到顶部托盘上的图片。如果你向堆栈中添加一个托盘，那个图片就会消失，因为它被我们放在顶部的托盘上的图片所取代。我们称之为**推送**。一些老式的堆栈有内置的弹簧，所以你必须真的把托盘推到底部，直到它保持在原位。
- en: When you take a tray from the stack, the opposite will occur. The picture of
    the second tray becomes visible and the entire stack of trays pops up a little
    bit. That is why we call this action **pop** or **pop up**. Without self-service
    restaurants, there may have been no computer science, as this inspired many computer
    scientists in the field of formal grammar to create the theories of pop-up and
    push-down automata. I wrote my, obligatory to graduate, university paper on such
    a topic (no, we did not have a self-service restaurant there).
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 当你从堆栈中取出托盘时，情况正好相反。第二个托盘的图片变得可见，整个托盘堆栈略微弹出。这就是我们称之为**弹出**或**弹出**的原因。如果没有自助餐厅，可能就没有计算机科学，因为这个想法激励了许多计算机科学家在形式语法领域创建了弹出和下推自动机的理论。我写了我毕业的必读书，关于这样一个主题（不，我们那里没有自助餐厅）。
- en: HTML5 History API and the history object
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: HTML5历史API和历史对象
- en: Browsers use a similar stack called the `history` stack. In JavaScript, you
    can access it through the `history` object, for which there are several methods
    available. The history object is part of the window object and is accessed through
    the `window.history` property. It has been around for years.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 浏览器使用一个类似的堆栈，称为`history`堆栈。在JavaScript中，你可以通过`history`对象访问它，该对象有几个可用方法。历史对象是窗口对象的一部分，通过`window.history`属性访问。它已经存在多年了。
- en: Normally, when the user navigates to a new page, the browser pushes the new
    URL on to its history stack and downloads and draws the new page. When the user
    presses the back button, the browser pops one page off its history stack and redraws
    the previous page.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，当用户导航到新页面时，浏览器会将新URL推送到其历史堆栈中，并下载和绘制新页面。当用户按下后退按钮时，浏览器从其历史堆栈中弹出一张页面并重新绘制上一个页面。
- en: But what if we use Ajax calls to update parts of the screen without needing
    to load a new page? Then, nothing is going to be pushed on to that stack by the
    browser. Well, that is true, unless we do it ourselves. And the key to making
    this possible is the `popstate` event and the `history.pushState()` function.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 但如果我们使用Ajax调用更新屏幕的部分内容而不需要加载新页面呢？那么，浏览器将不会向那个堆栈中推送任何内容。嗯，这是真的，除非我们自己这样做。使这成为可能的关键是`popstate`事件和`history.pushState()`函数。
- en: pushState()
  id: totrans-15
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: pushState()
- en: 'Each time we create code to update part of the screen, as we did in the examples
    in the previous chapter, we should use the `pushState()` function to put some
    relevant information on to the history stack and, if we want to, change the URL
    string that is displayed by the browser. `pushState()` takes three arguments:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 每次我们编写代码来更新屏幕的一部分，就像我们在上一章的示例中所做的那样，我们应该使用`pushState()`函数将一些相关信息推送到历史堆栈中，并且如果我们想的话，改变浏览器显示的URL字符串。`pushState()`接受三个参数：
- en: '[PRE0]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The first argument should be some structured data, such as an array of key/value
    pairs that we make as meaningful as possible. The data should contain enough information
    to allow us to restore the page in the shape it was when we issued the `pushState()`.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个参数应该是某种结构化数据，例如一个尽可能有意义的键/值对数组。数据应包含足够的信息，使我们能够恢复我们在发出`pushState()`时页面的形状。
- en: The second argument is intended to be a title of sorts to show up in the dropdown
    list of the browser's history. At the time of writing, there was not a single
    browser that implemented this.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个参数的目的是显示在浏览器历史记录的下拉列表中的某种标题。在撰写本文时，没有单个浏览器实现了这一点。
- en: 'The third argument, finally, is used to pass a string that is going to be our
    substitute URL for this state of the page. It is displayed by the browser, so
    once again, the visitor will believe he has landed on a different page. That URL
    string has a second purpose, which we will see at the end of this chapter. So,
    a possible `pushState()` statement related to some of the examples could be:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: So, the plate we just pushed on top of our stack in the browser self-service
    restaurant will have a picture of a key on it, labeled with the value of the variable
    `nav`, and a picture of an anchor, labeled `agenda`. The URL will be the same
    as before with a query string appended to it that also contains those two key/value
    pairs.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
- en: popstate event
  id: totrans-23
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: After you've used the `history.pushState()` function to push a fake URL to the
    browser's `history` stack, when the user presses the back button, the browser
    will fire a `popstate` event on the `window` object. This is our chance to create
    the illusion that there are actually different pages and that we are moving our
    visitor back to what they believe is the previous one.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
- en: For this purpose, we create an event handler to execute some code each time
    a `popstate` event occurs. Most of the code we already have, because we used a
    function to draw a portion of the screen. We can simply reuse that.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: So, in the preceding code, we act on each `popstate` event by looking at our
    stack. If it is not empty but has a picture of an anchor labeled `agenda`, we
    look for the value of `key` and call the function `updateAgendaContent()`, with
    `key` as argument, to restore the part of the screen we always update to its previous
    state. Of course, this time we are not going to call `pushState()`. If we were,
    subsequent pushing of the back key would have no visible effect.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
- en: There is also the special case where we have run out of trays when the stack
    is empty. Then, we will need code that we may have not written yet. In the example,
    I used a placeholder function named `restoreHomePage()`. What should that function
    do? It should replace the variable portion of our screen with the initial content
    it had when our page was first loaded.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
- en: popstate and different browsers
  id: totrans-29
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: At the time of writing, some browsers behaved differently than others. The current
    version of Safari will issue a `popstate` event on the initial page load, which
    can be utterly confusing. This also means that, in Safari, the `restoreHomePage`
    function will be called right after the initial page load. What that will do if
    your function is written correctly is replace the variable part of the screen
    with the exact same thing it already contains. Silly, isn't it? This may cause
    a small delay, and maybe some flickering, if the network is slow.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
- en: The History plugin
  id: totrans-31
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `popstate` event and `pushState` method are part of the so-called **History
    API** that was introduced in HTML5\. This means that our magic will only work
    if HTML5 capable browsers are used. That is, of course, not good enough. There
    are still a lot of people that visit your site using HTML4 capable browsers, so
    what do we do?
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '`popstate`事件和`pushState`方法是所谓的**历史API**的一部分，该API是在HTML5中引入的。这意味着我们的魔法只有在使用HTML5兼容的浏览器时才会起作用。当然，这还不够好。仍然有很多人使用HTML4兼容的浏览器访问你的网站，所以我们该怎么办？'
- en: Fortunately, several plugins for jQuery exist that allow you to use the same,
    or a similar, API and have your code work in both types of browsers. One even
    has a name that will make you think of self-service restaurants again (*BBQ*),
    but I have been using the so-called `jQuery history` plugin. At the time of writing,
    the plugin could be found at [https://github.com/browserstate/history.js](https://github.com/browserstate/history.js).
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，有几个jQuery插件允许你使用相同的或类似的API，并且让你的代码在两种类型的浏览器中都能工作。其中一个甚至有一个名字会让你再次想起自助餐厅（*BBQ*），但我一直在使用所谓的`jQuery
    history`插件。在撰写本文时，该插件可以在[https://github.com/browserstate/history.js](https://github.com/browserstate/history.js)找到。
- en: Bookmarking
  id: totrans-34
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 书签
- en: Let's move back from the self-service restaurant to our marketing person who
    wants to know which URL they can use to put in a document as a `link` to a page
    so that people can quickly access information that is found on the site. Perhaps
    they also want to know what to do if a visitor uses the `bookmark` feature of
    the browser to save the URL of a (in our case, virtual) page to revisit later.
    We can support this thanks to the URL parts we used in our `pushState` code.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从自助餐厅回到我们的市场营销人员，他们想知道他们可以使用哪个URL将文档中的链接放入页面，以便人们可以快速访问网站上的信息。也许他们还想了解如果访客使用浏览器的书签功能保存（在我们的案例中，是虚拟）页面的URL以便稍后重访，应该怎么做。我们可以通过在`pushState`代码中使用的URL部分来支持这一点。
- en: 'In our examples, we made sure that we stored enough information about our updated
    page in the state that we pushed on the history stack, and you learned how to
    restore our page to its previous state using that information. In our `pushState`
    code, we appended a query string to the URL that basically contains the same information.
    We can retrieve that information using the `location` object of the browser and
    its `href` property. Here is the code that will, if the URL with query string
    is used, cause our single page website to go to the expected state:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的示例中，我们确保在历史堆栈上推送的状态中存储了足够关于我们更新页面的信息，并且你学习了如何使用这些信息将我们的页面恢复到其之前的状态。在我们的`pushState`代码中，我们在URL上附加了一个查询字符串，它基本上包含了相同的信息。我们可以使用浏览器的`location`对象及其`href`属性来检索这些信息。以下是如果使用带有查询字符串的URL，将使我们的单页网站进入预期状态的代码：
- en: '[PRE3]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Note that we have come a long way already. A few chapters back we would have
    guessed this to be only possible in a huge chunk of PHP code using GET variables
    to get to our key/value pairs, but now this is written entirely in JavaScript
    and Ajax.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们已经走得很远了。在几章之前，我们可能会猜测这只能在包含GET变量的大量PHP代码中实现，以获取我们的键/值对，但现在这完全是使用JavaScript和Ajax编写的。
- en: In the previous example, a function was used called `QueryStringToJSON()`. This
    is not a standard JavaScript function. It is something you can write yourself
    or, like I did, grab off the Web. It dissects a query string and stores the key/value
    pairs into a JSON object. Yes, JSON! And what JSON is all about you will learn
    in the next chapter.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，使用了一个名为`QueryStringToJSON()`的函数。这不是一个标准的JavaScript函数。这是你可以自己编写的，或者像我一样，从网上抓取的。它分解查询字符串并将键/值对存储到JSON对象中。是的，JSON！关于JSON的内容你将在下一章学习。
- en: Summary
  id: totrans-40
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we addressed one of the main drawbacks of using Ajax. You learned
    how to use the HTML5 History API to create the expected behavior when a visitor
    of our site pushes the browser's back key, or drops a URL that they previously
    bookmarked, into the browser's URL bar. Even though this API is for HTML5 capable
    browsers, you learned that there are jQuery plugins around to support this magic
    in HTML4 capable browsers as well.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们讨论了使用Ajax的主要缺点之一。你学习了如何使用HTML5历史API在访客按下浏览器后退键或将他们之前书签的URL拖入浏览器地址栏时创建预期的行为。尽管这个API是为HTML5兼容的浏览器设计的，但你学习了有jQuery插件可以支持HTML4兼容的浏览器中的这种魔法。
- en: 'In the last few chapters, we started using Ajax more often to update only a
    portion of the screen, and to remain on the same page rather than loading a new
    one. As a consequence, we are exchanging smaller, but more frequent chunks of
    data between client and server. In the examples so far, the format of our data
    was HTML and it was all generated on the server. In the next chapter, you will
    learn two new formats for data exchange: **XML** and **JSON**.'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 在最后几章中，我们开始更频繁地使用Ajax来仅更新屏幕的一部分，并保持在同一页面上而不是加载新的一页。因此，我们在客户端和服务器之间交换的是更小但更频繁的数据块。到目前为止的示例中，我们数据的形式是HTML，并且所有内容都是在服务器上生成的。在下一章中，你将学习两种新的数据交换格式：**XML**和**JSON**。
