- en: Chapter 9. The History API – Not Forgetting Where We Are
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapter, we introduced Ajax, a collection of web techniques
    to update parts of the screen in web applications without having to create a link
    to a physically different page, have the browser request that new page from the
    server, and load it. Modern websites use this technique all over the place, as
    do their developers; Ajax is a common practice, a commodity almost.
  prefs: []
  type: TYPE_NORMAL
- en: The concept is, however, difficult to grasp by both the marketing people you
    have to work with and the visitors of your site. Doesn't it often occur that your
    marketing person asks you to add a page to the website and then wants to know
    what the URL is? It is **index.php**, honey, it always is. Visitors of your site
    who navigate through the menus will, when they hit the browser's back button,
    expect to look at the screen they just left. Instead they will be taken back to
    the website they were visiting before coming to yours, unless you use the techniques
    we are going to teach you in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: We will first describe the problem we are trying to solve; next, we will explain
    what the solution is in HTML5, as well as in HTML4 country.
  prefs: []
  type: TYPE_NORMAL
- en: The problem we are trying to solve
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Imagine a horizontal navigation menu where the visitor clicks on a menu item,
    just like the example we used in the previous chapter. In a classical website,
    the browser takes the visitor to a different page, for example, `galleries.php`,
    with its URL displayed by the browser. However, an Ajax-based site will simply
    update a part of the screen and not do anything with the URL bar each time the
    visitor clicks a menu item. No matter how many items they choose, once they push
    the browser's *BACK* button, they will find themselves back at the previous page,
    which will be the previous true page, and typically, a different website, and
    this is not where he expects to be.
  prefs: []
  type: TYPE_NORMAL
- en: We will solve this problem by using a technique that will restore the website
    to its previous state, as we cannot take it to the previous page. Before we go
    through the details, let's discuss a thing or two about **pushing** and **popping**
    states.
  prefs: []
  type: TYPE_NORMAL
- en: The self-service restaurant
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The best way to describe the technologies we are about to learn is to compare
    them with what you can find in any self-service restaurant. In such restaurants,
    you start by picking up a tray, and when you are done eating, you put the tray
    back. Now imagine a slightly different scenario. You are going to clean the tray
    before you put it back so that you can put it back on top of the same stack where
    you took it. The other difference you have to imagine is that, instead of having
    a multitude of trays that are all equally boring because they all look identical,
    every tray will have a different picture on it.
  prefs: []
  type: TYPE_NORMAL
- en: So, all these trays are part of a single stack. When you approach the stack,
    you can only see the picture that is on the top tray. If you add a tray to the
    stack, that picture will disappear as it is replaced by the one from the tray
    we place on top. We call that action **push**. Some old fashioned stacks have
    built-in springs, so you really have to push the tray down until it stays in place.
  prefs: []
  type: TYPE_NORMAL
- en: When you take a tray from the stack, the opposite will occur. The picture of
    the second tray becomes visible and the entire stack of trays pops up a little
    bit. That is why we call this action **pop** or **pop up**. Without self-service
    restaurants, there may have been no computer science, as this inspired many computer
    scientists in the field of formal grammar to create the theories of pop-up and
    push-down automata. I wrote my, obligatory to graduate, university paper on such
    a topic (no, we did not have a self-service restaurant there).
  prefs: []
  type: TYPE_NORMAL
- en: HTML5 History API and the history object
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Browsers use a similar stack called the `history` stack. In JavaScript, you
    can access it through the `history` object, for which there are several methods
    available. The history object is part of the window object and is accessed through
    the `window.history` property. It has been around for years.
  prefs: []
  type: TYPE_NORMAL
- en: Normally, when the user navigates to a new page, the browser pushes the new
    URL on to its history stack and downloads and draws the new page. When the user
    presses the back button, the browser pops one page off its history stack and redraws
    the previous page.
  prefs: []
  type: TYPE_NORMAL
- en: But what if we use Ajax calls to update parts of the screen without needing
    to load a new page? Then, nothing is going to be pushed on to that stack by the
    browser. Well, that is true, unless we do it ourselves. And the key to making
    this possible is the `popstate` event and the `history.pushState()` function.
  prefs: []
  type: TYPE_NORMAL
- en: pushState()
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Each time we create code to update part of the screen, as we did in the examples
    in the previous chapter, we should use the `pushState()` function to put some
    relevant information on to the history stack and, if we want to, change the URL
    string that is displayed by the browser. `pushState()` takes three arguments:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The first argument should be some structured data, such as an array of key/value
    pairs that we make as meaningful as possible. The data should contain enough information
    to allow us to restore the page in the shape it was when we issued the `pushState()`.
  prefs: []
  type: TYPE_NORMAL
- en: The second argument is intended to be a title of sorts to show up in the dropdown
    list of the browser's history. At the time of writing, there was not a single
    browser that implemented this.
  prefs: []
  type: TYPE_NORMAL
- en: 'The third argument, finally, is used to pass a string that is going to be our
    substitute URL for this state of the page. It is displayed by the browser, so
    once again, the visitor will believe he has landed on a different page. That URL
    string has a second purpose, which we will see at the end of this chapter. So,
    a possible `pushState()` statement related to some of the examples could be:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: So, the plate we just pushed on top of our stack in the browser self-service
    restaurant will have a picture of a key on it, labeled with the value of the variable
    `nav`, and a picture of an anchor, labeled `agenda`. The URL will be the same
    as before with a query string appended to it that also contains those two key/value
    pairs.
  prefs: []
  type: TYPE_NORMAL
- en: popstate event
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: After you've used the `history.pushState()` function to push a fake URL to the
    browser's `history` stack, when the user presses the back button, the browser
    will fire a `popstate` event on the `window` object. This is our chance to create
    the illusion that there are actually different pages and that we are moving our
    visitor back to what they believe is the previous one.
  prefs: []
  type: TYPE_NORMAL
- en: For this purpose, we create an event handler to execute some code each time
    a `popstate` event occurs. Most of the code we already have, because we used a
    function to draw a portion of the screen. We can simply reuse that.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: So, in the preceding code, we act on each `popstate` event by looking at our
    stack. If it is not empty but has a picture of an anchor labeled `agenda`, we
    look for the value of `key` and call the function `updateAgendaContent()`, with
    `key` as argument, to restore the part of the screen we always update to its previous
    state. Of course, this time we are not going to call `pushState()`. If we were,
    subsequent pushing of the back key would have no visible effect.
  prefs: []
  type: TYPE_NORMAL
- en: There is also the special case where we have run out of trays when the stack
    is empty. Then, we will need code that we may have not written yet. In the example,
    I used a placeholder function named `restoreHomePage()`. What should that function
    do? It should replace the variable portion of our screen with the initial content
    it had when our page was first loaded.
  prefs: []
  type: TYPE_NORMAL
- en: popstate and different browsers
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: At the time of writing, some browsers behaved differently than others. The current
    version of Safari will issue a `popstate` event on the initial page load, which
    can be utterly confusing. This also means that, in Safari, the `restoreHomePage`
    function will be called right after the initial page load. What that will do if
    your function is written correctly is replace the variable part of the screen
    with the exact same thing it already contains. Silly, isn't it? This may cause
    a small delay, and maybe some flickering, if the network is slow.
  prefs: []
  type: TYPE_NORMAL
- en: The History plugin
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `popstate` event and `pushState` method are part of the so-called **History
    API** that was introduced in HTML5\. This means that our magic will only work
    if HTML5 capable browsers are used. That is, of course, not good enough. There
    are still a lot of people that visit your site using HTML4 capable browsers, so
    what do we do?
  prefs: []
  type: TYPE_NORMAL
- en: Fortunately, several plugins for jQuery exist that allow you to use the same,
    or a similar, API and have your code work in both types of browsers. One even
    has a name that will make you think of self-service restaurants again (*BBQ*),
    but I have been using the so-called `jQuery history` plugin. At the time of writing,
    the plugin could be found at [https://github.com/browserstate/history.js](https://github.com/browserstate/history.js).
  prefs: []
  type: TYPE_NORMAL
- en: Bookmarking
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's move back from the self-service restaurant to our marketing person who
    wants to know which URL they can use to put in a document as a `link` to a page
    so that people can quickly access information that is found on the site. Perhaps
    they also want to know what to do if a visitor uses the `bookmark` feature of
    the browser to save the URL of a (in our case, virtual) page to revisit later.
    We can support this thanks to the URL parts we used in our `pushState` code.
  prefs: []
  type: TYPE_NORMAL
- en: 'In our examples, we made sure that we stored enough information about our updated
    page in the state that we pushed on the history stack, and you learned how to
    restore our page to its previous state using that information. In our `pushState`
    code, we appended a query string to the URL that basically contains the same information.
    We can retrieve that information using the `location` object of the browser and
    its `href` property. Here is the code that will, if the URL with query string
    is used, cause our single page website to go to the expected state:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Note that we have come a long way already. A few chapters back we would have
    guessed this to be only possible in a huge chunk of PHP code using GET variables
    to get to our key/value pairs, but now this is written entirely in JavaScript
    and Ajax.
  prefs: []
  type: TYPE_NORMAL
- en: In the previous example, a function was used called `QueryStringToJSON()`. This
    is not a standard JavaScript function. It is something you can write yourself
    or, like I did, grab off the Web. It dissects a query string and stores the key/value
    pairs into a JSON object. Yes, JSON! And what JSON is all about you will learn
    in the next chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we addressed one of the main drawbacks of using Ajax. You learned
    how to use the HTML5 History API to create the expected behavior when a visitor
    of our site pushes the browser's back key, or drops a URL that they previously
    bookmarked, into the browser's URL bar. Even though this API is for HTML5 capable
    browsers, you learned that there are jQuery plugins around to support this magic
    in HTML4 capable browsers as well.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the last few chapters, we started using Ajax more often to update only a
    portion of the screen, and to remain on the same page rather than loading a new
    one. As a consequence, we are exchanging smaller, but more frequent chunks of
    data between client and server. In the examples so far, the format of our data
    was HTML and it was all generated on the server. In the next chapter, you will
    learn two new formats for data exchange: **XML** and **JSON**.'
  prefs: []
  type: TYPE_NORMAL
