- en: Practical Usage of WordPress APIs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The use of application programming interfaces is common in modern websites.
    We use APIs such as Google Maps, Google Analytics, and Facebook to leverage the
    functionality of third-party services. Basically, APIs are created by developers
    to enable their features to other developers and platforms. Similarly, WordPress
    APIs let us use core features in a standard way to change and extend the functionality.
    We can also use these features to create our own APIs on top of WordPress and
    expose them to third-party services and platforms.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we are going to explore the available APIs, their functionality,
    and their use in development. We will be focusing more on three APIs that play
    a major role in custom development and yet have not been introduced in previous
    chapters. Developers often use WordPress shortcodes to provide pieces of reusable
    functionality, and the clients are familiar with using these shortcodes. So, we
    look into the techniques of creating shortcodes as well as identifying limitations.
    Next, we look at the importance of the Rewrite API in development tasks for building
    features without affecting the core features. Finally, we look at the REST API
    usage for enabling features to third-party developers through a standard interface.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: A brief overview of WordPress APIs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introducing Shortcode API
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating custom shortcodes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding the usage of shortcodes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Managing custom routes with Rewrite API
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Building remote connections with REST API
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By the end of this chapter, you should understand the API functions required
    for your development tasks. Also, you should be able to build reusable features
    with shortcodes and expose your features to third-party applications using REST
    API.
  prefs: []
  type: TYPE_NORMAL
- en: Technical Requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You will be required to have WordPress 4.9.8 installed to follow this procedure.
    Even if you have a later version of WordPress, the described examples should work
    with no significant problems.
  prefs: []
  type: TYPE_NORMAL
- en: 'The code files of this chapter can be found on GitHub:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://github.com/PacktPublishing/WordPress-Development-Quick-Start-Guide/tree/master/Chapter06](https://github.com/PacktPublishing/WordPress-Development-Quick-Start-Guide/tree/master/Chapter06)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Check out the following video to see the code in action:'
  prefs: []
  type: TYPE_NORMAL
- en: '[http://bit.ly/2EQa24y](http://bit.ly/2EQa24y)'
  prefs: []
  type: TYPE_NORMAL
- en: A brief overview of WordPress APIs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'WordPress API is a set of sub APIs that works together, allowing developers
    to build on top of core features. The individual APIs cover one or more core features,
    while some of the APIs can be used beyond WordPress''s core features. The REST
    API, Rewrite API. and Shortcode API are some of the ones we can use for WordPress''s
    core features, as well as custom features. The use of WordPress APIs reduces your
    workload as a developer, compared to building your own functions. Let''s take
    a look at the advantages of using APIs in WordPress:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Use of actions and filters**: WordPress API functions executes the necessary
    actions and filters within the process, allowing developers to customize the features.
    Using our own custom functions omits these actions and filters. Therefore, it
    will be difficult to combine or use many plugins together, as some of the plugins
    might be relying on these hooks within API functions.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Input validation and security**: The built-in API functions are developed
    and tested by the best WordPress developers in the world. Therefore, validation
    of the data and security in the process is highly reliable.  Using custom built
    functions instead of API functions increases the workload of the developer to
    implement these security features and validations.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Efficiency**: The built-in API functions are optimized to provide better
    performance when interacting with database as well as working with core features
    and files. So, using these functions improves the efficiency of your solutions.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Backward compatibility**: The WordPress team gives high priority to compatibility
    with older versions and hence rarely removes support for old functions and features.
    Therefore, using API functions guarantees the compatibility of the features in
    current WordPress versions, as well as future versions.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The preceding list explains why developers should use APIs whenever possible
    to save development time, as well as build risk-free solutions.
  prefs: []
  type: TYPE_NORMAL
- en: Using built-in APIs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As of the latest version, WordPress offers eighteen individual APIs to work
    with different parts of the core. We have already used some of the API functions
    in previous chapters. We are going to learn about a few APIs in detail throughout
    this chapter. Let''s take a look at the available APIs and their role in development:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Dashboard widget API**: It is used to add, edit, or modify the widgets on
    the admin dashboard. The dashboard is the location where each user is redirected
    after logging in from the backend. The default dashboard widgets includes **At
    a Glance**, **Quick Draft**, and **Activity**. This API is useful for building
    project-specific dashboards by removing unnecessary widgets and adding plugin
    specific widgets.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Database API**: It is used to simplify and optimize the operations in core
    database tables. We have already used core database API features using the `global $wpdb`
    object and query functions in [Chapter 2](3e88326a-c8fe-4943-ae81-4ff69e8b865e.xhtml),
    *Managing Database Structure, Storage, and Retrieval*.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**HTTP API**: It is used to securely execute HTTP operations such as sending
    requests for data or retrieving data. The API functions checks the server-supported
    connection types among various available connection types in PHP. We haven''t
    used the HTTP API in previous chapters.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**File Header API**: Itis used for working with file headers in themes and
    plugins. The functions of the API identifies themes and plugins using header comments
    section of files. From a developer''s perspective, the functionality of this API
    will not be commonly used in development tasks.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**File System API**: It is used for reading and writing local files to the
    filesystem on various hosting environments. From a developer''s perspective, the
    functionality of this API will not be commonly used in development tasks.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Metadata API**: It is used to work with WordPress meta object types in a
    standard way. WordPress provides meta tables for posts, users, and comments. These
    functions allows you to add, edit, modify, and delete post metadata with optimum
    performance. We already worked with the meta data API with the use of post meta
    functions such as `update_user_meta` and `get_user_meta` in [Chapter 5](40208ac9-c023-42b1-b48e-a368761b37a6.xhtml), *Extending
    Plugins with Addons, Filters, and Actions*. From a developer''s perspective, the
    functionality of this API is very important and commonly used in development tasks.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Options API**: It is used to work with the options table in WordPress for
    storing sitewide settings as well as theme and plugin-specific settings. These
    API functions allow you to add, edit, modify, and delete options with optimum
    performance. We already worked with the Options API with the use of  functions
    such as `get_option` and `update_option` in [Chapter 4](6bc0e5d5-b12d-4710-ac11-a600af054efa.xhtml), *Building
    Custom Modules with Plugin Development*. From a developer''s perspective, the
    functionality of this API is very important and is commonly used in development
    tasks.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Plugin API**: It is used in plugin development and hence it is important
    for you as a developer. The API consists of functions for managing WordPress hooks.
    We already worked with this API by using `add_filter`, `apply_filters`, `add_action`
    functions.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Quicktags API**: It is used to allow developers to add additional buttons
    to the **Text** mode of the WordPress content editor. We haven''t used this API,
    as it''s only focused on modifying the content editor. From a developer''s perspective,
    this API is important in scenarios where content creation is the primary feature
    of the site.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Settings API**: It is used to create and manage settings for your site as
    well as theme or plugins. You can use this API to add settings to existing settings
    pages of add your own custom settings sections to the WordPress Settings menu.
    This is one of the simplest methods to add and save settings, as most of the functionality
    is handled by the API. From a developer''s perspective, this API is very important
    for building any kind of site.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Theme Modification API**: It is intended for theme developers to add and
    retrieve settings of a theme as WordPress options. This API doesn’t play a vital
    role in development, unless you are building custom themes.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Theme Customization API**: It is used to customize theme settings, widgets,
    styles, and to see a preview of the changes instantly. You can access the features
    generated by this API using Appearance | Customize section. The developers can
    use this API to add their own settings, sections, and controls.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Transients API**: It is used to temporarily store or cache the information
    in `wp_options` table. Unlike WordPress options, transients have an expiration
    time and hence are only used for keeping information for short periods. The API
    functions allows you to store, retrieve, and delete transients with various options.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Widgets API**: It is used for creating and managing widgets in WordPress.
    In WordPress, a widget is a reusable piece of component that is mainly intended
    for the sidebar of the site. We will be discussing more about widgets and API
    functions in upcoming chapters.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**XML – RPC API**: It is used to expose the site functionality to third-party
    services and applications. This is the old way of providing API features, and
    it’s deprecating slowly with the emergence of REST API.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In this section, we had a brief overview of all the WordPress APIs except three.
    The APIs for shortcodes, rewrite rules, and REST play a major role in custom development,
    and hence we are going to discuss them in detail throughout the upcoming sections. You
    can view more details about the preceding APIs at [https://codex.wordpress.org/WordPress_API%27s](https://codex.wordpress.org/WordPress_API%27s).
  prefs: []
  type: TYPE_NORMAL
- en: Introducing shortcodes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Shortcode in WordPress is a piece of code that generates dynamic content for
    the site or alters a given content based on various requirements. This feature
    was introduced to allow users to add dynamic content to posts or pages. However,
    modern websites use shortcodes beyond its intended purpose. We can see shortcodes
    being used in widgets, template files, and even inside the plugin for improving
    reusability. The shortcode API is a set of functions allowing developers to easily
    create and use shortcode based on their preferences. Modern websites use advanced
    themes as well as numerous plugins for providing advanced features with eye-catching
    designs. Therefore, you will see an increased use of shortcodes. The shortcode
    is one of the simplest ways to add a feature to a site, and hence it's important
    to have thorough understanding of API functions.
  prefs: []
  type: TYPE_NORMAL
- en: Structure of a shortcode
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this section, we are going to understand WordPress shortcode by considering
    the perspective of different user types. As a developer, it''s important to understand
    all the three user perspectives to build and use shortcodes in development tasks.
    Let''s take a look at the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/9d20fe00-9482-4e47-808e-5580c98294ec.png)'
  prefs: []
  type: TYPE_IMG
- en: The preceding diagram is based on the three user perspectives involved in the
    process of using shortcodes.
  prefs: []
  type: TYPE_NORMAL
- en: The use of content is optional for a shortcode. We can find many self-enclosing
    shortcodes that generate the output without using any content.
  prefs: []
  type: TYPE_NORMAL
- en: Let's understand each of these three user perspectives.
  prefs: []
  type: TYPE_NORMAL
- en: Developer's perspective of a shortcode
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The developer is responsible for building the shortcode, unless you only plan
    to use the shortcodes available in the WordPress core. The shortcode needs to
    be created using the API functions and registered with WordPress using a plugin
    or theme. The preceding diagram shows the basic syntax of a shortcode from a developer’s
    perspective.
  prefs: []
  type: TYPE_NORMAL
- en: Content creator perspective of a shortcode
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Usually, the site administrator creates the content for most of the sites. However,
    you may also have other user roles or specific users with permission to create
    content. These users are responsible for using the shortcodes with necessary attributes
    and content in the site development process. The previous diagram illustrates
    the main syntax of a shortcode, where these users will use inside posts or pages.
  prefs: []
  type: TYPE_NORMAL
- en: They can use the shortcodes offered by WordPress core, theme, or plugins on
    the site. It's not a must for the content creator to know the source of the shortcode.
    However, the knowledge of whether a shortcode is generated from a theme, plugin,
    or WordPress core becomes handy in scenarios where you want to switch the theme
    or a plugin. Lack of knowledge in the source of the shortcode may lead to conflicts
    or even a complete breakdown of the site in such scenarios. These users are not
    aware of the source code of a shortcode, unless they want to explore the code
    inside theme or plugins.
  prefs: []
  type: TYPE_NORMAL
- en: User's perspective of a shortcode
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The user is anyone who visits the site, including guests and members. They will
    only see the output generated from the shortcode. These users are not aware of
    the existence of a shortcode, as the shortcode is not visible on the browser view
    or the page source. Also, the shortcode output doesn't have any predefined IDs
    or classes, and hence it’s not possible for these users to track a shortcode from
    the frontend.
  prefs: []
  type: TYPE_NORMAL
- en: Now you should have a basic idea of how WordPress shortcode is created and used
    to generate dynamic output. More details on the creation and use of a shortcode
    will be discussed in upcoming sections.
  prefs: []
  type: TYPE_NORMAL
- en: Using built-in shortcodes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'WordPress core contains set of built-in shortcodes mainly focused on adding
    various content types to posts and pages. The content creators can use these shortcodes
    directly on posts, pages, or any supported location without the need for any modifications.
    Let’s take a look at the existing shortcodes:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Audio**: It used for embedding and playing audio files'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Caption**: It used for adding captions to content. Mainly used for images'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Embed**: It used for embedding content from different sites supported by
    WordPress'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Gallery**: It used for displaying image galleries by passing the image ID''s'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Video**: It used for embedding and playing video files'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Playlist**: It used for displaying collection of audio and video files'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As you can see, these shortcodes don't use the main data of a WordPress site,
    such as posts, comments, users. So, we will have to work with shortcodes from
    external plugins or create custom shortcodes to cater for the functionality involving
    the WordPress database.
  prefs: []
  type: TYPE_NORMAL
- en: Building custom shortcodes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The process of building custom shortcodes is not as complex as many people
    think. The minimal implementation of a shortcode requires only few lines of code
    as shown in the diagram in the last section. A shortcode consists of four main
    parts:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Opening and closing tags**: Opening and closing tags are similar to HTML,
    WordPress shortcodes have opening and closing tags using square brackets. These
    tags are used by content creators to add the functionality into posts or pages.
    On the other hand, developers need to use this `tag` to register a shortcode as
    a unique element. Some of the shortcodes don’t have a closing tag and use a self-enclosing
    opening tag.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Attributes**: Attributes is a collection of data and settings required to
    process the functionality within the shortcode function and return the output.
    The list of attributes starts after the shortcode name in the opening tag. Each
    attribute has a key and values, as shown in the structure of a shortcode image.
    The attributes should be separated by one or more spaces. Inside the shortcode,
    developers can access the passed attributes using the array keys of the attributes
    variable.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Content**: Content is the content we add between the opening and closing
    tags of the shortcode. Once content is used, shortcode will act as a WordPress
    filter where we retrieve, process, and return the modified content. We can also
    define shortcodes without content by using a self-enclosing opening tag.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Output**: Output is the return value by the shortcodes based on the passed
    attributes and content. The output will be either content modified within the
    shortcode or the content will be used to capture and display site data. Many developers
    tend to print the shortcode output directly to the browser using PHP `echo` statements.
    However, shortcodes should always return the output instead of printing directly
    to the browser.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now we can move on to the process of creating custom shortcodes using these
    parts.
  prefs: []
  type: TYPE_NORMAL
- en: Creating custom shortcodes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this section, we are going to consider two scenarios to build custom shortcodes
    and explain the different kinds of uses of a shortcode. Let''s list the two requirements
    for building shortcodes for each one:'
  prefs: []
  type: TYPE_NORMAL
- en: Restricting the content based on a user's role
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Displaying a list of posts with attachments
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's get started.
  prefs: []
  type: TYPE_NORMAL
- en: Restricting content using a shortcode
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This scenario explains the creation of a shortcode using all the four shortcode
    components discussed in the previous section. Basically, we need a shortcode that
    accepts content and displays the output only to authorized users, while providing
    a custom output for unauthorized users. Let''s consider the shortcode needed for
    this scenario:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'The previous shortcode has one attribute for specifying the user roles not
    authorized to view the content and the content to be protected within the opening
    and closing tags. Now we have to match the previous shortcode with the code used
    in the *Structure of a shortcode* diagram. Consider the following code for the
    implementation of this shortcode:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: In this case, a callback function accepts attributes and content for the shortcode.
    WordPress provides a function called `shortcode_atts` to merge the passed attributes
    with default attributes and make an array of attributes required for processing
    the shortcode. It's a good practice to define the allowed attributes and default
    values inside the `shortcode_atts` function as an array. In this case, we are
    passing a value for the `role` parameter, and hence it will override the default
    parameter.
  prefs: []
  type: TYPE_NORMAL
- en: If we don't specify a value for a attribute, `shortcode_atts` will look for
    the default value. Next, we access the attributes using `$sh_attr` array and apply
    the conditions. Finally, we return the original content or a message based on
    the conditions. This is the most basic code required to build a shortcode.
  prefs: []
  type: TYPE_NORMAL
- en: Displaying posts with attachments
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This scenario explains a different use of a shortcode from both a developer''s
    perspective as well as a content creator''s perspective. Here, we need to display
    the list of posts with at least one attachment. Unlike the previous scenario,
    we are not retrieving and modifying the content. Instead, we are generating dynamic
    content based on the shortcode attributes. Let’s take a look at the shortcode
    needed for this scenario:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, there is no closing tag, and the closing part is done within
    the opening tag. These types of shortcodes are called as *self-enclosing* shortcodes.
    We don’t use any content in such shortcodes. In this case, we are displaying all
    the posts with attachments, and hence shortcode attributes are not required. If
    we were displaying posts with attachments for a specific category, the shortcode
    would have looked as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we can implement the previous shortcode by matching it with the syntax
    we used in our shortcode diagrams:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: In this case, we have no attributes, and hence we query the custom table by
    joining it with a posts table to generate the result. The `$content` variable
    will be empty, as we are not passing any data by using opening and closing tags.
    Finally, we return the HTML string to display the list of posts.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the usage of shortcodes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We discussed the techniques of building shortcodes in previous section. Now
    we need to understand the techniques of using these shortcodes in different parts
    of the site. Let''s take a look at the different locations where we can use shortcodes:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Posts and pages**: This is the most common use of a shortcode, where the
    content creator directly adds the shortcode to the post or page editor. Then,
    WordPress executes the shortcode and displays the result in the frontend post
    or page.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Widgets**: We can use shortcodes inside WordPress widgets to provide dynamic
    content similar o the posts and pages. However, we have to use additional code
    depending on the widget we use. The WordPress **Text widget** allows you to add
    shortcodes directly to the content editor and display the output on the frontend.
    Sometimes, you may want to use the shortcodes with HTML elements and hence need
    to use the **HTML widget** instead of the **Text widget**. The HTML widget doesn’t
    support shortcodes by default. So, we have to use the following code in the `functions.php`
    file of the theme or within any plugin to execute the shortcode:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: WordPress has a filter called `widget_text` that gets executed on the content
    of all widgets. We can use this filter to change the content as required. So far,
    we used `add_filter` statement with a callback function. Here, we also have a
    callback function called `do_shortcode`. However, you might be wondering why the
    implementation is missing. The `do_shortcode` function is built into WordPress,
    and hence we can directly call it without adding an implementation for the function.
    This function executes any shortcodes within the content.
  prefs: []
  type: TYPE_NORMAL
- en: '**Template Files**: Sometimes, we may need to call shortcodes inside a header,
    footer, or any template file. This becomes handy when you are customizing existing
    themes to integrate the features of other plugins. In such scenarios, adding the
    shortcode to the template file won’t work. We have to use a PHP script and execute
    the shortcode using `do_shortcode` function. Consider the following code for using
    a shortcode inside a template file:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: We need to also use the `echo` statement to print the output to the browser,
    as it's not automatically printed as in previous scenarios.
  prefs: []
  type: TYPE_NORMAL
- en: '**Plugins and themes**: Sometimes, we want to integrate the shortcode features
    with other plugins or themes. In such cases, we can directly call the shortcode
    instead of replicating the code for the shortcode. Assume we want to display the
    posts with attachments after the content of each post. In this scenario, we can
    internally call the shortcode within our plugin and generate the list of posts
    with attachments instead of writing a separate function or duplicating code. Consider
    the following statement for using a shortcode within a theme or a plugin code:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These are some of the common methods and locations for using shortcodes.
  prefs: []
  type: TYPE_NORMAL
- en: Tips for using shortcodes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The shortcode is a simple and flexible way of adding reusable functionality
    to a site. However, there are pros and cons of using shortcodes. As a developer,
    you need to understand when to use shortcodes and how to build quality shortcodes.
    The following tips will help you improve the shortcodes, as well as avoid unnecessary
    issues:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Filtering shortcode output**: Usually, we create some content within the
    shortcode and directly return the content as output. There are some plugins that
    use a filter on the output of a shortcode. It''s a great way of adding more flexibility
    where the developers can control the shortcode output of other plugins.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Using nested shortcodes**: We can add shortcodes inside other shortcodes
    to get an output. However, when using nested shortcodes, you need to use `do_shortcode`
    in the main shortcode to execute the shortcodes within its content.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Validating shortcode attributes**: Attributes are added by the content creators
    and hence need to be considered as user input. Since we shouldn''t trust any kind
    of user input, validation is a must for attribute values.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Using unique shortcode names**: Many plugins use generic shortcode names
    such as `[product]`, `[event]`, and so on. This may lead to conflicts with multiple
    plugins, and hence you should always use a plugin-specific prefix to make it unique.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Overuse of shortcodes**: Shortcode is an easy way of adding a bunch of content.
    However, using too many shortcodes inside posts or pages can lead to maintenance
    nightmares in later stages. As the post or page is dependent on shortcodes, it
    will be difficult to change the content.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We have covered the process of creating and using shortcodes. Now it's time
    to take a look at plugins that use shortcodes and identify various uses and developing
    techniques.
  prefs: []
  type: TYPE_NORMAL
- en: Managing custom routes with Rewrite API
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The default WordPress URL structure uses query parameters to load the necessary
    posts and pages. So, the URL of a post will look like [http://www.example.com/?p=130](http://www.example.com/?p=130).
    This is not ideal, as its difficult to remember the post ID and search engines
    won't give a higher preference to such URLs. Therefore, we need a better URL structure
    that doesn't use query parameters and gives a SEO-friendly URL. So, we use the
    WordPress permalinks section to change the URL structure. Then, WordPress will
    internally convert those SEO-friendly URLs to the default URL structure. We can
    access the permalinks settings section from Settings | Permalinks. Let's choose
    *Post Name* as the URL structure for our site. Then, the preceding URL will be
    converted to `http:// www.example.com/sample-post/`.
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, this is a much more user and SEO-friendly URL structure. Once
    the permalinks are set up, all the WordPress core features in the frontend will
    use this structure. However, in custom development, we may need custom URL structures
    to handle the functionality. In such cases, we can use Rewrite API to define our
    own routes and manage the functionality without interfering with default WordPress
    features.
  prefs: []
  type: TYPE_NORMAL
- en: '**What is Rewrite API?**'
  prefs: []
  type: TYPE_NORMAL
- en: 'WordPress Rewrite API is a set of functions that allows you to manage custom
    routes using tags, rules and endpoints. Let’s identify the functions used for
    implementing with Rewrite API:'
  prefs: []
  type: TYPE_NORMAL
- en: '`add_rewrite_rule`: This function is used to register new rewrite rules to
    WordPress for generating custom templates.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`add_rewrite_tag`: This function is used for registering new query variables.
    We need to use it with `add_rewrite_rule` to create rewrite rules for custom templates.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`add_rewrite_endpoint`: This function is used to create extra rewrite rules
    for WordPress core components.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`flush_rewrite_rules`: This is used to remove rewrite rules and then recreate
    rewrite rules.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In this section, we are going to create and manage custom rules using these
    functions except `add_rewrite_endpoint`. You can view more details about rewrite
    endpoints at [https://codex.wordpress.org/Rewrite_API/add_rewrite_endpoint](https://codex.wordpress.org/Rewrite_API/add_rewrite_endpoint).
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the need for custom routes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The use of custom routes becomes vital in developing plugins that goes beyond
    the default WordPress features. We are going to consider two scenarios to understand
    the need for custom rewriting:'
  prefs: []
  type: TYPE_NORMAL
- en: Assume we have a shortcode that is used to display user profile details and
    we use it inside a WordPress page called **Profile**. So, the URL of the page
    will be [http://www.example.com/profile](http://www.example.com/profile). Now,
    we need to use the same page to display user details of each user. Currently,
    it’s not possible, since we don’t have a way to identify the user when accessing
    this page. So, we need to modify the URL in a way that we can identify each user.
    Let’s assume we have a URL like [http://www.example.com/profile/john123](http://www.example.com/profile/john123)
    with the username after the page. Then, we can use the username component to identify
    the user and display the profile details. In this scenario, we have to use Rewrite
    API functions to match the URL with necessary query parameters and execute our
    functionality.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As we already discussed, adding shortcodes to such an important functionality
    can become an issue when the administrator deletes or removes the shortcodes by
    mistake. So, relying on posts or pages to handle such functionality can be considered
    as a risk. In such cases, we can avoid risk by using custom URLs that don't use
    posts or pages. Assume we want to display a login form at [http://www.example.com/user/login](http://www.example.com/user/login)
    and registration at [http://www.example.com/user/register](http://www.example.com/user/register).
    By default, these URLs will redirect to the *404 Not Found Page* when you don't
    have a post or page called *user*. So, we need to use Rewrite API to register
    custom routes and manage these URLs to offer custom features without interfering
    with core WordPress features.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In this section, we are going to implement the second scenario, as handling
    custom URLs without posts or pages is the ideal solution for custom features.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the routing rules
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We can use `add_rewrite_rule` function to register new custom routes with WordPress.
    This function can be implemented within many actions in WordPress. However, we
    usually use `init` action to handle the rewrite rules. Let''s add a custom rewrite
    rule to handle the scenario of user login and registration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'You can find the code for this section inside the `wpquick-rewrite-api` plugin
    in the source codes directory. The `add_rewrite_rule` function accepts two required
    and one optional parameters. Let’s take a look at the parameters and their role:'
  prefs: []
  type: TYPE_NORMAL
- en: '`regex`: This is the first parameter that matches the URL to the rule using
    a regular expression.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`redirect`: This is the second parameter that specifies the URL to request
    when current URL is matching the regular expression. As you can see, we pass the
    request to `index.php` with custom parameters that uniquely identify our functionality.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`after`: This optional parameter decides when to use this rewrite rule. If
    a `top` value is used, the rewrite rule will take precedence over other default
    WordPress rewrite rules. If a `bottom` value is used, preference will be given
    to existing rules.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now, you might think we can access `wpquick_action` using `$_GET` query parameters
    and implement the functionality for both login and registration. However, you
    won’t get `wpquick_action` as a `$_GET` parameter. WordPress doesn't allow you
    to use any type of variable in the query string. It will check for query variables
    within the existing list, and all other variables will be ignored. So, we have
    to specify the custom query variables before we can actually use them in code.
  prefs: []
  type: TYPE_NORMAL
- en: Adding query variables
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'WordPress has over 40 params registered to be used in queries. Let''s check
    the existing query variables before adding custom query variables. Add the following
    code to main file of `wpquick-rewrite-api` plugin and open the home page of your
    site:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'You will see all the existing query parameters as an array. Now we need to
    create our own query parameters to handle user login and registration. So, we
    add the following code to the `wpquick-rewrite-api` plugin:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: The `query_vars` is a built-in filter that allows us to add or remove query
    variables before the request is processed. In this scenario, we add a new query
    parameter called `wpquick_action` to the existing query parameters array.
  prefs: []
  type: TYPE_NORMAL
- en: WordPress core and other plugins registers considerable number of query variables.
    So, it's better to use a unique name with a prefix to avoid conflicts with query
    parameters in other plugins.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we have the ability to access `wpquick_action` variable from the URL. In
    this scenario, I used the `query_vars` filter to add new query variables and for
    the purpose of identifying built-in query variables. Rewrite API provides a function
    called `add_rewrite_tag` to implement the same functionality, and it’s the recommended
    way. So, we can remove the `query_vars` filter from our plugin and change the
    `wqraf_manage_user_routes` function as following to get the same functionality:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: The first parameter takes the **action name** surrounded by a `%` and the second
    parameter defines a `regex` to validate the value. Adding rewrite tags is relatively
    easy compared to using `query_vars` filter.
  prefs: []
  type: TYPE_NORMAL
- en: We modified the WordPress rewrite rules by adding a new rule. So, we have to
    flush the rewrite rules before the new rule takes effect. There are two ways to
    flush rewrite rules. First, we can visit Settings | Permalinks section to automatically
    refresh the rewrite rules. However, this is not ideal in development, as the user
    needs to manually go into the **Settings** section. So, we need a way to flush
    the rewrite rules automatically within our plugin, without needing an input from
    the user.
  prefs: []
  type: TYPE_NORMAL
- en: Flushing the rewriting rules
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We can easily flush the rewrite rules by calling WordPress `flush_rewrite_rules`
    function inside the `init` action. However, it will flush the rewrite rules on
    every request, generating unnecessary performance overhead. So, we need to use
    activation handler of the plugin to flush the rules. Let''s see the following
    implementation inside the activation handler:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Now go to the admin panel, deactivate the plugin, and activate the plugin again.
    Then, go to the URL [http://www.example.com/user/login](http://www.example.com/user/login)
    and check whether it works. Unfortunately, you will still get the 404 error for
    the request. You might be wondering what went wrong. Let''s go back and think
    about the process to understand the issue. We flushed the rules on plugin activation.
    So, the new rules should persist successfully. However, we define the rules on
    the `init` action, which is only executed after the plugin is activated. Therefore,
    new rules will not be available at the time of flushing. So, we have to update
    the function as follows to get it working:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Now deactivate and activate the plugin again. Then, go to the URL [http://www.example.com/user/login](http://www.example.com/user/login).
    This time, you won't get the 404 errors, as the rewrite rule is added and flushed
    properly. Now we are ready with our routing rules for user functionalities.
  prefs: []
  type: TYPE_NORMAL
- en: Displaying content for custom routes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We have to build a custom route to manage the login and registration of the
    site. Now we need to access the custom query variable from the custom route and
    generate the screens for login and registration. Consider the following code for
    the implementation of login and registration forms:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: WordPress executes the `template_redirect` action just before deciding which
    template to load. So, we can use this action to intercept the request and load
    our own template. First, we access the `wpquick_action` value using the `$wp_query`
    global object. This variable will contain either register or login in this scenario.
    Then, we use a `switch` statement to filter the action and load the necessary
    template. Here, we are only printing a title for explanations. You have to generate
    the login or registration forms instead of the title.
  prefs: []
  type: TYPE_NORMAL
- en: Since we are intercepting the request, our content will be loaded instead of
    the WordPress template. Here, it will only print the title without the header,
    footer, or other parts of the WordPress template. So, you have to generate a complete
    template by including header, footer, content area, and sidebars.
  prefs: []
  type: TYPE_NORMAL
- en: We have looked at the process of using Rewrite API functions to create custom
    routes and load custom templates for your plugins. This will become handy when
    developing advanced plugins with non-WordPress specific screens.
  prefs: []
  type: TYPE_NORMAL
- en: Building remote connections with REST API
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: WordPress REST API is gaining popularity over the old XML-RPC API and becoming
    a standard in site development. The API allows developers to connect WordPress
    sites with other sites as well as third-party applications. Modern sites are moving
    towards JS Framework-based frontends to optimize performance as well as to simplify
    the user experience. In such scenarios, developers can use WordPress as the backend
    for the core functionality and expose the data through the REST API to build frontends
    without using WordPress. The REST API could well be the future of development
    with WordPress.
  prefs: []
  type: TYPE_NORMAL
- en: The REST API was initially introduced in a external plugin for testing. Finally,
    it was included in WordPress core in WordPress 4.7, and now it fully supports
    REST API endpoints for all the major data models in WordPress.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s identify some of the common terms used in REST API operations:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Route**: This is a well-defined URL that can be mapped to an HTTP method'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Endpoint**: The process of matching a specific route to a HTTP method'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Request**: The call to an API endpoint with the necessary data'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Response**: The data provided by an API to a specific request'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Schema**: This is used to structure API data and provide info on the available
    properties and input parameters for API requests'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introducing core REST API endpoints
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: WordPress provides built-in API endpoints for working with most of the main
    core features. The documentation defines the endpoints, attributes, and example
    requests, simplifying the learning curve for developers. In this section, we are
    going to look at the core REST API endpoints and the use of test requests to understand
    the process. You can check all the available endpoints and additional information
    in WordPress REST API documentation at [https://developer.wordpress.org/rest-api/reference/](https://developer.wordpress.org/rest-api/reference/).
    The WordPress REST API is enabled by default. You can check whether an API is
    enabled on your site by accessing [http://www.example.com/wp-json](http://www.example.com/wp-json)
    in the browser. If the API is enabled, you will get a large JSON string with the
    available settings and endpoints.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding and testing Core API endpoints
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have to identify and understand the use of API endpoints, arguments, and
    return data formats to build features with API functions. Testing API requests
    is the best way to understand the process. We can use an existing tool to simplify
    the API request testing process. There are many such tools and we are going to
    use the Postman extension of Google Chrome browser.
  prefs: []
  type: TYPE_NORMAL
- en: '**Postman** is a tool that simplifies the process of managing APIs by offering
    features such as testing API requests, building API documentation, and monitoring
    API usage. This tool also provides many additional API-related features in both
    free and PRO versions. The free extension is more than enough to work with basic
    API testing for your projects. You can use the PRO version for advanced features
    such as team colloboration, creating mock servers and integrations with many third-party
    APIs.'
  prefs: []
  type: TYPE_NORMAL
- en: 'You can install the extension in your chrome browser from [https://www.getpostman.com/](https://www.getpostman.com/).
    Once installed, you will get a standalone app, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/8e87c0d8-6c90-4076-b11a-6423bed1fbb7.png)'
  prefs: []
  type: TYPE_IMG
- en: Now we are ready to test API requests with WordPress REST API. Mainly, we use
    HTTP `GET` and `POST` requests in development tasks. However, this tool provides
    the ability to use various HTTP request types, such as `PUT` and `DELETE`. The
    REST API contains endpoints that allows us to directly use GET requests as well
    as `POST` requests which requires authentication. So, we are going to check both
    types of requests.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s start by testing a GET request. Basically, these endpoints exposes the
    existing data in WordPress. First, you have to enter the URL of the endpoint in
    Enter request URL field and select the HTTP request as `GET`. The endpoint needs
    to be added after the  [http://www.example.com/wp-json/](http://www.example.com/wp-json/)
    section in the URL. So, the request for accessing the list of posts via REST API
    looks similar to the parameters shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/f12f53cc-9f6a-4a6c-92c1-1b3b54d3f9d7.png)'
  prefs: []
  type: TYPE_IMG
- en: The screen on the bottom displays the result of the request in the format we
    choose. We have to choose JSON as the result type, since successful API requests
    returns JSON data. Since we are using GET requests, the Type was also set as No
    Auth.
  prefs: []
  type: TYPE_NORMAL
- en: Now we can move forward to testing POST requests for retrieving data for display
    as well as modifying the database through API requests. Testing POST requests
    require more work compared to using GET requests. These requests always require
    some authentication and return an error when valid authentication is not available.
    So, first. you have to add the URL in **Enter request URL** and select the method
    as `POST`. Next, go to **Authorization** tab and select Basic Auth as the type.
    Then add the Username and Password of a user in your site with post creation and
    edit capabilities.
  prefs: []
  type: TYPE_NORMAL
- en: 'Generally, POST requests need additional parameters and values. Here, we are
    trying to create a post, and hence you can add the post details as key-value pairs
    in the form-data section of Body tab. Finally, click on the **Send** button to
    send the API request. However, you will get the following error message instead
    of creating the post:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'You might be confused why it''s returning a permission error even when we have
    provided basic authentication details. WordPress considers Basic Auth as an unsafe
    way of handling REST API requests, and, hence, **Basic Auth** is disabled by default.
    So, we have to use a plugin called **JSON Basic Authentication** by the WordPress
    API Team. This plugin is included in the source code folder for this chapter.
    Once this plugin is activated, you can send the request again and will see the
    response and form parameters, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/7954b0a4-50e6-41e2-a2d3-c0d9d688f641.png)'
  prefs: []
  type: TYPE_IMG
- en: The response will contain the details about the newly created post from our
    request. You can use `UPDATE` and `DELETE` operations similarly by changing the
    request type and providing necessary parameter values.
  prefs: []
  type: TYPE_NORMAL
- en: Basic Auth is not a recommended way of authenticating the REST API, since we
    have to transfer username and password details in each request in plain text format.
    So, the WordPress team suggests that we should only use Basic Auth for testing
    purposes or in highly secured private networks only.
  prefs: []
  type: TYPE_NORMAL
- en: Managing custom routes and endpoints
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The real power of REST API comes with the usage of custom routes and endpoints.
    There are certain limitations in adjusting existing routes and endpoints to our
    requirements. In some scenarios, we may have to create our own classes and extend
    the WordPress core classes to achieve custom functionality. So, custom routes
    and endpoints allow us to implement custom REST API features with minimum work,
    without interfering with WordPress core REST API features.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this section, we are going to implement the following features to learn
    the basics of custom REST API routes and endpoints:'
  prefs: []
  type: TYPE_NORMAL
- en: Disable the default post endpoint and use custom routes to expose posts only
    in selected categories with selected post data
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Provide REST API access to custom table data by listing available attachments
    in a post
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Let's start the implementation of these two features.
  prefs: []
  type: TYPE_NORMAL
- en: Creating custom routes for posts
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The default post related endpoint is accessible through `/wp/v2/posts`. We can
    execute a `GET` request on this endpoint without any parameters to retrieve the
    list of posts with all the main post details. Let's assume we want to use custom
    routes for each functionality in this endpoint to have more control over the post-related
    API requests. So, we have to block the existing endpoint before defining our own
    routes.
  prefs: []
  type: TYPE_NORMAL
- en: 'We are going to use a new plugin called **WQ REST API** to implement the features
    required for the REST API section of this chapter. You can use the plugin creation
    technique discussed in previous chapters to create the plugin with a main file.
    Let''s block the default post endpoint by using the following code inside the
    main file of the plugin:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'WordPress provides a filter called `rest_endpoints` to filter the existing
    endpoints and customize them by either removing or creating new ones. In this
    scenario, we have disabled the default post related endpoint by unsetting it from
    the endpoints array. This will remove the ability to list, create, update, and
    delete posts. So, we have to define custom routes for each of those features or
    use the same custom route to support all the post-related operations. Let''s start
    by adding a custom route to provide post data to third-party sources:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'The REST API includes an action called `rest_api_init`, which gets fired before
    executing an API request. Therefore, it’s the recommended action to introduce
    new routes to the API. Inside the callback function, we use the `register_rest_route`
    function to create new routes for our application. Let''s identify the basic parameters
    used in `register_rest_route` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '`namespace`: This will be the first URL segment after the main REST API URL.
    Here, we have used `wqra/v1`, and, hence, it will replace the `wp/v2` we used
    for accessing core WordPress routes.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`route`: This is the base URL for the route. Here, we have used `read_posts`
    as the route, and it will replace the default route of posts.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`methods`: Here, we have used the method as `WP_REST_Server::READABLE`. It
    makes sure that our custom route works when `WP_REST_Server` changes our readable
    endpoints. The *readable* constant of `WP_REST_Server` class is an alias of the `GET`
    method.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`callback`: This is the function that gets executed when a route is matched
    to a given endpoint. We have defined a callback function called `wqra_read_posts_handler`.
    All the post data that should be sent in the REST API response is prepared within
    this function.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`permission_callback`: This is the function used to check the permission of
    the request before executing the callback function. We have returned TRUE to provide
    permission. In real scenarios, we need to check user permissions using `current_user_can`
    function and return the Boolean value based on the user permission levels.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Now we can look into the implementation of our callback function for generating
    the posts list specific for the web site. Consider the following implementation
    of the `wqra_read_posts_handler` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: First, we use `WP_Query` object to pass custom settings and generate the list
    of posts based on our requirements. In this case, we are only allowing API users
    to view posts, except the ones from chosen categories. Then, we only add the post
    ID and title of the post, as we only want to provide these two pieces of data
    for API users. The default posts list gives access to all the main data of a post,
    and hence it’s not suitable for our requirements. Finally, we pass the resulted
    data array to the `rest_ensure_response` function. This function converts our
    data to JSON and returns the response compatible with `WP_REST_Response`.
  prefs: []
  type: TYPE_NORMAL
- en: Creating custom routes and endpoints for custom table data
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous section, we looked at the process of disabling existing API
    endpoints and creating our own endpoints to handle core WordPress data. The default
    WordPress REST APIs don't have any routes or endpoints for working with custom
    table data. So, we have to always use our own custom routes and endpoints for
    manipulating custom table data.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the previous chapters, we created a plugin to add attachments to posts.
    Now we are going to create a custom API endpoint that allows us to retrieve the
    attachments of a given post. Let''s start by adding another custom route to our
    REST API plugin, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: We use the same namespace as on the last occasion and use `list_post_attachments`
    as the new route. Also, we have an additional parameter in brackets, where we
    can pass the ID of the post. We have also set the method to `POST` instead of
    using `GET`. Since we are retrieving records and passing the ID in URL, we could
    have used `GET` as the method. However, we have enabled `POST` method so that
    we can pass additional parameters and filter the results. We have used a new callback
    function, `wqra_list_post_attachments_handler`, to handle the new custom route.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this scenario, there is an additional parameter called `args` compared to
    the previous custom route. This `args` array is used to specify additional parameters
    for the route. In this case, we use it to validate the parameters passed to the
    endpoint. The post ID is a numeric value, and hence we need to validate it before
    executing the REST API request. So, we execute the `validate_callback` function
    of the ID parameter. If you pass string value for the post ID, you will get the
    following invalid parameter error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'We can use this technique to validate multiple parameters with different conditions
    and make sure requests only contain the data in requested formats. Now we can
    move into the implementation of the `wqra_list_post_attachments_handler` function
    for handling the request to the new route:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: The REST API request object is passed to this function as a parameter. So, we
    use the `get_params` function of the `$data` object to retrieve the available
    parameters in the request. Next, we capture the post ID using the `id` attribute
    of the `$data` object. Next, we execute a custom query on the `wpqpa_post_attachments`
    table. The result will contain the file attachments for the given post. Then,
    we traverse through the results and assign the attachment details in to an array.
    Finally, we use the `rest_ensure_response` function to pass the attachment data
    in JSON format to the response.
  prefs: []
  type: TYPE_NORMAL
- en: There are also some disadvantages in using custom routes and endpoints, in situations
    where we have the ability to use existing routes and endpoints. We need to implement
    our own pagination and sorting for custom endpoints while WordPress provides them
    by default for existing endpoints. We can use user permission checks by default
    in WordPress core endpoints while we need to pass additional nonce parameters
    to check user permissions.
  prefs: []
  type: TYPE_NORMAL
- en: Now we can call this new route and retrieve the file attachments list for a
    given post.
  prefs: []
  type: TYPE_NORMAL
- en: Building the REST API client
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The API client is the user or service that uses the data provided by the REST
    API. We use the client to access the REST API of another site. The client site
    could be WordPress or a non-WordPress site. The client can also be implemented
    in a different programming language without using PHP. Let's identify the usage
    of API clients. In this chapter, we going to look at the process of building REST
    API client to access our data from external sites, as it's the most important
    use of an API.
  prefs: []
  type: TYPE_NORMAL
- en: REST API client from external site
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This is where the REST API is used to its maximum potential, even though we
    use it to build functionality of the same site. The main intention of creating
    a REST API is to provide access to third-party WordPress and non-WordPress based
    applications. So, the API client can be implemented in any programming language.
    In this section, we will be building a PHP based API client for accessing REST
    APIs of other applications with the support of CURL.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s add the API client implementation with CURL. You should place this code
    in a PHP file and access it from a source external to your application:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'We create a function called `wpquick_rest_api_client` to accept two parameters
    for the API endpoint: URL and the post data. Then, we initialize a `curl` request
    by executing `curl_init` function on the specified route. Next, we add the authorization
    header with a base-64 encoded string containing the combination of `username:password`.
    We need some sort of authenticate method to execute POST and DELETE requests.
    We should only use an authorization header for testing purposes. We will be discussing
    various authentication techniques in the next section. Then, we will specify the
    necessary `curl` parameters and add the post data to the request, if it''s provided.
    Finally, we execute and print the API response returned from the server.'
  prefs: []
  type: TYPE_NORMAL
- en: Now we have a basic API client function, and we can call the function with necessary
    parameters to execute REST API requests, as shown in the preceding code. In this
    case, we are retrieving the file attachments of the forum with the ID 5 as a JSON
    string. If we request the ID as a string, we will get an invalid parameter error,
    since it's validated and restricted in our route. So, we have identified the process
    of building an API client to access the site from external sources.
  prefs: []
  type: TYPE_NORMAL
- en: REST API is becoming the trend in modern web applications, and hence WordPress
    seems to provide more and more features to build fully functional REST APIs for
    applications. So, in the future, we will see the emergence of REST as a must-use
    WordPress feature.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: WordPress APIs are built for simplifying and standardizing the use of WordPress's
    core features. We can use these API functions to build future-proof solutions
    without spending unnecessary time on development.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we looked at the importance of using WordPress APIs and had
    a brief introduction to the functionality of each API. We choose three API's that
    play a major role in development, and we discussed them in detail. We started
    by understanding the structure and usage of a shortcode. Then, we discussed various
    techniques and locations for using shortcodes. Next, we moved into Rewrite API,
    which manages custom routes for custom features that go beyond WordPress's core
    features. Finally, we looked at the REST API for developing API functions and
    exposing application data to third-party services.
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 7](1a709b5f-c476-41f9-bc13-eb5f0541abaa.xhtml), *Managing Custom
    Post Types and Processing Forms,* we will be exploring two of the most important
    aspects in WordPress development by teaching the user of custom post types to
    build various features and use custom forms to capture and display advanced data.
  prefs: []
  type: TYPE_NORMAL
