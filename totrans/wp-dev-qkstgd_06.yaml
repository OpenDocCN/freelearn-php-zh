- en: Practical Usage of WordPress APIs
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: WordPress APIs 的实际应用
- en: The use of application programming interfaces is common in modern websites.
    We use APIs such as Google Maps, Google Analytics, and Facebook to leverage the
    functionality of third-party services. Basically, APIs are created by developers
    to enable their features to other developers and platforms. Similarly, WordPress
    APIs let us use core features in a standard way to change and extend the functionality.
    We can also use these features to create our own APIs on top of WordPress and
    expose them to third-party services and platforms.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在现代网站上，应用程序编程接口的使用很常见。我们使用 Google Maps、Google Analytics 和 Facebook 等API来利用第三方服务的功能。基本上，API是由开发者创建的，以使他们的功能对其他开发者和平台可用。同样，WordPress
    APIs让我们能够以标准方式使用核心功能来改变和扩展功能。我们还可以使用这些功能在WordPress之上创建自己的API，并将它们暴露给第三方服务和平台。
- en: In this chapter, we are going to explore the available APIs, their functionality,
    and their use in development. We will be focusing more on three APIs that play
    a major role in custom development and yet have not been introduced in previous
    chapters. Developers often use WordPress shortcodes to provide pieces of reusable
    functionality, and the clients are familiar with using these shortcodes. So, we
    look into the techniques of creating shortcodes as well as identifying limitations.
    Next, we look at the importance of the Rewrite API in development tasks for building
    features without affecting the core features. Finally, we look at the REST API
    usage for enabling features to third-party developers through a standard interface.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将探讨可用的API、它们的功能以及在开发中的应用。我们将更多地关注在自定义开发中起主要作用但尚未在前几章中介绍的三个API。开发者经常使用WordPress短代码来提供可重用功能，客户也熟悉使用这些短代码。因此，我们研究了创建短代码的技术以及识别限制。接下来，我们探讨Rewrite
    API在构建不影响核心功能的功能中的重要性。最后，我们查看REST API的使用，通过标准接口使功能对第三方开发者可用。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章我们将涵盖以下主题：
- en: A brief overview of WordPress APIs
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: WordPress APIs 的简要概述
- en: Introducing Shortcode API
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 介绍短代码 API
- en: Creating custom shortcodes
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建自定义短代码
- en: Understanding the usage of shortcodes
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解短代码的使用
- en: Managing custom routes with Rewrite API
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Rewrite API管理自定义路由
- en: Building remote connections with REST API
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 REST API 建立远程连接
- en: By the end of this chapter, you should understand the API functions required
    for your development tasks. Also, you should be able to build reusable features
    with shortcodes and expose your features to third-party applications using REST
    API.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章结束时，你应该了解开发任务所需的 API 函数。此外，你应该能够使用短代码构建可重用功能，并通过 REST API 将你的功能暴露给第三方应用程序。
- en: Technical Requirements
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: You will be required to have WordPress 4.9.8 installed to follow this procedure.
    Even if you have a later version of WordPress, the described examples should work
    with no significant problems.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 遵循此程序需要安装 WordPress 4.9.8。即使你有 WordPress 的更高版本，描述的示例也应该没有重大问题地运行。
- en: 'The code files of this chapter can be found on GitHub:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的代码文件可以在GitHub上找到：
- en: '[https://github.com/PacktPublishing/WordPress-Development-Quick-Start-Guide/tree/master/Chapter06](https://github.com/PacktPublishing/WordPress-Development-Quick-Start-Guide/tree/master/Chapter06)'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/PacktPublishing/WordPress-Development-Quick-Start-Guide/tree/master/Chapter06](https://github.com/PacktPublishing/WordPress-Development-Quick-Start-Guide/tree/master/Chapter06)'
- en: 'Check out the following video to see the code in action:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 查看以下视频，以查看代码的实际运行情况：
- en: '[http://bit.ly/2EQa24y](http://bit.ly/2EQa24y)'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: '[http://bit.ly/2EQa24y](http://bit.ly/2EQa24y)'
- en: A brief overview of WordPress APIs
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: WordPress APIs 的简要概述
- en: 'WordPress API is a set of sub APIs that works together, allowing developers
    to build on top of core features. The individual APIs cover one or more core features,
    while some of the APIs can be used beyond WordPress''s core features. The REST
    API, Rewrite API. and Shortcode API are some of the ones we can use for WordPress''s
    core features, as well as custom features. The use of WordPress APIs reduces your
    workload as a developer, compared to building your own functions. Let''s take
    a look at the advantages of using APIs in WordPress:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: WordPress API 是一组协同工作的子API，允许开发者在核心功能之上构建。单个API涵盖一个或多个核心功能，而一些API可以用于WordPress核心功能之外。REST
    API、Rewrite API 和 Shortcode API 是我们可以用于WordPress核心功能以及自定义功能的一些API。与构建自己的函数相比，使用WordPress
    API可以减少你的开发工作量。让我们看看在WordPress中使用API的优势：
- en: '**Use of actions and filters**: WordPress API functions executes the necessary
    actions and filters within the process, allowing developers to customize the features.
    Using our own custom functions omits these actions and filters. Therefore, it
    will be difficult to combine or use many plugins together, as some of the plugins
    might be relying on these hooks within API functions.'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**使用动作和过滤器**：WordPress API 函数在过程中执行必要的动作和过滤器，允许开发者自定义功能。使用我们自己的自定义函数会省略这些动作和过滤器。因此，将许多插件组合或一起使用将变得困难，因为一些插件可能依赖于
    API 函数中的这些钩子。'
- en: '**Input validation and security**: The built-in API functions are developed
    and tested by the best WordPress developers in the world. Therefore, validation
    of the data and security in the process is highly reliable.  Using custom built
    functions instead of API functions increases the workload of the developer to
    implement these security features and validations.'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**输入验证和安全**：内置的 API 函数是由世界上最优秀的 WordPress 开发者开发和测试的。因此，数据验证和过程中的安全性非常可靠。使用自定义构建的函数而不是
    API 函数会增加开发者的工作量，以实现这些安全功能和验证。'
- en: '**Efficiency**: The built-in API functions are optimized to provide better
    performance when interacting with database as well as working with core features
    and files. So, using these functions improves the efficiency of your solutions.'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**效率**：内置的 API 函数经过优化，以提高与数据库交互以及处理核心功能和文件时的性能。因此，使用这些函数可以提高您解决方案的效率。'
- en: '**Backward compatibility**: The WordPress team gives high priority to compatibility
    with older versions and hence rarely removes support for old functions and features.
    Therefore, using API functions guarantees the compatibility of the features in
    current WordPress versions, as well as future versions.'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**向后兼容性**：WordPress 团队高度重视与旧版本的兼容性，因此很少移除对旧函数和功能的支持。因此，使用 API 函数保证了当前 WordPress
    版本以及未来版本中功能的兼容性。'
- en: The preceding list explains why developers should use APIs whenever possible
    to save development time, as well as build risk-free solutions.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 上述列表解释了为什么开发者应尽可能使用 API 来节省开发时间，并构建无风险的解决方案。
- en: Using built-in APIs
  id: totrans-24
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用内置 API
- en: 'As of the latest version, WordPress offers eighteen individual APIs to work
    with different parts of the core. We have already used some of the API functions
    in previous chapters. We are going to learn about a few APIs in detail throughout
    this chapter. Let''s take a look at the available APIs and their role in development:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 根据最新版本，WordPress 提供了十八个独立的 API，用于处理核心的不同部分。我们已经在之前的章节中使用了一些 API 函数。在本章中，我们将详细介绍几个
    API。让我们来看看可用的 API 以及它们在开发中的作用：
- en: '**Dashboard widget API**: It is used to add, edit, or modify the widgets on
    the admin dashboard. The dashboard is the location where each user is redirected
    after logging in from the backend. The default dashboard widgets includes **At
    a Glance**, **Quick Draft**, and **Activity**. This API is useful for building
    project-specific dashboards by removing unnecessary widgets and adding plugin
    specific widgets.'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**仪表板小部件 API**：它用于添加、编辑或修改管理仪表板上的小部件。仪表板是用户从后端登录后重定向到的位置。默认仪表板小部件包括**概览**、**快速草稿**和**活动**。此
    API 通过删除不必要的 widget 并添加特定插件的 widget，有助于构建项目特定的仪表板。'
- en: '**Database API**: It is used to simplify and optimize the operations in core
    database tables. We have already used core database API features using the `global $wpdb`
    object and query functions in [Chapter 2](3e88326a-c8fe-4943-ae81-4ff69e8b865e.xhtml),
    *Managing Database Structure, Storage, and Retrieval*.'
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**数据库 API**：它用于简化并优化核心数据库表中的操作。我们已经在[第 2 章](3e88326a-c8fe-4943-ae81-4ff69e8b865e.xhtml)，*管理数据库结构、存储和检索*中使用过核心数据库
    API 功能，通过`global $wpdb`对象和查询函数。'
- en: '**HTTP API**: It is used to securely execute HTTP operations such as sending
    requests for data or retrieving data. The API functions checks the server-supported
    connection types among various available connection types in PHP. We haven''t
    used the HTTP API in previous chapters.'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**HTTP API**：它用于安全地执行 HTTP 操作，例如发送数据请求或检索数据。API 函数检查 PHP 中各种可用的连接类型中服务器支持的连接类型。我们之前章节中没有使用
    HTTP API。'
- en: '**File Header API**: Itis used for working with file headers in themes and
    plugins. The functions of the API identifies themes and plugins using header comments
    section of files. From a developer''s perspective, the functionality of this API
    will not be commonly used in development tasks.'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**文件头API**：它用于在主题和插件中处理文件头。该API的函数通过文件的头部注释部分识别主题和插件。从开发者的角度来看，该API的功能在开发任务中不太常用。'
- en: '**File System API**: It is used for reading and writing local files to the
    filesystem on various hosting environments. From a developer''s perspective, the
    functionality of this API will not be commonly used in development tasks.'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**文件系统API**：它用于在多种托管环境中读取和写入本地文件到文件系统。从开发者的角度来看，该API的功能在开发任务中不太常用。'
- en: '**Metadata API**: It is used to work with WordPress meta object types in a
    standard way. WordPress provides meta tables for posts, users, and comments. These
    functions allows you to add, edit, modify, and delete post metadata with optimum
    performance. We already worked with the meta data API with the use of post meta
    functions such as `update_user_meta` and `get_user_meta` in [Chapter 5](40208ac9-c023-42b1-b48e-a368761b37a6.xhtml), *Extending
    Plugins with Addons, Filters, and Actions*. From a developer''s perspective, the
    functionality of this API is very important and commonly used in development tasks.'
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**元数据API**：它用于以标准方式处理WordPress元对象类型。WordPress为帖子、用户和评论提供了元数据表。这些函数允许您以最佳性能添加、编辑、修改和删除帖子元数据。我们在[第5章](40208ac9-c023-42b1-b48e-a368761b37a6.xhtml)，*通过插件扩展、过滤器、和动作*中，使用`update_user_meta`和`get_user_meta`等帖子元数据函数与元数据API进行了交互。从开发者的角度来看，该API的功能非常重要，并且在开发任务中常用。'
- en: '**Options API**: It is used to work with the options table in WordPress for
    storing sitewide settings as well as theme and plugin-specific settings. These
    API functions allow you to add, edit, modify, and delete options with optimum
    performance. We already worked with the Options API with the use of  functions
    such as `get_option` and `update_option` in [Chapter 4](6bc0e5d5-b12d-4710-ac11-a600af054efa.xhtml), *Building
    Custom Modules with Plugin Development*. From a developer''s perspective, the
    functionality of this API is very important and is commonly used in development
    tasks.'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**选项API**：它用于处理WordPress中的选项表，以存储网站范围的设置以及主题和插件特定的设置。这些API函数允许您以最佳性能添加、编辑、修改和删除选项。我们在[第4章](6bc0e5d5-b12d-4710-ac11-a600af054efa.xhtml)，*使用插件开发构建自定义模块*中，使用`get_option`和`update_option`等函数与选项API进行了交互。从开发者的角度来看，该API的功能非常重要，并且在开发任务中常用。'
- en: '**Plugin API**: It is used in plugin development and hence it is important
    for you as a developer. The API consists of functions for managing WordPress hooks.
    We already worked with this API by using `add_filter`, `apply_filters`, `add_action`
    functions.'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**插件API**：它在插件开发中使用，因此对于您作为开发者来说非常重要。该API包含用于管理WordPress钩子的函数。我们已通过使用`add_filter`、`apply_filters`、`add_action`函数与该API进行了交互。'
- en: '**Quicktags API**: It is used to allow developers to add additional buttons
    to the **Text** mode of the WordPress content editor. We haven''t used this API,
    as it''s only focused on modifying the content editor. From a developer''s perspective,
    this API is important in scenarios where content creation is the primary feature
    of the site.'
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**快速标签API**：它用于允许开发者向WordPress内容编辑器的**文本**模式添加额外的按钮。我们没有使用此API，因为它仅关注修改内容编辑器。从开发者的角度来看，在内容创建是网站主要功能的情况下，此API很重要。'
- en: '**Settings API**: It is used to create and manage settings for your site as
    well as theme or plugins. You can use this API to add settings to existing settings
    pages of add your own custom settings sections to the WordPress Settings menu.
    This is one of the simplest methods to add and save settings, as most of the functionality
    is handled by the API. From a developer''s perspective, this API is very important
    for building any kind of site.'
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**设置API**：它用于创建和管理您网站的设置以及主题或插件的设置。您可以使用此API向现有设置页面添加设置，或将您自己的自定义设置部分添加到WordPress设置菜单中。这是添加和保存设置的最简单方法之一，因为大部分功能都由API处理。从开发者的角度来看，此API对于构建任何类型的网站都非常重要。'
- en: '**Theme Modification API**: It is intended for theme developers to add and
    retrieve settings of a theme as WordPress options. This API doesn’t play a vital
    role in development, unless you are building custom themes.'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**主题修改API**：它旨在让主题开发者添加和检索主题的设置作为WordPress选项。除非您正在构建自定义主题，否则该API在开发中不扮演关键角色。'
- en: '**Theme Customization API**: It is used to customize theme settings, widgets,
    styles, and to see a preview of the changes instantly. You can access the features
    generated by this API using Appearance | Customize section. The developers can
    use this API to add their own settings, sections, and controls.'
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**主题定制API**：它用于定制主题设置、小工具、样式，并可以立即预览更改。您可以通过外观 | 定制部分访问由该API生成的功能。开发者可以使用此API添加他们自己的设置、部分和控制。'
- en: '**Transients API**: It is used to temporarily store or cache the information
    in `wp_options` table. Unlike WordPress options, transients have an expiration
    time and hence are only used for keeping information for short periods. The API
    functions allows you to store, retrieve, and delete transients with various options.'
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Transients API**：它用于在`wp_options`表中临时存储或缓存信息。与WordPress选项不同，transients有一个过期时间，因此仅用于短期保存信息。API函数允许您使用各种选项存储、检索和删除transients。'
- en: '**Widgets API**: It is used for creating and managing widgets in WordPress.
    In WordPress, a widget is a reusable piece of component that is mainly intended
    for the sidebar of the site. We will be discussing more about widgets and API
    functions in upcoming chapters.'
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Widgets API**：它用于在WordPress中创建和管理小工具。在WordPress中，小工具是一个可重用的组件，主要用于网站的侧边栏。我们将在接下来的章节中更详细地讨论小工具和API函数。'
- en: '**XML – RPC API**: It is used to expose the site functionality to third-party
    services and applications. This is the old way of providing API features, and
    it’s deprecating slowly with the emergence of REST API.'
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**XML – RPC API**：它用于将网站功能暴露给第三方服务和应用程序。这是提供API功能的老方法，随着REST API的出现，它正在逐渐被弃用。'
- en: In this section, we had a brief overview of all the WordPress APIs except three.
    The APIs for shortcodes, rewrite rules, and REST play a major role in custom development,
    and hence we are going to discuss them in detail throughout the upcoming sections. You
    can view more details about the preceding APIs at [https://codex.wordpress.org/WordPress_API%27s](https://codex.wordpress.org/WordPress_API%27s).
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们对所有WordPress API进行了简要概述，除了三个。短代码、重写规则和REST API在定制开发中起着重要作用，因此我们将在接下来的章节中详细讨论它们。您可以在[https://codex.wordpress.org/WordPress_API%27s](https://codex.wordpress.org/WordPress_API%27s)查看有关先前API的更多详细信息。
- en: Introducing shortcodes
  id: totrans-42
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍短代码
- en: Shortcode in WordPress is a piece of code that generates dynamic content for
    the site or alters a given content based on various requirements. This feature
    was introduced to allow users to add dynamic content to posts or pages. However,
    modern websites use shortcodes beyond its intended purpose. We can see shortcodes
    being used in widgets, template files, and even inside the plugin for improving
    reusability. The shortcode API is a set of functions allowing developers to easily
    create and use shortcode based on their preferences. Modern websites use advanced
    themes as well as numerous plugins for providing advanced features with eye-catching
    designs. Therefore, you will see an increased use of shortcodes. The shortcode
    is one of the simplest ways to add a feature to a site, and hence it's important
    to have thorough understanding of API functions.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: WordPress中的短代码是一段代码，它根据各种要求为网站生成动态内容或更改给定内容。这个功能是为了允许用户向帖子或页面添加动态内容而引入的。然而，现代网站将短代码用于其预期目的之外。我们可以看到短代码被用于小工具、模板文件，甚至插件内部以提高可重用性。短代码API是一组函数，允许开发者根据他们的偏好轻松创建和使用短代码。现代网站使用高级主题以及众多插件来提供具有吸引力的设计的高级功能。因此，您将看到短代码的使用越来越多。短代码是向网站添加功能的最简单方法之一，因此了解API函数非常重要。
- en: Structure of a shortcode
  id: totrans-44
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 短代码的结构
- en: 'In this section, we are going to understand WordPress shortcode by considering
    the perspective of different user types. As a developer, it''s important to understand
    all the three user perspectives to build and use shortcodes in development tasks.
    Let''s take a look at the following diagram:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将从不同用户类型的视角来理解WordPress短代码。作为一个开发者，理解所有三种用户视角对于在开发任务中构建和使用短代码非常重要。让我们看一下以下图表：
- en: '![](img/9d20fe00-9482-4e47-808e-5580c98294ec.png)'
  id: totrans-46
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/9d20fe00-9482-4e47-808e-5580c98294ec.png)'
- en: The preceding diagram is based on the three user perspectives involved in the
    process of using shortcodes.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 上述图表基于使用短代码过程中涉及的三种用户视角。
- en: The use of content is optional for a shortcode. We can find many self-enclosing
    shortcodes that generate the output without using any content.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 短代码的内容使用是可选的。我们可以找到许多自闭合短代码，它们在不需要使用任何内容的情况下生成输出。
- en: Let's understand each of these three user perspectives.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们了解这三个用户视角中的每一个。
- en: Developer's perspective of a shortcode
  id: totrans-50
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 短代码的开发者视角
- en: The developer is responsible for building the shortcode, unless you only plan
    to use the shortcodes available in the WordPress core. The shortcode needs to
    be created using the API functions and registered with WordPress using a plugin
    or theme. The preceding diagram shows the basic syntax of a shortcode from a developer’s
    perspective.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 开发者负责构建短代码，除非你只计划使用WordPress核心中可用的短代码。短代码需要使用API函数创建，并通过插件或主题注册到WordPress中。前面的图示显示了从开发者视角的基本短代码语法。
- en: Content creator perspective of a shortcode
  id: totrans-52
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 短代码的内容创作者视角
- en: Usually, the site administrator creates the content for most of the sites. However,
    you may also have other user roles or specific users with permission to create
    content. These users are responsible for using the shortcodes with necessary attributes
    and content in the site development process. The previous diagram illustrates
    the main syntax of a shortcode, where these users will use inside posts or pages.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，网站管理员为大多数网站创建内容。然而，你也可能有其他用户角色或具有创建内容权限的特定用户。这些用户负责在网站开发过程中使用带有必要属性和内容的短代码。前面的图示说明了短代码的主要语法，这些用户将在帖子或页面中使用。
- en: They can use the shortcodes offered by WordPress core, theme, or plugins on
    the site. It's not a must for the content creator to know the source of the shortcode.
    However, the knowledge of whether a shortcode is generated from a theme, plugin,
    or WordPress core becomes handy in scenarios where you want to switch the theme
    or a plugin. Lack of knowledge in the source of the shortcode may lead to conflicts
    or even a complete breakdown of the site in such scenarios. These users are not
    aware of the source code of a shortcode, unless they want to explore the code
    inside theme or plugins.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 他们可以使用WordPress核心、主题或网站上提供的短代码。内容创作者不必知道短代码的来源。然而，在你想切换主题或插件的情况下，了解短代码是否由主题、插件或WordPress核心生成变得非常有用。在这些情况下，缺乏对短代码来源的了解可能会导致冲突，甚至导致网站完全崩溃。除非他们想探索主题或插件内部的代码，否则这些用户不会意识到短代码的源代码。
- en: User's perspective of a shortcode
  id: totrans-55
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 短代码的用户视角
- en: The user is anyone who visits the site, including guests and members. They will
    only see the output generated from the shortcode. These users are not aware of
    the existence of a shortcode, as the shortcode is not visible on the browser view
    or the page source. Also, the shortcode output doesn't have any predefined IDs
    or classes, and hence it’s not possible for these users to track a shortcode from
    the frontend.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 用户是任何访问网站的人，包括访客和成员。他们将只看到由短代码生成的输出。这些用户不知道短代码的存在，因为短代码在浏览器视图或页面源代码中是不可见的。此外，短代码输出没有预定义的ID或类，因此这些用户无法从前端跟踪短代码。
- en: Now you should have a basic idea of how WordPress shortcode is created and used
    to generate dynamic output. More details on the creation and use of a shortcode
    will be discussed in upcoming sections.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你应该对WordPress短代码的创建和使用以及如何生成动态输出有一个基本的了解。关于短代码的创建和使用将在后续章节中详细讨论。
- en: Using built-in shortcodes
  id: totrans-58
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用内置短代码
- en: 'WordPress core contains set of built-in shortcodes mainly focused on adding
    various content types to posts and pages. The content creators can use these shortcodes
    directly on posts, pages, or any supported location without the need for any modifications.
    Let’s take a look at the existing shortcodes:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: WordPress 核心包含一组内置短代码，主要专注于向帖子或页面添加各种内容类型。内容创作者可以直接在帖子、页面或任何支持的位置使用这些短代码，无需任何修改。让我们看看现有的短代码：
- en: '**Audio**: It used for embedding and playing audio files'
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**音频**：用于嵌入和播放音频文件'
- en: '**Caption**: It used for adding captions to content. Mainly used for images'
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**标题**：用于添加内容标题。主要用于图像'
- en: '**Embed**: It used for embedding content from different sites supported by
    WordPress'
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**嵌入**：用于嵌入由WordPress支持的网站的内容'
- en: '**Gallery**: It used for displaying image galleries by passing the image ID''s'
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**相册**：通过传递图像ID来显示图像相册'
- en: '**Video**: It used for embedding and playing video files'
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**视频**：用于嵌入和播放视频文件'
- en: '**Playlist**: It used for displaying collection of audio and video files'
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**播放列表**：用于显示音频和视频文件的集合'
- en: As you can see, these shortcodes don't use the main data of a WordPress site,
    such as posts, comments, users. So, we will have to work with shortcodes from
    external plugins or create custom shortcodes to cater for the functionality involving
    the WordPress database.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所见，这些短代码不使用WordPress网站的主要数据，如文章、评论、用户。因此，我们将不得不与外部插件中的短代码或创建自定义短代码来满足涉及WordPress数据库的功能。
- en: Building custom shortcodes
  id: totrans-67
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建自定义短代码
- en: 'The process of building custom shortcodes is not as complex as many people
    think. The minimal implementation of a shortcode requires only few lines of code
    as shown in the diagram in the last section. A shortcode consists of four main
    parts:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 构建自定义短代码的过程并不像许多人想象的那样复杂。短代码的最小实现只需要几行代码，如最后部分的图中所示。一个短代码由四个主要部分组成：
- en: '**Opening and closing tags**: Opening and closing tags are similar to HTML,
    WordPress shortcodes have opening and closing tags using square brackets. These
    tags are used by content creators to add the functionality into posts or pages.
    On the other hand, developers need to use this `tag` to register a shortcode as
    a unique element. Some of the shortcodes don’t have a closing tag and use a self-enclosing
    opening tag.'
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**开标签和闭标签**：开标签和闭标签类似于HTML，WordPress短代码使用方括号的开标签和闭标签。这些标签由内容创建者用于向文章或页面添加功能。另一方面，开发者需要使用这个`标签`来注册短代码作为唯一元素。一些短代码没有闭标签，并使用自闭合的开标签。'
- en: '**Attributes**: Attributes is a collection of data and settings required to
    process the functionality within the shortcode function and return the output.
    The list of attributes starts after the shortcode name in the opening tag. Each
    attribute has a key and values, as shown in the structure of a shortcode image.
    The attributes should be separated by one or more spaces. Inside the shortcode,
    developers can access the passed attributes using the array keys of the attributes
    variable.'
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**属性**：属性是一组数据设置，用于在短代码函数内部处理功能并返回输出。属性列表从短代码名称在开标签之后开始。每个属性都有一个键和值，如短代码图像的结构所示。属性应该由一个或多个空格分隔。在短代码内部，开发者可以使用属性变量的数组键访问传递的属性。'
- en: '**Content**: Content is the content we add between the opening and closing
    tags of the shortcode. Once content is used, shortcode will act as a WordPress
    filter where we retrieve, process, and return the modified content. We can also
    define shortcodes without content by using a self-enclosing opening tag.'
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**内容**：内容是我们添加到短代码开标签和闭标签之间的内容。一旦内容被使用，短代码将作为WordPress过滤器工作，在那里我们检索、处理和返回修改后的内容。我们也可以通过使用自闭合的开标签来定义没有内容短代码。'
- en: '**Output**: Output is the return value by the shortcodes based on the passed
    attributes and content. The output will be either content modified within the
    shortcode or the content will be used to capture and display site data. Many developers
    tend to print the shortcode output directly to the browser using PHP `echo` statements.
    However, shortcodes should always return the output instead of printing directly
    to the browser.'
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**输出**：输出是基于传递的属性和内容，由短代码返回的值。输出将是短代码内部修改的内容，或者内容将被用来捕获和显示网站数据。许多开发者倾向于直接使用PHP
    `echo`语句将短代码输出打印到浏览器。然而，短代码应该始终返回输出而不是直接打印到浏览器。'
- en: Now we can move on to the process of creating custom shortcodes using these
    parts.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以继续创建自定义短代码的过程，使用这些部分。
- en: Creating custom shortcodes
  id: totrans-74
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建自定义短代码
- en: 'In this section, we are going to consider two scenarios to build custom shortcodes
    and explain the different kinds of uses of a shortcode. Let''s list the two requirements
    for building shortcodes for each one:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将考虑两种场景来构建自定义短代码，并解释短代码的不同用途。让我们列出为每个构建短代码的两个要求：
- en: Restricting the content based on a user's role
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 根据用户角色限制内容
- en: Displaying a list of posts with attachments
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 显示带有附件的文章列表
- en: Let's get started.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始吧。
- en: Restricting content using a shortcode
  id: totrans-79
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用短代码限制内容
- en: 'This scenario explains the creation of a shortcode using all the four shortcode
    components discussed in the previous section. Basically, we need a shortcode that
    accepts content and displays the output only to authorized users, while providing
    a custom output for unauthorized users. Let''s consider the shortcode needed for
    this scenario:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 这种情况解释了使用之前章节中讨论的四个短代码组件创建短代码的过程。基本上，我们需要一个短代码，它接受内容，并且只对授权用户显示输出，同时为未授权用户提供自定义输出。让我们考虑这个场景所需的短代码：
- en: '[PRE0]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The previous shortcode has one attribute for specifying the user roles not
    authorized to view the content and the content to be protected within the opening
    and closing tags. Now we have to match the previous shortcode with the code used
    in the *Structure of a shortcode* diagram. Consider the following code for the
    implementation of this shortcode:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的短代码有一个属性用于指定不允许查看内容的用户角色和需要保护的内容，现在我们必须将之前的短代码与`短代码结构`图中的代码相匹配。考虑以下代码来实现这个短代码：
- en: '[PRE1]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: In this case, a callback function accepts attributes and content for the shortcode.
    WordPress provides a function called `shortcode_atts` to merge the passed attributes
    with default attributes and make an array of attributes required for processing
    the shortcode. It's a good practice to define the allowed attributes and default
    values inside the `shortcode_atts` function as an array. In this case, we are
    passing a value for the `role` parameter, and hence it will override the default
    parameter.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，一个回调函数接受短代码的属性和内容。WordPress提供了一个名为`shortcode_atts`的函数，用于合并传递的属性和默认属性，并创建一个用于处理短代码所需的属性数组。在`shortcode_atts`函数内部定义允许的属性和默认值作为一个数组是一个好的做法。在这种情况下，我们为`role`参数传递了一个值，因此它将覆盖默认参数。
- en: If we don't specify a value for a attribute, `shortcode_atts` will look for
    the default value. Next, we access the attributes using `$sh_attr` array and apply
    the conditions. Finally, we return the original content or a message based on
    the conditions. This is the most basic code required to build a shortcode.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们没有指定属性的值，`shortcode_atts`将查找默认值。接下来，我们使用`$sh_attr`数组访问属性并应用条件。最后，根据条件返回原始内容或消息。这是构建短代码所需的最基本的代码。
- en: Displaying posts with attachments
  id: totrans-86
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 显示带有附件的帖子
- en: 'This scenario explains a different use of a shortcode from both a developer''s
    perspective as well as a content creator''s perspective. Here, we need to display
    the list of posts with at least one attachment. Unlike the previous scenario,
    we are not retrieving and modifying the content. Instead, we are generating dynamic
    content based on the shortcode attributes. Let’s take a look at the shortcode
    needed for this scenario:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 这种情况从开发者和内容创作者的角度解释了短代码的不同用法。在这里，我们需要显示至少有一个附件的帖子列表。与之前的场景不同，我们不是检索和修改内容。相反，我们根据短代码属性生成动态内容。让我们看看这个场景所需的短代码：
- en: '[PRE2]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'As you can see, there is no closing tag, and the closing part is done within
    the opening tag. These types of shortcodes are called as *self-enclosing* shortcodes.
    We don’t use any content in such shortcodes. In this case, we are displaying all
    the posts with attachments, and hence shortcode attributes are not required. If
    we were displaying posts with attachments for a specific category, the shortcode
    would have looked as follows:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，没有关闭标签，关闭部分是在开标签内完成的。这类短代码被称为*自闭合*短代码。我们不需要在这些短代码中使用任何内容。在这种情况下，我们正在显示所有带有附件的帖子，因此不需要短代码属性。如果我们需要显示特定类别的帖子附件，短代码将如下所示：
- en: '[PRE3]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Now we can implement the previous shortcode by matching it with the syntax
    we used in our shortcode diagrams:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以通过将其与我们在短代码图中使用的语法相匹配来实现之前的短代码：
- en: '[PRE4]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: In this case, we have no attributes, and hence we query the custom table by
    joining it with a posts table to generate the result. The `$content` variable
    will be empty, as we are not passing any data by using opening and closing tags.
    Finally, we return the HTML string to display the list of posts.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们没有属性，因此我们通过将其与帖子表连接来查询自定义表以生成结果。`$content`变量将为空，因为我们没有通过开闭标签传递任何数据。最后，我们返回一个HTML字符串以显示帖子列表。
- en: Understanding the usage of shortcodes
  id: totrans-94
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解短代码的使用
- en: 'We discussed the techniques of building shortcodes in previous section. Now
    we need to understand the techniques of using these shortcodes in different parts
    of the site. Let''s take a look at the different locations where we can use shortcodes:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在上一节中讨论了构建短代码的技术。现在我们需要了解在不同网站部分使用这些短代码的技术。让我们看看我们可以使用短代码的不同位置：
- en: '**Posts and pages**: This is the most common use of a shortcode, where the
    content creator directly adds the shortcode to the post or page editor. Then,
    WordPress executes the shortcode and displays the result in the frontend post
    or page.'
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**帖子与页面**：这是短代码最常见的使用方式，内容创建者直接在帖子或页面编辑器中添加短代码。然后，WordPress执行短代码，并在前端帖子或页面上显示结果。'
- en: '**Widgets**: We can use shortcodes inside WordPress widgets to provide dynamic
    content similar o the posts and pages. However, we have to use additional code
    depending on the widget we use. The WordPress **Text widget** allows you to add
    shortcodes directly to the content editor and display the output on the frontend.
    Sometimes, you may want to use the shortcodes with HTML elements and hence need
    to use the **HTML widget** instead of the **Text widget**. The HTML widget doesn’t
    support shortcodes by default. So, we have to use the following code in the `functions.php`
    file of the theme or within any plugin to execute the shortcode:'
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**小部件**：我们可以在WordPress小部件中使用短代码来提供类似于帖子或页面的动态内容。然而，我们必须根据所使用的小部件使用额外的代码。WordPress的**文本小部件**允许你直接在内容编辑器中添加短代码，并在前端显示输出。有时，你可能想使用短代码与HTML元素一起，因此需要使用**HTML小部件**而不是**文本小部件**。HTML小部件默认不支持短代码。因此，我们必须在主题的`functions.php`文件或任何插件中以下代码来执行短代码：'
- en: '[PRE5]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: WordPress has a filter called `widget_text` that gets executed on the content
    of all widgets. We can use this filter to change the content as required. So far,
    we used `add_filter` statement with a callback function. Here, we also have a
    callback function called `do_shortcode`. However, you might be wondering why the
    implementation is missing. The `do_shortcode` function is built into WordPress,
    and hence we can directly call it without adding an implementation for the function.
    This function executes any shortcodes within the content.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: WordPress有一个名为`widget_text`的过滤器，它在所有小部件的内容上执行。我们可以使用这个过滤器来按需更改内容。到目前为止，我们使用了`add_filter`语句和一个回调函数。这里，我们还有一个名为`do_shortcode`的回调函数。然而，你可能想知道为什么实现缺失。`do_shortcode`函数是内置在WordPress中的，因此我们可以直接调用它，而无需为该函数添加实现。此函数执行内容中的任何短代码。
- en: '**Template Files**: Sometimes, we may need to call shortcodes inside a header,
    footer, or any template file. This becomes handy when you are customizing existing
    themes to integrate the features of other plugins. In such scenarios, adding the
    shortcode to the template file won’t work. We have to use a PHP script and execute
    the shortcode using `do_shortcode` function. Consider the following code for using
    a shortcode inside a template file:'
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**模板文件**：有时，我们可能需要在标题、页脚或任何模板文件中调用短代码。当你正在自定义现有主题以集成其他插件的功能时，这非常有用。在这种情况下，将短代码添加到模板文件中不会起作用。我们必须使用PHP脚本并使用`do_shortcode`函数来执行短代码。考虑以下代码，用于在模板文件中使用短代码：'
- en: '[PRE6]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: We need to also use the `echo` statement to print the output to the browser,
    as it's not automatically printed as in previous scenarios.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要使用`echo`语句将输出打印到浏览器，因为在之前的场景中它不是自动打印的。
- en: '**Plugins and themes**: Sometimes, we want to integrate the shortcode features
    with other plugins or themes. In such cases, we can directly call the shortcode
    instead of replicating the code for the shortcode. Assume we want to display the
    posts with attachments after the content of each post. In this scenario, we can
    internally call the shortcode within our plugin and generate the list of posts
    with attachments instead of writing a separate function or duplicating code. Consider
    the following statement for using a shortcode within a theme or a plugin code:'
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**插件与主题**：有时，我们希望将短代码功能与其他插件或主题集成。在这种情况下，我们可以直接调用短代码，而不是复制短代码的代码。假设我们想在每篇帖子内容之后显示带有附件的帖子。在这种情况下，我们可以在我们的插件内部调用短代码，生成带有附件的帖子列表，而不是编写单独的函数或复制代码。考虑以下用于在主题或插件代码中使用短代码的语句：'
- en: These are some of the common methods and locations for using shortcodes.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是使用短代码的一些常见方法和位置。
- en: Tips for using shortcodes
  id: totrans-105
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用短代码的技巧
- en: 'The shortcode is a simple and flexible way of adding reusable functionality
    to a site. However, there are pros and cons of using shortcodes. As a developer,
    you need to understand when to use shortcodes and how to build quality shortcodes.
    The following tips will help you improve the shortcodes, as well as avoid unnecessary
    issues:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 短代码是一种简单灵活的方法，可以将可重用的功能添加到网站中。然而，使用短代码既有优点也有缺点。作为一名开发者，你需要了解何时使用短代码以及如何构建高质量的短代码。以下提示将帮助你改进短代码，同时避免不必要的麻烦：
- en: '**Filtering shortcode output**: Usually, we create some content within the
    shortcode and directly return the content as output. There are some plugins that
    use a filter on the output of a shortcode. It''s a great way of adding more flexibility
    where the developers can control the shortcode output of other plugins.'
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**过滤短代码输出**：通常，我们在短代码内创建一些内容，并将其直接作为输出返回。有些插件会在短代码的输出上使用过滤器。这是一种增加灵活性的好方法，开发者可以控制其他插件的短代码输出。'
- en: '**Using nested shortcodes**: We can add shortcodes inside other shortcodes
    to get an output. However, when using nested shortcodes, you need to use `do_shortcode`
    in the main shortcode to execute the shortcodes within its content.'
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**使用嵌套短代码**：我们可以在其他短代码内添加短代码以获取输出。然而，在使用嵌套短代码时，您需要在主短代码中使用`do_shortcode`来执行其内容内的短代码。'
- en: '**Validating shortcode attributes**: Attributes are added by the content creators
    and hence need to be considered as user input. Since we shouldn''t trust any kind
    of user input, validation is a must for attribute values.'
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**验证短代码属性**：属性是由内容创建者添加的，因此需要将其视为用户输入。由于我们不应信任任何类型的用户输入，因此对属性值进行验证是必须的。'
- en: '**Using unique shortcode names**: Many plugins use generic shortcode names
    such as `[product]`, `[event]`, and so on. This may lead to conflicts with multiple
    plugins, and hence you should always use a plugin-specific prefix to make it unique.'
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**使用唯一的短代码名称**：许多插件使用通用的短代码名称，如 `[product]`、`[event]` 等。这可能导致多个插件之间的冲突，因此您应该始终使用插件特定的前缀来使其独特。'
- en: '**Overuse of shortcodes**: Shortcode is an easy way of adding a bunch of content.
    However, using too many shortcodes inside posts or pages can lead to maintenance
    nightmares in later stages. As the post or page is dependent on shortcodes, it
    will be difficult to change the content.'
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**过度使用短代码**：短代码是添加大量内容的一种简单方法。然而，在文章或页面中使用过多的短代码可能导致后期维护噩梦。由于文章或页面依赖于短代码，更改内容将变得困难。'
- en: We have covered the process of creating and using shortcodes. Now it's time
    to take a look at plugins that use shortcodes and identify various uses and developing
    techniques.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经介绍了创建和使用短代码的过程。现在，让我们看看使用短代码的插件，并识别各种用途和开发技术。
- en: Managing custom routes with Rewrite API
  id: totrans-113
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Rewrite API管理自定义路由
- en: The default WordPress URL structure uses query parameters to load the necessary
    posts and pages. So, the URL of a post will look like [http://www.example.com/?p=130](http://www.example.com/?p=130).
    This is not ideal, as its difficult to remember the post ID and search engines
    won't give a higher preference to such URLs. Therefore, we need a better URL structure
    that doesn't use query parameters and gives a SEO-friendly URL. So, we use the
    WordPress permalinks section to change the URL structure. Then, WordPress will
    internally convert those SEO-friendly URLs to the default URL structure. We can
    access the permalinks settings section from Settings | Permalinks. Let's choose
    *Post Name* as the URL structure for our site. Then, the preceding URL will be
    converted to `http:// www.example.com/sample-post/`.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 默认的WordPress URL结构使用查询参数来加载必要的文章和页面。因此，文章的URL将看起来像[http://www.example.com/?p=130](http://www.example.com/?p=130)。这并不理想，因为很难记住文章ID，搜索引擎也不会给予此类URL更高的优先级。因此，我们需要一个更好的URL结构，不使用查询参数，并提供SEO友好的URL。因此，我们使用WordPress的永久链接部分来更改URL结构。然后，WordPress将内部将这些SEO友好的URL转换为默认的URL结构。我们可以从设置
    | 永久链接访问永久链接设置部分。让我们选择*文章名称*作为我们网站的URL结构。然后，前面的URL将转换为`http:// www.example.com/sample-post/`。
- en: As you can see, this is a much more user and SEO-friendly URL structure. Once
    the permalinks are set up, all the WordPress core features in the frontend will
    use this structure. However, in custom development, we may need custom URL structures
    to handle the functionality. In such cases, we can use Rewrite API to define our
    own routes and manage the functionality without interfering with default WordPress
    features.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，这是一个更符合用户和SEO友好的URL结构。一旦设置好永久链接，WordPress前端的所有核心功能都将使用这种结构。然而，在自定义开发中，我们可能需要自定义URL结构来处理功能。在这种情况下，我们可以使用重写API来定义我们自己的路由并管理功能，而不会干扰默认的WordPress功能。
- en: '**What is Rewrite API?**'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: '**什么是重写API？**'
- en: 'WordPress Rewrite API is a set of functions that allows you to manage custom
    routes using tags, rules and endpoints. Let’s identify the functions used for
    implementing with Rewrite API:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: WordPress重写API是一组函数，允许您使用标签、规则和端点来管理自定义路由。让我们确定用于实现重写API的函数：
- en: '`add_rewrite_rule`: This function is used to register new rewrite rules to
    WordPress for generating custom templates.'
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`add_rewrite_rule`: 这个函数用于向WordPress注册新的重写规则以生成自定义模板。'
- en: '`add_rewrite_tag`: This function is used for registering new query variables.
    We need to use it with `add_rewrite_rule` to create rewrite rules for custom templates.'
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`add_rewrite_tag`: 这个函数用于注册新的查询变量。我们需要与`add_rewrite_rule`一起使用来为自定义模板创建重写规则。'
- en: '`add_rewrite_endpoint`: This function is used to create extra rewrite rules
    for WordPress core components.'
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`add_rewrite_endpoint`: 这个函数用于为WordPress核心组件创建额外的重写规则。'
- en: '`flush_rewrite_rules`: This is used to remove rewrite rules and then recreate
    rewrite rules.'
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`flush_rewrite_rules`: 这个函数用于删除重写规则然后重新创建重写规则。'
- en: In this section, we are going to create and manage custom rules using these
    functions except `add_rewrite_endpoint`. You can view more details about rewrite
    endpoints at [https://codex.wordpress.org/Rewrite_API/add_rewrite_endpoint](https://codex.wordpress.org/Rewrite_API/add_rewrite_endpoint).
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将使用这些函数（除了`add_rewrite_endpoint`）来创建和管理自定义规则。您可以在[https://codex.wordpress.org/Rewrite_API/add_rewrite_endpoint](https://codex.wordpress.org/Rewrite_API/add_rewrite_endpoint)查看关于重写端点的更多详细信息。
- en: Understanding the need for custom routes
  id: totrans-123
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解自定义路由的需求
- en: 'The use of custom routes becomes vital in developing plugins that goes beyond
    the default WordPress features. We are going to consider two scenarios to understand
    the need for custom rewriting:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 在开发超出默认WordPress功能的插件时，自定义路由的使用变得至关重要。我们将考虑两个场景来理解自定义重写的需求：
- en: Assume we have a shortcode that is used to display user profile details and
    we use it inside a WordPress page called **Profile**. So, the URL of the page
    will be [http://www.example.com/profile](http://www.example.com/profile). Now,
    we need to use the same page to display user details of each user. Currently,
    it’s not possible, since we don’t have a way to identify the user when accessing
    this page. So, we need to modify the URL in a way that we can identify each user.
    Let’s assume we have a URL like [http://www.example.com/profile/john123](http://www.example.com/profile/john123)
    with the username after the page. Then, we can use the username component to identify
    the user and display the profile details. In this scenario, we have to use Rewrite
    API functions to match the URL with necessary query parameters and execute our
    functionality.
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 假设我们有一个用于显示用户个人资料详情的短代码，并且我们在名为**Profile**的WordPress页面中使用它。因此，该页面的URL将是[http://www.example.com/profile](http://www.example.com/profile)。现在，我们需要使用相同的页面来显示每个用户的详细信息。目前，这是不可能的，因为我们没有在访问此页面时识别用户的方法。因此，我们需要以某种方式修改URL，以便我们可以识别每个用户。让我们假设我们有一个类似[http://www.example.com/profile/john123](http://www.example.com/profile/john123)的URL，用户名位于页面之后。然后，我们可以使用用户名组件来识别用户并显示个人资料详情。在这种情况下，我们必须使用重写API函数来匹配URL与必要的查询参数并执行我们的功能。
- en: As we already discussed, adding shortcodes to such an important functionality
    can become an issue when the administrator deletes or removes the shortcodes by
    mistake. So, relying on posts or pages to handle such functionality can be considered
    as a risk. In such cases, we can avoid risk by using custom URLs that don't use
    posts or pages. Assume we want to display a login form at [http://www.example.com/user/login](http://www.example.com/user/login)
    and registration at [http://www.example.com/user/register](http://www.example.com/user/register).
    By default, these URLs will redirect to the *404 Not Found Page* when you don't
    have a post or page called *user*. So, we need to use Rewrite API to register
    custom routes and manage these URLs to offer custom features without interfering
    with core WordPress features.
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 正如我们已经讨论过的，将短代码添加到如此重要的功能中可能会在管理员不小心删除或移除短代码时成为一个问题。因此，依靠帖子或页面来处理此类功能可能被视为一种风险。在这种情况下，我们可以通过使用不使用帖子或页面的自定义URL来避免风险。假设我们想在[http://www.example.com/user/login](http://www.example.com/user/login)显示登录表单，在[http://www.example.com/user/register](http://www.example.com/user/register)显示注册。默认情况下，当你没有名为`user`的帖子或页面时，这些URL将重定向到*404未找到页面*。因此，我们需要使用重写API来注册自定义路由并管理这些URL，以提供不干扰核心WordPress功能的自定义功能。
- en: In this section, we are going to implement the second scenario, as handling
    custom URLs without posts or pages is the ideal solution for custom features.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将实现第二个场景，因为处理没有帖子或页面的自定义URL是自定义功能的理想解决方案。
- en: Creating the routing rules
  id: totrans-128
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建路由规则
- en: 'We can use `add_rewrite_rule` function to register new custom routes with WordPress.
    This function can be implemented within many actions in WordPress. However, we
    usually use `init` action to handle the rewrite rules. Let''s add a custom rewrite
    rule to handle the scenario of user login and registration:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用`add_rewrite_rule`函数在WordPress中注册新的自定义路由。这个函数可以在WordPress的许多动作中实现。然而，我们通常使用`init`动作来处理重写规则。让我们添加一个自定义重写规则来处理用户登录和注册的场景：
- en: '[PRE7]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'You can find the code for this section inside the `wpquick-rewrite-api` plugin
    in the source codes directory. The `add_rewrite_rule` function accepts two required
    and one optional parameters. Let’s take a look at the parameters and their role:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在源代码目录中的`wpquick-rewrite-api`插件中找到本节的代码。`add_rewrite_rule`函数接受两个必需参数和一个可选参数。让我们看看这些参数及其作用：
- en: '`regex`: This is the first parameter that matches the URL to the rule using
    a regular expression.'
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`regex`：这是第一个参数，它使用正则表达式将URL与规则匹配。'
- en: '`redirect`: This is the second parameter that specifies the URL to request
    when current URL is matching the regular expression. As you can see, we pass the
    request to `index.php` with custom parameters that uniquely identify our functionality.'
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`redirect`：这是第二个参数，它指定当当前URL与正则表达式匹配时请求的URL。正如你所见，我们通过传递带有唯一标识我们功能的自定义参数将请求传递给`index.php`。'
- en: '`after`: This optional parameter decides when to use this rewrite rule. If
    a `top` value is used, the rewrite rule will take precedence over other default
    WordPress rewrite rules. If a `bottom` value is used, preference will be given
    to existing rules.'
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`after`：这个可选参数决定何时使用这个重写规则。如果使用`top`值，重写规则将优先于其他默认WordPress重写规则。如果使用`bottom`值，将优先考虑现有规则。'
- en: Now, you might think we can access `wpquick_action` using `$_GET` query parameters
    and implement the functionality for both login and registration. However, you
    won’t get `wpquick_action` as a `$_GET` parameter. WordPress doesn't allow you
    to use any type of variable in the query string. It will check for query variables
    within the existing list, and all other variables will be ignored. So, we have
    to specify the custom query variables before we can actually use them in code.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你可能认为我们可以使用`$_GET`查询参数访问`wpquick_action`并实现登录和注册的功能。然而，你不会在`$_GET`参数中找到`wpquick_action`。WordPress不允许你在查询字符串中使用任何类型的变量。它将检查现有列表中的查询变量，而所有其他变量将被忽略。因此，在我们实际上可以在代码中使用它们之前，我们必须指定自定义查询变量。
- en: Adding query variables
  id: totrans-136
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加查询变量
- en: 'WordPress has over 40 params registered to be used in queries. Let''s check
    the existing query variables before adding custom query variables. Add the following
    code to main file of `wpquick-rewrite-api` plugin and open the home page of your
    site:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: WordPress注册了超过40个参数以供查询使用。在添加自定义查询变量之前，让我们检查现有的查询变量。将以下代码添加到`wpquick-rewrite-api`插件的主体文件中，并打开你网站的首页：
- en: '[PRE8]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'You will see all the existing query parameters as an array. Now we need to
    create our own query parameters to handle user login and registration. So, we
    add the following code to the `wpquick-rewrite-api` plugin:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 你将看到所有现有的查询参数作为一个数组。现在我们需要创建我们自己的查询参数来处理用户登录和注册。因此，我们在`wpquick-rewrite-api`插件中添加以下代码：
- en: '[PRE9]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The `query_vars` is a built-in filter that allows us to add or remove query
    variables before the request is processed. In this scenario, we add a new query
    parameter called `wpquick_action` to the existing query parameters array.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: '`query_vars`是一个内置的过滤器，允许我们在请求处理之前添加或删除查询变量。在这种情况下，我们向现有的查询参数数组中添加了一个名为`wpquick_action`的新查询参数。'
- en: WordPress core and other plugins registers considerable number of query variables.
    So, it's better to use a unique name with a prefix to avoid conflicts with query
    parameters in other plugins.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: WordPress核心和其他插件注册了相当数量的查询变量。因此，最好使用带有前缀的唯一名称以避免与其他插件的查询参数冲突。
- en: 'Now we have the ability to access `wpquick_action` variable from the URL. In
    this scenario, I used the `query_vars` filter to add new query variables and for
    the purpose of identifying built-in query variables. Rewrite API provides a function
    called `add_rewrite_tag` to implement the same functionality, and it’s the recommended
    way. So, we can remove the `query_vars` filter from our plugin and change the
    `wqraf_manage_user_routes` function as following to get the same functionality:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有能力从URL中访问`wpquick_action`变量。在这种情况下，我使用了`query_vars`过滤器来添加新的查询变量，并用于识别内置的查询变量。重写API提供了一个名为`add_rewrite_tag`的函数来实现相同的功能，这是推荐的方式。因此，我们可以从我们的插件中移除`query_vars`过滤器，并将`wqraf_manage_user_routes`函数修改如下以获得相同的功能：
- en: '[PRE10]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The first parameter takes the **action name** surrounded by a `%` and the second
    parameter defines a `regex` to validate the value. Adding rewrite tags is relatively
    easy compared to using `query_vars` filter.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个参数接受一个由`%`包围的**动作名称**，第二个参数定义了一个`regex`来验证值。与使用`query_vars`过滤器相比，添加重写标签相对容易。
- en: We modified the WordPress rewrite rules by adding a new rule. So, we have to
    flush the rewrite rules before the new rule takes effect. There are two ways to
    flush rewrite rules. First, we can visit Settings | Permalinks section to automatically
    refresh the rewrite rules. However, this is not ideal in development, as the user
    needs to manually go into the **Settings** section. So, we need a way to flush
    the rewrite rules automatically within our plugin, without needing an input from
    the user.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过添加新的规则修改了WordPress的重写规则。因此，在新的规则生效之前，我们必须刷新重写规则。有两种刷新重写规则的方法。首先，我们可以访问设置
    | 永久链接部分来自动刷新重写规则。然而，在开发中这并不理想，因为用户需要手动进入**设置**部分。因此，我们需要在我们的插件中自动刷新重写规则的方法，而不需要用户的输入。
- en: Flushing the rewriting rules
  id: totrans-147
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 刷新重写规则
- en: 'We can easily flush the rewrite rules by calling WordPress `flush_rewrite_rules`
    function inside the `init` action. However, it will flush the rewrite rules on
    every request, generating unnecessary performance overhead. So, we need to use
    activation handler of the plugin to flush the rules. Let''s see the following
    implementation inside the activation handler:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以很容易地通过在`init`动作中调用WordPress的`flush_rewrite_rules`函数来刷新重写规则。然而，它会在每次请求时刷新重写规则，产生不必要的性能开销。因此，我们需要使用插件的激活处理程序来刷新规则。让我们看看以下激活处理程序中的实现：
- en: '[PRE11]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Now go to the admin panel, deactivate the plugin, and activate the plugin again.
    Then, go to the URL [http://www.example.com/user/login](http://www.example.com/user/login)
    and check whether it works. Unfortunately, you will still get the 404 error for
    the request. You might be wondering what went wrong. Let''s go back and think
    about the process to understand the issue. We flushed the rules on plugin activation.
    So, the new rules should persist successfully. However, we define the rules on
    the `init` action, which is only executed after the plugin is activated. Therefore,
    new rules will not be available at the time of flushing. So, we have to update
    the function as follows to get it working:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，转到管理面板，停用插件，然后再次激活插件。然后，转到URL [http://www.example.com/user/login](http://www.example.com/user/login)
    并检查它是否工作。不幸的是，你仍然会得到404错误。你可能想知道出了什么问题。让我们回到并思考这个过程，以了解问题所在。我们在插件激活时刷新了规则。因此，新规则应该成功持久化。然而，我们在`init`动作中定义了规则，这个动作只有在插件激活后才执行。因此，新规则在刷新时不可用。所以，我们必须更新函数如下以使其工作：
- en: '[PRE12]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Now deactivate and activate the plugin again. Then, go to the URL [http://www.example.com/user/login](http://www.example.com/user/login).
    This time, you won't get the 404 errors, as the rewrite rule is added and flushed
    properly. Now we are ready with our routing rules for user functionalities.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 现在请先禁用插件，然后再重新激活它。接着，访问网址 [http://www.example.com/user/login](http://www.example.com/user/login)。这次，你不会遇到404错误，因为重写规则已经被正确添加并刷新。现在我们已经准备好了用户功能的路由规则。
- en: Displaying content for custom routes
  id: totrans-153
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 显示自定义路由的内容
- en: 'We have to build a custom route to manage the login and registration of the
    site. Now we need to access the custom query variable from the custom route and
    generate the screens for login and registration. Consider the following code for
    the implementation of login and registration forms:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 我们必须构建一个自定义路由来管理站点的登录和注册。现在我们需要从自定义路由访问自定义查询变量，并生成登录和注册的屏幕。以下代码用于实现登录和注册表单的实现：
- en: '[PRE13]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: WordPress executes the `template_redirect` action just before deciding which
    template to load. So, we can use this action to intercept the request and load
    our own template. First, we access the `wpquick_action` value using the `$wp_query`
    global object. This variable will contain either register or login in this scenario.
    Then, we use a `switch` statement to filter the action and load the necessary
    template. Here, we are only printing a title for explanations. You have to generate
    the login or registration forms instead of the title.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: WordPress在决定加载哪个模板之前执行`template_redirect`动作。因此，我们可以使用这个动作来拦截请求并加载我们自己的模板。首先，我们使用全局对象`$wp_query`访问`wpquick_action`值。在这个场景中，这个变量将包含注册或登录。然后，我们使用`switch`语句来过滤动作并加载必要的模板。在这里，我们只打印标题以供说明。你必须生成登录或注册表单而不是标题。
- en: Since we are intercepting the request, our content will be loaded instead of
    the WordPress template. Here, it will only print the title without the header,
    footer, or other parts of the WordPress template. So, you have to generate a complete
    template by including header, footer, content area, and sidebars.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们正在拦截请求，我们的内容将会被加载而不是WordPress模板。在这里，它只会打印标题，而不会包含头部、底部或其他WordPress模板的部分。因此，你必须通过包含头部、底部、内容区域和侧边栏来生成一个完整的模板。
- en: We have looked at the process of using Rewrite API functions to create custom
    routes and load custom templates for your plugins. This will become handy when
    developing advanced plugins with non-WordPress specific screens.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经探讨了使用重写API函数来创建自定义路由和为插件加载自定义模板的过程。当开发具有非WordPress特定屏幕的高级插件时，这将非常有用。
- en: Building remote connections with REST API
  id: totrans-159
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用REST API建立远程连接
- en: WordPress REST API is gaining popularity over the old XML-RPC API and becoming
    a standard in site development. The API allows developers to connect WordPress
    sites with other sites as well as third-party applications. Modern sites are moving
    towards JS Framework-based frontends to optimize performance as well as to simplify
    the user experience. In such scenarios, developers can use WordPress as the backend
    for the core functionality and expose the data through the REST API to build frontends
    without using WordPress. The REST API could well be the future of development
    with WordPress.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: WordPress REST API正在超越旧的XML-RPC API，并成为网站开发的行业标准。该API允许开发者将WordPress站点与其他站点以及第三方应用程序连接起来。现代网站正朝着基于JS框架的前端发展，以优化性能并简化用户体验。在这种情况下，开发者可以使用WordPress作为核心功能的后端，并通过REST
    API公开数据来构建不使用WordPress的前端。REST API很可能是WordPress开发的未来。
- en: The REST API was initially introduced in a external plugin for testing. Finally,
    it was included in WordPress core in WordPress 4.7, and now it fully supports
    REST API endpoints for all the major data models in WordPress.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: REST API最初是在一个外部插件中引入用于测试的。最终，它在WordPress 4.7版本中被包含到WordPress核心中，现在它完全支持WordPress中所有主要数据模型的REST
    API端点。
- en: 'Let''s identify some of the common terms used in REST API operations:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们确定一些在REST API操作中常用的术语：
- en: '**Route**: This is a well-defined URL that can be mapped to an HTTP method'
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**路由**：这是一个可以映射到HTTP方法的明确定义的URL'
- en: '**Endpoint**: The process of matching a specific route to a HTTP method'
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**端点**：将特定路由与HTTP方法匹配的过程'
- en: '**Request**: The call to an API endpoint with the necessary data'
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**请求**：带有必要数据的API端点调用'
- en: '**Response**: The data provided by an API to a specific request'
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**响应**：API对特定请求提供的数据'
- en: '**Schema**: This is used to structure API data and provide info on the available
    properties and input parameters for API requests'
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**模式（Schema**）: 这用于结构化API数据并提供关于API请求中可用属性和输入参数的信息'
- en: Introducing core REST API endpoints
  id: totrans-168
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍核心REST API端点
- en: WordPress provides built-in API endpoints for working with most of the main
    core features. The documentation defines the endpoints, attributes, and example
    requests, simplifying the learning curve for developers. In this section, we are
    going to look at the core REST API endpoints and the use of test requests to understand
    the process. You can check all the available endpoints and additional information
    in WordPress REST API documentation at [https://developer.wordpress.org/rest-api/reference/](https://developer.wordpress.org/rest-api/reference/).
    The WordPress REST API is enabled by default. You can check whether an API is
    enabled on your site by accessing [http://www.example.com/wp-json](http://www.example.com/wp-json)
    in the browser. If the API is enabled, you will get a large JSON string with the
    available settings and endpoints.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: WordPress为处理大多数主要核心功能提供了内置的API端点。文档定义了端点、属性和示例请求，简化了开发者的学习曲线。在本节中，我们将探讨核心REST
    API端点以及使用测试请求来理解这个过程。您可以在WordPress REST API文档中查看所有可用端点和附加信息，网址为[https://developer.wordpress.org/rest-api/reference/](https://developer.wordpress.org/rest-api/reference/)。WordPress
    REST API默认启用。您可以通过在浏览器中访问[http://www.example.com/wp-json](http://www.example.com/wp-json)来检查您的网站上是否启用了API。如果API已启用，您将获得一个包含可用设置和端点的大型JSON字符串。
- en: Understanding and testing Core API endpoints
  id: totrans-170
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解和测试核心API端点
- en: We have to identify and understand the use of API endpoints, arguments, and
    return data formats to build features with API functions. Testing API requests
    is the best way to understand the process. We can use an existing tool to simplify
    the API request testing process. There are many such tools and we are going to
    use the Postman extension of Google Chrome browser.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 我们必须识别和理解API端点、参数和返回数据格式，以使用API功能构建功能。测试API请求是理解过程的最佳方式。我们可以使用现有的工具来简化API请求测试过程。有许多这样的工具，我们将使用Google
    Chrome浏览器的Postman扩展。
- en: '**Postman** is a tool that simplifies the process of managing APIs by offering
    features such as testing API requests, building API documentation, and monitoring
    API usage. This tool also provides many additional API-related features in both
    free and PRO versions. The free extension is more than enough to work with basic
    API testing for your projects. You can use the PRO version for advanced features
    such as team colloboration, creating mock servers and integrations with many third-party
    APIs.'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: '**Postman** 是一个通过提供测试API请求、构建API文档和监控API使用等特性来简化管理API过程的工具。此工具在免费和PRO版本中提供了许多额外的API相关功能。免费扩展对于处理基本API测试项目来说已经足够。您可以使用PRO版本的高级功能，例如团队协作、创建模拟服务器以及与许多第三方API的集成。'
- en: 'You can install the extension in your chrome browser from [https://www.getpostman.com/](https://www.getpostman.com/).
    Once installed, you will get a standalone app, as shown in the following screenshot:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以从[https://www.getpostman.com/](https://www.getpostman.com/)在您的Chrome浏览器中安装此扩展。一旦安装，您将获得一个独立的程序，如下面的截图所示：
- en: '![](img/8e87c0d8-6c90-4076-b11a-6423bed1fbb7.png)'
  id: totrans-174
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/8e87c0d8-6c90-4076-b11a-6423bed1fbb7.png)'
- en: Now we are ready to test API requests with WordPress REST API. Mainly, we use
    HTTP `GET` and `POST` requests in development tasks. However, this tool provides
    the ability to use various HTTP request types, such as `PUT` and `DELETE`. The
    REST API contains endpoints that allows us to directly use GET requests as well
    as `POST` requests which requires authentication. So, we are going to check both
    types of requests.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们准备使用WordPress REST API测试API请求。主要来说，我们在开发任务中主要使用HTTP `GET` 和 `POST` 请求。然而，这个工具提供了使用各种HTTP请求类型的能力，例如
    `PUT` 和 `DELETE`。REST API包含端点，允许我们直接使用GET请求以及需要认证的`POST`请求。因此，我们将检查这两种类型的请求。
- en: 'Let’s start by testing a GET request. Basically, these endpoints exposes the
    existing data in WordPress. First, you have to enter the URL of the endpoint in
    Enter request URL field and select the HTTP request as `GET`. The endpoint needs
    to be added after the  [http://www.example.com/wp-json/](http://www.example.com/wp-json/)
    section in the URL. So, the request for accessing the list of posts via REST API
    looks similar to the parameters shown in the following screenshot:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从测试一个GET请求开始。基本上，这些端点暴露了WordPress中现有的数据。首先，你必须在**输入请求URL**字段中输入端点的URL，并将HTTP请求选择为`GET`。端点需要添加到URL中的[http://www.example.com/wp-json/](http://www.example.com/wp-json/)部分之后。因此，通过REST
    API访问帖子列表的请求看起来与以下截图所示的参数相似：
- en: '![](img/f12f53cc-9f6a-4a6c-92c1-1b3b54d3f9d7.png)'
  id: totrans-177
  prefs: []
  type: TYPE_IMG
  zh: '![截图](img/f12f53cc-9f6a-4a6c-92c1-1b3b54d3f9d7.png)'
- en: The screen on the bottom displays the result of the request in the format we
    choose. We have to choose JSON as the result type, since successful API requests
    returns JSON data. Since we are using GET requests, the Type was also set as No
    Auth.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 底部的屏幕显示了我们选择的请求结果的格式。我们必须选择JSON作为结果类型，因为成功的API请求返回JSON数据。由于我们正在使用GET请求，类型也被设置为无认证。
- en: Now we can move forward to testing POST requests for retrieving data for display
    as well as modifying the database through API requests. Testing POST requests
    require more work compared to using GET requests. These requests always require
    some authentication and return an error when valid authentication is not available.
    So, first. you have to add the URL in **Enter request URL** and select the method
    as `POST`. Next, go to **Authorization** tab and select Basic Auth as the type.
    Then add the Username and Password of a user in your site with post creation and
    edit capabilities.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以继续测试用于检索数据以显示以及通过API请求修改数据库的POST请求。与使用GET请求相比，测试POST请求需要更多的工作。这些请求始终需要某种认证，并且在没有有效认证的情况下返回错误。因此，首先，你必须在**输入请求URL**中添加URL，并将方法选择为`POST`。接下来，转到**授权**标签页，并选择基本认证作为类型。然后添加具有创建和编辑帖子能力的网站用户的用户名和密码。
- en: 'Generally, POST requests need additional parameters and values. Here, we are
    trying to create a post, and hence you can add the post details as key-value pairs
    in the form-data section of Body tab. Finally, click on the **Send** button to
    send the API request. However, you will get the following error message instead
    of creating the post:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，POST请求需要额外的参数和值。在这里，我们正在尝试创建一个帖子，因此你可以在“主体”标签页的表单数据部分添加帖子详情作为键值对。最后，点击**发送**按钮发送API请求。然而，你将得到以下错误消息而不是创建帖子：
- en: '[PRE14]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'You might be confused why it''s returning a permission error even when we have
    provided basic authentication details. WordPress considers Basic Auth as an unsafe
    way of handling REST API requests, and, hence, **Basic Auth** is disabled by default.
    So, we have to use a plugin called **JSON Basic Authentication** by the WordPress
    API Team. This plugin is included in the source code folder for this chapter.
    Once this plugin is activated, you can send the request again and will see the
    response and form parameters, as shown in the following screenshot:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能不明白为什么即使我们提供了基本的认证信息，它仍然返回权限错误。WordPress认为基本认证是一种不安全的处理REST API请求的方式，因此，**基本认证**默认是禁用的。所以，我们必须使用WordPress
    API团队开发的名为**JSON基本认证**的插件。此插件包含在本章的源代码文件夹中。一旦此插件被激活，你就可以再次发送请求，并看到响应和表单参数，如下面的截图所示：
- en: '![](img/7954b0a4-50e6-41e2-a2d3-c0d9d688f641.png)'
  id: totrans-183
  prefs: []
  type: TYPE_IMG
  zh: '![截图](img/7954b0a4-50e6-41e2-a2d3-c0d9d688f641.png)'
- en: The response will contain the details about the newly created post from our
    request. You can use `UPDATE` and `DELETE` operations similarly by changing the
    request type and providing necessary parameter values.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 响应将包含关于我们请求中创建的新帖子的详细信息。你可以通过更改请求类型并提供必要的参数值，使用`UPDATE`和`DELETE`操作类似地使用。
- en: Basic Auth is not a recommended way of authenticating the REST API, since we
    have to transfer username and password details in each request in plain text format.
    So, the WordPress team suggests that we should only use Basic Auth for testing
    purposes or in highly secured private networks only.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们必须在每次请求中以纯文本格式传输用户名和密码详情，因此基本认证不是推荐用于认证REST API的方式。WordPress团队建议我们仅将基本认证用于测试目的或在高度安全的私有网络中。
- en: Managing custom routes and endpoints
  id: totrans-186
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 管理自定义路由和端点
- en: The real power of REST API comes with the usage of custom routes and endpoints.
    There are certain limitations in adjusting existing routes and endpoints to our
    requirements. In some scenarios, we may have to create our own classes and extend
    the WordPress core classes to achieve custom functionality. So, custom routes
    and endpoints allow us to implement custom REST API features with minimum work,
    without interfering with WordPress core REST API features.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: REST API的真正力量来自于自定义路由和端点的使用。在调整现有路由和端点以满足我们的要求方面存在某些限制。在某些情况下，我们可能必须创建自己的类并扩展WordPress核心类来实现自定义功能。因此，自定义路由和端点允许我们以最少的努力实现自定义REST
    API功能，而不会干扰WordPress核心REST API功能。
- en: 'In this section, we are going to implement the following features to learn
    the basics of custom REST API routes and endpoints:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将实现以下功能，以学习自定义REST API路由和端点的基础：
- en: Disable the default post endpoint and use custom routes to expose posts only
    in selected categories with selected post data
  id: totrans-189
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 禁用默认帖子端点并使用自定义路由仅在选择类别中选择帖子数据公开帖子
- en: Provide REST API access to custom table data by listing available attachments
    in a post
  id: totrans-190
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过列出帖子中的可用附件来提供自定义表数据的REST API访问
- en: Let's start the implementation of these two features.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始实现这两个功能。
- en: Creating custom routes for posts
  id: totrans-192
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为帖子创建自定义路由
- en: The default post related endpoint is accessible through `/wp/v2/posts`. We can
    execute a `GET` request on this endpoint without any parameters to retrieve the
    list of posts with all the main post details. Let's assume we want to use custom
    routes for each functionality in this endpoint to have more control over the post-related
    API requests. So, we have to block the existing endpoint before defining our own
    routes.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 默认帖子相关端点可通过`/wp/v2/posts`访问。我们可以对该端点执行不带任何参数的`GET`请求，以检索包含所有主要帖子细节的帖子列表。假设我们想要使用自定义路由为该端点的每个功能提供更多控制，因此我们必须在定义自己的路由之前阻止现有端点。
- en: 'We are going to use a new plugin called **WQ REST API** to implement the features
    required for the REST API section of this chapter. You can use the plugin creation
    technique discussed in previous chapters to create the plugin with a main file.
    Let''s block the default post endpoint by using the following code inside the
    main file of the plugin:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用一个名为**WQ REST API**的新插件来实现本章REST API部分的所需功能。您可以使用前几章中讨论的插件创建技术，通过创建一个主文件来创建该插件。让我们通过在插件的主文件中使用以下代码来阻止默认的帖子端点：
- en: '[PRE15]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'WordPress provides a filter called `rest_endpoints` to filter the existing
    endpoints and customize them by either removing or creating new ones. In this
    scenario, we have disabled the default post related endpoint by unsetting it from
    the endpoints array. This will remove the ability to list, create, update, and
    delete posts. So, we have to define custom routes for each of those features or
    use the same custom route to support all the post-related operations. Let''s start
    by adding a custom route to provide post data to third-party sources:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: WordPress提供了一个名为`rest_endpoints`的过滤器，用于过滤现有端点并通过删除或创建新的端点来自定义它们。在这种情况下，我们通过从端点数组中取消设置来禁用了默认的帖子相关端点。这将移除列出、创建、更新和删除帖子的能力。因此，我们必须为每个这些功能定义自定义路由，或者使用相同的自定义路由来支持所有与帖子相关的操作。让我们首先添加一个自定义路由来为第三方源提供帖子数据：
- en: '[PRE16]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The REST API includes an action called `rest_api_init`, which gets fired before
    executing an API request. Therefore, it’s the recommended action to introduce
    new routes to the API. Inside the callback function, we use the `register_rest_route`
    function to create new routes for our application. Let''s identify the basic parameters
    used in `register_rest_route` function:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: REST API包括一个名为`rest_api_init`的操作，它在执行API请求之前被触发。因此，将新路由引入API的推荐操作是它。在回调函数内部，我们使用`register_rest_route`函数为我们应用程序创建新路由。让我们确定`register_rest_route`函数中使用的参数的基本参数：
- en: '`namespace`: This will be the first URL segment after the main REST API URL.
    Here, we have used `wqra/v1`, and, hence, it will replace the `wp/v2` we used
    for accessing core WordPress routes.'
  id: totrans-199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`namespace`：这将是在主REST API URL之后的第一个URL段。在这里，我们使用了`wqra/v1`，因此它将替换我们用于访问核心WordPress路由的`wp/v2`。'
- en: '`route`: This is the base URL for the route. Here, we have used `read_posts`
    as the route, and it will replace the default route of posts.'
  id: totrans-200
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`route`：这是路由的基本URL。在这里，我们使用了`read_posts`作为路由，它将替换帖子的默认路由。'
- en: '`methods`: Here, we have used the method as `WP_REST_Server::READABLE`. It
    makes sure that our custom route works when `WP_REST_Server` changes our readable
    endpoints. The *readable* constant of `WP_REST_Server` class is an alias of the `GET`
    method.'
  id: totrans-201
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`methods`：在这里，我们使用的方法是`WP_REST_Server::READABLE`。这确保了当`WP_REST_Server`更改我们的可读端点时，我们的自定义路由可以正常工作。`WP_REST_Server`类的`readable`常量是`GET`方法的别名。'
- en: '`callback`: This is the function that gets executed when a route is matched
    to a given endpoint. We have defined a callback function called `wqra_read_posts_handler`.
    All the post data that should be sent in the REST API response is prepared within
    this function.'
  id: totrans-202
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`callback`：这是当路由与给定的端点匹配时执行的函数。我们定义了一个名为`wqra_read_posts_handler`的回调函数。所有应在REST
    API响应中发送的帖子数据都在此函数中准备。'
- en: '`permission_callback`: This is the function used to check the permission of
    the request before executing the callback function. We have returned TRUE to provide
    permission. In real scenarios, we need to check user permissions using `current_user_can`
    function and return the Boolean value based on the user permission levels.'
  id: totrans-203
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`permission_callback`：这是在执行回调函数之前检查请求权限的函数。我们返回TRUE以提供权限。在实际场景中，我们需要使用`current_user_can`函数检查用户权限，并根据用户权限级别返回布尔值。'
- en: 'Now we can look into the implementation of our callback function for generating
    the posts list specific for the web site. Consider the following implementation
    of the `wqra_read_posts_handler` function:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以查看我们生成特定于网站的帖子列表的回调函数的实现。考虑以下`wqra_read_posts_handler`函数的实现：
- en: '[PRE17]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: First, we use `WP_Query` object to pass custom settings and generate the list
    of posts based on our requirements. In this case, we are only allowing API users
    to view posts, except the ones from chosen categories. Then, we only add the post
    ID and title of the post, as we only want to provide these two pieces of data
    for API users. The default posts list gives access to all the main data of a post,
    and hence it’s not suitable for our requirements. Finally, we pass the resulted
    data array to the `rest_ensure_response` function. This function converts our
    data to JSON and returns the response compatible with `WP_REST_Response`.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们使用`WP_Query`对象传递自定义设置并生成基于我们要求的帖子列表。在这种情况下，我们只允许API用户查看帖子，除了所选分类的帖子。然后，我们只添加帖子的ID和标题，因为我们只想为API用户提供这两条数据。默认的帖子列表提供了对帖子所有主要数据的访问权限，因此它不适合我们的要求。最后，我们将结果数据数组传递给`rest_ensure_response`函数。此函数将我们的数据转换为JSON，并返回与`WP_REST_Response`兼容的响应。
- en: Creating custom routes and endpoints for custom table data
  id: totrans-207
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为自定义表数据创建自定义路由和端点
- en: In the previous section, we looked at the process of disabling existing API
    endpoints and creating our own endpoints to handle core WordPress data. The default
    WordPress REST APIs don't have any routes or endpoints for working with custom
    table data. So, we have to always use our own custom routes and endpoints for
    manipulating custom table data.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节中，我们探讨了禁用现有的API端点并创建我们自己的端点来处理核心WordPress数据的过程。默认的WordPress REST API没有用于处理自定义表数据的任何路由或端点。因此，我们必须始终使用我们自己的自定义路由和端点来操作自定义表数据。
- en: 'In the previous chapters, we created a plugin to add attachments to posts.
    Now we are going to create a custom API endpoint that allows us to retrieve the
    attachments of a given post. Let''s start by adding another custom route to our
    REST API plugin, as shown in the following code:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的章节中，我们创建了一个插件来添加附件到帖子。现在，我们将创建一个自定义API端点，允许我们检索给定帖子的附件。让我们从向我们的REST API插件添加另一个自定义路由开始，如下面的代码所示：
- en: '[PRE18]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: We use the same namespace as on the last occasion and use `list_post_attachments`
    as the new route. Also, we have an additional parameter in brackets, where we
    can pass the ID of the post. We have also set the method to `POST` instead of
    using `GET`. Since we are retrieving records and passing the ID in URL, we could
    have used `GET` as the method. However, we have enabled `POST` method so that
    we can pass additional parameters and filter the results. We have used a new callback
    function, `wqra_list_post_attachments_handler`, to handle the new custom route.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用与上次相同的命名空间，并使用`list_post_attachments`作为新的路由。此外，我们在括号中添加了一个额外的参数，其中我们可以传递帖子的ID。我们还已将方法设置为`POST`而不是使用`GET`。由于我们正在检索记录并在URL中传递ID，我们可以使用`GET`作为方法。然而，我们已启用`POST`方法，以便我们可以传递额外的参数并过滤结果。我们已使用一个新的回调函数`wqra_list_post_attachments_handler`来处理新的自定义路由。
- en: 'In this scenario, there is an additional parameter called `args` compared to
    the previous custom route. This `args` array is used to specify additional parameters
    for the route. In this case, we use it to validate the parameters passed to the
    endpoint. The post ID is a numeric value, and hence we need to validate it before
    executing the REST API request. So, we execute the `validate_callback` function
    of the ID parameter. If you pass string value for the post ID, you will get the
    following invalid parameter error:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，与之前的自定义路由相比，还有一个额外的参数称为`args`。这个`args`数组用于指定路由的附加参数。在这种情况下，我们使用它来验证传递给端点的参数。帖子ID是一个数值，因此我们需要在执行REST
    API请求之前对其进行验证。因此，我们执行ID参数的`validate_callback`函数。如果您为帖子ID传递字符串值，您将得到以下无效参数错误：
- en: '[PRE19]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'We can use this technique to validate multiple parameters with different conditions
    and make sure requests only contain the data in requested formats. Now we can
    move into the implementation of the `wqra_list_post_attachments_handler` function
    for handling the request to the new route:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用这项技术来验证具有不同条件的多个参数，并确保请求只包含请求的格式中的数据。现在我们可以进入实现`wqra_list_post_attachments_handler`函数，该函数用于处理对新路由的请求：
- en: '[PRE20]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The REST API request object is passed to this function as a parameter. So, we
    use the `get_params` function of the `$data` object to retrieve the available
    parameters in the request. Next, we capture the post ID using the `id` attribute
    of the `$data` object. Next, we execute a custom query on the `wpqpa_post_attachments`
    table. The result will contain the file attachments for the given post. Then,
    we traverse through the results and assign the attachment details in to an array.
    Finally, we use the `rest_ensure_response` function to pass the attachment data
    in JSON format to the response.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 将REST API请求对象作为参数传递给此函数。因此，我们使用`$data`对象的`get_params`函数来检索请求中可用的参数。接下来，我们使用`$data`对象的`id`属性捕获帖子ID。接下来，我们在`wpqpa_post_attachments`表上执行一个自定义查询。结果将包含给定帖子的文件附件。然后，我们遍历结果并将附件详情分配到一个数组中。最后，我们使用`rest_ensure_response`函数将附件数据以JSON格式传递到响应中。
- en: There are also some disadvantages in using custom routes and endpoints, in situations
    where we have the ability to use existing routes and endpoints. We need to implement
    our own pagination and sorting for custom endpoints while WordPress provides them
    by default for existing endpoints. We can use user permission checks by default
    in WordPress core endpoints while we need to pass additional nonce parameters
    to check user permissions.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们有能力使用现有路由和端点的情况下，使用自定义路由和端点也有一些缺点。对于自定义端点，我们需要实现自己的分页和排序，而WordPress默认为现有端点提供这些功能。我们可以在WordPress核心端点中默认使用用户权限检查，而我们需要传递额外的nonce参数来检查用户权限。
- en: Now we can call this new route and retrieve the file attachments list for a
    given post.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以调用这个新路由，并检索给定帖子的文件附件列表。
- en: Building the REST API client
  id: totrans-219
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建REST API客户端
- en: The API client is the user or service that uses the data provided by the REST
    API. We use the client to access the REST API of another site. The client site
    could be WordPress or a non-WordPress site. The client can also be implemented
    in a different programming language without using PHP. Let's identify the usage
    of API clients. In this chapter, we going to look at the process of building REST
    API client to access our data from external sites, as it's the most important
    use of an API.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: API客户端是使用REST API提供的数据的用户或服务。我们使用客户端来访问其他站点的REST API。客户端站点可以是WordPress或非WordPress站点。客户端也可以在不使用PHP的情况下用不同的编程语言实现。让我们确定API客户端的用法。在本章中，我们将探讨构建REST
    API客户端以从外部站点访问我们的数据的过程，因为这是API最重要的用途之一。
- en: REST API client from external site
  id: totrans-221
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 来自外部站点的REST API客户端
- en: This is where the REST API is used to its maximum potential, even though we
    use it to build functionality of the same site. The main intention of creating
    a REST API is to provide access to third-party WordPress and non-WordPress based
    applications. So, the API client can be implemented in any programming language.
    In this section, we will be building a PHP based API client for accessing REST
    APIs of other applications with the support of CURL.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 即使我们将REST API用于构建同一站点的功能，它也在这里达到了最大潜力。创建REST API的主要目的是为第三方WordPress和非WordPress基于的应用程序提供访问权限。因此，API客户端可以用任何编程语言实现。在本节中，我们将构建一个基于PHP的API客户端，以支持CURL访问其他应用程序的REST
    API。
- en: 'Let''s add the API client implementation with CURL. You should place this code
    in a PHP file and access it from a source external to your application:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们添加使用CURL的API客户端实现。你应该将此代码放置在一个PHP文件中，并从应用程序外部访问它：
- en: '[PRE21]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'We create a function called `wpquick_rest_api_client` to accept two parameters
    for the API endpoint: URL and the post data. Then, we initialize a `curl` request
    by executing `curl_init` function on the specified route. Next, we add the authorization
    header with a base-64 encoded string containing the combination of `username:password`.
    We need some sort of authenticate method to execute POST and DELETE requests.
    We should only use an authorization header for testing purposes. We will be discussing
    various authentication techniques in the next section. Then, we will specify the
    necessary `curl` parameters and add the post data to the request, if it''s provided.
    Finally, we execute and print the API response returned from the server.'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建了一个名为`wpquick_rest_api_client`的函数，用于接受API端点的两个参数：URL和文章数据。然后，我们通过在指定路由上执行`curl_init`函数来初始化一个`curl`请求。接下来，我们添加一个包含`username:password`组合的base-64编码字符串的授权头。我们需要某种认证方法来执行POST和DELETE请求。我们应该只为测试目的使用授权头。我们将在下一节讨论各种认证技术。然后，我们将指定必要的`curl`参数，并在请求中添加文章数据（如果提供）。最后，我们执行并打印从服务器返回的API响应。
- en: Now we have a basic API client function, and we can call the function with necessary
    parameters to execute REST API requests, as shown in the preceding code. In this
    case, we are retrieving the file attachments of the forum with the ID 5 as a JSON
    string. If we request the ID as a string, we will get an invalid parameter error,
    since it's validated and restricted in our route. So, we have identified the process
    of building an API client to access the site from external sources.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有一个基本的API客户端函数，我们可以使用必要的参数调用该函数来执行REST API请求，如前述代码所示。在这种情况下，我们正在以JSON字符串的形式检索ID为5的论坛的文件附件。如果我们请求ID作为字符串，我们将得到一个无效参数错误，因为它是经过验证和限制的。因此，我们已经确定了从外部来源构建API客户端以访问网站的过程。
- en: REST API is becoming the trend in modern web applications, and hence WordPress
    seems to provide more and more features to build fully functional REST APIs for
    applications. So, in the future, we will see the emergence of REST as a must-use
    WordPress feature.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: REST API正在成为现代Web应用程序的趋势，因此WordPress似乎提供了越来越多的功能来构建功能齐全的REST API。所以，在未来，我们将看到REST成为必须使用的WordPress功能。
- en: Summary
  id: totrans-228
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: WordPress APIs are built for simplifying and standardizing the use of WordPress's
    core features. We can use these API functions to build future-proof solutions
    without spending unnecessary time on development.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: WordPress API是为了简化并标准化WordPress核心功能的使用而构建的。我们可以使用这些API函数来构建未来证明的解决方案，而无需在开发上浪费不必要的时间。
- en: In this chapter, we looked at the importance of using WordPress APIs and had
    a brief introduction to the functionality of each API. We choose three API's that
    play a major role in development, and we discussed them in detail. We started
    by understanding the structure and usage of a shortcode. Then, we discussed various
    techniques and locations for using shortcodes. Next, we moved into Rewrite API,
    which manages custom routes for custom features that go beyond WordPress's core
    features. Finally, we looked at the REST API for developing API functions and
    exposing application data to third-party services.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们探讨了使用WordPress API的重要性，并对每个API的功能进行了简要介绍。我们选择了三个在开发中扮演重要角色的API，并对其进行了详细讨论。我们首先了解了短代码的结构和使用方法。然后，我们讨论了使用短代码的各种技术和位置。接下来，我们转向Rewrite
    API，它管理着超出WordPress核心功能的自定义路由。最后，我们研究了REST API，用于开发API函数并将应用程序数据暴露给第三方服务。
- en: In [Chapter 7](1a709b5f-c476-41f9-bc13-eb5f0541abaa.xhtml), *Managing Custom
    Post Types and Processing Forms,* we will be exploring two of the most important
    aspects in WordPress development by teaching the user of custom post types to
    build various features and use custom forms to capture and display advanced data.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第7章](1a709b5f-c476-41f9-bc13-eb5f0541abaa.xhtml)，“管理自定义文章类型和处理表单”，我们将通过教授用户如何构建各种功能和使用自定义表单来捕获和显示高级数据，来探讨WordPress开发中最重要两个方面。
