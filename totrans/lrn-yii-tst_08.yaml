- en: Chapter 8. Analyzing Testing Information
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the last three chapters, we covered the topic of writing tests at different
    levels: unit, functional, and acceptance. So far, we have tested the new interface
    that we created, and we learned to apply all the new methods. This was a relatively
    easy task, but we don''t know how good we did in our testing. There are some specific
    metrics that we can analyze to generate a direct and immediate report on the quality
    of the tests. These reports will help us in taking informed decisions regarding
    the architecture of our code.'
  prefs: []
  type: TYPE_NORMAL
- en: Codeception is bundled with most of these report generation tools, and it's
    quite easy as it's been until now.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will primarily cover the code coverage metrics, and we'll
    briefly touch on some other metrics, which can be obtained through various software.
  prefs: []
  type: TYPE_NORMAL
- en: Improving the quality of your tests
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Improving our code with the aid of additional tools
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Improving the quality of your tests
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Since the beginning of programming and, in particular, testing, many programmers
    started questioning themselves on what it means to write good tests, or in other
    words, how do I know that the test I have written is good? What are the metrics
    for this?
  prefs: []
  type: TYPE_NORMAL
- en: It's definitely not a question of personal preference or skill.
  prefs: []
  type: TYPE_NORMAL
- en: One of the first methods that was created for analyzing the quality of the tests
    was called code coverage. From a wider perspective, code coverage measures how
    much of the code is covered by the tests. There is a correlation between software
    bugs and the test code coverage, where the software with more code coverage has
    fewer bugs, although the tests won't remove the possibility of bugs being introduced,
    for instance, as a manifestation of complex interactions between modules or unexpected
    inputs and corner cases. This is why you need to be careful when planning and
    designing your tests, and you need to take into consideration that this won't
    remove the need for regression and exploratory testing, at least, not entirely.
  prefs: []
  type: TYPE_NORMAL
- en: There are several code coverage criteria that are normally used for the code
    coverage programs.
  prefs: []
  type: TYPE_NORMAL
- en: '**Line coverage**: This is based on the number of executable lines that were
    executed.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Function and method coverage**: This calculates the number of functions or
    methods that were executed.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Class and trait coverage**: This measures the covered classes and traits
    when all of their methods are executed.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Opcode coverage**: This is similar to line coverage, although a single line
    might generate more than one opcode. The line coverage considers a line to have
    been covered as soon as one of its opcodes are executed.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Branch coverage**: This measures if each possible combination of Boolean
    expression in the control structures are being evaluated when the tests are run.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Path coverage**: This is also called **Decision-to-Decision** (**DD**) path,
    and it considers all the possible execution paths, in terms of its unique sequence
    of branch execution from the beginning to the end of each method or function.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Change Risk Anti-Patterns** (**C.R.A.P.**) **Index**: This is based on the
    cyclomatic complexity and the code coverage of a unit of code. This index can
    be lowered by refactoring the code or by incrementing the number of tests. Either
    way, it''s primarily used for unit tests.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Since Codeception uses PHP_CodeCoverage, it does not support opcode coverage,
    branch coverage, and path coverage.
  prefs: []
  type: TYPE_NORMAL
- en: With this in mind, if we go back to our unit tests, we will understand a bit
    better the structure of our tests and how they are currently working.
  prefs: []
  type: TYPE_NORMAL
- en: Let's start by enabling the code coverage in our unit tests and then looking
    at their results.
  prefs: []
  type: TYPE_NORMAL
- en: Later, we will look at the functional and acceptance coverage reports, and then
    explore some other interesting information, which we can extract from our code.
  prefs: []
  type: TYPE_NORMAL
- en: Enabling code coverage in Codeception
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Codeception provides a global and a specific configuration for code coverage.
    Depending on the structure of your application and the type of test you are going
    to implement based on your test plan, you can have either a generic configuration
    in `/tests/codeception.yml,` or a specific configuration for each suite configuration
    file, such as `/tests/codeception/unit.suite.yml`. You can also have both of these
    configurations. However, in this case, the single suite configuration will override
    the setting of the global configuration.
  prefs: []
  type: TYPE_NORMAL
- en: 'We are going to use the global configuration file. So at the end of the file,
    append the following lines:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: This should be enough for getting started. The first option enables the code
    coverage, while the rest of the options tell Codeception and the code coverage
    program which files to include when writing the report for the white list and
    the black list. This will ensure that the results aggregate the information that
    is relevant to us, in other words, what we've written, rather than the framework
    itself.
  prefs: []
  type: TYPE_NORMAL
- en: We won't need to run the `build` command of Codeception, as there isn't a new
    module that has to be imported into our tester guys.
  prefs: []
  type: TYPE_NORMAL
- en: If we look at the `help` option for the `run` action of Codeception, then we
    will notice that it has two main options for generating the reports that we are
    interested in.
  prefs: []
  type: TYPE_NORMAL
- en: '`--coverage`: This generates the actual coverage report, and it is accompanied
    by a series of other options for controlling the format and the verbosity of the
    report'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`--report`: This generates an overall report of the tests that were run'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In conjunction with these two options, we will be able to generate the HTML
    and XML test and coverage reports, depending on the use. In particular, the XML
    report will be quite handy when we get to [Chapter 9](ch09.html "Chapter 9. Eliminating
    Stress with the Help of Automation"), *Eliminating Stress with the Help of Automation*.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: It's important to keep in mind that currently the coverage reports of the acceptance
    tests are not merged with the reports generated for the functional and unit tests.
    This is due to the way in which the code coverage is calculated and intercepted.
    Later, we will see what will be needed for generating the coverage reports for
    acceptance tests.
  prefs: []
  type: TYPE_NORMAL
- en: Extracting the code coverage information for unit tests
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the Codeception documentation, this is normally referred to as the **local
    coverage** report and it is applied to both the unit and functional tests. We'll
    touch upon remote coverage when talking about the coverage for acceptance tests.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can easily generate the coverage by appending the `--coverage` flag to the
    command shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'This will end with an output similar to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The execution time you see here is based on a machine with an i7-m620 processor,
    on which runs the Linux kernel. The coverage increases the time exponentially.
    On the same machine, running the unit tests takes less than 10 seconds.
  prefs: []
  type: TYPE_NORMAL
- en: There are methods for shortening the execution time. This can be done by using
    Robo, which is a task runner, and its specific Codeception plugin is robo-paracept.
    More information can be found in the official Codeception documentation at [http://codeception.com/docs/12-ParallelExecution](http://codeception.com/docs/12-ParallelExecution).
  prefs: []
  type: TYPE_NORMAL
- en: This report gives us a succinct and immediate output of the code coverage of
    our unit tests.
  prefs: []
  type: TYPE_NORMAL
- en: The coverage for classes, methods, and lines (and where the percentage is calculated
    from), and a slightly detailed breakdown per class can be seen from the summary.
  prefs: []
  type: TYPE_NORMAL
- en: We can see that we succeeded in covering 100 percent of the `Dog` and `LoginForm`
    classes, and we nonetheless achieved a good 84.62 percent of the methods of the
    `User` class, but disappointingly, we covered only 33.33 percent of the methods
    of the `ContactForm`.
  prefs: []
  type: TYPE_NORMAL
- en: But, what did we miss?
  prefs: []
  type: TYPE_NORMAL
- en: Well, there's only one way to find out, and that is by generating the HTML coverage
    report.
  prefs: []
  type: TYPE_NORMAL
- en: Generating a detailed coverage report of the unit tests
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'With the help of the `--coverage-html` option, we can generate a detailed code
    coverage report. Then, we can inspect it in order to understand what was covered
    and what was missed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'This will now end with the following output line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'The report will be saved in the `_output/coverage/` directory, where you will
    find two files: `dashboard.html` and `index.html`. The first gives you some nice
    graphs, which are a little more interesting than the coverage report summary printed
    on the console, but it is mostly used for showing off and it is not useful for
    understanding what''s wrong with the tests. There''s, in fact, an open request
    for suppressing this output on the console ([https://github.com/Codeception/Codeception/issues/1592](https://github.com/Codeception/Codeception/issues/1592)).'
  prefs: []
  type: TYPE_NORMAL
- en: '![Generating a detailed coverage report of the unit tests](img/B03646_08_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Details of the **Insufficient Coverage** panel on the dashboard
  prefs: []
  type: TYPE_NORMAL
- en: As you can see from the preceding screenshot, the bit that you might be interested
    in at this level of detail is the **Insufficient Coverage** panel, (currently)
    sitting at bottom-left of the page.
  prefs: []
  type: TYPE_NORMAL
- en: We will discuss the other panels later.
  prefs: []
  type: TYPE_NORMAL
- en: You will be really interested in the `index.html` file. From there, you can
    see some of the detailed statistics and you can dig into every single file that
    has been analyzed, to see what lines the tests have covered and so improve your
    tests from there.
  prefs: []
  type: TYPE_NORMAL
- en: '![Generating a detailed coverage report of the unit tests](img/B03646_08_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Summary of the coverage across all files analyzed
  prefs: []
  type: TYPE_NORMAL
- en: The summary of the coverage shows what's been covered, in some detail. This
    helped us in discovering immediately what was wrong with our testing, and in our
    case, one of the tests provided by Yii for `ContactForm` was not covered sufficiently.
    In the preceding screenshot, we can see that it shows 80 percent coverage of lines,
    33.33 percent coverage of the methods, but it does not show anything regarding
    the classes. This is because, unless you have all the methods covered, you won't
    have the class marked as covered.
  prefs: []
  type: TYPE_NORMAL
- en: 'This may not prove be a problem. There are methods that are not a part of our
    implementation and these can only be tested by using an integration test, and
    then there are others that can be covered by paying a bit of attention. If we
    click on the **ContactForm.php** link, then we would see the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Generating a detailed coverage report of the unit tests](img/B03646_08_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Summary of the coverage of the code in the selected file
  prefs: []
  type: TYPE_NORMAL
- en: 'Of the two methods that have not been covered, we don''t really need to cover
    the first method, `attributeLabels()`. Technically, this is because of two reasons:
    the first reason is that as it is a part of the Yii framework, we assume that
    it will work; the second reason is that it''s a trivial method, and it always
    returns an internal variable, which can''t be controlled in any way.'
  prefs: []
  type: TYPE_NORMAL
- en: The other method is the `contact()` method and it has been covered partially.
    So, we're going to fix this. It may well be possible that this specific test will
    get corrected in a future version of the framework. This might be something that
    you need to look out for.
  prefs: []
  type: TYPE_NORMAL
- en: By clicking on the **contact($email)** link, or by just scrolling to the bottom
    of the page, we will find our method, and this will show us that all the paths
    have not been covered.
  prefs: []
  type: TYPE_NORMAL
- en: '![Generating a detailed coverage report of the unit tests](img/B03646_08_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Discovering what needs to be covered with the aid of color coded lines
  prefs: []
  type: TYPE_NORMAL
- en: Our case is quite simple, so we will try to fix these errors either by adding
    the `@codeCoverageIgnore` directive to the documentation of the method that we
    want to exclude, or by adjusting or adding a new test to it in order to reach
    as close as possible to 100 percent. Remember, this is what we will be aiming
    for, but this is not necessarily our target.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'The solution to cover the remaining branch of the `if` statement is to add
    a test similar to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s run our tests again, and we will see the screenshot shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Generating a detailed coverage report of the unit tests](img/B03646_08_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: We've reached 100 percent coverage! Yay!
  prefs: []
  type: TYPE_NORMAL
- en: I'll leave it to you to fix the remaining errors. Certain situations might be
    hard to cover, and you may need additional hints and suggestions on how to restructure
    your tests.
  prefs: []
  type: TYPE_NORMAL
- en: Aggregating functional tests to unit tests
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now that we've seen what is going on in our unit tests and how to visually understand
    if we have effectively covered as much as we could, we can move to the functional
    tests that we wrote previously.
  prefs: []
  type: TYPE_NORMAL
- en: As we saw earlier, we can just add the functional suite to the command line
    for generating the aggregated reports.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: We will also see that by omitting the suites we will end up with the same result,
    but we don't know when the Codeception developers will merge all the three suites
    into a single coverage report, so just keep this in mind and consult the documentation.
  prefs: []
  type: TYPE_NORMAL
- en: Our unit tests have covered the models in their entirety. Our functional tests
    should focus on the controllers. You should be able to spot that the login page
    and the REST module controller have not been covered completely. So, let's discuss
    these one by one.
  prefs: []
  type: TYPE_NORMAL
- en: The login page will display the missing coverage for the login and the logout
    action.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the first case, it seems pretty easy to cover that. We have to make sure
    that we reach that action after logging in. So, let''s add the following assertion
    right after the successful login at the end of the test file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: As we can see, we're using a few specific paths for testing the website. This
    isn't a problem when interacting with the Codeception REST module, but here we
    have to be verbose.
  prefs: []
  type: TYPE_NORMAL
- en: The other portion that we have to cover is a little more complex. Once we are
    logged in, notice that the logout button has a JS click event attached to it,
    and that will send a POST request to `/logout`.
  prefs: []
  type: TYPE_NORMAL
- en: Since PHPBrowser won't be able to read JS, nor will it have the ability to do
    a specific POST call, we won't be able to cover this piece of code. Don't even
    think about using `sendPost()` as it's a specific method, which comes from the
    REST module of Codeception.
  prefs: []
  type: TYPE_NORMAL
- en: The only solution for this is to leave the coverage of this bit to the acceptance
    tests or to WebDriver.
  prefs: []
  type: TYPE_NORMAL
- en: Due to the fact that acceptance and functional tests have not been merged, we
    can exclude this method from the coverage report by using `@codeCoverageIgnore`.
    However, make sure that this isn't a case anymore and discuss it with your colleagues
    before excluding the method coverage from all the tests.
  prefs: []
  type: TYPE_NORMAL
- en: The last part that we need to cover is the controller of the REST interface.
    Here, we have a mixed situation. We have uncovered the functions that are mostly
    a part of our framework, such as the anonymous function that performs the authentication
    and `checkAccess()`, we have a small bit in `actionUpdate()`, which forbids anything
    but a PUT, and we have another control statement in `actionSearch()`, which controls
    who can search what.
  prefs: []
  type: TYPE_NORMAL
- en: In the first two cases we'll gladly avoid them from getting covered, as we've
    explicitly excluded the framework files which these two are part of.
  prefs: []
  type: TYPE_NORMAL
- en: For `actionUpdate(),` we'll find out that we won't even need a specific check,
    as Yii already defines the type of HTTP call that is allowed against the default
    REST interfaces.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can add a test that ensures that we can''t perform a POST on the interface
    and it can be added to any of the already present tests. This could be something
    along the lines of the following code block:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Lastly, we want to ensure that the user can only search for his own username
    to get the ID, as we outlined in [Chapter 6](ch06.html "Chapter 6. Testing the
    API – PHPBrowser to the Rescue"), *Testing the API – PHPBrowser to the Rescue*.
    In order to do this, we can simply add something similar to the code block shown
    here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: If we run the tests with coverage, then we'll get a 100 percent on all the files
    that we wanted to see the coverage on.
  prefs: []
  type: TYPE_NORMAL
- en: '![Aggregating functional tests to unit tests](img/B03646_08_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The final overview of the coverage for unit and functional tests
  prefs: []
  type: TYPE_NORMAL
- en: Generating acceptance tests' coverage report
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now that we've seen what to make of our coverage reports, we'll quickly look
    at the configuration that will help us in obtaining the coverage reports for the
    acceptance tests.
  prefs: []
  type: TYPE_NORMAL
- en: These coverage reports might not be the most important ones, but if constructed
    correctly, then they should prove that our scenarios are well written. Normally,
    the focus of acceptance tests is on ensuring browser cross- and preserving retro-compatibility.
  prefs: []
  type: TYPE_NORMAL
- en: As we've seen in [Chapter 7](ch07.html "Chapter 7. Having Fun Doing Browser
    Testing"), *Having Fun Doing Browser Testing*, Codeception talks to the Selenium
    standalone server, which in turn launches the browser and performs the required
    tests through the browser driver. Because of this architecture, the c3 project
    has been created, which basically listens to the browser calls and understands
    which bit of our code is being executed remotely.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, first of all, let''s get c3\. We can either download it from Composer or
    from the official website ([https://github.com/Codeception/c3](https://github.com/Codeception/c3))
    by running this command from the root of the project:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: If you're downloading it through Composer, then you'll have to add some additional
    instructions to the `composer.json` file. You should take the official documentation
    as the main reference point.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once you have it, include it in the `index-test.php` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'With this, we have hooked c3 to Yii. Now, we just need to make Codeception
    aware of it. So open the `codeception.yml` file, and add the following options
    to the `coverage` section of the file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: We need to enable the remote coverage, set the configuration of the file by
    using `remote_config,` and then specify the URL c3 should be listening on.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The detailed explanation of the remote code coverage and its configuration can
    be read from the official documentation of Codeception, which can be found at
    [http://codeception.com/docs/11-Codecoverage](http://codeception.com/docs/11-Codecoverage),
    and from the `README.md` file, which is either located in the `tests/` directory
    of your project or at [https://github.com/yiisoft/yii2-app-basic/tree/master/tests#remote-code-coverage](https://github.com/yiisoft/yii2-app-basic/tree/master/tests#remote-code-coverage).
  prefs: []
  type: TYPE_NORMAL
- en: Now, all our remote calls will go through the `index-test.php` file, and they
    will use c3 to generate the coverage data.
  prefs: []
  type: TYPE_NORMAL
- en: Additionally, we may want to get a trimmed down report for specific acceptance
    tests, and in our case, we can decide to focus our attention only on the controllers
    that are being hit, and then choose to remove any reporting for the models.
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to do so, consider what we already have in the main configuration
    file. We just need to add the following to our `acceptance.suite.yml` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'At this point, you can generate the reports separately by using the code block
    shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'You can also do this by simply running the tests for the whole suite, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: As we saw earlier, both of these methods will generate a separate report for
    the acceptance tests. It might happen that in the future this is no longer valid,
    so be sure to head over to the official documentation and check that.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once we generate the reports, we will notice two things: the tests with the
    coverage report might take ages, so we don''t want to run this every time we make
    a change to the interface. Secondly, we will have to cover the missing logout
    test that we have highlighted before.'
  prefs: []
  type: TYPE_NORMAL
- en: So, let's go to our `LoginCept.php` file and add what's missing.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Please note that we need to be very specific while using the URLs, just as we
    were with the functional tests.
  prefs: []
  type: TYPE_NORMAL
- en: Once this is done, we should find ourselves with the complete coverage of all
    the suites.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we'll see what else we can generate, and then we'll take
    it to the next level with the aid of automation in the next chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Improving our code with the aid of additional tools
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In addition to code coverage and test reports, we have a range of additional
    tools, which we can use for improving the quality of our code.
  prefs: []
  type: TYPE_NORMAL
- en: The two tools that we're going to talk about are the check style and the cyclomatic
    complexity through the C.R.A.P. index.
  prefs: []
  type: TYPE_NORMAL
- en: We are going to add more examples and tools to these in [Chapter 9](ch09.html
    "Chapter 9. Eliminating Stress with the Help of Automation"), *Eliminating Stress
    with the Help of Automation*, as each command would require too much knowledge
    from the developer's side, and it is something that can be automated and triggered
    by the flick of a switch.
  prefs: []
  type: TYPE_NORMAL
- en: '**PHP Checkstyle** (**PHPCS**) is a great tool, albeit it is rather complex
    at first . This will help us in maintaining a style of code that is uniform for
    all developers. You might care too much about this, and I''ve seen situations
    where decisions on which style to use have resulted in a big fight. However, the
    benefits of this are quite evident, as it forces the developers to control their
    style of coding. When used with the cyclomatic complexity, it can standardize
    the code and avoid any situation involving intricate and difficult code.'
  prefs: []
  type: TYPE_NORMAL
- en: There are some already existing code standards available for your use and these
    have been configured according to your needs. PHPCS only needs a reference for
    the configuration file or the name of the standard to follow.
  prefs: []
  type: TYPE_NORMAL
- en: We are going to install and use Yii 2 own code standards, which you can use
    as a base for specifying the rules that are more suited to your needs.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can install the Yii 2 code standards by using Composer, which will include
    the actual binary that we need as a dependency:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Once we have installed both of them, we can invoke them through the console
    by using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: The last three arguments are the folders that we want PHPCS to scan.
  prefs: []
  type: TYPE_NORMAL
- en: If you want to improve your code, then you should make use of the C.R.A.P. index,
    which is included in the coverage reports generated by Codeception. In the following
    chapter, we'll see how the cyclomatic complexity index can be used for basing
    the decisions for modifying your code.
  prefs: []
  type: TYPE_NORMAL
- en: The C.R.A.P. index has been designed for analyzing and predicting the amount
    of effort, pain, and time required for maintaining an existing body of code.
  prefs: []
  type: TYPE_NORMAL
- en: 'It is mathematically defined as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '*C.R.A.P.(m) = comp(m)^2 * (1 – cov(m)/100)^3 + comp(m)*'
  prefs: []
  type: TYPE_NORMAL
- en: Where *comp(m)* is the cyclomatic complexity, and *cov(m)* is the test code
    coverage provided by the automated tests. The cyclomatic complexity is calculated
    as 1 plus the number of unique decisions in the method.
  prefs: []
  type: TYPE_NORMAL
- en: A low C.R.A.P. index indicates a relatively low change and maintenance risk,
    because it's either not too complex or sufficiently covered by tests. To keep
    it practical, if your method is a straight sequence of calls, then it is likely
    that it will have a C.R.A.P. index that is close to 1\. The more `if`, `for,`
    and `while` clauses it has, the more complex it will be, and hence it will have
    a higher C.R.A.P. index.
  prefs: []
  type: TYPE_NORMAL
- en: This is where testing lets the potential problems emerge and points you in the
    direction that you should be taking for keeping your code maintainable and modular.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we've discussed the basic steps needed for configuring and
    generating the code coverage for the project. We've seen how to use the reports
    generated for discovering potential problems with the code. We've also covered
    some additional tools for improving our code quality.
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 9](ch09.html "Chapter 9. Eliminating Stress with the Help of Automation"),
    *Eliminating Stress with the Help of Automation*, we'll complete this journey.
    We will discuss the topic of additional tools, how to integrate them into a continuous
    integration system, and then display the results for better access and browsing.
  prefs: []
  type: TYPE_NORMAL
