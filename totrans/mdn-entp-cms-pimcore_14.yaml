- en: '*Chapter 14*: Data Integration'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapter, you learned about the concept of **Master Data Management**
    (**MDM**), and how to expose Pimcore objects to third-party applications using
    the **Datahub** Pimcore bundle. After defining how to install and activate that
    bundle and how to configure it, you learned how to perform GraphQL queries to
    retrieve object data and to create, update, or delete objects.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, you will learn how to perform data integration in Pimcore through
    standard import and export functionalities, when these standards are supposed
    to be used, and, otherwise, when the implementation of custom solutions is necessary.
  prefs: []
  type: TYPE_NORMAL
- en: 'The chapter is organized as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Importing Data
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Exporting Data
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Limitations of Standard Functionalities
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing Custom Solutions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Configuring the Data Importer
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We'll start by presenting how to perform simple CSV data importing and exporting
    using standard solutions. Then, we will explain the limitations you may encounter
    on using these standard solutions for importing and exporting, and we will explain
    how to implement a custom data operator that can be used in import configuration.
    Later in this chapter, we will present how to implement custom solutions for importing
    and exporting.
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As you have done in previous chapters, all you need to do is run the demo connected
    to this chapter by navigating to the `14\. Data Integration` folder of the official
    book repository and start a Docker environment.
  prefs: []
  type: TYPE_NORMAL
- en: 'To do so, just follow these instructions:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Run Docker with the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then, to restore all the settings on your local machine, just open a new shell
    and type the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Navigate to [http://localhost/admin](http://localhost/admin) and log in with
    your admin/pimcore credentials.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'You can access the official book repository to get the source code through
    the following link:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://github.com/PacktPublishing/Modernizing-Enterprise-CMS-using-Pimcore/tree/main/14.%20Data%20Integration](https://github.com/PacktPublishing/Modernizing-Enterprise-CMS-using-Pimcore/tree/main/14.%20Data%20Integration)'
  prefs: []
  type: TYPE_NORMAL
- en: Now you are ready to navigate the demo to discover all the aspects related to
    this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Importing Data
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, you will learn how to import data through a standard Pimcore
    CSV import. We will see how to configure the import of a simple CSV file, looking
    at the details of each step of the configuration, and how to save this configuration
    to use it in future imports.
  prefs: []
  type: TYPE_NORMAL
- en: Although this feature is deprecated in PimcoreX, we must consider that the Pimcore
    6 version still has widespread usage, so the explanation of this feature is still
    quite important. In the *Configuring the Data Importer* section of this chapter,
    we will then explain how to configure the new Pimcore Data Importer.
  prefs: []
  type: TYPE_NORMAL
- en: To start a new CSV import, just right-click on the folder in which you want
    to import the objects, select **CSV Import**, and select the object class of the
    objects you want to import. This operation will open an **Upload** dialog, through
    which you can upload the CSV file to import.
  prefs: []
  type: TYPE_NORMAL
- en: Once the file is uploaded, a new modal will be opened, and you can start to
    configure the import. In the following sections, we will analyze each step of
    this configuration.
  prefs: []
  type: TYPE_NORMAL
- en: CSV File Preview
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In the first panel of the imported configuration, a preview of the uploaded
    CSV file is shown. In the following screenshot, you can see how this panel looks:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 14.1: CSV File Preview'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_14.01_B17073.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 14.1: CSV File Preview'
  prefs: []
  type: TYPE_NORMAL
- en: As you can see in the previous screenshot, the CSV file rows are rendered as
    a table. If the checkbox at the top is enabled, the first CSV row is intended
    to contain the headers.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we will see how to perform column configuration, to associate
    every CSV column with the corresponding class attribute.
  prefs: []
  type: TYPE_NORMAL
- en: Column Configuration
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In the **Column Configuration** panel, we can associate every CSV column to
    the corresponding class attribute, so that for each CSV import, we can affect
    only a subset of the class fields. You can see how this panel looks in the following
    screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 14.2: Column Configuration'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_14.02_B17073.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 14.2: Column Configuration'
  prefs: []
  type: TYPE_NORMAL
- en: As you can see in the previous screenshot, in this panel there are two distinct
    areas. In the left region, you will find the class attributes, and you can drag
    and drop each attribute to the corresponding CSV columns, which are disposed of
    in the right region.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the left region, you can also see the **Operators** section. These operators
    can be used to change the way the data is processed. Let''s describe how each
    of these operators works:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Operator Base64**: This operator performs a Base64 encode or decode on the
    CSV data.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Operator Ignore**: This operator just lets the importer skip the corresponding
    CSV column.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Operator Iterator**: This operator lets you import the same CSV cell to multiple
    class attributes, by dragging and dropping these attributes as operator children.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Operator Locale Switcher**: This operator is useful to select the language
    for each localized field, allowing the import of text in different languages within
    the same CSV file.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Operator ObjectBrick Setter**: This operator lets you import a specific attribute
    of an **ObjectBrick**.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Operator PHP Code**: This operator type does not do anything on its own.
    It requires you to develop a PHP class to manage the CSV data, and pass the class
    namespace as a parameter of the operator. You will learn how to create a custom
    PHP operator in the *Creating a Custom Operator* section of this chapter.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Operator Published**: This operator just lets you publish or unpublish the
    imported objects, based on the CSV column value.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Operator Splitter**: This operator can be used to split the value of the
    CSV column into multiple attributes, given the separator character.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now that we have defined how to map each object attribute, in the next section
    we will show the criteria that permits us to resolve each row, to recognize whether
    each object already exists.
  prefs: []
  type: TYPE_NORMAL
- en: Resolver Settings
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In the following screenshot, you can see how the **Resolver Settings** panel
    looks:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 14.3: Resolver Settings'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_14.03_B17073.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 14.3: Resolver Settings'
  prefs: []
  type: TYPE_NORMAL
- en: 'As you can see in the previous screenshot, there is a set of properties to
    configure, which we are going to describe here:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Skip head row**: Defines whether the first row must be skipped. This must
    be checked if the first row of the CSV contains column headers.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Language**: The language of the import. All the values for localized fields
    will be imported for the specified language. If you need to import localized values
    for different languages within the same CSV import, you must use a **Locale Switcher**
    operator.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Pimcore\DataObject\Import\Resolver\AbstractResolver` class and passes the
    class namespace as an attribute.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Column**: This property lets you select the CSV column that contains the
    value that must be used by the resolver strategy.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Type**: This property lets you define whether the imported rows must be objects
    or variants. It''s possible to force this type, to let the importer keep the current
    type, or to dynamically set the type for each row, specifying the **Type column**
    property.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Create on demand**: If checked, not existing objects will be created.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Create parents**: If checked, subfolders on the object path will be created
    if they don''t exist.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Skip row if exists**: If checked, the row is skipped if the object already
    exists.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now that we have seen how to set up the resolver strategy, in the next section
    we will see how to change the CSV settings.
  prefs: []
  type: TYPE_NORMAL
- en: CSV Settings
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Here, you can see how the **CSV Settings** panel looks:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 14.4: CSV Settings'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_14.04_B17073.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 14.4: CSV Settings'
  prefs: []
  type: TYPE_NORMAL
- en: As you can see in the previous screenshot, in this panel you can change the
    CSV parsing settings, which include **Delimiter**, **Quote Character**, and so
    on. These settings are automatically detected during the file upload, but you
    can change them manually. After having changed these values, you must click on
    the **Reload column configuration** button to apply the changes.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we will see how to save and share the defined configuration.
  prefs: []
  type: TYPE_NORMAL
- en: Save & Share
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In the following screenshot, you can see what the **Save & Share** panel looks
    like:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 14.5: Save & Share'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_14.05_B17073.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 14.5: Save & Share'
  prefs: []
  type: TYPE_NORMAL
- en: As you can see in the previous screenshot, you can set the configuration name,
    and click on the **Save** button to save the configuration in the database. All
    the saved configurations can be restored by clicking the **Load** button and selecting
    the chosen configuration. The import configurations can be shared globally to
    all users, or to a restricted set of users and roles.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once the configuration is done, you can run the import by clicking the **Import**
    button. In the following screenshot, you can see the **Import Report** panel:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 14.6: Import Report'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_14.06_B17073.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 14.6: Import Report'
  prefs: []
  type: TYPE_NORMAL
- en: As you can see in the previous screenshot, for each row we can see whether the
    row was imported successfully and, if not, the error message for the row. For
    each imported row, the imported object can be opened.
  prefs: []
  type: TYPE_NORMAL
- en: To summarize, in this section you learned how to configure and run CSV imports.
    In the following section, you will learn how to export data in Pimcore.
  prefs: []
  type: TYPE_NORMAL
- en: Exporting Data
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous section, you learned how to configure and run CSV imports. In
    this section, you will learn how to export data. Similar to what we saw in the
    previous section on data importing, we can set up and save export configurations.
  prefs: []
  type: TYPE_NORMAL
- en: The first step to start a data export is to open an object grid by clicking
    on an object folder. When the grid is opened, the grid will contain only the class
    attributes that were marked as **Visible in Grid View** in the class configuration,
    as you learned in [*Chapter 5*](B17073_05_ePub_RK.xhtml#_idTextAnchor093), *Exploring
    Objects and Classes*.
  prefs: []
  type: TYPE_NORMAL
- en: 'To add or remove the fields that are shown in the grid, you must click on the
    **Grid Options** button to open the configuration modal. You can see how this
    configuration modal looks in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 14.7: Grid Options Configuration'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_14.07_B17073.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 14.7: Grid Options Configuration'
  prefs: []
  type: TYPE_NORMAL
- en: As you can see in the previous screenshot, the configuration modal structure
    is quite similar to the one that we saw in the column configuration panel of the
    import configuration.
  prefs: []
  type: TYPE_NORMAL
- en: In the left region, you can find the list of the class attributes and some sets
    of operators to format, render, and transform object data and to extract values
    from object relations. We can drag and drop class attributes and the operators
    in the right region so that these attributes will be shown in the grid.
  prefs: []
  type: TYPE_NORMAL
- en: In the previous screenshot, you may note that we used **Operator Any Getter**
    to extract a specific property from a relation. To do this, we just need to drag
    and drop the relation attribute as a child of the operator and specify the property
    that we want to extract for that relation.
  prefs: []
  type: TYPE_NORMAL
- en: Once the grid configuration is completed, you can click on the **Apply** button
    to confirm the changes, and you can also save the configuration to reuse it in
    the future by clicking the **Save Copy & Share** button.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following screenshot, you can see how the object grid looks after the
    changes:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 14.8: Object Grid'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_14.08_B17073.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 14.8: Object Grid'
  prefs: []
  type: TYPE_NORMAL
- en: As you can see in the previous screenshot, in the object grid the previously
    defined columns are shown. In the screenshot, you can also see that, if we open
    the **Grid Options** submenu, we can switch from different configurations, save
    a copy of the current configuration, set that configuration as favorite, or delete
    the current configuration.
  prefs: []
  type: TYPE_NORMAL
- en: 'The object grid shows all the objects and variants created inside the opened
    folder and, eventually, in existing subfolders. If you want to limit the objects
    shown to the first level of the hierarchy, you can enable the **just direct children**
    checkbox, as you can see in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 14.9: Object Grid'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_14.09_B17073.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 14.9: Object Grid'
  prefs: []
  type: TYPE_NORMAL
- en: As you can see in the previous screenshot, only direct children objects are
    shown. The objects in the grid can be exported both in CSV and in XLSX files.
    For CSV exports, you will be asked to choose the delimiter character.
  prefs: []
  type: TYPE_NORMAL
- en: To summarize, in this section you learned how to configure object grids, and
    how to perform data export. In the following section, you will discover which
    limitations you may encounter using standard import and export functionalities,
    and how to create custom operators for importing.
  prefs: []
  type: TYPE_NORMAL
- en: Limitations of Standard Functionalities
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous sections, you learned how to perform data importing and exporting
    through standard functionalities. As you learned, these functionalities are easy
    to configure and work well for simple scenarios.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, you will learn what the main limitations of these standard
    functionalities are, and you will learn how to implement a custom PHP operator
    to be used in CSV importing. Let's start by presenting the limitations of the
    previously seen export functionality.
  prefs: []
  type: TYPE_NORMAL
- en: Limitations of Data Export
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In the *Exporting data* section, you learned how to configure object grids
    to export object data. When using these configurations, you may encounter the
    following limitations:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Fieldcollections` attributes. The `Fieldcollections` can present a different
    cardinality for each object class, and it''s very difficult to represent these
    kinds of attributes in a flat structure such as a CSV or an XLSX file.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Parent-child relation** **redundancy**: Another limitation given by the file
    format is the fact that the parent-child relations cannot be explained without
    avoiding data redundancy because each object variant will be placed in a different
    row, and in the exported file there will not be any information about the fact
    that a row represents an object or a variant.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Excluding variants**: In the previous section, in terms of data filtering,
    you learned that you can use the **just direct children** checkbox to filter objects
    only and exclude object variants. This works only in the case that all the objects
    are directly created inside the opened folder, because if objects are created
    in subfolders, they will be skipped by clicking the checkbox. The only way to
    filter just for objects is to add a direct SQL condition, as you can see in the
    following screenshot:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![Figure 14.10: Direct SQL query'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_14.10_B17073.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 14.10: Direct SQL query'
  prefs: []
  type: TYPE_NORMAL
- en: As you can see in the previous screenshot, clicking on the **Direct SQL query**
    icon will open a textual input in which you can write a valid SQL condition. This
    is quite useful, but it requires knowing the database structure.
  prefs: []
  type: TYPE_NORMAL
- en: '**Server timeout**: Last but not least, there could be a problem related to
    timings. The export operation is done through an HTML call to a controller, so
    for thousands of objects to export, this operation may require a lot of time,
    and there could be a timeout depending on the server settings.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now that you have learned about the limitations of the standard data export,
    let's see which limitations you may encounter on data import.
  prefs: []
  type: TYPE_NORMAL
- en: Limitations of Data Import
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The main problem with importing CSV files is the standard required format for
    the different types of attributes. For example, for the following kinds of fields,
    we have the following limitations:'
  prefs: []
  type: TYPE_NORMAL
- en: '**QuantityValue**: To import the value for this kind of field, you have to
    put the numeric value in the CSV cell, followed by the unit of measure.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Select**: The CSV cell must contain a valid value for the selection and not
    the option label. This can be a problem in cases in which the created select has
    numeric IDs or, in general, not mnemonic values.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Multiselect**: Different values on multiselect fields must be only separated
    by the comma character.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`object:/` prefix, followed by the full path of the related object.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Advanced Relation**: Metadata for advanced relations cannot be imported.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Fieldcollection**: Values for Fieldcollection cannot be imported.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Media**: Images and videos cannot be attached to objects through a CSV import.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These limitations make the compilation of CSV files quite complex because it's
    difficult for non-expert users to create a CSV file that respects all the format
    rules. These limitations can be circumvented by creating custom PHP operators,
    as we will see in the following section, but of course, we will lose the advantage
    of importing data without the need to write any lines of code.
  prefs: []
  type: TYPE_NORMAL
- en: Another limitation related to CSV files is the format itself. Although the CSV
    format is a widespread standard, there could be dated external applications that
    cannot produce exports in the CSV format. That said, to import any other kind
    of file, a custom solution must be developed.
  prefs: []
  type: TYPE_NORMAL
- en: As for what concerns the importation process itself, the whole process cannot
    be run as a background process. Once the import is started, the import modal cannot
    be closed until the end of the import process because closing the modal will cause
    the import to be stopped. For each imported line, the frontend interface is refreshed,
    and for thousands of rows to be imported, the entire process can last some hours.
  prefs: []
  type: TYPE_NORMAL
- en: Due to these timings, it is not possible to schedule an automatic importation
    flow between external software and Pimcore because, as said, the import cannot
    be run as a background process and requires maintaining an open browser for a
    lot of hours.
  prefs: []
  type: TYPE_NORMAL
- en: Now that you have learned about the limitations of a standard data import, let's
    see how to create a custom PHP operator to be used on CSV imports. The use of
    these PHP operators can circumvent some of the previously mentioned limitations.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a Custom Operator
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the previous section, you learned which limitations you may encounter in
    the standard data import process. One of these limitations is the strict format
    required for some attribute types. This limitation can be circumvented by creating
    custom operators to manage CSV cell data.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this section, you will learn how to create these custom operators, and how
    to use them within CSV imports. In particular, we will see an example operator
    that will search for the option of a select field by the option label and not
    by its value. In the following code snippet, you can see how this operator can
    be created:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: As you can see in the previous code snippet, the operator must extend the `AbstractOperator`
    class. In the class constructor, we can parse the additional data that is defined
    in the operator configuration, and the implementation of the business logic must
    be done in the `process` function, which will be automatically called by the import
    flow.
  prefs: []
  type: TYPE_NORMAL
- en: In this specific example, we use the `getFieldDefinition` method of the object's
    class to retrieve the field definition. If the field is a select or a multiselect
    attribute, we can use the `getOptions` function to retrieve the select options
    and search the value that corresponds to the given label.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once the operator is created, we must use it on CSV import configurations.
    To do this, just drag and drop the **Operator PHP Code** operator in the CSV column
    to which you want to apply the operator to. In the operator configuration panel,
    you must put the operator namespace, as you can see in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 14.11: Operator PHP Code'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_14.11_B17073.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 14.11: Operator PHP Code'
  prefs: []
  type: TYPE_NORMAL
- en: As you can see in the previous screenshot, in the operator configuration we
    must put the PHP class namespace in the **PHP Class** input. Then, in the **Additional
    Data** text area, we can put some data to pass to the operator. In our example,
    we are passing this additional information as JSON, which will be parsed by the
    operator.
  prefs: []
  type: TYPE_NORMAL
- en: To summarize, in this section you learned about which limitations you may encounter
    on performing standard import and export processes. Then, you learned how to create
    custom PHP operators that can be used on the CSV import processes. In the following
    section, you will learn how to implement custom solutions for importing and exporting.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing Custom Solutions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous section, you learned about the limitations of standard import
    and export functionalities. Then, you learned how to create a custom operator
    to be used on CSV import processes.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, you will learn how to implement custom solutions for importing
    and exporting. In particular, you will learn how to add additional buttons to
    the object and folder editor in the Pimcore backend interface, which will call
    custom controllers on clicking, and how to create commands that could be scheduled
    and run as a background process.
  prefs: []
  type: TYPE_NORMAL
- en: Adding custom buttons
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this section, you will learn how to add custom buttons to the Pimcore backend
    interface, and how to let these buttons call for custom controllers to perform
    imports and exports.
  prefs: []
  type: TYPE_NORMAL
- en: 'To add these buttons, we need to implement the `postOpenObject` function inside
    the `Resources/js/Pimcore/startup.js` file of a previously created Pimcore bundle.
    In the following code snippet, you can see an example of how to create two buttons
    to upload and download files:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: As you can see in the previous code snippet, we first check whether the opened
    object is a folder, to add two different buttons in the folder editor toolbar.
    For each button, the `handler` function is the one that is called when the object
    is clicked.
  prefs: []
  type: TYPE_NORMAL
- en: In the first button, we are using the `pimcore.helpers.download` function to
    let the browser download the file returned in the response. In the second button,
    the use of `pimcore.helpers.uploadDialog` will render an upload modal; the uploaded
    file will be passed to the controller.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s now have a look at how to implement the controller actions that will
    be called by the created buttons. In the following code snippet, you can see an
    example of controller implementation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: As you can see in the previous code snippet, a specific function is created
    for each controller action. The HTTP request object is passed as an input argument
    for each action, and the request attribute values can be accessed by the `get`
    function.
  prefs: []
  type: TYPE_NORMAL
- en: On the `exportObjectsAction` function, we have configured the response to accept
    the download of a JSON file by setting the response header properly. The chosen
    file format is just an example and can be changed to the required one. On the
    `importObjectsAction` function, we read the uploaded file content from the `$_FILES`
    global variable, so that depending on the business logic, we can import the objects.
  prefs: []
  type: TYPE_NORMAL
- en: To summarize, in this section you learned how to add custom buttons to the Pimcore
    backend interface, and how to specifically realize controllers to import and export
    files. In the following section, you will learn how to create a command that can
    be invoked by the Pimcore console and that, eventually, can be scheduled to be
    executed as a background process.
  prefs: []
  type: TYPE_NORMAL
- en: Creating Pimcore Commands
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the previous section, you learned how to create custom controllers to perform
    imports and exports of any kind of file, by creating additional buttons to place
    in the Pimcore backend interface. In this section, you will learn how to create
    commands that can be invoked by the Pimcore console.
  prefs: []
  type: TYPE_NORMAL
- en: 'To create a new command, you just need to create a class that extends the `Pimcore\Console\AbstractCommand`
    class, as you can see in the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: As you can see in the previous code snippet, in the command configuration you
    can specify a name and a description for the command, and a list of optional or
    required arguments and options for the command.
  prefs: []
  type: TYPE_NORMAL
- en: The business logic for the command must be implemented in the `execute` function.
    We can use command native functions such as `dump` and `writeError` to print messages
    in the console.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once the command is developed, it must be declared as a service, as is shown
    in the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'You may note that, in the previous code snippet, the `command` tag reports
    the name of the created command. To invoke the command, you just need to run the
    following instruction:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'When running the command, the filename must be specified as an attribute. You
    can see the command result in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 14.12: Command execution'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_14.12_B17073.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 14.12: Command execution'
  prefs: []
  type: TYPE_NORMAL
- en: As you can see in the previous screenshot, messages and errors are dumped in
    the console.
  prefs: []
  type: TYPE_NORMAL
- en: To summarize, in the first part of this section you learned how to add custom
    buttons to the Pimcore backend interface, and how to let these buttons call for
    controller actions to upload and download files. Then, you learned how to create
    and run Pimcore commands through the Pimcore console.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, you will learn how to configure the new Pimcore Data Importer,
    which will let you import data from different sources and schedule imports in
    the background.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring the Data Importer
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous section, you learned how to implement custom solutions, and
    in particular, how to add custom buttons to the object interface and how to create
    executable commands.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, you will learn how to install and configure the new Pimcore
    Data Importer, which in the PimcoreX version will replace the standard CSV import
    that we described in the *Importing Data* section.
  prefs: []
  type: TYPE_NORMAL
- en: 'The Data Importer plugin is an extension of the Datahub bundle, which we described
    in [*Chapter 13*](B17073_13_ePub_RK.xhtml#_idTextAnchor228), *Implementing Master
    Data Management*. To install Data Importer, you just need to run the following
    script:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: As you can see in the preceding script, the Data Importer can be downloaded
    through Composer and can be enabled like every other Pimcore bundle, with the
    `pimcore:bundle:enable` command.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once you have enabled the bundle, you can open the **Datahub** configuration
    panel by accessing the **Settings** | **Datahub Config** option in the Pimcore
    menu. To create a new import configuration, you just need to click on the **Add
    Configuration** button, as you can see in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 14.13: Add import configuration'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_14.13_B17073.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 14.13: Add import configuration'
  prefs: []
  type: TYPE_NORMAL
- en: As you can see in the previous screenshot, in addition to the GraphQL configuration,
    you can select the **Data Objects Importer** option and fill in the configuration
    name.
  prefs: []
  type: TYPE_NORMAL
- en: 'To configure and run the import, you must follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'In the **General** tab, enable the **Active** checkbox and add an optional
    description, as you can see in the following screenshot:![Figure 14.14: General
    settings'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/Figure_14.14_B17073.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Figure 14.14: General settings'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: As you can see in the previous screenshot, the defined configuration name is
    shown in the settings.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: In the `POST` call to the generated URL.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Once you have defined the data source, you can specify the file format, choosing
    from CSV, JSON, XLSX, and XML, and fill in the specific configurations.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'In the **Import Settings** panel, configure the resolver and the mapping for
    each field in the uploaded file. In the following screenshot, you will see how
    to configure the resolver:![Figure 14.16: Import Resolver'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/Figure_14.16_B17073.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Figure 14.16: Import Resolver'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: As you can see in the previous screenshot, you can define the class involved
    in the import and the loading strategy, choosing from **Path**, **Id**, **Attribute**,
    or **No Loading**. This last option will let the importer always create new objects,
    without looking at these objects' existence. Then, you can choose where created
    and updated objects must be located, by defining an existing folder path, and
    how the published status must be affected.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: In the **Processing Settings** tab, you can define whether the configured import
    can be run multiple times in parallel or whether every importation run must be
    sequential.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'In the **Mappings** tab, define a mapping for each attribute of the uploaded
    file that you want to import. In the following screenshot, you will see how to
    add a new mapping and how to map a simple text field:![Figure 14.17: Import Mappings'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/Figure_14.17_B17073.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Figure 14.17: Import Mappings'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: As you can see in the previous screenshot, you can add a new field mapping by
    clicking on the **Add** button. To map a simple text field, you just need to select
    the correct field from the auto-detected source attributes and select the corresponding
    class field in the **Field Name** picklist.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'For different kinds of fields, you may need to add one or more transformations
    using the **Transformation Pipeline**. You can see an example in the following
    screenshot:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 14.18: Import Mappings'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '](img/Figure_14.18_B17073.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Figure 14.18: Import Mappings'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: As you can see in the previous screenshot, for **QuantityValue** attributes
    we can add a specific transformation. This requires selecting two source attributes,
    one containing the value and one containing the unit of measure.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: These pipelines can be used to import dates and numeric fields, or mode complex
    fields such as, for example, images and other kinds of assets, or the relation
    with other objects.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: In the left panel, you can see that the already defined fields are highlighted.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'In the **Execution** panel, run the import that you have configured. You can
    manually run the import by clicking on the **Start** button, as you can see in
    the following screenshot:![Figure 14.19: Import Execution'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/Figure_14.19_B17073.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Figure 14.19: Import Execution'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: As you can see in the previous screenshot, the import status is shown in the
    progress bar, and you can stop the import at any time.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: If you want to schedule the import to be run in the background, you just need
    to fill in the **Cron Definition** rule.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'To enable the `cron` execution, you just need to schedule the execution command
    as shown in the following script:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: To summarize, in this section you learned how to install and enable the Data
    Importer plugin. Through a step-by-step configuration, you learned how to create
    and execute an import configuration.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you learned how to import and export data using the standard
    Pimcore functionalities, which let you import and export CSV files after having
    defined the respective import and export configurations.
  prefs: []
  type: TYPE_NORMAL
- en: After having described how to properly set up these configurations, you learned
    which limitations you might encounter when performing these standard functionalities,
    and how to implement a custom operator to be used in the CSV import process.
  prefs: []
  type: TYPE_NORMAL
- en: Later in this chapter, you learned how to implement custom solutions for importing
    and exporting. In particular, you learned how to add custom buttons to the Pimcore
    backend interface, which lets you upload and download files, and how to create
    commands that can be invoked by the Pimcore console and, eventually, scheduled
    as background processes.
  prefs: []
  type: TYPE_NORMAL
- en: In the last section, you finally learned how to enable the Data Importer plugin
    to create import configurations from different kinds of sources, which you can
    execute manually or schedule to be executed in the background.
  prefs: []
  type: TYPE_NORMAL
- en: As this is the last chapter, let's try to summarize the whole book's content.
    In the first part of the book, we talked about the Pimcore basics, introducing
    Pimcore and its features, showing how to set up a development environment, how
    to move inside the Pimcore menus and functionalities, and how to administrate
    Pimcore sites.
  prefs: []
  type: TYPE_NORMAL
- en: In the second part, you learned how to implement a blog, step by step, using
    the Pimcore CMS engine, starting by learning how to create custom CMS pages and
    how to render data for the blog, and then how to create reusable components and
    how to finalize the website.
  prefs: []
  type: TYPE_NORMAL
- en: In the last chapters, we described how to use Pimcore for enterprise solutions,
    with a focus on the PIM and MDM Pimcore features and the data integration processes,
    providing concrete examples of how to connect Pimcore to external systems.
  prefs: []
  type: TYPE_NORMAL
- en: Now that you have reached the end of this book, we hope it has been an inspiring
    read, and that this book will be a useful guide for you to develop your projects
    with Pimcore.
  prefs: []
  type: TYPE_NORMAL
