<html><head></head><body>
        <section>

                            <header>
                    <h1 class="header-title">Extending Drupal</h1>
                </header>
            
            <article>
                
<p>This chapter dives into extending Drupal using a custom module:</p>
<ul>
<li>Creating a module</li>
<li>Defining a custom page</li>
<li>Defining permissions</li>
<li>Providing the configuration on installation or update</li>
<li>Creating an event subscriber</li>
<li>Using Features 3.0</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Introduction</h1>
                </header>
            
            <article>
                
<p>A feature of Drupal that makes it desirable is the ability to customize it through modules. Whether custom or contributed, modules extend the functionalities and capabilities of Drupal. Modules can be used to not only extend Drupal, but also to create a way to provide configuration and reusable features.</p>
<p>This chapter will discuss how to create a module and allow Drupal to discover it, allowing it to be installed from the extend page. Permissions, custom pages, and default configurations all come from modules. We will explore how to provide these through a custom module.</p>
<p>In addition to creating a module, we will discuss the Features module that provides a set of tools to generate a module and export its configuration.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Creating a module</h1>
                </header>
            
            <article>
                
<p>The first step to extend Drupal is to create a custom module. Although the task sounds daunting, it can be accomplished in a few simple steps. Modules can provide functionalities and customizations to functionalities provided by other modules, or they can be used as a way to contain the configuration and a site's state.</p>
<p>In this recipe, we will create a module by defining an <kbd>info.yml</kbd> file, a file containing information that Drupal uses to discover extensions, and enabling the module.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<ol>
<li>Create a folder named <kbd>mymodule</kbd> in the <kbd>modules</kbd> folder in the base directory of your Drupal site. This will be your module's directory.</li>
<li>Create a <kbd>mymodule.info.yml</kbd> file in your module's directory. This contains metadata that identifies the module to Drupal.</li>
<li>Add a line to the <kbd>name</kbd> key to provide a name for the module:</li>
</ol>
<pre style="padding-left: 60px">name: My Module! </pre>
<ol start="4">
<li>We will need to provide the <kbd>type</kbd> key to define the type of extension. We provide the <kbd>module</kbd> <span>value:</span></li>
</ol>
<pre style="padding-left: 60px">type: module </pre>
<ol start="5">
<li>The <kbd>description</kbd> key allows you to provide extra information about your module, which will be displayed on the module's list page:</li>
</ol>
<pre style="padding-left: 60px">description: This is an example module from the Drupal 8 Cookbook! </pre>
<ol start="6">
<li>All modules need to define the <kbd>core</kbd> key in order to specify a major release compatibility:</li>
</ol>
<pre style="padding-left: 60px">core: 8.x </pre>
<ol start="7">
<li>Save the <kbd>mymodule.info.yml</kbd> file, which resembles the following code:</li>
</ol>
<pre style="padding-left: 60px">name: My Module! 
type: module 
description: This is an example module from the Drupal 8 Cookbook! 
core: 8.x</pre>
<ol start="8">
<li>Log in to your Drupal site and go to <span class="packt_screen">Extend</span> from the administrative toolbar.</li>
<li>Search for <span class="packt_screen">My Module</span> to filter the list of options.</li>
<li>Check the checkbox and click on <span class="packt_screen">Install</span> to enable your module:</li>
</ol>
<div class="CDPAlignCenter CDPAlign"><img height="222" width="411" class="image-border" src="assets/73af832a-e99e-4bb8-8387-8d7e304599ad.png"/></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How it works...</h1>
                </header>
            
            <article>
                
<p>Drupal utilizes <kbd>info.yml</kbd> files to define extensions. Drupal has a discovery system that locates these files and parses them to discover modules. The <kbd>info_parser</kbd> service, provided by the <kbd>\Drupal\Core\Extension\InfoParser</kbd> class, reads the <kbd>info.yml</kbd> file. The parser guarantees that the required type, core, and name keys are present.</p>
<p>When a module is installed, it is added to the <kbd>core.extension</kbd> configuration object, which contains a list of installed modules and themes. The collection of modules in the <kbd>core.extension</kbd> module array will be installed, and will have PHP namespaces resolved, services loaded, and hooks registered.</p>
<p>When Drupal prepares to execute a hook or register services, it will iterate through the values in the <kbd>module</kbd> key in <kbd>core.extension</kbd>.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">There's more...</h1>
                </header>
            
            <article>
                
<p>There are more details about Drupal modules and the module <kbd>info.yml</kbd> files that we can explore.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Module namespaces</h1>
                </header>
            
            <article>
                
<p>Drupal 8 uses the PSR-4 standard developed by the <strong>PHP Framework Interoperability Group</strong> (<strong>PHP-FIG</strong>). The PSR-4 standard is for package-based PHP namespace autoloading. It defines a standard to understand how to automatically include classes based on a namespace and class name. Drupal modules have their own namespaces under the Drupal root namespace.</p>
<p>Using the module from the recipe, our PHP namespace will be <kbd>Drupal\mymodule</kbd>, which represents the <kbd>modules/mymodule/src</kbd> folder.</p>
<p>With PSR-4, files need to contain only one class, interface, or trait. These files need to have the same filename as the containing class, interface, or trait name. This allows a class loader to resolve a namespace as a directory path and know the class's filename. The file can then be automatically loaded when it is used in a file.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Module discovery locations</h1>
                </header>
            
            <article>
                
<p>Drupal supports multiple module discovery locations. Modules can be placed in the following directories and discovered:</p>
<ul>
<li><kbd>/profiles/CURRENT PROFILE/modules</kbd></li>
<li><kbd>/sites/all/modules</kbd></li>
<li><kbd>/modules</kbd></li>
<li><kbd>/sites/default/modules</kbd></li>
<li><kbd>/sites/example.com/modules</kbd></li>
</ul>
<p>The <kbd>\Drupal\Core\Extension\ExtensionDiscovery</kbd> class handles the discovery of extensions by type. It will iteratively scan each location and discover modules that are available. The discovery order is important. If the same module is placed in <kbd>/modules</kbd>, but also in the <kbd>sites/default/modules</kbd> directory, the latter will take precedence.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Defining a package group</h1>
                </header>
            
            <article>
                
<p>Modules can define a <kbd>package</kbd> key to group modules on the module list page:</p>
<div class="CDPAlignCenter CDPAlign"><img class="image-border" src="assets/e4875d0a-cfa5-407d-bb88-dd04ab8e099f.png"/></div>
<p>Projects that include multiple submodules, such as Drupal Commerce, specify packages to normalize the modules' list form. Contributed modules for the Drupal Commerce project utilize a package name, <kbd>Commerce (contrib)</kbd>, to group them on the module list page.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Module dependencies</h1>
                </header>
            
            <article>
                
<p>Modules can define dependencies to ensure that those modules are enabled before your module can be enabled.</p>
<p>Here is the <kbd>info.yml</kbd> for the <kbd>Responsive Image</kbd> module:</p>
<pre>name: Responsive Image 
type: module 
description: 'Provides an image formatter and breakpoint mappings to output responsive images using the HTML5 picture tag.' 
package: Core 
version: VERSION 
core: 8.x 
<strong>dependencies: 
  - breakpoint 
  - image</strong> </pre>
<p>The <kbd>dependencies</kbd> key specifies that the <kbd>breakpoint</kbd> and <kbd>image</kbd> modules need to be enabled first before the <kbd>Responsive Image</kbd> module can be enabled. When enabling a module that requires dependencies that are disabled, the installation form will provide a prompt asking you whether you would like to install the dependencies as well. If a dependency module is missing, the module cannot be installed. The dependency will show a status of (<span class="packt_screen">missing</span>).</p>
<p>A module that is a dependency of another module will state the information in its description, along with the other module's status. For example, the Breakpoint module will show that the Re module requires it as a dependency and is disabled:</p>
<div class="CDPAlignCenter CDPAlign"><img class="image-border" src="assets/bf6cea81-0985-484f-b6e3-19c4081dff92.png"/></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Specifying the module's version</h1>
                </header>
            
            <article>
                
<p>There is a <kbd>version</kbd> key that defines the current module's version. Projects on Drupal.org do not specify this directly, as the Drupal.org extension packager adds it when a release is created. However, this key can be important for private modules to track the release information.</p>
<p>Versions are expected to be single strings, such as <kbd>1.0-alpha1</kbd> and <kbd>2.0.1</kbd>. You can also pass <kbd>VERSION</kbd>, which will resolve to the current version of Drupal core.</p>
<div class="packt_infobox">Drupal.org does not currently support semantic versioning for contributed projects. There is a, now postponed, policy discussion in the issue queue, which can be found at <a href="https://www.drupal.org/node/1612910"><span class="URLPACKT">https://www.drupal.org/node/1612910</span></a>.</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">See also...</h1>
                </header>
            
            <article>
                
<ul>
<li>Refer to the PSR-4: Autoloader specification at <a href="http://www.php-fig.org/psr/psr-4/"><span class="URLPACKT">http://www.php-fig.org/psr/psr-4/</span></a></li>
<li>Refer to the Drupal.org documentation for creating a module at <a href="https://www.drupal.org/docs/8/creating-custom-modules">https://www.drupal.org/docs/8/creating-custom-modules</a></li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Defining a custom page</h1>
                </header>
            
            <article>
                
<p>In Drupal, there are routes that represent URL paths that Drupal interprets to return content. Modules can define routes and methods that return data to be rendered and then displayed to the end user.</p>
<p>In this recipe, we will define a controller that provides an output and a route. The route provides a URL path that Drupal will associate with our controller to display the output.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Getting ready</h1>
                </header>
            
            <article>
                
<p>Create a new module like the one in the first recipe. We will refer to the module as <kbd>mymodule</kbd> throughout the recipe. Use your module's name as appropriate.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<ol>
<li>Firstly, we'll set up the controller. Create a <kbd>src</kbd> folder in your module's base directory and another folder named <kbd>Controller</kbd> inside it.</li>
</ol>
<p>Â </p>
<ol start="2">
<li>Create <kbd>MyPageController.php</kbd> that will hold the route's controller class:</li>
</ol>
<div class="CDPAlignCenter CDPAlign"><img height="254" width="660" class="image-border" src="assets/edd1de71-62ec-4560-b27b-d0da427fb87b.png"/></div>
<ol start="3">
<li>The PSR-4 standard states that filenames match the class names they hold, so we will create a <kbd>MyPageController</kbd> class:</li>
</ol>
<pre style="padding-left: 60px">&lt;?php 
 
namespace Drupal\mymodule\Controller; 
 
use Drupal\Core\Controller\ControllerBase; 
 
/** 
 * Returns responses for My Module module. 
 */ 
class MyPageController extends ControllerBase { 
 
} </pre>
<p style="padding-left: 60px">This creates the <kbd>MyPageController</kbd> class, which extends the <kbd>\Drupal\Core\Controller\ControllerBase</kbd> class. This base class provides a handful of utilities for interacting with the container.</p>
<p style="padding-left: 60px">The <kbd>Drupal\mymodule\Controller</kbd> namespace allows Drupal to automatically load the file from <kbd>/modules/mymodule/src/Controller</kbd>.</p>
<ol start="4">
<li>Next, we will create a method that returns a string of text in our class. Add the following method to our <kbd>MyPageController</kbd> class:</li>
</ol>
<pre style="padding-left: 60px">/** 
 * Returns markup for our custom page. 
 */ 
public function customPage() { 
  return [ 
    '#markup' =&gt; t('Welcome to my custom page!'), 
  ]; 
} </pre>
<p style="padding-left: 60px">The <kbd>customPage</kbd> method returns a render array that the Drupal theming layer can parse. The <kbd>#markup</kbd> key denotes a value that does not have any additional rendering or theming processes.</p>
<ol start="5">
<li>Create a <kbd>mymodule.routing.yml</kbd> file in the base directory of your module so that a route can be added to this controller and method.</li>
<li>The first step is to define the route's internal name for the route to be referenced by:</li>
</ol>
<pre style="padding-left: 60px">mymodule.mypage: </pre>
<ol start="7">
<li>Give the route a path (<kbd>mypage</kbd>):</li>
</ol>
<pre style="padding-left: 60px">mymodule.mypage: 
  path: '/mypage' </pre>
<ol start="8">
<li>The <kbd>defaults</kbd> key allows us to provide the controller with a fully qualified class name, the method to use, and the page's title:</li>
</ol>
<pre style="padding-left: 60px">mymodule.mypage: 
  path: '/mypage' 
  defaults: 
    _controller: '\Drupal\mymodule\Controller\MyPageController::customPage' 
    _title: 'My custom page' </pre>
<p style="padding-left: 60px">You need to provide the initial <kbd>\</kbd> when providing the fully qualified class name.</p>
<div class="packt_tip">Remember that Drupal uses PSR-4 autoloading. Drupal is able to determine that a class with the namespace of <kbd>\Drupal\mymodule\Controller</kbd> is in the <kbd>/path/to/drupal/modules/mymodule/src/Controller</kbd> directory.</div>
<ol start="9">
<li>Lastly, define a <kbd>requirements</kbd> key to set the access callback:</li>
</ol>
<pre style="padding-left: 60px">mymodule.mypage: 
  path: '/mypage' 
  defaults: 
  _controller: '\Drupal\mymodule\Controller\MyPageController::customPage' 
  _title: 'My custom page' 
requirements: 
  _permission: 'access content' </pre>
<ol start="10">
<li>Go to <span class="packt_screen">Configuration</span>, and then <span class="packt_screen">Performance</span> in the <span class="packt_screen">DEVEOLOPMENT</span> section, and click on <span class="packt_screen">Clear all caches</span> button to rebuild Drupal's routes.</li>
<li>Go to <kbd>/mypage</kbd> on your Drupal site and view your custom page:</li>
</ol>
<div class="CDPAlignCenter CDPAlign"><img height="310" width="578" class="image-border" src="assets/45c6dbe2-0715-48ca-8506-9db1f1b5cf0c.png"/></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How it works...</h1>
                </header>
            
            <article>
                
<p>Drupal uses routes, which define a path, that returns content. Each route has a method in a controller class that generates the content, in the form of a render array, to be delivered to the user. When a request comes to Drupal, the system tries to match the path to known routes. If the route is found, the route's definition is used to deliver the page. If the route cannot be found, the 404 page is displayed.</p>
<p>The HTTP kernel takes the request and loads the route. It will invoke the defined controller method or procedural function. The result of the invoked method or function is then handed to the presentation layer of Drupal to be rendered into the content that can be delivered to the user.</p>
<p>Drupal 8 builds on top of the Symfony HTTP kernel to provide the underlying functionality of its route system. It has added the ability to provide access requirements, cast placeholders into loaded objects, and provide partial page responses.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">There's more...</h1>
                </header>
            
            <article>
                
<p>Routes have extra capabilities that can be configured; we will explore those in the next section.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Parameters in routes</h1>
                </header>
            
            <article>
                
<p>Routes can accept dynamic arguments that can be passed to the route controller's method. Placeholder elements can be defined in the route using curly brackets in the URL that denote dynamic values.</p>
<p>The following example code shows what a route might look like:</p>
<pre style="padding-left: 30px">mymodule.cats: 
  path: '/cat/{name}' 
  defaults: 
    _controller: '\Drupal\mymodule\Controller\MyPageController::cats' 
  requirements: 
    _permission: 'access content' </pre>
<p>This route specifies the <kbd>/cat/{name}</kbd> path. The <kbd>{name}</kbd> placeholder will accept dynamic values and pass them to the controller's method:</p>
<pre>class MyPageController { 
  // ... 
  public function cats($name) { 
    return [ 
      '#markup' =&gt; t('My cats name is: @name', [ 
         '@name' =&gt; $name, 
      ]), 
    ]; 
  } 
} </pre>
<p>This method accepts the <kbd>name</kbd> variable from the route and substitutes it into the render array to display it as a text.</p>
<p>Drupal's routing system provides a method of upcasting a variable into a loaded object. In Drupal, upcasting is the process of taking a route parameter and converting it into a richer piece of data. This includes taking an entity ID and providing the loaded entity to the system. There are a set of parameter converter classes under the <kbd>\Drupal\Core\ParamConverter</kbd> namespace. The <kbd>EntityConverter</kbd> class will read options defined in the route and replace a placeholder value with a loaded entity object.</p>
<p>If we have an entity type called <strong>cat</strong>, we can turn the <kbd>name</kbd> placeholder into a method that will be provided with the loaded <kbd>cat</kbd> object in our controller's method:</p>
<pre>mymodule.cats: 
  path: '/cat/{name}' 
  defaults: 
    _controller: '\Drupal\mymodule\Controller\MyPageController::cats' 
  requirements: 
    _permission: 'access content' 
  options: 
    parameters: 
      name: 
         type: entity:cat </pre>
<div class="packt_infobox">This is not required for entities as the defined entity route handler can automatically generate this. Entities are covered in <a href="2f5fe169-0ba6-4746-9586-896f00f0bb28.xhtml"><em><span class="ChapterrefPACKT">Chapter 10</span></em></a>, <em>The Entity API</em>.</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Validating parameters in routes</h1>
                </header>
            
            <article>
                
<p>Drupal provides regular expression validation against route parameters. If the parameter fails the regular expression validation, a 404 page will be returned. Using an example route, we can add the validation to ensure that only alphabetical characters are used in the route parameter:</p>
<pre>mymodule.cats: 
  path: '/cat/{name}' 
  defaults: 
    _controller: '\Drupal\mymodule\Controller\MyPageController::cats' 
  requirements: 
    _permission: 'access content' 
    name: '[a-zA-z]+' </pre>
<p>Under the <kbd>requirements</kbd> key, you can add a new value that matches the name of the placeholder. You can then set it to have the value of the regular expression you would like to use. This would prevent <kbd>c@ts</kbd> or <kbd>cat!</kbd> from being valid parameters.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Route requirements</h1>
                </header>
            
            <article>
                
<p>Routes can define different access requirements through the <kbd>requirements</kbd> key. Multiple validators can be added. However, there must be one that provides a true result, or else the route will return <span class="packt_screen">403, access denied</span>. This is true if the route defines no requirement validators.</p>
<p>Route requirement validators are defined by implementing <kbd>\Drupal\Core\Routing\Access\AccessInterface</kbd>. Here are some of the common requirement validators defined throughout Drupal core:</p>
<ul>
<li><kbd>_access: TRUE</kbd>: Always grants access to the route</li>
<li><kbd>_entity_access</kbd>: Validates that the current user has the ability to perform<br/>
<kbd>entity_type.operation</kbd>, such as <kbd>node.view</kbd></li>
<li><kbd>_permission</kbd>: Checks whether the current user has the provided permission</li>
<li><kbd>_user_is_logged_in</kbd>: Validates that the current user is logged in, which is defined with a Boolean value in the <kbd>routing.yml</kbd> file</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Providing dynamic routes</h1>
                </header>
            
            <article>
                
<p>The routing system allows modules to define routes programmatically. This can be accomplished by providing a <kbd>routing_callbacks</kbd> key that defines a class and method that will return an array of the <kbd>\Symfony\Component\Routing\Route</kbd> objects.</p>
<div class="packt_infobox">If you are working with entities, refer to <a href="2f5fe169-0ba6-4746-9586-896f00f0bb28.xhtml"><em><span class="ChapterrefPACKT">Chapter 10</span></em></a>, <em>The Entity API</em> to learn about overriding the default route handler to create dynamic routes.</div>
<p>In the module's <kbd>routing.yml</kbd>, you will define the routing callbacks key and related class:</p>
<pre>route_callbacks: 
  - '\Drupal\mymodule\Routing\CustomRoutes::routes' </pre>
<p>The <kbd>\Drupal\mymodule\Routing\CustomRoutes</kbd> class will then have a method named routes, which returns an array of Symfony route objects:</p>
<pre>&lt;?php 
 
namespace Drupal\mymodule\Routing; 
use Symfony\Component\Routing\Route; 
 
class CustomRoutes { 
  public function routes() { 
    $routes = []; 
      
    // Create mypage route programmatically 
    $routes['mymodule.mypage'] = new Route( 
        // Path definition 
       'mypage', 
        // Route defaults 
       [ 
          '_controller' =&gt; '\Drupal\mymodule\Controller\MyPageController::customPage', 
          '_title' =&gt; 'My custom page', 
        ], 
        // Route requirements 
       [ 
          '_permission' =&gt; 'access content', 
        ] 
    ); 
    return $routes; 
  } 
} </pre>
<p>If a module provides a class that interacts with routes, the best practice is to place it in the routing portion of the module's namespace. This helps you identify its purpose.</p>
<p>The invoked method is expected to return an array of initiated route objects. The route class takes the following arguments:</p>
<ul>
<li><kbd>Path</kbd>: This represents the route</li>
<li><kbd>Defaults</kbd>: This is an array of default values</li>
<li><kbd>Requirements</kbd>: This is an array of required validators</li>
<li><kbd>Options</kbd>: This is an array that can be passed and used optionally</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Altering existing routes</h1>
                </header>
            
            <article>
                
<p>When Drupal's route system is rebuilt because of a module being enabled or caches being rebuilt, an event is fired that allows modules to alter routes defined statically in YAML or dynamically. This involves implementing an event subscriber by extending <kbd>\Drupal\Core\Routing\RouteSubscribeBase</kbd>, which subscribes the <kbd>RoutingEvents::ALTER</kbd> event.</p>
<p>Create a <kbd>src/Routing/RouteSubscriber.php</kbd> file in your module. It will hold the route subscriber class:</p>
<pre>&lt;?php 
 
namespace Drupal\mymodule\Routing; 
 
use Drupal\Core\Routing\RouteSubscriberBase; 
use Symfony\Component\Routing\RouteCollection; 
 
class RouteSubscriber extends RouteSubscriberBase { 
 
  /** 
   * {@inheritdoc} 
   */ 
  public function alterRoutes(RouteCollection $collection) { 
    // Change path of mymodule.mypage to use a hyphen 
    if ($route = $collection-&gt;get('mymodule.mypage')) { 
      $route-&gt;setPath('/my-page'); 
    } 
  } 
 
} </pre>
<p>The preceding code extends <kbd>RouteSubscribeBase</kbd> and implements the <kbd>alterRoutes()</kbd> method. We make an attempt to load the <kbd>mymodule.mypage</kbd> route, and, if it exists, we change its path to <kbd>my-page</kbd>. Since objects are always passed by reference, we do not need to return a value.</p>
<p>For Drupal to recognize the subscriber, we will need to describe it in the module's <kbd>services.yml</kbd> file. In the base directory of your module, create a <kbd>mymodule.services.yml</kbd> file and add the following code:</p>
<pre>services: 
  mymodule.route_subscriber: 
    class: Drupal\mymodule\Routing\RouteSubscriber 
    tags: 
      - { name: event_subscriber } </pre>
<p>This registers our route subscriber class as a service to the container so that Drupal can execute it when the event is fired.</p>
<div class="packt_infobox">The <em>Creating an event subscriber</em> recipe later in this chapter will cover more about event dispatching and subscribing.</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">See also</h1>
                </header>
            
            <article>
                
<ul>
<li>Refer to the Symfony routing documentation at <a href="http://symfony.com/doc/current/book/routing.html"><span class="URLPACKT">http://symfony.com/doc/current/book/routing.html</span></a></li>
<li><span class="ChapterrefPACKT">Refer to <a href="2f5fe169-0ba6-4746-9586-896f00f0bb28.xhtml"><em>Chapter 10</em></a></span>, <em>The Entity API</em></li>
<li>Refer to the access checking on routes community documentation at <a href="https://www.drupal.org/node/2122195"><span class="URLPACKT">https://www.drupal.org/node/2122195</span></a></li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Defining permissions</h1>
                </header>
            
            <article>
                
<p>In Drupal, there are roles and permissions used to define robust access control lists for users. Modules use permissions to check whether the current user has access to perform an action, view specific items, or do other operations. Modules then define the permissions that are used so that Drupal is aware of them. Developers can then construct roles, which are made up of enabled permissions.</p>
<p>In this recipe, we will define a new permission to view custom pages defined in a module. The permission will be added to a custom route and will restrict access to the route path to users who have a role containing the permission.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Getting ready</h1>
                </header>
            
            <article>
                
<p>Create a new module like the one in the first recipe. We will refer to the module as <kbd>mymodule</kbd> throughout the recipe. Use your module's name in the following recipe as appropriate.</p>
<p>This recipe also modifies a route defined in the module. We will refer to this route as <kbd>mymodule.mypage</kbd>. Modify the appropriate path in your module's <kbd>routing.yml</kbd> file.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<ol>
<li>Permissions are stored in a <kbd>permissions.yml</kbd> file. Add a <kbd>mymodule.permissions.yml</kbd> to the base directory of your module.</li>
<li>First, we will need to define the internal string used to identify this permission, such as <kbd>view mymodule pages</kbd>:</li>
</ol>
<pre style="padding-left: 60px">view mymodule pages: </pre>
<ol start="3">
<li>Each permission is a YAML array of data. We will need to provide a <kbd>title</kbd> key that will be displayed on the permissions page:</li>
</ol>
<pre style="padding-left: 60px">view mymodule pages: 
  title: 'View my module pages' </pre>
<ol start="4">
<li>Permissions have a <kbd>description</kbd> key to provide details of the permission on the permissions page:</li>
</ol>
<pre style="padding-left: 60px">view mymodule pages: 
  title: 'View my module pages' 
  description: 'Allows users to view pages provided by My Module' </pre>
<ol start="5">
<li>Save your <kbd>permissions.yml</kbd> and edit the module's <kbd>routing.yml</kbd> to use the permission for controlling access to a route.</li>
<li>Modify the route's <kbd>requirements</kbd> key to have a <kbd>_permission</kbd> key that is equal to the defined permission:</li>
</ol>
<pre style="padding-left: 60px">mymodule.mypage: 
  path: '/mypage' 
  defaults: 
  _controller: '\Drupal\mymodule\Controller\MyPageController::customPage' 
  _title: 'My custom page' 
requirements: 
  _permission: 'view mymodule pages' </pre>
<ol start="7">
<li>Go to <span class="packt_screen">Configuration</span> and then to <span class="packt_screen">Performance</span> in the <span class="packt_screen">DEVELOPMENT</span> section and click on <span class="packt_screen">Clear all caches</span> to rebuild Drupal's routes.</li>
<li>Go to <span class="packt_screen">People</span> and then to <span class="packt_screen">Permissions</span> to add your permission as the authenticated user and anonymous user roles for <span class="packt_screen">My module!</span>:</li>
</ol>
<div class="CDPAlignCenter CDPAlign"><img class="image-border" src="assets/a99e3644-f78c-4d2f-915a-3380c0cbacc1.png"/></div>
<ol start="9">
<li>Log out of your Drupal site and view the <kbd>/mypage</kbd> page. You will see the content, and will not receive an access denied page.</li>
</ol>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How it works...</h1>
                </header>
            
            <article>
                
<p>Permissions and roles are provided by the <kbd>User</kbd> module. The <kbd>user.permissions</kbd> service discovers the <kbd>permissions.yml</kbd> provided by installed modules. By default, the service is defined through the <kbd>\Drupal\user\PermissionHandler</kbd> class.</p>
<p>Drupal does not save a list of all permissions that are available. The permissions for a system are loaded when the permissions page is loaded. Roles contain an array of permissions.</p>
<p>When checking a user's access for a permission, Drupal checks all the user's roles to see whether they support that permission.</p>
<div class="packt_infobox">You can pass an undefined permission to a user access check and not receive an error. The access check will simply fail unless the user is UID 1, which bypasses access checks.</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">There's more...</h1>
                </header>
            
            <article>
                
<p>We will cover more ways to work with permissions in your modules in the upcoming sections.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Restrict access flag for permissions</h1>
                </header>
            
            <article>
                
<p>Permissions can be flagged as having a security risk if enabled; this is the <kbd>restrict access</kbd> flag. When this flag is set to <kbd>restrict access: TRUE</kbd>, it will add a warning to the permission description.</p>
<p class="mce-root">This allows module developers to provide more context to the amount of control a permission may give a user:</p>
<div class="CDPAlignCenter CDPAlign"><img class="image-border" src="assets/c8951919-0813-4509-95f6-524ca634b1b9.png"/></div>
<p class="mce-root">The permission definition from our recipe would look like the following:</p>
<pre><br/>view mymodule pages: <br/> title: 'View my module pages' <br/> description: 'Allows users to view pages provided by My Module' <br/> restrict access: TRUE</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Defining permissions programmatically</h1>
                </header>
            
            <article>
                
<p>Permissions can be defined by a module programmatically or statically in a <kbd>YAML</kbd> file. A module needs to provide a <kbd>permission_callbacks</kbd> key in its <kbd>permissions.yml</kbd> that contains either an array of classes and their methods or a procedural function name.</p>
<p>For example, the Filter module provides granular permissions based on the different text filters created in Drupal:</p>
<pre>permission_callbacks: 
- Drupal\filter\FilterPermissions::permissions </pre>
<p>This tells the <kbd>user_permissions</kbd> service to execute the permissions method of the<br/>
<kbd>\Drupal\Filter\FilterPermissions</kbd> class. The method is expected to return an array that matches the same structure as that of the <kbd>permissions.yml</kbd> file.</p>
<p>An example of using generated permissions will be covered in <em>Implementing custom access control for an entity</em> recipe of <a href="2f5fe169-0ba6-4746-9586-896f00f0bb28.xhtml"><em>Chapter 10</em></a>, <em>The Entity API</em>.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Checking whether a user has permissions</h1>
                </header>
            
            <article>
                
<p>The user account interface provides a method for checking whether a user entity has a permission. To check whether the current user has a permission, you will get the current user, and you need to invoke the <kbd>hasPermission</kbd> method:</p>
<pre>\Drupal::currentUser()-&gt;hasPermission('my permission'); </pre>
<p>The <kbd>\Drupal::currentUser()</kbd> method returns the current active user object. This allows you to check whether the active user has the necessary permissions to perform certain types of actions.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Providing the configuration on the installation or update</h1>
                </header>
            
            <article>
                
<p>Drupal provides a configuration management system, which is discussed in <a href="b2659986-a8dc-4503-a043-6071ab7b6722.xhtml"><em><span class="ChapterrefPACKT">Chapter 9</span></em></a>, <em>Configuration Management - Deploying in Drupal 8</em>, and modules can provide configuration on an installation or through an update system. Modules provide the configuration through <kbd>YAML</kbd> files when they are first installed. Once the module is enabled, the configuration is then placed in the configuration management system; however updates can be made to the configuration in code through the Drupal update system.</p>
<p>In this recipe, we will provide a configuration YAML that creates a new contact form and then manipulates it through a schema version change in the update system.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Getting ready</h1>
                </header>
            
            <article>
                
<p>Create a new module like the one in the first recipe. We will refer to the module as <kbd>mymodule</kbd> throughout the recipe. Use your module's appropriate name where necessary.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<ol>
<li>Create a <kbd>config</kbd> folder in your module's base directory. Drupal requires its configuration YAML to be in a subfolder of <kbd>config</kbd>.</li>
<li>Create a folder named <kbd>install</kbd> in the <kbd>config</kbd> folder. The configuration YAML in this folder will be imported on module installation.</li>
<li>In the <kbd>install</kbd> folder, create a <kbd>contact.form.contactus.yml</kbd> to store the YAML definition of the contact form, <span class="packt_screen">Contact Us</span>:
<div class="CDPAlignCenter CDPAlign"><img height="150" width="384" class="image-border" src="assets/7ec6fd6a-85a9-4d4e-879a-6683f5a26cd9.png"/></div>
</li>
<li>We will define the configuration of a contact form based on the <kbd>contact.schema.yml</kbd> file provided by the Contact module. Add the following YAML content into the file:</li>
</ol>
<pre style="padding-left: 60px">langcode: en 
status: true 
dependences: {}
id: contactus 
label: 'Contact Us' 
recipients: 
  - webmaster@example.com 
reply: '' 
weight: 0 </pre>
<p style="padding-left: 60px">The configuration entry is based on a schema definition, which we will cover in <a href="b2659986-a8dc-4503-a043-6071ab7b6722.xhtml"><em><span class="ChapterrefPACKT">Chapter 9</span></em></a>, <em>Configuration Management - Deploying in Drupal 8</em>. The <kbd>langcode</kbd>, <kbd>status</kbd>, and <kbd>dependencies</kbd> are the required configuration management keys.</p>
<p style="padding-left: 60px">The <kbd>id</kbd> is the contact form's machine name and the label is the human display name. The <kbd>recipients</kbd> key is a YAML array of valid email addresses. The reply key is a string of text for the <span class="packt_screen">Auto-reply</span> field. Finally, the <kbd>weight</kbd> defines the form's weight in the administrative list.</p>
<ol start="5">
<li>Go to <span class="packt_screen">Extend</span> and enable your module to import the configuration item.</li>
<li>The <span class="packt_screen">Contact Us</span> form will now be located on the <span class="packt_screen">Contact forms</span> overview page, located under <span class="packt_screen">Structure</span>:</li>
</ol>
<div class="CDPAlignCenter CDPAlign"><img height="178" width="581" class="image-border" src="assets/bd7ce3f0-23f9-44b5-a308-7234f5798d9c.png"/></div>
<ol start="7">
<li>Create a <kbd>mymodule.install</kbd> file in the module's base directory. Drupal checks <kbd>.install</kbd> files for update hooks.</li>
<li>We will create a function called <kbd>mymodule_update_8001()</kbd> that will be read by the update system and make our configuration changes:</li>
</ol>
<pre style="padding-left: 60px">&lt;?php 
 
/** 
 * Update "Contact Us" form to have a reply message. 
 */ 
function mymodule_update_8001() { 
  $contact_form = \Drupal\contact\Entity\ContactForm::load('contactus'); 
  $contact_form-&gt;setReply(t('Thank you for contacting us, we will reply shortly')); 
  $contact_form-&gt;save(); 
} </pre>
<p style="padding-left: 60px">This function uses the entity's class to load our configuration entity object. It loads <kbd>contactus</kbd>, which our module has provided, and sets the reply property to a new value.</p>
<ol start="9">
<li>Go to <kbd>/update.php</kbd> in your browser to run the Drupal's database update system. Click on <span class="packt_screen">Apply pending updates</span> to run the update system:</li>
</ol>
<div class="CDPAlignCenter CDPAlign"><img height="299" width="554" class="image-border" src="assets/e0a0ed6a-4e35-4f01-9579-b84f037769c7.png"/></div>
<ol start="10">
<li>Review the <span class="packt_screen">Contact Us</span> form settings and verify that the reply message has been set.</li>
</ol>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How it works...</h1>
                </header>
            
            <article>
                
<p>Drupal's <kbd>moduler_installer</kbd> service, provided through <kbd>\Drupal\Core\Extension\ModuleInstaller</kbd>, ensures that configuration items defined in the module's <kbd>config</kbd> folder are processed on installation. When a module is installed, the <kbd>config.installer</kbd> service, provided through <kbd>\Drupal\Core\Config\ConfigInstaller</kbd>, is called to process the module's default configuration.</p>
<p>In the event, the <kbd>config.installer</kbd> service makes an attempt to import the configuration from the <kbd>install</kbd> folder that already exists, and an exception will be thrown. Modules cannot provide changes made to the existing configuration through static YAML definitions.</p>
<p>Since modules cannot adjust configuration objects through static YAML definitions provided to Drupal, they can utilize the database update system to modify the configuration. Drupal utilizes a schema version for modules. The base schema version for a module is <kbd>8000</kbd>. Modules can provide update hooks in the form of <kbd>hook_update_N</kbd>, where <kbd>N</kbd> represents the next schema version. When Drupal's updates are run, they will execute the proper update hooks and update the module's schema version.</p>
<p>Configuration objects are immutable by default. To edit a configuration, a mutable object needs to be loaded through the configuration factory service.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">There's more...</h1>
                </header>
            
            <article>
                
<p>We will discuss configuration in <a href="b2659986-a8dc-4503-a043-6071ab7b6722.xhtml"><em><span class="ChapterrefPACKT">Chapter 9</span></em></a>, <em>Configuration Management - Deploying in Drupal 8</em>; however, we will now dive into some important notes when working with modules and configurations.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Configuration subdirectories</h1>
                </header>
            
            <article>
                
<p>There are three directories that the configuration management system will inspect in a module's <kbd>config</kbd> folder, which are as follows:</p>
<ul>
<li><kbd>install</kbd></li>
<li><kbd>optional</kbd></li>
<li><kbd>schema</kbd></li>
</ul>
<p>The <kbd>install</kbd> folder specifies the configuration that will be imported. If the configuration object exists, the installation will fail. The <kbd>optional</kbd> folder contains the configuration that will be installed if the following conditions are met:</p>
<ul>
<li>The configuration does not already exist</li>
<li>It is a configuration entity</li>
<li>Its dependencies can be met</li>
</ul>
<p>If any one of the conditions fails, the configuration will not be installed, but it will not halt the module's installation process.</p>
<p>The <kbd>schema</kbd> folder provides configuration object definitions. This uses YAML definitions to structure configuration objects, and is covered in depth in <a href="b2659986-a8dc-4503-a043-6071ab7b6722.xhtml"><em><span class="ChapterrefPACKT">Chapter 9</span></em></a>, <em>Configuration Management - Deploying in Drupal 8</em>.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Modifying the existing configuration on installation</h1>
                </header>
            
            <article>
                
<p>The configuration management system does not allow modules to provide configuration on an installation that already exists. For example, if a module tries to provide <kbd>system.site</kbd> and defines the site's name, it would fail to install. This is because the system module provides this configuration object when you first install Drupal.</p>
<p>Drupal provides <kbd>hook_install()</kbd> that modules can implement in their <kbd>.install</kbd> file. This hook is executed during the module's installation process. The following code will update the site's title to <em>Drupal 8 Cookbook</em>! on the module's installation:</p>
<pre>/** 
 * Implements hook_install(). 
 */ 
function mymodule_install() { 
  // Set the site name. 
  \Drupal::configFactory() 
    -&gt;getEditable('system.site') 
    -&gt;set('name', 'Drupal 8 Cookbook!') 
    -&gt;save(); 
} </pre>
<p>Configurable objects are immutable by default when loaded by the default <kbd>config</kbd> service. To modify a configuration object, you will need to use the configuration factory to receive a mutable object. The mutable object can have <kbd>set</kbd> and <kbd>save</kbd> methods that are executed to update the configuration in a configuration object.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">See also</h1>
                </header>
            
            <article>
                
<ul>
<li><span class="ChapterrefPACKT">Refer to <a href="b2659986-a8dc-4503-a043-6071ab7b6722.xhtml"><em>Chapter 9</em></a></span>, <em>Configuration Management - Deploying in Drupal 8</em></li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Creating an event subscriber</h1>
                </header>
            
            <article>
                
<p>New to Drupal 8 is the event dispatcher system. One of the many benefits of Drupal is the ability to react to specific processes and alter or react to them. Unlike the hook system that exists in Drupal 8, and has for many versions of Drupal, the event dispatch system uses explicit registration to an event.</p>
<p>The events dispatcher system comes from the Symfony framework and allows components to easily interact with one another. Within Drupal, and integrated Symfony components, events are dispatched, and event subscribers can listen to the events and react to changes or other processes.</p>
<p>In this recipe, we will subscribe to the <kbd>REQUEST</kbd> event, which fires when a request is first handled. If the user is not logged in, we will navigate them to the login page.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<ol>
<li>Create <kbd>src/EventSubscriber/RequestSubscriber.php</kbd> in your module.</li>
<li>Define the <kbd>RequestSubscriber</kbd> class, which implements the <kbd>EventSubscriberInterface</kbd> interface:</li>
</ol>
<pre style="padding-left: 60px">&lt;?php<br/><br/> namespace Drupal\mymodule\EventSubscriber;<br/><br/> use Symfony\Component\EventDispatcher\EventSubscriberInterface;<br/><br/> class RequestSubscriber implements EventSubscriberInterface {<br/><br/> } 
 </pre>
<ol start="3">
<li>To satisfy the interface requirements, we must add a <kbd>getSubscribedEvents</kbd> method. This tells the system which events we are subscribing to and the method that needs to be invoked:</li>
</ol>
<pre style="padding-left: 60px">&lt;?php<br/><br/> namespace Drupal\mymodule\EventSubscriber;<br/><br/> use Symfony\Component\EventDispatcher\EventSubscriberInterface;<br/> use Symfony\Component\HttpKernel\KernelEvents;<br/><br/> class RequestSubscriber implements EventSubscriberInterface {<br/><br/>   /**<br/>    * {@inheritdoc}<br/>    */<br/>   public static function getSubscribedEvents() {<br/>     return [<br/>       KernelEvents::REQUEST =&gt; ['doAnonymousRedirect', 28],<br/>     ];<br/>   }<br/><br/> } </pre>
<p style="padding-left: 60px">The <kbd>KernelEvents</kbd> class provides constants for available events. Our <span>returned</span> array specifies the method to invoke and its priority for that event.</p>
<div class="packt_infobox">Priorities will be discussed in the <em>How it works</em>... section. It is provided in the example to resolve possible conflicts when the <kbd>dynamic_page_cache</kbd> module is enabled.</div>
<ol start="4">
<li>Create the <kbd>doAnonymousRedirect</kbd> method we specified, which will receive a <kbd>GetResponseEvent</kbd> argument:</li>
</ol>
<pre style="padding-left: 60px">&lt;?php<br/><br/> namespace Drupal\mymodule\EventSubscriber;<br/><br/> use Drupal\Core\Url;<br/> use Symfony\Component\EventDispatcher\EventSubscriberInterface;<br/> use Symfony\Component\HttpFoundation\RedirectResponse;<br/> use Symfony\Component\HttpKernel\Event\GetResponseEvent;<br/> use Symfony\Component\HttpKernel\KernelEvents;<br/><br/> class RequestSubscriber implements EventSubscriberInterface {<br/><br/>   /**<br/>    * Redirects all anonymous users to the login page.<br/>    *<br/>    * @param \Symfony\Component\HttpKernel\Event\GetResponseEvent $event<br/>    *   The event.<br/>    */<br/>   public function doAnonymousRedirect(GetResponseEvent $event) {<br/>     // Make sure we are not on the user login route.<br/>     if (\Drupal::routeMatch()-&gt;getRouteName() == 'user.login') {<br/>       return;<br/>     }<br/><br/>     // Check if the current user is logged in.<br/>     if (\Drupal::currentUser()-&gt;isAnonymous()) {<br/>       // If they are not logged in, create a redirect response.<br/>       $url = Url::fromRoute('user.login')-&gt;toString();<br/>       $redirect = new RedirectResponse($url);<br/><br/>       // Set the redirect response on the event, cancelling default response.<br/>       $event-&gt;setResponse($redirect);<br/>     }<br/>   }<br/><br/>   /**<br/>    * {@inheritdoc}<br/>    */<br/>   public static function getSubscribedEvents() {<br/>     return [<br/>       KernelEvents::REQUEST =&gt; ['doAnonymousRedirect', 28],<br/>     ];<br/>   }<br/><br/> } </pre>
<p style="padding-left: 60px">To prevent a redirect loop, we will use the <kbd>RouteMatch</kbd> service to get the current route object and verify that we are not already on the <kbd>user.login</kbd> route page.</p>
<p style="padding-left: 60px">Then we check whether the user is anonymous and, if the user is anonymous, set the event's response to a redirect response.</p>
<ol start="5">
<li>Now that we have created our class, create a <kbd>mymodule.services.yml</kbd> file in your module's directory.</li>
<li>We must register our class with the service container so that Drupal understands that it will act as an event subscriber.</li>
</ol>
<pre style="padding-left: 60px">services:<br/>   mymodule.request_subscriber:<br/>     class: Drupal\mymodule\EventSubscriber\RequestSubscriber<br/>     tags:<br/>       - { name: event_subscriber } </pre>
<p style="padding-left: 60px">The <kbd>event_subscriber</kbd> tag tells the container to invoke the <kbd>getSubscribedEvents</kbd> method and register its methods.</p>
<ol start="7">
<li>Install the module or rebuild Drupal's caches if it has been already installed.</li>
<li>Navigate to any page as an anonymous user--you will be redirected to the login form.</li>
</ol>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How it works...</h1>
                </header>
            
            <article>
                
<p>Throughout Drupal and Symfony components, and even other third-party PHP libraries, events can be passed to the event dispatcher. The <kbd>event_dispatcher</kbd> service in Drupal is an optimized version of the one provided by Symfony, but is completely interoperable.</p>
<p>When the container is built, all services tagged as <kbd>event_subscribers</kbd> are gathered. They are then registered into the <kbd>event_dispatcher</kbd> service, keyed by the events returned in the <kbd>getSubscribedEvents</kbd> method.</p>
<p>When the <kbd>event_dispatcher</kbd> service is told to dispatch an event, it invokes the proper methods on all subscribed services. With <kbd>KernelEvents::REQUEST</kbd>, <kbd>KernelEvents::EXCEPTION</kbd> and <kbd>KernelEvents::VIEW</kbd>, you have the opportunity to provide a response before the controller is invoked. Then there are events, such as <kbd>ConfigEvents::SAVE</kbd> and <kbd>ConfigEvents::DELETE</kbd>, that are dispatched and allow you to react to a configuration being saved or deleted but are not actually able to adjust the configuration entity directly through the event object.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">There's more...</h1>
                </header>
            
            <article>
                
<p>Event subscribers require knowledge of creating services, registering them, and even dependency injection. We'll discuss this some more in the next section.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Using dependency injection</h1>
                </header>
            
            <article>
                
<p>With Drupal 8 and the implementation of a service container comes the concept of dependency injection. Dependency injection is a software design concept, and at its base level, it provides a means to use a class without having to directly reference it. In our example, we retrieve services multiple times using the global static class <kbd>\Drupal</kbd>. This is bad practice within services, and can make testing more difficult.</p>
<p>To implement dependency injection, first, we will add a constructor to our class that accepts the services used (<kbd>current_route_match</kbd> and <kbd>current_user</kbd>) and matches protected properties to store them:</p>
<pre>/**<br/>  * The route match.<br/>  *<br/>  * @var \Drupal\Core\Routing\RouteMatchInterface<br/>  */<br/> protected $routeMatch;<br/><br/> /**<br/>  * Account proxy.<br/>  *<br/>  * @var \Drupal\Core\Session\AccountProxyInterface<br/>  */<br/> protected $accountProxy;<br/><br/> /**<br/>  * Creates a new RequestSubscriber object.<br/>  *<br/>  * @param \Drupal\Core\Routing\RouteMatchInterface $route_match<br/>  *   The route match.<br/>  * @param \Drupal\Core\Session\AccountProxyInterface $account_proxy<br/>  *   The current user.<br/>  */<br/> public function __construct(RouteMatchInterface $route_match, AccountProxyInterface $account_proxy) {<br/>   $this-&gt;routeMatch = $route_match;<br/>   $this-&gt;accountProxy = $account_proxy;<br/> } </pre>
<p>We can then replace any calls to <kbd>\Drupal::</kbd> with <kbd>$this-&gt;</kbd>:</p>
<pre>/**<br/>  * Redirects all anonymous users to the login page.<br/>  *<br/>  * @param \Symfony\Component\HttpKernel\Event\GetResponseEvent $event<br/>  *   The event.<br/>  */<br/> public function doAnonymousRedirect(GetResponseEvent $event) {<br/>   // Make sure we are not on the user login route.<br/>   if ($this-&gt;routeMatch-&gt;getRouteName() == 'user.login') {<br/>     return;<br/>   }<br/><br/>   // Check if the current user is logged in.<br/>   if ($this-&gt;accountProxy-&gt;isAnonymous()) {<br/>     // If they are not logged in, create a redirect response.<br/>     $url = Url::fromRoute('user.login')-&gt;toString();<br/>     $redirect = new RedirectResponse($url);<br/><br/>     // Set the redirect response on the event, cancelling default response.<br/>     $event-&gt;setResponse($redirect);<br/>   }<br/> } 
 </pre>
<p>Finally, we will update <kbd>mymodule.services.yml</kbd> to specify our constructor arguments so that they will be injected when the container runs our event subscriber:</p>
<pre>services:<br/>   mymodule.request_subscriber:<br/>     class: Drupal\mymodule\EventSubscriber\RequestSubscriber<br/>     arguments: ['@current_route_match', '@current_user']<br/>     tags:<br/>       - { name: event_subscriber } 
 </pre>
<p>Dependency injection feels and seems magical at first. However, with use and practice, it will begin to make more sense and become second nature when developing with Drupal 8.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">See also</h1>
                </header>
            
            <article>
                
<ul>
<li>Refer to the Drupal.org API documentation for events and a list of available events at <a href="https://api.drupal.org/api/drupal/core%21core.api.php/group/events/8.3.x"><span class="URLPACKT">https://api.drupal.org/api/drupal/core%21core.api.php/group/events/8.3.x</span></a></li>
<li><span>Refer to the</span> Drupal.org API documentation on services and dependency injection at <a href="https://api.drupal.org/api/drupal/core%21core.api.php/group/container/8.3.x"><span class="URLPACKT">https://api.drupal.org/api/drupal/core%21core.api.php/group/container/8.3.x</span></a></li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Using Features 3.0</h1>
                </header>
            
            <article>
                
<p>Many Drupal users create custom modules to provide specific sets of features that they can reuse across multiple sites. In fact, there is a module for the sole purpose of providing a means to export configuration and create modules that provide features. This is how the Features module received its name, in fact.</p>
<p>The Features module has two submodules. The main Features module provides all the functionalities. The Features UI module provides a user interface to create and manage features.</p>
<p>We will use Features to export a module with a configuration that contains the default page and article content types provided by the standard installation so that they can be used on other installation profiles.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<ol>
<li>First, we will install the Features module using Composer, which will also download its dependency, the <strong>Configuration Update Manager</strong> module:</li>
</ol>
<pre style="padding-left: 60px">$ cd /path/to/drupal8<br/>$ composer require drupal/features</pre>
<ol start="2">
<li>Go to <span class="packt_screen">Extend</span> and install the <span class="packt_screen">Features UI</span> module, confirming the requirements to install <span class="packt_screen">Features and Configuration Update Manager</span> as well.</li>
<li>Go to <span class="packt_screen">Configuration</span>, and in the <span class="packt_screen">DEVELOPMENT</span> section, you will find the link to access the Features user interface; click on <span class="packt_screen">Features</span>:
<div class="CDPAlignCenter CDPAlign"><img height="278" width="435" class="image-border" src="assets/e1b494ea-73af-44e3-a591-076d3681bf4d.png"/></div>
</li>
<li>Click on <span class="packt_screen">Create new feature</span> to start making a custom Feature module.</li>
</ol>
<p>Â </p>
<ol start="5">
<li>Provide a <kbd>Name</kbd> for the feature, such as <span class="packt_screen">Content Authoring</span>.</li>
<li>Optionally, you can provide a description. This acts as the <kbd>description</kbd> key in the module's <kbd>info.yml</kbd>.</li>
<li>Toggle the <span class="packt_screen">Content types</span> grouping and check the <span class="packt_screen">Article</span> and <span class="packt_screen">Basic Page</span> checkboxes to mark them for export.</li>
<li>The Features module will automatically add detected dependencies or important configuration items to also be exported, such as fields and view modes:
<div class="CDPAlignCenter CDPAlign"><img height="404" width="441" class="image-border" src="assets/74b49b41-5338-4baa-91ea-4c9047d445ac.png"/></div>
</li>
<li>Click on <span class="packt_screen">Write</span> to write the module to export the module and configuration to the <kbd>/modules/custom</kbd> directory in your Drupal site.</li>
<li>Go to <span class="packt_screen">Extend</span>, search for the <span class="packt_screen">Content Authoring</span> module, and install your newly created module.</li>
</ol>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How it works...</h1>
                </header>
            
            <article>
                
<p>Features exports static YAML configuration files into the module's <kbd>config/install</kbd> folder. Features modifies the standard configuration management workflow by ensuring that a specific kind of configuration exists. Configuration management does not allow modules to overwrite existing configuration objects, but Features manages and allows this to happen.</p>
<p>To accomplish this, Features provides <kbd>\Drupal\features\FeaturesConfigInstaller</kbd>, which extends the default <kbd>config.install</kbd> service class. It then alters the services definition to use its <kbd>FeaturesConfigInstaller</kbd> class instead of the default <kbd>\Drupal\Core\Config\ConfigInstaller</kbd> class.</p>
<p>Beyond adjusting the <kbd>config.install</kbd> service, Features harnesses all the functionalities of the configuration management system to provide a simpler way to generate modules.</p>
<div class="packt_infobox">Any module can be considered a Feature's module by adding the <kbd>features: true</kbd> key to its <kbd>info.yml</kbd>. This will allow it to be managed through the Features UI.</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">There's more...</h1>
                </header>
            
            <article>
                
<p>Features is a robust tool to easily provide bundled configuration; we will discuss more ways to use the Features module in the next section.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Suggested feature modules</h1>
                </header>
            
            <article>
                
<p>The Features module provides an intelligent bundling method that reviews the current Drupal site's configuration and suggests feature modules that should be created to preserve the configuration. These are provided through package assignment plugins.</p>
<p>These plugins use logic to assign configurations to specific packages:</p>
<div class="CDPAlignCenter CDPAlign"><img class="image-border" src="assets/896394f8-b6f6-4ffd-bccc-3fcc6dcee182.png"/></div>
<p>When you visit the Features UI, it will present you with suggested feature modules to be exported. Expanding the items will list the configuration items that will be bundled. Clicking on the suggested feature's link opens the creation form. Alternatively, the checkbox can be used in conjunction with the <span class="packt_screen">Download archive</span> or <span class="packt_screen">Write</span> button at the bottom of the form.</p>
<div class="packt_infobox">The unpackaged section shows a configuration that has not met any of the packaging rules to group the configuration into a specified module. This will need to be manually added to a created feature module.</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Features bundles</h1>
                </header>
            
            <article>
                
<p>In the Features module, there are bundles, and bundles have their own assignment method configurations. The purpose of bundles inside Features is to provide an automatic assignment of configuration that can be grouped into exported modules:</p>
<div class="CDPAlignCenter CDPAlign"><img height="407" width="613" class="image-border" src="assets/c3db51c3-3e21-4c38-8d16-5d5090e8bb5b.png"/></div>
<p>A bundle has a human display name and machine name. The bundle's machine name will be prefixed on all feature modules generated under this bundle. You also can specify the bundle to act as an installation profile. The features UI was heavily used in Drupal 7 to construct distributions and spawn the concept of the bundle functionality.</p>
<p>Assignment methods can be rearranged and configured to your liking.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Managing the configuration state of Features</h1>
                </header>
            
            <article>
                
<p>The Features UI provides a means to review changes to the feature's configuration that may have been made. If a configuration item controlled by a feature module has been modified, it will show up under the differences section of the Features UI. This will allow you to import or update the Feature module with the change.</p>
<p>The <span class="packt_screen">Import</span> option will force the site to use the configuration defined in the module's configuration <kbd>YAML</kbd> files. For example, in the following screenshot we have an exported content type whose description was modified in the user interface after being exported:</p>
<div class="CDPAlignCenter CDPAlign"><img class="image-border" src="assets/f1130b56-93d9-4f5b-9207-9c8ab5b62361.png"/></div>
<p>The difference created by the feature module is highlighted. If the difference was checked, and if you click on <span class="packt_screen">Import changes</span>, the content type's description would be reset to that defined in the configuration.</p>
<p>From the main features overview table, the feature module can be re-exported to include the change and update the exported YAML files.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">See also</h1>
                </header>
            
            <article>
                
<ul>
<li>Refer to the Drupal.org handbook for the Features module at <a href="https://www.drupal.org/docs/8/modules/features"><span class="URLPACKT">https://www.drupal.org/docs/8/modules/featuresï»¿</span></a></li>
</ul>
<p class="mce-root"/>
<p class="mce-root"/>


            </article>

            
        </section>
    </body></html>