<html><head></head><body><div class="chapter" title="Chapter&#xA0;9.&#xA0;The History API &#x2013; Not Forgetting Where We Are"><div class="titlepage"><div><div><h1 class="title"><a id="ch09"/>Chapter 9. The History API – Not Forgetting Where We Are</h1></div></div></div><p>In the previous chapter, we introduced Ajax, a collection of web techniques to update parts of the screen in web applications without having to create a link to a physically different page, have the browser request that new page from the server, and load it. Modern websites use this technique all over the place, as do their developers; Ajax is a common practice, a commodity almost.</p><p>The concept is, however, difficult to grasp by both the marketing people you have to work with and the visitors of your site. Doesn't it often occur that your marketing person asks you to add a page to the website and then wants to know what the URL is? It is <span class="strong"><strong>index.php</strong></span>, honey, it always<a id="id640" class="indexterm"/> is. Visitors of your site who navigate through the menus will, when they hit the browser's back button, expect to look at the screen they just left. Instead they will be taken back to the website they were visiting before coming to yours, unless you use the techniques we are going to teach you in this chapter.</p><p>We will first describe the problem we are trying to solve; next, we will explain what the solution is in HTML5, as well as in HTML4 country.</p><div class="section" title="The problem we are trying to solve"><div class="titlepage"><div><div><h1 class="title"><a id="ch09lvl1sec67"/>The problem we are trying to solve</h1></div></div></div><p>Imagine a horizontal navigation menu where the visitor clicks on a menu item, just like the example we used in the <a id="id641" class="indexterm"/>previous chapter. In a classical website, the browser takes the visitor to a different page, for example, <code class="literal">galleries.php</code>, with its URL displayed by the browser. However, an Ajax-based site will simply update a part of the screen and not do anything with the URL bar each time the visitor clicks a menu item. No matter how many items they choose, once they push the browser's <span class="emphasis"><em>BACK</em></span> button, they will find themselves back at the previous page, which will be the previous true page, and typically, a different website, and this is not where he expects to be.</p><p>We will solve this problem by using a technique that will restore the website to its previous state, as we cannot take it to the previous page. Before we go through the details, let's discuss a<a id="id642" class="indexterm"/> thing or two about<a id="id643" class="indexterm"/> <span class="strong"><strong>pushing</strong></span> and <span class="strong"><strong>popping</strong></span> <a id="id644" class="indexterm"/>states.</p></div></div>
<div class="section" title="The self-service restaurant"><div class="titlepage"><div><div><h1 class="title"><a id="ch09lvl1sec68"/>The self-service restaurant</h1></div></div></div><p>The best way to describe the technologies we are about to learn is to compare them with what you can find in any self-service restaurant. In such restaurants, you start by picking up a tray, and when you are done eating, you put the tray back. Now imagine a slightly different scenario. You are going to clean the tray before you put it back so that you can put it back on top of the<a id="id645" class="indexterm"/> same stack where you took it. The other difference you have to imagine is that, instead of having a multitude of trays that are all equally boring because they all look identical, every tray will have a different picture on it.</p><p>So, all these trays are part of a single stack. When you approach the stack, you can only see the picture that is on the top tray. If you add a tray to the stack, that picture will disappear as it is replaced by the one from the tray we place on top. We call that action <span class="strong"><strong>push</strong></span>. Some <a id="id646" class="indexterm"/>old fashioned stacks have built-in springs, so you really have to push the tray down until it stays in place.</p><p>When you take a tray from the stack, the opposite will occur. The picture of the second tray becomes visible and the entire stack of trays pops up a little bit. That is why we call this action <span class="strong"><strong>pop</strong></span> or <span class="strong"><strong>pop up</strong></span>. Without<a id="id647" class="indexterm"/> self-service restaurants, there may have been no computer<a id="id648" class="indexterm"/> science, as this inspired many computer scientists in the field of formal grammar to create the theories of pop-up and push-down automata. I wrote my, obligatory to graduate, university paper on such a topic (no, we did not have a self-service restaurant there).</p></div>
<div class="section" title="HTML5 History API and the history object"><div class="titlepage"><div><div><h1 class="title"><a id="ch09lvl1sec69"/>HTML5 History API and the history object</h1></div></div></div><p>Browsers use a similar stack called the <code class="literal">history</code> stack. In JavaScript, you can access it through the <code class="literal">history</code> object, for which there are several methods available. The history object is part of the window <a id="id649" class="indexterm"/>object and is accessed through the <code class="literal">window.history</code> property. It has been around for years.</p><p>Normally, when the user navigates<a id="id650" class="indexterm"/> to a new page, the browser pushes the new URL on to its history stack and downloads and draws the new page. When the user presses the back button, the browser pops one page off its history stack and redraws the previous page.</p><p>But what if we use Ajax calls to update parts of the screen without needing to load a new page? Then, nothing is going to be pushed on to that stack by the browser. Well, that is true, unless we do it ourselves. And the<a id="id651" class="indexterm"/> key to making this possible is the<a id="id652" class="indexterm"/> <code class="literal">popstate</code> event and the <code class="literal">history.pushState()</code> function.</p><div class="section" title="pushState()"><div class="titlepage"><div><div><h2 class="title"><a id="ch09lvl2sec113"/>pushState()</h2></div></div></div><p>Each time we create code to update part of the screen, as we did in the examples in the previous chapter, we should use the <code class="literal">pushState()</code> function<a id="id653" class="indexterm"/> to put some relevant information on to the history stack and, if we want to, change the URL string that is displayed by the browser. <code class="literal">pushState()</code> takes three arguments:</p><div class="informalexample"><pre class="programlisting">history.pushState(data, title, url);</pre></div><p>The first argument should be<a id="id654" class="indexterm"/> some structured data, such as an array of key/value pairs that we make as meaningful as possible. The data should contain enough information to allow us to restore the page in the shape it was when we issued the <code class="literal">pushState()</code>.</p><p>The second argument is intended to be a title of sorts to show up in the dropdown list of the browser's history. At the time of writing, there was not a single browser that implemented this.</p><p>The third argument, finally, is used to pass a string that is going to be our substitute URL for this state of the page. It is displayed by the browser, so once again, the visitor will believe he has landed on a different page. That URL string has a second purpose, which we will see at the end of this chapter. So, a possible <code class="literal">pushState()</code> statement related to some of the examples could be:</p><div class="informalexample"><pre class="programlisting">url ="?anchor=agenda&amp;key=" + nav;
updateAgendaContent(nav);  // this updates part of the screen
history.pushState({key:nav, anchor:"agenda"}, "", url);</pre></div><p>So, the plate we just pushed on top of our stack in the browser self-service restaurant will have a picture of a key on it, labeled with the value of the variable <code class="literal">nav</code>, and a picture of an anchor, labeled <code class="literal">agenda</code>. The URL will be the same as before with a query string appended to it that also contains those two key/value pairs.</p><div class="section" title="popstate event"><div class="titlepage"><div><div><h3 class="title"><a id="ch09lvl3sec49"/>popstate event</h3></div></div></div><p>After you've used the<a id="id655" class="indexterm"/> <code class="literal">history.pushState()</code> function to push a fake URL to the browser's <code class="literal">history</code> stack, when the user presses<a id="id656" class="indexterm"/> the back button, the browser will fire a <code class="literal">popstate</code> event on the <code class="literal">window</code> object. This is our chance to create the illusion that there are actually different pages and that we are moving our visitor back to what they believe is the previous one.</p><p>For this purpose, we create<a id="id657" class="indexterm"/> an event handler to execute some code each time a <code class="literal">popstate</code> event occurs. Most of the code we already have, because we used a function to draw a portion of the screen. We can simply reuse that.</p><div class="informalexample"><pre class="programlisting">window.addEventListener('popstate', function(event) {
if (event.state){
switch (event.state.anchor) {

case "agenda":
  updateAgendaContent(event.state.key);
 break;
..
}

}
else
{
restoreHomePage();
}
});</pre></div><p>So, in the preceding code, we act on each <code class="literal">popstate</code> event by looking at our stack. If it is not empty but has a picture of an anchor labeled <code class="literal">agenda</code>, we look for the value of <code class="literal">key</code> and call the function <code class="literal">updateAgendaContent()</code>, with <code class="literal">key</code> as argument, to restore the part of the screen we always update to its previous state. Of course, this time we are not going to call <code class="literal">pushState()</code>. If we were, subsequent pushing of the back key would have no visible effect.</p><p>There is also the special case where we have run out of trays when the stack is empty. Then, we will need code that we <a id="id658" class="indexterm"/>may have not written yet. In the example, I used a placeholder function named <code class="literal">restoreHomePage()</code>. What should that function do? It should replace the variable portion of our screen with the initial content it had when our page was first loaded.</p></div><div class="section" title="popstate and different browsers"><div class="titlepage"><div><div><h3 class="title"><a id="ch09lvl3sec50"/>popstate and different browsers</h3></div></div></div><p>At the time of writing, some browsers behaved differently than others. The current version of Safari will issue a<a id="id659" class="indexterm"/> <code class="literal">popstate</code> event on the initial page load, which can be utterly confusing. This also means that, in Safari, the <code class="literal">restoreHomePage</code> function will be called right after the initial page load. What that will do if your function is written correctly is replace the variable part of the screen with the exact same thing it already contains. Silly, isn't it? This may cause a small delay, and maybe some flickering, if the network is slow.</p></div></div></div>
<div class="section" title="The History plugin"><div class="titlepage"><div><div><h1 class="title"><a id="ch09lvl1sec70"/>The History plugin</h1></div></div></div><p>The <code class="literal">popstate</code> event and <code class="literal">pushState</code> method are part of the so-called<a id="id660" class="indexterm"/> <span class="strong"><strong>History API</strong></span> that was introduced in HTML5. This means that our magic will only work if HTML5 capable browsers are used. That is, of course, not<a id="id661" class="indexterm"/> good enough. There are still a lot of people that visit your site using HTML4 capable browsers, so what do we do?</p><p>Fortunately, several plugins for jQuery exist that allow you to use the same, or a similar, API and have your code work in both types of browsers. One even has a name that will make you think of self-service restaurants again (<span class="emphasis"><em>BBQ</em></span>), but I have been using the so-called <code class="literal">jQuery history</code> plugin. At the<a id="id662" class="indexterm"/> time of writing, the plugin could be found at <a class="ulink" href="https://github.com/browserstate/history.js">https://github.com/browserstate/history.js</a>.</p></div>
<div class="section" title="Bookmarking"><div class="titlepage"><div><div><h1 class="title"><a id="ch09lvl1sec71"/>Bookmarking</h1></div></div></div><p>Let's move back from the self-service restaurant to our marketing person who wants to know which URL they can use to put in a <a id="id663" class="indexterm"/>document as a <code class="literal">link</code> to a page so that people can quickly access information that is found on the site. Perhaps they also want to know what to do if a visitor uses the <code class="literal">bookmark</code> feature of the browser to save the URL of a (in our case, virtual) page to revisit later. We can support this thanks to the URL parts we used in our <code class="literal">pushState</code> code.</p><p>In our examples, we made sure that we stored enough information about our updated page in the state that we pushed on the history stack, and you learned how to restore our page to its previous state using that information. In our <code class="literal">pushState</code> code, we appended a query string to the URL that basically contains the same information. We can retrieve that information using the <code class="literal">location</code> object of the browser and its <code class="literal">href</code> property. Here is the code that will, if the URL with query string is used, cause our single page website to go to the expected state:</p><div class="informalexample"><pre class="programlisting">$(document).ready(function(){
var url = location.href;
  if (url) {
  var urlData = url.QueryStringToJSON();
    if (urlData.anchor) {
      var anchor = urlData.anchor;
      var topic = urlData.key;
      switch (anchor) {
      case "agenda":
       updateAgendaContent(topic);
       history.pushState({key:topic, anchor:anchor}, topic, url);
       break;
      }
     }
  }
});</pre></div><p>Note that we have come a long way already. A few chapters back we would have guessed this to be only possible in a huge chunk of PHP code using GET variables to get to our key/value pairs, but now this is written entirely in JavaScript and Ajax.</p><p>In the previous example, a function<a id="id664" class="indexterm"/> was used called <code class="literal">QueryStringToJSON()</code>. This is not a standard JavaScript function. It is something you can write yourself or, like I did, grab off the Web. It dissects a query string and stores the key/value pairs into a JSON object. Yes, JSON! And what JSON is all about you will learn in the next chapter.</p></div>
<div class="section" title="Summary"><div class="titlepage"><div><div><h1 class="title"><a id="ch09lvl1sec72"/>Summary</h1></div></div></div><p>In this chapter, we addressed one of the main drawbacks of using Ajax. You learned how to use the HTML5 History API to create the expected behavior when a visitor of our site pushes the browser's back key, or drops a URL that they previously bookmarked, into the browser's URL bar. Even though this API is for HTML5 capable browsers, you learned that there are jQuery plugins around to support this magic in HTML4 capable browsers as well.</p><p>In the last few chapters, we started using Ajax more often to update only a portion of the screen, and to remain on the same page rather than loading a new one. As a consequence, we are exchanging smaller, but more frequent chunks of data between client and server. In the examples so far, the format of our data was HTML and it was all generated on the server. In the next chapter, you will learn two new formats for data exchange: <span class="strong"><strong>XML</strong></span> and <span class="strong"><strong>JSON</strong></span>.</p></div></body></html>