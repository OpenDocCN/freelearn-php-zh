<html><head></head><body>
<div class="book" title="Chapter&#xA0;8.&#xA0;Multicasting in RxPHP and PHP7 pthreads Extension" id="1Q5IA1-bd355a22cf10407cb10df27e65585b8d"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch08" class="calibre1"/>Chapter 8. Multicasting in RxPHP and PHP7 pthreads Extension</h1></div></div></div><p class="calibre8">To make use of multiple CPUs and multiple cores, we've been using subprocesses. This is, of course, a very easy and safe method to run code in parallel. In combination with Unix sockets, we can make inter-process communication happen with ease. In the previous chapter, we combined all of this with RxPHP to make applications that were completely separated and run in parallel.</p><p class="calibre8">In this chapter, we'll have a look at a very interesting PHP7 extension called <code class="literal">pthreads</code>, which allows multithreading in PHP using POSIX threads.</p><p class="calibre8">In particular, this chapter will cover the following topics:</p><div class="book"><ul class="itemizedlist"><li class="listitem">A deeper look into the <code class="literal">Subject</code> class and its variants.</li><li class="listitem">Multicasting operators in RxPHP and all its derivatives</li><li class="listitem">Examples of <code class="literal">ConnectableObservable</code> and <code class="literal">MulticastObservable</code></li><li class="listitem">Using a single instance of the Subject with multiple source Observables</li><li class="listitem">Basics of multithreading in PHP</li><li class="listitem">Notes on today's state of the <code class="literal">pthreads</code> extension, its two major versions, and its current practical usage</li><li class="listitem">Writing a couple of multithreaded applications with the <code class="literal">pthreads</code> extension that'll demonstrate how to use the <code class="literal">Thread</code>, <code class="literal">Worker</code>, and <code class="literal">Poll</code> classes</li></ul></div><p class="calibre8">Before we go parallel, we should have a look at yet another feature of Reactive Extensions called multicasting, which involves the <code class="literal">multicast()</code> operator and its derivates. Multicasting is build around Subjects so let's first have a better look at what different types of Subject are available to us.
</p></div>

<div class="book" title="Chapter&#xA0;8.&#xA0;Multicasting in RxPHP and PHP7 pthreads Extension" id="1Q5IA1-bd355a22cf10407cb10df27e65585b8d">
<div class="book" title="Subjects"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_1"><a id="ch08lvl1sec53" class="calibre1"/>Subjects</h1></div></div></div><p class="calibre8">We've been using Subjects in this book since <a class="calibre1" title="Chapter 2. Reactive Programming with RxPHP" href="part0024_split_000.html#MSDG2-bd355a22cf10407cb10df27e65585b8d">Chapter 2</a>, <span class="strong"><em class="calibre18">Reactive Programming with RxPHP</em></span>, but there're multiple different variants of the <code class="literal">Subject</code> class for more specific use cases where all of them are relevant to multicasting.</p></div></div>

<div class="book" title="Chapter&#xA0;8.&#xA0;Multicasting in RxPHP and PHP7 pthreads Extension" id="1Q5IA1-bd355a22cf10407cb10df27e65585b8d">
<div class="book" title="Subjects">
<div class="book" title="BehaviorSubject"><div class="book"><div class="book"><div class="book"><h2 class="title2" id="calibre_pb_2"><a id="ch08lvl2sec69" class="calibre1"/>BehaviorSubject</h2></div></div></div><p class="calibre8">The <code class="literal">BehaviorSubject</code> class extends the default <code class="literal">Subject</code> class and lets us set a default value that is passed to its observer right on subscription. Consider this very simple example of <code class="literal">BehaviorSubject</code>:</p><pre class="programlisting">// behaviorSubject_01.php  
use Rx\Subject\BehaviorSubject; 
 
$subject = new BehaviorSubject(42); 
$subject-&gt;subscribe(new DebugSubject()); 
</pre><p class="calibre8">When <code class="literal">DebugSubject</code> subscribes to the <code class="literal">BehaviorSubject</code> class, the default value <code class="literal">42</code> is emitted immediately. This is a similar functionality to using the <code class="literal">startWith()</code> operator.</p><p class="calibre8">The output is then just a single line:</p><pre class="programlisting">
<span class="strong"><strong class="calibre17">$ php behaviorSubject_01.php</strong></span>
<span class="strong"><strong class="calibre17">15:11:54 [] onNext: 42 (integer)</strong></span>
</pre></div></div></div>

<div class="book" title="Chapter&#xA0;8.&#xA0;Multicasting in RxPHP and PHP7 pthreads Extension" id="1Q5IA1-bd355a22cf10407cb10df27e65585b8d">
<div class="book" title="Subjects">
<div class="book" title="ReplaySubject"><div class="book"><div class="book"><div class="book"><h2 class="title2" id="calibre_pb_3"><a id="ch08lvl2sec70" class="calibre1"/>ReplaySubject</h2></div></div></div><p class="calibre8">The <code class="literal">ReplaySubject</code> class internally contains an array of the last <span class="strong"><em class="calibre18">N</em></span> values it received and automatically re-emits them to every new observer on subscription.</p><p class="calibre8">In the following example, we subscribe to <code class="literal">RangeObservable</code>, which immediately emits all its values to the <code class="literal">ReplaySubject</code> class. The last three values are always stored in an array and when we later subscribe with the <code class="literal">DebugSubject</code> class, it'll immediately receive all three of them:</p><pre class="programlisting">// replaySubject_01.php 
use Rx\Subject\ReplaySubject; 
$subject = new ReplaySubject(3); 
 
Observable::range(1, 8) 
    -&gt;subscribe($subject); 
 
$subject-&gt;subscribe(new DebugSubject()); 
</pre><p class="calibre8">The output consists of the last three values that the <code class="literal">ReplaySubject</code> class received:</p><pre class="programlisting">
<span class="strong"><strong class="calibre17">$ php replaySubject_01.php </strong></span>
<span class="strong"><strong class="calibre17">15:46:30 [] onNext: 6 (integer)</strong></span>
<span class="strong"><strong class="calibre17">15:46:30 [] onNext: 7 (integer)</strong></span>
<span class="strong"><strong class="calibre17">15:46:30 [] onNext: 8 (integer)</strong></span>
<span class="strong"><strong class="calibre17">15:46:30 [] onCompleted</strong></span>
</pre><p class="calibre8">Notice, that we also received the <code class="literal">complete</code> signal, which is correct because it was emitted by <code class="literal">RangeObservable</code>.</p></div></div></div>

<div class="book" title="Chapter&#xA0;8.&#xA0;Multicasting in RxPHP and PHP7 pthreads Extension" id="1Q5IA1-bd355a22cf10407cb10df27e65585b8d">
<div class="book" title="Subjects">
<div class="book" title="AsyncSubject"><div class="book"><div class="book"><div class="book"><h2 class="title2" id="calibre_pb_4"><a id="ch08lvl2sec71" class="calibre1"/>AsyncSubject</h2></div></div></div><p class="calibre8">The last Subject type RxPHP offers out of the box is called <code class="literal">AsyncSubject</code>, which might seem a little confusing. The only thing this Subject does is that it emits only the last value it received before receiving the <code class="literal">complete</code> signal.</p><p class="calibre8">We'll demonstrate this Subject on a similar example to the previous one. We'll just switch the order of actions and we'll subscribe the <code class="literal">DebugSubject</code> class before subscribing to the source Observable to see that it silently suppresses all values except the last one:</p><pre class="programlisting">// asyncSubject_01.php 
use Rx\Subject\AsyncSubject; 
$subject = new AsyncSubject(); 
$subject-&gt;subscribe(new DebugSubject()); 
 
Observable::range(1, 8) 
    -&gt;subscribe($subject); 
</pre><p class="calibre8">The output is only the last value emitted by the source <code class="literal">RangeObservable</code>:</p><pre class="programlisting">
<span class="strong"><strong class="calibre17">$ php asyncSubject_01.php </strong></span>
<span class="strong"><strong class="calibre17">16:00:46 [] onNext: 8 (integer)</strong></span>
<span class="strong"><strong class="calibre17">16:00:46 [] onCompleted</strong></span>
</pre><p class="calibre8">Now we know everything we need to start working with multicasting and the <code class="literal">multicast()</code> operator in particular.</p></div></div></div>

<div class="book" title="Multicasting in RxPHP"><div class="book" id="1R42S2-bd355a22cf10407cb10df27e65585b8d"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch08lvl1sec54" class="calibre1"/>Multicasting in RxPHP</h1></div></div></div><p class="calibre8">In Reactive Extensions, multicasting means sharing a single subscription among multiple observers via an instance of a <code class="literal">Subject</code> class. All multicasting operators are internally based on the general <code class="literal">multicast()</code> operator that implements their most common functionality. Of course, we're not limited to only using the <code class="literal">Subject</code> class and we'll use <code class="literal">ReplaySubject</code> and <code class="literal">BehaviorSubject</code> as well.</p><p class="calibre8">Multicasting is common to all Rx implementations, so knowledge of how it works inside is generally useful.</p></div>

<div class="book" title="Multicasting in RxPHP">
<div class="book" title="The multicast() operator and ConnectableObservable"><div class="book"><div class="book"><div class="book"><h2 class="title2" id="calibre_pb_1"><a id="ch08lvl2sec72" class="calibre1"/>The multicast() operator and ConnectableObservable</h2></div></div></div><p class="calibre8">The <code class="literal">multicast()</code> operator returns <code class="literal">ConnectableObservable</code> or <code class="literal">MulticastObservable</code> based on what arguments we pass. We'll first have a look at how it works with <code class="literal">ConnectableObservable</code>, because this should be very familiar to us.</p><p class="calibre8">A typical use case could look like the following example:</p><pre class="programlisting">// multicast_01.php  
$observable = Rx\Observable::defer(function() { 
        printf("Observable::defer\n"); 
        return Observable::range(1, 3); 
    }) 
    -&gt;multicast(new Subject()); 
 
$observable-&gt;subscribe(new DebugSubject('1')); 
$observable-&gt;subscribe(new DebugSubject('2')); 
$observable-&gt;connect(); 
</pre><p class="calibre8">Instead of instantiating <code class="literal">ConnectableObservable</code>, we used the <code class="literal">multicast()</code> operator to do it for us.</p><p class="calibre8">In this example, we created a single source Observable and subscribed two observers to it. Then, after calling <code class="literal">connect()</code>, the <code class="literal">ConnectableObservable</code> class subscribed to an instance of <code class="literal">AnonymousObservable</code> returned from the <code class="literal">Observable::defer</code> static method.</p><p class="calibre8">As we can see, the <code class="literal">multicast()</code> operator returns an instance of <code class="literal">ConnectableObservable</code>. The result from this example is as follows:</p><pre class="programlisting">
<span class="strong"><strong class="calibre17">$ php multicast_01.php </strong></span>
<span class="strong"><strong class="calibre17">Observable::defer</strong></span>
<span class="strong"><strong class="calibre17">10:43:42 [1] onNext: 1 (integer)</strong></span>
<span class="strong"><strong class="calibre17">10:43:42 [2] onNext: 1 (integer)</strong></span>
<span class="strong"><strong class="calibre17">10:43:42 [1] onNext: 2 (integer)</strong></span>
<span class="strong"><strong class="calibre17">10:43:42 [2] onNext: 2 (integer)</strong></span>
<span class="strong"><strong class="calibre17">18:12:16 [1] onNext: 3 (integer)</strong></span>
<span class="strong"><strong class="calibre17">18:12:16 [2] onNext: 3 (integer)</strong></span>
<span class="strong"><strong class="calibre17">10:43:42 [1] onCompleted</strong></span>
<span class="strong"><strong class="calibre17">10:43:42 [2] onCompleted</strong></span>
</pre><p class="calibre8">All observers subscribe to the same instance of the Subject that we passed. This is an important implication that we need to be aware of.</p><p class="calibre8">In a moment, we'll have a look at a slightly modified version of this example that passes different arguments to <code class="literal">multicast()</code>.</p></div></div>

<div class="book" title="Multicasting in RxPHP">
<div class="book" title="MulticastObservable"><div class="book"><div class="book"><div class="book"><h2 class="title2" id="calibre_pb_2"><a id="ch08lvl2sec73" class="calibre1"/>MulticastObservable</h2></div></div></div><p class="calibre8">Another Observable used for multicasting is called <code class="literal">MulticastObservable</code>. Its usage is similar to <code class="literal">ConnectableObservable</code>, but its internal functionality is very different. Consider the following example:</p><pre class="programlisting">// multicastObservable_01.php 
$source = Rx\Observable::defer(function() { 
    printf("Observable::defer\n"); 
    return Observable::range(1, 3); 
}); 
 
$observable = new MulticastObservable($source, function() { 
    return new Subject(); 
}, function (ConnectableObservable $connectable) { 
    return $connectable-&gt;startWith('start'); 
}); 
 
$observable-&gt;subscribe(new DebugSubject('1')); 
$observable-&gt;subscribe(new DebugSubject('2')); 
</pre><p class="calibre8">When subscribing to <code class="literal">MulticastObservable</code>, it internally calls the <code class="literal">multicast()</code> operator on the source Observable (which returns <code class="literal">ConnectableObservable</code>, as we saw in the previous example) and runs the first callable to create an instance of the <code class="literal">Subject</code> class. This is the first major difference to using just <code class="literal">multicast()</code>, where we always shared the same instance of the <code class="literal">Subject</code> class. The <code class="literal">MulticastObservable</code>, in contrast, creates a new <code class="literal">Subject</code> for every subscriber.</p><p class="calibre8">So internally, we have an instance of <code class="literal">ConnectableObservable</code>. Then it calls the second callable with this <code class="literal">ConnectableObservable</code> passed as an argument, which means we can further chain operators to it, or we could even use a completely different Observable (just remember this method has to return an Observable because the operator will internally subscribe to it).</p><p class="calibre8">This callable is often called the <span class="strong"><strong class="calibre17">selector function</strong></span> because it lets us select where we want to subscribe. After that, <code class="literal">MulticastObservable</code> subscribes to the Observable returned and calls the <code class="literal">connect()</code> method on the <code class="literal">ConnectableObservable</code>.</p><p class="calibre8">In our example, we create a new instance of the <code class="literal">Subject</code> class for every subscriber and then chain <code class="literal">startWith()</code> with the <code class="literal">ConnectableObservable</code>, which makes it emit a single value before emitting values from the source.</p><p class="calibre8">The output will look like the following:</p><pre class="programlisting">
<span class="strong"><strong class="calibre17">$ php multicastObservable_01.php </strong></span>
<span class="strong"><strong class="calibre17">12:54:20 [1] onNext: start (string)</strong></span>
<span class="strong"><strong class="calibre17">Observable::defer</strong></span>
<span class="strong"><strong class="calibre17">12:54:20 [1] onNext: 1 (integer)</strong></span>
<span class="strong"><strong class="calibre17">12:54:20 [1] onNext: 2 (integer)</strong></span>
<span class="strong"><strong class="calibre17">12:54:20 [1] onNext: 3 (integer)</strong></span>
<span class="strong"><strong class="calibre17">12:54:20 [1] onCompleted</strong></span>
<span class="strong"><strong class="calibre17">12:54:20 [2] onNext: start (string)</strong></span>
<span class="strong"><strong class="calibre17">Observable::defer</strong></span>
<span class="strong"><strong class="calibre17">12:54:20 [2] onNext: 1 (integer)</strong></span>
<span class="strong"><strong class="calibre17">12:54:20 [2] onNext: 2 (integer)</strong></span>
<span class="strong"><strong class="calibre17">12:54:20 [2] onNext: 3 (integer)</strong></span>
<span class="strong"><strong class="calibre17">12:54:20 [2] onCompleted</strong></span>
</pre><p class="calibre8">Note that the deferred Observable was called twice, which is correct. Each observer has its own instances of the Subject and <code class="literal">ConnectableObservable</code>. We have full control of what Subjects we're using for multicasting instead of leaving it to the default <code class="literal">multicast()</code> behavior.</p><p class="calibre8">The question is, why does it matter whether we're using the same instance of the Subject or not?</p><div class="book" title="Subjects and their internal state"><div class="book"><div class="book"><div class="book"><h3 class="title1"><a id="ch08lvl3sec26" class="calibre1"/>Subjects and their internal state</h3></div></div></div><p class="calibre8">We know how to use Subjects. We also know what the <code class="literal">next</code>, <code class="literal">complete</code>, and <code class="literal">error</code> signals do. So what happens if we use a single <code class="literal">Subject</code> and subscribe to a cold Observable multiple times? Consider the following example:</p><pre class="programlisting">// subject_01.php 
$subject = new Subject(); 
 
$subject-&gt;subscribe(new DebugSubject('1')); 
$subject-&gt;onNext(1); 
$subject-&gt;onNext(2); 
$subject-&gt;onNext(3); 
$subject-&gt;onCompleted(); 
 
$subject-&gt;subscribe(new DebugSubject('2')); 
$subject-&gt;onNext(4); 
$subject-&gt;onCompleted(); 
</pre><p class="calibre8">We'll run this example and talk about what happens inside the <code class="literal">Subject</code> instance. Note that we subscribed to the <code class="literal">Subject</code> twice where the first observer (represented by <code class="literal">DebugSubject</code>) receives the first three values and then emits the <code class="literal">complete</code> signal.</p><p class="calibre8">However, what happens with the second observer?</p><pre class="programlisting">
<span class="strong"><strong class="calibre17">$ php subject_01.php </strong></span>
<span class="strong"><strong class="calibre17">13:15:00 [1] onNext: 1 (integer)</strong></span>
<span class="strong"><strong class="calibre17">13:15:00 [1] onNext: 2 (integer)</strong></span>
<span class="strong"><strong class="calibre17">13:15:00 [1] onNext: 3 (integer)</strong></span>
<span class="strong"><strong class="calibre17">13:15:00 [1] onCompleted</strong></span>
<span class="strong"><strong class="calibre17">13:15:00 [2] onCompleted</strong></span>
</pre><p class="calibre8">The second observer received just the <code class="literal">complete</code> signal, and none of the observers received the value <code class="literal">4</code>.</p><p class="calibre8">It's very important to understand what happens internally inside a <code class="literal">Subject</code> class when it receives a <code class="literal">complete</code> signal (this means it receives a <code class="literal">complete</code> signal or we call the <code class="literal">onCompleted()</code> method manually):</p><div class="book"><ol class="orderedlist"><li class="listitem" value="1">The <code class="literal">Subject</code> class checks whether it's already been marked as stopped. If it has, then the method returns immediately. If it's not stopped, then it marks itself as stopped.</li><li class="listitem" value="2">The complete signals are then sent to all observers.</li><li class="listitem" value="3">The array of observers is emptied.</li></ol><div class="calibre22"/></div><p class="calibre8">So now it should make sense. The first three values were emitted as usual. Then we called <code class="literal">onComplete()</code>, which did exactly what we described in these bullet points. At this point, this <code class="literal">Subject</code> instance has no observers (see step 4). Then we subscribe with another observer, which is added to the array of observers. This observer immediately receives a <code class="literal">complete</code> signal because the Subject is already stopped and didn't end with an error.</p><p class="calibre8">At this point, calling <code class="literal">onNext(4)</code> does nothing because the <code class="literal">Subject</code> instance is already stopped (see step 1).</p><p class="calibre8">This principle might be a problem in situations where we purposely want to defer creating Observables with, for example, the <code class="literal">Observable::defer</code> static method that will be called multiple times. Once it sends the <code class="literal">complete</code> signal, all consecutive values will be ignored by the <code class="literal">Subject</code> instance for the reasons we explained. We'll have another example featuring this issue later in this chapter.</p><p class="calibre8">This is a very important principle we need to be aware of when using <code class="literal">multicast()</code> operators and the <code class="literal">ConnectableObservable</code>.</p><p class="calibre8">Whether this applies to <code class="literal">MulticastObservable</code> is up to us, depending on what we return from its first callable. We can use the same instance of <code class="literal">Subject</code> or we can create a new one depending on what we want to achieve.</p><div class="informaltable" title="Note"><h3 class="title1"><a id="note41" class="calibre1"/>Note</h3><p class="calibre8">If this all looks confusing, just remember that Subjects have an internal state. When they receive <code class="literal">complete</code> or <code class="literal">error</code> notification, they'll never re-emit any value further.</p></div></div></div></div>

<div class="book" title="Multicasting in RxPHP">
<div class="book" title="The multicast() operator and MulticastObservable"><div class="book"><div class="book"><div class="book"><h2 class="title2" id="calibre_pb_3"><a id="ch08lvl2sec74" class="calibre1"/>The multicast() operator and MulticastObservable</h2></div></div></div><p class="calibre8">So let's go back to the <code class="literal">multicast()</code> operator and see how <code class="literal">MulticastObservable</code> is related to all this. We said that <code class="literal">multicast()</code> returns <code class="literal">ConnectableObservable</code> or <code class="literal">MulticastObservable</code> depending on the arguments we use. This is true when we use the second argument to <code class="literal">multicast()</code>.</p><p class="calibre8">Consider the following example, where we also pass a selector function to the <code class="literal">multicast()</code> operator:</p><pre class="programlisting">// multicast_02.php  
use Rx\Observable; 
use Rx\Subject\Subject; 
 
$subject = new Subject(); 
$source = Observable::range(1, 3) 
    -&gt;multicast($subject, function($connectable) { 
        return $connectable-&gt;concat(Observable::just('start')); 
    }) 
    -&gt;concat(Observable::just('concat')); 
 
$source-&gt;subscribe(new DebugSubject()); 
$source-&gt;subscribe(new DebugSubject()); 
</pre><p class="calibre8">If we use the second argument to <code class="literal">multicast()</code>, it wraps the <code class="literal">$subject</code> variable with a callable before it's passed to <code class="literal">MulticastObservable</code>. In fact, <code class="literal">multicast()</code> is internally implemented as the following:</p><pre class="programlisting">function multicast($subject, $selector=null, $scheduler=null){ 
  return $selector ? 
    new MulticastObservable($this, function () use ($subject) { 
      return $subject; 
    }, $selector) : 
    new ConnectableObservable($this, $subject, $scheduler); 
} 
</pre><p class="calibre8">This always guarantees that we're using the same <code class="literal">Subject</code>. The only thing that decides which Observable we'll receive is whether we use the selector function or not. The preceding example also adds the <code class="literal">startWith()</code> and <code class="literal">concat()</code> operators to see what effect this selector function can have.</p><p class="calibre8">The output for this example is affected by the issue we showed earlier:</p><pre class="programlisting">
<span class="strong"><strong class="calibre17">$ php multicast_02.php</strong></span>
<span class="strong"><strong class="calibre17">13:41:23 [] onNext: start (string)</strong></span>
<span class="strong"><strong class="calibre17">13:41:23 [] onNext: 1 (integer)</strong></span>
<span class="strong"><strong class="calibre17">13:41:23 [] onNext: 2 (integer)</strong></span>
<span class="strong"><strong class="calibre17">13:41:23 [] onNext: 3 (integer)</strong></span>
<span class="strong"><strong class="calibre17">13:41:23 [] onNext: concat (string)</strong></span>
<span class="strong"><strong class="calibre17">13:41:23 [] onCompleted</strong></span>
<span class="strong"><strong class="calibre17">13:41:23 [] onNext: start (string)</strong></span>
<span class="strong"><strong class="calibre17">13:41:23 [] onNext: concat (string)</strong></span>
<span class="strong"><strong class="calibre17">13:41:23 [] onCompleted</strong></span>
</pre><p class="calibre8">The second subscriber hasn't received any value, even though we subscribed twice to the source Observable.</p><div class="book" title="Comparing ConnectableObservable and MulticastObservable"><div class="book"><div class="book"><div class="book"><h3 class="title1"><a id="ch08lvl3sec27" class="calibre1"/>Comparing ConnectableObservable and MulticastObservable</h3></div></div></div><p class="calibre8">To be extra clear about the difference between these two use cases and <code class="literal">ConnectableObservable</code> and <code class="literal">MulticastObservable</code>, let's have a look at these two diagrams:</p><p class="calibre8">
</p><div class="mediaobject"><img src="../images/00030.jpeg" alt="Comparing ConnectableObservable and MulticastObservable" class="calibre19"/></div><p class="calibre20"> </p><p class="calibre8">
</p><p class="calibre8">Diagram representing a ConnectableObservable with two observers</p><p class="calibre8">In this diagram, we have a single <code class="literal">ConnectableObservable</code> that internally contains one <code class="literal">Subject</code>. Both observers are subscribed to the same <code class="literal">Subject</code>.</p><p class="calibre8">On the other hand, with <code class="literal">MulticastObservable</code> we'll get the following structure:</p><p class="calibre8">
</p><div class="mediaobject"><img src="../images/00031.jpeg" alt="Comparing ConnectableObservable and MulticastObservable" class="calibre19"/></div><p class="calibre20"> </p><p class="calibre8">
</p><p class="calibre8">Diagram representing a MulticastObservable with two observers</p><p class="calibre8">The two <code class="literal">ConnectableObservables</code> inside the grey boxes mean we have no control over them (these are created automatically by the internal <code class="literal">multicast()</code> call, as mentioned earlier).</p><p class="calibre8">As we can see from the examples, with <code class="literal">MulticastObservable</code> created via the <code class="literal">multicast()</code> call, we won't be able to achieve the same result as we see in this image because <code class="literal">multicast()</code> always forces us to use a single Subject instance. Of course, we could always create an instance of <code class="literal">MulticastObservable</code> ourselves, as we saw earlier in this chapter, but there's also an operator for this purpose that we can use.</p></div></div></div>

<div class="book" title="Multicasting in RxPHP">
<div class="book" title="The multicastWithSelector() operator"><div class="book"><div class="book"><div class="book"><h2 class="title2" id="calibre_pb_4"><a id="ch08lvl2sec75" class="calibre1"/>The multicastWithSelector() operator</h2></div></div></div><p class="calibre8">To simplify creating instances of <code class="literal">MulticastObservable</code>, we have the <code class="literal">multicastWithSelector()</code> operator, which takes two callables as arguments that have the same purpose as calling <code class="literal">MulticastObservable</code> itself.</p><p class="calibre8">Consider the following example:</p><pre class="programlisting">// multicastWithSelector_01.php  
$source = Observable::range(1, 3) 
    -&gt;multicastWithSelector(function() { 
        return new Subject(); 
    }, function(ConnectableObservable $connectable) { 
        return $connectable-&gt;concat(Observable::just('concat')); 
    }); 
 
$source-&gt;subscribe(new DebugSubject()); 
$source-&gt;subscribe(new DebugSubject()); 
</pre><p class="calibre8">This example illustrates the diagram we saw previously. We have two observers where each has its own instance of <code class="literal">Subject</code>. We also made use of the selector function that appends a <code class="literal">concat</code> string at the end of the chain.</p><p class="calibre8">The output is then easily predictable:</p><pre class="programlisting">
<span class="strong"><strong class="calibre17">$ php multicastWithSelector_01.php </strong></span>
<span class="strong"><strong class="calibre17">15:05:56 [] onNext: 1 (integer)</strong></span>
<span class="strong"><strong class="calibre17">15:05:56 [] onNext: 2 (integer)</strong></span>
<span class="strong"><strong class="calibre17">15:05:56 [] onNext: 3 (integer)</strong></span>
<span class="strong"><strong class="calibre17">15:05:56 [] onNext: concat (string)</strong></span>
<span class="strong"><strong class="calibre17">15:05:56 [] onCompleted</strong></span>
<span class="strong"><strong class="calibre17">15:05:56 [] onNext: 1 (integer)</strong></span>
<span class="strong"><strong class="calibre17">15:05:56 [] onNext: 2 (integer)</strong></span>
<span class="strong"><strong class="calibre17">15:05:56 [] onNext: 3 (integer)</strong></span>
<span class="strong"><strong class="calibre17">15:05:56 [] onNext: concat (string)</strong></span>
<span class="strong"><strong class="calibre17">15:05:56 [] onCompleted</strong></span>
</pre><p class="calibre8">This was an introduction to multicasting in Rx and the <code class="literal">multicast()</code> operator in RxPHP. Since there're a few other operators based on <code class="literal">multicast()</code>, we'll talk about them now when we know how <code class="literal">multicast()</code> behaves internally.</p></div></div>

<div class="book" title="Multicasting in RxPHP">
<div class="book" title="The publish*() and share*() operator groups"><div class="book"><div class="book"><div class="book"><h2 class="title2" id="calibre_pb_5"><a id="ch08lvl2sec76" class="calibre1"/>The publish*() and share*() operator groups</h2></div></div></div><p class="calibre8">There're multiple other operators internally using the <code class="literal">multicast()</code> operator, and we can split them into two basic groups:</p><div class="book"><ul class="itemizedlist"><li class="listitem"><code class="literal">publish*()</code>: Operators starting with the word "publish" wrap the <code class="literal">multicast()</code> operator and call it with one of the <code class="literal">Subject</code> classes. All <code class="literal">publish*</code> variants accept an optional argument, which is the selector function that we talked about earlier. Therefore, all of them can return <code class="literal">ConnectableObservable</code> or <code class="literal">MulticastObservable</code> just like <code class="literal">multicast()</code>.</li><li class="listitem"><code class="literal">share*()</code>: Operators starting with the word "share" internally use the same <code class="literal">publish*</code> equivalent and chain it with the <code class="literal">refCount()</code> operator. All <code class="literal">share*</code> operators don't allow any selector function.</li></ul></div><p class="calibre8">To understand the difference between the two groups, we need to first understand what the <code class="literal">refCount()</code> operator is.</p><div class="book" title="The refCount() operator"><div class="book"><div class="book"><div class="book"><h3 class="title1"><a id="ch08lvl3sec28" class="calibre1"/>The refCount() operator</h3></div></div></div><p class="calibre8">We already know this very basic usage of <code class="literal">ConnectableObservable</code>. Let's consider the following example, and first see how we can call the <code class="literal">connect()</code> method manually and then switch to the <code class="literal">refCount()</code> operator:</p><pre class="programlisting">// refCount_01.php  
$source = Observable::create(function($observer) { 
    $observer-&gt;onNext(1); 
    $observer-&gt;onNext(2); 
    $observer-&gt;onNext(3); 
}); 
$conn = new Observable\ConnectableObservable($source); 
$conn-&gt;subscribe(new DebugSubject('1')); 
$conn-&gt;subscribe(new DebugSubject('2')); 
$conn-&gt;connect(); 
</pre><p class="calibre8">This is simple. We have two observers subscribed to the <code class="literal">ConnectableObservable</code> waiting to call <code class="literal">connect()</code>, which subscribes to the source Observable (in this case <code class="literal">AnonymousObservable</code> with a custom subscribe function) and emits all values to both observers at the same time.</p><p class="calibre8">Note that we're purposely not using <code class="literal">RangeObservable</code> because we don't want to emit the <code class="literal">complete</code> signal:</p><pre class="programlisting">
<span class="strong"><strong class="calibre17">$ php refCount_01.php </strong></span>
<span class="strong"><strong class="calibre17">17:20:41 [1] onNext: 1 (integer)</strong></span>
<span class="strong"><strong class="calibre17">17:20:41 [2] onNext: 1 (integer)</strong></span>
<span class="strong"><strong class="calibre17">17:20:41 [1] onNext: 2 (integer)</strong></span>
<span class="strong"><strong class="calibre17">17:20:41 [2] onNext: 2 (integer)</strong></span>
<span class="strong"><strong class="calibre17">17:20:41 [1] onNext: 3 (integer)</strong></span>
<span class="strong"><strong class="calibre17">17:20:41 [2] onNext: 3 (integer)</strong></span>
</pre><p class="calibre8">This is pretty simple, but we had to call <code class="literal">connect()</code> ourselves, which is sometimes alright. However, other times we can leave this logic to the <code class="literal">refCount()</code> operator.</p><p class="calibre8">Well, actually it's not an operator (it's not lifted to an Observable chain with the <code class="literal">lift()</code> method). It's just a method on <code class="literal">ConnectableObservable</code> that returns an instance of <code class="literal">RefCountObservable</code>.</p><p class="calibre8">This Observable internally subscribes and unsubscribes to the source Observable. When the first observer subscribes, it also calls <code class="literal">connect()</code> on the <code class="literal">ConnectableObservable</code>. Then when another observer subscribes, it does nothing because we've already subscribed. When unsubscribing, the procedure is exactly the opposite. If even the last observer unsubscribes, then <code class="literal">RefCountObservable</code> also unsubscribes the <code class="literal">ConnectableObservable</code>.</p><p class="calibre8">This has some interesting consequences. We can use <code class="literal">refCount()</code> to automatically subscribe when there's at least one observer, as we can see in this example:</p><pre class="programlisting">// refCount_02.php  
$source = Rx\Observable::create(function($observer) { 
    $observer-&gt;onNext(1); 
    $observer-&gt;onNext(2); 
    $observer-&gt;onNext(3); 
}); 
$conn = (new Rx\Observable\ConnectableObservable($source)) 
    -&gt;refCount(); 
 
$conn-&gt;subscribe(new DebugSubject('1')); 
$conn-&gt;subscribe(new DebugSubject('2')); 
</pre><p class="calibre8">We have two observers again, but this time we're not calling <code class="literal">connect()</code> by ourselves. Instead, we're using <code class="literal">refCount()</code> to call the <code class="literal">connect()</code> method for us. Since we're sharing the same subscription to the source, only the first observer will receive values. The second observer doesn't cause another subscription to the source (as we can see from the preceding explanation):</p><pre class="programlisting">
<span class="strong"><strong class="calibre17">$ php refCount_02.php </strong></span>
<span class="strong"><strong class="calibre17">17:52:05 [1] onNext: 1 (integer)</strong></span>
<span class="strong"><strong class="calibre17">17:52:05 [1] onNext: 2 (integer)</strong></span>
<span class="strong"><strong class="calibre17">17:52:05 [1] onNext: 3 (integer)</strong></span>
</pre><p class="calibre8">However, if we unsubscribe after receiving values for the first observer (which causes unsubscription from <code class="literal">ConnectableObservable</code> inside <code class="literal">RefCountObservable</code>) and then subscribe again with the second observer, it'll make the source emit all its values because we have subscribed to it again:</p><pre class="programlisting">// refCount_03.php 
// ... 
$sub = $conn-&gt;subscribe(new DebugSubject('1')); 
$sub-&gt;dispose(); 
$conn-&gt;subscribe(new DebugSubject('2')); 
</pre><p class="calibre8">When we called <code class="literal">dispose()</code>, we made <code class="literal">RefCountObservable</code> unsubscribe from its source because there are no more observers.</p><p class="calibre8">This example prints all values twice:</p><pre class="programlisting">
<span class="strong"><strong class="calibre17">$ php refCount_03.php </strong></span>
<span class="strong"><strong class="calibre17">17:53:29 [1] onNext: 1 (integer)</strong></span>
<span class="strong"><strong class="calibre17">17:53:29 [1] onNext: 2 (integer)</strong></span>
<span class="strong"><strong class="calibre17">17:53:29 [1] onNext: 3 (integer)</strong></span>
<span class="strong"><strong class="calibre17">17:53:29 [2] onNext: 1 (integer)</strong></span>
<span class="strong"><strong class="calibre17">17:53:29 [2] onNext: 2 (integer)</strong></span>
<span class="strong"><strong class="calibre17">17:53:29 [2] onNext: 3 (integer)</strong></span>
</pre><p class="calibre8">Of course, we need to be sure we don't stop the inner <code class="literal">Subject</code> in <code class="literal">ConnectableObservable</code> as we talked about before. The <code class="literal">ConnectableObservable</code> class uses a single instance of <code class="literal">Subject</code>, so if it received a complete signal, then no unsubscription or subscription would change this.</p></div></div></div>

<div class="book" title="Multicasting in RxPHP">
<div class="book" title="The publish() and share() operators"><div class="book"><div class="book"><div class="book"><h2 class="title2" id="calibre_pb_6"><a id="ch08lvl2sec77" class="calibre1"/>The publish() and share() operators</h2></div></div></div><p class="calibre8">Now we know what the <code class="literal">multicast()</code> and <code class="literal">refCount()</code> operators do, we can finally understand what <code class="literal">publish()</code> and <code class="literal">share()</code> do.</p><p class="calibre8">Using <code class="literal">publish()</code> is just a shortcut to calling <code class="literal">multicast()</code> with the <code class="literal">Subject</code> instance as a parameter. If we rewrote the very first example on the <code class="literal">multicast()</code> operator, it would look almost the same:</p><pre class="programlisting">// publish_01.php  
use Rx\Observable; 
$observable = Observable::defer(function() { 
        printf("Observable::defer\n"); 
        return Observable::range(1, 3); 
    }) 
    -&gt;publish(); 
 
$observable-&gt;subscribe(new DebugSubject('1')); 
$observable-&gt;subscribe(new DebugSubject('2')); 
$observable-&gt;connect(); 
</pre><p class="calibre8">The output for this demo is exactly the same as for <code class="literal">multicast_01.php</code>, so we don't need to reprint it here.</p><p class="calibre8">The <code class="literal">share()</code> Operator uses the <code class="literal">publish()-&gt;refCount()</code> chain internally, so we don't need to call <code class="literal">connect()</code> any more. However, the output is not the same.</p><p class="calibre8">The <code class="literal">RangeObservable</code> sent the complete signal, which marked the internal <code class="literal">Subject</code> in <code class="literal">ConnectableObservable</code> as stopped, so the second observer won't receive anything except the <code class="literal">complete</code> signal that is emitted by the <code class="literal">Subject</code> class right at the point of subscription (it's not emitted by the source Observable):</p><pre class="programlisting">// share_01.php  
use Rx\Observable; 
$observable = Observable::defer(function() { 
        printf("Observable::defer\n"); 
        return Observable::range(1, 3); 
    }) 
    -&gt;share(); 
 
$observable-&gt;subscribe(new DebugSubject('1')); 
$observable-&gt;subscribe(new DebugSubject('2')); 
</pre><p class="calibre8">From the output, we can see that the source Observable is really created just once:</p><pre class="programlisting">
<span class="strong"><strong class="calibre17">$ php share_01.php </strong></span>
<span class="strong"><strong class="calibre17">Observable::defer</strong></span>
<span class="strong"><strong class="calibre17">18:17:12 [1] onNext: 1 (integer)</strong></span>
<span class="strong"><strong class="calibre17">18:17:12 [1] onNext: 2 (integer)</strong></span>
<span class="strong"><strong class="calibre17">18:17:12 [1] onNext: 3 (integer)</strong></span>
<span class="strong"><strong class="calibre17">18:17:12 [1] onCompleted</strong></span>
<span class="strong"><strong class="calibre17">18:17:12 [2] onCompleted</strong></span>
</pre><p class="calibre8">These two basic operators have many variants, but are based on the same principle.</p></div></div>

<div class="book" title="Multicasting in RxPHP">
<div class="book" title="The publishValue() and shareValue() operators"><div class="book"><div class="book"><div class="book"><h2 class="title2" id="calibre_pb_7"><a id="ch08lvl2sec78" class="calibre1"/>The publishValue() and shareValue() operators</h2></div></div></div><p class="calibre8">These operators are based on <code class="literal">BehaviorSubject</code> instead of just <code class="literal">Subject</code>. The principle is then exactly the same. The <code class="literal">publishValue()</code> operator calls <code class="literal">multicast()</code> with an instance of <code class="literal">BehaviorSubject</code>. Then the <code class="literal">shareValue()</code> operator calls <code class="literal">publishValue()-&gt;refCount()</code>.</p><p class="calibre8">Using <code class="literal">BehaviorSubject</code> allows us to set the default value that is emitted to all observers when they subscribe.</p><p class="calibre8">We can test this operator on the same example as before:</p><pre class="programlisting">// publishValue_01.php  
$source = Observable::defer(function() { 
        printf("Observable::defer\n"); 
        return Observable::range(1, 3); 
    }) 
    -&gt;publishValue('default'); 
 
$source-&gt;subscribe(new DebugSubject()); 
$source-&gt;subscribe(new DebugSubject()); 
$source-&gt;connect(); 
</pre><p class="calibre8">The output always starts with the default string because it's emitted by <code class="literal">BehaviorSubject</code> as the first value:</p><pre class="programlisting">
<span class="strong"><strong class="calibre17">$ php publishValue_01.php </strong></span>
<span class="strong"><strong class="calibre17">18:47:17 [] onNext: default (string)</strong></span>
<span class="strong"><strong class="calibre17">18:47:17 [] onNext: default (string)</strong></span>
<span class="strong"><strong class="calibre17">Observable::defer</strong></span>
<span class="strong"><strong class="calibre17">18:47:17 [] onNext: 1 (integer)</strong></span>
<span class="strong"><strong class="calibre17">18:47:17 [] onNext: 1 (integer)</strong></span>
<span class="strong"><strong class="calibre17">18:47:17 [] onNext: 2 (integer)</strong></span>
<span class="strong"><strong class="calibre17">18:47:17 [] onNext: 2 (integer)</strong></span>
<span class="strong"><strong class="calibre17">18:47:17 [] onNext: 3 (integer)</strong></span>
<span class="strong"><strong class="calibre17">18:47:17 [] onNext: 3 (integer)</strong></span>
<span class="strong"><strong class="calibre17">18:47:17 [] onCompleted</strong></span>
<span class="strong"><strong class="calibre17">18:47:17 [] onCompleted</strong></span>
</pre><p class="calibre8">Using <code class="literal">shareValue()</code> is the same as using <code class="literal">share()</code>, so we don't need to include it here.</p></div></div>

<div class="book" title="Multicasting in RxPHP">
<div class="book" title="The replay(), shareReplay(), and publishLast() operators"><div class="book"><div class="book"><div class="book"><h2 class="title2" id="calibre_pb_8"><a id="ch08lvl2sec79" class="calibre1"/>The replay(), shareReplay(), and publishLast() operators</h2></div></div></div><p class="calibre8">All these share exactly the same principle as the previous two operators, just based on <code class="literal">ReplaySubject</code> (<code class="literal">replay()</code> and <code class="literal">shareReplay()</code>) or <code class="literal">AsyncSubject</code> (the <code class="literal">publishLast()</code> operator).</p><p class="calibre8">We don't need to include examples for those operators here because there would be nothing new for us to see.</p></div></div>

<div class="book" title="PHP pthreads extension"><div class="book" id="1S2JE2-bd355a22cf10407cb10df27e65585b8d"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch08lvl1sec55" class="calibre1"/>PHP pthreads extension</h1></div></div></div><p class="calibre8">Since the year 2000, PHP can be compiled as <span class="strong"><strong class="calibre17">thread safe</strong></span>, which allows any process to run multiple instances of the PHP interpreter in multiple threads (one thread per PHP interpreter). Each PHP interpreter has its own isolated context which doesn't share any data (the "share nothing" philosophy) with others.</p><p class="calibre8">This is commonly used in web servers such as Apache (depending on its modules). Apache creates multiple subprocesses where each subprocess runs multiple threads with multiple PHP interpreters. Running interpreters in threads instead of subprocesses has its advantages and disadvantages.</p><p class="calibre8">Creating only threads is significantly faster and doesn't consume as much memory as creating subprocesses.</p><p class="calibre8">An obvious disadvantage is isolation. Even though all PHP interpreters run independently in threads, if any of them causes, for example, a "segmentation fault" error, then the entire process and all of its threads are terminated immediately. This even includes threads that didn't cause any error and that might be processing an HTTP request from another client at that moment.</p><p class="calibre8">This so-called <span class="strong"><strong class="calibre17">Server API</strong></span> (<span class="strong"><strong class="calibre17">SAPI</strong></span>) isn't very helpful to us. We need to be able to run our own pieces of code in threads ("user land multithreading"). The PHP extension pthreads is an object-oriented API that does exactly this. It takes our code and creates a new PHP interpreter, which then starts executing it.</p><p class="calibre8">Note that the PHP pthreads are based on POSIX threads, which means that when we create a thread using pthreads, we're creating a real thread and not forking or creating subprocesses underneath.</p><p class="calibre8">In some languages, such as Python, there are threads that behave like they're executing code in parallel, but in fact there's still just one single threaded Python interpreter switching from one "thread" to another. So there's no real parallelism.</p><p class="calibre8">However, PHP <code class="literal">pthreads</code> come with a cost, and it's important to understand at least a little of what's going on inside.</p></div>

<div class="book" title="PHP pthreads extension">
<div class="book" title="Prerequisites"><div class="book"><div class="book"><div class="book"><h2 class="title2" id="calibre_pb_1"><a id="ch08lvl2sec80" class="calibre1"/>Prerequisites</h2></div></div></div><p class="calibre8">In this chapter, we'll use the new <code class="literal">pthreads</code> v3, which means we need to use PHP7+. There's also the older <code class="literal">pthreads</code> v2, which is designed for PHP5. Since there are major differences in the internal implementations with these two versions, we'll stick only to the new one.</p><p class="calibre8">As we said earlier, in order to use the <code class="literal">pthreads</code> extension, PHP has to be compiled with the <span class="strong"><strong class="calibre17">Thread Safety</strong></span> option enabled. This needs to be enabled when compiling PHP and can't be enabled later (if you're only downloading the PHP executable, make sure you're downloading the correct one, usually marked as ZTS).</p><p class="calibre8">A universal way to install <code class="literal">pthreads</code> is with the PECL tool, which should work on all platforms:</p><pre class="programlisting">
<span class="strong"><strong class="calibre17">$ pecl install pthreads</strong></span>
</pre><p class="calibre8">Alternatively, if you're running OS X, you can use a homebrew tool that also enables it in PHP config files for you:</p><pre class="programlisting">
<span class="strong"><strong class="calibre17">$ brew install php70-pthreads</strong></span>
</pre><div class="informaltable" title="Note"><h3 class="title1"><a id="note42" class="calibre1"/>Note</h3><p class="calibre8">The current pthreads v3 can be enabled only when running PHP code in a standalone script. This means pthreads can't be part of any PHP application ran using for example <code class="literal">php-fpm</code>. In other words, we can use pthreads only in console applications and not it web applications.</p></div></div></div>

<div class="book" title="PHP pthreads extension">
<div class="book" title="Introduction to multithreading with pthreads in PHP7"><div class="book"><div class="book"><div class="book"><h2 class="title2" id="calibre_pb_2"><a id="ch08lvl2sec81" class="calibre1"/>Introduction to multithreading with pthreads in PHP7</h2></div></div></div><p class="calibre8">The most basic example of pthreads in PHP can simply be the spawning of multiple threads and printing their results. We'll make random pauses with <code class="literal">sleep()</code> functions to simulate multiple long running tasks. Remember that in PHP the <code class="literal">sleep()</code> function is always blocking (it blocks the interpreter execution for a certain number of seconds):</p><pre class="programlisting">// threads_01.php  
class MyThread extends Thread { 
    protected $i; 
    public function __construct($i) { 
        $this-&gt;i = $i; 
    } 
    public function run() { 
        sleep(rand(1, 5)); 
        printf("%d: done\n", $this-&gt;i); 
    } 
} 
 
$threads = []; 
foreach (range(0, 5) as $i) { 
    $thread = new MyThread($i); 
    $thread-&gt;start(); 
    $threads[] = $thread; 
} 
 
foreach ($threads as $thread) { 
    $thread-&gt;join(); 
} 
echo "All done\n"; 
</pre><p class="calibre8">A task is represented by a class extending the base <code class="literal">Thread</code> class and implementing its <code class="literal">run()</code> method. This <code class="literal">run()</code> method contains code that'll be run in a separate thread when we call <code class="literal">start()</code>. Note that we need to implement the <code class="literal">run()</code> method and not the <code class="literal">start()</code> method. The <code class="literal">start()</code> method is an internal method written in C that calls <code class="literal">run()</code> for us.</p><p class="calibre8">After we create and start each thread, we use the <code class="literal">join()</code> method, which blocks the current interpreter and waits until that particular thread finishes. If it's already finished, then it'll continue. By looping over all threads and calling <code class="literal">join()</code>, we effectively wait until all of them finish.</p><p class="calibre8">When we run this example, we'll get the following result (you'll get a different order since we're using random sleep intervals):</p><pre class="programlisting">
<span class="strong"><strong class="calibre17">$ php threads_01.php </strong></span>
<span class="strong"><strong class="calibre17">0: done</strong></span>
<span class="strong"><strong class="calibre17">2: done</strong></span>
<span class="strong"><strong class="calibre17">1: done</strong></span>
<span class="strong"><strong class="calibre17">5: done</strong></span>
<span class="strong"><strong class="calibre17">3: done</strong></span>
<span class="strong"><strong class="calibre17">4: done</strong></span>
<span class="strong"><strong class="calibre17">All done</strong></span>
</pre><p class="calibre8">We won't go into much depth when using the <code class="literal">pthreads</code> extension in this chapter. There are primarily three reasons for this, as of April 2017:</p><div class="book"><ul class="itemizedlist"><li class="listitem"><span class="strong"><strong class="calibre17">Documentation on pthreads is very insufficient</strong></span>: Documentation on most of the classes and methods in pthreads contains very little information. There's at most one sentence, usually without any example, so it's mostly up to the developer to guess what it does.</li><li class="listitem"><span class="strong"><strong class="calibre17">Documentation, examples, and other sources of information are often obsolete</strong></span>: The new pthreads v3 works only with PHP7. However, the official documentation at <a class="calibre1" href="http://php.net/manual/en/book.pthreads.php">
http://php.net/manual/en/book.pthreads.php
</a> covers only <code class="literal">pthreads</code> v2. In the meantime, <code class="literal">pthreads</code> internals have changed, so you might be surprised that some examples won't work at all. For example, the <code class="literal">Mutex</code> and <code class="literal">Cond</code> classes don't exist at all now.</li><li class="listitem"><span class="strong"><strong class="calibre17">Documentation is non-existent</strong></span>: The new classes coming with pthreads v3 aren't documented at all. The official homepage <a class="calibre1" href="https://github.com/krakjoe/pthreads">
https://github.com/krakjoe/pthreads
</a> mentions differences between the two versions, but doesn't contain any information on how to effectively use them. For example, the PHP documentation found at <a class="calibre1" href="http://php.net/manual/en/book.pthreads.php">
http://php.net/manual/en/book.pthreads.php
</a> doesn't mention the <code class="literal">Volatile</code> class at all.</li></ul></div><p class="calibre8">This all means that using pthreads is a pain at this moment, and getting any relevant information is hard.</p><p class="calibre8">There are also caveats regarding having multiple PHP contexts that need to share data while staying completely isolated. Since we need to be aware of these issues, it's worth spending some time explaining what this means for us.</p></div></div>

<div class="book" title="PHP pthreads extension">
<div class="book" title="Getting/setting data from/to threads"><div class="book"><div class="book"><div class="book"><h2 class="title2" id="calibre_pb_3"><a id="ch08lvl2sec82" class="calibre1"/>Getting/setting data from/to threads</h2></div></div></div><p class="calibre8">In PHP, all objects are passed by reference by default. Consider the following example, where we pass an instance of <code class="literal">stdClass</code> to another object, where we modify it:</p><pre class="programlisting">// references_01.php  
$obj = new stdClass(); 
$obj-&gt;prop = 'foo'; 
 
$obj2 = $obj; 
printf("%d\n", $obj === $obj2); 
 
class TestClass { 
    public $obj; 
    public $objCopy; 
 
    public function copyObj() { 
        $this-&gt;objCopy = $this-&gt;obj; 
        $this-&gt;objCopy-&gt;prop2 = 'bar'; 
    } 
} 
 
$testObj = new TestClass(); 
$testObj-&gt;obj = $obj; 
$testObj-&gt;copyObj(); 
printf("%d\n", $obj === $testObj-&gt;objCopy); 
print_r($obj); 
</pre><p class="calibre8">We created an instance of <code class="literal">stdClass</code> called <code class="literal">$obj</code>. Then we reassigned it to <code class="literal">$obj2</code> and compared the two with an identity operator (three equal signs <code class="literal">===</code>). Then we pass the <code class="literal">$obj</code> to an instance of <code class="literal">TestClass</code>, where we do the same and also add one more property to it called <code class="literal">prop2</code>.</p><p class="calibre8">The output from this example is what we might expect:</p><pre class="programlisting">
<span class="strong"><strong class="calibre17">$ php7 references_01.php </strong></span>
<span class="strong"><strong class="calibre17">1</strong></span>
<span class="strong"><strong class="calibre17">1</strong></span>
<span class="strong"><strong class="calibre17">stdClass Object (</strong></span>
<span class="strong"><strong class="calibre17">    [prop] =&gt; foo</strong></span>
<span class="strong"><strong class="calibre17">    [prop2] =&gt; bar</strong></span>
<span class="strong"><strong class="calibre17">)</strong></span>
</pre><p class="calibre8">All the variables reference the same object. This is what we're used to and what we're using in PHP all the time.</p><p class="calibre8">However, this can't work with <code class="literal">pthreads</code>. We're not allowed to share objects (memory addresses) among different PHP contexts. These have to always be isolated, which is the very basic premise for thread-safe execution. We can test this with a very simple example, following on from the previous one:</p><pre class="programlisting">// threads_02.php  
class MyThread extends Thread { 
    public $obj; 
    public $objCopy; 
 
    public function run() { 
        $this-&gt;objCopy = $this-&gt;obj; 
        $this-&gt;objCopy-&gt;prop2 = 'bar'; 
        printf("%d\n", $this-&gt;obj === $this-&gt;obj); 
    } 
} 
 
$obj = new stdClass(); 
$obj-&gt;prop = 'foo'; 
 
$thread = new MyThread($obj); 
$thread-&gt;obj = $obj; 
$thread-&gt;start(); 
$thread-&gt;join(); 
 
printf("%d\n", $obj === $thread-&gt;objCopy); 
print_r($obj); 
</pre><p class="calibre8">In this example, we're using the identity operator to compare <code class="literal">$this-&gt;obj</code> with another variable that should be referencing the same object.</p><p class="calibre8">Now let's see what happens when we run this example:</p><pre class="programlisting">
<span class="strong"><strong class="calibre17">$ php threads_02.php </strong></span>
<span class="strong"><strong class="calibre17">0</strong></span>
<span class="strong"><strong class="calibre17">0</strong></span>
<span class="strong"><strong class="calibre17">stdClass Object (</strong></span>
<span class="strong"><strong class="calibre17">    [prop] =&gt; foo</strong></span>
<span class="strong"><strong class="calibre17">)</strong></span>
</pre><p class="calibre8">All the comparisons return <code class="literal">false</code>. Even the most obvious one, <code class="literal">$this-&gt;obj === $this-&gt;obj</code>, returns <code class="literal">false</code>.</p><p class="calibre8">In <code class="literal">pthreads</code>, it has to work like this because PHP interpreters are isolated, and thus all read and write operations from the parent and other contexts need to be performed via copying data. However, there's an exception to this rule. Classes coming from the <code class="literal">pthreads</code> extension (including all their descendants) aren't copied, and are just referenced, as we'll see in a later example.</p><p class="calibre8">So in this example, we actually copied the object multiple times. Every call to <code class="literal">$this-&gt;obj</code> made a copy to the current context, as well as to the last <code class="literal">$thread-&gt;objCopy</code> statement.</p><p class="calibre8">The consequence of this principle is that we have to gather results from threads manually; we can't just pass an object to its constructor that will be populated with results by the thread itself.</p><p class="calibre8">A modified version of the first example would look like this:</p><pre class="programlisting">// threads_08.php  
class MyThread extends Thread { 
    protected $i; 
    public $result; 
 
    public function __construct($i) { 
        $this-&gt;i = $i; 
    } 
 
    public function run() { 
        sleep(rand(1, 5)); 
        printf("%d: done\n", $this-&gt;i); 
        $this-&gt;result = pow($this-&gt;i, 2); 
    } 
} 
 
$threads = []; 
foreach (range(5, 7) as $i) { 
    $thread = new MyThread($i); 
    $thread-&gt;start(); 
    $threads[] = $thread; 
} 
 
foreach ($threads as $i =&gt; $thread) { 
    $thread-&gt;join(); 
    printf("%d: %d\n", $i, $thread-&gt;result); 
} 
echo "All done\n"; 
</pre><p class="calibre8">This is basically the same demo as before; we're just storing results for each thread in a public property that we can later read after calling <code class="literal">join()</code>.</p><p class="calibre8">The output for this example is as follows:</p><pre class="programlisting">
<span class="strong"><strong class="calibre17">$ php threads_08.php </strong></span>
<span class="strong"><strong class="calibre17">7: done</strong></span>
<span class="strong"><strong class="calibre17">5: done</strong></span>
<span class="strong"><strong class="calibre17">6: done</strong></span>
<span class="strong"><strong class="calibre17">0: 25</strong></span>
<span class="strong"><strong class="calibre17">1: 36</strong></span>
<span class="strong"><strong class="calibre17">2: 49</strong></span>
<span class="strong"><strong class="calibre17">All done</strong></span>
</pre><p class="calibre8">Although creating threads is simple, if we had multiple threads it'd be hard to keep track of which threads are running and which are already finished. In real-world applications, it's usually not required to spawn many threads to be executed just once. Creating so many threads is inefficient and, most importantly, unnecessary.</p></div></div>

<div class="book" title="PHP pthreads extension">
<div class="book" title="Using Thread, Worker, and Pool classes"><div class="book"><div class="book"><div class="book"><h2 class="title2" id="calibre_pb_4"><a id="ch08lvl2sec83" class="calibre1"/>Using Thread, Worker, and Pool classes</h2></div></div></div><p class="calibre8">The <code class="literal">Thread</code> class represents a single interpreter context and a single task. When we want to run the same task multiple times, we need to create multiple instances of the same class and then join all the results (to wait until they're done).</p><p class="calibre8">There's also the <code class="literal">Worker</code> class. Similar to the <code class="literal">Thread</code> class, it represents a single interpreter context, but instead of doing a single job, it can stack jobs and execute them one after another.</p><p class="calibre8">We can take the previous <code class="literal">MyThread</code> class and this time we'll execute all tasks on a single <code class="literal">Worker</code>:</p><pre class="programlisting">// threads_03.php  
 
class MyThread extends Thread { 
    protected $i; 
    public $result; 
 
    public function __construct($i) { 
        $this-&gt;i = $i; 
    } 
 
    public function run() { 
        sleep(rand(1, 5)); 
        printf("%d: done\n", $this-&gt;i); 
        $this-&gt;result = pow($this-&gt;i, 2); 
    } 
} 
 
$worker = new Worker(); 
$threads = []; 
foreach (range(1, 4) as $i) { 
    $thread = new MyThread($i); 
    $worker-&gt;stack($thread); 
    $threads[] = $thread; 
} 
 
$worker-&gt;start(); 
echo "Starting worker\n"; 
 
// Add another task after the worker has started 
$thread = new MyThread(42); 
$worker-&gt;stack($thread); 
$threads[] = $thread; 
$worker-&gt;shutdown(); 
 
foreach ($threads as $i =&gt; $thread) { 
    printf("%d: %d\n", $i, $thread-&gt;result); 
} 
echo "All done\n"; 
</pre><p class="calibre8">Since we have a single interpreter context, all tasks will be executed one after another. With the call to <code class="literal">shutdown()</code>, we make the <code class="literal">Worker</code> class wait until all stacked tasks are done. We can also add tasks to the worker after it's started the execution:</p><pre class="programlisting">
<span class="strong"><strong class="calibre17">$ php7 threads_03.php </strong></span>
<span class="strong"><strong class="calibre17">Starting worker</strong></span>
<span class="strong"><strong class="calibre17">5: done</strong></span>
<span class="strong"><strong class="calibre17">6: done</strong></span>
<span class="strong"><strong class="calibre17">7: done</strong></span>
<span class="strong"><strong class="calibre17">42: done</strong></span>
<span class="strong"><strong class="calibre17">0: 25</strong></span>
<span class="strong"><strong class="calibre17">1: 36</strong></span>
<span class="strong"><strong class="calibre17">2: 49</strong></span>
<span class="strong"><strong class="calibre17">3: 1764</strong></span>
<span class="strong"><strong class="calibre17">All done</strong></span>
</pre><p class="calibre8">Note that tasks are run one after another and not in parallel.</p><p class="calibre8">We used the default <code class="literal">Worker</code> class provided by <code class="literal">pthreads</code>, but we can make our own class extending from <code class="literal">Worker</code> as well. For example, consider the following class:</p><pre class="programlisting">class MyWorker extends Worker { 
    public function run() { 
        // ... Initialize this Worker and its context. 
    } 
} 
</pre><p class="calibre8">This class extends the <code class="literal">run()</code> method just like the <code class="literal">Thread</code> class. The <code class="literal">Worker</code> class's <code class="literal">run()</code> method, however, is called only once when initializing the PHP interpreter context, and allows us to set up the <code class="literal">Worker</code> class.</p><p class="calibre8">We can, of course, create multiple <code class="literal">Worker</code> instances and stack tasks on them, but handling which workers are available and which workers are busy would be tedious.</p><p class="calibre8">For this reason, <code class="literal">pthreads</code> have the <code class="literal">Pool</code> class. It can contain a number of workers and distribute tasks among them. We don't need to worry about selecting the correct worker, and can leave everything to the <code class="literal">Pool</code> class.</p><p class="calibre8">Now let's consider the following example, where we'll use a <code class="literal">Pool</code> of three <code class="literal">Worker</code> classes to perform six tasks in total:</p><pre class="programlisting">// threads_04.php 
class MyWorker extends Worker { 
    public function run() { 
        printf("%s: starting worker\n", date('H:i:s')); 
    } 
} 
class Task extends Threaded { 
    public function run() { 
        sleep(3); 
        printf("%s: done\n", date('H:i:s')); 
    } 
} 
printf("%s: start\n", date('H:i:s')); 
$pool = new Pool(3, MyWorker::class); 
 
foreach (range(0, 5) as $i) { 
    $pool-&gt;submit(new Task()); 
} 
 
$pool-&gt;shutdown(); 
echo "All done\n"; 
</pre><p class="calibre8">Each <code class="literal">Task</code> instance makes a three-second-long sleep. Since we're using three <code class="literal">Worker</code> classes, we can run three tasks at the same time, so running this demo should take exactly six seconds. Just as we did with the <code class="literal">Worker</code> class, we call <code class="literal">shutdown()</code>, which waits until all the tasks are processed and then shuts down all the workers. This is like calling <code class="literal">join()</code> on each task.</p><p class="calibre8">The <code class="literal">Pool</code> class takes three arguments: the number of workers to run simultaneously, the <code class="literal">Worker</code> class name that it'll instantiate (we can obviously use the default <code class="literal">Worker::class</code> as well), and an array of parameters passed to the <code class="literal">Worker</code> class's constructor.</p><p class="calibre8">The output from this example is as follows:</p><pre class="programlisting">$ php threads_04.php
22:50:51: start
22:50:51: starting worker
22:50:51: starting worker
22:50:51: starting worker
22:50:54: done
22:50:54: done
22:50:54: done
22:50:57: done
22:50:57: done
22:50:57: done
All done 
</pre><p class="calibre8">The main difference from the developer's perspective is that we're scheduling six tasks to be executed on three threads. In our very first example of pthreads, we executed six tasks as well, but on six threads.</p><p class="calibre8">The general rule of thumb is to use as few threads as we need. Creating threads requires some resource allocations (mostly creating a new PHP interpreter), and with tasks that actually do some heavy computing, the code will reach a point where the creation of additional threads will no longer produce any performance benefit. It's very effective to run in parallel tasks that spend most of their time waiting, such as system calls, or downloading data via HTTP. We can create many threads for these tasks, and they will all run in parallel and won't require practically any CPU time.</p><p class="calibre8">On the other hand, if we had tasks that do require CPU time, then at some point adding more threads won't have any effect because there will be no more CPUs/cores to run the interpreters, so it'll need to switch from one execution context to another. All the threads will run in parallel, but it'll take a long time to finish all of them. Whether it's worth it or not depends on what we want to achieve, but usually it's better to use a lower number of threads and execute tasks in smaller chunks.</p><div class="informaltable" title="Note"><h3 class="title1"><a id="note43" class="calibre1"/>Note</h3><p class="calibre8">A good number of threads for computationally intensive tasks is usually calculated as <span class="strong"><em class="calibre18">(number of CPUs) * (number of cores per CPU)</em></span>.</p></div><p class="calibre8">So this is why we might want to use the <code class="literal">Pool</code> class. Also, an important aspect we haven't seen in the previous example is how we can grab results from the finished tasks.</p><div class="book" title="Retrieving results from thread pools"><div class="book"><div class="book"><div class="book"><h3 class="title1"><a id="ch08lvl3sec29" class="calibre1"/>Retrieving results from thread pools</h3></div></div></div><p class="calibre8">The easiest way to get processed data from threads is by keeping their references and then iterating them to get results. The most obvious example could look like the following:</p><pre class="programlisting">// threads_12.php 
class MyThread extends Thread { 
    protected $i; 
    public $result; 
    public function __construct($i) { 
        $this-&gt;i = $i; 
    } 
    public function run() { 
        $this-&gt;result = pow($this-&gt;i, 2); 
    } 
} 
 
$pool = new Pool(3); 
$threads = []; 
foreach (range(1, 7) as $i) { 
    $thread = new MyThread($i); 
    $pool-&gt;submit($thread); 
    $threads[] = $thread; 
} 
$pool-&gt;shutdown(); 
 
$results = []; 
foreach ($threads as $thread) { 
    $results[] = $thread-&gt;result; 
} 
print_r($results); 
</pre><p class="calibre8">This is very simple and works as expected. However, it's not very practical. We used the <code class="literal">shutdown()</code> method to wait for all scheduled tasks to finish and then collected all the results from all threads. This would get more complicated if we didn't want to wait until all threads have finished and wanted to collect results as they're ready. We'd have to go back to something like an event loop that periodically checks all threads for their results.</p><p class="calibre8">Of course this is doable, but pthreads proposes another and more elegant way of doing this.</p><p class="calibre8">For this reason, the <code class="literal">Pool</code> class has a method called <code class="literal">collect()</code>. This method takes as an argument a callable that is called on every thread. This callable has to decide whether the thread has already finished or not. If it is finished, we can grab its result right inside the callable and return <code class="literal">true</code>, which means this thread can be disposed.</p><p class="calibre8">Unfortunately, there's one large BUT. In the current pthreads v3, the behavior of <code class="literal">Pool::collect()</code> has most likely changed. In most examples, you'll see the <code class="literal">collect()</code> method being used as follows:</p><pre class="programlisting">// threads_10.php  
$pool = new Pool(3); 
 
while (@$i++ &lt; 6) { 
    $pool-&gt;submit(new class($i) extends Thread { 
        public $id; 
        private $garbage; 
 
        public function __construct($id) { 
            $this-&gt;id = $id; 
        } 
        public function run() { 
            sleep(1); 
            printf("Hello World from %d\n", $this-&gt;id); 
            $this-&gt;setGarbage(); 
        } 
        public function setGarbage() { 
            $this-&gt;garbage = true; 
        } 
        public function isGarbage(): bool { 
            return $this-&gt;garbage; 
        } 
    }); 
} 
while ($pool-&gt;collect(function(Collectable $work){ 
    printf("Collecting %d\n", $work-&gt;id); 
    return $work-&gt;isGarbage(); 
})) continue; 
 
$pool-&gt;shutdown(); 
</pre><p class="calibre8">This example is using an anonymous class (a PHP7 feature) to extend <code class="literal">Thread</code> to represent a single task.</p><p class="calibre8">Although this example seems simple and is used in many resources (including the <a class="calibre1" href="http://stackoverflow.com">
stackoverflow.com
</a> answers by the author of pthreads), it doesn't collect all the results. We wanted to include this example here to show how it should work and most likely will work in the updated version of pthread.</p><p class="calibre8">The output of PHP7 and pthreads v3 looks like the following (you'll probably get these lines in a different order):</p><pre class="programlisting">
<span class="strong"><strong class="calibre17">$ php threads_10.php </strong></span>
<span class="strong"><strong class="calibre17">Hello World from 1</strong></span>
<span class="strong"><strong class="calibre17">Collecting 1</strong></span>
<span class="strong"><strong class="calibre17">Hello World from 2</strong></span>
<span class="strong"><strong class="calibre17">Collecting 2</strong></span>
<span class="strong"><strong class="calibre17">Hello World from 3</strong></span>
<span class="strong"><strong class="calibre17">Collecting 3</strong></span>
<span class="strong"><strong class="calibre17">Hello World from 4</strong></span>
<span class="strong"><strong class="calibre17">Hello World from 5</strong></span>
<span class="strong"><strong class="calibre17">Hello World from 6</strong></span>
</pre><p class="calibre8">As you can see, the last three threads weren't collected at all.</p><p class="calibre8">There are a couple of possible reasons why this doesn't work:</p><div class="book"><ul class="itemizedlist"><li class="listitem">With prior versions of pthreads, we had to extend the <code class="literal">Collectable</code> class instead of the <code class="literal">Thread</code> class. The <code class="literal">Collectable</code> class used to be a class originally, but this has changed, and it's now an interface. This change is documented on the pthreads readme page (<a class="calibre1" href="https://github.com/krakjoe/pthreads#php7">
https://github.com/krakjoe/pthreads#php7
</a>). Now, the <code class="literal">Thread</code> class implements <code class="literal">Collectable</code> automatically. In most resources, you'll find <code class="literal">Collectable</code> used as a class.</li><li class="listitem">The official documentation on <code class="literal">Pool::collect()</code> is insufficient. It doesn't mention at all that the callables need to return <code class="literal">Boolean</code> determining whether the thread should be disposed. Also, the documentation is for the older <code class="literal">pthreads</code> v2 where the <code class="literal">collect()</code> method is said to return void. This is not (or maybe never was) true since it's always used in a <code class="literal">while</code> loop (see <a class="calibre1" href="http://stackoverflow.com/questions/28416842/how-does-poolcollect-works">http://stackoverflow.com/questions/28416842/how-does-poolcollect-works</a> or <a class="calibre1" href="https://gist.github.com/krakjoe/9384409">https://gist.github.com/krakjoe/9384409</a>).</li><li class="listitem">Changes to <code class="literal">Pool::collect()</code> are mentioned in the official readme at <a class="calibre1" href="https://github.com/krakjoe/pthreads#php7">
https://github.com/krakjoe/pthreads#php7
</a>. Quote: "<span class="strong"><em class="calibre18">The <code class="literal">Pool::collect</code> mechanism was moved from <code class="literal">Pool</code> to <code class="literal">Worker</code> for a more robust <code class="literal">Worker</code> and simpler <code class="literal">Pool</code> inheritance.</em></span>" What this means remains a mystery.</li><li class="listitem">In some examples, you'll see developers extending the <code class="literal">Pool</code> class and looping with <code class="literal">while (count($this-&gt;work))</code>. This was probably meant to loop while there is work scheduled. In pthreads v3, the <code class="literal">work</code> property doesn't exist on the <code class="literal">Pool</code> class. The official readme page listing the breaking changes we mentioned already has no record of this change.</li></ul></div><p class="calibre8">So our biggest problem is the lack of any reliable information.</p><p class="calibre8">It looks desperate, but there is, in fact, a sane way of collecting all the results. We'll make use of yet another undocumented class called <code class="literal">Volatile</code> and pass it to all our threads. As we said earlier when talking about sharing data between interpreter contexts, all data needs to be copied. In contrast, classes coming from the pthreads extension (and all classes extending them) are referenced directly, and we're going to use this to our advantage.</p><p class="calibre8">Let's have a look at this example using the <code class="literal">Volatile</code> class to collect the results from the threads:</p><pre class="programlisting">// threads_05.php 
class Task extends Thread { 
  public $result; 
  private $i; 
 
  public function __construct($i, Volatile $results) { 
    $this-&gt;i = $i; 
    $this-&gt;results = $results; 
  } 
  public function run() { 
    sleep(1); 
    $result = pow($this-&gt;i, 2); 
    printf("%s: done %d\n", date('H:i:s'), $result); 
 
    $this-&gt;results-&gt;synchronized(function($results,$result){ 
      $results[] = (array)['id' =&gt; $this-&gt;i,'result' =&gt; $result]; 
      $results-&gt;notify(); 
    }, $this-&gt;results, $result); 
  } 
} 
 
$pool = new Pool(2); 
$results = new Volatile(); 
foreach (range(0, 3) as $i) { 
  $pool-&gt;submit(new Task($i, $results)); 
} 
 
$results-&gt;synchronized(function() use ($results) { 
  while (count($results) != 4) { 
    $results-&gt;wait(); 
  } 
}); 
 
while ($pool-&gt;collect()) continue; 
$pool-&gt;shutdown(); 
print_r($results); 
echo "All done\n"; 
</pre><p class="calibre8">The first part looks very familiar. We created a class extending the <code class="literal">Thread</code> class, and then an instance of <code class="literal">Pool</code> where we'll schedule four tasks. Each task in its constructor takes the same instance of <code class="literal">Volatile</code>. That's the object where we'll append results for all our threads.</p><p class="calibre8">With the <code class="literal">Volatile</code> class, we're also using three new methods that are useful only when executing multithreaded code where we need some sort of synchronization between threads:</p><div class="book"><ul class="itemizedlist"><li class="listitem"><code class="literal">synchronized()</code>: This method runs the callable while holding the access lock for this object. We need to use this method in our example to be sure that only one thread is able to append results at a time. Note that the pthreads are using POSIX threads underneath, so the operator <code class="literal">[]</code> is not an atomic operation at all. If we didn't use locks, then multiple threads might try to modify the resulting array, which would lead to completely unpredictable behavior.</li><li class="listitem"><code class="literal">wait()</code>: This method makes the current interpreter context wait until <code class="literal">notify()</code> is called on the same object (it's a blocking operation). Note that calling <code class="literal">wait()</code> will release the access lock while it is waiting, and then it'll be reacquired after awakening with <code class="literal">notify()</code>. Therefore, this method needs to be called inside <code class="literal">synchronized()</code>.</li><li class="listitem"><code class="literal">notify()</code>: This method wakes the waiting interpreter context after calling the <code class="literal">wait()</code> method.</li></ul></div><p class="calibre8">Using <code class="literal">wait()</code> and <code class="literal">notify()</code> might be very dangerous if used inappropriately. If the thread containing <code class="literal">notify()</code> called this method before the first thread arrived at <code class="literal">wait()</code>, then the first context would be stuck at <code class="literal">wait()</code> forever because there'd be no other <code class="literal">notify()</code> call to awaken it.</p><p class="calibre8">So we run <code class="literal">wait()</code> calls in a loop because we know that only one thread can acquire the lock, and therefore each thread will append to <code class="literal">$results</code> one after the other.</p><p class="calibre8">All threads will share the same reference to <code class="literal">Volatile</code> because, as we said, it's a class from the pthreads extension (or its derivate extending the <code class="literal">Threaded</code> class), so it won't be copied on read/write attempts.</p><p class="calibre8">When we run this example, we'll get the expected output:</p><pre class="programlisting">
<span class="strong"><strong class="calibre17">$ php threads_05.php </strong></span>
<span class="strong"><strong class="calibre17">17:21:42: done 0</strong></span>
<span class="strong"><strong class="calibre17">17:21:42: done 1</strong></span>
<span class="strong"><strong class="calibre17">17:21:43: done 9</strong></span>
<span class="strong"><strong class="calibre17">17:21:43: done 4</strong></span>
<span class="strong"><strong class="calibre17">Volatile Object (</strong></span>
<span class="strong"><strong class="calibre17">    [0] =&gt; Array(</strong></span>
<span class="strong"><strong class="calibre17">            [id] =&gt; </strong></span>
<span class="strong"><strong class="calibre17">            [result] =&gt; 0</strong></span>
<span class="strong"><strong class="calibre17">        )</strong></span>
<span class="strong"><strong class="calibre17">    [1] =&gt; Array(</strong></span>
<span class="strong"><strong class="calibre17">            [id] =&gt; </strong></span>
<span class="strong"><strong class="calibre17">            [result] =&gt; 1</strong></span>
<span class="strong"><strong class="calibre17">        )</strong></span>
<span class="strong"><strong class="calibre17">    [2] =&gt; Array(</strong></span>
<span class="strong"><strong class="calibre17">            [id] =&gt; </strong></span>
<span class="strong"><strong class="calibre17">            [result] =&gt; 9</strong></span>
<span class="strong"><strong class="calibre17">        )</strong></span>
<span class="strong"><strong class="calibre17">    [3] =&gt; Array(</strong></span>
<span class="strong"><strong class="calibre17">            [id] =&gt; </strong></span>
<span class="strong"><strong class="calibre17">            [result] =&gt; 4</strong></span>
<span class="strong"><strong class="calibre17">        )</strong></span>
<span class="strong"><strong class="calibre17">)</strong></span>
<span class="strong"><strong class="calibre17">All done</strong></span>
</pre><p class="calibre8">Note one last thing. When appending our results, we used the following line:</p><pre class="programlisting">$results[] = (array)['id' =&gt; $this-&gt;i, 'result' =&gt; $result]; 
</pre><p class="calibre8">We're using typecasting with <code class="literal">(array)</code>, which seems redundant. In fact, we have to do this in order not to lose the reference to this array. When setting an array to a property of the <code class="literal">Thread</code> class, it's automatically converted into a <code class="literal">Volatile</code> object unless we typecast it beforehand to an array. Without typecasting, the <code class="literal">Volatile</code> object representing the array would be deallocated when this context is shut down, so we need to force typecast it to an array in order to be copied.</p><p class="calibre8">
There's actually one more solution to the problem described above with 

<code class="literal">Pool</code> 
class not collection all results correctly (although this solution is not as elegant as using <code class="literal">synchronized()</code> methods). Instead of using the <code class="literal">collect()</code> method to control how long we want to run the while loop, we can manually count the threads that have finished, in a similar way to the following example:
</p><pre class="programlisting">
// threads_13.php
$pool = new Pool(3);
// populate $pool with 6 tasks...
$remaining = 6;
while ($remaining !== 0) {
  $pool-&gt;collect(function(Collectable $work) use (&amp;$remaining) {
    $done = $work-&gt;isGarbage();
    if ($done) {
      printf("Collecting %d\n", $work-&gt;id);
      $remaining--;
    }
    return $done;
  });
}
</pre><p class="calibre8">
Now the responsibility to run the while loop as long as necessary lies on us and not the <code class="literal">collect()</code> method (that might be bugged).
</p><p class="calibre8">
When we run this example with the same anonymous class instances as shown previously, we'll correctly collect all the results.
</p><pre class="programlisting">
<span class="strong"><strong class="calibre17">
$ php threads_13.php 
Hello World from 1
Collecting 1
Hello World from 2
Collecting 2
Hello World from 3
Collecting 3
Hello World from 4
Hello World from 5
Hello World from 6
Collecting 6
Collecting 4
Collecting 5
</strong></span>
</pre></div></div></div>
<div class="book" title="RxPHP and pthreads" id="1T1401-bd355a22cf10407cb10df27e65585b8d"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch08lvl1sec56" class="calibre1"/>RxPHP and pthreads</h1></div></div></div><p class="calibre8">
A good question is how is all this about pthreads related to RxPHP and to Rx in general.
</p><p class="calibre8">
In PHP, we're typically not used to work with asynchronous tasks and if we do, the implementation details are well hidden from us. This is for example the case with event loops and RxPHP, where we don't need to care what's going on inside RxPHP classes under the hood.
</p><p class="calibre8">In the next chapter, we'd like to achieve the same state where we'll have a general purpose Observable or an operator that runs tasks in parallel using pthreads. Since working with asynchronous code in RxPHP is easy, pthreads is a perfect candidate that could add very interesting functionality which can be easily reused anywhere.</p></div>
<div class="book" title="Summary" id="1TVKI1-bd355a22cf10407cb10df27e65585b8d"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch08lvl1sec57" class="calibre1"/>Summary</h1></div></div></div><p class="calibre8">In this chapter, we went through two larger topics. We'll use both of them in the next chapter, where we'll write multithreaded applications with pthreads, as well as distributed applications with Gearman.</p><p class="calibre8">The two topics we covered were multicasting in RxPHP and all operators related to it, and using the PHP7 pthreads v3 extension to write multithreaded PHP7 applications.</p><p class="calibre8">Multicasting in Rx is very useful in order to share a single connection to source Observables without resubscribing. This comes with the <code class="literal">refCount()</code> operator to work more easily with <code class="literal">ConnectableObservables</code>.</p><p class="calibre8">Multithreaded programming in PHP is possible with the pthreads extension. However, it's not as simple as it seems, and there are multiple caveats, most importantly insufficient documentation and an overall unintuitive approach. In the next chapter, we'll use just the most basic functions from pthreads to avoid confusion and eventual inconsistency with future updates of pthreads. The goal for the next chapter is to write an extendable code quality tool, based on the <code class="literal">nikic/php-parser</code> project (<a class="calibre1" href="https://github.com/nikic/PHP-Parser">
https://github.com/nikic/PHP-Parser
</a>), which will allow adding custom rules using RxPHP operator chains. We'll base the application on what we've covered in this chapter.</p></div></body></html>