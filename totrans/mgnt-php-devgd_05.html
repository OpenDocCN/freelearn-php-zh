<html><head></head><body><div class="chapter" title="Chapter&#xA0;5.&#xA0;The Magento API"><div class="titlepage"><div><div><h1 class="title"><a id="ch05"/>Chapter 5. The Magento API</h1></div></div></div><p>In the previous chapter, we extended the Magento backend and learned how to use some of the backend components, so that store owners can manage and manipulate the gift registry data of each customer.</p><p>In this chapter, we will go over the following topics:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The Magento Core API</li><li class="listitem" style="list-style-type: disc">The multiple API protocols <a id="id319" class="indexterm"/>available (<span class="strong"><strong>REST</strong></span>, <span class="strong"><strong>SOAP</strong></span>, and <a id="id320" class="indexterm"/><span class="strong"><strong>XML-RPC</strong></span>)</li><li class="listitem" style="list-style-type: disc">How to use the <a id="id321" class="indexterm"/>Core API</li><li class="listitem" style="list-style-type: disc">How to extend the API to implement a new functionality</li><li class="listitem" style="list-style-type: disc">How to restrict parts of the API to specific web user roles</li></ul></div><p>While the backend provides an interface for day-to-day operations, sometimes, we will need to access and transmit data to and from third-party systems. Magento already provides the API functionality for most of the core functionalities, but for our custom gift registry extension, we will need to extend the <code class="literal">Mage_Api</code> functionality.</p><div class="section" title="The Core API"><div class="titlepage"><div><div><h1 class="title"><a id="ch05lvl1sec35"/>The Core API</h1></div></div></div><p>Often, while talking about<a id="id322" class="indexterm"/> the API, I heard developers talk about the Magento SOAP API, the Magento XML-RPC API, or the RESTful API, but there is the important fact that these are not separate APIs for each of these protocols. Instead, Magento has a single Core API.</p><p>As you might notice, Magento is built mostly around abstraction and configuration (mostly XML), and the Magento API is no exception. We have a single Core API and adapters for each of the different protocol types. This is incredibly flexible, and if we want to, we can implement our adapter for another protocol.</p><p>The core Magento API gives us the ability to manage products, categories, attributes, orders, and invoices; this is done by <a id="id323" class="indexterm"/>exposing three of the core modules:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">Mage_Catalog</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">Mage_Sales</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">Mage_Customer</code></li></ul></div><p>The API supports three different types: SOAP, XML-RPC, and REST. Now, if you have done web development outside Magento and with other APIs, it is most likely that these APIs have been RESTful APIs.</p><p>Before we jump into the specifics of the Magento API architecture, it is important that we understand the differences between each of the supported API types.</p><div class="section" title="XML-RPC"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec46"/>XML-RPC</h2></div></div></div><p>XML-RPC was one of the first <a id="id324" class="indexterm"/>supported protocols by Magento, and is the oldest<a id="id325" class="indexterm"/> of them all. This protocol has a single endpoint on which all the functions are called and accessed. The definition for XML-RPC is quoted on Wikipedia as follows:</p><div class="blockquote"><blockquote class="blockquote"><p><span class="emphasis"><em>XML-RPC is a remote procedure call (RPC) protocol that uses XML to encode its calls and HTTP as a transport mechanism.</em></span></p></blockquote></div><p>Since there is only a single endpoint, XML-RPC is easy to use and maintain; its purpose is to be a simple and effective protocol to send and receive data; and implementation uses straightforward XML to encode and decode a remote procedure call along with the parameters.</p><p>However, this comes at a cost, and there are several problems with the whole XML-RPC protocol:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Lack of discoverability and documentation.</li><li class="listitem" style="list-style-type: disc">Anonymous parameters, XML-RPC relies on the order of the parameters to differentiate them.</li><li class="listitem" style="list-style-type: disc">Simplicity is both the greatest strength and the greatest issue with XML-RPC. While most of the tasks can easily be achieved with XML-RPC some tasks will require you to bend over backwards to achieve something that should be straightforward to implement.</li></ul></div><p>Soap was designed to <a id="id326" class="indexterm"/>address XML-RPC limitations and provide a more robust protocol.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note23"/>Note</h3><p>For more information about <a id="id327" class="indexterm"/>XML-RPC, you can refer to <a class="ulink" href="http://en.wikipedia.org/wiki/XML-RPC">http://en.wikipedia.org/wiki/XML-RPC</a>.</p></div></div></div><div class="section" title="SOAP"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec47"/>SOAP</h2></div></div></div><p>SOAP v1 was one of the first supported protocols by Magento along with XML-RPC, and SOAP v2 has been supported since the<a id="id328" class="indexterm"/> release of <span class="strong"><strong>Magento CE 1.3</strong></span>.</p><p>The definition for SOAP is <a id="id329" class="indexterm"/>quoted on Wikipedia as follows:</p><div class="blockquote"><blockquote class="blockquote"><p><span class="emphasis"><em>SOAP, originally an acronym for Simple Object Access protocol, is a protocol specification for exchanging structured information in the implementation of web services in computer networks.</em></span></p></blockquote></div><p>A SOAP request is an <code class="literal">HTTP POST</code> request that contains a SOAP envelope, header, and body.</p><p>The core of SOAP is the <a id="id330" class="indexterm"/>
<span class="strong"><strong>Web Services Description Language</strong></span> (<span class="strong"><strong>WSDL</strong></span>), which is XML. WSDL is used to describe the functionality of the web service, in this case, our API methods. This is achieved by using the following series<a id="id331" class="indexterm"/> of predetermined objects:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">types</code>: The <code class="literal">types</code> elements are used to describe the data transmitted with the API; the <code class="literal">type</code> elements are defined using XML Schema, a special language for this purpose</li><li class="listitem" style="list-style-type: disc"><code class="literal">message</code>: The <code class="literal">message</code> element is used to specify the information needed to perform each operation; in the case of Magento, our API methods will always use a request and a respond <code class="literal">message</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">portType</code>: The <code class="literal">portType</code> elements are used the define the operations that can be performed and the corresponding messages</li><li class="listitem" style="list-style-type: disc"><code class="literal">port</code>: The <code class="literal">port</code> element is used to define the connection point; in the case of Magento, a simple string is used</li><li class="listitem" style="list-style-type: disc"><code class="literal">service</code>: The <code class="literal">service</code> element is used to specify which functions are exposed through the API</li><li class="listitem" style="list-style-type: disc"><code class="literal">binding</code>: The <code class="literal">binding</code> elements are used to define the operations and the interface with the SOAP protocol</li></ul></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note24"/>Note</h3><p>For more information<a id="id332" class="indexterm"/> about the SOAP protocol, you can refer to <a class="ulink" href="http://en.wikipedia.org/wiki/SOAP">http://en.wikipedia.org/wiki/SOAP</a>.</p></div></div><p>All the WSDL configuration<a id="id333" class="indexterm"/> is contained inside each module's <code class="literal">wsdl.xml</code> file; for <a id="id334" class="indexterm"/>example, let's take a look at an excerpt of the <code class="literal">Catalog Product</code> API, located at <code class="literal">app/code/local/Mdg/Giftregistry/etc/wsdl.xml</code>:</p><div class="informalexample"><pre class="programlisting">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;definitions       name="{{var wsdl.name}}" targetNamespace="urn:{{var wsdl.name}}"&gt;
  &lt;types&gt;
    &lt;schema  targetNamespace="urn:Magento"&gt;
      ...
      &lt;complexType name="catalogProductEntity"&gt;
        &lt;all&gt;
          &lt;element name="product_id" type="xsd:string" /&gt;
          &lt;element name="sku" type="xsd:string" /&gt;
          &lt;element name="name" type="xsd:string" /&gt;
          &lt;element name="set" type="xsd:string" /&gt;
          &lt;element name="type" type="xsd:string" /&gt;
          &lt;element name="category_ids" type="typens:ArrayOfString" /&gt;
          &lt;element name="website_ids" type="typens:ArrayOfString" /&gt;
        &lt;/all&gt;
      &lt;/complexType&gt;
    &lt;/schema&gt;
  &lt;/types&gt;
  &lt;message name="catalogProductListResponse"&gt;
    &lt;part name="storeView" type="typens:catalogProductEntityArray" /&gt;
  &lt;/message&gt;
  ...
  &lt;portType name="{{var wsdl.handler}}PortType"&gt;
    ...
    &lt;operation name="catalogProductList"&gt;
      &lt;documentation&gt;Retrieve products list by filters&lt;/documentation&gt;
      &lt;input message="typens:catalogProductListRequest" /&gt;
      &lt;output message="typens:catalogProductListResponse" /&gt;
    &lt;/operation&gt;
    ...
  &lt;/portType&gt;
  &lt;binding name="{{var wsdl.handler}}Binding" type="typens:{{var wsdl.handler}}PortType"&gt;
    &lt;soap:binding style="rpc" transport="http://schemas.xmlsoap.org/soap/http" /&gt;
    ...
    &lt;operation name="catalogProductList"&gt;
      &lt;soap:operation soapAction="urn:{{var wsdl.handler}}Action" /&gt;
      &lt;input&gt;
        &lt;soap:body namespace="urn:{{var wsdl.name}}" use="encoded" encodingStyle= "http://schemas.xmlsoap.org/soap/encoding/" /&gt;
      &lt;/input&gt;
      &lt;output&gt;
        &lt;soap:body namespace="urn:{{var wsdl.name}}" use="encoded" encodingStyle= "http://schemas.xmlsoap.org/soap/encoding/" /&gt;
      &lt;/output&gt;
    &lt;/operation&gt;
    ...
  &lt;/binding&gt;
  &lt;service name="{{var wsdl.name}}Service"&gt;
    &lt;port name="{{var wsdl.handler}}Port" binding="typens:{{var wsdl.handler}}Binding"&gt;
      &lt;soap:address location="{{var wsdl.url}}" /&gt;
    &lt;/port&gt;
  &lt;/service&gt;
&lt;/definitions&gt;</pre></div><p>Using WSDL, we can<a id="id335" class="indexterm"/> document, list, and support more complex data types.</p></div><div class="section" title="The RESTful API"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec48"/>The RESTful API</h2></div></div></div><p>The RESTful API is a new addition to the family of protocols supported by Magento and is only available<a id="id336" class="indexterm"/> on <span class="strong"><strong>Magento CE 1.7</strong></span> or higher.</p><p>The definition for a <a id="id337" class="indexterm"/>RESTful web service can be quoted as follows:</p><div class="blockquote"><blockquote class="blockquote"><p><span class="emphasis"><em>A RESTful web service (also called a RESTful web API) is the web service implemented using HTTP and the principles of REST.</em></span></p></blockquote></div><p>A RESTful API can be defined by the following three aspects:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">It makes use of the standard of HTTP methods, such as <code class="literal">GET</code>, <code class="literal">POST</code>, <code class="literal">DELETE</code>, and <code class="literal">PUT</code></li><li class="listitem" style="list-style-type: disc">It exposes the URIs formatted in a directory-like structure</li><li class="listitem" style="list-style-type: disc">It uses JSON or XML to transfer information</li></ul></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note25"/>Note</h3><p>The REST API supports the response in two formats, which are XML and JSON.</p></div></div><p>One the advantages that REST has over SOAP and XML-RPC is that all interaction with the REST API is done through the HTTP protocol, which means that it can be used by virtually any programming language.</p><p>The Magento REST API has the following characteristics:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Resources are accessed by making an HTTP request to the Magento API service</li><li class="listitem" style="list-style-type: disc">The service will reply with the data for the request, a status indicator, or even both</li><li class="listitem" style="list-style-type: disc">All resources can be accessed by using <code class="literal">https://magento.localhost.com/api/rest/</code> as URL</li><li class="listitem" style="list-style-type: disc">Resources return<a id="id338" class="indexterm"/> <span class="strong"><strong>HTTP status codes</strong></span>, such as <code class="literal">HTTP Status Code 200</code>, to indicate success on a response or <code class="literal">HTTP Status Code 400</code> to indicate a bad request</li><li class="listitem" style="list-style-type: disc">Requests to a particular resource are done by adding a particular path to the base URL (<code class="literal">https://magento.localhost.com/api/rest/</code>)</li></ul></div><p>REST uses <span class="strong"><strong>HTTP verbs</strong></span> to<a id="id339" class="indexterm"/> manage the states of resources. In the Magento implementation, four verbs are available: <code class="literal">GET</code>, <code class="literal">POST</code>, <code class="literal">PUT</code>, and <code class="literal">DELETE</code>. For this reason, using the RESTful API is<a id="id340" class="indexterm"/> easy in most cases.</p></div></div></div>
<div class="section" title="Using the API"><div class="titlepage"><div><div><h1 class="title"><a id="ch05lvl1sec36"/>Using the API</h1></div></div></div><p>Now that we have clarified each of the available protocols, let's explore what we can do with the Magento API and how we can use it with each of the available protocols.</p><p>We will use the product endpoint as<a id="id341" class="indexterm"/> an example to access and work with the different API protocols.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note26"/>Note</h3><p>The examples are provided in PHP <a id="id342" class="indexterm"/>and use the three different protocols. For complete examples in other programming languages, check out <a class="ulink" href="http://magedevguide.com">http://magedevguide.com</a>.</p></div></div><div class="section" title="Setting up the API credentials for XML-RPC/SOAP"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec49"/>Setting up the API credentials for XML-RPC/SOAP</h2></div></div></div><p>Before we get started <a id="id343" class="indexterm"/>we, need to create a set of web service credentials in order to access the API functions.</p><p>The first thing that we need to set up is the API user role. <span class="strong"><strong>Roles</strong></span> control the permissions for the API using <a id="id344" class="indexterm"/>
<span class="strong"><strong>Access Control List</strong></span> (<span class="strong"><strong>ACL</strong></span>). By implementing this design pattern, Magento is able to restrict certain parts of its API to specific users.</p><p>Later on this chapter, we will learn how we can add our custom functions to the ACL and secure our custom extensions API methods. For now, we just need to create a role with full permissions:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Go to the Magento backend.</li><li class="listitem">Navigate to <span class="strong"><strong>System</strong></span> | <span class="strong"><strong>Web Services</strong></span> | <span class="strong"><strong>Roles</strong></span> from the main navigation menu.</li><li class="listitem">Click on the <span class="strong"><strong>Add New Role</strong></span> button.</li><li class="listitem">As shown in the following screenshot, you will be requested to provide a role name and specify the role resources:<div class="mediaobject"><img src="graphics/4195OS_05_02.jpg" alt="Setting up the API credentials for XML-RPC/SOAP"/></div></li><li class="listitem">By default, the <span class="strong"><strong>Resource Access</strong></span> option is set to <span class="strong"><strong>Custom</strong></span> and no resources are selected. In our case, we will change the <span class="strong"><strong>Resource Access</strong></span> option by selecting <span class="strong"><strong>All</strong></span> from the drop-down menu.</li><li class="listitem">Click on the <span class="strong"><strong>Save Role</strong></span> button.</li></ol></div><p>Now that we have a <a id="id345" class="indexterm"/>valid role in our store, let's proceed to create a web API user:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Go to the Magento backend.</li><li class="listitem">Navigate to <span class="strong"><strong>System</strong></span> | <span class="strong"><strong>Web Services</strong></span> | <span class="strong"><strong>Users</strong></span> from the main navigation menu.</li><li class="listitem">Click on the <span class="strong"><strong>Add New User</strong></span> button.</li><li class="listitem">As shown in the following screenshot, you will be asked for the user information:<div class="mediaobject"><img src="graphics/4195OS_05_01.jpg" alt="Setting up the API credentials for XML-RPC/SOAP"/></div></li><li class="listitem">In the <span class="strong"><strong>API Key</strong></span> and <span class="strong"><strong>API Key Confirmation</strong></span> fields, input your desired password.</li><li class="listitem">Click<a id="id346" class="indexterm"/> on the <span class="strong"><strong>User Role</strong></span> tab.</li><li class="listitem">Select the user role that we just created.</li><li class="listitem">Click on the <span class="strong"><strong>Save User</strong></span> button.</li></ol></div><p>The reason that we need to create username and role to access the API is that every single API function requires a <span class="strong"><strong>session token</strong></span> to be passed as a parameter.</p><p>For this reason, every time we need to use the API, the first call that we have to make is to the <code class="literal">login</code> function, which will return a valid session token id.</p></div><div class="section" title="Setting up the REST API credentials"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec50"/>Setting up the REST API credentials</h2></div></div></div><p>The new RESTful <a id="id347" class="indexterm"/>API is slightly different in terms of authentication; instead of using the traditional Magento web service users, it uses a three-legged <a id="id348" class="indexterm"/>
<span class="strong"><strong>OAuth 1.0</strong></span> protocol to provide authentication.</p><p>OAuth works by asking the user to authorize its application. When the user registers an application, he/she needs to fill in the following fields:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>User</strong></span>: This refers to a<a id="id349" class="indexterm"/> customer who has an account with Magento, and can user the services with the API.</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Consumer</strong></span>: This refers to a third-party application that uses OAuth to access the Magento API.</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Consumer key</strong></span>: This refers to a unique value used to identify a user with Magento.</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Consumer secret</strong></span>: This refers to a secret used by the customer to guarantee the ownership of the consumer key. This value is never passed on the request.</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Request token</strong></span>: This value is used by the consumer (application) to obtain authorization from the user to access the API resources.</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Access token</strong></span>: This is returned in exchange of the request token and on successful authentication.</li></ul></div><p>Let's proceed to register our application by going to <span class="strong"><strong>System</strong></span> | <span class="strong"><strong>Web Services</strong></span> | <span class="strong"><strong>REST - OAuth Consumers</strong></span>, and selecting <span class="strong"><strong>Add New</strong></span> in the <span class="strong"><strong>Admin</strong></span> panel. We will get the following screen:</p><div class="mediaobject"><img src="graphics/4195OS_05_03.jpg" alt="Setting up the REST API credentials"/></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note27"/>Note</h3><p>One important thing to notice is that a callback URL must be defined, to which the user will be redirected after successfully authorizing the application.</p></div></div><p>So, our first step is to<a id="id350" class="indexterm"/> learn how to get this session token ID on each of the available API protocols:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">To get session the token ID in XML-RPC, we need to execute the following code:<div class="informalexample"><pre class="programlisting">$apiUser = 'username';
$apiKey = 'password';
$client = new Zend_XmlRpc_Client('http://ourhost.com/api/xmlrpc/');
// We authenticate ourselves and get a session token id
$sessionId = $client-&gt;call('login', array($apiUser, $apiKey));</pre></div></li><li class="listitem" style="list-style-type: disc">To get a session token ID in SOAP v2, we need to execute the following code:<div class="informalexample"><pre class="programlisting">$apiUser = 'username';
$apiKey = 'password';
$client = new SoapClient('http://ourhost.com/api/v2_soap/?wsdl');
// We authenticate ourselves and get a session token id
$sessionId = $client-&gt;login($apiUser, $apiKey);</pre></div></li><li class="listitem" style="list-style-type: disc">To get a session token<a id="id351" class="indexterm"/> ID in REST, we need to execute the following code:<div class="informalexample"><pre class="programlisting">$callbackUrl = "http://magento.localhost.com/oauth_admin.php";
$temporaryCredentialsRequestUrl = "http://magento.localhost.com/oauth/ initiate?oauth_callback=" . urlencode($callbackUrl);
$adminAuthorizationUrl = 'http://magento.localhost.com/admin/oAuth_authorize';
$accessTokenRequestUrl = 'http://magento.localhost.com/oauth/token';
$apiUrl = 'http://magento.localhost.com/api/rest';
$consumerKey = 'yourconsumerkey';
$consumerSecret = 'yourconsumersecret';

session_start();

$authType = ($_SESSION['state'] == 2) ? OAUTH_AUTH_TYPE_AUTHORIZATION : OAUTH_AUTH_TYPE_URI;
$oauthClient = new OAuth($consumerKey, $consumerSecret, OAUTH_SIG_METHOD_HMACSHA1, $authType);

$oauthClient-&gt;setToken($_SESSION['token'], $_SESSION['secret']);</pre></div></li></ul></div></div><div class="section" title="Loading and reading data"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec51"/>Loading and reading data</h2></div></div></div><p>The <code class="literal">Mage_Catalog</code> module product <a id="id352" class="indexterm"/>endpoint has the following exposed methods that <a id="id353" class="indexterm"/>we can use to manage products:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">catalog_product.currentStore</code>: This can be used to set/get the current store view</li><li class="listitem" style="list-style-type: disc"><code class="literal">catalog_product.list</code>: This retrieves the products list using filters</li><li class="listitem" style="list-style-type: disc"><code class="literal">catalog_product.info</code>: This retrieves a product</li><li class="listitem" style="list-style-type: disc"><code class="literal">catalog_product.create</code>: This creates a new product</li><li class="listitem" style="list-style-type: disc"><code class="literal">catalog_product.update</code>: This updates a product</li><li class="listitem" style="list-style-type: disc"><code class="literal">catalog_product.setSpecialPrice</code>: This sets a special price for a product</li><li class="listitem" style="list-style-type: disc"><code class="literal">catalog_product.getSpecialPrice</code>: This gets a special price for a product</li><li class="listitem" style="list-style-type: disc"><code class="literal">catalog_product.delete</code>: This deletes a product</li></ul></div><p>Right now, the functions<a id="id354" class="indexterm"/> that are of particular interest to us are <code class="literal">catalog_product.list</code> and <code class="literal">catalog_product.info</code>. Let's see how we can use the API to retrieve product data from our staging store.</p><p>To retrieve product data from our staging store in XML-RPC, execute the following code:</p><div class="informalexample"><pre class="programlisting">…
$result = $client-&gt;call($sessionId, 'catalog_product.list');
print_r ($result);
…</pre></div><p>To retrieve product data<a id="id355" class="indexterm"/> from our staging store in SOAP v2, execute the following code:</p><div class="informalexample"><pre class="programlisting">…
$result = $client-&gt;catalogProductList($sessionId);
print_r($result);
…</pre></div><p>To retrieve product data from our staging store in REST, execute the following code:</p><div class="informalexample"><pre class="programlisting">…
$resourceUrl = $apiUrl . "/products";
$oauthClient-&gt;fetch($resourceUrl, array(), 'GET', array('Content- Type' =&gt; 'application/json'));
$productsList = json_decode($oauthClient-&gt;getLastResponse());
…</pre></div><p>Regardless of the protocol, we will get back a list of all the products' <span class="strong"><strong>SKUs</strong></span> (short for <span class="strong"><strong>Stock Keeping Units</strong></span>), but what<a id="id356" class="indexterm"/> if we want to filter that product list based on an attribute? Well, the Magento lists functions that allows us to do this by passing a parameter. That said, let's see how we can add filters to our product list call.</p><p>To add filters to our product list call in XML-RPC, execute the following code:</p><div class="informalexample"><pre class="programlisting">…
$result = $client-&gt;call('catalog_product.list', array($sessionId, $filters);
print_r ($result);
…</pre></div><p>To add filters to our <a id="id357" class="indexterm"/>product list call in SOAP v2, execute the following code:</p><div class="informalexample"><pre class="programlisting">…
$result = $client-&gt;catalogProductList($sessionId,$filters);
print_r($result);
…</pre></div><p>Using REST, things are not that simple, and it is not possible to retrieve a product collection filtered by an attribute. However, we can retrieve all the products that belong to a specific category</p><p>To add filters to our<a id="id358" class="indexterm"/> product list call in REST, execute the following code:</p><div class="informalexample"><pre class="programlisting">…
$categoryId = 3;
$resourceUrl = $apiUrl . "/products/category_id=" . categoryId;
$oauthClient-&gt;fetch($resourceUrl, array(), 'GET', array('Content- Type' =&gt; 'application/json'));
$productsList = json_decode($oauthClient-&gt;getLastResponse());
…</pre></div></div><div class="section" title="Updating data"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec52"/>Updating data</h2></div></div></div><p>Now that we can retrieve product<a id="id359" class="indexterm"/> information from the Magento API, we can start updating the content of each product.</p><p>The <code class="literal">catalog_product.update</code> method will allow us to modify any of the product attributes; the function call takes the following parameters:</p><p>To update data in XML-RPC, execute the following code:</p><div class="informalexample"><pre class="programlisting">…
$productId = 200;
$productData = array( 'sku' =&gt; 'changed_sku', 'name' =&gt; 'New Name', 'price' =&gt; 15.40 );
$result = $client-&gt;call($sessionId, 'catalog_product.update', array($productId, $productData));
print_r($result);
…</pre></div><p>To update data in SOAP v2, execute the following code:</p><div class="informalexample"><pre class="programlisting">…
$productId = 200;
$productData = array( 'sku' =&gt; 'changed_sku', 'name' =&gt; 'New Name', 'price' =&gt; 15.40 );
$result = $client-&gt;catalogProductUpdate($sessionId, array($productId, $productData));
print_r($result);
…</pre></div><p>To update data in<a id="id360" class="indexterm"/> REST, execute the following code:</p><div class="informalexample"><pre class="programlisting">…
$productData = json_encode(array(
  'type_id'           =&gt; 'simple',
  'attribute_set_id'  =&gt; 4,
  'sku'               =&gt; 'simple' . uniqid(),
  'weight'            =&gt; 10,
  'status'            =&gt; 1,
  'visibility'        =&gt; 4,
  'name'              =&gt; 'Test Product',
  'description'       =&gt; 'Description',
  'short_description' =&gt; 'Short Description',
  'price'             =&gt; 29.99,
  'tax_class_id'      =&gt; 2,
));
$oauthClient-&gt;fetch($resourceUrl, $productData, OAUTH_HTTP_METHOD_POST, array('Content-Type' =&gt; 'application/json'));
$updatedProduct = json_decode($oauthClient- &gt;getLastResponseInfo());
…</pre></div></div><div class="section" title="Deleting a product"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec53"/>Deleting a product</h2></div></div></div><p>Deleting products<a id="id361" class="indexterm"/> using the API is very simple, and is probably one of the most common operations.</p><p>To delete products in XML-RPC, execute the following code:</p><div class="informalexample"><pre class="programlisting">…
$productId = 200;
$result = $client-&gt;call($sessionId, 'catalog_product.delete', $productId);
print_r($result);
…</pre></div><p>To delete products in SOAP v2, execute the following code:</p><div class="informalexample"><pre class="programlisting">…
$productId = 200;
$result = $client-&gt;catalogProductDelete($sessionId, $productId);
print_r($result);
…</pre></div><p>To delete the code<a id="id362" class="indexterm"/> in REST, execute the following code:</p><div class="informalexample"><pre class="programlisting">…
$productData = json_encode(array(
  'id'           =&gt; 4
));
$oauthClient-&gt;fetch($resourceUrl, $productData, OAUTH_HTTP_METHOD_DELETE, array('Content-Type' =&gt; 'application/json'));
$updatedProduct = json_decode($oauthClient- &gt;getLastResponseInfo());
…</pre></div></div></div>
<div class="section" title="Extending the API"><div class="titlepage"><div><div><h1 class="title"><a id="ch05lvl1sec37"/>Extending the API</h1></div></div></div><p>Now that we have a basic understanding of how to use the Magento Core API, we can proceed to extend and add our custom functionality. In order to <a id="id363" class="indexterm"/>add new API functionality, we have to modify/create the following files:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">wsdl.xml</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">api.xml</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">api.php</code></li></ul></div><p>In order to make our registries accessible for third-party systems, we need to create and expose the following functions</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">giftregistry_registry.list</code>: This retrieves a list of all the registry IDs; it takes an optional customer ID parameter</li><li class="listitem" style="list-style-type: disc"><code class="literal">giftregistry_registry.info</code>: This retrieves all the registry information; it takes a required registry_id parameter</li><li class="listitem" style="list-style-type: disc"><code class="literal">giftregistry_item.list</code>: This retrieves a list of all the registry item IDs associated with a registry; it takes a required <code class="literal">registry_id</code> parameter</li><li class="listitem" style="list-style-type: disc"><code class="literal">giftregistry_item.info</code>: This retrieves the product and detailed information of a registry item; it takes a required <code class="literal">item_id</code> parameter</li></ul></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note28"/>Note</h3><p>There's a challenge here. So far, we have only added reading operations; try to include API methods to<a id="id364" class="indexterm"/> update, delete, and create registries and registry items. To see the answer with<a id="id365" class="indexterm"/> the complete code and full breakdown, refer to <a class="ulink" href="http://www.magedevguide.com/">http://www.magedevguide.com/</a>.</p></div></div><p>Our first step is to implement the API class and the required functions:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Navigate to the <code class="literal">Model</code> directory.</li><li class="listitem">Create a new class called <code class="literal">Api.php</code> at <code class="literal">app/code/local/Mdg/Giftregistry/Model/Api.php</code>, and place the following placeholder content inside it:<div class="informalexample"><pre class="programlisting">&lt;?php
class Mdg_Giftregisty_Model_Api extends Mage_Api_Model_Resource_Abstract
{
  public function getRegistryList($customerId = null)
  {
  
  }

  public function getRegistryInfo($registryId)
  {
  
  }

  public function getRegistryItems($registryId)
  {
  
  }

  public function getRegistryItemInfo($registryItemId)
  {
  
  }
}</pre></div></li><li class="listitem">Create a new directory called <code class="literal">Api/</code>.</li><li class="listitem">Inside <code class="literal">Api/</code>, create a new class called <code class="literal">V2.php</code> at <code class="literal">app/code/local/Mdg/Giftregistry/Model/Api/V2.php</code> and place the following placeholder content inside it:<div class="informalexample"><pre class="programlisting">&lt;?php
class Mdg_Giftregisty_Model_Api_V2 extends Mdg_Giftregisty_Model_Api
{

}</pre></div></li></ol></div><p>The first thing you might notice is that <code class="literal">V2.php</code> extends the API class that we just created. The only difference is that the <code class="literal">V2</code> class is used by the <code class="literal">SOAP_v2</code> protocol, while the regular API class is used for all other requests.</p><p>Let's update the API class<a id="id366" class="indexterm"/> with some working code located at <code class="literal">app/code/local/Mdg/Giftregistry/Model/Api.php</code>:</p><div class="informalexample"><pre class="programlisting">&lt;?php
class Mdg_Giftregisty_Model_Api extends Mage_Api_Model_Resource_Abstract
{
  public function getRegistryList($customerId = null)
  {
    $registryCollection = Mage::getModel('mdg_giftregistry/entity')-&gt;getCollection();
    if (!is_null($customerId)) {
      $registryCollection-&gt;addFieldToFilter('customer_id', $customerId);
    }
    return $registryCollection;
  }
  
  public function getRegistryInfo($registryId)
  {
    if (!is_null($registryId)) {
      $registry = Mage::getModel('mdg_giftregistry/entity') -&gt;load($registryId);
      if ($registry) {
        return $registry;
      } else {
        return false;
      }
    } else {
      return false;
    }
  }
  
  public function getRegistryItems($registryId)
  {
    if (!is_null($registryId)) {
      $registryItems = Mage::getModel('mdg_giftregistry/item') -&gt;getCollection();
      $registryItems-&gt;addFieldToFilter('registry_id', $registryId);
      Return $registryItems;
    } else {
      return false;
    }
  }
  
  public function getRegistryItemInfo($registryItemId)
  {
    if (!is_null($registryItemId)) {
      $registryItem = Mage::getModel('mdg_giftregistry/item') -&gt;load($registryItemId);
      if ($registryItem) {
        return $registryItem;
      } else {
        return false;
      }
    } else {
      return false;
    }
  }
}</pre></div><p>As we can see from the <a id="id367" class="indexterm"/>preceding code, we are not doing anything new. Each function is in charge of loading either a collection of Magento objects, or a specific object based on the required parameters.</p><p>In order to expose this new function to the Magento API, we need to configure the XML files we created previously. Let's<a id="id368" class="indexterm"/> start by updating <code class="literal">api.xml</code>:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Open the <code class="literal">api.xml</code> file.</li><li class="listitem">Add the following XML code to this file located at <code class="literal">app/code/local/Mdg/Giftregistry/etc/api.xml</code>:<div class="informalexample"><pre class="programlisting">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;config&gt;
  &lt;api&gt;
    &lt;resources&gt;
      &lt;giftregistry_registry translate="title" module="mdg_giftregistry"&gt;
        &lt;model&gt;mdg_giftregistry/api&lt;/model&gt;
        &lt;title&gt;Mdg Giftregistry Registry functions&lt;/title&gt;
        &lt;methods&gt;
          &lt;list translate="title" module="mdg_giftregistry"&gt;
            &lt;title&gt;getRegistryList&lt;/title&gt;
            &lt;method&gt;getRegistryList&lt;/method&gt;
          &lt;/list&gt;
          &lt;info translate="title" module="mdg_giftregistry"&gt;
            &lt;title&gt;getRegistryInfo&lt;/title&gt;
            &lt;method&gt;getRegistryInfo&lt;/method&gt;
          &lt;/info&gt;
        &lt;/methods&gt;
      &lt;/giftregistry_registry&gt;
      &lt;giftregistry_item translate="title" module="mdg_giftregistry"&gt;
        &lt;model&gt;mdg_giftregistry/api&lt;/model&gt;
        &lt;title&gt;Mdg Giftregistry Registry Items functions&lt;/title&gt;
        &lt;methods&gt;
          &lt;list translate="title" module="mdg_giftregistry"&gt;
            &lt;title&gt;getRegistryItems&lt;/title&gt;
            &lt;method&gt;getRegistryItems&lt;/method&gt;
          &lt;/list&gt;
          &lt;info translate="title" module="mdg_giftregistry"&gt;
            &lt;title&gt;getRegistryItemInfo&lt;/title&gt;
            &lt;method&gt;getRegistryItemInfo&lt;/method&gt;
          &lt;/info&gt;
        &lt;/methods&gt;
      &lt;/giftregistry_item&gt;
    &lt;/resources&gt;
    &lt;resources_alias&gt;
      giftregistry_registry&gt;giftregistry_registry &lt;/giftregistry_registry&gt;
      &lt;giftregistry_item&gt;giftregistry_item &lt;/giftregistry_item&gt;
    &lt;/resources_alias&gt;
    &lt;v2&gt;
      &lt;resources_function_prefix&gt;
        &lt;giftregistry_registry&gt;giftregistry_registry &lt;/giftregistry_registry&gt;
        &lt;giftregistry_item&gt;giftregistry_item &lt;/giftregistry_item&gt;
      &lt;/resources_function_prefix&gt;
    &lt;/v2&gt;
  &lt;/api&gt;
&lt;/config&gt;</pre></div></li></ol></div><p>There is one more file we <a id="id369" class="indexterm"/>need to update in order to make sure the SOAP adapters pick up our new API functions:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Open the <code class="literal">wsdl.xml</code> file.</li><li class="listitem">Since WSDL is normally very long in extend, we will break it down in several places. Let's start by defining the skeleton of the <code class="literal">wsdl.xml</code> file, located at <code class="literal">app/code/local/Mdg/Giftregistry/etc/wsdl.xml</code>:<div class="informalexample"><pre class="programlisting">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;definitions       name="{{var wsdl.name}}" targetNamespace="urn:{{var wsdl.name}}"&gt;
  &lt;types /&gt;
  &lt;message name="gitregistryRegistryListRequest" /&gt;
  &lt;portType name="{{var wsdl.handler}}PortType" /&gt;
  &lt;binding name="{{var wsdl.handler}}Binding" type="typens:{{var wsdl.handler}}PortType"&gt;
    &lt;soap:binding style="rpc" transport="http://schemas.xmlsoap.org/soap/http" /&gt;
  &lt;/binding&gt;
  &lt;service name="{{var wsdl.name}}Service"&gt;
    &lt;port name="{{var wsdl.handler}}Port" binding="typens:{{var wsdl.handler}}Binding"&gt;
      &lt;soap:address location="{{var wsdl.url}}" /&gt;
    &lt;/port&gt;
  &lt;/service&gt;
&lt;/definitions&gt;</pre></div></li><li class="listitem">This is the basic placeholder where we have all the main nodes that we defined at the <a id="id370" class="indexterm"/>beginning of the chapter. The first thing that we have to define is the custom data type that our API will use, located at <code class="literal">app/code/local/Mdg/Giftregistry/etc/wsdl.xml</code>:<div class="informalexample"><pre class="programlisting">…
&lt;schema  targetNamespace="urn:Magento"&gt;
  &lt;import namespace="http://schemas.xmlsoap.org/soap/encoding/" schemaLocation= "http://schemas.xmlsoap.org/soap/encoding/"/&gt;
  &lt;complexType name="giftRegistryEntity"&gt;
    &lt;all&gt;
      &lt;element name="entity_id" type="xsd:integer" minOccurs="0" /&gt;
      &lt;element name="customer_id" type="xsd:integer" minOccurs="0" /&gt;
      &lt;element name="type_id" type="xsd:integer" minOccurs="0" /&gt;
      &lt;element name="website_id" type="xsd:integer" minOccurs="0" /&gt;
      &lt;element name="event_date" type="xsd:string" minOccurs="0" /&gt;
      &lt;element name="event_country" type="xsd:string" minOccurs="0" /&gt;
      &lt;element name="event_location" type="xsd:string" minOccurs="0" /&gt;
    &lt;/all&gt;
  &lt;/complexType&gt;
  &lt;complexType name="giftRegistryEntityArray"&gt;
    &lt;complexContent&gt;
      &lt;restriction base="soapenc:Array"&gt;
        &lt;attribute ref="soapenc:arrayType" wsdl:arrayType="typens:giftRegistryEntity[]" /&gt;
      &lt;/restriction&gt;
    &lt;/complexContent&gt;
  &lt;/complexType&gt;
  &lt;complexType name="registryItemsEntity"&gt;
    &lt;all&gt;
      &lt;element name="item_id" type="xsd:integer" minOccurs="0" /&gt;
      &lt;element name="registry_id" type="xsd:integer" minOccurs="0" /&gt;
      &lt;element name="product_id" type="xsd:integer" minOccurs="0" /&gt;
    &lt;/all&gt;
  &lt;/complexType&gt;
  &lt;complexType name="registryItemsArray"&gt;
    &lt;complexContent&gt;
      &lt;restriction base="soapenc:Array"&gt;
        &lt;attribute ref="soapenc:arrayType" wsdl:arrayType="typens:registryItemsEntity[]" /&gt;
      &lt;/restriction&gt;
    &lt;/complexContent&gt;
  &lt;/complexType&gt;
&lt;/schema&gt;
…</pre></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note29"/>Note</h3><p>Complex data types allow us to map which attributes and objects are transmitted through the API.</p></div></div></li><li class="listitem">Messages allow us to<a id="id371" class="indexterm"/> define which of the complex types are transmitted on each API call request and response. Let's proceed by adding the respective messages in our <code class="literal">wsdl.xml</code> file located at <code class="literal">app/code/local/Mdg/Giftregistry/etc/wsdl.xml</code>:<div class="informalexample"><pre class="programlisting">…
&lt;message name="gitregistryRegistryListRequest"&gt;
  &lt;part name="sessionId" type="xsd:string" /&gt;
  &lt;part name="customerId" type="xsd:integer"/&gt;
&lt;/message&gt;
&lt;message name="gitregistryRegistryListResponse"&gt;
  &lt;part name="result" type="typens:giftRegistryEntityArray" /&gt;
&lt;/message&gt;
&lt;message name="gitregistryRegistryInfoRequest"&gt;
  &lt;part name="sessionId" type="xsd:string" /&gt;
  &lt;part name="registryId" type="xsd:integer"/&gt;
&lt;/message&gt;
&lt;message name="gitregistryRegistryInfoResponse"&gt;
  &lt;part name="result" type="typens:giftRegistryEntity" /&gt;
&lt;/message&gt;
&lt;message name="gitregistryItemListRequest"&gt;
  &lt;part name="sessionId" type="xsd:string" /&gt;
  &lt;part name="registryId" type="xsd:integer"/&gt;
&lt;/message&gt;
&lt;message name="gitregistryItemListResponse"&gt;
  &lt;part name="result" type="typens:registryItemsArray" /&gt;
&lt;/message&gt;
&lt;message name="gitregistryItemInfoRequest"&gt;
  &lt;part name="sessionId" type="xsd:string" /&gt;
  &lt;part name="registryItemId" type="xsd:integer"/&gt;
&lt;/message&gt;
&lt;message name="gitregistryItemInfoResponse"&gt;
  &lt;part name="result" type="typens:registryItemsEntity"/&gt;
&lt;/message&gt;
…</pre></div></li><li class="listitem">One important thing<a id="id372" class="indexterm"/> to notice is that each request message will always include a <code class="literal">sessionId</code> that is used to validate and authenticate each request. On the other hand, the response is used to specify which complex data types or values are returned. Adding the respective messages in our <code class="literal">wsdl.xml</code> file located at <code class="literal">app/code/local/Mdg/Giftregistry/etc/wsdl.xml</code>:<div class="informalexample"><pre class="programlisting">…
&lt;portType name="{{var wsdl.handler}}PortType"&gt;
  &lt;operation name="giftregistryRegistryList"&gt;
    &lt;documentation&gt;Get Registries List&lt;/documentation&gt;
    &lt;input message="typens:gitregistryRegistryListRequest" /&gt;
    &lt;output message="typens:gitregistryRegistryListResponse" /&gt;
  &lt;/operation&gt;
  &lt;operation name="giftregistryRegistryInfo"&gt;
    &lt;documentation&gt;Get Registry Info&lt;/documentation&gt;
    &lt;input message="typens:gitregistryRegistryInfoRequest" /&gt;
    &lt;output message="typens:gitregistryRegistryInfoResponse" /&gt;
  &lt;/operation&gt;
  &lt;operation name="giftregistryItemList"&gt;
    &lt;documentation&gt;getAllProductsInfo&lt;/documentation&gt;
    &lt;input message="typens:gitregistryItemListRequest" /&gt;
    &lt;output message="typens:gitregistryItemListResponse" /&gt;
  &lt;/operation&gt;
  &lt;operation name="giftregistryItemInfo"&gt;
    &lt;documentation&gt;getAllProductsInfo&lt;/documentation&gt;
    &lt;input message="typens:gitregistryItemInfoRequest" /&gt;
    &lt;output message="typens:gitregistryItemInfoResponse" /&gt;
  &lt;/operation&gt;
&lt;/portType&gt;
…</pre></div></li><li class="listitem">The next thing that is required to properly add a new API endpoint is to define the bindings, which <a id="id373" class="indexterm"/>are used to specify the methods that are exposed. Adding the respective messages in our <code class="literal">wsdl.xml</code> file located at <code class="literal">app/code/local/Mdg/Giftregistry/etc/wsdl.xml</code>:<div class="informalexample"><pre class="programlisting">…
&lt;operation name="giftregistryRegistryList"&gt;
  &lt;soap:operation soapAction="urn:{{var wsdl.handler}}Action" /&gt;
  &lt;input&gt;
    &lt;soap:body namespace="urn:{{var wsdl.name}}" use="encoded" encodingStyle= "http://schemas.xmlsoap.org/soap/encoding/" /&gt;
  &lt;/input&gt;
  &lt;output&gt;
    &lt;soap:body namespace="urn:{{var wsdl.name}}" use="encoded" encodingStyle= "http://schemas.xmlsoap.org/soap/encoding/" /&gt;
  &lt;/output&gt;
&lt;/operation&gt;
&lt;operation name="giftregistryRegistryInfo"&gt;
  &lt;soap:operation soapAction="urn:{{var wsdl.handler}}Action" /&gt;
  &lt;input&gt;
    &lt;soap:body namespace="urn:{{var wsdl.name}}" use="encoded" encodingStyle= "http://schemas.xmlsoap.org/soap/encoding/" /&gt;
  &lt;/input&gt;
  &lt;output&gt;
    &lt;soap:body namespace="urn:{{var wsdl.name}}" use="encoded" encodingStyle= "http://schemas.xmlsoap.org/soap/encoding/" /&gt;
  &lt;/output&gt;
&lt;/operation&gt;
&lt;operation name="giftregistryItemList"&gt;
  &lt;soap:operation soapAction="urn:{{var wsdl.handler}}Action" /&gt;
  &lt;input&gt;
    &lt;soap:body namespace="urn:{{var wsdl.name}}" use="encoded" encodingStyle= "http://schemas.xmlsoap.org/soap/encoding/" /&gt;
  &lt;/input&gt;
  &lt;output&gt;
    &lt;soap:body namespace="urn:{{var wsdl.name}}" use="encoded" encodingStyle= "http://schemas.xmlsoap.org/soap/encoding/" /&gt;
  &lt;/output&gt;
&lt;/operation&gt;
&lt;operation name="giftregistryInfoList"&gt;
  &lt;soap:operation soapAction="urn:{{var wsdl.handler}}Action" /&gt;
  &lt;input&gt;
    &lt;soap:body namespace="urn:{{var wsdl.name}}" use="encoded" encodingStyle= "http://schemas.xmlsoap.org/soap/encoding/" /&gt;
  &lt;/input&gt;
  &lt;output&gt;
    &lt;soap:body namespace="urn:{{var wsdl.name}}" use="encoded" encodingStyle= "http://schemas.xmlsoap.org/soap/encoding/" /&gt;
  &lt;/output&gt;
&lt;/operation&gt;
…</pre></div></li></ol></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note30"/>Note</h3><p>You can see the<a id="id374" class="indexterm"/> complete <code class="literal">wsdl.xml</code> in one piece at <a class="ulink" href="http://magedevguide.com/chapter6/wsdl">http://magedevguide.com/chapter6/wsdl</a>.</p></div></div><p>Even after we broke it down, the WSDL code can still seem overwhelming. To be honest, it took me some time to get used to such a massive XML file, so let's review what each section does:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">types</code>: These are used to describe the data transmitted with the API; types are defined using XML Schema, a special language for this purpose</li><li class="listitem" style="list-style-type: disc"><code class="literal">message</code>: This is used to specify the information needed to perform each operation; in the case of Magento, our API methods will always use a request and respond message</li><li class="listitem" style="list-style-type: disc"><code class="literal">portType</code>: This is used to define the operations that can be performed and the corresponding messages</li><li class="listitem" style="list-style-type: disc"><code class="literal">port</code>: This is used to define the connection point; in the case of Magento, a simple string is used</li><li class="listitem" style="list-style-type: disc"><code class="literal">service</code>: This is used to specify which functions are exposed through the API</li><li class="listitem" style="list-style-type: disc"><code class="literal">bindings</code>: These <a id="id375" class="indexterm"/>are used to define the operations and the interface with the SOAP protocol</li></ul></div><div class="section" title="Extending the REST API"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec54"/>Extending the REST API</h2></div></div></div><p>So far, we have only worked on extending the SOAP and XML-RPC parts of the API; the process involved in extending the RESTful API is slightly different.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note31"/>Note</h3><p>The REST API was introduced with Magento Community Edition 1.7 and Enterprise Edition 1.12.</p></div></div><p>In order to expose the new API<a id="id376" class="indexterm"/> methods to the REST API, we need to create a new file called <code class="literal">api2.xml</code>; the configuration in this file is a little more complex than the normal <code class="literal">api.xml</code>, so we will break it down after adding the full code:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Create a new file called <code class="literal">api2.xml</code> under the <code class="literal">etc/</code> folder.</li><li class="listitem">Open <code class="literal">api2.xml</code>.</li><li class="listitem">Copy the following code in <code class="literal">api2.xml</code> located at <code class="literal">app/code/local/Mdg/Giftregistry/etc/api2.xml</code>:<div class="informalexample"><pre class="programlisting">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;config&gt;
  &lt;api2&gt;
    &lt;resource_groups&gt;
      &lt;giftregistry translate="title" module="mdg_giftregistry"&gt;
        &lt;title&gt;MDG GiftRegistry API calls&lt;/title&gt;
        &lt;sort_order&gt;30&lt;/sort_order&gt;
        &lt;children&gt;
          &lt;giftregistry_registry translate="title" module="mdg_giftregistry"&gt;
            &lt;title&gt;Gift Registries&lt;/title&gt;
            &lt;sort_order&gt;50&lt;/sort_order&gt;
          &lt;/giftregistry_registry&gt;
          &lt;giftregistry_item translate="title" module="mdg_giftregistry"&gt;
            &lt;title&gt;Gift Registry Items&lt;/title&gt;
            &lt;sort_order&gt;50&lt;/sort_order&gt;
          &lt;/giftregistry_item&gt;
        &lt;/children&gt;
      &lt;/giftregistry&gt;
    &lt;/resource_groups&gt;
    &lt;resources&gt;
      &lt;giftregistryregistry translate="title" module="mdg_giftregistry"&gt;
        &lt;group&gt;giftregistry_registry&lt;/group&gt;
        &lt;model&gt;mdg_giftregistry/api_registry&lt;/model&gt;
        &lt;working_model&gt;mdg_giftregistry/api_registry &lt;/working_model&gt;
        &lt;title&gt;Gift Registry&lt;/title&gt;
        &lt;sort_order&gt;10&lt;/sort_order&gt;
        &lt;privileges&gt;
          &lt;admin&gt;
            &lt;create&gt;1&lt;/create&gt;
            &lt;retrieve&gt;1&lt;/retrieve&gt;
            &lt;update&gt;1&lt;/update&gt;
            &lt;delete&gt;1&lt;/delete&gt;
          &lt;/admin&gt;
        &lt;/privileges&gt;
        &lt;attributes translate="product_count" module="mdg_giftregistry"&gt;
          &lt;registry_list&gt;Registry List&lt;/registry_list&gt;
          &lt;registry&gt;Registry&lt;/registry&gt;
          &lt;item_list&gt;Item List&lt;/item_list&gt;
          &lt;item&gt;Item&lt;/item&gt;
        &lt;/attributes&gt;
        &lt;entity_only_attributes /&gt;
        &lt;exclude_attributes /&gt;
        &lt;routes&gt;
          &lt;route_registry_list&gt;
            &lt;route&gt;/mdg/registry/list&lt;/route&gt;
            &lt;action_type&gt;collection&lt;/action_type&gt;
          &lt;/route_registry_list&gt;
          &lt;route_registry_entity&gt;
            &lt;route&gt;/mdg/registry/:registry_id&lt;/route&gt;
            &lt;action_type&gt;entity&lt;/action_type&gt;
          &lt;/route_registry_entity&gt;
          &lt;route_registry_list&gt;
            &lt;route&gt;/mdg/registry_item/list&lt;/route&gt;
            &lt;action_type&gt;collection&lt;/action_type&gt;
          &lt;/route_registry_list&gt;
          &lt;route_registry_list&gt;
            &lt;route&gt;/mdg/registry_item/:item_id&lt;/route&gt;
            &lt;action_type&gt;entity&lt;/action_type&gt;
          &lt;/route_registry_list&gt;
        &lt;/routes&gt;
        &lt;versions&gt;1&lt;/versions&gt;
      &lt;/giftregistryregistry&gt;
    &lt;/resources&gt;
  &lt;/api2&gt;
&lt;/config&gt;</pre></div></li></ol></div><p>One important thing to notice is that we are defining a route node inside this configuration file. This is treated by <a id="id377" class="indexterm"/>Magento as a frontend route, and is used to access the RESTful API function. Also, notice that we don't need to create a new controller for this to work.</p><p>Now, we also need to include a new class to handle the REST requests and implement each of the defined privileges:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Create a new class called <code class="literal">V1.php</code> under <code class="literal">Model/Api/Registry/Rest/Admin</code>.</li><li class="listitem">Open the <code class="literal">V1.php</code> class located at <code class="literal">app/code/local/Mdg/Giftregistry/Model/Api/Registry/Rest/Admin/V1.php</code> and copy the following code:<div class="informalexample"><pre class="programlisting">&lt;?php

class Mdg_Giftregistry_Model_Api_Registry_Rest_Admin_V1 extends Mage_Catalog_Model_Api2_Product_Rest
{
  /**
  * @return stdClass
   */
  protected function _retrieve()
  {
    $registryCollection = Mage::getModel('mdg_giftregistry/entity')-&gt;getCollection();
    return $registryCollection;
  }
}</pre></div></li></ol></div></div></div>
<div class="section" title="Securing the API"><div class="titlepage"><div><div><h1 class="title"><a id="ch05lvl1sec38"/>Securing the API</h1></div></div></div><p>Securing our API is already part of the process of creating our module, and is also handled by the configuration. The way Magento restrict access to their API is using ACL.</p><p>As we learned earlier, these <a id="id378" class="indexterm"/>ACL allows us to set up roles with access to different parts of the API. Now what we have to do is make our new custom functions available to the ACL:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Open the <code class="literal">api.xml</code> file.</li><li class="listitem">Add the following code after the <code class="literal">&lt;/v2&gt;</code> node located at <code class="literal">app/code/local/Mdg/Giftregistry/etc/api.xml</code>:<div class="informalexample"><pre class="programlisting">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;acl&gt;
  &lt;resources&gt;
    &lt;giftregistry translate="title" module="mdg_giftregistry"&gt;
      &lt;title&gt;MDG Gift Registry&lt;/title&gt;
      &lt;sort_order&gt;1&lt;/sort_order&gt;
      &lt;registry translate="title" module="mdg_giftregistry"&gt;
        &lt;title&gt;MDG Gift Registry&lt;/title&gt;
        &lt;list translate="title" module="mdg_giftregistry"&gt;
          &lt;title&gt;List Available Registries&lt;/title&gt;
        &lt;/list&gt;
        &lt;info translate="title" module="mdg_giftregistry"&gt;
          &lt;title&gt;Retrieve registry data&lt;/title&gt;
        &lt;/info&gt;
      &lt;/registry&gt;
      &lt;item translate="title" module="mdg_giftregistry"&gt;
        &lt;title&gt;MDG Gift Registry Item&lt;/title&gt;
        &lt;list translate="title" module="mdg_giftregistry"&gt;
          &lt;title&gt;List Available Items inside a registry&lt;/title&gt;
        &lt;/list&gt;
        &lt;info translate="title" module="mdg_giftregistry"&gt;
          &lt;title&gt;Retrieve registry item data&lt;/title&gt;
        &lt;/info&gt;
      &lt;/item&gt;
    &lt;/giftregistry&gt;
  &lt;/resources&gt;
&lt;/acl&gt;</pre></div></li></ol></div></div>
<div class="section" title="Summary"><div class="titlepage"><div><div><h1 class="title"><a id="ch05lvl1sec39"/>Summary</h1></div></div></div><p>While we learned how to extend Magento to add new functionalities to both store owners and customers in previous chapters, knowing how to extend and work with the Magento API opens a world of possibilities.</p><p>Using the API, we can integrate Magento with third-party systems, such as ERP and <span class="strong"><strong>Point of Sale</strong></span> (<span class="strong"><strong>POS</strong></span>) both by importing and exporting data.</p><p>In the next chapter, we will learn how to properly build a test for all the code we have been building so far, and we will also explore multiple testing frameworks.</p></div></body></html>