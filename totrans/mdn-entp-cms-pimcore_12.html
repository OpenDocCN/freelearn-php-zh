<html><head></head><body>
		<div id="_idContainer194">
			<h1 id="_idParaDest-210"><em class="italic"><a id="_idTextAnchor211"/>Chapter 12</em>: Implementing Product Information Management</h1>
			<p>In previous chapters, you learned about s<a id="_idTextAnchor212"/>ome key features of the Pimcore environment presented in <a href="B17073_01_ePub_RK.xhtml#_idTextAnchor014"><em class="italic">Chapter 1</em></a>,<em class="italic"> Introducing Pimcore</em>. In particular, in <a href="B17073_06_ePub_RK.xhtml#_idTextAnchor112"><em class="italic">Chapter 6</em></a>, <em class="italic">Using Digital Asset Management</em>, you discovered the Pimcore <strong class="bold">Digital Asset Management</strong> (<strong class="bold">DAM</strong>) feature and all aspects related to images and asset management. Then, in <a href="B17073_04_ePub_RK.xhtml#_idTextAnchor083"><em class="italic">Chapter 4</em></a>, <em class="italic">Creating Documents in Pimcore</em>, and in <a href="B17073_08_ePub_RK.xhtml#_idTextAnchor139"><em class="italic">Chapter 8</em></a>, <em class="italic">Creating Custom CMS Pages</em>, you learned about the concept of <strong class="bold">content management systems</strong> (<strong class="bold">CMSes</strong>) and how to create documents and site pages.</p>
			<p>In this chapter, we will go in-depth through the concept of <strong class="bold">Product Information Management</strong> (<strong class="bold">PIM</strong>), putting into practice the concepts of Pimcore classes learned in <a href="B17073_05_ePub_RK.xhtml#_idTextAnchor093"><em class="italic">Chapter 5</em></a>, <em class="italic">Exploring Objects and Classes,</em> to define a <strong class="source-inline">Product</strong> entity. The chapter is organized as follows:</p>
			<ul>
				<li>What is a PIM?</li>
				<li>Defining the <strong class="source-inline">Product</strong> entity</li>
				<li>Creating Product Variants</li>
				<li>Creating a Bundle Product</li>
				<li>Managing different Product Types</li>
				<li>Working with Workflows</li>
			</ul>
			<p>Starting with the explanation of what a PIM system is, we will implement an example of a <strong class="source-inline">Product</strong> class. After having defined the class attributes, you will learn how to create product variants and bundle products, and how to manage different product types using Objectbricks. In the last section of the chapter, you will learn how to define a workflow to fill in the product information step by step.</p>
			<h1 id="_idParaDest-211"><a id="_idTextAnchor213"/>Technical requirements</h1>
			<p>As you have done in previous chapters, all you need to do is run the demo connected to this chapter by navigating to the <strong class="source-inline">12.</strong> <strong class="source-inline">Implementing</strong> <strong class="source-inline">Product</strong> <strong class="source-inline">Information</strong> <strong class="source-inline">Management</strong> folder of the official book repository and start a Docker environment.</p>
			<p>To do so, just follow these instructions:</p>
			<ol>
				<li>Run Docker with the following command:<p class="source-code"><strong class="bold">docker-compose up</strong></p></li>
				<li>Then, to restore all the settings on your local machine, just open a new shell and type the following command:<p class="source-code"><strong class="bold">docker-compose exec php bash restore.sh</strong></p></li>
				<li>Navigate to <a href="http://localhost/admin">http://localhost/admin</a> and log in with your admin/pimcore credentials.</li>
			</ol>
			<p>You can access the official book repository to get the source code through the following link: </p>
			<p><a href="https://github.com/PacktPublishing/Modernizing-Enterprise-CMS-using-Pimcore/tree/main/12.%20Implementing%20Product%20Information%20Management">https://github.com/PacktPublishing/Modernizing-Enterprise-CMS-using-Pimcore/tree/main/12.%20Implementing%20Product%20Information%20Management</a></p>
			<p>Now you are ready to navigate through the demo to discover all the aspects related to this chapter.</p>
			<h1 id="_idParaDest-212"><a id="_idTextAnchor214"/>What is a PIM?</h1>
			<p>In <a href="B17073_01_ePub_RK.xhtml#_idTextAnchor014"><em class="italic">Chapter 1</em></a>, <em class="italic">Introducing Pimcore</em>, we briefly introduced the concept of <strong class="bold">Product Information Management (PIM)</strong>. In this section, we will better explain this concept, which we will put into practice throughout the following sections of this chapter.</p>
			<p>The concept of PIM encompasses<a id="_idIndexMarker766"/> a set of technologies and procedures that allow centralized management of product data and their distribution across different channels. In many common scenarios, information relating to products may come from multiple sources, potentially with different data structures, both due to different needs dictated by their distribution channels and through the provision of different technologies in distinct areas within the same company.</p>
			<p>The use of a PIM allows you to integrate information from different sources into a single platform and organize it all coherently, with the possibility of redistributing this information in different ways to e-commerce platforms, websites, paper catalogs, and so on. It also allows complete and dynamic management of the product data, including customizing and filtering information related to different types of products to manage prices and currencies, different<a id="_idIndexMarker767"/> units of measurement, multilingual translations, multimedia content, and much more. </p>
			<p>The ability to centralize all this information in a single platform allows you to manage products completely independently of any distribution channel; the PIM will be responsible for sending only the information it needs to each channel. This centralized management gives consistency to product information, avoiding the need to replicate data in different platforms and keeping them aligned, reducing design errors. This also brings benefits in terms of the management cost of any catalogs, price lists, and online platforms.</p>
			<p>The use of a PIM is essential for companies that need to sell or present their products in different platforms and media, but also for business scenarios in which it is necessary to share information relating to products in different departments or development areas, always keeping the production of such information centralized. The need to have a PIM increases even more as the number of products to manage increases, as the cost of managing and maintaining data is drastically reduced, limiting it to a single platform.</p>
			<p>PIM technologies also make it possible to integrate information relating to products alongside them with the management of multimedia content associated with them and to send such content to the various distribution channels.</p>
			<p>All these aspects regarding the concept of PIM and its usages are summarized in the following diagram:</p>
			<div>
				<div id="_idContainer176" class="IMG---Figure">
					<img src="image/Figure_12.01_B17073.jpg" alt="Figure 12.1: PIM Architecture&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 12.1: PIM Architecture</p>
			<p>As you can see in the previous diagram, products can be imported into a PIM system by uploading files or implementing specific flows to establish an integration with other software or databases. Products can also be created and enriched directly in the PIM environment<a id="_idIndexMarker768"/>, through<a id="_idIndexMarker769"/> the <strong class="bold">graphical user interface</strong> (<strong class="bold">GUI</strong>).</p>
			<p>Product data can then be exported to e-commerce or other software, or properly exported to files. In <a href="B17073_14_ePub_RK.xhtml#_idTextAnchor243"><em class="italic">Chapter 14</em></a>, <em class="italic">Data Integration</em>, you will learn different ways to import and export products in Pimcore.</p>
			<p>To summarize, in this section, you learned about the concept of PIM and the benefits that a PIM system brings as regards to product data management and distribution. In the following section, we will build a <strong class="source-inline">Product</strong> entity step by step, defining a Pimcore class that will represent the product concept.</p>
			<h1 id="_idParaDest-213"><a id="_idTextAnchor215"/>Defining the Product Entity</h1>
			<p>In the previous section, you learned about the concept of Product Information Management<a id="_idIndexMarker770"/>. As the name suggests, in a PIM system, it's mandatory to create a class that represents the products, and this is what we are going to do in this section.</p>
			<p>Pimcore does not set any constraints as far as the concept of products is concerned, so we can simply create a class named <strong class="source-inline">Product</strong> and define all the attributes that reflect our needs. So, as you learned in <a href="B17073_05_ePub_RK.xhtml#_idTextAnchor093"><em class="italic">Chapter 5</em></a>, <em class="italic">Exploring Objects and Classes</em>, just go through <strong class="bold">Settings </strong>|<strong class="bold"> Data Objects </strong>|<strong class="bold"> Classes</strong>, and create a new class named <strong class="source-inline">Product</strong>.</p>
			<p>If you followed the instructions provided in the <em class="italic">Technical requirements</em> section, you should find an already defined<a id="_idIndexMarker771"/> <strong class="source-inline">Product</strong> class. Please note that this is just a typical example of the concept of a product and that you can add or remove class attributes according to your needs. You can see what this class looks like in the following screenshot:</p>
			<div>
				<div id="_idContainer177" class="IMG---Figure">
					<img src="image/Figure_12.02_B17073.jpg" alt="Figure 12.2: Product class&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 12.2: Product class</p>
			<p>Let's describe the various class components that are shown in the previous screenshot. The class is composed of five panels that enclose different attributes representing common concepts for products, and these are outlined here:</p>
			<ul>
				<li><strong class="bold">Product Information</strong>: In this panel, you can find the <strong class="bold">Stock-Keeping Unit</strong> (<strong class="bold">SKU</strong>)<a id="_idIndexMarker772"/>, which is a unique identifier for products and the product price. Then, we added the product name and description as localized fields so that you can provide translations.</li>
				<li><strong class="bold">Categorization</strong>: In this panel, you can see some attributes defined to categorize the product. The <strong class="source-inline">brand</strong> attribute is a custom-defined single select field with common brands as options; there's also a predefined options list to choose the country where the product was made. The last attribute is a many-to-one relation with another class added to describe categories.</li>
				<li><strong class="bold">Composition</strong>: In this panel<a id="_idIndexMarker773"/>, you can find an advanced many-to-many relation component to relate the product to the materials that compose the product. In this relation, you can set the percentage of the various materials to define the composition.</li>
				<li><strong class="bold">Attributes</strong>: In this panel, we have defined attributes that can be used to represent the product variants, such as <strong class="source-inline">color</strong> and <strong class="source-inline">size</strong>. For the <strong class="source-inline">color</strong> attribute, we have defined a relationship with a dedicated class.</li>
				<li><strong class="bold">Images</strong>: As the name suggests, this panel is designed to contain the product images. In particular, we used a <strong class="bold">Fieldcollection</strong> to administer an undefined number of images.</li>
			</ul>
			<p>For the sake of completeness, in the following screenshot, you will see the other class definitions:</p>
			<div>
				<div id="_idContainer178" class="IMG---Figure">
					<img src="image/Figure_12.03_B17073.jpg" alt="Figure 12.3: Class definitions&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 12.3: Class definitions</p>
			<p>In the previous screenshot, you can see the definitions for the <strong class="source-inline">Category</strong>, <strong class="source-inline">Material</strong>, and <strong class="source-inline">Color</strong> classes. For the <strong class="source-inline">Category</strong> class, we have defined a unique <strong class="source-inline">code</strong> attribute and a couple of localized fields, called <strong class="source-inline">name</strong> and <strong class="source-inline">description</strong>. The same structure is made for the <strong class="source-inline">Material</strong> class, with the addition of another field to define the material typology. For the <strong class="source-inline">Color</strong> class, an attribute<a id="_idIndexMarker774"/> to set the <strong class="bold">hexadecimal</strong> (<strong class="bold">hex</strong>) value was added.</p>
			<p>As previously mentioned, you should already find these classes after the installation process described in the <em class="italic">Technical requirements</em> section of this chapter, but you can import them at any time by selecting the files<a id="_idIndexMarker775"/> that you can find in the <strong class="source-inline">src/classes</strong> folder of the chapter repository, as you have seen in <a href="B17073_07_ePub_RK.xhtml#_idTextAnchor129"><em class="italic">Chapter 7</em></a>,<em class="italic"> Administrating Pimcore Sites</em>.</p>
			<p>As you have learned in <a href="B17073_05_ePub_RK.xhtml#_idTextAnchor093"><em class="italic">Chapter 5</em></a>, <em class="italic">Exploring Objects and Classes</em>, you can easily perform data entry to create products and other entities. In the following screenshot, you can see an example of a created product:</p>
			<div>
				<div id="_idContainer179" class="IMG---Figure">
					<img src="image/Figure_12.04_B17073.jpg" alt="Figure 12.4: Product entity&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 12.4: Product entity</p>
			<p>As you can see in the previous screenshot, the structure of the created product reflects the class definition. To better organize the contents, objects of the various classes are divided into the corresponding subfolders.</p>
			<p>To summarize, in this section, we have seen how to define a <strong class="source-inline">Product</strong> entity. We have presented a possible implementation of the product concept, but this concept has no fixed definition in terms of attributes, so you can choose to create attributes that better reflect your needs. Beside from this, we have defined other secondary classes to relate the products to other concepts such as categories, materials, and colors. This is useful for keeping this information<a id="_idIndexMarker776"/> linked to a product without the need to replicate them in all products.</p>
			<p>In the following section, you will learn how to create product variants in order to create configurable products.</p>
			<h1 id="_idParaDest-214"><a id="_idTextAnchor216"/>Creating product variants</h1>
			<p>In the previous section, you have seen how to define a <strong class="source-inline">Product</strong> entity and an example of product object creation. In this section, you will learn how to enable the inheritance for the <strong class="source-inline">Product</strong> class<a id="_idIndexMarker777"/> to create product variants and define configurable products. Later in this section, we will see some <strong class="bold">PHP: Hypertext Preprocessor</strong> (<strong class="bold">PHP</strong>) code examples that will show how to practically use<a id="_idIndexMarker778"/> variants during development.</p>
			<p>To enable inheritance for the <strong class="source-inline">Product</strong> class, open the class definition and select the <strong class="bold">General Settings</strong> root element. You can enable class inheritance and allow the variants' creation by selecting the checkboxes that you see in the following screenshot:</p>
			<div>
				<div id="_idContainer180" class="IMG---Figure">
					<img src="image/Figure_12.05_B17073.jpg" alt="Figure 12.5: Enabling inheritance&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 12.5: Enabling inheritance</p>
			<p>As you can see in the previous screenshot, three checkboxes can be enabled, as follows:</p>
			<ul>
				<li><strong class="bold">Allow inheritance</strong>: If checked, this property enables inheritance among objects in a tree-structured way. The child objects can be instances of the same class or may belong to a different class.</li>
				<li><strong class="bold">Allow variants</strong>: If checked, this enables the possibility to create object variants. The variant definition is a particular kind of inheritance. The variant class cannot be chosen, but the class is forced to be the same as the parent object.  </li>
				<li><strong class="bold">Show variants in tree</strong>: If enabled, this property allows you to see the variants in the object tree.</li>
			</ul>
			<p>Once you have enabled these checkboxes<a id="_idIndexMarker779"/>, you must click on the <strong class="bold">Save</strong> button to apply the changes. After having enabled variants for the class, variants can be created for products. To create a variant, just right-click on a previously created product, select <strong class="bold">Add Variant</strong>, and type the variant name.</p>
			<p>In the following screenshot, you will see an example of a configurable product with variants defined:</p>
			<div>
				<div id="_idContainer181" class="IMG---Figure">
					<img src="image/Figure_12.06_B17073.jpg" alt="Figure 12.6: Product variant example&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 12.6: Product variant example</p>
			<p>As you can see in the previous screenshot, enabling the corresponding property lets the product variants be shown in the object tree. You can recognize product variants by the different specific icons in the tree structure.</p>
			<p>The variants inherit all property values from the parent, but it's possible to override those properties in each variant<a id="_idIndexMarker780"/>. In this specific example, we have used the <strong class="source-inline">Color</strong><strong class="bold"> </strong>attribute to create a configurable product with different variants.</p>
			<p>Now that you have learned how to create product variants in the Pimcore interface, let's see how to practically use variants in code, looking at some coding examples.</p>
			<p>A key aspect concerning variants is the object <strong class="bold">type</strong>. This is a system property defined for objects of all classes; this property cannot be filled manually, but it's automatically defined when we create an element. There are three different object types<a id="_idIndexMarker781"/>, outlined as follows:</p>
			<ul>
				<li><strong class="source-inline">folder</strong>: This type is assigned when we create a folder in the <strong class="bold">Data Objects</strong> section.</li>
				<li><strong class="source-inline">object</strong>: This type is assigned when we create an object instance of a class.</li>
				<li><strong class="source-inline">variant</strong>: This type is assigned when we create an object variant.</li>
			</ul>
			<p>When coding in Pimcore, it's important to know that all native methods that perform searches for lists of objects always consider only <strong class="source-inline">folder</strong> and <strong class="source-inline">object</strong> types, so it's necessary to explicitly specify that you want to retrieve variants. Through the following examples, we will see how to do this.</p>
			<h2 id="_idParaDest-215"><a id="_idTextAnchor217"/>Parent PHP class</h2>
			<p>In this first example, you will learn how to create a parent PHP class<a id="_idIndexMarker782"/> for the <strong class="source-inline">Product </strong>class and how to create a method to retrieve the product<a id="_idIndexMarker783"/> variants. The creation of this class is not strictly related to the concept of variants, but it's a feature that is worth discovering and that can be useful in different scenarios.</p>
			<p>As we briefly introduced in the <em class="italic">Creating and Editing a Class Definition</em> section of <a href="B17073_05_ePub_RK.xhtml#_idTextAnchor093"><em class="italic">Chapter 5</em></a>, <em class="italic">Exploring Objects and Classes</em>, for each class, there is the possibility of defining a custom parent PHP class. This can be any PHP class that directly or indirectly extends the <strong class="source-inline">Pimcore\Model\DataObject\Concrete</strong> class.</p>
			<p>The <strong class="source-inline">Concrete</strong> class is a PHP class that is originally extended by all Pimcore classes and that contains all the common methods for all the classes, such as the <strong class="source-inline">save</strong> and <strong class="source-inline">getById</strong> operations, to cite a couple of them.</p>
			<p>In the following code snippet, you will see an example <strong class="source-inline">product</strong> parent class with a defined method to retrieve product<a id="_idIndexMarker784"/> variants:</p>
			<p class="source-code">&lt;?php</p>
			<p class="source-code">namespace App\Model;</p>
			<p class="source-code">use Pimcore\Model\DataObject;</p>
			<p class="source-code">class AbstractProduct extends DataObject\Concrete</p>
			<p class="source-code">{</p>
			<p class="source-code">    /**</p>
			<p class="source-code">     * @return self[]</p>
			<p class="source-code">     */</p>
			<p class="source-code">    public function getVariants(){</p>
			<p class="source-code">        $variantType = self::OBJECT_TYPE_VARIANT; //variant</p>
			<p class="source-code">        $variants = $this-&gt;getChildren(array($variantType));</p>
			<p class="source-code">        return $variants;</p>
			<p class="source-code">    }</p>
			<p class="source-code">}</p>
			<p>As you can see in the previous code snippet, this class extends the previously mentioned <strong class="source-inline">Concrete</strong> class. In this class, we have created a <strong class="source-inline">getVariants</strong> method that invokes the original <strong class="source-inline">getChildren</strong> method, specifying the need to retrieve objects of the type <strong class="source-inline">variant</strong>. This is necessary because, as we said in the previous section, all listing methods consider only objects<a id="_idIndexMarker785"/> and folders if no types are directly specified. </p>
			<p>Once the PHP class is created, we must properly set the corresponding property in the <strong class="source-inline">Product</strong> class, as you can see in the following screenshot:</p>
			<div>
				<div id="_idContainer182" class="IMG---Figure">
					<img src="image/Figure_12.07_B17073.jpg" alt="Figure 12.7: Configuring the parent PHP class&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 12.7: Configuring the parent PHP class</p>
			<p>As you can see in the previous screenshot, you may write the complete class namespace in the <strong class="bold">Parent PHP Class</strong> input<a id="_idIndexMarker786"/>. Once you have filled that in, you must click on the <strong class="bold">Save</strong> button to apply the changes.</p>
			<p>After having defined the parent PHP class, you can call the <strong class="source-inline">getVariants</strong> method for each product object instance<a id="_idIndexMarker787"/>, as you can see in the following code snippet:</p>
			<p class="source-code">&lt;?php</p>
			<p class="source-code">    use Pimcore\Model\DataObject;</p>
			<p class="source-code">    $product = DataObject\Product::getById(1);</p>
			<p class="source-code">    $variants = $product-&gt;getVariants();</p>
			<p class="source-code">?&gt;</p>
			<p>In the previous code snippet, you can see that since the <strong class="source-inline">Product</strong> class extends the previously created <strong class="source-inline">AbstractProduct</strong> class, every product object can use the defined <strong class="source-inline">getVariants</strong> method.</p>
			<p>The <strong class="source-inline">getChildre</strong>n method that we have seen in this example is just one particular case of object listing. In the following example, we will see how to retrieve variants in common listing methods.</p>
			<h2 id="_idParaDest-216"><a id="_idTextAnchor218"/>Object Listing</h2>
			<p>In the previous example, we have seen how to retrieve the variants of a specific product, using the methods that retrieve the product children. In this example, we will see how to retrieve variants in generic listing methods.</p>
			<p>In the following code snippet, you can see how product variants can be retrieved<a id="_idIndexMarker788"/> on listing queries:</p>
			<p class="source-code">&lt;?php</p>
			<p class="source-code">    use Pimcore\Model\DataObject\Product;</p>
			<p class="source-code">    use Pimcore\Model\DataObject\AbstractObject;</p>
			<p class="source-code">    $list = new Product\Listing();</p>
			<p class="source-code">    $list-&gt;setObjectTypes([AbstractObject::OBJECT_TYPE_    VARIANT]);</p>
			<p class="source-code">    $variants = $list-&gt;load();</p>
			<p class="source-code">?&gt;</p>
			<p>In the previous code snippet, you can see how to initialize a product listing. For listing objects, there is a specific method to set the object types that you want to retrieve. This method is the one that is used internally by the <strong class="source-inline">getChildren</strong> method you have seen in the previous example. The <strong class="source-inline">load</strong> method returns an array of objects that respect the listing conditions.</p>
			<p>In these first two examples, you have learned how to retrieve existing variants. In the following example, you will see how to create a new variant instead.</p>
			<h2 id="_idParaDest-217"><a id="_idTextAnchor219"/>Creating a new Variant</h2>
			<p>In the previous examples, you learned<a id="_idIndexMarker789"/> how to query for existing variants. In this example, you will learn how to create a product variant.</p>
			<p>In the following code snippet, you will see how to create a variant for an existing product:</p>
			<p class="source-code">&lt;?php</p>
			<p class="source-code">    use Pimcore\Model\DataObject\Product;</p>
			<p class="source-code">    use Pimcore\Model\DataObject\AbstractObject;</p>
			<p class="source-code">    $tshirt = Product::getByName("Classic T-Shirt", "en", 1);</p>
			<p class="source-code">    $orange = new Product();</p>
			<p class="source-code">    $orange-&gt;setKey("Orange");</p>
			<p class="source-code">    $orange-&gt;setParent($tshirt);</p>
			<p class="source-code">    $orange-&gt;setType(AbstractObject::OBJECT_TYPE_VARIANT);</p>
			<p class="source-code">    $orange-&gt;save();</p>
			<p class="source-code">?&gt;</p>
			<p>As you can see in the previous code snippet, first of all you have to get the product object. The retrieved product must be declared as the parent of the new product variant. Then, it's necessary to explicitly<a id="_idIndexMarker790"/> set the product type to declare that the created product is a variant.</p>
			<p>In the example, you will note the use of the <strong class="source-inline">getByName</strong> method. This kind of method is automatically generated for each class attribute at class-definition save. The first argument is the value to search for, the second one is for localized fields (the language for which the value must be searched), and the third one is the limit parameter. If the limit is 1, a single object is returned; otherwise, the return type is an instance of the class listing.</p>
			<p>To summarize, in this section, you learned how to enable variants for the <strong class="source-inline">Product</strong> class and how to create product variants. Then, through some code examples, you learned how to retrieve existing variants and how to create new ones.</p>
			<p>In the following section, you will learn how to create bundled products and how to create a service that listens to events fired after certain operations are made—for example, to automatically calculate one or more product field values when a product is saved.</p>
			<h1 id="_idParaDest-218"><a id="_idTextAnchor220"/>Creating a Bundle Product</h1>
			<p>In the previous section, you learned how to enable and create product variants and how to practically use them in code examples. In this section, you will learn how to define bundle products.</p>
			<p>In marketing, the concept of <strong class="bold">Product Bundling</strong> is the practice of offering a set of individual products or services together as one combined product or service package<a id="_idIndexMarker791"/>. Typically, bundle<a id="_idIndexMarker792"/> products are intended to be kits or, more generically, a group of coherent products, with the advantage of a discounted price if bought together instead of buying them separately.</p>
			<p>Through this chapter, we will first see how to modify our previously created <strong class="source-inline">Product </strong>class to define bundle products. Then, we will discover how to automatically perform operations once the product is saved to calculate the bundle price.</p>
			<h2 id="_idParaDest-219"><a id="_idTextAnchor221"/>Defining bundle products</h2>
			<p>In this section, you will learn how to modify the <strong class="source-inline">Product</strong> class to be able to define bundle products<a id="_idIndexMarker793"/>. The easiest solution is to create a self-referenced relation attribute with the <strong class="source-inline">Product</strong> class itself. This will let you choose the products that will form the bundle from the previously created products.</p>
			<p>To add this attribute, you need to perform the following instructions:</p>
			<ol>
				<li value="1">Open the <strong class="source-inline">Product</strong> class definition.</li>
				<li>Right-click on the <strong class="bold">Product Information</strong> panel and select <strong class="bold">Add Data Component</strong> | <strong class="bold">Relation</strong> | <strong class="bold">Many-to-Many Object Relation</strong>.</li>
				<li>Write <strong class="source-inline">bundle_products</strong> as the attribute name and <strong class="source-inline">Bundle</strong> <strong class="source-inline">Products</strong> as the attribute title.</li>
				<li>In the <strong class="bold">Allowed Classes</strong> list, select the <strong class="source-inline">Product</strong> class.</li>
				<li>In the <strong class="bold">Visible Fields</strong> list, select the class fields that you want to show in the relation—for example, <strong class="source-inline">sku</strong> and <strong class="source-inline">name</strong>.</li>
				<li>Click on the <strong class="bold">Save</strong> button to apply the changes.</li>
			</ol>
			<p>In the following screenshot<a id="_idIndexMarker794"/>, you can see what the <strong class="source-inline">Product</strong> class should look like after these operations:</p>
			<div>
				<div id="_idContainer183" class="IMG---Figure">
					<img src="image/Figure_12.08_B17073.jpg" alt="Figure 12.8: Bundle_Products Attribute&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 12.8: Bundle_Products Attribute</p>
			<p>As you can see in the previous screenshot, the new attribute is added at the bottom of the panel, and the desired visible fields are selected.</p>
			<p>Now that we have created this attribute, we can create a bundle product. To do that, simply create a new product object, then use the previously created relation attribute to select a couple of products that will compose the bundle product. Once you have selected these products they will appear in the relationship, as you can see in the following screenshot:</p>
			<div>
				<div id="_idContainer184" class="IMG---Figure">
					<img src="image/Figure_12.09_B17073.jpg" alt="Figure 12.9: Bundle Products relation&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 12.9: Bundle Products relation</p>
			<p>As you can see in the previous screenshot, only the previously selected product fields are visible in the relation attribute. </p>
			<p>Now that we have defined which are the products that compose our bundle, we may want to automatically calculate<a id="_idIndexMarker795"/> the bundle price based on the price of the selected products. So we need to open the class definition and add a new numeric attribute to store the bundle price, as you can see in the following screenshot:</p>
			<div>
				<div id="_idContainer185" class="IMG---Figure">
					<img src="image/Figure_12.10_B17073.jpg" alt="Figure 12.10: Bundle price attribute&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 12.10: Bundle price attribute</p>
			<p>In the previous screenshot, you can see that this attribute is marked as <strong class="bold">Not editable</strong>, and this means that we need a method to calculate the bundle price. </p>
			<p>To summarize, in this section, you learned how to alter the <strong class="source-inline">Product</strong> class to define bundle products. In the following section, you will learn how to create a listener class that listens for an event fired by the product save operation, which will allow you to automatically calculate<a id="_idIndexMarker796"/> the bundle price.</p>
			<h2 id="_idParaDest-220"><a id="_idTextAnchor222"/>Creating an Event Listener</h2>
			<p>In the previous section, you learned how to define bundle products. In common scenarios, the price<a id="_idIndexMarker797"/> of a bundle product is less than the sum of the individual price of the products it's composed of. It may be useful to automatically calculate the price of a bundle product with a predefined rule, instead of manually inserting this value.</p>
			<p>In this section, you will learn how to create<a id="_idIndexMarker798"/> an event listener to capture events fired once the product is saved. The saving of an object is just one of the events that could be listened to in Pimcore, which includes all <strong class="bold">create, read, update, and delete</strong> (<strong class="bold">CRUD</strong>) operations<a id="_idIndexMarker799"/> on objects, assets, and documents, operations on users, the opening of search or grid lists, and many others.</p>
			<p>To create an event listener, you first need to register a new class in the <strong class="source-inline">app/config/services.yml</strong> file, as you can see in the following code snippet:</p>
			<p class="source-code">services:</p>
			<p class="source-code">App\EventListener\DataObjectListener:</p>
			<p class="source-code">        tags:</p>
			<p class="source-code">            - { name: kernel.event_listener, event: pimcore.            dataobject.postUpdate, method: onObjectPostUpdate }</p>
			<p>As you can see in the previous snippet, a new service can be defined by adding the class namespace. In the <strong class="source-inline">tags</strong> attribute, we must define one or more tags of our service. Each tag is composed of three properties, outlined as follows:</p>
			<ul>
				<li><strong class="source-inline">name</strong>: The name of the tag. We must provide the <strong class="source-inline">kernel.event_listener</strong> fixed value to let the service be correctly recognized as an event listener.</li>
				<li><strong class="source-inline">event</strong>: Used to specify which event we want to listen to. In our case, we are interested in listening to the <strong class="source-inline">postUpdate</strong> event for objects. This event, as the name suggests, is fired after an object is saved.</li>
				<li><strong class="source-inline">method</strong>: In this property, we must put the name of the method of our class that will be called automatically when an event is fired.</li>
			</ul>
			<p>For event listeners, each defined<a id="_idIndexMarker800"/> tag represents a specific event, so you must add one tag for each event that you want your service to listen to.</p>
			<p>Let's now see how to implement<a id="_idIndexMarker801"/> the defined service to calculate the price of our bundle product. In the following code snippet, you will see a possible implementation:</p>
			<p class="source-code">&lt;?php</p>
			<p class="source-code">namespace App\EventListener;</p>
			<p class="source-code">use Pimcore\Event\Model\DataObjectEvent;</p>
			<p class="source-code">use Pimcore\Model\DataObject\Product;</p>
			<p class="source-code">class DataObjectListener </p>
			<p class="source-code">{</p>
			<p class="source-code">    public function onObjectPostUpdate (DataObjectEvent $e) </p>
			<p class="source-code">    {</p>
			<p class="source-code">        $obj = $e-&gt;getObject(); </p>
			<p class="source-code">        if($obj instanceof Product)</p>
			<p class="source-code">        {</p>
			<p class="source-code">            $bundleProducts = $obj-&gt;getBundle_products();</p>
			<p class="source-code">            $currentPrice = $obj-&gt;getBundlePrice();</p>
			<p class="source-code">            if(count($bundleProducts) &gt;0)</p>
			<p class="source-code">            {</p>
			<p class="source-code">                $bundlePrice = 0;</p>
			<p class="source-code">                foreach($bundleProducts as $product)</p>
			<p class="source-code">                {</p>
			<p class="source-code">                    $price = $product-&gt;getPrice()</p>
			<p class="source-code">                        -&gt;getValue();</p>
			<p class="source-code">                    $bundlePrice += $price;</p>
			<p class="source-code">                }</p>
			<p class="source-code">                //substract the 20% of the sum</p>
			<p class="source-code">                $bundlePrice = round($bundlePrice*0.8,2);</p>
			<p class="source-code">                //Add this check to avoid circular saves</p>
			<p class="source-code">                if($bundlePrice != $currentPrice)</p>
			<p class="source-code">                {</p>
			<p class="source-code">                    $obj-&gt;setBundlePrice($bundlePrice);</p>
			<p class="source-code">                    $obj-&gt;save();</p>
			<p class="source-code">                }</p>
			<p class="source-code">            }</p>
			<p class="source-code">        }</p>
			<p class="source-code">    }</p>
			<p class="source-code">}</p>
			<p>Let's analyze the previous code snippet, to understand the key aspects. First of all, you may note that we have defined a method named <strong class="source-inline">onObjectPostUpdate</strong>, which is the name defined<a id="_idIndexMarker802"/> in the <strong class="source-inline">services.yml</strong> file. </p>
			<p>This method takes the fired event as an argument, and from this event, we can extract the object that fired<a id="_idIndexMarker803"/> the event itself. As you may note, we must check for the object class to do the operations part only if the object is a product.</p>
			<p>For each product that composes the bundle, we add up the product prices, and in the end, we decrease this sum by 20%. Please note that this is just an example and that you can define your own rule. </p>
			<p>To avoid a circular loop on product saves, we save the product only in cases where the new calculated price is different<a id="_idIndexMarker804"/> from the previous one. If we omit this check, the save operation made on this service will fire the event again.</p>
			<p>To summarize, in this section, you learned about the concept of product bundling and how to change the <strong class="source-inline">Product</strong> class by adding attributes that allow you to define bundle products. Later, you learned<a id="_idIndexMarker805"/> how to create an event listener service to capture events fired by operations on objects, such as the saving of a product. In the provided example, you have seen how to automatically calculate the price of a bundle product. </p>
			<p>In the following section, you will learn how to extend the <strong class="source-inline">Product</strong> class to manage different types of products without the need to create a specific class for each product.</p>
			<h1 id="_idParaDest-221"><a id="_idTextAnchor223"/>Managing different Product Types</h1>
			<p>In the previous section, you learned how to define bundle products. In this section, you will learn how to manage different types of products without creating a different class for each product type. If you need to manage a heterogeneous set of products, such as shirts and shoes, you will probably<a id="_idIndexMarker806"/> need specific attributes to better represent these concepts.</p>
			<p>Surely, we could create two different classes for shirts and shoes, but we will need to define redundant fields for both classes to describe properties that are shared between them—for example, the title, price, description, and so on.</p>
			<p>In <a href="B17073_05_ePub_RK.xhtml#_idTextAnchor093"><em class="italic">Chapter 5</em></a>, <em class="italic">Exploring Objects and Classes</em>, we introduced the concept of <strong class="bold">Objectbricks</strong>. With Objectbricks, we just need to create little sets of attributes to describe specific fields and allow our class to dynamically add these bricks. As the name suggests, class objects can be composed of one or more bricks added to the common attributes.</p>
			<p>Before creating Objectbrick definitions, we need to create an attribute in the <strong class="source-inline">Product</strong> class to accommodate the various bricks. To create this attribute, just right-click on a panel component inside the class definition and select <strong class="bold">Add Data Component </strong>|<strong class="bold"> Structured </strong>|<strong class="bold"> Objectbricks</strong>, fill in the attribute<a id="_idIndexMarker807"/> name, and click on the <strong class="bold">Save</strong> button to apply the changes. In the following screenshot, you can see an example of this:</p>
			<div>
				<div id="_idContainer186" class="IMG---Figure">
					<img src="image/Figure_12.11_B17073.jpg" alt="Figure 12.11: Objectbricks attribute&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 12.11: Objectbricks attribute</p>
			<p>As you can see in the previous screenshot, we have created an attribute of the <strong class="bold">Objectbricks</strong> type. As an optional property, we can set the maximum number of bricks that can be attached to each object.</p>
			<p>Now that we have defined the attribute in the <strong class="source-inline">Product</strong> class, we can define one or more Objectbricks. To do that, just go through <strong class="bold">Settings</strong> | <strong class="bold">Data Objects | Objectbricks</strong>. To add a new Objectbricks definition, you just need to click on the <strong class="bold">Add</strong> button, write the name of your brick, and click on the <strong class="bold">OK</strong> button. In the following screenshot, you can see an example of a created Objectbrick:</p>
			<div>
				<div id="_idContainer187" class="IMG---Figure">
					<img src="image/Figure_12.12_B17073.jpg" alt="Figure 12.12: Objectbrick definition&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 12.12: Objectbrick definition</p>
			<p>As you can see in the previous screenshot, the Objectbricks definition panel is the same as the class creation one. Besides, for Objectbricks, we can select the classes and the specific attributes to attach the Objectbrick<a id="_idIndexMarker808"/> to. In this example, we have attached the Objectbrick to the <strong class="source-inline">Product</strong> class, and we have selected the previously created attribute.</p>
			<p>Once the Objectbricks are defined, we can attach them to the product objects. In the following screenshot, you can see what the Objectbrick looks like in the product object:</p>
			<div>
				<div id="_idContainer188" class="IMG---Figure">
					<img src="image/Figure_12.13_B17073.jpg" alt="Figure 12.13: Objectbrick instance&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 12.13: Objectbrick instance</p>
			<p>As you can see in the previous screenshot, in the product objects, the Objectbricks appear as a specific section. You can attach one or more Objectbricks to every object since the defined limit is reached, and every kind of Objectbrick can be attached once within the same objects.</p>
			<p>To summarize, in this section, you learned how to manage different types of products using Objectbricks. Objectbricks can be considered as subsets of attributes that can be attached to classes to extend the class concept with extra attributes. For the <strong class="source-inline">Product</strong> class, for example, we can think about creating specific attributes for shirts, shoes, and so on.</p>
			<p>In the next section, you will learn how to configure a workflow that will let you control the completeness of the product information, step by step.</p>
			<h1 id="_idParaDest-222"><a id="_idTextAnchor224"/>Working with workflows</h1>
			<p>A workflow consists of a sequence of processes and tasks that represent the work that must be done to reach a common goal. Typically, we may think about workflows as a graph.</p>
			<p>Pimcore Workflow Management provides<a id="_idIndexMarker809"/> configurations of multiple workflows on assets, documents, data objects, to support data maintenance processes, element life cycles, and various other processes. Pimcore workflows are based on the Symfony workflow component and extend it with specific features. Before starting the configuration of a Pimcore workflow, let's describe the basics concepts of the Symfony workflow component, as follows:</p>
			<ol>
				<li value="1"><strong class="bold">Workflow Type 'Workflow'</strong>: This is the default type of workflow and allows you to model a workflow net that is a subclass of a petri net. For this kind of workflow, an element can be in several states of the workflow at the same time.</li>
				<li><strong class="bold">Workflow Type 'State Machine'</strong>: A state machine is a subset of a workflow and its purpose is to hold a state of your model. A state machine cannot be in more than one place simultaneously. </li>
				<li><strong class="bold">Place</strong>: A place is a step in a workflow and describes a characteristic or status of an element. Depending on the place, an element may appear in a specific view—for example, to have a focus on translations only. We will have a look at how to create a custom layout for a Pimcore class in the following section.</li>
				<li><strong class="bold">Marking Store</strong>: The marking store stores the current place(s) for each element. </li>
				<li><strong class="bold">Transition</strong>: A transition describes the action that is performed to move from one place to another. Transitions may be allowed or not, depending on additional criteria, and may require additional notes and information entered by the user.</li>
				<li><strong class="bold">Transition Guard</strong>: Defines a criterion that defines whether a transition is currently allowed or not.</li>
			</ol>
			<p>By reading the following sections, you will learn how to properly configure a Pimcore workflow. We will start by defining a custom layout for the <strong class="source-inline">Product</strong> class and will then see how to set up a workflow<a id="_idIndexMarker810"/> that will guide the completion of product information.</p>
			<h2 id="_idParaDest-223"><a id="_idTextAnchor225"/>Configuring a Custom Layout</h2>
			<p>As mentioned before, in the various places of a workflow we can show a custom view for the element. This is made possible by configuring custom layouts<a id="_idIndexMarker811"/> on the corresponding class.</p>
			<p>To create a custom layout, just open the class definition and click on the <strong class="bold">Configure custom layouts</strong> button. When that button<a id="_idIndexMarker812"/> is clicked, a new modal window is opened, and you can add a new custom layout or load a previously created one. To create a new layout, just click on the <strong class="bold">Add</strong> button. In the modal that will open, you can write the new layout name and <strong class="bold">identifier</strong> (<strong class="bold">ID</strong>)<a id="_idIndexMarker813"/>, as you can see in the following screenshot:</p>
			<div>
				<div id="_idContainer189" class="IMG---Figure">
					<img src="image/Figure_12.14_B17073.jpg" alt="Figure 12.14: Creating a Custom Layout&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 12.14: Creating a Custom Layout</p>
			<p>As you can see in the previous screenshot, to add a new custom layout you just need to fill in the <strong class="bold">Name</strong> and <strong class="bold">Unique identifier</strong> fields and click on the <strong class="bold">OK</strong> button to confirm.</p>
			<p>Once you have initialized the custom layout, you can specify which attributes you want to show in the layout itself. In the following screenshot, you can see how this configuration can be done:</p>
			<div>
				<div id="_idContainer190" class="IMG---Figure">
					<img src="image/Figure_12.15_B17073.jpg" alt="Figure 12.15: Custom Layout Configuration&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 12.15: Custom Layout Configuration</p>
			<p>As you can see in the previous screenshot, the configuration modal is composed of two main panels. In the left panel, you will find the previously defined class structure, while in the right panel, you can drag and drop<a id="_idIndexMarker814"/> the attributes you want to show in the custom layout from the left panel.</p>
			<p>For each attribute, you can decide<a id="_idIndexMarker815"/> to change some properties, such as the possibility to edit the attribute itself. Once you have configured the custom layout, you can click on the <strong class="bold">Save</strong> button to apply the changes.</p>
			<p>Now that you have seen how to configure custom layouts, let's see how to use them in a workflow configuration.</p>
			<h2 id="_idParaDest-224"><a id="_idTextAnchor226"/>Configuring a Pimcore workflow</h2>
			<p>In the previous section, you learned how to configure<a id="_idIndexMarker816"/> custom layouts<a id="_idIndexMarker817"/> for Pimcore classes. In this section, you will learn how to configure Pimcore workflows and how to use the previously created custom layouts.</p>
			<p>As with many other services, Pimcore workflows must be defined in the <strong class="source-inline">config.yaml</strong> file of the Pimcore project or the same file of a specific bundle. In this section, you will learn how to properly configure<a id="_idIndexMarker818"/> a workflow.</p>
			<p>In the following code snippet, you will see how to initialize the workflow<a id="_idIndexMarker819"/> configuration:</p>
			<p class="source-code">pimcore:</p>
			<p class="source-code">    workflows:</p>
			<p class="source-code">        product_workflow:</p>
			<p class="source-code">            label: 'Product Workflow'</p>
			<p class="source-code">            type: 'state_machine'</p>
			<p class="source-code">            supports:</p>
			<p class="source-code">                - 'Pimcore\Model\DataObject\Product'</p>
			<p class="source-code">            marking_store:</p>
			<p class="source-code">                type: single_state</p>
			<p class="source-code">                arguments:</p>
			<p class="source-code">                    - marking</p>
			<p>As you can see in the preceding snippet, to initialize a workflow you must add the <strong class="source-inline">workflows</strong> keyword under the <strong class="source-inline">pimcore</strong> keyword. Then, you must add a unique ID for the workflow, which is <strong class="source-inline">product_workflow</strong> in our example.</p>
			<p>At the lower level, you can define some parameters, which are provided here:</p>
			<ol>
				<li value="1"><strong class="source-inline">label</strong>: The workflow title.</li>
				<li><strong class="source-inline">type</strong>: The workflow type, which can be <strong class="source-inline">workflow</strong> or <strong class="source-inline">state_machine</strong>, as described in the chapter introduction.</li>
				<li><strong class="source-inline">supports</strong>: One or more classes to which the workflow is applied.</li>
				<li><strong class="source-inline">marking_store</strong>: For <strong class="source-inline">state_machine</strong> workflows, you can specify which attribute of the class must be used to store the workflow state. If that attribute is a picklist attribute, you can let the class dynamically create the picklist options by reading the workflow states<a id="_idIndexMarker820"/> by defining the options provider, as you can see in the following screenshot:</li>
			</ol>
			<div>
				<div id="_idContainer191" class="IMG---Figure">
					<img src="image/Figure_12.16_B17073.jpg" alt="Figure 12.16: Workflow states options provider&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 12.16: Workflow states options provider</p>
			<p>As you can see in the previous screenshot, you can fill in the <strong class="bold">Options Provider Class or Service Name</strong> and specify the workflow name as the <strong class="bold">Options Provider Data</strong>. The options provider class will automatically read the workflow states<a id="_idIndexMarker821"/>, which you can configure with the <strong class="source-inline">places</strong> keyword, as you can see in the following snippet:</p>
			<p class="source-code">pimcore:</p>
			<p class="source-code">    workflows:</p>
			<p class="source-code">        product_workflow:</p>
			<p class="source-code">            places:</p>
			<p class="source-code">                base_data:</p>
			<p class="source-code">                    label: 'Base Data'</p>
			<p class="source-code">                    color: '#ffd700'</p>
			<p class="source-code">                    permissions:</p>
			<p class="source-code">                        - objectLayout: basedata</p>
			<p>As you can see in the previous code snippet, you can add one or more states behind the <strong class="source-inline">places</strong> keyword. For each state, you must specify a unique ID and define a label and a color that will be used to highlight the label text. If you want to restrict the visible class attributes for a particular state, you may specify a previously defined custom layout in the <strong class="source-inline">objectLayout</strong> keyword behind <strong class="source-inline">permissions</strong>.</p>
			<p>The last step in the workflow configuration is to define transitions between different states. You can see how to define transitions in the following code snippet:</p>
			<p class="source-code">pimcore:</p>
			<p class="source-code">    workflows:</p>
			<p class="source-code">        product_workflow:</p>
			<p class="source-code">            transitions:</p>
			<p class="source-code">                product_images:</p>
			<p class="source-code">                    from: [ translations, enrichment ]</p>
			<p class="source-code">                    to: images</p>
			<p class="source-code">                    guard: subject.checkTranslationsCompleted()</p>
			<p class="source-code">                    options:</p>
			<p class="source-code">                        label: 'Edit Images'</p>
			<p class="source-code">                        notes:</p>
			<p class="source-code">                            commentEnabled: true</p>
			<p class="source-code">                            commentRequired: false</p>
			<p class="source-code">                        iconClass: 'pimcore_icon_image'</p>
			<p>As you can see in the previous snippet, the transitions must be defined behind the <strong class="source-inline">transitions</strong> keyword. For each transition, you must define a unique ID; then, you must specify one or more states<a id="_idIndexMarker822"/> from which the transition can start<a id="_idIndexMarker823"/> and one destination state only. In the following screenshot, you can see how a transition can be invoked:</p>
			<div>
				<div id="_idContainer192" class="IMG---Figure">
					<img src="image/Figure_12.17_B17073.jpg" alt="Figure 12.17: Invoking workflow transitions&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 12.17: Invoking workflow transitions</p>
			<p>As you can see in the previous screenshot, a grouped button is automatically injected into the object editor to let you select the available transitions.</p>
			<p>If needed, you can also specify a <strong class="source-inline">guard</strong> function that is automatically invoked when the workflow is placed in one of the <strong class="source-inline">from</strong> states. If the <strong class="source-inline">guard</strong> function does not pass, it will not be possible to apply the transition<a id="_idIndexMarker824"/> and move to the destination state. In this specific example, you can let the user edit the images only after the transitions<a id="_idIndexMarker825"/> are completed. A transition guard must be a function of the object, so the best solution is to create this function in the parent PHP class that we mentioned in the <em class="italic">Creating product variants</em> section of this chapter.</p>
			<p>Optionally, you can also specify some extra options on a transition, such as setting up a custom icon for the transition or letting the user write a note when the transition is invoked, as you can see in the following screenshot:</p>
			<div>
				<div id="_idContainer193" class="IMG---Figure">
					<img src="image/Figure_12.18_B17073.jpg" alt="Figure 12.18: Notes on transition&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 12.18: Notes on transition</p>
			<p>As you can see in the previous screenshot, when the user clicks on the transition action, a modal will open and the user can write a comment that will be stored in the <strong class="bold">Notes &amp; Events</strong> section inside the object, and then click on the <strong class="bold">Perform Action</strong> button to complete the transition.</p>
			<p>To summarize, in this section<a id="_idIndexMarker826"/>, you learned how to configure a Pimcore workflow. By defining<a id="_idIndexMarker827"/> custom layouts, you can force users to fill in product information step by step, to ensure data completion. In particular, you learned how to define places for the workflow and how to configure workflow transitions.</p>
			<h1 id="_idParaDest-225"><a id="_idTextAnchor227"/>Summary</h1>
			<p>In this chapter, you learned about the concept of <strong class="bold">Product Information Management </strong>by defining a <strong class="source-inline">Product</strong> entity and providing practical examples. In the first section of the chapter, you learned what a PIM is and what its main features are. Then, you learned how to create and configure a <strong class="source-inline">Product</strong> class, according to your needs.</p>
			<p>After having defined the <strong class="source-inline">Product</strong> class, you learned how to enable inheritance for the class and how to define product variants for an existing product. Through practical code examples, you also learned how to retrieve variants on listings and how to create new product variants.</p>
			<p>Later in this chapter, you learned about the concept of product bundling and how to add new fields to the <strong class="source-inline">Product</strong> class to let you define bundle products. Then, you learned how to create an event listener service to listen to events fired by the objects—for example, to catch once the product is saved. In particular, you have seen a code example showing how to calculate the price of a bundle product.</p>
			<p>After that, you learned how to use Objectbricks to extend the <strong class="source-inline">Product</strong> class, attaching groups of attributes useful to define specific concepts. This is useful if you want to represent different kinds of products without creating a class for each kind, to avoid the redundancy of common attributes.</p>
			<p>In the last section, you learned how to configure custom layouts for Pimcore classes and how to use them in Pimcore workflow configurations. Through a concrete example, you learned how to configure a workflow to fill in product information step by step.</p>
			<p>In the next chapter, you will learn how to expose products and other entities to the outside through the Pimcore Datahub bundle and how to turn Pimcore into a <strong class="bold">Master Data Management </strong>(<strong class="bold">MDM</strong>) platform.</p>
		</div>
	</body></html>