- en: Chapter 7. Authenticating and Authorizing Users
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When working with modern web applications, we often need to authenticate our
    users to ensure that they are who they claim to be and that they have the appropriate
    permissions (authorization) required to access information. In this chapter, we'll
    cover the basics of authenticating users with Yii2 and granting them access to
    specific pages within our applications using basic access control filters and
    more complex role-based access control filters.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, we'll be building upon the migration scripts and models we
    created in [Chapter 4](part0030_split_000.html#SJGS2-ad3e09b384df46aea690d9c8897d5fe7
    "Chapter 4. Active Record, Models, and Forms"), *Active Record, Models, and Forms*.
    Before starting this chapter, make sure you have a good understanding of the models
    and migrations we created in that chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Authentication of users
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: With nearly every sufficiently sized web application, we will ultimately need
    our application to support the storage and authentication of users in order to
    ensure that the users working with our application are who they claim to be. With
    web applications, we typically handle authentication through a public identity
    (such as an e-mail address) and a secret that the user knows (such as a password).
    Depending upon the sensitivity of our data and our threat model, we can also extend
    our authentication process to include a two-factor authentication code issued
    either through an SMS text message or a two-factor authentication application,
    such as Authy or Google Authenticator. In this section, we'll cover how to implement
    basic authentication with Yii2 and explore how we can enhance the security of
    our users through the authentication process.
  prefs: []
  type: TYPE_NORMAL
- en: 'In Yii2, authentication is managed through the user component and is defined
    in our `config/web.php` application configuration file. Before we can start authenticating
    users in our application, we first need to define this component in our configuration
    file. Specifically, we need to tell Yii2 where it can find the identity class
    we''ll use to handle the authentication logic within our application. In the following
    code block, we''ve defined our identity class as our User model that we created
    in [Chapter 3](part0023_split_000.html#LTSU1-ad3e09b384df46aea690d9c8897d5fe7
    "Chapter 3. Migrations, DAO, and Query Building"), *Migrations, DAO, and Query
    Building*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: In the upcoming sections, we'll go over how to extend our `User` class to support
    authentication.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing the user identity interface
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To implement our identity class with the required authentication logic, we must
    first have our identity class (`app\models\User`, defined in `models\User.php`)
    implement `yii\web\IdentityInterface`.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Remember, in PHP 5+, interfaces are PHP constructs that define which methods
    the implemented class must contain.
  prefs: []
  type: TYPE_NORMAL
- en: 'In PHP 5+, we can enhance our `User` object with the required interface methods
    by first using the `implements` keyword in our class, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we can implement the methods outlined in the `IdentityInterface` interface.
    These methods are `findIdentity($id)`, `findIdentityByAccessToken()`, `getId()`,
    `getAuthKey($token, $type)`, and `validateAuthKey($authKey)`:'
  prefs: []
  type: TYPE_NORMAL
- en: The first method we need to implement is `findIdentity($id)`. This method is
    responsible for finding an instance of the `identity` class with the specified
    `$id` attribute, and is primarily used when Yii2 needs to authenticate the user
    from the session data.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'To implement this method, we need to define the static method and return an
    instance of our `User` class, as shown in the following example:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The next method defined in `yii\web\IdentityInterface` that we need to define
    is `findIdentityByAccessToken($token, $type)`. In Yii2, authentication can be
    handled through a frontend web form, a cookie (if we''re using cookie-based authentication),
    or a RESTful API. The `findIdentityByAccessToken` method is used when we''re using
    RESTful authentication. Since our application doesn''t have a REST API yet, we
    can simply define this method with an empty body, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: 'If we want to add basic support for token-based authentication, we will need
    to perform the following steps:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 1\. Add a new migration to store an access token with our user data.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 2\. Create an API-based authentication method that generates an access token
    and store it alongside our user data
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '3\. Implement the `findIdentityByAccessToken()` method, as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We'll cover RESTful API authentication in more detail in [Chapter 9](part0052_split_000.html#1HIT82-ad3e09b384df46aea690d9c8897d5fe7
    "Chapter 9. RESTful APIs"), *RESTful APIs*.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Next, we need to explicitly define the `getId()` method, which will return
    the ID of our user:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: While `yii\base\Object`, which `yii\base\ActiveRecord` extends from, defines
    a magic method `__getter` for all of our public properties defined in our `ActiveRecord`
    instance, interfaces in PHP 5+ require all methods listed in the interface to
    be explicitly defined.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Finally, we need to implement the `getAuthKey()` and `validateAuthKey()` methods
    within our application. As stated previously, these two methods are explicitly
    used for cookie-based authentication. Since we won''t be using cookie-based authentication
    in this chapter, we can leave these two methods, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Cookie-based authentication
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'When working with users, we often need to include a feature similar to the
    *Remember me* feature in our application so that our users can seamlessly log
    in to our application after they have been away for some time. To make cookie-based
    authentication work in Yii2, we need to make several changes to our application:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we need to set the `enableAutoLogin` property of our user component
    in our web configuration file to `true`. This will allow Yii2 to automatically
    log users in if they have the appropriate cookie set:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, we''ll need to define a location to store and persist our user''s cookie-based
    authentication token. One way to achieve this would be to add an additional migration
    that adds an `auth_key` column to our user table. During the creation of our user,
    we can then seed this value, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: Alternatively, we can make this value persist into a secondary storage system,
    such as in Memcached or Redis. We'll cover how to use cache data using Redis and
    Memcached in [Chapter 12](part0075_split_000.html#27GQ62-ad3e09b384df46aea690d9c8897d5fe7
    "Chapter 12. Performance and Security"), *Performance and Security*.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Finally, when we define our login form method that instantiates our `IdentityInterface`
    object, we''ll need to log the user in with a duration, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Yii2 will consequently create a cookie that it will use internally and that
    will automatically log the user in as long as the cookie is valid. If the duration
    is not set, session-based authentication will be used instead of a cookie-based
    one, which means that our user session will expire when the user closes their
    browser rather than when the user's cookie expires.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Working with user identities
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Now that we've defined the methods required for our identity interface, let's
    take a look at the `yii\web\User` object in more detail.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Remember, the `yii\web\User` class is distinct from the `app\models\User` class.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `yii\web\User` object is referenced in Yii2 through `\Yii::$app->user`,
    which contains information on the current user. Information about our user can
    be retrieved through the `\Yii::$app->user->identity` property. If a user isn''t
    authenticated, this property will be `NULL`. However, if a user is authenticated,
    it will be populated with information about the current user. For instance, if
    we want to fetch the complete name of the user as defined in the `app\models\User`
    class we extended in [Chapter 4](part0030_split_000.html#SJGS2-ad3e09b384df46aea690d9c8897d5fe7
    "Chapter 4. Active Record, Models, and Forms"), *Active Record, Models, and Forms*,
    we can do that as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Alternatively, we can detect whether a user is logged in by checking the `isGuest`
    property of `yii\web\User`, as follows. This property will return `true` if the
    user is not authenticated and `false` if they are:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Moreover, if we want to retrieve the ID of the user, we can access it through
    the `getId()` method we defined in our `User` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we can log our user in and out of our application using the respective
    `login()` and `logout()` methods in `Yii::$app->user`. To log a user in, we first
    need to create an instance of the identity we established earlier. In the following
    example, we''re fetching the identity information from the user''s e-mail address.
    As mentioned previously, we can also supply a duration parameter as part of the
    `login()` method for cookie-based authentication:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: After we're authenticated, we can log users out of our application by calling
    `\Yii::$app->user->logout()`. By default, this parameter will destroy all the
    session data associated with the current user. If we want to preserve this data,
    we can pass `false` as the first parameter to the `logout()` method.
  prefs: []
  type: TYPE_NORMAL
- en: Authenticating users with forms
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now that we''ve implemented our identity interface and know the basics of the
    `yii\web\User` component, let''s piece these components together with the user
    data we created in [Chapter 3](part0023_split_000.html#LTSU1-ad3e09b384df46aea690d9c8897d5fe7
    "Chapter 3. Migrations, DAO, and Query Building"), *Migrations, DAO, and Query
    Building*, and the `UserForm` class and scenario we created in [Chapter 4](part0030_split_000.html#SJGS2-ad3e09b384df46aea690d9c8897d5fe7
    "Chapter 4. Active Record, Models, and Forms"), *Active Record, Models, and Forms*.
    As a reminder, here is the `UserForm` class we started with in [Chapter 4](part0030_split_000.html#SJGS2-ad3e09b384df46aea690d9c8897d5fe7
    "Chapter 4. Active Record, Models, and Forms"), *Active Record, Models, and Forms*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'To enhance our `UserForm` class to facilitate logging in, we need to make a
    couple of changes:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, since we''ll be working with our identity object in multiple places,
    we should create a private variable to store it. This will help reduce the number
    of queries we need to make to our database when working with our form. We''ll
    also want to define a method to retrieve this property:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, we''ll need to implement a method to validate our user''s password. As
    mentioned in [Chapter 3](part0023_split_000.html#LTSU1-ad3e09b384df46aea690d9c8897d5fe7
    "Chapter 3. Migrations, DAO, and Query Building"), *Migrations, DAO, and Query
    Building*, we''re hashing the user''s password using the PHP 5 `password_hash`
    method. To validate passwords that are hashed this way, we can use the PHP 5 `password_verify`
    method. For our application, let''s add a `verifyPassword()` method to our `app\models\User`
    class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'To call this method, we''re going to add a new validator to the `rules()` method
    of our `UserForm` class that only executes on the login scenario we defined previously:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Recalling the information we covered in [Chapter 4](part0030_split_000.html#SJGS2-ad3e09b384df46aea690d9c8897d5fe7
    "Chapter 4. Active Record, Models, and Forms"), *Active Record, Models, and Forms*,
    we know that in the login scenario, the `validatePassword` method will be called
    to satisfy the new validation rule we added to our `rules()` method. We can define
    this method as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We'll finalize our `UserForm` class by adding a `login()` method that will validate
    the email and password submitted by our user and then log the user in.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'With our form finalized, we can then implement the login action in our controller
    that will finish the workflow. In our case, let''s have our login action redirect
    the user to a page that will display some information about the user after they''re
    logged in. Since we''ve already defined the bulk of this action back in [Chapter
    4](part0030_split_000.html#SJGS2-ad3e09b384df46aea690d9c8897d5fe7 "Chapter 4. Active
    Record, Models, and Forms"), *Active Record, Models, and Forms*, a small change
    is required for this action:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: For illustration purposes, let's also dump the information from `\Yii::$app->user->identity`
    on this page so that we can see it. We can do this by creating the secure action
    we mentioned previously and then using the `VarDumper` helper to print this information.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Since we already created our login view in [Chapter 4](part0030_split_000.html#SJGS2-ad3e09b384df46aea690d9c8897d5fe7
    "Chapter 4. Active Record, Models, and Forms"), *Active Record, Models, and Forms*,
    we can authenticate ourselves into the application using the credentials listed
    in that chapter. For example, we can log in as an admin using the following credentials:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Username: `admin@example.com`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Password: `admin`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If authenticated successfully, we will be redirected to the secure page that
    dumps our user attributes on the page.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Authorization
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Though we're now able to authenticate ourselves against our database, we need
    to implement the necessary methods in order to ensure that the right people can
    access the right pages. To do this, we need to implement either an access control
    filter or a role-based access control filter.
  prefs: []
  type: TYPE_NORMAL
- en: Access control filters
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'One way to control access to certain pages is to create access control filters.
    Access control filters in Yii2 are behaviors we can bind to our controllers to
    ensure that the right people have access to the right content. The access control
    filter is implemented through `yii\filter\AccessControl` and is primarily used
    when simple access control is needed, such when needing to make sure users are
    logged in or not (although it can be configured for rules that are more complex).
    As a filter, `yii\filter\AccessControl` is implemented in the `behaviors()` method
    of our controller, as shown in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'The previously mentioned code does several things, so let''s break it down:'
  prefs: []
  type: TYPE_NORMAL
- en: 'As mentioned in previous chapters, behaviors return an array of options. In
    this case, the first behavior we''re returning is the access behavior, which specifies
    the `yii\filter\AccessControl` filter as the class this behavior should use:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Next, we define the actions we want our filter to apply. In this case, we only
    want `yii\filter\AccessControl` to be applied to the login, logout, and register
    actions of our `SiteController` object.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Finally, we define the rules that our filter should obey. In the following
    snippet, we declare that we want unauthenticated users (designated by the special
    character `?` within the roles section) to access the login and register action
    and allow any authenticated user (designated by the special character `@` within
    the roles section) to access the logout action:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'By default, if a user is unauthenticated, our access control filter will redirect
    the user to our login page, and if they do not have access, `yii\web\ForbiddenHttpException`
    will be thrown. As this isn''t always desirable, we can modify our filter by setting
    the `denyCallback` parameter of our filter. Also, we can, within the rules section
    of our filter, define the conditions upon which an error can occur by setting
    the `matchCallback` property. As an example, if we want to make our secure action
    accessible to only administrators, we can write the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: In this section, users are only allowed to use the secure action if they have
    a role of `2` (which is the role we designated as an administrator in [Chapter
    3](part0023_split_000.html#LTSU1-ad3e09b384df46aea690d9c8897d5fe7 "Chapter 3. Migrations,
    DAO, and Query Building"), *Migrations, DAO, and Query Building*). If they aren't
    authenticated, we redirect them to the login page, and if they are authenticated
    but don't have sufficient permissions, we throw an HTTP 403 error.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The example shown previously is to illustrate what we can do with the `matchCallback`
    and `denyCallback` properties of our access control filter.
  prefs: []
  type: TYPE_NORMAL
- en: 'With an access control filter, we can restrict access to certain actions by
    the IP address by setting the `ips` parameter within our rules section, as shown.
    IP addresses can be restricted either by a specific IP or by a subnet using the
    wildcard character, as shown in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Additionally, we can restrict access to our action by specifying which HTTP
    verbs are permitted using the `yii\filter\VerbFilter` filter. For instance, if
    we want to ensure that only `GET` requests can be run against our secure action,
    we can define the following behavior:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'By default, our access control filter will attempt to apply itself to every
    action within our controller. To specify the actions that our filter should be
    restricted to, we can set the `only` property of our filter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Additionally, we can specify actions that our access control rules should be
    applied to by setting the `actions` property of our `rules` array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'In a manner similar to the `only` parameter, we can exclude certain actions
    from the authentication filter by setting the `except` filter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Access control filters are broken down into rules, as shown in the previous
    example. Each rule applies only to a specific set of actions, which allows us
    to specify custom allow or deny callbacks for these rules. The parent options
    of `only` and `except`, however, specify when the parent access control filter
    should be applied.
  prefs: []
  type: TYPE_NORMAL
- en: Role-based access control
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As an alternative to managing access with the user identity object, we can also
    manage access to actions by configuring **role-based access control** (**RBAC**)
    within our application. In Yii2, RBAC works by creating roles that represent a
    collection of permissions and then assigning roles to a specific user. Roles are
    represented by a check to determine if a given role or permission is applicable
    to the user in question. In this section, we'll cover the basics of configuring
    and working with RBAC in Yii2.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Yii2's implementation of RBAC follows the NIST RBAC model through the `authManager`
    component. The complete implementation details of the NIST RBAC model are located
    at [http://csrc.nist.gov/rbac/sandhu-ferraiolo-kuhn-00.pdf](http://csrc.nist.gov/rbac/sandhu-ferraiolo-kuhn-00.pdf).
  prefs: []
  type: TYPE_NORMAL
- en: Configuring RBAC
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To start working with RBAC, we first need to configure our `authManager` component
    for RBAC and define the authorization manager we want to use. Yii2 provides two
    different authorization managers, the first being `yii\rbac\PhpManager`, which
    uses a PHP script to store authorization data, and `yii\rbac\DbManager`, which
    utilizes the application database to manage authorization data. For simple applications
    with nondynamic permissions and roles, `yii\rbac\PhpManager` may be preferred.
  prefs: []
  type: TYPE_NORMAL
- en: 'To configure `authManager`, we simply need to define the class that we want
    to use, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: By default, `yii\rbac\PhpManager` will store authorization data in the `@app/rbac`
    directory, which must be writable by your web server.
  prefs: []
  type: TYPE_NORMAL
- en: 'Alternatively, if we''re using a database to manage our authorization data,
    we will configure `authManager` as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'When using our database to manage our authorization data, we need to run RBAC
    migrations to configure our database appropriately, which can be done by running
    the following command from our command-line interface:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'This will result in output similar to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: After configuring RBAC, our `authManager` component can be accessed by `\Yii::$app->authManager`.
  prefs: []
  type: TYPE_NORMAL
- en: Creating permissions and permission relationships
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'After configuring our `authManager` component, we need to define the permissions
    we want our users to have and the relationships between them. For most applications
    with fixed permission hierarchies, this can be achieved by writing an RBAC console
    command to initialize the data in our database. In the following example, we''ll
    create three permissions for an imaginary issue management application, a permission
    for a user to create new issues, support for newly created issues, a supervisor
    to oversee supervisors, and an administrator permission:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'Our newly created permission scheme can then be initialized by running the
    `rbac/init` command from our command line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'After defining our roles, we can apply them to our users during our registration
    step or in the administrative dashboard, as shown. In this example, we''re fetching
    the admin role and assigning it to our administrative user, which has a user ID
    of `4`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'Alternatively, we can define an implicit default role within our `authManager`
    component. This way, we do not need to explicitly assign new users to the lowest-level
    user role. This can be achieved as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: Custom authorization rules
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In addition to basic authentication roles and permissions, we can also define
    custom rules by extending `yii\rbac\Rule` and implementing the `execute()` method,
    as shown in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'Custom rules can be added to our `authManager` component, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: Checking if a user has access to a role
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'After configuring RBAC, creating the required roles, and assigning users to
    these roles, we can check to see if a user has access to a particular role using
    the `yii\web\User::can()` method, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'We can also check accessibility against our newly created rule by checking
    against the parent role and passing in the required data, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Though more explicit through the naming of roles and rules, using RBAC can quickly
    become confusing. When using RBAC, thoroughly document permissions, relationships,
    and rules for reference later.
  prefs: []
  type: TYPE_NORMAL
- en: Flash messages
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Rather than blindly redirecting users without information, we can utilize flash
    messages in Yii2 to display one-time useful pieces of information to the user,
    such as what action they need to perform in order to complete another action (such
    as them having to log in to view the secure page).
  prefs: []
  type: TYPE_NORMAL
- en: In Yii1, user-specified flash messages can be tied directly to the user component.
    In Yii2, they're solely managed by the session object. In this section, we'll
    show how to use flash messages by example by enhancing our login view. We'll also
    take advantage of several of the other widgets and helpers we've covered in previous
    chapters.
  prefs: []
  type: TYPE_NORMAL
- en: 'As shown in the previous section, when a user is a guest and they try to access
    a secure page, we simply redirect them back to the login page without any information.
    To provide good user experience, we can set a flash message before redirecting
    the user and then display that flash message in our login view. As an example,
    the `behaviors()` method of our controller will change to the following. Note
    the use of the `setFlash()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'Within our login view file, we can then check for the presence of a specific
    type of flash message using the `hasFlash()` method and then displaying a particular
    flash message using the `getFlash()` method, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: Now if we navigate our browser to site/secure without being authenticated, we
    are shown the following. Moreover, if we refresh the page again, the flash message
    disappears, as flash messages are only intended to be displayed once.
  prefs: []
  type: TYPE_NORMAL
- en: '![Flash messages](img/00038.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Hashing and encryption
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When dealing with user information, it''s essential to be mindful of best security
    practices in order to ensure that user information such as passwords is stored
    in a way that if your database is compromised, the user''s bare passwords are
    not exposed in plain text. As shown in [Chapter 3](part0023_split_000.html#LTSU1-ad3e09b384df46aea690d9c8897d5fe7
    "Chapter 3. Migrations, DAO, and Query Building"), *Migrations, DAO, and Query
    Building*, we''re using the native PHP `password_hash()` and `password_verify()`
    functions to encrypt and decrypt our users'' passwords. While these standards
    are easy to use, in the development of your application, you may find it easier
    to take advantage of the Yii2 security component used to hash user passwords and
    for the encryption of sensitive data:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: Hashing and verifying passwords
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'With Yii2, we can hash and verify user passwords using the `generatePasswordHash()`
    and `validatePassword()` methods of the security component. Like the `password_hash()`
    and `password_verify()` functions, the `generatePasswordHash()` and `validatePassword()`
    methods use `bcrypt` to hash the user passwords:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'Passwords can then be verified, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'By default, Yii2 will use the PHP `crypt()` function to generate password hashes,
    but can, optionally, be configured to use the raw `password_hash()` methods using
    the `PASSWORD_DEFAULT` algorithm by setting the `passwordHashStrategy` property
    of the security component within the application configuration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: It's highly recommended that you use the `password_hash` strategy over crypt
    as PHP will continue to strengthen the hashing algorithm of `PASSWORD_DEFAULT`
    to increase the security of PHP.
  prefs: []
  type: TYPE_NORMAL
- en: The password hashing methods implemented by Yii2, however, are simply wrappers
    around native PHP functions. Both the native functions and Yii2 implementations
    will remain backward-compatible with each other. For a more object-oriented approach,
    it's recommended that you use Yii2 methods.
  prefs: []
  type: TYPE_NORMAL
- en: Data encryption and decryption
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'For convenience, Yii2 provides a way to encrypt and decrypt data using a secret
    key or a user''s passwords. To encrypt data with Yii2, we can use the `encryptByPassword()`
    method of the security component, as shown in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'Data can then be decrypted using the `decryptByPassword()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The secret password used for the encrypt and decrypt methods should be unique
    to the user and be stored in a format that if our database is compromised, the
    secret password itself is not compromised. A good secret to use would be the separate
    password submitted by the user.
  prefs: []
  type: TYPE_NORMAL
- en: Data hashing
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In addition to hashing passwords and encrypting data, we can also hash data
    for integrity verification using the `hashData()` and `validateData()` methods.
    These methods will be beneficial to present and validate checksums of files or
    raw data:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Unlike encrypted data, hashed data cannot be recovered to its original state.
    Hashes are beneficial in order to verify that information hasn't been tampered
    with, and it ensures that the integrity of files or data is consistent after transmission.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we covered the basics of authenticating the identity of our
    users and granting them access to certain pages based upon attributes we set in
    the user identity interface, and how to implement Yii2's hierarchical role-based
    authentication. We also explored how to use flash messages to enhance our user
    experience. Additionally, we explored a few components of the security component,
    which enabled us to hash the user's passwords, hash and verify data, and encrypt
    and decrypt information utilizing the user's password.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we'll cover more complex routing within our application,
    how to work with and modify our responses directly with Yii2, and the basics of
    listening and responding to events.
  prefs: []
  type: TYPE_NORMAL
