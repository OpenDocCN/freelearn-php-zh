- en: Chapter 7. Authenticating and Authorizing Users
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第7章. 认证和授权用户
- en: When working with modern web applications, we often need to authenticate our
    users to ensure that they are who they claim to be and that they have the appropriate
    permissions (authorization) required to access information. In this chapter, we'll
    cover the basics of authenticating users with Yii2 and granting them access to
    specific pages within our applications using basic access control filters and
    more complex role-based access control filters.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 当与现代Web应用一起工作时，我们经常需要认证我们的用户，以确保他们是他们所声称的那个人，并且他们拥有访问信息的适当权限（授权）。在本章中，我们将介绍使用Yii2认证用户的基础知识，并探讨如何使用基本访问控制过滤器以及更复杂的基于角色的访问控制过滤器，让他们访问我们应用中的特定页面。
- en: Tip
  id: totrans-2
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: In this chapter, we'll be building upon the migration scripts and models we
    created in [Chapter 4](part0030_split_000.html#SJGS2-ad3e09b384df46aea690d9c8897d5fe7
    "Chapter 4. Active Record, Models, and Forms"), *Active Record, Models, and Forms*.
    Before starting this chapter, make sure you have a good understanding of the models
    and migrations we created in that chapter.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将基于我们在[第4章](part0030_split_000.html#SJGS2-ad3e09b384df46aea690d9c8897d5fe7
    "第4章. 活动记录、模型和表单")中创建的迁移脚本和模型，即*活动记录、模型和表单*。在开始本章之前，请确保您已经很好地理解了在该章中创建的模型和迁移。
- en: Authentication of users
  id: totrans-4
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 用户认证
- en: With nearly every sufficiently sized web application, we will ultimately need
    our application to support the storage and authentication of users in order to
    ensure that the users working with our application are who they claim to be. With
    web applications, we typically handle authentication through a public identity
    (such as an e-mail address) and a secret that the user knows (such as a password).
    Depending upon the sensitivity of our data and our threat model, we can also extend
    our authentication process to include a two-factor authentication code issued
    either through an SMS text message or a two-factor authentication application,
    such as Authy or Google Authenticator. In this section, we'll cover how to implement
    basic authentication with Yii2 and explore how we can enhance the security of
    our users through the authentication process.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 几乎对于每一个足够规模的Web应用，我们最终都需要我们的应用支持用户存储和认证，以确保与我们的应用一起工作的用户是他们所声称的那个人。在Web应用中，我们通常通过公开的身份（如电子邮件地址）和用户知道的秘密（如密码）来处理认证。根据我们数据的安全性和我们的威胁模型，我们还可以扩展我们的认证过程，包括通过短信文本消息或Authy或Google
    Authenticator等双因素认证应用发出的双因素认证代码。在本节中，我们将介绍如何使用Yii2实现基本认证，并探讨我们如何通过认证过程增强我们用户的网络安全。
- en: 'In Yii2, authentication is managed through the user component and is defined
    in our `config/web.php` application configuration file. Before we can start authenticating
    users in our application, we first need to define this component in our configuration
    file. Specifically, we need to tell Yii2 where it can find the identity class
    we''ll use to handle the authentication logic within our application. In the following
    code block, we''ve defined our identity class as our User model that we created
    in [Chapter 3](part0023_split_000.html#LTSU1-ad3e09b384df46aea690d9c8897d5fe7
    "Chapter 3. Migrations, DAO, and Query Building"), *Migrations, DAO, and Query
    Building*:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在Yii2中，认证是通过用户组件管理的，并在我们的`config/web.php`应用配置文件中定义。在我们开始在我们的应用中认证用户之前，我们首先需要在配置文件中定义此组件。具体来说，我们需要告诉Yii2它可以在哪里找到我们将用于处理应用内认证逻辑的身份类。在下面的代码块中，我们已经将我们的身份类定义为我们在[第3章](part0023_split_000.html#LTSU1-ad3e09b384df46aea690d9c8897d5fe7
    "第3章. 迁移、DAO和查询构建")中创建的用户模型，即*Migrations, DAO, and Query Building*：
- en: '[PRE0]'
  id: totrans-7
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: In the upcoming sections, we'll go over how to extend our `User` class to support
    authentication.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的章节中，我们将介绍如何扩展我们的`User`类以支持认证。
- en: Implementing the user identity interface
  id: totrans-9
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现用户身份接口
- en: To implement our identity class with the required authentication logic, we must
    first have our identity class (`app\models\User`, defined in `models\User.php`)
    implement `yii\web\IdentityInterface`.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 要实现具有所需认证逻辑的我们的身份类，我们首先必须让我们的身份类（`app\models\User`，在`models\User.php`中定义）实现`yii\web\IdentityInterface`。
- en: Tip
  id: totrans-11
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: Remember, in PHP 5+, interfaces are PHP constructs that define which methods
    the implemented class must contain.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，在PHP 5+中，接口是PHP构造，用于定义实现类必须包含哪些方法。
- en: 'In PHP 5+, we can enhance our `User` object with the required interface methods
    by first using the `implements` keyword in our class, as follows:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在PHP 5+中，我们可以通过在我们的类中使用`implements`关键字来增强我们的`User`对象，如下所示：
- en: '[PRE1]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Then, we can implement the methods outlined in the `IdentityInterface` interface.
    These methods are `findIdentity($id)`, `findIdentityByAccessToken()`, `getId()`,
    `getAuthKey($token, $type)`, and `validateAuthKey($authKey)`:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以实现`IdentityInterface`接口中概述的方法。这些方法是`findIdentity($id)`、`findIdentityByAccessToken()`、`getId()`、`getAuthKey($token,
    $type)`和`validateAuthKey($authKey)`：
- en: The first method we need to implement is `findIdentity($id)`. This method is
    responsible for finding an instance of the `identity` class with the specified
    `$id` attribute, and is primarily used when Yii2 needs to authenticate the user
    from the session data.
  id: totrans-16
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要实现的第一种方法是`findIdentity($id)`。此方法负责找到具有指定`$id`属性的`identity`类的实例，并且主要用于当Yii2需要从会话数据中验证用户时。
- en: 'To implement this method, we need to define the static method and return an
    instance of our `User` class, as shown in the following example:'
  id: totrans-17
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要实现此方法，我们需要定义静态方法并返回我们的`User`类的一个实例，如下面的示例所示：
- en: '[PRE2]'
  id: totrans-18
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The next method defined in `yii\web\IdentityInterface` that we need to define
    is `findIdentityByAccessToken($token, $type)`. In Yii2, authentication can be
    handled through a frontend web form, a cookie (if we''re using cookie-based authentication),
    or a RESTful API. The `findIdentityByAccessToken` method is used when we''re using
    RESTful authentication. Since our application doesn''t have a REST API yet, we
    can simply define this method with an empty body, as follows:'
  id: totrans-19
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`yii\web\IdentityInterface`中定义的下一个我们需要定义的方法是`findIdentityByAccessToken($token,
    $type)`。在Yii2中，认证可以通过前端网页表单、Cookie（如果我们使用基于Cookie的认证）或RESTful API来处理。`findIdentityByAccessToken`方法用于我们使用RESTful认证时。由于我们的应用程序还没有REST
    API，我们可以简单地定义此方法为空体，如下所示：
- en: '[PRE3]'
  id: totrans-20
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Tip
  id: totrans-21
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: 'If we want to add basic support for token-based authentication, we will need
    to perform the following steps:'
  id: totrans-22
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果我们想要添加基于令牌的认证的基本支持，我们需要执行以下步骤：
- en: 1\. Add a new migration to store an access token with our user data.
  id: totrans-23
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 1. 添加一个新的迁移来存储与我们的用户数据一起的访问令牌。
- en: 2\. Create an API-based authentication method that generates an access token
    and store it alongside our user data
  id: totrans-24
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 2. 创建一个基于API的认证方法，该方法生成访问令牌并将其存储在我们的用户数据旁边
- en: '3\. Implement the `findIdentityByAccessToken()` method, as follows:'
  id: totrans-25
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 3. 实现以下`findIdentityByAccessToken()`方法：
- en: '[PRE4]'
  id: totrans-26
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: We'll cover RESTful API authentication in more detail in [Chapter 9](part0052_split_000.html#1HIT82-ad3e09b384df46aea690d9c8897d5fe7
    "Chapter 9. RESTful APIs"), *RESTful APIs*.
  id: totrans-27
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们将在[第9章](part0052_split_000.html#1HIT82-ad3e09b384df46aea690d9c8897d5fe7 "第9章。RESTful
    APIs")中更详细地介绍RESTful API认证，*RESTful APIs*。
- en: 'Next, we need to explicitly define the `getId()` method, which will return
    the ID of our user:'
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们需要明确定义`getId()`方法，它将返回我们用户的ID：
- en: '[PRE5]'
  id: totrans-29
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Tip
  id: totrans-30
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: While `yii\base\Object`, which `yii\base\ActiveRecord` extends from, defines
    a magic method `__getter` for all of our public properties defined in our `ActiveRecord`
    instance, interfaces in PHP 5+ require all methods listed in the interface to
    be explicitly defined.
  id: totrans-31
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 虽然`yii\base\Object`，`yii\base\ActiveRecord`从中扩展，为我们在`ActiveRecord`实例中定义的所有公共属性定义了一个魔法方法`__getter`，但PHP
    5+中的接口要求显式定义接口中列出的所有方法。
- en: 'Finally, we need to implement the `getAuthKey()` and `validateAuthKey()` methods
    within our application. As stated previously, these two methods are explicitly
    used for cookie-based authentication. Since we won''t be using cookie-based authentication
    in this chapter, we can leave these two methods, as follows:'
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们需要在我们的应用程序中实现`getAuthKey()`和`validateAuthKey()`方法。如前所述，这两个方法专门用于基于Cookie的认证。由于我们本章不会使用基于Cookie的认证，我们可以简单地定义这两个方法，如下所示：
- en: '[PRE6]'
  id: totrans-33
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Cookie-based authentication
  id: totrans-34
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 基于Cookie的认证
- en: 'When working with users, we often need to include a feature similar to the
    *Remember me* feature in our application so that our users can seamlessly log
    in to our application after they have been away for some time. To make cookie-based
    authentication work in Yii2, we need to make several changes to our application:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 当与用户一起工作时，我们经常需要在我们的应用程序中包含一个类似于*记住我*功能的功能，以便我们的用户在离开一段时间后可以无缝地登录到我们的应用程序。为了使基于Cookie的认证在Yii2中工作，我们需要对我们的应用程序进行一些更改：
- en: 'First, we need to set the `enableAutoLogin` property of our user component
    in our web configuration file to `true`. This will allow Yii2 to automatically
    log users in if they have the appropriate cookie set:'
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们需要在我们的网络配置文件中将用户组件的 `enableAutoLogin` 属性设置为 `true`。这将允许 Yii2 在用户设置了适当的
    cookie 后自动登录：
- en: '[PRE7]'
  id: totrans-37
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Next, we''ll need to define a location to store and persist our user''s cookie-based
    authentication token. One way to achieve this would be to add an additional migration
    that adds an `auth_key` column to our user table. During the creation of our user,
    we can then seed this value, as follows:'
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们需要定义一个位置来存储和持久化我们的基于 cookie 的认证令牌。一种实现方式是添加一个额外的迁移，为我们的用户表添加一个 `auth_key`
    列。在创建我们的用户时，我们可以设置此值，如下所示：
- en: '[PRE8]'
  id: totrans-39
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Tip
  id: totrans-40
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: Alternatively, we can make this value persist into a secondary storage system,
    such as in Memcached or Redis. We'll cover how to use cache data using Redis and
    Memcached in [Chapter 12](part0075_split_000.html#27GQ62-ad3e09b384df46aea690d9c8897d5fe7
    "Chapter 12. Performance and Security"), *Performance and Security*.
  id: totrans-41
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 或者，我们可以将此值持久化到二级存储系统中，例如 Memcached 或 Redis。我们将在 [第 12 章](part0075_split_000.html#27GQ62-ad3e09b384df46aea690d9c8897d5fe7
    "第 12 章。性能和安全") 中介绍如何使用 Redis 和 Memcached 缓存数据，*性能和安全*。
- en: 'Finally, when we define our login form method that instantiates our `IdentityInterface`
    object, we''ll need to log the user in with a duration, as follows:'
  id: totrans-42
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，当我们定义我们的登录表单方法以实例化我们的 `IdentityInterface` 对象时，我们需要以如下方式记录用户的登录时长：
- en: '[PRE9]'
  id: totrans-43
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Yii2 will consequently create a cookie that it will use internally and that
    will automatically log the user in as long as the cookie is valid. If the duration
    is not set, session-based authentication will be used instead of a cookie-based
    one, which means that our user session will expire when the user closes their
    browser rather than when the user's cookie expires.
  id: totrans-44
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: Yii2 将创建一个 cookie，它将用于内部操作，并且只要 cookie 有效，就会自动登录用户。如果没有设置时长，将使用基于会话的认证而不是基于
    cookie 的认证，这意味着当用户关闭浏览器时，我们的用户会话将过期，而不是当用户的 cookie 过期时。
- en: Working with user identities
  id: totrans-45
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 与用户身份交互
- en: Now that we've defined the methods required for our identity interface, let's
    take a look at the `yii\web\User` object in more detail.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经定义了我们的身份接口所需的方法，让我们更详细地看看 `yii\web\User` 对象。
- en: Tip
  id: totrans-47
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: Remember, the `yii\web\User` class is distinct from the `app\models\User` class.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，`yii\web\User` 类与 `app\models\User` 类是不同的。
- en: 'The `yii\web\User` object is referenced in Yii2 through `\Yii::$app->user`,
    which contains information on the current user. Information about our user can
    be retrieved through the `\Yii::$app->user->identity` property. If a user isn''t
    authenticated, this property will be `NULL`. However, if a user is authenticated,
    it will be populated with information about the current user. For instance, if
    we want to fetch the complete name of the user as defined in the `app\models\User`
    class we extended in [Chapter 4](part0030_split_000.html#SJGS2-ad3e09b384df46aea690d9c8897d5fe7
    "Chapter 4. Active Record, Models, and Forms"), *Active Record, Models, and Forms*,
    we can do that as follows:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '`yii\web\User` 对象在 Yii2 中通过 `\Yii::$app->user` 来引用，它包含了当前用户的信息。我们可以通过 `\Yii::$app->user->identity`
    属性来检索我们用户的信息。如果一个用户未认证，这个属性将是 `NULL`。然而，如果一个用户已认证，它将包含当前用户的信息。例如，如果我们想获取用户在 [第
    4 章](part0030_split_000.html#SJGS2-ad3e09b384df46aea690d9c8897d5fe7 "第 4 章。活动记录、模型和表单")
    中定义的完整姓名，即 *活动记录、模型和表单*，我们可以这样做：'
- en: '[PRE10]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Alternatively, we can detect whether a user is logged in by checking the `isGuest`
    property of `yii\web\User`, as follows. This property will return `true` if the
    user is not authenticated and `false` if they are:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，我们可以通过检查 `yii\web\User` 的 `isGuest` 属性来检测用户是否已登录。如果用户未认证，此属性将返回 `true`；如果已认证，则返回
    `false`：
- en: '[PRE11]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Moreover, if we want to retrieve the ID of the user, we can access it through
    the `getId()` method we defined in our `User` class:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，如果我们想获取用户的 ID，我们可以通过我们在 `User` 类中定义的 `getId()` 方法来访问它：
- en: '[PRE12]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Finally, we can log our user in and out of our application using the respective
    `login()` and `logout()` methods in `Yii::$app->user`. To log a user in, we first
    need to create an instance of the identity we established earlier. In the following
    example, we''re fetching the identity information from the user''s e-mail address.
    As mentioned previously, we can also supply a duration parameter as part of the
    `login()` method for cookie-based authentication:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们可以使用`Yii::$app->user`中的相应`login()`和`logout()`方法在我们的应用程序中登录和注销用户。要登录用户，我们首先需要创建我们之前建立的标识实例。在下面的示例中，我们正在从用户的电子邮件地址获取标识信息。如前所述，我们还可以将持续时间参数作为`login()`方法的一部分提供，用于基于cookie的认证：
- en: '[PRE13]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: After we're authenticated, we can log users out of our application by calling
    `\Yii::$app->user->logout()`. By default, this parameter will destroy all the
    session data associated with the current user. If we want to preserve this data,
    we can pass `false` as the first parameter to the `logout()` method.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们认证之后，我们可以通过调用`\Yii::$app->user->logout()`来将用户从我们的应用程序中注销。默认情况下，此参数将销毁与当前用户关联的所有会话数据。如果我们想保留这些数据，我们可以将`false`作为`logout()`方法的第一个参数传递。
- en: Authenticating users with forms
  id: totrans-58
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用表单验证用户
- en: 'Now that we''ve implemented our identity interface and know the basics of the
    `yii\web\User` component, let''s piece these components together with the user
    data we created in [Chapter 3](part0023_split_000.html#LTSU1-ad3e09b384df46aea690d9c8897d5fe7
    "Chapter 3. Migrations, DAO, and Query Building"), *Migrations, DAO, and Query
    Building*, and the `UserForm` class and scenario we created in [Chapter 4](part0030_split_000.html#SJGS2-ad3e09b384df46aea690d9c8897d5fe7
    "Chapter 4. Active Record, Models, and Forms"), *Active Record, Models, and Forms*.
    As a reminder, here is the `UserForm` class we started with in [Chapter 4](part0030_split_000.html#SJGS2-ad3e09b384df46aea690d9c8897d5fe7
    "Chapter 4. Active Record, Models, and Forms"), *Active Record, Models, and Forms*:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经实现了我们的身份接口，并且了解了`yii\web\User`组件的基础知识，让我们将这些组件与我们在[第3章](part0023_split_000.html#LTSU1-ad3e09b384df46aea690d9c8897d5fe7
    "第3章。迁移、DAO和查询构建")中创建的用户数据、*迁移、DAO和查询构建*以及我们在[第4章](part0030_split_000.html#SJGS2-ad3e09b384df46aea690d9c8897d5fe7
    "第4章。活动记录、模型和表单")中创建的`UserForm`类和场景组合在一起。作为提醒，以下是我们在[第4章](part0030_split_000.html#SJGS2-ad3e09b384df46aea690d9c8897d5fe7
    "第4章。活动记录、模型和表单")中开始的`UserForm`类：
- en: '[PRE14]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'To enhance our `UserForm` class to facilitate logging in, we need to make a
    couple of changes:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 为了增强我们的`UserForm`类以方便登录，我们需要进行一些更改：
- en: 'First, since we''ll be working with our identity object in multiple places,
    we should create a private variable to store it. This will help reduce the number
    of queries we need to make to our database when working with our form. We''ll
    also want to define a method to retrieve this property:'
  id: totrans-62
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，由于我们将在多个地方使用我们的身份对象，我们应该创建一个私有变量来存储它。这将有助于减少我们在使用表单时对数据库进行的查询次数。我们还将想要定义一个方法来检索这个属性：
- en: '[PRE15]'
  id: totrans-63
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Next, we''ll need to implement a method to validate our user''s password. As
    mentioned in [Chapter 3](part0023_split_000.html#LTSU1-ad3e09b384df46aea690d9c8897d5fe7
    "Chapter 3. Migrations, DAO, and Query Building"), *Migrations, DAO, and Query
    Building*, we''re hashing the user''s password using the PHP 5 `password_hash`
    method. To validate passwords that are hashed this way, we can use the PHP 5 `password_verify`
    method. For our application, let''s add a `verifyPassword()` method to our `app\models\User`
    class:'
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们需要实现一个方法来验证用户的密码。如[第3章](part0023_split_000.html#LTSU1-ad3e09b384df46aea690d9c8897d5fe7
    "第3章。迁移、DAO和查询构建")中所述，*迁移、DAO和查询构建*，我们使用PHP 5的`password_hash`方法对用户的密码进行散列。为了验证以这种方式散列的密码，我们可以使用PHP
    5的`password_verify`方法。对于我们的应用程序，让我们在我们的`app\models\User`类中添加一个`verifyPassword()`方法：
- en: '[PRE16]'
  id: totrans-65
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'To call this method, we''re going to add a new validator to the `rules()` method
    of our `UserForm` class that only executes on the login scenario we defined previously:'
  id: totrans-66
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要调用此方法，我们将向我们的`UserForm`类的`rules()`方法添加一个新的验证器，该验证器仅在之前定义的登录场景中执行：
- en: '[PRE17]'
  id: totrans-67
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Recalling the information we covered in [Chapter 4](part0030_split_000.html#SJGS2-ad3e09b384df46aea690d9c8897d5fe7
    "Chapter 4. Active Record, Models, and Forms"), *Active Record, Models, and Forms*,
    we know that in the login scenario, the `validatePassword` method will be called
    to satisfy the new validation rule we added to our `rules()` method. We can define
    this method as follows:'
  id: totrans-68
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 回想我们在[第4章](part0030_split_000.html#SJGS2-ad3e09b384df46aea690d9c8897d5fe7 "第4章。Active
    Record, Models, and Forms")中介绍的信息，即*Active Record, Models, and Forms*，我们知道在登录场景中，`validatePassword`方法将被调用以满足我们添加到`rules()`方法中的新验证规则。我们可以定义此方法如下：
- en: '[PRE18]'
  id: totrans-69
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: We'll finalize our `UserForm` class by adding a `login()` method that will validate
    the email and password submitted by our user and then log the user in.
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将通过添加一个`login()`方法来最终化我们的`UserForm`类，该方法将验证用户提交的电子邮件和密码，然后登录用户。
- en: '[PRE19]'
  id: totrans-71
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'With our form finalized, we can then implement the login action in our controller
    that will finish the workflow. In our case, let''s have our login action redirect
    the user to a page that will display some information about the user after they''re
    logged in. Since we''ve already defined the bulk of this action back in [Chapter
    4](part0030_split_000.html#SJGS2-ad3e09b384df46aea690d9c8897d5fe7 "Chapter 4. Active
    Record, Models, and Forms"), *Active Record, Models, and Forms*, a small change
    is required for this action:'
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在我们的表单最终化后，我们可以在控制器中实现登录操作，以完成工作流程。在我们的情况下，让我们让登录操作将用户重定向到一个页面，在用户登录后显示一些关于用户的信息。由于我们已经在[第4章](part0030_split_000.html#SJGS2-ad3e09b384df46aea690d9c8897d5fe7
    "第4章。Active Record, Models, and Forms")中定义了此操作的绝大部分，因此对此操作只需要进行小的修改：
- en: '[PRE20]'
  id: totrans-73
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: For illustration purposes, let's also dump the information from `\Yii::$app->user->identity`
    on this page so that we can see it. We can do this by creating the secure action
    we mentioned previously and then using the `VarDumper` helper to print this information.
  id: totrans-74
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 为了说明目的，让我们也在这页上显示`\Yii::$app->user->identity`的信息，以便我们可以看到它。我们可以通过创建之前提到的安全操作，然后使用`VarDumper`辅助程序来打印这些信息。
- en: '[PRE21]'
  id: totrans-75
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Since we already created our login view in [Chapter 4](part0030_split_000.html#SJGS2-ad3e09b384df46aea690d9c8897d5fe7
    "Chapter 4. Active Record, Models, and Forms"), *Active Record, Models, and Forms*,
    we can authenticate ourselves into the application using the credentials listed
    in that chapter. For example, we can log in as an admin using the following credentials:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们已经在[第4章](part0030_split_000.html#SJGS2-ad3e09b384df46aea690d9c8897d5fe7
    "第4章。Active Record, Models, and Forms")中创建了我们的登录视图，即*Active Record, Models, and
    Forms*，因此我们可以使用该章节中列出的凭据来验证我们的应用程序。例如，我们可以使用以下凭据登录为管理员：
- en: 'Username: `admin@example.com`'
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户名：`admin@example.com`
- en: 'Password: `admin`'
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 密码：`admin`
- en: If authenticated successfully, we will be redirected to the secure page that
    dumps our user attributes on the page.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 如果身份验证成功，我们将被重定向到显示我们用户属性的安全页面。
- en: '[PRE22]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Authorization
  id: totrans-81
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 授权
- en: Though we're now able to authenticate ourselves against our database, we need
    to implement the necessary methods in order to ensure that the right people can
    access the right pages. To do this, we need to implement either an access control
    filter or a role-based access control filter.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我们现在能够对我们的数据库进行身份验证，但我们需要实现必要的方法以确保正确的人可以访问正确的页面。为此，我们需要实现访问控制过滤器或基于角色的访问控制过滤器。
- en: Access control filters
  id: totrans-83
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 访问控制过滤器
- en: 'One way to control access to certain pages is to create access control filters.
    Access control filters in Yii2 are behaviors we can bind to our controllers to
    ensure that the right people have access to the right content. The access control
    filter is implemented through `yii\filter\AccessControl` and is primarily used
    when simple access control is needed, such when needing to make sure users are
    logged in or not (although it can be configured for rules that are more complex).
    As a filter, `yii\filter\AccessControl` is implemented in the `behaviors()` method
    of our controller, as shown in the following example:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 控制对某些页面的访问的一种方法是通过创建访问控制过滤器。在Yii2中，访问控制过滤器是我们可以绑定到我们的控制器上的行为，以确保正确的人有权访问正确的内容。访问控制过滤器通过`yii\filter\AccessControl`实现，主要用于需要简单访问控制的情况，例如需要确保用户是否已登录（尽管它可以配置为更复杂的规则）。作为一个过滤器，`yii\filter\AccessControl`在我们的控制器中的`behaviors()`方法中实现，如下例所示：
- en: '[PRE23]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'The previously mentioned code does several things, so let''s break it down:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 之前提到的代码执行了几个操作，让我们来分解一下：
- en: 'As mentioned in previous chapters, behaviors return an array of options. In
    this case, the first behavior we''re returning is the access behavior, which specifies
    the `yii\filter\AccessControl` filter as the class this behavior should use:'
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如前几章所述，行为返回一个选项数组。在这种情况下，我们返回的第一个行为是访问行为，它指定了`yii\filter\AccessControl`过滤器作为此行为应使用的类：
- en: '[PRE24]'
  id: totrans-88
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Next, we define the actions we want our filter to apply. In this case, we only
    want `yii\filter\AccessControl` to be applied to the login, logout, and register
    actions of our `SiteController` object.
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们定义我们希望我们的过滤器应用的操作。在这种情况下，我们只想将`yii\filter\AccessControl`应用于我们的`SiteController`对象的登录、注销和注册操作。
- en: '[PRE25]'
  id: totrans-90
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Finally, we define the rules that our filter should obey. In the following
    snippet, we declare that we want unauthenticated users (designated by the special
    character `?` within the roles section) to access the login and register action
    and allow any authenticated user (designated by the special character `@` within
    the roles section) to access the logout action:'
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们定义我们的过滤器应遵守的规则。在下面的代码片段中，我们声明我们希望未经认证的用户（在角色部分由特殊字符`?`指定）可以访问登录和注册操作，并允许任何已认证的用户（在角色部分由特殊字符`@`指定）可以访问注销操作：
- en: '[PRE26]'
  id: totrans-92
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'By default, if a user is unauthenticated, our access control filter will redirect
    the user to our login page, and if they do not have access, `yii\web\ForbiddenHttpException`
    will be thrown. As this isn''t always desirable, we can modify our filter by setting
    the `denyCallback` parameter of our filter. Also, we can, within the rules section
    of our filter, define the conditions upon which an error can occur by setting
    the `matchCallback` property. As an example, if we want to make our secure action
    accessible to only administrators, we can write the following code:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，如果用户未认证，我们的访问控制过滤器将重定向用户到我们的登录页面，如果他们没有访问权限，将抛出`yii\web\ForbiddenHttpException`。由于这并不总是期望的，我们可以通过设置过滤器的`denyCallback`参数来修改我们的过滤器。此外，我们可以在过滤器的规则部分中，通过设置`matchCallback`属性来定义错误可能发生的情况。例如，如果我们想使我们的安全操作仅对管理员可访问，我们可以编写以下代码：
- en: '[PRE27]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: In this section, users are only allowed to use the secure action if they have
    a role of `2` (which is the role we designated as an administrator in [Chapter
    3](part0023_split_000.html#LTSU1-ad3e09b384df46aea690d9c8897d5fe7 "Chapter 3. Migrations,
    DAO, and Query Building"), *Migrations, DAO, and Query Building*). If they aren't
    authenticated, we redirect them to the login page, and if they are authenticated
    but don't have sufficient permissions, we throw an HTTP 403 error.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，用户只有在其角色为`2`（这是我们将在[第3章](part0023_split_000.html#LTSU1-ad3e09b384df46aea690d9c8897d5fe7
    "第3章。迁移、DAO和查询构建")中指定的管理员角色）时才能使用安全操作。如果他们未认证，我们将重定向他们到登录页面；如果他们已认证但权限不足，我们将抛出HTTP
    403错误。
- en: Tip
  id: totrans-96
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: The example shown previously is to illustrate what we can do with the `matchCallback`
    and `denyCallback` properties of our access control filter.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 之前显示的示例是为了说明我们可以使用访问控制过滤器的`matchCallback`和`denyCallback`属性做什么。
- en: 'With an access control filter, we can restrict access to certain actions by
    the IP address by setting the `ips` parameter within our rules section, as shown.
    IP addresses can be restricted either by a specific IP or by a subnet using the
    wildcard character, as shown in the following example:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 通过访问控制过滤器，我们可以在规则部分设置`ips`参数来通过IP地址限制对某些操作的访问，如下所示。IP地址可以通过特定的IP或使用通配符字符的子网进行限制，如下面的示例所示：
- en: '[PRE28]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Additionally, we can restrict access to our action by specifying which HTTP
    verbs are permitted using the `yii\filter\VerbFilter` filter. For instance, if
    we want to ensure that only `GET` requests can be run against our secure action,
    we can define the following behavior:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们可以通过指定允许的HTTP动词来限制对操作的访问，使用`yii\filter\VerbFilter`过滤器。例如，如果我们想确保只有`GET`请求可以针对我们的安全操作运行，我们可以定义以下行为：
- en: '[PRE29]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'By default, our access control filter will attempt to apply itself to every
    action within our controller. To specify the actions that our filter should be
    restricted to, we can set the `only` property of our filter:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，我们的访问控制过滤器将尝试将自身应用于我们控制器中的每个操作。为了指定我们的过滤器应限制的操作，我们可以设置过滤器的`only`属性：
- en: '[PRE30]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Additionally, we can specify actions that our access control rules should be
    applied to by setting the `actions` property of our `rules` array:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们可以通过设置`rules`数组的`actions`属性来指定我们的访问控制规则应应用的操作：
- en: '[PRE31]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'In a manner similar to the `only` parameter, we can exclude certain actions
    from the authentication filter by setting the `except` filter:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 类似于`only`参数，我们可以通过设置`except`过滤器来排除某些操作从身份验证过滤器：
- en: '[PRE32]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Tip
  id: totrans-108
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: Access control filters are broken down into rules, as shown in the previous
    example. Each rule applies only to a specific set of actions, which allows us
    to specify custom allow or deny callbacks for these rules. The parent options
    of `only` and `except`, however, specify when the parent access control filter
    should be applied.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 访问控制过滤器被分解为规则，如前一个示例所示。每个规则仅适用于一组特定的操作，这允许我们为这些规则指定自定义的允许或拒绝回调。然而，`only`和`except`的父选项指定了父访问控制过滤器何时应用。
- en: Role-based access control
  id: totrans-110
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 基于角色的访问控制
- en: As an alternative to managing access with the user identity object, we can also
    manage access to actions by configuring **role-based access control** (**RBAC**)
    within our application. In Yii2, RBAC works by creating roles that represent a
    collection of permissions and then assigning roles to a specific user. Roles are
    represented by a check to determine if a given role or permission is applicable
    to the user in question. In this section, we'll cover the basics of configuring
    and working with RBAC in Yii2.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 作为使用用户身份对象管理访问的替代方案，我们也可以通过在我们的应用程序中配置**基于角色的访问控制**（**RBAC**）来管理对操作的访问。在Yii2中，RBAC通过创建代表一组权限的角色，然后将这些角色分配给特定用户来实现。角色通过检查来确定给定的角色或权限是否适用于相关用户。在本节中，我们将介绍在Yii2中配置和使用RBAC的基本知识。
- en: Tip
  id: totrans-112
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: Yii2's implementation of RBAC follows the NIST RBAC model through the `authManager`
    component. The complete implementation details of the NIST RBAC model are located
    at [http://csrc.nist.gov/rbac/sandhu-ferraiolo-kuhn-00.pdf](http://csrc.nist.gov/rbac/sandhu-ferraiolo-kuhn-00.pdf).
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: Yii2对RBAC的实现通过`authManager`组件遵循NIST RBAC模型。NIST RBAC模型的完整实现细节位于[http://csrc.nist.gov/rbac/sandhu-ferraiolo-kuhn-00.pdf](http://csrc.nist.gov/rbac/sandhu-ferraiolo-kuhn-00.pdf)。
- en: Configuring RBAC
  id: totrans-114
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 配置RBAC
- en: To start working with RBAC, we first need to configure our `authManager` component
    for RBAC and define the authorization manager we want to use. Yii2 provides two
    different authorization managers, the first being `yii\rbac\PhpManager`, which
    uses a PHP script to store authorization data, and `yii\rbac\DbManager`, which
    utilizes the application database to manage authorization data. For simple applications
    with nondynamic permissions and roles, `yii\rbac\PhpManager` may be preferred.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始使用RBAC，我们首先需要为RBAC配置我们的`authManager`组件并定义我们想要使用的授权管理器。Yii2提供了两种不同的授权管理器，第一种是`yii\rbac\PhpManager`，它使用PHP脚本来存储授权数据，第二种是`yii\rbac\DbManager`，它利用应用程序数据库来管理授权数据。对于具有非动态权限和角色的简单应用程序，`yii\rbac\PhpManager`可能更受欢迎。
- en: 'To configure `authManager`, we simply need to define the class that we want
    to use, as follows:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 要配置`authManager`，我们只需定义我们想要使用的类，如下所示：
- en: '[PRE33]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Tip
  id: totrans-118
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: By default, `yii\rbac\PhpManager` will store authorization data in the `@app/rbac`
    directory, which must be writable by your web server.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，`yii\rbac\PhpManager`将授权数据存储在`@app/rbac`目录中，该目录必须可由您的Web服务器写入。
- en: 'Alternatively, if we''re using a database to manage our authorization data,
    we will configure `authManager` as follows:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，如果我们使用数据库来管理我们的授权数据，我们将按如下方式配置`authManager`：
- en: '[PRE34]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'When using our database to manage our authorization data, we need to run RBAC
    migrations to configure our database appropriately, which can be done by running
    the following command from our command-line interface:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用我们的数据库来管理我们的授权数据时，我们需要运行RBAC迁移来适当地配置我们的数据库，这可以通过从我们的命令行界面运行以下命令来完成：
- en: '[PRE35]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'This will result in output similar to the following:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 这将导致输出类似于以下内容：
- en: '[PRE36]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: After configuring RBAC, our `authManager` component can be accessed by `\Yii::$app->authManager`.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 配置RBAC后，我们可以通过`\Yii::$app->authManager`访问`authManager`组件。
- en: Creating permissions and permission relationships
  id: totrans-127
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建权限和权限关系
- en: 'After configuring our `authManager` component, we need to define the permissions
    we want our users to have and the relationships between them. For most applications
    with fixed permission hierarchies, this can be achieved by writing an RBAC console
    command to initialize the data in our database. In the following example, we''ll
    create three permissions for an imaginary issue management application, a permission
    for a user to create new issues, support for newly created issues, a supervisor
    to oversee supervisors, and an administrator permission:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 在配置我们的`authManager`组件之后，我们需要定义我们希望用户拥有的权限以及它们之间的关系。对于大多数具有固定权限层次结构的应用程序，这可以通过编写RBAC控制台命令来初始化数据库中的数据来实现。在以下示例中，我们将为虚构的问题管理应用程序创建三个权限：一个用户创建新问题的权限，支持新创建的问题，一个监督员监督监督员，以及管理员权限：
- en: '[PRE37]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Our newly created permission scheme can then be initialized by running the
    `rbac/init` command from our command line:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以通过从我们的命令行运行`rbac/init`命令来初始化我们新创建的权限方案：
- en: '[PRE38]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'After defining our roles, we can apply them to our users during our registration
    step or in the administrative dashboard, as shown. In this example, we''re fetching
    the admin role and assigning it to our administrative user, which has a user ID
    of `4`:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 在定义了我们的角色之后，我们可以在注册步骤或管理仪表板中将其应用于我们的用户，如下所示。在这个例子中，我们正在获取管理员角色并将其分配给具有用户ID `4`的管理员用户：
- en: '[PRE39]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Alternatively, we can define an implicit default role within our `authManager`
    component. This way, we do not need to explicitly assign new users to the lowest-level
    user role. This can be achieved as follows:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，我们可以在`authManager`组件中定义一个隐含的默认角色。这样，我们就不需要明确地将新用户分配到最低级别的用户角色。这可以通过以下方式实现：
- en: '[PRE40]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Custom authorization rules
  id: totrans-136
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 自定义授权规则
- en: 'In addition to basic authentication roles and permissions, we can also define
    custom rules by extending `yii\rbac\Rule` and implementing the `execute()` method,
    as shown in the following example:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 除了基本的身份验证角色和权限之外，我们还可以通过扩展`yii\rbac\Rule`并实现`execute()`方法来定义自定义规则，如下所示：
- en: '[PRE41]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Custom rules can be added to our `authManager` component, as follows:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将自定义规则添加到我们的`authManager`组件中，如下所示：
- en: '[PRE42]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Checking if a user has access to a role
  id: totrans-141
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 检查用户是否有访问角色的权限
- en: 'After configuring RBAC, creating the required roles, and assigning users to
    these roles, we can check to see if a user has access to a particular role using
    the `yii\web\User::can()` method, as shown here:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 在配置了RBAC、创建了所需的角色并将用户分配到这些角色之后，我们可以使用`yii\web\User::can()`方法来检查用户是否有访问特定角色的权限，如下所示：
- en: '[PRE43]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'We can also check accessibility against our newly created rule by checking
    against the parent role and passing in the required data, as shown here:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以通过检查父角色并传递所需数据来验证我们的新创建的规则是否可访问，如下所示：
- en: '[PRE44]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Tip
  id: totrans-146
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: Though more explicit through the naming of roles and rules, using RBAC can quickly
    become confusing. When using RBAC, thoroughly document permissions, relationships,
    and rules for reference later.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然通过角色和规则的命名更加明确，但使用RBAC可能会很快变得令人困惑。当使用RBAC时，请彻底记录权限、关系和规则以供以后参考。
- en: Flash messages
  id: totrans-148
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 闪存消息
- en: Rather than blindly redirecting users without information, we can utilize flash
    messages in Yii2 to display one-time useful pieces of information to the user,
    such as what action they need to perform in order to complete another action (such
    as them having to log in to view the secure page).
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 而不是盲目地重定向用户而不提供信息，我们可以利用Yii2中的闪存消息向用户显示一次性有用的信息，例如他们需要执行什么操作才能完成另一个操作（例如，他们必须登录才能查看受保护的页面）。
- en: In Yii1, user-specified flash messages can be tied directly to the user component.
    In Yii2, they're solely managed by the session object. In this section, we'll
    show how to use flash messages by example by enhancing our login view. We'll also
    take advantage of several of the other widgets and helpers we've covered in previous
    chapters.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 在Yii1中，用户指定的闪存消息可以直接绑定到用户组件。在Yii2中，它们完全由会话对象管理。在本节中，我们将通过增强我们的登录视图来举例说明如何使用闪存消息。我们还将利用我们在前几章中介绍的其他小部件和辅助工具。
- en: 'As shown in the previous section, when a user is a guest and they try to access
    a secure page, we simply redirect them back to the login page without any information.
    To provide good user experience, we can set a flash message before redirecting
    the user and then display that flash message in our login view. As an example,
    the `behaviors()` method of our controller will change to the following. Note
    the use of the `setFlash()` method:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 如前节所示，当用户是访客且尝试访问受保护页面时，我们只需将他们重定向回登录页面，不提供任何信息。为了提供良好的用户体验，我们可以在重定向用户之前设置一个闪存消息，然后在登录视图中显示该消息。例如，我们控制器的`behaviors()`方法将变为以下内容。注意`setFlash()`方法的使用：
- en: '[PRE45]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Within our login view file, we can then check for the presence of a specific
    type of flash message using the `hasFlash()` method and then displaying a particular
    flash message using the `getFlash()` method, as shown here:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的登录视图文件中，我们可以使用`hasFlash()`方法检查是否存在特定类型的闪存消息，然后使用`getFlash()`方法显示特定的闪存消息，如下所示：
- en: '[PRE46]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: Now if we navigate our browser to site/secure without being authenticated, we
    are shown the following. Moreover, if we refresh the page again, the flash message
    disappears, as flash messages are only intended to be displayed once.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果我们未经过认证就导航到site/secure，我们会看到以下内容。此外，如果我们再次刷新页面，闪存消息会消失，因为闪存消息只打算显示一次。
- en: '![Flash messages](img/00038.jpeg)'
  id: totrans-156
  prefs: []
  type: TYPE_IMG
  zh: '![闪存消息](img/00038.jpeg)'
- en: Hashing and encryption
  id: totrans-157
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 哈希和加密
- en: 'When dealing with user information, it''s essential to be mindful of best security
    practices in order to ensure that user information such as passwords is stored
    in a way that if your database is compromised, the user''s bare passwords are
    not exposed in plain text. As shown in [Chapter 3](part0023_split_000.html#LTSU1-ad3e09b384df46aea690d9c8897d5fe7
    "Chapter 3. Migrations, DAO, and Query Building"), *Migrations, DAO, and Query
    Building*, we''re using the native PHP `password_hash()` and `password_verify()`
    functions to encrypt and decrypt our users'' passwords. While these standards
    are easy to use, in the development of your application, you may find it easier
    to take advantage of the Yii2 security component used to hash user passwords and
    for the encryption of sensitive data:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 在处理用户信息时，必须注意最佳安全实践，以确保用户信息（如密码）以某种方式存储，如果您的数据库被破坏，用户的明文密码不会被暴露。如[第3章](part0023_split_000.html#LTSU1-ad3e09b384df46aea690d9c8897d5fe7
    "第3章。迁移、DAO和查询构建")所示，“迁移、DAO和查询构建”，我们正在使用原生的PHP `password_hash()`和`password_verify()`函数来加密和解密我们的用户密码。虽然这些标准易于使用，但在您应用程序的开发过程中，您可能会发现利用Yii2安全组件来哈希用户密码和加密敏感数据更容易：
- en: '[PRE47]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: Hashing and verifying passwords
  id: totrans-160
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 哈希和验证密码
- en: 'With Yii2, we can hash and verify user passwords using the `generatePasswordHash()`
    and `validatePassword()` methods of the security component. Like the `password_hash()`
    and `password_verify()` functions, the `generatePasswordHash()` and `validatePassword()`
    methods use `bcrypt` to hash the user passwords:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Yii2，我们可以通过安全组件的`generatePasswordHash()`和`validatePassword()`方法来哈希和验证用户密码。与`password_hash()`和`password_verify()`函数一样，`generatePasswordHash()`和`validatePassword()`方法使用`bcrypt`来哈希用户密码：
- en: '[PRE48]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Passwords can then be verified, as follows:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，密码可以按以下方式验证：
- en: '[PRE49]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'By default, Yii2 will use the PHP `crypt()` function to generate password hashes,
    but can, optionally, be configured to use the raw `password_hash()` methods using
    the `PASSWORD_DEFAULT` algorithm by setting the `passwordHashStrategy` property
    of the security component within the application configuration:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，Yii2将使用PHP的`crypt()`函数生成密码哈希，但可以通过设置应用程序配置中安全组件的`passwordHashStrategy`属性，选择性地配置为使用原始的`password_hash()`方法，使用`PASSWORD_DEFAULT`算法：
- en: '[PRE50]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: Tip
  id: totrans-167
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: It's highly recommended that you use the `password_hash` strategy over crypt
    as PHP will continue to strengthen the hashing algorithm of `PASSWORD_DEFAULT`
    to increase the security of PHP.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 强烈建议您使用`password_hash`策略而不是加密，因为PHP将继续增强`PASSWORD_DEFAULT`的哈希算法，以增加PHP的安全性。
- en: The password hashing methods implemented by Yii2, however, are simply wrappers
    around native PHP functions. Both the native functions and Yii2 implementations
    will remain backward-compatible with each other. For a more object-oriented approach,
    it's recommended that you use Yii2 methods.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，Yii2实现的密码哈希方法是原生PHP函数的包装。原生函数和Yii2实现将相互保持向后兼容。为了更面向对象的方法，建议您使用Yii2方法。
- en: Data encryption and decryption
  id: totrans-170
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 数据加密和解密
- en: 'For convenience, Yii2 provides a way to encrypt and decrypt data using a secret
    key or a user''s passwords. To encrypt data with Yii2, we can use the `encryptByPassword()`
    method of the security component, as shown in the following example:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 为了方便起见，Yii2提供了一种使用密钥或用户密码来加密和解密数据的方法。要使用Yii2加密数据，我们可以使用安全组件的`encryptByPassword()`方法，如下例所示：
- en: '[PRE51]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Data can then be decrypted using the `decryptByPassword()` method:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用`decryptByPassword()`方法解密数据：
- en: '[PRE52]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: Tip
  id: totrans-175
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: The secret password used for the encrypt and decrypt methods should be unique
    to the user and be stored in a format that if our database is compromised, the
    secret password itself is not compromised. A good secret to use would be the separate
    password submitted by the user.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 用于加密和解密方法的秘密密码应仅对用户唯一，并以一种格式存储，如果我们的数据库遭到破坏，秘密密码本身不会受到损害。一个好的秘密是使用用户提交的单独密码。
- en: Data hashing
  id: totrans-177
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 数据散列
- en: 'In addition to hashing passwords and encrypting data, we can also hash data
    for integrity verification using the `hashData()` and `validateData()` methods.
    These methods will be beneficial to present and validate checksums of files or
    raw data:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 除了散列密码和加密数据外，我们还可以使用`hashData()`和`validateData()`方法对数据进行散列以进行完整性验证。这些方法将有助于展示和验证文件或原始数据的校验和：
- en: '[PRE53]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: Tip
  id: totrans-180
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: Unlike encrypted data, hashed data cannot be recovered to its original state.
    Hashes are beneficial in order to verify that information hasn't been tampered
    with, and it ensures that the integrity of files or data is consistent after transmission.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 与加密数据不同，散列数据无法恢复到其原始状态。散列在验证信息未被篡改方面很有益处，并且确保文件或数据在传输后的一致性。
- en: Summary
  id: totrans-182
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we covered the basics of authenticating the identity of our
    users and granting them access to certain pages based upon attributes we set in
    the user identity interface, and how to implement Yii2's hierarchical role-based
    authentication. We also explored how to use flash messages to enhance our user
    experience. Additionally, we explored a few components of the security component,
    which enabled us to hash the user's passwords, hash and verify data, and encrypt
    and decrypt information utilizing the user's password.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们介绍了验证用户身份的基本知识，以及根据我们在用户身份界面中设置的属性授予他们访问某些页面的权限，以及如何实现Yii2的基于角色的分层认证。我们还探讨了如何使用闪存消息来增强用户体验。此外，我们还探讨了安全组件的一些组件，使我们能够散列用户的密码、散列和验证数据，以及使用用户的密码加密和解密信息。
- en: In the next chapter, we'll cover more complex routing within our application,
    how to work with and modify our responses directly with Yii2, and the basics of
    listening and responding to events.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将介绍我们应用程序中更复杂的路由，如何使用和修改我们的响应，以及监听和响应事件的基础知识。
