- en: Chapter 11. MongoDB
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第11章。MongoDB
- en: In this chapter, we will first compare traditional relational databases with
    so-called **NoSQL databases** and quickly introduce **MongoDB**, a **document
    database**. You will learn what it is, how to get and install it, and how to create
    a database to insert documents. Then, you will learn how to interface with it
    using PHP as the language.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将首先比较传统的关联数据库和所谓的**NoSQL数据库**，并快速介绍**MongoDB**，一个**文档数据库**。你将了解它是什么，如何获取和安装它，以及如何创建数据库以插入文档。然后，你将学习如何使用PHP作为语言与之交互。
- en: Relational database management systems
  id: totrans-2
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 关系数据库管理系统
- en: In [Chapter 6](ch06.html "Chapter 6. PHP and MySQL"), *PHP and MySQL*, we introduced
    the MySQL database and how to interface with it using the PHP language. That was
    not really the language to talk to the database. We used PHP to compose query
    strings that are lines of code in another language, native to the database **SQL**.
    It is used to query the database, to extract data from it, replace it, or insert
    it. We mentioned that SQL is one of those very few languages that has been around
    for many years and is expected to stick around for many more. It is used for many
    different databases, open source or commercial, small or large, that we collectively
    call **relational database management systems** (**RDBMS**).
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第6章](ch06.html "第6章。PHP和MySQL")中，我们介绍了MySQL数据库以及如何使用PHP语言与之交互。这并不是真正与数据库对话的语言。我们使用PHP来编写查询字符串，这些字符串是另一种语言的代码行，这种语言是数据库的本地语言**SQL**。它用于查询数据库，从中提取数据，替换数据或插入数据。我们提到，SQL是那些存在多年且预计还会存在很长时间的非常少数语言之一。它被用于许多不同的数据库，开源或商业的，小或大的，我们统称为**关系数据库管理系统**（**RDBMS**）。
- en: A relational database uses tables. The columns represent the type of data stored
    in it, the rows the data itself. You could have a table with customer data containing
    fields like *name*, *firstname*, *address*, *zipcode*, *city*, *telephone*, *accountnr*,
    and so on. All tables contain indexes that can be used in other tables to show
    how they are related. The values of the indexes themselves should never change.
    So, if a customer changes the address, the address needs to be changed in the
    customer table, and only in the customer table, as in all other tables, the customer
    will be referenced by his or her `customer_id`. This is a good thing, but as your
    data becomes more complex, so will the number of tables.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 关系数据库使用表格。列代表存储在其中的数据类型，行代表数据本身。你可以有一个包含客户数据的表格，包含如*姓名*、*名*、*地址*、*邮编*、*城市*、*电话*、*账户号*等字段。所有表格都包含索引，可以在其他表格中使用以显示它们之间的关系。索引本身的值永远不应该改变。因此，如果客户更改地址，地址需要在客户表中更改，并且只在该客户表中更改，就像在其他所有表中一样，客户将通过他的或她的`customer_id`被引用。这是一件好事，但随着你的数据变得更加复杂，表格的数量也会增加。
- en: My experience with this is that, as soon as a record needs to contain two things
    of the same kind, like when someone has two addresses, you feel you need to create
    another table.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 我在使用这个系统的经验是，一旦需要记录包含两种相同类型的信息，比如当某人有两个地址时，你会觉得需要创建另一个表格。
- en: Queries to access data that you need to compose the HTML of a webpage and that
    is spread across many tables can become quite complex, one INNER JOIN after another.
    Once the need arises to add a table or to add a column to an existing table, you
    will also have to change your code.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 访问数据以组成网页HTML的查询可能会变得相当复杂，一个接一个的内部连接（INNER JOIN）。一旦需要添加表格或向现有表格中添加列，你也必须更改你的代码。
- en: It is a common practice in projects that use RDBMS to first define the tables
    of your database, and then start writing your code. The definition of your tables
    is put in a schema or diagram. So, each time a table needs to be added or changed,
    so does your schema.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用关系数据库管理系统（RDBMS）的项目中，这是一个常见的做法：首先定义数据库的表格，然后开始编写代码。表格的定义被放在一个模式或图中。因此，每次需要添加或更改表格时，你的模式也需要相应地更改。
- en: 'In summary, as your database grows and your data becomes more complex, a lot
    of overhead can be created: adding tables or columns, writing complex queries,
    or constantly changing the schema of your database. Wouldn''t it be nice to be
    able to use a different kind of database, where each record contains all the information
    you need, and nothing else? Yes, it would.'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 总结来说，随着数据库的增长和数据的复杂化，可以创建大量的开销：添加表格或列、编写复杂的查询或不断更改数据库的模式。如果能够使用不同类型的数据库，其中每个记录都包含你需要的所有信息，而没有其他信息，那岂不是很好？是的，会很好。
- en: NoSQL databases
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: NoSQL数据库
- en: 'In recent years, several new database technologies emerged that are not RDBMS.
    Most, if not all of them, tried to solve a particular problem (instead of wanting
    to be a generic solution for everybody). They are collectively called NoSQL databases.
    The NoSQL part can be interpreted in two ways: **NO SQL**, meaning no query language
    available, or **Not Only SQL**, meaning the technology supports more than just
    SQL. NoSQL databases have become quite popular in web development.'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 近年来，出现了几种新的数据库技术，它们不是关系型数据库管理系统（RDBMS）。其中大多数，如果不是全部，都试图解决一个特定的问题（而不是想要成为适合所有人的通用解决方案）。它们被统称为NoSQL数据库。NoSQL这一部分可以有两种解释：**NO
    SQL**，意味着没有可用的查询语言，或者**Not Only SQL**，意味着这项技术支持不仅仅是SQL。NoSQL数据库在Web开发中已经变得相当流行。
- en: There are several types. The group of NoSQL databases that is of interest to
    us are so-called document databases. What is stored in the database are documents.
    A document in this context is not, let's say, a Word or PDF document, but a JSON
    object. Document databases provide the ability to query on any field in the document,
    so they are, for sure, Not Only SQL databases.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 有几种类型。对我们感兴趣的NoSQL数据库组是所谓的文档数据库。存储在数据库中的是文档。在这个上下文中，文档不是，比如说，Word或PDF文档，而是一个JSON对象。文档数据库提供了在文档的任何字段上进行查询的能力，因此它们无疑是Not
    Only SQL数据库。
- en: 'What we are doing here is the reverse of what is going on with RDBMS. Every
    record, or document, will contain all the information we want in it, and nothing
    else. If an item needs to be added to a document that was never used before, we
    simply add it. There is no need to change a schema or a table. If a record now
    needs two things of the same kind, we do things the JSON way: we use an array
    instead of a single object.'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里所做的是与RDBMS中发生的事情相反。每个记录或文档将包含我们想要的所有信息，没有其他信息。如果需要向一个以前从未使用过的文档中添加项目，我们只需添加即可。不需要更改模式或表。如果一个记录现在需要两种相同类型的东西，我们按照JSON的方式行事：我们使用数组而不是单个对象。
- en: Surprisingly enough, those databases perform and scale very well, even with
    thousands of documents. The NoSQL database we have chosen for our projects, and
    for this book, is MongoDB. It appears to be the one that has the most features,
    is the most widely adopted—the *New York Times* uses it!—and scales and performs
    well.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 令人惊讶的是，这些数据库即使在拥有数千个文档的情况下也能表现出色，并且具有良好的扩展性。我们为项目以及本书所选用的NoSQL数据库是MongoDB。它似乎拥有最多的功能，被最广泛采用——**《纽约时报》**也在使用它！——并且具有良好的扩展性和性能。
- en: MongoDB
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: MongoDB
- en: With MongoDB, we just replace MySQL with a document database that can be a better
    solution for our projects and has JSON as the common denominator. MongoDB uses
    collections and documents. So, that makes it more suitable for, for example, an
    online bookstore application.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 使用MongoDB，我们只需用文档数据库替换MySQL，这可能成为我们项目的更好解决方案，并且以JSON作为共同的基础。MongoDB使用集合和文档。这使得它更适合，例如，在线书店应用程序。
- en: As a document in MongoDB is a JSON object, to transfer data to it from PHP is
    as simple as storing the data in a PHP array. No more multiple tables and inner
    joins required. We will explain how to get to MongoDB, create a database, and
    add and update documents. We will do so from within a PHP program, as well as
    the MongoDB shell.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 由于MongoDB中的文档是一个JSON对象，因此从PHP中向其传输数据就像在PHP数组中存储数据一样简单。不再需要多个表和内部连接。我们将解释如何连接到MongoDB，创建数据库，以及添加和更新文档。我们将从PHP程序以及MongoDB
    shell中这样做。
- en: Installing MongoDB
  id: totrans-17
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 安装MongoDB
- en: Obtaining and installing MongoDB depends on the platform you are using. Go to
    [www.mongodb.org](http://www.mongodb.org) for the software and the documentation.
    This will get you basically two programs. The first one is **mongod** (known as
    the **MongoDB daemon**), a program that needs to be up and running all the time,
    just like a MySQL server would. The second one is simply called **mongo** and
    it is **the** **MongoDB shell**. It is a command interpreter that lets you create
    databases, collections, and documents, and modify them. I like to think of it
    as **phpMyAdmin** for MongoDB.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 获取和安装MongoDB取决于您所使用的平台。请访问[www.mongodb.org](http://www.mongodb.org)以获取软件和文档。这将为您提供基本上两个程序。第一个是**mongod**（被称为**MongoDB守护进程**），一个需要一直运行和开启的程序，就像MySQL服务器一样。第二个程序简单地称为**mongo**，它是**MongoDB
    shell**。它是一个命令解释器，允许您创建数据库、集合和文档，并对其进行修改。我喜欢将其视为MongoDB的**phpMyAdmin**。
- en: If you want to access and manipulate your MongoDB database from within a program,
    you will also need to download and install a driver for MongoDB for the programming
    language of your choice. So, for PHP, we will need a PHP driver for MongoDB. Drivers
    can be built from source, but there is also binary available from distributions
    that change all the time. So, use your favorite search engine and look for a PHP
    driver for MongoDB. At the time of writing, there was one at `php.net/manual/en/book.mongo.php`.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想在程序内部访问和操作你的MongoDB数据库，你还需要下载并安装一个适用于你选择编程语言的MongoDB驱动程序。所以，对于PHP，我们需要一个MongoDB的PHP驱动程序。驱动程序可以从源代码构建，但也有一些来自不断变化的发行版的二进制文件。所以，使用你喜欢的搜索引擎，查找MongoDB的PHP驱动程序。在撰写本文时，`php.net/manual/en/book.mongo.php`有一个。
- en: The MongoDB shell
  id: totrans-20
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: MongoDB shell
- en: 'Once you have all these things installed, it is time to start filling up a
    database with documents. In MySQL, we started by first creating all our tables,
    maybe initially on a piece of paper, and then for real by using phpMyAdmin. In
    MongoDB, we use the MongoDB shell to populate our database for the first time.
    However, there is no need to create tables. We simply add documents. As they say
    in French: *simple comme bonjour*.'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦安装好所有这些工具，就是时候开始用文档填充数据库了。在MySQL中，我们首先创建所有表格，可能最初是在一张纸上，然后通过使用phpMyAdmin来实际操作。在MongoDB中，我们使用MongoDB
    shell来首次填充我们的数据库。然而，没有必要创建表格。我们只需添加文档。正如他们所说的法语：*简单得就像你好*。
- en: In order to do so, we make the distinction between databases, collections, and
    documents. Every instance of MongoDB can contain one or more databases. Although
    you can do everything with a single database, it is recommended that you use separate
    databases where appropriate, for example, one for each project.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 为了做到这一点，我们在数据库、集合和文档之间做出区分。每个MongoDB实例可以包含一个或多个数据库。虽然你可以用单个数据库做所有事情，但建议在适当的时候使用单独的数据库，例如，每个项目一个数据库。
- en: Although you could put all your documents into a database, just like that, it
    is better to organize them as several collections. Compared to RDBMS, documents
    are the equivalent of table rows, and collections are the counterpart of tables.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然你可以像那样将所有文档放入数据库，但最好将它们组织为几个集合。与RDBMS相比，文档相当于表行，而集合相当于表。
- en: In the remainder of this section, we will walk you through using the MongoDB
    shell to do basic **Create, Read, Update, and Delete** (**CRUD**) operations.
    For more detailed and advanced operations, consult the excellent MongoDB documentation
    at [mongodb.org](http://mongodb.org) or some of the books available on the subject.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节的剩余部分，我们将向您展示如何使用MongoDB shell进行基本的**创建、读取、更新和删除**（**CRUD**）操作。对于更详细和高级的操作，请参考优秀的MongoDB文档，网址为[mongodb.org](http://mongodb.org)，或者一些关于这个主题的书籍。
- en: 'To start the MongoDB shell, simply type `mongo` in the command line. You will
    see something similar to:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 要启动MongoDB shell，只需在命令行中输入`mongo`。你会看到类似以下的内容：
- en: '[PRE0]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'You are now talking to the command interpreter, which basically reads JavaScript
    code. By default, mongoDB will connect to a database called `test`. The `>` symbol
    is your command prompt. Just to show that it works, let''s promptly change it:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 你现在正在与命令解释器对话，它基本上读取JavaScript代码。默认情况下，mongoDB会连接到一个名为`test`的数据库。`>`符号是你的命令提示符。为了展示它的工作，让我们立即更改它：
- en: '[PRE1]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Creating databases, collections, and documents
  id: totrans-29
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建数据库、集合和文档
- en: 'We have changed our command prompt to the string mongoDB. Let''s connect to
    a different database:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经将命令提示符更改为字符串mongoDB。让我们连接到另一个数据库：
- en: '[PRE2]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'You have now switched to a database called `california`. You think I forgot
    something and I am telling you I did not, I just want to keep the suspense going
    here. Now, let''s add a document to a collection `people`. Simply type:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 你现在已经切换到了名为`california`的数据库。你认为我忘记了什么，但我告诉你我没有，我只是想保持悬念。现在，让我们向`people`集合添加一个文档。只需输入：
- en: '[PRE3]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Let''s find out whether something really happened here. There is a method to
    find all the documents in a collection, unsurprisingly, called `find()`:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们找出这里是否真的发生了什么。有一个方法可以找到集合中的所有文档，不出所料，它被称为`find()`：
- en: '[PRE4]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Oh my goodness, we now have created a database called `california`, and in it,
    a collection `people`, and inside it, our first document. All of this just happens;
    if the database or collection does not exist yet, MongoDB will create them. Unlike
    in MySQL, there is no need for any SQL to create the database nor table ahead
    of time or to specify data types.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 哇，我们现在创建了一个名为`california`的数据库，在其中，一个名为`people`的集合，以及它里面的第一个文档。所有这些事情都发生了；如果数据库或集合尚未存在，MongoDB将创建它们。与MySQL不同，在创建数据库或表之前不需要任何SQL，也不需要指定数据类型。
- en: 'If you type the following two commands, you will indeed see that they now exist:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你输入以下两个命令，你确实会看到它们现在存在：
- en: '[PRE5]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'There is an alternate to find, which gives a nicer output, called `findOne()`:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 有一个`find`的替代方法，它提供了一个更友好的输出，称为`findOne()`：
- en: '[PRE6]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Of course, there is only one thing to find, but as the number of documents
    increases, we want to be more specific, so we could say things like:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，我们只找到一件事情，但随着文档数量的增加，我们希望更加具体，所以我们可以这样说：
- en: '[PRE7]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: This is beginning to look very much like a query, because it is one! You may
    have noticed a key named `"_id"` and a very long value. Let's spend a few lines
    on this.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 这看起来越来越像是一个查询，因为它就是！你可能注意到了一个名为`"_id"`的关键字和一个非常长的值。让我们花几行来讨论这个问题。
- en: _id and ObjectIds
  id: totrans-44
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '`_id`和ObjectId'
- en: Every document stored in MongoDB must have an `"_id"` key. It can be any type,
    but it defaults to `ObjectId`. In a single collection, every document must have
    a unique value for `"_id"`, which ensures that every document in a collection
    can be uniquely identified. ObjectId use 12 bytes of storage. As stated previously,
    if there is no `"_id"` key present when a document is inserted, one will be automatically
    added to the inserted document.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 存储在MongoDB中的每个文档都必须有一个`"_id"`键。它可以任何类型，但默认为`ObjectId`。在一个集合中，每个文档都必须有一个唯一的`"_id"`值，这确保了集合中的每个文档都可以唯一标识。ObjectId使用12字节存储空间。如前所述，如果插入文档时没有`"_id"`键，MongoDB将自动将其添加到插入的文档中。
- en: Loading scripts
  id: totrans-46
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 加载脚本
- en: The mongoDB shell interprets JavaScript and also has built-in functions. Some
    things you are used to will not work, such as `alert()`, because it is a method
    of the Windows object, and that is only available when you are running in a browser.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: mongoDB shell可以解析JavaScript，并且还有内置函数。一些你习惯使用的东西可能不起作用，比如`alert()`，因为它属于Windows对象的方法，而且只有在浏览器中运行时才可用。
- en: 'A very useful function is `load()`. You can prepare all your commands ahead
    of time and store them in a file. Create a folder for your project, go to it,
    and store the following, which is very close to one of our JSON examples from
    the previous chapter, in a file `californiapeople.js`:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '`load()`是一个非常有用的函数。你可以在事先准备所有命令并将它们存储在一个文件中。为你的项目创建一个文件夹，进入它，并将以下内容（与上一章中我们的一些JSON示例非常相似）存储在一个名为`californiapeople.js`的文件中：'
- en: '[PRE8]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Then, issue the following command:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，输入以下命令：
- en: '[PRE9]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'This will insert five more documents into the `people` collection. To verify
    it, type:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 这将向`people`集合中插入五个更多文档。为了验证它，输入以下命令：
- en: '[PRE10]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The result will look similar to this:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 结果看起来可能像这样：
- en: '[PRE11]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Removing documents
  id: totrans-56
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 删除文档
- en: 'Notice that there are now two documents containing `Ansel Adams`, clearly distinct
    by its `"_id"`. But, we only need one, so it is time to remove one. This is done
    using the `remove()` function. Beware, if you do not specify an argument in the
    following command, all documents in the collection would be removed and once documents
    are removed, they cannot be restored:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 注意现在有两个包含`Ansel Adams`的文档，它们通过其`"_id"`明显不同。但我们只需要一个，所以现在是时候删除一个了。这是通过`remove()`函数完成的。当心，如果你在以下命令中不指定任何参数，集合中的所有文档都将被删除，一旦文档被删除，就无法恢复：
- en: '[PRE12]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Updating documents
  id: totrans-59
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 更新文档
- en: Our final CRUD operation is update. In this example, we add a key:value pair
    to the document that has the information relating to the late nature photographer
    and rock climber Galen Rowell. In this case, we set a value for the field `"died"`.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 我们最后的CRUD操作是更新。在这个例子中，我们向包含有关已故自然摄影师和攀岩家加伦·罗威尔信息的文档中添加一个键值对。在这种情况下，我们为字段`"died"`设置了一个值。
- en: '[PRE13]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '`$set` is an example of a **modifier**. It allows us to specify how we want
    to change the document. In the previous example, the value of the field `"died"`
    would have been updated or created if it did not yet exist.'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '`$set`是一个**修饰符**的例子。它允许我们指定我们想要如何更改文档。在上一个例子中，如果该字段`"died"`尚未存在，其值将被更新或创建。'
- en: 'Some of the other modifiers are `$unset`, to remove a field, `$inc` and `$dec`
    to increment and decrement a field, and `$push` and `$pull` to add an element
    to an array or remove it:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: MongoDB data types
  id: totrans-65
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: In MongoDB, we do not have to specify data types ahead of time. You just use
    them, and by now, you should have recognized, from our examples, the same data
    types that make up a JSON object. However, in MongoDB we have a few extras.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
- en: Basic data types
  id: totrans-67
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'We can use the same basic data types as in JSON: `null`, `true`, `false`, `string`,
    `number`, and `array`.'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
- en: Dates
  id: totrans-69
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Dates are always hard to deal with, not only in life but also in databases.
    Fortunately, MongoDB supports the JavaScript `Date()` class, giving us a data
    type when using dates. Dates are stored as the number of milliseconds that have
    elapsed since the epoch and do not contain any information on the time zone. Of
    course, if you like, you could store the time zone as a separate key:value pair:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'In MySQL, the equivalent of the previous code would be to use `NOW()`. If you
    issue a `find()` on the document where you added `"today"`, you will see something
    like:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Embedded documents
  id: totrans-74
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The value of a field in a document can also be an entire document. We called
    these **embedded documents**.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: One more example
  id: totrans-77
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Let''s finish this section on the MongoDB shell with one more example. Let''s
    take our `practical.json` file from [Chapter 10](ch10.html "Chapter 10. XML and
    JSON"), *XML and JSON*, and the JSON object it contains. By simply surrounding
    it with `db.junelake.insert()`, we can turn it into a MongoDB command:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Once executed, either by typing it in or storing it in a file first, and then
    using the `load()` function, we have now inserted a document into the `junelake`
    collection of our gallery database. We can even access it as a JSON object and
    walk through it:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'We can use the `print()` function to display those values. We can even go through
    a loop, as we did in [Chapter 10](ch10.html "Chapter 10. XML and JSON"), *XML
    and JSON*. That is why I picked the name `json` as my variable name, where we
    had `json` as the variable that contained what our Ajax call returned:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: So, we might as well, now that we can get JSON straight out of our MongoDB database,
    use the exact same JavaScript code to generate an HTML page of our photo gallery,
    right? Wrong! Our database resides on a server and is also the server where we
    execute the MongoDB shell (even if it is on our developer machine, it still has
    the role of a server).
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
- en: 'In order for that JavaScript code generating our HTML to be useful, it has
    to be executed on the client and interpreted by a different JavaScript interpreter
    than the MonoDB shell - the one that we have been using since the beginning of
    this book: *the browser*.'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
- en: 'To paraphrase a famous line out of a James Bond movie: *JSON, how the hell
    are we going to get this data over here?* Well, this will have to happen the same
    way like before. We will use an Ajax call to execute code on the server to extract
    data from our database, this time a MongoDB database, and then process that data
    on the client side to generate our HTML.'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 用一句著名电影台词来概括：*JSON，我们究竟如何才能把数据传到这里来？* 好吧，这将会和之前一样发生。我们将使用Ajax调用在服务器上执行代码以从我们的数据库中提取数据，这次是一个MongoDB数据库，然后客户端处理这些数据以生成我们的HTML。
- en: Up to this point, the only programming language we know we can use on the server
    side is PHP, so we need a way to access our MongoDB database using PHP.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们知道我们可以在服务器端使用的唯一编程语言是PHP，因此我们需要一种方法来使用PHP访问我们的MongoDB数据库。
- en: MongoDB and PHP
  id: totrans-88
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: MongoDB和PHP
- en: We will dive right into it. We finished the previous section by inserting documents
    into the database containing the data we need for our photo gallery page. Then
    we discovered that we could not use it right away. However, we can, if we have
    the PHP driver installed and the mongo extension specified in our `php.ini` file,
    we can access our MongoDB database from a PHP program on the server. It can be
    extremely short.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将直接进入主题。我们在上一节通过将包含我们照片画廊页面所需数据的文档插入数据库来结束。然后我们发现我们无法立即使用它。然而，如果我们已经安装了PHP驱动程序并在`php.ini`文件中指定了mongo扩展，我们就可以从服务器上的PHP程序访问我们的MongoDB数据库。它可以非常简短。
- en: Getting our gallery data
  id: totrans-90
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 获取我们的画廊数据
- en: 'This is all it takes:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是全部所需：
- en: '[PRE21]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Thanks to the driver, we have access to a `Mongo()` class. On the first line,
    we make a connection to MongoDB, on the second, we select the database we want
    to use, and on the third, we specify the collection we are dealing with.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 多亏了驱动程序，我们有了对`Mongo()`类的访问权限。在第一行，我们连接到MongoDB，在第二行，我们选择我们想要使用的数据库，在第三行，我们指定我们正在处理的集合。
- en: 'Next, we use the `findone()` method, which we recognize from the previous section.
    As PHP does not know about JSON objects, this is going to return something else:
    an array. Now, remember that there is a PHP function that converts an array to
    JSON: `json_encode()`. There it is. Just `echo` it for the Ajax call to catch
    it and do the rest of the job on the client side. Here are the other pieces. I
    have not repeated the CSS file here.'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们使用`findone()`方法，这是我们之前章节中提到的。由于PHP不知道JSON对象，这将返回其他内容：一个数组。现在，记住有一个PHP函数可以将数组转换为JSON：`json_encode()`。就在那里。只需`echo`它，以便Ajax调用能够捕获它，并在客户端完成剩余的工作。这里还有其他部分。我没有在这里重复CSS文件。
- en: 'This is the HTML file:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 这是HTML文件：
- en: '[PRE22]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'This is the JavaScript file:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 这是JavaScript文件：
- en: '[PRE23]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: We used the `.post()` jQuery method to execute our PHP script on the server
    and collect the JSON data. Notice the extra `"json"` argument in the `.post()`
    statement. It is very important as it tells the Ajax call to expect the data to
    be in the JSON format, and to not attempt to process it as HTML. If you forget
    this part, strange things will happen, or worse, nothing at all.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用了`.post()` jQuery方法在服务器上执行我们的PHP脚本并收集JSON数据。注意`.post()`语句中的额外`"json"`参数。这非常重要，因为它告诉Ajax调用预期数据将以JSON格式提供，并且不要尝试将其作为HTML处理。如果您忘记这部分，可能会发生奇怪的事情，或者更糟，什么也不发生。
- en: CRUD operations with MongoDB and PHP
  id: totrans-100
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用MongoDB和PHP进行CRUD操作
- en: We conclude this chapter with an overview on how to perform some of the basic
    CRUD operations using PHP and MongoDB.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 我们用PHP和MongoDB执行一些基本CRUD操作的概述来结束这一章。
- en: As we have mentioned, PHP does not support JSON objects, so we have to use arrays.
    In the previous example, we fetched data from the database, so we did not even
    have to look at the array, we just converted it to JSON. The only disappointing
    part may be that as we are dealing with a document database that contains JSON
    objects, we grab data, it shows up as arrays, and we have to convert it back to
    JSON. That does not appear to be very efficient, but if you already know PHP,
    it is easy to write.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们提到的，PHP不支持JSON对象，所以我们必须使用数组。在之前的例子中，我们从数据库中获取数据，所以我们甚至不需要查看数组，我们只需将其转换为JSON。唯一令人失望的部分可能是在处理包含JSON对象的文档数据库时，我们获取数据，它显示为数组，我们必须将其转换回JSON。这看起来似乎不是很高效，但如果您已经熟悉PHP，编写起来很容易。
- en: We will discuss a JSON all the way (JavaScript all the way too) alternative
    in the final chapter of this book.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在本书的最后一章讨论一个JSON（以及JavaScript）的替代方案。
- en: Insert documents
  id: totrans-104
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 插入文档
- en: Let's add another famous California person to our `people` collection in the
    `california` database. Those of you familiar with Venice Beach know who I am talking
    about. He is the guy with a turban on rollerblades, skating up and down the boardwalk.
    He has not changed in 30 years, except that he is now selling T-shirts instead
    of cassette tapes.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在 `california` 数据库的 `people` 集合中添加另一个著名的加利福尼亚人。那些熟悉威尼斯海滩的人都知道我在说什么。他是那个戴着头巾在滑板上上下滑行的人。30
    年来他几乎没有变化，除了现在他卖 T恤而不是卡带。
- en: 'It is very much the same as the `insert()` in the MongoDB shell, except our
    *key:value* pairs are now *key=>value* pairs as part of an associative array:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 它与 MongoDB shell 中的 `insert()` 几乎相同，只是我们的 *key:value* 对现在是作为关联数组的一部分的 *key=>value*
    对：
- en: '[PRE24]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Update documents
  id: totrans-108
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 更新文档
- en: 'Let''s update our document by adding one more key:value pair:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过添加一个额外的键值对来更新我们的文档：
- en: '[PRE25]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: So far, we could have used double quotes instead of single quotes in our examples,
    but for the `$set` modifier we can only use single quotes, because, as you know,
    `$` has a special meaning in PHP—without the single quotes, `$set` would have
    been interpreted as a PHP variable.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，在我们的例子中，我们可以使用双引号而不是单引号，但对于 `$set` 修改符，我们只能使用单引号，因为，正如你所知，`$` 在 PHP 中有特殊含义——如果没有单引号，`$set`
    就会被解释为一个 PHP 变量。
- en: Queries with conditions
  id: totrans-112
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 带条件的查询
- en: 'Just as we did with the shell, we can use the `findone()` function to query
    a document:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 就像我们在 shell 中做的那样，我们可以使用 `findone()` 函数来查询一个文档：
- en: '[PRE26]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Once again, an array is used instead of a key:value pair. But we can make these
    queries more complex. Several keywords exist that can be use to refine our query.
    Here is one more example:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调，我们使用数组而不是键值对。但我们可以使这些查询更加复杂。存在几个关键字可以用来细化我们的查询。这里有一个额外的例子：
- en: '[PRE27]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: '`findone()` only gives us one document back and does so as an associative array,
    like in our very first example. If we use `find()`, the data of several documents
    is returned. In the shell we had a nice little output, defaulting to the first
    20 documents, but, here, using PHP, we will be given what is called a MongoDB
    **cursor**.'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: '`findone()` 只返回一个文档，并以关联数组的形式返回，就像我们最初的例子一样。如果我们使用 `find()`，则会返回多个文档的数据。在 shell
    中，我们得到了一个很好的小输出，默认为前 20 个文档，但在这里，使用 PHP，我们将得到一个称为 MongoDB **游标**的东西。'
- en: MongoDB cursor object
  id: totrans-118
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: MongoDB 游标对象
- en: 'The MongoDB `db.collection.find()` returns all documents as an iterable object,
    or cursor. In PHP, `find()` returns all documents with all their data, which is
    probably not what you want. But, as we do not have too much data at this point,
    here is one way to get it all and walk or iterate through it in PHP:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: MongoDB 的 `db.collection.find()` 返回所有文档作为一个可迭代的对象，或者游标。在 PHP 中，`find()` 返回所有文档及其所有数据，这可能不是你想要的。但因为我们现在没有太多数据，这里有一种方法可以获取所有数据并在
    PHP 中遍历它：
- en: '[PRE28]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: In the example, `$cursor` is an object of the MongoDB cursor class. Several
    methods are available for this class, giving you alternate ways to iterate through
    your cursor. If you want to turn the cursor into an array, you can use the `iterator_to_array()`
    function.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 在例子中，`$cursor` 是 MongoDB 游标类的对象。这个类有几个方法可用，为你提供了遍历游标的不同方式。如果你想将游标转换为数组，可以使用
    `iterator_to_array()` 函数。
- en: In the example, we iterate through `$cursor` using a `foreach()` loop, giving
    us access to each document as an array to do with it whatever we want. What we
    did was `echo` the name.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 在例子中，我们使用 `foreach()` 循环遍历 `$cursor`，这样我们就可以访问每个文档并将其作为数组来处理。我们做的是 `echo` 名称。
- en: 'To conclude, we''ll show you how to refine our query. Imagine you want to perform
    the same query, which in SQL would look like:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 为了总结，我们将向你展示如何细化我们的查询。想象一下，你想执行相同的查询，在 SQL 中它看起来像：
- en: '[PRE29]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'In MongoDB PHP lingo, this would be:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 在 MongoDB PHP 术语中，这将是：
- en: '[PRE30]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: This should, by now, look pretty straightforward to you. The cursor modifier
    part allows you to limit or influence the data that is returned, for example,
    there is a **sort** modifier.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 到现在为止，这应该对你来说已经很直接了。游标修改符部分允许你限制或影响返回的数据，例如，有一个 **排序** 修改符。
- en: The `projection` array allows you to specify which fields you are interested
    in. By default, the value of `id` is always returned, so if you do not need it,
    add `_id => 0` to your projection array.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: '`projection` 数组允许你指定你感兴趣的哪些字段。默认情况下，`id` 的值总是返回，所以如果你不需要它，请在你的投影数组中添加 `_id
    => 0`。'
- en: Summary
  id: totrans-129
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 概述
- en: In this chapter, you learned about MongoDB, a document database that is very
    popular amongst NoSQL databases. Documents stored in the database are basically
    nothing more than JSON objects. They can be grouped in collections, the equivalent
    of tables in RDBMS.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你学习了MongoDB，这是一种在NoSQL数据库中非常受欢迎的文档数据库。存储在数据库中的文档基本上就是JSON对象。它们可以被分组到集合中，这相当于RDBMS中的表。
- en: Using the MongoDB shell, we can populate databases and collections from the
    command line. From within web applications, we can access a MongoDB database on
    the server using PHP. This is really easy because JSON objects can be written
    as associative arrays.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 使用MongoDB shell，我们可以从命令行填充数据库和集合。在Web应用程序内部，我们可以使用PHP访问服务器上的MongoDB数据库。这真的很简单，因为JSON对象可以写成关联数组。
- en: In the last few chapters, there was a lot of sample code and I promised you
    a textbook so you can learn away from the computer. In the next chapter, there
    will be a lot more reading to do.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 在最后几章中，有很多示例代码，我承诺你会有一本教科书，这样你就可以在电脑外学习。在下一章，将有更多的阅读内容。
- en: The newest trends in web development are being discussed, triggered by the totally
    different way people are using the Web compared to just a couple of years ago.
    We are going to focus a little more on how your website looks and a little less
    on how it works.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 当前Web开发的新趋势正在被讨论，这是由于人们使用Web的方式与几年前完全不同所引发的。我们将更多地关注你的网站外观，而较少关注其工作方式。
