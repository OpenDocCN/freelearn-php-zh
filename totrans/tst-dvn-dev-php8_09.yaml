- en: '9'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Continuous Integration
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapters, we went through the software development process of
    a toy car model inventory solution. We followed the test-driven development process,
    and at this stage, we should now be familiar with it. However, there are still
    a lot of missing features in the software that we are building. In this chapter,
    we will start with an almost complete solution that you can get from the GitHub
    repository for this chapter. We will then make sure our solution works.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we’ll start with an almost complete software solution except
    for the missing last feature, which is to filter the table containing the toy
    car models. We have built a lot of tests; wouldn’t it be great if we could automatically
    trigger the execution of these tests whenever we created a pull request to the
    develop or main branch? Automatically triggering the test suites that we have
    spent so much time developing will help us catch bugs or defects before they even
    get merged into the main branch. This is where continuous integration will be
    able to help us.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will go through the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Running and passing all the Symfony application tests
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using Bitbucket Pipelines for continuous integration
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, you are expected to have basic knowledge of using Git version
    control for web applications. You should also use the development environment
    and solution code from this book’s GitHub repository: [https://github.com/PacktPublishing/Test-Driven-Development-with-PHP-8/tree/main/Chapter%209](https://github.com/PacktPublishing/Test-Driven-Development-with-PHP-8/tree/main/Chapter%209).'
  prefs: []
  type: TYPE_NORMAL
- en: Preparing the development environment for this chapter
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: First, download the code found at [https://github.com/PacktPublishing/Test-Driven-Development-with-PHP-8/tree/main/Chapter%209](https://github.com/PacktPublishing/Test-Driven-Development-with-PHP-8/tree/main/Chapter%209).
  prefs: []
  type: TYPE_NORMAL
- en: To run the containers and execute the commands in this chapter, you should be
    inside the `docker-server-web-1` container.
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the following command to confirm the container name for our web server:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'To run the containers, run the following command from the `/docker` directory
    from the repository in your host machine:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Once inside the container, run the following commands to install the libraries
    required through Composer:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Running and passing all the Symfony application tests
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapter, we started writing solution code by trying to follow
    the SOLID principles. To develop the other parts of the application, we can just
    continue following the same process. In this chapter, I have taken the liberty
    to complete all other tests and the solution code needed to pass those tests.
    We will go through the tests and make sure they pass.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up the local environment
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Check out the source code provided in the *Technical requirements* section
    into your local development machine and run the following commands from the host
    machine to configure your development environment:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'After running these commands, make sure that the containers we built earlier
    in this book are up and running by running the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'You should see the following Docker container names:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Now that the containers are running, we need to prepare the Symfony and Behat
    applications running inside the `docker_server-web_1` container by installing
    the packages they depend on, as well as creating the database and tables that
    our example PHP application needs.
  prefs: []
  type: TYPE_NORMAL
- en: Preparing the Symfony application and tests
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Now, let’s set up the required database tables and libraries needed by our
    Symfony application. While still inside the `docker` directory, run the following
    command from your host machine:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Alternatively, run the following command inside the `docker_server-web_1` container:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: The `setup.sh` file is just a shell script I have added to easily configure
    our Symfony application and prepare the database and tables we need to run the
    tests.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you open the following shell file, you will see that we are simply running
    some Doctrine commands and using Composer to install all the Symfony dependencies
    needed:'
  prefs: []
  type: TYPE_NORMAL
- en: codebase/symfony/setup.sh
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: This shell script will come in handy once we are running the application in
    the **continuous integration** (**CI**) machine.
  prefs: []
  type: TYPE_NORMAL
- en: After running the `setup.sh` command, your development environment should be
    ready to run all the unit and integration tests from inside our Symfony application.
  prefs: []
  type: TYPE_NORMAL
- en: In [*Chapter 5*](B18318_05.xhtml#_idTextAnchor070), *Unit Testing*, we created
    a shell script called `codebase/symfony/runCoverage.sh`. This shell script will
    help us run all the tests and check how much test coverage we have against our
    solution code. Realistically speaking though, we don’t have to cover all the code
    inside our application since some of them are third-party libraries with no tests,
    or some of them might be just **Plain Old PHP Object** (**POPO**) classes. But
    for the code that we develop, we should add automated tests for them.
  prefs: []
  type: TYPE_NORMAL
- en: If you think you need to exclude some classes from the code coverage report,
    you can open the `codebase/symfony/phpunit.xml` configuration file and add the
    directories you want to exclude from the coverage report.
  prefs: []
  type: TYPE_NORMAL
- en: 'From within the `docker_server-web_1` container, if you open the `codebase/symfony/tests`
    directory inside our Symfony application, you will see the following tests:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.1 – Symfony tests directory](img/Figure_9.01_B18318.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.1 – Symfony tests directory
  prefs: []
  type: TYPE_NORMAL
- en: 'We have three main directories for the tests: **Functional**, **Integration**,
    and **Unit**. The **Functional** tests in this example are the controller tests,
    which are the tests that use HTTP requests; you can think of them as Integration
    tests as well but they cover more integrated code. The **Integration** tests are
    the tests that run through the different custom classes and how they interact
    with each other, making sure that they all work as expected. Finally, the **Unit**
    tests are simple tests that focus on single units or functions inside a specific
    class.'
  prefs: []
  type: TYPE_NORMAL
- en: You can browse through the directories and classes inside `codebase/symfony/src`
    to check the actual classes our tests are testing against.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s see whether the tests pass; from the host machine, run the following
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Alternatively, run the following command inside the `docker_server-web_1` container:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Since we have configured the database and tables needed for the tests, you
    should see the following result:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.2 – Passing Symfony tests](img/Figure_9.02_B18318.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.2 – Passing Symfony tests
  prefs: []
  type: TYPE_NORMAL
- en: It looks like we have a lot of passing tests, but let’s open one of the test
    classes and see exactly what we are testing for.
  prefs: []
  type: TYPE_NORMAL
- en: 'Open `codebase/symfony/tests/Integration/DAL/Reader/ColorReaderTest.php`; you
    will see the following content:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: You will notice that in this test class, we are reading data from the database
    and running some assertions against the results from the database. In [*Chapter
    7*](B18318_07.xhtml#_idTextAnchor108), *Building Solution Code with BDD and TDD*,
    we created the databases we needed for both testing and the main database for
    the actual solution code.
  prefs: []
  type: TYPE_NORMAL
- en: 'We have the following databases inside the `docker_server-mysql_1` container:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.3 – MySQL databases](img/Figure_9.03_B18318.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.3 – MySQL databases
  prefs: []
  type: TYPE_NORMAL
- en: We are using the `cars` database for the actual solution code, and `cars_test`
    for the automated tests. This way, our automated tests won’t contaminate our main
    application database.
  prefs: []
  type: TYPE_NORMAL
- en: Now, finally, before we deploy to the CI solution, let’s run the `runCoverage.sh`
    shell script we built earlier.
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the following command from the host machine:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Alternatively, run the following command inside the `docker_server-web_1` container:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, you should see the following test result:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.4 – Test coverage report](img/Figure_9.04_B18318.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.4 – Test coverage report
  prefs: []
  type: TYPE_NORMAL
- en: 'Great! At this stage, we are sure that the tests are running properly and that
    they can also connect to the test database:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.5 – Test data](img/Figure_9.05_B18318.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.5 – Test data
  prefs: []
  type: TYPE_NORMAL
- en: If you check the `toy_cars` table inside the `cars_test` MySQL database, you
    should see some sample data created by the automated tests.
  prefs: []
  type: TYPE_NORMAL
- en: Next, let’s move on to our more elaborate functional tests defined inside the
    Behat application.
  prefs: []
  type: TYPE_NORMAL
- en: Preparing the Behat application and tests
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In the previous section, we were able to run and pass all the Symfony application
    tests. Now, we’ll need to make sure that we have also passed our behavior-driven
    tests living inside the Behat application.
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the following command from your host machine to set up the Behat application:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Alternatively, run the following command inside the `docker_server-web_1` container:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Just like what we did earlier in the Symfony application, we first need to set
    up the Behat application and install its dependencies.
  prefs: []
  type: TYPE_NORMAL
- en: In [*Chapter 6*](B18318_06.xhtml#_idTextAnchor094), *Applying Behavior-Driven
    Development*, we created test features and scenarios using the Gherkin language.
    We also created some Context PHP classes that contain steps we have defined in
    the feature files we’ve created. These Context classes will be executed by Behat
    to serve as functional PHP tests.
  prefs: []
  type: TYPE_NORMAL
- en: The difference between the Symfony tests and the tests from our Behat application
    is that the Behat tests do not care about how we achieve the results or how specific
    PHP classes interact with other PHP classes. They only care about testing very
    high-level functional and behavioral scenarios.
  prefs: []
  type: TYPE_NORMAL
- en: That’s it – now, we are ready to run our behavior-driven tests.
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the following command from the host machine and see whether you can pass
    our Behat tests:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Alternatively, run the following command inside the `docker_server-web_1` container:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'You should see the following results:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.6 – Behat tests passing](img/Figure_9.06_B18318.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.6 – Behat tests passing
  prefs: []
  type: TYPE_NORMAL
- en: Great! We have passed all the test scenarios that we have defined. If you want
    to check all the feature files and scenarios, you can open the files in `codebase/behat/features`.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we are sure that our automated tests are working properly from our
    development machine, we are ready to use them in Bitbucket Pipelines for our CI
    solution.
  prefs: []
  type: TYPE_NORMAL
- en: Using Bitbucket Pipelines for CI
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We’ve spent a lot of effort building our automated tests and solution code,
    and all these efforts are aimed to help us develop maintainable and more reliable
    software. CI is the practice of being able to integrate code changes from different
    sources. With the addition of automated tests, this is where our hard work will
    start to pay off on a bigger scale with all the tests we’ve been writing. This
    will help in preventing us from introducing regressions into the main code base.
    For example, the CI process can reject a git pull request if there are broken
    automated tests.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are a lot of CI tools out there, but in this example, since I am using
    Bitbucket for the version control in the project, I’ll just use Bitbucket Pipelines
    as it’s already integrated well with Bitbucket Cloud. It is extremely easy to
    use, as you will see. Let’s get started:'
  prefs: []
  type: TYPE_NORMAL
- en: 'In the Bitbucket Cloud dashboard, select the repository you are using for your
    project, and click on the **Pipelines** link on the left menu:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 9.7 – Create your first pipeline](img/Figure_9.07_B18318.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.7 – Create your first pipeline
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, select the **Build PHP Application** box. You will see the example template
    for creating your first pipeline:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 9.8 – Create your first pipeline](img/Figure_9.08_B18318.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.8 – Create your first pipeline
  prefs: []
  type: TYPE_NORMAL
- en: 'Here, you will see a simple `.yml` file; you can edit it to run your script.
    For our example project, you can use the following content:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: bitbucket-pipelines.yml
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, these are just some commands we want to run while setting up
    the Docker containers we need to use in the CI cloud. You will notice that we
    are using the `codebase/symfony/setup.sh` and `codebase/behat/setup.sh` files
    to install all the dependencies and libraries that our Symfony and Behat applications
    need. This includes creating the `cars` and `cars_test` databases we are using
    inside our Symfony application!
  prefs: []
  type: TYPE_NORMAL
- en: 'Paste the script into the text area and click on the **Commit File** button.
    You’ll be redirected to the **Pipelines** page, where you will see your build
    running:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 9.9 – Pipeline running](img/Figure_9.09_B18318.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.9 – Pipeline running
  prefs: []
  type: TYPE_NORMAL
- en: You will notice from the preceding screenshot that we were able to build the
    same containers we were working with from our local machine.
  prefs: []
  type: TYPE_NORMAL
- en: 'The build will take a few minutes to run. Here, we want the following to happen
    in the CI cloud:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a host machine.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Install the necessary libraries we need to run `docker-compose`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Build the Docker containers we are using for our solution.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Install Composer packages for Symfony.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Run the Doctrine Database migrations for Symfony.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Execute the `runCoverage.sh` test script for Symfony.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Make sure we pass all the Symfony tests.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Install Composer packages for Behat.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Execute the `runBehatTests.sh` test script for Behat.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Make sure we pass all the Behat tests.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'That’s a lot of steps! But we need to do all of these things to make sure we
    can run our automated tests as if we are just running them from our local machine.
    After a few minutes, check back on your **Build** and see whether we have passed
    the Symfony tests:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/Figure_9.10_B18318.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figue 9.10 – CI pass Symfony tests
  prefs: []
  type: TYPE_NORMAL
- en: 'Great! By running the `runCoverage.sh` shell script from inside the CI, we
    can make sure that all the tests and code are still running as expected! Now,
    let’s see whether our Behat tests also pass. Keep scrolling down the build screen
    until you find the Behat test results:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.11 – CI pass Behat tests](img/Figure_9.11_B18318.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.11 – CI pass Behat tests
  prefs: []
  type: TYPE_NORMAL
- en: As you can see from the log, we passed the same five scenarios that we passed
    earlier from our local development machine!
  prefs: []
  type: TYPE_NORMAL
- en: At this stage, **Pipelines** will show a green bar with a check indicating that
    we have passed the entire build.
  prefs: []
  type: TYPE_NORMAL
- en: In [*Chapter 2*](B18318_02.xhtml#_idTextAnchor027), *Understanding and Organizing
    the Business Requirements of Our Project*, we created some Jira tickets and integrated
    our Bitbucket repository into the Jira project. Now, this is going to be very
    handy for Bitbucket Pipelines as it is also seamlessly integrated with Jira.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the root directory of the solution code, as cloned from [https://github.com/PacktPublishing/Test-Driven-Development-with-PHP-8/tree/main/Chapter%209](https://github.com/PacktPublishing/Test-Driven-Development-with-PHP-8/tree/main/Chapter%209),
    you will find a `bitbucket-pipelines.yml` file containing the scripts we have
    used to run our first pipeline. Now, each time you push an update into the Bitbucket
    branch that is connected to the Jira ticket that you’re working on, Jira will
    be automatically able to detect the Pipelines build that is running for your Jira
    ticket as well:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.12 – Jira and Pipelines integrated](img/Figure_9.12_B18318.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.12 – Jira and Pipelines integrated
  prefs: []
  type: TYPE_NORMAL
- en: 'Click on the **1 build incomplete** link below the **Create pull request**link
    area highlighted in the preceding screenshot; you will see a popup containing
    the list of builds that have been executed for that branch and ticket:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.13 – Pipelines builds popup from the Jira page](img/Figure_9.13_B18318.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.13 – Pipelines builds popup from the Jira page
  prefs: []
  type: TYPE_NORMAL
- en: This is a set of very powerful tools. Your team can monitor tasks using Jira,
    and you can make sure that the source code being pushed by you, or any other developer,
    is not detrimental to the existing software before you decide whether you want
    to deploy the solution.
  prefs: []
  type: TYPE_NORMAL
- en: If a developer pushes code that changes the behavior of your application negatively,
    and there are enough automated tests to cover it, then you’ll be able to catch
    the problem as it will fail the CI build.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we went through the process of setting up our updated development
    environment complete with all the test and solution code we need to build our
    example project. We created and used shell scripts to help us install dependencies,
    set up databases, and seed data, making sure that we have everything we need to
    easily run our tests from a local machine or in the cloud.
  prefs: []
  type: TYPE_NORMAL
- en: We also created our first Bitbucket Pipeline to help us implement continuous
    integration. By using CI, we can run all our automated tests in the cloud to make
    sure that we do not break anything in the code base each time we commit and push
    changes to a branch.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will deploy our solution into an external web server,
    where we will also be able to test the application using a web browser.
  prefs: []
  type: TYPE_NORMAL
