- en: '9'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '9'
- en: Continuous Integration
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 持续集成
- en: In the previous chapters, we went through the software development process of
    a toy car model inventory solution. We followed the test-driven development process,
    and at this stage, we should now be familiar with it. However, there are still
    a lot of missing features in the software that we are building. In this chapter,
    we will start with an almost complete solution that you can get from the GitHub
    repository for this chapter. We will then make sure our solution works.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在前几章中，我们探讨了玩具车模型库存解决方案的软件开发过程。我们遵循了测试驱动开发的过程，在这个阶段，我们应该已经熟悉了它。然而，我们正在构建的软件中仍然有很多缺失的功能。在本章中，我们将从一个几乎完整的解决方案开始，你可以从本章的
    GitHub 仓库中获取这个解决方案。然后我们将确保我们的解决方案能够正常工作。
- en: In this chapter, we’ll start with an almost complete software solution except
    for the missing last feature, which is to filter the table containing the toy
    car models. We have built a lot of tests; wouldn’t it be great if we could automatically
    trigger the execution of these tests whenever we created a pull request to the
    develop or main branch? Automatically triggering the test suites that we have
    spent so much time developing will help us catch bugs or defects before they even
    get merged into the main branch. This is where continuous integration will be
    able to help us.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将从一个几乎完整的软件解决方案开始，除了缺少的最后一个功能，即过滤包含玩具车模型的表格。我们已经编写了很多测试；如果我们能够在创建 develop
    或 main 分支的 pull request 时自动触发这些测试的执行，那岂不是很好？自动触发我们花费了大量时间开发的测试套件将帮助我们捕捉到在它们甚至被合并到主分支之前就已经存在的错误或缺陷。这就是持续集成能够帮助我们的地方。
- en: 'In this chapter, we will go through the following topics:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将探讨以下主题：
- en: Running and passing all the Symfony application tests
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 运行并通过所有 Symfony 应用程序测试
- en: Using Bitbucket Pipelines for continuous integration
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Bitbucket Pipelines 进行持续集成
- en: Technical requirements
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'In this chapter, you are expected to have basic knowledge of using Git version
    control for web applications. You should also use the development environment
    and solution code from this book’s GitHub repository: [https://github.com/PacktPublishing/Test-Driven-Development-with-PHP-8/tree/main/Chapter%209](https://github.com/PacktPublishing/Test-Driven-Development-with-PHP-8/tree/main/Chapter%209).'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你应具备使用 Git 版本控制进行 Web 应用程序的基本知识。你还应使用本书 GitHub 仓库中的开发环境和解决方案代码：[https://github.com/PacktPublishing/Test-Driven-Development-with-PHP-8/tree/main/Chapter%209](https://github.com/PacktPublishing/Test-Driven-Development-with-PHP-8/tree/main/Chapter%209)。
- en: Preparing the development environment for this chapter
  id: totrans-9
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 为本章准备开发环境
- en: First, download the code found at [https://github.com/PacktPublishing/Test-Driven-Development-with-PHP-8/tree/main/Chapter%209](https://github.com/PacktPublishing/Test-Driven-Development-with-PHP-8/tree/main/Chapter%209).
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，下载位于[https://github.com/PacktPublishing/Test-Driven-Development-with-PHP-8/tree/main/Chapter%209](https://github.com/PacktPublishing/Test-Driven-Development-with-PHP-8/tree/main/Chapter%209)的代码。
- en: To run the containers and execute the commands in this chapter, you should be
    inside the `docker-server-web-1` container.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 要运行容器并执行本章中的命令，你应该在 `docker-server-web-1` 容器内部。
- en: 'Run the following command to confirm the container name for our web server:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 运行以下命令以确认我们的 web 服务器的容器名称：
- en: '[PRE0]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'To run the containers, run the following command from the `/docker` directory
    from the repository in your host machine:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 要运行容器，请从主机机器上的 `/docker` 目录运行以下命令：
- en: '[PRE1]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Once inside the container, run the following commands to install the libraries
    required through Composer:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦进入容器，运行以下命令以通过 Composer 安装所需的库：
- en: '[PRE2]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Running and passing all the Symfony application tests
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 运行并通过所有 Symfony 应用程序测试
- en: In the previous chapter, we started writing solution code by trying to follow
    the SOLID principles. To develop the other parts of the application, we can just
    continue following the same process. In this chapter, I have taken the liberty
    to complete all other tests and the solution code needed to pass those tests.
    We will go through the tests and make sure they pass.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们开始编写解决方案代码，试图遵循 SOLID 原则。为了开发应用程序的其他部分，我们可以继续遵循相同的过程。在本章中，我已自行完成了所有其他测试和通过这些测试所需的解决方案代码。我们将通过这些测试并确保它们通过。
- en: Setting up the local environment
  id: totrans-20
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设置本地环境
- en: 'Check out the source code provided in the *Technical requirements* section
    into your local development machine and run the following commands from the host
    machine to configure your development environment:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 将*技术要求*部分提供的源代码检查到你的本地开发机器中，并从主机机器上运行以下命令来配置你的开发环境：
- en: '[PRE3]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'After running these commands, make sure that the containers we built earlier
    in this book are up and running by running the following command:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在运行这些命令后，确保本书前面构建的容器正在运行，可以通过运行以下命令来检查：
- en: '[PRE4]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'You should see the following Docker container names:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该会看到以下Docker容器名称：
- en: '[PRE5]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Now that the containers are running, we need to prepare the Symfony and Behat
    applications running inside the `docker_server-web_1` container by installing
    the packages they depend on, as well as creating the database and tables that
    our example PHP application needs.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 现在容器正在运行，我们需要通过安装它们依赖的包以及创建我们的示例PHP应用所需的数据库和表来准备`docker_server-web_1`容器内运行的Symfony和Behat应用。
- en: Preparing the Symfony application and tests
  id: totrans-28
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 准备Symfony应用和测试
- en: 'Now, let’s set up the required database tables and libraries needed by our
    Symfony application. While still inside the `docker` directory, run the following
    command from your host machine:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们设置我们的Symfony应用所需的数据库表和库。仍然在`docker`目录内，从你的主机机器上运行以下命令：
- en: '[PRE6]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Alternatively, run the following command inside the `docker_server-web_1` container:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，在`docker_server-web_1`容器内部运行以下命令：
- en: '[PRE7]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The `setup.sh` file is just a shell script I have added to easily configure
    our Symfony application and prepare the database and tables we need to run the
    tests.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '`setup.sh`文件只是一个shell脚本，我添加它来方便地配置我们的Symfony应用，并准备运行测试所需的数据库和表。'
- en: 'If you open the following shell file, you will see that we are simply running
    some Doctrine commands and using Composer to install all the Symfony dependencies
    needed:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你打开以下shell文件，你会看到我们只是在运行一些Doctrine命令，并使用Composer安装所有所需的Symfony依赖项：
- en: codebase/symfony/setup.sh
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: '`codebase/symfony/setup.sh`'
- en: '[PRE8]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: This shell script will come in handy once we are running the application in
    the **continuous integration** (**CI**) machine.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们在**持续集成**（**CI**）机器上运行应用时，这个shell脚本将非常有用。
- en: After running the `setup.sh` command, your development environment should be
    ready to run all the unit and integration tests from inside our Symfony application.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 在运行`setup.sh`命令后，你的开发环境应该已经准备好，可以从我们的Symfony应用内部运行所有单元和集成测试。
- en: In [*Chapter 5*](B18318_05.xhtml#_idTextAnchor070), *Unit Testing*, we created
    a shell script called `codebase/symfony/runCoverage.sh`. This shell script will
    help us run all the tests and check how much test coverage we have against our
    solution code. Realistically speaking though, we don’t have to cover all the code
    inside our application since some of them are third-party libraries with no tests,
    or some of them might be just **Plain Old PHP Object** (**POPO**) classes. But
    for the code that we develop, we should add automated tests for them.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 在[*第五章*](B18318_05.xhtml#_idTextAnchor070)的*单元测试*部分，我们创建了一个名为`codebase/symfony/runCoverage.sh`的shell脚本。这个shell脚本将帮助我们运行所有测试并检查我们的解决方案代码的测试覆盖率。然而，从现实的角度来看，我们不需要覆盖应用内部的所有代码，因为其中一些是没有任何测试的第三方库，或者其中一些可能是简单的**纯PHP对象**（**POPO**）类。但对于我们开发的代码，我们应该为它们添加自动化的测试。
- en: If you think you need to exclude some classes from the code coverage report,
    you can open the `codebase/symfony/phpunit.xml` configuration file and add the
    directories you want to exclude from the coverage report.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你认为需要从代码覆盖率报告中排除一些类，你可以打开`codebase/symfony/phpunit.xml`配置文件，并添加你想要从覆盖率报告中排除的目录。
- en: 'From within the `docker_server-web_1` container, if you open the `codebase/symfony/tests`
    directory inside our Symfony application, you will see the following tests:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 在`docker_server-web_1`容器内部，如果你打开我们的Symfony应用中的`codebase/symfony/tests`目录，你会看到以下测试：
- en: '![Figure 9.1 – Symfony tests directory](img/Figure_9.01_B18318.jpg)'
  id: totrans-42
  prefs: []
  type: TYPE_IMG
  zh: '![图9.1 – Symfony测试目录](img/Figure_9.01_B18318.jpg)'
- en: Figure 9.1 – Symfony tests directory
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.1 – Symfony测试目录
- en: 'We have three main directories for the tests: **Functional**, **Integration**,
    and **Unit**. The **Functional** tests in this example are the controller tests,
    which are the tests that use HTTP requests; you can think of them as Integration
    tests as well but they cover more integrated code. The **Integration** tests are
    the tests that run through the different custom classes and how they interact
    with each other, making sure that they all work as expected. Finally, the **Unit**
    tests are simple tests that focus on single units or functions inside a specific
    class.'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有三个主要的测试目录：**功能**、**集成**和**单元**。在这个例子中，**功能**测试是控制器测试，这些测试使用 HTTP 请求；你可以把它们看作是集成测试，但它们覆盖了更集成的代码。**集成**测试是运行通过不同自定义类及其相互交互的测试，确保它们都按预期工作。最后，**单元**测试是简单的测试，专注于特定类中的单个单元或函数。
- en: You can browse through the directories and classes inside `codebase/symfony/src`
    to check the actual classes our tests are testing against.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以浏览`codebase/symfony/src`目录和类，以检查我们的测试实际针对的类。
- en: 'Let’s see whether the tests pass; from the host machine, run the following
    command:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看测试是否通过；从主机机器上运行以下命令：
- en: '[PRE9]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Alternatively, run the following command inside the `docker_server-web_1` container:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，在`docker_server-web_1`容器内部运行以下命令：
- en: '[PRE10]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Since we have configured the database and tables needed for the tests, you
    should see the following result:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们已经配置了测试所需的数据库和表，你应该看到以下结果：
- en: '![Figure 9.2 – Passing Symfony tests](img/Figure_9.02_B18318.jpg)'
  id: totrans-51
  prefs: []
  type: TYPE_IMG
  zh: '![图 9.2 – 通过 Symfony 测试](img/Figure_9.02_B18318.jpg)'
- en: Figure 9.2 – Passing Symfony tests
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.2 – 通过 Symfony 测试
- en: It looks like we have a lot of passing tests, but let’s open one of the test
    classes and see exactly what we are testing for.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 看起来我们有很多通过测试，但让我们打开一个测试类，看看我们确切在测试什么。
- en: 'Open `codebase/symfony/tests/Integration/DAL/Reader/ColorReaderTest.php`; you
    will see the following content:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 打开`codebase/symfony/tests/Integration/DAL/Reader/ColorReaderTest.php`；你会看到以下内容：
- en: '[PRE11]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: You will notice that in this test class, we are reading data from the database
    and running some assertions against the results from the database. In [*Chapter
    7*](B18318_07.xhtml#_idTextAnchor108), *Building Solution Code with BDD and TDD*,
    we created the databases we needed for both testing and the main database for
    the actual solution code.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 你会注意到，在这个测试类中，我们从数据库中读取数据，并对数据库的结果执行一些断言。在[*第 7 章*](B18318_07.xhtml#_idTextAnchor108)，“使用
    BDD 和 TDD 构建解决方案代码”，我们创建了测试所需和实际解决方案代码的主数据库。
- en: 'We have the following databases inside the `docker_server-mysql_1` container:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 在`docker_server-mysql_1`容器内部有以下数据库：
- en: '![Figure 9.3 – MySQL databases](img/Figure_9.03_B18318.jpg)'
  id: totrans-58
  prefs: []
  type: TYPE_IMG
  zh: '![图 9.3 – MySQL 数据库](img/Figure_9.03_B18318.jpg)'
- en: Figure 9.3 – MySQL databases
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.3 – MySQL 数据库
- en: We are using the `cars` database for the actual solution code, and `cars_test`
    for the automated tests. This way, our automated tests won’t contaminate our main
    application database.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`cars`数据库作为实际解决方案代码，使用`cars_test`进行自动化测试。这样，我们的自动化测试就不会污染我们的主要应用程序数据库。
- en: Now, finally, before we deploy to the CI solution, let’s run the `runCoverage.sh`
    shell script we built earlier.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，最后，在我们部署到 CI 解决方案之前，让我们运行我们之前构建的`runCoverage.sh` shell 脚本。
- en: 'Run the following command from the host machine:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 从主机机器上运行以下命令：
- en: '[PRE12]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Alternatively, run the following command inside the `docker_server-web_1` container:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，在`docker_server-web_1`容器内部运行以下命令：
- en: '[PRE13]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Now, you should see the following test result:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你应该看到以下测试结果：
- en: '![Figure 9.4 – Test coverage report](img/Figure_9.04_B18318.jpg)'
  id: totrans-67
  prefs: []
  type: TYPE_IMG
  zh: '![图 9.4 – 测试覆盖率报告](img/Figure_9.04_B18318.jpg)'
- en: Figure 9.4 – Test coverage report
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.4 – 测试覆盖率报告
- en: 'Great! At this stage, we are sure that the tests are running properly and that
    they can also connect to the test database:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 太好了！在这个阶段，我们确信测试正在正常运行，并且它们也可以连接到测试数据库：
- en: '![Figure 9.5 – Test data](img/Figure_9.05_B18318.jpg)'
  id: totrans-70
  prefs: []
  type: TYPE_IMG
  zh: '![图 9.5 – 测试数据](img/Figure_9.05_B18318.jpg)'
- en: Figure 9.5 – Test data
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.5 – 测试数据
- en: If you check the `toy_cars` table inside the `cars_test` MySQL database, you
    should see some sample data created by the automated tests.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你检查`cars_test` MySQL 数据库中的`toy_cars`表，你应该看到自动化测试创建的一些样本数据。
- en: Next, let’s move on to our more elaborate functional tests defined inside the
    Behat application.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们继续到 Behat 应用程序内部定义的更详细的函数测试。
- en: Preparing the Behat application and tests
  id: totrans-74
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 准备 Behat 应用程序和测试
- en: In the previous section, we were able to run and pass all the Symfony application
    tests. Now, we’ll need to make sure that we have also passed our behavior-driven
    tests living inside the Behat application.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节中，我们能够运行并通过所有Symfony应用程序测试。现在，我们需要确保我们也通过了Behat应用程序中的行为驱动测试。
- en: 'Run the following command from your host machine to set up the Behat application:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 从您的宿主机运行以下命令来设置Behat应用程序：
- en: '[PRE14]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Alternatively, run the following command inside the `docker_server-web_1` container:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，在`docker_server-web_1`容器内运行以下命令：
- en: '[PRE15]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Just like what we did earlier in the Symfony application, we first need to set
    up the Behat application and install its dependencies.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 就像我们在之前的Symfony应用程序中做的那样，我们首先需要设置Behat应用程序并安装其依赖项。
- en: In [*Chapter 6*](B18318_06.xhtml#_idTextAnchor094), *Applying Behavior-Driven
    Development*, we created test features and scenarios using the Gherkin language.
    We also created some Context PHP classes that contain steps we have defined in
    the feature files we’ve created. These Context classes will be executed by Behat
    to serve as functional PHP tests.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 在[*第6章*](B18318_06.xhtml#_idTextAnchor094)“应用行为驱动开发”中，我们使用Gherkin语言创建了测试功能和场景。我们还创建了一些包含我们在创建的功能文件中定义的步骤的上下文PHP类。这些上下文类将由Behat执行，作为功能PHP测试。
- en: The difference between the Symfony tests and the tests from our Behat application
    is that the Behat tests do not care about how we achieve the results or how specific
    PHP classes interact with other PHP classes. They only care about testing very
    high-level functional and behavioral scenarios.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: Symfony测试和我们的Behat应用程序测试之间的区别在于，Behat测试不关心我们如何实现结果或特定的PHP类如何与其他PHP类交互。它们只关心测试非常高级的功能和行为场景。
- en: That’s it – now, we are ready to run our behavior-driven tests.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 就这些了——现在，我们已经准备好运行我们的行为驱动测试了。
- en: 'Run the following command from the host machine and see whether you can pass
    our Behat tests:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 从宿主机运行以下命令，看看您是否可以通过我们的Behat测试：
- en: '[PRE16]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Alternatively, run the following command inside the `docker_server-web_1` container:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，在`docker_server-web_1`容器内运行以下命令：
- en: '[PRE17]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'You should see the following results:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该看到以下结果：
- en: '![Figure 9.6 – Behat tests passing](img/Figure_9.06_B18318.jpg)'
  id: totrans-89
  prefs: []
  type: TYPE_IMG
  zh: '![图9.6 – Behat测试通过](img/Figure_9.06_B18318.jpg)'
- en: Figure 9.6 – Behat tests passing
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.6 – Behat测试通过
- en: Great! We have passed all the test scenarios that we have defined. If you want
    to check all the feature files and scenarios, you can open the files in `codebase/behat/features`.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 太好了！我们已经通过了我们定义的所有测试场景。如果您想检查所有功能文件和场景，您可以在`codebase/behat/features`中打开这些文件。
- en: Now that we are sure that our automated tests are working properly from our
    development machine, we are ready to use them in Bitbucket Pipelines for our CI
    solution.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们确信我们的自动化测试在开发机器上运行正常，我们就可以准备在Bitbucket Pipelines中为我们CI解决方案使用它们了。
- en: Using Bitbucket Pipelines for CI
  id: totrans-93
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Bitbucket Pipelines进行持续集成
- en: We’ve spent a lot of effort building our automated tests and solution code,
    and all these efforts are aimed to help us develop maintainable and more reliable
    software. CI is the practice of being able to integrate code changes from different
    sources. With the addition of automated tests, this is where our hard work will
    start to pay off on a bigger scale with all the tests we’ve been writing. This
    will help in preventing us from introducing regressions into the main code base.
    For example, the CI process can reject a git pull request if there are broken
    automated tests.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 我们投入了大量的努力来构建我们的自动化测试和解决方案代码，所有这些努力都是为了帮助我们开发可维护且更可靠的软件。持续集成（CI）是指能够从不同来源集成代码变更的实践。随着自动化测试的加入，我们所有的努力将开始在大规模上得到回报，因为我们已经编写了所有这些测试。这将帮助我们防止将回归引入主代码库。例如，CI过程可以拒绝一个git
    pull请求，如果存在损坏的自动化测试。
- en: 'There are a lot of CI tools out there, but in this example, since I am using
    Bitbucket for the version control in the project, I’ll just use Bitbucket Pipelines
    as it’s already integrated well with Bitbucket Cloud. It is extremely easy to
    use, as you will see. Let’s get started:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 现在有大量的CI工具，但在这个例子中，由于我在项目中使用Bitbucket进行版本控制，所以我将只使用Bitbucket Pipelines，因为它已经很好地与Bitbucket
    Cloud集成。它非常容易使用，您将会看到。让我们开始吧：
- en: 'In the Bitbucket Cloud dashboard, select the repository you are using for your
    project, and click on the **Pipelines** link on the left menu:'
  id: totrans-96
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Bitbucket Cloud仪表板中，选择您用于项目的存储库，然后点击左侧菜单上的**流水线**链接：
- en: '![Figure 9.7 – Create your first pipeline](img/Figure_9.07_B18318.jpg)'
  id: totrans-97
  prefs: []
  type: TYPE_IMG
  zh: '![图9.7 – 创建你的第一个流水线](img/Figure_9.07_B18318.jpg)'
- en: Figure 9.7 – Create your first pipeline
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.7 – 创建你的第一个管道
- en: 'Then, select the **Build PHP Application** box. You will see the example template
    for creating your first pipeline:'
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，选择 **构建 PHP 应用程序** 复选框。您将看到创建第一个管道的示例模板：
- en: '![Figure 9.8 – Create your first pipeline](img/Figure_9.08_B18318.jpg)'
  id: totrans-100
  prefs: []
  type: TYPE_IMG
  zh: '![图 9.8 – 创建你的第一个管道](img/Figure_9.08_B18318.jpg)'
- en: Figure 9.8 – Create your first pipeline
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.8 – 创建你的第一个管道
- en: 'Here, you will see a simple `.yml` file; you can edit it to run your script.
    For our example project, you can use the following content:'
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这里，您将看到一个简单的 `.yml` 文件；您可以编辑它以运行您的脚本。对于我们的示例项目，您可以使用以下内容：
- en: bitbucket-pipelines.yml
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: bitbucket-pipelines.yml
- en: '[PRE18]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: As you can see, these are just some commands we want to run while setting up
    the Docker containers we need to use in the CI cloud. You will notice that we
    are using the `codebase/symfony/setup.sh` and `codebase/behat/setup.sh` files
    to install all the dependencies and libraries that our Symfony and Behat applications
    need. This includes creating the `cars` and `cars_test` databases we are using
    inside our Symfony application!
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，这些只是我们在设置 CI 云中需要使用的 Docker 容器时想要运行的命令。您会注意到我们正在使用 `codebase/symfony/setup.sh`
    和 `codebase/behat/setup.sh` 文件来安装我们的 Symfony 和 Behat 应用程序所需的全部依赖项和库。这包括在我们的 Symfony
    应用程序内部创建我们使用的 `cars` 和 `cars_test` 数据库！
- en: 'Paste the script into the text area and click on the **Commit File** button.
    You’ll be redirected to the **Pipelines** page, where you will see your build
    running:'
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将脚本粘贴到文本区域，然后点击 **提交文件** 按钮。您将被重定向到 **管道** 页面，在那里您将看到您的构建正在运行：
- en: '![Figure 9.9 – Pipeline running](img/Figure_9.09_B18318.jpg)'
  id: totrans-107
  prefs: []
  type: TYPE_IMG
  zh: '![图 9.9 – 管道运行](img/Figure_9.09_B18318.jpg)'
- en: Figure 9.9 – Pipeline running
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.9 – 管道运行
- en: You will notice from the preceding screenshot that we were able to build the
    same containers we were working with from our local machine.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 从前面的屏幕截图可以看出，我们能够构建与我们在本地机器上工作相同的容器。
- en: 'The build will take a few minutes to run. Here, we want the following to happen
    in the CI cloud:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 构建过程将需要几分钟。在这里，我们希望在 CI 云中发生以下操作：
- en: Create a host machine.
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建主机机器。
- en: Install the necessary libraries we need to run `docker-compose`.
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 安装运行 `docker-compose` 所需的必要库。
- en: Build the Docker containers we are using for our solution.
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 构建我们用于解决方案的 Docker 容器。
- en: Install Composer packages for Symfony.
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 安装 Symfony 的 Composer 包。
- en: Run the Doctrine Database migrations for Symfony.
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行 Doctrine 数据库迁移以进行 Symfony。
- en: Execute the `runCoverage.sh` test script for Symfony.
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 执行 `runCoverage.sh` 测试脚本以进行 Symfony。
- en: Make sure we pass all the Symfony tests.
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保我们通过所有的 Symfony 测试。
- en: Install Composer packages for Behat.
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 安装 Behat 的 Composer 包。
- en: Execute the `runBehatTests.sh` test script for Behat.
  id: totrans-119
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 执行 `runBehatTests.sh` 测试脚本以进行 Behat。
- en: Make sure we pass all the Behat tests.
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保我们通过所有的 Behat 测试。
- en: 'That’s a lot of steps! But we need to do all of these things to make sure we
    can run our automated tests as if we are just running them from our local machine.
    After a few minutes, check back on your **Build** and see whether we have passed
    the Symfony tests:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 这需要很多步骤！但我们需要做所有这些事情，以确保我们可以像在本地机器上运行它们一样运行我们的自动化测试。几分钟后，回到您的 **构建** 页面，查看我们是否通过了
    Symfony 测试：
- en: '![](img/Figure_9.10_B18318.jpg)'
  id: totrans-122
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/Figure_9.10_B18318.jpg)'
- en: Figue 9.10 – CI pass Symfony tests
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.10 – CI 通过 Symfony 测试
- en: 'Great! By running the `runCoverage.sh` shell script from inside the CI, we
    can make sure that all the tests and code are still running as expected! Now,
    let’s see whether our Behat tests also pass. Keep scrolling down the build screen
    until you find the Behat test results:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 太好了！通过在 CI 内部运行 `runCoverage.sh` 脚本，我们可以确保所有测试和代码仍然按预期运行！现在，让我们看看我们的 Behat 测试是否也通过。继续向下滚动构建屏幕，直到您找到
    Behat 测试结果：
- en: '![Figure 9.11 – CI pass Behat tests](img/Figure_9.11_B18318.jpg)'
  id: totrans-125
  prefs: []
  type: TYPE_IMG
  zh: '![图 9.11 – CI 通过 Behat 测试](img/Figure_9.11_B18318.jpg)'
- en: Figure 9.11 – CI pass Behat tests
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.11 – CI 通过 Behat 测试
- en: As you can see from the log, we passed the same five scenarios that we passed
    earlier from our local development machine!
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 如您从日志中看到的，我们通过了与之前从本地开发机器上通过相同的五个场景！
- en: At this stage, **Pipelines** will show a green bar with a check indicating that
    we have passed the entire build.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个阶段，**管道** 将显示一个带有勾选标记的绿色条，表示我们已经通过了整个构建。
- en: In [*Chapter 2*](B18318_02.xhtml#_idTextAnchor027), *Understanding and Organizing
    the Business Requirements of Our Project*, we created some Jira tickets and integrated
    our Bitbucket repository into the Jira project. Now, this is going to be very
    handy for Bitbucket Pipelines as it is also seamlessly integrated with Jira.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 在[*第2章*](B18318_02.xhtml#_idTextAnchor027)，*理解和组织我们项目的业务需求*中，我们创建了一些Jira工单并将我们的Bitbucket仓库集成到Jira项目中。现在，这对于Bitbucket
    Pipelines来说将非常方便，因为它也与Jira无缝集成。
- en: 'In the root directory of the solution code, as cloned from [https://github.com/PacktPublishing/Test-Driven-Development-with-PHP-8/tree/main/Chapter%209](https://github.com/PacktPublishing/Test-Driven-Development-with-PHP-8/tree/main/Chapter%209),
    you will find a `bitbucket-pipelines.yml` file containing the scripts we have
    used to run our first pipeline. Now, each time you push an update into the Bitbucket
    branch that is connected to the Jira ticket that you’re working on, Jira will
    be automatically able to detect the Pipelines build that is running for your Jira
    ticket as well:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 在从[https://github.com/PacktPublishing/Test-Driven-Development-with-PHP-8/tree/main/Chapter%209](https://github.com/PacktPublishing/Test-Driven-Development-with-PHP-8/tree/main/Chapter%209)克隆的解决方案代码的根目录中，您将找到一个`bitbucket-pipelines.yml`文件，其中包含我们用于运行第一个管道的脚本。现在，每次您将更新推送到与您正在处理的Jira工单连接的Bitbucket分支时，Jira将能够自动检测为您的Jira工单运行的Pipelines构建：
- en: '![Figure 9.12 – Jira and Pipelines integrated](img/Figure_9.12_B18318.jpg)'
  id: totrans-131
  prefs: []
  type: TYPE_IMG
  zh: '![图9.12 – Jira和Pipelines集成](img/Figure_9.12_B18318.jpg)'
- en: Figure 9.12 – Jira and Pipelines integrated
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.12 – Jira和Pipelines集成
- en: 'Click on the **1 build incomplete** link below the **Create pull request**link
    area highlighted in the preceding screenshot; you will see a popup containing
    the list of builds that have been executed for that branch and ticket:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 点击前面截图中的**创建拉取请求**区域下方的**1构建不完整**链接；您将看到一个弹出窗口，其中包含为该分支和工单已执行的构建列表：
- en: '![Figure 9.13 – Pipelines builds popup from the Jira page](img/Figure_9.13_B18318.jpg)'
  id: totrans-134
  prefs: []
  type: TYPE_IMG
  zh: '![图9.13 – Pipelines从Jira页面构建弹出窗口](img/Figure_9.13_B18318.jpg)'
- en: Figure 9.13 – Pipelines builds popup from the Jira page
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.13 – 从Jira页面构建弹出窗口
- en: This is a set of very powerful tools. Your team can monitor tasks using Jira,
    and you can make sure that the source code being pushed by you, or any other developer,
    is not detrimental to the existing software before you decide whether you want
    to deploy the solution.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一套非常强大的工具。您的团队可以使用Jira监控任务，并确保在您决定是否部署解决方案之前，您或任何其他开发者推送的源代码不会对现有软件造成损害。
- en: If a developer pushes code that changes the behavior of your application negatively,
    and there are enough automated tests to cover it, then you’ll be able to catch
    the problem as it will fail the CI build.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 如果开发者推送的代码改变了应用程序的负面行为，并且有足够的自动化测试来覆盖它，那么您将能够在CI构建失败时捕捉到问题。
- en: Summary
  id: totrans-138
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we went through the process of setting up our updated development
    environment complete with all the test and solution code we need to build our
    example project. We created and used shell scripts to help us install dependencies,
    set up databases, and seed data, making sure that we have everything we need to
    easily run our tests from a local machine or in the cloud.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们完成了设置我们的更新后的开发环境的过程，包括构建示例项目所需的全部测试和解决方案代码。我们创建并使用shell脚本来帮助我们安装依赖项、设置数据库和初始化数据，确保我们拥有从本地机器或云端轻松运行测试所需的一切。
- en: We also created our first Bitbucket Pipeline to help us implement continuous
    integration. By using CI, we can run all our automated tests in the cloud to make
    sure that we do not break anything in the code base each time we commit and push
    changes to a branch.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还创建了我们的第一个Bitbucket Pipeline，以帮助我们实现持续集成。通过使用CI，我们可以将所有自动化测试在云端运行，以确保每次提交和推送更改到分支时，我们不会破坏代码库中的任何内容。
- en: In the next chapter, we will deploy our solution into an external web server,
    where we will also be able to test the application using a web browser.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将把我们的解决方案部署到外部Web服务器，在那里我们也将能够使用Web浏览器测试应用程序。
