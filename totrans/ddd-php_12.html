<html><head></head><body>
        <section>

            <header>
                <h1 class="header-title">Integrating Bounded Contexts</h1>
            </header>

            <article>
                
<p>Every enterprise application is typically composed of several areas in which the company operates. Areas such as <em>billing</em>, <em>inventory</em>, <em>shipping management</em>, <em>catalog</em>, and so on are common examples. The easiest manner in which to manage all these concerns may seem to lean toward a <strong>monolithic system</strong>. But, you might wonder, does it have to be this way? What if any friction garnered between teams working on these separate areas could be reduced by splitting this big monolithic application into smaller, independent chunks? In this chapter, we'll explore how to do this, so be prepared for insights and heuristics around <strong>strategical design</strong>.</p>
<div class="packt_infobox">
<p><span class="packt_screen">Dealing with Distributed Systems<br/></span>Dealing with distributed systems is <strong>hard</strong>. Breaking a system into independent autonomous parts has its benefits, but it also increases complexity. For example, the coordination and synchronization of distributed systems is not trivial, and as a result, should be considered carefully. As Martin Fowler said in the <a href="https://www.martinfowler.com/books/eaa.html">PoEAA</a> book, the first law of distributed systems is always: <strong>Don't distribute</strong>.</p>
</div>


            </article>

            <footer style="margin-top: 5em;">
                
            </footer>

        </section>
    

        <section>

            <header>
                <h1 class="header-title">Integration Through the Data Store</h1>
            </header>

            <article>
                
<p>One of the most commonly used techniques to integrate different parts of an application has always been to share the same data store, along with the same code base. This is usually known as a monolithic application, and it often ends up with a single data store that hosts the data related to all the concerns within the application.</p>
<p>Consider an e-commerce application. A shared data store would contain all concerns (Example: tables within a relational database) surrounding the catalog, billing, inventory, and so on. There's nothing wrong with this approach per se—for example, in small linear applications where the complexity is not too high. However, within complex Domains, some issues can arise. If you share data across many tables touching multiple application concerns, transactions will have a big impact on performance.</p>
<p>Another less technical problem that could develop is in regard to the Ubiquitous Language. The main advantage of the separation of Bounded Contexts is having <strong>a single Ubiquitous Language for each one</strong>. In doing so, models will be separated into their own Contexts. Mixing all models together within the same Context can lead to ambiguity and confusion.</p>
<p>Going back to the e-commerce system, imagine we want to introduce the concept of a t-shirt. Within the catalogue Context, a t-shirt would be a <em>product</em> with properties like <em>color</em>, <em>size</em>, <em>material</em>, and maybe some fancy <em>pictures</em>. In the <em>inventory</em> system, however, we don't really want to concern ourselves with these things. Here, a <em>product</em> has a different meaning, where we care about different properties like <em>weight</em>, <em>location in the warehouse</em>, or <em>dimensions</em>. Mixing both Contexts together will tangle concepts and complicate the design. In Domain-Driven Design terms, mixing concepts in this manner is what is called a Shared Kernel.</p>
<div class="packt_infobox"><span class="packt_screen">Shared Kernel</span><br/>
Designate some subset of the domain model that the teams agree to share. Of course this includes, along with this subset of the model, the subset of code or of the database design associated with that part of the model. This explicitly shared stuff has special status, and shouldn't be changed without consultation with the other team. Integrate a functional system frequently, but somewhat less often than the pace of CONTINUOUS INTEGRATION within the teams. At these integrations, run the tests of both teams.  Eric Evans - <a href="https://www.amazon.com/Domain-Driven-Design-Tackling-Complexity-Software/dp/0321125215">Domain-Driven Design: Tackling Complexity in the Heart of Software</a></div>
<p>We don't recommend using a Shared Kernel, as multiple teams can collide within the development of it, which not only results in maintenance issues but also becomes a point of friction. However, if you opt to use a Shared Kernel, changes should be agreed upon beforehand and between all parties involved. Conceptually, this approach has other problems, such as people seeing it as a bag to place <em>stuff</em> that doesn't belong anywhere else, and this grows indefinitely. A better way of dealing with the ever-growing complexity of the monolith is to break it up in different autonomous pieces, such as communicating through REST, RPC, or messaging systems. This requires drawing clear boundaries, with each Context likely ending up with its own Infrastructure—data stores, servers, messaging middleware, and so on — and even its own team.</p>
<p>As you might imagine, this could lead to some degree of duplication, but that's a tradeoff that we're willing to make in order to reduce complexity. In Domain-Driven Design, we call these independent pieces <strong>Bounded Contexts</strong>.</p>


            </article>

            <footer style="margin-top: 5em;">
                
            </footer>

        </section>
    

        <section>

            <header>
                <h1 class="header-title">Integration Relationships</h1>
            </header>

            <article>
                
<h2>Customer - Supplier</h2>
<p>When there's a unidirectional integration between two Bounded Contexts, where one acts as a provider (<strong>upstream</strong>) and the other as a client (<strong>downstream</strong>), we'll end up with <strong>Customer - Supplier Development Teams</strong>.</p>
<div class="packt_infobox">Establish a clear customer/supplier relationship between the two teams. In planning sessions, make the downstream team play the customer role to the upstream team. Negotiate and budget tasks for downstream requirements so that everyone understands the commitment and schedule. Jointly develop automated acceptance tests that will validate the interface expected. Add these tests to the upstream team's test suite, to be run as part of its' continuous integration. This testing will free the upstream team to make changes without fear of side effects downstream. Eric Evans - <a href="https://www.amazon.com/Domain-Driven-Design-Tackling-Complexity-Software/dp/0321125215">Domain-Driven Design: Tackling Complexity in the Heart of Software</a>.</div>
<p>Customer - Supplier Development Teams are the most common way of integrating Bounded Contexts and usually represent a win-win situation when teams work closely.</p>


            </article>

            <footer style="margin-top: 5em;">
                
            </footer>

        </section>
    

        <section>

            <header>
                <h1 class="header-title">Separate Ways</h1>
            </header>

            <article>
                
<p>Continuing with the e-commerce example, think about reporting revenue to an old legacy retailer financial system. The integration could be incredibly expensive, resulting in it not being worth the effort to implement. In Domain-Driven Design strategic terms, this is known as <strong>Separate Ways</strong>.</p>
<div class="packt_infobox">Integration is always expensive. Sometimes the benefit is small. So Declare a BOUNDED CONTEXT to have no connection to the others at all, allowing developers to find simple, specialized solutions within this small scope. Eric Evans - <em>Domain-Driven Design:</em> <a href="https://www.amazon.com/Domain-Driven-Design-Tackling-Complexity-Software/dp/0321125215">Tackling Complexity in the Heart of Software</a>.</div>


            </article>

            <footer style="margin-top: 5em;">
                
            </footer>

        </section>
    

        <section>

            <header>
                <h1 class="header-title">Conformist</h1>
            </header>

            <article>
                
<p>Consider again the e-commerce example and integration with a third-party shipping service. Both Domains differ in models, teams, and Infrastructure. The team responsible for maintaining the third-party shipping service will not participate in your product planning or provide any solutions to the e-commerce system. These teams don't have a close relationship. We could choose to accept and <em>conform</em> to their Domain Model. In strategic design, this is what we call a <strong>Conformist Integration</strong>.</p>
<div class="packt_infobox">Eliminate the complexity of translation between BOUNDED CONTEXTS by slavishly adhering to the model of the upstream team. Although this cramps the style of the downstream designers and probably does not yield the ideal model for the application, choosing CONFORMITY enormously simplifies integration. Also, you will share a UBIQUITOUS LANGUAGE with your supplier team. The supplier is in the driver's seat, so it is good to make communication easy for them. Altruism may be sufficient to get them to share information with you. Eric Evans - <em>Domain-Driven Design:</em> <a href="https://www.amazon.com/Domain-Driven-Design-Tackling-Complexity-Software/dp/0321125215">Tackling Complexity in the Heart of Software</a>.</div>


            </article>

            <footer style="margin-top: 5em;">
                
            </footer>

        </section>
    

        <section>

            <header>
                <h1 class="header-title">Implementing Bounded Context Integrations</h1>
            </header>

            <article>
                
<p>To make things easier, we'll assume Bounded Contexts have a Customer - Supplier relationship.</p>


            </article>

            <footer style="margin-top: 5em;">
                
            </footer>

        </section>
    

        <section>

            <header>
                <h1 class="header-title">Modern RPC</h1>
            </header>

            <article>
                
<p>With modern RPC, we refer to RPC through RESTful resources. A Bounded Context reveals a clear interface to interact with to the outside world. It exposes resources that could be manipulated through HTTP verbs. We could say that the Bounded Context offers a set of services and operations. In strategical terms, this is what is called an <strong>Open Host Service</strong>.</p>
<div class="packt_infobox"><span class="packt_screen">Open Host Service</span><br/>
Define a protocol that gives access to your subsystem as a set of SERVICES. Open the protocol so that all who need to integrate with you can use it. Enhance and expand the protocol to handle new integration requirements, except when a single team has idiosyncratic needs. Then, use a one-off translator to augment the protocol for that special case so that the shared protocol can stay simple and coherent. Eric Evans - <em>Domain-Driven Design:</em> <a href="https://www.amazon.com/Domain-Driven-Design-Tackling-Complexity-Software/dp/0321125215">Tackling Complexity in the Heart of Software</a><em>.</em></div>
<p>Let's explore an example provided within the <a href="https://github.com/dddinphp/last-wishes">Last Wishes application</a> that comes with this book's GitHub organization.</p>
<p>The application is a web platform with the purpose of letting people save their last wills before they die. There are two Contexts: one responsible for handling wills—the Will Bounded Context—and one in charge of giving points to the users of the system—the <a href="https://github.com/dddinphp/last-wishes-gamify">Gamification Context</a>. In the Will Context, the user could have badges related to the number of points the user made on the Gamification Context. This means that we need to integrate both Contexts together in order to show the badges a user has on the Will Context.</p>
<p>The Gamification Context is a full-fledged event-driven application powered by a custom event sourcing engine. It's a full-stack Symfony application that uses <a href="http://symfony.com/doc/current/bundles/FOSRestBundle/index.html">FOSRestBundle</a>, <a href="https://github.com/willdurand/BazingaHateoasBundle">BazingaHateoasBundle</a>, <a href="https://github.com/schmittjoh/JMSSerializerBundle">JMSSerializerBundle</a>, <a href="https://github.com/schmittjoh/JMSSerializerBundle">NelmioApiDocBundle</a>, and <a href="https://github.com/schmittjoh/JMSSerializerBundle">OngrElasticsearchBundle</a> to provide a level 3 and up REST API (commonly known as the Glory of REST), according to the <a href="https://martinfowler.com/articles/richardsonMaturityModel.html">Richardson Maturity <em>Mo</em>del</a>. All the Events triggered within this Context are projected against an Elasticsearch server, in order to produce the data needed for the views. We'll expose the number of points made for a given user through an endpoint like <kbd>http://gamification.context.host/api/users/{id}</kbd>.</p>
<p>We'll also fetch the user projection from Elasticsearch and serialize it to a format previously negotiated with the client:</p>
<pre>
namespace AppBundle\Controller;<br/><br/>use FOS\RestBundle\Controller\Annotations as Rest;<br/>use FOS\RestBundle\Controller\FOSRestController;<br/>use Nelmio\ApiDocBundle\Annotation\ApiDoc;<br/><br/>class UsersController extends FOSRestController<br/>{<br/>    /**<br/>     * @ApiDoc(<br/>     *     resource = true,<br/>     *     description = "Finds a user given a user ID",<br/>     *     statusCodes = {<br/>     *         200 = "Returned when the user have been found",<br/>     *         404 = "Returned when the user could not be found"<br/>     *     }<br/>     * )<br/>     *<br/>     * @Rest\View(<br/>     *     statusCode = 200<br/>     * )<br/>     */<br/>    public function getUserAction($id)<br/>    {<br/>        $repo = $this-&gt;get('es.manager.default.user');<br/>        $user = $repo-&gt;find($id);<br/><br/>        if (!$user) {<br/>            throw $this-&gt;createNotFoundException(<br/>                sprintf(<br/>                    'A user with an ID of %s does not exist',<br/>                    $id<br/>                )<br/>            );<br/>        }<br/>        return $user;<br/>    }<br/>}
</pre>
<p>As we explained in the <a href="d29cc2f8-a8a4-4c83-9322-3f346397de30.xhtml">Chapter 2</a>, <em>Architectural Styles</em> reads are treated as an Infrastructure concern, so there's no need to wrap them inside a Command / Command Handler flow.</p>
<p>The resulting JSON+HAL representation of a user will be like this:</p>
<pre>
{<br/>    "id": "c3c587c6-610a-42df",<br/>    "points": 0,<br/>    "_links": {<br/>        "self": {<br/>            "href":<br/>            "http://gamification.ctx/api/users/c3c587c6-610a-42df"<br/>        }<br/>    }<br/>}
</pre>
<p>Now we're in a good position to integrate both Contexts. We just need to write the client in the Will Context for consuming the endpoint we've just created. Should we mix both Domain Models? Digesting the Gamification Context directly will mean adapting the Will Context to the Gamification one, resulting in a <strong>Conformist</strong> integration. However, separating these concerns seems worth the effort. We need a layer for guaranteeing the integrity and the consistency of the Domain Model within the Will Context, and we need to translate <em>points</em> (Gamification) to <em>badges</em> (Will). In Domain-Driven Design, this translation mechanism is what's called an <strong>Anti-Corruption layer</strong>.</p>
<div class="packt_infobox"><span class="packt_screen">Anti-Corruption Layer</span><br/>
Create an isolating layer to provide clients with functionality in terms of their own domain model. The layer talks to the other system through its existing interface, requiring little or no modification to the other system. Internally, the layer translates in both directions as necessary between the two models. Eric Evans - <em>Domain-Driven Design:</em> <a href="https://www.amazon.com/Domain-Driven-Design-Tackling-Complexity-Software/dp/0321125215">Tackling Complexity in the Heart of Software.</a></div>
<p>So, what does the Anti-Corruption layer look like? Most of the time, Services will be interacting with a combination of Adapters and Facades. The Services encapsulate and hide the low-level complexities behind these transformations. Facades aid in hiding and encapsulating access details required for fetching data from the Gamification model. Adapters translate between models, often using specialized Translators.</p>
<p>Let's see how to define a User Service within the Will's model that will be responsible for retrieving the badges earned by a given user:</p>
<pre>
<span>namespace Lw\Domain\Model\User;<br/><br/>interface UserService<br/>{<br/>    public function badgesFrom(UserId $id);<br/>}<br/></span>
</pre>
<p>Now let's look at the implementation on the Infrastructure side. We'll use an adapter for the transformation process:</p>
<pre>
namespace Lw\Infrastructure\Service;<br/><br/>use Lw\Domain\Model\User\UserId;<br/>use Lw\Domain\Model\User\UserService;<br/><br/>class TranslatingUserService implements UserService<br/>{<br/>    private $userAdapter;<br/><br/>    public function __construct(UserAdapter $userAdapter)<br/>    {<br/>        $this-&gt;userAdapter = $userAdapter;<br/>    }<br/><br/>    public function badgesFrom(UserId $id)<br/>    {<br/>        return $this-&gt;userAdapter-&gt;toBadges($id);<br/>    }<br/>}
</pre>
<p>And here's the HTTP implementation for the <kbd>UserAdapter</kbd>:</p>
<pre>
namespace Lw\Infrastructure\Service;<br/><br/>use GuzzleHttp\Client;<br/><br/>class HttpUserAdapter implements UserAdapter<br/>{<br/>    private $client;<br/><br/>    public function __construct(Client $client)<br/>    {<br/>        $this-&gt;client = $client;<br/>    }<br/><br/>    public function toBadges( $id)<br/>    {<br/>        $response = $this-&gt;client-&gt;get(<br/>            sprintf('/users/%s', $id),<br/>            [<br/>                'allow_redirects' =&gt; true,<br/>                'headers' =&gt; [<br/>                    'Accept' =&gt; 'application/hal+json'<br/>                ]<br/>            ]<br/>        );<br/><br/>        $badges = [];<br/>        if (200 === $response-&gt;getStatusCode()) {<br/>            $badges = <br/>                (new UserTranslator())<br/>                    -&gt;toBadgesFromRepresentation(<br/>                        json_decode(<br/>                            $response-&gt;getBody(),<br/>                            true<br/>                        )<br/>                    );<br/>        }<br/>        return $badges;<br/>    }<br/>}
</pre>
<p>As you can see, the Adapter acts as a <strong>Facade to the Gamification Context</strong> too. We did it this way, as fetching the User resource on the Gamification side is pretty straightforward. The Adapter uses the <kbd>UserTranslator</kbd> to perform the translation:</p>
<pre>
namespace Lw\Infrastructure\Service;<br/><br/>use Lw\Infrastructure\Domain\Model\User\FirstWillMadeBadge;<br/>use Symfony\Component\PropertyAccess\PropertyAccess;<br/><br/>class UserTranslator<br/>{<br/>    public function toBadgesFromRepresentation($representation)<br/>    {<br/>        $accessor = PropertyAccess::createPropertyAccessor();<br/>        $points = $accessor-&gt;getValue($representation, 'points');<br/>        $badges = [];<br/>        if ($points &gt; 3) {<br/>            $badges[] = new FirstWillMadeBadge();<br/>        }<br/>        return $badges;<br/>    }<br/>}
</pre>
<p>The Translator specializes in transforming the points coming from the Gamification Context into badges.</p>
<p>We've shown how to integrate two Bounded Contexts where respective teams share a <strong>Customer-Supplier</strong> relationship. The Gamification Context exposes the integration through an <strong>Open Host Service</strong> implemented by a RESTful protocol. On the other side, the Will Context consumes the service through an <strong>Anti-Corruption layer</strong> responsible for translating the model from one Domain to the other, ensuring the Will Context's integrity.</p>


            </article>

            <footer style="margin-top: 5em;">
                
            </footer>

        </section>
    

        <section>

            <header>
                <h1 class="header-title">Message Queues</h1>
            </header>

            <article>
                
<p>RESTful resources aren't the only way of enabling integrations between Bounded Contexts. As we'll see, messaging middleware enables decoupled integrations between different Contexts.</p>
<p>Continuing with the Last Wishes application, we've just implemented a unidirectional relationship between two teams to manage points and badges within their respective Contexts. However, we left an important functionality out of scope on purpose: <strong>rewarding the user every time they make a wish</strong>.</p>
<p>We could go for another Open Host Service with a pull strategy. The Will Context will be pulling the Gamification Context periodically to get badges on sync (Example: through an scheduler like Cron). This solution will impact the user's experience, and it'll waste a lot of unnecessary resources.</p>
<p>A better approach is to use a <strong>messaging middleware</strong>. With this solution, Contexts could push messages to a middleware (often a message queue). Interested parties will be able to subscribe, inspect, and consume information on demand in a decoupled fashion. In order to do this, we need a <strong>specialized, shared, and common communication language</strong>, so all the parties can understand the information transmitted. This is what's called the <strong>Published Language</strong>.</p>
<div class="packt_infobox"><span class="packt_screen">Published Language</span><br/>
Use a well-documented shared language that can express the necessary domain information as a common medium of communication, translating as necessary into and out of that language.  Eric Evans - <em>Domain-Driven Design:</em> <a href="https://www.amazon.com/Domain-Driven-Design-Tackling-Complexity-Software/dp/0321125215">Tackling Complexity in the Heart of Software</a>.</div>
<p>In thinking about the format of these messages and looking closer at our Domain Model, we realize we already have what we need: <a href="607255c5-e619-4398-94bb-484c008472b7.xhtml">Chapter 6</a>, <em>Domain-Events</em>. It's not necessary to define a new way of communicating between Bounded Contexts. Instead, we can just use Domain Events to define a common language across Contexts. The definition of <em>something that Domain Experts care about that just happened</em> fits perfectly with what we're looking for: a formal Published Language.</p>
<p>In our example, we could use RabbitMQ as a messaging middleware. This is probably one of the most reliable and robust messaging <a href="https://www.amqp.org/">AMQP</a> protocols out there. We'll also incorporate the widely used PHP libraries <a href="https://github.com/php-amqplib/php-amqplib">php-amqplib</a> and <a href="https://github.com/php-amqplib/RabbitMqBundle">RabbitMQBundle</a>.</p>
<p>Let's start with the Will Context, as it's the one that triggers Events when the user signs up or when making a wish. As we've already seen in the <a href="607255c5-e619-4398-94bb-484c008472b7.xhtml">Chapter 6</a>, <em>Domain-Events</em>, <strong>it's a good idea to store Domain Events into a persistent mechanism</strong>, so we'll assume that's what was done. We need a message publisher to fetch and publish stored Domain Events from the Event store to the messaging middleware. We already did the integration with RabbitMQ in the <a href="607255c5-e619-4398-94bb-484c008472b7.xhtml">Chapter 6</a>, <em>Domain-Events</em>, so we just need to implement the code in the Gamification Context. We'll listen for Events triggered by the Will Context. As we're using the Symfony Framework, we take advantage of a Symfony package called RabbitMQBundle.</p>
<p>We define two message consumers for the <em>User Registered</em> and <em>Wish Was Made</em> events:</p>
<pre>
namespace AppBundle\Infrastructure\Messaging\PhpAmqpLib;<br/><br/>use Lw\Gamification\Command\SignupCommand;<br/>use OldSound\RabbitMqBundle\RabbitMq\ConsumerInterface;<br/>use PhpAmqpLib\Message\AMQPMessage;<br/><br/>class PhpAmqpLibLastWillUserRegisteredConsumer<br/>    implements ConsumerInterface<br/>{<br/>    private $commandBus;<br/><br/>    public function __construct($commandBus)<br/>    {<br/>        $this-&gt;commandBus = $commandBus;<br/>    }<br/><br/>    public function execute(AMQPMessage $message)<br/>    {<br/>        $type = $message-&gt;get('type');<br/><br/>        if('Lw\Domain\Model\User\UserRegistered' === $type) {<br/>            $event = json_decode($message-&gt;body);<br/>            $eventBody = json_decode($event-&gt;event_body);<br/><br/>            $this-&gt;commandBus-&gt;handle(<br/>                new SignupCommand($eventBody-&gt;user_id-&gt;id)<br/>            );<br/>            return true;<br/>        }<br/>        return false;<br/>    }<br/>}
</pre>
<p>Note that in this case, we're only processing messages with the type of <kbd>Lw\Domain\Model\User\UserRegistered</kbd>:</p>
<pre>
namespace AppBundle\Infrastructure\Messaging\PhpAmqpLib;<br/><br/>use Lw\Gamification\Command\RewardUserCommand;<br/>use Lw\Gamification\Domain\Model\AggregateDoesNotExist; <br/>use OldSound\RabbitMqBundle\RabbitMq\ConsumerInterface;<br/>use PhpAmqpLib\Message\AMQPMessage;<br/><br/>class PhpAmqpLibLastWillWishWasMadeConsumer implements ConsumerInterface<br/>{<br/>    private $commandBus;<br/><br/>    public function __construct($commandBus)<br/>    {<br/>        $this-&gt;commandBus = $commandBus;<br/>    }<br/><br/>    public function execute(AMQPMessage $message)<br/>    {<br/>        $type = $message-&gt;get('type');<br/><br/>        if ('Lw\Domain\Model\Wish\WishWasMade' === $type) {<br/>            $event = json_decode($message-&gt;body);<br/>            $eventBody = json_decode($event-&gt;event_body);<br/><br/>            try {<br/>                $points = 5;<br/>                $this-&gt;commandBus-&gt;handle(<br/>                    new RewardUserCommand(<br/>                        $eventBody-&gt;user_id-&gt;id,<br/>                        $points<br/>                    )<br/>                );<br/>            } catch (AggregateDoesNotExist $e) {<br/>                // Noop<br/>            }<br/><br/>            return true;<br/>        }<br/><br/>        return false;<br/>    }<br/>}
</pre>
<p>Again, we're only interested in tracking <kbd>Lw\Domain\Model\Wish\WishWasMade events</kbd>.</p>
<p>In both cases, we use a Command Bus, which we discussed in the Chapter, Application. However, we can summarize it as a highway that decouples the Command and Receiver. The <strong>when</strong> and <strong>how</strong> a Command is executed is independent from <strong>who</strong> triggered it.</p>
<p>The Gamification Context uses <a href="http://tactician.thephpleague.com/">Tactician</a> (and <a href="https://github.com/thephpleague/tactician-bundle">TacticianBundle</a>), a simple Command Bus that can be extended and adapted to your system. So now we're almost ready to start consuming Events from the Will Context.</p>
<p>The only thing we still need to do is define the RabbitMQBundle configuration in Symfony's <kbd>config.yml</kbd> file:</p>
<pre>
services:<br/>    last_will_user_registered_consumer:<br/>        class:<br/>            AppBundle\Infrastructure\Messaging\<br/>                PhpAmqpLib\PhpAmqpLibLastWillUserRegisteredConsumer<br/>        arguments:<br/>            - @tactician.commandbus<br/><br/>    last_will_wish_was_made_consumer:<br/>        class:<br/>            AppBundle\Infrastructure\Messaging\<br/>                PhpAmqpLib\PhpAmqpLibLastWillWishWasMadeConsumer<br/>        arguments:<br/>            - @tactician.commandbus<br/><br/>old_sound_rabbit_mq:<br/>    connections:<br/>         default:<br/>              host: " %rabbitmq_host%"<br/>              port: " %rabbitmq_port%"<br/>              user: " %rabbitmq_user%"<br/>              password: " %rabbitmq_password%"<br/>              vhost: " %rabbitmq_vhost%"<br/>              lazy: true<br/><br/>    consumers:<br/>        last_will_user_registered:<br/>            connection: default<br/>            callback: last_will_user_registered_consumer<br/><br/>            exchange_options:<br/>                name: last-will<br/>                type: fanout<br/><br/>            queue_options:<br/>                name: last-will<br/><br/>        last_will_wish_was_made:<br/>            connection: default<br/>            callback: last_will_wish_was_made_consumer<br/><br/>            exchange_options:<br/>                name: last-will<br/>                type: fanout<br/><br/>            queue_options:<br/>                name: last-wil
</pre>
<p>The most convenient RabbitMQ configuration is probably the [<a href="https://www.rabbitmq.com/tutorials/tutorial-three-php.html">Publish / Subscribe</a>] pattern. All messages published by the Will Context will be delivered to all connected consumers. This is called <strong>fanout</strong> in the RabbitMQ exchange configuration.</p>
<p>The exchange consists of an agent being in charge of delivering messages to the corresponding queues:</p>
<pre>
&gt; php app/console rabbitmq:consumer --messages=1000 last_will_user_registered<br/>&gt; php app/console rabbitmq:consumer --messages=1000 last_will_wish_was_made
</pre>
<p>With those two commands, Symfony will execute both consumers and they'll start listening for Domain Events. We've specified a limit of 1,000 messages to consume, as PHP isn't the best platform for executing long-running processes. It also might be a good idea to use something like <a href="http://supervisord.org/">Supervisor</a> to monitor and restart processes periodically.</p>


            </article>

            <footer style="margin-top: 5em;">
                
            </footer>

        </section>
    

        <section>

            <header>
                <h1 class="header-title">Wrap-Up</h1>
            </header>

            <article>
                
<p>Although we've only seen a small part of it, strategical design is at the heart and soul of Domain-Driven Design. It's an essential part that aids in developing better and more semantic models. We recommend using messaging middleware to integrate Bounded Contexts, as this naturally leads to simpler, decoupled, and Event-driven architectures.</p>


            </article>

            <footer style="margin-top: 5em;">
                
            </footer>

        </section>
    </body></html>