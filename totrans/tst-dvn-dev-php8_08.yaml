- en: '8'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Using TDD with SOLID Principles
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When I first started programming, I instantly got addicted to it. I felt so
    excited about the thought of coming up with a solution to a problem using programs
    and my own imagination. Back in school, there was a time when the instructor gave
    us the task of solving some simple algebraic challenges using Turbo-C. I had goosebumps
    and felt very excited as I quickly realized I could just write programs to solve
    these types of challenges repeatedly. Write the program once, pass different arguments,
    and get different results. I loved it. I remember a challenge to compute the height
    of a bridge if someone is standing on it, drops a ball, and hears a sound after
    several seconds. Easy! Now, I can just use my program to compute the height of
    the bridge for me repeatedly. Now, I don’t have to keep remembering that the Earth’s
    gravitational acceleration is at around 9.8 m/s2 – I can just declare it in the
    program! I learned that in programming, I can follow my own rules to get from
    point A to point B. Give me a task, and I can come up with a solution using my
    own imagination to finish the task. This, for me, is the best thing about programming.
    I was one proud spaghetti-code-writing machine. I didn’t care about how clean
    my code was – I just needed to solve problems using code! Learning about other
    programming languages made me even more excited, and I thought the possibilities
    were endless – if the task or challenge did not defy the laws of physics, I thought
    it could be solved using programming! I did not pay attention to code cleanliness
    or maintainability. What are those? I don’t need those!
  prefs: []
  type: TYPE_NORMAL
- en: When I started working professionally as a software developer, I continued with
    my mindset of just enjoying solving problems using programming. I didn’t care
    how disorganized my solutions were – they solved the problems, and my employers
    and clients were happy. Done, I’m out of here. Too easy. I thought I knew everything
    and that I was unstoppable. Oh boy, I was so wrong. The more I learned, the more
    I realized how little I knew how to program.
  prefs: []
  type: TYPE_NORMAL
- en: As I continued working on more complex projects with other developers while
    having to maintain these projects, I learned the hard way how difficult I had
    made my life by writing code I couldn’t easily maintain myself. I’m probably not
    the only developer on the planet to have experienced this problem. I was sure
    other people had encountered these issues before, and I was sure there were solutions
    out there. One of the solutions that helped make my life a lot easier was by trying
    to follow the **SOLID** principles by *Robert C. Martin*. They really helped change
    my programming life, and using these principles with **Test-Driven Development**
    (**TDD**) made my programming life even easier! There are more principles and
    architectural design patterns out there to help make your application more maintainable,
    but in this chapter, we will be focusing on the SOLID principles one by one while
    doing TDD.
  prefs: []
  type: TYPE_NORMAL
- en: We’ll go through the process of interpreting a Jira ticket into a BDD test,
    which, in turn, will help us in creating our integration tests, down to the development
    of the solution code. Then, one by one, we will go through each of the SOLID principles
    by using TDD as you would do in a real project.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will go through the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Jira to BDD to TDD
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: TDD with the Single-Responsibility Principle
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: TDD with the Open-Closed Principle
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: TDD with the Liskov Substitution Principle
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: TDD with the Interface Segregation Principle
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: TDD with the Dependency Inversion Principle
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, the reader needs to use the base code from the repository found
    at [https://github.com/PacktPublishing/Test-Driven-Development-with-PHP-8/tree/main/Chapter%208](https://github.com/PacktPublishing/Test-Driven-Development-with-PHP-8/tree/main/Chapter%208).
  prefs: []
  type: TYPE_NORMAL
- en: Preparing the development environment for the chapter
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'First, get the base code for this chapter found at https://github.com/PacktPublishing/Test-Driven-Development-with-PHP-8/tree/main/Chapter%206/base/phptdd
    or simply run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: To run the containers and execute the commands in this chapter, you should be
    inside the `docker-server-web-1` container.
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the following command to confirm the container name for our web server:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'To run the containers, run the following command from the `/docker` directory
    from the repository in your host machine:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Once inside the container, run the following commands to install the libraries
    required through `composer`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Jira to BDD to TDD
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The SOLID principles, as defined by Robert C. Martin, are a set of coding guidelines
    or standards that help developers write more organized, decoupled, maintainable,
    extensible software. In this chapter, we’ll go through them one by one, but we
    will try to simulate the process by working on a real project and then implementing
    each of the principles.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will be writing solution code that will try to adhere to
    the SOLID principles, but before that, we need an example problem to solve. As
    we did in [*Chapter 7*](B18318_07.xhtml#_idTextAnchor108)*, Building Solution
    Code with BDD and TDD*, we’ll start with a Jira ticket, write some Gherkin features,
    write Behat tests, write integration and unit tests, and then write the SOLID-adhering
    solution code as depicted in the following flowchart:'
  prefs: []
  type: TYPE_NORMAL
- en: "![Figure 8.1 \uFEFF– Development flow](img/Figure_8.01_B18318.jpg)"
  prefs: []
  type: TYPE_IMG
- en: Figure 8.1 – Development flow
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s use one of the Jira tickets we created in [*Chapter 2*](B18318_02.xhtml#_idTextAnchor027),
    *Understanding and Organizing the Business Requirements for Our Project*. We created
    a story to let a logged-in user input and save some toy car model data. This will
    be a nice simple feature to use to demonstrate the SOLID principles:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.2 – Ticket for creating toy model data](img/Figure_8.02_B18318.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8.2 – Ticket for creating toy model data
  prefs: []
  type: TYPE_NORMAL
- en: As we did in [*Chapter 7*](B18318_07.xhtml#_idTextAnchor108), *Building Solution
    Code with BDD and TDD*, create a new git branch for your Jira ticket. Check out
    the git branch from the repository you set up in [*Chapter 2*](B18318_02.xhtml#_idTextAnchor027),
    *Understanding and Organizing the Business Requirements for Our Project*, and
    let’s start writing some tests and programs!
  prefs: []
  type: TYPE_NORMAL
- en: Before we start learning about the SOLID principles, first, we need to work
    on the BDD tests that will drive us to write the solution code while trying to
    follow the SOLID principles. Remember, we always need to start with failing tests.
    Next, to start with BDD, we need to write a Gherkin feature first.
  prefs: []
  type: TYPE_NORMAL
- en: Gherkin feature
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let’s start by writing a Gherkin feature to describe what behavior we expect
    to build. Create the following feature file with the following content inside
    the `behat` directory:'
  prefs: []
  type: TYPE_NORMAL
- en: codebase/behat/features/create_toy_car_record.feature
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Now that we have our feature, let’s generate the Behat PHP context class for
    it.
  prefs: []
  type: TYPE_NORMAL
- en: Behat context
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We will now take the Gherkin feature and make a PHP context class for it. Follow
    these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, update the `behat.yml` file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: codebase/behat/behat.yml
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'After updating the main `behat.yml` file, run the following commands to create
    the PHP context class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: There should now be a new class created in `features/bootstrap/CreateToyCarRecordContext.php`.
    Refactor the `iAmInTheInventorySystemPage` method so that it throws `\Exception`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Next, let’s make sure we can execute this feature test by running the following
    command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'You should then see the following test result:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.3 – Failed test](img/Figure_8.03_B18318.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8.3 – Failed test
  prefs: []
  type: TYPE_NORMAL
- en: Good – now, we know that the Behat test for this feature can be executed and
    fails as expected, so let’s move on to the Symfony application.
  prefs: []
  type: TYPE_NORMAL
- en: Functional test
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The Behat test we created is already a functional test – do we still have to
    create a functional test inside the Symfony directory? I think this is optional,
    but it will help us to quickly run basic smoke tests – for example, if we want
    to quickly check whether our controller loads and doesn’t encounter a fatal error.
    We don’t need to run the bigger and slower Behat test to find that out:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create the following test class with the following content:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: codebase/symfony/tests/Functional/Controller/InventoryAdminControllerTest.php
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'After creating our controller test class, let’s run the following command to
    make sure that PHPUnit can execute this test and that it fails:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: After running the test, make sure that you get a test failure. Remember the
    red phase?
  prefs: []
  type: TYPE_NORMAL
- en: Great – we can forget about creating the controller for now. Let’s move on to
    the integration tests. These tests will be used to develop the mechanism to persist
    the toy car model in the database.
  prefs: []
  type: TYPE_NORMAL
- en: Integration test
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We will now need to start writing integration tests that will help us write
    the code to persist or create a new toy car model. After passing these tests,
    then we can go back to the Behat tests we created earlier and make sure they pass:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create the following test class, with the following content:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: codebase/symfony/tests/Integration/Processor/ToyCarProcessorTest.php
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'After creating the test class, make sure that PHPUnit can recognize the new
    test class by running the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'After running the command, you should see the familiar and soothing PHPUnit
    failure result:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 8.4 – Failing processor test](img/Figure_8.04_B18318.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8.4 – Failing processor test
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have a failing integration test, let’s build the code to pass it.
    We want to be able to persist a new toy car model into the persistence layer which
    is our database. Do we even have a DB table for it? Nope, not yet. But we don’t
    care. We can continue working on the solution code. Next, we will be trying to
    follow the **Single-Responsibility Principle** (**SRP**) to write our solution
    code.
  prefs: []
  type: TYPE_NORMAL
- en: TDD with the Single-Responsibility Principle
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let’s start with what I think is one of the most important principles in the
    SOLID principles. Are you familiar with god classes or objects – where one class
    can do almost everything? A single class for login, registration, displaying registered
    users, and so on? If there are two developers working on the same god class, can
    you already imagine how challenging that can be? And what happens after you deploy
    it to production and then an issue is found in the part where you display a list
    of registered users? You will have to change or fix that god class, but now the
    same class for login and registration has been modified and these processes may
    be compromised too. You run a bigger risk of introducing regressions to your login
    and registration functionalities by just trying to fix the list of registered
    users. You fix one feature, and there’s a greater risk of breaking other features.
  prefs: []
  type: TYPE_NORMAL
- en: This is where the SRP will start to make sense. The SRP mandates that a class
    should only have one main responsibility, and one reason to be changed. Is it
    that simple? Sometimes not. A `Login` class should only know about letting a user
    log in, and not have the program responsible for displaying a list of registered
    users or checking out a shopping cart, but sometimes where to draw the line can
    become very subjective.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we’ll start writing the actual solution code while trying to implement
    the SRP.
  prefs: []
  type: TYPE_NORMAL
- en: Writing the solution code
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We have a failing test that tests whether our application can create a toy car
    model and persist it in the database, but we don’t even have a database table
    for it yet. It’s okay – we will only focus on the PHP side of things for now.
  prefs: []
  type: TYPE_NORMAL
- en: Model class
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'It’s better for our processor PHP class to deal with objects and not to directly
    know about database table rows and so on. Let’s create a **Plain Old PHP Object**
    (**POPO**) that will represent what a toy car model is, without caring about the
    database structure:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create the following file with the following content:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: codebase/symfony/src/Model/ToyCar.php
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: After declaring the properties, it’s best to generate the accessors and mutators
    for all of these properties, rather than accessing them directly.
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, this is just a POPO class. Nothing fancy. No information whatsoever
    about how to persist it in our database. Its responsibility is just to be a model
    that represents what a toy car is.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s also create the `CarManufacturer` and `ToyColor` models. Create the following
    classes with the following content:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: codebase/symfony/src/Model/ToyColor.php
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: After declaring the properties, generate the accessors and mutators for the
    class.
  prefs: []
  type: TYPE_NORMAL
- en: 'See the following for the car manufacturer:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: codebase/symfony/src/Model/CarManufacturer.php
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Now, generate the accessors and mutators for this class as well.
  prefs: []
  type: TYPE_NORMAL
- en: Now, we have the main `ToyCar` model, which is also using the `ToyColor` and
    `CarManufacturer` models. As you can see, as with the `ToyCar` model, these two
    classes are not responsible for persisting or reading data either.
  prefs: []
  type: TYPE_NORMAL
- en: As you remember, we are using the Doctrine ORM as a tool to interact with our
    database. We can also use Doctrine entities directly in our processor class if
    we want to, but that would mean that our processor class would now be using a
    class that has a dependency on Doctrine. What if we need to use a different ORM?
    To keep things a little bit less coupled, we will just use `codebase/symfony/src/Model/ToyCar.php`
    in the processor class we will be creating next.
  prefs: []
  type: TYPE_NORMAL
- en: Processor class
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'For us to create and persist a toy car model, we will need a class that will
    need to process it for us. The thing is, we still don’t have a database at this
    stage – where do we persist the toy car model? For now, nowhere, but we can still
    pass the test:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create the following interface with the following content:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: codebase/symfony/src/DAL/Writer/WriterInterface.php
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: We created a very simple interface that our data-writer objects can implement.
    We’ll then use this interface for our processor class.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let’s create the toy car workflow or processor class. Create the following
    class with the following content:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: codebase/symfony/src/Processor/ToyCarProcessor.php
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: We have created a processor class that has a `create` method that accepts the
    toy car model we created previously, and then tries to write the model using an
    instance of a writer class that doesn’t exist. What if another developer in your
    company is working on the data-writer class and it will take him 2 weeks to complete
    it? Do you wait for 2 weeks to pass your integration test?
  prefs: []
  type: TYPE_NORMAL
- en: If your processor class must validate the data and do other things after the
    data has been written into the database, should those programs be delayed too
    just because you are waiting for the other developer to complete their work? Probably
    not! We can use test doubles to replace the missing dependencies for now.
  prefs: []
  type: TYPE_NORMAL
- en: Test doubles
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Most of the time, it’s just difficult or impractical to be able to run a test
    against a feature with all its dependencies already built. Sometimes, we need
    to have a solution to be able to test the specific feature we want, even if we
    have not built the other dependencies yet, or simply want to isolate or only focus
    our test on a certain feature. Here, we can use test doubles. You can read more
    about test doubles for PHPUnit at [https://phpunit.readthedocs.io/en/9.5/test-doubles.html](https://phpunit.readthedocs.io/en/9.5/test-doubles.html).
  prefs: []
  type: TYPE_NORMAL
- en: Mock and Stub
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The processor class we just created needs a concrete instance of `ToyValidatorInterface`
    and `WriterInterface`. Since we have not created those classes yet, we can still
    proceed in passing the test just by using a `Mock` object. In PHPUnit, the `Mock`
    object is an interface that extends the `Stub` interface. This means that in the
    code, a `Mock` object is an implementation of a `Stub` interface. The process
    of replacing the instances of `ToyValidatorInterface` and `WriterInterface` with
    a `Mock` object and setting a `return` value when a specific method is executed
    is called stubbing. Let’s try it for real:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Go back to the `ToyCarProcessorTest` class and refactor it with the following
    content:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: codebase/symfony/tests/Integration/Processor/ToyCarProcessorTest.php
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'In the `testCanCreate` function here, we are creating mock objects for the
    `ValidationModel`, `ToyCarValidator`, and `ToyCarWriter` classes. We then instantiate
    the main `ToyCarCreator` class while passing the mock `ToyCarValidator` and `ToyCarWriter`
    classes into its constructor. This is called dependency injection, which will
    be discussed further later in the chapter. Lastly, we then run the `ToyCarCreator`’s
    `create` method to simulate a developer trying to create a new toy car record:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s run the test by entering the following command and see what result we
    get:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'You should then see the following result:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.5 – Passed the test using a stub](img/Figure_8.05_B18318.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8.5 – Passed the test using a stub
  prefs: []
  type: TYPE_NORMAL
- en: We passed the test, even though we have not really persisted anything in the
    database yet. It’s very common in bigger and more complex projects that you’ll
    have to rely on test doubles just to isolate and focus on your test even if other
    dependencies are either not built yet or are too cumbersome to include as a part
    of your test.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now going back to the SRP, our `ToyCarProcessor` now has two responsibilities
    – to validate and create a toy car model. Equally, other developers are using
    your class’s `validate` method. Let’s refactor our code to redefine the focus
    and responsibility of our `ToyCarProcessor` class:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Rename the following classes:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`ToyCarProcessor.php` to `ToyCarCreator.php`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ToyCarProcessorTest.php` to `ToyCarCreatorTest.php`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Next, let’s refactor the `ToyCarCreatorTest.php` class. Open the following
    class and replace the content with the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: codebase/symfony/tests/Integration/Processor/ToyCarCreatorTest.php
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, we added a new `Mock` object for the validation. I will explain
    why we must do that after we refactor the content of the `ToyCarCreator.php` class.
    Let’s create a validator interface, and then refactor the `ToyCarCreator` class.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create the following file with the following content:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: codebase/symfony/src/Validator/ValidatorInterface.php
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Open `codebase/symfony/src/Processor/ToyCarCreator.php` and use the following
    content:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE27]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE28]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE29]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE30]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE31]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE32]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE33]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE34]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE35]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE36]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE37]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE38]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE39]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE40]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE41]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE42]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE43]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE44]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE45]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE46]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE47]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE48]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE49]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE50]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE51]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE52]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE53]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE54]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE55]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE56]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE57]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Next, add the necessary accessors and mutators for the private properties we
    have declared in the class.
  prefs: []
  type: TYPE_NORMAL
- en: We renamed the class just to give it a more specific name. Sometimes, just naming
    the class to something else helps you clean up your code. Also, you will notice
    that we have removed the publicly visible `validate` class. This class will no
    longer contain any validation logic – it only knows that it will run a validation
    routine before it tries to persist the data. This is the class’s main responsibility.
  prefs: []
  type: TYPE_NORMAL
- en: 'We still have not written any validation and data persistence code, but let’s
    see whether we can still pass the test to test the main responsibility of the
    class, which is to do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Accept a `ToyCar` model object.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Run a validation routine.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Attempt to persist the data.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Return the result.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Run the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, you should see the following result:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.6 – Passing the test using two stubs](img/Figure_8.06_B18318.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8.6 – Passing the test using two stubs
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we used BDD and TDD to direct us into writing the solution
    code. We have created POPOs with a single responsibility. We have also created
    a `ToyCarCreator` class that does not contain the validation logic, nor the persistence
    mechanism. It knows it needs to do some validation and some persistence, but it
    does not have the concrete implementation of those programs. Each class will have
    its own specialization or a specific job, or a specific single responsibility.
  prefs: []
  type: TYPE_NORMAL
- en: Great – now, we can pass the test again even after refactoring. Next, let’s
    continue writing the solution code by following the O in the SOLID principle,
    which is the **Open-Closed** **Principle** (**OCP**).
  prefs: []
  type: TYPE_NORMAL
- en: TDD with the Open-Closed Principle
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The OCP was first defined by *Bertrand Meyer*, but in this chapter, we will
    follow the later version defined by *Robert C. Martin*, which is also called the
    polymorphic OCP.
  prefs: []
  type: TYPE_NORMAL
- en: The OCP states that objects should be open to extension and closed to modification.
    The aim is that we should be able to modify the behaviour or a feature by extending
    the original code instead of directly refactoring the original code. That’s great
    because that will help us developers and testers be more confident about the ticket
    we’re working on, as we haven’t touched the original code that might be used somewhere
    else – less risk of regression.
  prefs: []
  type: TYPE_NORMAL
- en: 'In our `ToyCarCreateTest` class, we are stubbing a validator object because
    we have not written a concrete validator class yet. There are a lot of different
    ways of implementing validation, but for this example, we’ll try to make it very
    simple. Let’s go back to the code and create a validator:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new test class with the following content:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: codebase/symfony/tests/Unit/Validator/ToyCarValidatorTest.php
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: After creating the test class, as usual, we need to run the test to make sure
    that PHPUnit recognizes your test.
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Make sure that you get an error, as we have not created the validator class
    yet. Remember the red phase? You’ll notice that in the data provider, we have
    set an empty string for the name. We will make the validator class return `false`
    whenever it sees an empty string for the toy car name.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, that we have the failing test, let’s proceed with creating the class to
    pass it. Create a new PHP class with the following content:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: codebase/symfony/src/Validator/ToyCarValidator.php
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: We have created a very simple validation logic where we only check for the toy
    car’s name if it’s not an empty string. Now, let’s run the test again.
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: You should now see a passing test.
  prefs: []
  type: TYPE_NORMAL
- en: 'Okay, so for now, we can make sure that the toy car model’s name should always
    be a string that is not empty – but here’s the thing, what if we want to add more
    validation logic? We will have to keep on modifying the `ToyCarValidator` class.
    That’s not wrong. It’s just that it’s arguably better to follow the OCP so that
    we don’t keep modifying our code – less class modification, less risk of breaking
    things. Let’s refactor our solution code to pass the test again:'
  prefs: []
  type: TYPE_NORMAL
- en: Let’s add some validation logic for the year and retain the toy car name validation
    as well.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Right now, we are in the green phase, moving to the refactor phase. We’ll be
    using polymorphism, which we discussed in [*Chapter 4*](B18318_04.xhtml#_idTextAnchor050),
    *Using Object-Oriented Programming in PHP*, instead of inheritance in this solution.
    Create the following interface with the following content:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: codebase/symfony/src/Validator/ToyCarValidatorInterface.php
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: 'We created a new `ToyCarValidatorInterface` interface that will replace the
    `ToyCarValidator` concrete class. You will notice that the validate method returns
    an object – let’s create that object too:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: codebase/symfony/src/Model/ValidationModel.php
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: After creating the class, generate the accessors and mutators for the properties.
  prefs: []
  type: TYPE_NORMAL
- en: Instead of simply returning `true` or `false` on our validation program, we
    can now return an array containing the field name and validation result for that
    field name as well. Let’s continue coding.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create the following test class with the following content:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: codebase/symfony/tests/Unit/Validator/ToyCarValidatorTest.php
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: 'If you run this test, you will see four failures, as we have four sets of values
    inside the `provideYear` data provider. Run the test by running the following
    command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'If the test fails, that’s good. Let’s proceed with the solution code:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create the following solution class with the following content:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: codebase/symfony/src/Validator/YearValidator.php
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: Now, we have a simple validation class for checking whether a year is acceptable
    for our car. If we want to add more logic here, such as checking for the minimum
    and maximum acceptable value, we can put all that logic here.
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the following command again and see whether the tests pass:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'You should see the following result:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.7 – Simple date validation test](img/Figure_8.07_B18318.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8.7 – Simple date validation test
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have passed the very simple test for the year validator, next,
    let’s move on to the name validator:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create the following test class with the following content:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: codebase/symfony/tests/Unit/Validator/NameValidatorTest.php
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: 'As with the year validator, if you run this test now, you will encounter multiple
    errors, but we have to make sure that it does fail or error out. Run the following
    command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'After running the command, you should see five errors. That’s okay. Let’s build
    the solution code for it now. Create the following class with the following content:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: codebase/symfony/src/Validator/NameValidator.php
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we have a simple logic to validate a name. Let’s run the name validator
    test again, and see whether it passes. Run the following command again:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: You should now see five passing tests.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s summarize what we have added so far. We created two new validation classes,
    and both are working as expected based on our unit tests – but how is this better
    than the first solution we created? How is this relevant to the OCP? Well, first
    we need to tie things together and pass the bigger `ToyCarValidatorTest`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s refactor the `ToyCarValidator` class with the following content:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: codebase/symfony/src/Validator/ToyCarValidator.php
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: Then, generate the accessors and mutators for the `$``validators` property.
  prefs: []
  type: TYPE_NORMAL
- en: 'You will notice that in the constructor, we are instantiating two validator
    classes, and within the validate method, we are using those validator classes.
    Each validator class will then have its own custom logic on how to run the validate
    method. Now, refactor the following test class with the following content:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: codebase/symfony/tests/Unit/Validator/ToyCarValidatorTest.php
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, in this test, we are checking for the validity of the entire toy car model
    object, as well as checking which specific field of the toy car model has passed
    or failed the validation. Let’s see whether the test passes. Run the following
    command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, you should see the following result:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.8 – Passing toy car validation test](img/Figure_8.08_B18318.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8.8 – Passing toy car validation test
  prefs: []
  type: TYPE_NORMAL
- en: You will notice that we passed three assertions. It looks like we are starting
    to get a test with more responsibilities. It’s still better to do one assertion
    per test, just so that we don’t end up having a god test class! For now, we’ll
    move on.
  prefs: []
  type: TYPE_NORMAL
- en: Now, what have we achieved by refactoring? Well, first, we no longer have the
    validation logic for checking the validity of the toy name inside the `ToyCarValidatorTest`
    class. Second, we can now check for the validity of the year. If we want to improve
    the date and name validation logic, we won’t have to do it in the main `ToyCarValidator`
    class – but what if we want to add more validator classes? Such as a `ToyColorValidator`
    class? Well, we can still do that without even touching the main class! We’ll
    refactor `ToyCarValidator` and discuss how to do so later in the chapter in the
    *TDD with the Dependency Inversion* *Principle* section.
  prefs: []
  type: TYPE_NORMAL
- en: But what if we want to change the entire behavior of the `ToyCarValidator.php`
    class we created and change the logic entirely? Well, there’s no need to modify
    it – we can just replace the entire `ToyCarValidator.php` class with a different
    concrete implementation of the `ToyCarValidatorInterface` interface!
  prefs: []
  type: TYPE_NORMAL
- en: Next, we’ll talk about the **Liskov Substitution** **Principle** (**LSP**).
  prefs: []
  type: TYPE_NORMAL
- en: TDD with the Liskov Substitution Principle
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The LSP was introduced by Barbara Liskov. The way that I use it is that an implementation
    of an interface should be replaceable with another implementation of that interface
    without changing the behavior. If you are extending a superclass, the child class
    must be able to substitute the superclass without breaking the behavior.
  prefs: []
  type: TYPE_NORMAL
- en: In this example, let’s try adding a business rule to reject toy car models that
    were built on or before 1950.
  prefs: []
  type: TYPE_NORMAL
- en: 'As usual, let’s start with a test:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Open the `YearValidatorTest.php` class we created earlier and modify the test
    class with the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: codebase/symfony/tests/Unit/Validator/YearValidatorTest.php
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: We added a new test so that we check for `ToyCarTooOldException`. Let’s add
    this exception class as well, but first, let’s run the test.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Run the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now you will see four errors. That’s okay. Now, let’s add the missing exception
    class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: codebase/symfony/src/Validator/ToyCarTooOldException.php
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, it’s just a simple exception class that extends the main PHP
    `\``Exception` class.
  prefs: []
  type: TYPE_NORMAL
- en: If we run the test again, we should now pass the test, as we have told PHPUnit
    that we are expecting exceptions for this test by using the `$``this->expectException()`
    method.
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, we should be able to pass the test – you should see the following result:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.9 – Passing the old car rejection test](img/Figure_8.09_B18318.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8.9 – Passing the old car rejection test
  prefs: []
  type: TYPE_NORMAL
- en: This means that we are correctly throwing the `ToyCarTooOldException` object
    whenever we submit a year that is less than or equal to 1950 – but what will happen
    to our `ToyCarValidatorTest`?
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s modify the test data with a year less than 1950 and see what happens:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Modify the data provider content with the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: codebase/symfony/tests/Unit/Validator/ToyCarValidatorTest.php
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, run the following command and see what happens:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'You will notice that we have failed the test with the following message:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.10 – Failed toy car validation](img/Figure_8.10_B18318.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8.10 – Failed toy car validation
  prefs: []
  type: TYPE_NORMAL
- en: Now, we can see that we have an uncaught exception. Our `ToyCarValidator` program
    is not programmed to handle this exception object. Why is that? Well, the interface
    in this example is the `codebase/symfony/src/Validator/ValidatorInterface.php`
    interface. This interface throws a `ToyCarValidationException` object. The problem
    now is that our implementing class, the `YearValidator.php` class, throws a different
    exception compared to its contract or interface. Therefore, it breaks the behavior.
    To fix this problem, we simply need to throw the correct exception as declared
    in the interface.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s modify the `ToyCarTooOldException` class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: codebase/symfony/src/Validator/ToyCarTooOldException.php
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, we simply replaced the class it extends to `ToyCarValidationException`.
    The `ToyCarValidator.php` class is designed to catch this exception.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let’s run the test by running the following command and see whether it
    really works:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We should now pass the test and see the following result:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.11 – Passing the toy car validator test, with old car validation](img/Figure_8.11_B18318.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8.11 – Passing the toy car validator test, with old car validation
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we are passing the test again, let’s see what is being returned by
    our `ToyCarValidator` program. Remember the shell scripts we wrote back in [*Chapter
    5*](B18318_05.xhtml#_idTextAnchor070), *Unit Testing*? Let’s use one of them.
    Put a breakpoint in `codebase/symfony/tests/Unit/Validator/ToyCarValidatorTest.php`
    at line **23**. Then, run the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Inspect the `$result` variable, and you should see the following content:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 8.12 – Validation model](img/Figure_8.12_B18318.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8.12 – Validation model
  prefs: []
  type: TYPE_NORMAL
- en: You can see that our `ToyCarValidator`’s validate method returns a `ValidationModel`
    object. It gives a summary of the fields we validated for, as well as the exception
    message for the `year` field.
  prefs: []
  type: TYPE_NORMAL
- en: We’ve seen how interfaces can be useful, but sometimes they become too powerful.
    Next, we’ll talk about the **Interface Segregation Principle** (**ISP**) to help
    stop this from happening.
  prefs: []
  type: TYPE_NORMAL
- en: TDD with the Interface Segregation Principle
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Interfaces are very helpful, but sometimes it can be very easy to pollute them
    with capabilities that are not really supposed to be a part of the interface.
    I used to encounter this violation a lot. I was asking myself how I kept on creating
    empty methods with to-do comments, only to find classes a few months or years
    later, still with those to-do comments and the methods still empty.
  prefs: []
  type: TYPE_NORMAL
- en: I used to touch my interfaces first and stuff them with all the methods I thought
    I needed. Then, when I finally wrote the concrete implementations, these concrete
    classes mostly had empty methods in them.
  prefs: []
  type: TYPE_NORMAL
- en: An interface should only have methods that are specific to that interface. If
    there’s a method in there that is not entirely related to that interface, you
    need to segregate it into a different interface.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s see that in action. Again, let’s start with a – you guessed it right
    – test:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Open the `codebase/symfony/tests/Unit/Validator/NameValidatorTest.php` test
    class and add the following content:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE86]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE87]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE88]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE89]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE90]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE91]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE92]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE93]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE94]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE95]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE96]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE97]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE98]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE99]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE100]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE101]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE102]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE103]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE104]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE105]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE106]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We introduced a new function in the test called `validateLength`, which is common
    for strings. We also added a very long name, and we set `false` to be expected
    to be returned in the data provider.
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the following test:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE107]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: You should get an error, as we have not created the new method yet.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, open the `ValidatorInterface.php` interface and add the `validateLength`
    method we are expecting to have in our test:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: codebase/symfony/src/Validator/ValidatorInterface.php
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE108]'
  prefs: []
  type: TYPE_PRE
- en: 'Great – now we have the contract for validating a string’s length. If we go
    back to the `NameValidator.php` class, we’ll get the following error from the
    IDE:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 8.13 – Must implement the method](img/Figure_8.13_B18318.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8.13 – Must implement the method
  prefs: []
  type: TYPE_NORMAL
- en: Obviously, we need to implement the `validateLength` method for the `NameValidator.php`
    class, which is okay, as we want to validate the string length – but what would
    happen if we also wanted to create a validator for the `ToyCar` model’s color?
    The `ToyCar` model’s color property expects a `ToyColor.php` object, not a string!
    Therefore, the solution is to delete the `validateLength` method from `ValidatorInterface`.
    Certain classes will implement `ValidatorInterface` without the need to implement
    this logic. What we can do instead is create a new interface called the `StringValidator`
    interface that can have the `validateLength` method.
  prefs: []
  type: TYPE_NORMAL
- en: 'Refactor the `codebase/symfony/src/Validator/ValidatorInterface.php` interface
    and delete the `validateLength` method we just added, and create the following
    file with the following content:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: codebase/symfony/src/Validator/StringValidatorInterface.php
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE109]'
  prefs: []
  type: TYPE_PRE
- en: At this stage, we have segregated the `validateLength` method into a separate
    interface, removing it from the `ValidatorInterface.php` interface.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, open the `NameValidator.php` class, and refactor it with the following
    content:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: codebase/symfony/src/Validator/NameValidator.php
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE110]'
  prefs: []
  type: TYPE_PRE
- en: 'We have refactored the `NameValidator` class so that it now also checks for
    the name’s length. Let’s run the test and see whether it passes:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE111]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, you should see the following result:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.14 – Passing the string length validation test](img/Figure_8.14_B18318.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8.14 – Passing the string length validation test
  prefs: []
  type: TYPE_NORMAL
- en: What we did is instead of combining different methods into `ValidatorInterface`,
    we segregated them into two different interfaces. Then, we only implement the
    `StringValidator` interface for the validator objects that will need this `validateLength`
    method. That’s basically what the ISP is all about. This is a very basic example,
    but it is very easy to fall victim to these very powerful interfaces if you don’t
    watch out.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we will go back to the `ToyCarValidator` class and see how we can improve
    what we had earlier in the *TDD with the Open-Closed Principle* example, using
    the **Dependency Inversion** **Principle** (**DIP**).
  prefs: []
  type: TYPE_NORMAL
- en: TDD with the Dependency Inversion Principle
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In terms of making a class more testable, the DIP is probably the most important
    principle on the list for me. The DIP suggests that details should depend on abstractions.
    To me, this means that the specifics of a program that does not really belong
    to a class should be abstracted. The DIP allows us as developers to remove a concrete
    implementation of a routine or program and put it in a different object altogether.
    We can then use the DIP to inject the object that we need, whenever we need it.
    We can inject the object that we need in the constructor, passed as an argument
    upon class instantiation, or simply expose a mutator function.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s revisit the `ToyCarValidator` class that we created earlier in this chapter
    to see how we can implement the DIP.
  prefs: []
  type: TYPE_NORMAL
- en: '**How will this look in** **our code?**'
  prefs: []
  type: TYPE_NORMAL
- en: 'Going back to the `ToyCarValidator.php` class, you will notice that in the
    `__constructor` method, we have instantiated two classes:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.15 – Hardcoded dependencies](img/Figure_8.15_B18318.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8.15 – Hardcoded dependencies
  prefs: []
  type: TYPE_NORMAL
- en: 'How can we improve this? Well, this program works – as you have seen, we are
    passing `ToyCarValidatorTest`. The only problem is that our `ToyCarValidator`
    class is now hardcoded to its dependencies – the `YearValidator` and `NameValidator`
    classes. What if we want to replace these classes – or what if we want to add
    more validators? Well, what we can do is remove the dependency from inside of
    the class. Follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Refactor the following test class, and replace the `testCanValidate` method
    with the following content:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: codebase/symfony/tests/Unit/Validator/ToyCarValidatorTest.php
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE112]'
  prefs: []
  type: TYPE_PRE
- en: You will notice that the objects that `ToyCarValidator` depends on are now being
    instantiated outside the `ToyCarValidator` class – and we then set the validators
    using the `setValidators` mutator.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, remove the hardcoded validator instantiations from the `ToyCarValidator`’s
    constructor:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: codebase/symfony/src/Validator/ToyCarValidator.php
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE113]'
  prefs: []
  type: TYPE_PRE
- en: 'We no longer have the hardcoded validator instantiations – now, let’s run the
    test and see whether the tests still pass:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE114]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: After running the command, you should see that the tests still pass. At this
    point, we can keep creating new validators and just add them to the array of validators
    we want to inject into the `ToyCarValidator.php` class.
  prefs: []
  type: TYPE_NORMAL
- en: Now, open the `ToyCarCreator.php` class we created earlier in this chapter,
    and you’ll see that it’s already prepared to accept dependencies from the outside.
    We can also refactor the class so that we can automatically inject the dependencies
    it needs during instantiation.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Open the following test class and refactor it with the following content:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: codebase/symfony/tests/Integration/Processor/ToyCarCreatorTest.php
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE115]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, we have instantiated the dependencies of the `ToyCarCreator.php`
    class and then injected them as a parameter when we instantiated the class in
    `ToyCarCreator($validatorStub, $toyWriterStub);`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, open the `ToyCarCreator.php` solution class and refactor it with the
    following content:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: codebase/symfony/src/Processor/ToyCarCreator.php
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE116]'
  prefs: []
  type: TYPE_PRE
- en: Upon instantiation, both the validator and writer dependencies are set through
    the constructor.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we run the test, it should still pass:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE117]'
  prefs: []
  type: TYPE_PRE
- en: After running the command, you should still see a passing test.
  prefs: []
  type: TYPE_NORMAL
- en: The most obvious thing that you will notice with this approach is that you will
    have to manage all the dependencies yourself and then inject them into the object
    that needs them. Luckily, we are not the first people to encounter this headache.
    There are a lot of service containers out there that help manage the dependencies
    that your application needs, but the most important thing when selecting a service
    container for PHP is that it should follow the PSR-11 standards. You can read
    more about PSR-11 at [https://www.php-fig.org/psr/psr-11/](https://www.php-fig.org/psr/psr-11/).
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we’ve gone through the SOLID principles one by one. We used
    our tests to kickstart the development of our solution code so that we can use
    them as examples for implementing the SOLID principles in real life.
  prefs: []
  type: TYPE_NORMAL
- en: We have covered the SRP, which helped us make a PHP class’s responsibility or
    capability more focused. The OCP helped us avoid the need for touching or modifying
    a class in some instances when we want to change its behavior. The LSP helped
    us be stricter about the behavior of an interface, making it easier for us to
    switch concrete objects implementing that interface without breaking the parent
    class’s behavior. The ISP helped us make the responsibility of an interface more
    focused – classes that implement this interface will no longer have empty methods
    just because they were declared by the interface. The DIP helped us quickly test
    our `ToyCarCreator` class even without creating a concrete implementation of its
    dependencies, such as the `ToyCarValidator` class.
  prefs: []
  type: TYPE_NORMAL
- en: When working on real-life projects, some principles are hard to strictly follow,
    and sometimes the boundaries are vague. Add the pressure of real-life deadlines
    and it gets even more interesting. One thing is for sure, using BDD and TDD will
    help you be more confident about the features you are developing, especially when
    you are already a few months deep into a project. Adding SOLID principles on top
    of that makes your solution even better!
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will try to utilize automated tests to help us make
    sure that any code changes that any developer in your team pushes into your code
    repository will not break the expected behavior of your software. We will try
    to automate this process by using Continuous Integration.
  prefs: []
  type: TYPE_NORMAL
- en: Part 3 – Deployment Automation and Monitoring
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this part of the book, you will learn how to utilize automated tests to improve
    and automate the code integration process, as well as automate the deployment
    process of an application. You will also learn how to monitor a PHP application
    after it’s been deployed.
  prefs: []
  type: TYPE_NORMAL
- en: 'This section comprises the following chapters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[*Chapter 9*](B18318_09.xhtml#_idTextAnchor138), *Continuous Integration*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[*Chapter 10*](B18318_10.xhtml#_idTextAnchor146), *Continuous Delivery*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[*Chapter 11*](B18318_11.xhtml#_idTextAnchor162), *Monitoring*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
