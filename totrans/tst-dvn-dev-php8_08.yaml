- en: '8'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '8'
- en: Using TDD with SOLID Principles
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用SOLID原则进行TDD
- en: When I first started programming, I instantly got addicted to it. I felt so
    excited about the thought of coming up with a solution to a problem using programs
    and my own imagination. Back in school, there was a time when the instructor gave
    us the task of solving some simple algebraic challenges using Turbo-C. I had goosebumps
    and felt very excited as I quickly realized I could just write programs to solve
    these types of challenges repeatedly. Write the program once, pass different arguments,
    and get different results. I loved it. I remember a challenge to compute the height
    of a bridge if someone is standing on it, drops a ball, and hears a sound after
    several seconds. Easy! Now, I can just use my program to compute the height of
    the bridge for me repeatedly. Now, I don’t have to keep remembering that the Earth’s
    gravitational acceleration is at around 9.8 m/s2 – I can just declare it in the
    program! I learned that in programming, I can follow my own rules to get from
    point A to point B. Give me a task, and I can come up with a solution using my
    own imagination to finish the task. This, for me, is the best thing about programming.
    I was one proud spaghetti-code-writing machine. I didn’t care about how clean
    my code was – I just needed to solve problems using code! Learning about other
    programming languages made me even more excited, and I thought the possibilities
    were endless – if the task or challenge did not defy the laws of physics, I thought
    it could be solved using programming! I did not pay attention to code cleanliness
    or maintainability. What are those? I don’t need those!
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 当我开始编程时，我立刻沉迷其中。我对于使用程序和自己的想象力来解决问题想出解决方案的想法感到非常兴奋。在学校的时候，有一次老师给我们布置了一个任务，就是使用Turbo-C来解决一些简单的代数挑战。当我很快意识到我可以编写程序来反复解决这类挑战时，我感到非常兴奋，甚至起了一身鸡皮疙瘩。编写一次程序，传递不同的参数，得到不同的结果。我喜欢这样。我记得有一个挑战是计算如果有人站在桥上，扔下一个球，几秒钟后听到声音，桥的高度是多少。简单！现在，我可以用我的程序反复计算桥的高度。现在，我不再需要记住地球的重力加速度大约是9.8
    m/s²了——我可以在程序中声明它！我了解到在编程中，我可以遵循自己的规则从A点到B点。给我一个任务，我可以用自己的想象力想出解决方案来完成这个任务。对我来说，这就是编程最好的地方。我成了一个自豪的意大利面代码编写机器。我不在乎我的代码有多干净——我只需要用代码来解决问题！学习其他编程语言让我更加兴奋，我认为可能性是无限的——如果任务或挑战不违反物理定律，我认为可以用编程来解决！我没有注意代码的整洁性或可维护性。那些是什么？我不需要那些！
- en: When I started working professionally as a software developer, I continued with
    my mindset of just enjoying solving problems using programming. I didn’t care
    how disorganized my solutions were – they solved the problems, and my employers
    and clients were happy. Done, I’m out of here. Too easy. I thought I knew everything
    and that I was unstoppable. Oh boy, I was so wrong. The more I learned, the more
    I realized how little I knew how to program.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 当我开始作为软件开发者专业工作时，我继续以仅仅享受使用编程解决问题的心态工作。我不在乎我的解决方案有多不整洁——它们解决了问题，我的雇主和客户都很高兴。完成了，我就可以离开了。太简单了。我认为我知道一切，而且我觉得自己无所不能。哦，我错了。我学得越多，就越意识到我懂得编程的越少。
- en: As I continued working on more complex projects with other developers while
    having to maintain these projects, I learned the hard way how difficult I had
    made my life by writing code I couldn’t easily maintain myself. I’m probably not
    the only developer on the planet to have experienced this problem. I was sure
    other people had encountered these issues before, and I was sure there were solutions
    out there. One of the solutions that helped make my life a lot easier was by trying
    to follow the **SOLID** principles by *Robert C. Martin*. They really helped change
    my programming life, and using these principles with **Test-Driven Development**
    (**TDD**) made my programming life even easier! There are more principles and
    architectural design patterns out there to help make your application more maintainable,
    but in this chapter, we will be focusing on the SOLID principles one by one while
    doing TDD.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 当我继续与其他开发者一起工作，同时维护这些项目时，我痛苦地意识到，由于编写了自己难以维护的代码，我给自己带来了多大的麻烦。我可能不是地球上唯一经历过这种问题的开发者。我确信其他人之前也遇到过这些问题，我也确信有解决方案。其中一个帮助我生活变得容易的解决方案是尝试遵循**罗伯特·C·马丁**的**SOLID**原则。它们真的帮助改变了我的编程生活，并且使用这些原则与**测试驱动开发**（**TDD**）一起使我的编程生活变得更加容易！还有更多的原则和架构设计模式可以帮助使你的应用程序更易于维护，但在这个章节中，我们将逐个关注SOLID原则，并在进行TDD的同时进行。
- en: We’ll go through the process of interpreting a Jira ticket into a BDD test,
    which, in turn, will help us in creating our integration tests, down to the development
    of the solution code. Then, one by one, we will go through each of the SOLID principles
    by using TDD as you would do in a real project.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将逐步解释将Jira工单转换为BDD测试的过程，这将反过来帮助我们创建集成测试，直至开发解决方案代码。然后，我们将逐个通过使用TDD来介绍每个SOLID原则，就像在真实项目中做的那样。
- en: 'In this chapter, we will go through the following topics:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将介绍以下主题：
- en: Jira to BDD to TDD
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Jira到BDD到TDD
- en: TDD with the Single-Responsibility Principle
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基于单一职责原则的TDD
- en: TDD with the Open-Closed Principle
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基于开放封闭原则的TDD
- en: TDD with the Liskov Substitution Principle
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基于Liskov替换原则的TDD
- en: TDD with the Interface Segregation Principle
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基于接口分离原则的TDD
- en: TDD with the Dependency Inversion Principle
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基于依赖倒置原则的TDD
- en: Technical requirements
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: In this chapter, the reader needs to use the base code from the repository found
    at [https://github.com/PacktPublishing/Test-Driven-Development-with-PHP-8/tree/main/Chapter%208](https://github.com/PacktPublishing/Test-Driven-Development-with-PHP-8/tree/main/Chapter%208).
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，读者需要使用位于[https://github.com/PacktPublishing/Test-Driven-Development-with-PHP-8/tree/main/Chapter%208](https://github.com/PacktPublishing/Test-Driven-Development-with-PHP-8/tree/main/Chapter%208)的仓库中的基础代码。
- en: Preparing the development environment for the chapter
  id: totrans-15
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备本章的开发环境
- en: 'First, get the base code for this chapter found at https://github.com/PacktPublishing/Test-Driven-Development-with-PHP-8/tree/main/Chapter%206/base/phptdd
    or simply run the following command:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，获取本章的基础代码，该代码位于https://github.com/PacktPublishing/Test-Driven-Development-with-PHP-8/tree/main/Chapter%206/base/phptdd，或者简单地运行以下命令：
- en: '[PRE0]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: To run the containers and execute the commands in this chapter, you should be
    inside the `docker-server-web-1` container.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 要运行容器并执行本章中的命令，你应该在 `docker-server-web-1` 容器内部。
- en: 'Run the following command to confirm the container name for our web server:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 运行以下命令以确认我们的Web服务器的容器名称：
- en: '[PRE1]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'To run the containers, run the following command from the `/docker` directory
    from the repository in your host machine:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 要运行容器，从主机机器上的 `/docker` 目录运行以下命令：
- en: '[PRE2]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Once inside the container, run the following commands to install the libraries
    required through `composer`:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦进入容器，运行以下命令通过 `composer` 安装所需的库：
- en: '[PRE3]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Jira to BDD to TDD
  id: totrans-25
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Jira到BDD到TDD
- en: The SOLID principles, as defined by Robert C. Martin, are a set of coding guidelines
    or standards that help developers write more organized, decoupled, maintainable,
    extensible software. In this chapter, we’ll go through them one by one, but we
    will try to simulate the process by working on a real project and then implementing
    each of the principles.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 根据罗伯特·C·马丁的定义，SOLID原则是一套编码指南或标准，有助于开发者编写更组织化、解耦、可维护和可扩展的软件。在本章中，我们将逐一介绍它们，但我们将通过在一个真实项目上工作并实现每个原则来模拟这个过程。
- en: 'In this chapter, we will be writing solution code that will try to adhere to
    the SOLID principles, but before that, we need an example problem to solve. As
    we did in [*Chapter 7*](B18318_07.xhtml#_idTextAnchor108)*, Building Solution
    Code with BDD and TDD*, we’ll start with a Jira ticket, write some Gherkin features,
    write Behat tests, write integration and unit tests, and then write the SOLID-adhering
    solution code as depicted in the following flowchart:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将编写尝试遵循SOLID原则的解决方案代码，但在那之前，我们需要一个要解决的问题的例子。正如我们在[*第7章*](B18318_07.xhtml#_idTextAnchor108)，“使用BDD和TDD构建解决方案代码”中所做的那样，我们将从一个Jira工单开始，编写一些Gherkin特性，编写Behat测试，编写集成和单元测试，然后编写如以下流程图所示的遵循SOLID原则的解决方案代码：
- en: "![Figure 8.1 \uFEFF– Development flow](img/Figure_8.01_B18318.jpg)"
  id: totrans-28
  prefs: []
  type: TYPE_IMG
  zh: '![图8.1 – 开发流程](img/Figure_8.01_B18318.jpg)'
- en: Figure 8.1 – Development flow
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.1 – 开发流程
- en: 'Let’s use one of the Jira tickets we created in [*Chapter 2*](B18318_02.xhtml#_idTextAnchor027),
    *Understanding and Organizing the Business Requirements for Our Project*. We created
    a story to let a logged-in user input and save some toy car model data. This will
    be a nice simple feature to use to demonstrate the SOLID principles:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用我们在[*第2章*](B18318_02.xhtml#_idTextAnchor027)，“理解并组织我们项目的业务需求”中创建的一个Jira工单，*理解并组织我们项目的业务需求*。我们创建了一个故事，让登录用户输入并保存一些玩具车型号数据。这将是一个很好的简单功能，用于演示SOLID原则：
- en: '![Figure 8.2 – Ticket for creating toy model data](img/Figure_8.02_B18318.jpg)'
  id: totrans-31
  prefs: []
  type: TYPE_IMG
  zh: '![图8.2 – 创建玩具模型数据的工单](img/Figure_8.02_B18318.jpg)'
- en: Figure 8.2 – Ticket for creating toy model data
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.2 – 创建玩具模型数据的工单
- en: As we did in [*Chapter 7*](B18318_07.xhtml#_idTextAnchor108), *Building Solution
    Code with BDD and TDD*, create a new git branch for your Jira ticket. Check out
    the git branch from the repository you set up in [*Chapter 2*](B18318_02.xhtml#_idTextAnchor027),
    *Understanding and Organizing the Business Requirements for Our Project*, and
    let’s start writing some tests and programs!
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在[*第7章*](B18318_07.xhtml#_idTextAnchor108)，*使用BDD和TDD构建解决方案代码*中做的那样，为你的Jira票据创建一个新的git分支。从你在[*第2章*](B18318_02.xhtml#_idTextAnchor027)，*理解和组织我们项目的业务需求*中设置的仓库检出git分支，然后让我们开始编写一些测试和程序！
- en: Before we start learning about the SOLID principles, first, we need to work
    on the BDD tests that will drive us to write the solution code while trying to
    follow the SOLID principles. Remember, we always need to start with failing tests.
    Next, to start with BDD, we need to write a Gherkin feature first.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始学习SOLID原则之前，首先，我们需要工作于BDD测试，这将引导我们编写遵循SOLID原则的解决方案代码。记住，我们始终需要从失败的测试开始。接下来，为了开始使用BDD，我们需要首先编写一个Gherkin功能。
- en: Gherkin feature
  id: totrans-35
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Gherkin功能
- en: 'Let’s start by writing a Gherkin feature to describe what behavior we expect
    to build. Create the following feature file with the following content inside
    the `behat` directory:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从编写一个Gherkin功能来描述我们期望构建的行为开始。在`behat`目录中创建以下功能文件，并包含以下内容：
- en: codebase/behat/features/create_toy_car_record.feature
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: codebase/behat/features/create_toy_car_record.feature
- en: '[PRE4]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Now that we have our feature, let’s generate the Behat PHP context class for
    it.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了我们的功能，让我们为它生成Behat PHP上下文类。
- en: Behat context
  id: totrans-40
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Behat上下文
- en: 'We will now take the Gherkin feature and make a PHP context class for it. Follow
    these steps:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将使用Gherkin功能并为其创建一个PHP上下文类。按照以下步骤操作：
- en: 'First, update the `behat.yml` file:'
  id: totrans-42
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，更新`behat.yml`文件：
- en: codebase/behat/behat.yml
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: codebase/behat/behat.yml
- en: '[PRE5]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'After updating the main `behat.yml` file, run the following commands to create
    the PHP context class:'
  id: totrans-45
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更新主`behat.yml`文件后，运行以下命令来创建PHP上下文类：
- en: '[PRE6]'
  id: totrans-46
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '[PRE7]'
  id: totrans-47
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '[PRE8]'
  id: totrans-48
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '[PRE9]'
  id: totrans-49
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: There should now be a new class created in `features/bootstrap/CreateToyCarRecordContext.php`.
    Refactor the `iAmInTheInventorySystemPage` method so that it throws `\Exception`.
  id: totrans-50
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在应该在`features/bootstrap/CreateToyCarRecordContext.php`中创建了一个新的类。重构`iAmInTheInventorySystemPage`方法，使其抛出`\Exception`。
- en: 'Next, let’s make sure we can execute this feature test by running the following
    command:'
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，让我们确保我们可以通过运行以下命令来执行此功能测试：
- en: '[PRE10]'
  id: totrans-52
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '[PRE11]'
  id: totrans-53
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'You should then see the following test result:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该会看到以下测试结果：
- en: '![Figure 8.3 – Failed test](img/Figure_8.03_B18318.jpg)'
  id: totrans-55
  prefs: []
  type: TYPE_IMG
  zh: '![图8.3 – 失败的测试](img/Figure_8.03_B18318.jpg)'
- en: Figure 8.3 – Failed test
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.3 – 失败的测试
- en: Good – now, we know that the Behat test for this feature can be executed and
    fails as expected, so let’s move on to the Symfony application.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 好的 – 现在，我们知道这个功能的Behat测试可以执行并且如预期那样失败，所以让我们继续到Symfony应用程序。
- en: Functional test
  id: totrans-58
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 功能测试
- en: 'The Behat test we created is already a functional test – do we still have to
    create a functional test inside the Symfony directory? I think this is optional,
    but it will help us to quickly run basic smoke tests – for example, if we want
    to quickly check whether our controller loads and doesn’t encounter a fatal error.
    We don’t need to run the bigger and slower Behat test to find that out:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建的Behat测试已经是一个功能测试 – 我们是否还需要在Symfony目录中创建一个功能测试？我认为这是可选的，但它将帮助我们快速运行基本烟雾测试
    – 例如，如果我们想快速检查我们的控制器是否加载并且没有遇到致命错误。我们不需要运行更大、更慢的Behat测试来找出这一点：
- en: 'Create the following test class with the following content:'
  id: totrans-60
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建以下测试类，并包含以下内容：
- en: codebase/symfony/tests/Functional/Controller/InventoryAdminControllerTest.php
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: codebase/symfony/tests/Functional/Controller/InventoryAdminControllerTest.php
- en: '[PRE12]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'After creating our controller test class, let’s run the following command to
    make sure that PHPUnit can execute this test and that it fails:'
  id: totrans-63
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在创建我们的控制器测试类之后，让我们运行以下命令以确保PHPUnit可以执行此测试并且它失败：
- en: '[PRE13]'
  id: totrans-64
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '[PRE14]'
  id: totrans-65
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: After running the test, make sure that you get a test failure. Remember the
    red phase?
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 在运行测试后，请确保你得到一个测试失败。还记得那个红色阶段吗？
- en: Great – we can forget about creating the controller for now. Let’s move on to
    the integration tests. These tests will be used to develop the mechanism to persist
    the toy car model in the database.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 太好了 – 我们现在可以暂时忘记创建控制器了。让我们继续到集成测试。这些测试将用于开发将玩具车模型持久化到数据库的机制。
- en: Integration test
  id: totrans-68
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 集成测试
- en: 'We will now need to start writing integration tests that will help us write
    the code to persist or create a new toy car model. After passing these tests,
    then we can go back to the Behat tests we created earlier and make sure they pass:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在需要开始编写集成测试，这将帮助我们编写代码以持久化或创建一个新的玩具车模型。通过通过这些测试后，然后我们可以回到我们之前创建的Behat测试，并确保它们通过：
- en: 'Create the following test class, with the following content:'
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建以下测试类，内容如下：
- en: codebase/symfony/tests/Integration/Processor/ToyCarProcessorTest.php
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: codebase/symfony/tests/Integration/Processor/ToyCarProcessorTest.php
- en: '[PRE15]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'After creating the test class, make sure that PHPUnit can recognize the new
    test class by running the following command:'
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在创建测试类后，确保PHPUnit可以通过运行以下命令识别新的测试类：
- en: '[PRE16]'
  id: totrans-74
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'After running the command, you should see the familiar and soothing PHPUnit
    failure result:'
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行命令后，你应该看到熟悉的、令人安慰的PHPUnit失败结果：
- en: '![Figure 8.4 – Failing processor test](img/Figure_8.04_B18318.jpg)'
  id: totrans-76
  prefs: []
  type: TYPE_IMG
  zh: '![图8.4 – 失败的处理器测试](img/Figure_8.04_B18318.jpg)'
- en: Figure 8.4 – Failing processor test
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.4 – 失败的处理器测试
- en: Now that we have a failing integration test, let’s build the code to pass it.
    We want to be able to persist a new toy car model into the persistence layer which
    is our database. Do we even have a DB table for it? Nope, not yet. But we don’t
    care. We can continue working on the solution code. Next, we will be trying to
    follow the **Single-Responsibility Principle** (**SRP**) to write our solution
    code.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有一个失败的集成测试，让我们构建代码来通过它。我们希望能够将新的玩具车模型持久化到持久层，也就是我们的数据库。我们甚至有为其创建的DB表吗？没有，还没有。但我们不在乎。我们可以继续工作在解决方案代码上。接下来，我们将尝试遵循**单一职责原则**（**SRP**）来编写我们的解决方案代码。
- en: TDD with the Single-Responsibility Principle
  id: totrans-79
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用单一职责原则进行TDD（测试驱动开发）
- en: Let’s start with what I think is one of the most important principles in the
    SOLID principles. Are you familiar with god classes or objects – where one class
    can do almost everything? A single class for login, registration, displaying registered
    users, and so on? If there are two developers working on the same god class, can
    you already imagine how challenging that can be? And what happens after you deploy
    it to production and then an issue is found in the part where you display a list
    of registered users? You will have to change or fix that god class, but now the
    same class for login and registration has been modified and these processes may
    be compromised too. You run a bigger risk of introducing regressions to your login
    and registration functionalities by just trying to fix the list of registered
    users. You fix one feature, and there’s a greater risk of breaking other features.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从我认为在SOLID原则中最重要的一条原则开始。你对上帝类或对象熟悉吗——一个类可以几乎做任何事情？一个用于登录、注册、显示已注册用户等的单一类？如果有两个开发者正在同一个上帝类上工作，你能想象这会有多具挑战性吗？而且，当你将其部署到生产环境中并发现显示已注册用户列表的部分有问题时，会发生什么？你将不得不更改或修复那个上帝类，但现在用于登录和注册的同一个类已经被修改，这些流程也可能受到影响。仅仅尝试修复已注册用户列表，就有可能引入登录和注册功能的回归。你修复了一个功能，但打破其他功能的可能性更大。
- en: This is where the SRP will start to make sense. The SRP mandates that a class
    should only have one main responsibility, and one reason to be changed. Is it
    that simple? Sometimes not. A `Login` class should only know about letting a user
    log in, and not have the program responsible for displaying a list of registered
    users or checking out a shopping cart, but sometimes where to draw the line can
    become very subjective.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是SRP开始变得有意义的地方。SRP规定，一个类应该只有一个主要职责，以及一个改变的理由。这很简单吗？有时并不简单。一个`Login`类应该只了解让用户登录，而不应该让程序负责显示已注册用户列表或检查购物车，但有时在哪里划线可能非常主观。
- en: Next, we’ll start writing the actual solution code while trying to implement
    the SRP.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将开始编写实际的解决方案代码，同时尝试实现SRP（单一职责原则）。
- en: Writing the solution code
  id: totrans-83
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编写解决方案代码
- en: We have a failing test that tests whether our application can create a toy car
    model and persist it in the database, but we don’t even have a database table
    for it yet. It’s okay – we will only focus on the PHP side of things for now.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有一个失败的测试，用于测试我们的应用程序是否能够创建一个玩具车模型并将其持久化到数据库中，但我们还没有为它创建数据库表。没关系——我们现在只关注PHP方面的事情。
- en: Model class
  id: totrans-85
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 模型类
- en: 'It’s better for our processor PHP class to deal with objects and not to directly
    know about database table rows and so on. Let’s create a **Plain Old PHP Object**
    (**POPO**) that will represent what a toy car model is, without caring about the
    database structure:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的处理器PHP类来说，处理对象而不是直接了解数据库表行等会更好。让我们创建一个**普通PHP对象**（**POPO**），它将代表玩具汽车模型，而不关心数据库结构：
- en: 'Create the following file with the following content:'
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建以下文件，内容如下：
- en: codebase/symfony/src/Model/ToyCar.php
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: codebase/symfony/src/Model/ToyCar.php
- en: '[PRE17]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: After declaring the properties, it’s best to generate the accessors and mutators
    for all of these properties, rather than accessing them directly.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 在声明属性后，最好为所有这些属性生成访问器和修改器，而不是直接访问它们。
- en: As you can see, this is just a POPO class. Nothing fancy. No information whatsoever
    about how to persist it in our database. Its responsibility is just to be a model
    that represents what a toy car is.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，这只是一个POPO类。没有任何关于如何在我们的数据库中持久化的信息。它的职责只是作为一个代表玩具汽车的模型。
- en: 'Let’s also create the `CarManufacturer` and `ToyColor` models. Create the following
    classes with the following content:'
  id: totrans-92
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们再创建`CarManufacturer`和`ToyColor`模型。创建以下类，内容如下：
- en: codebase/symfony/src/Model/ToyColor.php
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: codebase/symfony/src/Model/ToyColor.php
- en: '[PRE18]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: After declaring the properties, generate the accessors and mutators for the
    class.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 在声明属性后，为这个类生成访问器和修改器。
- en: 'See the following for the car manufacturer:'
  id: totrans-96
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下为汽车制造商的示例：
- en: codebase/symfony/src/Model/CarManufacturer.php
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: codebase/symfony/src/Model/CarManufacturer.php
- en: '[PRE19]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Now, generate the accessors and mutators for this class as well.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，也为这个类生成访问器和修改器。
- en: Now, we have the main `ToyCar` model, which is also using the `ToyColor` and
    `CarManufacturer` models. As you can see, as with the `ToyCar` model, these two
    classes are not responsible for persisting or reading data either.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们有主要的`ToyCar`模型，它也使用了`ToyColor`和`CarManufacturer`模型。如您所见，与`ToyCar`模型一样，这两个类也不负责持久化或读取数据。
- en: As you remember, we are using the Doctrine ORM as a tool to interact with our
    database. We can also use Doctrine entities directly in our processor class if
    we want to, but that would mean that our processor class would now be using a
    class that has a dependency on Doctrine. What if we need to use a different ORM?
    To keep things a little bit less coupled, we will just use `codebase/symfony/src/Model/ToyCar.php`
    in the processor class we will be creating next.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所记，我们正在使用Doctrine ORM作为与数据库交互的工具。如果我们想的话，我们也可以在我们的处理器类中直接使用Doctrine实体，但这意味着我们的处理器类现在将使用一个依赖于Doctrine的类。如果我们需要使用不同的ORM呢？为了使事情稍微不那么耦合，我们将在我们即将创建的处理器类中使用`codebase/symfony/src/Model/ToyCar.php`。
- en: Processor class
  id: totrans-102
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 处理器类
- en: 'For us to create and persist a toy car model, we will need a class that will
    need to process it for us. The thing is, we still don’t have a database at this
    stage – where do we persist the toy car model? For now, nowhere, but we can still
    pass the test:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 为了创建和持久化玩具汽车模型，我们需要一个类来为我们处理它。问题是，在这个阶段我们还没有数据库——我们该在哪里持久化玩具汽车模型？目前还没有地方，但我们仍然可以通过测试：
- en: 'Create the following interface with the following content:'
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建以下接口，内容如下：
- en: codebase/symfony/src/DAL/Writer/WriterInterface.php
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: codebase/symfony/src/DAL/Writer/WriterInterface.php
- en: '[PRE20]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: We created a very simple interface that our data-writer objects can implement.
    We’ll then use this interface for our processor class.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建了一个非常简单的接口，我们的数据写入对象可以实现。然后我们将使用这个接口来处理我们的处理器类。
- en: 'Now, let’s create the toy car workflow or processor class. Create the following
    class with the following content:'
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们创建玩具汽车工作流程或处理器类。创建以下类，内容如下：
- en: codebase/symfony/src/Processor/ToyCarProcessor.php
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: codebase/symfony/src/Processor/ToyCarProcessor.php
- en: '[PRE21]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: We have created a processor class that has a `create` method that accepts the
    toy car model we created previously, and then tries to write the model using an
    instance of a writer class that doesn’t exist. What if another developer in your
    company is working on the data-writer class and it will take him 2 weeks to complete
    it? Do you wait for 2 weeks to pass your integration test?
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建了一个处理器类，它有一个`create`方法，接受我们之前创建的玩具汽车模型，然后尝试使用一个不存在的写入类实例来写入模型。如果贵公司的另一位开发者正在处理数据写入类，并且需要两周时间才能完成，你会等待两周来通过集成测试吗？
- en: If your processor class must validate the data and do other things after the
    data has been written into the database, should those programs be delayed too
    just because you are waiting for the other developer to complete their work? Probably
    not! We can use test doubles to replace the missing dependencies for now.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的处理器类必须在数据写入数据库后验证数据并执行其他操作，那么这些程序是否也应该因为你在等待其他开发者完成他们的工作而延迟？可能不是！我们可以使用测试替身来暂时替换缺失的依赖项。
- en: Test doubles
  id: totrans-113
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 测试替身
- en: Most of the time, it’s just difficult or impractical to be able to run a test
    against a feature with all its dependencies already built. Sometimes, we need
    to have a solution to be able to test the specific feature we want, even if we
    have not built the other dependencies yet, or simply want to isolate or only focus
    our test on a certain feature. Here, we can use test doubles. You can read more
    about test doubles for PHPUnit at [https://phpunit.readthedocs.io/en/9.5/test-doubles.html](https://phpunit.readthedocs.io/en/9.5/test-doubles.html).
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数时候，要运行一个针对具有所有已构建依赖项的功能的测试是困难的或不切实际的。有时，我们需要一个解决方案来测试我们想要的特定功能，即使我们还没有构建其他依赖项，或者只是想隔离或仅关注某个特定功能。在这里，我们可以使用测试替身。你可以在[https://phpunit.readthedocs.io/en/9.5/test-doubles.html](https://phpunit.readthedocs.io/en/9.5/test-doubles.html)了解更多关于PHPUnit测试替身的信息。
- en: Mock and Stub
  id: totrans-115
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 模拟和存根
- en: 'The processor class we just created needs a concrete instance of `ToyValidatorInterface`
    and `WriterInterface`. Since we have not created those classes yet, we can still
    proceed in passing the test just by using a `Mock` object. In PHPUnit, the `Mock`
    object is an interface that extends the `Stub` interface. This means that in the
    code, a `Mock` object is an implementation of a `Stub` interface. The process
    of replacing the instances of `ToyValidatorInterface` and `WriterInterface` with
    a `Mock` object and setting a `return` value when a specific method is executed
    is called stubbing. Let’s try it for real:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚刚创建的处理器类需要一个`ToyValidatorInterface`和`WriterInterface`的具体实例。由于我们还没有创建这些类，我们仍然可以通过使用`Mock`对象来通过测试。在PHPUnit中，`Mock`对象是一个扩展了`Stub`接口的接口。这意味着在代码中，`Mock`对象是`Stub`接口的一个实现。用`Mock`对象替换`ToyValidatorInterface`和`WriterInterface`的实例，并在执行特定方法时设置`return`值的过程称为存根（stubbing）。让我们实际尝试一下：
- en: 'Go back to the `ToyCarProcessorTest` class and refactor it with the following
    content:'
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 返回到`ToyCarProcessorTest`类，并使用以下内容重构它：
- en: codebase/symfony/tests/Integration/Processor/ToyCarProcessorTest.php
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: codebase/symfony/tests/Integration/Processor/ToyCarProcessorTest.php
- en: '[PRE22]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'In the `testCanCreate` function here, we are creating mock objects for the
    `ValidationModel`, `ToyCarValidator`, and `ToyCarWriter` classes. We then instantiate
    the main `ToyCarCreator` class while passing the mock `ToyCarValidator` and `ToyCarWriter`
    classes into its constructor. This is called dependency injection, which will
    be discussed further later in the chapter. Lastly, we then run the `ToyCarCreator`’s
    `create` method to simulate a developer trying to create a new toy car record:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里的`testCanCreate`函数中，我们正在为`ValidationModel`、`ToyCarValidator`和`ToyCarWriter`类创建模拟对象。然后我们实例化主要的`ToyCarCreator`类，并将模拟的`ToyCarValidator`和`ToyCarWriter`类传递给其构造函数。这被称为依赖注入，将在本章后面进一步讨论。最后，我们运行`ToyCarCreator`的`create`方法来模拟开发者尝试创建一个新的玩具车记录：
- en: 'Let’s run the test by entering the following command and see what result we
    get:'
  id: totrans-121
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们通过输入以下命令来运行测试，看看我们会得到什么结果：
- en: '[PRE23]'
  id: totrans-122
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'You should then see the following result:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该会看到以下结果：
- en: '![Figure 8.5 – Passed the test using a stub](img/Figure_8.05_B18318.jpg)'
  id: totrans-124
  prefs: []
  type: TYPE_IMG
  zh: '![图8.5 – 使用存根通过了测试](img/Figure_8.05_B18318.jpg)'
- en: Figure 8.5 – Passed the test using a stub
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.5 – 使用存根通过了测试
- en: We passed the test, even though we have not really persisted anything in the
    database yet. It’s very common in bigger and more complex projects that you’ll
    have to rely on test doubles just to isolate and focus on your test even if other
    dependencies are either not built yet or are too cumbersome to include as a part
    of your test.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过了测试，尽管我们还没有在数据库中真正持久化任何内容。在更大、更复杂的项目中，你可能会不得不依赖于测试替身（test doubles）来隔离并专注于你的测试，即使其他依赖项尚未构建，或者太复杂以至于无法作为测试的一部分包含在内。
- en: 'Now going back to the SRP, our `ToyCarProcessor` now has two responsibilities
    – to validate and create a toy car model. Equally, other developers are using
    your class’s `validate` method. Let’s refactor our code to redefine the focus
    and responsibility of our `ToyCarProcessor` class:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 现在回到SRP（单一职责原则），我们的`ToyCarProcessor`现在有两个职责 – 验证和创建玩具车模型。同样，其他开发者也在使用你的类的`validate`方法。让我们重构我们的代码，重新定义`ToyCarProcessor`类的焦点和职责：
- en: 'Rename the following classes:'
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 重命名以下类：
- en: '`ToyCarProcessor.php` to `ToyCarCreator.php`'
  id: totrans-129
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将`ToyCarProcessor.php`重命名为`ToyCarCreator.php`
- en: '`ToyCarProcessorTest.php` to `ToyCarCreatorTest.php`'
  id: totrans-130
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将`ToyCarProcessorTest.php`重命名为`ToyCarCreatorTest.php`
- en: 'Next, let’s refactor the `ToyCarCreatorTest.php` class. Open the following
    class and replace the content with the following:'
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，让我们重构`ToyCarCreatorTest.php`类。打开以下类，并将其内容替换为以下内容：
- en: codebase/symfony/tests/Integration/Processor/ToyCarCreatorTest.php
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: codebase/symfony/tests/Integration/Processor/ToyCarCreatorTest.php
- en: '[PRE24]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: As you can see, we added a new `Mock` object for the validation. I will explain
    why we must do that after we refactor the content of the `ToyCarCreator.php` class.
    Let’s create a validator interface, and then refactor the `ToyCarCreator` class.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，我们添加了一个新的`Mock`对象用于验证。我将在重构`ToyCarCreator.php`类的内容后解释为什么我们必须这样做。让我们创建一个验证器接口，然后重构`ToyCarCreator`类。
- en: 'Create the following file with the following content:'
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建以下文件，并包含以下内容：
- en: codebase/symfony/src/Validator/ValidatorInterface.php
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: codebase/symfony/src/Validator/ValidatorInterface.php
- en: '[PRE25]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Open `codebase/symfony/src/Processor/ToyCarCreator.php` and use the following
    content:'
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`codebase/symfony/src/Processor/ToyCarCreator.php`，并使用以下内容：
- en: '[PRE26]'
  id: totrans-139
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: '[PRE27]'
  id: totrans-140
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: '[PRE28]'
  id: totrans-141
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: '[PRE29]'
  id: totrans-142
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: '[PRE30]'
  id: totrans-143
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: '[PRE31]'
  id: totrans-144
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: '[PRE32]'
  id: totrans-145
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: '[PRE33]'
  id: totrans-146
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: '[PRE34]'
  id: totrans-147
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: '[PRE35]'
  id: totrans-148
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: '[PRE36]'
  id: totrans-149
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: '[PRE37]'
  id: totrans-150
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: '[PRE38]'
  id: totrans-151
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: '[PRE39]'
  id: totrans-152
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE39]'
- en: '[PRE40]'
  id: totrans-153
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE40]'
- en: '[PRE41]'
  id: totrans-154
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE41]'
- en: '[PRE42]'
  id: totrans-155
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE42]'
- en: '[PRE43]'
  id: totrans-156
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE43]'
- en: '[PRE44]'
  id: totrans-157
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE44]'
- en: '[PRE45]'
  id: totrans-158
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE45]'
- en: '[PRE46]'
  id: totrans-159
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE46]'
- en: '[PRE47]'
  id: totrans-160
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE47]'
- en: '[PRE48]'
  id: totrans-161
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE48]'
- en: '[PRE49]'
  id: totrans-162
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE49]'
- en: '[PRE50]'
  id: totrans-163
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE50]'
- en: '[PRE51]'
  id: totrans-164
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE51]'
- en: '[PRE52]'
  id: totrans-165
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE52]'
- en: '[PRE53]'
  id: totrans-166
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE53]'
- en: '[PRE54]'
  id: totrans-167
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE54]'
- en: '[PRE55]'
  id: totrans-168
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE55]'
- en: '[PRE56]'
  id: totrans-169
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE56]'
- en: '[PRE57]'
  id: totrans-170
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE57]'
- en: Next, add the necessary accessors and mutators for the private properties we
    have declared in the class.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，为我们在类中声明的私有属性添加必要的访问器和修改器。
- en: We renamed the class just to give it a more specific name. Sometimes, just naming
    the class to something else helps you clean up your code. Also, you will notice
    that we have removed the publicly visible `validate` class. This class will no
    longer contain any validation logic – it only knows that it will run a validation
    routine before it tries to persist the data. This is the class’s main responsibility.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 我们只是将类重命名，使其具有更具体的名称。有时，只是将类的名称改为其他名称就可以帮助你清理代码。此外，您会注意到我们已经删除了公开可见的`validate`类。这个类将不再包含任何验证逻辑
    – 它只知道在尝试持久化数据之前将运行一个验证例程。这是这个类的主要职责。
- en: 'We still have not written any validation and data persistence code, but let’s
    see whether we can still pass the test to test the main responsibility of the
    class, which is to do the following:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还没有编写任何验证和数据持久化代码，但让我们看看我们是否还能通过测试来测试类的主体职责，即执行以下操作：
- en: Accept a `ToyCar` model object.
  id: totrans-174
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接受一个`ToyCar`模型对象。
- en: Run a validation routine.
  id: totrans-175
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行验证例程。
- en: Attempt to persist the data.
  id: totrans-176
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 尝试持久化数据。
- en: Return the result.
  id: totrans-177
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 返回结果。
- en: 'Run the following command:'
  id: totrans-178
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行以下命令：
- en: '[PRE58]'
  id: totrans-179
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'Now, you should see the following result:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你应该看到以下结果：
- en: '![Figure 8.6 – Passing the test using two stubs](img/Figure_8.06_B18318.jpg)'
  id: totrans-181
  prefs: []
  type: TYPE_IMG
  zh: '![图8.6 – 使用两个存根通过测试](img/Figure_8.06_B18318.jpg)'
- en: Figure 8.6 – Passing the test using two stubs
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.6 – 使用两个存根通过测试
- en: In this section, we used BDD and TDD to direct us into writing the solution
    code. We have created POPOs with a single responsibility. We have also created
    a `ToyCarCreator` class that does not contain the validation logic, nor the persistence
    mechanism. It knows it needs to do some validation and some persistence, but it
    does not have the concrete implementation of those programs. Each class will have
    its own specialization or a specific job, or a specific single responsibility.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们使用了BDD和TDD来指导我们编写解决方案代码。我们创建了具有单一职责的POPOs。我们还创建了一个`ToyCarCreator`类，该类不包含验证逻辑，也不包含持久化机制。它知道它需要执行一些验证和一些持久化，但没有这些程序的具体实现。每个类都将有自己的专业化或特定的工作，或特定的单一职责。
- en: Great – now, we can pass the test again even after refactoring. Next, let’s
    continue writing the solution code by following the O in the SOLID principle,
    which is the **Open-Closed** **Principle** (**OCP**).
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 太好了 – 现在即使在重构之后，我们也能再次通过测试。接下来，让我们继续编写解决方案代码，遵循SOLID原则中的O（开闭）原则，即**开闭原则**（**OCP**）。
- en: TDD with the Open-Closed Principle
  id: totrans-185
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 基于开闭原则的TDD
- en: The OCP was first defined by *Bertrand Meyer*, but in this chapter, we will
    follow the later version defined by *Robert C. Martin*, which is also called the
    polymorphic OCP.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: OCP（开闭原则）最初由**伯纳德·迈耶**定义，但在这章中，我们将遵循**罗伯特·C·马丁**定义的后续版本，也称为多态OCP。
- en: The OCP states that objects should be open to extension and closed to modification.
    The aim is that we should be able to modify the behaviour or a feature by extending
    the original code instead of directly refactoring the original code. That’s great
    because that will help us developers and testers be more confident about the ticket
    we’re working on, as we haven’t touched the original code that might be used somewhere
    else – less risk of regression.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: OCP原则指出，对象应该对扩展开放，对修改封闭。目标是我们应该能够通过扩展原始代码来修改行为或功能，而不是直接重构原始代码。这很好，因为它将帮助我们这些开发者和测试者对我们正在处理的工单更有信心，因为我们没有触及可能被其他地方使用的原始代码——降低回归的风险。
- en: 'In our `ToyCarCreateTest` class, we are stubbing a validator object because
    we have not written a concrete validator class yet. There are a lot of different
    ways of implementing validation, but for this example, we’ll try to make it very
    simple. Let’s go back to the code and create a validator:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的`ToyCarCreateTest`类中，我们正在模拟一个验证对象，因为我们还没有编写具体的验证类。实现验证的方法有很多种，但在这个例子中，我们将尝试让它非常简单。让我们回到代码中创建一个验证器：
- en: 'Create a new test class with the following content:'
  id: totrans-189
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的测试类，内容如下：
- en: codebase/symfony/tests/Unit/Validator/ToyCarValidatorTest.php
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: codebase/symfony/tests/Unit/Validator/ToyCarValidatorTest.php
- en: '[PRE59]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: After creating the test class, as usual, we need to run the test to make sure
    that PHPUnit recognizes your test.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建测试类之后，像往常一样，我们需要运行测试以确保PHPUnit能够识别你的测试。
- en: 'Run the following command:'
  id: totrans-193
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行以下命令：
- en: '[PRE60]'
  id: totrans-194
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE60]'
- en: Make sure that you get an error, as we have not created the validator class
    yet. Remember the red phase? You’ll notice that in the data provider, we have
    set an empty string for the name. We will make the validator class return `false`
    whenever it sees an empty string for the toy car name.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 确保你得到一个错误，因为我们还没有创建验证器类。还记得红色阶段吗？你会注意到在数据提供者中，我们为名称设置了一个空字符串。我们将使验证器类在看到玩具汽车名称为空字符串时返回`false`。
- en: 'Now, that we have the failing test, let’s proceed with creating the class to
    pass it. Create a new PHP class with the following content:'
  id: totrans-196
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们已经有了失败的测试，让我们继续创建一个类来通过它。创建一个新的PHP类，内容如下：
- en: codebase/symfony/src/Validator/ToyCarValidator.php
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: codebase/symfony/src/Validator/ToyCarValidator.php
- en: '[PRE61]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: We have created a very simple validation logic where we only check for the toy
    car’s name if it’s not an empty string. Now, let’s run the test again.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建了一个非常简单的验证逻辑，我们只检查玩具汽车的名称是否不为空字符串。现在，让我们再次运行测试。
- en: 'Run the following command:'
  id: totrans-200
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行以下命令：
- en: '[PRE62]'
  id: totrans-201
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE62]'
- en: You should now see a passing test.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 你现在应该看到一个通过测试。
- en: 'Okay, so for now, we can make sure that the toy car model’s name should always
    be a string that is not empty – but here’s the thing, what if we want to add more
    validation logic? We will have to keep on modifying the `ToyCarValidator` class.
    That’s not wrong. It’s just that it’s arguably better to follow the OCP so that
    we don’t keep modifying our code – less class modification, less risk of breaking
    things. Let’s refactor our solution code to pass the test again:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，所以现在我们可以确保玩具汽车型号的名称应该始终是一个非空字符串——但是这里的问题是，如果我们想添加更多的验证逻辑怎么办？我们将不得不继续修改`ToyCarValidator`类。这并没有错。只是我们认为遵循OCP更好，这样我们就不需要修改我们的代码——减少类修改，降低破坏事物的风险。让我们重构我们的解决方案代码以通过测试：
- en: Let’s add some validation logic for the year and retain the toy car name validation
    as well.
  id: totrans-204
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们为年份添加一些验证逻辑，并保留玩具汽车的名称验证。
- en: 'Right now, we are in the green phase, moving to the refactor phase. We’ll be
    using polymorphism, which we discussed in [*Chapter 4*](B18318_04.xhtml#_idTextAnchor050),
    *Using Object-Oriented Programming in PHP*, instead of inheritance in this solution.
    Create the following interface with the following content:'
  id: totrans-205
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 目前，我们处于绿色阶段，正在转向重构阶段。我们将使用多态性，这在[*第4章*](B18318_04.xhtml#_idTextAnchor050)中讨论过，即使用PHP面向对象编程，而不是在这个解决方案中使用继承。创建以下接口并包含以下内容：
- en: codebase/symfony/src/Validator/ToyCarValidatorInterface.php
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: codebase/symfony/src/Validator/ToyCarValidatorInterface.php
- en: '[PRE63]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'We created a new `ToyCarValidatorInterface` interface that will replace the
    `ToyCarValidator` concrete class. You will notice that the validate method returns
    an object – let’s create that object too:'
  id: totrans-208
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们创建了一个新的`ToyCarValidatorInterface`接口，它将取代`ToyCarValidator`具体类。你会注意到验证方法返回了一个对象——让我们也创建这个对象：
- en: codebase/symfony/src/Model/ValidationModel.php
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: codebase/symfony/src/Model/ValidationModel.php
- en: '[PRE64]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: After creating the class, generate the accessors and mutators for the properties.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建类之后，为属性生成访问器和修改器。
- en: Instead of simply returning `true` or `false` on our validation program, we
    can now return an array containing the field name and validation result for that
    field name as well. Let’s continue coding.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的验证程序中，我们不仅可以简单地返回`true`或`false`，现在还可以返回一个包含字段名和该字段名的验证结果的数组。让我们继续编码。
- en: 'Create the following test class with the following content:'
  id: totrans-213
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建以下测试类，内容如下：
- en: codebase/symfony/tests/Unit/Validator/ToyCarValidatorTest.php
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: codebase/symfony/tests/Unit/Validator/ToyCarValidatorTest.php
- en: '[PRE65]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'If you run this test, you will see four failures, as we have four sets of values
    inside the `provideYear` data provider. Run the test by running the following
    command:'
  id: totrans-216
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果你运行这个测试，你会看到四个失败，因为我们有四个`provideYear`数据提供者中的值集。通过以下命令运行测试：
- en: '[PRE66]'
  id: totrans-217
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'If the test fails, that’s good. Let’s proceed with the solution code:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 如果测试失败，那很好。让我们继续编写解决方案代码：
- en: 'Create the following solution class with the following content:'
  id: totrans-219
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建以下解决方案类，内容如下：
- en: codebase/symfony/src/Validator/YearValidator.php
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: codebase/symfony/src/Validator/YearValidator.php
- en: '[PRE67]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: Now, we have a simple validation class for checking whether a year is acceptable
    for our car. If we want to add more logic here, such as checking for the minimum
    and maximum acceptable value, we can put all that logic here.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们有一个简单的验证类，用于检查年份是否适合我们的汽车。如果我们想在这里添加更多逻辑，例如检查最小和最大可接受值，我们可以将所有这些逻辑都放在这里。
- en: 'Run the following command again and see whether the tests pass:'
  id: totrans-223
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 再次运行以下命令，看看测试是否通过：
- en: '[PRE68]'
  id: totrans-224
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'You should see the following result:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该看到以下结果：
- en: '![Figure 8.7 – Simple date validation test](img/Figure_8.07_B18318.jpg)'
  id: totrans-226
  prefs: []
  type: TYPE_IMG
  zh: '![图8.7 – 简单日期验证测试](img/Figure_8.07_B18318.jpg)'
- en: Figure 8.7 – Simple date validation test
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.7 – 简单日期验证测试
- en: 'Now that we have passed the very simple test for the year validator, next,
    let’s move on to the name validator:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经通过了年份验证器的非常简单的测试，接下来，让我们继续到名称验证器：
- en: 'Create the following test class with the following content:'
  id: totrans-229
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建以下测试类，内容如下：
- en: codebase/symfony/tests/Unit/Validator/NameValidatorTest.php
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: codebase/symfony/tests/Unit/Validator/NameValidatorTest.php
- en: '[PRE69]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'As with the year validator, if you run this test now, you will encounter multiple
    errors, but we have to make sure that it does fail or error out. Run the following
    command:'
  id: totrans-232
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 与年份验证器一样，如果你现在运行这个测试，你会遇到多个错误，但我们必须确保它确实失败或出错。运行以下命令：
- en: '[PRE70]'
  id: totrans-233
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'After running the command, you should see five errors. That’s okay. Let’s build
    the solution code for it now. Create the following class with the following content:'
  id: totrans-234
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行命令后，你应该看到五个错误。这没关系。现在让我们为它构建解决方案代码。创建以下类，内容如下：
- en: codebase/symfony/src/Validator/NameValidator.php
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: codebase/symfony/src/Validator/NameValidator.php
- en: '[PRE71]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'Now, we have a simple logic to validate a name. Let’s run the name validator
    test again, and see whether it passes. Run the following command again:'
  id: totrans-237
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们有一个简单的逻辑来验证名称。让我们再次运行名称验证器测试，看看它是否通过。再次运行以下命令：
- en: '[PRE72]'
  id: totrans-238
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE72]'
- en: You should now see five passing tests.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 你现在应该看到五个通过测试。
- en: Let’s summarize what we have added so far. We created two new validation classes,
    and both are working as expected based on our unit tests – but how is this better
    than the first solution we created? How is this relevant to the OCP? Well, first
    we need to tie things together and pass the bigger `ToyCarValidatorTest`.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们总结一下到目前为止我们添加了什么。我们创建了两个新的验证类，并且根据我们的单元测试，它们都按预期工作 - 但这比我们最初创建的解决方案好在哪里？这与OCP有什么关系？首先，我们需要将这些事情联系起来，并通过更大的`ToyCarValidatorTest`。
- en: 'Let’s refactor the `ToyCarValidator` class with the following content:'
  id: totrans-241
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们使用以下内容重构`ToyCarValidator`类：
- en: codebase/symfony/src/Validator/ToyCarValidator.php
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: codebase/symfony/src/Validator/ToyCarValidator.php
- en: '[PRE73]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: Then, generate the accessors and mutators for the `$``validators` property.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，为`$validators`属性生成访问器和修改器。
- en: 'You will notice that in the constructor, we are instantiating two validator
    classes, and within the validate method, we are using those validator classes.
    Each validator class will then have its own custom logic on how to run the validate
    method. Now, refactor the following test class with the following content:'
  id: totrans-245
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你会注意到在构造函数中，我们实例化了两个验证类，在`validate`方法中使用了这些验证类。每个验证类都将有自己的自定义逻辑来运行`validate`方法。现在，使用以下内容重构以下测试类：
- en: codebase/symfony/tests/Unit/Validator/ToyCarValidatorTest.php
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: codebase/symfony/tests/Unit/Validator/ToyCarValidatorTest.php
- en: '[PRE74]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'Now, in this test, we are checking for the validity of the entire toy car model
    object, as well as checking which specific field of the toy car model has passed
    or failed the validation. Let’s see whether the test passes. Run the following
    command:'
  id: totrans-248
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，在这个测试中，我们正在检查整个玩具车模型对象的合法性，以及检查玩具车模型的具体字段是否通过了或未通过验证。让我们看看测试是否通过。运行以下命令：
- en: '[PRE75]'
  id: totrans-249
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'Now, you should see the following result:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你应该看到以下结果：
- en: '![Figure 8.8 – Passing toy car validation test](img/Figure_8.08_B18318.jpg)'
  id: totrans-251
  prefs: []
  type: TYPE_IMG
  zh: '![图 8.8 - 通过的玩具车验证测试](img/Figure_8.08_B18318.jpg)'
- en: Figure 8.8 – Passing toy car validation test
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.8 – 通过的玩具车验证测试
- en: You will notice that we passed three assertions. It looks like we are starting
    to get a test with more responsibilities. It’s still better to do one assertion
    per test, just so that we don’t end up having a god test class! For now, we’ll
    move on.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 你会注意到我们通过了三个断言。看起来我们开始得到一个具有更多职责的测试。仍然最好每个测试只做一条断言，这样我们才不会最终得到一个糟糕的测试类！现在，我们将继续前进。
- en: Now, what have we achieved by refactoring? Well, first, we no longer have the
    validation logic for checking the validity of the toy name inside the `ToyCarValidatorTest`
    class. Second, we can now check for the validity of the year. If we want to improve
    the date and name validation logic, we won’t have to do it in the main `ToyCarValidator`
    class – but what if we want to add more validator classes? Such as a `ToyColorValidator`
    class? Well, we can still do that without even touching the main class! We’ll
    refactor `ToyCarValidator` and discuss how to do so later in the chapter in the
    *TDD with the Dependency Inversion* *Principle* section.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，通过重构，我们取得了什么成果？首先，我们不再需要在 `ToyCarValidatorTest` 类中检查玩具名称的合法性验证逻辑。其次，我们现在可以检查年份的合法性。如果我们想改进日期和名称验证逻辑，我们不需要在主要的
    `ToyCarValidator` 类中做这件事——但如果我们想添加更多的验证器类呢？比如一个 `ToyColorValidator` 类？嗯，我们仍然可以做到，甚至不需要触及主类！我们将重构
    `ToyCarValidator`，并在本章的 *TDD 与依赖倒置原则* 部分稍后讨论如何做。
- en: But what if we want to change the entire behavior of the `ToyCarValidator.php`
    class we created and change the logic entirely? Well, there’s no need to modify
    it – we can just replace the entire `ToyCarValidator.php` class with a different
    concrete implementation of the `ToyCarValidatorInterface` interface!
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 但如果我们想改变我们创建的 `ToyCarValidator.php` 类的整个行为并完全改变逻辑呢？嗯，没有必要修改它——我们只需用 `ToyCarValidatorInterface`
    接口的不同具体实现来替换整个 `ToyCarValidator.php` 类！
- en: Next, we’ll talk about the **Liskov Substitution** **Principle** (**LSP**).
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将讨论 **Liskov 替换原则**（**LSP**）。
- en: TDD with the Liskov Substitution Principle
  id: totrans-257
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Liskov 替换原则进行 TDD
- en: The LSP was introduced by Barbara Liskov. The way that I use it is that an implementation
    of an interface should be replaceable with another implementation of that interface
    without changing the behavior. If you are extending a superclass, the child class
    must be able to substitute the superclass without breaking the behavior.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: LSP 是由 Barbara Liskov 提出的。我使用它的方式是，一个接口的实现应该可以用另一个接口的实现替换，而不会改变行为。如果你正在扩展一个超类，子类必须能够替换超类而不破坏行为。
- en: In this example, let’s try adding a business rule to reject toy car models that
    were built on or before 1950.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，让我们尝试添加一个业务规则来拒绝在 1950 年或之前建造的玩具车模型。
- en: 'As usual, let’s start with a test:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 如往常一样，让我们从测试开始：
- en: 'Open the `YearValidatorTest.php` class we created earlier and modify the test
    class with the following:'
  id: totrans-261
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开我们之前创建的 `YearValidatorTest.php` 类，并使用以下内容修改测试类：
- en: codebase/symfony/tests/Unit/Validator/YearValidatorTest.php
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: codebase/symfony/tests/Unit/Validator/YearValidatorTest.php
- en: '[PRE76]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: We added a new test so that we check for `ToyCarTooOldException`. Let’s add
    this exception class as well, but first, let’s run the test.
  id: totrans-264
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们添加了一个新的测试，以便我们检查 `ToyCarTooOldException`。让我们也添加这个异常类，但首先，让我们运行测试。
- en: 'Run the following command:'
  id: totrans-265
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行以下命令：
- en: '[PRE77]'
  id: totrans-266
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE77]'
- en: 'Now you will see four errors. That’s okay. Now, let’s add the missing exception
    class:'
  id: totrans-267
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在你将看到四个错误。这是可以的。现在，让我们添加缺失的异常类：
- en: codebase/symfony/src/Validator/ToyCarTooOldException.php
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: codebase/symfony/src/Validator/ToyCarTooOldException.php
- en: '[PRE78]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: As you can see, it’s just a simple exception class that extends the main PHP
    `\``Exception` class.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所见，它只是一个简单的异常类，它扩展了主要的 PHP `\Exception` 类。
- en: If we run the test again, we should now pass the test, as we have told PHPUnit
    that we are expecting exceptions for this test by using the `$``this->expectException()`
    method.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们再次运行测试，现在我们应该通过测试，因为我们已经通过使用 `$this->expectException()` 方法告诉 PHPUnit 我们期望这个测试抛出异常。
- en: 'Run the following command:'
  id: totrans-272
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行以下命令：
- en: '[PRE79]'
  id: totrans-273
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE79]'
- en: 'Now, we should be able to pass the test – you should see the following result:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们应该能够通过测试 - 你应该看到以下结果：
- en: '![Figure 8.9 – Passing the old car rejection test](img/Figure_8.09_B18318.jpg)'
  id: totrans-275
  prefs: []
  type: TYPE_IMG
  zh: '![图8.9 – 通过旧车拒绝测试](img/Figure_8.09_B18318.jpg)'
- en: Figure 8.9 – Passing the old car rejection test
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.9 – 通过旧车拒绝测试
- en: This means that we are correctly throwing the `ToyCarTooOldException` object
    whenever we submit a year that is less than or equal to 1950 – but what will happen
    to our `ToyCarValidatorTest`?
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着每次我们提交一个小于或等于1950年的年份时，我们都会正确地抛出`ToyCarTooOldException`对象 - 但我们的`ToyCarValidatorTest`会发生什么？
- en: 'Let’s modify the test data with a year less than 1950 and see what happens:'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们修改测试数据，年份小于1950年，看看会发生什么：
- en: 'Modify the data provider content with the following:'
  id: totrans-279
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下内容修改数据提供者内容：
- en: codebase/symfony/tests/Unit/Validator/ToyCarValidatorTest.php
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: codebase/symfony/tests/Unit/Validator/ToyCarValidatorTest.php
- en: '[PRE80]'
  id: totrans-281
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: 'Now, run the following command and see what happens:'
  id: totrans-282
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，运行以下命令并查看会发生什么：
- en: '[PRE81]'
  id: totrans-283
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE81]'
- en: 'You will notice that we have failed the test with the following message:'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 你会注意到我们用以下消息失败了测试：
- en: '![Figure 8.10 – Failed toy car validation](img/Figure_8.10_B18318.jpg)'
  id: totrans-285
  prefs: []
  type: TYPE_IMG
  zh: '![图8.10 – 玩具车验证失败](img/Figure_8.10_B18318.jpg)'
- en: Figure 8.10 – Failed toy car validation
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.10 – 玩具车验证失败
- en: Now, we can see that we have an uncaught exception. Our `ToyCarValidator` program
    is not programmed to handle this exception object. Why is that? Well, the interface
    in this example is the `codebase/symfony/src/Validator/ValidatorInterface.php`
    interface. This interface throws a `ToyCarValidationException` object. The problem
    now is that our implementing class, the `YearValidator.php` class, throws a different
    exception compared to its contract or interface. Therefore, it breaks the behavior.
    To fix this problem, we simply need to throw the correct exception as declared
    in the interface.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以看到我们有一个未捕获的异常。我们的`ToyCarValidator`程序没有编写来处理这个异常对象。为什么是这样呢？嗯，这个例子中的接口是`codebase/symfony/src/Validator/ValidatorInterface.php`接口。这个接口抛出一个`ToyCarValidationException`对象。现在的问题是，我们的实现类，即`YearValidator.php`类，抛出的异常与其合同或接口不同。因此，它破坏了行为。为了解决这个问题，我们只需要抛出接口中声明的正确异常。
- en: 'Let’s modify the `ToyCarTooOldException` class:'
  id: totrans-288
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们修改`ToyCarTooOldException`类：
- en: codebase/symfony/src/Validator/ToyCarTooOldException.php
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: codebase/symfony/src/Validator/ToyCarTooOldException.php
- en: '[PRE82]'
  id: totrans-290
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: As you can see, we simply replaced the class it extends to `ToyCarValidationException`.
    The `ToyCarValidator.php` class is designed to catch this exception.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，我们只是将继承的类替换为`ToyCarValidationException`。`ToyCarValidator.php`类被设计用来捕获这个异常。
- en: 'Now, let’s run the test by running the following command and see whether it
    really works:'
  id: totrans-292
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们运行以下命令来执行测试，看看它是否真的起作用：
- en: '[PRE83]'
  id: totrans-293
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE83]'
- en: 'We should now pass the test and see the following result:'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在应该通过测试并看到以下结果：
- en: '![Figure 8.11 – Passing the toy car validator test, with old car validation](img/Figure_8.11_B18318.jpg)'
  id: totrans-295
  prefs: []
  type: TYPE_IMG
  zh: '![图8.11 – 通过玩具车验证器测试，使用旧车验证](img/Figure_8.11_B18318.jpg)'
- en: Figure 8.11 – Passing the toy car validator test, with old car validation
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.11 – 通过玩具车验证器测试，使用旧车验证
- en: 'Now that we are passing the test again, let’s see what is being returned by
    our `ToyCarValidator` program. Remember the shell scripts we wrote back in [*Chapter
    5*](B18318_05.xhtml#_idTextAnchor070), *Unit Testing*? Let’s use one of them.
    Put a breakpoint in `codebase/symfony/tests/Unit/Validator/ToyCarValidatorTest.php`
    at line **23**. Then, run the following command:'
  id: totrans-297
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们再次通过测试，让我们看看我们的`ToyCarValidator`程序返回了什么。还记得我们之前在[*第5章*](B18318_05.xhtml#_idTextAnchor070)，*单元测试*中写的shell脚本吗？让我们使用其中一个。在`codebase/symfony/tests/Unit/Validator/ToyCarValidatorTest.php`的第**23**行设置一个断点。然后，运行以下命令：
- en: '[PRE84]'
  id: totrans-298
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE84]'
- en: 'Inspect the `$result` variable, and you should see the following content:'
  id: totrans-299
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 检查`$result`变量，你应该看到以下内容：
- en: '![Figure 8.12 – Validation model](img/Figure_8.12_B18318.jpg)'
  id: totrans-300
  prefs: []
  type: TYPE_IMG
  zh: '![图8.12 – 验证模型](img/Figure_8.12_B18318.jpg)'
- en: Figure 8.12 – Validation model
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.12 – 验证模型
- en: You can see that our `ToyCarValidator`’s validate method returns a `ValidationModel`
    object. It gives a summary of the fields we validated for, as well as the exception
    message for the `year` field.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到我们的`ToyCarValidator`的validate方法返回一个`ValidationModel`对象。它总结了我们对哪些字段进行了验证，以及`year`字段的异常消息。
- en: We’ve seen how interfaces can be useful, but sometimes they become too powerful.
    Next, we’ll talk about the **Interface Segregation Principle** (**ISP**) to help
    stop this from happening.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到了接口如何有用，但有时它们变得过于强大。接下来，我们将讨论**接口分离原则（ISP**）来帮助防止这种情况发生。
- en: TDD with the Interface Segregation Principle
  id: totrans-304
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 基于接口分离原则的TDD
- en: Interfaces are very helpful, but sometimes it can be very easy to pollute them
    with capabilities that are not really supposed to be a part of the interface.
    I used to encounter this violation a lot. I was asking myself how I kept on creating
    empty methods with to-do comments, only to find classes a few months or years
    later, still with those to-do comments and the methods still empty.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 接口非常有用，但有时很容易让它们充满那些实际上不应该成为接口一部分的功能。我经常遇到这种违规行为。我一直在想，我怎么能一直创建带有待办注释的空方法，几个月或几年后，发现这些类仍然带有那些待办注释，方法仍然是空的。
- en: I used to touch my interfaces first and stuff them with all the methods I thought
    I needed. Then, when I finally wrote the concrete implementations, these concrete
    classes mostly had empty methods in them.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 我过去总是先触摸接口，然后把所有我认为需要的功能都塞进去。然后，当我最终编写具体的实现时，这些具体的类大多数都是空方法。
- en: An interface should only have methods that are specific to that interface. If
    there’s a method in there that is not entirely related to that interface, you
    need to segregate it into a different interface.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 一个接口应该只包含与该接口特定的方法。如果其中有一个方法与该接口完全不相关，你需要将其分离到不同的接口中。
- en: 'Let’s see that in action. Again, let’s start with a – you guessed it right
    – test:'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看它是如何工作的。再次，让我们从一个——你猜对了——测试开始：
- en: 'Open the `codebase/symfony/tests/Unit/Validator/NameValidatorTest.php` test
    class and add the following content:'
  id: totrans-309
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`codebase/symfony/tests/Unit/Validator/NameValidatorTest.php`测试类，并添加以下内容：
- en: '[PRE85]'
  id: totrans-310
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE85]'
- en: '[PRE86]'
  id: totrans-311
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE86]'
- en: '[PRE87]'
  id: totrans-312
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE87]'
- en: '[PRE88]'
  id: totrans-313
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE88]'
- en: '[PRE89]'
  id: totrans-314
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE89]'
- en: '[PRE90]'
  id: totrans-315
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE90]'
- en: '[PRE91]'
  id: totrans-316
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE91]'
- en: '[PRE92]'
  id: totrans-317
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE92]'
- en: '[PRE93]'
  id: totrans-318
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE93]'
- en: '[PRE94]'
  id: totrans-319
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE94]'
- en: '[PRE95]'
  id: totrans-320
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE95]'
- en: '[PRE96]'
  id: totrans-321
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE96]'
- en: '[PRE97]'
  id: totrans-322
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE97]'
- en: '[PRE98]'
  id: totrans-323
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE98]'
- en: '[PRE99]'
  id: totrans-324
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE99]'
- en: '[PRE100]'
  id: totrans-325
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE100]'
- en: '[PRE101]'
  id: totrans-326
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE101]'
- en: '[PRE102]'
  id: totrans-327
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE102]'
- en: '[PRE103]'
  id: totrans-328
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE103]'
- en: '[PRE104]'
  id: totrans-329
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE104]'
- en: '[PRE105]'
  id: totrans-330
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE105]'
- en: '[PRE106]'
  id: totrans-331
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE106]'
- en: We introduced a new function in the test called `validateLength`, which is common
    for strings. We also added a very long name, and we set `false` to be expected
    to be returned in the data provider.
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在测试中引入了一个新的函数`validateLength`，这是字符串共有的。我们还添加了一个非常长的名字，并将`false`设置为在数据提供者中期望返回的值。
- en: 'Run the following test:'
  id: totrans-333
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行以下测试：
- en: '[PRE107]'
  id: totrans-334
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE107]'
- en: You should get an error, as we have not created the new method yet.
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该会得到一个错误，因为我们还没有创建新的方法。
- en: 'Now, open the `ValidatorInterface.php` interface and add the `validateLength`
    method we are expecting to have in our test:'
  id: totrans-336
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，打开`ValidatorInterface.php`接口，并添加我们期望在测试中拥有的`validateLength`方法：
- en: codebase/symfony/src/Validator/ValidatorInterface.php
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: codebase/symfony/src/Validator/ValidatorInterface.php
- en: '[PRE108]'
  id: totrans-338
  prefs: []
  type: TYPE_PRE
  zh: '[PRE108]'
- en: 'Great – now we have the contract for validating a string’s length. If we go
    back to the `NameValidator.php` class, we’ll get the following error from the
    IDE:'
  id: totrans-339
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 太好了——现在我们有了验证字符串长度的合约。如果我们回到`NameValidator.php`类，IDE会显示以下错误：
- en: '![Figure 8.13 – Must implement the method](img/Figure_8.13_B18318.jpg)'
  id: totrans-340
  prefs: []
  type: TYPE_IMG
  zh: '![图8.13 – 必须实现的方法](img/Figure_8.13_B18318.jpg)'
- en: Figure 8.13 – Must implement the method
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.13 – 必须实现的方法
- en: Obviously, we need to implement the `validateLength` method for the `NameValidator.php`
    class, which is okay, as we want to validate the string length – but what would
    happen if we also wanted to create a validator for the `ToyCar` model’s color?
    The `ToyCar` model’s color property expects a `ToyColor.php` object, not a string!
    Therefore, the solution is to delete the `validateLength` method from `ValidatorInterface`.
    Certain classes will implement `ValidatorInterface` without the need to implement
    this logic. What we can do instead is create a new interface called the `StringValidator`
    interface that can have the `validateLength` method.
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，我们需要为`NameValidator.php`类实现`validateLength`方法，这是可以接受的，因为我们想验证字符串长度——但如果我们也想为`ToyCar`模型的颜色创建一个验证器呢？`ToyCar`模型的颜色属性期望一个`ToyColor.php`对象，而不是一个字符串！因此，解决方案是从`ValidatorInterface`中删除`validateLength`方法。某些类将不需要实现此逻辑即可实现`ValidatorInterface`。我们可以做的是创建一个新的接口，称为`StringValidator`接口，它可以包含`validateLength`方法。
- en: 'Refactor the `codebase/symfony/src/Validator/ValidatorInterface.php` interface
    and delete the `validateLength` method we just added, and create the following
    file with the following content:'
  id: totrans-343
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 重构`codebase/symfony/src/Validator/ValidatorInterface.php`接口，并删除我们刚刚添加的`validateLength`方法，并创建以下文件，内容如下：
- en: codebase/symfony/src/Validator/StringValidatorInterface.php
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: codebase/symfony/src/Validator/StringValidatorInterface.php
- en: '[PRE109]'
  id: totrans-345
  prefs: []
  type: TYPE_PRE
  zh: '[PRE109]'
- en: At this stage, we have segregated the `validateLength` method into a separate
    interface, removing it from the `ValidatorInterface.php` interface.
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个阶段，我们将`validateLength`方法分离到一个单独的接口中，从`ValidatorInterface.php`接口中移除了它。
- en: 'Now, open the `NameValidator.php` class, and refactor it with the following
    content:'
  id: totrans-347
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，打开`NameValidator.php`类，并使用以下内容重构它：
- en: codebase/symfony/src/Validator/NameValidator.php
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: codebase/symfony/src/Validator/NameValidator.php
- en: '[PRE110]'
  id: totrans-349
  prefs: []
  type: TYPE_PRE
  zh: '[PRE110]'
- en: 'We have refactored the `NameValidator` class so that it now also checks for
    the name’s length. Let’s run the test and see whether it passes:'
  id: totrans-350
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们已经重构了`NameValidator`类，使其现在也检查名称的长度。让我们运行测试，看看它是否通过：
- en: '[PRE111]'
  id: totrans-351
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE111]'
- en: 'Now, you should see the following result:'
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你应该能看到以下结果：
- en: '![Figure 8.14 – Passing the string length validation test](img/Figure_8.14_B18318.jpg)'
  id: totrans-353
  prefs: []
  type: TYPE_IMG
  zh: '![图8.14 – 通过字符串长度验证测试](img/Figure_8.14_B18318.jpg)'
- en: Figure 8.14 – Passing the string length validation test
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.14 – 通过字符串长度验证测试
- en: What we did is instead of combining different methods into `ValidatorInterface`,
    we segregated them into two different interfaces. Then, we only implement the
    `StringValidator` interface for the validator objects that will need this `validateLength`
    method. That’s basically what the ISP is all about. This is a very basic example,
    but it is very easy to fall victim to these very powerful interfaces if you don’t
    watch out.
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 我们所做的是，不是将不同的方法组合到`ValidatorInterface`中，而是将它们分成了两个不同的接口。然后，我们只为需要这个`validateLength`方法的验证器对象实现`StringValidator`接口。这基本上就是ISP（接口隔离原则）的全部内容。这是一个非常基础的例子，但如果你不留意，很容易就会成为这些非常强大的接口的受害者。
- en: Next, we will go back to the `ToyCarValidator` class and see how we can improve
    what we had earlier in the *TDD with the Open-Closed Principle* example, using
    the **Dependency Inversion** **Principle** (**DIP**).
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将回到`ToyCarValidator`类，看看我们如何可以在*使用开放-封闭原则的TDD*示例中改进我们之前的内容。
- en: TDD with the Dependency Inversion Principle
  id: totrans-357
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用依赖倒置原则的TDD
- en: In terms of making a class more testable, the DIP is probably the most important
    principle on the list for me. The DIP suggests that details should depend on abstractions.
    To me, this means that the specifics of a program that does not really belong
    to a class should be abstracted. The DIP allows us as developers to remove a concrete
    implementation of a routine or program and put it in a different object altogether.
    We can then use the DIP to inject the object that we need, whenever we need it.
    We can inject the object that we need in the constructor, passed as an argument
    upon class instantiation, or simply expose a mutator function.
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 在使一个类更易于测试方面，DIP（依赖倒置原则）可能是列表中对我最重要的原则。DIP建议细节应该依赖于抽象。对我来说，这意味着不属于类的程序的具体细节应该被抽象化。DIP允许我们作为开发者移除一个程序或例程的具体实现，并将其放入一个完全不同的对象中。然后我们可以使用DIP在需要的时候注入所需的对象。我们可以在构造函数中注入对象，作为类实例化时的参数传递，或者简单地暴露一个修改器函数。
- en: Let’s revisit the `ToyCarValidator` class that we created earlier in this chapter
    to see how we can implement the DIP.
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回顾一下本章早期创建的`ToyCarValidator`类，看看我们如何可以实施DIP（依赖倒置原则）。
- en: '**How will this look in** **our code?**'
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: '**在我们的代码中这会是什么样子？**'
- en: 'Going back to the `ToyCarValidator.php` class, you will notice that in the
    `__constructor` method, we have instantiated two classes:'
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 回到`ToyCarValidator.php`类，你会在`__constructor`方法中注意到，我们实例化了两个类：
- en: '![Figure 8.15 – Hardcoded dependencies](img/Figure_8.15_B18318.jpg)'
  id: totrans-362
  prefs: []
  type: TYPE_IMG
  zh: '![图8.15 – 硬编码的依赖关系](img/Figure_8.15_B18318.jpg)'
- en: Figure 8.15 – Hardcoded dependencies
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.15 – 硬编码的依赖关系
- en: 'How can we improve this? Well, this program works – as you have seen, we are
    passing `ToyCarValidatorTest`. The only problem is that our `ToyCarValidator`
    class is now hardcoded to its dependencies – the `YearValidator` and `NameValidator`
    classes. What if we want to replace these classes – or what if we want to add
    more validators? Well, what we can do is remove the dependency from inside of
    the class. Follow these steps:'
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 我们如何改进这个？嗯，这个程序是工作的——正如你所看到的，我们正在传递`ToyCarValidatorTest`。唯一的问题是我们的`ToyCarValidator`类现在硬编码到了它的依赖中——`YearValidator`和`NameValidator`类。如果我们想替换这些类——或者如果我们想添加更多的验证器呢？嗯，我们可以从类内部移除这个依赖。按照以下步骤操作：
- en: 'Refactor the following test class, and replace the `testCanValidate` method
    with the following content:'
  id: totrans-365
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 重构以下测试类，并将`testCanValidate`方法替换为以下内容：
- en: codebase/symfony/tests/Unit/Validator/ToyCarValidatorTest.php
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: codebase/symfony/tests/Unit/Validator/ToyCarValidatorTest.php
- en: '[PRE112]'
  id: totrans-367
  prefs: []
  type: TYPE_PRE
  zh: '[PRE112]'
- en: You will notice that the objects that `ToyCarValidator` depends on are now being
    instantiated outside the `ToyCarValidator` class – and we then set the validators
    using the `setValidators` mutator.
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 你会注意到，`ToyCarValidator`所依赖的对象现在是在`ToyCarValidator`类外部实例化的——然后我们使用`setValidators`修改器设置验证器。
- en: 'Now, remove the hardcoded validator instantiations from the `ToyCarValidator`’s
    constructor:'
  id: totrans-369
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，从`ToyCarValidator`的构造函数中移除硬编码的验证器实例化：
- en: codebase/symfony/src/Validator/ToyCarValidator.php
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: codebase/symfony/src/Validator/ToyCarValidator.php
- en: '[PRE113]'
  id: totrans-371
  prefs: []
  type: TYPE_PRE
  zh: '[PRE113]'
- en: 'We no longer have the hardcoded validator instantiations – now, let’s run the
    test and see whether the tests still pass:'
  id: totrans-372
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们不再有硬编码的验证器实例化——现在，让我们运行测试，看看测试是否仍然通过：
- en: '[PRE114]'
  id: totrans-373
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE114]'
- en: After running the command, you should see that the tests still pass. At this
    point, we can keep creating new validators and just add them to the array of validators
    we want to inject into the `ToyCarValidator.php` class.
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 运行命令后，你应该看到测试仍然通过。在这个时候，我们可以继续创建新的验证器，并将它们添加到我们想要注入到`ToyCarValidator.php`类的验证器数组中。
- en: Now, open the `ToyCarCreator.php` class we created earlier in this chapter,
    and you’ll see that it’s already prepared to accept dependencies from the outside.
    We can also refactor the class so that we can automatically inject the dependencies
    it needs during instantiation.
  id: totrans-375
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，打开本章中我们创建的`ToyCarCreator.php`类，你会看到它已经准备好接受外部的依赖。我们还可以重构这个类，以便在实例化时自动注入它需要的依赖。
- en: 'Open the following test class and refactor it with the following content:'
  id: totrans-376
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开以下测试类，并使用以下内容进行重构：
- en: codebase/symfony/tests/Integration/Processor/ToyCarCreatorTest.php
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: codebase/symfony/tests/Integration/Processor/ToyCarCreatorTest.php
- en: '[PRE115]'
  id: totrans-378
  prefs: []
  type: TYPE_PRE
  zh: '[PRE115]'
- en: As you can see, we have instantiated the dependencies of the `ToyCarCreator.php`
    class and then injected them as a parameter when we instantiated the class in
    `ToyCarCreator($validatorStub, $toyWriterStub);`.
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，我们已经实例化了`ToyCarCreator.php`类的依赖，然后在`ToyCarCreator($validatorStub, $toyWriterStub);`中实例化类时将它们作为参数注入。
- en: 'Then, open the `ToyCarCreator.php` solution class and refactor it with the
    following content:'
  id: totrans-380
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，打开`ToyCarCreator.php`解决方案类，并使用以下内容进行重构：
- en: codebase/symfony/src/Processor/ToyCarCreator.php
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: codebase/symfony/src/Processor/ToyCarCreator.php
- en: '[PRE116]'
  id: totrans-382
  prefs: []
  type: TYPE_PRE
  zh: '[PRE116]'
- en: Upon instantiation, both the validator and writer dependencies are set through
    the constructor.
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: 在实例化时，验证器和编写器依赖项都通过构造函数设置。
- en: 'If we run the test, it should still pass:'
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们运行测试，它应该仍然通过：
- en: '[PRE117]'
  id: totrans-385
  prefs: []
  type: TYPE_PRE
  zh: '[PRE117]'
- en: After running the command, you should still see a passing test.
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: 运行命令后，你应该仍然看到通过测试。
- en: The most obvious thing that you will notice with this approach is that you will
    have to manage all the dependencies yourself and then inject them into the object
    that needs them. Luckily, we are not the first people to encounter this headache.
    There are a lot of service containers out there that help manage the dependencies
    that your application needs, but the most important thing when selecting a service
    container for PHP is that it should follow the PSR-11 standards. You can read
    more about PSR-11 at [https://www.php-fig.org/psr/psr-11/](https://www.php-fig.org/psr/psr-11/).
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这种方法最明显的事情是，你必须自己管理所有依赖，然后将它们注入到需要它们的对象中。幸运的是，我们不是第一个遇到这种头疼问题的人。有很多服务容器可以帮助管理应用程序需要的依赖，但在选择PHP服务容器时，最重要的是它应该遵循PSR-11标准。你可以在[https://www.php-fig.org/psr/psr-11/](https://www.php-fig.org/psr/psr-11/)了解更多关于PSR-11的信息。
- en: Summary
  id: totrans-388
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we’ve gone through the SOLID principles one by one. We used
    our tests to kickstart the development of our solution code so that we can use
    them as examples for implementing the SOLID principles in real life.
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们逐个介绍了SOLID原则。我们使用测试来启动解决方案代码的开发，以便我们可以将它们作为在现实生活中实现SOLID原则的示例。
- en: We have covered the SRP, which helped us make a PHP class’s responsibility or
    capability more focused. The OCP helped us avoid the need for touching or modifying
    a class in some instances when we want to change its behavior. The LSP helped
    us be stricter about the behavior of an interface, making it easier for us to
    switch concrete objects implementing that interface without breaking the parent
    class’s behavior. The ISP helped us make the responsibility of an interface more
    focused – classes that implement this interface will no longer have empty methods
    just because they were declared by the interface. The DIP helped us quickly test
    our `ToyCarCreator` class even without creating a concrete implementation of its
    dependencies, such as the `ToyCarValidator` class.
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经介绍了SRP（单一职责原则），它帮助我们使PHP类的职责或能力更加专注。OCP（开闭原则）帮助我们避免在某些情况下需要修改类的行为时，需要触及或修改类。LSP（里氏替换原则）帮助我们更严格地对待接口的行为，使得我们更容易在不破坏父类行为的情况下切换实现该接口的具体对象。ISP（接口隔离原则）帮助我们使接口的职责更加专注——实现此接口的类将不再因为接口的声明而拥有空方法。DIP（依赖倒置原则）帮助我们快速测试`ToyCarCreator`类，即使没有创建其依赖的具体实现，如`ToyCarValidator`类。
- en: When working on real-life projects, some principles are hard to strictly follow,
    and sometimes the boundaries are vague. Add the pressure of real-life deadlines
    and it gets even more interesting. One thing is for sure, using BDD and TDD will
    help you be more confident about the features you are developing, especially when
    you are already a few months deep into a project. Adding SOLID principles on top
    of that makes your solution even better!
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: 在实际项目工作中，一些原则很难严格遵循，有时边界也模糊不清。再加上现实生活中的截止日期压力，事情就变得更加有趣。有一点可以肯定，使用行为驱动开发（BDD）和技术驱动开发（TDD）将帮助您对自己的开发功能更有信心，尤其是在您已经深入一个项目几个月之后。在之上添加SOLID原则会使您的解决方案更加完善！
- en: In the next chapter, we will try to utilize automated tests to help us make
    sure that any code changes that any developer in your team pushes into your code
    repository will not break the expected behavior of your software. We will try
    to automate this process by using Continuous Integration.
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将尝试利用自动化测试来帮助我们确保任何开发者在将代码推送到您的代码仓库时，不会破坏软件预期的行为。我们将通过使用持续集成来自动化这一过程。
- en: Part 3 – Deployment Automation and Monitoring
  id: totrans-393
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第三部分 - 自动化部署和监控
- en: In this part of the book, you will learn how to utilize automated tests to improve
    and automate the code integration process, as well as automate the deployment
    process of an application. You will also learn how to monitor a PHP application
    after it’s been deployed.
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书的这一部分，您将学习如何利用自动化测试来改进和自动化代码集成过程，以及自动化应用程序的部署过程。您还将学习如何在应用程序部署后监控PHP应用程序。
- en: 'This section comprises the following chapters:'
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: 本节包括以下章节：
- en: '[*Chapter 9*](B18318_09.xhtml#_idTextAnchor138), *Continuous Integration*'
  id: totrans-396
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第9章*](B18318_09.xhtml#_idTextAnchor138)，*持续集成*'
- en: '[*Chapter 10*](B18318_10.xhtml#_idTextAnchor146), *Continuous Delivery*'
  id: totrans-397
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第10章*](B18318_10.xhtml#_idTextAnchor146)，*持续交付*'
- en: '[*Chapter 11*](B18318_11.xhtml#_idTextAnchor162), *Monitoring*'
  id: totrans-398
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第11章*](B18318_11.xhtml#_idTextAnchor162)，*监控*'
