- en: '*Chapter 10*: Creating Pimcore Bricks'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第10章*: 创建Pimcore砖块'
- en: In the previous chapter, we learned how to use Pimcore to create entities and
    render custom web pages. Previously, in [*Chapter 8*](B17073_08_ePub_RK.xhtml#_idTextAnchor139),
    *Creating Custom CMS Pages*, we discovered how to create CMS pages using the web
    interface or custom **Model View Controller** (**MVC**) pages. In both cases,
    we'd like to have some reusable components that can be defined once and used in
    every case by changing some settings. Think about a contact form widget that you
    can drag and drop on any web page. Well, these kinds of reusable components in
    Pimcore are called **Bricks**.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们学习了如何使用Pimcore创建实体并渲染自定义网页。之前，在[*第8章*](B17073_08_ePub_RK.xhtml#_idTextAnchor139)
    *创建自定义CMS页面*中，我们发现了如何使用Web界面或自定义**模型视图控制器**（**MVC**）页面创建CMS页面。在两种情况下，我们都希望有一些可重用的组件，这些组件可以定义一次，并在每次使用时通过更改一些设置来使用。想想看，你可以将其拖放到任何网页上的联系表单小部件。嗯，在Pimcore中，这类可重用组件被称为**砖块**。
- en: In this chapter, we will learn how to build reusable components that can be
    placed in CMS or MVC pages and, moreover, can be ported from project to project
    using bundles.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将学习如何构建可重用的组件，这些组件可以放置在CMS或MVC页面上，而且还可以通过包在不同的项目之间移植。
- en: 'This is our roadmap:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们的路线图：
- en: Creating a bundle
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个包
- en: Understanding how a Brick works
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解砖块的工作原理
- en: Implementing a simple Brick
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现一个简单的砖块
- en: Implementing a contact form Brick
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现联系表单砖块
- en: Implementing a Slideshow brick
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现幻灯片砖块
- en: Using bricks and blocks for a general-purpose template
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用砖块和块构建通用模板
- en: By the end of this chapter, you will have learned how to create custom interactive
    widgets to compose pages. This is important to cover all the needs of the users
    on your website.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，你将学会如何创建自定义交互式小部件来组合页面。这对于满足你网站上用户的所有需求非常重要。
- en: Let's start to discover bricks!
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始探索砖块！
- en: Technical requirements
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'As with the previous chapters, there is a demo that you can find on our GitHub
    repository here: https://github.com/PacktPublishing/Modernizing-Enterprise-CMS-using-Pimcore/.'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 就像前面的章节一样，这里有一个可以在我们的GitHub仓库中找到的演示：https://github.com/PacktPublishing/Modernizing-Enterprise-CMS-using-Pimcore/
- en: All you need to run the demo connected to this chapter is to clone it, then
    navigate to the `Full Demo` folder and start the Docker environment.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 要运行与本章相关的演示，你需要克隆它，然后导航到`Full Demo`文件夹并启动Docker环境。
- en: 'To do so, just follow these instructions:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 要这样做，只需遵循以下说明：
- en: 'Run Docker with the following command:'
  id: totrans-16
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下命令运行Docker：
- en: '[PRE0]'
  id: totrans-17
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Then, to restore all the settings from on your local machine, type the following:'
  id: totrans-18
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，为了从你的本地机器上恢复所有设置，请输入以下命令：
- en: '[PRE1]'
  id: totrans-19
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Navigate to [http://localhost/admin](http://localhost/admin) and log in with
    your admin/pimcore credentials.
  id: totrans-20
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导航到[http://localhost/admin](http://localhost/admin)并使用你的管理员/pimcore凭据登录。
- en: 'What you will get with this setup is the following:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 使用此设置，你将获得以下内容：
- en: A `BlogBundle` where you will find all the assets produced in this chapter
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个`BlogBundle`，在这里你可以找到本章产生的所有资源
- en: A fully working Pimcore instance, with data and configuration installed
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个完全工作的Pimcore实例，已安装数据和配置
- en: This project is a good reference, but after all the practice we have had with
    Pimcore, you could also start a project from scratch and try to replicate all
    the steps on your own.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 这个项目是一个很好的参考，但毕竟我们在Pimcore上已经有很多实践经验了，你也可以从头开始一个项目，并尝试自己复制所有步骤。
- en: Creating a bundle
  id: totrans-25
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建一个包
- en: Before starting our journey into bricks, we have to learn how to create a bundle.
    In [*Chapter 7*](B17073_07_ePub_RK.xhtml#_idTextAnchor129), *Administrating Pimcore
    Sites*, we learned how to install a bundle released from a vendor, but how do
    we build our own? In this section, we will learn how a bundle is structured and
    how you can build it. Bundles are very important for creating a portable set of
    features that you can reuse or distribute across websites. In our demo project,
    we will create a blog bundle that is self-contained and that you can pick and
    place on any of your websites.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始砖块之旅之前，我们必须学习如何创建一个包。在[*第7章*](B17073_07_ePub_RK.xhtml#_idTextAnchor129)
    *管理Pimcore站点*中，我们学习了如何安装来自供应商的包，但我们是怎样构建自己的呢？在本节中，我们将学习包的结构以及如何构建它。包对于创建一个可携带的功能集非常重要，你可以重用它或在网站之间分发。在我们的演示项目中，我们将创建一个自包含的博客包，你可以将其挑选并放置在你的任何网站上。
- en: What is a bundle?
  id: totrans-27
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 什么是包？
- en: 'You have used the main application for many examples in previous chapters.
    This is good for implementing the specific project but it is not portable. Talking
    simply, a bundle is a folder that contains both source code and templates. You
    can get this set of files by adding a composer dependency or by using a local
    folder. This lets you take your code and reuse it in multiple projects, or simply
    divide a complex application into modules. For simplicity, in this book, we will
    use a local folder inside the `bundles` path. Each subfolder will host a different
    bundle. In this chapter, we will cover all that is needed to start a blog, so
    we will create a `BlogBundle`. This means that we will have the `/bundles/BlogBundle`
    folder that will contain all the bundle-related files. This set of files is not
    discovered automatically; you have to add a specific configuration in your `composer.json`.
    In the next piece of code, there is the configuration for the blog bundle:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的章节中，您已经使用了主应用程序的许多示例。这对于实现特定项目来说很好，但它并不便携。简单来说，一个包是一个包含源代码和模板的文件夹。您可以通过添加
    composer 依赖项或使用本地文件夹来获取这个文件集。这使您可以将代码用于多个项目，或者简单地将复杂的应用程序划分为模块。为了简单起见，在这本书中，我们将使用
    `bundles` 路径内的本地文件夹。每个子文件夹将托管不同的包。在本章中，我们将涵盖启动博客所需的所有内容，因此我们将创建一个 `BlogBundle`。这意味着我们将有一个包含所有与包相关的文件的
    `/bundles/BlogBundle` 文件夹。这个文件集不是自动发现的；您必须在您的 `composer.json` 中添加特定的配置。在下一部分代码中，是博客包的配置：
- en: '[PRE2]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: As you can see in the previous snippet, the blog folder is added to the `psr-4`
    definition, just after the standard `src` that's mapped to the `App` namespace.
    In our case, we map the `BlogBundle` namespace with the `bundles/BlogBundle/`
    folder. Of course, you can play with this configuration and create your own setup
    to fit your needs. Anyway, we recommend keeping the configuration as close as
    possible to the Symfony standard.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 如您在前面的代码片段中所见，博客文件夹被添加到 `psr-4` 定义中，紧随标准 `src` 之后，它映射到 `App` 命名空间。在我们的情况下，我们将
    `BlogBundle` 命名空间映射到 `bundles/BlogBundle/` 文件夹。当然，您可以玩转这个配置，创建自己的设置以适应您的需求。无论如何，我们建议将配置尽可能接近
    Symfony 标准。
- en: 'Here is a list of folders and files inside a bundle:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是一个包内文件夹和文件的列表：
- en: '`/bundles/BlogBundle`: This is the bundle folder that contains all the bundle
    assets. The bundle is self-contained, so it contains all the resources (config,
    themes, and so on) and the classes.'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/bundles/BlogBundle`：这是包含所有包资源的包文件夹。包是自包含的，因此它包含所有资源（配置、主题等）和类。'
- en: '`DependencyInjection`: This contains two important files for configuring the
    bundle: `BlogExtension.php` (the convention is the name of the bundle without
    the `Bundle` word and then `Extension.php`) and `Configuration.php`.'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`DependencyInjection`：此目录包含配置包的两个重要文件：`BlogExtension.php`（约定是去掉 `Bundle` 单词的包名称然后加上
    `Extension.php`）和 `Configuration.php`。'
- en: '`Document/Areabrick`: This folder is used for `Brick` classes; we will look
    at it in detail in the next section.'
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Document/Areabrick`：此文件夹用于 `Brick` 类；我们将在下一节中详细探讨。'
- en: '`Controller`: This folder contains the controllers.'
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`控制器`：此文件夹包含控制器。'
- en: '`Resources`: This contains the following subfolders:'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`资源`：此目录包含以下子目录：'
- en: 'a) `config`: Where your YAML files are built.'
  id: totrans-37
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: a) `config`：您的 YAML 文件构建于此。
- en: 'b) `public`: Here you can load all the assets that will be published under
    `/bundles/{bundle name}/`, so if you add here a file called `script.js`, you will
    have it at [http://localhost/bundles/blog/script.js](http://localhost/bundles/blog/script.js).'
  id: totrans-38
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: b) `public`：在这里，您可以加载所有将在 `/bundles/{bundle name}/` 下发布的资源，因此如果您在这里添加一个名为 `script.js`
    的文件，您将可以在 [http://localhost/bundles/blog/script.js](http://localhost/bundles/blog/script.js)
    找到它。
- en: 'c) `views`: You can create here a subfolder containing templates for each controller.
    This folder also contains the `Areas` subfolder, which will have all the `Brick`
    templates.'
  id: totrans-39
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: c) `视图`：您可以在其中创建一个包含每个控制器模板的子文件夹。此文件夹还包含 `Areas` 子文件夹，其中将包含所有的 `Brick` 模板。
- en: Now it's time to create our first bundle!
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候创建我们的第一个包了！
- en: Creating a bundle from the command line
  id: totrans-41
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 从命令行创建包
- en: You could manually create the files and folders by using the naming convention.
    This is not hard, but it is easy to make some errors while doing it manually.
    Fortunately, we have a command from Pimcore that does the job for us.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过使用命名约定手动创建文件和文件夹。这并不难，但在手动操作时很容易出错。幸运的是，我们有一个来自 Pimcore 的命令可以为我们完成这项工作。
- en: In Symfony 5, this is no longer a built-in feature, so we have to install a
    bundle from Pimcore and then we can use the console to create a bundle skeleton.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
- en: 'Creating a bundle is very straightforward and will be explained in the next
    steps:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
- en: 'Enter your Docker instance using the following command:'
  id: totrans-45
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-46
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Install the bundle generator using the following command:'
  id: totrans-47
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-48
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The previous command will add the bundle and configure it for use as a regular
    console command.
  id: totrans-49
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Navigate to `config/bundles.php` and register the bundle using the following
    piece of code:'
  id: totrans-50
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-51
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Run the following command:'
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-53
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: This will create a set of folders and files for your bundle. The result after
    you run this command is the creation of the bundle with all the basic subfolders.
  id: totrans-54
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Moreover, in order to make the bundle content available for the application,
    we need to change our composer definition by adding a namespace mapping, as in
    the next example:'
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-56
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: After this step, you might need to run `chmod -R www-data.` for a permission
    fix. In the Docker example we provided, this is mandatory.
  id: totrans-57
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Now the bundle is available for the system and can be enabled and installed
    as explained in [*Chapter 3*](B17073_03_ePub_RK.xhtml#_idTextAnchor062), *Getting
    Started with Pimcore Admin UI*.
  id: totrans-58
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In this section, we learned how a bundle is composed and how to create a new
    one. Now that we have our bundle ready, we can start talking about bricks by using
    some practical examples.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
- en: Understanding how a Brick works
  id: totrans-60
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In simple words, a Brick is composed of a class that takes the place of the
    controller and a view. Building a Brick is not so different from implementing
    an MVC page. The most important exception is that, in this case, we do not have
    the routing part, as the Brick is added to an existing page (it cannot be run
    standalone). In the following diagram, we have a schema that explains how Bricks
    work:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.1: Conceptual schema for a brick'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_10.01_B17073.jpg)'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 10.1: Conceptual schema for a brick'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
- en: In the previous diagram, we can see that a page (**My Page**) can host many
    bricks. Each one is composed of a **Class** and two templates (**edit** and **view**).
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
- en: In the following sections, we will learn how to implement every single component,
    including classes and templates.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
- en: The class implementation
  id: totrans-67
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A brick is an instance of `Pimcore\Extension\Document\Areabrick\AreabrickInterface`,
    but for convenience, we always extend the `AbstractTemplateAreabrick` class, which
    implements the interface and gives us some interesting methods. These classes
    can be loaded manually or autoloaded using YAML files. Even if adding classes
    to YAML files is easy, it is always an additional step to do. So, we usually prefer
    the autoloading scenario, which simply requires us to use a default folder (`Document/Areabrick`)
    where we place the classes. The namespace of your class must be `namespace BlogBundle\Document\Areabrick`.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
- en: 'The following class implements a simple brick:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'As you can see in the preceding snippet, there are some methods that have to
    be implemented to provide the information for your components. These methods,
    highlighted in the code, are as follows:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
- en: '`getName`: This method returns the name of the brick (it should be unique).'
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`getDescription`: This method returns the long description of the brick and
    it is shown in the web interface to give the user an idea of what the brick does.'
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`getTemplateSuffix`: This method is used for defining the template extension
    (Twig or PHP). To adopt Twig templates instead of a PHP template, use `static::TEMPLATE_SUFFIX_TWIG`.'
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now that the class part is ready, we can see how to set up the templating in
    the next section.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
- en: Templating
  id: totrans-76
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Usually, for brick classes, the template follows a naming convention. The place
    where they have to be located is the `Areas` folder inside the view folder (`Resources/views`).
    Each brick must have its own folder, but the folder name must be in spinal case
    (all lowercase with hyphens between words, so `MyBrick` will need a folder named
    `my-brick`). The name of the view template has to be `view.html.twig`.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
- en: Some bricks are fully WYSIWYG, and you can change the component's behavior just
    by entering data. Others have the configuration separated by the rendering. In
    these cases, you can configure an edit popup that will prompt for data. We will
    see that configuration in detail with the next sections' examples.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
- en: 'In the next schema, we summarized the naming convention, adding a path example
    for each case. The **Global** scenario is the option where you add the brick to
    the main project (app folder) and the **Bundle** scenario is where you will add
    the brick to specific a bundle:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
- en: '**View path**:'
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'a) **Global**:'
  id: totrans-81
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-82
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'b) **Bundle**:'
  id: totrans-83
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-84
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '**Class**:'
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'a) **Global**:'
  id: totrans-86
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-87
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'b) **Bundle**:'
  id: totrans-88
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-89
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: In this section, we learn what a brick is composed of. This was important for
    understanding the naming convention and the principles for using them. Now it's
    time to go in depth with some examples! In the next section, we will cover the
    most important use cases, from easy to complex usage.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
- en: Implementing a simple brick
  id: totrans-91
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will implement our first brick. Because the spirit of this
    book is to learn using real-world examples, we won't limit this to a "hello world"
    example. In our first example, we will create a widget that could be placed many
    times on the page and reused. This widget will allow adding text, choosing the
    header type (h1, h2, and so on), and entering the text.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
- en: 'To complete this goal, we have to follow these steps:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
- en: Create a document and link it to a controller and a template file. We have done
    this step many times in [*Chapter 4*](B17073_04_ePub_RK.xhtml#_idTextAnchor083),
    *Creating Documents in Pimcore*, and [*Chapter 9*](B17073_09_ePub_RK.xhtml#_idTextAnchor166),
    *Configuring Entities and Rendering Data*. This document will be used for testing
    the brick that we are creating.
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create a `Heading.php` file inside `/bundles/BlogBundle/Document/Areabrick`.
    The contents of the file should be like this:'
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-96
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The code provided declares a brick called `Header` with a specific description.
    Now that we have the brick definition, we have to add a template for it. This
    will be our next step.
  id: totrans-97
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Add a template in `/bundles/BlogBundle/Resources/views/Areas` called `view.html.twig`.
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the following code to the file:'
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-100
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The code is divided into two branches. The first one is activated in edit mode
    and displays a select component that lets you choose the heading type (h1, h2,
    and so on) and the text; the second branch of code displays the data wrapping
    text in the header. All we need to implement our first brick is done; we just
    have to test it now.
  id: totrans-101
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Inside the template that was created in *Step 1*, add the following snippet:'
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-103
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'This editable will display the following component in edit mode:'
  id: totrans-104
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 10.2: Editable components'
  id: totrans-105
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '](img/Figure_10.02_B17073.jpg)'
  id: totrans-106
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Figure 10.2: Editable components'
  id: totrans-107
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: This component is just a placeholder that will let us choose a brick from the
    brick list and will put it inside the page. We will do this in the next step.
  id: totrans-108
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Click on the plus button. It will display the following menu:![Figure 10.3:
    The menu for Areablock'
  id: totrans-109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/Figure_10.03_B17073.jpg)'
  id: totrans-110
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Figure 10.3: The menu for Areablock'
  id: totrans-111
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: As you can see in the preceding screenshot, the data we entered into the class
    is used to distinguish the component. In fact, we chose **Header** as the brick
    name and **A component for rendering a Header** as the description.
  id: totrans-112
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Click on the `My H1 text` into the box:![Figure 10.4: The heading brick editing'
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/Figure_10.04_B17073.jpg)'
  id: totrans-114
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Figure 10.4: The heading brick editing'
  id: totrans-115
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Now click the **Preview** button or navigate to the page. The output will be
    the following:'
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 10.5: The output of the brick'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_10.05_B17073.jpg)'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 10.5: The output of the brick'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
- en: The page displays the text we chose properly.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
- en: This first example shows how simple it is to create a reusable component in
    Pimcore. In fact, we can use the heading brick on every page, giving the user
    the power of picking it when needed and configuring it. You can use this in conjunction
    with **blocks** to allow the user to choose a sequence of custom elements or hardcode
    it in a template. Moreover, we can also use an interactive brick. We will discover
    all these features in the next sections.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
- en: Implementing a contact form brick
  id: totrans-122
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this example, we will discover how to create an interactive component where
    the user can insert data. For this purpose, we will create a contact form. The
    behavior of this widget will be straightforward: we will have a form with a subject,
    name, message, and clickable button. An email will be sent to a fixed recipient
    address once the details are filled in and the button is clicked. This example
    will also introduce a working example of opening the brick''s editor to get parameters
    not shown in the view. Follow these steps to implement the example:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
- en: First, create a document with a template and place an `areabrick` in the editable's
    template. In the next step, we will have to create the brick.
  id: totrans-124
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，使用模板创建一个文档，并在可编辑的模板中放置一个 `areabrick`。在下一步中，我们将必须创建砖。
- en: 'Create the `ContactForm.php` file in `/bundles/BlogBundle/Document/Areabrick/`.
    The content will be as follows:'
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `/bundles/BlogBundle/Document/Areabrick/` 中创建 `ContactForm.php` 文件。内容如下：
- en: '[PRE16]'
  id: totrans-126
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Now we need to ask the user to add the recipient address for the contact form.
    In a complex scenario, you may need to add more parameters and organize them.
    This is possible by implementing a special `EditableDialogBoxInterface` interface.
    In the next piece of code, we can see the code that we have to add:'
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们需要要求用户为联系表单添加收件人地址。在复杂场景中，您可能需要添加更多参数并对其进行组织。这可以通过实现特殊的 `EditableDialogBoxInterface`
    接口来实现。在下一段代码中，我们可以看到必须添加的代码：
- en: '[PRE17]'
  id: totrans-128
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The configuration is, in fact, an array of items that can be grouped in a container.
    In our case, we used a tab pane, and we placed the input inside it. This array
    will be used to automatically generate the user''s input form. Entered data will
    be available to the user as regular editables, as in the following snippet:'
  id: totrans-129
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 实际上，配置是一个可以分组到容器中的项目数组。在我们的案例中，我们使用了选项卡面板，并将输入放置在其中。此数组将用于自动生成用户的输入表单。输入的数据将以常规可编辑的形式提供给用户，如下面的代码片段所示：
- en: '[PRE18]'
  id: totrans-130
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Create the `view.html.twig` file. This file will contain all the content that
    will be displayed to the user. In the next snippet of code, we have a simplified
    version of the form for brevity (the full bootstrap example is in the source code
    related to this book):'
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建 `view.html.twig` 文件。此文件将包含将显示给用户的全部内容。在下一个代码片段中，为了简洁，我们提供了一个简化的表单（完整的 bootstrap
    示例在本书相关的源代码中）：
- en: '[PRE19]'
  id: totrans-132
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The template contains an alert message, which is a message used to confirm sending
    the email to the user or to display an error. The form contains the input for
    getting the field from the user and a submit button. The action is not specified,
    so this form will submit data to the page itself. The input hidden `sendEmail`
    is a flag that will activate the sending procedure.
  id: totrans-133
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 模板包含一个警告消息，这是一个用于确认向用户发送电子邮件或显示错误的消息。表单包含从用户获取字段的输入和一个提交按钮。动作未指定，因此此表单将向页面本身提交数据。隐藏的输入
    `sendEmail` 是一个将激活发送过程的标志。
- en: 'Now it''s time to specify logic in the backend for reading POST data and to
    send a real email. The next snippet shows the method to add to the brick class:'
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在是时候在后台指定读取 POST 数据和发送真实电子邮件的逻辑了。下一个代码片段显示了要添加到砖类中的方法：
- en: '[PRE20]'
  id: totrans-135
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'The preceding code implements the logic for getting parameters and sends an
    email notifying the user about the result. `$request=$info->getRequest();` is
    used to get the HTTP request that contains the submitted data, and the `get` method
    is used to obtain the value of the `sendEmail` flag, which activates the sending
    procedure. You can pass variables to the view by using the parameters, as in the
    following piece of code:'
  id: totrans-136
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 之前的代码实现了获取参数并发送通知用户结果的逻辑。`$request=$info->getRequest();` 用于获取包含提交数据的 HTTP 请求，并使用
    `get` 方法获取 `sendEmail` 标志的值，该标志激活发送过程。您可以通过使用参数将变量传递给视图，如下面的代码片段所示：
- en: '[PRE21]'
  id: totrans-137
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Now all the components are in place to test our brick.
  id: totrans-138
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 现在所有组件都已就绪，可以测试我们的砖了。
- en: Add the brick to the page by following *Steps 5-6* from the *Implementing a
    simple brick* section. Now you will have the contact form component on the page
    and it will be a working one.
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按照从 *实现简单砖* 部分的 *步骤 5-6* 添加砖到页面。现在页面上将有一个工作状态的联系表单组件。
- en: 'Open the settings by clicking the pencil icon in the brick''s toolbar:![Figure
    10.6: Opening the popup'
  id: totrans-140
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过点击砖的工具栏中的铅笔图标打开设置：![图 10.6：打开弹出窗口
- en: '](img/Figure_10.06_B17073.jpg)'
  id: totrans-141
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/Figure_10.06_B17073.jpg)'
- en: 'Figure 10.6: Opening the popup'
  id: totrans-142
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 10.6：打开弹出窗口
- en: 'By clicking the pencil icon, a popup will be shown:![Figure 10.7: The popup
    for entering the recipient'
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击铅笔图标，将显示一个弹出窗口：![图 10.7：输入收件人的弹出窗口
- en: '](img/Figure_10.07_B17073.jpg)'
  id: totrans-144
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/Figure_10.07_B17073.jpg)'
- en: 'Figure 10.7: The popup for entering the recipient'
  id: totrans-145
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 10.7：输入收件人的弹出窗口
- en: You can enter an email address to be used as the recipient for the contact form.
  id: totrans-146
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 您可以输入用作联系表单收件人的电子邮件地址。
- en: Save the document and open the document's page you created in *Step 1* of this
    section. The contact form will be shown.
  id: totrans-147
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存文档并打开本节 *步骤 1* 中创建的文档页面。将显示联系表单。
- en: 'Fill in the form with data (it is a contact form, so the field meanings should
    be self-explanatory) and click **Send**. You should see a confirmation alert as
    in the following screenshot:'
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 用数据填写表单（它是一个联系表单，所以字段含义应该是自解释的）并点击**发送**。您应该会看到一个确认警报，如下面的截图所示：
- en: '![Figure 10.8: The contact form showing the confirmation message after sending'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 10.8：发送后显示确认信息的联系表单](img/Figure_10.08_B17073.jpg)'
- en: '](img/Figure_10.08_B17073.jpg)'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_10.08_B17073.jpg)'
- en: 'Figure 10.8: The contact form showing the confirmation message after sending'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.8：发送后显示确认信息的联系表单
- en: As you have learned from this example, it is quite easy to implement an interactive
    widget such as a contact form. Anyway, there are some tricks to know to avoid
    conflicts when you have multiple components on the same page. We will explain
    this in the next section.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 如您从本例中学到的那样，实现交互式小部件，如联系表单，相当简单。无论如何，当您在同一页面上有多个组件时，有一些技巧需要了解以避免冲突。我们将在下一节中解释这一点。
- en: Avoiding conflicts
  id: totrans-153
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 避免冲突
- en: For the contact form example, we have to raise a point about submitting data
    on a page with multiple bricks. Using the post approach, we send data to the server
    and manage the request on the backend. This procedure is very easy but it can
    lead to some issues. In fact, think about a case where you have many components
    on the same page.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 对于联系表单的例子，我们必须提出一个关于在具有多个砖块的页面上提交数据的问题。使用帖子方法，我们向服务器发送数据并在后端管理请求。这个程序非常简单，但它可能导致一些问题。事实上，考虑一下您在同一页面上有多个组件的情况。
- en: In our example, if we put two contact form widgets on the same page, clicking
    send will trigger both actions. The same can happen with different components
    with similar field names.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的例子中，如果我们将两个联系表单小部件放在同一页面上，点击发送将会触发两个动作。类似的情况也可能发生在具有相似字段名称的不同组件上。
- en: 'To avoid such conflicts, follow these troubleshooting steps:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 为了避免此类冲突，请遵循以下故障排除步骤：
- en: Add a unique prefix (per component) to all the field names. In our case, this
    could be `cf` for `ContactForm`, and the name will be `cf-name`, `cf-sendEmail`,
    and so on.
  id: totrans-157
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为所有字段名称添加一个唯一的前缀（每个组件一个）。在我们的例子中，这可以是`cf`用于`ContactForm`，名称将是`cf-name`、`cf-sendEmail`等等。
- en: 'Add the instance name as the trigger value. This is required to make your post
    unique. The changes to the action method of the brick class (created in *Step
    5* of *Implementing a contact form brick*) are the following:'
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将实例名称作为触发值。这是使您的帖子独特所必需的。砖块类的动作方法（在*实现联系表单砖块*的*步骤 5*中创建）的更改如下：
- en: '[PRE22]'
  id: totrans-159
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: The email sending procedure is now processed only if the name of the component
    is exactly the same that originates the post. Two different instances of the same
    brick produce different names, so your action will be triggered only once.
  id: totrans-160
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 现在只有当组件的名称与产生帖子的名称完全相同时，才会处理电子邮件发送过程。同一砖块的两种不同实例会产生不同的名称，因此您的动作只会被触发一次。
- en: 'The final step is to make a small change in the view template file (created
    in *Step 3* of *Implementing a contact form brick*). We will be adding a hidden
    input with the `cf-sendEmail` name attribute and the ID computed from the action
    method as `value`. Cut and paste the next snippet to your view file:'
  id: totrans-161
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 最后一步是在视图模板文件中进行一个小改动（在*实现联系表单砖块*的*步骤 3*中创建）。我们将添加一个具有`cf-sendEmail`名称属性和从动作方法计算出的ID作为`value`的隐藏输入。将以下片段复制到您的视图文件中：
- en: '[PRE23]'
  id: totrans-162
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: This value will be sent back to our action method with the post argument and
    we will be comparing it with the one generated on the server side. If they are
    not equal, the post is not matched to the current component, and we avoid any
    action.
  id: totrans-163
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 此值将作为帖子参数发送回我们的动作方法，我们将将其与服务器端生成的值进行比较。如果它们不相等，帖子就不会与当前组件匹配，我们避免任何动作。
- en: In this section, we learned how to implement a contact form. The example we
    have just finished showed us how simple it is to create an interactive brick that
    can be reused. You are not only able to reuse this component on any page of your
    website, but you can also copy the bundle to another website and get this feature
    for free. In the next example, we will discover how to implement a slideshow,
    mixing controllers and bricks to reuse the code that we might have written for
    an MVC page.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们学习了如何实现联系表单。我们刚刚完成的例子向我们展示了创建一个可重用的交互式砖块是多么简单。您不仅能够在您网站的任何页面上重用此组件，还可以将捆绑包复制到另一个网站，并免费获得此功能。在下一个例子中，我们将了解如何实现幻灯片，通过混合控制器和砖块来重用我们可能为MVC页面编写的代码。
- en: Implementing a slideshow brick
  id: totrans-165
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现幻灯片砖块
- en: 'In this example, we will build a slideshow widget that can be used to display
    a carousel of images. This will be very easy, and we will use just bootstrap and
    the tools learned so far. In fact, we will reuse the code used for displaying
    the image gallery in [*Chapter 9*](B17073_09_ePub_RK.xhtml#_idTextAnchor166),
    *Configuring Entities and Rendering Data*, but we will integrate it into a brick.
    To do that, follow these steps:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 在本例中，我们将构建一个幻灯片小部件，可以用来显示图像轮播。这将非常简单，我们只需使用bootstrap和迄今为止学到的工具。实际上，我们将重用用于显示图像库的代码[*第9章*](B17073_09_ePub_RK.xhtml#_idTextAnchor166)，*配置实体和渲染数据*，但我们将将其集成到一个砖块中。为此，请按照以下步骤操作：
- en: First of all, prepare the environment by creating a folder called `Slideshow`
    and upload a list of images to it. We should use wide images (such as 1920x1080).
  id: totrans-167
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，通过创建一个名为`Slideshow`的文件夹并上传一系列图像到其中来准备环境。我们应该使用宽图像（例如1920x1080）。
- en: Open the image settings for each image and add the title and description of
    the image as metadata. We will use it in the template.
  id: totrans-168
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为每个图像打开图像设置，并将图像的标题和描述作为元数据添加。我们将在模板中使用它。
- en: 'Access the properties panel by clicking the **Properties** tab button on the
    toolbar. Each Pimcore entity (objects, documents, and assets) has a set of key/pair
    properties that can be used to expand the information dynamically. We will use
    them to add metadata to our images. In the next screenshot, we can see a valid
    configuration:![Figure 10.9: Image properties'
  id: totrans-169
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过单击工具栏上的**属性**选项卡按钮来访问属性面板。每个Pimcore实体（对象、文档和资产）都有一组键/值属性，可以用来动态扩展信息。我们将使用它们来为我们的图像添加元数据。在下一张截图中，我们可以看到一个有效的配置：![图10.9：图像属性
- en: '](img/Figure_10.09_B17073.jpg)'
  id: totrans-170
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图片](img/Figure_10.09_B17073.jpg)'
- en: 'Figure 10.9: Image properties'
  id: totrans-171
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图10.9：图像属性
- en: The previous screenshot shows the properties table. We added a title and subtitle
    field with some value inside.
  id: totrans-172
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 上一张截图显示了属性表。我们添加了一个标题和副标题字段，并输入了一些值。
- en: 'Create a thumbnail preset. We have to configure the thumbnail engine to resize
    the uploaded images to match the format that the slideshow component expects.
    The user could upload images too big or with the wrong proportions (for example,
    landscape instead of portrait) but we need to make sure that all the images have
    the same height to show the images properly. We need to crop the uploaded images
    and make them the same format. In our example, we can use a crop transformation
    that will produce images that are only 400 px tall. To do that, just enter the
    **Width, Height** and **X, Y** settings as in the following screenshot:![Figure
    10.10: The thumbnail configuration'
  id: totrans-173
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个缩略图预设。我们必须配置缩略图引擎，以便将上传的图像调整大小以匹配幻灯片组件期望的格式。用户可能会上传过大或比例错误的图像（例如，横向而不是纵向），但我们需要确保所有图像具有相同的高度，以便正确显示图像。我们需要裁剪上传的图像并使它们具有相同的格式。在我们的示例中，我们可以使用一个裁剪转换，该转换将生成只有400像素高的图像。为此，只需输入以下截图中的**宽度、高度**和**X、Y**设置：![图10.10：缩略图配置
- en: '](img/Figure_10.10_B17073.jpg)'
  id: totrans-174
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图片](img/Figure_10.10_B17073.jpg)'
- en: 'Figure 10.10: The thumbnail configuration'
  id: totrans-175
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图10.10：缩略图配置
- en: Create a brick called `SlideShow` by adding `SlideShow.php` in the brick class
    folder (for example, `/bundles/BlogBundle/Document/Areabrick/SlideShow.php`).
  id: totrans-176
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过在砖块类文件夹中添加`SlideShow.php`来创建一个名为`SlideShow`的砖块（例如，`/bundles/BlogBundle/Document/Areabrick/SlideShow.php`）。
- en: Create the template file in the view folder (for example, `/bundles/BlogBundle/Resources/views/Areas/slide-show`).
    Pay attention to the folder name – it has to match the brick name, but it's lowercase
    with the words split with a hyphen, so `slide-show` will be `Slideshow`.
  id: totrans-177
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在视图文件夹中创建一个模板文件（例如，`/bundles/BlogBundle/Resources/views/Areas/slide-show`）。请注意文件夹名称
    - 它必须与砖块名称匹配，但要以小写形式呈现，单词之间用连字符分隔，因此`slide-show`将是`Slideshow`。
- en: 'Now add the following content to the template:'
  id: totrans-178
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在将以下内容添加到模板中：
- en: '[PRE24]'
  id: totrans-179
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: The preceding code adds a Pimcore renderlet that lets the user drag a folder
    on it and uses a controller for implementing the rendering logic. In our case,
    we will use the gallery action from the `SlideShow` controller. We are using a
    controller in a bundle, so we must specify the bundle name also.
  id: totrans-180
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 上述代码添加了一个Pimcore renderlet，允许用户将其拖放到文件夹上，并使用控制器来实现渲染逻辑。在我们的情况下，我们将使用`SlideShow`控制器中的画廊操作。我们正在使用一个包中的控制器，因此我们必须指定包名称。
- en: 'Add the `SlideShow` controller to the controller folder (for example, `/bundles/BlogBundle/Document/Controller/SlideShowController.php`).
    The initial content should be the following:'
  id: totrans-181
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`SlideShow`控制器添加到控制器文件夹中（例如，`/bundles/BlogBundle/Document/Controller/SlideShowController.php`）。初始内容应如下所示：
- en: '[PRE25]'
  id: totrans-182
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Now we have to implement the action for rendering the view. This action will
    take the folder added by the user and will load the image list for passing it
    to the view. In the following snippet, we have the action implementation; take
    it and add it to your controller:'
  id: totrans-183
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-184
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: The code is the same as what we used in the gallery example of *Chapter 9*,
    *Configuring Entities and Rendering Data*, so there is no need for more explanation.
  id: totrans-185
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'The last step for rendering it properly is to create a view called `gallery`
    and place it into the folder relative to the controller (for example, `/bundles/BlogBundle/Resources/views/slide_show/gallery.twig`).
    The template that we will use is the following:'
  id: totrans-186
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  id: totrans-187
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Add the brick to a page and drag a folder to it:![Figure 10.11: Dragging the
    folder to the component'
  id: totrans-188
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/Figure_10.11_B17073.jpg)'
  id: totrans-189
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Figure 10.11: Dragging the folder to the component'
  id: totrans-190
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Now you will see a sliding carousel as in the next screenshot:'
  id: totrans-191
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 10.12: The slideshow in action'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_10.12_B17073.jpg)'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 10.12: The slideshow in action'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
- en: In the previous screenshot, we highlighted the navigation buttons and the fields
    printed over the image.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we discovered how we can integrate controllers and bricks.
    The same result can be achieved by using the relation editable covered in [*Chapter
    8*](B17073_08_ePub_RK.xhtml#_idTextAnchor139), *Creating Custom CMS Pages*, and
    implementing the template inside the brick itself. Now that we have covered all
    the topics relating to bricks, it's time to learn how to implement a layout that
    could let us create any kind of page without writing any additional code.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
- en: Using bricks and blocks for a general-purpose template
  id: totrans-197
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'What we want to do in this section is to find a solution for implementing all
    kinds of layouts without wasting hours creating custom templates. Theoretically
    speaking, we could have a set of base objects and then mount them together to
    create all kinds of websites. In practice, this is what we should do with Pimcore:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.13: General-purpose template'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_10.13_B17073.jpg)'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 10.13: General-purpose template'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
- en: The previous diagram shows how a multipurpose layout is structured. We have
    many horizontal sections (**Section 1**, …, **Section N**) that can be divided
    into columns (**col1**, **col2**, **col3**). In each place, you will be able to
    add bricks for composing the page in any layout you want.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
- en: Theoretically speaking, we need to add a block iteration that will print rows
    inside another block iteration that will print columns. This lets us create a
    matrix of elements where we can add an `areablock` that lets us choose any brick
    we want. This layout is quite easy to implement in words, and feasible by putting
    into practice what we learned in the last chapters.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
- en: 'In this example, we will create a generic layout like the one that is shown
    in the following figure:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.14: Generic website layout'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_10.14_B17073.jpg)'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 10.14: Generic website layout'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
- en: 'In the preceding figure, we can note the three bands (**Header**, **contact
    form** with a description on the left side, and then a **full width** **slideshow**).
    This is, of course, a very simple use case, but with some imagination, you should
    understand how you can extend this to any kind of web page. Follow these steps
    to create a custom layout:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的图中，我们可以注意到三个带（**标题**、**左侧带有描述的联系方式**，然后是一个**全宽**的幻灯片）。这当然是一个非常简单的用例，但通过一些想象力，你应该能理解如何将其扩展到任何类型的网页。按照以下步骤创建自定义布局：
- en: 'The first step is to create an area brick that could implement a Bootstrap
    container. This area brick will let the user choose the column number and sizes.
    So, we have to create the brick class in `Document/AreaBrick/Container.php`. The
    starting code is the following:'
  id: totrans-209
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 第一步是创建一个可以实现 Bootstrap 容器的区域砖。这个区域砖将允许用户选择列数和大小。因此，我们必须在 `Document/AreaBrick/Container.php`
    中创建砖类。起始代码如下：
- en: '[PRE28]'
  id: totrans-210
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'The second step is to configure the component for exposing the column configuration
    to the user. In this example, we assume that we can have only three layout options
    (one column, two columns 30%-70%, and two columns of the same size). In a real-world
    example, you can prepare any possible combination in terms of the number of columns
    and sizes to make the user really autonomous in managing any kind of layout. In
    the next piece of code, there is the configuration for creating a drop-down list
    with all the layout:'
  id: totrans-211
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 第二步是为组件配置以向用户公开列配置。在这个例子中，我们假设我们只能有三种布局选项（一列、两列 30%-70% 和大小相同的两列）。在现实世界的例子中，你可以准备任何可能的组合，包括列数和大小，以使用户能够真正自主地管理任何类型的布局。在下一段代码中，有创建包含所有布局的下拉列表的配置：
- en: '[PRE29]'
  id: totrans-212
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Note that, for simplicity, we used the names of a file template as values for
    the select item, so that the item could be simply related to the content.
  id: totrans-213
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意，为了简单起见，我们使用了文件模板的名称作为选择项的值，这样项就可以简单地与内容相关联。
- en: 'The last step in the class is to read the configuration parameter and pass
    it to the view. To do this, you can just add the `action` method implementation
    that you find in the following piece of code to your class:'
  id: totrans-214
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 类中的最后一步是读取配置参数并将其传递到视图中。为此，你只需将以下代码中的 `action` 方法实现添加到你的类中：
- en: '[PRE30]'
  id: totrans-215
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: As you can see from the source code, the relative filename is transformed into
    a full path and added to the property bag.
  id: totrans-216
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如从源代码中看到的，相对文件名被转换成完整路径并添加到属性包中。
- en: 'Now we have to implement the main view template. Just add to the `view.html.twig`
    file the following code:'
  id: totrans-217
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们必须实现主视图模板。只需将以下代码添加到 `view.html.twig` 文件中：
- en: '[PRE31]'
  id: totrans-218
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: The previous piece of code includes the template based on the variable set in
    the action and simply wraps it in a bootstrap container. Moreover, when you are
    in edit mode, it adds a bar to the bottom to help the user identify the layout.
  id: totrans-219
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 上一段代码包含了基于动作中设置的变量创建的模板，并且简单地将其包裹在 bootstrap 容器中。此外，当你处于编辑模式时，它会在底部添加一个栏来帮助用户识别布局。
- en: 'Now we have to implement the brick template. As usual, we need to create a
    `view.html.twig` file, but this time we will also create a folder with many other
    templates that will be loaded dynamically. So, create the `one.html.twig`, `two-50-50.html.twig`,
    and `two-30-70.html.twig` files. The final result will be the following:![Figure
    10.15: Files configuration'
  id: totrans-220
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们必须实现砖模板。像往常一样，我们需要创建一个 `view.html.twig` 文件，但这次我们还将创建一个包含许多其他模板的文件夹，这些模板将被动态加载。因此，创建
    `one.html.twig`、`two-50-50.html.twig` 和 `two-30-70.html.twig` 文件。最终结果如下：![图 10.15：文件配置
- en: '](img/Figure_10.15_B17073.jpg)'
  id: totrans-221
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/Figure_10.15_B17073.jpg)'
- en: 'Figure 10.15: Files configuration'
  id: totrans-222
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 10.15：文件配置
- en: 'Now we have to implement the three templates. For brevity, we will report here
    only one case: the others are very similar and can be found in the repository
    code. The next piece of code shows the two-column implementation:'
  id: totrans-223
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们必须实现三个模板。为了简洁，我们在这里只报告一个案例：其他案例非常相似，可以在代码库中找到。下一段代码展示了两列的实现：
- en: '[PRE32]'
  id: totrans-224
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: As you can see in the previous piece of code, there is a bootstrap row and two
    columns (`col-6`; `col-6` means the same width). Inside each column, the `areablock`
    component will allow you to choose the component to add inside it. Now we are
    ready to use our general-purpose template in a real-world example!
  id: totrans-225
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 正如你在前面的代码中看到的，有一个 bootstrap 行和两个列（`col-6`；`col-6` 表示相同的宽度）。在每一列内部，`areablock`
    组件将允许你选择要添加到其中的组件。现在我们准备好在现实世界的例子中使用我们的通用模板了！
- en: 'Create the `layout.html.twig` file in `/bundles/BlogBundle/Layout`, and add
    the following snippet:'
  id: totrans-226
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  id: totrans-227
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: This snippet of code will render a parametric header that is put on all our
    pages. You don't want to have it on all the pages? Not a problem. You can always
    transform this code into a brick and place it only where you really need it.
  id: totrans-228
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Now, create a template. Because we want to create a standard layout with horizontal
    bands, we will allow the use of only the `Container` brick.
  id: totrans-229
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'To do that, just create a file inside the default folder called `generic.html.twig`,
    and add it in the following piece of code:'
  id: totrans-230
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  id: totrans-231
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: The preceding script defines a page structure with a header and an area block
    that will host the containers for our page layout.
  id: totrans-232
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Create a web page and use the `generic.html.twig` template we created during
    *Step 6* of this procedure.
  id: totrans-233
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Open the web page that you have created in edit mode. You should see the following
    result:![Figure 10.16: Adding the container to the page'
  id: totrans-234
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/Figure_10.16_B17073.jpg)'
  id: totrans-235
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Figure 10.16: Adding the container to the page'
  id: totrans-236
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'After this step, the component will be ready on the page. Now click on the
    configuration button, as in the following screenshot:![Figure 10.17: Opening settings'
  id: totrans-237
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/Figure_10.17_B17073.jpg)'
  id: totrans-238
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Figure 10.17: Opening settings'
  id: totrans-239
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'At this point, the user is able to select a layout using the edit box as in
    the contact form example that we saw in the previous section. The result of this
    configuration is the following popup:![Figure 10.18: Selecting the layout'
  id: totrans-240
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/Figure_10.18_B17073.jpg)'
  id: totrans-241
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Figure 10.18: Selecting the layout'
  id: totrans-242
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'The following screenshot shows the area brick that lets us create as many bands
    as we want. After this step, you should get the following result:'
  id: totrans-243
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 10.19: The container component on the page'
  id: totrans-244
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '](img/Figure_10.19_B17073.jpg)'
  id: totrans-245
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Figure 10.19: The container component on the page'
  id: totrans-246
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Add the columns content into it by clicking the plus button inside the container
    area (shown in *Figure 10.19*) and choosing the column brick.
  id: totrans-247
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add a contact form on the right by clicking the plus button and choosing the
    item from the component menu.
  id: totrans-248
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'On the left column, add a header component, the one we created earlier in the
    *Implementing a simple brick* section. Then add a WYSIWYG editor just above the
    header. You should get the result shown in the following screenshot:![Figure 10.20:
    The web page with the contact form and data'
  id: totrans-249
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/Figure_10.20_B17073.jpg)'
  id: totrans-250
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Figure 10.20: The web page with the contact form and data'
  id: totrans-251
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Now add another container just after the previous one by clicking on the top
    down arrow (*Figure 10.20*). On this component, add a slideshow brick. Configure
    it by dragging and dropping the images as we have done in the slideshow example
    in this chapter. The next screenshot summarizes your work in this part of the
    page:'
  id: totrans-252
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 10.21: The result to obtain in this example'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_10.21_B17073.jpg)'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 10.21: The result to obtain in this example'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we learned how to create a template that could suit most situations.
    The example has been a good opportunity for testing the general-purpose layout
    in a real-life scenario. This template, in conjunction with all the bricks that
    you could create, will cover the most common scenarios and will save a lot of
    time.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们学习了如何创建一个能够适应大多数情况的模板。这个例子为我们提供了一个在现实场景中测试通用布局的好机会。这个模板，结合你能够创建的所有砖块，将涵盖最常见的场景，并将节省大量时间。
- en: Summary
  id: totrans-257
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we continued our journey with the Pimcore CMS by discovering
    the bricks engine, another important tool for creating dynamic websites. By creating
    bricks, it's easy to prepare reusable components that can be used by web page
    editors to compose any website without asking the developers for customization.
    This new way to proceed is very important in reducing the development effort,
    keeping quality standards high, and increasing the speed of implementing the features
    that users want.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们继续使用Pimcore CMS，通过发现砖块引擎，另一个创建动态网站的重要工具。通过创建砖块，可以轻松准备可重复使用的组件，网页编辑人员可以使用这些组件来组合任何网站，而无需向开发者请求定制。这种新的处理方式对于减少开发工作量、保持高质量标准和提高实现用户所需功能的速度非常重要。
- en: To be more specific, we discovered how bricks work by implementing real-world
    examples. The contact form and slideshow are components that you will reuse in
    your projects for sure. Moreover, we also learned how to create a general-purpose
    template that enables us to produce any layout of a page without writing a single
    line of code.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 更具体地说，我们通过实施现实世界的例子发现了砖块的工作原理。联系表单和幻灯片是你在项目中一定会重复使用的组件。此外，我们还学习了如何创建一个通用模板，使我们能够不写一行代码就生成任何页面布局。
- en: In the next chapter, we will learn how to finalize our website by discovering
    some important details and solutions for everyday Pimcore usage. To list the most
    important ones, we will learn how to create a bundle's installers to easily recreate
    our classes and contents after the setup, and we will learn how to create a multisite
    instance of Pimcore.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将学习如何通过发现一些日常Pimcore使用的重要细节和解决方案来最终确定我们的网站。最重要的几点包括，我们将学习如何创建安装包的安装程序，以便在设置后轻松重新创建我们的类和内容，以及我们将学习如何创建Pimcore的多站点实例。
