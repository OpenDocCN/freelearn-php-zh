- en: Chapter 11. Creating an API for Use in a Mobile App
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you will learn how to create RESTful Web Services with the
    new integrated management of Yii 2.
  prefs: []
  type: TYPE_NORMAL
- en: You will learn how to create a new application to manage the `api` environment
    and how to create a controller using the default base classes provided by the
    framework.
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, we will cover authentication methods and you''ll learn how to customize
    the response output format. We''ll also discuss:'
  prefs: []
  type: TYPE_NORMAL
- en: Configuring the REST app in the advanced template
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Creating a controller:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'For example: creating a controller to manage rooms'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Authentication:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'For example: using authentication to get a customers list'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'New controller actions:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'For example: getting a rooms list for a reservation'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Customizing authentication and the response
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'For example: status response node in received data'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Other forms of export – RSS:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'For example: creating RSS with a list of available rooms'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Configuring a REST app in the advanced template
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before using the advanced template, it is advisable to configure RESTful Web
    Services, since, as you saw in previous chapters, this configuration allows you
    to easily add a new application in the same project.
  prefs: []
  type: TYPE_NORMAL
- en: Yii provides many built-in features to create RESTful Web Services and it reduces
    the code needed to implement it that is always structured with models, controllers,
    and actions.
  prefs: []
  type: TYPE_NORMAL
- en: 'These are its main features:'
  prefs: []
  type: TYPE_NORMAL
- en: Default actions (`index`, `view`, `create`, `update`, `delete`, and `options`)
    in `yii\rest\ActiveController`, which is the base controller suggested to override
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A response format selectable from input
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Customized authentication and authorization
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Caching and rate limiting
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Yii applies well-established knowledge about RESTful Web Services creation,
    such as how to present metadata in the response output. So, it is advisable that
    we follow the framework guidelines as far as possible; in this way, we will write
    commonly manageable REST APIs.
  prefs: []
  type: TYPE_NORMAL
- en: The first thing to do with an advanced template is to create a new application
    in the same project, for example renaming it `api`. Yii has not got a built-in
    functionality to create a new application, but it only takes a few steps to complete
    this task.
  prefs: []
  type: TYPE_NORMAL
- en: 'Starting from the root of our project, we will create, as well as for other
    applications (`common`, `backend`, `frontend`, and `console`), a new folder named
    `api` with the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, enter in `api` and let''s create these five subfolders:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: We must only create files for the first two folders, and the others will be
    left temporarily empty.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Another possible solution would be to copy complete content from other applications,
    such as `frontend` or `backend`, to the new application destination folder and
    then to clear content that is not useful.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `config` folder, we must create two files: `main.php` and `params.php`.
    The second file, `params.php`, will be temporarily empty as we have not got any
    parameters to store in it, such as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'The content of `api/config/main.php` will, instead, be:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we will create an `index.php` file in the `web` folder with the following
    content:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Still in the `web` folder, we will create the `.htaccess` file to handle a
    pretty URL:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we have to add a new alias in `common/config/bootstrap` regarding
    the `api` application:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Our job is complete, as we finally have a brand new application from scratch.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Be sure to make the `runtime` folder writable, since the framework will write
    in it runtime data such as log files.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a controller
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Yii provides two base classes: `\yii\rest\Controller` and `\yii\rest\ActiveController`
    that we can extend when we are creating a new controller for RESTful web services.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Both of these classes contain the following useful common features, in execution
    order:'
  prefs: []
  type: TYPE_NORMAL
- en: The response output as required from the request (content negotiator).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The HTTP method validation.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Authentication.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Rate limiting.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The second class `\yii\rest\ActiveController` adds more functionalities through
    ActiveRecord, such as handling user authorization and a set of already existing
    actions: `index`, `view`, `create`, `update`, `delete`, and `options`.'
  prefs: []
  type: TYPE_NORMAL
- en: We will see that Yii provides all the necessary information to get the response
    status and content through the body and HTTP header.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s create a controller to extend `\yii\rest\Controller` or rather without
    ActiveRecord. Create a new controller in `api/controllers/TestRestController.php`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, we have a method `dataList`, which returns an array of
    objects, and an `actionIndex` method that provides the `index` action for `TestRestController`
    and returns that list.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Many examples can be executed using a web browser (requested by employing the
    GET verb). Generally, however, we need a specific tool to test RESTful web services,
    such as `Postman` for example, an excellent extension for the Chrome browser or
    the `curl` command for advanced users.
  prefs: []
  type: TYPE_NORMAL
- en: The first feature of `\yii\rest\Controller` is to arrange the response output
    format, dynamically based on the request, which is also called **content negotiation**.
  prefs: []
  type: TYPE_NORMAL
- en: 'Indeed, we can try to launch this request through `http://hostname/yiiadv/api/web/test-rest/index`
    in our browser, or through specific tools using the GET verb and the `Accept`
    HTTP header set to `application/xml`, or by using `curl`, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'In these cases, we will get a response based on the XML data:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating a controller](img/B04656_11_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The XML data response to test-rest/index
  prefs: []
  type: TYPE_NORMAL
- en: 'However, if we change the `Accept` header to `application/json`, we will get
    a response based on the JSON data:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'In these cases, we will get a response based on the JSON data:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating a controller](img/B04656_11_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The JSON data response to test-rest/index
  prefs: []
  type: TYPE_NORMAL
- en: The same data will be rendered in different ways according to the `Accept` header
    sent from the client.
  prefs: []
  type: TYPE_NORMAL
- en: 'The second feature, HTTP method validation, allows you to specify which verbs
    are available for a resource. Verbs are defined in the `behaviors()` method, which
    must be extended to modify this setting:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: In this case, we only set the GET verb to the `index` action, because keys of
    the `actions` attribute of `behaviors['verbs']` are the actions and the value
    is an array containing supported HTTP methods.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we launch `http://hostname/yiiadv/api/web/test-rest/index` using the GET
    verb (as a browser request), we will continue to display the result. However,
    if we change the HTTP method to the POST verb, for example, we will get an exception
    error:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating a controller](img/B04656_11_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: An exception error using the wrong verb
  prefs: []
  type: TYPE_NORMAL
- en: This is because only the GET verb is supported by the `index` action.
  prefs: []
  type: TYPE_NORMAL
- en: In the next sections, we will explain the third and fourth features, authentication
    and rate limiting.
  prefs: []
  type: TYPE_NORMAL
- en: Example – creating a controller to manage rooms
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: With this example, we will apply the concepts dealt with in the previous chapter,
    in this case using `\yii\rest\ActiveController` as the base class instead of `\yii\rest\Controller`,
    since we are going to employ an ActiveRecord class to manipulate data.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new controller in `api/controllers/RoomsController.php`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'This controller implicitly contains these actions:'
  prefs: []
  type: TYPE_NORMAL
- en: '`actionIndex` that returns a list of models, accessible only with GET and HEAD
    HTTP methods'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`actionView` that returns details about the mode, accessible only with the
    GET and HEAD HTTP methods by passing the `id` parameter'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`actionCreate` that creates a new model, accessible only with the POST HTTP
    methods'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`actionUpdate` that updates an existing model, accessible only with the PUT
    and PATCH HTTP methods'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`actionDelete` that deletes an existing model, accessible only with the DELETE
    HTTP method'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`actionOptions` that returns the allowed HTTP methods'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now, let's try to launch all these methods.
  prefs: []
  type: TYPE_NORMAL
- en: 'Launch `actionIndex` at `http://hostname/yiiadv/api/web/rooms` using the GET
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'We will get all the records in the database as an array of the JSON object
    and HTTP header, along with the successful status code and pagination details:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: If we launch the same URL using the HEAD HTTP method, we will only get the HTTP
    HEADER response without a body, so we will get only the pagination information.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, if we launch the same URL with an unsupported HTTP method, for example
    the PUT method, we will get two important HTTP headers:'
  prefs: []
  type: TYPE_NORMAL
- en: The `status code` header set to `405 Method Not Allowed`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `Allow` header set to `GET, HEAD`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `status code` header says that a method is not supported, and the `Allow`
    header returns a list of supported HTTP methods for that action.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, launch `actionView` on `http://hostname/yiiadv/api/web/rooms/view?id=1`
    using the GET method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'If we try to launch a nonexistent ID, for example `http://hostname/yiiadv/api/web/rooms/view?id=100`,
    using the GET method, we will get this body response:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: The HTTP `status code` header will be set to `404 Not Found` to specify that
    the requested item (`id=100`) does not exist. Using only the HEAD HTTP method,
    we will get information from the HTTP `status code` set to `404`. The `Create`
    and `Update` actions require that the client sends body content of the object
    to be created or updated.
  prefs: []
  type: TYPE_NORMAL
- en: 'By default, Yii recognizes only the `application/x-www-form-urlencoded` and
    `multipart/form-data` input formats. In order to enable the JSON input format,
    we need to configure the `parsers` property of the request''s application component
    in the `api/config/main.php` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'After configuring the JSON input parser, we can call `http://hostname/yiiadv/api/web/rooms/create`
    using the POST HTTP method to create a new room and pass, for example, this JSON:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'If no error occurred, we will get:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'If we are missing some required fields and there are validation errors, we
    will get:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: The same thing needs to be done for an update action, in this case, however,
    we will call `http://hostname/yiiadv/api/web/rooms/update` and pass the `id` URL
    parameter using the PUT or PATCH HTTP method. In this case, only the HTTP header
    status code `200 OK` will be a successful response and the update object will
    be returned as body content.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, `actionDelete` is used by calling `http://hostname/yiiadv/api/web/rooms/delete`,
    by passing the `id` URL parameter, and using the DELETE HTTP method. A successful
    execution will return `204 No Content` as the HTTP status code; otherwise, it
    will be `404 Not Found`.
  prefs: []
  type: TYPE_NORMAL
- en: Authentication
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There are three kinds of authentication:'
  prefs: []
  type: TYPE_NORMAL
- en: '**HTTP Basic Auth** (the `HttpBasicAuth` class): This method uses the WWW-Authenticate
    HTTP header to send the username and password for every request'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Query parameter** (the `QueryParamAuth` class): This method uses an access
    token passed as query parameter in the API URL'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**OAuth 2** (the `HttpBearerAuth` class): This method uses an access token
    that is obtained by the consumer from an authorization server and sent to the
    API server via HTTP bearer tokens'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Yii supports all the methods mentioned, but we can also easily create a new
    one.
  prefs: []
  type: TYPE_NORMAL
- en: 'To enable authentication, follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Configure the user application component in the configuration, setting `enableSession`
    to `false` in order to make user authentication status not persistent using a
    session across requests. Next, set `loginUrl` to `null` to show the HTTP 403 error
    instead of redirecting it to the login page.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Specify which authentication method we want to use, configuring the `authenticator`
    behavior in API controller classes.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Implement `yii\web\IdentityInterface::findIdentityByAccessToken()` in the user
    identity class.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: The first step ensures that REST requests are really stateless, but if you need
    to persist or store session data, you can skip this step.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Step 1 can be configured in `api/config/main.php`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Step 2 requires that we extend the `behaviors()` controller method, specifying
    a single authenticator:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Or we can do this by specifying multiple authenticators:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Finally, step 3 requires the implementation of `findIdentityByAccessToken()`
    of the `identityClass` specified in the configuration file.
  prefs: []
  type: TYPE_NORMAL
- en: 'In a simple scenario, the access token can be stored in a column of the `User`
    table and then retrieved:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: At the end of the configuration, every request will try to authenticate the
    user in the `beforeAction()` method of the same controller.
  prefs: []
  type: TYPE_NORMAL
- en: Now, let's take a look at the first authentication method, `HTTPBasicAuth`.
    This method requires us to set the `auth` property to the callable PHP function;
    if it is not set, the username will be used as the access token passed to the
    `\yii\web\User::loginByAccessToken()` method.
  prefs: []
  type: TYPE_NORMAL
- en: 'The basic implementation of the `HttpBasicAuth` authentication is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: The callable PHP function stored by the `auth` property can be represented as
    an inline function, or as an array, whose first value is the object and the second
    is the function name to be called, by passing `$username` and `$password` parameters.
  prefs: []
  type: TYPE_NORMAL
- en: Check how PHP is running through `phpinfo()`. If you display CGI/FCGI, then
    you need to add `SetEnvIf Authorization .+ HTTP_AUTHORIZATION=$0` in `.htaccess`
    to use HTTP Auth from PHP.
  prefs: []
  type: TYPE_NORMAL
- en: The second authentication method is query parameter, by using the `QueryParamAuth`
    class. With this method, a query parameter named `access-token` must be passed
    to the URL. Then, it will call the `\yii\web\user::loginByAccessToken()` method,
    passing `access-token` as the first parameter. This function will return an `IdentityInterface`
    or `null`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The URL parameter name can be changed using `tokenParam` in the authentication
    declaration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: With this configuration, the URL must be `http://hostname/url?myAccessToken=...`
  prefs: []
  type: TYPE_NORMAL
- en: The last authentication method, OAuth 2, requires an authorization server from
    which we will get the bearer token to pass to the REST API server, which is similar
    to `QueryParamAuth`.
  prefs: []
  type: TYPE_NORMAL
- en: Example – using authentication to get a customers list
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this example, we are going to authenticate ourselves by using two methods
    at the same time: `HTTPBasicAuth` and `QueryParamAuth`. When using `QueryParamAuth`
    with an access token, we will first call a publically accessible action to get
    an access token that the user will pass to all the other actions as the query
    URL parameter.'
  prefs: []
  type: TYPE_NORMAL
- en: We will start by creating a new model from the `Customer` database table and
    putting it into the `common/models` folder. Then, we will create a new user in
    the `User` database table using, for example, `foo` as the username and `$2a$12$xzGZB29iqBHva4sEYbJeT.pq9g1/VdjoD0S67ciDB30EWSCE18sW6`
    as the password (this is equivalent to the hashed bar text).
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new controller in `api/controllers/CustomersController.php` that only
    extends the `behaviors()` method to implement `HTTPBasicAuth` and `QueryParamAuth`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: In `HTTPBasicAuth`, we implement the `auth` property inside the configuration
    array by checking `$username` and then validating the password. If the username
    and password match each other, it will return the user found or will otherwise
    be null.
  prefs: []
  type: TYPE_NORMAL
- en: '`QueryParamAuth`, instead, does not need any property other than the class,
    since we will use `access-token` as the query parameter name. Nevertheless, to
    complete this task, we need an action that will return the related user''s access
    token after passing both the username and password.'
  prefs: []
  type: TYPE_NORMAL
- en: 'For this purpose, we will add the `actionAccessTokenByUser()` method, which
    looks for the user with the `$username` and `$password` parameters passed. If
    the user already exists, its `access_token` property will be updated with a random
    string, so every time we call this action, `access_token` will change and the
    previous one will be cancelled:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Finally, to test `HTTPBasicAuth`, we need to pass the WWW-Authentication header
    by calling the `http://hostname/yiiadv/api/web/customers/index` URL.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we want to use `QueryParamAuth`, we need to:'
  prefs: []
  type: TYPE_NORMAL
- en: Get `access-token` returned from `http://hostname/yiiadv/api/web/customers/access-token-by-user`,
    by passing the username and hashed password
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Call `http://hostname/yiiadv/api/web/customers/index?access-token`, by passing
    the access-token property value received from the previous request
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`QueryParamAuth` calls the `findIdentityByAccessToken()` function of `IdentityInterfaces`(the
    user mode ). So, check that the method is implemented, and if it''s not, implement
    it as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Pay attention, as this way of using access tokens allows the use of the REST
    API with the same credentials for only one client at a time. This is because any
    time an `access-token-by-user` is called, a new `access-token` will be created.
    Therefore, it should be created a relation one-to-many between users and `access-token`
    in order to provide multiple clients with access using the same username/password
    credentials.
  prefs: []
  type: TYPE_NORMAL
- en: New controller action
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'It is very simple to add new actions to the REST API controller. We only need
    to remember three differences in the web controller:'
  prefs: []
  type: TYPE_NORMAL
- en: Verb setting for the new action
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Authenticate the setting for the new action
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Output for the new action
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The first two steps are configured in the `behaviors()` method of the controller:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: In the first part of the `behaviors()` method, we will only set the `get` and
    `head` HTTP methods to call the `myCustomAction` action. If we try to call this
    action with other HTTP methods, we will get a not supported exception.
  prefs: []
  type: TYPE_NORMAL
- en: In the last part of the `behaviors()` method, we will set it so that `myCustomAction`
    has not got authentication, since it is in the `except` property.
  prefs: []
  type: TYPE_NORMAL
- en: 'The third difference, output for the new action, states that we have different
    ways to return data. We can use:'
  prefs: []
  type: TYPE_NORMAL
- en: A key-value pair array to create a single object from scratch
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An ActiveRecord instance to create a single object
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An ActiveRecord array to create a list of objects
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A data provider
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In this last case, the framework will automatically output pagination information
    and links to other pages (if present).
  prefs: []
  type: TYPE_NORMAL
- en: Example – getting a rooms list for a reservation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this example, we need to create a `Reservation` model in the `common/models`
    folder using Gii.
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, we create a new controller in `api/controllers/ReservationsController.php`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: Now, let's call `http://hostname/yiiadv/api/web/reservations/index-with-rooms`,
    where we will display a list of reservations, in each of which the `room` property
    is expanded together with the content of room object related to the reservation.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Take care to ensure that the `room` relation already exists in the `Reservation`
    model. If not, we must add this relation to the `Reservation` model:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: However, this solution is inefficient since we always get all the rows and if
    there are too many of them, this can result in it being too expensive for us.
    To solve this problem, we could use a DataProvider created from a set of data
    found, or better yet, a more simple solution automatically provided by Yii.
  prefs: []
  type: TYPE_NORMAL
- en: Indeed, Yii provides some easy ways to display relations and filter returned
    fields. For example, there could be fields that we do not want to show, such as
    a password, private data, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: 'Models have these methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '`fields()`: By default, classes that extend `yii\base\Model::fields()` return
    all the model attributes as fields, while classes that extend `yii\db\ActiveRecord::fields()`
    only return the attributes that have been populated from the DB'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`extraFields()`: By default, classes that extend `yii\base\Model::extraFields()`
    return nothing, while classes that extend `yii\db\ActiveRecord::extraFields()`
    return the names of the relations that have been populated from the DB'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The first method, `fields()`, is a key-value array where the key is the name
    of the field returned. The value can be empty if the returned content is the attribute
    with the same name as the key, a string indicating which attribute to get the
    returned value from, or a callable PHP function to manipulate the returned value.
  prefs: []
  type: TYPE_NORMAL
- en: The second method, `extraFields()`, is a string array whose values are relations
    defined in the model class.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, to dynamically filter the requested field, we append the `fields` parameter
    to the requested URL and the `expand` parameter to get a list of relations from
    the models.
  prefs: []
  type: TYPE_NORMAL
- en: So, if we call `http://hostname/yiiadv/api/web/reservations/index?expand=room`,
    we will get the same result but we will also have the pagination and loaded models
    that are only necessary for that page.
  prefs: []
  type: TYPE_NORMAL
- en: However, it would be more convenient for us to distribute an URL without special
    parameters, such as the `expand` and `fields`, for example, in order to avoid
    confusion among developers who will use these APIs.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can use `actionIndexWithRooms` as a wrapper for `actionIndex` with an expanded
    parameter in this way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: With this solution, the `http://hostname/yiiadv/api/web/reservations/index-with-rooms`
    URL is simply a wrapper for h`ttp://hostname/yiiadv/api/web/reservations/index?expand=room`
    but this prevents developers from having to remember which parameters to pass
    to the URL to obtain the necessary nodes in the response.
  prefs: []
  type: TYPE_NORMAL
- en: Customizing authentication and response
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Yii allows us to quickly create a custom authentication method for our application.
    This is useful because in some cases, the previously mentioned authentications
    are not sufficient.
  prefs: []
  type: TYPE_NORMAL
- en: 'A custom authentication model can be made by extending the `yii\filters\auth\AuthMethod`
    class, which implements `yii\filters\auth\AuthInterface` that requires overriding
    the `authenticate` (`$user`, `$request`, and `$response`) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: Even though the REST API should be stateless, or rather should not save session
    data, it could be necessary to store some information or preferences during a
    session across requests.
  prefs: []
  type: TYPE_NORMAL
- en: So, if we need to support a session, we can start it through the `authenticate()`
    method called in the `beforeAction()` event. The idea is to use `QueryParamAuth`
    using `access-token` as the session ID to identify the current session.
  prefs: []
  type: TYPE_NORMAL
- en: For this purpose, we will create a new folder in `api\components` to store the
    custom `SessionAuth` method.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is the content of the `api/components/SessionAuth.php` file where the
    query URL parameter is named `sid`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: It is also necessary to create an action to start the session; otherwise, the
    user will not be stored in the session.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, create a new controller called `UsersController` in `api/controllers/UsersController.php`
    to handle the login:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: As earlier defined, in the `behaviors()` method, the actions of this controller,
    except for `login`, will authenticate against the `SessionAuth` component that
    checks primarily whether a user has successfully executed the login action.
  prefs: []
  type: TYPE_NORMAL
- en: We now call `http://hostname/yiiadv/api/web/users/login?username=&passwordHash=`
    and fill out the `username` and `passwordHash` fields. It returns the session
    ID to access the session data. Also, the `loggedUser` property is filled out in
    the session with the user model data.
  prefs: []
  type: TYPE_NORMAL
- en: Now, we can store shared information among requests as a typical web application.
  prefs: []
  type: TYPE_NORMAL
- en: Now, let's see how to customize a response in RESTful Web Services. First of
    all, this operation could be needed when we have to add, for example, extra information,
    such as explicit error messages to display in the client or operation status code.
  prefs: []
  type: TYPE_NORMAL
- en: 'The custom response must extend `\yii\web\Response` and override the `send()`
    method, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: This `send()` method manipulates data stored in the object properties, mainly
    in the `$this->data` variable.
  prefs: []
  type: TYPE_NORMAL
- en: This customization, which we will see in detail in the next example, is incomplete,
    as the `send()` method should implement all the manipulations of data made from
    the `\yii\web\Response` version. We must remember that Yii returns data based
    on the `Accept` HTTP header passed from the client and many other convenient functionalities.
  prefs: []
  type: TYPE_NORMAL
- en: 'It is possible to maintain this behavior simply by calling `parent::send()`
    before returning from the `send()` function, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: Because, as said before, `send()` uses the `$this->data` variable as a container
    for data to be sent.
  prefs: []
  type: TYPE_NORMAL
- en: Example – status response node in data received
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now, let's apply the concepts seen in the previous chapter to add extra data
    into a response. This practice is useful when we need to return to client information
    about the operation status and extra data such as detailed error messages.
  prefs: []
  type: TYPE_NORMAL
- en: 'The purpose of this example is to return a response with two attributes:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `status` attribute containing three properties: `response_code` with an
    integer value indicating the operation state, `response_message` with a string
    value representation of `response_code` and `response_extra` with a custom text
    string'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `data` attribute containing the expected output data
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We will use a class containing all the integer codes and their text representations
    as a response code, since the integer value will be used to fill in the `response_code`
    property and a string representation to fill in the `response_message` property.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new class file in `api/components/ApiResponseCode.php` with this content:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: In this component, we defined a list of constants that represent all response
    codes that can be sent to a client. For each response code, there will be a relative
    text representation returned by the `responseMessage()` static method. Then, there
    will also be an array of extra text messages returned by `responseExtras()` that
    will fill the `response_extra` property if no specific text `extra` is passed.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, we must write the component that extends `\yii\web\Response` named
    `ApiResponse` in `api/components/ApiResponse.php`. In this component, we will
    define three custom properties: `statusResponseCode`, `statusResponseMessage`,
    and `statusResponseExtra`, which we are going to fill with content composing in
    the `status` property.'
  prefs: []
  type: TYPE_NORMAL
- en: In this way, we will have a convenient method, `fillStatusResponse()`, based
    on the `$code` parameter, which will automatically fill in both the `statusResponseExtra`
    and `statusResponseMessage` properties.
  prefs: []
  type: TYPE_NORMAL
- en: The core of this component is the overridden `send()` method that will return
    `status` with `ERR_OK` as response message and `0` as response code by default
    if there are no client errors (as authentication, not found, and so on.). This
    is unless a developer changes the values of `statusResponseCode`, `statusResponseExtra`,
    and `statusResponseMessage`, or manually or automatically calls its properties
    with `fillStatusResponse()`.
  prefs: []
  type: TYPE_NORMAL
- en: Otherwise, if there are some client errors, we will support `Not Authenticated`
    and `Not Found` errors.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is the content of the `api/components/ApiResponse.php` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we have to change the configuration file `api/config/main.php` by
    adding the `response` property as a component to indicate to use a custom response
    class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: Let's make some attempts. Try to call the non-existent URL `http://hostname/yiiadv/api/web/reservations/index-inexistent`.
  prefs: []
  type: TYPE_NORMAL
- en: 'This will be the output, correctly returning data as null and the status with
    the error explained:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Example – status response node in data received](img/B04656_11_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The response with an error after calling a non-existent URL
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, try to call a URL that requires authentication: `http://hostname/yiiadv/api/web/customers/index`,
    which we already implemented in the previous paragraphs.'
  prefs: []
  type: TYPE_NORMAL
- en: 'This will be the output, correctly returning data as null and the status with
    the error explained:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Example – status response node in data received](img/B04656_11_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The response with an error when calling the URL with authentication
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, we try to call a URL that returns data: `http://hostname/yiiadv/api/web/rooms/index`,
    which is already implemented in the previous paragraphs.'
  prefs: []
  type: TYPE_NORMAL
- en: 'This will be the output, correctly returning data as filled and successful
    as the status:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Example – status response node in data received](img/B04656_11_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: A response with a successful output
  prefs: []
  type: TYPE_NORMAL
- en: Other forms of export – RSS
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Yii allows us to create a custom format response to output data. The response
    format can be changed based on the `Accept` HTTP header sent by the client or
    done programmatically. When Yii receives a request, it searches for an available
    response formatter based on the `Accept` HTTP header value and finally calls the
    `format` (`$response`) method of the response formatter found.
  prefs: []
  type: TYPE_NORMAL
- en: 'Therefore, there are three steps to create custom responses:'
  prefs: []
  type: TYPE_NORMAL
- en: Implementing the `yii\web\ResponseFormatterInterface` interface.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Adding a new custom formatter response property in the configuration file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Extending the `behaviors()` method of the controller to handle specific `Accept`
    HTTP header values.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The first step requires us to implement the `yii\web\ResponseFormatterInterface`
    interface and extend its method `format` (`$response`). Data to be formatted is
    stored in the `$response->data` property, and the response to client must be filled
    out in the `$response->content` property:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'The second step requires us to add a reference to the custom response formatter.
    For this purpose, we will use the `formatters` property of `response`, which is
    an array where keys are the format names, and the array values are the corresponding
    configurations to create formatter objects:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'The third step requires us to extend the `behaviors()` method of the controller
    in order to handle specific `Accept` HTTP header values and indicate to the framework
    which response formatter to use according to the `Accept` HTTP header value, for
    example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: When a client sends a request with the `Accept` HTTP header set to `application/rss+xml`,
    this controller will use the `rss` formatter (read from the configuration file)
    to prepare the response. If we specify a formatter that does not exist in the
    configuration file, we will get `InvalidConfigException`.
  prefs: []
  type: TYPE_NORMAL
- en: Example – creating an RSS with a list of available rooms
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now, let's look at how to create an RSS response formatter for the available
    rooms.
  prefs: []
  type: TYPE_NORMAL
- en: 'First of all, we must create the complete response formatter component in `api/components/RssResponseFormatter.php`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: The RSS response formatter must implement the `format` (`$response`) method
    to correctly implement `yii\web\ResponseFormatterInterface`. When the `format`
    (`$response`) method is invoked, it will set the `Content-Type` HTTP header to
    `application/rss+xml`, use data that is ready to be sent from the `$response->data`
    property, and fill in the `$response->content` property, which is the final content
    received by the client.
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, we must change the `api/config/main.php` file to add the `response` property
    with the support of the new response formatter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: The `formatter` property is an array of the response formatter where the keys
    are the format names and the values are the corresponding configurations to create
    formatter objects.
  prefs: []
  type: TYPE_NORMAL
- en: In this case, we configured a new formatter called `rss` that represents the
    `\api\components\RssResponseFormatter` component.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we have to configure the `behaviors()` method in the controller to
    handle the `Accept` HTTP header with the `application/rss+xml` value.
  prefs: []
  type: TYPE_NORMAL
- en: 'Open the `RoomsController` file in `api/controllers/RoomsController.php` and
    add the extension to the `behaviors()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: Starting from the base configuration of `$behaviors` inherited from `parent::behaviors()`,
    the `contentNegotiator` attribute contains a reference to `formats` for the `Accept`
    HTTP header value. The array keys are the `Accept` HTTP header value that is supported,
    and the values are the corresponding response formatter.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we try to make the following request:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'We should display the following response:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Example – creating an RSS with a list of available rooms](img/B04656_11_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The RSS response output
  prefs: []
  type: TYPE_NORMAL
- en: We can also use the response formatter programmatically. It is enough to set
    the format of the `Yii::$app->response` application component to a configured
    response formatter in the configuration file.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, we can add a new action named `actionIndexRss` in `RoomsController`
    that will output data using `RssResponseFormatter` in this way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we created `api` for use in a mobile app through the use of
    the powerful tools provided by Yii. We adopted the approach of creating a new
    application in order to distribute RESTful web services, instead of mixing web
    and `api` controllers. For this purpose, at the beginning of the chapter, we configured
    a new REST application using the advanced template.
  prefs: []
  type: TYPE_NORMAL
- en: After configuring the RESTful web service environment, we discovered two kinds
    of `api` controllers that Yii provides by default, then we created controllers
    with custom data and data from ActiveRecord.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we found out the default authentication methods for RESTful Web Services
    provided by framework and you learned how to use them.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we focused on how to customize the response output format, taking an
    example of how to create an RSS version of the available data.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, you will learn how to write a console application and will
    look at the differences between web and console apps.
  prefs: []
  type: TYPE_NORMAL
