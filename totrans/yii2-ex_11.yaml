- en: Chapter 11. Creating an API for Use in a Mobile App
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第11章 创建用于移动应用程序的API
- en: In this chapter, you will learn how to create RESTful Web Services with the
    new integrated management of Yii 2.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你将学习如何使用Yii 2的新集成管理创建RESTful Web服务。
- en: You will learn how to create a new application to manage the `api` environment
    and how to create a controller using the default base classes provided by the
    framework.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 你将学习如何创建一个新的应用程序来管理`api`环境，以及如何使用框架提供的默认基类创建控制器。
- en: 'Then, we will cover authentication methods and you''ll learn how to customize
    the response output format. We''ll also discuss:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将介绍认证方法，并教你如何自定义响应输出格式。我们还将讨论：
- en: Configuring the REST app in the advanced template
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在高级模板中配置REST应用程序
- en: 'Creating a controller:'
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建控制器：
- en: 'For example: creating a controller to manage rooms'
  id: totrans-6
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 例如：创建一个控制器来管理房间
- en: 'Authentication:'
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 认证：
- en: 'For example: using authentication to get a customers list'
  id: totrans-8
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 例如：使用认证来获取客户列表
- en: 'New controller actions:'
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 新的控制器操作：
- en: 'For example: getting a rooms list for a reservation'
  id: totrans-10
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 例如：获取预订的房间列表
- en: Customizing authentication and the response
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 自定义认证和响应
- en: 'For example: status response node in received data'
  id: totrans-12
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 例如：接收数据中的状态响应节点
- en: 'Other forms of export – RSS:'
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 其他形式的导出 – RSS：
- en: 'For example: creating RSS with a list of available rooms'
  id: totrans-14
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 例如：创建包含可用房间列表的RSS
- en: Configuring a REST app in the advanced template
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在高级模板中配置REST应用程序
- en: Before using the advanced template, it is advisable to configure RESTful Web
    Services, since, as you saw in previous chapters, this configuration allows you
    to easily add a new application in the same project.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用高级模板之前，建议配置RESTful Web服务，因为，正如你在前面的章节中看到的，这种配置允许你轻松地在同一项目中添加新的应用程序。
- en: Yii provides many built-in features to create RESTful Web Services and it reduces
    the code needed to implement it that is always structured with models, controllers,
    and actions.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: Yii提供了许多内置功能来创建RESTful Web服务，它减少了实现所需的代码，并且总是以模型、控制器和动作的结构化方式实现。
- en: 'These are its main features:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 它的主要功能包括：
- en: Default actions (`index`, `view`, `create`, `update`, `delete`, and `options`)
    in `yii\rest\ActiveController`, which is the base controller suggested to override
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在`yii\rest\ActiveController`中的默认操作（`index`、`view`、`create`、`update`、`delete`和`options`），这是建议覆盖的基本控制器
- en: A response format selectable from input
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可从输入中选择响应格式
- en: Customized authentication and authorization
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 自定义认证和授权
- en: Caching and rate limiting
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 缓存和速率限制
- en: Yii applies well-established knowledge about RESTful Web Services creation,
    such as how to present metadata in the response output. So, it is advisable that
    we follow the framework guidelines as far as possible; in this way, we will write
    commonly manageable REST APIs.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: Yii在创建RESTful Web服务方面应用了成熟的知识，例如如何在响应输出中呈现元数据。因此，我们尽可能遵循框架指南是明智的；这样，我们将编写易于管理的REST
    API。
- en: The first thing to do with an advanced template is to create a new application
    in the same project, for example renaming it `api`. Yii has not got a built-in
    functionality to create a new application, but it only takes a few steps to complete
    this task.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 使用高级模板的第一件事是在同一项目中创建一个新的应用程序，例如将其重命名为`api`。Yii没有内置创建新应用程序的功能，但只需几个步骤就可以完成这项任务。
- en: 'Starting from the root of our project, we will create, as well as for other
    applications (`common`, `backend`, `frontend`, and `console`), a new folder named
    `api` with the following command:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 从我们项目的根目录开始，我们将创建，以及其他应用程序（`common`、`backend`、`frontend`和`console`），一个名为`api`的新文件夹，以下命令：
- en: '[PRE0]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Now, enter in `api` and let''s create these five subfolders:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，进入`api`并创建这五个子文件夹：
- en: '[PRE1]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: We must only create files for the first two folders, and the others will be
    left temporarily empty.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 我们必须只为前两个文件夹创建文件，其他文件夹暂时保持为空。
- en: Note
  id: totrans-30
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Another possible solution would be to copy complete content from other applications,
    such as `frontend` or `backend`, to the new application destination folder and
    then to clear content that is not useful.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个可能的解决方案是从其他应用程序（如`frontend`或`backend`）复制完整内容到新的应用程序目标文件夹，然后清除无用的内容。
- en: 'In the `config` folder, we must create two files: `main.php` and `params.php`.
    The second file, `params.php`, will be temporarily empty as we have not got any
    parameters to store in it, such as:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 在`config`文件夹中，我们必须创建两个文件：`main.php`和`params.php`。第二个文件`params.php`将暂时为空，因为我们还没有任何参数要存储在其中，例如：
- en: '[PRE2]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The content of `api/config/main.php` will, instead, be:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '`api/config/main.php`的内容将变为：'
- en: '[PRE3]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Then, we will create an `index.php` file in the `web` folder with the following
    content:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们在 `web` 文件夹中创建一个 `index.php` 文件，内容如下：
- en: '[PRE4]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Still in the `web` folder, we will create the `.htaccess` file to handle a
    pretty URL:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 仍然在 `web` 文件夹中，我们将创建 `.htaccess` 文件来处理漂亮的 URL：
- en: '[PRE5]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Finally, we have to add a new alias in `common/config/bootstrap` regarding
    the `api` application:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们必须在 `common/config/bootstrap` 中添加一个关于 `api` 应用程序的新别名：
- en: '[PRE6]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Our job is complete, as we finally have a brand new application from scratch.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的工作完成了，因为我们最终从头开始创建了一个全新的应用程序。
- en: Note
  id: totrans-43
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Be sure to make the `runtime` folder writable, since the framework will write
    in it runtime data such as log files.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 请确保将 `runtime` 文件夹设置为可写，因为框架将在此处写入运行时数据，例如日志文件。
- en: Creating a controller
  id: totrans-45
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建控制器
- en: 'Yii provides two base classes: `\yii\rest\Controller` and `\yii\rest\ActiveController`
    that we can extend when we are creating a new controller for RESTful web services.'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们创建新的 RESTful 网络服务控制器时，Yii 提供了两个基类：`\yii\rest\Controller` 和 `\yii\rest\ActiveController`，我们可以扩展它们。
- en: 'Both of these classes contain the following useful common features, in execution
    order:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个类都包含以下有用的公共特性，按执行顺序排列：
- en: The response output as required from the request (content negotiator).
  id: totrans-48
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 根据请求所需输出的响应（内容协商器）。
- en: The HTTP method validation.
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: HTTP 方法验证。
- en: Authentication.
  id: totrans-50
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 认证。
- en: Rate limiting.
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 速率限制。
- en: 'The second class `\yii\rest\ActiveController` adds more functionalities through
    ActiveRecord, such as handling user authorization and a set of already existing
    actions: `index`, `view`, `create`, `update`, `delete`, and `options`.'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 第二类 `\yii\rest\ActiveController` 通过 ActiveRecord 添加更多功能，例如处理用户授权和一组已存在的操作：`index`、`view`、`create`、`update`、`delete`
    和 `options`。
- en: We will see that Yii provides all the necessary information to get the response
    status and content through the body and HTTP header.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将看到 Yii 通过正文和 HTTP 头提供了所有必要的详细信息来获取响应状态和内容。
- en: 'Let''s create a controller to extend `\yii\rest\Controller` or rather without
    ActiveRecord. Create a new controller in `api/controllers/TestRestController.php`:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个控制器来扩展 `\yii\rest\Controller` 或者更确切地说，不使用 ActiveRecord。在 `api/controllers/TestRestController.php`
    中创建一个新的控制器：
- en: '[PRE7]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: In the preceding code, we have a method `dataList`, which returns an array of
    objects, and an `actionIndex` method that provides the `index` action for `TestRestController`
    and returns that list.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们有一个 `dataList` 方法，它返回一个对象数组，还有一个 `actionIndex` 方法，它为 `TestRestController`
    提供 `index` 动作并返回该列表。
- en: Note
  id: totrans-57
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Many examples can be executed using a web browser (requested by employing the
    GET verb). Generally, however, we need a specific tool to test RESTful web services,
    such as `Postman` for example, an excellent extension for the Chrome browser or
    the `curl` command for advanced users.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 许多示例可以使用网络浏览器执行（通过使用 GET 动词请求）。然而，通常我们需要一个特定的工具来测试 RESTful 网络服务，例如 `Postman`，它是
    Chrome 浏览器的一个优秀扩展，或者对于高级用户来说，可以使用 `curl` 命令。
- en: The first feature of `\yii\rest\Controller` is to arrange the response output
    format, dynamically based on the request, which is also called **content negotiation**.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: '`\yii\rest\Controller` 的第一个特性是根据请求动态安排响应输出格式，这被称为 **内容协商**。'
- en: 'Indeed, we can try to launch this request through `http://hostname/yiiadv/api/web/test-rest/index`
    in our browser, or through specific tools using the GET verb and the `Accept`
    HTTP header set to `application/xml`, or by using `curl`, as follows:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 的确，我们可以尝试在我们的浏览器中通过 `http://hostname/yiiadv/api/web/test-rest/index` 启动此请求，或者通过使用
    GET 动词和将 `Accept` HTTP 头设置为 `application/xml` 的特定工具，或者使用 `curl`，如下所示：
- en: '[PRE8]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'In these cases, we will get a response based on the XML data:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 在这些情况下，我们将根据 XML 数据获得响应：
- en: '![Creating a controller](img/B04656_11_01.jpg)'
  id: totrans-63
  prefs: []
  type: TYPE_IMG
  zh: '![创建控制器](img/B04656_11_01.jpg)'
- en: The XML data response to test-rest/index
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: XML 数据响应到 test-rest/index
- en: 'However, if we change the `Accept` header to `application/json`, we will get
    a response based on the JSON data:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果我们将 `Accept` 头更改为 `application/json`，我们将根据 JSON 数据获得响应：
- en: '[PRE9]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'In these cases, we will get a response based on the JSON data:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 在这些情况下，我们将根据 JSON 数据获得响应：
- en: '![Creating a controller](img/B04656_11_02.jpg)'
  id: totrans-68
  prefs: []
  type: TYPE_IMG
  zh: '![创建控制器](img/B04656_11_02.jpg)'
- en: The JSON data response to test-rest/index
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: JSON 数据响应到 test-rest/index
- en: The same data will be rendered in different ways according to the `Accept` header
    sent from the client.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 根据客户端发送的 `Accept` 头，相同的数据将以不同的方式呈现。
- en: 'The second feature, HTTP method validation, allows you to specify which verbs
    are available for a resource. Verbs are defined in the `behaviors()` method, which
    must be extended to modify this setting:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个特性，HTTP方法验证，允许您指定资源可用的动词。动词在`behaviors()`方法中定义，必须扩展以修改此设置：
- en: '[PRE10]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: In this case, we only set the GET verb to the `index` action, because keys of
    the `actions` attribute of `behaviors['verbs']` are the actions and the value
    is an array containing supported HTTP methods.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们只将GET动词设置为`index`操作，因为`behaviors['verbs']`的`actions`属性的键是操作，值是一个包含支持的HTTP方法的数组。
- en: 'If we launch `http://hostname/yiiadv/api/web/test-rest/index` using the GET
    verb (as a browser request), we will continue to display the result. However,
    if we change the HTTP method to the POST verb, for example, we will get an exception
    error:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们使用GET动词（作为浏览器请求）启动`http://hostname/yiiadv/api/web/test-rest/index`，我们将继续显示结果。然而，如果我们将HTTP方法更改为POST动词，例如，我们将得到异常错误：
- en: '![Creating a controller](img/B04656_11_03.jpg)'
  id: totrans-75
  prefs: []
  type: TYPE_IMG
  zh: '![创建控制器](img/B04656_11_03.jpg)'
- en: An exception error using the wrong verb
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 使用错误的动词引发的异常错误
- en: This is because only the GET verb is supported by the `index` action.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 这是因为只有GET动词支持`index`操作。
- en: In the next sections, we will explain the third and fourth features, authentication
    and rate limiting.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将解释第三个和第四个特性，即身份验证和速率限制。
- en: Example – creating a controller to manage rooms
  id: totrans-79
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 示例 - 创建一个用于管理房间的控制器
- en: With this example, we will apply the concepts dealt with in the previous chapter,
    in this case using `\yii\rest\ActiveController` as the base class instead of `\yii\rest\Controller`,
    since we are going to employ an ActiveRecord class to manipulate data.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们将应用上一章中处理的概念，在这种情况下，使用`\yii\rest\ActiveController`作为基类而不是`\yii\rest\Controller`，因为我们打算使用ActiveRecord类来操作数据。
- en: 'Create a new controller in `api/controllers/RoomsController.php`:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 在`api/controllers/RoomsController.php`中创建一个新的控制器：
- en: '[PRE11]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'This controller implicitly contains these actions:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 此控制器隐式包含以下操作：
- en: '`actionIndex` that returns a list of models, accessible only with GET and HEAD
    HTTP methods'
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`actionIndex`返回模型列表，只能通过GET和HEAD HTTP方法访问'
- en: '`actionView` that returns details about the mode, accessible only with the
    GET and HEAD HTTP methods by passing the `id` parameter'
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`actionView`返回关于模型的详细信息，通过传递`id`参数，只能通过GET和HEAD HTTP方法访问'
- en: '`actionCreate` that creates a new model, accessible only with the POST HTTP
    methods'
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`actionCreate`用于创建新模型，只能通过POST HTTP方法访问'
- en: '`actionUpdate` that updates an existing model, accessible only with the PUT
    and PATCH HTTP methods'
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`actionUpdate`用于更新现有模型，只能通过PUT和PATCH HTTP方法访问'
- en: '`actionDelete` that deletes an existing model, accessible only with the DELETE
    HTTP method'
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`actionDelete`用于删除现有模型，只能通过DELETE HTTP方法访问'
- en: '`actionOptions` that returns the allowed HTTP methods'
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 返回允许的HTTP方法的`actionOptions`
- en: Now, let's try to launch all these methods.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们尝试启动所有这些方法。
- en: 'Launch `actionIndex` at `http://hostname/yiiadv/api/web/rooms` using the GET
    method:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 使用GET方法在`http://hostname/yiiadv/api/web/rooms`上启动`actionIndex`：
- en: '[PRE12]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'We will get all the records in the database as an array of the JSON object
    and HTTP header, along with the successful status code and pagination details:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将以JSON对象的数组形式以及HTTP头部、成功状态码和分页详情获取数据库中的所有记录：
- en: '[PRE13]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: If we launch the same URL using the HEAD HTTP method, we will only get the HTTP
    HEADER response without a body, so we will get only the pagination information.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们使用HEAD HTTP方法启动相同的URL，我们只会得到没有主体的HTTP头部响应，因此我们只会得到分页信息。
- en: 'Finally, if we launch the same URL with an unsupported HTTP method, for example
    the PUT method, we will get two important HTTP headers:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，如果我们使用不支持HTTP方法（例如PUT方法）启动相同的URL，我们将得到两个重要的HTTP头部：
- en: The `status code` header set to `405 Method Not Allowed`
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将`状态码`头设置为`405 方法不允许`
- en: The `Allow` header set to `GET, HEAD`
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将`Allow`头设置为`GET, HEAD`
- en: The `status code` header says that a method is not supported, and the `Allow`
    header returns a list of supported HTTP methods for that action.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '`状态码`头表明不支持该方法，而`Allow`头返回对该操作支持的HTTP方法列表。'
- en: 'Now, launch `actionView` on `http://hostname/yiiadv/api/web/rooms/view?id=1`
    using the GET method:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，使用GET方法在`http://hostname/yiiadv/api/web/rooms/view?id=1`上启动`actionView`：
- en: '[PRE14]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'If we try to launch a nonexistent ID, for example `http://hostname/yiiadv/api/web/rooms/view?id=100`,
    using the GET method, we will get this body response:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们尝试使用GET方法启动一个不存在的ID，例如`http://hostname/yiiadv/api/web/rooms/view?id=100`，我们将得到以下响应体：
- en: '[PRE15]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The HTTP `status code` header will be set to `404 Not Found` to specify that
    the requested item (`id=100`) does not exist. Using only the HEAD HTTP method,
    we will get information from the HTTP `status code` set to `404`. The `Create`
    and `Update` actions require that the client sends body content of the object
    to be created or updated.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: HTTP `状态码` 标头将被设置为 `404 Not Found` 以指定请求的项目（`id=100`）不存在。仅使用 HEAD HTTP 方法，我们将从设置为
    `404` 的 HTTP `状态码` 获取信息。`Create` 和 `Update` 动作要求客户端发送要创建或更新的对象的正文内容。
- en: 'By default, Yii recognizes only the `application/x-www-form-urlencoded` and
    `multipart/form-data` input formats. In order to enable the JSON input format,
    we need to configure the `parsers` property of the request''s application component
    in the `api/config/main.php` file:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，Yii 只识别 `application/x-www-form-urlencoded` 和 `multipart/form-data` 输入格式。为了启用
    JSON 输入格式，我们需要在 `api/config/main.php` 文件中配置请求应用程序组件的 `parsers` 属性：
- en: '[PRE16]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'After configuring the JSON input parser, we can call `http://hostname/yiiadv/api/web/rooms/create`
    using the POST HTTP method to create a new room and pass, for example, this JSON:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 在配置 JSON 输入解析器后，我们可以使用 POST HTTP 方法调用 `http://hostname/yiiadv/api/web/rooms/create`
    来创建一个新的房间，并传递例如以下 JSON：
- en: '[PRE17]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'If no error occurred, we will get:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有发生错误，我们将得到：
- en: '[PRE18]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'If we are missing some required fields and there are validation errors, we
    will get:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 如果缺少一些必需的字段并且存在验证错误，我们将得到：
- en: '[PRE19]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The same thing needs to be done for an update action, in this case, however,
    we will call `http://hostname/yiiadv/api/web/rooms/update` and pass the `id` URL
    parameter using the PUT or PATCH HTTP method. In this case, only the HTTP header
    status code `200 OK` will be a successful response and the update object will
    be returned as body content.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 对于更新操作，也需要做同样的事情，在这种情况下，然而，我们将调用 `http://hostname/yiiadv/api/web/rooms/update`
    并使用 PUT 或 PATCH HTTP 方法传递 `id` URL 参数。在这种情况下，只有 HTTP 标头状态码 `200 OK` 才是成功的响应，并且更新对象将作为正文内容返回。
- en: Finally, `actionDelete` is used by calling `http://hostname/yiiadv/api/web/rooms/delete`,
    by passing the `id` URL parameter, and using the DELETE HTTP method. A successful
    execution will return `204 No Content` as the HTTP status code; otherwise, it
    will be `404 Not Found`.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，通过调用 `http://hostname/yiiadv/api/web/rooms/delete` 并传递 `id` URL 参数，使用 DELETE
    HTTP 方法来使用 `actionDelete`。成功的执行将返回 `204 No Content` 作为 HTTP 状态码；否则，它将是 `404 Not
    Found`。
- en: Authentication
  id: totrans-115
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 认证
- en: 'There are three kinds of authentication:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 有三种认证方式：
- en: '**HTTP Basic Auth** (the `HttpBasicAuth` class): This method uses the WWW-Authenticate
    HTTP header to send the username and password for every request'
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**HTTP 基本认证** (`HttpBasicAuth` 类): 此方法使用 WWW-Authenticate HTTP 标头为每个请求发送用户名和密码'
- en: '**Query parameter** (the `QueryParamAuth` class): This method uses an access
    token passed as query parameter in the API URL'
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**查询参数** (`QueryParamAuth` 类): 此方法使用作为 API URL 查询参数传递的访问令牌'
- en: '**OAuth 2** (the `HttpBearerAuth` class): This method uses an access token
    that is obtained by the consumer from an authorization server and sent to the
    API server via HTTP bearer tokens'
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**OAuth 2** (`HttpBearerAuth` 类): 此方法使用由消费者从授权服务器获取的访问令牌，并通过 HTTP 承载令牌发送到 API
    服务器'
- en: Yii supports all the methods mentioned, but we can also easily create a new
    one.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: Yii 支持所有提到的方法，但我们也可以轻松地创建一个新的方法。
- en: 'To enable authentication, follow these steps:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 要启用认证，请按照以下步骤操作：
- en: Configure the user application component in the configuration, setting `enableSession`
    to `false` in order to make user authentication status not persistent using a
    session across requests. Next, set `loginUrl` to `null` to show the HTTP 403 error
    instead of redirecting it to the login page.
  id: totrans-122
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在配置中配置用户应用程序组件，将 `enableSession` 设置为 `false` 以确保用户认证状态在请求之间不持久化使用会话。接下来，将 `loginUrl`
    设置为 `null` 以显示 HTTP 403 错误而不是将其重定向到登录页面。
- en: Specify which authentication method we want to use, configuring the `authenticator`
    behavior in API controller classes.
  id: totrans-123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 指定我们想要使用的认证方法，在 API 控制器类中配置 `authenticator` 行为。
- en: Implement `yii\web\IdentityInterface::findIdentityByAccessToken()` in the user
    identity class.
  id: totrans-124
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在用户身份类中实现 `yii\web\IdentityInterface::findIdentityByAccessToken()`。
- en: Note
  id: totrans-125
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The first step ensures that REST requests are really stateless, but if you need
    to persist or store session data, you can skip this step.
  id: totrans-126
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 第一步确保 REST 请求确实是无状态的，但如果您需要持久化或存储会话数据，则可以跳过此步骤。
- en: 'Step 1 can be configured in `api/config/main.php`:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 第一步可以在 `api/config/main.php` 中配置：
- en: '[PRE20]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Step 2 requires that we extend the `behaviors()` controller method, specifying
    a single authenticator:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 第二步要求我们扩展 `behaviors()` 控制器方法，指定一个单独的认证器：
- en: '[PRE21]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Or we can do this by specifying multiple authenticators:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 或者我们可以通过指定多个认证器来完成这个操作：
- en: '[PRE22]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Finally, step 3 requires the implementation of `findIdentityByAccessToken()`
    of the `identityClass` specified in the configuration file.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，步骤 3 需要实现配置文件中指定的 `identityClass` 的 `findIdentityByAccessToken()`。
- en: 'In a simple scenario, the access token can be stored in a column of the `User`
    table and then retrieved:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 在一个简单场景中，访问令牌可以存储在 `User` 表的列中，然后检索：
- en: '[PRE23]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: At the end of the configuration, every request will try to authenticate the
    user in the `beforeAction()` method of the same controller.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 在配置的末尾，每个请求都会尝试在相同控制器的 `beforeAction()` 方法中认证用户。
- en: Now, let's take a look at the first authentication method, `HTTPBasicAuth`.
    This method requires us to set the `auth` property to the callable PHP function;
    if it is not set, the username will be used as the access token passed to the
    `\yii\web\User::loginByAccessToken()` method.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看第一种认证方法，`HTTPBasicAuth`。此方法要求我们将 `auth` 属性设置为可调用的 PHP 函数；如果没有设置，则将使用用户名作为传递给
    `\yii\web\User::loginByAccessToken()` 方法的访问令牌。
- en: 'The basic implementation of the `HttpBasicAuth` authentication is:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: '`HttpBasicAuth` 认证的基本实现是：'
- en: '[PRE24]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: The callable PHP function stored by the `auth` property can be represented as
    an inline function, or as an array, whose first value is the object and the second
    is the function name to be called, by passing `$username` and `$password` parameters.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 存储在 `auth` 属性中的可调用 PHP 函数可以表示为一个内联函数，或者作为一个数组，其中第一个值是对象，第二个是要调用的函数名，通过传递 `$username`
    和 `$password` 参数。
- en: Check how PHP is running through `phpinfo()`. If you display CGI/FCGI, then
    you need to add `SetEnvIf Authorization .+ HTTP_AUTHORIZATION=$0` in `.htaccess`
    to use HTTP Auth from PHP.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 检查 PHP 通过 `phpinfo()` 的运行情况。如果您显示 CGI/FCGI，那么您需要在 `.htaccess` 中添加 `SetEnvIf
    Authorization .+ HTTP_AUTHORIZATION=$0` 以使用 HTTP Auth 从 PHP。
- en: The second authentication method is query parameter, by using the `QueryParamAuth`
    class. With this method, a query parameter named `access-token` must be passed
    to the URL. Then, it will call the `\yii\web\user::loginByAccessToken()` method,
    passing `access-token` as the first parameter. This function will return an `IdentityInterface`
    or `null`.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 第二种认证方法是查询参数，通过使用 `QueryParamAuth` 类。使用此方法，必须将名为 `access-token` 的查询参数传递到 URL。然后，它将调用
    `\yii\web\user::loginByAccessToken()` 方法，将 `access-token` 作为第一个参数传递。此函数将返回 `IdentityInterface`
    或 `null`。
- en: 'The URL parameter name can be changed using `tokenParam` in the authentication
    declaration:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用 `tokenParam` 在认证声明中更改 URL 参数的名称：
- en: '[PRE25]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: With this configuration, the URL must be `http://hostname/url?myAccessToken=...`
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 使用此配置，URL 必须是 `http://hostname/url?myAccessToken=...`
- en: The last authentication method, OAuth 2, requires an authorization server from
    which we will get the bearer token to pass to the REST API server, which is similar
    to `QueryParamAuth`.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一种认证方法是 OAuth 2，它需要一个授权服务器，从该服务器我们将获取用于传递给 REST API 服务器的载体令牌，这与 `QueryParamAuth`
    类似。
- en: Example – using authentication to get a customers list
  id: totrans-147
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 示例 - 使用认证获取客户列表
- en: 'In this example, we are going to authenticate ourselves by using two methods
    at the same time: `HTTPBasicAuth` and `QueryParamAuth`. When using `QueryParamAuth`
    with an access token, we will first call a publically accessible action to get
    an access token that the user will pass to all the other actions as the query
    URL parameter.'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们将同时使用两种方法进行认证：`HTTPBasicAuth` 和 `QueryParamAuth`。当使用 `QueryParamAuth`
    并带有访问令牌时，我们首先调用一个公开可访问的操作来获取用户将传递给所有其他操作的访问令牌作为查询 URL 参数。
- en: We will start by creating a new model from the `Customer` database table and
    putting it into the `common/models` folder. Then, we will create a new user in
    the `User` database table using, for example, `foo` as the username and `$2a$12$xzGZB29iqBHva4sEYbJeT.pq9g1/VdjoD0S67ciDB30EWSCE18sW6`
    as the password (this is equivalent to the hashed bar text).
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先从 `Customer` 数据库表创建一个新的模型，并将其放入 `common/models` 文件夹中。然后，我们将使用 `foo` 作为用户名，`$2a$12$xzGZB29iqBHva4sEYbJeT.pq9g1/VdjoD0S67ciDB30EWSCE18sW6`
    作为密码（这相当于散列后的文本）在 `User` 数据库表中创建一个新的用户。
- en: 'Create a new controller in `api/controllers/CustomersController.php` that only
    extends the `behaviors()` method to implement `HTTPBasicAuth` and `QueryParamAuth`:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `api/controllers/CustomersController.php` 中创建一个新的控制器，该控制器只扩展 `behaviors()`
    方法以实现 `HTTPBasicAuth` 和 `QueryParamAuth`：
- en: '[PRE26]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: In `HTTPBasicAuth`, we implement the `auth` property inside the configuration
    array by checking `$username` and then validating the password. If the username
    and password match each other, it will return the user found or will otherwise
    be null.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 在`HTTPBasicAuth`中，我们通过检查`$username`并在配置数组中实现`auth`属性来验证密码。如果用户名和密码匹配，它将返回找到的用户或否则返回null。
- en: '`QueryParamAuth`, instead, does not need any property other than the class,
    since we will use `access-token` as the query parameter name. Nevertheless, to
    complete this task, we need an action that will return the related user''s access
    token after passing both the username and password.'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，`QueryParamAuth`不需要除类以外的任何属性，因为我们将以`access-token`作为查询参数名称。尽管如此，为了完成这个任务，我们需要一个操作，该操作在传递用户名和密码后返回相关用户的访问令牌。
- en: 'For this purpose, we will add the `actionAccessTokenByUser()` method, which
    looks for the user with the `$username` and `$password` parameters passed. If
    the user already exists, its `access_token` property will be updated with a random
    string, so every time we call this action, `access_token` will change and the
    previous one will be cancelled:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 为了这个目的，我们将添加`actionAccessTokenByUser()`方法，该方法查找带有`$username`和`$password`参数的用户。如果用户已经存在，其`access_token`属性将使用随机字符串更新，因此每次调用此操作时，`access_token`都会更改，上一个将被取消：
- en: '[PRE27]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Finally, to test `HTTPBasicAuth`, we need to pass the WWW-Authentication header
    by calling the `http://hostname/yiiadv/api/web/customers/index` URL.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，为了测试`HTTPBasicAuth`，我们需要通过调用`http://hostname/yiiadv/api/web/customers/index`
    URL来传递WWW-Authentication头。
- en: 'If we want to use `QueryParamAuth`, we need to:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想使用`QueryParamAuth`，我们需要：
- en: Get `access-token` returned from `http://hostname/yiiadv/api/web/customers/access-token-by-user`,
    by passing the username and hashed password
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过传递用户名和散列密码从`http://hostname/yiiadv/api/web/customers/access-token-by-user`获取`access-token`
- en: Call `http://hostname/yiiadv/api/web/customers/index?access-token`, by passing
    the access-token property value received from the previous request
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过传递从上一个请求中接收到的访问令牌属性值，调用`http://hostname/yiiadv/api/web/customers/index?access-token`
- en: '`QueryParamAuth` calls the `findIdentityByAccessToken()` function of `IdentityInterfaces`(the
    user mode ). So, check that the method is implemented, and if it''s not, implement
    it as follows:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: '`QueryParamAuth`调用`IdentityInterfaces`（用户模式）的`findIdentityByAccessToken()`函数。因此，请检查该方法是否已实现，如果没有，按照以下方式实现它：'
- en: '[PRE28]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Pay attention, as this way of using access tokens allows the use of the REST
    API with the same credentials for only one client at a time. This is because any
    time an `access-token-by-user` is called, a new `access-token` will be created.
    Therefore, it should be created a relation one-to-many between users and `access-token`
    in order to provide multiple clients with access using the same username/password
    credentials.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，这种使用访问令牌的方式允许同时只使用相同的凭据使用REST API。这是因为每次调用`access-token-by-user`时，都会创建一个新的`access-token`。因此，应该创建用户和`access-token`之间的一对多关系，以便为多个客户端提供使用相同的用户名/密码凭据的访问。
- en: New controller action
  id: totrans-163
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 新的控制器操作
- en: 'It is very simple to add new actions to the REST API controller. We only need
    to remember three differences in the web controller:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 向REST API控制器添加新操作非常简单。我们只需要记住在Web控制器中的三个区别：
- en: Verb setting for the new action
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 新操作的动词设置
- en: Authenticate the setting for the new action
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 验证新操作的设置
- en: Output for the new action
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 新操作的输出
- en: 'The first two steps are configured in the `behaviors()` method of the controller:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 前两个步骤在控制器的`behaviors()`方法中配置：
- en: '[PRE29]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: In the first part of the `behaviors()` method, we will only set the `get` and
    `head` HTTP methods to call the `myCustomAction` action. If we try to call this
    action with other HTTP methods, we will get a not supported exception.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 在`behaviors()`方法的第一个部分，我们只会将`get`和`head` HTTP方法设置为调用`myCustomAction`操作。如果我们尝试使用其他HTTP方法调用此操作，我们将得到一个不支持异常。
- en: In the last part of the `behaviors()` method, we will set it so that `myCustomAction`
    has not got authentication, since it is in the `except` property.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 在`behaviors()`方法的最后部分，我们将设置`myCustomAction`没有认证，因为它在`except`属性中。
- en: 'The third difference, output for the new action, states that we have different
    ways to return data. We can use:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 新操作的第三个区别，输出，表明我们有不同的方式来返回数据。我们可以使用：
- en: A key-value pair array to create a single object from scratch
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从头开始创建单个对象的关键值对数组
- en: An ActiveRecord instance to create a single object
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ActiveRecord实例用于创建单个对象
- en: An ActiveRecord array to create a list of objects
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ActiveRecord数组用于创建对象列表
- en: A data provider
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据提供者
- en: In this last case, the framework will automatically output pagination information
    and links to other pages (if present).
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 在最后这种情况中，框架将自动输出分页信息和链接到其他页面（如果有的话）。
- en: Example – getting a rooms list for a reservation
  id: totrans-178
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 示例 - 获取预订的房间列表
- en: In this example, we need to create a `Reservation` model in the `common/models`
    folder using Gii.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们需要在 `common/models` 文件夹中使用 Gii 创建一个 `Reservation` 模型。
- en: 'Then, we create a new controller in `api/controllers/ReservationsController.php`:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们在 `api/controllers/ReservationsController.php` 中创建一个新的控制器：
- en: '[PRE30]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Now, let's call `http://hostname/yiiadv/api/web/reservations/index-with-rooms`,
    where we will display a list of reservations, in each of which the `room` property
    is expanded together with the content of room object related to the reservation.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们调用 `http://hostname/yiiadv/api/web/reservations/index-with-rooms`，我们将显示一个预订列表，其中每个预订的
    `room` 属性都与相关的房间对象内容一起展开。
- en: Note
  id: totrans-183
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'Take care to ensure that the `room` relation already exists in the `Reservation`
    model. If not, we must add this relation to the `Reservation` model:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意确保 `room` 关系已在 `Reservation` 模型中存在。如果没有，我们必须将此关系添加到 `Reservation` 模型中：
- en: '[PRE31]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: However, this solution is inefficient since we always get all the rows and if
    there are too many of them, this can result in it being too expensive for us.
    To solve this problem, we could use a DataProvider created from a set of data
    found, or better yet, a more simple solution automatically provided by Yii.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这个解决方案效率不高，因为我们总是获取所有行，如果行数太多，这可能会对我们来说成本过高。为了解决这个问题，我们可以使用从找到的一组数据创建的数据提供程序，或者更好的是，使用
    Yii 自动提供的更简单的解决方案。
- en: Indeed, Yii provides some easy ways to display relations and filter returned
    fields. For example, there could be fields that we do not want to show, such as
    a password, private data, and so on.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 事实上，Yii 提供了一些简单的方法来显示关系和过滤返回字段。例如，可能有一些我们不希望显示的字段，如密码、私人数据等。
- en: 'Models have these methods:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 模型有这些方法：
- en: '`fields()`: By default, classes that extend `yii\base\Model::fields()` return
    all the model attributes as fields, while classes that extend `yii\db\ActiveRecord::fields()`
    only return the attributes that have been populated from the DB'
  id: totrans-189
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`fields()`: 默认情况下，扩展 `yii\base\Model::fields()` 的类返回所有模型属性作为字段，而扩展 `yii\db\ActiveRecord::fields()`
    的类仅返回已从数据库中填充的属性'
- en: '`extraFields()`: By default, classes that extend `yii\base\Model::extraFields()`
    return nothing, while classes that extend `yii\db\ActiveRecord::extraFields()`
    return the names of the relations that have been populated from the DB'
  id: totrans-190
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`extraFields()`: 默认情况下，扩展 `yii\base\Model::extraFields()` 的类返回空值，而扩展 `yii\db\ActiveRecord::extraFields()`
    的类返回已从数据库中填充的关系的名称'
- en: The first method, `fields()`, is a key-value array where the key is the name
    of the field returned. The value can be empty if the returned content is the attribute
    with the same name as the key, a string indicating which attribute to get the
    returned value from, or a callable PHP function to manipulate the returned value.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 第一种方法，`fields()`，是一个键值数组，其中键是返回字段的名称。如果返回的内容与键具有相同的名称，则值可以为空；也可以是一个表示从哪个属性获取返回值的字符串，或者是一个可调用的
    PHP 函数来操作返回值。
- en: The second method, `extraFields()`, is a string array whose values are relations
    defined in the model class.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 第二种方法，`extraFields()`，是一个字符串数组，其值是在模型类中定义的关系。
- en: Finally, to dynamically filter the requested field, we append the `fields` parameter
    to the requested URL and the `expand` parameter to get a list of relations from
    the models.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，为了动态过滤请求的字段，我们将 `fields` 参数附加到请求的 URL 上，并将 `expand` 参数用于从模型获取关系列表。
- en: So, if we call `http://hostname/yiiadv/api/web/reservations/index?expand=room`,
    we will get the same result but we will also have the pagination and loaded models
    that are only necessary for that page.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，如果我们调用 `http://hostname/yiiadv/api/web/reservations/index?expand=room`，我们将得到相同的结果，但我们还将拥有仅对该页面必要的分页和加载的模型。
- en: However, it would be more convenient for us to distribute an URL without special
    parameters, such as the `expand` and `fields`, for example, in order to avoid
    confusion among developers who will use these APIs.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，对我们来说，分发不带特殊参数的 URL 会更方便，例如 `expand` 和 `fields`，例如，为了避免使用这些 API 的开发者之间的混淆。
- en: 'We can use `actionIndexWithRooms` as a wrapper for `actionIndex` with an expanded
    parameter in this way:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用 `actionIndexWithRooms` 作为 `actionIndex` 的包装器，并以此方式包含展开参数：
- en: '[PRE32]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: With this solution, the `http://hostname/yiiadv/api/web/reservations/index-with-rooms`
    URL is simply a wrapper for h`ttp://hostname/yiiadv/api/web/reservations/index?expand=room`
    but this prevents developers from having to remember which parameters to pass
    to the URL to obtain the necessary nodes in the response.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这个解决方案，`http://hostname/yiiadv/api/web/reservations/index-with-rooms` URL只是
    `http://hostname/yiiadv/api/web/reservations/index?expand=room` 的包装器，但这阻止了开发者记住需要传递哪些参数到URL以获取响应中的必要节点。
- en: Customizing authentication and response
  id: totrans-199
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 自定义身份验证和响应
- en: Yii allows us to quickly create a custom authentication method for our application.
    This is useful because in some cases, the previously mentioned authentications
    are not sufficient.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: Yii 允许我们快速为我们的应用程序创建自定义的身份验证方法。这很有用，因为在某些情况下，之前提到的身份验证方法是不够的。
- en: 'A custom authentication model can be made by extending the `yii\filters\auth\AuthMethod`
    class, which implements `yii\filters\auth\AuthInterface` that requires overriding
    the `authenticate` (`$user`, `$request`, and `$response`) method:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 通过扩展 `yii\filters\auth\AuthMethod` 类来创建自定义身份验证模型，该类实现了 `yii\filters\auth\AuthInterface`，需要重写
    `authenticate` (`$user`, `$request`, 和 `$response`) 方法：
- en: '[PRE33]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Even though the REST API should be stateless, or rather should not save session
    data, it could be necessary to store some information or preferences during a
    session across requests.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管REST API应该是无状态的，或者说不应该保存会话数据，但在会话期间跨请求存储一些信息或首选项可能是必要的。
- en: So, if we need to support a session, we can start it through the `authenticate()`
    method called in the `beforeAction()` event. The idea is to use `QueryParamAuth`
    using `access-token` as the session ID to identify the current session.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，如果我们需要支持会话，我们可以通过在 `beforeAction()` 事件中调用的 `authenticate()` 方法来启动会话。想法是使用
    `QueryParamAuth`，使用 `access-token` 作为会话 ID 来标识当前会话。
- en: For this purpose, we will create a new folder in `api\components` to store the
    custom `SessionAuth` method.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 为了这个目的，我们将在 `api\components` 中创建一个新的文件夹来存储自定义的 `SessionAuth` 方法。
- en: 'This is the content of the `api/components/SessionAuth.php` file where the
    query URL parameter is named `sid`:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 这是 `api/components/SessionAuth.php` 文件的内容，其中查询URL参数被命名为 `sid`：
- en: '[PRE34]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: It is also necessary to create an action to start the session; otherwise, the
    user will not be stored in the session.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 同时，创建一个用于启动会话的操作也是必要的；否则，用户将不会被存储在会话中。
- en: 'So, create a new controller called `UsersController` in `api/controllers/UsersController.php`
    to handle the login:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在 `api/controllers/UsersController.php` 中创建一个新的控制器 `UsersController` 来处理登录：
- en: '[PRE35]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: As earlier defined, in the `behaviors()` method, the actions of this controller,
    except for `login`, will authenticate against the `SessionAuth` component that
    checks primarily whether a user has successfully executed the login action.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，在 `behaviors()` 方法中，除了 `login` 之外，这个控制器的所有操作都将对 `SessionAuth` 组件进行身份验证，该组件主要检查用户是否成功执行了登录操作。
- en: We now call `http://hostname/yiiadv/api/web/users/login?username=&passwordHash=`
    and fill out the `username` and `passwordHash` fields. It returns the session
    ID to access the session data. Also, the `loggedUser` property is filled out in
    the session with the user model data.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在调用 `http://hostname/yiiadv/api/web/users/login?username=&passwordHash=`
    并填写 `username` 和 `passwordHash` 字段。它返回会话 ID 以访问会话数据。此外，会话中的 `loggedUser` 属性会填充用户模型数据。
- en: Now, we can store shared information among requests as a typical web application.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以像典型的Web应用程序一样在请求之间存储共享信息。
- en: Now, let's see how to customize a response in RESTful Web Services. First of
    all, this operation could be needed when we have to add, for example, extra information,
    such as explicit error messages to display in the client or operation status code.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看如何在 RESTful Web 服务中自定义响应。首先，当我们需要添加额外的信息时，例如在客户端显示的显式错误消息或操作状态码，这个操作可能是必要的。
- en: 'The custom response must extend `\yii\web\Response` and override the `send()`
    method, as follows:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 自定义响应必须扩展 `\yii\web\Response` 并重写 `send()` 方法，如下所示：
- en: '[PRE36]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: This `send()` method manipulates data stored in the object properties, mainly
    in the `$this->data` variable.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 这个 `send()` 方法操作对象属性中存储的数据，主要在 `$this->data` 变量中。
- en: This customization, which we will see in detail in the next example, is incomplete,
    as the `send()` method should implement all the manipulations of data made from
    the `\yii\web\Response` version. We must remember that Yii returns data based
    on the `Accept` HTTP header passed from the client and many other convenient functionalities.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
- en: 'It is possible to maintain this behavior simply by calling `parent::send()`
    before returning from the `send()` function, as follows:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Because, as said before, `send()` uses the `$this->data` variable as a container
    for data to be sent.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
- en: Example – status response node in data received
  id: totrans-222
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now, let's apply the concepts seen in the previous chapter to add extra data
    into a response. This practice is useful when we need to return to client information
    about the operation status and extra data such as detailed error messages.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
- en: 'The purpose of this example is to return a response with two attributes:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
- en: 'The `status` attribute containing three properties: `response_code` with an
    integer value indicating the operation state, `response_message` with a string
    value representation of `response_code` and `response_extra` with a custom text
    string'
  id: totrans-225
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `data` attribute containing the expected output data
  id: totrans-226
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We will use a class containing all the integer codes and their text representations
    as a response code, since the integer value will be used to fill in the `response_code`
    property and a string representation to fill in the `response_message` property.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new class file in `api/components/ApiResponseCode.php` with this content:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: In this component, we defined a list of constants that represent all response
    codes that can be sent to a client. For each response code, there will be a relative
    text representation returned by the `responseMessage()` static method. Then, there
    will also be an array of extra text messages returned by `responseExtras()` that
    will fill the `response_extra` property if no specific text `extra` is passed.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, we must write the component that extends `\yii\web\Response` named
    `ApiResponse` in `api/components/ApiResponse.php`. In this component, we will
    define three custom properties: `statusResponseCode`, `statusResponseMessage`,
    and `statusResponseExtra`, which we are going to fill with content composing in
    the `status` property.'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
- en: In this way, we will have a convenient method, `fillStatusResponse()`, based
    on the `$code` parameter, which will automatically fill in both the `statusResponseExtra`
    and `statusResponseMessage` properties.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
- en: The core of this component is the overridden `send()` method that will return
    `status` with `ERR_OK` as response message and `0` as response code by default
    if there are no client errors (as authentication, not found, and so on.). This
    is unless a developer changes the values of `statusResponseCode`, `statusResponseExtra`,
    and `statusResponseMessage`, or manually or automatically calls its properties
    with `fillStatusResponse()`.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
- en: Otherwise, if there are some client errors, we will support `Not Authenticated`
    and `Not Found` errors.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
- en: 'This is the content of the `api/components/ApiResponse.php` file:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Finally, we have to change the configuration file `api/config/main.php` by
    adding the `response` property as a component to indicate to use a custom response
    class:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Let's make some attempts. Try to call the non-existent URL `http://hostname/yiiadv/api/web/reservations/index-inexistent`.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
- en: 'This will be the output, correctly returning data as null and the status with
    the error explained:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
- en: '![Example – status response node in data received](img/B04656_11_04.jpg)'
  id: totrans-241
  prefs: []
  type: TYPE_IMG
- en: The response with an error after calling a non-existent URL
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, try to call a URL that requires authentication: `http://hostname/yiiadv/api/web/customers/index`,
    which we already implemented in the previous paragraphs.'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
- en: 'This will be the output, correctly returning data as null and the status with
    the error explained:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
- en: '![Example – status response node in data received](img/B04656_11_05.jpg)'
  id: totrans-245
  prefs: []
  type: TYPE_IMG
- en: The response with an error when calling the URL with authentication
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, we try to call a URL that returns data: `http://hostname/yiiadv/api/web/rooms/index`,
    which is already implemented in the previous paragraphs.'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
- en: 'This will be the output, correctly returning data as filled and successful
    as the status:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
- en: '![Example – status response node in data received](img/B04656_11_06.jpg)'
  id: totrans-249
  prefs: []
  type: TYPE_IMG
- en: A response with a successful output
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
- en: Other forms of export – RSS
  id: totrans-251
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Yii allows us to create a custom format response to output data. The response
    format can be changed based on the `Accept` HTTP header sent by the client or
    done programmatically. When Yii receives a request, it searches for an available
    response formatter based on the `Accept` HTTP header value and finally calls the
    `format` (`$response`) method of the response formatter found.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
- en: 'Therefore, there are three steps to create custom responses:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
- en: Implementing the `yii\web\ResponseFormatterInterface` interface.
  id: totrans-254
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Adding a new custom formatter response property in the configuration file.
  id: totrans-255
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Extending the `behaviors()` method of the controller to handle specific `Accept`
    HTTP header values.
  id: totrans-256
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The first step requires us to implement the `yii\web\ResponseFormatterInterface`
    interface and extend its method `format` (`$response`). Data to be formatted is
    stored in the `$response->data` property, and the response to client must be filled
    out in the `$response->content` property:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'The second step requires us to add a reference to the custom response formatter.
    For this purpose, we will use the `formatters` property of `response`, which is
    an array where keys are the format names, and the array values are the corresponding
    configurations to create formatter objects:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'The third step requires us to extend the `behaviors()` method of the controller
    in order to handle specific `Accept` HTTP header values and indicate to the framework
    which response formatter to use according to the `Accept` HTTP header value, for
    example:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: When a client sends a request with the `Accept` HTTP header set to `application/rss+xml`,
    this controller will use the `rss` formatter (read from the configuration file)
    to prepare the response. If we specify a formatter that does not exist in the
    configuration file, we will get `InvalidConfigException`.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
- en: Example – creating an RSS with a list of available rooms
  id: totrans-264
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now, let's look at how to create an RSS response formatter for the available
    rooms.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
- en: 'First of all, we must create the complete response formatter component in `api/components/RssResponseFormatter.php`:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: The RSS response formatter must implement the `format` (`$response`) method
    to correctly implement `yii\web\ResponseFormatterInterface`. When the `format`
    (`$response`) method is invoked, it will set the `Content-Type` HTTP header to
    `application/rss+xml`, use data that is ready to be sent from the `$response->data`
    property, and fill in the `$response->content` property, which is the final content
    received by the client.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, we must change the `api/config/main.php` file to add the `response` property
    with the support of the new response formatter:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: The `formatter` property is an array of the response formatter where the keys
    are the format names and the values are the corresponding configurations to create
    formatter objects.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
- en: In this case, we configured a new formatter called `rss` that represents the
    `\api\components\RssResponseFormatter` component.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we have to configure the `behaviors()` method in the controller to
    handle the `Accept` HTTP header with the `application/rss+xml` value.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
- en: 'Open the `RoomsController` file in `api/controllers/RoomsController.php` and
    add the extension to the `behaviors()` method:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: Starting from the base configuration of `$behaviors` inherited from `parent::behaviors()`,
    the `contentNegotiator` attribute contains a reference to `formats` for the `Accept`
    HTTP header value. The array keys are the `Accept` HTTP header value that is supported,
    and the values are the corresponding response formatter.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
- en: 'If we try to make the following request:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  id: totrans-278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'We should display the following response:'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
- en: '![Example – creating an RSS with a list of available rooms](img/B04656_11_07.jpg)'
  id: totrans-280
  prefs: []
  type: TYPE_IMG
- en: The RSS response output
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
- en: We can also use the response formatter programmatically. It is enough to set
    the format of the `Yii::$app->response` application component to a configured
    response formatter in the configuration file.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, we can add a new action named `actionIndexRss` in `RoomsController`
    that will output data using `RssResponseFormatter` in this way:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: Summary
  id: totrans-285
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we created `api` for use in a mobile app through the use of
    the powerful tools provided by Yii. We adopted the approach of creating a new
    application in order to distribute RESTful web services, instead of mixing web
    and `api` controllers. For this purpose, at the beginning of the chapter, we configured
    a new REST application using the advanced template.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
- en: After configuring the RESTful web service environment, we discovered two kinds
    of `api` controllers that Yii provides by default, then we created controllers
    with custom data and data from ActiveRecord.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 在配置好RESTful网络服务环境之后，我们发现Yii默认提供了两种`api`控制器，然后我们创建了带有自定义数据和来自ActiveRecord的数据的控制器。
- en: Next, we found out the default authentication methods for RESTful Web Services
    provided by framework and you learned how to use them.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 接着，我们了解了框架提供的RESTful网络服务的默认认证方法，并学习了如何使用它们。
- en: Finally, we focused on how to customize the response output format, taking an
    example of how to create an RSS version of the available data.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们关注了如何自定义响应输出格式，以创建可用数据的RSS版本为例。
- en: In the next chapter, you will learn how to write a console application and will
    look at the differences between web and console apps.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，你将学习如何编写控制台应用程序，并了解网络应用程序和控制台应用程序之间的区别。
