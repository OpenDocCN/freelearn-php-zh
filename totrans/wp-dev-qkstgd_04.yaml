- en: Building Custom Modules with Plugin Development
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Enormous free plugin base and plugin-based architecture are the keys to success
    of WordPress as a CMS. Plugins allow developers to build independent features
    as well as connect with the modules developed by other developers. We can use
    plugins to build quality sites with the code written by the top WordPress developers
    in the world, without spending a single dollar. From the developer's perspective,
    plugins allow you to reach and help thousands of users while being able to promote
    your skills as a developer. Anyone who has basic programming knowledge can create
    plugins to meet application-specific requirements. However, it takes considerable
    effort to develop quality plugins that can be reused across a wide range of projects.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, you will learn about the concept of plugins and how they are
    different from your theme. You will also go through the life cycle events of a
    proper plugin while creating a post attachments plugin to illustrate the use of
    these events. The primary concepts in plugin development such as data validation,
    sanitization, and nonce will be introduced. Understanding how to leverage existing
    WordPress features to build plugins that can be added or removed without affecting
    the other parts is the highlight of this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the role of plugins in development
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a basic plugin from scratch
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Exploring the life cycle of a plugin
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Developing a post attachment plugin
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Identifying the advantages of custom plugin development
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Guidelines for building quality plugins
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By the end of this chapter, you should be able to understand the role of plugins
    and have the necessary knowledge to build a basic plugin from scratch using the
    recommended practices.
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You will be required to have WordPress 4.9.8 installed to follow this procedure.
    Even if you
  prefs: []
  type: TYPE_NORMAL
- en: have a later version of WordPress, the described examples should work with no
    significant problems.
  prefs: []
  type: TYPE_NORMAL
- en: 'The code files of this chapter can be found on GitHub:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://github.com/PacktPublishing/WordPress-Development-Quick-Start-Guide/tree/master/Chapter04](https://github.com/PacktPublishing/WordPress-Development-Quick-Start-Guide/tree/master/Chapter04)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Check out the following video to see the code in action:'
  prefs: []
  type: TYPE_NORMAL
- en: '[http://bit.ly/2Py2szO](http://bit.ly/2Py2szO)'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the role of plugins
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A plugin is a set of functions dedicated to work as an independent solution,
    while extending or adding new features to WordPress. In WordPress, plugins are
    similar to the Apps we use in iOS and Android. We have the ability to use or remove
    any plugin without affecting WordPress's core features. Also, plugins allow us
    to separate independent features into their own plugins, making them easier to
    maintain. The [wordpress.org](http://wordpress.org) plugin base has over 50,000
    free plugins, and sometimes you don't have to develop anything for WordPress websites.
    You can just use a number of plugins and integrate them properly to build advanced
    features.
  prefs: []
  type: TYPE_NORMAL
- en: The role of plugins is vital for the development of a site. In [Chapter 3](94db5df8-bbb4-4e75-ae88-fa38a9aabe05.xhtml),
    *Designing Flexible Frontends with Theme Development*, we discussed the role of
    a theme, and the features beyond the scope of a theme. Basically, any feature
    beyond the scope of a theme should be developed with plugins. However, there are
    scenarios where we will also use plugins to develop theme-specific things like
    templates and styles so that they are compatible with multiple themes. In most
    scenarios, plugins should either use their own styles and designs or default to
    the styles of the theme. It's not ideal to develop plugins focusing on a specific
    theme as it's almost impossible to switch to another theme at later stages.
  prefs: []
  type: TYPE_NORMAL
- en: 'In development, building plugins can range from just a few lines of code with
    filter implementations to advanced modules with thousands of lines of code. Let''s
    take a look at some of the common types of development tasks with plugins:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Building reusable blocks**: WordPress sites are mostly built by non-technical
    site owners and hence building the blocks of simple features is a common task.
    These blocks allow the client to add the feature anywhere in the site without
    needing a developer. We can use shortcodes or widgets to provide features as reusable
    blocks. In modern sites, page builders are used frequently to build the page''s
    design. Therefore, we can also develop components for page builders that are to
    be used as reusable blocks.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Modifying built-in features**: This is a must for many sites, especially
    for extending the backend features and customizing the backend display. Since
    these are built-in features, we can''t modify the WordPress file to customize
    them. Therefore, we need to choose actions and filters of built-in features and
    implement them with the use of plugins.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Data capturing and displaying**: This is another common type of requirement,
    especially for sites that go beyond basic blogs. In these kinds of tasks, we need
    to create custom forms in the frontend, and either use backend features to store
    the data or create our own data storage. Built-in custom post types and custom
    build forms are used to handle such requirements.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Integrating UI components**: Modern websites are filled with interactive
    user interface components that are designed to display substantial data in a limited
    space. These components are mostly powered by open source JavaScript libraries.
    So, integrating these libraries and letting administrators add data to these components
    is another common requirement.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These are some of the challenges you face when working on a specific WordPress
    site. The process of building plugins to handle these types of requirements is
    essential for WordPress developers and hence we will be covering them in upcoming
    chapters. However, if you are planning to develop your own plugin, the challenges
    and possibilities are enormous. We can explore the WordPress plugin directory
    to understand what a plugin can do and the scope involved.
  prefs: []
  type: TYPE_NORMAL
- en: WordPress plugin types based on features
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As you explore, you will understand that the roles of plugins may vary from
    one another. So, it''s important to identify these different types of plugins
    in order to face the challenges in extending different WordPress modules. Here,
    we are going to choose some of the popular plugins of different plugin types and
    discuss how they interact with WordPress''s frontend and backend. This is purely
    a personal preference and hence you may want to categorize them differently after
    exploring the plugin directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Yoast SEO** ([https://wordpress.org/plugins/wordpress-seo/](https://wordpress.org/plugins/wordpress-seo/)):
    This plugin is used to improve the SEO of the site by adding necessary content
    to pages. This type of plugin has interfaces in the backend, where we can add
    content or settings. However, these plugins work under the hood in the frontend
    as we can''t see any content. The examples for this type includes plugins from
    caching, analytics, and translation categories.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**WordPress Importer** ([https://wordpress.org/plugins/wordpress-importer/](https://wordpress.org/plugins/wordpress-importer/)):
    This plugin imports data into the WordPress database from files. These types of
    plugins don''t have any features in the frontend or backend interfaces. Instead,
    these plugins are used to provide functionality by changing database values. The
    examples for these types of plugins include Duplicate Post and All-in-One WP Migration.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**WooCommerce** ([https://wordpress.org/plugins/woocommerce/](https://wordpress.org/plugins/woocommerce/)):
    This plugin is used to simplify the online shopping process by creating and selling
    products. These types of plugins have interfaces in the backend to add content
    as well as interfaces in the frontend to display the content. Apart from that,
    these plugins contain extensive data processing. This is the most common type
    of plugin you will get for development tasks. The examples for this type of plugin
    include BuddyPress and bbPress.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Meta Slider** ([https://wordpress.org/plugins/ml-slider/](https://wordpress.org/plugins/ml-slider/)):
    This plugin adds elegant image sliders to the frontend of the site. These types
    of plugins have backend interfaces for adding content and frontend interfaces
    for displaying the content inside modern UI elements. However, no data processing
    is involved. The examples for this type of plugin include Easy FancyBox and Max
    Mega Menu.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Admin Menu Editor** ([https://wordpress.org/plugins/admin-menu-editor/](https://wordpress.org/plugins/admin-menu-editor/)):
    This plugin allows you to change the menus and the related settings. These types
    of plugins allow you to add, change, and remove built-in backend features to suit
    your needs. There is no interaction with the frontend or data in such plugins.
    The examples for this type of plugin include Admin Columns and Simple Page Ordering.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Easy Google Fonts** ([https://wordpress.org/plugins/easy-google-fonts/](https://wordpress.org/plugins/easy-google-fonts/)):
    This plugin allows you to use Google Fonts for the content of the site. These
    types of plugins often don''t have functionality related to the backend or frontend.
    Instead, they connect third-party services with WordPress. The examples for this
    type of plugin include AddToAny Share Buttons and Google Doc Embedder.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Advanced Custom Fields** ([https://wordpress.org/plugins/advanced-custom-fields/](https://wordpress.org/plugins/advanced-custom-fields/)
    ): This plugin acts as a framework, letting developers and clients build forms
    using existing components. These types of plugins interacts with both the backend
    and the frontend. However, these plugins don''t provide site-specific features.
    Instead, the administrator decides which elements are displayed to the user and
    how the data is processed. Examples of such plugins include Elementor Page Builder
    and Pods Custom Content Types and Fields.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The types of plugins we can build is enormous and can't be covered here, even
    if we were to have a complete chapter dedicated to them. Therefore, we have chosen
    a few plugins that contain the most popular types of development tasks.
  prefs: []
  type: TYPE_NORMAL
- en: Creating your first plugin
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The process of developing a simple plugin is not complex. It follows the same
    process we used for themes, where we used PHP header comments. First, you have
    to create a new directory inside `wp-content/plugins`, with a preferred name.
    In this example, we are going to name it `wpquick-after-post-content`. Once the
    plugin directory has been created, we can create the main plugin file, which is `wpquick-after-post-content.php`.
    You can use the preferred name for the main plugin file. Now, we have to add the
    following header comments section to define it as a plugin:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The plugin definition comment is similar to the theme definition, where Theme
    Name and Theme URI are being replaced by Plugin Name and Plugin URI. Once the
    comment has been added, this directory becomes a plugin and you can refresh the
    backend plugins list to reflect the plugin's details. Now, you can add any PHP
    code within the main plugin file or sub-files to begin development with WordPress.
    The only thing that differs from usual PHP development is the use of WordPress
    hooks. We will be introducing the necessary hooks throughout this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s add some functionality to the plugin. We have named this plugin After
    Post Content. The functionality is to add dynamic content after each post in the
    site. In [Chapter 3](94db5df8-bbb4-4e75-ae88-fa38a9aabe05.xhtml), *Designing Flexible
    Frontends with Theme Development*,we added a dynamic advertisement bar to the
    header section. Here, we will be displaying the same advertisement, after the
    post content. Consider the following code for the implementation of this feature:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: This code is added to the main plugin file, just after the header comments section.
    Usually, we have to modify the post template to add such content in pure PHP development.
    In WordPress, everything is hooked into an action or a filter, and hence we can
    use them without modifying the template files. Here, we have used the `the_content`
    filter with a callback function. We already discussed the use of filters in [Chapter
    3](94db5df8-bbb4-4e75-ae88-fa38a9aabe05.xhtml), *Designing Flexible Frontends
    with Theme Development*. This filter is used to modify the post/page content and
    is included in all of the properly coded themes. The default post content is passed
    to this filter and plugins can alter this content by implementing this hook.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this scenario, we have used the `is_singular` function for the conditional
    check. This function is used to check if we are viewing the single page of any
    given post type. Once the condition is matched, we add the dynamic advertisement
    bar after the existing post content. Now, you can create and view a new post in
    the frontend. The content we added will be displayed in a similar fashion as to
    what''s shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/381ff567-4078-42ad-bfa8-2ee4118b5ef5.png)'
  prefs: []
  type: TYPE_IMG
- en: We have created a simple plugin in a very short time span. WordPress plugins
    can range from a few lines of code like this one, to advanced systems with thousands
    of lines of code. So, as we can see, developing WordPress plugins is not hard.
    It's always a good option to separate even a few lines of codes into a separate
    plugin, assuming that the functionality can be useful for many sites. In this
    example, we only added a fixed bar to each and every post. In real world implementations,
    we will have to change these advertisements as well as have the ability to add
    them to each post from the backend.
  prefs: []
  type: TYPE_NORMAL
- en: Exploring the life cycle of a plugin
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A product life cycle is a series of events or stages that occur from the start
    to the completion of the product or process. WordPress plugins contain life cycle
    events, from initial activation to uninstallation. It's important to understand
    all of these events to keep the plugin working and make the data consistent, even
    after exiting the plugin. Many developers are aware of only a few of these events,
    leading to low quality plugins.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this section, we are going to look at the life cycle of a plugin and how
    we can manage each of the events in the cycle. Consider the following diagram
    for a basic illustration of events in a plugin:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/af75db8e-1305-4d44-a83b-6c02c55ba834.png)'
  prefs: []
  type: TYPE_IMG
- en: 'As you can see, the life cycle of a plugin has five events, apart from its
    functionality. A plugin starts the cycle via an activation event. The cycle is
    completed with either deactivate or uninstall events, until it starts the cycle
    again with activation. Let''s understand these five events:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Activation**: This is a built-in event that''s fired by clicking the Activate
    button from the WordPress plugin list or installation screen. This can be used
    for executing certain actions upon activation as well as to initialize the plugin
    data and settings. Ideally, the initialization tasks should be done through a
    separate installation process since plugin activation is not a one-time event.
    However, a limited number of plugins offer a separate installation process, as
    it''s a plugin-specific event. Therefore, most developers will use WordPress''s
    built-in activation process to initialize the plugins with necessary condition
    checks. Adding rewrite rules, creating/modifying database tables, adding default
    settings. and creating demo data are some of practical functions that are executed
    in the activation process.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Installation**: This is not a built-in event, and most WordPress plugins
    use the activation event for installation. However, we may need a step by step
    installation process like WordPress for complex plugins. With this, we can implement
    our own installation process by using custom code after the activation. You can
    install WooCommerce to check how the plugin-specific installation process is handled
    with custom screens.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Upgrading**: This is a built-in event for plugins in the WordPress plugin
    repository and is used just after the version upgrade has completed. However,
    this event is not available for other plugins unless we build a custom upgrade
    process to get the files from our own server. Therefore, we need to handle this
    by combining existing WordPress hooks and conditional checks in scenarios where
    we don''t have a custom automatic upgrade process. This event can be used for
    adding default values for additional settings in new versions, altering database
    tables, converting existing data to a new format, and so on.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Deactivation**: This is a built-in event that''s fired by clicking the Deactivate
    link from the WordPress plugin list. This action should be used to execute certain
    tasks before the plugin is deactivated. Often, developers misunderstand the use
    of this action and tend to use it as an uninstallation process. Deactivation is
    a temporary event and hence you should not delete plugin data within this hook.
    Ideally, this event should be used for functions such as removing rewrite rules,
    clearing the cache, and temporary database values.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Uninstallation**: This is also a built-in event that''s fired by clicking
    the Delete link from the WordPress plugins list. This is the proper event to handle
    uninstallation and must be used to clear plugin-specific data. Many plugins don''t
    have an uninstallation process, leaving the plugin data in the database. Once
    a plugin is deactivated, the plugin data doesn''t affect the site''s features.
    However, this data affects the site''s performance, and also makes it prone to
    conflicts with plugins that will be used in the future. Therefore, it''s important
    to implement the uninstall event for a plugin as well as instruct the user on
    what happens upon uninstallation.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the next section, we will be developing a plugin while using the most important
    and mandatory life cycle events of a plugin.
  prefs: []
  type: TYPE_NORMAL
- en: Developing a post attachments plugin
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the two preceding sections, we discussed the steps for building a basic plugin
    and the life cycle events. In this section, we will be developing a plugin, while
    covering the implementation of life cycle events and critical features in plugin
    development. Let's summarize the requirement of the plugin.
  prefs: []
  type: TYPE_NORMAL
- en: The use of blog posts and displaying dynamic content after the post is common
    in most WordPress sites. We already looked at the process of adding content after
    the post, in the first plugin we developed. Now, we are going to extend the feature
    to allow attachment downloads after the post. In some sites, it's essential to
    allow users to download files related to the post. This plugin will allow the
    administrator to add files to a post from the backend and let users download these
    files by displaying them after the post's content.
  prefs: []
  type: TYPE_NORMAL
- en: Let's start the development of our plugin by creating a new directory called
    `wpquick-post-attachments` inside the `wp-content/plugins` directory. Then, we
    need to create the main plugin file inside the new directory as `wpquick-post-attachments.php`.
    As usual, we need to add the plugin header comments section to this file in order
    to let WordPress list it as a plugin. You can use the plugin header comments from
    the previous plugin with a modified name and description.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we have to identify the tasks involved in the development process of this
    plugin:'
  prefs: []
  type: TYPE_NORMAL
- en: Creating a custom table to store attachment details of each post
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding a file field in the post creation screen to upload attachments
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Uploading and saving the attachments in a custom table
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Displaying attachments after post content with a download feature
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's start the development process by adding these features within the plugin
    life cycle events we discussed.
  prefs: []
  type: TYPE_NORMAL
- en: Creating settings upon plugin activation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The activation process of a plugin is handled by the built-in `register_activation_hook`
    function. In this scenario, we are developing a simple plugin to illustrate the
    importance of concepts in plugin development. Here, we will be using the built-in
    activation event to initialize the settings and data for this plugin, instead
    of creating separate installation process. Add the following code to the `wpquick-post-attachments.php`
    file, after the header comments section:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: We use the `register_activation_hook` function to register a custom function
    to be executed upon the activation process. The first parameter takes the path
    of the main plugin file, while the second parameter is used to define the function
    name. Here, we have used a function called `wpqpa_activate`.
  prefs: []
  type: TYPE_NORMAL
- en: We start the plugin activation process by creating a custom table to store the
    post attachment path and other necessary details. We already discussed the process
    of creating custom tables and the use of the `dbDelta` function in [Chapter 2](3e88326a-c8fe-4943-ae81-4ff69e8b865e.xhtml),
    *Managing Database Structure, Storage, and Retrieval*, and hence the explanations
    will not be repeated in this section. Apart from table creation, we can also save
    initial data or the settings required to run the plugin. In this scenario, we
    are capturing the plugin version from the header comments section by using the `get_file_data`
    function and saving it to `wp_options` table with a plugin-specific key called
    `wpqpa_version`.
  prefs: []
  type: TYPE_NORMAL
- en: 'We used the activation process to generate the necessary configurations in
    the database. Before moving into the development of these features, we need to
    specify the necessary paths to access the other files in the plugin. So, let''s
    add some constants to the main plugin file by using the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: First, we have to use the `defined` function to check whether a constant with
    a given name is already defined in order to prevent errors. Here, we have added
    two constants to define the URL to the plugin file inside the plugin directory
    and the full directory path. These two constants are used in upcoming sections
    to load scripts, styles, and PHP files for the plugin. Now, we can move into the
    process of building the features of the plugin.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing post attachment uploads
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The post creation screen is designed to let developers extend features by using
    custom meta boxes. In this scenario, we need a way to let the administrator upload
    files to a post. So, we need to define a custom meta box for displaying the input
    elements, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: The `add_meta_boxes_post` action is used to register a new meta box for normal
    posts. Inside this action, we can create a new meta box by using the `add_meta_box`
    function.
  prefs: []
  type: TYPE_NORMAL
- en: If you are registering a meta box for a specific post type, it's recommended
    that you use the `add_meta_boxes_{post_type}` action. In scenarios where the meta
    box is registered for multiple post types, you can use the generic `add_meta_boxes`
    action.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first three parameters of this function are required and used for unique
    meta box ID, meta box title, and callback function, respectively. In this scenario,
    we are calling a function in the main plugin file and hence we can just use the
    function name. However, if the callback function resides within a PHP class, you
    need to use the following syntax to call the function on an object of the class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'The remaining three parameters in the preceding code are used for screen, context,
    and priority, respectively. Let''s take a look at the use of those three parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Screen**: This parameter specifies the WordPress screen ID or IDs as an array
    to display the metabox. Each screen in WordPress has a specific ID to let developers
    build features for specific screens. Here, we have used post as the screen since
    we are only displaying the metabox for normal posts. You can check the available
    screen IDs of the admin screens by going to [https://codex.wordpress.org/Plugin_API/Admin_Screen_Reference](https://codex.wordpress.org/Plugin_API/Admin_Screen_Reference).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Context**: This parameter defines the location within the screen. We have
    three options for the post screen: normal, advanced, and side. The default value
    is advanced and displays a metabox under the post editor. However, if a *normal*
    metabox is created, it will display before the metaboxes with advanced context.
    The side option moves the metabox to the side column, along with the Publish buttons.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Priority**: This parameter defines the location of the metabox within a context.
    We have four values called high, core, default, and low. The high value places
    the metabox on top within the context while the priority will get lower as we
    move to the low option.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Next, we need to complete the implementation of the callback function before
    we can check the new metabox on the post screen. Let''s consider the following
    code for the implementation of the `display_post_attachments_meta_box` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'This function automatically receives post object and metabox details as parameters.
    Most of the code is self-explanatory as it contains the container elements and
    the necessary HTML fields. However, the last line is very important as a developer.
    WordPress uses a technique called **nonce** to increase the security of your code.
    Let''s take a look at the definition of nonce, which has been extracted from the
    official codex:'
  prefs: []
  type: TYPE_NORMAL
- en: '"A nonce is a "number used once" to help protect URLs and forms from certain
    types of misuse, malicious or otherwise. WordPress nonces aren''t numbers, but
    are hashes made up of numbers and letters. Nor are they used only once, but have
    a limited "lifetime" after which they expire. During that time period, the same
    nonce will be generated for a given user in a given context. The nonce for that
    action will remain the same for that user until that nonce life cycle has completed."'
  prefs: []
  type: TYPE_NORMAL
- en: 'In short, nonces are used to validate the user''s request and keep the integrity
    of the submitted data. It''s a must to use nonce validations in plugin development,
    especially when you are developing plugins for public use. The `wp_nonce_field`
    function is used to add a hidden field with a nonce value. The first parameter
    to this function is an action name that will be used in the verification process,
    and the second parameter is the name of the HTML hidden field. We can use the `wp_nonce_field`
    function without any of these parameters, but it''s strongly recommended to use
    both options. The following is a sample output that''s been generated from the
    use of the `wp_nonce_field` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'This nonce value will be used later in the data saving process for verification.
    So far, we have added the necessary HTML for displaying file upload input fields.
    However, these elements might display all over the place without the necessary
    styles. Therefore, we need to create a directory called `css` inside our plugin
    directory and add a CSS file as `wpqpa.css`. Then, we need to include the CSS
    in the file by using recommended WordPress actions. Consider the following code
    for including the CSS file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: In WordPress, we need to use `admin_enqueue_scripts` action for adding script
    and style files to the backend, and use the `wp_enqueue_scripts` action for the
    frontend. In this scenario, we are displaying the same files list in both the
    frontend and the backend. Therefore, we use both actions to load the CSS file
    we created. First, we have to register style files by using the `wp_register_style`
    function with a unique key and path. Then, we use the `wp_enqueue_style` function
    to add the styles file to the page. More details and advanced uses of script and
    style loading will be discussed in upcoming chapters. The CSS styles for this
    plugin are not discussed in this chapter. You can use the source files for this
    chapter to understand and modify them.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we can take a look at the modified post creation screen with our metabox,
    as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/cea5b65e-92ad-476c-bd40-5d447a993401.png)'
  prefs: []
  type: TYPE_IMG
- en: The custom metabox is displayed under the post editor. However, in a single
    site, we could be using many plugins with custom metaboxes. Therefore, you can't
    get the metabox to the exact location we need unless you are willing to change
    the code of such plugins.
  prefs: []
  type: TYPE_NORMAL
- en: Uploading attachments and saving attachment data
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The next step in the process is uploading and saving the file that's been selected
    by the administrator. In this scenario, we add the File and File Title inside
    the metabox by using the defined fields. Then, the administrator needs to hit
    the post's Publish or Update button to save the attachment along with the post.
  prefs: []
  type: TYPE_NORMAL
- en: Ideally, the attachment details should be uploaded and saved using AJAX in order
    to support multiple files without needing to update the post. In this scenario,
    we have used a normal form submit as we have not introduced AJAX yet and we need
    to understand the process of handling normal POST requests.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take a look at the attachment saving process using the following code,
    which has been added to the main file of our plugin:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Usually, developers can access POST request data directly within any file of
    the site. However, WordPress uses an event-based architecture and hence we need
    to implement proper hooks to access this data. Accessing the request data outside
    a proper WordPress event can lead to conflicting or the unavailability of data.
    Therefore, we use the `init` action to access the POST data, as the user request
    is fully loaded by the time it reaches the `init` action. More about action execution
    process will be discussed in [Chapter 5](40208ac9-c023-42b1-b48e-a368761b37a6.xhtml),
    *Extending Plugins with Addons, Filters, and Actions*.
  prefs: []
  type: TYPE_NORMAL
- en: The `init` action will be executed for each and every request and hence we need
    to make sure that we use our custom code only when necessary. Therefore, we check
    the availability of the `wpqpa_file_name` field in the user request and return
    without executing the custom code when it's not available. Then, we have to grab
    the necessary data from the POST request. Here, we need three values for the file
    name, nonce, and post ID.
  prefs: []
  type: TYPE_NORMAL
- en: 'You may have noticed the use of a function called `sanitize_text_field`. This
    function is used to remove unnecessary tags, spaces, line breaks, and characters
    from text field submissions. You should never trust incoming data; that''s why
    you should use `sanitize_text_field` before recording it. We should always validate
    and restrict user input values to improve the security of the code and prevent
    conflicts in the database. WordPress uses a three step process to secure data
    by validating, sanitizing, and escaping:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Sanitizing**: At this stage, we have to grab the user submitted data and
    make sure that it contains the accepted values. WordPress provides a set of functions
    for cleaning the user input and making it secure. The `sanitize_text_field` is
    one of the functions among thirteen sanitizing functions. The available functions
    and their use are explained at [https://codex.wordpress.org/Validating_Sanitizing_and_Escaping_User_Data#Sanitizing:_Cleaning_User_Input](https://codex.wordpress.org/Validating_Sanitizing_and_Escaping_User_Data#Sanitizing:_Cleaning_User_Input).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Validating**: At this stage, we validate the cleaned input values from the
    previous stage. The intention of this step is to check whether user submitted
    data matches with the accepted values. Unlike sanitization, there are no specific
    functions for validation. We can use our own conditions with both PHP and WordPress
    functions for validation. Validating data types, string lengths, data formats,
    and empty values are some of the common uses of this step.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Escaping**: This step is used when displaying data to the user. The intention
    of this step is to secure the data to be displayed. WordPress provides a set of
    built-in escaping functions based on different data. We will be discussing the
    use of escaping in upcoming chapters. The available escaping functions and their
    use is explained at [https://codex.wordpress.org/Data_Validation#Output_Sanitation](https://codex.wordpress.org/Data_Validation#Output_Sanitation).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You should choose the necessary functions from these three sections for validating
    the user data, depending on the type of fields used in a form and the accepted
    values.
  prefs: []
  type: TYPE_NORMAL
- en: 'The next step in the process is validating input data and uploading the attachment.
    Consider the following code, which is placed after the input data capturing code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: First, we need to validate the user request by using the nonce value that we
    added in the custom meta box. We start by checking the existence of the nonce
    value by using the `isset( $_POST['wpqpa_nonce'] )` condition. Then, we can use
    the `wp_verify_nonce` function to verify the submitted nonce value. The first
    parameter to this function takes the value of the nonce field and the second parameter
    takes the action name of the nonce field. Once nonce is successfully verified,
    we can upload the attachment.
  prefs: []
  type: TYPE_NORMAL
- en: Here, we use a function called `wpqpa_process_file_upload` for handling attachment
    uploads. The majority of the code in the `wpqpa_process_file_upload` function
    is not WordPress-specific and hence self-explanatory. You can use the source code
    files for this chapter to understand the implementation of this function.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we have to revert back to the `wpqpa_save_private_attachment_files` function,
    where we added the comment *Upload code section 1*. The data generated from the
    upload file''s function is stored in the `$result_upload` variable. Let''s continue
    the implementation to save the attachment details to the custom database table:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: First, we check whether the attachment upload has completed by using the status
    option of the `$result_upload` variable. Once the condition is matched, we get
    the file name from the `$result_upload` variable and define the custom table name
    in a variable. Next, we use the `insert` function of the global `$wpdb` object
    to save the data to the `wpqpa_post_attachments` table that was created in the
    activation event of the plugin. We already discussed the use of the `insert` function
    in [Chapter 2](3e88326a-c8fe-4943-ae81-4ff69e8b865e.xhtml), *Managing Database
    Structure, Storage, and Retrieval*, and hence I am not going to explain it in
    this section.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, the code for the attachment upload process is completed. However, you
    won''t be able to upload attachments at this stage. In order to upload files,
    you need to change the `enctype` of HTML forms to `multipart/form-data`. By default,
    WordPress won''t add the `enctype` attribute to the post submission form. Also
    it''s not possible to manually add it, as the form code is generated within WordPress.
    So, we need to use the built-in `post_edit_form_tag` action to add the necessary
    `enctype`, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Now, the entire process is completed and you should be able to test it by uploading
    a file with the use of post Publish or Update buttons. The uploaded attachment
    data should be reflected in the custom table.
  prefs: []
  type: TYPE_NORMAL
- en: Displaying uploaded attachments
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We need a way to display the uploaded files within the post edit screen as
    well as on the frontend, after the post content. For this, we are going to use
    a common function called `wpqpa_file_attachment_list` to generate an attachments
    list, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: This function is placed inside the main plugin file and accepts a post object
    as a parameter. First, we use the `prepare` function of the `$wpdb` object to
    securely prepare the SQL query for execution. In this function, we need to assign
    placeholders to all of the user input data and pass the values as parameters.
    Once the query has been prepared, we can use the `get_results` function to execute
    the query and get a list of files that are attached to the specific post.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we use a `foreach` statement to loop through the resulting attachments.
    Inside the loop, we get the URL of the post by using the built-in `get_permalink`
    function. Then, we add file-specific query parameters to the URL by using the
    custom `wpqpa_add_query_string` function. You can check the implementation of
    this function inside the main plugin file in the source code directory for this
    chapter. This URL is used to identify the attachment and provides download features
    in later stages of the implementation. Finally, we add the necessary HTML elements
    and containers with the attachment information and the download link. The prepared
    HTML will be returned from this function.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we need to call this function within the `display_post_attachments_meta_box`
    function and display the attachments list after the file upload fields. After
    uploading a few files, your screen will look similar to what''s shown in the following
    screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/79e4f4d8-2e00-4e5c-8f88-8306b1613785.png)'
  prefs: []
  type: TYPE_IMG
- en: Here, we have only used **Download** as an action button to keep the implementation
    simple and useful for this book. Usually, you will need other actions such as
    edit and delete for attachments.
  prefs: []
  type: TYPE_NORMAL
- en: Displaying attachments in posts
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The main requirement of this plugin was to attach files to posts and let users
    download them from the post page. So far, we have created the background to save
    and display the attachments. Now, it's time to implement the main requirements
    by displaying them after the content of each post.
  prefs: []
  type: TYPE_NORMAL
- en: 'At the start of this chapter, we created a plugin to use the `the_content`
    filter and add dynamic content after the post. The same technique will be used
    in this scenario. Let''s consider the following code for the implementation of
    the `the_content` filter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'As usual, we add the `the_content` filter and the callback function to handle
    the display of attachments. First, we check whether we are actually viewing an
    individual post by using the `is_singular` conditional function. If the condition
    is not matched, we return the content, as attachments are only intended for normal
    posts. Once the condition is matched, we call the reusable function we created
    earlier to display the list of attachments for the post. The following screenshot
    previews how attachments are displayed in a single post page:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/05cdbcf7-cf10-4f2c-ac32-f8656ebeb48f.png)'
  prefs: []
  type: TYPE_IMG
- en: Now, we have come to the final stage, where we need to implement a file download
    link to complete the plugin.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing the post attachments download
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This section is straightforward for developers who have already implemented
    file downloads with pure PHP. In the preceding section, we created a download
    link with a few custom parameters. Here, we have to use these parameters to identify
    attachments. Let''s start this implementation by adding a custom download function
    on the `init` action:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: As we have already discussed, it's very important to hook every custom function
    into a suitable WordPress action. In this scenario, we chose the `init` action
    since WordPress has finished loading and we need to access data from GET requests.
    We begin this function by checking the GET parameters in the URL to make sure
    that it's a request to download post attachments. You should note the use of `sanitize_text_field`,
    even for GET parameters, which is intended only for verification. Then, we access
    the attachment ID and post ID by using URL parameters with the necessary validation.
    Next, we execute a SQL select query to find the attachment details by using the
    database functions that were discussed in the previous sections. However, there
    is a slight difference in the `get_results` function, and that is that we have
    used an additional parameter called `ARRAY_A`. This is used to define the format
    of the result set. In the previous section, we didn't use this parameter and hence
    we got a set of objects as a result set. Once we use this option, the results
    will be provided in an associative array. Next, we check the availability of a
    matching attachment and use the result set to define the attachment URL and directory
    path.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s one way to write the file download code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: First, we use the file directory path to get the mime type of the file as it's
    important to keep the integrity of the downloaded file. When the mime type is
    not empty, we use the necessary PHP headers for file downloading. We uploaded
    the files with a dynamic name containing a number value based on time. It's not
    ideal to let users download a file with such a name. Therefore, we use the conditional
    check to add the original file name stored in our custom table. We revert to using
    the base name of the file when the original file name is not available in the
    database. The rest of the code contain the usual PHP headers for file downloads
    and the `readfile` function to output the file content. Now, we have completed
    the functionality of the plugin. You should be able to download the attachments
    from the list that's displayed after the post content.
  prefs: []
  type: TYPE_NORMAL
- en: Handling plugin version upgrades
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The version upgrade process is handled by the built-in `upgrader_process_complete`
    hook. We can implement this hook to add whatever data changes are required for
    the upgrade. We don't have a built-in upgrading event that can handle both plugins
    from the WordPress directory as well as custom plugins. Therefore, we have to
    build a custom upgrade process by using one of the existing hooks and conditional
    checks.
  prefs: []
  type: TYPE_NORMAL
- en: As we have already discussed, the WordPress plugin directory offers an automatic
    upgrade process. The custom plugins won't have such features by default. Therefore,
    we need to build an automatic upgrade process for the custom plugin. Many custom
    plugins don't have such features and hence we have considered such an implementation
    beyond the scope of this chapter. In such a scenario, users will have to either
    deactivate the current version and upload the new version or replace the current
    version files with a new version. So, the upgrade process needs to happen in the
    initial request after the file's replacement.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider the following code, where we used the `wp_loaded` action to handle
    the upgrade process of this plugin:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: First, we use the `wp_loaded` hook with a callback function since all of the
    plugins are loaded when executing this hook. Then, we need to compare whether
    we are using the old version or the new version of the plugin. So, we grab the
    current version from the plugin header comments and the stored version from the
    database. Next, we check if the version is already stored in the database. The
    unavailability of the version in the database means that we are installing the
    plugin for the first time and hence we update the version.
  prefs: []
  type: TYPE_NORMAL
- en: The next step is comparing the two versions and seeing if the current version
    is higher than the installed version. In such a case, we can execute the tasks
    of the upgrade process. If these values are he same, the version hasn't changed
    and there is no need for the upgrade process. In this example, we are adding a
    default value for a new setting. In real world implementations, we can execute
    tasks such as changing existing data, adding new settings data, and adding database
    tables or columns.
  prefs: []
  type: TYPE_NORMAL
- en: Handling plugin deactivation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This event is handled by the built-in `register_deactivation_hook` function.
    The use of this function is similar to the activation hook. This plugin contains
    basic features and hence we can't find a suitable practical use of the deactivation
    hook. Therefore, we will not be implementing this event for this plugin.
  prefs: []
  type: TYPE_NORMAL
- en: Uninstalling the plugin to clean the resources
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There's a big difference between deactivating and uninstalling a plugin. Cleaning
    resources should only be done upon deactivation. WordPress provides two methods
    for implementing the uninstallation process. The first method is using a built-in
    function called `register_uninstall_hook` to handle the uninstall process. This
    works similar to the technique we used in activation, through a callback function.
    The second method is using a file called `uninstall.php` inside the root folder
    of the plugin. In this plugin, we are going to use the latter technique with the
    `uninstall.php` file.
  prefs: []
  type: TYPE_NORMAL
- en: You can view more details about the other technique at [https://developer.wordpress.org/reference/functions/register_uninstall_hook/](https://developer.wordpress.org/reference/functions/register_uninstall_hook/).
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we have to create a file called `uninstall.php` inside the `wpquick-post-attachments`
    plugin directory. This file runs automatically when deleting the plugin from the
    plugins section. We can include the code for the uninstallation process directly
    inside the plugin. This is a basic plugin and hence we only need to delete the
    plugin-specific settings and custom tables that were created for the plugin. Let''s
    take a look at the implementation of the `uninstall.php` file inside the plugin:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: First, we need to check the availability of the `WP_UNINSTALL_PLUGIN` constant.
    This constant is set by WordPress in the process of uninstalling the plugin. If
    the constant is not available, the request could be an invalid one trying to delete
    the plugin data. Once the constant is set, we can implement the resource cleaning
    process. In this scenario, we have deleted the plugin version from the `wp_options`
    table and the whole `wp_wpqpa_post_attachments` table.
  prefs: []
  type: TYPE_NORMAL
- en: We have completed the simple plugin planned for this chapter by covering the
    functionality in each life cycle event. Usually, developers often consider the
    functionality and activation events of a plugin. However, upgrading and uninstalling
    events are critical in plugin development and hence you must use them with extra
    caution. Unless these events are handled properly, upgrading can break the entire
    site's functionality while uninstalling can leave a substantial amount of unused
    data.
  prefs: []
  type: TYPE_NORMAL
- en: Identifying the advantages of custom plugin development as a developer
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'WordPress has captured over 35% of sites and the enormous plugin base is continuing
    to grow at a rapid pace. So, site owners can find existing plugins to build whatever
    they want. Developers might consider this a risk, since WordPress sites can be
    built without a developer. This is partially true as the need for basic level
    developers are declining. On the other hand, the need for quality WordPress developers
    are emerging more than ever. In this section, we are going to focus on how custom
    plugin development is important for you as a developer. Let''s take a look at
    the advantages of developing custom plugins:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Reusability in many projects**: Among WordPress developers, a higher percentage
    of development is done for individual clients for site-specific requirements.
    Therefore, you may feel that you can add features anywhere you want, as it''s
    not going to change over time. However, you can separate non-project-specific
    features into separate plugins and use them for multiple clients to build rapid
    and cost-effective solutions.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Performance and security**: There are some tools and techniques to measure
    the performance and security of WordPress plugins. However, the process is not
    perfect and we won''t have time to check each and every piece of code in existing
    plugins. So, we have no choice other than use existing plugins without knowing
    the risks. In sites where performance and security is a top priority, custom plugin
    development is the best solution as you are aware of the security and performance
    concerns and could improve upon them.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Build a community for your profile and work**: In my personal experience,
    developing a plugin and releasing it to the public for free is the ideal method
    for exposing you as a developer to the world. There are millions of websites that
    require developers. However, there are also thousands of developers who are capable
    of building WordPress solutions. So, this is the ideal way to reach thousands
    of people that require developers and find potential clients on the way. You will
    also get other benefits as a substantial amount of people will be discussing your
    work and help you fix these issues.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Generating a consistent income source**: Premium plugin development has become
    a major business with the evolution of WordPress in recent years. There are developers
    who have made millions of dollars developing plugins in their spare time and selling
    them on their own. So, developing plugins could be an ideal solution for making
    a living without depending on a few clients or needing to find new clients every
    day.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Eliminate the concern of version updates**: This is a major concern for most
    site owners as they use the services of freelance developers and hence the developer
    is not available at the stage of upgrading. No matter whether it''s free or premium,
    existing plugins will always release updated versions with more features and fixes.
    On one hand, upgrading without the proper knowledge is a risk as it could break
    the existing features. On the other hand, not upgrading could be a security risk.
    We don''t have this concern in custom development, where you build site-specific
    plugins. Once the site is completed, you don''t need to release a new version
    of the plugin, that is unless you want to add more features or find an incompatibility
    with WordPress versions.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Provides flexibility and consistency in design**: Most basic to intermediate
    level WordPress sites are built by using existing plugins. The issue with using
    existing plugins is the flexibility and inconsistency in design. Most plugins
    are developed for common purposes. Therefore, the design is either very basic
    to suit any site or fixed without much flexibility. So, using any number of plugins
    means that the elements generated from plugins will be completely different to
    the design of the theme. This leads to the tedious process of plugin customization
    to make the design consistent. On the other hand, custom plugins can be designed
    to match the theme of the site and keep the consistency of design. Therefore,
    you can develop custom plugins when it''s cost-effective compared to the customization
    of existing plugins.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These advantages are only a few among the dozens of direct and indirect benefits.
    You should read WordPress-related blogs and explore the work of popular developers
    to understand the capacity and potential of plugin development.
  prefs: []
  type: TYPE_NORMAL
- en: Guidelines for building quality plugins
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Up until this point, we have looked at the process of building simple plugins
    with the recommended practices. Most of you will be developing WordPress sites
    for individual clients and hence the plugins you develop will not have to go through
    a verification process for quality. However, it's important to build extendable
    and maintainable plugins that are to be compatible with WordPress version upgrades
    as well as other third-party plugins. On the other hand, if you are developing
    plugins for the WordPress plugin directory or premium plugin marketplace, you
    will have to go through an extensive verification and review process for both
    the code and features. So, the quality of the plugin needs to match the minimum
    quality standards.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take a look at some of the common guidelines for building quality WordPress
    plugins, apart from the need to follow WordPress coding standards:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Using built-in WordPress functions**: This is a common problem in WordPress
    development where developers tend to create their own functions due to a lack
    of knowledge in WordPress. The power of WordPress comes from its existing modules
    and hence we should always use the existing functions rather than create our own
    functions. Also, the existing functions are optimized and coded by expert WordPress
    developers and hence there is less chance of generating bugs or compatibility
    issues.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Using the necessary hooks in existing features**: Certain hooks are used
    in core features to let developers customize and extend their functionality. If
    you are implementing or modifying a core feature, you should include the necessary
    hooks so that solutions created by other developers are compatible with your solution.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Always load built-in libraries**: There can be dozens of plugins inside a
    single site and often some of these plugins require the same libraries, such as
    jQuery. So, one developer may build the solution for a specific jQuery version
    and another one could build for a different version. Including multiple versions
    of the same library often leads to conflicts. Therefore, you should always check
    if the library is available within the WordPress core and load the built-in version
    by using the recommended hooks.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Use plugin-specific prefixes**: When working with plugins that come from
    multiple developers, there is a high chance of generating conflicts in both code
    as well as data. So, we should always add a unique prefix to our plugin. We should
    use this prefix on function names, class names, constants, database tables, and
    even plugin-specific data in common tables such as `wp_options`, `wp_postmeta`,
    and `wp_usermeta`. However, most of the modern plugins follow the object-oriented
    style, and hence you may not need to use the prefix for function names.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Use hooks for extendable features**: You might be developing a plugin with
    common solutions after complete research of the requirements. But, more often
    than not, clients will ask for customization''s in all parts in your code. So,
    it''s better to keep your code as open as possible for future changes. Therefore,
    you should always use filters for values which might change and use actions for
    places where the process or template can be extended.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These are some of the well-known and recommended guidelines. As you gain experience
    with plugin development, you can add a lot more guidelines to the preceding list
    based on user feedback and how other plugins work. Make sure that you use these
    guidelines as much as possible and release the plugin to the public whenever possible.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Plugins can be considered the most important aspect of WordPress when it comes
    to custom development. If we discard the existing plugin base, WordPress will
    be a just another CMS without major attention from users or developers. As a developer,
    it's important to know the ins and outs of plugin development to survive in the
    growing WordPress community. Due to this, in this chapter, we looked at the role
    of plugins in development by discussing common plugin-related tasks. We chose
    popular plugins to explain different types of plugins and how they interact with
    WordPress sites. Next, we looked at the process of creating a basic plugin for
    WordPress. Most beginner developers are capable of building solutions with PHP
    and integrating the solution as a WordPress plugin. However, plugins created without
    the knowledge of complete life cycle events can turn into a nightmare at later
    stages of the project. Therefore, we looked at the life cycle events of a WordPress
    plugin and the functionality of each event. Next, we built a WordPress plugin
    to attach files to posts and let users download them from the frontend. In the
    process, we covered life cycle events, data validation, sanitization, use of metaboxes,
    and the concept of nonces. Finally, we looked at the common guidelines for building
    quality plugins and how plugin development can benefit you as a WordPress developer.
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 5](40208ac9-c023-42b1-b48e-a368761b37a6.xhtml), *Extending Plugins
    with Addons, Filters, and Actions*, we will be looking at advanced plugin concepts
    as well as customizing existing popular plugins.
  prefs: []
  type: TYPE_NORMAL
