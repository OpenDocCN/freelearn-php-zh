- en: Building Custom Modules with Plugin Development
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用插件开发构建自定义模块
- en: Enormous free plugin base and plugin-based architecture are the keys to success
    of WordPress as a CMS. Plugins allow developers to build independent features
    as well as connect with the modules developed by other developers. We can use
    plugins to build quality sites with the code written by the top WordPress developers
    in the world, without spending a single dollar. From the developer's perspective,
    plugins allow you to reach and help thousands of users while being able to promote
    your skills as a developer. Anyone who has basic programming knowledge can create
    plugins to meet application-specific requirements. However, it takes considerable
    effort to develop quality plugins that can be reused across a wide range of projects.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 丰富的免费插件库和基于插件的架构是 WordPress 作为 CMS 成功的关键。插件允许开发者构建独立的功能，以及与其他开发者开发的模块连接。我们可以使用插件来构建由全球顶级
    WordPress 开发者编写的优质网站，而无需花费一分钱。从开发者的角度来看，插件允许您帮助成千上万的用户，同时还能推广您作为开发者的技能。任何具有基本编程知识的人都可以创建插件以满足特定应用的需求。然而，开发出可跨多个项目复用的优质插件需要相当大的努力。
- en: In this chapter, you will learn about the concept of plugins and how they are
    different from your theme. You will also go through the life cycle events of a
    proper plugin while creating a post attachments plugin to illustrate the use of
    these events. The primary concepts in plugin development such as data validation,
    sanitization, and nonce will be introduced. Understanding how to leverage existing
    WordPress features to build plugins that can be added or removed without affecting
    the other parts is the highlight of this chapter.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您将了解插件的概念以及它们与您的主题有何不同。您还将通过创建一个帖子附件插件来了解适当的插件的生存周期事件，以说明这些事件的使用。插件开发中的主要概念，如数据验证、清理和
    nonce，将被介绍。了解如何利用现有的 WordPress 功能来构建可以添加或删除而不会影响其他部分的插件是本章的亮点。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Understanding the role of plugins in development
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解插件在开发中的作用
- en: Creating a basic plugin from scratch
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从零开始创建基本插件
- en: Exploring the life cycle of a plugin
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 探索插件的生存周期
- en: Developing a post attachment plugin
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 开发帖子附件插件
- en: Identifying the advantages of custom plugin development
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 识别自定义插件开发的优点
- en: Guidelines for building quality plugins
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建高质量插件的指南
- en: By the end of this chapter, you should be able to understand the role of plugins
    and have the necessary knowledge to build a basic plugin from scratch using the
    recommended practices.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，您应该能够理解插件的作用，并具备使用推荐实践从头开始构建基本插件所必需的知识。
- en: Technical requirements
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: You will be required to have WordPress 4.9.8 installed to follow this procedure.
    Even if you
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 遵循此流程需要您已安装 WordPress 4.9.8。即使您拥有更晚版本的 WordPress，描述的示例也应能无重大问题地运行。
- en: have a later version of WordPress, the described examples should work with no
    significant problems.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 即使您拥有更晚版本的 WordPress，描述的示例也应能无重大问题地运行。
- en: 'The code files of this chapter can be found on GitHub:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的代码文件可以在 GitHub 上找到：
- en: '[https://github.com/PacktPublishing/WordPress-Development-Quick-Start-Guide/tree/master/Chapter04](https://github.com/PacktPublishing/WordPress-Development-Quick-Start-Guide/tree/master/Chapter04)'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/PacktPublishing/WordPress-Development-Quick-Start-Guide/tree/master/Chapter04](https://github.com/PacktPublishing/WordPress-Development-Quick-Start-Guide/tree/master/Chapter04)'
- en: 'Check out the following video to see the code in action:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 查看以下视频以查看代码的实际应用：
- en: '[http://bit.ly/2Py2szO](http://bit.ly/2Py2szO)'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: '[http://bit.ly/2Py2szO](http://bit.ly/2Py2szO)'
- en: Understanding the role of plugins
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解插件的作用
- en: A plugin is a set of functions dedicated to work as an independent solution,
    while extending or adding new features to WordPress. In WordPress, plugins are
    similar to the Apps we use in iOS and Android. We have the ability to use or remove
    any plugin without affecting WordPress's core features. Also, plugins allow us
    to separate independent features into their own plugins, making them easier to
    maintain. The [wordpress.org](http://wordpress.org) plugin base has over 50,000
    free plugins, and sometimes you don't have to develop anything for WordPress websites.
    You can just use a number of plugins and integrate them properly to build advanced
    features.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 插件是一组专门用于作为独立解决方案工作的函数，同时扩展或添加WordPress的新功能。在WordPress中，插件类似于我们在iOS和Android中使用的应用。我们有权使用或删除任何插件，而不会影响WordPress的核心功能。此外，插件允许我们将独立功能分离成各自的插件，使它们更容易维护。[wordpress.org](http://wordpress.org)的插件库拥有超过50,000个免费插件，有时你甚至不需要为WordPress网站开发任何东西。你只需使用多个插件并正确集成它们，就可以构建高级功能。
- en: The role of plugins is vital for the development of a site. In [Chapter 3](94db5df8-bbb4-4e75-ae88-fa38a9aabe05.xhtml),
    *Designing Flexible Frontends with Theme Development*, we discussed the role of
    a theme, and the features beyond the scope of a theme. Basically, any feature
    beyond the scope of a theme should be developed with plugins. However, there are
    scenarios where we will also use plugins to develop theme-specific things like
    templates and styles so that they are compatible with multiple themes. In most
    scenarios, plugins should either use their own styles and designs or default to
    the styles of the theme. It's not ideal to develop plugins focusing on a specific
    theme as it's almost impossible to switch to another theme at later stages.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 插件在网站开发中起着至关重要的作用。在第3章中，*使用主题开发设计灵活的前端*，我们讨论了主题的作用以及主题范围之外的功能。基本上，任何超出主题范围的功能都应该使用插件来开发。然而，也有一些场景，我们也会使用插件来开发特定于主题的事物，如模板和样式，以便它们与多个主题兼容。在大多数情况下，插件应该要么使用它们自己的样式和设计，要么默认使用主题的样式。专注于特定主题的插件开发并不理想，因为在后期阶段几乎不可能切换到另一个主题。
- en: 'In development, building plugins can range from just a few lines of code with
    filter implementations to advanced modules with thousands of lines of code. Let''s
    take a look at some of the common types of development tasks with plugins:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 在开发过程中，构建插件的范围可以从只有几行代码的过滤器实现到数千行代码的高级模块。让我们看看一些使用插件的常见开发任务：
- en: '**Building reusable blocks**: WordPress sites are mostly built by non-technical
    site owners and hence building the blocks of simple features is a common task.
    These blocks allow the client to add the feature anywhere in the site without
    needing a developer. We can use shortcodes or widgets to provide features as reusable
    blocks. In modern sites, page builders are used frequently to build the page''s
    design. Therefore, we can also develop components for page builders that are to
    be used as reusable blocks.'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**构建可重用块**：WordPress网站大多由非技术性的网站所有者构建，因此构建简单功能的块是常见任务。这些块允许客户在网站的任何位置添加功能，而无需开发者。我们可以使用短代码或小工具提供作为可重用块的特性。在现代网站上，页面构建器经常被用来构建页面设计。因此，我们也可以开发用于页面构建器的组件，这些组件将被用作可重用块。'
- en: '**Modifying built-in features**: This is a must for many sites, especially
    for extending the backend features and customizing the backend display. Since
    these are built-in features, we can''t modify the WordPress file to customize
    them. Therefore, we need to choose actions and filters of built-in features and
    implement them with the use of plugins.'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**修改内置功能**：这对于许多网站来说是必须的，尤其是对于扩展后端功能和自定义后端显示。由于这些是内置功能，我们不能修改WordPress文件来定制它们。因此，我们需要选择内置功能的动作和过滤器，并使用插件来实现它们。'
- en: '**Data capturing and displaying**: This is another common type of requirement,
    especially for sites that go beyond basic blogs. In these kinds of tasks, we need
    to create custom forms in the frontend, and either use backend features to store
    the data or create our own data storage. Built-in custom post types and custom
    build forms are used to handle such requirements.'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**数据捕获和显示**：这是另一种常见的需求类型，尤其是对于超出基本博客功能的网站。在这些任务中，我们需要在前端创建自定义表单，并使用后端功能存储数据或创建自己的数据存储。内置的自定义帖子类型和自定义构建表单用于处理此类需求。'
- en: '**Integrating UI components**: Modern websites are filled with interactive
    user interface components that are designed to display substantial data in a limited
    space. These components are mostly powered by open source JavaScript libraries.
    So, integrating these libraries and letting administrators add data to these components
    is another common requirement.'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**集成UI组件**：现代网站充满了旨在在有限空间内显示大量数据的交互式用户界面组件。这些组件大多由开源JavaScript库提供支持。因此，集成这些库并允许管理员向这些组件添加数据是另一个常见需求。'
- en: These are some of the challenges you face when working on a specific WordPress
    site. The process of building plugins to handle these types of requirements is
    essential for WordPress developers and hence we will be covering them in upcoming
    chapters. However, if you are planning to develop your own plugin, the challenges
    and possibilities are enormous. We can explore the WordPress plugin directory
    to understand what a plugin can do and the scope involved.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 在处理特定WordPress网站时，你将面临一些挑战。构建插件以处理这些类型的需求对于WordPress开发者来说是必不可少的，因此我们将在接下来的章节中介绍它们。然而，如果你计划开发自己的插件，挑战和可能性是巨大的。我们可以探索WordPress插件目录，了解插件能做什么以及涉及的范畴。
- en: WordPress plugin types based on features
  id: totrans-27
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 基于功能的WordPress插件类型
- en: 'As you explore, you will understand that the roles of plugins may vary from
    one another. So, it''s important to identify these different types of plugins
    in order to face the challenges in extending different WordPress modules. Here,
    we are going to choose some of the popular plugins of different plugin types and
    discuss how they interact with WordPress''s frontend and backend. This is purely
    a personal preference and hence you may want to categorize them differently after
    exploring the plugin directory:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 随着你继续探索，你会明白插件的作用可能各不相同。因此，识别这些不同类型的插件以面对扩展不同WordPress模块的挑战是很重要的。在这里，我们将选择一些不同插件类型的流行插件，并讨论它们如何与WordPress的前端和后端交互。这纯粹是个人偏好，因此在你探索插件目录后，你可能希望以不同的方式对它们进行分类：
- en: '**Yoast SEO** ([https://wordpress.org/plugins/wordpress-seo/](https://wordpress.org/plugins/wordpress-seo/)):
    This plugin is used to improve the SEO of the site by adding necessary content
    to pages. This type of plugin has interfaces in the backend, where we can add
    content or settings. However, these plugins work under the hood in the frontend
    as we can''t see any content. The examples for this type includes plugins from
    caching, analytics, and translation categories.'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Yoast SEO** ([https://wordpress.org/plugins/wordpress-seo/](https://wordpress.org/plugins/wordpress-seo/)):
    此插件通过在页面中添加必要的内容来提高网站的SEO。此类插件在后台有界面，我们可以添加内容或设置。然而，这些插件在前端内部工作，因为我们看不到任何内容。这类插件的例子包括来自缓存、分析和翻译类别的插件。'
- en: '**WordPress Importer** ([https://wordpress.org/plugins/wordpress-importer/](https://wordpress.org/plugins/wordpress-importer/)):
    This plugin imports data into the WordPress database from files. These types of
    plugins don''t have any features in the frontend or backend interfaces. Instead,
    these plugins are used to provide functionality by changing database values. The
    examples for these types of plugins include Duplicate Post and All-in-One WP Migration.'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**WordPress导入器** ([https://wordpress.org/plugins/wordpress-importer/](https://wordpress.org/plugins/wordpress-importer/)):
    此插件通过文件将数据导入WordPress数据库。这类插件在前端或后端界面中没有任何功能。相反，这些插件通过更改数据库值来提供功能。这类插件的例子包括重复帖子插件和All-in-One
    WP迁移插件。'
- en: '**WooCommerce** ([https://wordpress.org/plugins/woocommerce/](https://wordpress.org/plugins/woocommerce/)):
    This plugin is used to simplify the online shopping process by creating and selling
    products. These types of plugins have interfaces in the backend to add content
    as well as interfaces in the frontend to display the content. Apart from that,
    these plugins contain extensive data processing. This is the most common type
    of plugin you will get for development tasks. The examples for this type of plugin
    include BuddyPress and bbPress.'
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**WooCommerce** ([https://wordpress.org/plugins/woocommerce/](https://wordpress.org/plugins/woocommerce/)):
    此插件通过创建和销售产品来简化在线购物过程。这类插件在后台有界面以添加内容，在前端也有界面以显示内容。除此之外，这些插件包含广泛的数据处理。这是你在开发任务中最常见的插件类型。这类插件的例子包括BuddyPress和bbPress。'
- en: '**Meta Slider** ([https://wordpress.org/plugins/ml-slider/](https://wordpress.org/plugins/ml-slider/)):
    This plugin adds elegant image sliders to the frontend of the site. These types
    of plugins have backend interfaces for adding content and frontend interfaces
    for displaying the content inside modern UI elements. However, no data processing
    is involved. The examples for this type of plugin include Easy FancyBox and Max
    Mega Menu.'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Meta Slider** ([https://wordpress.org/plugins/ml-slider/](https://wordpress.org/plugins/ml-slider/))：此插件为网站的前端添加了优雅的图片滑块。这类插件具有用于添加内容的后端界面和用于在现代UI元素中显示内容的客户端界面。然而，不涉及数据处理。此类插件的例子包括Easy
    FancyBox和Max Mega Menu。'
- en: '**Admin Menu Editor** ([https://wordpress.org/plugins/admin-menu-editor/](https://wordpress.org/plugins/admin-menu-editor/)):
    This plugin allows you to change the menus and the related settings. These types
    of plugins allow you to add, change, and remove built-in backend features to suit
    your needs. There is no interaction with the frontend or data in such plugins.
    The examples for this type of plugin include Admin Columns and Simple Page Ordering.'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**管理员菜单编辑器** ([https://wordpress.org/plugins/admin-menu-editor/](https://wordpress.org/plugins/admin-menu-editor/))：此插件允许你更改菜单和相关设置。这类插件允许你添加、更改和删除内置的后端功能以满足你的需求。此类插件不与前端或数据交互。此类插件的例子包括Admin
    Columns和Simple Page Ordering。'
- en: '**Easy Google Fonts** ([https://wordpress.org/plugins/easy-google-fonts/](https://wordpress.org/plugins/easy-google-fonts/)):
    This plugin allows you to use Google Fonts for the content of the site. These
    types of plugins often don''t have functionality related to the backend or frontend.
    Instead, they connect third-party services with WordPress. The examples for this
    type of plugin include AddToAny Share Buttons and Google Doc Embedder.'
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Easy Google Fonts** ([https://wordpress.org/plugins/easy-google-fonts/](https://wordpress.org/plugins/easy-google-fonts/))：此插件允许你为网站内容使用Google字体。这类插件通常没有与后端或前端相关的功能。相反，它们将第三方服务与WordPress连接。此类插件的例子包括AddToAny分享按钮和Google文档嵌入器。'
- en: '**Advanced Custom Fields** ([https://wordpress.org/plugins/advanced-custom-fields/](https://wordpress.org/plugins/advanced-custom-fields/)
    ): This plugin acts as a framework, letting developers and clients build forms
    using existing components. These types of plugins interacts with both the backend
    and the frontend. However, these plugins don''t provide site-specific features.
    Instead, the administrator decides which elements are displayed to the user and
    how the data is processed. Examples of such plugins include Elementor Page Builder
    and Pods Custom Content Types and Fields.'
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**高级自定义字段** ([https://wordpress.org/plugins/advanced-custom-fields/](https://wordpress.org/plugins/advanced-custom-fields/))：此插件充当框架，允许开发者和客户使用现有组件构建表单。这类插件与后端和前端都进行交互。然而，这些插件不提供特定于站点的功能。相反，管理员决定向用户显示哪些元素以及如何处理数据。此类插件的例子包括Elementor页面构建器和Pods自定义内容类型和字段。'
- en: The types of plugins we can build is enormous and can't be covered here, even
    if we were to have a complete chapter dedicated to them. Therefore, we have chosen
    a few plugins that contain the most popular types of development tasks.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以构建的插件类型非常多，这里无法全部涵盖，即使我们有一个专门章节来介绍它们。因此，我们选择了一些包含最流行开发任务的插件。
- en: Creating your first plugin
  id: totrans-37
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建你的第一个插件
- en: 'The process of developing a simple plugin is not complex. It follows the same
    process we used for themes, where we used PHP header comments. First, you have
    to create a new directory inside `wp-content/plugins`, with a preferred name.
    In this example, we are going to name it `wpquick-after-post-content`. Once the
    plugin directory has been created, we can create the main plugin file, which is `wpquick-after-post-content.php`.
    You can use the preferred name for the main plugin file. Now, we have to add the
    following header comments section to define it as a plugin:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 开发一个简单插件的过程并不复杂。它遵循了我们用于主题的相同流程，其中我们使用了PHP头部注释。首先，你必须在`wp-content/plugins`目录内创建一个新的目录，并给它一个首选的名称。在这个例子中，我们将将其命名为`wpquick-after-post-content`。一旦创建了插件目录，我们就可以创建主要的插件文件，即`wpquick-after-post-content.php`。你可以为主插件文件使用首选的名称。现在，我们必须添加以下头部注释部分来定义它为一个插件：
- en: '[PRE0]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The plugin definition comment is similar to the theme definition, where Theme
    Name and Theme URI are being replaced by Plugin Name and Plugin URI. Once the
    comment has been added, this directory becomes a plugin and you can refresh the
    backend plugins list to reflect the plugin's details. Now, you can add any PHP
    code within the main plugin file or sub-files to begin development with WordPress.
    The only thing that differs from usual PHP development is the use of WordPress
    hooks. We will be introducing the necessary hooks throughout this chapter.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 插件定义注释与主题定义类似，其中主题名称和主题URI被插件名称和插件URI所替换。一旦注释被添加，这个目录就变成了一个插件，你可以刷新后端插件列表以反映插件的详细信息。现在，你可以在主插件文件或子文件中添加任何PHP代码，以开始使用WordPress进行开发。与常规PHP开发不同的是，这里使用的是WordPress钩子。我们将在本章中介绍必要的钩子。
- en: 'Let''s add some functionality to the plugin. We have named this plugin After
    Post Content. The functionality is to add dynamic content after each post in the
    site. In [Chapter 3](94db5df8-bbb4-4e75-ae88-fa38a9aabe05.xhtml), *Designing Flexible
    Frontends with Theme Development*,we added a dynamic advertisement bar to the
    header section. Here, we will be displaying the same advertisement, after the
    post content. Consider the following code for the implementation of this feature:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们给这个插件添加一些功能。我们把这个插件命名为“帖子内容之后”。这个功能是在网站的每篇帖子之后添加动态内容。在[第3章](94db5df8-bbb4-4e75-ae88-fa38a9aabe05.xhtml)，“使用主题开发设计灵活的前端”，我们向头部部分添加了一个动态广告栏。在这里，我们将在帖子内容之后显示相同的广告。考虑以下代码来实现这个功能：
- en: '[PRE1]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: This code is added to the main plugin file, just after the header comments section.
    Usually, we have to modify the post template to add such content in pure PHP development.
    In WordPress, everything is hooked into an action or a filter, and hence we can
    use them without modifying the template files. Here, we have used the `the_content`
    filter with a callback function. We already discussed the use of filters in [Chapter
    3](94db5df8-bbb4-4e75-ae88-fa38a9aabe05.xhtml), *Designing Flexible Frontends
    with Theme Development*. This filter is used to modify the post/page content and
    is included in all of the properly coded themes. The default post content is passed
    to this filter and plugins can alter this content by implementing this hook.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码被添加到主插件文件中，在头部注释部分之后。通常，我们不得不修改帖子模板来在纯PHP开发中添加这样的内容。在WordPress中，所有内容都钩接到一个动作或过滤器上，因此我们可以使用它们而不修改模板文件。在这里，我们使用了`the_content`过滤器与一个回调函数。我们已经在[第3章](94db5df8-bbb4-4e75-ae88-fa38a9aabe05.xhtml)，“使用主题开发设计灵活的前端”中讨论了过滤器的作用。这个过滤器用于修改帖子/页面内容，并且包含在所有正确编码的主题中。默认的帖子内容传递给这个过滤器，插件可以通过实现这个钩子来改变这个内容。
- en: 'In this scenario, we have used the `is_singular` function for the conditional
    check. This function is used to check if we are viewing the single page of any
    given post type. Once the condition is matched, we add the dynamic advertisement
    bar after the existing post content. Now, you can create and view a new post in
    the frontend. The content we added will be displayed in a similar fashion as to
    what''s shown in the following screenshot:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个场景中，我们使用了`is_singular`函数进行条件检查。这个函数用于检查我们是否正在查看任何给定帖子类型的单页。一旦条件匹配，我们就在现有帖子内容之后添加动态广告栏。现在，你可以在前端创建和查看新帖子。我们添加的内容将以与以下截图所示类似的方式显示：
- en: '![](img/381ff567-4078-42ad-bfa8-2ee4118b5ef5.png)'
  id: totrans-45
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/381ff567-4078-42ad-bfa8-2ee4118b5ef5.png)'
- en: We have created a simple plugin in a very short time span. WordPress plugins
    can range from a few lines of code like this one, to advanced systems with thousands
    of lines of code. So, as we can see, developing WordPress plugins is not hard.
    It's always a good option to separate even a few lines of codes into a separate
    plugin, assuming that the functionality can be useful for many sites. In this
    example, we only added a fixed bar to each and every post. In real world implementations,
    we will have to change these advertisements as well as have the ability to add
    them to each post from the backend.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在非常短的时间内创建了一个简单的插件。WordPress插件可以从几行代码如这一例，到数千行代码的复杂系统。因此，正如我们所看到的，开发WordPress插件并不困难。将即使是几行代码也分离成单独的插件总是一个好选择，假设这些功能对许多网站都有用。在这个例子中，我们只向每篇帖子添加了一个固定的栏。在实际应用中，我们还需要更改这些广告，并具有从后端将它们添加到每篇帖子的能力。
- en: Exploring the life cycle of a plugin
  id: totrans-47
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 探索插件的生命周期
- en: A product life cycle is a series of events or stages that occur from the start
    to the completion of the product or process. WordPress plugins contain life cycle
    events, from initial activation to uninstallation. It's important to understand
    all of these events to keep the plugin working and make the data consistent, even
    after exiting the plugin. Many developers are aware of only a few of these events,
    leading to low quality plugins.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 产品生命周期是一系列从产品或流程开始到完成的事件或阶段。WordPress插件包含生命周期事件，从初始激活到卸载。理解所有这些事件对于保持插件正常运行和数据一致性至关重要，即使在退出插件之后也是如此。许多开发者只知道其中的一些事件，导致插件质量低下。
- en: 'In this section, we are going to look at the life cycle of a plugin and how
    we can manage each of the events in the cycle. Consider the following diagram
    for a basic illustration of events in a plugin:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将探讨插件的整个生命周期以及如何管理生命周期中的每个事件。以下图表展示了插件中事件的基本示意图：
- en: '![](img/af75db8e-1305-4d44-a83b-6c02c55ba834.png)'
  id: totrans-50
  prefs: []
  type: TYPE_IMG
  zh: '![插件生命周期图](img/af75db8e-1305-4d44-a83b-6c02c55ba834.png)'
- en: 'As you can see, the life cycle of a plugin has five events, apart from its
    functionality. A plugin starts the cycle via an activation event. The cycle is
    completed with either deactivate or uninstall events, until it starts the cycle
    again with activation. Let''s understand these five events:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，插件的生命周期包含五个事件，除了其功能之外。插件通过激活事件开始生命周期。通过停用或卸载事件完成周期，然后再次通过激活事件开始新的周期。让我们了解这五个事件：
- en: '**Activation**: This is a built-in event that''s fired by clicking the Activate
    button from the WordPress plugin list or installation screen. This can be used
    for executing certain actions upon activation as well as to initialize the plugin
    data and settings. Ideally, the initialization tasks should be done through a
    separate installation process since plugin activation is not a one-time event.
    However, a limited number of plugins offer a separate installation process, as
    it''s a plugin-specific event. Therefore, most developers will use WordPress''s
    built-in activation process to initialize the plugins with necessary condition
    checks. Adding rewrite rules, creating/modifying database tables, adding default
    settings. and creating demo data are some of practical functions that are executed
    in the activation process.'
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**激活**：这是一个内置事件，当从WordPress插件列表或安装屏幕点击激活按钮时触发。这可以用于在激活时执行某些操作，以及初始化插件的数据和设置。理想情况下，初始化任务应该通过一个单独的安装过程来完成，因为插件激活不是一次性的事件。然而，只有少数插件提供单独的安装过程，因为它是一个特定于插件的事件。因此，大多数开发者将使用WordPress的内置激活过程来初始化插件，并进行必要的条件检查。在激活过程中执行的一些实际功能包括添加重写规则、创建/修改数据库表、添加默认设置以及创建演示数据。'
- en: '**Installation**: This is not a built-in event, and most WordPress plugins
    use the activation event for installation. However, we may need a step by step
    installation process like WordPress for complex plugins. With this, we can implement
    our own installation process by using custom code after the activation. You can
    install WooCommerce to check how the plugin-specific installation process is handled
    with custom screens.'
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**安装**：这不是一个内置事件，大多数WordPress插件使用激活事件进行安装。然而，对于复杂的插件，我们可能需要一个类似于WordPress的逐步安装过程。通过这种方式，我们可以在激活后使用自定义代码实现自己的安装过程。您可以通过安装WooCommerce来查看如何通过自定义屏幕处理特定于插件的安装过程。'
- en: '**Upgrading**: This is a built-in event for plugins in the WordPress plugin
    repository and is used just after the version upgrade has completed. However,
    this event is not available for other plugins unless we build a custom upgrade
    process to get the files from our own server. Therefore, we need to handle this
    by combining existing WordPress hooks and conditional checks in scenarios where
    we don''t have a custom automatic upgrade process. This event can be used for
    adding default values for additional settings in new versions, altering database
    tables, converting existing data to a new format, and so on.'
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**升级**：这是一个WordPress插件库中插件的内置事件，在版本升级完成后使用。然而，除非我们构建一个自定义的升级过程从我们的服务器获取文件，否则此事件对其他插件不可用。因此，我们需要通过结合现有的WordPress钩子和条件检查来处理这种情况，在没有自定义自动升级过程的情况下。此事件可以用于在新版本中添加默认值以设置附加设置、更改数据库表、将现有数据转换为新的格式等。'
- en: '**Deactivation**: This is a built-in event that''s fired by clicking the Deactivate
    link from the WordPress plugin list. This action should be used to execute certain
    tasks before the plugin is deactivated. Often, developers misunderstand the use
    of this action and tend to use it as an uninstallation process. Deactivation is
    a temporary event and hence you should not delete plugin data within this hook.
    Ideally, this event should be used for functions such as removing rewrite rules,
    clearing the cache, and temporary database values.'
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**停用**：这是一个由点击WordPress插件列表中的停用链接触发的内置事件。这个动作应该用于在插件停用之前执行某些任务。通常，开发者会误解这个动作的用途，并倾向于将其用作卸载过程。停用是一个临时事件，因此你在这个钩子中不应该删除插件数据。理想情况下，这个事件应该用于诸如删除重写规则、清除缓存和临时数据库值等功能。'
- en: '**Uninstallation**: This is also a built-in event that''s fired by clicking
    the Delete link from the WordPress plugins list. This is the proper event to handle
    uninstallation and must be used to clear plugin-specific data. Many plugins don''t
    have an uninstallation process, leaving the plugin data in the database. Once
    a plugin is deactivated, the plugin data doesn''t affect the site''s features.
    However, this data affects the site''s performance, and also makes it prone to
    conflicts with plugins that will be used in the future. Therefore, it''s important
    to implement the uninstall event for a plugin as well as instruct the user on
    what happens upon uninstallation.'
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**卸载**：这也是一个由点击WordPress插件列表中的删除链接触发的内置事件。这是处理卸载的正确事件，必须用于清除插件特定的数据。许多插件没有卸载过程，导致插件数据留在数据库中。一旦插件被停用，插件数据不会影响网站的功能。然而，这些数据会影响网站的性能，并使其容易与未来将使用的插件发生冲突。因此，为插件实现卸载事件以及指导用户在卸载后会发生什么非常重要。'
- en: In the next section, we will be developing a plugin while using the most important
    and mandatory life cycle events of a plugin.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将使用插件最重要的和强制性的生命周期事件来开发一个插件。
- en: Developing a post attachments plugin
  id: totrans-58
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 开发一个帖子附件插件
- en: In the two preceding sections, we discussed the steps for building a basic plugin
    and the life cycle events. In this section, we will be developing a plugin, while
    covering the implementation of life cycle events and critical features in plugin
    development. Let's summarize the requirement of the plugin.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 在前两个章节中，我们讨论了构建基本插件和生命周期事件的步骤。在本节中，我们将开发一个插件，同时涵盖生命周期事件在插件开发中的实现和关键特性。让我们总结一下插件的需求。
- en: The use of blog posts and displaying dynamic content after the post is common
    in most WordPress sites. We already looked at the process of adding content after
    the post, in the first plugin we developed. Now, we are going to extend the feature
    to allow attachment downloads after the post. In some sites, it's essential to
    allow users to download files related to the post. This plugin will allow the
    administrator to add files to a post from the backend and let users download these
    files by displaying them after the post's content.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 在大多数WordPress网站上，使用博客文章并在帖子后显示动态内容是常见的。我们已经在前开发的第一个插件中查看过在帖子后添加内容的过程。现在，我们将扩展功能，允许在帖子后下载附件。在一些网站上，允许用户下载与帖子相关的文件是必不可少的。这个插件将允许管理员从后端向帖子添加文件，并允许用户通过在帖子内容后显示这些文件来下载这些文件。
- en: Let's start the development of our plugin by creating a new directory called
    `wpquick-post-attachments` inside the `wp-content/plugins` directory. Then, we
    need to create the main plugin file inside the new directory as `wpquick-post-attachments.php`.
    As usual, we need to add the plugin header comments section to this file in order
    to let WordPress list it as a plugin. You can use the plugin header comments from
    the previous plugin with a modified name and description.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从在`wp-content/plugins`目录内创建一个名为`wpquick-post-attachments`的新目录开始，来开发我们的插件。然后，我们需要在新目录内创建主插件文件，命名为`wpquick-post-attachments.php`。像往常一样，我们需要在这个文件中添加插件头部注释部分，以便WordPress将其列为插件。你可以使用之前插件的插件头部注释，只需修改名称和描述即可。
- en: 'Now, we have to identify the tasks involved in the development process of this
    plugin:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们必须确定这个插件开发过程中涉及的任务：
- en: Creating a custom table to store attachment details of each post
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个自定义表来存储每篇帖子的附件详情
- en: Adding a file field in the post creation screen to upload attachments
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在帖子创建屏幕中添加一个文件字段来上传附件
- en: Uploading and saving the attachments in a custom table
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在自定义表中上传和保存附件
- en: Displaying attachments after post content with a download feature
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在帖子内容后显示附件并具有下载功能
- en: Let's start the development process by adding these features within the plugin
    life cycle events we discussed.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从在之前讨论的插件生命周期事件中添加这些功能开始开发过程。
- en: Creating settings upon plugin activation
  id: totrans-68
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在插件激活时创建设置
- en: 'The activation process of a plugin is handled by the built-in `register_activation_hook`
    function. In this scenario, we are developing a simple plugin to illustrate the
    importance of concepts in plugin development. Here, we will be using the built-in
    activation event to initialize the settings and data for this plugin, instead
    of creating separate installation process. Add the following code to the `wpquick-post-attachments.php`
    file, after the header comments section:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 插件的激活过程由内置的`register_activation_hook`函数处理。在这种情况下，我们正在开发一个简单的插件来阐述插件开发中概念的重要性。在这里，我们将使用内置的激活事件来初始化此插件设置和数据，而不是创建单独的安装过程。将以下代码添加到`wpquick-post-attachments.php`文件中，在头部注释部分之后：
- en: '[PRE2]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: We use the `register_activation_hook` function to register a custom function
    to be executed upon the activation process. The first parameter takes the path
    of the main plugin file, while the second parameter is used to define the function
    name. Here, we have used a function called `wpqpa_activate`.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`register_activation_hook`函数来注册一个在激活过程中要执行的自定义函数。第一个参数接受主插件文件的路径，而第二个参数用于定义函数名称。在这里，我们使用了一个名为`wpqpa_activate`的函数。
- en: We start the plugin activation process by creating a custom table to store the
    post attachment path and other necessary details. We already discussed the process
    of creating custom tables and the use of the `dbDelta` function in [Chapter 2](3e88326a-c8fe-4943-ae81-4ff69e8b865e.xhtml),
    *Managing Database Structure, Storage, and Retrieval*, and hence the explanations
    will not be repeated in this section. Apart from table creation, we can also save
    initial data or the settings required to run the plugin. In this scenario, we
    are capturing the plugin version from the header comments section by using the `get_file_data`
    function and saving it to `wp_options` table with a plugin-specific key called
    `wpqpa_version`.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过创建一个自定义表来存储帖子附件路径和其他必要细节来开始插件激活过程。我们已经在[第2章](3e88326a-c8fe-4943-ae81-4ff69e8b865e.xhtml)中讨论了创建自定义表和`dbDelta`函数的使用，因此本节中不会重复解释。除了表创建之外，我们还可以保存初始数据或运行插件所需的设置。在这种情况下，我们通过使用`get_file_data`函数从头部注释部分捕获插件版本，并将其保存到具有特定键`wpqpa_version`的`wp_options`表中。
- en: 'We used the activation process to generate the necessary configurations in
    the database. Before moving into the development of these features, we need to
    specify the necessary paths to access the other files in the plugin. So, let''s
    add some constants to the main plugin file by using the following code:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用激活过程在数据库中生成必要的配置。在开发这些功能之前，我们需要指定必要的路径以访问插件中的其他文件。因此，让我们通过以下代码在主插件文件中添加一些常量：
- en: '[PRE3]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: First, we have to use the `defined` function to check whether a constant with
    a given name is already defined in order to prevent errors. Here, we have added
    two constants to define the URL to the plugin file inside the plugin directory
    and the full directory path. These two constants are used in upcoming sections
    to load scripts, styles, and PHP files for the plugin. Now, we can move into the
    process of building the features of the plugin.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们必须使用`defined`函数来检查是否已经定义了具有给定名称的常量，以防止错误。在这里，我们添加了两个常量来定义插件目录内插件文件的URL和完整目录路径。这两个常量将在后续部分中用于加载插件的脚本、样式和PHP文件。现在，我们可以进入构建插件功能的过程。
- en: Implementing post attachment uploads
  id: totrans-76
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现帖子附件上传
- en: 'The post creation screen is designed to let developers extend features by using
    custom meta boxes. In this scenario, we need a way to let the administrator upload
    files to a post. So, we need to define a custom meta box for displaying the input
    elements, as shown in the following code:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 帖子创建屏幕设计为允许开发者通过使用自定义元框来扩展功能。在这种情况下，我们需要一种让管理员能够将文件上传到帖子中的方法。因此，我们需要定义一个自定义元框来显示输入元素，如下面的代码所示：
- en: '[PRE4]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The `add_meta_boxes_post` action is used to register a new meta box for normal
    posts. Inside this action, we can create a new meta box by using the `add_meta_box`
    function.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '`add_meta_boxes_post`动作用于为普通帖子注册一个新的元框。在这个动作内部，我们可以使用`add_meta_box`函数创建一个新的元框。'
- en: If you are registering a meta box for a specific post type, it's recommended
    that you use the `add_meta_boxes_{post_type}` action. In scenarios where the meta
    box is registered for multiple post types, you can use the generic `add_meta_boxes`
    action.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你正在为特定文章类型注册元框，建议你使用`add_meta_boxes_{post_type}`动作。在元框为多个文章类型注册的场景中，你可以使用通用的`add_meta_boxes`动作。
- en: 'The first three parameters of this function are required and used for unique
    meta box ID, meta box title, and callback function, respectively. In this scenario,
    we are calling a function in the main plugin file and hence we can just use the
    function name. However, if the callback function resides within a PHP class, you
    need to use the following syntax to call the function on an object of the class:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数的前三个参数是必需的，分别用于唯一的元框ID、元框标题和回调函数。在这种情况下，我们正在调用主插件文件中的一个函数，因此我们可以直接使用函数名。然而，如果回调函数位于PHP类中，你需要使用以下语法来在类的对象上调用函数：
- en: '[PRE5]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The remaining three parameters in the preceding code are used for screen, context,
    and priority, respectively. Let''s take a look at the use of those three parameters:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码中的剩余三个参数分别用于屏幕、上下文和优先级。让我们看看这三个参数的使用方法：
- en: '**Screen**: This parameter specifies the WordPress screen ID or IDs as an array
    to display the metabox. Each screen in WordPress has a specific ID to let developers
    build features for specific screens. Here, we have used post as the screen since
    we are only displaying the metabox for normal posts. You can check the available
    screen IDs of the admin screens by going to [https://codex.wordpress.org/Plugin_API/Admin_Screen_Reference](https://codex.wordpress.org/Plugin_API/Admin_Screen_Reference).'
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**屏幕**: 此参数指定了用于显示元框的WordPress屏幕ID或ID数组。WordPress中的每个屏幕都有一个特定的ID，以便开发者为特定屏幕构建功能。在这里，我们使用了“文章”作为屏幕，因为我们只为普通文章显示元框。您可以通过访问[https://codex.wordpress.org/Plugin_API/Admin_Screen_Reference](https://codex.wordpress.org/Plugin_API/Admin_Screen_Reference)来检查管理屏幕的可用的屏幕ID。'
- en: '**Context**: This parameter defines the location within the screen. We have
    three options for the post screen: normal, advanced, and side. The default value
    is advanced and displays a metabox under the post editor. However, if a *normal*
    metabox is created, it will display before the metaboxes with advanced context.
    The side option moves the metabox to the side column, along with the Publish buttons.'
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**上下文**: 此参数定义了屏幕内的位置。对于文章屏幕，我们有三个选项：普通、高级和侧边。默认值是高级，在文章编辑器下方显示元框。然而，如果创建了一个*普通*元框，它将显示在具有高级上下文的元框之前。侧边选项将元框移动到侧边栏，与发布按钮一起。'
- en: '**Priority**: This parameter defines the location of the metabox within a context.
    We have four values called high, core, default, and low. The high value places
    the metabox on top within the context while the priority will get lower as we
    move to the low option.'
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**优先级**: 此参数定义了元框在上下文中的位置。我们有四个值，称为高、核心、默认和低。高值将元框放置在上下文顶部，而随着我们移动到低选项，优先级将降低。'
- en: 'Next, we need to complete the implementation of the callback function before
    we can check the new metabox on the post screen. Let''s consider the following
    code for the implementation of the `display_post_attachments_meta_box` function:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，在我们可以检查文章屏幕上的新元框之前，我们需要完成回调函数的实现。让我们考虑以下用于实现`display_post_attachments_meta_box`函数的代码：
- en: '[PRE6]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'This function automatically receives post object and metabox details as parameters.
    Most of the code is self-explanatory as it contains the container elements and
    the necessary HTML fields. However, the last line is very important as a developer.
    WordPress uses a technique called **nonce** to increase the security of your code.
    Let''s take a look at the definition of nonce, which has been extracted from the
    official codex:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数自动接收文章对象和元框详情作为参数。大部分代码都是自我解释的，因为它包含容器元素和必要的HTML字段。然而，最后一行对于开发者来说非常重要。WordPress使用一种称为**nonce**的技术来提高你代码的安全性。让我们看看nonce的定义，它已经从官方手册中提取出来：
- en: '"A nonce is a "number used once" to help protect URLs and forms from certain
    types of misuse, malicious or otherwise. WordPress nonces aren''t numbers, but
    are hashes made up of numbers and letters. Nor are they used only once, but have
    a limited "lifetime" after which they expire. During that time period, the same
    nonce will be generated for a given user in a given context. The nonce for that
    action will remain the same for that user until that nonce life cycle has completed."'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: “一次性数是一个“一次使用”的数字，用于帮助保护URL和表单免受某些类型的滥用，无论是恶意的还是其他类型的。WordPress的一次性数不是数字，而是由数字和字母组成的哈希值。它们也不是只使用一次，而是在有限的生命周期后过期。在此期间，给定用户在给定上下文中将生成相同的一次性数。该动作的一次性数将保持不变，直到该一次性数生命周期完成。”
- en: 'In short, nonces are used to validate the user''s request and keep the integrity
    of the submitted data. It''s a must to use nonce validations in plugin development,
    especially when you are developing plugins for public use. The `wp_nonce_field`
    function is used to add a hidden field with a nonce value. The first parameter
    to this function is an action name that will be used in the verification process,
    and the second parameter is the name of the HTML hidden field. We can use the `wp_nonce_field`
    function without any of these parameters, but it''s strongly recommended to use
    both options. The following is a sample output that''s been generated from the
    use of the `wp_nonce_field` function:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，一次性数用于验证用户请求并保持提交数据的完整性。在插件开发中，尤其是在开发供公众使用的插件时，使用一次性数验证是必须的。`wp_nonce_field`函数用于添加一个带有一次性数值的隐藏字段。此函数的第一个参数是在验证过程中将使用的动作名称，第二个参数是HTML隐藏字段的名称。我们可以不使用这些参数中的任何一个来使用`wp_nonce_field`函数，但强烈建议使用这两个选项。以下是从使用`wp_nonce_field`函数生成的示例输出：
- en: '[PRE7]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'This nonce value will be used later in the data saving process for verification.
    So far, we have added the necessary HTML for displaying file upload input fields.
    However, these elements might display all over the place without the necessary
    styles. Therefore, we need to create a directory called `css` inside our plugin
    directory and add a CSS file as `wpqpa.css`. Then, we need to include the CSS
    in the file by using recommended WordPress actions. Consider the following code
    for including the CSS file:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 这个一次性值将在数据保存过程中用于验证。到目前为止，我们已经添加了必要的HTML来显示文件上传输入字段。然而，如果没有必要的样式，这些元素可能会到处显示。因此，我们需要在我们的插件目录内创建一个名为`css`的目录，并添加一个CSS文件，命名为`wpqpa.css`。然后，我们需要通过使用推荐的WordPress操作来包含这个CSS文件。以下是一个包含CSS文件的代码示例：
- en: '[PRE8]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: In WordPress, we need to use `admin_enqueue_scripts` action for adding script
    and style files to the backend, and use the `wp_enqueue_scripts` action for the
    frontend. In this scenario, we are displaying the same files list in both the
    frontend and the backend. Therefore, we use both actions to load the CSS file
    we created. First, we have to register style files by using the `wp_register_style`
    function with a unique key and path. Then, we use the `wp_enqueue_style` function
    to add the styles file to the page. More details and advanced uses of script and
    style loading will be discussed in upcoming chapters. The CSS styles for this
    plugin are not discussed in this chapter. You can use the source files for this
    chapter to understand and modify them.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 在WordPress中，我们需要使用`admin_enqueue_scripts`动作来添加脚本和样式文件到后端，并使用`wp_enqueue_scripts`动作来处理前端。在这种情况下，我们在前端和后端都显示了相同的文件列表。因此，我们使用这两个动作来加载我们创建的CSS文件。首先，我们必须使用带有唯一键和路径的`wp_register_style`函数注册样式文件。然后，我们使用`wp_enqueue_style`函数将样式文件添加到页面中。脚本和样式加载的更多细节和高级用法将在后续章节中讨论。本章节不讨论此插件的CSS样式。你可以使用本章的源文件来理解和修改它们。
- en: 'Now, we can take a look at the modified post creation screen with our metabox,
    as shown in the following screenshot:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以看一下带有我们的元框修改后的帖子创建屏幕，如下面的截图所示：
- en: '![](img/cea5b65e-92ad-476c-bd40-5d447a993401.png)'
  id: totrans-97
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/cea5b65e-92ad-476c-bd40-5d447a993401.png)'
- en: The custom metabox is displayed under the post editor. However, in a single
    site, we could be using many plugins with custom metaboxes. Therefore, you can't
    get the metabox to the exact location we need unless you are willing to change
    the code of such plugins.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 自定义元框显示在帖子编辑器下方。然而，在一个单站点中，我们可能会使用许多带有自定义元框的插件。因此，除非你愿意更改这些插件的代码，否则你无法将元框放置在我们需要的确切位置。
- en: Uploading attachments and saving attachment data
  id: totrans-99
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 上传附件和保存附件数据
- en: The next step in the process is uploading and saving the file that's been selected
    by the administrator. In this scenario, we add the File and File Title inside
    the metabox by using the defined fields. Then, the administrator needs to hit
    the post's Publish or Update button to save the attachment along with the post.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 在此过程中下一步是上传并保存管理员选择的文件。在这种情况下，我们通过定义的字段在元框中添加文件和文件标题。然后，管理员需要点击文章的“发布”或“更新”按钮来保存附件。
- en: Ideally, the attachment details should be uploaded and saved using AJAX in order
    to support multiple files without needing to update the post. In this scenario,
    we have used a normal form submit as we have not introduced AJAX yet and we need
    to understand the process of handling normal POST requests.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 理想情况下，附件详情应使用 AJAX 上传并保存，以支持多文件上传而无需更新文章。在这种情况下，我们使用了正常的表单提交，因为我们尚未引入 AJAX，并且我们需要了解处理正常
    POST 请求的过程。
- en: 'Let''s take a look at the attachment saving process using the following code,
    which has been added to the main file of our plugin:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过以下代码查看附件保存过程，该代码已被添加到我们的插件主文件中：
- en: '[PRE9]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Usually, developers can access POST request data directly within any file of
    the site. However, WordPress uses an event-based architecture and hence we need
    to implement proper hooks to access this data. Accessing the request data outside
    a proper WordPress event can lead to conflicting or the unavailability of data.
    Therefore, we use the `init` action to access the POST data, as the user request
    is fully loaded by the time it reaches the `init` action. More about action execution
    process will be discussed in [Chapter 5](40208ac9-c023-42b1-b48e-a368761b37a6.xhtml),
    *Extending Plugins with Addons, Filters, and Actions*.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，开发者可以直接在任何网站文件中访问 POST 请求数据。然而，WordPress 使用基于事件的架构，因此我们需要实现适当的钩子来访问这些数据。在适当的
    WordPress 事件之外访问请求数据可能会导致冲突或数据不可用。因此，我们使用 `init` 动作来访问 POST 数据，因为用户请求在到达 `init`
    动作时已经完全加载。关于动作执行过程的更多内容将在第 5 章“使用插件扩展、过滤器、和动作”中讨论，[第 5 章](40208ac9-c023-42b1-b48e-a368761b37a6.xhtml)。
- en: The `init` action will be executed for each and every request and hence we need
    to make sure that we use our custom code only when necessary. Therefore, we check
    the availability of the `wpqpa_file_name` field in the user request and return
    without executing the custom code when it's not available. Then, we have to grab
    the necessary data from the POST request. Here, we need three values for the file
    name, nonce, and post ID.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '`init` 动作将为每个请求执行，因此我们需要确保我们仅在必要时使用自定义代码。因此，我们检查用户请求中 `wpqpa_file_name` 字段的可用性，当它不可用时，我们不执行自定义代码并返回。然后，我们必须从
    POST 请求中获取必要的数据。在这里，我们需要三个值：文件名、nonce 和文章 ID。'
- en: 'You may have noticed the use of a function called `sanitize_text_field`. This
    function is used to remove unnecessary tags, spaces, line breaks, and characters
    from text field submissions. You should never trust incoming data; that''s why
    you should use `sanitize_text_field` before recording it. We should always validate
    and restrict user input values to improve the security of the code and prevent
    conflicts in the database. WordPress uses a three step process to secure data
    by validating, sanitizing, and escaping:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经注意到了一个名为 `sanitize_text_field` 的函数的使用。此函数用于从文本字段提交中删除不必要的标签、空格、换行符和字符。你不应该信任传入的数据；这就是为什么在记录之前你应该使用
    `sanitize_text_field`。我们应该始终验证并限制用户输入值，以提高代码的安全性并防止数据库中的冲突。WordPress 通过验证、清理和转义来使用三个步骤来保护数据：
- en: '**Sanitizing**: At this stage, we have to grab the user submitted data and
    make sure that it contains the accepted values. WordPress provides a set of functions
    for cleaning the user input and making it secure. The `sanitize_text_field` is
    one of the functions among thirteen sanitizing functions. The available functions
    and their use are explained at [https://codex.wordpress.org/Validating_Sanitizing_and_Escaping_User_Data#Sanitizing:_Cleaning_User_Input](https://codex.wordpress.org/Validating_Sanitizing_and_Escaping_User_Data#Sanitizing:_Cleaning_User_Input).'
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**清理**：在这个阶段，我们必须获取用户提交的数据并确保它包含接受的值。WordPress 提供了一组用于清理用户输入并使其安全的函数。`sanitize_text_field`
    是其中的一个函数，共有 13 个清理函数。可用的函数及其用途在 [https://codex.wordpress.org/Validating_Sanitizing_and_Escaping_User_Data#Sanitizing:_Cleaning_User_Input](https://codex.wordpress.org/Validating_Sanitizing_and_Escaping_User_Data#Sanitizing:_Cleaning_User_Input)
    中解释。'
- en: '**Validating**: At this stage, we validate the cleaned input values from the
    previous stage. The intention of this step is to check whether user submitted
    data matches with the accepted values. Unlike sanitization, there are no specific
    functions for validation. We can use our own conditions with both PHP and WordPress
    functions for validation. Validating data types, string lengths, data formats,
    and empty values are some of the common uses of this step.'
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**验证**：在这个阶段，我们验证上一阶段清理后的输入值。此步骤的目的是检查用户提交的数据是否与接受的值匹配。与清理不同，没有特定的验证函数。我们可以使用PHP和WordPress函数的自己的条件进行验证。验证数据类型、字符串长度、数据格式和空值是此步骤的一些常见用途。'
- en: '**Escaping**: This step is used when displaying data to the user. The intention
    of this step is to secure the data to be displayed. WordPress provides a set of
    built-in escaping functions based on different data. We will be discussing the
    use of escaping in upcoming chapters. The available escaping functions and their
    use is explained at [https://codex.wordpress.org/Data_Validation#Output_Sanitation](https://codex.wordpress.org/Data_Validation#Output_Sanitation).'
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**转义**：此步骤用于向用户显示数据时。此步骤的目的是确保要显示的数据安全。WordPress提供了一套基于不同数据的内置转义函数。我们将在接下来的章节中讨论转义的使用。可用的转义函数及其使用在[https://codex.wordpress.org/Data_Validation#Output_Sanitation](https://codex.wordpress.org/Data_Validation#Output_Sanitation)中解释。'
- en: You should choose the necessary functions from these three sections for validating
    the user data, depending on the type of fields used in a form and the accepted
    values.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 根据表单中使用的字段类型和接受的值，您应该从这三个部分中选择必要的函数来验证用户数据。
- en: 'The next step in the process is validating input data and uploading the attachment.
    Consider the following code, which is placed after the input data capturing code:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 处理过程的下一步是验证输入数据和上传附件。考虑以下代码，它放置在输入数据捕获代码之后：
- en: '[PRE10]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: First, we need to validate the user request by using the nonce value that we
    added in the custom meta box. We start by checking the existence of the nonce
    value by using the `isset( $_POST['wpqpa_nonce'] )` condition. Then, we can use
    the `wp_verify_nonce` function to verify the submitted nonce value. The first
    parameter to this function takes the value of the nonce field and the second parameter
    takes the action name of the nonce field. Once nonce is successfully verified,
    we can upload the attachment.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要通过使用我们在自定义元框中添加的nonce值来验证用户请求。我们首先通过使用`isset($_POST['wpqpa_nonce'])`条件来检查nonce值的存在。然后，我们可以使用`wp_verify_nonce`函数来验证提交的nonce值。这个函数的第一个参数接受nonce字段的值，第二个参数接受nonce字段的动作名称。一旦nonce成功验证，我们就可以上传附件。
- en: Here, we use a function called `wpqpa_process_file_upload` for handling attachment
    uploads. The majority of the code in the `wpqpa_process_file_upload` function
    is not WordPress-specific and hence self-explanatory. You can use the source code
    files for this chapter to understand the implementation of this function.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用一个名为`wpqpa_process_file_upload`的函数来处理附件上传。`wpqpa_process_file_upload`函数中的大部分代码不是WordPress特定的，因此是自解释的。您可以使用本章的源代码文件来了解此函数的实现。
- en: 'Now, we have to revert back to the `wpqpa_save_private_attachment_files` function,
    where we added the comment *Upload code section 1*. The data generated from the
    upload file''s function is stored in the `$result_upload` variable. Let''s continue
    the implementation to save the attachment details to the custom database table:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们必须回到`wpqpa_save_private_attachment_files`函数，我们在其中添加了注释*上传代码部分1*。从上传文件的功能生成数据存储在`$result_upload`变量中。让我们继续实现，将附件详细信息保存到自定义数据库表中：
- en: '[PRE11]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: First, we check whether the attachment upload has completed by using the status
    option of the `$result_upload` variable. Once the condition is matched, we get
    the file name from the `$result_upload` variable and define the custom table name
    in a variable. Next, we use the `insert` function of the global `$wpdb` object
    to save the data to the `wpqpa_post_attachments` table that was created in the
    activation event of the plugin. We already discussed the use of the `insert` function
    in [Chapter 2](3e88326a-c8fe-4943-ae81-4ff69e8b865e.xhtml), *Managing Database
    Structure, Storage, and Retrieval*, and hence I am not going to explain it in
    this section.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们通过使用`$result_upload`变量的状态选项来检查附件上传是否完成。一旦条件匹配，我们就从`$result_upload`变量中获取文件名，并在一个变量中定义自定义表名。接下来，我们使用全局`$wpdb`对象的`insert`函数将数据保存到插件激活事件中创建的`wpqpa_post_attachments`表中。我们已经在[第2章](3e88326a-c8fe-4943-ae81-4ff69e8b865e.xhtml)中讨论了`insert`函数的使用，因此在此部分中不再解释。
- en: 'Now, the code for the attachment upload process is completed. However, you
    won''t be able to upload attachments at this stage. In order to upload files,
    you need to change the `enctype` of HTML forms to `multipart/form-data`. By default,
    WordPress won''t add the `enctype` attribute to the post submission form. Also
    it''s not possible to manually add it, as the form code is generated within WordPress.
    So, we need to use the built-in `post_edit_form_tag` action to add the necessary
    `enctype`, as shown in the following code:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，附件上传过程的代码已经完成。然而，在这个阶段你将无法上传附件。为了上传文件，你需要将HTML表单的`enctype`更改为`multipart/form-data`。默认情况下，WordPress不会向帖子提交表单添加`enctype`属性。而且，由于表单代码是在WordPress内部生成的，所以无法手动添加。因此，我们需要使用内置的`post_edit_form_tag`动作来添加必要的`enctype`，如下面的代码所示：
- en: '[PRE12]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Now, the entire process is completed and you should be able to test it by uploading
    a file with the use of post Publish or Update buttons. The uploaded attachment
    data should be reflected in the custom table.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，整个过程已经完成，你应该能够通过使用帖子发布或更新按钮上传文件来测试它。上传的附件数据应该反映在自定义表中。
- en: Displaying uploaded attachments
  id: totrans-121
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 显示上传的附件
- en: 'We need a way to display the uploaded files within the post edit screen as
    well as on the frontend, after the post content. For this, we are going to use
    a common function called `wpqpa_file_attachment_list` to generate an attachments
    list, as shown in the following code:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要一种方法在帖子编辑屏幕以及在前端帖子内容之后显示上传的文件。为此，我们将使用一个名为`wpqpa_file_attachment_list`的通用函数来生成附件列表，如下面的代码所示：
- en: '[PRE13]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: This function is placed inside the main plugin file and accepts a post object
    as a parameter. First, we use the `prepare` function of the `$wpdb` object to
    securely prepare the SQL query for execution. In this function, we need to assign
    placeholders to all of the user input data and pass the values as parameters.
    Once the query has been prepared, we can use the `get_results` function to execute
    the query and get a list of files that are attached to the specific post.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数放置在主插件文件中，并接受一个帖子对象作为参数。首先，我们使用`$wpdb`对象的`prepare`函数来安全地准备执行SQL查询。在这个函数中，我们需要为所有用户输入数据分配占位符，并将值作为参数传递。一旦查询已准备就绪，我们就可以使用`get_results`函数来执行查询，并获取与特定帖子相关联的文件列表。
- en: Next, we use a `foreach` statement to loop through the resulting attachments.
    Inside the loop, we get the URL of the post by using the built-in `get_permalink`
    function. Then, we add file-specific query parameters to the URL by using the
    custom `wpqpa_add_query_string` function. You can check the implementation of
    this function inside the main plugin file in the source code directory for this
    chapter. This URL is used to identify the attachment and provides download features
    in later stages of the implementation. Finally, we add the necessary HTML elements
    and containers with the attachment information and the download link. The prepared
    HTML will be returned from this function.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们使用`foreach`语句遍历结果附件。在循环内部，我们通过使用内置的`get_permalink`函数获取帖子的URL。然后，我们使用自定义的`wpqpa_add_query_string`函数向URL中添加文件特定的查询参数。你可以在本章的源代码目录中的主插件文件中检查此函数的实现。此URL用于识别附件，并在实现的后阶段提供下载功能。最后，我们添加必要的HTML元素和容器，包含附件信息和下载链接。准备好的HTML将从此函数返回。
- en: 'Now, we need to call this function within the `display_post_attachments_meta_box`
    function and display the attachments list after the file upload fields. After
    uploading a few files, your screen will look similar to what''s shown in the following
    screenshot:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们需要在`display_post_attachments_meta_box`函数中调用此函数，并在文件上传字段之后显示附件列表。上传几个文件后，你的屏幕将类似于以下截图所示：
- en: '![](img/79e4f4d8-2e00-4e5c-8f88-8306b1613785.png)'
  id: totrans-127
  prefs: []
  type: TYPE_IMG
  zh: '![](img/79e4f4d8-2e00-4e5c-8f88-8306b1613785.png)'
- en: Here, we have only used **Download** as an action button to keep the implementation
    simple and useful for this book. Usually, you will need other actions such as
    edit and delete for attachments.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们只使用了**下载**作为操作按钮以保持实现简单且对本书有用。通常，你将需要其他操作，如编辑和删除附件。
- en: Displaying attachments in posts
  id: totrans-129
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在帖子中显示附件
- en: The main requirement of this plugin was to attach files to posts and let users
    download them from the post page. So far, we have created the background to save
    and display the attachments. Now, it's time to implement the main requirements
    by displaying them after the content of each post.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 此插件的主要要求是将文件附加到帖子中，并允许用户从帖子页面下载它们。到目前为止，我们已经创建了保存和显示附件的背景。现在，是时候通过在每篇帖子的内容后显示它们来实现主要要求。
- en: 'At the start of this chapter, we created a plugin to use the `the_content`
    filter and add dynamic content after the post. The same technique will be used
    in this scenario. Let''s consider the following code for the implementation of
    the `the_content` filter:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章开始时，我们创建了一个插件来使用`the_content`过滤器并在帖子后添加动态内容。同样的技术将在此场景中使用。让我们考虑以下代码来实现`the_content`过滤器：
- en: '[PRE14]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'As usual, we add the `the_content` filter and the callback function to handle
    the display of attachments. First, we check whether we are actually viewing an
    individual post by using the `is_singular` conditional function. If the condition
    is not matched, we return the content, as attachments are only intended for normal
    posts. Once the condition is matched, we call the reusable function we created
    earlier to display the list of attachments for the post. The following screenshot
    previews how attachments are displayed in a single post page:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 如同往常，我们添加了`the_content`过滤器以及回调函数来处理附件的显示。首先，我们使用`is_singular`条件函数检查我们是否正在查看单个帖子。如果条件不匹配，我们返回内容，因为附件仅适用于正常帖子。一旦条件匹配，我们调用我们之前创建的可重复使用的函数来显示帖子的附件列表。以下截图预览了在单个帖子页面中附件的显示方式：
- en: '![](img/05cdbcf7-cf10-4f2c-ac32-f8656ebeb48f.png)'
  id: totrans-134
  prefs: []
  type: TYPE_IMG
  zh: '![](img/05cdbcf7-cf10-4f2c-ac32-f8656ebeb48f.png)'
- en: Now, we have come to the final stage, where we need to implement a file download
    link to complete the plugin.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们已经到达了最后阶段，需要实现一个文件下载链接以完成插件。
- en: Implementing the post attachments download
  id: totrans-136
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现帖子附件下载
- en: 'This section is straightforward for developers who have already implemented
    file downloads with pure PHP. In the preceding section, we created a download
    link with a few custom parameters. Here, we have to use these parameters to identify
    attachments. Let''s start this implementation by adding a custom download function
    on the `init` action:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 对于已经使用纯PHP实现文件下载的开发者来说，本节内容非常直接。在前一节中，我们使用一些自定义参数创建了一个下载链接。在这里，我们必须使用这些参数来识别附件。让我们通过在`init`动作上添加一个自定义下载函数来开始此实现：
- en: '[PRE15]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: As we have already discussed, it's very important to hook every custom function
    into a suitable WordPress action. In this scenario, we chose the `init` action
    since WordPress has finished loading and we need to access data from GET requests.
    We begin this function by checking the GET parameters in the URL to make sure
    that it's a request to download post attachments. You should note the use of `sanitize_text_field`,
    even for GET parameters, which is intended only for verification. Then, we access
    the attachment ID and post ID by using URL parameters with the necessary validation.
    Next, we execute a SQL select query to find the attachment details by using the
    database functions that were discussed in the previous sections. However, there
    is a slight difference in the `get_results` function, and that is that we have
    used an additional parameter called `ARRAY_A`. This is used to define the format
    of the result set. In the previous section, we didn't use this parameter and hence
    we got a set of objects as a result set. Once we use this option, the results
    will be provided in an associative array. Next, we check the availability of a
    matching attachment and use the result set to define the attachment URL and directory
    path.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们已经讨论过的，将每个自定义函数钩入合适的 WordPress 动作非常重要。在这种情况下，我们选择了 `init` 动作，因为 WordPress
    已经完成加载，我们需要从 GET 请求中访问数据。我们从这个函数开始，检查 URL 中的 GET 参数以确保这是一个下载帖子附件的请求。你应该注意 `sanitize_text_field`
    的使用，即使是对于 GET 参数，它仅用于验证。然后，我们通过使用带有必要验证的 URL 参数来访问附件 ID 和帖子 ID。接下来，我们执行一个 SQL
    选择查询，使用之前章节中讨论的数据库函数来查找附件详情。然而，`get_results` 函数有一个细微的差别，那就是我们使用了一个额外的参数，称为 `ARRAY_A`。这是用来定义结果集格式的。在之前的章节中，我们没有使用这个参数，因此我们得到了一组对象作为结果集。一旦我们使用这个选项，结果将以关联数组的形式提供。接下来，我们检查匹配的附件是否存在，并使用结果集来定义附件
    URL 和目录路径。
- en: 'Here''s one way to write the file download code:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是编写文件下载代码的一种方法：
- en: '[PRE16]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: First, we use the file directory path to get the mime type of the file as it's
    important to keep the integrity of the downloaded file. When the mime type is
    not empty, we use the necessary PHP headers for file downloading. We uploaded
    the files with a dynamic name containing a number value based on time. It's not
    ideal to let users download a file with such a name. Therefore, we use the conditional
    check to add the original file name stored in our custom table. We revert to using
    the base name of the file when the original file name is not available in the
    database. The rest of the code contain the usual PHP headers for file downloads
    and the `readfile` function to output the file content. Now, we have completed
    the functionality of the plugin. You should be able to download the attachments
    from the list that's displayed after the post content.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们使用文件目录路径来获取文件的 MIME 类型，因为保持下载文件的完整性非常重要。当 MIME 类型不为空时，我们使用必要的 PHP 头部来下载文件。我们使用基于时间数值的动态名称上传文件。让用户下载这样的文件名称并不理想。因此，我们使用条件检查来添加存储在我们自定义表中的原始文件名。当原始文件名在数据库中不可用时，我们回退到使用文件的基名。其余的代码包含文件下载的常规
    PHP 头部和 `readfile` 函数来输出文件内容。现在，我们已经完成了插件的函数功能。你应该能够从显示在帖子内容之后的列表中下载附件。
- en: Handling plugin version upgrades
  id: totrans-143
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理插件版本升级
- en: The version upgrade process is handled by the built-in `upgrader_process_complete`
    hook. We can implement this hook to add whatever data changes are required for
    the upgrade. We don't have a built-in upgrading event that can handle both plugins
    from the WordPress directory as well as custom plugins. Therefore, we have to
    build a custom upgrade process by using one of the existing hooks and conditional
    checks.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 版本升级过程由内置的 `upgrader_process_complete` 钩子处理。我们可以实现这个钩子来添加升级所需的所有数据更改。我们没有内置的升级事件可以同时处理来自
    WordPress 目录的插件以及自定义插件。因此，我们必须通过使用现有的钩子和条件检查来构建自定义的升级过程。
- en: As we have already discussed, the WordPress plugin directory offers an automatic
    upgrade process. The custom plugins won't have such features by default. Therefore,
    we need to build an automatic upgrade process for the custom plugin. Many custom
    plugins don't have such features and hence we have considered such an implementation
    beyond the scope of this chapter. In such a scenario, users will have to either
    deactivate the current version and upload the new version or replace the current
    version files with a new version. So, the upgrade process needs to happen in the
    initial request after the file's replacement.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们已经讨论过的，WordPress插件目录提供了一个自动升级过程。自定义插件默认不会有这样的功能。因此，我们需要为自定义插件构建一个自动升级过程。许多自定义插件没有这样的功能，因此我们已将此类实现视为本章范围之外的内容。在这种情况下，用户必须停用当前版本并上传新版本，或者用新版本替换当前版本文件。因此，升级过程需要在文件替换后的初始请求中发生。
- en: 'Consider the following code, where we used the `wp_loaded` action to handle
    the upgrade process of this plugin:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下代码，我们使用了`wp_loaded`动作来处理此插件的升级过程：
- en: '[PRE17]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: First, we use the `wp_loaded` hook with a callback function since all of the
    plugins are loaded when executing this hook. Then, we need to compare whether
    we are using the old version or the new version of the plugin. So, we grab the
    current version from the plugin header comments and the stored version from the
    database. Next, we check if the version is already stored in the database. The
    unavailability of the version in the database means that we are installing the
    plugin for the first time and hence we update the version.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们使用`wp_loaded`钩子和回调函数，因为所有插件在执行此钩子时都会被加载。然后，我们需要比较我们是否正在使用插件的旧版本或新版本。因此，我们从插件头部注释中获取当前版本，从数据库中获取存储的版本。接下来，我们检查版本是否已在数据库中存储。版本在数据库中的不可用意味着我们正在首次安装插件，因此我们更新版本。
- en: The next step is comparing the two versions and seeing if the current version
    is higher than the installed version. In such a case, we can execute the tasks
    of the upgrade process. If these values are he same, the version hasn't changed
    and there is no need for the upgrade process. In this example, we are adding a
    default value for a new setting. In real world implementations, we can execute
    tasks such as changing existing data, adding new settings data, and adding database
    tables or columns.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是比较两个版本，看当前版本是否高于已安装的版本。在这种情况下，我们可以执行升级过程的任务。如果这些值相同，版本没有变化，不需要升级过程。在这个例子中，我们为一个新的设置添加一个默认值。在实际应用中，我们可以执行诸如更改现有数据、添加新的设置数据以及添加数据库表或列等任务。
- en: Handling plugin deactivation
  id: totrans-150
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理插件停用
- en: This event is handled by the built-in `register_deactivation_hook` function.
    The use of this function is similar to the activation hook. This plugin contains
    basic features and hence we can't find a suitable practical use of the deactivation
    hook. Therefore, we will not be implementing this event for this plugin.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 此事件由内置的`register_deactivation_hook`函数处理。此函数的使用与激活钩子类似。由于此插件包含基本功能，因此我们无法找到合适的实际用途来使用停用钩子。因此，我们将不会为此插件实现此事件。
- en: Uninstalling the plugin to clean the resources
  id: totrans-152
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 卸载插件以清理资源
- en: There's a big difference between deactivating and uninstalling a plugin. Cleaning
    resources should only be done upon deactivation. WordPress provides two methods
    for implementing the uninstallation process. The first method is using a built-in
    function called `register_uninstall_hook` to handle the uninstall process. This
    works similar to the technique we used in activation, through a callback function.
    The second method is using a file called `uninstall.php` inside the root folder
    of the plugin. In this plugin, we are going to use the latter technique with the
    `uninstall.php` file.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 停用和卸载插件之间有很大的区别。清理资源应在停用后进行。WordPress提供了两种实现卸载过程的方法。第一种方法是通过一个内置函数`register_uninstall_hook`来处理卸载过程。这类似于我们在激活中使用的技巧，通过回调函数。第二种方法是在插件的根目录内使用一个名为`uninstall.php`的文件。在这个插件中，我们将使用后一种技术，即`uninstall.php`文件。
- en: You can view more details about the other technique at [https://developer.wordpress.org/reference/functions/register_uninstall_hook/](https://developer.wordpress.org/reference/functions/register_uninstall_hook/).
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在[https://developer.wordpress.org/reference/functions/register_uninstall_hook/](https://developer.wordpress.org/reference/functions/register_uninstall_hook/)查看有关其他技术的更多详细信息。
- en: 'First, we have to create a file called `uninstall.php` inside the `wpquick-post-attachments`
    plugin directory. This file runs automatically when deleting the plugin from the
    plugins section. We can include the code for the uninstallation process directly
    inside the plugin. This is a basic plugin and hence we only need to delete the
    plugin-specific settings and custom tables that were created for the plugin. Let''s
    take a look at the implementation of the `uninstall.php` file inside the plugin:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们必须在`wpquick-post-attachments`插件目录内创建一个名为`uninstall.php`的文件。当从插件部分删除插件时，此文件会自动运行。我们可以在插件中直接包含卸载过程的代码。这是一个基本的插件，因此我们只需要删除为插件创建的特定设置和自定义表。让我们看看插件内`uninstall.php`文件的实现：
- en: '[PRE18]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: First, we need to check the availability of the `WP_UNINSTALL_PLUGIN` constant.
    This constant is set by WordPress in the process of uninstalling the plugin. If
    the constant is not available, the request could be an invalid one trying to delete
    the plugin data. Once the constant is set, we can implement the resource cleaning
    process. In this scenario, we have deleted the plugin version from the `wp_options`
    table and the whole `wp_wpqpa_post_attachments` table.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要检查`WP_UNINSTALL_PLUGIN`常量的可用性。这个常量是在WordPress卸载插件的过程中设置的。如果常量不可用，请求可能是一个无效的请求，试图删除插件数据。一旦常量被设置，我们就可以实现资源清理过程。在这种情况下，我们已经从`wp_options`表中删除了插件版本，并删除了整个`wp_wpqpa_post_attachments`表。
- en: We have completed the simple plugin planned for this chapter by covering the
    functionality in each life cycle event. Usually, developers often consider the
    functionality and activation events of a plugin. However, upgrading and uninstalling
    events are critical in plugin development and hence you must use them with extra
    caution. Unless these events are handled properly, upgrading can break the entire
    site's functionality while uninstalling can leave a substantial amount of unused
    data.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过涵盖每个生命周期事件的功能，完成了本章计划中的简单插件。通常，开发者经常考虑插件的功能和激活事件。然而，升级和卸载事件在插件开发中至关重要，因此你必须格外小心地使用它们。除非这些事件得到妥善处理，否则升级可能会破坏整个站点的功能，而卸载可能会留下大量未使用的数据。
- en: Identifying the advantages of custom plugin development as a developer
  id: totrans-159
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 作为开发者识别自定义插件开发的优点
- en: 'WordPress has captured over 35% of sites and the enormous plugin base is continuing
    to grow at a rapid pace. So, site owners can find existing plugins to build whatever
    they want. Developers might consider this a risk, since WordPress sites can be
    built without a developer. This is partially true as the need for basic level
    developers are declining. On the other hand, the need for quality WordPress developers
    are emerging more than ever. In this section, we are going to focus on how custom
    plugin development is important for you as a developer. Let''s take a look at
    the advantages of developing custom plugins:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: WordPress已经占据了超过35%的网站，庞大的插件库正在以快速的速度持续增长。因此，网站所有者可以找到现有的插件来构建他们想要的任何东西。开发者可能会认为这是一个风险，因为WordPress站点可以不通过开发者来构建。这在一定程度上是正确的，因为基本级别开发者的需求正在下降。另一方面，对高质量WordPress开发者的需求比以往任何时候都更加突出。在本节中，我们将重点讨论为什么自定义插件开发对你这个开发者来说很重要。让我们看看开发自定义插件的优势：
- en: '**Reusability in many projects**: Among WordPress developers, a higher percentage
    of development is done for individual clients for site-specific requirements.
    Therefore, you may feel that you can add features anywhere you want, as it''s
    not going to change over time. However, you can separate non-project-specific
    features into separate plugins and use them for multiple clients to build rapid
    and cost-effective solutions.'
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**在许多项目中实现复用性**：在WordPress开发者中，有较高比例的开发是为个别客户针对特定网站需求进行的。因此，你可能觉得你可以随意添加任何你想要的功能，因为它们不会随时间改变。然而，你可以将非项目特定功能分离成独立的插件，并为多个客户使用它们来构建快速且成本效益高的解决方案。'
- en: '**Performance and security**: There are some tools and techniques to measure
    the performance and security of WordPress plugins. However, the process is not
    perfect and we won''t have time to check each and every piece of code in existing
    plugins. So, we have no choice other than use existing plugins without knowing
    the risks. In sites where performance and security is a top priority, custom plugin
    development is the best solution as you are aware of the security and performance
    concerns and could improve upon them.'
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**性能和安全**：有一些工具和技术可以衡量WordPress插件的性能和安全。然而，这个过程并不完美，我们没有时间检查现有插件中的每一行代码。因此，我们别无选择，只能使用现有的插件而不了解风险。在性能和安全是首要任务的网站上，定制插件开发是最佳解决方案，因为您了解安全和性能问题，并可以在此之上进行改进。'
- en: '**Build a community for your profile and work**: In my personal experience,
    developing a plugin and releasing it to the public for free is the ideal method
    for exposing you as a developer to the world. There are millions of websites that
    require developers. However, there are also thousands of developers who are capable
    of building WordPress solutions. So, this is the ideal way to reach thousands
    of people that require developers and find potential clients on the way. You will
    also get other benefits as a substantial amount of people will be discussing your
    work and help you fix these issues.'
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**为您的个人资料和工作建立一个社区**：根据我的个人经验，开发插件并将其免费发布给公众是向世界展示您作为开发者的理想方法。有成千上万的网站需要开发者。然而，也有数千名开发者能够构建WordPress解决方案。因此，这是接触数千需要开发者的理想方式，并在过程中找到潜在客户。您还将获得其他好处，因为大量的人会讨论您的工作并帮助您修复这些问题。'
- en: '**Generating a consistent income source**: Premium plugin development has become
    a major business with the evolution of WordPress in recent years. There are developers
    who have made millions of dollars developing plugins in their spare time and selling
    them on their own. So, developing plugins could be an ideal solution for making
    a living without depending on a few clients or needing to find new clients every
    day.'
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**生成一个稳定的收入来源**：随着近年来WordPress的发展，付费插件开发已成为一项主要业务。有些开发者利用业余时间开发插件，赚取了数百万美元，并将它们在自己的平台上销售。因此，开发插件可能是一个理想的解决方案，可以不依赖于少数客户或每天需要寻找新客户来谋生。'
- en: '**Eliminate the concern of version updates**: This is a major concern for most
    site owners as they use the services of freelance developers and hence the developer
    is not available at the stage of upgrading. No matter whether it''s free or premium,
    existing plugins will always release updated versions with more features and fixes.
    On one hand, upgrading without the proper knowledge is a risk as it could break
    the existing features. On the other hand, not upgrading could be a security risk.
    We don''t have this concern in custom development, where you build site-specific
    plugins. Once the site is completed, you don''t need to release a new version
    of the plugin, that is unless you want to add more features or find an incompatibility
    with WordPress versions.'
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**消除版本更新的担忧**：这是大多数网站所有者的一大担忧，因为他们使用自由职业开发者的服务，因此在升级阶段开发者无法提供支持。无论免费还是付费，现有的插件总是会发布带有更多功能和修复的更新版本。一方面，如果没有适当的知识进行升级，可能会破坏现有功能，这存在风险。另一方面，不升级可能会带来安全风险。在我们进行定制开发的情况下，我们不需要担心这个问题，因为您会构建特定于网站的插件。一旦网站完成，您不需要发布插件的新版本，除非您想添加更多功能或发现与WordPress版本不兼容的问题。'
- en: '**Provides flexibility and consistency in design**: Most basic to intermediate
    level WordPress sites are built by using existing plugins. The issue with using
    existing plugins is the flexibility and inconsistency in design. Most plugins
    are developed for common purposes. Therefore, the design is either very basic
    to suit any site or fixed without much flexibility. So, using any number of plugins
    means that the elements generated from plugins will be completely different to
    the design of the theme. This leads to the tedious process of plugin customization
    to make the design consistent. On the other hand, custom plugins can be designed
    to match the theme of the site and keep the consistency of design. Therefore,
    you can develop custom plugins when it''s cost-effective compared to the customization
    of existing plugins.'
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**提供设计上的灵活性和一致性**：大多数基本到中级水平的WordPress网站都是通过使用现有插件来构建的。使用现有插件的问题在于设计的灵活性和不一致性。大多数插件是为通用目的开发的。因此，设计要么非常基础以适应任何网站，要么固定且缺乏灵活性。所以，使用任意数量的插件意味着插件生成的元素将与主题设计完全不同。这导致了一个繁琐的过程，即插件定制以使设计保持一致。另一方面，定制插件可以设计得与网站主题相匹配，并保持设计的一致性。因此，当与现有插件的定制相比具有成本效益时，你可以开发定制插件。'
- en: These advantages are only a few among the dozens of direct and indirect benefits.
    You should read WordPress-related blogs and explore the work of popular developers
    to understand the capacity and potential of plugin development.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 这些优势只是众多直接和间接好处中的一小部分。你应该阅读与WordPress相关的博客，并探索知名开发者的作品，以了解插件开发的潜力和能力。
- en: Guidelines for building quality plugins
  id: totrans-168
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建高质量插件的指南
- en: Up until this point, we have looked at the process of building simple plugins
    with the recommended practices. Most of you will be developing WordPress sites
    for individual clients and hence the plugins you develop will not have to go through
    a verification process for quality. However, it's important to build extendable
    and maintainable plugins that are to be compatible with WordPress version upgrades
    as well as other third-party plugins. On the other hand, if you are developing
    plugins for the WordPress plugin directory or premium plugin marketplace, you
    will have to go through an extensive verification and review process for both
    the code and features. So, the quality of the plugin needs to match the minimum
    quality standards.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经讨论了使用推荐实践构建简单插件的过程。你们中的大多数人将开发WordPress网站供个人客户使用，因此你们开发的插件不需要经过质量验证过程。然而，构建可扩展和可维护的插件，这些插件与WordPress版本升级以及其他第三方插件兼容，这一点很重要。另一方面，如果你正在为WordPress插件目录或高级插件市场开发插件，你将不得不对代码和功能进行广泛的验证和审查过程。因此，插件的质量需要符合最低质量标准。
- en: 'Let''s take a look at some of the common guidelines for building quality WordPress
    plugins, apart from the need to follow WordPress coding standards:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看构建高质量WordPress插件的一些常见指南，除了需要遵循WordPress编码标准之外：
- en: '**Using built-in WordPress functions**: This is a common problem in WordPress
    development where developers tend to create their own functions due to a lack
    of knowledge in WordPress. The power of WordPress comes from its existing modules
    and hence we should always use the existing functions rather than create our own
    functions. Also, the existing functions are optimized and coded by expert WordPress
    developers and hence there is less chance of generating bugs or compatibility
    issues.'
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**使用内置的WordPress函数**：这是WordPress开发中常见的问题，由于开发者对WordPress缺乏了解，往往倾向于创建自己的函数。WordPress的力量来自于其现有的模块，因此我们应该始终使用现有的函数，而不是创建自己的函数。此外，现有的函数是由经验丰富的WordPress开发者优化和编写的，因此产生错误或兼容性问题的可能性较小。'
- en: '**Using the necessary hooks in existing features**: Certain hooks are used
    in core features to let developers customize and extend their functionality. If
    you are implementing or modifying a core feature, you should include the necessary
    hooks so that solutions created by other developers are compatible with your solution.'
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**使用现有功能中的必要钩子**：某些钩子在核心功能中使用，以便开发者自定义和扩展其功能。如果你正在实现或修改核心功能，你应该包含必要的钩子，以便其他开发者创建的解决方案与你的解决方案兼容。'
- en: '**Always load built-in libraries**: There can be dozens of plugins inside a
    single site and often some of these plugins require the same libraries, such as
    jQuery. So, one developer may build the solution for a specific jQuery version
    and another one could build for a different version. Including multiple versions
    of the same library often leads to conflicts. Therefore, you should always check
    if the library is available within the WordPress core and load the built-in version
    by using the recommended hooks.'
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**始终加载内置库**：一个网站中可能包含数十个插件，并且通常其中一些插件需要相同的库，例如jQuery。因此，一个开发者可能为特定的jQuery版本构建解决方案，而另一个开发者可能为不同的版本构建。包含同一库的多个版本通常会导致冲突。因此，你应该始终检查库是否在WordPress核心中可用，并通过使用推荐的钩子加载内置版本。'
- en: '**Use plugin-specific prefixes**: When working with plugins that come from
    multiple developers, there is a high chance of generating conflicts in both code
    as well as data. So, we should always add a unique prefix to our plugin. We should
    use this prefix on function names, class names, constants, database tables, and
    even plugin-specific data in common tables such as `wp_options`, `wp_postmeta`,
    and `wp_usermeta`. However, most of the modern plugins follow the object-oriented
    style, and hence you may not need to use the prefix for function names.'
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**使用插件特定的前缀**：当与来自多个开发者的插件一起工作时，代码和数据中产生冲突的可能性很高。因此，我们应该始终为我们的插件添加一个唯一的前缀。我们应该在函数名、类名、常量、数据库表以及如`wp_options`、`wp_postmeta`和`wp_usermeta`等公共表中的插件特定数据上使用这个前缀。然而，大多数现代插件遵循面向对象风格，因此你可能不需要为函数名使用前缀。'
- en: '**Use hooks for extendable features**: You might be developing a plugin with
    common solutions after complete research of the requirements. But, more often
    than not, clients will ask for customization''s in all parts in your code. So,
    it''s better to keep your code as open as possible for future changes. Therefore,
    you should always use filters for values which might change and use actions for
    places where the process or template can be extended.'
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**使用钩子扩展可扩展功能**：你可能已经对需求进行了彻底的研究，并开发了一个具有常见解决方案的插件。但更常见的情况是，客户会要求对你的代码的所有部分进行定制。因此，最好让你的代码尽可能开放，以适应未来的变化。因此，你应该始终使用过滤器来处理可能改变的价值，并使用动作来扩展过程或模板的地方。'
- en: These are some of the well-known and recommended guidelines. As you gain experience
    with plugin development, you can add a lot more guidelines to the preceding list
    based on user feedback and how other plugins work. Make sure that you use these
    guidelines as much as possible and release the plugin to the public whenever possible.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是一些知名且推荐的指南。随着你对插件开发的经验积累，你可以根据用户反馈和其他插件的工作方式，将更多指南添加到前面的列表中。确保尽可能多地使用这些指南，并在可能的情况下将插件发布给公众。
- en: Summary
  id: totrans-177
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: Plugins can be considered the most important aspect of WordPress when it comes
    to custom development. If we discard the existing plugin base, WordPress will
    be a just another CMS without major attention from users or developers. As a developer,
    it's important to know the ins and outs of plugin development to survive in the
    growing WordPress community. Due to this, in this chapter, we looked at the role
    of plugins in development by discussing common plugin-related tasks. We chose
    popular plugins to explain different types of plugins and how they interact with
    WordPress sites. Next, we looked at the process of creating a basic plugin for
    WordPress. Most beginner developers are capable of building solutions with PHP
    and integrating the solution as a WordPress plugin. However, plugins created without
    the knowledge of complete life cycle events can turn into a nightmare at later
    stages of the project. Therefore, we looked at the life cycle events of a WordPress
    plugin and the functionality of each event. Next, we built a WordPress plugin
    to attach files to posts and let users download them from the frontend. In the
    process, we covered life cycle events, data validation, sanitization, use of metaboxes,
    and the concept of nonces. Finally, we looked at the common guidelines for building
    quality plugins and how plugin development can benefit you as a WordPress developer.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 插件在WordPress的定制开发中可以被认为是最重要的方面。如果我们摒弃现有的插件库，WordPress将仅仅是一个没有引起用户或开发者主要关注的另一个CMS。作为一名开发者，了解插件开发的方方面面对于在日益增长的WordPress社区中生存至关重要。因此，在本章中，我们通过讨论常见的插件相关任务来探讨了插件在开发中的作用。我们选择了流行的插件来解释不同类型的插件以及它们如何与WordPress站点交互。接下来，我们研究了创建WordPress基本插件的过程。大多数初学者开发者都能够使用PHP构建解决方案并将其作为WordPress插件集成。然而，没有了解完整生命周期事件的插件在项目后期可能会变成一场噩梦。因此，我们研究了WordPress插件的生命周期事件以及每个事件的功能。接下来，我们构建了一个WordPress插件，用于将文件附加到帖子中，并允许用户从前端下载它们。在这个过程中，我们涵盖了生命周期事件、数据验证、净化、使用元框以及nonce的概念。最后，我们探讨了构建高质量插件的一般指南以及插件开发如何作为WordPress开发者对你有益。
- en: In [Chapter 5](40208ac9-c023-42b1-b48e-a368761b37a6.xhtml), *Extending Plugins
    with Addons, Filters, and Actions*, we will be looking at advanced plugin concepts
    as well as customizing existing popular plugins.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第5章](40208ac9-c023-42b1-b48e-a368761b37a6.xhtml)《使用插件扩展、过滤器和动作》中，我们将探讨高级插件概念以及定制现有流行插件。
