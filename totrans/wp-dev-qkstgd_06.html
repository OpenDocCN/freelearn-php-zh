<html><head></head><body>
        <section>

                            <header>
                    <h1 class="header-title">Practical Usage of WordPress APIs</h1>
                </header>
            
            <article>
                
<p>The use of application programming interfaces is common in modern websites. We use APIs such as Google Maps, Google Analytics, and Facebook to leverage the functionality of third-party services. Basically, APIs are created by developers to enable their features to other developers and platforms. Similarly, WordPress APIs let us use core features in a standard way to change and extend the functionality. We can also use these features to create our own APIs on top of WordPress and expose them to third-party services and platforms.</p>
<p>In this chapter, we are going to explore the available APIs, their functionality, and their use in development. We will be focusing more on three APIs that play a major role in custom development and yet have not been introduced in previous chapters. Developers often use WordPress shortcodes to provide pieces of reusable functionality, and the clients are familiar with using these shortcodes. So, we look into the techniques of creating shortcodes as well as identifying limitations. Next, we look at the importance of the Rewrite API in development tasks for building features without affecting the core features. Finally, we look at the REST API usage for enabling features to third-party developers through a standard interface.</p>
<p>In this chapter, we will cover the following topics:</p>
<ul>
<li>A brief overview of WordPress APIs</li>
<li>Introducing Shortcode API</li>
<li>Creating custom shortcodes</li>
<li>Understanding the usage of shortcodes</li>
<li>Managing custom routes with Rewrite API</li>
<li>Building remote connections with REST API</li>
</ul>
<p class="mce-root"/>
<p><span>By the end of this chapter, you should understand the API functions required for your development tasks. </span><span>Also, you should be able to build reusable features with shortcodes and expose your features to third-party applications</span> using REST API.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Technical Requirements</h1>
                </header>
            
            <article>
                
<p>You will be required to have WordPress 4.9.8 installed to follow this procedure. Even if you have a later version of WordPress, the described examples should work with no significant problems.</p>
<p class="mce-root">The code files of this chapter can be found on GitHub:<br/>
<a href="https://github.com/PacktPublishing/WordPress-Development-Quick-Start-Guide/tree/master/Chapter06">https://github.com/PacktPublishing/WordPress-Development-Quick-Start-Guide/tree/master/Chapter06</a></p>
<p class="mce-root">Check out the following video to see the code in action:<br/>
<a href="http://bit.ly/2EQa24y" target="_blank">http://bit.ly/2EQa24y</a></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">A brief overview of WordPress APIs</h1>
                </header>
            
            <article>
                
<p>WordPress API is a set of sub APIs that works together, allowing developers to build on top of core features. The individual APIs cover one or more core features, while some of the APIs can be used beyond WordPress's core features. The REST API, Rewrite API. and Shortcode API are some of the ones we can use for WordPress's core features, as well as custom features. The use of WordPress APIs reduces your workload as a developer, compared to building your own functions. Let's take a look at the advantages of using APIs in WordPress:</p>
<ul>
<li><strong>Use of actions and filters</strong>: WordPress API functions executes the necessary actions and filters within the process, allowing developers to customize the features. Using our own custom functions omits these actions and filters. Therefore, it will be difficult to combine or use many plugins together, as some of the plugins might be relying on these hooks within API functions.</li>
<li><strong>Input validation and security</strong>: The built-in API functions are developed and tested by the best WordPress developers in the world. Therefore, validation of the data and security in the process is highly reliable.  Using custom built functions instead of API functions increases the workload of the developer to implement these security features and validations.</li>
<li><strong>Efficiency</strong>: The built-in API functions are optimized to provide better performance when interacting with database as well as working with core features and files. So, using these functions improves the efficiency of your solutions.</li>
<li><strong>Backward compatibility</strong>: The WordPress team gives high priority to compatibility with older versions and hence rarely removes support for old functions and features. Therefore, using API functions guarantees the compatibility of the features in current WordPress versions, as well as future versions.</li>
</ul>
<p><span>The preceding list explains why developers should use APIs whenever possible to save development time, as well as build risk-free solutions.</span></p>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mceNonEditable"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Using built-in APIs</h1>
                </header>
            
            <article>
                
<p><strong> </strong>As of the latest version, WordPress offers eighteen individual APIs to work with different parts of the core. We have already used some of the API functions in previous chapters. We are going to learn about a few APIs in detail throughout this chapter. Let's take a look at the available APIs and their role in development:<strong> </strong></p>
<ul>
<li><strong>Dashboard widget API</strong>: It is used to add, edit, or modify the widgets on the admin dashboard. The dashboard is the location where each user is redirected after logging in from the backend. The default dashboard widgets includes <strong>At a Glance</strong>, <strong>Quick Draft</strong>, and <strong>Activity</strong>. This API is useful for building project-specific dashboards by removing unnecessary widgets and adding plugin specific widgets. </li>
<li><strong>Database API</strong>: It is used to simplify and optimize the operations in core database tables. We have already used core database API features using the <kbd>global $wpdb</kbd> object and query functions in <a href="3e88326a-c8fe-4943-ae81-4ff69e8b865e.xhtml" target="_blank">Chapter 2</a>, <em>Managing Database Structure, Storage, and Retrieval</em>.</li>
<li><strong>HTTP API</strong>: It is used to securely execute HTTP operations such as sending requests for data or retrieving data. The API functions checks the server-supported connection types among various available connection types in PHP. We haven't used the HTTP API in previous chapters. </li>
<li><strong>File Header API</strong>: It<strong> </strong>is used for working with file headers in themes and plugins. The functions of the API identifies themes and plugins using header comments section of files. From a developer's perspective, the functionality of this API will not be commonly used in development tasks. </li>
<li><strong>File System API</strong>: It is used for reading and writing local files to the filesystem on various hosting environments. From a developer's perspective, the functionality of this API will not be commonly used in development tasks. </li>
<li><strong>Metadata API</strong>: It is used to work with WordPress meta object types in a standard way. WordPress provides meta tables for posts, users, and comments. These functions allows you to add, edit, modify, and delete post metadata with optimum performance. We already worked with the meta data API with the use of post meta functions such as <kbd>update_user_meta</kbd> and <kbd>get_user_meta</kbd> in <a href="40208ac9-c023-42b1-b48e-a368761b37a6.xhtml" target="_blank">Chapter 5</a>, <em>Extending Plugins with Addons, Filters, and Actions</em>. From a developer's perspective, the functionality of this API is very important and commonly used in development tasks. </li>
</ul>
<p class="mce-root"/>
<p class="mce-root"/>
<ul>
<li><strong>Options API</strong>: It is used to work with the options table in WordPress for storing sitewide settings as well as theme and plugin-specific settings. These API functions allow you to add, edit, modify, and delete options with optimum performance. We already worked with the Options API with the use of  functions such as <kbd>get_option</kbd> and <kbd>update_option</kbd> in <a href="6bc0e5d5-b12d-4710-ac11-a600af054efa.xhtml" target="_blank">Chapter 4</a>, <em>Building Custom Modules with Plugin Development</em>. From a developer's perspective, the functionality of this API is very important and is commonly used in development tasks. </li>
<li><strong>Plugin API</strong>: It is used in plugin development and hence it is important for you as a developer. The API consists of functions for managing WordPress hooks. We already worked with this API by using <kbd>add_filter</kbd>, <kbd>apply_filters</kbd>, <kbd>add_action</kbd> functions. </li>
<li><strong>Quicktags API</strong>: It is used to allow developers to add additional buttons to the <strong>Text</strong> mode of the WordPress content editor. We haven't used this API, as it's only focused on modifying the content editor. From a developer's perspective, this API is important in scenarios where <span>content creation is </span>the primary feature of the site. </li>
<li><strong>Settings API</strong>: It is used to create and manage settings for your site as well as theme or plugins. You can use this API to add settings to existing settings pages of add your own custom settings sections to the WordPress Settings menu. This is one of the simplest methods to add and save settings, as most of the functionality is handled by the API. From a developer's perspective, this API is very important for building any kind of site. </li>
<li><strong>Theme Modification API</strong>: It is intended for theme developers to add and retrieve settings of a theme as WordPress options. This API doesn’t play a vital role in development, unless you are building custom themes. </li>
<li><strong>Theme Customization API</strong>: It is used to customize theme settings, widgets, styles, and to see a preview of the changes instantly. You can access the features generated by this API using <span class="packt_screen">Appearance</span> | <span class="packt_screen">Customize</span> section. The developers can use this API to add their own settings, sections, and controls. </li>
<li><strong>Transients API</strong>: It is used to temporarily store or cache the information in <kbd>wp_options</kbd> table. Unlike WordPress options, transients have an expiration time and hence are only used for keeping information for short periods. The API functions allows you to store, retrieve, and delete transients with various options. </li>
</ul>
<ul>
<li><strong>Widgets API</strong>: It is used for creating and managing widgets in WordPress. In WordPress, a widget is a reusable piece of component that is mainly intended for the sidebar of the site. We will be discussing more about widgets and API functions in upcoming chapters. </li>
<li><strong>XML – RPC API</strong>: It is used to expose the site functionality to third-party services and applications. This is the old way of providing API features, and it’s deprecating slowly with the emergence of REST API. </li>
</ul>
<p>In this section, we had a brief overview of all the WordPress APIs except three. The APIs for shortcodes, rewrite rules, and REST play a major role in custom development, and hence we are going to discuss them in detail throughout the upcoming sections. <span>You can view more details about the preceding APIs at <a href="https://codex.wordpress.org/WordPress_API%27s">https://codex.wordpress.org/WordPress_API%27s</a></span>.<span><a href="https://codex.wordpress.org/WordPress_API%27s"/></span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Introducing shortcodes</h1>
                </header>
            
            <article>
                
<p>Shortcode in WordPress is a piece of code that generates dynamic content for the site or alters a given content based on various requirements. This feature was introduced to allow users to add dynamic content to posts or pages. However, modern websites use shortcodes beyond its intended purpose. We can see shortcodes being used in widgets, template files, and even inside the plugin for improving reusability. The shortcode API is a set of functions allowing developers to easily create and use shortcode based on their preferences. Modern websites use advanced themes as well as numerous plugins for providing advanced features with eye-catching designs. Therefore, you will see an increased use of shortcodes. The shortcode is one of the simplest ways to add a feature to a site, and hence it's important to have thorough understanding of API functions.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Structure of a shortcode</h1>
                </header>
            
            <article>
                
<p>In this section, we are going to understand WordPress shortcode by considering the perspective of different user types. As a developer, it's important to understand all the three user perspectives to build and use shortcodes in development tasks. Let's take a look at the following diagram:</p>
<div class="packt_figref CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-328 image-border" src="assets/9d20fe00-9482-4e47-808e-5580c98294ec.png" style="width:35.75em;height:23.83em;"/></div>
<p>The preceding diagram is based on the three user perspectives involved in the process of using shortcodes.</p>
<div class="packt_infobox">The use of content is optional for a shortcode. We can find many self-enclosing shortcodes that generate the output without using any content.</div>
<p>Let's understand each of these three user perspectives.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Developer's perspective of a shortcode</h1>
                </header>
            
            <article>
                
<p>The developer is responsible for building the shortcode, unless you only plan to use the shortcodes available in the WordPress core. The shortcode needs to be created using the API functions and registered with WordPress using a plugin or theme. The preceding diagram shows the basic syntax of a shortcode from a developer’s perspective.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Content creator perspective of a shortcode</h1>
                </header>
            
            <article>
                
<p>Usually, the site administrator creates the content for most of the sites. However, you may also have other user roles or specific users with permission to create content. These users are responsible for using the shortcodes with necessary attributes and content in the site development process. The previous diagram illustrates the main syntax of a shortcode, where these users will use inside posts or pages.</p>
<p>They can use the shortcodes offered by WordPress core, theme, or plugins on the site. It's not a must for the content creator to know the source of the shortcode. However, the knowledge of whether a shortcode is generated from a theme, plugin, or WordPress core becomes handy in scenarios where you want to switch the theme or a plugin. Lack of knowledge in the source of the shortcode may lead to conflicts or even a complete breakdown of the site in such scenarios. These users are not aware of the source code of a shortcode, unless they want to explore the code inside theme or plugins.<strong> </strong></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">User's perspective of a shortcode</h1>
                </header>
            
            <article>
                
<p>The user is anyone who visits the site, including guests and members. They will only see the output generated from the shortcode. These users are not aware of the existence of a shortcode, as the shortcode is not visible on the browser view or the page source. Also, the shortcode output doesn't have any predefined IDs or classes, and hence it’s not possible for these users to track a shortcode from the frontend.</p>
<p>Now you should have a basic idea of how WordPress shortcode is created and used to generate dynamic output. More details on the creation and use of a shortcode will be discussed in upcoming sections.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Using built-in shortcodes</h1>
                </header>
            
            <article>
                
<p>WordPress core contains set of built-in shortcodes mainly focused on adding various content types to posts and pages. The content creators can use these shortcodes directly on posts, pages, or any supported location without the need for any modifications. Let’s take a look at the existing shortcodes:</p>
<ul>
<li><strong>Audio</strong>: It used for embedding and playing audio files</li>
<li><strong>Caption</strong>: It used for adding captions to content. Mainly used for images</li>
<li><strong>Embed</strong>: It used for embedding content from different sites supported by WordPress</li>
<li><strong>Gallery</strong>: It used for displaying image galleries by passing the image ID's</li>
</ul>
<ul>
<li><strong>Video</strong>: It used for embedding and playing video files</li>
<li><strong>Playlist</strong>: It used for displaying collection of audio and video files</li>
</ul>
<p>As you can see, these shortcodes don't use the main data of a WordPress site, such as posts, comments, users. So, we will have to work with shortcodes from external plugins or create custom shortcodes to cater for the functionality involving the WordPress database.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Building custom shortcodes</h1>
                </header>
            
            <article>
                
<p>The process of building custom shortcodes is not as complex as many people think. The minimal implementation of a shortcode requires only few lines of code as shown in the diagram in the last section. A shortcode consists of four main parts:</p>
<ul>
<li><strong>Opening and closing tags</strong>: Opening and closing tags are similar to HTML, WordPress shortcodes have opening and closing tags using square brackets. These tags are used by content creators to add the functionality into posts or pages. On the other hand, developers need to use this <kbd>tag</kbd> to register a shortcode as a unique element. Some of the shortcodes don’t have a closing tag and use a self-enclosing opening tag. </li>
<li><strong>Attributes</strong>: Attributes is a collection of data and settings required to process the functionality within the shortcode function and return the output. The list of attributes starts after the shortcode name in the opening tag. Each attribute has a key and values, as shown in the structure of a shortcode image. The attributes should be separated by one or more spaces. Inside the shortcode, developers can access the passed attributes using the array keys of the attributes variable.</li>
<li><strong>Content</strong>: Content is the content we add between the opening and closing tags of the shortcode. Once content is used, shortcode will act as a WordPress filter where we retrieve, process, and return the modified content. We can also define shortcodes without content by using a self-enclosing opening tag.</li>
<li><strong>Output</strong>: Output is the return value by the shortcodes based on the passed attributes and content. The output will be either content modified within the shortcode or the content will be used to capture and display site data. Many developers tend to print the shortcode output directly to the browser using PHP <kbd>echo</kbd> statements. However, shortcodes should always return the output instead of printing directly to the browser.</li>
</ul>
<p>Now we can move on to the process of creating custom shortcodes using these parts.</p>
<p class="mce-root"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Creating custom shortcodes</h1>
                </header>
            
            <article>
                
<p>In this section, we are going to consider two scenarios to build custom shortcodes and explain the different kinds of uses of a shortcode. Let's list the <span><span>two </span></span>requirements for building shortcodes for each one:</p>
<ul>
<li>Restricting the content based on a user's role</li>
<li>Displaying a list of posts with attachments</li>
</ul>
<p>Let's get started.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Restricting content using a shortcode</h1>
                </header>
            
            <article>
                
<p>This scenario explains the creation of a shortcode using all the four shortcode components discussed in the previous section. Basically, we need a shortcode that accepts content and displays the output only to authorized users, while providing a custom output for unauthorized users. Let's consider the shortcode needed for this scenario:</p>
<pre>[wpquick_restrict_content  role=subscriber]  Content to be protected [/wpquick_restrict_content]</pre>
<p>The previous shortcode has one attribute for specifying the user roles not authorized to view the content and the content to be protected within the opening and closing tags. Now we have to match the previous shortcode with the code used in the <em>Structure of a shortcode</em> diagram. Consider the following code for the implementation of this shortcode:</p>
<pre>add_shortcode( 'wpquick_restrict_content', 'wpquick_restrict_content_display' );<br/>function wpquick_restrict_content_display( $atts, $content ){<br/>  $sh_attr = shortcode_atts( array( 'role' =&gt; '' ), $atts );<br/> <br/>  if( $sh_attr['role'] != '' &amp;&amp; ! current_user_can( $sh_attr['role'] ) ){<br/>    $content = __('You don\'t have permission to view this content','wqsa');<br/>  } <br/>  return $content;<br/>}</pre>
<p>In this case, a callback function accepts attributes and content for the shortcode. WordPress provides a function called <kbd>shortcode_atts</kbd> to merge the passed attributes with default attributes and make an array of attributes required for processing the shortcode. It's a good practice to define the allowed attributes and default values inside the <span><kbd>shortcode_atts</kbd> function as an array. In this case, we are passing a value for the</span> <kbd>role</kbd> <span>parameter, and hence it will override the default parameter.</span></p>
<p><span>If we don't specify a value for a attribute, <kbd>shortcode_atts</kbd> will look for the default value. Next, we access the attributes using <kbd>$sh_attr</kbd> array and apply the conditions. Finally, we return the original content or a message based on the conditions. This is the most basic code required to build a shortcode.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Displaying posts with attachments</h1>
                </header>
            
            <article>
                
<p>This scenario explains a different use of a shortcode from both a developer's perspective as well as a content creator's perspective. Here, we need to display the list of posts with at least one attachment. Unlike the previous scenario, we are not retrieving and modifying the content. Instead, we are generating dynamic content based on the shortcode attributes. Let’s take a look at the shortcode needed for this scenario:</p>
<pre>[wpquick_attachment_posts/]</pre>
<p>As you can see, there is no closing tag, and the closing part is done within the opening tag. These types of shortcodes are called as <em>self-enclosing</em> shortcodes. We don’t use any content in such shortcodes. In this case, we are displaying all the posts with attachments, and hence shortcode attributes are not required. If we were displaying posts with attachments for a specific category, the shortcode would have looked as follows:</p>
<pre>[wpquick_attachment_posts category='1' /]</pre>
<p>Now we can implement the previous shortcode by matching it with the syntax we used in our shortcode diagrams:</p>
<pre>add_shortcode( 'wpquick_attachment_posts', 'wpquick_attachment_posts_display' );<br/>function wpquick_attachment_posts_display( $atts, $content ){<br/>  global $wpdb;<br/>  $post_attachments_table = $wpdb-&gt;prefix.'wpqpa_post_attachments'; <br/>  $sql = "SELECT P.post_title,P.guid from $post_attachments_table as PA inner join $wpdb-&gt;posts as P on P.ID=PA.post_id group by PA.post_id ";<br/><br/>  $result = $wpdb-&gt;get_results($sql);<br/>  $html = '';<br/>  if($result){<br/>    foreach ( $result as $key =&gt; $value ) {<br/>      $html .= '&lt;a href="'. $value-&gt;guid .'"&gt;'. $value-&gt;post_title .'&lt;/a&gt;&lt;br/&gt;'; <br/>    }<br/>  } <br/>  return $html;<br/>}</pre>
<p>In this case, we have no attributes, and hence we query the custom table by joining it with a posts table to generate the result. The <kbd>$content</kbd> variable will be empty, as we are not passing any data by using opening and closing tags. Finally, we return the HTML string to display the list of posts.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Understanding the usage of shortcodes</h1>
                </header>
            
            <article>
                
<p>We discussed the techniques of building shortcodes in previous section. Now we need to understand the techniques of using these shortcodes in different parts of the site. Let's take a look at the different locations where we can use shortcodes:</p>
<ul>
<li><strong>Posts and pages</strong>: This is the most common use of a shortcode, where the content creator directly adds the shortcode to the post or page editor. Then, WordPress executes the shortcode and displays the result in the frontend post or page.</li>
<li><strong>Widgets</strong>: We can use shortcodes inside WordPress widgets to provide dynamic content similar o the posts and pages. However, we have to use additional code depending on the widget we use. The WordPress <strong>Text widget</strong> allows you to add shortcodes directly to the content editor and display the output on the frontend. Sometimes, you may want to use the shortcodes with HTML elements and hence need to use the <strong>HTML widget</strong> instead of the <strong>Text widget</strong>. The HTML widget doesn’t support shortcodes by default. So, we have to use the following code in the <kbd>functions.php</kbd> file of the theme or within any plugin to execute the shortcode:</li>
</ul>
<pre>     add_filter( 'widget_text', 'do_shortcode' );</pre>
<p style="padding-left: 60px">WordPress has a filter called <kbd>widget_text</kbd> that gets executed on the content of all widgets. We can use this filter to change the content as required. So far, we used <kbd>add_filter</kbd> statement with a callback function. Here, we also have a callback function called <kbd>do_shortcode</kbd>. However, you might be wondering why the implementation is missing. The <kbd>do_shortcode</kbd> function is built into WordPress, and hence we can directly call it without adding an implementation for the function. This function executes any shortcodes within the content.</p>
<ul>
<li><strong>Template Files</strong>: Sometimes, we may need to call shortcodes inside a header, footer, or any template file. This becomes handy when you are customizing existing themes to integrate the features of other plugins. In such scenarios, adding the shortcode to the template file won’t work. We have to use a PHP script and execute the shortcode using <kbd>do_shortcode</kbd> function. Consider the following code for using a shortcode inside a template file: </li>
</ul>
<pre>      &lt;?php echo do_shortcode('wpquick_attachment_posts'); ?&gt; </pre>
<p style="padding-left: 60px">We need to also use the <kbd>echo</kbd> statement to print the output to the browser, as it's not automatically printed as in previous scenarios.</p>
<ul>
<li><strong>Plugins and themes</strong>: Sometimes, we want to integrate the shortcode features with other plugins or themes. In such cases, we can directly call the shortcode instead of replicating the code for the shortcode. Assume we want to display the posts with attachments after the content of each post. In this scenario, we can internally call the shortcode within our plugin and generate the list of posts with attachments instead of writing a separate function or duplicating code. Consider the following statement for using a shortcode within a theme or a plugin code:</li>
</ul>
<p>These are some of the common methods and locations for using shortcodes. </p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Tips for using shortcodes</h1>
                </header>
            
            <article>
                
<p>The shortcode is a simple and flexible way of adding reusable functionality to a site. However, there are pros and cons of using shortcodes. As a developer, you need to understand when to use shortcodes and how to build quality shortcodes. The following tips will help you improve the shortcodes, as well as avoid unnecessary issues:</p>
<ul>
<li><strong>Filtering shortcode output</strong>: Usually, we create some content within the shortcode and directly return the content as output. There are some plugins that use a filter on the output of a shortcode. It's a great way of adding more flexibility where the developers can control the shortcode output of other plugins.</li>
<li><strong>Using nested shortcodes</strong>: We can add shortcodes inside other shortcodes to get an output. However, when using nested shortcodes, you need to use <kbd>do_shortcode</kbd> in the main shortcode to execute the shortcodes within its content.</li>
</ul>
<ul>
<li><strong>Validating shortcode attributes</strong>: Attributes are added by the content creators and hence need to be considered as user input. Since we shouldn't trust any kind of user input, validation is a must for attribute values.</li>
<li><strong>Using unique shortcode names</strong>: Many plugins use generic shortcode names such as <kbd>[product]</kbd>, <kbd>[event]</kbd>, and so on. This may lead to conflicts with multiple plugins, and hence you should always use a plugin-specific prefix to make it unique.</li>
</ul>
<ul>
<li><strong>Overuse of shortcodes</strong>: Shortcode is an easy way of adding a bunch of content. However, using too many shortcodes inside posts or pages can lead to maintenance nightmares in later stages. As the post or page is dependent on shortcodes, it will be difficult to change the content.</li>
</ul>
<p>We have covered the process of creating and using shortcodes. Now it's time to take a look at plugins that use shortcodes and identify various uses and developing techniques.</p>
<p> </p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Managing custom routes with Rewrite API</h1>
                </header>
            
            <article>
                
<p>The default WordPress URL structure uses query parameters to load the necessary posts and pages. So, the URL of a post will look like <a href="http://www.example.com/?p=130">http://www.example.com/?p=130</a>. This is not ideal, as its difficult to remember the post ID and search engines won't give a higher preference to such URLs. Therefore, we need a better URL structure that doesn't use query parameters and gives a SEO-friendly URL. So, we use the WordPress permalinks section to change the URL structure. Then, WordPress will internally convert those SEO-friendly URLs to the default URL structure. We can access the permalinks settings section from <span class="packt_screen">Settings</span> | <span class="packt_screen">Permalinks</span>. Let's choose <em>Post Name</em> as the URL structure for our site. Then, the preceding URL will be converted to <kbd>http:// www.example.com/sample-post/</kbd>.</p>
<p>As you can see, this is a much more user and SEO-friendly URL structure. Once the permalinks are set up, all the WordPress core features in the frontend will use this structure. However, in custom development, we may need custom URL structures to handle the functionality. In such cases, we can use Rewrite API to define our own routes and manage the functionality without interfering with default WordPress features.</p>
<p><strong>What is Rewrite API?</strong></p>
<p>WordPress Rewrite API is a set of functions that allows you to manage custom routes using tags, rules and endpoints. Let’s identify the functions used for implementing with Rewrite API:</p>
<ul>
<li class="mce-root"><kbd>add_rewrite_rule</kbd>: This function is used to register new rewrite rules to WordPress for generating custom templates.</li>
<li class="mce-root"><kbd>add_rewrite_tag</kbd>: This function is used for registering new query variables. We need to use it with <kbd>add_rewrite_rule</kbd> to create rewrite rules for custom templates.</li>
<li class="mce-root"><kbd>add_rewrite_endpoint</kbd>: This function is used to create extra rewrite rules for WordPress core components.</li>
<li class="mce-root"><kbd>flush_rewrite_rules</kbd>: This is used to remove rewrite rules and then recreate rewrite rules.</li>
</ul>
<p>In this section, we are going to create and manage custom rules using these functions except <kbd>add_rewrite_endpoint</kbd>. You can view more details about rewrite endpoints at <a href="https://codex.wordpress.org/Rewrite_API/add_rewrite_endpoint">https://codex.wordpress.org/Rewrite_API/add_rewrite_endpoint</a>.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Understanding the need for custom routes</h1>
                </header>
            
            <article>
                
<p>The use of custom routes becomes vital in developing plugins that goes beyond the default WordPress features. We are going to consider two scenarios to understand the need for custom rewriting:</p>
<ul>
<li>Assume we have a shortcode that is used to display user profile details and we use it inside a WordPress page called <strong>Profile</strong>. So, the URL of the page will be <a href="http://www.example.com/profile">http://www.example.com/profile</a>. Now, we need to use the same page to display user details of each user. Currently, it’s not possible, since we don’t have a way to identify the user when accessing this page. So, we need to modify the URL in a way that we can identify each user. Let’s assume we have a URL like <a href="http://www.example.com/profile/john123">http://www.example.com/profile/john123</a> with the username after the page. Then, we can use the username component to identify the user and display the profile details. In this scenario, we have to use Rewrite API functions to match the URL with necessary query parameters and execute our functionality.</li>
</ul>
<ul>
<li>As we already discussed, adding shortcodes to such an important functionality can become an issue when the administrator deletes or removes the shortcodes by mistake. So, relying on posts or pages to handle such functionality can be considered as a risk. In such cases, we can avoid risk by using custom URLs that don't use posts or pages. Assume we want to display a login form at <a href="http://www.example.com/user/login">http://www.example.com/user/login</a> and registration at <a href="http://www.example.com/user/register">http://www.example.com/user/register</a>. By default, these URLs will redirect to the <em>404 Not Found Page</em> when you don't have a post or page called <em>user</em>. So, we need to use Rewrite API to register custom routes and manage these URLs to offer custom features without interfering with core WordPress features.</li>
</ul>
<p>In this section, we are going to implement the second scenario, as handling custom URLs without posts or pages is the ideal solution for custom features.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Creating the routing rules</h1>
                </header>
            
            <article>
                
<p>We can use <kbd>add_rewrite_rule</kbd> function to register new custom routes with WordPress. This function can be implemented within many actions in WordPress. However, we usually use <kbd>init</kbd> action to handle the rewrite rules. Let's add a custom rewrite rule to handle the scenario of user login and registration:</p>
<pre>add_action('init','wqraf_manage_user_routes');<br/>function wqraf_manage_user_routes() {<br/>  add_rewrite_rule( '^user/([^/]+)/?', 'index.php?wpquick_action=$matches[1]', 'top' );<br/>}</pre>
<p>You can find the code for this section inside the <kbd>wpquick-rewrite-api</kbd> plugin in the source codes directory. The <kbd>add_rewrite_rule</kbd> function accepts two required and one optional parameters. Let’s take a look at the parameters and their role:</p>
<ul>
<li><kbd>regex</kbd>: This is the first parameter that matches the URL to the rule using a regular expression.</li>
<li><kbd>redirect</kbd>: This is the second parameter that specifies the URL to request when current URL is matching the regular expression. As you can see, we pass the request to <kbd>index.php</kbd> with custom parameters that uniquely identify our functionality.</li>
<li><kbd>after</kbd>: This optional parameter decides when to use this rewrite rule. If a <kbd>top</kbd> value is used, the rewrite rule will take precedence over other default WordPress rewrite rules. If a <kbd>bottom</kbd> value is used, preference will be given to existing rules.</li>
</ul>
<p class="mce-root"/>
<p class="mce-root"/>
<p>Now, you might think we can access <kbd>wpquick_action</kbd> using <kbd>$_GET</kbd> query parameters and implement the functionality for both login and registration. However, you won’t get <kbd>wpquick_action</kbd> as a <kbd>$_GET</kbd> parameter. WordPress doesn't allow you to use any type of variable in the query string. It will check for query variables within the existing list, and all other variables will be ignored. So, we have to specify the custom query variables before we can actually use them in code.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Adding query variables</h1>
                </header>
            
            <article>
                
<p>WordPress has over 40 params registered to be used in queries. Let's check the existing query variables before adding custom query variables. Add the following code to main file of <kbd>wpquick-rewrite-api</kbd> plugin and open the home page of your site:</p>
<pre>add_filter( 'query_vars', 'wqraf_manage_user_query_vars' );<br/>function wqraf_manage_user_query_vars( $query_vars ) {<br/>  echo "&lt;pre&gt;";print_r($query_vars);exit;<br/>}</pre>
<p>You will see all the existing query parameters as an array. Now we need to create our own query parameters to handle user login and registration. So, we add the following code to the <kbd>wpquick-rewrite-api</kbd> plugin:</p>
<pre>add_filter( 'query_vars', 'wqraf_manage_user_query_vars' );<br/>function wqraf_manage_user_query_vars( $query_vars ) {<br/>  $query_vars[] = 'wpquick_action';<br/>  return $query_vars;<br/>}</pre>
<p>The <kbd>query_vars</kbd> is a built-in filter that allows us to add or remove query variables before the request is processed. In this scenario, we add a new query parameter called <kbd>wpquick_action</kbd> to the existing query parameters array.</p>
<div class="packt_tip">WordPress core and other plugins registers considerable number of query variables. So, it's better to use a unique name with a prefix to avoid conflicts with query parameters in other plugins.</div>
<p>Now we have the ability to access <kbd>wpquick_action</kbd> variable from the URL. In this scenario, I used the <kbd>query_vars</kbd> filter to add new query variables and for the purpose of identifying built-in query variables. Rewrite API provides a function called <kbd>add_rewrite_tag</kbd> to implement the same functionality, and it’s the recommended way. So, we can remove the <kbd>query_vars</kbd> filter from our plugin and change the <kbd>wqraf_manage_user_routes</kbd> function as following to get the same functionality:</p>
<pre>function wqraf_manage_user_routes() {<br/>  add_rewrite_rule( '^user/([^/]+)/?', 'index.php?wpquick_actions=$matches[1]', 'top' );<br/>  add_rewrite_tag('%wpquick_actions%', '([^&amp;]+)');<br/>}</pre>
<p>The first parameter takes the <strong>action name</strong> surrounded by a <kbd>%</kbd> and the second parameter defines a <kbd>regex</kbd> to validate the value. Adding rewrite tags is relatively easy compared to using <kbd>query_vars</kbd> filter.</p>
<p>We modified the WordPress rewrite rules by adding a new rule. So, we have to flush the rewrite rules before the new rule takes effect. There are two ways to flush rewrite rules. First, we can visit <span class="packt_screen">Settings</span> | <span class="packt_screen">Permalinks</span> section to automatically refresh the rewrite rules. However, this is not ideal in development, as the user needs to manually go into the <strong>Settings</strong> section. So, we need a way to flush the rewrite rules automatically within our plugin, without needing an input from the user.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Flushing the rewriting rules</h1>
                </header>
            
            <article>
                
<p>We can easily flush the rewrite rules by calling WordPress <kbd>flush_rewrite_rules</kbd> function inside the <kbd>init</kbd> action. However, it will flush the rewrite rules on every request, generating unnecessary performance overhead. So, we need to use activation handler of the plugin to flush the rules. Let's see the following implementation inside the activation handler:</p>
<pre>register_activation_hook( __FILE__, 'wqraf_activate' );<br/>function wqraf_activate(){<br/>  flush_rewrite_rules(); <br/>}</pre>
<p>Now go to the admin panel, deactivate the plugin, and activate the plugin again. Then, go to the URL <a href="http://www.example.com/user/login">http://www.example.com/user/login</a> and check whether it works. Unfortunately, you will still get the 404 error for the request. You might be wondering what went wrong. Let's go back and think about the process to understand the issue. We flushed the rules on plugin activation. So, the new rules should persist successfully. However, we define the rules on the <kbd>init</kbd> action, which is only executed after the plugin is activated. Therefore, new rules will not be available at the time of flushing. So, we have to update the function as follows to get it working:</p>
<pre>register_activation_hook( __FILE__, 'wqraf_activate' );<br/>function wqraf_activate(){<br/>  wqraf_manage_user_routes();<br/>  flush_rewrite_rules(); <br/>}</pre>
<p>Now deactivate and activate the plugin again. Then, go to the URL <a href="http://www.example.com/user/login">http://www.example.com/user/login</a>. This time, you won't get the 404 errors, as the rewrite rule is added and flushed properly. Now we are ready with our routing rules for user functionalities.</p>
<p class="mce-root"/>
<p class="mceNonEditable"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Displaying content for custom routes</h1>
                </header>
            
            <article>
                
<p>We have to build a custom route to manage the login and registration of the site. Now we need to access the custom query variable from the custom route and generate the screens for login and registration. Consider the following code for the implementation of login and registration forms:</p>
<pre>add_action( 'template_redirect', 'wqraf_front_controller' );<br/>function wqraf_front_controller() {<br/>  global $wp_query;<br/>  $wpquick_action = isset ( $wp_query-&gt;query_vars['wpquick_action'] ) ? $wp_query-&gt;query_vars['wpquick_action'] : '';<br/>  switch ( $wpquick_action ) {<br/>    case 'register':<br/>      echo "&lt;h1&gt;REgistration Form&lt;/h1&gt;";exit;<br/>      break;<br/>    case 'login':<br/>      echo "&lt;h1&gt;Login Form&lt;/h1&gt;";exit;<br/>      break;<br/>  }<br/>}</pre>
<p>WordPress executes the <kbd>template_redirect</kbd> action just before deciding which template to load. So, we can use this action to intercept the request and load our own template. First, we access the <kbd>wpquick_action</kbd> value using the <kbd>$wp_query</kbd> global object. This variable will contain either register or login in this scenario. Then, we use a <kbd>switch</kbd> statement to filter the action and load the necessary template. Here, we are only printing a title for explanations. You have to generate the login or registration forms instead of the title.</p>
<div class="packt_tip">Since we are intercepting the request, our content will be loaded instead of the WordPress template. Here, it will only print the title without the header, footer, or other parts of the WordPress template. So, you have to generate a complete template by including header, footer, content area, and sidebars.</div>
<p>We have looked at the process of using Rewrite API functions to create custom routes and load custom templates for your plugins. This will become handy when developing advanced plugins with non-WordPress specific screens.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Building remote connections with REST API</h1>
                </header>
            
            <article>
                
<p>WordPress REST API is gaining popularity over the old XML-RPC API and becoming a standard in site development. The API allows developers to connect WordPress sites with other sites as well as third-party applications. Modern sites are moving towards JS Framework-based frontends to optimize performance as well as to simplify the user experience. In such scenarios, developers can use WordPress as the backend for the core functionality and expose the data through the REST API to build frontends without using WordPress. The REST API could well be the future of development with WordPress.</p>
<p>The REST API was initially introduced in a external plugin for testing. Finally, it was included in WordPress core in WordPress 4.7, and now it fully supports REST API endpoints for all the major data models in WordPress.</p>
<p>Let's identify some of the common terms used in REST API operations:</p>
<ul>
<li><strong>Route</strong>: This is a well-defined URL that can be mapped to an HTTP method</li>
<li><strong>Endpoint</strong>: The process of matching a specific route to a HTTP method</li>
<li><strong>Request</strong>: The call to an API endpoint with the necessary data</li>
<li><strong>Response</strong>: The data provided by an API to a specific request</li>
<li><strong>Schema</strong>: This is used to structure API data and provide info on the available properties and input parameters for API requests</li>
</ul>
<p class="mce-root"/>
<p class="mce-root"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Introducing core REST API endpoints</h1>
                </header>
            
            <article>
                
<p>WordPress provides built-in API endpoints for working with most of the main core features. The documentation defines the endpoints, attributes, and example requests, simplifying the learning curve for developers. In this section, we are going to look at the core REST API endpoints and the use of test requests to understand the process. You can check all the available endpoints and additional information in WordPress REST API documentation at <a href="https://developer.wordpress.org/rest-api/reference/">https://developer.wordpress.org/rest-api/reference/</a>. The WordPress REST API is enabled by default. You can check whether an API is enabled on your site by accessing <a href="http://www.example.com/wp-json">http://www.example.com/wp-json</a> in the browser. If the API is enabled, you will get a large JSON string with the available settings and endpoints.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Understanding and testing Core API endpoints</h1>
                </header>
            
            <article>
                
<p>We have to identify and understand the use of API endpoints, arguments, and return data formats to build features with API functions. Testing API requests is the best way to understand the process. We can use an existing tool to simplify the API request testing process. There are many such tools and we are going to use the Postman extension of Google Chrome browser.</p>
<p><strong>Postman</strong> is a tool that simplifies the process of managing APIs by offering features such as testing API requests, building API documentation, and monitoring API usage. This tool also provides many additional API-related features in both free and PRO versions. The free extension is more than enough to work with basic API testing for your projects. You can use the PRO version for advanced features such as team colloboration, creating mock servers and integrations with many third-party APIs.</p>
<p>You can install the extension in your chrome browser from <a href="https://www.getpostman.com/">https://www.getpostman.com/</a>. Once installed, you will get a standalone app, as shown in the following screenshot:</p>
<div class="packt_figref CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-329 image-border" src="assets/8e87c0d8-6c90-4076-b11a-6423bed1fbb7.png" style="width:79.58em;height:40.83em;"/></div>
<p>Now we are ready to test API requests with WordPress REST API. Mainly, we use HTTP <kbd>GET</kbd> and <kbd>POST</kbd> requests in development tasks. However, this tool provides the ability to use various HTTP request types, such as <kbd>PUT</kbd> and <kbd>DELETE</kbd>. The REST API contains endpoints that allows us to directly use GET requests as well as <kbd>POST</kbd> requests which requires authentication. So, we are going to check both types of requests.</p>
<p>Let’s start by testing a GET request. Basically, these endpoints exposes the existing data in WordPress. First, you have to enter the URL of the endpoint in <span class="packt_screen">Enter request URL</span> field and select the HTTP request as <kbd>GET</kbd>. The endpoint needs to be added after the  <a href="http://www.example.com/wp-json/">http://www.example.com/wp-json/</a> section in the URL. So, the request for accessing the list of posts via REST API looks similar to the parameters shown in the following screenshot:</p>
<div class="packt_figref CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-330 image-border" src="assets/f12f53cc-9f6a-4a6c-92c1-1b3b54d3f9d7.png" style="width:77.67em;height:43.83em;"/></div>
<p>The screen on the bottom displays the result of the request in the format we choose. We have to choose JSON as the result type, since successful API requests returns JSON data. Since we are using GET requests, the <span class="packt_screen">Type</span> was also set as <span class="packt_screen">No Auth</span>.</p>
<p>Now we can move forward to testing POST requests for retrieving data for display as well as modifying the database through API requests. Testing POST requests require more work compared to using GET requests. These requests always require some authentication and return an error when valid authentication is not available. So, first. you have to add the URL in <strong><span class="packt_screen">Enter request URL</span></strong> and select the method as <kbd>POST</kbd>. Next, go to <strong><span class="packt_screen">Authorization</span></strong> tab and select <span class="packt_screen">Basic Auth</span> as the type. Then add the <span class="packt_screen">Username</span> and <span class="packt_screen">Password</span> of a user in your site with post creation and edit capabilities.</p>
<p class="mce-root"/>
<p>Generally, POST requests need additional parameters and values. Here, we are trying to create a post, and hence you can add the post details as key-value pairs in the <span class="packt_screen">form-data</span> section of <span class="packt_screen">Body</span> tab. Finally, click on the <strong><span class="packt_screen">Send</span></strong> button to send the API request. However, you will get the following error message instead of creating the post:</p>
<pre>{ "code": "rest_cannot_create", "message": "Sorry, you are not allowed to create posts as this user.", "data": { "status": 401 } }</pre>
<p>You might be confused why it's returning a permission error even when we have provided basic authentication details. WordPress considers Basic Auth as an unsafe way of handling REST API requests, and, hence, <strong>Basic Auth</strong> is disabled by default. So, we have to use a plugin called <strong>JSON Basic Authentication</strong> by the WordPress API Team. This plugin is included in the source code folder for this chapter. Once this plugin is activated, you can send the request again and will see the response and form parameters, as shown in the following screenshot:</p>
<div class="packt_figref CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-331 image-border" src="assets/7954b0a4-50e6-41e2-a2d3-c0d9d688f641.png" style="width:75.25em;height:46.50em;"/></div>
<p class="mce-root"/>
<p class="mce-root"/>
<p>The response will contain the details about the newly created post from our request. You can use <kbd>UPDATE</kbd> and <kbd>DELETE</kbd> operations similarly by changing the request type and providing necessary parameter values.</p>
<div class="packt_infobox">Basic Auth is not a recommended way of authenticating the REST API, since we have to transfer username and password details in each request in plain text format. So, the WordPress team suggests that we should only use Basic Auth for testing purposes or in highly secured private networks only.</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Managing custom routes and endpoints</h1>
                </header>
            
            <article>
                
<p>The real power of REST API comes with the usage of custom routes and endpoints. There are certain limitations in adjusting existing routes and endpoints to our requirements. In some scenarios, we may have to create our own classes and extend the WordPress core classes to achieve custom functionality. So, custom routes and endpoints allow us to implement custom REST API features with minimum work, without interfering with WordPress core REST API features.</p>
<p>In this section, we are going to implement the following features to learn the basics of custom REST API routes and endpoints:</p>
<ol>
<li>Disable the default post endpoint and use custom routes to expose posts only in selected categories with selected post data</li>
<li>Provide REST API access to custom table data by listing available attachments in a post</li>
</ol>
<p>Let's start the implementation of these two features.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Creating custom routes for posts</h1>
                </header>
            
            <article>
                
<p>The default post related endpoint is accessible through <kbd>/wp/v2/posts</kbd>. We can execute a <kbd>GET</kbd> request on this endpoint without any parameters to retrieve the list of posts with all the main post details. Let's assume we want to use custom routes for each functionality in this endpoint to have more control over the post-related API requests. So, we have to block the existing endpoint before defining our own routes.</p>
<p>We are going to use a new plugin called <strong>WQ REST API</strong> to implement the features required for the REST API section of this chapter. You can use the plugin creation technique discussed in previous chapters to create the plugin with a main file. Let's block the default post endpoint by using the following code inside the main file of the plugin:</p>
<pre>add_filter( 'rest_endpoints', 'wpquick_rest_endpoints');<br/>function wpquick_rest_endpoints( $endpoints ){<br/>    if ( isset( $endpoints['/wp/v2/posts'] ) ) {<br/>        unset( $endpoints['/wp/v2/posts'] );<br/>    }<br/>    return $endpoints;<br/>}        </pre>
<p>WordPress provides a filter called <kbd>rest_endpoints</kbd> to filter the existing endpoints and customize them by either removing or creating new ones. In this scenario, we have disabled the default post related endpoint by unsetting it from the endpoints array. This will remove the ability to list, create, update, and delete posts. So, we have to define custom routes for each of those features or use the same custom route to support all the post-related operations. Let's start by adding a custom route to provide post data to third-party sources:</p>
<pre>function wqra_routes() {<br/>  register_rest_route( 'wqra/v1', '/read_posts', <br/>        array( 'methods'  =&gt; WP_REST_Server::READABLE, <br/>                'callback' =&gt; 'wqra_read_posts_handler',                                       'permission_callback' =&gt; function () {<br/>                         return true;<br/>               }<br/>    ) );<br/>}<br/>add_action( 'rest_api_init', 'wqra_routes' );</pre>
<p>The REST API includes an action called <kbd>rest_api_init</kbd>, which gets fired before executing an API request. Therefore, it’s the recommended action to introduce new routes to the API. Inside the callback function, we use the <kbd>register_rest_route</kbd> function to create new routes for our application. Let's identify the basic parameters used in <kbd>register_rest_route</kbd> function:</p>
<ul>
<li><kbd>namespace</kbd>: This will be the first URL segment after the main REST API URL. Here, we have used <kbd>wqra/v1</kbd>, and, hence, it will replace the <kbd>wp/v2</kbd> we used for accessing core WordPress routes.</li>
<li><kbd>route</kbd>: This is the base URL for the route. Here, we have used <kbd>read_posts</kbd> as the route, and it will replace the default route of posts.</li>
</ul>
<p class="mce-root"/>
<ul>
<li><kbd>methods</kbd>: Here, we have used the method as <kbd>WP_REST_Server::READABLE</kbd>. It makes sure that our custom route works when <kbd>WP_REST_Server</kbd> changes our readable endpoints. The <em>readable</em> constant of <kbd>WP_REST_Server</kbd> class is an alias of the <kbd>GET</kbd> method.</li>
<li><kbd>callback</kbd>: This is the function that gets executed when a route is matched to a given endpoint. We have defined a callback function called <kbd>wqra_read_posts_handler</kbd>. All the post data that should be sent in the REST API response is prepared within this function.</li>
<li><kbd>permission_callback</kbd>: This is the function used to check the permission of the request before executing the callback function. We have returned TRUE to provide permission. In real scenarios, we need to check user permissions using <kbd>current_user_can</kbd> function and return the Boolean value based on the user permission levels.</li>
</ul>
<p>Now we can look into the implementation of our callback function for generating the posts list specific for the web site. Consider the following implementation of the <kbd>wqra_read_posts_handler</kbd> function:</p>
<pre>function wqra_read_posts_handler() {<br/>  $posts_query = new WP_Query(array('post_type' =&gt; 'post','post_status' =&gt;'publish', 'order' =&gt; 'desc', 'orderby' =&gt; 'date', 'category__not_in' =&gt; array( 20 ),'posts_per_page'=&gt;-1 ));<br/>  $data = array();<br/>  if($posts_query-&gt;have_posts()){<br/>    while($posts_query-&gt;have_posts()) : $posts_query-&gt;the_post();<br/>      array_push($data, array("ID" =&gt; get_the_ID(), "title" =&gt; get_the_title() ));<br/>    endwhile;<br/>  }<br/><br/>  return rest_ensure_response(($data));<br/>}</pre>
<p>First, we use <kbd>WP_Query</kbd> object to pass custom settings and generate the list of posts based on our requirements. In this case, we are only allowing API users to view posts, except the ones from chosen categories. Then, we only add the post ID and title of the post, as we only want to provide these two pieces of data for API users. The default posts list gives access to all the main data of a post, and hence it’s not suitable for our requirements. Finally, we pass the resulted data array to the <kbd>rest_ensure_response</kbd> function. This function converts our data to JSON and returns the response compatible with <kbd>WP_REST_Response</kbd>.</p>
<p class="mce-root"/>
<p class="mce-root"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Creating custom routes and endpoints for custom table data</h1>
                </header>
            
            <article>
                
<p>In the previous section, we looked at the process of disabling existing API endpoints and creating our own endpoints to handle core WordPress data. The default WordPress REST APIs don't have any routes or endpoints for working with custom table data. So, we have to always use our own custom routes and endpoints for manipulating custom table data.</p>
<p>In the previous chapters, we created a plugin to add attachments to posts. Now we are going to create a custom API endpoint that allows us to retrieve the attachments of a given post. Let's start by adding another custom route to our REST API plugin, as shown in the following code:</p>
<pre>function wqra_routes() {<br/>  // Custom route for read posts<br/>  register_rest_route( 'wqra/v1', '/list_post_attachments/(?P&lt;id&gt;\d+)', array(<br/>     'methods' =&gt; 'POST','callback' =&gt; 'wqra_list_post_attachments_handler',<br/>     'args' =&gt; array( 'id' =&gt; array( 'validate_callback' =&gt; function($param, $request, $key) {<br/>                 return is_numeric($param);<br/>     }<br/>     ) ) ) );<br/>}</pre>
<p>We use the same namespace as on the last occasion and use <kbd>list_post_attachments</kbd> as the new route. Also, we have an additional parameter in brackets, where we can pass the ID of the post. We have also set the method to <kbd>POST</kbd> instead of using <kbd>GET</kbd>. Since we are retrieving records and passing the ID in <span class="packt_screen">URL</span>, we could have used <kbd>GET</kbd> as the method. However, we have enabled <kbd>POST</kbd> method so that we can pass additional parameters and filter the results. We have used a new callback function, <kbd>wqra_list_post_attachments_handler</kbd>, to handle the new custom route.</p>
<p>In this scenario, there is an additional parameter called <kbd>args</kbd> compared to the previous custom route. This <kbd>args</kbd> array is used to specify additional parameters for the route. In this case, we use it to validate the parameters passed to the endpoint. The post ID is a numeric value, and hence we need to validate it before executing the REST API request. So, we execute the <kbd>validate_callback</kbd> function of the ID parameter. If you pass string value for the post ID, you will get the following invalid parameter error:</p>
<pre>{"code":"rest_invalid_param","message":"Invalid parameter(s):id","data":{"status":400,"params":{"id":"Invalid parameter."}}}</pre>
<p class="mce-root"/>
<p>We can use this technique to validate multiple parameters with different conditions and make sure requests only contain the data in requested formats. Now we can move into the implementation of the <kbd>wqra_list_post_attachments_handler</kbd> function for handling the request to the new route:</p>
<pre>function wqra_list_post_attachments_handler($data){<br/>  global $wpdb;<br/>  $data = $data-&gt;get_params();      <br/>  $post_id = isset($data['id']) ? $data['id'] : 0;<br/>  $post_attachments_table = $wpdb-&gt;prefix.'wpqpa_post_attachments';<br/>  $sql  = $wpdb-&gt;prepare( "SELECT * from $post_attachments_table where post_id = %d ", $post_id);<br/>  $result = $wpdb-&gt;get_results($sql);<br/>  $post_attachments = array();<br/> if($result){<br/>   foreach ($result as $key =&gt; $value) {<br/>     $post_attachments[] = array('ID'=&gt; $value-&gt;id, 'file_name' =&gt; $value-&gt;file_name, 'file_path' =&gt; $value-&gt;file_path);<br/>   }<br/>  }<br/><br/>  return rest_ensure_response(($post_attachments));<br/>}</pre>
<p>The REST API request object is passed to this function as a parameter. So, we use the <kbd>get_params</kbd> function of the <kbd>$data</kbd> object to retrieve the available parameters in the request. Next, we capture the post ID using the <kbd>id</kbd> attribute of the <kbd>$data</kbd> object. Next, we execute a custom query on the <kbd>wpqpa_post_attachments</kbd> table. The result will contain the file attachments for the given post. Then, we traverse through the results and assign the attachment details in to an array. Finally, we use the <kbd>rest_ensure_response</kbd> function to pass the attachment data in JSON format to the response.</p>
<div class="packt_infobox">There are also some disadvantages in using custom routes and endpoints, in situations where we have the ability to use existing routes and endpoints. We need to implement our own pagination and sorting for custom endpoints while WordPress provides them by default for existing endpoints. We can use user permission checks by default in WordPress core endpoints while we need to pass additional nonce parameters to check user permissions.</div>
<p>Now we can call this new route and retrieve the file attachments list for a given post.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Building the REST API client</h1>
                </header>
            
            <article>
                
<p>The API client is the user or service that uses the data provided by the REST API. <span>We use the client to access the REST API of another site. The client site could be WordPress or a non-WordPress site. The client can also be implemented in a different programming language without using PHP.</span> Let's identify the usage of API clients. In this chapter, we going to look at the process of building REST API client to access our data from external sites, as it's the most important use of an API.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">REST API client from external site</h1>
                </header>
            
            <article>
                
<p>This is where the REST API is used to its maximum potential, even though we use it to build functionality of the same site. The main intention of creating a REST API is to provide access to third-party WordPress and non-WordPress based applications. So, the API client can be implemented in any programming language. In this section, we will be building a PHP based API client for accessing REST APIs of other applications with the support of CURL.</p>
<p>Let's add the API client implementation with CURL. You should place this code in a PHP file and access it from a source external to your application:</p>
<pre>function wpquick_rest_api_client( $url, $post_data = '' ){<br/>  $api_route = $url;<br/>  $ch = curl_init( $api_route );<br/>  $headers = array(<br/>    'Authorization:Basic YWRtaW46dTh1OHU4dTg='// &lt;---<br/>    );<br/>  curl_setopt( $ch, CURLOPT_HTTPHEADER, $headers );<br/>  curl_setopt( $ch, CURLOPT_SSL_VERIFYHOST, false );<br/>  curl_setopt( $ch, CURLOPT_RETURNTRANSFER, 1 );<br/>  curl_setopt( $ch, CURLOPT_POST, true );<br/>  curl_setopt( $ch, CURLOPT_SSL_VERIFYPEER, false );<br/>  if( $post_data != '' ){<br/>    curl_setopt( $ch, CURLOPT_POSTFIELDS, $post_data );<br/>  }<br/>  curl_setopt( $ch, CURLOPT_VERBOSE, 1 );<br/>  $return = curl_exec( $ch );<br/>  echo "&lt;pre&gt;";<br/>  print_r( $return );<br/>  exit;<br/>}<br/><br/>$post_data = array();<br/>$post_data = json_encode( $post_data );<br/>$api_route ="http://www.example.com/wp-json/wqra/v1/list_post_attachments/5";<br/>wpquick_rest_api_client( $api_route, $post_data );</pre>
<p>We create a function called <kbd>wpquick_rest_api_client</kbd> to accept two parameters for the API endpoint: URL and the post data. Then, we initialize a <kbd>curl</kbd> request by executing <kbd>curl_init</kbd> function on the specified route. Next, we add the authorization header with a base-64 encoded string containing the combination of <kbd>username:password</kbd>. We need some sort of authenticate method to execute POST and DELETE requests. We should only use an authorization header for testing purposes. We will be discussing various authentication techniques in the next section. Then, we will specify the necessary <kbd>curl</kbd> parameters and add the post data to the request, if it's provided. Finally, we execute and print the API response returned from the server.</p>
<p>Now we have a basic API client function, and we can call the function with necessary parameters to execute REST API requests, as shown in the preceding code. In this case, we are retrieving the file attachments of the forum with the ID 5 as a JSON string. If we request the ID as a string, we will get an invalid parameter error, since it's validated and restricted in our route. So, we have identified the process of building an API client to access the site from external sources.</p>
<p>REST API is becoming the trend in modern web applications, and hence WordPress seems to provide more and more features to build fully functional REST APIs for applications. So, in the future, we will see the emergence of REST as a must-use WordPress feature.</p>
<p class="mce-root"/>
<p class="mce-root"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Summary</h1>
                </header>
            
            <article>
                
<p>WordPress APIs are built for simplifying and standardizing the use of WordPress's core features. We can use these API functions to build future-proof solutions without spending unnecessary time on development.</p>
<p>In this chapter, we looked at the importance of using WordPress APIs and had a brief introduction to the functionality of each API. We choose three API's that play a major role in development, and we discussed them in detail. We started by understanding the structure and usage of a shortcode. Then, we discussed various techniques and locations for using shortcodes. Next, we moved into Rewrite API, which manages custom routes for custom features that go beyond WordPress's core features. Finally, we looked at the REST API for developing API functions and exposing application data to third-party services.</p>
<p>In <a href="1a709b5f-c476-41f9-bc13-eb5f0541abaa.xhtml" target="_blank">Chapter 7</a>, <em>Managing Custom Post Types and Processing Forms,</em> we will be exploring two of the most important aspects in WordPress development by teaching the user of custom post types to build various features and use custom forms to capture and display advanced data.</p>


            </article>

            
        </section>
    </body></html>