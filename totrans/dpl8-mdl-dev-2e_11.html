<html><head></head><body>
        <section>

                            <header>
                    <h1 class="header-title">Caching</h1>
                </header>
            
            <article>
                
<p>Application performance has always been one of the pain points when developing with Drupal, and there are many reasons for this. For example, PHP is not the fastest language out there. Many beginner Drupal developers fall prey to the multitude of modules available and go a bit overboard with enabling more than needed. And indeed, the Drupal architecture is simply not the most performant. In its defense though, a very complex architecture that does a lot out of the box will have some speed trade-offs.</p>
<p>One critical component in this game, however, is caching. For those of you not familiar with this term, caching is the application strategy of storing copies of processed code (or anything that results from it) in view of delivering it to the user more quickly when requested subsequent times. For example, when you go to a website, your browser <span><span>will most likely cache</span></span> (store) certain assets locally on your computer so that when you visit the site the next time, it can show them to you faster.</p>
<p>Although caching has been steadily improving with recent versions of Drupal, it has been still lacking significantly. Particularly when it comes to serving registered users. Drupal 8, however, is a completely different ball game. The system has been totally revamped and brought into all aspects of the Drupal architecture. Unfortunately, though, this has put yet another big new thing on the plate of things Drupal 7 developers need to learn. Because it's a complex system, we simply cannot (and should not) get around it. But you're in luck, because in this chapter we will break it all down and see what we're dealing with. So when you are doing module development in Drupal 8, your code will be more performant, your site will run faster, and ultimately your users will be happier.</p>
<p>So, what exactly are we going to talk about in this chapter?</p>
<p>First, we are going to cover some introductory notions about the caching system in Drupal 8 and look at the main types of caching available. Here, we will also see how, during development, we can disable caching to increase our productivity.</p>
<p>Next, we are going to talk about cacheability metadata. This is one of the most important things you'll need to know as a Drupal 8 module developer when it comes to caching. It has to do with declaring render arrays (and other objects) in a way in which Drupal can cache them properly (and invalidate caches accordingly). We will talk about things such as cache tags, contexts, and max-age, but also see how to apply them to render arrays, block plugins, and access results.</p>
<p>After that, we will look at how we can tackle highly dynamic components (render arrays) that cannot or should not be cached. Drupal 8 has a powerful <em>auto-placeholdering</em> system that uses lazy builders to postpone rendering until a later stage, which can greatly improve both cacheability and perceived performance.</p>
<p>Lastly, we are going to look at how we can interact with the Cache API ourselves in order to create, read, and invalidate our own cache entries. Sometimes we need to perform expensive calculations or show external data on our site, which can benefit from being cached.</p>
<p>So let's get to it.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Introduction to Caching</h1>
                </header>
            
            <article>
                
<p>The first thing I would like to mention before getting into the meat of the Cache API is that this subsystem is one of the best documented ones (at the time of writing). You can check out the main entry page (<span class="URLPACKT"><a href="https://www.drupal.org/docs/8/api/cache-api/cache-api">https://www.drupal.org/docs/8/api/cache-api/cache-api</a></span>) and I recommend keeping it close by when developing.</p>
<p>The Cache system in Drupal 8 provides the API needed to handle the creation, storage, and invalidation of cached data. From a storage perspective, it is extensible, allowing us to write our own custom cache <em>backends</em> (<kbd>CacheBackendInterface</kbd>). By default, however, cache data gets stored in the database and hence the default backend is <kbd>DatabaseBackend</kbd>. Going forward, we will focus only on this implementation since it is the most commonly used one, especially when starting a new project. Quite often though, once the site becomes more complex, alternative caching backends can be employed for better performance—such as Memecache or Redis.</p>
<p>The simplest type of cache in Drupal 8 is the so-called <em>Internal Page Cache</em>, whose functionality resides inside the Page Cache core module. The goal of this cache layer is to serve anonymous users with responses that are cached in their entirety. The primary assumption is that certain pages can be cached once and served to all anonymous users just the same—an approach similar to what we had in Drupal 7. Unlike the previous version though, this one is much smarter when it comes to (not) serving stale content as it makes use of the so-called <em>cache tags</em> to invalidate cached pages when something on those page changes. We will talk about cache tags in more detail soon.</p>
<p>This module is enabled by default when installing Drupal 8 and can be configured more or less the same as in Drupal 7 by going to <kbd>admin/config/development/performance</kbd>:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/f5263a7f-086a-42f7-a2ac-35fe9f36c520.png"/></p>
<p>Although serving anonymous users in not-so-complex websites was not that bad in Drupal 7, when it came to authenticated users it was quite the opposite. The contributed Authcache module was the best solution for dynamic and granular caching, but it was extremely difficult to use and implement. Some of its core tenets, however, have been used in the development of the <kbd>Dynamic Page Cache</kbd> module in Drupal 8, which makes things much simpler (and robust).</p>
<p>This core module also comes enabled by default and provides all the necessaries for caching pages for all kinds of users. That is, pages that can depend on certain <em>cache contexts</em>. In a nutshell, the approach of this module is to cache together the bits of the page that can be served for all users and handle the dynamic content that depends on a context separately. It can do so because of the standardization of those bits into render arrays and other components that can provide <em>cacheability metadata</em>. The latter is collected and used to cache and invalidate the final result. We will talk about cache contexts and all this metadata in this chapter and get a better understanding of it.</p>
<p>Before continuing, I recommend you look back to the <em>Developer settings</em> section of <a href="5c4ab442-1596-40ca-b305-d72b6c47ed59.xhtml">Chapter 1</a>, <em>Developing for Drupal 8</em>, where I recommended <span><span>that you </span></span>use the developer settings when doing development. One of the reasons is caching, primarily the dynamic page cache, which you can disable inside the <kbd>settings.php</kbd> file:</p>
<pre>$settings['cache']['bins']['dynamic_page_cache'] = 'cache.backend.null';  </pre>
<p>It is difficult to do actual development with caching enabled, but at the same time, it's important to often enable it and make sure your code still runs correctly. It is very easy to forget about certain bits of code that depend on a context or should be invalidated upon an action, and sometimes you will only spot these if you test with caching enabled.</p>
<p>That being said, let's talk about cacheability metadata and how this works with render arrays.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Cacheability metadata</h1>
                </header>
            
            <article>
                
<p>Cacheability metadata is used to describe the <em>thing</em> that is rendered with respect to its <em>dynamism</em>. Most of the time, as Drupal 8 module developers, we will be using this metadata when working with render arrays. We will see a bit later where else these come into play, but for now, let's see what the actual properties are and what they are used for in the context of render arrays.</p>
<p>When creating render arrays, there are a few things we need to think about when it comes to caching. And we always need to think about these things.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Cache tags</h1>
                </header>
            
            <article>
                
<p>The first thing we need to think about is what our render array depends on. Are we rendering some entity data? Are we using some configuration values? Or anything that might be changed elsewhere impacting what we have to render? If the answer is yes, we need to use <em>cache tags</em>. If we don't use them, our render array gets cached as it is, and if the underlying data changes, we end up showing our users stale content or data.</p>
<p>To look at this another way, imagine a simple Article node. This content can be shown on its main detail page, in a listing of article teasers or even a listing of article titles (and many other places potentially). And since there is no way of knowing where it will be used, it is the responsibility of the render array that displays this content to mark this node entity as a dependency using cache tags. This way, when the node gets updated, all the render arrays that depend on it get invalidated as well.</p>
<p>Cache tags are simple strings and we can declare many cache tags for a single render array. They do have a special form in the following pattern: <kbd>thing:identifier</kbd>, or in some cases, just simply <kbd>thing</kbd> (if there is only one single element of that "thing"). For example, the cache tag for a given node would be in the format <kbd>node:1</kbd>, where the identifier is the actual node ID. Or for a configuration object it would be <kbd>config:hello_world.custom_salutation</kbd>.</p>
<p>I hinted before how, for example, some node content can be present in a list and therefore using the cache tags we can ensure that the render array for that node gets updated when the node does. Since render arrays are highly granular, this can present a small extra problem as the list itself can be a render array that may not even know which nodes it renders. Or even more so, it does not know when new nodes are created and should be included in it. To solve this issue, we have a special <em>list</em> cache tag we can use when rendering entities. For example, the <kbd>node_list</kbd> cache tag can be used for node entities, while the <kbd>product_list</kbd> cache tag can be used for product entities. These are automatically understood by the Drupal caching system, so all we have to do is use them appropriately.</p>
<p>To make life easier, however, all entities and configuration objects can be "interrogated" to provide their respective cache tags. For example:</p>
<pre>$tags = $node-&gt;getCacheTags();  </pre>
<p>Where <kbd>$tags</kbd> will be an array containing one tag—<kbd>node:[nid]</kbd>.</p>
<p>The same applies to configuration objects and this is handy because it prevents typos and errors. This is due to the generic <kbd>CacheableDependencyInterface</kbd> they implement which defines the methods for retrieving the cache metadata properties. In fact, any value that needs to be a cache dependency can and should implement this interface. As you'll find, there are a quite a few classes in Drupal core that do so.</p>
<div class="packt_infobox">You will also encounter <kbd>RefinableCacheableDependencyInterface</kbd> which is used in cases in which the cacheability of the underlying object can change at runtime. For example, an entity translation is added, which means that a new cache context needs to be added for that language.</div>
<p>We can also figure out the "list" cache tag specific to a given entity type. For example, instead of hardcoding the <kbd>product_list</kbd> tag, we can use the <kbd>getListCacheTags()</kbd> method on the <kbd>EntityTypeInterface</kbd>.</p>
<p>If your render array depends on something custom, you can use custom cache tags, but it will be your responsibility to also invalidate them when the underlying data is changed. We will see how this is done when we interact with the Cache API directly. It's always good to consistently use the <kbd>CacheableDependencyInterface</kbd> for any custom value objects.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Cache contexts</h1>
                </header>
            
            <article>
                
<p>Once we've thought about the dependencies of the render array, the second most important thing to consider is what it differs by. In other words, is there any reason why this render array should be shown one way sometimes but another way some other time?</p>
<p>Let's take a simple example of a render array that prints out the name of the current user. Nothing could be less complicated. Ignoring the cache tags for now, we immediately realize that we cannot show the same username to all users, right? So, the user <em>Danny</em> should see "Hi Danny" while user <em>John</em> should see "Hi John". We are talking about the same render array but one that differs by context. In other words, a variation of this render array needs to get cached separately for each encountered context. This is where we use the aforementioned <em>cache contexts</em>.</p>
<p>Similar to cache tags, cache contexts are simple strings, and a render array can be defined with more than just one. For example, the <kbd>user</kbd> context will cache a variation of a given render array for each user.</p>
<p>Moreover, they are hierarchical in nature in the sense that some contexts can include others. For example, let's continue with our previous example. Let's assume that users with the <kbd>editor</kbd> role should see the greeting message but the ones with the <kbd>contributor</kbd> role should see a different, more complicated one. In this case, the cache context would be on the roles the user has. But since it already depends on the actual user due to the need to show its username, it doesn't make sense to even bother with the roles context because the former encompasses the latter. Moreover, Drupal is smart enough to remove the superfluous one when combining the cache contexts from all the render arrays that make up a page. But if our render array differs, for example, only on the user roles and not necessarily the user itself, we should use the specific context—<kbd>user.roles</kbd>. As you may notice, the hierarchical nature is reflected in the dot (<kbd>.</kbd>) separation of the contexts.</p>
<p>There are a number of cache contexts already defined by Drupal core. Although you probably won't have to, at least in the beginning, you can define other contexts too. I recommend you check out the documentation page (<span class="URLPACKT"><a href="https://www.drupal.org/docs/8/api/cache-api/cache-contexts">https://www.drupal.org/docs/8/api/cache-api/cache-contexts</a></span>) for the available cache contexts that come out of the box.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Max-age</h1>
                </header>
            
            <article>
                
<p>The last main thing we need to think about when creating render arrays is how long they should be stored in the cache, barring any changes in the underlying data that might invalidate them. This is something that you will probably rarely set and by default it will be permanent. More often, however, you will set this cache property to 0 in order to denote that this render array should never be cached. This is when you are rendering something highly dynamic that doesn't make sense to be cached at all.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Using the cache metadata</h1>
                </header>
            
            <article>
                
<p>Now that we have looked at the three main cache properties, we need to consider creating render arrays, so let's revisit some of our previous work and apply this in practice as needed.</p>
<div class="packt_infobox">Quite often, you'll see the <kbd>CacheableMetadata</kbd> object being used and passed around in Drupal 8 core code. This is simply used to represent cache metadata and also provides some handy methods to apply that metadata to a render array, statically instantiate itself from one, or from a <kbd>CacheableDependencyInterface</kbd> object, as well as merge itself with another <kbd>CacheableMetadata</kbd> object.</div>
<p>The render array we will look at is inside the <kbd>HelloWorldSalutation::getSalutationComponent()</kbd> service and is used to render the salutation message. We are building it quite dynamically, but a simplified version looks like this (omitting some things):</p>
<pre>$render = [ 
  '#theme' =&gt; 'hello_world_salutation', 
  '#salutation' =&gt; [ 
    '#markup' =&gt; $salutation 
  ] 
];    </pre>
<p>Here, <kbd>$salutation</kbd> is either the message from the configuration object or the one generated based on the time of day.</p>
<p>Right off the bat, I will mention that this is one of those cases in which we cannot really cache the render array due to its highly dynamic nature. This is caused by the dependency on the time of day. Sure, we could set a maximum age of a few seconds or an hour, but is it even worth it? And we also run the risk of showing the wrong salutation.</p>
<p>So in this case, what we can do is add a maximum age of 0:</p>
<pre>$render = [ 
  '#theme' =&gt; 'hello_world_salutation', 
  '#salutation' =&gt; [ 
    '#markup' =&gt; $salutation 
  ], 
  '#cache' =&gt; [ 
    'max-age' =&gt; 0 
  ] 
];   </pre>
<p>The cache metadata goes under a <kbd>#cache</kbd> render array property as shown above.</p>
<p>Specifying the max-age basically tells Drupal not to ever cache this render array. Something important to know about this is that this declaration will bubble up to the top-level render array that makes the Controller response, preventing the entire thing from being cached. So, do not make the decision to prevent caching lightly. In our example, this is basically the entire Controller response and it is actually a very simple calculation, so we are good. Later in the chapter, we will talk about the ways this can be mitigated.</p>
<div class="packt_infobox">There is still a problem with us setting the <kbd>max-age</kbd> to 0 in this example. Although it will work with dynamic page caching (<kbd>max-age</kbd> will bubble up), the internal page cache serving anonymous users will not get this information. So, anonymous users will see the same thing every time. Possibly in future Drupal 8 releases, this will be fixed. We won't account for this issue yet because it's a great example of a bug that becomes apparent using automated tests, and we will see that in the final chapter of the book—as well as the solution, of course.</div>
<p>Let's, for a minute, assume that our salutation component is simply rendering the message stored in the configuration object and does not show time-specific content. If you remember:</p>
<pre>$config = $this-&gt;configFactory-&gt;get('hello_world.custom_salutation'); 
$salutation = $config-&gt;get('salutation');  </pre>
<p>In this case, we could cache the render array, but as we discussed earlier, we'd need to think about the dependencies as well as the potential variations it can have. It is already pretty obvious what the dependencies are—the configuration object. So, we would do the following:</p>
<pre>$render = [ 
  '#theme' =&gt; 'hello_world_salutation', 
  '#salutation' =&gt; [ 
    '#markup' =&gt; $salutation 
  ], 
  '#cache' =&gt; [ 
    'tags' =&gt; $config-&gt;getCacheTags() 
  ] 
];  </pre>
<p>Basically, we are requesting this particular configuration object's cache tags and setting those onto the render array. If we had more sets of cache tags to set from multiple objects, we would have to merge them. There is a tool we can use to ensure we do it right. For example:</p>
<pre>$tags = Cache::mergeTags($config_one-&gt;getCacheTags(), $config_two-&gt;getCacheTags());  </pre>
<p>This will merge two arrays of cache tags, pure and simple. The <kbd>Drupal\Core\Cache\Cache</kbd> class also has static helper methods for merging cache contexts and max-ages (among other things, I encourage you to check this out as you progress).</p>
<p>Thankfully, our render array is simple and does not vary, and hence we don't need cache contexts. If, however, we had appended the current username to the salutation, we would have had to add the <kbd>user</kbd> context to the render array as follows:</p>
<pre><span>'#cache' </span><span>=&gt; [<br/></span><span>  </span><span>'tags' </span><span>=&gt; </span><span>$config</span><span>-&gt;</span><span>getCacheTags</span><span>()</span><span>,<br/></span><span>  </span><span>'contexts' </span><span>=&gt; [</span><span>'user'</span><span>]<br/></span><span>]</span></pre>
<p>This would have cached the render array differently for each user who visits the page and would serve them accordingly at subsequent visits.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Caching in block plugins</h1>
                </header>
            
            <article>
                
<p>The render array we saw earlier was used as part of a Controller response. The latter is also known as the <em>main content</em> as it is the primary output of the page. On a normal Drupal installation, which uses the Block module, this is included inside the <kbd>Main page content</kbd> block. We also said that setting a max-age of 0 will bubble up to the top-level render array, causing the entire page to not be cached. This is true so far as the Controller response is concerned. Other blocks are still cached independently according to their own metadata.</p>
<p>In this book, you have already learned how we can create custom blocks, and we saw that they are also built using render arrays. Since this is the case, cache metadata can also be applied to those arrays for caching them properly. However, since we are extending from the <kbd>BlockBase</kbd> class when creating block plugins, we are essentially implementing the <kbd>CacheableDependencyInterface</kbd> because <kbd>BlockPluginInterface</kbd> extends it.</p>
<p>So instead of setting the metadata on the render array, we should, whenever possible, use the methods on that interface by overriding the default parent implementations. For example:</p>
<pre>/** 
* {@inheritdoc} 
*/ 
public function getCacheContexts() { 
  return Cache::mergeContexts(parent::getCacheContexts(), ['user']); 
}  </pre>
<p>We should always merge our own values with the ones from the parent.</p>
<p>In some cases, though, especially when declaring cache tags, it makes more sense to set them inside the render array of the <kbd>build()</kbd> method. That is because you may have already done some work to get your hands on the dependent objects, and it doesn't make sense to repeat that inside another method. That is totally fine.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Caching access results</h1>
                </header>
            
            <article>
                
<p>Another important place where cache metadata needs to be considered is on <kbd>AccessResultInterface</kbd> objects. If you remember from the previous chapter, objects implementing this interface are used consistently to represent access to a certain resource. On top of that, they can also contain cacheability metadata. This is because access may depend on certain data that can change with an impact on the access result itself. Since Drupal tries to cache access as well, we need to inform it of these dependencies.</p>
<p>A good example to see this in action is our <kbd>HelloWorldAccess</kbd> service where we dynamically check access to our <kbd>hello_world.hello</kbd> route. So instead of simply returning the <kbd>AccessResultInterface</kbd>, we add cacheable dependencies to it before doing so. The rewritten <kbd>access()</kbd> method can now look like this:</p>
<pre>$config = $this-&gt;configFactory-&gt;get('hello_world.custom_salutation'); 
$salutation = $config-&gt;get('salutation'); 
$access = in_array('editor', $account-&gt;getRoles()) &amp;&amp; $salutation != "" ? AccessResult::forbidden() : AccessResult::allowed(); 
$access-&gt;addCacheableDependency($config); 
$access-&gt;addCacheableDependency($account); 
return $access;  </pre>
<p>The <kbd>addCacheableDependency()</kbd> method usually takes <kbd>CacheableDependencyInterface</kbd> objects to read their cache metadata. If something else is passed, the access result is deemed not cacheable. So in our case, since the access depends on both the salutation configuration object and the user account, we add them both as cache dependencies.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Placeholders and lazy building</h1>
                </header>
            
            <article>
                
<p>Now that we've seen a bit about how the cacheability metadata can be used in more common scenarios, let's shift gears and talk about those page components that have highly dynamic data.</p>
<p>When we set the maximum age of our Hello World salutation to 0 seconds (don't cache), I mentioned that there are ways this can be improved in order to help performance. This involves postponing the rendering of the respective bit to the very last moment with the help of placeholders. But first, a bit of background.</p>
<p>Each of the cache properties we talked about can have values that make caching the render array pointless. We've already talked about the maximum age being set to 0, but you can also argue very low expiration times to have the same effect. Additionally, certain cache tags can be invalidated too frequently, again making the render arrays that depend on what they represent pointless to cache. Finally, certain cache contexts can provide many variations that significantly limit the effectiveness of the cache to the point that it may even be counterproductive (high storage costs).</p>
<p>Cache tags are something very specific to the application we are building, so there are no general assumptions that can be made as to which have a high invalidation rate. However, there are two cache contexts that by default are considered to have much too high cardinality to be effective: <kbd>session</kbd> and <kbd>user</kbd>. Yes, we talked about the <kbd>user</kbd> context earlier as a good example but in reality—by default—adding this context to a render array has pretty much the same effect as setting the max-age to 0—it will not be cached. The same goes for the <kbd>session</kbd> context because there can be so many sessions and users on the site, you probably won't want to have cache records for each individual one.</p>
<p>Since these are not rules that have to necessarily apply to all applications, Drupal configures these values as service parameters, making them changeable if needed. Inside the <kbd>core.services.yml</kbd> file (which lists most of the core services), we can find some parameter definitions as well, including this one:</p>
<pre><span>renderer.config: <br/></span><span>  auto_placeholder_conditions: <br/></span><span>    max-age: </span>0 <br/>    <span>contexts: </span>[<span>'session'</span>, <span>'user'</span>] <br/>    <span>tags: </span>[] </pre>
<p>As you can see, the max-age value of 0 and the previously mentioned cache contexts are included, but no tags. We can also change these values. So, for example, if in our application we know that we won't have too many users and it does, in fact, make sense to cache by user context, or we know of certain cache tags with high invalidation frequency, it makes sense to change this. There are two ways we can do it: either we use our site-wide <kbd>services.yml</kbd> file and copy these declarations (while making the appropriate changes) or we can use the services file of a given module in the same way. Both methods have the effect of overriding the default parameters set by Drupal core.</p>
<p>Now that we are clear on why certain things are not cacheable, let's see how this can be addressed using <em>auto-placeholdering</em>.</p>
<p>Auto-placeholdering is the process by which Drupal identifies the render arrays that cannot or should not be cached for the reasons we mentioned before, and replaces them with a placeholder. The latter is then replaced at the very last possible moment while allowing the rest of the page components to be cached. This is also called <em>lazy building</em>.</p>
<p>Drupal identifies the bits <span><span>that</span></span> need to be lazy built by the cache metadata that fits the conditions we saw before and the presence of the <kbd>#lazy_builder</kbd> property on the render array. The latter maps to a callback that returns its own render array, which can also contain said cache metadata. And it doesn't matter which of the render arrays contains the latter.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Lazy builders</h1>
                </header>
            
            <article>
                
<p>Lazy builders are nothing more than callbacks on a render array that Drupal can use to build the render array at a later stage. The callbacks can be static (a reference to a class and method) or dynamic (a reference to a service and method). Using the latter approach is more flexible as we can inject dependencies from the container as we do regularly with services. Moreover, the callback can take parameters, which means it can build the render array already having at least part of the required data.</p>
<p>The best way to understand this is to see an example. Since we decided that our salutation component should have a cache lifetime of 0 seconds, it's a good opportunity to build it using a lazy builder.</p>
<p>The first thing we need to do is replace our <kbd>helloWorld</kbd> Controller method in which we directly call the salutation service with this:</p>
<pre>return [ 
  '#lazy_builder' =&gt; ['hello_world.lazy_builder:renderSalutation', []], 
  '#create_placeholder' =&gt; TRUE, 
]; </pre>
<p>Back in <a href="feada4d1-f255-4dd6-83b5-8d66bab5f852.xhtml">Chapter 4</a>, <em>Theming,</em> when I said a render array needs to have at least one of the four properties (<kbd>#type</kbd>, <kbd>#theme</kbd>, <kbd>#markup</kbd>, or <kbd>#plain_text</kbd>), I lied. We can also use a lazy builder like this to defer the building of the render array to a later stage.</p>
<p>The <kbd>#lazy_builder</kbd> needs to be an array whose first item is the callback and second is an array of arguments to pass to it. In our case, we don't need any of the latter. We could pass the salutation service, but instead, we will inject it into the new <kbd>hello_world.lazy_builder</kbd> service we will create in a minute. The callback reference is in the format of <kbd>service_name:method</kbd> (one colon used for separation) or for static calls <kbd>class_name::method</kbd> (two colons). We also explicitly declare <kbd>#create_placeholder</kbd> to make it clear that this render array should be replaced with a placeholder. Lastly, as I mentioned earlier, the cache metadata can be applied to this render array or it can also be on the resulting one from the lazy builder. So, we'll opt for the latter approach in this case.</p>
<p>Let's now define our service:</p>
<pre>hello_world.lazy_builder: 
  class: Drupal\hello_world\HelloWorldLazyBuilder 
  arguments: ['@hello_world.salutation']  </pre>
<p>Nothing out of the ordinary here, but we are injecting the <kbd>HelloWorldSalutation</kbd> service as a dependency so that we can ask it for our salutation component. The actual service class looks like this:</p>
<pre>namespace Drupal\hello_world; 
 
/** 
 * Lazy builder for the Hello World salutation. 
 */ 
class HelloWorldLazyBuilder { 
 
  /** 
   * @var \Drupal\hello_world\HelloWorldSalutation 
   */ 
  protected $salutation; 
 
  /** 
   * HelloWorldLazyBuilder constructor. 
   * 
   * @param \Drupal\hello_world\HelloWorldSalutation $salutation 
   */ 
  public function __construct(HelloWorldSalutation $salutation) { 
    $this-&gt;salutation = $salutation; 
  } 
 
  /** 
   * Renders the Hello World salutation message. 
   */ 
  public function renderSalutation() { 
    return $this-&gt;salutation-&gt;getSalutationComponent(); 
  } 
}  </pre>
<p>All very simple. The <kbd>renderSalutation()</kbd> method is required as we referenced it from our lazy builder. That is all we have to do. But, what exactly happens with this?</p>
<p>When Drupal renders our Controller, it finds the lazy builder and registers it with a placeholder, which is then used instead of the actual final render array. Then, at a much later stage in the page-building process, the lazy builder is invoked and the actual output is rendered to replace the placeholder. There are a couple of advantages and implications with this. First, it allows Drupal to bypass this highly dynamic bit of output and cache the rest of the components in the dynamic page cache. This is to prevent the lack of cacheability from infecting the entire page. Second, there are two different strategies (so far) with which placeholders can be processed. By default, in using the so-called <em>Single Flush</em> method, the placeholder replacement is postponed until the last minute, but the response is not sent back to the browser before this is done. So, the dynamic page cache does improve things (caches what it can), but the response still depends on the placeholder processing finishing. Depending on how long that takes, the page load, in general, can suffer. However, when using the <strong>BigPipe</strong> (<span class="URLPACKT"><a href="https://www.facebook.com/notes/facebook-engineering/bigpipe-pipelining-web-pages-for-high-performance/389414033919">https://www.facebook.com/notes/facebook-engineering/bigpipe-pipelining-web-pages-for-high-performance/389414033919</a></span>) approach, the response is sent back to the browser before the placeholders are replaced. And as the latter finishes as well, the replacements are streamed to the browser. This greatly improves the perceived performance of the site as users can already see most parts of the page before the slower bits appear.</p>
<p>The <em>BigPipe</em> technique was invented by Facebook as a way to deal with highly dynamic pages and was gradually brought into Drupal 8 as an experimental core module. With version 8.3 it has been marked stable and ready for use in production sites. I highly recommend you keep this module enabled as it comes with the Standard installation profile.</p>
<div class="packt_infobox">As you've probably guessed by now, the lazy builder approach is only useful when it comes to Dynamic Page Caching. That is when we cache for authenticated users. It will not work with the Internal Page Cache which is used for anonymous users.</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Using the Cache API</h1>
                </header>
            
            <article>
                
<p>So far in this chapter, we've mostly preoccupied ourselves with render arrays and how we can expose them to the Cache API for better performance. It's now time to talk a bit about how cache entries are stored by default in Drupal and how we can interact with them ourselves in our code.</p>
<p>As mentioned earlier, a central interface for the cache system is the <kbd>CacheBackendInterface</kbd>, which is the interface any caching system needs to implement. It basically provides the methods for creating, reading, and invalidating cache entries.</p>
<p>As we might expect, when we want to interact with the Cache API, we use a service to retrieve an instance of the <kbd>CacheBackendInterface</kbd>. However, the service name we use depends on the cache <em>bin</em> we want to work with. Cache bins are repositories that group together cache entries based on their type. So, the aforementioned implementation wraps a single cache bin, and each bin has a machine name. The service name will then be in the following format: <kbd>cache.[bin]</kbd>. This means that for each cache bin, we have a separate service.</p>
<p>The static shorthand for getting this service looks like this:</p>
<pre>$cache = \Drupal::cache();  </pre>
<p>This will return the <kbd>default</kbd> bin represented by a <kbd>CacheBackendInterface</kbd> implementation. If we want to request a specific bin, we pass the name as an argument:</p>
<pre>$cache = \Drupal::cache('render');  </pre>
<p>This will return the <kbd>render</kbd> cache bin.</p>
<p>And of course, if we need to inject a cache bin wrapper somewhere, we simply use the service machine name in the format I mentioned before.</p>
<p>Even though we have a separate service for each cache bin, they all basically do the same thing, and that is use the <kbd>CacheFactory</kbd> to instantiate the right type of cache backend for that bin. Individual cache backends can be registered and set as the default either globally or for specific bins.</p>
<p>As I mentioned at the beginning of the chapter, the default cache backend in Drupal—the one this factory will instantiate for all the bins—is the <kbd>DatabaseBackend</kbd>. Each bin is represented by a database table. This is similar in concept to what we had in Drupal 7.</p>
<p>Now that we know how to load the cache backend service, let's see how we can use it to read and cache things. When it comes to this, your number one reference point is the <kbd>CacheBackendInterface</kbd> which documents all the methods. However, since it does not reinforce return values, the examples we will see next are done with the database cache backend. They might differ from other cache backend implementations.</p>
<p>The first method we'll talk about is <kbd>get()</kbd>, which takes the ID of the cache entry we want to retrieve (<kbd>$cid</kbd>) and an optional <kbd>$allow_invalid</kbd> parameter. The first parameter is clear enough, but the second one is used in case we want to retrieve the entry even if it has expired or has been invalidated. This can be useful in those cases in which <em>stale</em> data is preferred over the recalculation costs of multiple concurrent requests:</p>
<pre>$data = $cache-&gt;get('my_cache_entry_cid');  </pre>
<p>The resulting <kbd>$data</kbd> variable is a PHP standard class that contains the <kbd>data</kbd> key (the data that has been cached) and all sorts of metadata about the cache entry: expiration, creation timestamp, tags, valid status, and so on.</p>
<p>Of course, there is also a <kbd>getMultiple()</kbd> method which you can use to retrieve multiple entries at once.</p>
<p>More fun, though, is the <kbd>set()</kbd> method which allows us to store something in the cache. There are four parameters to this method:</p>
<ul>
<li><kbd>$cid</kbd> : The cache ID that can be used to retrieve the entry.</li>
<li><kbd>$data</kbd> : A serializable data structure such as an array or object (or simple scalar value).</li>
<li><kbd>$expire</kbd> : The UNIX timestamp after which this entry is considered invalid, or <kbd>CacheBackendInterface::CACHE_PERMANENT</kbd> to indicate that this entry is never invalid unless specifically invalidated. The latter is the default.</li>
<li><kbd>$tags</kbd> : An array of cache tags that will be used to invalidate this entry if it depends on something else (cache metadata, basically).</li>
</ul>
<p>So to use it, we would do something like this:</p>
<pre>$cache-&gt;set('my_cache_entry_cid', 'my_value');  </pre>
<p>With this statement we are creating a simple non-serialized cache entry into our chosen bin that does not expire unless specifically invalidated (or deleted). Subsequent calls with the same cache ID will simply override the entry. If the cache value is an array or object, it will get serialized automatically.</p>
<p>When it comes to deleting, there are two easy methods: <kbd>delete()</kbd> and <kbd>deleteMultiple()</kbd>, which take the <kbd>$cid</kbd> (or an array of cache IDs, respectively) as an argument and removes the entries from the bin completely. If we want to delete all the items in the bin, we can use the <kbd>deleteAll()</kbd> method.</p>
<p>Instead of deleting entries, quite often it's a good idea to invalidate them. We'll still be able to retrieve the data using the <kbd>$allow_invalid</kbd> parameter and can use the entry while the new one is being recalculated. This can be done almost exactly as deleting but using the following methods instead: <kbd>invalidate()</kbd>, <kbd>invalidateMultiple()</kbd>, and <kbd>invalidateAll()</kbd>.</p>
<p>OK, but what about those cache tags we can store with the entry? We already kind of know their purpose and that is to <em>tag</em> cache entries across multiple bins with certain data markers that can make them easy to invalidate when the data changes. Just like with render arrays. So, how can we do this?</p>
<p>Let's assume that we store the following cache entry:</p>
<pre>$cache-&gt;set('my_cache_entry_cid', 'my_value', CacheBackendInterface::CACHE_PERMANENT, ['node:10']);  </pre>
<p>We essentially make it dependent on changes to the Node with the ID of 10. This means that when that node changes, our entry (together with all other entries in all other bins that have the same tag) becomes invalid. Simple as that.</p>
<p>But we can also have our own tags that make it depend on something custom of ours like a data value (which, as we discussed earlier in the chapter, should implement the <kbd>CacheableDependencyInterface</kbd>) or a process of some kind. In that case, we would also have to take care of invalidating all the cache entries that have our tag. The simplest way we can do this is statically, using the <kbd>Cache</kbd> class we encountered earlier when merging metadata together:</p>
<pre>Cache::invalidateTags(['my_custom_tag']);  </pre>
<p>This will invalidate all cache entries that are <em>tagged</em> with any of the tags passed in the array. Under the hood, this method uses a static call to the cache invalidator service, so whenever possible, it's best to actually inject that service—<kbd>cache_tags.invalidator</kbd>.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Creating our own cache bin</h1>
                </header>
            
            <article>
                
<p>Usually, the existing cache bins, particularly the default one, will be enough to store our own cache entries. However, there are times in which we need to create multiple entries for the same functionality, in which case, it would help to have a special bin for that. So, let's see how that can be created.</p>
<p>It's quite easy because all we have to do is define a service:</p>
<pre><span>cache.my_bin: <br/></span><span>  class: </span>Drupal\Core\Cache\CacheBackendInterface <br/>  <span>tags: <br/></span><span>    </span>- { <span>name: </span>cache.bin } <br/>  <span>factory: </span>cache_factory:get <br/>  <span>arguments: </span>[my_bin] </pre>
<p>The class used in this service definition is actually an interface. This is because we are using a factory to instantiate the service rather than the container directly. This means we don't know what class will be instantiated. In this case, the factory in question is the service with the name <kbd>cache_factory</kbd> and its <kbd>get()</kbd> method. In <a href="360802d2-dd46-4d08-b478-9351d56ed2a0.xhtml">Chapter 3</a>, <em>Logging and Mailing</em>, we saw an example in which something like this happened when we talked about logger channels.</p>
<p>The <kbd>cache.bin</kbd> tag is used so that Drupal can understand the function of this service, namely, that it is a cache bin. The responsibility of making sure this bin gets its storage belongs to the actual backend. So in our example, the <kbd>DatabaseBackend</kbd> creates and removes the cache table as needed.</p>
<p>Lastly, the static argument is the name of the bin that gets passed to the factory and that is used to create the cache backend for this particular bin. That is pretty much it. If we clear the cache, we can already see a new cache table for our bin in the database.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Summary</h1>
                </header>
            
            <article>
                
<p>In this chapter, we covered the main aspects of caching in Drupal 8 any module developer needs to be familiar with. We introduced some key concepts and talked about the two main types of caching—Internal Page Cache (used for anonymous users) and Dynamic Page Cache (used for authenticated users).</p>
<p>We dug deeper into cacheability metadata, which is probably the most important and common thing we need to understand. It's imperative to use this properly so that all the render arrays we build are cached and invalidated correctly. We also saw how block plugins have specific methods we can use to define their cacheability metadata and how access results should also receive cacheability dependencies, as needed. Stemming from this, we also explored lazy builders and the <em>auto-placeholdering</em> strategies that allow us to handle highly dynamic components while maintaining good cacheability overall.</p>
<p>Lastly, we looked into using the Cache API ourselves in order to store, read, and invalidate our own cache entries. We even saw how to create our own custom cache bin.</p>
<p>Caching is a very important aspect of Drupal 8 module development. In previous versions, it didn't even come close and we were able to get away with it quite often without even paying attention to it. Now, we have a powerful system in place to make rendering more performant, and we should make use of it.</p>
<p>In the next chapter, we are going to talk about JavaScript and how we can use it in a Drupal context, as well as the powerful Ajax API.</p>


            </article>

            
        </section>
    </body></html>