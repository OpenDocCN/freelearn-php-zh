<html><head></head><body><div id="sbo-rt-content"><div id="_idContainer055">
			<h1 id="_idParaDest-80"><em class="italic"><a id="_idTextAnchor079"/></em><a href="B17606_04_Final_PD_ePub.xhtml#_idTextAnchor079"><em class="italic">Chapter 4</em></a>: Diving into Liquid Core with Objects</h1>
			<p>In the previous three chapters, we have been referencing objects. However, in this chapter, we will learn about objects, their attributes, and some of the best ways to use them. By learning about objects, we will finalize some projects that we have started and work on new projects to develop our knowledge further.</p>
			<p>We will cover the following topics in this chapter:</p>
			<ul>
				<li>Working with global objects</li>
				<li>Improving the workflow with metafields</li>
				<li>Content and special objects</li>
			</ul>
			<p>Upon completing this chapter, we will understand what content objects are, why they are mandatory, and how to use them, which is the first step in creating future templates. We will have also learned more about the global objects that we have been referencing up until now.</p>
			<p>However, due to the significant number of global objects and attributes they offer us, we will not cover all of them. Instead, we will only explain some of the essential global objects and attributes, which will set us on the right path to understanding objects entirely. By learning about objects, we will also learn to understand metafields, which allow us to store and dynamically output additional data on our store. Lastly, we will learn about the special objects that will help us output some helpful functionalities on our store.</p>
			<h1 id="_idParaDest-81"><a id="_idTextAnchor080"/>Technical requirements</h1>
			<p>While we will explain each topic and have it presented with the accompanying graphics, we will need an internet connection to follow the steps outlined in this chapter, considering that Shopify is a hosted service.</p>
			<p>The code for this chapter is available on GitHub at https://github.com/PacktPublishing/Shopify-Theme-Customization-with-Liquid/tree/main/Chapter04.</p>
			<p>The Code in Action video for the chapter can be found here: <a href="https://bit.ly/3u7hqyB">https://bit.ly/3u7hqyB</a></p>
			<h1 id="_idParaDest-82"><a id="_idTextAnchor081"/>Working with global objects</h1>
			<p>We referenced objects and their attributes in the previous chapter. <em class="italic">But what exactly are objects?</em></p>
			<p>These objects, or so-called <strong class="bold">liquid variables</strong>, are elements that allow us to read the content defined <a id="_idIndexMarker284"/>in our backend and dynamically output it to <a id="_idIndexMarker285"/>help us create better programming logic. We can output the data by combining the objects and attributes encapsulated by <em class="italic">double curly braces</em>. An example of the global object that we were using in the previous chapter would be <strong class="source-inline">{{ collection.title }}</strong>, where the <strong class="source-inline">collection</strong> keyword would be our object and <strong class="source-inline">title</strong> would be the attribute.</p>
			<p>We can reference these global objects inside any file by directly visiting the page whose content we are looking to recover and calling the object, or manually invoking the object for the specific page using its handle and combining it with the variable tags. Let's see this in action.</p>
			<p>As you may recall from the previous chapter, while we were working on the project on our indoor collection page, we initially used <strong class="source-inline">collection.title</strong> to recover the collection's name:</p>
			<p class="source-code">{{ collection.title }}</p>
			<p>When used inside the collection page, the preceding code will provide us with the data we are looking for. However, <em class="italic">what if we wanted to access the</em> <strong class="source-inline">indoor</strong> <em class="italic">collection object while visiting the outdoor collection page?</em></p>
			<p>This is where our knowledge of accessing the page object using the page handle, which we covered in <a href="B17606_02_Final_PD_ePub.xhtml#_idTextAnchor030"><em class="italic">Chapter 2</em></a>, <em class="italic">The Basic Flow of Liquid</em>, in the <em class="italic">EmptyDrop</em> subsection of the <em class="italic">Understanding the types of data</em> section comes to help.</p>
			<p>We can access the object using its handle by pluralizing the object's name we are trying to access, followed by either a squared bracket (<strong class="source-inline">[]</strong>) or dot (<strong class="source-inline">.</strong>) notation:</p>
			<p class="source-code">{% assign customCollection = collections["indoor"].title %}</p>
			<p class="source-code">{% assign customCollection = collections.indoor.title %}</p>
			<p>By defining a variable with the object of the indoor collection, we can output the data for that collection on any page by simply invoking the object, followed by the attribute that we need:</p>
			<p class="source-code">{{ customCollection.title }}</p>
			<p>While our object name differs from the original object name, it will allow us to output the same information compared to when we used <strong class="source-inline">{{ collection.title }}</strong> inside the collection template.</p>
			<p class="callout-heading">Important note:</p>
			<p class="callout">In the previous example, we created a variable using the <strong class="source-inline">customCollection</strong> name. However, note that you can create this variable using any name of your choice, including the collection itself. While the <strong class="source-inline">collection</strong> keyword is not reserved, we should pay close attention when using the keywords already in use as this can cause unexpected results.</p>
			<p>Considering that <a id="_idIndexMarker286"/>global objects is an extensive topic, it would not be very productive to explain each object and their attributes separately. Instead, we will be creating a few projects to see firsthand how to work with different kinds of objects and the data types they return.</p>
			<p>As we have already mentioned, an object, in combination with attributes, allows us to read the information from our admin and dynamically output it to create various functionalities. Let's start by familiarizing ourselves with the collection and product objects, which we will use to finalize the <strong class="source-inline">Custom collection</strong> project that we started in the previous chapter.</p>
			<h2 id="_idParaDest-83"><a id="_idTextAnchor082"/>Custom collection</h2>
			<p>In the previous chapter, we created a <strong class="source-inline">for</strong> loop that outputs the names of the products from the <a id="_idIndexMarker287"/>outdoor collection, whose price is lower than $100.00. We did this by creating a <strong class="source-inline">collection-form</strong> snippet whose content we are outputting using the <strong class="source-inline">for</strong> parameter, combined with the <strong class="source-inline">render</strong> tag. We placed this at the bottom of our <strong class="source-inline">collection.liquid</strong> template file:</p>
			<p class="source-code">{% render "collection-form" for collections["outdoor"]  .products as product %}</p>
			<p>Inside our snippet, we added an <strong class="source-inline">if</strong> statement to check if the product price is higher than <strong class="source-inline">10000</strong>. If it is, we should output the product <strong class="source-inline">form</strong> tag and the product title:</p>
			<p class="source-code">{% if product.price &gt; 10000 %}</p>
			<p class="source-code">  {% continue %}</p>
			<p class="source-code">{% else %}</p>
			<p class="source-code">  {% form "product", product, data-location: "collection" %}</p>
			<p class="source-code">    {{ product.title }}</p>
			<p class="source-code">  {% endform %}</p>
			<p class="source-code">{% endif %}</p>
			<p>If we were to preview our code by vising the indoor collection page, we would only see a list of names, so let's try to improve this snippet by writing some code that will output the entire product block instead of only the product's name.</p>
			<p>Let's start by <a id="_idIndexMarker288"/>refactoring the code inside the snippet by removing the <strong class="source-inline">continue</strong> and <strong class="source-inline">capture</strong> tags, refining our statement by removing the <strong class="source-inline">else</strong> statement, wrapping <strong class="source-inline">{{ product.title }}</strong>, positioning it above the product form, and finally removing the extra parameters from our product <strong class="source-inline">form</strong> tag:</p>
			<p class="source-code">{% if product.price &lt; 10000 %}</p>
			<p class="source-code">  &lt;p&gt;{{ product.title }}&lt;/p&gt;</p>
			<p class="source-code">  {% form "product", product %}</p>
			<p class="source-code">  {% endform %}</p>
			<p class="source-code">{% endif %}</p>
			<p>The newly refactored code will do the same thing as it did previously, but now, it will be easier to understand and maintain. </p>
			<p>Let's proceed by creating our product block. Currently, we only have a product name, so let's include the hyperlink that will redirect us to the actual product name when we click on the product's name.</p>
			<p>We can do this by wrapping <strong class="source-inline">{{ product.title }}</strong> inside of the hyperlink tag, with its <strong class="source-inline">href</strong> attribute set to <strong class="source-inline">{{ product.url }}</strong>. This will return the relative path:</p>
			<p class="source-code">{% if product.price &lt; 10000 %}</p>
			<p class="source-code">  <strong class="bold">&lt;a href="{{ product.url }}"&gt;</strong></p>
			<p class="source-code">    &lt;p&gt;{{ product.title }}&lt;/p&gt;</p>
			<p class="source-code">  <strong class="bold">&lt;/a&gt;</strong></p>
			<p class="source-code">  {% form "product", product %}</p>
			<p class="source-code">  {% endform %}</p>
			<p class="source-code">{% endif %}</p>
			<p>The addition <a id="_idIndexMarker289"/>of the hyperlink has ensured that we will be redirected to the actual product page by clicking the product's name. The next thing we need to do is include the image for each of our products.</p>
			<p>We can do this by creating an image HTML tag inside the hyperlink tag, just above the product title, and setting its <strong class="source-inline">src</strong> attribute to <strong class="source-inline">{{ product | img_url }}</strong>. This will return a string to <a id="_idIndexMarker290"/>the location of the product image on Shopify's <strong class="bold">Content Delivery Network</strong> (<strong class="bold">CDN</strong>):</p>
			<p class="source-code">{% if product.price &lt; 10000 %}</p>
			<p class="source-code">  &lt;a href="{{ product.url }}"&gt;</p>
			<p class="source-code">    <strong class="bold">&lt;img src="{{ product | img_url }}"/&gt;</strong></p>
			<p class="source-code">    &lt;p&gt;{{ product.title }}&lt;/p&gt;</p>
			<p class="source-code">  &lt;/a&gt;</p>
			<p class="source-code">  {% form "product", product %}</p>
			<p class="source-code">  {% endform %}</p>
			<p class="source-code">{% endif %}</p>
			<p>Our product block is starting to look a lot better, but we still need to show the price of our products. We can include the product price by wrapping <strong class="source-inline">{{ product.price | money }}</strong> inside the <strong class="source-inline">p</strong> HTML tags:</p>
			<p class="source-code">{% if product.price &lt; 10000 %}</p>
			<p class="source-code">  &lt;a href="{{ product.url }}"&gt;</p>
			<p class="source-code">    &lt;img src="{{ product | img_url }}"/&gt;</p>
			<p class="source-code">    &lt;p&gt;{{ product.title }}&lt;/p&gt;</p>
			<p class="source-code">    <strong class="bold">&lt;p&gt;{{ product.price | money }}&lt;/p&gt;</strong></p>
			<p class="source-code">  &lt;/a&gt;</p>
			<p class="source-code">  {% form "product", product %}</p>
			<p class="source-code">  {% endform %}</p>
			<p class="source-code">{% endif %}</p>
			<p class="callout-heading">Tip:</p>
			<p class="callout">Notice that we have a small addition separated by a pipe character for both the <strong class="source-inline">image</strong> and <strong class="source-inline">price</strong> objects. This <a id="_idIndexMarker291"/>addition is called a <strong class="bold">filter</strong>, which helps us modify the output that we would otherwise receive from the object.</p>
			<p>For example, if we were to call the <strong class="source-inline">product</strong> object with the <strong class="source-inline">price</strong> attribute, we would receive a number <a id="_idIndexMarker292"/>value without any format, such as <strong class="source-inline">2599</strong>. However, by applying the <strong class="source-inline">money</strong> filter to the object, we have automatically changed the otherwise meaningless number into a string data type and formatted it according to our store-selected currency formatting, resulting in a $25.99 string.</p>
			<p>We will not go into too much detail regarding filters right now, as we will be learning about them in the next chapter. For now, this basic information about filters will have to suffice. Let's return to our example.</p>
			<p>So far, we have included the product name, image, and price, which check most of the necessary boxes that are needed to present a product. However, notice that the product <strong class="source-inline">form</strong> is currently empty. Let's change this by introducing an <strong class="source-inline">input</strong> element so that it's of the <strong class="source-inline">submit</strong> type, which should allow us to purchase the product directly from the collection page:</p>
			<p class="source-code">{% if product.price &lt; 10000 %}</p>
			<p class="source-code">  &lt;a href="{{ product.url }}"&gt;</p>
			<p class="source-code">    &lt;img src="{{ product | img_url }}"/&gt;</p>
			<p class="source-code">    &lt;p&gt;{{ product.title }}&lt;/p&gt;</p>
			<p class="source-code">    &lt;p&gt;{{ product.price | money }}&lt;/p&gt;</p>
			<p class="source-code">  &lt;/a&gt;</p>
			<p class="source-code">  {% form "product", product %}</p>
			<p class="source-code">    <strong class="bold">&lt;input type="submit" value="Add to Cart"/&gt;</strong></p>
			<p class="source-code">  {% endform %}</p>
			<p class="source-code">{% endif %}</p>
			<p>With the addition of the <strong class="bold">Add to Cart</strong> button, we have created a button that should allow us to <a id="_idIndexMarker293"/>purchase the products directly from our collection page, without having to navigate to the product page. However, if we were to click it right now, we would encounter an error stating <strong class="bold">Parameter Missing or Invalid: Required parameter missing or invalid: items</strong>:</p>
			<div>
				<div id="_idContainer044" class="IMG---Figure">
					<img src="Images/Figure_4.01_B17606.jpg" alt="Figure 4.1 – Result of submitting a product form with missing parameters&#13;&#10;" width="777" height="503"/>
				</div>
			</div>
			<p class="figure-caption">Figure 4.1 – Result of submitting a product form with missing parameters</p>
			<p>The parameter that we are missing is the <strong class="source-inline">id</strong> property of the variant that we are looking to purchase.</p>
			<p>Every product on Shopify can have up to three different sets of options. For example, a product can have multiple sizes, colors, and materials. Each combination of these three choices generates a unique number called a variant <strong class="source-inline">id</strong>, which tells our product <strong class="source-inline">form</strong> which combination of options it should place in the cart.</p>
			<p>Note that these <a id="_idIndexMarker294"/>options are entirely optional as we can have a product without any variant options. However, even then, we still need to include the variant <strong class="source-inline">id</strong>. We should include this variant <strong class="source-inline">id</strong> as a <strong class="source-inline">value</strong> attribute of the <strong class="source-inline">hidden</strong> HTML input element with <strong class="source-inline">id</strong> as its <strong class="source-inline">name</strong> attribute:</p>
			<p class="source-code">{% if product.price &lt; 10000 %}</p>
			<p class="source-code">  &lt;a href="{{ product.url }}"&gt;</p>
			<p class="source-code">    &lt;img src="{{ product | img_url }}"/&gt;</p>
			<p class="source-code">    &lt;p&gt;{{ product.title }}&lt;/p&gt;</p>
			<p class="source-code">    &lt;p&gt;{{ product.price | money }}&lt;/p&gt;</p>
			<p class="source-code">  &lt;/a&gt;</p>
			<p class="source-code">  {% form "product", product %}</p>
			<p class="source-code">    &lt;input type="hidden" name="id" value="{{<strong class="bold">       product.first_available_variant.id }}</strong>" /&gt;</p>
			<p class="source-code">    &lt;input type="submit" value="Add to Cart"/&gt;</p>
			<p class="source-code">  {% endform %}</p>
			<p class="source-code">{% endif %}</p>
			<p>With the addition of the variant <strong class="source-inline">id</strong>, we now have a fully functional product <strong class="source-inline">form</strong>. By clicking the <strong class="bold">Add to Cart</strong> button, we can submit the request to the Shopify servers, where the product and its variant will be identified based on the submitted variant <strong class="source-inline">id</strong> and added to our cart.</p>
			<p>Notice that we will also be automatically redirected to the cart page after clicking the <strong class="bold">Add to Cart</strong> button. This is the default behavior that we can rectify in one of two ways.</p>
			<p>The first way would require us to add the <strong class="source-inline">return_to</strong> parameter to our product <strong class="source-inline">form</strong> tag, which will allow us to set the page we should return to after submitting the form. We can remind ourselves of how to use the <strong class="source-inline">return_to</strong> parameter by returning to the previous chapter and revisiting <em class="italic">The form tag</em> subsection, located under the <em class="italic">Theme tags</em> section. The other way would be to use the <strong class="bold">Shopify Ajax API</strong>, which we will learn about later in this book.</p>
			<p>Let's return to the indoor collection for now. Let's look at the entire collection page and compare the initial collection products with our custom collection at the bottom. You will notice that <a id="_idIndexMarker295"/>besides being styled in a much better way than our collection, the initial collection products also contain a red sale badge, along with a regular and discounted price.</p>
			<p>Each product in the admin contains two different fields for price, located under the <strong class="bold">Pricing</strong> section. The first field, named <strong class="bold">Price</strong>, allows us to set the current price of our product. However, the second field, named <strong class="bold">Compare at price</strong>, allows us to set the initial price to simulate a discount. We can access this field data by combining the <strong class="source-inline">product</strong> object with the <strong class="source-inline">compare_at_price</strong> attribute.</p>
			<p>Let's return to our code on the collection page and modify it so that it includes both the sale badge and the compare price to match the initial collection. We can show the comparison price by wrapping <strong class="source-inline">{{ product.compare_at_price | money }}</strong> inside the <strong class="source-inline">span</strong> element and positioning it right after <strong class="source-inline">{{ product.price | money }}</strong>. Additionally, we can implement the sale badge by creating a simple string message inside the <strong class="source-inline">span</strong> tag and placing it under the <strong class="source-inline">price</strong> element:</p>
			<p class="source-code">{% if product.price &lt; 10000 %}</p>
			<p class="source-code">  &lt;a href="{{ product.url }}"&gt;</p>
			<p class="source-code">    &lt;img src="{{ product | img_url }}"/&gt;</p>
			<p class="source-code">    &lt;p&gt;{{ product.title }}&lt;/p&gt;</p>
			<p class="source-code">    &lt;p&gt;{{ product.price | money }}<strong class="bold">&lt;span&gt;{{         product.compare_at_price | money }}&lt;/span&gt;</strong>&lt;/p&gt;</p>
			<p class="source-code"><strong class="bold">    &lt;span&gt;sale&lt;/span&gt;</strong></p>
			<p class="source-code">  &lt;/a&gt;</p>
			<p class="source-code">  {% form "product", product %}</p>
			<p class="source-code">    &lt;input type="hidden" name="id" value="{{         product.first_available_variant.id }}" /&gt;</p>
			<p class="source-code">    &lt;input type="submit" value="Add to Cart"/&gt;</p>
			<p class="source-code">  {% endform %}</p>
			<p class="source-code">{% endif %}</p>
			<p>We have included all the necessary elements for the <strong class="source-inline">Custom collection</strong> items. However, quite a few products do not have their comparison price and sale badges visible, which results from the <strong class="bold">Compare at price</strong> field being empty inside the product admin. We can <a id="_idIndexMarker296"/>resolve the second issue by modifying the <strong class="source-inline">if</strong> statement on our first line so that it shows products with a defined comparison price:</p>
			<p class="source-code"><strong class="bold">{% if product.compare_at_price != blank %}</strong></p>
			<p class="source-code">  &lt;a href="{{ product.url }}"&gt;</p>
			<p class="source-code">    &lt;img src="{{ product | img_url }}"/&gt;</p>
			<p class="source-code">    &lt;p&gt;{{ product.title }}&lt;/p&gt;</p>
			<p class="source-code">    &lt;p&gt;{{ product.price | money }}&lt;span&gt;{{         product.compare_at_price | money }}&lt;/span&gt;&lt;/p&gt;</p>
			<p class="source-code">      &lt;span&gt;sale&lt;/span&gt;</p>
			<p class="source-code">  <strong class="bold">&lt;/a&gt;</strong></p>
			<p class="source-code">  {% form "product", product %}</p>
			<p class="source-code">    <strong class="bold">&lt;input type="hidden" name="id" value="{{         product.first_available_variant.id }}" /&gt;</strong></p>
			<p class="source-code">    &lt;input type="submit" value="Add to Cart"/&gt;</p>
			<p class="source-code">  {% endform %}</p>
			<p class="source-code">{% endif %}</p>
			<p>By modifying the <strong class="source-inline">if</strong> statement, we have ensured that we only display products on sale, consequently creating a custom on-sale addition for our initial collection. The only thing left to do is update the HTML formatting and add some CSS styling. While formatting and styling are entirely optional, we advise you to use the same formatting as it will be easier to follow up with future changes. The HTML formatted code, along with some basic CSS styling, can be found at the following GitHub link within the <strong class="source-inline">Learning Projects</strong> directory, under the name <strong class="source-inline">Custom collection</strong>: https://github.com/PacktPublishing/Shopify-Theme-Customization-with-Liquid/tree/main/Chapter04/Learning%20Projects/Custom%20collection.</p>
			<p>This GitHub repository contains three files, each named according to the location where the code should be included.</p>
			<p>If we preview <a id="_idIndexMarker297"/>our collection indoor collection now, we will see a significant improvement compared to when we started:</p>
			<div>
				<div id="_idContainer045" class="IMG---Figure">
					<img src="Images/Figure_4.02_B17606.jpg" alt="Figure 4.2 – Example of a complete custom collection project&#13;&#10;" width="953" height="486"/>
				</div>
			</div>
			<p class="figure-caption">Figure 4.2 – Example of a complete custom collection project</p>
			<p>So far, we have only mentioned objects whose attributes return a single value, such as <strong class="source-inline">product.price</strong>, <strong class="source-inline">product.title</strong>, or <strong class="source-inline">product.first_available_variant.id</strong>. However, they can also return an array or even act as helper tools for our programming logic.</p>
			<p>One of the most used objects that returns an array is the <strong class="source-inline">linklist</strong> object. Combined with the <strong class="source-inline">link</strong> object, it will help us read the data from the menu within the navigation admin and help us create a custom navigation menu.</p>
			<h2 id="_idParaDest-84"><a id="_idTextAnchor083"/>Custom navigation</h2>
			<p>For our <a id="_idIndexMarker298"/>next project, we will create a multi-level navigation menu specifically for our collection page. However, before we can learn about the <strong class="source-inline">linklist</strong> and <strong class="source-inline">link</strong> objects, we need to create a navigation menu. Let's get started:</p>
			<ol>
				<li>We can create a new navigation menu by navigating to admin, clicking on <strong class="bold">Online store</strong> to expand it, and clicking on the <strong class="bold">Navigation</strong> link, where we can create the new menu by clicking the <strong class="bold">Add menu</strong> button:<div id="_idContainer046" class="IMG---Figure"><img src="Images/Figure_4.03_B17606.jpg" alt="Figure 4.3 – Example of accessing the Navigation menu&#13;&#10;" width="1122" height="610"/></div><p class="figure-caption">Figure 4.3 – Example of accessing the Navigation menu</p></li>
				<li>After clicking the <strong class="bold">Add menu</strong> button, set the menu's title to <strong class="bold">Indoor Navigation</strong>. The page's handle will be automatically populated once we set the menu's name, so there is no need to modify it manually.</li>
				<li>We are now ready to populate the menu. Click on the <strong class="bold">Add menu item</strong> button and click on the <strong class="bold">Link</strong> field, which will automatically display a dropdown menu. For the first menu item, click on <strong class="bold">Collections</strong>, then <strong class="bold">All collections</strong>, which should immediately populate the menu item's name and link fields. Click on the <strong class="bold">Add</strong> button to finish adding the menu item.</li>
				<li>Repeat the previous step six more times by creating two menu items named and linked to the two collections <strong class="bold">Indoor</strong> and <strong class="bold">Outdoor</strong>, and then four menu items to any four products in our store.</li>
				<li>Once we have created the additional menu items, move the <strong class="bold">Indoor</strong> and <strong class="bold">Outdoor</strong> menu items under the <strong class="bold">All collections</strong> menu item to create a nesting menu. We can do this by clicking on the six dots before the menu item's name, and then <a id="_idIndexMarker299"/>holding and moving them over the <strong class="bold">All collections</strong> menu item until the indented blue line shows, at which point we should release the click:<div id="_idContainer047" class="IMG---Figure"><img src="Images/Figure_4.04_B17606.jpg" alt="Figure 4.4 – Example of creating a dropdown menu inside the Navigation menu&#13;&#10;" width="888" height="743"/></div><p class="figure-caption">Figure 4.4 – Example of creating a dropdown menu inside the Navigation menu</p></li>
				<li>Repeat the previous step and move the two product menu items under the <strong class="bold">Indoor</strong> collection menu item, which we have already moved under the <strong class="bold">All collections</strong> menu item. Repeat the same process for the <strong class="bold">Outdoor</strong> collection menu item and the two product menu items that are remaining.</li>
			</ol>
			<p>If we have done everything right, we should end up with an <strong class="bold">Indoor Navigation</strong> menu containing a single menu item containing <strong class="bold">All collections</strong>, which contains two collection menu items containing two product menu items each. Suppose the menu format does not look the same after following the preceding steps. In that case, we can consult the <a id="_idIndexMarker300"/>Shopify documentation on nesting the menu items, where we can find more detailed instructions and a YouTube link on this topic.</p>
			<p>For additional <a id="_idIndexMarker301"/>information on creating nesting navigation, please refer to https://help.shopify.com/en/manual/online-store/menus-and-links/drop-down-menus.</p>
			<p class="callout-heading">Important note:</p>
			<p class="callout">The maximum amount of nesting menu items we can have inside a single menu is up to three levels long. We can consider the menu that we previously created as a three-level navigation menu, which is the limit.</p>
			<p>Now that we have successfully created the navigation menu, we can start creating a variable that we will assign the value of the <strong class="source-inline">linklist</strong> object to, followed by the handle of the navigation we are trying to access. Remember that when accessing the object using the handle, we need to pluralize the object by adding the letter <strong class="source-inline">s</strong> at the end of the object:</p>
			<p class="source-code">{% assign collection-menu = linklists.indoor-navigation %}</p>
			<p>With that, we have successfully saved the object of our indoor navigation to the <strong class="source-inline">collection-menu</strong> variable. Let's test it inside our <strong class="source-inline">collection.template</strong>. To do so, we will call the <strong class="source-inline">collection-menu</strong> object, followed by the <strong class="source-inline">title</strong> and <strong class="source-inline">levels</strong> attributes, just above <strong class="source-inline">{% section 'collection-template' %}</strong> so that we can see the name of our navigation and the number of nesting menus it has:</p>
			<p class="source-code">{% assign collection-menu = linklists.indoor-navigation %}</p>
			<p class="source-code"><strong class="bold">{{ collection-menu.title }} - {{ collection-menu.levels }}</strong></p>
			<p>If we preview our indoor collection, we will be able to see the name of our navigation and the number of nested levels the navigation menu has:</p>
			<p class="source-code">Indoor Navigation - 3</p>
			<p>Now that we have confirmed that we have recovered the correct menu object, we can remove the <strong class="source-inline">collection-menu.title</strong> and <strong class="source-inline">collection-menu.levels</strong> lines. For the next step, we will need to use the <strong class="source-inline">for</strong> tag to loop over the array of links inside the object, which we can recover by calling the <strong class="source-inline">collection-menu</strong> object, followed by the <strong class="source-inline">links</strong> attribute:</p>
			<p class="source-code">{% assign collection-menu = linklists.indoor-navigation %}</p>
			<p class="source-code">  <strong class="bold">{% for link in collection-menu.links %}</strong></p>
			<p class="source-code">    <strong class="bold">{{ link.title }}</strong></p>
			<p class="source-code">  <strong class="bold">{% endfor %}</strong></p>
			<p>If we preview our <strong class="bold">Indoor</strong> collection now, we will notice that the only menu item that's visible on <a id="_idIndexMarker302"/>our page is the first level item, <strong class="bold">All Collections</strong>. Suppose we would like to loop over the additional nested menus located inside the <strong class="bold">All Collections</strong> menu item. In that case, we will need to create a second loop inside the first loop to recover the data from the second level.</p>
			<p>The key difference is that we will not use <strong class="source-inline">collection-menu</strong> as our object. Instead, we will use the <strong class="source-inline">link</strong> object from our first <strong class="source-inline">for</strong> loop, combined with the <strong class="source-inline">links</strong> attribute, which will give us access to the array of links inside the <strong class="source-inline">link</strong> object:</p>
			<p class="source-code">{% assign collection-menu = linklists.indoor-navigation %}</p>
			<p class="source-code">{% for link in collection-menu.links %}</p>
			<p class="source-code">  {{ link.title }}</p>
			<p class="source-code"><strong class="bold">  {% for sub_link in link.links %}</strong></p>
			<p class="source-code"><strong class="bold">    {{ sub_link.title }}</strong></p>
			<p class="source-code"><strong class="bold">  {% endfor %}</strong></p>
			<p class="source-code">{% endfor %}</p>
			<p>By looping over the <strong class="source-inline">link</strong> object, we were able to recover the array links nested inside the <strong class="bold">All Collections</strong> menu item. Using the same technique, we can loop over the array of links inside the final level of the <strong class="bold">Indoor</strong> navigation menu:</p>
			<p class="source-code">{% assign collection-menu = linklists.indoor-navigation %}</p>
			<p class="source-code">{% for link in collection-menu.links %}</p>
			<p class="source-code">  {{ link.title }}</p>
			<p class="source-code">  {% for sub_link in link.links %}</p>
			<p class="source-code">    {{ sub_link.title }}</p>
			<p class="source-code"><strong class="bold">    {% for sub_sub_link in sub_link.links %}</strong></p>
			<p class="source-code"><strong class="bold">      {{ sub_sub_link.title }}</strong></p>
			<p class="source-code"><strong class="bold">    {% endfor %}</strong></p>
			<p class="source-code">  {% endfor %}</p>
			<p class="source-code">{% endfor %}</p>
			<p>We now have <a id="_idIndexMarker303"/>all the necessary elements to create a working on-hover navigation menu. The only thing left is to add some <strong class="source-inline">HTML</strong> tags and apply the necessary styling to create the on-hover dropdown effect. However, before we proceed with styling, let's try to be a bit more creative.</p>
			<p>Notice that our menu links are just that – links. <em class="italic">But what if we wanted to be more creative by showing an image with every product menu item?</em> For this to work, we would need to identify which menu items are pointing toward the products, which we can do by using the <strong class="source-inline">type</strong> attribute and comparing whether the returned value is equal to the <strong class="source-inline">product_link</strong> string. Since we already know that only the third level of the navigation contains the product menu items, we will only include this feature inside the third <strong class="source-inline">for</strong> loop:</p>
			<p class="source-code">{% assign collection-menu = linklists.indoor-navigation %}</p>
			<p class="source-code">{% for link in collection-menu.links %}</p>
			<p class="source-code">  {{ link.title }}</p>
			<p class="source-code">  {% for sub_link in link.links %}</p>
			<p class="source-code">    {{ sub_link.title }}</p>
			<p class="source-code"><strong class="bold">    </strong>{% for sub_sub_link in sub_link.links %}</p>
			<p class="source-code"><strong class="bold">      {% if sub_sub_link.type == "product_link" %}</strong></p>
			<p class="source-code"><strong class="bold">        &lt;img src="{{ sub_sub_link | img_url: "250x250"}}"/&gt;</strong></p>
			<p class="source-code"><strong class="bold">      {% endif %}</strong></p>
			<p class="source-code"><strong class="bold">      </strong>{{ sub_sub_link.title }}</p>
			<p class="source-code">    {% endfor %}</p>
			<p class="source-code">  {% endfor %}</p>
			<p class="source-code">{% endfor %}</p>
			<p>Now, it makes sense that this should work and that, as a result, we should be able to see four images of our products inside the navigation menu. However, note that <strong class="source-inline">sub_sub_link</strong> is still only a <strong class="source-inline">link</strong> object, and the <strong class="source-inline">link</strong> object does not have an image attached to it. To show the image that's attached to the product, we will have to recover the object of the product that our link is pointing to.</p>
			<p>We can <a id="_idIndexMarker304"/>easily do this by modifying the <strong class="source-inline">sub_sub_link</strong> object inside the <strong class="source-inline">IMG</strong> tag so that it includes the <strong class="source-inline">object</strong> attribute:</p>
			<p class="source-code">{% assign collection-menu = linklists.indoor-navigation %}</p>
			<p class="source-code">{% for link in collection-menu.links %}</p>
			<p class="source-code">  {{ link.title }}</p>
			<p class="source-code">  {% for sub_link in link.links %}</p>
			<p class="source-code">    {{ sub_link.title }}</p>
			<p class="source-code"><strong class="bold">    </strong>{% for sub_sub_link in sub_link.links %}</p>
			<p class="source-code"><strong class="bold">      {% if sub_sub_link.type == "product_link" %}</strong></p>
			<p class="source-code"><strong class="bold">        &lt;img src="{{ sub_sub_link.object </strong>| img_url:<strong class="bold">                 "250x250" }}"/&gt;</strong></p>
			<p class="source-code"><strong class="bold">      {% endif %}</strong></p>
			<p class="source-code"><strong class="bold">      {{ sub_sub_link.title }}</strong></p>
			<p class="source-code"><strong class="bold">    {% endfor %}</strong></p>
			<p class="source-code">  {% endfor %}</p>
			<p class="source-code">{% endfor %}</p>
			<p>With the addition of the <strong class="source-inline">object</strong> attribute, we now have access to the entire product object, including its title, price, images, and all other data. In comparison, <strong class="source-inline">sub_sub_link.object.price</strong> would return precisely the same results as writing <strong class="source-inline">product.price</strong> would, which we used in the previous project to display the prices of our <strong class="source-inline">Custom collection</strong> products.</p>
			<p>The only thing left to do now is provide our code with some HTML format and apply the necessary styling. The HTML formatted code, along with some basic CSS styling, can be found at the following GitHub link, under the name <strong class="source-inline">Custom navigation</strong>: </p>
			<p>https://github.com/PacktPublishing/Shopify-Theme-Customization-with-Liquid/tree/main/Chapter04/Learning%20Projects/Custom%20Navigation.</p>
			<p>This GitHub repository contains two files, each named according to the location where the code should be included.</p>
			<p>While working <a id="_idIndexMarker305"/>on this project, we were able to create a fundamental version of the mega menu, allowing us to output any image attached to our pages easily. While it might not look impressive, the knowledge we have learned from this project has taught us how to create any navigation menu, as well as a custom subcollections page where we can output other collections.</p>
			<p>So far, all our projects have been related to recovering the predefined data from our admin. <em class="italic">However, what if we needed to capture data regarding the customization of a particular product, show the choice on the cart page, and then forward the captured data with the order?</em></p>
			<h2 id="_idParaDest-85"><a id="_idTextAnchor084"/>Product customization</h2>
			<p>For our next project, we will be creating a custom HTML input on the product page, which <a id="_idIndexMarker306"/>will allow us to capture any data that the customer may input and learn how to forward the value of the input, along with the order itself. </p>
			<p>To achieve this functionality, we will be using the <strong class="source-inline">line_item</strong> object. <strong class="source-inline">line_item</strong> represents each item within our cart. We can access the <strong class="source-inline">line_item</strong> object through the <strong class="source-inline">cart</strong> object, followed by the <strong class="source-inline">items</strong> attribute, which will provide us with access to the <strong class="source-inline">line_item</strong> object for each product.</p>
			<p>Before we can use <strong class="source-inline">line_item object</strong> to output the data on our cart page, we will need to create a field to capture this data. Let's start by navigating to our <strong class="source-inline">product.liquid</strong> template and find the opening tag of the <strong class="source-inline">product</strong> form. As we can see, the <strong class="source-inline">product</strong> form tag is not present in this file, but we do have a <strong class="source-inline">section</strong> tag, which, as you may recall from the previous chapter, allows us to render a static section.</p>
			<p>Let's proceed by navigating to the <strong class="source-inline">product-template.liquid</strong> section file. We can access it by hovering over the section tag's name and clicking on the small arrow. Alternatively, we can <a id="_idIndexMarker307"/>find it inside the <strong class="source-inline">Sections</strong> directory. After finding the <strong class="source-inline">product</strong> form tag, we can start creating the customization feature by adding an HTML input tag of the <strong class="source-inline">text</strong> type, which we will be using to capture information related to each specific product. We can add this field at the top of the <strong class="source-inline">product</strong> form tag, just above the first <strong class="source-inline">unless</strong> statement:</p>
			<p class="source-code">{% form 'product', product, class:form_classes, novalidate:   'novalidate', data-product-form: '' %}</p>
			<p class="source-code">            {{ form | payment_terms }}</p>
			<p class="source-code"><strong class="bold">            &lt;input type="text" placeholder="Your Name"/&gt;</strong></p>
			<p class="source-code">            {% unless product.has_only_default_variant %}</p>
			<p>If we try to preview our product page, we will see an input field with <strong class="bold">Your Name</strong> as the placeholder:</p>
			<div>
				<div id="_idContainer048" class="IMG---Figure">
					<img src="Images/Figure_4.05_B17606.jpg" alt="Figure 4.5 – Example of a custom field on the product page&#13;&#10;" width="967" height="524"/>
				</div>
			</div>
			<p class="figure-caption">Figure 4.5 – Example of a custom field on the product page</p>
			<p>However, if we fill in the input, add the product to the cart, and visit our cart page by clicking the <a id="_idIndexMarker308"/>cart icon in the top-right corner, we will notice that we did not capture the data successfully with the product. To save the <strong class="source-inline">line_item</strong> data value, we will need to modify the HTML input by adding the <strong class="source-inline">name</strong> property in <strong class="source-inline">name="properties[Your Name]"</strong> format:</p>
			<p class="source-code">&lt;input type="text"<strong class="bold"> name="properties[Your Name]"</strong> placeholder="Your Name"/&gt;</p>
			<p>The <strong class="source-inline">name</strong> property is a predefined attribute that allows us to capture the <strong class="source-inline">input</strong> element's value, followed by a mandatory keyword, called <strong class="source-inline">properties</strong>, and a pair of square brackets. Any value inside these square brackets – in our case, <strong class="bold">Your Name</strong> – will serve as that property name.</p>
			<p>With the <strong class="source-inline">name</strong> attribute in place, if we fill in the input field, click on the <strong class="bold">Add to Cart</strong> button, and visit the cart page, we will notice that both the <strong class="source-inline">line_item</strong> attribute's name and value were successfully captured and chained to each product.</p>
			<p>When dealing with newer themes, such as the one we are using, this would be the last step in capturing customization for each product. However, for some older themes, which are still quite present today, we would need to write some code that will display the <strong class="source-inline">line_item</strong> properties inside the cart page.</p>
			<p>Before writing this code, we will need to identify where we should add our code. As we mentioned previously, to access the <strong class="source-inline">line_item</strong> object, we will need to use <strong class="source-inline">cart.items</strong> to recover an array of products in our cart, which should already be present in our <strong class="source-inline">cart.liquid</strong> section file: </p>
			<p class="source-code">{% for item in cart.items %}</p>
			<p class="source-code">{% endfor %}</p>
			<p>With the <strong class="source-inline">cart.items</strong> loop, we have gained access to the objects of each product, which, similar to the <strong class="source-inline">product</strong> object, provides us with access to various attributes, such as the <strong class="source-inline">product</strong> object's title, price, and the quantity that we have added to the cart, as well as its properties. </p>
			<p>We can <a id="_idIndexMarker309"/>access the properties of each product by using <strong class="source-inline">item</strong> as our object, followed by the <strong class="source-inline">properties</strong> attribute. However, since we can capture multiple properties for each product, <strong class="source-inline">item.properties</strong> will return an array of data, meaning that we will need to use the <strong class="source-inline">for</strong> tag:</p>
			<p class="source-code"><strong class="bold">{% for property in item.properties %}</strong></p>
			<p class="source-code">  {{ property }}</p>
			<p class="source-code"><strong class="bold">{% endfor %}</strong></p>
			<p>Note that <strong class="source-inline">{{ property }}</strong> is considered an array data type since it contains both the name of the <strong class="source-inline">line_item</strong> property and its value. If we were to use this code to output the <strong class="source-inline">line_item</strong> code on our page, we would end up with both values stuck together. Since using another <strong class="source-inline">for</strong> tag to go over the array that contains two elements would be excessive, we can use the <strong class="source-inline">first</strong> and <strong class="source-inline">last</strong> filters to output the split values:</p>
			<p class="source-code">{% for property in item.properties %}</p>
			<p class="source-code">  &lt;span&gt;{{ property<strong class="bold">.first</strong> }}&lt;/span&gt;:&lt;span&gt;{{ property<strong class="bold">.last</strong>     }}&lt;/span&gt;</p>
			<p class="source-code">{% endfor %}</p>
			<p>The <strong class="source-inline">first</strong> and <strong class="source-inline">last</strong> filters, as their names suggest, allow us to access the first and last element inside an array. However, since we are looking to split our array into two separate elements, it is perfect as it helps us avoid writing another <strong class="source-inline">for</strong> loop. We will learn more about this and other filters in the next chapter.</p>
			<p class="callout-heading">Important note:</p>
			<p class="callout">Adding the same product variant multiple times to the cart with a different <strong class="source-inline">line_item</strong> property value will not override the product we previously added to the cart, nor affect its <strong class="source-inline">line_item</strong> property value. Instead, we will end up with each product positioned on a new line, as if it were a different product.</p>
			<p>The only time when we can include multiple variants of the same product on the same line is if <a id="_idIndexMarker310"/>the product variant contains the same data, the <strong class="source-inline">line_item</strong> property included. Here is an example:</p>
			<div>
				<div id="_idContainer049" class="IMG---Figure">
					<img src="Images/Figure_4.06_B17606.jpg" alt="Figure 4.6 – Example of the line item property chained to different product variants&#13;&#10;" width="821" height="579"/>
				</div>
			</div>
			<p class="figure-caption">Figure 4.6 – Example of the line item property chained to different product variants</p>
			<p>If we were to click the <strong class="bold">CHECK OUT</strong> button, we would notice that the same <strong class="source-inline">line_item</strong> values were visible inside the checkout summary as well. Note that the same <strong class="source-inline">line_item</strong> property will be visible inside the order admin if we complete the purchase through our checkout page.</p>
			<p class="callout-heading">Important note:</p>
			<p class="callout">We can only capture the <strong class="source-inline">line_item</strong> properties through Shopify's default checkout. If we were to complete the payment through any other checkout, such as <strong class="bold">PayPal</strong>, we would not be able to attach the <strong class="source-inline">line_item</strong> properties to our products, and they will not be visible inside the order admin.</p>
			<p>With that, we have learned how to capture custom data for each of our products and display them on the cart and checkout pages. However, sometimes, we will be forced to recover the <strong class="source-inline">line_item</strong> data and visually hide it from both the cart and checkout pages. We can easily hide the <strong class="source-inline">line_item</strong> data from the cart page with some CSS code, <em class="italic">but how are we supposed to modify the code on the checkout page, considering that we do not have access to it?</em></p>
			<p>This is where the underscore character will help us. If we are looking to collect <strong class="source-inline">line_items</strong> and have them visible when we receive the order in our admin, while at the same time visually hiding the <strong class="source-inline">line_items</strong> properties from the checkout page, we would need to modify the <strong class="source-inline">name</strong> property inside the <strong class="source-inline">product.liquid</strong> section file to include the underscore inside the square bracket:</p>
			<p class="source-code">&lt;input type="text" name="properties[<strong class="bold">_Your Name</strong>]" placeholder="Your Name"/&gt;</p>
			<p>Any property <a id="_idIndexMarker311"/>name with the underscore as the first character inside the square bracket will not be visible on the checkout page. However, it will still be visible once we receive the order in our admin.</p>
			<p>Besides allowing us to hide the <strong class="source-inline">line_items</strong> properties from the checkout page automatically, the underscore character also helps us create a more automatic process for hiding the <strong class="source-inline">line_items</strong> property from the cart page, without having to write CSS code for every <strong class="source-inline">line_items</strong> property that we want to hide.</p>
			<p>With the introduction of the underscore character, we now have one uniquely distinctive character that we can use to filter the <strong class="source-inline">line_items</strong> properties we would like to show and which ones we would like to hide.</p>
			<p>Since we are dealing with string-type data, we can use the <strong class="source-inline">truncate</strong> filter, which, as its name suggests, allows <a id="_idIndexMarker312"/>us to truncate a string. The <strong class="source-inline">truncate</strong> filter accepts the following two parameters:</p>
			<ul>
				<li>The first parameter is a required number value, which allows us to set how many characters we expect the <strong class="source-inline">truncate</strong> filter to return.</li>
				<li>The second parameter is an optional parameter, which allows us to set a specific string value we would like to append to each returned string value. Note that if we do not <a id="_idIndexMarker313"/>include the second parameter, by default, the <strong class="source-inline">truncate</strong> filter will append three dots to the end of the string, which will count inside the previous parameter number value's <strong class="source-inline">count</strong>.</li>
			</ul>
			<p>Since we are looking to check whether the <strong class="source-inline">line_items</strong> key value contains the underscore character as the first character in the string, we can apply the <strong class="source-inline">truncate</strong> filter and set the first parameter to <strong class="source-inline">1</strong>. However, we will also need to include the second parameter and set it equal to an empty string to avoid the previously mentioned ellipsis:</p>
			<p class="source-code">{% for property in item.properties %}</p>
			<p class="source-code">  {% assign first_character_in_key = p.first <strong class="bold">| truncate: 1,     ''</strong> %}</p>
			<p class="source-code">  {% unless first_character_in_key == '_' %}</p>
			<p class="source-code">    &lt;span&gt;{{ property.first }}&lt;/span&gt;:&lt;span&gt;{{         property.last }}&lt;/span&gt;</p>
			<p class="source-code">  {% endunless %}</p>
			<p class="source-code">{% endfor %}</p>
			<p>Note that <a id="_idIndexMarker314"/>throughout this project, we have only used a single <strong class="source-inline">text</strong> input type. However, we are free to use any input type at our disposal, including the <strong class="source-inline">date</strong>, <strong class="source-inline">color</strong>, <strong class="source-inline">radio</strong>, and <strong class="source-inline">select</strong> inputs. The only limitation is that we cannot use the <strong class="source-inline">file</strong> upload input type with Ajax. The product <strong class="source-inline">form</strong> tag will also need to include the <strong class="source-inline">enctype="multipart/form-data</strong>" attribute to capture the file upload input value.</p>
			<p>With this project, we have learned how to create a valuable feature that will allow us to create specific customization for each product template, or even each product separately. We can design it as a simple feature with a single input or create an entire form with various inputs to fill in before purchasing a product.</p>
			<p>We can also use the <strong class="bold">Shopify UI Elements</strong> generator to create any number of <strong class="source-inline">line_items</strong> easily and simply paste them inside our product templates. We can find the Shopify <a id="_idIndexMarker315"/>UI Elements generator at https://ui-elements-generator.myshopify.com/pages/line-item-property.</p>
			<p>Let's say that we were looking to save page-specific data for some of the pages in our admin. However, if we <a id="_idIndexMarker316"/>were to navigate to our admin and open a product, collection, or any other page, we would notice that each page contains a predefined number of fields to store data. This is where the metafields objects come to the rescue.</p>
			<h1 id="_idParaDest-86"><a id="_idTextAnchor085"/>Improving the workflow with metafields</h1>
			<p><strong class="bold">Metafields</strong> are global <a id="_idIndexMarker317"/>objects that allow us to store additional data <a id="_idIndexMarker318"/>inside our admin and output it to the storefront. As such, they are both powerful and necessary tools for creating complex designs with unique content.</p>
			<p>Metafields consist of three mandatory elements:</p>
			<ul>
				<li>The <strong class="bold">namespace</strong>, which we <a id="_idIndexMarker319"/>can use to group different metafields, so long as they share the same namespace.</li>
				<li>The <strong class="source-inline">key</strong> attribute, which <a id="_idIndexMarker320"/>allows us to access a specific metafield.</li>
				<li>A <strong class="bold">value</strong> where <a id="_idIndexMarker321"/>we can store an integer, string, or <strong class="source-inline">json_string</strong> data type.</li>
			</ul>
			<p>We can also use a <strong class="source-inline">description</strong> field for the short description of a metafield, which is optional compared to the previous three. </p>
			<p>Metafields, while powerful tools, had quite a disadvantage as they were only available through third-party apps. However, since the Shopify Unite 2021 event, the metafields functionality has become available natively inside the Shopify dashboard, and not only that, but it has received quite the upgrade!</p>
			<p>The <strong class="source-inline">metafields</strong> functionality, while functional, at the time of writing, is only partially available as we can only access the product and variant metafields. The <strong class="source-inline">page</strong>, <strong class="source-inline">blog</strong>, <strong class="source-inline">article</strong>, <strong class="source-inline">collection</strong>, <strong class="source-inline">order</strong>, <strong class="source-inline">customer</strong>, and <strong class="source-inline">shop</strong> metafields are pending to be released. For this reason, we will learn how to handle these metafields through a third-party app and the Shopify dashboard.</p>
			<p>Considering that most of today's themes still rely on third-party apps for their metafields needs, let's start by learning how to utilize a metafields app to create custom content for our pages.</p>
			<h2 id="_idParaDest-87"><a id="_idTextAnchor086"/>Setting up a metafields app</h2>
			<p>For us to use and access metafields objects, we will need to either install an app or a browser <a id="_idIndexMarker322"/>extension that allows us to use this functionality. For this book's purposes, we will proceed by installing an app so that we can familiarize ourselves with that Shopify app market as well:</p>
			<ol>
				<li value="1">To install an app on our store, we need to navigate to our admin and click on <strong class="bold">Apps</strong>, just above <strong class="bold">Sales Channels</strong>. Inside the <strong class="bold">Apps</strong> section, we will be able to see a list of all the apps that we have installed on our store. However, as we currently do not have any, the list is empty. Let's change this by clicking on the <strong class="bold">Shop for apps</strong> button in the top-right corner:<div id="_idContainer050" class="IMG---Figure"><img src="Images/Figure_4.07_B17606.jpg" alt="Figure 4.7 – Example of starting the app install process&#13;&#10;" width="883" height="540"/></div><p class="figure-caption">Figure 4.7 – Example of starting the app install process</p></li>
				<li>Clicking the <strong class="bold">Shop for apps</strong> button will open the Shopify app store inside a new window. Here, we can browse trending apps and search categories for various apps. However, since we know what we are looking for, we will search for the metafields app by typing the keyword <strong class="source-inline">metafields</strong> inside the search field.</li>
				<li>After submitting a search, we will receive a significant number of apps that we can use, and most of them have a free plan available. For our purposes, we will be using the <strong class="bold">Metafields Guru</strong> app. While which app you choose is entirely optional, since <a id="_idIndexMarker323"/>they all offer the same functionality, we advise you to use the same app here as it will be easier to follow up with future development. Upon clicking on the app, you will be redirected to the app window.</li>
				<li>After opening <a id="_idIndexMarker324"/>the app's landing page, we will be able to see more information about the page, which we should always read to check whether the app offers the features that we need. Let's click on the <strong class="bold">Add app</strong> button, which should immediately redirect us to our store and start the app installation process. On the other hand, if we are not, we will need to log in by submitting a store URL inside the popup window and clicking on the <strong class="bold">Log in</strong> button, which will start the app installation process:<div id="_idContainer051" class="IMG---Figure"><img src="Images/Figure_4.08_B17606.jpg" alt="Figure 4.8 – Example of the login popup on the Shopify app store&#13;&#10;" width="707" height="313"/></div><p class="figure-caption">Figure 4.8 – Example of the login popup on the Shopify app store</p></li>
				<li>After starting the installation process, we will see one last window, where we will need to provide the app with requested access to our store. Since we are working on a development store, we can immediately proceed by clicking on the <strong class="bold">Install app</strong> button. However, if we are working on a managed store for a client, it is strongly advised that we never install the app on someone else's store, even if they have asked us to do so. The store owner should be the one to install any necessary app once they know about all the personal information that the app will be collecting. Otherwise, we might be accountable for any possible problems.</li>
			</ol>
			<p>With the <strong class="bold">Metafields Guru</strong> app now installed, we will see the first view within the app, where we <a id="_idIndexMarker325"/>can see all the different types of pages we can create metafields for:</p>
			<div>
				<div id="_idContainer052" class="IMG---Figure">
					<img src="Images/Figure_4.09_B17606.jpg" alt="Figure 4.9 – Different types of pages we can use metafields objects for&#13;&#10;" width="693" height="743"/>
				</div>
			</div>
			<p class="figure-caption">Figure 4.9 – Different types of pages we can use metafields objects for</p>
			<p>As shown in the preceding screenshot, metafields are powerful tools that allow us to customize any section of our store. So, let's begin by creating the metafield for a product page:</p>
			<ol>
				<li value="1">The first thing we need to do is navigate to the <strong class="bold">Product</strong> section of our admin, select any product of our choosing, and click on it.</li>
				<li>After opening <a id="_idIndexMarker326"/>the product page, click on the <strong class="bold">More actions</strong> button in the top-right corner to reveal the <strong class="bold">Edit Metafields</strong> button. Click on it to launch the <strong class="bold">Metafields Guru</strong> app:<div id="_idContainer053" class="IMG---Figure"><img src="Images/Figure_4.10_B17606.jpg" alt="Figure 4.10 – Example of starting the Metafield Guru app for a specific page&#13;&#10;" width="880" height="516"/></div><p class="figure-caption">Figure 4.10 – Example of starting the Metafield Guru app for a specific page</p></li>
				<li>Once inside the app, we will be able to see a list of all the metafields that we have for this specific product, or even the variant if we select the <strong class="bold">Variants</strong> card. However, since we don't have any, the screen is empty. Let's create our first metafield by clicking the <strong class="bold">Create metafield</strong> button.</li>
				<li>Inside this first field, we can select the data type that we will save inside this specific metafield. This is where we will be populating the other three fields with the <strong class="source-inline">key</strong>, <strong class="source-inline">namespace</strong>, and <strong class="source-inline">metafield</strong> values. We can leave the <strong class="source-inline">String</strong> value selected for our example and then, inside the <strong class="source-inline">key</strong> field, type in the word <strong class="source-inline">example</strong>.<p>The <strong class="source-inline">namespace</strong> field already contains the <strong class="source-inline">global</strong> keyword, but we can enter any type <a id="_idIndexMarker327"/>of text in the final field. For example, we will use <strong class="source-inline">Metafields are awesome!</strong>. After filling in all the fields, save your changes by clicking the <strong class="bold">Save</strong> button in the top-right corner:</p></li>
			</ol>
			<div>
				<div id="_idContainer054" class="IMG---Figure">
					<img src="Images/Figure_4.11_B17606.jpg" alt="Figure 4.11 – Example of creating a product metafield&#13;&#10;" width="825" height="677"/>
				</div>
			</div>
			<p class="figure-caption">Figure 4.11 – Example of creating a product metafield</p>
			<p>Now that we have learned how to create a metafield, it is time to learn how to output the previously saved data to our storefront.</p>
			<h2 id="_idParaDest-88"><a id="_idTextAnchor087"/>Rendering the metafields value</h2>
			<p>We can access the <strong class="source-inline">metafields</strong> object through the object of the page we created the metafield for, followed by the <strong class="source-inline">metafields</strong> object, followed by <strong class="source-inline">namespace</strong>, followed by <strong class="source-inline">key</strong>:</p>
			<p class="source-code">{{ product.metafields.global.example }}</p>
			<p>We can enter <a id="_idIndexMarker328"/>the metafield code anywhere where we have access to the <strong class="source-inline">product</strong> object. However, for our purposes, we should place the code inside the <strong class="source-inline">product.liquid</strong> section, just above the <strong class="source-inline">line_item</strong> input that we included in one of our previous projects.</p>
			<p>Now that we have created the product metafield and have the metafield object code in place, all we need to do is test it out. However, remember that we have created a metafield for a specific product only, meaning that we can only preview it on that specific product. If we were to preview the product we created the metafield for, we would see the following metafield string value displayed correctly on our page:</p>
			<p class="source-code">Metafields are awesome!</p>
			<p>With that, we have successfully created and displayed a single metafield value. However, <em class="italic">what if we had a larger number of similar metafields? How would we output all of them?</em> We initially mentioned that we could use the <strong class="source-inline">namespace</strong> attribute to different group metafields together, so long as they share the same <strong class="source-inline">namespace</strong>. Using <strong class="source-inline">namespace</strong> with the <strong class="source-inline">for</strong> tag, we can loop over all the metafields with the same <strong class="source-inline">namespace</strong> and recover their values:</p>
			<p class="source-code">{% for value in product.metafields.global %}</p>
			<p class="source-code">  {{ value }}</p>
			<p class="source-code">{% endfor %}</p>
			<p>Running the previous code would recover any metafields with the <strong class="source-inline">global</strong> keyword as its namespace. However, since we are not using the <strong class="source-inline">key</strong> attribute this time, we will receive the results in array format:</p>
			<p class="source-code">exampleMetafields are awesome!</p>
			<p>To split the array, we will need to use the <strong class="source-inline">first</strong> and <strong class="source-inline">last</strong> filters, as we did previously, to split the <strong class="source-inline">line_item</strong> object on the cart page:</p>
			<p class="source-code">{% for value in product.metafields.global %}</p>
			<p class="source-code">  {{ value | first }}:{{ value | last }}</p>
			<p class="source-code">{% endfor %}</p>
			<p>Using the <strong class="source-inline">first</strong> and <strong class="source-inline">last</strong> filters, we have successfully split the array into two separate elements that we can now use in any way we require.</p>
			<p>With that, we have taken a significant step forward by learning how to output single and multiple metafield values through a third-party app.</p>
			<p>While helpful, adding metafields through a third-party app requires quite a bit of hardcoding, which we can avoid by creating metafields through the Shopify dashboard instead. However, while metafields have received a powerful upgrade, they also have a prerequisite, which we learned about previously. For this reason, we will learn how to set up and handle <a id="_idIndexMarker329"/>metafields through the Shopify dashboard in the following chapters to gain a better understanding of this.</p>
			<p>Using metafields, we can now add well-organized, unique content to each page or even create complex functionalities. For example, with metafields, we can create product accordions, show hand-picked recommended products, and use them to show the expected delivery time for each product/variant and other features. We are only limited by our inspiration.</p>
			<p>The few projects that we have covered by now might look inadequate compared to the number of different types of global objects we have at our disposal. However, the knowledge we have attained through these projects has set us on the right path of understanding objects entirely. Our primary focus was not simply listing objects and their attributes, which we can quickly get from Shopify documentation, but learning how to use different objects and attributes through real-life projects that we will be working on tomorrow as Shopify experts.</p>
			<p>Before we can say that we understand how objects work, we will need to learn more about content objects, without which we would not be able to output any content on our pages.</p>
			<h1 id="_idParaDest-89"><a id="_idTextAnchor088"/>Content and special objects</h1>
			<p>Previously, we learned <a id="_idIndexMarker330"/>how to use global objects to output the data from <a id="_idIndexMarker331"/>our admin on our templates and section files. Now, it is time to learn how to use content objects to output the content of template and sections files, as well as any other assets that are necessary for the Shopify store to operate. We can divide the content objects into three separate groups: <strong class="source-inline">content_for_header</strong>, <strong class="source-inline">content_for_index</strong>, and <strong class="source-inline">content_for_layout</strong>.</p>
			<p>All three types <a id="_idIndexMarker332"/>of content objects have descriptive names that tell <a id="_idIndexMarker333"/>us what they do. However, to ensure that we fully understand their importance, we will provide a small explanation for each.</p>
			<h2 id="_idParaDest-90"><a id="_idTextAnchor089"/>The content_for_header object</h2>
			<p><strong class="source-inline">content_for_header</strong> is a mandatory object located inside the <strong class="source-inline">theme.liquid</strong> layout file – more <a id="_idIndexMarker334"/>specifically, inside the HTML <strong class="source-inline">&lt;head&gt;</strong> tag:</p>
			<p class="source-code">{{ content_for_header }}</p>
			<p>The whole <a id="_idIndexMarker335"/>purpose of this object is to load all the scripts that Shopify requires into the document's header dynamically. Among these scripts, we can find Shopify and Google Analytics scripts, and even the scripts required for some Shopify apps.</p>
			<h2 id="_idParaDest-91"><a id="_idTextAnchor090"/>The content_for_index object</h2>
			<p><strong class="source-inline">content_for_index</strong> is a not mandatory object and it's located within the <strong class="source-inline">index.liquid</strong> template, which we can find inside the <strong class="source-inline">Template</strong> directory:</p>
			<p class="source-code">{{ content_for_index }}</p>
			<p>However, this <a id="_idIndexMarker336"/>object allows us to dynamically <a id="_idIndexMarker337"/>output dynamic sections from the theme editor, making it mandatory. Without it, we would not be able to output any content from our theme editor. </p>
			<h2 id="_idParaDest-92"><a id="_idTextAnchor091"/>The content_for_layout object</h2>
			<p><strong class="source-inline">content_for_layout</strong> is the final mandatory object located inside the <strong class="source-inline">theme.liquid</strong> layout file. This <a id="_idIndexMarker338"/>object allows us to load content <a id="_idIndexMarker339"/>that's been dynamically generated by other templates, such as <strong class="source-inline">index.liquid</strong> and  <strong class="source-inline">collection.liquid</strong>:</p>
			<p class="source-code">{{ content_for_layout }}</p>
			<p>Note that it is not possible to delete the <strong class="source-inline">content_for_header</strong> and <strong class="source-inline">content_for_layout</strong> objects from their respective positions, so we don't need to worry too much about them. However, it is essential to know what each of the content objects does since even though we cannot delete them, we can comment them out, which will create issues with our storefront.</p>
			<p>Finally, besides global and content objects, we also have another set of objects that we can only use under specific circumstances. The only two objects we currently have at our disposal are the <strong class="source-inline">additional_checkout_buttons</strong> and <strong class="source-inline">content_for_additional_checkout_buttons</strong> objects, which will provide us with a way to dynamically generate a set of buttons leading to a third-party provider's checkout page. </p>
			<p>However, note that deciding which buttons will be visible depends on the payment methods that <a id="_idIndexMarker340"/>we have set in the admin, as well <a id="_idIndexMarker341"/>as some other parameters. For example, for the <strong class="bold">Apple Pay</strong> checkout button to be visible, besides enabling the payment method in the admin, the customer will also have to use an Apple device to see it.</p>
			<p>The <strong class="source-inline">additional_checkout_buttons</strong> object allows us to check whether the store offers payment using third-party payment providers, such as PayPal, Apple, and others. Suppose we have enabled a payment gateway to some third-party payment providers. The <strong class="source-inline">additional_checkout_buttons</strong> object, in combination with an <strong class="source-inline">if</strong> statement, will return <strong class="source-inline">true</strong>, which will allow us to use our next special object; that is, <strong class="source-inline">content_for_additional_checkout_buttons</strong>.</p>
			<p>After confirming that we have enabled these payment methods with third parties, we can use the <strong class="source-inline">content_for_additional_checkout_buttons</strong> object to generate the buttons for those payment providers:</p>
			<p class="source-code">{% if additional_checkout_buttons %}</p>
			<p class="source-code">  {{ content_for_additional_checkout_buttons }}</p>
			<p class="source-code">{% endif %}</p>
			<p>While the placement of the code is entirely optional, it is usually placed on the cart page, next to the default <strong class="bold">Checkout</strong> button.</p>
			<h1 id="_idParaDest-93"><a id="_idTextAnchor092"/>Summary</h1>
			<p>In this chapter, we learned about different types of objects while considering various projects. Within our first project, <strong class="source-inline">Custom collection</strong>, we learned how to access single-valued attributes within the <strong class="source-inline">product</strong> object by creating a custom collection feature with a fully functional product form. The second project, <strong class="source-inline">Custom navigation</strong>, taught us how to access and handle objects whose attributes return an array. Working through the <strong class="source-inline">Product Customization</strong> project, we understood how to capture multiple data types, chain them with the selected variant, and output the same data on both the cart and checkout pages.</p>
			<p>Besides working on different projects, we also had the pleasure of learning how to install new apps from the store and how to use a third-party app to create additional input fields within our admin, which gave us access to <strong class="source-inline">metafields</strong> objects.</p>
			<p>Finally, we learned about the different types of content and special objects, why some are mandatory, where we can find them, and how we can use some of them to connect our store to various payment providers outside Shopify.</p>
			<p>The knowledge that we have attained through this chapter will be especially helpful in the next chapter, where we will learn more about the filters that we have been referencing through our projects.</p>
			<h1 id="_idParaDest-94"><a id="_idTextAnchor093"/>Questions</h1>
			<ol>
				<li value="1">What are we missing in the following block of code to make <strong class="source-inline">form</strong> functional?<p class="source-code">{% form "product", product %}</p><p class="source-code">  &lt;input type="hidden" value="{{    product.first_available_variant.id }}" /&gt;</p><p class="source-code">    &lt;input type="submit" value="Add to Cart"/&gt;</p><p class="source-code">{% endform %}</p></li>
				<li>How can we get access to the <strong class="source-inline">product</strong> object through a link defined in the admin navigation?</li>
				<li>What are the two approaches to accessing single and multiple <strong class="source-inline">metafield</strong> objects?</li>
				<li>What adjustment do we need to make to the input element if we were looking to capture the <strong class="source-inline">line_item</strong> value and hide it on the checkout page?<p class="source-code">&lt;input type="text" name="properties[Your Name]" placeholder="Your Name"/&gt;</p></li>
			</ol>
			<h1 id="_idParaDest-95"><a id="_idTextAnchor094"/>Practice makes perfect</h1>
			<p>In the previous chapter, we worked together through various projects and implementations. However, we can only gain a proper understanding by working on the projects ourselves and forcing ourselves to make that next step. So far, we haven't completed any personal projects as we were still learning the basics. However, with objects behind us, we are now set to start creating our own solutions.</p>
			<p>The few mini-projects we will cover here will help us solidify some of our already attained knowledge from the previous chapters. It will also push our limits by forcing us to think outside of the box and find solutions for the problems that we haven't faced so far.</p>
			<p>Each project will contain detailed information about what we need to do to help us achieve the results.</p>
			<p>We recommend working on each project independently from the previous chapters since this will ensure that we have truly understood what we have learned so far.</p>
			<p>No single project has either a correct or incorrect solution. However, if by any chance we get stuck, we can always consult the project solution at the end of this book.</p>
			<h2 id="_idParaDest-96"><a id="_idTextAnchor095"/>Project 1</h2>
			<p>For our first project, we will be creating a custom collection on a general page. However, the difference between this project and the one we worked on previously is that this custom collection will be a dynamic and reusable code block. Depending on the page name, we should see different products in the featured collection.</p>
			<p>Here are the steps for the assets:</p>
			<ol>
				<li value="1">Create a new page template called <strong class="source-inline">featured-collection.liquid</strong>.</li>
				<li>Create a new page, name it similarly to one of the collection pages on our store, and assign it the new page template that we created previously.</li>
				<li>Create the new menu item inside the current main menu navigation, called <strong class="source-inline">Projects</strong>, and add the newly created page as a nested menu inside the <strong class="source-inline">Projects</strong> menu item.</li>
				<li>Create a new snippet file named <strong class="source-inline">custom-collection</strong>.</li>
			</ol>
			<p>Here are the assignment steps:</p>
			<ol>
				<li value="1">Include the <strong class="source-inline">custom-collection</strong> snippet inside <strong class="source-inline">featured-collection.liquid</strong> with <strong class="source-inline">collection</strong> as a parameter. Since the page shares a name that's similar to our collections', we should use the page handle to create the <strong class="source-inline">collection</strong> object.</li>
				<li>Using the <strong class="source-inline">collection</strong> object that we passed previously, create a custom collection using the <strong class="source-inline">for</strong> tag to display no more than four products.</li>
				<li>The products should contain an image, title, vendor, regular price, comparing price visible, and a working product form.</li>
				<li>If a product has more than one variant, include a dropdown so that we can select the exact variant we are looking to select.</li>
				<li>After submitting the form, return us to the same page we were previously on.</li>
				<li>Once complete, any page with <strong class="source-inline">featured-collection.liquid</strong> assigned as its template should display different types of products based on the page name; for example, Indoor or Outdoor.</li>
			</ol>
			<h2 id="_idParaDest-97"><a id="_idTextAnchor096"/>Project 2</h2>
			<p>For our second project, we will be creating a subcollection template page where we will be able to output different collection pages. The code that we will create, similar to the previous project, should be reusable. We should receive different results based on the name of the page we have assigned the template to, and the collections that have been assigned to the navigation menu with the same name.</p>
			<p>Here are the steps for the assets:</p>
			<ol>
				<li value="1">Create a new page template called <strong class="source-inline">page-subcollection.liquid</strong>.</li>
				<li>Create a new page and assign it to the new page template that we created previously.</li>
				<li>Create the new navigation menu and give it the same name we gave the page that we created previously.</li>
				<li>Inside the new navigation menu, include no less than six collection menu items.</li>
				<li>Create a new snippet file called <strong class="source-inline">custom-subcollection</strong>.</li>
			</ol>
			<p>Here are the assignment steps:</p>
			<ol>
				<li value="1">Include the <strong class="source-inline">custom-subcollection</strong> snippet inside <strong class="source-inline">page-subcollection.liquid</strong> with <strong class="source-inline">subcollection</strong> as a parameter. Since the page shares a name that's similar to our navigation menu, we should use the page handle to create the <strong class="source-inline">subcollection</strong> object.</li>
				<li>Using the <strong class="source-inline">subcollection</strong> object that we passed previously, use a <strong class="source-inline">for</strong> tag to create a list of all the collection pages inside the specific navigation menu.</li>
				<li>The collection list should contain an image and a title.</li>
				<li>If the collection does not have the image assigned to it, we should take the image of the first product inside that collection and show it as the collection image.</li>
				<li>Once complete, any page with <strong class="source-inline">custom-subcollection.liquid</strong> assigned as its template should display different results based on its name, as well as the collection that was assigned to the navigation menu with the same name.</li>
			</ol>
		</div>
	</div></body></html>