- en: Chapter 6. Plugins
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we will take a look at a feature of Magento called **plugins**.
    Before we start with plugins, we first need to understand the term interception
    because the two terms are used somewhat interchangeably when dealing with Magento.
  prefs: []
  type: TYPE_NORMAL
- en: '**Interception** is a software design pattern that is used when we want to
    insert code dynamically without necessarily changing the original class behavior.
    This works by dynamically inserting code between the calling code and the target
    object.'
  prefs: []
  type: TYPE_NORMAL
- en: The interception pattern in Magento is implemented via plugins. They provide
    the before, after, and around listeners, which help us extend the observed method
    behavior.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Creating a plugin
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using the `before` listener
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using the `after` listener
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using the `around` listener
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The plugin sort order
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Before we start creating a plugin, it is worth noting their limitations. Plugins
    cannot be created for just any class or method, as they do not work for the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Final classes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Final methods
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The classes that are created without a dependency injection
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's go ahead and create a plugin using a simple module called `Foggyline_Plugged`.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a plugin
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Start by creating the `app/code/Foggyline/Plugged/registration.php` file with
    partial content, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, create the `app/code/Foggyline/Plugged/etc/module.xml` file with partial
    content, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The preceding file is simply a new module declaration with the dependency set
    against the `Magento_Catalog` module, as we will be observing its class. We will
    not go into the details of module declaration right now, as that will be covered
    later in the following chapters.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, create the `app/code/Foggyline/Plugged/etc/di.xml` file with partial content,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Plugins are defined within the module `di.xml` file. To define a plugin, by
    using the `type` element and its `name` attribute, we first map the class that
    we want to observe. In this case, we are observing the `Magento\Catalog\Block\Product\AbstractProduct`
    class. Note that even though the file and class name imply an abstract type of
    class, the `AbstractProduct` class is not abstract.
  prefs: []
  type: TYPE_NORMAL
- en: In the `type` element, we then define one or more plugins using the `plugin`
    element.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `plugin` element has the following four attributes assigned to it:'
  prefs: []
  type: TYPE_NORMAL
- en: '`name`: Using this attribute, you can provide a unique and recognizable name
    value that is specific to the plugin'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`sortOrder`: This attribute determines the order of execution when multiple
    plugins are observing the same method'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`disabled`: The default value of this attribute is set to `false`, but if it
    is set to `true`, it will disable the plugin'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`type`: This attribute points to the class that we will be using to implement
    the `before`, `after`, or `around` listener'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'After doing this, create the `app/code/Foggyline/Plugged/Block/Catalog/Product/AbstractProductPlugin1.php`
    file with partial content, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'As per the type definition in the `di.xml` file, the plugin observes the `Magento\Catalog\Block\Product\AbstractProduct`
    class, and this class has a method called `getAddToCartUrl`, which is defined
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'The `AbstractProductPlugin1` class does not have to be extended from another
    class for the plugin to work. We define the `before`, `after` and `around` listeners
    for the `getAddToCartUrl` method by using the naming convention, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: We will go into the details of each listener later. Right now we need to finish
    the module by creating the `AbstractProductPlugin2.php` and `AbstractProductPlugin3.php`
    files as a copy of `AbstractProductPlugin1.php` and along with that, simply changing
    all the number values within their code from `1` to `2` or `3`.
  prefs: []
  type: TYPE_NORMAL
- en: It's a good practice to organize the listeners into folders matching the structure
    of the observed class location. For example, if a module is called `Foggyline_Plugged`
    and we are observing the method in the `Magento\Catalog\Block\Product\AbstractProduct`
    class, we should consider putting the plugin class into the `Foggyline/Plugged/Block/Catalog/Product/AbstractProductPlugin.php`
    file. This is a not a requirement. Rather, it is a nice convention for other developers
    to easily manage the code.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once the module is in place, we need to execute the following commands on the
    console:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: This will make the module visible to Magento.
  prefs: []
  type: TYPE_NORMAL
- en: If we now open the storefront in a browser for a category page, we will see
    the results of all the `var_dump` function calls.
  prefs: []
  type: TYPE_NORMAL
- en: Let's go ahead and take a look at each and every listener method in detail.
  prefs: []
  type: TYPE_NORMAL
- en: Using the before listener
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `before` listeners are used when we want to change the arguments of an original
    method or add some behavior before an original method is called.
  prefs: []
  type: TYPE_NORMAL
- en: Looking back at the `beforeGetAddToCartUrl` listener method definition, you
    will see that it has three properties assigned in sequence—`$subject`, `$product`,
    and `$additional`.
  prefs: []
  type: TYPE_NORMAL
- en: With the `before` method listener, the first property is always the `$subject`
    property, which contains the instance of the object type being observed. Properties
    following the `$subject` property match the properties of the observed `getAddToCartUrl`
    method in a sequential order.
  prefs: []
  type: TYPE_NORMAL
- en: 'This simple rule used for transformation is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: The `before` listener methods do not need to have a return value.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we run `get_class($subject)` in the `beforeGetAddToCartUrl` listener method
    that we previously saw, we will have the following result:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: What this shows is that even though we are observing the `AbstractProduct` class,
    the `$subject` property is not directly of that type. Rather, it is of the `ListProduct\Interceptor`
    type. This is something that you should keep in mind during development.
  prefs: []
  type: TYPE_NORMAL
- en: Using the after listener
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `after` listeners are used when we want to change the values returned by
    an original method or add some behavior after an original method is called.
  prefs: []
  type: TYPE_NORMAL
- en: Looking back at the `afterGetAddToCartUrl` listener method definition, you will
    see that it has only one `$subject` property assigned.
  prefs: []
  type: TYPE_NORMAL
- en: With the `after` method listener, the first and only property is always the
    `$subject` property, which contains the instance of the object type being observed
    and not the return value of the observed method.
  prefs: []
  type: TYPE_NORMAL
- en: 'This simple rule used for transformation is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: The `after` listener methods do not need to have a return value.
  prefs: []
  type: TYPE_NORMAL
- en: Like the `before` interceptor method, the `$subject` property in this case is
    not directly of the `AbstractProduct` type. Rather, it is of the parent `ListProduct\Interceptor`
    type.
  prefs: []
  type: TYPE_NORMAL
- en: Using the around listener
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `around` listeners are used when we want to change both the arguments and
    the returned values of an original method or add some behavior before and after
    an original method is called.
  prefs: []
  type: TYPE_NORMAL
- en: Looking back at the `aroundGetAddToCartUrl` listener method definition, you
    will see that it has four properties assigned in sequence—`$subject`, `$proceed`,
    `$product`, and `$additional`.
  prefs: []
  type: TYPE_NORMAL
- en: With the `after` method listener, the first property is always the `$subject`
    property, which contains the instance of the object type being observed and not
    the return value of the observed method. The second property is always the `$proceed`
    property of `\Closure`. The properties following the `$subject` and `$proceed`
    match the properties of the observed `getAddToCartUrl` method in the sequential
    order too.
  prefs: []
  type: TYPE_NORMAL
- en: 'This simple rule used for transformation is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'The `around` listener methods must have a return value. The return value is
    formed in such way that the parameters following the `$closure` parameter in the
    `around` listener method definition are passed to the `$closure` function call
    in a sequential order, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: The plugin sort order
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Looking back, when we defined a plugin in the `di.xml` file, one of the attributes
    that we set for every plugin definition was `sortOrder`. It was set to `100`,
    `200` to `300` for `foggyPlugin1`, `foggyPlugin2` and `foggyPlugin3` respectively.
  prefs: []
  type: TYPE_NORMAL
- en: 'The flow of the code execution for the preceding plugins is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Plugin1 - beforeGetAddToCartUrl`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Plugin1 - aroundGetAddToCartUrl`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Plugin2 - beforeGetAddToCartUrl`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Plugin2 - aroundGetAddToCartUrl`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Plugin3 - beforeGetAddToCartUrl`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Plugin3 - aroundGetAddToCartUrl`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Plugin3 - afterGetAddToCartUrl`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Plugin2 - afterGetAddToCartUrl`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Plugin1 - afterGetAddToCartUrl`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In other words, if multiple plugins are listening to the same method, the following
    execution order is used:'
  prefs: []
  type: TYPE_NORMAL
- en: The `before` plugin functions with the lowest `sortOrder` value
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `around` plugin functions with the lowest `sortOrder` value
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `before` plugin functions following the `sortOrder` value from the lowest
    to the highest
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `around` plugin functions following the `sortOrder` value from the lowest
    to the highest
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `after` plugin functions with the highest `sortOrder` value
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `after` plugin functions following the `sortOrder` value from the highest
    to the lowest
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Special care needs to be taken when it comes to the `around` listener, as it
    is the only listener that needs to return a value. If we omit the return value,
    we risk breaking the execution flow in such a way that the other around plugins
    for the same method won't be executed.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we had a look at a powerful feature of Magento called plugins.
    We created a small module with three plugins; each plugin had a different sort
    order. This enabled us to trace the execution flow of multiple plugins that observe
    the same method. We explored in detail the `before`, `after`, and `around` listener
    methods, while having a strong emphasis on the parameter order. The finalized
    module used in this chapter can be found at [https://github.com/ajzele/B05032-Foggyline_Plugged](https://github.com/ajzele/B05032-Foggyline_Plugged).
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we are going to dive deep into backend development.
  prefs: []
  type: TYPE_NORMAL
