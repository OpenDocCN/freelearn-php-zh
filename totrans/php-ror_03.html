<html><head></head><body>
<div id="_idContainer021">
<h1 class="chapter-number" id="_idParaDest-36"><a id="_idTextAnchor037"/><span class="koboSpan" id="kobo.1.1">3</span></h1>
<h1 id="_idParaDest-37"><a id="_idTextAnchor038"/><span class="koboSpan" id="kobo.2.1">Comparing Basic Ruby Syntax to PHP</span></h1>
<p><span class="koboSpan" id="kobo.3.1">Running scripts in PHP and Ruby is similar, though each language has its peculiarities. </span><span class="koboSpan" id="kobo.3.2">Similarly, both Ruby’s and PHP’s syntax can be strangely similar at times, as we saw in </span><a href="B19230_01.xhtml#_idTextAnchor015"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.4.1">Chapter 1</span></em></span></a><span class="koboSpan" id="kobo.5.1">. </span><span class="koboSpan" id="kobo.5.2">However, if we are serious about becoming Ruby programmers, we will need to learn both the differences and the enhancements that Ruby brings to </span><span class="No-Break"><span class="koboSpan" id="kobo.6.1">the table.</span></span></p>
<p><span class="koboSpan" id="kobo.7.1">Let’s embark on this journey and start creating, executing, and debugging our own Ruby scripts with the resources that we already have from knowing PHP, and see Ruby’s language improvements over other languages. </span><span class="koboSpan" id="kobo.7.2">We’ll not only think in Ruby but program in “the Ruby </span><span class="No-Break"><span class="koboSpan" id="kobo.8.1">way” too.</span></span></p>
<p><span class="koboSpan" id="kobo.9.1">So, in this chapter, we will cover the </span><span class="No-Break"><span class="koboSpan" id="kobo.10.1">following topics:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.11.1">Running Ruby code from the </span><span class="No-Break"><span class="koboSpan" id="kobo.12.1">command line</span></span></li>
<li><span class="koboSpan" id="kobo.13.1">Exploring types </span><span class="No-Break"><span class="koboSpan" id="kobo.14.1">of variables</span></span></li>
<li><span class="koboSpan" id="kobo.15.1">Using </span><span class="No-Break"><span class="koboSpan" id="kobo.16.1">conditional statements</span></span></li>
<li><span class="koboSpan" id="kobo.17.1">Repeating code </span><span class="No-Break"><span class="koboSpan" id="kobo.18.1">with loops</span></span></li>
<li><span class="koboSpan" id="kobo.19.1">Using Ruby </span><span class="No-Break"><span class="koboSpan" id="kobo.20.1">language enhancements</span></span></li>
</ul>
<h1 id="_idParaDest-38"><a id="_idTextAnchor039"/><span class="koboSpan" id="kobo.21.1">Technical requirements</span></h1>
<p><span class="koboSpan" id="kobo.22.1">To follow along with this chapter, we will need </span><span class="No-Break"><span class="koboSpan" id="kobo.23.1">the following:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.24.1">Any IDE to view/edit code (for example, SublimeText, Visual Studio Code, Notepad++ Vim, Emacs, and </span><span class="No-Break"><span class="koboSpan" id="kobo.25.1">so on)</span></span></li>
<li><span class="koboSpan" id="kobo.26.1">For macOS users, you will also need to have Xcode Command Line </span><span class="No-Break"><span class="koboSpan" id="kobo.27.1">Tools installed</span></span></li>
<li><span class="koboSpan" id="kobo.28.1">Ruby version 2.6 or later will need to be installed and ready </span><span class="No-Break"><span class="koboSpan" id="kobo.29.1">to use</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.30.1">The code presented in this chapter is available </span><span class="No-Break"><span class="koboSpan" id="kobo.31.1">at </span></span><a href="https://github.com/PacktPublishing/From-PHP-to-Ruby-on-Rails/"><span class="No-Break"><span class="koboSpan" id="kobo.32.1">https://github.com/PacktPublishing/From-PHP-to-Ruby-on-Rails/</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.33.1">.</span></span></p>
<h1 id="_idParaDest-39"><a id="_idTextAnchor040"/><span class="koboSpan" id="kobo.34.1">Running Ruby code from the command line</span></h1>
<p><span class="koboSpan" id="kobo.35.1">One of the first things we need</span><a id="_idIndexMarker068"/><span class="koboSpan" id="kobo.36.1"> to learn about when picking up Ruby is how to run our code and view the output directly on our screen. </span><span class="koboSpan" id="kobo.36.2">There are different ways to achieve this, but we will be doing so in the simplest of ways. </span><span class="koboSpan" id="kobo.36.3">While there are various ways to load code from the command line, we’ll start with one </span><span class="No-Break"><span class="koboSpan" id="kobo.37.1">single file.</span></span></p>
<h2 id="_idParaDest-40"><a id="_idTextAnchor041"/><span class="koboSpan" id="kobo.38.1">Running a simple code file</span></h2>
<p><span class="koboSpan" id="kobo.39.1">As I mentioned in the introduction, running</span><a id="_idIndexMarker069"/><span class="koboSpan" id="kobo.40.1"> scripts in Ruby is simple</span><a id="_idIndexMarker070"/><span class="koboSpan" id="kobo.41.1"> and easy. </span><span class="koboSpan" id="kobo.41.2">Similar to running scripts in PHP, we can create a file, add Ruby code to it, and execute it with Ruby. </span><span class="koboSpan" id="kobo.41.3">Running or executing code simply means that we will have Ruby read (also referred to as parse) through our source code, and then</span><a id="_idIndexMarker071"/><span class="koboSpan" id="kobo.42.1"> translate it into a language that the computer can understand </span><span class="No-Break"><span class="koboSpan" id="kobo.43.1">and process.</span></span></p>
<p><span class="koboSpan" id="kobo.44.1">Let’s start with a simple example by creating a folder called </span><strong class="source-inline"><span class="koboSpan" id="kobo.45.1">ruby_syntax</span></strong><span class="koboSpan" id="kobo.46.1"> on our desktop. </span><span class="koboSpan" id="kobo.46.2">In that folder, create our source code file, which is called </span><strong class="source-inline"><span class="koboSpan" id="kobo.47.1">running_ruby.rb</span></strong><span class="koboSpan" id="kobo.48.1">, with your IDE </span><span class="No-Break"><span class="koboSpan" id="kobo.49.1">of choice.</span></span></p>
<p><span class="koboSpan" id="kobo.50.1">Now, let’s add some code to </span><span class="No-Break"><span class="koboSpan" id="kobo.51.1">our file:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.52.1">
# running_ruby.rb
print('I am running a Ruby script');</span></pre> <p><span class="koboSpan" id="kobo.53.1">Now, let’s open a shell and go to the same folder we </span><span class="No-Break"><span class="koboSpan" id="kobo.54.1">just created:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.55.1">
cd path-to-our-desktop/ruby_syntax</span></pre> <p><span class="koboSpan" id="kobo.56.1">Once we are in this folder in our shell, we can run the script we just created </span><span class="No-Break"><span class="koboSpan" id="kobo.57.1">with Ruby:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.58.1">
ruby running_ruby.rb</span></pre> <p><span class="koboSpan" id="kobo.59.1">This should output </span><span class="No-Break"><span class="koboSpan" id="kobo.60.1">the following:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.61.1">
I am running a Ruby script</span></pre> <p><span class="koboSpan" id="kobo.62.1">As I mentioned in </span><a href="B19230_01.xhtml#_idTextAnchor015"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.63.1">Chapter 1</span></em></span></a><span class="koboSpan" id="kobo.64.1">, this syntax is strangely familiar to the PHP one. </span><span class="koboSpan" id="kobo.64.2">If we compared the two, we would have the following </span><span class="No-Break"><span class="koboSpan" id="kobo.65.1">PHP equivalent:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.66.1">
&lt;?php # running_php.php
print('I am running a PHP script');</span></pre> <p><span class="koboSpan" id="kobo.67.1">We would then run the example in the same way as the Ruby one, but with the PHP executable instead, </span><span class="No-Break"><span class="koboSpan" id="kobo.68.1">like so:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.69.1">
php running_php.php</span></pre> <p><span class="koboSpan" id="kobo.70.1">The outcome would be the same as the Ruby one but with the string </span><span class="No-Break"><span class="koboSpan" id="kobo.71.1">for PHP.</span></span></p>
<p><span class="koboSpan" id="kobo.72.1">Back to the Ruby example, and just like we did to the examples in </span><a href="B19230_01.xhtml#_idTextAnchor015"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.73.1">Chapter 1</span></em></span></a><span class="koboSpan" id="kobo.74.1">, let’s modify our Ruby code so that it’s slightly </span><span class="No-Break"><span class="koboSpan" id="kobo.75.1">more readable:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.76.1">
# running_ruby.rb
print 'I am running a Ruby script without parenthesis'</span></pre> <p><span class="koboSpan" id="kobo.77.1">Even though the syntax is slightly similar, the outcome is the same, with the advantage that it reads more naturally. </span><span class="koboSpan" id="kobo.77.2">While </span><strong class="source-inline"><span class="koboSpan" id="kobo.78.1">print</span></strong><span class="koboSpan" id="kobo.79.1"> is available</span><a id="_idIndexMarker072"/><span class="koboSpan" id="kobo.80.1"> in Ruby for outputting text for the user, you may</span><a id="_idIndexMarker073"/><span class="koboSpan" id="kobo.81.1"> also use </span><strong class="source-inline"><span class="koboSpan" id="kobo.82.1">puts</span></strong><span class="koboSpan" id="kobo.83.1"> or simply </span><strong class="source-inline"><span class="koboSpan" id="kobo.84.1">p</span></strong><span class="koboSpan" id="kobo.85.1">. </span><span class="koboSpan" id="kobo.85.2">You’ll see this very often </span><span class="No-Break"><span class="koboSpan" id="kobo.86.1">in Ruby.</span></span></p>
<h2 id="_idParaDest-41"><a id="_idTextAnchor042"/><span class="koboSpan" id="kobo.87.1">Loading a source code file with the load method</span></h2>
<p><span class="koboSpan" id="kobo.88.1">At this point, you know how to execute Ruby code</span><a id="_idIndexMarker074"/><span class="koboSpan" id="kobo.89.1"> in a single file. </span><span class="koboSpan" id="kobo.89.2">However, as our source code grows, it will become</span><a id="_idIndexMarker075"/><span class="koboSpan" id="kobo.90.1"> impractical to have a single source code file. </span><span class="koboSpan" id="kobo.90.2">That is why Ruby allows us to load source code from other </span><span class="No-Break"><span class="koboSpan" id="kobo.91.1">source files.</span></span></p>
<p><span class="koboSpan" id="kobo.92.1">Let’s see how to do this. </span><span class="koboSpan" id="kobo.92.2">First, we must create a file to be loaded – in this example, the file is called </span><strong class="source-inline"><span class="koboSpan" id="kobo.93.1">my_library.rb</span></strong><span class="koboSpan" id="kobo.94.1"> and contains some </span><span class="No-Break"><span class="koboSpan" id="kobo.95.1">simple content:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.96.1">
# my_library.rb
print 'I am a library.'</span></pre> <p><span class="koboSpan" id="kobo.97.1">While we now have runnable Ruby code, we are not going to run </span><strong class="source-inline"><span class="koboSpan" id="kobo.98.1">my_library.rb</span></strong><span class="koboSpan" id="kobo.99.1"> directly, but rather let another script load its code. </span><span class="koboSpan" id="kobo.99.2">This is where the </span><strong class="source-inline"><span class="koboSpan" id="kobo.100.1">load</span></strong><span class="koboSpan" id="kobo.101.1"> method comes in. </span><span class="koboSpan" id="kobo.101.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.102.1">load</span></strong><span class="koboSpan" id="kobo.103.1"> method takes a filename and its code and includes it in our execution. </span><span class="koboSpan" id="kobo.103.2">So, let’s create another file called </span><strong class="source-inline"><span class="koboSpan" id="kobo.104.1">load_library.rb</span></strong><span class="koboSpan" id="kobo.105.1"> with </span><span class="No-Break"><span class="koboSpan" id="kobo.106.1">this content:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.107.1">
# load_library.rb
load 'my_library.rb'</span></pre> <p><span class="koboSpan" id="kobo.108.1">Now, run the code with the </span><span class="No-Break"><span class="koboSpan" id="kobo.109.1">following command:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.110.1">
ruby load_library.rb</span></pre> <p><span class="koboSpan" id="kobo.111.1">The output of the script should be </span><span class="No-Break"><span class="koboSpan" id="kobo.112.1">as follows:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.113.1">
I am a library.</span></pre> <p><span class="koboSpan" id="kobo.114.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.115.1">load_library.rb</span></strong><span class="koboSpan" id="kobo.116.1"> file injects (or as its name implies, </span><em class="italic"><span class="koboSpan" id="kobo.117.1">loads</span></em><span class="koboSpan" id="kobo.118.1">) the code from the </span><strong class="source-inline"><span class="koboSpan" id="kobo.119.1">my_library.rb</span></strong><span class="koboSpan" id="kobo.120.1"> file and executes it. </span><span class="koboSpan" id="kobo.120.2">This way, we can easily separate large chunks of code into smaller, more </span><span class="No-Break"><span class="koboSpan" id="kobo.121.1">readable ones.</span></span></p>
<p><span class="koboSpan" id="kobo.122.1">Now, what happens</span><a id="_idIndexMarker076"/><span class="koboSpan" id="kobo.123.1"> if we call the </span><strong class="source-inline"><span class="koboSpan" id="kobo.124.1">load</span></strong><span class="koboSpan" id="kobo.125.1"> method</span><a id="_idIndexMarker077"/><span class="koboSpan" id="kobo.126.1"> more than once in Ruby? </span><span class="koboSpan" id="kobo.126.2">Well, let’s try </span><span class="No-Break"><span class="koboSpan" id="kobo.127.1">it out:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.128.1">
# load_library.rb
load 'my_library.rb'
load 'my_library.rb'</span></pre> <p><span class="koboSpan" id="kobo.129.1">After running the command again, the output is </span><span class="No-Break"><span class="koboSpan" id="kobo.130.1">as follows:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.131.1">
I am a library. </span><span class="koboSpan" id="kobo.131.2">I am a library.</span></pre> <p><span class="koboSpan" id="kobo.132.1">From this behavior, we can infer that every time we load a file, its code will be executed, which is very useful when our files change multiple times during their execution – in these cases, the code is said to be </span><span class="No-Break"><span class="koboSpan" id="kobo.133.1">dynamically changing.</span></span></p>
<p><span class="koboSpan" id="kobo.134.1">As an example of dynamically changing code, let’s say we needed a script to include new parts of the code, but could not be stopped for doing so. </span><span class="koboSpan" id="kobo.134.2">In a case such as this, we would need the code to be constantly refreshed, and this is where the </span><strong class="source-inline"><span class="koboSpan" id="kobo.135.1">load</span></strong><span class="koboSpan" id="kobo.136.1"> method comes in. </span><span class="koboSpan" id="kobo.136.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.137.1">load</span></strong><span class="koboSpan" id="kobo.138.1"> method refreshes the code every single time it comes across the file that’s changing – that is, it renews our code every time the Ruby engine detects a change. </span><span class="koboSpan" id="kobo.138.2">Otherwise, we would have to stop the execution every time we needed a new change in </span><span class="No-Break"><span class="koboSpan" id="kobo.139.1">our code.</span></span></p>
<p><span class="koboSpan" id="kobo.140.1">Ruby’s </span><strong class="source-inline"><span class="koboSpan" id="kobo.141.1">load</span></strong><span class="koboSpan" id="kobo.142.1"> method is similar to PHP’s </span><strong class="source-inline"><span class="koboSpan" id="kobo.143.1">include</span></strong><span class="koboSpan" id="kobo.144.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.145.1">require</span></strong><span class="koboSpan" id="kobo.146.1"> functions. </span><span class="koboSpan" id="kobo.146.2">However, Ruby’s </span><strong class="source-inline"><span class="koboSpan" id="kobo.147.1">require</span></strong><span class="koboSpan" id="kobo.148.1"> method</span><a id="_idIndexMarker078"/><span class="koboSpan" id="kobo.149.1"> is slightly different</span><a id="_idIndexMarker079"/><span class="koboSpan" id="kobo.150.1"> than the one in PHP, as we’ll </span><span class="No-Break"><span class="koboSpan" id="kobo.151.1">see next.</span></span></p>
<h2 id="_idParaDest-42"><a id="_idTextAnchor043"/><span class="koboSpan" id="kobo.152.1">Loading a source code file with the require method</span></h2>
<p><span class="koboSpan" id="kobo.153.1">In contrast to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.154.1">load</span></strong><span class="koboSpan" id="kobo.155.1"> method, sometimes, we just need</span><a id="_idIndexMarker080"/><span class="koboSpan" id="kobo.156.1"> the code to be executed only once, and for that, we can</span><a id="_idIndexMarker081"/><span class="koboSpan" id="kobo.157.1"> use the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.158.1">require</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.159.1"> method.</span></span></p>
<p><span class="koboSpan" id="kobo.160.1">Let’s see it in action by creating another file called </span><strong class="source-inline"><span class="koboSpan" id="kobo.161.1">require_library.rb</span></strong><span class="koboSpan" id="kobo.162.1"> with the </span><span class="No-Break"><span class="koboSpan" id="kobo.163.1">following content:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.164.1">
# require_library.rb
require './my_library.rb'</span></pre> <p><span class="koboSpan" id="kobo.165.1">Now, let’s run it in the same way that we ran the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.166.1">load_library.rb</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.167.1"> script:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.168.1">
ruby require_library.rb</span></pre> <p><span class="koboSpan" id="kobo.169.1">Initially, the output will be the same as when we ran the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.170.1">load_library.rb</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.171.1"> script:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.172.1">
I am a library.</span></pre> <p><span class="koboSpan" id="kobo.173.1">However, notice that in this example, we included the dot slash prefix (</span><strong class="source-inline"><span class="koboSpan" id="kobo.174.1">./</span></strong><span class="koboSpan" id="kobo.175.1">) before the filename. </span><span class="koboSpan" id="kobo.175.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.176.1">require</span></strong><span class="koboSpan" id="kobo.177.1"> function needs either the absolute path or the relative path of the file – because the </span><strong class="source-inline"><span class="koboSpan" id="kobo.178.1">my_library.rb</span></strong><span class="koboSpan" id="kobo.179.1"> example is within the same folder, we use the relative path to the current folder, which would be </span><strong class="source-inline"><span class="koboSpan" id="kobo.180.1">./</span></strong><span class="koboSpan" id="kobo.181.1">. </span><span class="koboSpan" id="kobo.181.2">In simple terms, the source code for </span><strong class="source-inline"><span class="koboSpan" id="kobo.182.1">require_library.rb</span></strong><span class="koboSpan" id="kobo.183.1"> would read as “inject the code that is in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.184.1">my_library.rb</span></strong><span class="koboSpan" id="kobo.185.1"> file, which is in the </span><span class="No-Break"><span class="koboSpan" id="kobo.186.1">same folder.”</span></span></p>
<p><span class="koboSpan" id="kobo.187.1">Now, let’s try calling the </span><strong class="source-inline"><span class="koboSpan" id="kobo.188.1">require</span></strong><span class="koboSpan" id="kobo.189.1"> method more </span><span class="No-Break"><span class="koboSpan" id="kobo.190.1">than once:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.191.1">
# require_library.rb
require './my_library.rb'
require './my_library.rb'</span></pre> <p><span class="koboSpan" id="kobo.192.1">Let’s run it again with the </span><span class="No-Break"><span class="koboSpan" id="kobo.193.1">following code:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.194.1">
ruby require_library.rb</span></pre> <p><span class="koboSpan" id="kobo.195.1">To an experienced PHP developer, it should not be a surprise that the output is </span><span class="No-Break"><span class="koboSpan" id="kobo.196.1">as follows:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.197.1">
I am a library.</span></pre> <p><span class="koboSpan" id="kobo.198.1">Ruby’s </span><strong class="source-inline"><span class="koboSpan" id="kobo.199.1">require</span></strong><span class="koboSpan" id="kobo.200.1"> method works pretty much the same way as </span><strong class="source-inline"><span class="koboSpan" id="kobo.201.1">include_once</span></strong><span class="koboSpan" id="kobo.202.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.203.1">require_once</span></strong><span class="koboSpan" id="kobo.204.1"> from PHP. </span><span class="koboSpan" id="kobo.204.2">The Ruby interpreter only loads the code once, and whenever you try to load it again, the engine notices that you already loaded that code, so it doesn’t load it again, saving memory </span><span class="No-Break"><span class="koboSpan" id="kobo.205.1">and resources.</span></span></p>
<p><span class="koboSpan" id="kobo.206.1">One last thing we may wish to consider while using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.207.1">require</span></strong><span class="koboSpan" id="kobo.208.1"> method is that it is not compulsory to include the file extension, so this will </span><span class="No-Break"><span class="koboSpan" id="kobo.209.1">also work:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.210.1">
# require_library.rb
require './my_library'</span></pre> <p><span class="koboSpan" id="kobo.211.1">By not using the file extension, our code looks slightly cleaner. </span><span class="koboSpan" id="kobo.211.2">Now, how is the </span><strong class="source-inline"><span class="koboSpan" id="kobo.212.1">require</span></strong><span class="koboSpan" id="kobo.213.1"> method useful, you may ask? </span><span class="koboSpan" id="kobo.213.2">Well, whenever you’re writing libraries that will be used in several parts of your code, you don’t have to worry about loading your library multiple times as the </span><strong class="source-inline"><span class="koboSpan" id="kobo.214.1">require</span></strong><span class="koboSpan" id="kobo.215.1"> method</span><a id="_idIndexMarker082"/><span class="koboSpan" id="kobo.216.1"> will only load it once, thus saving memory resources. </span><span class="koboSpan" id="kobo.216.2">We’ll keep it simple for now, but if you are interested</span><a id="_idIndexMarker083"/><span class="koboSpan" id="kobo.217.1"> in more options for importing code, there is also the </span><strong class="source-inline"><span class="koboSpan" id="kobo.218.1">require_relative</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.219.1">method: </span></span><a href="https://apidock.com/ruby/Kernel/require_relative"><span class="No-Break"><span class="koboSpan" id="kobo.220.1">https://apidock.com/ruby/Kernel/require_relative</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.221.1">.</span></span></p>
<h2 id="_idParaDest-43"><a id="_idTextAnchor044"/><span class="koboSpan" id="kobo.222.1">Ruby classes and modules</span></h2>
<p><span class="koboSpan" id="kobo.223.1">In Ruby, modules</span><a id="_idIndexMarker084"/><span class="koboSpan" id="kobo.224.1"> are a way to group code</span><a id="_idIndexMarker085"/><span class="koboSpan" id="kobo.225.1"> so that it can be reused. </span><span class="koboSpan" id="kobo.225.2">Specifically, modules are collections of methods and constants that can be injected into classes. </span><span class="koboSpan" id="kobo.225.3">By themselves, modules aren’t useful as you can’t use them in an isolated manner. </span><span class="koboSpan" id="kobo.225.4">We use modules to add functionality to </span><span class="No-Break"><span class="koboSpan" id="kobo.226.1">a class.</span></span></p>
<p><span class="koboSpan" id="kobo.227.1">A class, as you probably know, is a blueprint</span><a id="_idIndexMarker086"/><span class="koboSpan" id="kobo.228.1"> of an abstraction</span><a id="_idIndexMarker087"/><span class="koboSpan" id="kobo.229.1"> from the real world taken to the programming world. </span><span class="koboSpan" id="kobo.229.2">A class can have different methods to represent actions and attributes to represent values. </span><span class="koboSpan" id="kobo.229.3">A class can be enhanced by including additional methods and constants from a module. </span><span class="koboSpan" id="kobo.229.4">So, in simple terms, a class can attach methods and constants from a module – and that’s what the </span><strong class="source-inline"><span class="koboSpan" id="kobo.230.1">include</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.231.1">method does.</span></span></p>
<p><span class="koboSpan" id="kobo.232.1">Let’s look at this in a simplified example. </span><span class="koboSpan" id="kobo.232.2">Create a file called </span><strong class="source-inline"><span class="koboSpan" id="kobo.233.1">include_module.rb</span></strong><span class="koboSpan" id="kobo.234.1"> with the </span><span class="No-Break"><span class="koboSpan" id="kobo.235.1">following code:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.236.1">
# include_module.rb
class MyClass end</span></pre> <p><span class="koboSpan" id="kobo.237.1">Here, we’re creating a simple empty class called </span><strong class="source-inline"><span class="koboSpan" id="kobo.238.1">MyClass</span></strong><span class="koboSpan" id="kobo.239.1"> with no methods. </span><span class="koboSpan" id="kobo.239.2">Now, let’s create an instance of </span><span class="No-Break"><span class="koboSpan" id="kobo.240.1">this class:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.241.1">
my_class_instance = MyClass.new</span></pre> <p><span class="koboSpan" id="kobo.242.1">We can’t do much with this class as it is empty, so let’s add a </span><strong class="source-inline"><span class="koboSpan" id="kobo.243.1">Utilities</span></strong><span class="koboSpan" id="kobo.244.1"> module </span><span class="No-Break"><span class="koboSpan" id="kobo.245.1">to it:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.246.1">
module Utilities end</span></pre> <p><span class="koboSpan" id="kobo.247.1">And just like the previous class (</span><strong class="source-inline"><span class="koboSpan" id="kobo.248.1">MyClass</span></strong><span class="koboSpan" id="kobo.249.1">), this is just an empty module. </span><span class="koboSpan" id="kobo.249.2">Let’s add a method called </span><strong class="source-inline"><span class="koboSpan" id="kobo.250.1">debug</span></strong><span class="koboSpan" id="kobo.251.1"> to our module so that both our class and module end up looking </span><span class="No-Break"><span class="koboSpan" id="kobo.252.1">like this:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.253.1">
# include_module.rb
class MyClass end
module Utilities
  def debug
    puts 'We are debugging'
  end
end
my_class_instance = MyClass.new</span></pre> <p><span class="koboSpan" id="kobo.254.1">With this code, we’ve declared</span><a id="_idIndexMarker088"/><span class="koboSpan" id="kobo.255.1"> a method</span><a id="_idIndexMarker089"/><span class="koboSpan" id="kobo.256.1"> named </span><strong class="source-inline"><span class="koboSpan" id="kobo.257.1">debug</span></strong><span class="koboSpan" id="kobo.258.1"> that prints</span><a id="_idIndexMarker090"/><span class="koboSpan" id="kobo.259.1"> the text “We are</span><a id="_idIndexMarker091"/><span class="koboSpan" id="kobo.260.1"> debugging.” </span><span class="koboSpan" id="kobo.260.2">Can we add this method to </span><strong class="source-inline"><span class="koboSpan" id="kobo.261.1">MyClass</span></strong><span class="koboSpan" id="kobo.262.1">? </span><span class="koboSpan" id="kobo.262.2">Well, this is where the </span><strong class="source-inline"><span class="koboSpan" id="kobo.263.1">include</span></strong><span class="koboSpan" id="kobo.264.1"> method </span><span class="No-Break"><span class="koboSpan" id="kobo.265.1">comes in.</span></span></p>
<h2 id="_idParaDest-44"><a id="_idTextAnchor045"/><span class="koboSpan" id="kobo.266.1">The include method</span></h2>
<p><span class="koboSpan" id="kobo.267.1">At this point, we should incorporate</span><a id="_idIndexMarker092"/><span class="koboSpan" id="kobo.268.1"> this newly built debug</span><a id="_idIndexMarker093"/><span class="koboSpan" id="kobo.269.1"> method with the </span><strong class="source-inline"><span class="koboSpan" id="kobo.270.1">include</span></strong><span class="koboSpan" id="kobo.271.1"> method because, as it stands now, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.272.1">debug</span></strong><span class="koboSpan" id="kobo.273.1"> method is not currently being used. </span><span class="koboSpan" id="kobo.273.2">It’s merely defined. </span><span class="koboSpan" id="kobo.273.3">With the </span><strong class="source-inline"><span class="koboSpan" id="kobo.274.1">include</span></strong><span class="koboSpan" id="kobo.275.1"> method, we can now “attach” the </span><strong class="source-inline"><span class="koboSpan" id="kobo.276.1">debug</span></strong><span class="koboSpan" id="kobo.277.1"> method to our class by adding this to the end of </span><span class="No-Break"><span class="koboSpan" id="kobo.278.1">the file:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.279.1">
MyClass.include(Utilities)</span></pre> <p><span class="koboSpan" id="kobo.280.1">This simply means that the </span><strong class="source-inline"><span class="koboSpan" id="kobo.281.1">debug</span></strong><span class="koboSpan" id="kobo.282.1"> method is now available to </span><strong class="source-inline"><span class="koboSpan" id="kobo.283.1">my_class_instance</span></strong><span class="koboSpan" id="kobo.284.1">. </span><span class="koboSpan" id="kobo.284.2">Let’s call our newly included </span><strong class="source-inline"><span class="koboSpan" id="kobo.285.1">debug</span></strong><span class="koboSpan" id="kobo.286.1"> method from our class instance. </span><span class="koboSpan" id="kobo.286.2">Your final code should look </span><span class="No-Break"><span class="koboSpan" id="kobo.287.1">like this:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.288.1">
# include_module.rb
class MyClass end
module Utilities
  def debug
    puts 'We are debugging'
  end
end
my_class_instance = MyClass.new
MyClass.include(Utilities)
my_class_instance.debug</span></pre> <p><span class="koboSpan" id="kobo.289.1">Now, for the moment of truth – let’s </span><span class="No-Break"><span class="koboSpan" id="kobo.290.1">run it:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.291.1">
ruby require_library.rb</span></pre> <p><span class="koboSpan" id="kobo.292.1">This will output </span><span class="No-Break"><span class="koboSpan" id="kobo.293.1">the following:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.294.1">
We are debugging</span></pre> <p><span class="koboSpan" id="kobo.295.1">This means that we have successfully attached the debug method to our empty class. </span><span class="koboSpan" id="kobo.295.2">This comes in handy whenever we need modules that are reused throughout </span><span class="No-Break"><span class="koboSpan" id="kobo.296.1">our code.</span></span></p>
<p><span class="koboSpan" id="kobo.297.1">The equivalent to Ruby’s </span><strong class="source-inline"><span class="koboSpan" id="kobo.298.1">include</span></strong><span class="koboSpan" id="kobo.299.1"> method in PHP is a resource called </span><strong class="source-inline"><span class="koboSpan" id="kobo.300.1">traits</span></strong><span class="koboSpan" id="kobo.301.1">. </span><span class="koboSpan" id="kobo.301.2">If you’re interested</span><a id="_idIndexMarker094"/><span class="koboSpan" id="kobo.302.1"> in this topic, check out </span><a href="https://www.php.net/manual/en/language.oop5.traits.php"><span class="koboSpan" id="kobo.303.1">https://www.php.net/manual/en/language.oop5.traits.php</span></a><span class="koboSpan" id="kobo.304.1">. </span><span class="koboSpan" id="kobo.304.2">This might be a little complicated to grasp at first since we haven’t looked at object-oriented programming in Ruby so far, but don’t worry</span><a id="_idIndexMarker095"/><span class="koboSpan" id="kobo.305.1"> if you don’t fully understand </span><a id="_idIndexMarker096"/><span class="koboSpan" id="kobo.306.1">it at this point – we will </span><span class="No-Break"><span class="koboSpan" id="kobo.307.1">get there.</span></span></p>
<h2 id="_idParaDest-45"><a id="_idTextAnchor046"/><span class="koboSpan" id="kobo.308.1">Interactive Ruby Shell (IRB)</span></h2>
<p><span class="koboSpan" id="kobo.309.1">Sometimes, you may want to quickly test</span><a id="_idIndexMarker097"/><span class="koboSpan" id="kobo.310.1"> a very small piece of code</span><a id="_idIndexMarker098"/><span class="koboSpan" id="kobo.311.1"> and it may seem like a hassle to create a file, add the code, and then run it. </span><span class="koboSpan" id="kobo.311.2">Maybe we just want to test the syntax of a single line of code. </span><span class="koboSpan" id="kobo.311.3">Well, we don’t have to create a file to just test a line of code. </span><span class="koboSpan" id="kobo.311.4">Just like in other languages, such as Python or even PHP, we have a tool just for that in Ruby: it’s the </span><strong class="bold"><span class="koboSpan" id="kobo.312.1">Interactive Ruby Shell</span></strong><span class="koboSpan" id="kobo.313.1">, better known as </span><strong class="bold"><span class="koboSpan" id="kobo.314.1">IRB</span></strong><span class="koboSpan" id="kobo.315.1">. </span><span class="koboSpan" id="kobo.315.2">Let’s take a look </span><span class="No-Break"><span class="koboSpan" id="kobo.316.1">at it.</span></span></p>
<p><span class="koboSpan" id="kobo.317.1">Within a shell, run the </span><span class="No-Break"><span class="koboSpan" id="kobo.318.1">following command:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.319.1">
irb</span></pre> <p><span class="koboSpan" id="kobo.320.1">This will make your shell look </span><span class="No-Break"><span class="koboSpan" id="kobo.321.1">like this:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.322.1">
irb(main):001:0&gt;</span></pre> <p><span class="koboSpan" id="kobo.323.1">This shell works as a real-time Ruby interpreter – that is, after the </span><strong class="source-inline"><span class="koboSpan" id="kobo.324.1">&gt;</span></strong><span class="koboSpan" id="kobo.325.1"> symbol, we can start typing Ruby commands</span><a id="_idIndexMarker099"/><span class="koboSpan" id="kobo.326.1"> that will be interpreted and executed right away. </span><span class="koboSpan" id="kobo.326.2">As a simple example, let’s add 1 </span><span class="No-Break"><span class="koboSpan" id="kobo.327.1">and 1:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.328.1">
irb(main):001:0&gt; 1+1</span></pre> <p><span class="koboSpan" id="kobo.329.1">This will return the </span><span class="No-Break"><span class="koboSpan" id="kobo.330.1">following result:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.331.1">
irb(main):001:0&gt; 1+1
=&gt; 2</span></pre> <p><span class="koboSpan" id="kobo.332.1">This comes in quite handy when you quickly want to test syntax and operations, or even view the content of a class. </span><span class="koboSpan" id="kobo.332.2">It works in the same way as the Ruby binary we’ve been using in </span><span class="No-Break"><span class="koboSpan" id="kobo.333.1">previous examples.</span></span></p>
<p><span class="koboSpan" id="kobo.334.1">So, as a final example, let’s load the </span><strong class="source-inline"><span class="koboSpan" id="kobo.335.1">include_module</span></strong><span class="koboSpan" id="kobo.336.1"> file we created, but now with this </span><span class="No-Break"><span class="koboSpan" id="kobo.337.1">interactive shell:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.338.1">
irb(main):001:0&gt; require './include_module'
We are debugging
=&gt; true</span></pre> <p><span class="koboSpan" id="kobo.339.1">Now that we’ve included the code in our shell with the </span><strong class="source-inline"><span class="koboSpan" id="kobo.340.1">require</span></strong><span class="koboSpan" id="kobo.341.1"> method, we can use this loaded code in our </span><strong class="source-inline"><span class="koboSpan" id="kobo.342.1">irb</span></strong><span class="koboSpan" id="kobo.343.1"> session. </span><span class="koboSpan" id="kobo.343.2">Since we have the </span><strong class="source-inline"><span class="koboSpan" id="kobo.344.1">MyClass</span></strong><span class="koboSpan" id="kobo.345.1"> definition available, we can use it as a blueprint to create an instance </span><span class="No-Break"><span class="koboSpan" id="kobo.346.1">of </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.347.1">MyClass</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.348.1">:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.349.1">
irb(main):001:0&gt; another_instance = MyClass.new</span></pre> <p><span class="koboSpan" id="kobo.350.1">This returns a unique identifier that Ruby uses internally to know where the instance resides in the </span><span class="No-Break"><span class="koboSpan" id="kobo.351.1">computer’s memory:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.352.1">
=&gt; #&lt;MyClass:0x000000014a17ed50&gt;</span></pre> <p><span class="koboSpan" id="kobo.353.1">Note that we can call the </span><strong class="source-inline"><span class="koboSpan" id="kobo.354.1">debug</span></strong><span class="koboSpan" id="kobo.355.1"> method on our newly created </span><span class="No-Break"><span class="koboSpan" id="kobo.356.1">instance too:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.357.1">
irb(main):001:0&gt; another_instance.debug</span></pre> <p><span class="koboSpan" id="kobo.358.1">And just like before, we get the </span><span class="No-Break"><span class="koboSpan" id="kobo.359.1">same output:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.360.1">
We are debugging
=&gt; nil</span></pre> <p><span class="koboSpan" id="kobo.361.1">To exit this interactive shell, simply type </span><strong class="source-inline"><span class="koboSpan" id="kobo.362.1">exit</span></strong><span class="koboSpan" id="kobo.363.1"> to make your shell go back to normal. </span><span class="koboSpan" id="kobo.363.2">In case you were wondering, there is a similar shell</span><a id="_idIndexMarker100"/><span class="koboSpan" id="kobo.364.1"> in PHP called interactive shell. </span><span class="koboSpan" id="kobo.364.2">Be sure to check out this page if you’re interested in this </span><span class="No-Break"><span class="koboSpan" id="kobo.365.1">topic: </span></span><a href="https://www.php.net/manual/en/features.commandline.interactive.php"><span class="No-Break"><span class="koboSpan" id="kobo.366.1">https://www.php.net/manual/en/features.commandline.interactive.php</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.367.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.368.1">At this point, we can proudly say that we now know how to run Ruby code in a couple of different ways. </span><span class="koboSpan" id="kobo.368.2">We also know</span><a id="_idIndexMarker101"/><span class="koboSpan" id="kobo.369.1"> how to use a single source code</span><a id="_idIndexMarker102"/><span class="koboSpan" id="kobo.370.1"> file, or load code from a separate source code file. </span><span class="koboSpan" id="kobo.370.2">Either way, whether you’re running your code with the Ruby binary or with the interactive shell, you’re going to need a way to store and use values, which brings us to our next </span><span class="No-Break"><span class="koboSpan" id="kobo.371.1">topic: variables.</span></span></p>
<h1 id="_idParaDest-46"><a id="_idTextAnchor047"/><span class="koboSpan" id="kobo.372.1">Exploring types of variables</span></h1>
<p><span class="koboSpan" id="kobo.373.1">Variables in Ruby have the same utility</span><a id="_idIndexMarker103"/><span class="koboSpan" id="kobo.374.1"> as in other programming languages: they are mutable containers for values. </span><span class="koboSpan" id="kobo.374.2">Simply put, variables are used to save values for later usage. </span><span class="koboSpan" id="kobo.374.3">These values may change over time, or even change the type of data </span><span class="No-Break"><span class="koboSpan" id="kobo.375.1">they contain.</span></span></p>
<p><span class="koboSpan" id="kobo.376.1">Just like with PHP, Ruby</span><a id="_idIndexMarker104"/><span class="koboSpan" id="kobo.377.1"> is dynamically typed (or duck typing), which means that the interpreter infers what type of data we are handling at runtime. </span><span class="koboSpan" id="kobo.377.2">We don’t need to tell Ruby or PHP that a variable is either a string, a number, or a Boolean. </span><span class="koboSpan" id="kobo.377.3">One difference with PHP, however, is that in later versions of PHP, you </span><em class="italic"><span class="koboSpan" id="kobo.378.1">can</span></em><span class="koboSpan" id="kobo.379.1"> specify what type of data to use, especially in object-oriented PHP. </span><span class="koboSpan" id="kobo.379.2">However, even with this “enhancement,” the majority of the language </span><span class="No-Break"><span class="koboSpan" id="kobo.380.1">remains duck-typed.</span></span></p>
<p><span class="koboSpan" id="kobo.381.1">How does this affect us as developers? </span><span class="koboSpan" id="kobo.381.2">Well, let’s take a look at a simple example. </span><span class="koboSpan" id="kobo.381.3">First, open an IRS. </span><span class="koboSpan" id="kobo.381.4">Type the </span><span class="No-Break"><span class="koboSpan" id="kobo.382.1">following command:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.383.1">
irb</span></pre> <p><span class="koboSpan" id="kobo.384.1">As we saw previously, once we type this command, the shell will look </span><span class="No-Break"><span class="koboSpan" id="kobo.385.1">like this:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.386.1">
irb(main):001:0&gt;</span></pre> <p><span class="koboSpan" id="kobo.387.1">Now, type the </span><span class="No-Break"><span class="koboSpan" id="kobo.388.1">following declarations:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.389.1">
name = "Oscar"
age = 35
is_married = true
books_read_this_week = 2.5</span></pre> <p><span class="koboSpan" id="kobo.390.1">Note that though the information in the previous code block is what you should type, it will look like this in </span><span class="No-Break"><span class="koboSpan" id="kobo.391.1">the prompt:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.392.1">
irb(main):001:0&gt; name = "Oscar"
=&gt; "Oscar"
irb(main):002:0&gt; age = 35
=&gt; 35
irb(main):003:0&gt; is_married = true
=&gt; true
irb(main):004:0&gt;books_read_this_week = 2.5
=&gt; 2.5</span></pre> <p><span class="koboSpan" id="kobo.393.1">One of the core features of the Ruby language is that with every line of code, Ruby will attempt to return a value. </span><span class="koboSpan" id="kobo.393.2">If you declare a variable, Ruby will return the assigned value. </span><span class="koboSpan" id="kobo.393.3">So, when we added the </span><strong class="source-inline"><span class="koboSpan" id="kobo.394.1">name</span></strong><span class="koboSpan" id="kobo.395.1"> variable, Ruby returned the value of the variable – that is, </span><strong class="source-inline"><span class="koboSpan" id="kobo.396.1">"Oscar"</span></strong><span class="koboSpan" id="kobo.397.1">. </span><span class="koboSpan" id="kobo.397.2">This comes in handy when we use this behavior to obtain the type of data a variable is holding. </span><span class="koboSpan" id="kobo.397.3">Ruby “knows” what type of data this </span><strong class="source-inline"><span class="koboSpan" id="kobo.398.1">name</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.399.1">variable contains.</span></span></p>
<p><span class="koboSpan" id="kobo.400.1">To do this, we can make use of the internal </span><strong class="source-inline"><span class="koboSpan" id="kobo.401.1">class</span></strong><span class="koboSpan" id="kobo.402.1"> method. </span><span class="koboSpan" id="kobo.402.2">Just type </span><strong class="source-inline"><span class="koboSpan" id="kobo.403.1">name.class</span></strong><span class="koboSpan" id="kobo.404.1">; </span><strong class="source-inline"><span class="koboSpan" id="kobo.405.1">irb</span></strong><span class="koboSpan" id="kobo.406.1"> should return something similar </span><span class="No-Break"><span class="koboSpan" id="kobo.407.1">to this:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.408.1">
irb(main):005:0&gt; name.class
=&gt; String</span></pre> <p><span class="koboSpan" id="kobo.409.1">The Ruby interpreter determined</span><a id="_idIndexMarker105"/><span class="koboSpan" id="kobo.410.1"> that the </span><strong class="source-inline"><span class="koboSpan" id="kobo.411.1">name</span></strong><span class="koboSpan" id="kobo.412.1"> variable is a string, or in simple terms, text. </span><span class="koboSpan" id="kobo.412.2">The same can be done to the other variables we just declared, such as the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.413.1">age</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.414.1"> variable:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.415.1">
irb(main):006:0&gt; age.class
=&gt; Integer</span></pre> <p><span class="koboSpan" id="kobo.416.1">And in that same manner, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.417.1">is_married</span></strong><span class="koboSpan" id="kobo.418.1"> variable is a Boolean variable. </span><span class="koboSpan" id="kobo.418.2">We can confirm this by getting the class of </span><span class="No-Break"><span class="koboSpan" id="kobo.419.1">that variable:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.420.1">
irb(main):006:0&gt; is_married.class
=&gt; TrueClass</span></pre> <p><span class="koboSpan" id="kobo.421.1">This means that the </span><strong class="source-inline"><span class="koboSpan" id="kobo.422.1">is_married</span></strong><span class="koboSpan" id="kobo.423.1"> variable has a Boolean value of </span><strong class="source-inline"><span class="koboSpan" id="kobo.424.1">true</span></strong><span class="koboSpan" id="kobo.425.1">. </span><span class="koboSpan" id="kobo.425.2">We can do the same with the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.426.1">books_read_this_week</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.427.1"> variable:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.428.1">
irb(main):006:0&gt; books_read_this_week.class
=&gt; Float</span></pre> <p><span class="koboSpan" id="kobo.429.1">We did not explicitly tell Ruby what type of variables we were going to use, yet Ruby “knew” this automagically. </span><span class="koboSpan" id="kobo.429.2">This means that we don’t have to worry about telling Ruby the type of data we are going to use. </span><span class="koboSpan" id="kobo.429.3">This is pragmatic for the most part, but I must admit I’ve been in scenarios where it would have helped to have known the type of data </span><span class="No-Break"><span class="koboSpan" id="kobo.430.1">before runtime.</span></span></p>
<p><span class="koboSpan" id="kobo.431.1">So far, in our previous examples, we’ve looked at four different types of variables in Ruby: strings, integers, Booleans (true or false), and float values. </span><span class="koboSpan" id="kobo.431.2">However, there are three more types of variables that we should look at in depth: arrays, hashes, and symbols. </span><span class="koboSpan" id="kobo.431.3">We’ll go through</span><a id="_idIndexMarker106"/><span class="koboSpan" id="kobo.432.1"> each of </span><span class="No-Break"><span class="koboSpan" id="kobo.433.1">them now.</span></span></p>
<h2 id="_idParaDest-47"><a id="_idTextAnchor048"/><span class="koboSpan" id="kobo.434.1">Arrays</span></h2>
<p><span class="koboSpan" id="kobo.435.1">Arrays are a way</span><a id="_idIndexMarker107"/><span class="koboSpan" id="kobo.436.1"> of grouping common</span><a id="_idIndexMarker108"/><span class="koboSpan" id="kobo.437.1"> variables. </span><span class="koboSpan" id="kobo.437.2">Coming from a PHP background, arrays can be very simple to understand both conceptually and syntactically. </span><span class="koboSpan" id="kobo.437.3">Conceptually, we put together similar or related values. </span><span class="koboSpan" id="kobo.437.4">An example could be grouping a person’s phone numbers in a single variable. </span><span class="koboSpan" id="kobo.437.5">Another example could be storing a physical address by saving the street, number, city, zip code, and more all in the same variable. </span><span class="koboSpan" id="kobo.437.6">As we will see next, the Ruby syntax is very similar to the </span><span class="No-Break"><span class="koboSpan" id="kobo.438.1">PHP one.</span></span></p>
<p><span class="koboSpan" id="kobo.439.1">Arrays let us take related values and save them in a single variable. </span><span class="koboSpan" id="kobo.439.2">As an example, let’s say we wanted to save my siblings’ ages. </span><span class="koboSpan" id="kobo.439.3">We could create an array of integers that represented my siblings’ ages. </span><span class="koboSpan" id="kobo.439.4">Let’s do just that in PHP and Ruby and compare both syntaxes. </span><span class="koboSpan" id="kobo.439.5">This would be the </span><span class="No-Break"><span class="koboSpan" id="kobo.440.1">PHP syntax:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.441.1">
$siblings_ages = [ 42, 31, 25 ];</span></pre> <p><span class="koboSpan" id="kobo.442.1">And this would be the </span><span class="No-Break"><span class="koboSpan" id="kobo.443.1">Ruby syntax:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.444.1">
siblings_ages = [ 42, 31, 25 ]</span></pre> <p><span class="koboSpan" id="kobo.445.1">Except for </span><strong class="source-inline"><span class="koboSpan" id="kobo.446.1">$</span></strong><span class="koboSpan" id="kobo.447.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.448.1">;</span></strong><span class="koboSpan" id="kobo.449.1">,, both pieces of code are the same; this goes to show that understanding the concepts of Ruby arrays should not be difficult if you’re from a PHP background. </span><span class="koboSpan" id="kobo.449.2">While there are other ways to declare arrays, we’ll keep the syntax simple </span><span class="No-Break"><span class="koboSpan" id="kobo.450.1">for now.</span></span></p>
<p><span class="koboSpan" id="kobo.451.1">Now that we understand how to declare arrays, let’s look at some practical uses </span><span class="No-Break"><span class="koboSpan" id="kobo.452.1">for them.</span></span></p>
<p><span class="koboSpan" id="kobo.453.1">Arrays can have other types of values in Ruby (not just numbers). </span><span class="koboSpan" id="kobo.453.2">Let’s say I wanted to list the instruments someone knows how to play. </span><span class="koboSpan" id="kobo.453.3">We could make a list of strings and name </span><span class="No-Break"><span class="koboSpan" id="kobo.454.1">it </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.455.1">instruments_played</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.456.1">:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.457.1">
instruments_played = ["guitar", "drums", "bass", "ukulele"]</span></pre> <p><span class="koboSpan" id="kobo.458.1">As you can see, we have grouped related values (in this case instruments) in a single variable. </span><span class="koboSpan" id="kobo.458.2">We’ve created a list ready to be used within our code. </span><span class="koboSpan" id="kobo.458.3">This type of array, as it was declared, has an internal counter to reference each value. </span><span class="koboSpan" id="kobo.458.4">This internal counter starts with 0, so the first value (</span><strong class="source-inline"><span class="koboSpan" id="kobo.459.1">guitar</span></strong><span class="koboSpan" id="kobo.460.1">) would be contained in </span><strong class="source-inline"><span class="koboSpan" id="kobo.461.1">instruments_played[0]</span></strong><span class="koboSpan" id="kobo.462.1">, the second value (</span><strong class="source-inline"><span class="koboSpan" id="kobo.463.1">drums</span></strong><span class="koboSpan" id="kobo.464.1">) would be contained in </span><strong class="source-inline"><span class="koboSpan" id="kobo.465.1">instruments_played[1]</span></strong><span class="koboSpan" id="kobo.466.1">, and </span><span class="No-Break"><span class="koboSpan" id="kobo.467.1">so on.</span></span></p>
<p><span class="koboSpan" id="kobo.468.1">Should we want to print out all of the instruments on the screen, we could print each instrument one </span><span class="No-Break"><span class="koboSpan" id="kobo.469.1">by one:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.470.1">
puts instruments_played[0]
puts instruments_played[1]
puts instruments_played[2]
puts instruments_played[3]</span></pre> <p><span class="koboSpan" id="kobo.471.1">However, this is tedious and impractical, and as you may have guessed, we have a better programming way of doing this. </span><span class="koboSpan" id="kobo.471.2">Instead of counting one by one, we can iterate through all values of the array using the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.472.1">do</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.473.1"> statement:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.474.1">
for i in 0…4 do
puts instruments_played[i]
end</span></pre> <p><span class="koboSpan" id="kobo.475.1">The three-dot notation (</span><strong class="source-inline"><span class="koboSpan" id="kobo.476.1">…</span></strong><span class="koboSpan" id="kobo.477.1">) might be new and even weird</span><a id="_idIndexMarker109"/><span class="koboSpan" id="kobo.478.1"> to someone coming from PHP, but if you just read</span><a id="_idIndexMarker110"/><span class="koboSpan" id="kobo.479.1"> through the code, it almost makes sense. </span><span class="koboSpan" id="kobo.479.2">This notation</span><a id="_idIndexMarker111"/><span class="koboSpan" id="kobo.480.1"> is called range and you’ll see it used often in Ruby. </span><span class="koboSpan" id="kobo.480.2">The notation creates a counter that goes from 0 to a value less than 4 (3, in this case), then increments the counter by 1. </span><span class="koboSpan" id="kobo.480.3">This counter is then assigned to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.481.1">i</span></strong><span class="koboSpan" id="kobo.482.1"> variable. </span><span class="koboSpan" id="kobo.482.2">The example would read something like, “For the </span><strong class="source-inline"><span class="koboSpan" id="kobo.483.1">i</span></strong><span class="koboSpan" id="kobo.484.1"> variable, create a cycle that starts with 0, ends in 3, increases by 1, and prints each value of the array one by one.” </span><span class="koboSpan" id="kobo.484.2">The output would look something </span><span class="No-Break"><span class="koboSpan" id="kobo.485.1">like this:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.486.1">
guitar
drums
bass
ukulele
=&gt; 0...4</span></pre> <p><span class="koboSpan" id="kobo.487.1">Did you notice that the </span><strong class="source-inline"><span class="koboSpan" id="kobo.488.1">…</span></strong><span class="koboSpan" id="kobo.489.1"> notation excludes the number 4, equivalent to [0,4] in mathematical notation? </span><span class="koboSpan" id="kobo.489.2">Well, what if we wanted the range to be inclusive – for example, [0,3] – which would include the last number? </span><span class="koboSpan" id="kobo.489.3">Ruby also has a two-dot notation (</span><strong class="source-inline"><span class="koboSpan" id="kobo.490.1">..</span></strong><span class="koboSpan" id="kobo.491.1">) that </span><em class="italic"><span class="koboSpan" id="kobo.492.1">does</span></em><span class="koboSpan" id="kobo.493.1"> include the last number in its range. </span><span class="koboSpan" id="kobo.493.2">So, we could rewrite the example </span><span class="No-Break"><span class="koboSpan" id="kobo.494.1">as follows:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.495.1">
for i in 0..3 do
puts instruments_played[i]
end</span></pre> <p><span class="koboSpan" id="kobo.496.1">The output would be the same as the </span><span class="No-Break"><span class="koboSpan" id="kobo.497.1">previous example:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.498.1">
guitar
drums
bass
ukulele
=&gt; 0..3</span></pre> <p><span class="koboSpan" id="kobo.499.1">You may use the three-dot or the two-dot notation</span><a id="_idIndexMarker112"/><span class="koboSpan" id="kobo.500.1"> as you see fit. </span><span class="koboSpan" id="kobo.500.2">If you are more interested in the topic</span><a id="_idIndexMarker113"/><span class="koboSpan" id="kobo.501.1"> of ranges, I suggest that you look at the documentation regarding this </span><span class="No-Break"><span class="koboSpan" id="kobo.502.1">topic: </span></span><a href="https://ruby-doc.org/core-2.5.1/Range.html"><span class="No-Break"><span class="koboSpan" id="kobo.503.1">https://ruby-doc.org/core-2.5.1/Range.html</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.504.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.505.1">Now, let’s get back to arrays. </span><span class="koboSpan" id="kobo.505.2">Just like PHP, Ruby has some internal methods to work with arrays. </span><span class="koboSpan" id="kobo.505.3">As an example of this parallel design, PHP has a function to tell us the size of an array. </span><span class="koboSpan" id="kobo.505.4">The function is called </span><strong class="source-inline"><span class="koboSpan" id="kobo.506.1">count()</span></strong><span class="koboSpan" id="kobo.507.1"> and has a Ruby equivalent called </span><strong class="source-inline"><span class="koboSpan" id="kobo.508.1">size()</span></strong><span class="koboSpan" id="kobo.509.1">. </span><span class="koboSpan" id="kobo.509.2">Just remember that everything in Ruby is an object, so you would not use </span><strong class="source-inline"><span class="koboSpan" id="kobo.510.1">size(instruments_played)</span></strong><span class="koboSpan" id="kobo.511.1"> as you would in PHP. </span><span class="koboSpan" id="kobo.511.2">Instead, to print the number of elements of our array, we would call the </span><strong class="source-inline"><span class="koboSpan" id="kobo.512.1">size()</span></strong><span class="koboSpan" id="kobo.513.1"> method as a method of the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.514.1">instruments_played</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.515.1"> array:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.516.1">
puts instruments_played.size</span></pre> <p><span class="koboSpan" id="kobo.517.1">Since the array has four elements, we would</span><a id="_idIndexMarker114"/><span class="koboSpan" id="kobo.518.1"> get an output of </span><strong class="source-inline"><span class="koboSpan" id="kobo.519.1">4</span></strong><span class="koboSpan" id="kobo.520.1">. </span><span class="koboSpan" id="kobo.520.2">Additionally, there is another method that does the same thing </span><span class="No-Break"><span class="koboSpan" id="kobo.521.1">called </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.522.1">length</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.523.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.524.1">Two more internal methods that I find extremely useful are </span><strong class="source-inline"><span class="koboSpan" id="kobo.525.1">first</span></strong><span class="koboSpan" id="kobo.526.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.527.1">last</span></strong><span class="koboSpan" id="kobo.528.1">. </span><span class="koboSpan" id="kobo.528.2">These methods (as we can infer from their names) let us fetch the first and last elements of the array, respectively. </span><span class="koboSpan" id="kobo.528.3">Let’s try the </span><strong class="source-inline"><span class="koboSpan" id="kobo.529.1">first</span></strong><span class="koboSpan" id="kobo.530.1"> method with some </span><span class="No-Break"><span class="koboSpan" id="kobo.531.1">variable interpolation:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.532.1">
puts "I learned how to play the #{instruments_played.first} first"</span></pre> <p><span class="koboSpan" id="kobo.533.1">This would output </span><span class="No-Break"><span class="koboSpan" id="kobo.534.1">the following:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.535.1">
I learned how to play the guitar first</span></pre> <p><span class="koboSpan" id="kobo.536.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.537.1">last</span></strong><span class="koboSpan" id="kobo.538.1"> method works in the </span><span class="No-Break"><span class="koboSpan" id="kobo.539.1">same way:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.540.1">
puts "I learned how to play the #{instruments_played.last} last"</span></pre> <p><span class="koboSpan" id="kobo.541.1">This would output </span><span class="No-Break"><span class="koboSpan" id="kobo.542.1">as expected:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.543.1">
I learned how to play the ukulele last</span></pre> <p><span class="koboSpan" id="kobo.544.1">As you can see, we’ve combined</span><a id="_idIndexMarker115"/><span class="koboSpan" id="kobo.545.1"> a string and a variable’s content</span><a id="_idIndexMarker116"/><span class="koboSpan" id="kobo.546.1"> to create a new string. </span><span class="koboSpan" id="kobo.546.2">This combination</span><a id="_idIndexMarker117"/><span class="koboSpan" id="kobo.547.1"> is referred to as </span><span class="No-Break"><span class="koboSpan" id="kobo.548.1">variable interpolation.</span></span></p>
<h3><span class="koboSpan" id="kobo.549.1">Variable interpolation</span></h3>
<p><span class="koboSpan" id="kobo.550.1">Variable interpolation (a term you will hear a lot in programming) involves </span><a id="_idIndexMarker118"/><span class="koboSpan" id="kobo.551.1">substituting a variable with its value. </span><span class="koboSpan" id="kobo.551.2">It’s extremely useful when printing messages and/or showing data to users. </span><span class="koboSpan" id="kobo.551.3">When used correctly, variable interpolation lets us embed a variable value inside a string. </span><span class="koboSpan" id="kobo.551.4">Let’s take the code from our </span><span class="No-Break"><span class="koboSpan" id="kobo.552.1">previous example:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.553.1">
instruments_played = ["guitar", "drums", "bass", "ukulele"]
puts "I learned how to play the #{instruments_played.first} first"</span></pre> <p><span class="koboSpan" id="kobo.554.1">There are a couple of layers to the string interpolation feature, so let’s analyze it </span><span class="No-Break"><span class="koboSpan" id="kobo.555.1">in parts.</span></span></p>
<p><span class="koboSpan" id="kobo.556.1">First, on the second line of the code, we can see that, inside the string, we have added a special block, which starts with the </span><strong class="source-inline"><span class="koboSpan" id="kobo.557.1">#</span></strong><span class="koboSpan" id="kobo.558.1"> symbol followed by a set of curly brackets ( </span><strong class="source-inline"><span class="koboSpan" id="kobo.559.1">#{ }</span></strong><span class="koboSpan" id="kobo.560.1"> ). </span><span class="koboSpan" id="kobo.560.2">When used inside a string, this block determines that we are going to </span><span class="No-Break"><span class="koboSpan" id="kobo.561.1">use interpolation.</span></span></p>
<p><span class="koboSpan" id="kobo.562.1">Secondly, everything inside the curly brackets will be interpreted and returned. </span><span class="koboSpan" id="kobo.562.2">In this example, the code inside the curly brackets is </span><strong class="source-inline"><span class="koboSpan" id="kobo.563.1">instruments_played.last</span></strong><span class="koboSpan" id="kobo.564.1">, which holds the last element of the array. </span><span class="koboSpan" id="kobo.564.2">This last element of the array will be returned as part of the string, thus finalizing the interpolation. </span><span class="koboSpan" id="kobo.564.3">This only works when the string is defined with double </span><span class="No-Break"><span class="koboSpan" id="kobo.565.1">quotes (</span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.566.1">“”</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.567.1">).</span></span></p>
<h3><span class="koboSpan" id="kobo.568.1">Combining array types</span></h3>
<p><span class="koboSpan" id="kobo.569.1">So far, we’ve seen arrays that hold</span><a id="_idIndexMarker119"/><span class="koboSpan" id="kobo.570.1"> the same type of data – we had an array exclusively made of strings and another array exclusively made of integers. </span><span class="koboSpan" id="kobo.570.2">But one last feature worth noting regarding Ruby arrays is that they can also combine different variable types within the same array. </span><span class="koboSpan" id="kobo.570.3">As a random example, let’s add unrelated values to </span><span class="No-Break"><span class="koboSpan" id="kobo.571.1">an array:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.572.1">
random_values = [25, "drums", false, 3.8]</span></pre> <p><span class="koboSpan" id="kobo.573.1">In this array, we are combining different types of data (integers, strings, Booleans, and floating points) into a single array. </span><span class="koboSpan" id="kobo.573.2">Not all languages support this behavior within arrays, but both Ruby and </span><span class="No-Break"><span class="koboSpan" id="kobo.574.1">PHP do.</span></span></p>
<p><span class="koboSpan" id="kobo.575.1">As we mentioned when we started looking at variable types, Ruby is dynamically typed. </span><span class="koboSpan" id="kobo.575.2">One of the features of a dynamically typed language is that arrays can combine the type of data they hold. </span><span class="koboSpan" id="kobo.575.3">In contrast, in a strongly typed language such as Java, arrays are forced to have the same type of data on each element – that is, you can only have an array of integers or only an array of strings. </span><span class="koboSpan" id="kobo.575.4">That is not to say that Ruby is better than Java or that, in general, strongly typed languages are better than dynamically typed languages. </span><span class="koboSpan" id="kobo.575.5">They just have </span><span class="No-Break"><span class="koboSpan" id="kobo.576.1">different designs.</span></span></p>
<p><span class="koboSpan" id="kobo.577.1">If you’re interested in learning</span><a id="_idIndexMarker120"/><span class="koboSpan" id="kobo.578.1"> more regarding the subject of arrays, please take a look at the official Ruby </span><span class="No-Break"><span class="koboSpan" id="kobo.579.1">documentation: </span></span><a href="https://ruby-doc.org/core-2.7.0/Array.html"><span class="No-Break"><span class="koboSpan" id="kobo.580.1">https://ruby-doc.org/core-2.7.0/Array.html</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.581.1">.</span></span></p>
<h2 id="_idParaDest-48"><a id="_idTextAnchor049"/><span class="koboSpan" id="kobo.582.1">Hashes</span></h2>
<p><span class="koboSpan" id="kobo.583.1">Now, let’s take a look at another</span><a id="_idIndexMarker121"/><span class="koboSpan" id="kobo.584.1"> type of variable that PHP developers will also understand</span><a id="_idIndexMarker122"/><span class="koboSpan" id="kobo.585.1"> very easily: hashes. </span><span class="koboSpan" id="kobo.585.2">A hash is an array but the main difference is that it has textual indexes instead of numbered indexes. </span><span class="koboSpan" id="kobo.585.3">Hashes are very similar to arrays in their behavior, but with the difference</span><a id="_idIndexMarker123"/><span class="koboSpan" id="kobo.586.1"> that we use strings to reference certain values. </span><span class="koboSpan" id="kobo.586.2">In PHP, these are known as </span><span class="No-Break"><span class="koboSpan" id="kobo.587.1">associative arrays.</span></span></p>
<p><span class="koboSpan" id="kobo.588.1">Let’s see an example in action. </span><span class="koboSpan" id="kobo.588.2">Here, we have a hash with the index in English and the value </span><span class="No-Break"><span class="koboSpan" id="kobo.589.1">in Spanish:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.590.1">
numbers = { "one" =&gt; "uno", "two" =&gt; "dos", "three" =&gt; "tres" }</span></pre> <p><span class="koboSpan" id="kobo.591.1">Similar to what we could do with an array, to get the value of a single index, we could type </span><span class="No-Break"><span class="koboSpan" id="kobo.592.1">the following:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.593.1">
puts numbers["one"]</span></pre> <p><span class="koboSpan" id="kobo.594.1">We would get the </span><span class="No-Break"><span class="koboSpan" id="kobo.595.1">following output:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.596.1">
uno</span></pre> <p><span class="koboSpan" id="kobo.597.1">As you can see, the index is a string and is more readable to a human. </span><span class="koboSpan" id="kobo.597.2">It’s this readability where a hash can come in handy. </span><span class="koboSpan" id="kobo.597.3">Let’s rewrite the first example we used at the start of the </span><em class="italic"><span class="koboSpan" id="kobo.598.1">Exploring types of variables</span></em><span class="koboSpan" id="kobo.599.1"> section so that it uses </span><span class="No-Break"><span class="koboSpan" id="kobo.600.1">a hash:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.601.1">
person = { "name" =&gt; "Oscar", "age" =&gt; 35, "is_married" =&gt; true, "books_read_this_week" =&gt; 2.5 }</span></pre> <p><span class="koboSpan" id="kobo.602.1">Instead of having separate variables for </span><strong class="source-inline"><span class="koboSpan" id="kobo.603.1">name</span></strong><span class="koboSpan" id="kobo.604.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.605.1">age</span></strong><span class="koboSpan" id="kobo.606.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.607.1">is_married</span></strong><span class="koboSpan" id="kobo.608.1">, and </span><strong class="source-inline"><span class="koboSpan" id="kobo.609.1">books_read_this_week</span></strong><span class="koboSpan" id="kobo.610.1">, we have a hash that groups all of these values into a single variable called </span><strong class="source-inline"><span class="koboSpan" id="kobo.611.1">person</span></strong><span class="koboSpan" id="kobo.612.1">. </span><span class="koboSpan" id="kobo.612.2">Now, we can reference each index, </span><span class="No-Break"><span class="koboSpan" id="kobo.613.1">as follows:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.614.1">
person["name"]
person["age"]
person["is_married"]
person["books_read_this_week"]</span></pre> <p><span class="koboSpan" id="kobo.615.1">Additionally, we could print a very readable message with </span><span class="No-Break"><span class="koboSpan" id="kobo.616.1">the following:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.617.1">
puts "#{person["name"]} is #{person["age"]} years old"</span></pre> <p><span class="koboSpan" id="kobo.618.1">Even for a developer who is just starting Ruby, this is not just readable but understandable regarding the intent of the code. </span><span class="koboSpan" id="kobo.618.2">As expected, it would output </span><span class="No-Break"><span class="koboSpan" id="kobo.619.1">the following:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.620.1">
Oscar is 35 years old</span></pre> <p><span class="koboSpan" id="kobo.621.1">Hashes are super useful when working with mapped data that needs to be read by a human. </span><span class="koboSpan" id="kobo.621.2">It’s also useful when you’re working with data that </span><span class="No-Break"><span class="koboSpan" id="kobo.622.1">is changing.</span></span></p>
<p><span class="koboSpan" id="kobo.623.1">This brings us to the last variable type that we’re going to see, which I must say is more complicated than I wish it were. </span><span class="koboSpan" id="kobo.623.2">The types</span><a id="_idIndexMarker124"/><span class="koboSpan" id="kobo.624.1"> of variables we’ve seen so far are mutable, which means that they can be changed. </span><span class="koboSpan" id="kobo.624.2">However, sometimes, we don’t need certain values to change – we need more of a location</span><a id="_idIndexMarker125"/><span class="koboSpan" id="kobo.625.1"> where this value is stored. </span><span class="koboSpan" id="kobo.625.2">Symbols do </span><span class="No-Break"><span class="koboSpan" id="kobo.626.1">just this.</span></span></p>
<h2 id="_idParaDest-49"><a id="_idTextAnchor050"/><span class="koboSpan" id="kobo.627.1">Symbols</span></h2>
<p><span class="koboSpan" id="kobo.628.1">Symbols are highly optimized identifiers</span><a id="_idIndexMarker126"/><span class="koboSpan" id="kobo.629.1"> that map immutable strings to fixed</span><a id="_idIndexMarker127"/><span class="koboSpan" id="kobo.630.1"> internal values. </span><span class="koboSpan" id="kobo.630.2">They are also immutable strings themselves – that is, they do not change </span><span class="No-Break"><span class="koboSpan" id="kobo.631.1">their value.</span></span></p>
<p><span class="koboSpan" id="kobo.632.1">The concept is a bit complex, but I believe it will be more understandable with an example. </span><span class="koboSpan" id="kobo.632.2">Let’s take a simple string and view what its value is pointing to. </span><span class="koboSpan" id="kobo.632.3">So, run </span><span class="No-Break"><span class="koboSpan" id="kobo.633.1">this code:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.634.1">
"name".object_id</span></pre> <p><span class="koboSpan" id="kobo.635.1">When you create a string, Ruby will take the string object and internally save it somewhere in memory. </span><span class="koboSpan" id="kobo.635.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.636.1">object_id</span></strong><span class="koboSpan" id="kobo.637.1"> method saves this internal unique identifier. </span><span class="koboSpan" id="kobo.637.2">Notice what happens when you call the same line a couple </span><span class="No-Break"><span class="koboSpan" id="kobo.638.1">of times:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.639.1">
irb(main):126:0&gt; "name".object_id
=&gt; 2391267760
irb(main):127:0&gt; "name".object_id
=&gt; 2391332180
irb(main):128:0&gt; "name".object_id
=&gt; 2391359800</span></pre> <p><span class="koboSpan" id="kobo.640.1">The first string is pointing to a different address than the second and third strings. </span><span class="koboSpan" id="kobo.640.2">So, every time we type the </span><strong class="source-inline"><span class="koboSpan" id="kobo.641.1">name</span></strong><span class="koboSpan" id="kobo.642.1"> string, Ruby creates and stores a brand new string. </span><span class="koboSpan" id="kobo.642.2">Even though they have the same value, they are still different. </span><span class="koboSpan" id="kobo.642.3">As an analogy, it would be like having a file with the same name but in different folders. </span><span class="koboSpan" id="kobo.642.4">Even if the files had the same contents, they are still </span><span class="No-Break"><span class="koboSpan" id="kobo.643.1">different files.</span></span></p>
<p><span class="koboSpan" id="kobo.644.1">This is not the same with symbols. </span><span class="koboSpan" id="kobo.644.2">Symbols refer to the same memory location. </span><span class="koboSpan" id="kobo.644.3">Let’s try the same example </span><span class="No-Break"><span class="koboSpan" id="kobo.645.1">with symbols:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.646.1">
:name.object_id</span></pre> <p><span class="koboSpan" id="kobo.647.1">This should also return a unique identifier number. </span><span class="koboSpan" id="kobo.647.2">However, what happens when we call this same code </span><span class="No-Break"><span class="koboSpan" id="kobo.648.1">multiple times?</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.649.1">
Irb(main):129:0&gt; :name.object_id
=&gt; 88028
irb(main):130:0&gt; :name.object_id
=&gt; 88028
irb(main):131:0&gt; :name.object_id
=&gt; 88028</span></pre> <p><span class="koboSpan" id="kobo.650.1">Instead of returning different random numbers, this time, we get the same (though still random) number. </span><span class="koboSpan" id="kobo.650.2">This is because every time we call </span><strong class="source-inline"><span class="koboSpan" id="kobo.651.1">:name</span></strong><span class="koboSpan" id="kobo.652.1">, the Ruby interpreter is looking at the same location in memory. </span><span class="koboSpan" id="kobo.652.2">Using the same analogy, it would be like creating a unique file, and then whenever we needed the file again, we would create links that would point to that original file. </span><span class="koboSpan" id="kobo.652.3">So, even if the links were in different folders, they would point to the </span><span class="No-Break"><span class="koboSpan" id="kobo.653.1">same file.</span></span></p>
<p><span class="koboSpan" id="kobo.654.1">We won’t dive into this subject further for now as it’s enough to just understand the basics of it, but we will see more examples in future chapters, particularly the Ruby on Rails ones. </span><span class="koboSpan" id="kobo.654.2">At the moment, just remember this good rule of thumb: use a symbol when the identity of an object is important. </span><span class="koboSpan" id="kobo.654.3">Should the content</span><a id="_idIndexMarker128"/><span class="koboSpan" id="kobo.655.1"> be more important, use </span><span class="No-Break"><span class="koboSpan" id="kobo.656.1">a string.</span></span></p>
<p><span class="koboSpan" id="kobo.657.1">If you would like to know</span><a id="_idIndexMarker129"/><span class="koboSpan" id="kobo.658.1"> more about symbols</span><a id="_idIndexMarker130"/><span class="koboSpan" id="kobo.659.1"> now, the following website is a great </span><span class="No-Break"><span class="koboSpan" id="kobo.660.1">resource: </span></span><a href="https://medium.com/@lcriswell/ruby-symbols-vs-strings-248842529fd9"><span class="No-Break"><span class="koboSpan" id="kobo.661.1">https://medium.com/@lcriswell/ruby-symbols-vs-strings-248842529fd9</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.662.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.663.1">So far, we’ve learned all about variables. </span><span class="koboSpan" id="kobo.663.2">But what good is a variable if we can’t make decisions regarding these variables? </span><span class="koboSpan" id="kobo.663.3">That’s our </span><span class="No-Break"><span class="koboSpan" id="kobo.664.1">next topic.</span></span></p>
<h1 id="_idParaDest-50"><a id="_idTextAnchor051"/><span class="koboSpan" id="kobo.665.1">Using conditional statements</span></h1>
<p><span class="koboSpan" id="kobo.666.1">Now that we know what types</span><a id="_idIndexMarker131"/><span class="koboSpan" id="kobo.667.1"> of variables we can use in Ruby, let’s give these variables some more </span><span class="No-Break"><span class="koboSpan" id="kobo.668.1">practical use.</span></span></p>
<h2 id="_idParaDest-51"><a id="_idTextAnchor052"/><span class="koboSpan" id="kobo.669.1">The if statement</span></h2>
<p><span class="koboSpan" id="kobo.670.1">By now, we should</span><a id="_idIndexMarker132"/><span class="koboSpan" id="kobo.671.1"> all be familiar with the </span><strong class="source-inline"><span class="koboSpan" id="kobo.672.1">if</span></strong><span class="koboSpan" id="kobo.673.1"> statement and its structure: if a sentence</span><a id="_idIndexMarker133"/><span class="koboSpan" id="kobo.674.1"> is true, the code should do or </span><span class="No-Break"><span class="koboSpan" id="kobo.675.1">return something.</span></span></p>
<p><span class="koboSpan" id="kobo.676.1">Let’s take the person hash that we used in the previous section as </span><span class="No-Break"><span class="koboSpan" id="kobo.677.1">our base:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.678.1">
person = { "name" =&gt; "Oscar", "age" =&gt; 35, "is_married" =&gt; true, "books_read_this_week" =&gt; 2.5 }</span></pre> <p><span class="koboSpan" id="kobo.679.1">Using that, we can create a basic </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.680.1">if</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.681.1"> statement:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.682.1">
if person["is_married"] == true
  puts "Person is married"
end</span></pre> <p><span class="koboSpan" id="kobo.683.1">This is pretty much self-explanatory. </span><span class="koboSpan" id="kobo.683.2">This would read: “If the value in </span><strong class="source-inline"><span class="koboSpan" id="kobo.684.1">person["married"]</span></strong><span class="koboSpan" id="kobo.685.1"> is equal to true, then print </span><strong class="source-inline"><span class="koboSpan" id="kobo.686.1">Person is married</span></strong><span class="koboSpan" id="kobo.687.1">.” </span><span class="koboSpan" id="kobo.687.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.688.1">end</span></strong><span class="koboSpan" id="kobo.689.1"> keyword limits when the </span><strong class="source-inline"><span class="koboSpan" id="kobo.690.1">if</span></strong><span class="koboSpan" id="kobo.691.1"> statement is done – that is, anything after the </span><strong class="source-inline"><span class="koboSpan" id="kobo.692.1">end</span></strong><span class="koboSpan" id="kobo.693.1"> keyword is not part of the block. </span><span class="koboSpan" id="kobo.693.2">You’ll see the end </span><strong class="source-inline"><span class="koboSpan" id="kobo.694.1">key</span></strong><span class="koboSpan" id="kobo.695.1"> keyword a lot in Ruby – just keep in mind that it is used to delimit certain blocks </span><span class="No-Break"><span class="koboSpan" id="kobo.696.1">of code.</span></span></p>
<p><span class="koboSpan" id="kobo.697.1">While the previous code is useful, there is a better way to write this – the “Ruby way.” </span><span class="koboSpan" id="kobo.697.2">First, we remove </span><strong class="source-inline"><span class="koboSpan" id="kobo.698.1">== true</span></strong><span class="koboSpan" id="kobo.699.1"> and if we are only going to execute a single action, we can write it in </span><span class="No-Break"><span class="koboSpan" id="kobo.700.1">one line:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.701.1">
puts "Person is married" if person["is_married"]</span></pre> <p><span class="koboSpan" id="kobo.702.1">This reads much like a sentence</span><a id="_idIndexMarker134"/><span class="koboSpan" id="kobo.703.1"> and you’ll see a lot of Rubyists</span><a id="_idIndexMarker135"/><span class="koboSpan" id="kobo.704.1"> using this </span><span class="No-Break"><span class="koboSpan" id="kobo.705.1">useful one-liner.</span></span></p>
<h2 id="_idParaDest-52"><a id="_idTextAnchor053"/><span class="koboSpan" id="kobo.706.1">The if-else statement</span></h2>
<p><span class="koboSpan" id="kobo.707.1">If you need a different action</span><a id="_idIndexMarker136"/><span class="koboSpan" id="kobo.708.1"> in case the value is not true, then you should</span><a id="_idIndexMarker137"/><span class="koboSpan" id="kobo.709.1"> use the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.710.1">if-else</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.711.1"> structure:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.712.1">
if person["age"] &lt; 31
  puts "This person is under 30"
else
  puts "This person is over 30"
end</span></pre> <p><span class="koboSpan" id="kobo.713.1">This would output </span><span class="No-Break"><span class="koboSpan" id="kobo.714.1">the following:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.715.1">
This person is over 30</span></pre> <p><span class="koboSpan" id="kobo.716.1">Just remember, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.717.1">if</span></strong><span class="koboSpan" id="kobo.718.1"> statement evaluates the condition. </span><span class="koboSpan" id="kobo.718.2">If the condition is true, Ruby executes the code that is on the next line. </span><span class="koboSpan" id="kobo.718.3">However, if the condition is false, Ruby skips the first block, goes to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.719.1">else</span></strong><span class="koboSpan" id="kobo.720.1"> statement, and executes</span><a id="_idIndexMarker138"/><span class="koboSpan" id="kobo.721.1"> the code that is right</span><a id="_idIndexMarker139"/><span class="koboSpan" id="kobo.722.1"> after the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.723.1">else</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.724.1"> keyword.</span></span></p>
<h2 id="_idParaDest-53"><a id="_idTextAnchor054"/><span class="koboSpan" id="kobo.725.1">The ternary operator</span></h2>
<p><span class="koboSpan" id="kobo.726.1">As a last example of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.727.1">if</span></strong><span class="koboSpan" id="kobo.728.1"> statement, we also have</span><a id="_idIndexMarker140"/><span class="koboSpan" id="kobo.729.1"> the ternary operator, which we also have</span><a id="_idIndexMarker141"/><span class="koboSpan" id="kobo.730.1"> in other coding languages; though it’s not as readable, it’s still useful. </span><span class="koboSpan" id="kobo.730.2">Let’s see </span><span class="No-Break"><span class="koboSpan" id="kobo.731.1">an example:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.732.1">
over_or_under = person["age"] &gt; 31 ? </span><span class="koboSpan" id="kobo.732.2">"over" : "under"
puts "This person is #{over_or_under} 30"</span></pre> <p><span class="koboSpan" id="kobo.733.1">With the ternary operator, the condition between the </span><strong class="source-inline"><span class="koboSpan" id="kobo.734.1">=</span></strong><span class="koboSpan" id="kobo.735.1"> sign and </span><strong class="source-inline"><span class="koboSpan" id="kobo.736.1">?</span></strong><span class="koboSpan" id="kobo.737.1"> will be evaluated. </span><span class="koboSpan" id="kobo.737.2">If the condition is deemed as true, then the value to the left of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.738.1">:</span></strong><span class="koboSpan" id="kobo.739.1"> symbol is returned. </span><span class="koboSpan" id="kobo.739.2">If the condition is deemed as false, then the value to the right of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.740.1">:</span></strong><span class="koboSpan" id="kobo.741.1"> symbol is returned. </span><span class="koboSpan" id="kobo.741.2">In this case, the value stored in </span><strong class="source-inline"><span class="koboSpan" id="kobo.742.1">person["age"]</span></strong><span class="koboSpan" id="kobo.743.1"> is 35. </span><span class="koboSpan" id="kobo.743.2">Since 35 is over 30, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.744.1">over</span></strong><span class="koboSpan" id="kobo.745.1"> string will be stored in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.746.1">over_or_under</span></strong><span class="koboSpan" id="kobo.747.1"> variable. </span><span class="koboSpan" id="kobo.747.2">The second line of code will simply interpolate this value and should </span><span class="No-Break"><span class="koboSpan" id="kobo.748.1">return this:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.749.1">
This person is over 30</span></pre> <p><span class="koboSpan" id="kobo.750.1">While this is not as readable as the previous </span><strong class="source-inline"><span class="koboSpan" id="kobo.751.1">if</span></strong><span class="koboSpan" id="kobo.752.1"> statements, the code is still valid and available in most programming languages. </span><span class="koboSpan" id="kobo.752.2">The ternary operator is the same in PHP and is useful when you need to store a value that depends on </span><span class="No-Break"><span class="koboSpan" id="kobo.753.1">a condition.</span></span></p>
<p><span class="koboSpan" id="kobo.754.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.755.1">if</span></strong><span class="koboSpan" id="kobo.756.1"> statement is probably one of the most used resources in programming, so it’s a good idea to understand the syntax, the use, and the different use cases that it solves. </span><span class="koboSpan" id="kobo.756.2">Now, let’s look at another resource that uses true/false values to </span><span class="No-Break"><span class="koboSpan" id="kobo.757.1">run code.</span></span></p>
<h1 id="_idParaDest-54"><a id="_idTextAnchor055"/><span class="koboSpan" id="kobo.758.1">Repeating code with loops</span></h1>
<p><span class="koboSpan" id="kobo.759.1">We have come to our next topic, which</span><a id="_idIndexMarker142"/><span class="koboSpan" id="kobo.760.1"> is loops. </span><span class="koboSpan" id="kobo.760.2">Ruby, just like other languages, has different</span><a id="_idIndexMarker143"/><span class="koboSpan" id="kobo.761.1"> ways of making the same code execute repeatedly. </span><span class="koboSpan" id="kobo.761.2">When we discussed arrays, specifically the array that contained instruments’ names, we saw an example of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.762.1">for</span></strong><span class="koboSpan" id="kobo.763.1"> loop, which was used to print each instrument contained in the array. </span><span class="koboSpan" id="kobo.763.2">But let’s look at another type of loop, one that is more commonly used: the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.764.1">while</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.765.1"> loop.</span></span></p>
<p><span class="koboSpan" id="kobo.766.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.767.1">while</span></strong><span class="koboSpan" id="kobo.768.1"> loop lets us repeat a code execution that is determined by a true/false condition. </span><span class="koboSpan" id="kobo.768.2">Let’s say we wanted to print a number from one to three. </span><span class="koboSpan" id="kobo.768.3">We could create a </span><strong class="source-inline"><span class="koboSpan" id="kobo.769.1">print</span></strong><span class="koboSpan" id="kobo.770.1"> statement and simply repeat it three times while incrementing the value. </span><span class="koboSpan" id="kobo.770.2">However, let’s try a different way</span><a id="_idIndexMarker144"/><span class="koboSpan" id="kobo.771.1"> that will be more concise. </span><span class="koboSpan" id="kobo.771.2">Start by creating a </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.772.1">counter</span></strong></span><span class="No-Break"><a id="_idIndexMarker145"/></span><span class="No-Break"><span class="koboSpan" id="kobo.773.1"> variable:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.774.1">
counter = 1</span></pre> <p><span class="koboSpan" id="kobo.775.1">Now, we can start the </span><strong class="source-inline"><span class="koboSpan" id="kobo.776.1">while</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.777.1">loop cycle:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.778.1">
while counter &lt;= 3
  puts counter
  counter++
end</span></pre> <p><span class="koboSpan" id="kobo.779.1">This may seem like valid code, but we will get an error from the </span><span class="No-Break"><span class="koboSpan" id="kobo.780.1">Ruby interpreter:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.781.1">
Traceback (most recent call last):
        3: from /usr/bin/irb:23:in `&lt;main&gt;'
        2: from /usr/bin/irb:23:in `load'
        1: from /Library/Ruby/Gems/2.6.0/gems/irb-1.0.0/exe/irb:11:in `&lt;top (required)&gt;'
SyntaxError ((irb):205: syntax error, unexpected end)</span></pre> <p><span class="koboSpan" id="kobo.782.1">This is because of a common erroneous assumption that most Ruby newbies make. </span><span class="koboSpan" id="kobo.782.2">If you use PHP or JavaScript, you will be used to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.783.1">++</span></strong><span class="koboSpan" id="kobo.784.1"> operator, which is equivalent to adding 1 to a variable. </span><span class="koboSpan" id="kobo.784.2">It’s the same as writing </span><span class="No-Break"><span class="koboSpan" id="kobo.785.1">the following:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.786.1">
counter = counter + 1</span></pre> <p><span class="koboSpan" id="kobo.787.1">However, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.788.1">++</span></strong><span class="koboSpan" id="kobo.789.1"> operator does not exist in Ruby (so this also goes for the </span><strong class="source-inline"><span class="koboSpan" id="kobo.790.1">––</span></strong><span class="koboSpan" id="kobo.791.1"> operator, which decreases a value by 1). </span><span class="koboSpan" id="kobo.791.2">So, instead of using the nonexistent operator in Ruby, we would have to rewrite our code so that it looks </span><span class="No-Break"><span class="koboSpan" id="kobo.792.1">like this:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.793.1">
while counter &lt;= 3
  puts counter
  counter += 1
end</span></pre> <p><span class="koboSpan" id="kobo.794.1">This would output </span><span class="No-Break"><span class="koboSpan" id="kobo.795.1">the following:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.796.1">
1
2
3
=&gt; nil</span></pre> <p><span class="koboSpan" id="kobo.797.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.798.1">while</span></strong><span class="koboSpan" id="kobo.799.1"> statement has a very similar structure to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.800.1">if</span></strong><span class="koboSpan" id="kobo.801.1"> statement, but instead of just executing a line of code, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.802.1">while</span></strong><span class="koboSpan" id="kobo.803.1"> statement evaluates the condition and will execute the code if the condition is </span><span class="No-Break"><span class="koboSpan" id="kobo.804.1">still met.</span></span></p>
<p><span class="koboSpan" id="kobo.805.1">In this case, before entering</span><a id="_idIndexMarker146"/><span class="koboSpan" id="kobo.806.1"> the cycle, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.807.1">counter</span></strong><span class="koboSpan" id="kobo.808.1"> variable has a value of </span><strong class="source-inline"><span class="koboSpan" id="kobo.809.1">1</span></strong><span class="koboSpan" id="kobo.810.1"> – as the condition</span><a id="_idIndexMarker147"/><span class="koboSpan" id="kobo.811.1"> to continue the cycle is for the value to be less than or equal to 3, the condition is met. </span><span class="koboSpan" id="kobo.811.2">Since the condition is met, Ruby will execute the code that is before the </span><strong class="source-inline"><span class="koboSpan" id="kobo.812.1">end</span></strong><span class="koboSpan" id="kobo.813.1"> keyword, so the number 1 will be printed and a 1 will be added to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.814.1">counter</span></strong><span class="koboSpan" id="kobo.815.1"> variable. </span><span class="koboSpan" id="kobo.815.2">Since this is a cycle, Ruby will go back and read the condition again, but this time, </span><strong class="source-inline"><span class="koboSpan" id="kobo.816.1">counter</span></strong><span class="koboSpan" id="kobo.817.1"> has a value of </span><strong class="source-inline"><span class="koboSpan" id="kobo.818.1">2</span></strong><span class="koboSpan" id="kobo.819.1">, so it will execute the whole block again. </span><span class="koboSpan" id="kobo.819.2">Once the value of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.820.1">counter</span></strong><span class="koboSpan" id="kobo.821.1"> reaches </span><strong class="source-inline"><span class="koboSpan" id="kobo.822.1">4</span></strong><span class="koboSpan" id="kobo.823.1">, Ruby will determine that the </span><strong class="source-inline"><span class="koboSpan" id="kobo.824.1">while</span></strong><span class="koboSpan" id="kobo.825.1"> condition is no longer met and break the loop without executing the code inside </span><span class="No-Break"><span class="koboSpan" id="kobo.826.1">it again.</span></span></p>
<p><span class="koboSpan" id="kobo.827.1">A more useful example of loops is when we work with arrays. </span><span class="koboSpan" id="kobo.827.2">We already saw one way to iterate through arrays with a counter, but we also have a method called </span><strong class="source-inline"><span class="koboSpan" id="kobo.828.1">each</span></strong><span class="koboSpan" id="kobo.829.1"> to iterate through every element of an array. </span><span class="koboSpan" id="kobo.829.2">Let’s take the </span><strong class="source-inline"><span class="koboSpan" id="kobo.830.1">instruments_played</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.831.1">array again:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.832.1">
instruments_played = ["guitar", "drums", "bass", "ukulele"]</span></pre> <p><span class="koboSpan" id="kobo.833.1">We can use </span><strong class="source-inline"><span class="koboSpan" id="kobo.834.1">each</span></strong><span class="koboSpan" id="kobo.835.1"> to go through each element, </span><span class="No-Break"><span class="koboSpan" id="kobo.836.1">like this:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.837.1">
instruments_played.each do |instrument|
puts instrument
end</span></pre> <p><span class="koboSpan" id="kobo.838.1">This code will loop through the array so that we don’t have to repeat code for every element of said array. </span><span class="koboSpan" id="kobo.838.2">And this is exactly what loops are for: to write less code. </span><span class="koboSpan" id="kobo.838.3">For every element in the array, Ruby will print the value of the element (we called it </span><strong class="source-inline"><span class="koboSpan" id="kobo.839.1">instrument</span></strong><span class="koboSpan" id="kobo.840.1"> for readability, and just for this example, but we can call it anything </span><span class="No-Break"><span class="koboSpan" id="kobo.841.1">we want).</span></span></p>
<p><span class="koboSpan" id="kobo.842.1">Additionally, we can compress this code into a single line by using curly brackets, </span><span class="No-Break"><span class="koboSpan" id="kobo.843.1">like so:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.844.1">
instruments_played.each { |instrument| puts instrument  }</span></pre> <p><span class="koboSpan" id="kobo.845.1">This will have the same output</span><a id="_idIndexMarker148"/><span class="koboSpan" id="kobo.846.1"> as the previous example, but as you can see, it’s more concise</span><a id="_idIndexMarker149"/><span class="koboSpan" id="kobo.847.1"> and it’s quite readable. </span><span class="koboSpan" id="kobo.847.2">Additionally, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.848.1">each</span></strong><span class="koboSpan" id="kobo.849.1"> loop helps us write code that will adapt to the size of the contents. </span><span class="koboSpan" id="kobo.849.2">Should we add another element to the array, we would not have to modify anything within our loop to print the added instrument. </span><span class="koboSpan" id="kobo.849.3">The loop would do </span><span class="No-Break"><span class="koboSpan" id="kobo.850.1">so automatically.</span></span></p>
<p><span class="koboSpan" id="kobo.851.1">Lastly, what happens when we want to access the index of an array? </span><span class="koboSpan" id="kobo.851.2">We have a method just for that. </span><span class="koboSpan" id="kobo.851.3">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.852.1">each_with_index</span></strong><span class="koboSpan" id="kobo.853.1"> method will make the index of the array available, as you can see in </span><span class="No-Break"><span class="koboSpan" id="kobo.854.1">this example:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.855.1">
instruments_played.each_with_index do |instrument, index|
puts "#{index}: #{instrument}"
end</span></pre> <p><span class="koboSpan" id="kobo.856.1">This code will output </span><span class="No-Break"><span class="koboSpan" id="kobo.857.1">the following:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.858.1">
0: guitar
1: drums
2: bass
3: ukulele
=&gt; ["guitar", "drums", "bass", "ukulele"]</span></pre> <p><span class="koboSpan" id="kobo.859.1">Again, both </span><strong class="source-inline"><span class="koboSpan" id="kobo.860.1">instrument</span></strong><span class="koboSpan" id="kobo.861.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.862.1">index</span></strong><span class="koboSpan" id="kobo.863.1"> are just aliases – we can name them anything we choose – but the order in which we type them is what will decide which value will be stored in them. </span><span class="koboSpan" id="kobo.863.2">The array element value will be stored in the first variable (</span><strong class="source-inline"><span class="koboSpan" id="kobo.864.1">instrument</span></strong><span class="koboSpan" id="kobo.865.1">) and the array counter will be stored in the second </span><span class="No-Break"><span class="koboSpan" id="kobo.866.1">variable (</span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.867.1">index</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.868.1">).</span></span></p>
<p><span class="koboSpan" id="kobo.869.1">We could very well rewrite the example, like so, and still get the </span><span class="No-Break"><span class="koboSpan" id="kobo.870.1">same output:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.871.1">
instruments_played.each_with_index do |array_element, array_index|
puts "#{array_index}: #{array_element}"
end</span></pre> <p><span class="koboSpan" id="kobo.872.1">The new code will have the same output as before, but this time, we renamed </span><strong class="source-inline"><span class="koboSpan" id="kobo.873.1">instrument</span></strong><span class="koboSpan" id="kobo.874.1"> and its </span><strong class="source-inline"><span class="koboSpan" id="kobo.875.1">index</span></strong><span class="koboSpan" id="kobo.876.1"> to </span><strong class="source-inline"><span class="koboSpan" id="kobo.877.1">array_element</span></strong><span class="koboSpan" id="kobo.878.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.879.1">array_index</span></strong><span class="koboSpan" id="kobo.880.1">, which at this point was just a personal choice I made to make the code make more sense to me. </span><span class="koboSpan" id="kobo.880.2">This goes to show that, as programmers, we decide how to name variables in the defense of readability (trust me – the more you grow as a programmer, the more time you’ll spend trying to </span><span class="No-Break"><span class="koboSpan" id="kobo.881.1">name variables).</span></span></p>
<p><span class="koboSpan" id="kobo.882.1">At this point, we know how to repeat code by using loops and by iterating through arrays. </span><span class="koboSpan" id="kobo.882.2">Instead of writing the same code multiple times, we exploited Ruby’s </span><strong class="source-inline"><span class="koboSpan" id="kobo.883.1">while</span></strong><span class="koboSpan" id="kobo.884.1"> statement and the </span><strong class="source-inline"><span class="koboSpan" id="kobo.885.1">each</span></strong><span class="koboSpan" id="kobo.886.1"> method to improve efficiency and readability within our code. </span><span class="koboSpan" id="kobo.886.2">But we are not done yet. </span><span class="koboSpan" id="kobo.886.3">Ruby has a few more tricks</span><a id="_idIndexMarker150"/><span class="koboSpan" id="kobo.887.1"> up its sleeve to further improve readability. </span><span class="koboSpan" id="kobo.887.2">We’ll take a look at these tricks</span><a id="_idIndexMarker151"/><span class="koboSpan" id="kobo.888.1"> in the </span><span class="No-Break"><span class="koboSpan" id="kobo.889.1">next section.</span></span></p>
<h1 id="_idParaDest-55"><a id="_idTextAnchor056"/><span class="koboSpan" id="kobo.890.1">Using Ruby language enhancements</span></h1>
<p><span class="koboSpan" id="kobo.891.1">For the most part, as developers, we should</span><a id="_idIndexMarker152"/><span class="koboSpan" id="kobo.892.1"> always strive to increase the readability of our code as this will help everyone in the long run. </span><span class="koboSpan" id="kobo.892.2">I’ve been in scenarios where I’ve looked back at my code and had trouble understanding what the code was doing. </span><span class="koboSpan" id="kobo.892.3">That meant that my code was poorly written. </span><span class="koboSpan" id="kobo.892.4">Imagine the toll that this poorly written code may have on the next developer or team that has to use it or, worse, improve it. </span><span class="koboSpan" id="kobo.892.5">In contrast, if my code was well written, we wouldn’t have this issue. </span><span class="koboSpan" id="kobo.892.6">This is me saying this: please write readable code, and I can’t stress enough the lengths Ruby developers will go to make their code readable over any other enhancement in our code. </span><span class="koboSpan" id="kobo.892.7">Ruby comes with some additional tools to </span><span class="No-Break"><span class="koboSpan" id="kobo.893.1">achieve this.</span></span></p>
<h2 id="_idParaDest-56"><a id="_idTextAnchor057"/><span class="koboSpan" id="kobo.894.1">The unless sentence</span></h2>
<p><span class="koboSpan" id="kobo.895.1">One example of these</span><a id="_idIndexMarker153"/><span class="koboSpan" id="kobo.896.1"> options is a language enhancement called the </span><strong class="source-inline"><span class="koboSpan" id="kobo.897.1">unless</span></strong><span class="koboSpan" id="kobo.898.1"> sentence. </span><span class="koboSpan" id="kobo.898.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.899.1">unless</span></strong><span class="koboSpan" id="kobo.900.1"> sentence</span><a id="_idIndexMarker154"/><span class="koboSpan" id="kobo.901.1"> is a negative </span><strong class="source-inline"><span class="koboSpan" id="kobo.902.1">if</span></strong><span class="koboSpan" id="kobo.903.1"> sentence – that is, it will execute the code only when the condition is </span><em class="italic"><span class="koboSpan" id="kobo.904.1">not</span></em><span class="koboSpan" id="kobo.905.1"> met. </span><span class="koboSpan" id="kobo.905.2">Let’s see it being used in </span><span class="No-Break"><span class="koboSpan" id="kobo.906.1">an example.</span></span></p>
<p><span class="koboSpan" id="kobo.907.1">Let’s assume the following scenario: we have a product aimed at unmarried individuals. </span><span class="koboSpan" id="kobo.907.2">For simplicity, we will just print out the message “Promo for singles” if the person is not married. </span><span class="koboSpan" id="kobo.907.3">Let’s try to write the code for that. </span><span class="koboSpan" id="kobo.907.4">Let’s take our previous hash example for a </span><span class="No-Break"><span class="koboSpan" id="kobo.908.1">person’s details:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.909.1">
person = { "name" =&gt; "Oscar", "age" =&gt; 35, "is_married" =&gt; true, "books_read_this_week" =&gt; 2.5 }</span></pre> <p><span class="koboSpan" id="kobo.910.1">Now, let’s change the </span><strong class="source-inline"><span class="koboSpan" id="kobo.911.1">is_married</span></strong><span class="koboSpan" id="kobo.912.1"> value </span><span class="No-Break"><span class="koboSpan" id="kobo.913.1">to </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.914.1">false</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.915.1">:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.916.1">
person = { "name" =&gt; "Oscar", "age" =&gt; 35, "is_married" =&gt; false, "books_read_this_week" =&gt; 2.5 }</span></pre> <p><span class="koboSpan" id="kobo.917.1">Once we have declared that hash, we can try to print a message if the person </span><span class="No-Break"><span class="koboSpan" id="kobo.918.1">is single:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.919.1">
puts "Promo for singles" if person["is_married"] == false</span></pre> <p><span class="koboSpan" id="kobo.920.1">Because the person is not married, the output is </span><span class="No-Break"><span class="koboSpan" id="kobo.921.1">as follows:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.922.1">
Promo for singles</span></pre> <p><span class="koboSpan" id="kobo.923.1">And while the code works, it simply</span><a id="_idIndexMarker155"/><span class="koboSpan" id="kobo.924.1"> doesn’t look good. </span><span class="koboSpan" id="kobo.924.2">We could</span><a id="_idIndexMarker156"/><span class="koboSpan" id="kobo.925.1"> use the bang (</span><strong class="source-inline"><span class="koboSpan" id="kobo.926.1">!</span></strong><span class="koboSpan" id="kobo.927.1">) operator to invert the Boolean value from true </span><span class="No-Break"><span class="koboSpan" id="kobo.928.1">to false:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.929.1">
puts "Show promotion" if !person["is_married"]</span></pre> <p><span class="koboSpan" id="kobo.930.1">Though this code still works, it still looks bad. </span><span class="koboSpan" id="kobo.930.2">Let’s look at the options Ruby has to </span><span class="No-Break"><span class="koboSpan" id="kobo.931.1">fix this.</span></span></p>
<p><span class="koboSpan" id="kobo.932.1">In most programming languages, you’ll see a lot of sentences that read “if not.” </span><span class="koboSpan" id="kobo.932.2">Of course, this is awful to read and goes against the readability principles of Ruby. </span><span class="koboSpan" id="kobo.932.3">To solve this issue, Ruby’s creators added the exact sentence to make this more readable: </span><strong class="source-inline"><span class="koboSpan" id="kobo.933.1">unless</span></strong><span class="koboSpan" id="kobo.934.1">. </span><span class="koboSpan" id="kobo.934.2">It works similarly to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.935.1">if</span></strong><span class="koboSpan" id="kobo.936.1"> statement but will execute the code if the condition is </span><span class="No-Break"><span class="koboSpan" id="kobo.937.1">deemed false.</span></span></p>
<p><span class="koboSpan" id="kobo.938.1">In this case, this is helpful when we have code to be executed only when the person is not married. </span><span class="koboSpan" id="kobo.938.2">So, instead of writing an if negative sentence (if a person is </span><em class="italic"><span class="koboSpan" id="kobo.939.1">not</span></em><span class="koboSpan" id="kobo.940.1"> married), </span><strong class="source-inline"><span class="koboSpan" id="kobo.941.1">if !person["is_married"]</span></strong><span class="koboSpan" id="kobo.942.1">, we could rewrite the example as follows (unless a person </span><span class="No-Break"><span class="koboSpan" id="kobo.943.1">is married):</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.944.1">
unless person["is_married"]
  puts "Show promotion"
end</span></pre> <p><span class="koboSpan" id="kobo.945.1">This is looking much better already, but just like the </span><strong class="source-inline"><span class="koboSpan" id="kobo.946.1">if</span></strong><span class="koboSpan" id="kobo.947.1"> statement, we can convert it into </span><span class="No-Break"><span class="koboSpan" id="kobo.948.1">a one-liner:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.949.1">
puts "Show promotion" unless person["is_married"]</span></pre> <p><span class="koboSpan" id="kobo.950.1">This is a very Ruby-esque sentence, reading exactly like it behaves: “Print “Show promotion” unless the person is married.” </span><span class="koboSpan" id="kobo.950.2">This is about as readable as </span><span class="No-Break"><span class="koboSpan" id="kobo.951.1">it gets.</span></span></p>
<p><span class="koboSpan" id="kobo.952.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.953.1">unless</span></strong><span class="koboSpan" id="kobo.954.1"> sentence</span><a id="_idIndexMarker157"/><span class="koboSpan" id="kobo.955.1"> is so useful that one of the most used PHP frameworks today, called Laravel, has borrowed</span><a id="_idIndexMarker158"/><span class="koboSpan" id="kobo.956.1"> this functionality in the form</span><a id="_idIndexMarker159"/><span class="koboSpan" id="kobo.957.1"> of a </span><span class="No-Break"><span class="koboSpan" id="kobo.958.1">directive: </span></span><a href="https://laravel.com/docs/9.x/blade#if-statements"><span class="No-Break"><span class="koboSpan" id="kobo.959.1">https://laravel.com/docs/9.x/blade#if-statements</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.960.1">.</span></span></p>
<h2 id="_idParaDest-57"><a id="_idTextAnchor058"/><span class="koboSpan" id="kobo.961.1">The until loop</span></h2>
<p><span class="koboSpan" id="kobo.962.1">Just like the </span><strong class="source-inline"><span class="koboSpan" id="kobo.963.1">unless</span></strong><span class="koboSpan" id="kobo.964.1"> sentence, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.965.1">until</span></strong><span class="koboSpan" id="kobo.966.1"> loop solves</span><a id="_idIndexMarker160"/><span class="koboSpan" id="kobo.967.1"> the same issue with </span><span class="No-Break"><span class="koboSpan" id="kobo.968.1">negative</span></span><span class="No-Break"><a id="_idIndexMarker161"/></span><span class="No-Break"><span class="koboSpan" id="kobo.969.1"> conditions.</span></span></p>
<p><span class="koboSpan" id="kobo.970.1">Instead of writing “while not,” which reads horribly, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.971.1">until</span></strong><span class="koboSpan" id="kobo.972.1"> sentence takes a false statement and executes the loop until the condition </span><span class="No-Break"><span class="koboSpan" id="kobo.973.1">becomes true.</span></span></p>
<p><span class="koboSpan" id="kobo.974.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.975.1">until</span></strong><span class="koboSpan" id="kobo.976.1"> sentence takes a false statement and executes the loop until the condition becomes true. </span><span class="koboSpan" id="kobo.976.2">Let’s look at our </span><strong class="source-inline"><span class="koboSpan" id="kobo.977.1">while</span></strong><span class="koboSpan" id="kobo.978.1"> example from </span><span class="No-Break"><span class="koboSpan" id="kobo.979.1">earlier again:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.980.1">
counter = 1
while counter &lt;= 3
  puts counter
  counter += 1
end</span></pre> <p><span class="koboSpan" id="kobo.981.1">Using </span><strong class="source-inline"><span class="koboSpan" id="kobo.982.1">until</span></strong><span class="koboSpan" id="kobo.983.1">, we can rewrite it </span><span class="No-Break"><span class="koboSpan" id="kobo.984.1">as follows:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.985.1">
counter = 1
until counter &gt; 3
  puts counter
  counter += 1
end</span></pre> <p><span class="koboSpan" id="kobo.986.1">The output is the same as with the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.987.1">while</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.988.1"> statement:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.989.1">
1
2
3
=&gt; nil</span></pre> <p><span class="koboSpan" id="kobo.990.1">Our code would read like “Print the counter until the counter is larger than 3.” </span><span class="koboSpan" id="kobo.990.2">Whether you choose to use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.991.1">while not</span></strong><span class="koboSpan" id="kobo.992.1"> sentence or the </span><strong class="source-inline"><span class="koboSpan" id="kobo.993.1">until</span></strong><span class="koboSpan" id="kobo.994.1"> sentence will be up to you as they both seem readable, but the fact that Ruby</span><a id="_idIndexMarker162"/><span class="koboSpan" id="kobo.995.1"> has both sentences available tells us that Ruby is designed to be read</span><a id="_idIndexMarker163"/><span class="koboSpan" id="kobo.996.1"> and not </span><span class="No-Break"><span class="koboSpan" id="kobo.997.1">just programmed.</span></span></p>
<h2 id="_idParaDest-58"><a id="_idTextAnchor059"/><span class="koboSpan" id="kobo.998.1">Automatic returns</span></h2>
<p><span class="koboSpan" id="kobo.999.1">When working within the IRB, you may have noticed</span><a id="_idIndexMarker164"/><span class="koboSpan" id="kobo.1000.1"> that whenever you type variables, the IRB will output the value</span><a id="_idIndexMarker165"/><span class="koboSpan" id="kobo.1001.1"> you just typed. </span><span class="koboSpan" id="kobo.1001.2">Even on our last </span><strong class="source-inline"><span class="koboSpan" id="kobo.1002.1">until</span></strong><span class="koboSpan" id="kobo.1003.1"> statement example, the shell first outputs the three numbers and then a final </span><strong class="source-inline"><span class="koboSpan" id="kobo.1004.1">=&gt; nil</span></strong><span class="koboSpan" id="kobo.1005.1"> value. </span><span class="koboSpan" id="kobo.1005.2">If you take a closer look at the other examples, you’ll see a similar behavior. </span><span class="koboSpan" id="kobo.1005.3">This is because Ruby always attempts to return a value – be it a declaration, a method, or just a string, Ruby will try to automatically return </span><span class="No-Break"><span class="koboSpan" id="kobo.1006.1">a value.</span></span></p>
<p><span class="koboSpan" id="kobo.1007.1">If you’re not convinced, let’s use the IRB to see it more explicitly. </span><span class="koboSpan" id="kobo.1007.2">So, type </span><span class="No-Break"><span class="koboSpan" id="kobo.1008.1">the following:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1009.1">
"This is a string"</span></pre> <p><span class="koboSpan" id="kobo.1010.1">We are not declaring the string or assigning it to a value; we are simply typing a string into the IRB shell. </span><span class="koboSpan" id="kobo.1010.2">And what does the shell do? </span><span class="koboSpan" id="kobo.1010.3">It returns the value we </span><span class="No-Break"><span class="koboSpan" id="kobo.1011.1">just typed:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1012.1">
=&gt; "this is a string"</span></pre> <p><span class="koboSpan" id="kobo.1013.1">Coming from a PHP background (and other languages for that matter), grasping the “automatic return” feature is crucial to understanding more complex Ruby code. </span><span class="koboSpan" id="kobo.1013.2">It’s important to know that PHP (and most languages) do not behave this way. </span><span class="koboSpan" id="kobo.1013.3">PHP (and other languages) require us to explicitly return the value, while Ruby does this by default. </span><span class="koboSpan" id="kobo.1013.4">In PHP, this is achieved by using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1014.1">return</span></strong><span class="koboSpan" id="kobo.1015.1"> sentence. </span><span class="koboSpan" id="kobo.1015.2">That said, from time to time, you will encounter Ruby code with an explicit </span><strong class="source-inline"><span class="koboSpan" id="kobo.1016.1">return</span></strong><span class="koboSpan" id="kobo.1017.1"> statement, as it will sometimes increase readability. </span><span class="koboSpan" id="kobo.1017.2">To further understand this feature, for the next few examples, we’ll exit the IRB and continue by creating source code files and running Ruby to execute them. </span><span class="koboSpan" id="kobo.1017.3">You may still follow the next examples in the IRB, but I would highly recommend that you follow them with source code files instead of </span><span class="No-Break"><span class="koboSpan" id="kobo.1018.1">the IRB.</span></span></p>
<p><span class="koboSpan" id="kobo.1019.1">Let’s say we wanted to create a method that prints a message on the screen. </span><span class="koboSpan" id="kobo.1019.2">We can do so by creating a file called </span><strong class="source-inline"><span class="koboSpan" id="kobo.1020.1">methods.rb</span></strong><span class="koboSpan" id="kobo.1021.1">. </span><span class="koboSpan" id="kobo.1021.2">This file will contain the </span><span class="No-Break"><span class="koboSpan" id="kobo.1022.1">following code:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1023.1">
# methods.rb
def message()
  return "This is a message"
end</span></pre> <p><span class="koboSpan" id="kobo.1024.1">For now, we’re defining a method called </span><strong class="source-inline"><span class="koboSpan" id="kobo.1025.1">message</span></strong><span class="koboSpan" id="kobo.1026.1"> that returns a string. </span><span class="koboSpan" id="kobo.1026.2">In Ruby, we define a method with the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1027.1">def</span></strong><span class="koboSpan" id="kobo.1028.1"> reserved keyword and limit the definition with the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1029.1">end</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1030.1"> keyword.</span></span></p>
<p><span class="koboSpan" id="kobo.1031.1">Now, let’s add another method</span><a id="_idIndexMarker166"/><span class="koboSpan" id="kobo.1032.1"> called </span><strong class="source-inline"><span class="koboSpan" id="kobo.1033.1">say()</span></strong><span class="koboSpan" id="kobo.1034.1"> and, inside</span><a id="_idIndexMarker167"/><span class="koboSpan" id="kobo.1035.1"> that method, call the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1036.1">message()</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1037.1"> method:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1038.1">
 # methods.rb
...
</span><span class="koboSpan" id="kobo.1038.2">def say()
  message()
end</span></pre> <p><span class="koboSpan" id="kobo.1039.1">So far, we haven’t done anything out of the ordinary – we just have one method calling another. </span><span class="koboSpan" id="kobo.1039.2">If we opened a shell and executed this script, it would appear to be </span><span class="No-Break"><span class="koboSpan" id="kobo.1040.1">doing nothing:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1041.1">
ruby methods.rb</span></pre> <p><span class="koboSpan" id="kobo.1042.1">This script outputs nothing, but behind the scenes, it has two methods that are now defined and ready to be used. </span><span class="koboSpan" id="kobo.1042.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.1043.1">message</span></strong><span class="koboSpan" id="kobo.1044.1"> method is explicitly (not automatically) returning a string because of the use of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1045.1">return</span></strong><span class="koboSpan" id="kobo.1046.1"> keyword. </span><span class="koboSpan" id="kobo.1046.2">This code still looks familiar, but not </span><span class="No-Break"><span class="koboSpan" id="kobo.1047.1">for long.</span></span></p>
<p><span class="koboSpan" id="kobo.1048.1">Now, let’s print out the contents of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1049.1">say()</span></strong><span class="koboSpan" id="kobo.1050.1"> method with this last line on </span><span class="No-Break"><span class="koboSpan" id="kobo.1051.1">the code:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1052.1">
# methods.rb
...
</span><span class="koboSpan" id="kobo.1052.2">def say()
  return message()
end
puts say()</span></pre> <p><span class="koboSpan" id="kobo.1053.1">If we run this again, we will see the following message on </span><span class="No-Break"><span class="koboSpan" id="kobo.1054.1">the screen:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1055.1">
This is a message</span></pre> <p><span class="koboSpan" id="kobo.1056.1">And this is where Ruby behaves differently to PHP. </span><span class="koboSpan" id="kobo.1056.2">While you can explicitly use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1057.1">return</span></strong><span class="koboSpan" id="kobo.1058.1"> function in Ruby, Ruby does not need the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1059.1">return</span></strong><span class="koboSpan" id="kobo.1060.1"> statement because it already does it automatically as part of its default behavior. </span><span class="koboSpan" id="kobo.1060.2">So let's try it out by removing the return statement from both the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1061.1">message()</span></strong><span class="koboSpan" id="kobo.1062.1"> and the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1063.1">say()</span></strong><span class="koboSpan" id="kobo.1064.1"> methods. </span><span class="koboSpan" id="kobo.1064.2">Your final code should look </span><span class="No-Break"><span class="koboSpan" id="kobo.1065.1">like this:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1066.1">
# methods.rb
def message()
  "This is a message"
end
def say()
  message()
end
puts say()</span></pre> <p><span class="koboSpan" id="kobo.1067.1">Admittedly, this looks weird, especially for someone</span><a id="_idIndexMarker168"/><span class="koboSpan" id="kobo.1068.1"> from a PHP background. </span><span class="koboSpan" id="kobo.1068.2">My advice</span><a id="_idIndexMarker169"/><span class="koboSpan" id="kobo.1069.1"> to you is to just try to get used to this syntax. </span><span class="koboSpan" id="kobo.1069.2">You’ll see it very often in Ruby. </span><span class="koboSpan" id="kobo.1069.3">To make it easier to learn this rule, we can generalize and say, “Every sentence in Ruby will return a value.” </span><span class="koboSpan" id="kobo.1069.4">With some notable exceptions, this is true for all </span><span class="No-Break"><span class="koboSpan" id="kobo.1070.1">Ruby sentences.</span></span></p>
<h2 id="_idParaDest-59"><a id="_idTextAnchor060"/><span class="koboSpan" id="kobo.1071.1">Optional parentheses</span></h2>
<p><span class="koboSpan" id="kobo.1072.1">Another weird but useful syntactic enhancement</span><a id="_idIndexMarker170"/><span class="koboSpan" id="kobo.1073.1"> is that the parentheses </span><a id="_idIndexMarker171"/><span class="koboSpan" id="kobo.1074.1">on Ruby methods are purely optional – so, you can choose whether to include parentheses or not. </span><span class="koboSpan" id="kobo.1074.2">And just like every Ruby resource we’ve learned about so far, we should try to use it to make our code easier to read, but we should also try to avoid overusing it. </span><span class="koboSpan" id="kobo.1074.3">Excessive use of this feature could have us formatting our code </span><span class="No-Break"><span class="koboSpan" id="kobo.1075.1">like this:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1076.1">
method1 method2 parmeter1, parameter2</span></pre> <p><span class="koboSpan" id="kobo.1077.1">The problem with this snippet is that we don’t know if the comma is being used for separating the arguments for </span><strong class="source-inline"><span class="koboSpan" id="kobo.1078.1">method1</span></strong><span class="koboSpan" id="kobo.1079.1"> or </span><strong class="source-inline"><span class="koboSpan" id="kobo.1080.1">method2</span></strong><span class="koboSpan" id="kobo.1081.1">. </span><span class="koboSpan" id="kobo.1081.2">In this case, we should </span><span class="No-Break"><span class="koboSpan" id="kobo.1082.1">use parenthesis:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1083.1">
method1( method2( parameter1, parameter2 )</span></pre> <p><span class="koboSpan" id="kobo.1084.1">Now, it’s more than clear that </span><strong class="source-inline"><span class="koboSpan" id="kobo.1085.1">method2</span></strong><span class="koboSpan" id="kobo.1086.1"> is receiving two arguments while </span><strong class="source-inline"><span class="koboSpan" id="kobo.1087.1">method1</span></strong><span class="koboSpan" id="kobo.1088.1"> is just receiving one argument. </span><span class="koboSpan" id="kobo.1088.2">Let’s look at a more simplified example by removing the parenthesis from our previous examples. </span><span class="koboSpan" id="kobo.1088.3">Our example will now look </span><span class="No-Break"><span class="koboSpan" id="kobo.1089.1">like this:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1090.1">
# methods.rb
def message
  "This is a message"
end
def say
  puts message
end
say</span></pre> <p><span class="koboSpan" id="kobo.1091.1">The output is the same as before, but now, the code looks a lot more like proper sentences instead of code syntax. </span><span class="koboSpan" id="kobo.1091.2">You’ll see a lot of code similar to this, especially when you start using Ruby on Rails. </span><span class="koboSpan" id="kobo.1091.3">Because of the lack of parenthesis, Ruby allows us to have a method and a variable with the same name. </span><span class="koboSpan" id="kobo.1091.4">In this case, we have a method called </span><strong class="source-inline"><span class="koboSpan" id="kobo.1092.1">message</span></strong><span class="koboSpan" id="kobo.1093.1"> and a variable </span><span class="No-Break"><span class="koboSpan" id="kobo.1094.1">called </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1095.1">message</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1096.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.1097.1">This scenario, if left unexplained, can lead to a lot of confusion later on. </span><span class="koboSpan" id="kobo.1097.2">To that effect, let’s take our previous example and tweak it so that we have a better understanding of this naming behavior. </span><span class="koboSpan" id="kobo.1097.3">First, we’ll add a parameter to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1098.1">say()</span></strong><span class="koboSpan" id="kobo.1099.1"> method so that the printed message is dynamic. </span><span class="koboSpan" id="kobo.1099.2">This parameter will be </span><span class="No-Break"><span class="koboSpan" id="kobo.1100.1">named </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1101.1">message</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1102.1">:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1103.1">
# methods.rb
...
</span><span class="koboSpan" id="kobo.1103.2">def say message
  puts message
end
say "Now we can say anything"</span></pre> <p><span class="koboSpan" id="kobo.1104.1">In other programming languages, we would expect an error if we tried to run this code, and this is where Ruby can sometimes be overwhelming when you’re starting to use it. </span><span class="koboSpan" id="kobo.1104.2">We purposely named the parameter </span><strong class="source-inline"><span class="koboSpan" id="kobo.1105.1">message</span></strong><span class="koboSpan" id="kobo.1106.1">, which means we now have a </span><strong class="source-inline"><span class="koboSpan" id="kobo.1107.1">message</span></strong><span class="koboSpan" id="kobo.1108.1"> method and a </span><strong class="source-inline"><span class="koboSpan" id="kobo.1109.1">message</span></strong><span class="koboSpan" id="kobo.1110.1"> local variable. </span><span class="koboSpan" id="kobo.1110.2">When reaching the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1111.1">puts message</span></strong><span class="koboSpan" id="kobo.1112.1"> line, we are not sure if we are calling the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1113.1">message</span></strong><span class="koboSpan" id="kobo.1114.1"> parameter or the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1115.1">message</span></strong><span class="koboSpan" id="kobo.1116.1"> method without the parentheses. </span><span class="koboSpan" id="kobo.1116.2">Unfortunately, this confusion happens more often than not, or at least that was my experience when I started to use Ruby </span><span class="No-Break"><span class="koboSpan" id="kobo.1117.1">more professionally.</span></span></p>
<p><span class="koboSpan" id="kobo.1118.1">So, my advice here is to try to use parenthesis</span><a id="_idIndexMarker172"/><span class="koboSpan" id="kobo.1119.1"> when calling </span><a id="_idIndexMarker173"/><span class="koboSpan" id="kobo.1120.1">methods, even when the syntax doesn’t require us to use them. </span><span class="koboSpan" id="kobo.1120.2">For teaching purposes, we won’t be doing it in this example. </span><span class="koboSpan" id="kobo.1120.3">So, our final source code should look </span><span class="No-Break"><span class="koboSpan" id="kobo.1121.1">like this:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1122.1">
# methods.rb
def message
  return "This is a message"
end
def say message
  puts message
end
say "Now we can say anything"</span></pre> <p><span class="koboSpan" id="kobo.1123.1">As you would expect (or not), when executing the script on the shell, we’ll get the </span><span class="No-Break"><span class="koboSpan" id="kobo.1124.1">following output:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1125.1">
Now we can say anything</span></pre> <p><span class="koboSpan" id="kobo.1126.1">Why did it print that string and not the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1127.1">"This is a message"</span></strong><span class="koboSpan" id="kobo.1128.1"> string? </span><span class="koboSpan" id="kobo.1128.2">Well, this is because the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1129.1">message</span></strong><span class="koboSpan" id="kobo.1130.1"> variable took precedence over the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1131.1">message</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1132.1"> method.</span></span></p>
<p><span class="koboSpan" id="kobo.1133.1">While this feature may not seem</span><a id="_idIndexMarker174"/><span class="koboSpan" id="kobo.1134.1"> pretty (I don’t like it that much), I guarantee you that you’ll come across it from time</span><a id="_idIndexMarker175"/><span class="koboSpan" id="kobo.1135.1"> to time, and you should be prepared </span><span class="No-Break"><span class="koboSpan" id="kobo.1136.1">for it.</span></span></p>
<h2 id="_idParaDest-60"><a id="_idTextAnchor061"/><span class="koboSpan" id="kobo.1137.1">Questionable exclamation method names</span></h2>
<p><span class="koboSpan" id="kobo.1138.1">As a cherry on top of the language</span><a id="_idIndexMarker176"/><span class="koboSpan" id="kobo.1139.1"> enhancements in Ruby, its creators</span><a id="_idIndexMarker177"/><span class="koboSpan" id="kobo.1140.1"> have also included a naming feature to add readability</span><a id="_idIndexMarker178"/><span class="koboSpan" id="kobo.1141.1"> to our methods: the exclamation mark (</span><strong class="source-inline"><span class="koboSpan" id="kobo.1142.1">!</span></strong><span class="koboSpan" id="kobo.1143.1">) (also known as a bang) and the question mark (</span><strong class="source-inline"><span class="koboSpan" id="kobo.1144.1">?</span></strong><span class="koboSpan" id="kobo.1145.1">). </span><span class="koboSpan" id="kobo.1145.2">They don’t change behavior in any way, but they allow for a line of code to read as a question or as an exclamation. </span><span class="koboSpan" id="kobo.1145.3">Methods named with the exclamation mark are called dangerous methods because they modify the object from where they are called. </span><span class="koboSpan" id="kobo.1145.4">Methods named with the question mark are called predicate methods and, by convention, return </span><span class="No-Break"><span class="koboSpan" id="kobo.1146.1">a Boolean.</span></span></p>
<p><span class="koboSpan" id="kobo.1147.1">To see this in action, we’ll create a method with the question mark. </span><span class="koboSpan" id="kobo.1147.2">Let’s create a new file called </span><strong class="source-inline"><span class="koboSpan" id="kobo.1148.1">enhanced_naming.rb</span></strong><span class="koboSpan" id="kobo.1149.1"> and add the </span><span class="No-Break"><span class="koboSpan" id="kobo.1150.1">following code:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1151.1">
# enhanced_naming.rb
$married_status = false
def is_married
  $married_status
end</span></pre> <p><span class="koboSpan" id="kobo.1152.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.1153.1">$married_status</span></strong><span class="koboSpan" id="kobo.1154.1"> variable is a global</span><a id="_idIndexMarker179"/><span class="koboSpan" id="kobo.1155.1"> variable, which simply</span><a id="_idIndexMarker180"/><span class="koboSpan" id="kobo.1156.1"> means that we can modify or access its contents on a method or outside the method. </span><span class="koboSpan" id="kobo.1156.2">In this case, we defined a method that gets the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1157.1">$married_status</span></strong><span class="koboSpan" id="kobo.1158.1"> value. </span><span class="koboSpan" id="kobo.1158.2">However, knowing that we can add the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1159.1">?</span></strong><span class="koboSpan" id="kobo.1160.1"> to the name of this method, let’s rename the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1161.1">is_married</span></strong><span class="koboSpan" id="kobo.1162.1"> method </span><span class="No-Break"><span class="koboSpan" id="kobo.1163.1">like so:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1164.1">
# enhanced_naming.rb
$married_status = false
def is_married?
</span><span class="koboSpan" id="kobo.1164.2">  $married_status
end</span></pre> <p><span class="koboSpan" id="kobo.1165.1">Now, let’s use an already familiar one-liner to print a message for a </span><span class="No-Break"><span class="koboSpan" id="kobo.1166.1">married person:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1167.1">
puts "Promo for married people" if is_married?</span></pre> <p><span class="koboSpan" id="kobo.1168.1">While adding </span><strong class="source-inline"><span class="koboSpan" id="kobo.1169.1">?</span></strong><span class="koboSpan" id="kobo.1170.1"> to the name of the method does not affect its behavior, it does change the sentence into an obvious question. </span><span class="koboSpan" id="kobo.1170.2">We’ll see this syntax very often </span><span class="No-Break"><span class="koboSpan" id="kobo.1171.1">in Ruby.</span></span></p>
<p><span class="koboSpan" id="kobo.1172.1">Similarly, we can use the bang symbol (</span><strong class="source-inline"><span class="koboSpan" id="kobo.1173.1">!</span></strong><span class="koboSpan" id="kobo.1174.1">) as part of the name of a method. </span><span class="koboSpan" id="kobo.1174.2">Again, adding it to the name doesn’t affect the behavior by itself, but it tells whoever is reading the code that we’re doing something different than just calling a method. </span><span class="koboSpan" id="kobo.1174.3">As an example, let’s rename our </span><strong class="source-inline"><span class="koboSpan" id="kobo.1175.1">marry</span></strong><span class="koboSpan" id="kobo.1176.1"> method to </span><strong class="source-inline"><span class="koboSpan" id="kobo.1177.1">marry!</span></strong><span class="koboSpan" id="kobo.1178.1"> and see what it </span><span class="No-Break"><span class="koboSpan" id="kobo.1179.1">looks like:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1180.1">
def marry!
</span><span class="koboSpan" id="kobo.1180.2">  $married_status = true
end</span></pre> <p><span class="koboSpan" id="kobo.1181.1">As a convention adopted by the Ruby community, the bang symbol (</span><strong class="source-inline"><span class="koboSpan" id="kobo.1182.1">!</span></strong><span class="koboSpan" id="kobo.1183.1">) will tell the reader (of the code) that we are making a change within an object. </span><span class="koboSpan" id="kobo.1183.2">A method without the bang symbol would simply return a value, but not affect the object itself. </span><span class="koboSpan" id="kobo.1183.3">So, in this case, we are changing the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1184.1">$married_status</span></strong><span class="koboSpan" id="kobo.1185.1"> value to </span><strong class="source-inline"><span class="koboSpan" id="kobo.1186.1">true</span></strong><span class="koboSpan" id="kobo.1187.1">. </span><span class="koboSpan" id="kobo.1187.2">This is what the code should look </span><span class="No-Break"><span class="koboSpan" id="kobo.1188.1">like now:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1189.1">
# enhanced_naming.rb
$married_status = false
def is_married?
</span><span class="koboSpan" id="kobo.1189.2">  $married_status
end
def marry!
</span><span class="koboSpan" id="kobo.1189.3">  $married_status = true
end
puts "Promo for married people" if is_married?</span></pre> <p><span class="koboSpan" id="kobo.1190.1">Sadly, when we run this example, we don’t see</span><a id="_idIndexMarker181"/><span class="koboSpan" id="kobo.1191.1"> any output. </span><span class="koboSpan" id="kobo.1191.2">This is because the initial value of the global </span><strong class="source-inline"><span class="koboSpan" id="kobo.1192.1">$married_status</span></strong><span class="koboSpan" id="kobo.1193.1"> variable is </span><strong class="source-inline"><span class="koboSpan" id="kobo.1194.1">false</span></strong><span class="koboSpan" id="kobo.1195.1">, and our code will only print a message if the value</span><a id="_idIndexMarker182"/><span class="koboSpan" id="kobo.1196.1"> is </span><strong class="source-inline"><span class="koboSpan" id="kobo.1197.1">true</span></strong><span class="koboSpan" id="kobo.1198.1">. </span><span class="koboSpan" id="kobo.1198.2">Now, let’s call the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1199.1">marry!</span></strong><span class="koboSpan" id="kobo.1200.1"> method and copy the one-liner again at the end of </span><span class="No-Break"><span class="koboSpan" id="kobo.1201.1">the code:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1202.1">
puts "Promo for married people" if is_married?
</span><span class="koboSpan" id="kobo.1202.2">marry!
</span><span class="koboSpan" id="kobo.1202.3">puts "Promo for married people" if is_married?</span></pre> <p><span class="koboSpan" id="kobo.1203.1">Now, we can run the </span><span class="No-Break"><span class="koboSpan" id="kobo.1204.1">code again:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1205.1">
ruby enhanced.rb</span></pre> <p><span class="koboSpan" id="kobo.1206.1">The output will look </span><span class="No-Break"><span class="koboSpan" id="kobo.1207.1">like this:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1208.1">
Promo for married people</span></pre> <p><span class="koboSpan" id="kobo.1209.1">What’s happening here? </span><span class="koboSpan" id="kobo.1209.2">We have a global </span><strong class="source-inline"><span class="koboSpan" id="kobo.1210.1">$married_status</span></strong><span class="koboSpan" id="kobo.1211.1"> variable with an initial </span><strong class="source-inline"><span class="koboSpan" id="kobo.1212.1">false</span></strong><span class="koboSpan" id="kobo.1213.1"> value. </span><span class="koboSpan" id="kobo.1213.2">Then, we have two methods – one to get the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1214.1">$married_status</span></strong><span class="koboSpan" id="kobo.1215.1"> value and another to change it to true. </span><span class="koboSpan" id="kobo.1215.2">Finally, we attempt to print the message but since the initial value is </span><strong class="source-inline"><span class="koboSpan" id="kobo.1216.1">false</span></strong><span class="koboSpan" id="kobo.1217.1">, the message is not printed. </span><span class="koboSpan" id="kobo.1217.2">By calling the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1218.1">marry!</span></strong><span class="koboSpan" id="kobo.1219.1"> method, we change </span><strong class="source-inline"><span class="koboSpan" id="kobo.1220.1">$married_status</span></strong><span class="koboSpan" id="kobo.1221.1"> to </span><strong class="source-inline"><span class="koboSpan" id="kobo.1222.1">true</span></strong><span class="koboSpan" id="kobo.1223.1">, which makes the last line of our script print out </span><span class="No-Break"><span class="koboSpan" id="kobo.1224.1">the message.</span></span></p>
<p><span class="koboSpan" id="kobo.1225.1">Ruby brings language enhancements to programming merely to improve code readability. </span><span class="koboSpan" id="kobo.1225.2">I’ve seen code written so beautifully that it reinforces the idea behind not writing comments on your code, but rather lets your code speak for itself. </span><span class="koboSpan" id="kobo.1225.3">Once you start using them regularly, you will appreciate</span><a id="_idIndexMarker183"/><span class="koboSpan" id="kobo.1226.1"> them more and more</span><a id="_idIndexMarker184"/><span class="koboSpan" id="kobo.1227.1"> and you’ll wish all languages had </span><span class="No-Break"><span class="koboSpan" id="kobo.1228.1">these enhancements.</span></span></p>
<h1 id="_idParaDest-61"><a id="_idTextAnchor062"/><span class="koboSpan" id="kobo.1229.1">Summary</span></h1>
<p><span class="koboSpan" id="kobo.1230.1">In this chapter, we learned how to write, execute, and require scripts with the Ruby binary, along with how to use the IRB to execute Ruby code directly on the command line without having to write </span><span class="No-Break"><span class="koboSpan" id="kobo.1231.1">source code.</span></span></p>
<p><span class="koboSpan" id="kobo.1232.1">Additionally, we reviewed Ruby’s syntax for writing variables, the syntax for </span><strong class="source-inline"><span class="koboSpan" id="kobo.1233.1">if</span></strong><span class="koboSpan" id="kobo.1234.1"> statements, and how to loop through both cycles and arrays. </span><span class="koboSpan" id="kobo.1234.2">Finally, we learned some of the language enhancements that Ruby has and PHP doesn’t so that we can read and understand more complex </span><span class="No-Break"><span class="koboSpan" id="kobo.1235.1">Ruby code.</span></span></p>
<p><span class="koboSpan" id="kobo.1236.1">Now, we are ready to write Ruby code to solve real-life examples. </span><span class="koboSpan" id="kobo.1236.2">We’ll start doing this in the </span><span class="No-Break"><span class="koboSpan" id="kobo.1237.1">next chapter.</span></span></p>
</div>
</body></html>