- en: 4\. Functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Overview
  prefs: []
  type: TYPE_NORMAL
- en: By the end of this chapter, you will be able to work with built-in functions;
    create user-defined functions; and write anonymous functions.
  prefs: []
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When writing software, we often run into situations where we need to do a specific
    task in different places within the application that we are building. Without
    thinking about it, it can be easy to fall into the habit of rewriting the same
    code over and over again, causing code repetition and making it harder to debug
    errors when they show up. However, as with all other programming languages, PHP
    gives you the ability to structure reusable code in what is known as a **function**,
    which is also sometimes referred to as a method. These two terms will be used
    interchangeably throughout this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Think of a function as a reusable set of instructions or statements. After writing
    it once, you can call it as many times as you like. Functions bundle logic that
    should otherwise be kept inseparably together.
  prefs: []
  type: TYPE_NORMAL
- en: 'Grouping and isolating a set of instructions inside a function comes with a
    number of benefits. The most obvious one is the option to reuse it: once you have
    written your function, you never need to rewrite or reinvent this particular set
    of instructions again. Functions also improve consistency – this means that each
    time you call your function, you can be sure the same set of instructions will
    be applied.'
  prefs: []
  type: TYPE_NORMAL
- en: Another less obvious benefit is that your code becomes much more readable, especially
    when you name your functions so that it is clear what they do.
  prefs: []
  type: TYPE_NORMAL
- en: Another good thing about a function is that it encloses local variables within
    its scope, so that they do not pollute the global scope. We will discuss scope
    in more detail later.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s an example of a simple function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Here''s a function that has been written to calculate the average of the values
    passed to this function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Note that this is not production-ready code. The function does not check anything
    about its inputs and does not prevent error conditions, such as division by zero,
    if you do not pass any arguments. The `function-average.php` file contains a more
    elaborate example of the same function for you to refer to on the GitHub repository.
  prefs: []
  type: TYPE_NORMAL
- en: A function is **callable**. However, note that not all callables are functions.
    Functions can call other functions, functions can pass functions around to other
    functions to be called by them, and functions can create functions. Confused?
    Read on and look at the examples and you will see that it is not complicated at
    all.
  prefs: []
  type: TYPE_NORMAL
- en: What is a Callable?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Simply put, a callable is a part of your code that you can "call". When we say
    that you can "call" something, we mean that you can tell the program to execute
    it.
  prefs: []
  type: TYPE_NORMAL
- en: A callable can be written with parentheses after it, for example, `functionName()`.
  prefs: []
  type: TYPE_NORMAL
- en: As previously described, a function is a type of callable, so a function can
    be called (that is, you can tell your program to execute it).
  prefs: []
  type: TYPE_NORMAL
- en: 'As an example, consider the following user-defined function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Do not worry about the details of the function right now—we will get into the
    nitty-gritty of it later. This function could be defined anywhere in your code,
    but let's assume that it is defined in a script called `how-many-times-did-we-tell-you.php`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The contents of the script would then look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'The function takes a single parameter, `$numberOfTimes`, which must be of the
    `int` (integer) type, and it returns a string. The `int` type hint and the `string`
    return type are optional. We will discuss parameters and returning values later
    in the chapter. Now, `function howManyTimesDidWeTellYou(int $numberOfTimes): string`
    is just the function declaration: it defines the function. The script itself does
    nothing yet.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to enable the function to actually do something, we need to call it
    from our code. It is perfectly valid to continue in the same script file and call
    the function that we just defined as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'If you open a Terminal and execute the script, you will see no output. Why
    not? The reason is that while the function does return a string, it does not print
    any output. To generate output, you need to `echo` the return value of the function
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Now you will see output if you execute the script.
  prefs: []
  type: TYPE_NORMAL
- en: 'Execute the script by calling it from the command line in the directory where
    the script lives. You can simply type the following text and press *Enter*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'You will immediately spot a problem with this output: it is grammatically incorrect.
    And what if we were to pass a negative integer? Then, the output would be even
    logically incorrect. Our function is not production-ready at this point.'
  prefs: []
  type: TYPE_NORMAL
- en: A more elaborate example of the function and how it can be called is to be found
    in the `how-many-times-did-we-tell-you.php` file.
  prefs: []
  type: TYPE_NORMAL
- en: Note that it is possible to print text from within functions by using `echo`
    inside a function. However, this makes the function less reusable as it will generate
    output as soon as it is called. In some cases, you might want to delay output.
    For example, you may be collecting and combining strings before you output them,
    or you may want to store the string in a database and don't want to display it
    at this stage. Although printing directly from within a function is generally
    considered bad practice, you will see it a lot in systems such as WordPress. Printing
    from a function can be convenient in a context where generating output is the
    most important task.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 4.1: Using Built-in Functions'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This exercise is about string manipulation. PHP has many built-in string manipulation
    functions. The one we will be using here is `substr()`. Like most other built-in
    functions, the behavior of `substr()` can be tweaked by passing various parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new directory called `Chapter04`. Then, inside it, create a folder
    named `exercises`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a file called `hello.php` in the `Chapter04/exercises` directory.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Write the opening script tag:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The opening tag tells the parser that, from this point onward, what we write
    is PHP.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Write the instruction that extracts and prints "Hello" from "Hello World" using
    `substr()`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The `echo` command prints the result of the statement that comes after it.
    The statement calls the `substr` function with three arguments: the literal string,
    `Hello World`, and the literal integers `0` and `5`. What this says is "*give
    me the five characters of the input string starting from 0*". In PHP, you can
    think of a string as almost like an array, where each character in that string
    is an element. Like in many other programming languages, array indices start at
    zero instead of one. If you count the characters, you will see that `H e l l o`
    are the first five characters of the `Hello World` input string. They are returned
    from the function as a new string of five characters.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Optionally, on the next line, `echo` a newline, only for clarity of the output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`PHP_EOL` is a predefined constant that outputs a newline in the correct format
    for the operating system you are on. Using this constant makes your code more
    portable between different operating systems.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Open a Terminal and go to the `Chapter04/exercises` directory where your `hello.php`
    script is placed and execute the file using the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Observe that `Hello` and a newline are printed in the Terminal; this is what
    the output looks in the Terminal:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 4.1: Printing the output to the Terminal'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '](img/C14196_04_01.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Figure 4.1: Printing the output to the Terminal'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Don't worry if your path differs from that of the screenshot as this will depend
    on your system settings.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Now change the code to the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Run the script again and notice the output is now `World` (notice the space
    at the start). What happened is that the substring is now taken from position
    5 (the sixth character, the space), to the end of the string.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Change the code to:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Run the script and notice the output will be `orl`. What happens is that now
    the start is negative and counted backward from the end of the string. The length
    is `3` and taken toward the end of the string from the start:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 4.2: Printing the sliced string'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '](img/C14196_04_02.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Figure 4.2: Printing the sliced string'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: In the preceding screenshot, you can see the output from *step 8*. The output
    looks this way because I used a scratch file in PhpStorm. I added a new scratch
    file and just quickly pasted the code into it and ran it using the green play
    button in PhpStorm. Scratch files are a way of quickly testing some code in files
    while the files are not added to your project.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Change the statement to the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`Ideeën` is a Dutch word that means "ideas." However, for this example, we
    need the `ë` character, so we can''t just type "ideas."'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Run the script again and notice that the output is `ën`. If you have been paying
    attention so far, you should have expected the output to be `eën`: it is three
    characters long, counted from `start = -3`, and counted backward from the end
    of the string until the end of the string. So, why is the output two characters
    long in this case and not three? The explanation is that `ë` is a multibyte character.
    If you need to check whether a string is UTF-8-encoding, you can use an additional
    built-in function called `mb_detect_encoding`, passing the string as the first
    parameter and UTF-8 as the second parameter. The `substr` method just counts bytes
    and does not account for characters that are multiple bytes in length. Now, there
    is a solution for that: `mb_substr`. In fact, for many string manipulation functions,
    there are sister functions that are prefixed with `mb_` to indicate that they
    support multibyte characters. If you always use the `mb_` versions of these methods,
    you will get the expected results.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Change the statement to the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Run the script once more and notice that now you get the expected output of
    `eën`:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 4.3: Printing the output of the sliced strings'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/C14196_04_03.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 4.3: Printing the output of the sliced strings'
  prefs: []
  type: TYPE_NORMAL
- en: Remember to always use the `mb_*` versions of string manipulation functions.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we were introduced to callables and started to get a glimpse
    of the built-in functions that are available to us. Next, we are going to dive
    a little deeper into the types of callables.
  prefs: []
  type: TYPE_NORMAL
- en: Types of Callables
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There are several types of callables:'
  prefs: []
  type: TYPE_NORMAL
- en: Functions, such as `mb_strtoupper`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Anonymous functions or closures.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Variables that hold the name of a function.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An array with two elements, where the first element is the object and the second
    element is the name of the function you wish to call that exists within the object
    written as a string. An example of this can be found in the `callables.php` document.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An object that has the `__invoke` magic method defined.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The `__invoke` method is a magic function that can be attached to classes that
    when initialized to a variable will make that assigned variable into a callable
    function. Here''s a simple example of the `__invoke` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding example, we declared a `$sparky` object and executed this object
    as a function by calling it `$sparky()`. This function, in turn, invoked its primary
    action and printed the result.
  prefs: []
  type: TYPE_NORMAL
- en: To verify whether something is a callable, you can pass it to the built-in `is_callable`
    function. This function will return `true` if its first argument is a callable
    and `false` if not. The `is_callable` function actually takes up to three arguments
    that tweak the behavior of `is_callable`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Try out the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: You can explore more examples in the `callables.php` script on the GitHub repository.
  prefs: []
  type: TYPE_NORMAL
- en: Language Constructs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`if` and `while`. Language constructs that act like functions look very much
    like built-in functions in the way they are used. If you want to print a string,
    you can choose to use `echo`, which is a language construct; or `print`, which
    is also a language construct. There are small differences between `echo` and `print`,
    and `echo` is the most commonly used. When comparing the two, `echo` doesn''t
    have a return value and has the option of multiple parameters, whereas `print`
    returns a value that can be used in an expression and allows only one parameter.
    `echo` is the most flexible of the two and is a tiny bit faster. Language constructs
    can be used with or without parentheses. In contrast, callables are always used
    with parentheses:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Both statements print `hello world`. A language construct has a more efficient
    underlying implementation in C than a function and thus will execute faster. You
    can use parentheses with `echo` and `print`, but it is not mandatory.
  prefs: []
  type: TYPE_NORMAL
- en: Introduction to Built-In Functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'PHP comes with many built-in functions, such as `strtoupper`, which changes
    the case of an input string to uppercase:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: PHP natively comes with a ton of functions. By adding extensions to PHP, you
    add even more built-in functions and classes to it. Built-in functions are precompiled
    in C as this is the language that PHP and its extensions are written in.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: How to add an extension will differ depending on which operating system you
    are on. So, when searching for it, always add the name of your operating system
    to your search and be sure to consult the most recent results first, as they are
    more likely to outline the correct procedure for installing or compiling extensions
    into PHP.
  prefs: []
  type: TYPE_NORMAL
- en: 'There is hardly anything more frustrating than spending days on writing some
    functionality, only to discover toward the end that there is a built-in function
    that does the same thing five times faster. So, before writing functionality yourself,
    try to google or search [https://packt.live/2OxT91A](https://packt.live/2OxT91A)
    for built-in functions. If you are using an IDE, built-in functions will be suggested
    by autocomplete as soon as you start typing in a PHP document. PHP is often called
    a glue language: it is used to tie different systems together. Therefore, there
    is a wealth of functions that talk to databases, file resources, network resources,
    external libraries, and so on.'
  prefs: []
  type: TYPE_NORMAL
- en: 'If you are using a function that is provided by an extension that is not installed
    or compiled with your PHP version, you will get an error. For example, calling
    `gd_info()` when `GD` is not installed results in `Fatal error: Uncaught Error:
    Call to undefined function gd_info()`. By the way, `GD` is a library used for
    image manipulation.'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: On a side note, in many real-life projects, we handle multibyte strings. When
    handling multibyte strings, you should be using the multibyte-safe string manipulation
    functions. Instead of `strtoupper`, you would be using `mb_strtoupper`.
  prefs: []
  type: TYPE_NORMAL
- en: Finding Built-In Functions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To find out which version of PHP you are currently using, open up a Terminal,
    type the following command, and then hit *Enter*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'To find out what extensions are installed on your system, type the following
    command and hit *Enter*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: This will list all extensions currently installed and enabled in your PHP installation.
    You can also list the extensions using the built-in `get_loaded_extensions` PHP
    function.
  prefs: []
  type: TYPE_NORMAL
- en: 'To make use of that, write a file called `list-extensions.php` with the following
    content:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Execute the file from the command line as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that if you do this, you will have used two built-in functions: `print_r`
    and `get_loaded_extensions`. The `print_r()` function prints its first argument
    in human-readable form. You can use the second argument, a `true` Boolean value,
    to return the output instead of printing it on the screen. That way, you can write
    it to a log file, for example, or pass it on to another function.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The output should look like the following screenshot (note that the extensions
    may vary on your system):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.4: Listing the extensions'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/C14196_04_04.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 4.4: Listing the extensions'
  prefs: []
  type: TYPE_NORMAL
- en: 'Another function that you may find useful while exploring the built-in functions
    and the extensions is `get_extension_funcs ( string $module_name ) : array`, which
    you can use to list the functions that an extension provides. Often, it will be
    easier to find the functions in the documentation of the extension.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the top part of the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.5: Listing the top extensions'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/C14196_04_05.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 4.5: Listing the top extensions'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: You can find more information about built-in functions at [https://packt.live/2oiJPEl](https://packt.live/2oiJPEl).
  prefs: []
  type: TYPE_NORMAL
- en: Parameters and Return Values
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Parameters are the variables written within the function declaration. Arguments
    are the values that you pass as these parameters. Return values are the values
    that the function returns when it has completely executed. In the previous example,
    `get_loaded_extensions` was called without any arguments: there was nothing between
    the braces after `get_loaded_extensions`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The return value of `get_loaded_extensions()` is an array of extensions loaded
    into PHP – extensions that are installed and enabled. That return value was used
    as an argument to `print_r`, which returned a user-friendly string describing
    its input. To clarify this, the `list-extensions.php` script could be rewritten
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Passing Parameters by Reference
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Parameters that are objects are always passed by reference. We will go into
    further detail about objects in *Chapter 5*, *Object Oriented Programming*, but
    to give you a little bit of context, think of an object as a container that contains
    scoped variables and functions. This means that an address in memory where that
    object exists is passed into the function so the function can find the actual
    object internally when it needs it. If the function modifies the referenced object,
    then the original object that is held in memory will reflect those changes. If
    you want a copy of the object to work on instead, you need to clone the object
    with the `clone` keyword before working on it. You can think of a clone as a copier
    that will make an exact copy of the object you want to duplicate.
  prefs: []
  type: TYPE_NORMAL
- en: 'An example of the use of the `clone` keyword can be found here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'If the modified copy is required outside the function, you can choose to return
    it from the function. In the following example, `$document` becomes a variable
    that contains an object reference to a `DomDocument` object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: With scalar variable parameters, it is the programmer of the function who decides
    whether a parameter is passed by reference or as a copy of the original value.
    Note that only variables can be passed by reference.
  prefs: []
  type: TYPE_NORMAL
- en: 'A scalar variable is a variable that holds a scalar value, such as `$a` in
    the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: As opposed to just `10`, which is an integer value, scalars can be numbers,
    strings, or arrays.
  prefs: []
  type: TYPE_NORMAL
- en: If you pass a literal scalar value to a function that expects a reference, you
    will get an error stating that only variables can be passed by reference. This
    is because the PHP parser holds no references to scalars – they are just themselves.
    It is only when you assign a scalar to a variable that a reference to that variable
    will exist internally.
  prefs: []
  type: TYPE_NORMAL
- en: Passing Scalar Variables by Reference
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: PHP has many functions that work on arrays. They differ a lot as to whether
    they take the array as a reference or not.
  prefs: []
  type: TYPE_NORMAL
- en: 'Take the following array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'The built-in `sort()` function will sort the preceding fruits in alphabetical
    order. The array is passed by reference. So, after calling `sort($fruits);`, the
    original array will be in alphabetical order:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'The output should be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'As opposed to passing by reference, `array_reverse` works on a copy of the
    array passed into it and returns it with its elements in reverse order:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: For more elaborate examples, you can refer to `array-pass-by-reference.php`
    and `array-pass-a-copy.php`, which are available on GitHub.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another example that you see in real-life code is `preg_match()`. This function
    matches an occurrence of a pattern in a string and stores it in the optional `&$matches`
    parameter, which is passed by reference. This means that you have to declare a
    `$matches` variable before you call the function or even while you are calling
    it. After the function has run, the previously empty `$matches` array will be
    filled with the match. The pattern is a regular expression. Regular expressions
    deserve their own chapter, but the essence is that a regular expression defines
    a pattern that the parser can then recognize in a string and return as a match.
    The `preg_match()` function returns `1` if the pattern exists in the string and
    `matches`, if provided, will contain the actual match:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, the first occurrence that is found is the single match stored
    in `$matches`. If you want all of the spaces followed by three word characters,
    you should use `preg_match_all()`.
  prefs: []
  type: TYPE_NORMAL
- en: 'To demonstrate how simply changing the `preg_match` function to `preg_match_all`
    can return all instances of the matches, we will change the following line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'We will replace it with the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: This will result in returning all of the sections that match our defined pattern.
  prefs: []
  type: TYPE_NORMAL
- en: 'The output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: 'To learn more about regex, take a look at: [https://packt.live/33n2y0n](https://packt.live/33n2y0n).'
  prefs: []
  type: TYPE_NORMAL
- en: Optional Parameters
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You will have noticed that we have used `print_r()` in a lot of examples to
    display a user-friendly representation of variables that would otherwise not make
    much sense. Let''s take the following array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'Using `echo $values;` would just print `Array` on the screen, while `print_r($values);`
    prints a human-readable format for us to view:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, suppose that you would like to send information about `$values` to somewhere
    other than the screen. The reason for this could be that you want to send information
    about an error, or that you would like to keep a log of what is going on in your
    application. In the message that you send, you would like to include information
    about the contents of `$values`. If you were to use `print_r` for that, the output
    would not appear in your message but would be written to the screen instead. That
    is not what you want. Now the optional second parameter of `print_r` comes into
    play. If you pass that second argument with your function call and make it `true`,
    the output will not be printed directly, but instead be returned from the function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'The `$output` variable now contains the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: This can be used later to compose a message to be sent anywhere you need.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 4.2: Working with print_r()'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this exercise, we will use the `print_r()` function to print different shapes
    in a human-readable format. To do this, we will execute the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Let's start by creating a new file in your project directory and calling it
    `print_r.php`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Next, we are going to open our PHP script with the opening tag and define a
    `$shapes` variable with three different shapes:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'On the next line, let''s echo out the contents of `$values`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Let''s go ahead and open the project directory in the Terminal and run it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'You''ll see that all that is printed is the following:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This is because `echo` isn't designed to show array contents. However, this
    is where `print_r()` now comes into play.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Let''s replace `echo` with `print_r`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We''ll run the script using the following command:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now we can see the values of the array as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 4.6: Printing the values of an array'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/C14196_04_06.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 4.6: Printing the values of an array'
  prefs: []
  type: TYPE_NORMAL
- en: A Varying Number of Parameters
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Functions can accept a varying number of parameters. Take, for example, `printf`,
    which is used to print a string of text from a predefined formatted string, filling
    out placeholders with values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'This will print the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: While `$format` is a required parameter, the remaining parameters are optional
    and variable in number. The important takeaway here is that you can pass as many
    as you like.
  prefs: []
  type: TYPE_NORMAL
- en: The number of parameters must match the number of placeholders in the string,
    but that is specific to `printf`. When allowing a varying number of parameters,
    it is up to the designer of the function to decide whether or not to validate
    the number of parameters against certain restrictions.
  prefs: []
  type: TYPE_NORMAL
- en: There is also the `sprintf` function, which acts almost the same way; however,
    instead of printing the resulting text, it returns it from the function so that
    you can use the output later.
  prefs: []
  type: TYPE_NORMAL
- en: 'You might have noticed that the placeholders are different: `%d` and `%s`.
    This can be used as a simple validation: `%d` expects a number, while `%s` accepts
    anything that can be cast to a string.'
  prefs: []
  type: TYPE_NORMAL
- en: Flag Parameters
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In earlier examples, we used the `sort()` function with just one parameter:
    the array we want to be sorted for us. The function accepts a second parameter.
    In this case, the second parameter is also defined as a flag, which means only
    values of certain predefined constants, called flags, are accepted. The flag determines
    the way in which `sort()` behaves. If you want to use multiple flags, then you
    can simply use the pipe (`|`) symbol between each flag.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s now take a slightly different input array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: The array is now sorted alphabetically as expected. Without the flags, sorting
    would be case-sensitive and `orange` would come last, because it is lowercase.
    The same result can be achieved using `natcasesort($fruits)`. See the example
    in `array-use-sort-with-flags.php` on GitHub.
  prefs: []
  type: TYPE_NORMAL
- en: In general, it is a good idea, when using a function, to consult the documentation
    about extended possibilities by using extra arguments. Often, a function does
    not exactly do what you want but can be made to do it by passing extra arguments.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 4.3: Using Built-In Functions with Arrays'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this exercise, we will see how the PHP built-in functions work with arrays:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a file called `array-functions.php` in the `exercises` directory of `Chapter04`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Type the opening tag and the statement that creates the array named `$signal`,
    which contains the different colors in a traffic signal:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Display the array of integers in a human-readable format:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Execute the script using the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 4.7: Printing the array of traffic signal colors'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '](img/C14196_04_07.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Figure 4.7: Printing the array of traffic signal colors'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Notice in the preceding output how the array elements are indexed with colors
    and the first element is at index `0` and the third element at index `2`. These
    are the default indices when you do not declare your own indices.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Use the `array_reverse` function to reverse the array:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The `array_reverse()` method will reverse the order of the array elements and
    return the result as a new array while leaving the original array unchanged.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Print the reversed array:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Execute the `php array-functions.php` command.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'The output looks like the following screenshot:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 4.8: Printing the reverse array'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '](img/C14196_04_08.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Figure 4.8: Printing the reverse array'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Notice how element `3` is now the first element at index `0` of the array and
    element `1` is the last. At index `2`, although the array is reversed, the indices
    stay at the same positions as in the original array.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Add the following code again to print the original array:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 4.9: Printing the array'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '](img/C14196_04_09.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Figure 4.9: Printing the array'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: This is to demonstrate that the original array will not be changed by `array_reverse`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Open a Terminal and go to the directory where you just typed the `array-functions.php`
    script. Run the script and hit *Enter*:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Observe that three arrays are displayed. The output on the screen will look
    like the following screenshot when the array contains only three integers:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 4.10: Printing the three arrays'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '](img/C14196_04_10.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Figure 4.10: Printing the three arrays'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The first array displays your array with integers, the second is your array
    with integers in reverse order, and the third is the unchanged original array
    with the integers in regular order, as you entered them.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Change the statement that reverses the array to the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'What we did here has not always been possible in PHP, but it is possible today:
    we assign `true` to the `$preserve_keys` variable and, at the same time, we pass
    it as the second argument to `array_reverse`. The advantage of doing this is self-documenting
    the operations we are doing, and we can reuse the variable later if we need to.
    However, in general, this type of assignment can be easily overlooked and, if
    you do not need the variable later, it is probably better to just pass `true`.
    You might use this type of assignment depending on what you are building.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Look carefully at the output when you run the script again:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 4.11: Printing the three arrays again'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '](img/C14196_04_11.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Figure 4.11: Printing the three arrays again'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: When you inspect the output, specifically the array in the middle, you will
    notice that the keys have been preserved in the reversed array. It is true that
    element `3` is now the first element in the array, but note that index `2` is
    now the first index as well. So, `$integers[2]` still contains the value of `3`
    and `$integers[0]` still holds the value of `1`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Now let''s declare another `$streets` array with the names of a few streets:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now let''s sort the array with flags combined with the bitwise OR operator:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 4.12: Printing the array in alphabetical order'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '](img/C14196_04_12.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Figure 4.12: Printing the array in alphabetical order'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: In this case, the `sort()` function sorts the string case-insensitively.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'If we sort the array using the bitwise AND operator, we will see that the street
    names starting with uppercase letters move to the top of the array and rest of
    the street names print in alphabetical order:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 4.13: Printing the words that start with uppercase letters at the
    top of the array'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/C14196_04_13.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 4.13: Printing the words that start with uppercase letters at the top
    of the array'
  prefs: []
  type: TYPE_NORMAL
- en: In this exercise, you have seen one of the many powerful array manipulation
    functions of PHP at work. You learned that this function—`array_reverse` – returns
    a new array rather than modifying the original. You may deduce that the input
    argument, your array, is not passed by reference, because, otherwise, the original
    would have been changed by the reversion. You also learned that the second argument
    to this function – `boolean $preserve_keys` – if `true` does change the behavior
    of the function so that the elements stay at the same indices as before the reversion.
    You may deduce from this that the default value of the second argument is `false`.
    We then explored how to use the `sort` function to arrange the elements of an
    array in a specific order.
  prefs: []
  type: TYPE_NORMAL
- en: Introduction to User-Defined Functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A user-defined function is a function that either you or another user has written
    and is not built into PHP itself. Built-in functions are generally faster than
    user-defined functions that do the same thing, as they are already compiled from
    C. Always look for built-in functions before you try to write your own!
  prefs: []
  type: TYPE_NORMAL
- en: Naming Functions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Naming things is difficult. Try to choose names for your functions that are
    descriptive but not overly long. Very long function names are unreadable. When
    you read the name, you should ideally be able to guess what the function does.
    The rules for naming identifiers in PHP apply here. Function names are case-insensitive;
    however, by convention, you do not call a function with casing that is different
    from how it was defined. Speaking of conventions, you are free to design the casing
    any way you like, but two flavors generally prevail: `snake_case()` or `camelCase()`.
    In all cases, do what your team agrees upon – consistency is far more important
    than any personal preference, no matter how strong. If you are free to choose
    your coding convention, then, by all means, stick to the PSR-1 standard as recommended
    by PHP-FIG ([https://packt.live/2IBLprS](https://packt.live/2IBLprS)). Although
    it refers to functions as methods (as in class methods), you may safely assume
    that this also applies to (global) functions, which this chapter is about. This
    means that if you are free to choose, you can choose `camelCase()` for functions.'
  prefs: []
  type: TYPE_NORMAL
- en: Do not redeclare a built-in function (that is, do not write a function with
    the same name as a built-in function in the root namespace). Instead, give your
    own function a unique name, or put it in its own namespace. The best practice
    is to never use the name of an existing function for your own function, not even
    within your own namespace, to avoid confusion.
  prefs: []
  type: TYPE_NORMAL
- en: Documenting Your Functions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You may add a comment above a function, which is called a DocBlock. This contains
    annotations, prefixed with the `@` symbol. It also contains a description of what
    the function does. Ideally, it also describes why the function is there:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: Namespaced Functions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`Date`. If different libraries do this, you cannot use both libraries at the
    same time, because the second time a `Date` class is loaded, PHP will complain
    that you cannot redeclare the `Date` class, since it has already been loaded.'
  prefs: []
  type: TYPE_NORMAL
- en: To solve this problem, we use namespaces. If two different vendors of libraries
    use their vendor name for the namespace and create their `Date` class within that
    namespace, the names are far less likely to clash.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can think of a namespace as some kind of prefix. Say that `You` and `Me`
    are both vendors and we both want to introduce a `Date` class. Instead of naming
    the classes `MeDate` and `YouDate`, we create them in files that live in a `Me`
    directory and in a `You` directory. The class file will simply be called `Date.php`
    for both vendors. Inside your `Date.php` file, you will write the namespace as
    the very first statement (after the strict types declaration, if any):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: 'We will write a `Date.php` file that starts as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: Now, because the classes live in their own namespace, they have a so-called
    `You\Date` and `Me\Date`. Notice that the names are different. You will learn
    more about namespaces in *Chapter 5*, *Object-Oriented Programming*, because they
    matter to objects more than functions.
  prefs: []
  type: TYPE_NORMAL
- en: 'Namespaced functions are rare, but they are possible. To write a function in
    a namespace, declare the namespace at the top of the file where you define the
    function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: 'And then call it in another file in the root namespace (no namespace):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: 'We could import the `Chapter04` namespace near the top of the unit test with
    a `use` statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: Pure Functions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Pure functions do not have side effects. Not-so-pure functions will have side
    effects. So, what is a side effect? Well, when a function has a side effect, it
    changes something that exists outside of the scope of a function.
  prefs: []
  type: TYPE_NORMAL
- en: Scope
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You can think of scope as a "fence" within which a variable or function can
    operate. Within the function scope are its input, its output, and everything that
    is made available inside the function body. Functions can pull things out of the
    global scope into their own scope and alter them, thus causing side effects. To
    keep things simple, it is best when functions do not have side effects. It makes
    fault finding and unit testing easier when functions do not try to alter the environment
    in which they live, but, instead, just focus on their own responsibility.
  prefs: []
  type: TYPE_NORMAL
- en: Variables declared outside the function live in the global scope and are available
    within the function. Variables declared within the function body are not available
    outside the function scope, unless extra work is done.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following examples, two ways are used to demonstrate how variables from
    the global scope can be used inside a function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: After the function was called twice, `$count` will have the value of `2`, which
    is essentially a count of how many times the function was called during a single
    script run. After the next run, the `$count` variable will be `2` again, because
    the value is not preserved between script runs and also because it is initialized
    at `0` each time the script runs. Regardless, values are not preserved between
    script runs, unless you persist them explicitly in a file or some form of cache
    or some other form of persistence layer.
  prefs: []
  type: TYPE_NORMAL
- en: In general, it is better for functions not to have side effects and not to meddle
    with global scope.
  prefs: []
  type: TYPE_NORMAL
- en: The $GLOBALS Superglobal Array
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Global variables are always available inside the special `$GLOBALS` superglobal
    array. So, instead of using the `global` keyword, we could have incremented `$GLOBALS['count'];`
    in the previous example.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 4.4: Using the $GLOBALS array'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this exercise, you will change the function in `count-me-with-GLOBALS.php`
    so that it no longer uses the `global` keyword but uses the `$GLOBALS` superglobal
    array instead:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Take another look at the function used in the previous example:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Remove the contents of the function body so that your function looks like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The function is now empty and does nothing.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Add a new statement to the empty function body that increments `count` in the
    `$GLOBALS` array:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The function now does exactly the same as before, but with less code.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Call the `countMe()` function twice. The script should now look like the script
    in `count-me-with-GLOBALS.php`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: 'The output looks like the following screenshot when you run the script. The
    output is both a newline and a value of `$count` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.14: Printing the count'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/C14196_04_14.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 4.14: Printing the count'
  prefs: []
  type: TYPE_NORMAL
- en: The Single Responsibility Principle
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A function is easier to use, more reliable when reused, and easier to test when
    it does only one thing – that is, when it has a single responsibility. When you
    need another task to be performed, do not add it to your existing function; just
    write another one instead.
  prefs: []
  type: TYPE_NORMAL
- en: 'The syntax of a function is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: Don't be put off by this apparently complex syntax definition. Functions are
    really easy to write, as the following examples in this chapter will show you.
  prefs: []
  type: TYPE_NORMAL
- en: However, let's now spend some time trying to break this syntax apart.
  prefs: []
  type: TYPE_NORMAL
- en: The function Keyword
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `function` keyword tells the PHP parser that what comes next is a function.
  prefs: []
  type: TYPE_NORMAL
- en: Identifier
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The identifier represents the name of the function. Here, the general rules
    for identifiers in PHP will apply. The most important ones to remember are that
    it cannot start with a number and it cannot contain spaces. It can contain Unicode
    characters, although this is relatively uncommon. It is, however, quite common
    to define special, frequently used functions with underscores:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: This function is used to translate the text in WordPress templates. The idea
    behind it is that you will spot immediately that this function is something special
    and you won't be tempted to write a function with the same name yourself. It is
    also very easy to type, which is handy for frequently used functions. As you can
    see, it takes a required parameter, `$text`, to be translated. It also takes an
    optional `$domain`, in which the translation is defined, which is the `default`
    domain by default (a `text` domain in translations serves to separate different
    fields of interest that might have the same word for different things, so that
    these words can be translated differently if the other language has different
    words depending on the context). `__` function is what we call a wrapper for the
    translate function. It passes its arguments on to the `translate` function and
    returns the return value of the `translate` function. It is faster to type and
    it takes up less space in templates, making them more readable.
  prefs: []
  type: TYPE_NORMAL
- en: Type Hints
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In the function declaration, type hinting is used to specify the expected data
    type of an argument. Type hints for objects have existed since PHP 5.0 and for
    arrays since PHP 5.1\. Type hints for scalars have existed since PHP 7.0\. Nullable
    type hints have existed since PHP 7.1\. A type hint for `object` has existed since
    PHP 7.2\. Consider the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding example, there are three type hints. The first one hints that
    `$maxCredits` should be an integer. The second one hints that `$period` should
    be a string, and the third one hints that `$waitDays` must be an integer.
  prefs: []
  type: TYPE_NORMAL
- en: If a type hint is prefixed with a question mark, as in `?int`, this indicates
    that the argument must either be the hinted type or `null`. In this case, the
    hinted type is `integer`. This has been possible since PHP 7.1.
  prefs: []
  type: TYPE_NORMAL
- en: The Spread Operator (…) with Type Hints
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The spread operator (`…`) is optional and indicates that the parameter has to
    be an array that only contains elements of the hinted type. Although it has existed
    since PHP 5.6, it is a rarely used yet very powerful and useful feature that makes
    your code more robust and reliable, with less code. There is no longer a need
    to check every element of a homogeneous array. When you define a parameter with
    such a type hint, you also need to call the function with the parameter prefixed
    with the spread operator.
  prefs: []
  type: TYPE_NORMAL
- en: The following is an example of a fictional function that I made up to demonstrate
    the use of the spread operator. The `processDocuments` function transforms XML
    documents using **eXtensible Stylesheet Language Transformations** (**XSLT**).
    While this is really interesting when you need to transform documents, it doesn't
    really matter for the demonstration of the spread operator.
  prefs: []
  type: TYPE_NORMAL
- en: The spread operator is the three dots before `$xmlDocuments` in the function
    signature. It means that `$xmlDocuments` must be an array that contains only objects
    of the `DomDocument` hinted type. A `DomDocument` hinted type is an object that
    can load and hold XML. It can be processed by an object of the `XsltProcessor`
    class, to transform the document into another document. `XsltProcessor` in PHP
    is very powerful and very performant. You can even use PHP functions inside your
    XSL style sheets. This nifty feature should be used with caution, however, because
    it will render your XSL style sheets useless to other processors as they do not
    know PHP.
  prefs: []
  type: TYPE_NORMAL
- en: 'The return type of the function is `Generator`. This is caused by the `yield`
    statement inside the `foreach` loop. The `yield` statement causes the function
    to return each value (a document, in our case) as soon as it becomes available.
    This means it is efficient with memory: it does not keep the objects in memory
    in an array to return them all at once, but instead returns them one by one immediately
    after creation. This makes a generator very performant on large sets while also
    using fewer memory resources:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: The preceding function may appear pretty confusing, but it is fairly simple.
    Let's start with the usage of the spread operator; this is used to signify that
    the parameter will be required as an array. Additionally, the parameters are type
    hinted as `DomDocument` objects, meaning that the parameters will be an array
    of `DomDocument` objects. Moving onto the function, we define a new instance of
    `XsltProcessor` and load in a style sheet for the processor. Note that this is
    a conceptual example and more information on `XsltProcessor` and style sheets
    can be found in the PHP documentation at [https://packt.live/2OxT91A](https://packt.live/2OxT91A).
    Finally, we use a `foreach` loop to iterate through the array of documents and
    yield the results of the process method on each document. As document processing
    can be memory intensive, the use case for a generator is apparent if you can imagine
    passing a large array of documents to this function.
  prefs: []
  type: TYPE_NORMAL
- en: 'To call this function, use the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: Parameters in User-Defined Functions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'When defining a function, you are allowed to define parameters for it. When
    you are defining a parameter, consider whether it is expected to always be of
    the same type or whether you can force the developer using your code to always
    pass the same type. For example, when integer values are expected, a type hint
    of `int` is a good idea. Even if a developer passes `2`, which is a string, they
    can easily be educated to cast this to an integer before passing it to your function,
    using `(int) "2"`. More realistically, `2` would be stored in a variable. So,
    now you have a type hint:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, you should come up with a good name for your parameter. Ideally, it should
    be descriptive, but not overly long. When you expect a `DomDocument` object, `$domDocument`,
    `$xmlDocument`, or simply `$document` can be fine names, while `$doc` might be
    a little too short and confusing to some people and just `$d` would be just bad:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: 'Does a default value make sense for `$offset`? In most cases, it will be `0`,
    because we usually start a process at the beginning of something. So, `0` would
    make a great default value, in this case:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: Now we have a parameter with a type hint of `int` and a default of `0`. The
    parameter is now optional and should be defined after the parameters that are
    not optional.
  prefs: []
  type: TYPE_NORMAL
- en: If a parameter cannot be expected to always be of the same type, processing
    it in your function may be harder, because you might have to check its type in
    order to decide how you should treat it. This makes unit testing your function
    harder and it complicates fault finding if things go wrong, since your code will
    have several paths of execution, depending on the type of input.
  prefs: []
  type: TYPE_NORMAL
- en: When a parameter is prefixed with `&`, it means that if a scalar is passed,
    it will be passed by reference, instead of as a copy or literal. Objects are always
    passed by reference and, therefore, using `&` on an object parameter is redundant
    and does not change the behavior of the function.
  prefs: []
  type: TYPE_NORMAL
- en: Return Types in User-Defined Functions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Return types are written as a colon followed by the type name. Return types
    were introduced in PHP 7\. They make your code more robust because you are more
    explicit about what you expect from your function, and this can be checked at
    compile time rather than failing at runtime when something goes wrong, possibly
    in production. If you use an IDE, it will warn you when a return type does not
    match what you actually return or expect from the function. This means you can
    correct the error before it hits your users.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the preceding example, the `processDocuments` function has a return type
    of `Generator`. A `Generator` type generates values and makes them available as
    soon as possible. This can be very performant: you don''t have to wait for all
    the values to become available before processing them further. You can start with
    further processing as soon as the first value comes out of the `Generator` type.
    The `Generator` type churns out a value each time the `yield` language construct
    is used.'
  prefs: []
  type: TYPE_NORMAL
- en: '`yield` was introduced in PHP 5\. At the time of writing, we are at PHP 7.3
    and there are still many developers who have never used `yield` or do not even
    know what it does. When you are processing arrays or records from a database,
    for example, and you need extreme performance, consider whether you have a use
    case for a `Generator` type.'
  prefs: []
  type: TYPE_NORMAL
- en: You can use `void` as the return type to indicate that nothing is returned from
    the function.
  prefs: []
  type: TYPE_NORMAL
- en: Signature
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The following part of the function declaration is called the **signature**:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: So, the signature of a function defines its parameters and the return type.
  prefs: []
  type: TYPE_NORMAL
- en: Returning a Value
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A function may return a value or not. When the function does not return anything,
    not even `null`, the return type can be void as of PHP 7.1\. Values are returned
    by typing `return` followed by what you want to return. This can be any valid
    expression or just a single variable or literal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: Parameters and Arguments
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Functions accept arguments. An argument is a literal, variable, object, or even
    callable that you pass into a function for the function to act upon. If a parameter
    is defined at the position of the argument, you can use the argument inside your
    function by using the name of the parameter. The number of parameters may be variable
    or fixed. *PHP allows you to pass more parameters than the function signature
    defines*. If you want dynamic parameters, PHP has two built-in functions that
    make this possible; you can get the number of parameters with `func_num_args()`
    and the parameters themselves with `func_get_args()`. To show these functions
    in action, we will take a look at an example.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s an example of using `func_num_args()`. In this example, we define a
    method that will have no predefined parameters/arguments. But using the built-in
    `func_num_args` function, we will be able to count how many parameters/arguments
    are passed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE88]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that we can count the number of arguments, we can combine that function
    with `func_get_args()` to loop through and see what was passed. Here''s an example
    of using `func_get_args()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE89]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE90]'
  prefs: []
  type: TYPE_PRE
- en: Optional Parameters
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Parameters to functions are optional when they have default values defined
    for them:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE91]'
  prefs: []
  type: TYPE_PRE
- en: This function defines a parameter, `$name`, with a default value of `John`.
    This means that when calling the function, you do not need to provide the `$name`
    parameter. We say that the `$name` parameter is optional. If you do not provide
    a `$name` parameter, `John` will be passed anyway for the `$name` parameter. Optional
    parameters should be defined at the very end in the function signature, because,
    otherwise, if any required parameters come after the optional ones, you would
    still have to provide the optional parameters when calling the function.
  prefs: []
  type: TYPE_NORMAL
- en: The example is in `function-with-default-value.php`. The various usages are
    documented in the `TestSayHello.php` unit test.
  prefs: []
  type: TYPE_NORMAL
- en: Parameters Passed by Reference to Our Function
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Remember the `countMe` function? It used a global variable named `$count` to
    keep track of how many times the function was called. This could also have been
    accomplished by passing the `$count` variable by reference, which is also a slightly
    better practice than polluting the global scope from within your function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE92]'
  prefs: []
  type: TYPE_PRE
- en: 'Use it further down in the same script, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE93]'
  prefs: []
  type: TYPE_PRE
- en: Please note that calling methods in the same script as they are defined in is
    perfect for exercises and playing with code and also for simple scripts, but doing
    this is actually a violation of PSR-1\. This is a coding convention that states
    that files either define functions (not causing side effects) or use them (causing
    side effects).
  prefs: []
  type: TYPE_NORMAL
- en: Default Values for Parameters
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the following example, we are demonstrating the use of default values. By
    defining a default value, you give the developer using the function the ability
    to use the function as is without having to pass their own value.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE94]'
  prefs: []
  type: TYPE_PRE
- en: Between the parentheses is the function signature, which consists of a single
    parameter, `$systemTempDirectory`, with a type hint of `string` and a default
    value of `/tmp`. This means that if you pass a directory with your function call,
    it must be a string. If you do not pass an argument, the default value will be
    used.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 4.5: Writing a Function that Adds Two Numbers'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now that you''ve read through some of the theory behind writing your own functions,
    let''s make a start on actually writing some of our own. In this exercise, we
    will create a simple function that adds two numbers and prints its sum:'
  prefs: []
  type: TYPE_NORMAL
- en: Find the `add.php` file in `Chapter04/exercises/`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Start typing the following comment in the file and type the function template:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE95]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: You start with the `function` keyword; then the name of the function, `add`;
    the opening brace; the `$param1` and `$param2` parameters; the closing brace;
    the colon to announce the return type; the return type, `string`; and, finally,
    the function body, `{}`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Inside the function body, type a check to see whether the parameters are numeric
    values by using `is_numeric()`. This built-in function returns `true` if its argument
    represents a numeric value, even when its type is `string`. So, it will return
    `true` for `23` and `0.145` and `10E6`, for example. The latter is a scientific
    notation of 1,000,000:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE96]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We throw an exception when the value is not numeric and cannot be added. Don't
    worry about exceptions now; they will be explained in the next chapter.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Now that you can be sure that both values are numeric and can be added without
    unexpected results, it is time to actually add them. Continue typing in the function
    body:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE97]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now it is time to compose the requested message. On the next line, type the
    following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE98]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: What you see in action here is called `$param1`, `$param2`, and `$sum` will
    be expanded into the string sentence. They will also be automatically cast to
    a string.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'String interpolation, although really fast, is still a relatively costly operation
    for the PHP parser. If you need to maximize performance for a use case where every
    nanosecond counts, then it would be better for you to use *string concatenation*
    because it is faster. Here is the same line written using string concatenation:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE99]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The dot (`.`) is the string concatenation operator. It glues two strings together.
    Other types of values are cast to strings automatically before the concatenation
    happens.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Now you can write the following after your function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE100]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add a newline for clarity of the output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE101]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Run the script from the `exercises` directory:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE102]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 4.15: Printing the sum'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/C14196_04_15.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 4.15: Printing the sum'
  prefs: []
  type: TYPE_NORMAL
- en: In this exercise, you have learned how to validate and process the arguments
    to your function and how to format and return some output. You have also learned
    how to perform some very simple math with PHP.
  prefs: []
  type: TYPE_NORMAL
- en: Variable Functions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'If you store a function name in a variable, you can call this variable as a
    function. Here''s an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE103]'
  prefs: []
  type: TYPE_PRE
- en: This is not limited to built-in functions. In fact, you can do the same thing
    with your own functions.
  prefs: []
  type: TYPE_NORMAL
- en: Anonymous Functions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'These are functions without identifiers (refer to the following syntax). They
    can be passed into any function that accepts a callable as input. Consider the
    following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE104]'
  prefs: []
  type: TYPE_PRE
- en: The preceding is an anonymous function, also called a closure. It does not have
    a name, so it cannot be called by its name, but it can be passed into another
    function that does accept a callable as input.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you want to call the anonymous function, there are two ways to achieve this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE105]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding example, the function is created and called immediately with
    the `2.3` argument. The output that is returned will be `1`, because `2.3` is
    greater than `0`. Then `echo` prints the output. In this setup, the anonymous
    function can be called only once – there is no reference to it that would allow
    you to call it again.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the next example, the function will be stored in a variable named `$callable`.
    You may name the variable whatever you like, as long as you stick to the rules
    for naming variables in PHP:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE106]'
  prefs: []
  type: TYPE_PRE
- en: Using a Variable from Outside of Scope Inside an Anonymous Function
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As stated previously in this chapter, you may need to use a variable that was
    defined outside of the scope of the function you are defining. In the following
    exercise, you will see an example of how we can make use of the `use` keyword
    to pass a variable to the anonymous function.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 4.6: Working with Anonymous Functions'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this exercise, we will declare an anonymous function and examine how it
    works:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new file named `callable.php`. Add your opening PHP tag as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE107]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then, define the initial variable that you want to use:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE108]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now define your callable function and pass your `$a` variable to it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE109]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'On the next line, let''s assign a new value to `$a`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE110]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'To see what the current value of `$a` is, we will call `$callable` and print
    it to the screen:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE111]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Lastly, add a new line for readability:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE112]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We can now run this script in the command line using the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE113]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE114]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: So, what's happening here? First, we declare an anonymous function and store
    it in `$callable`. We say it should use `$a` by using the `use` keyword. Then,
    we change the value of `$a` to `different`, call our `$callable` function, and
    then `echo` the result. The result is `15`, which is the initial value of `$a`.
    The reason for this is that when using `use` to import `$a` into the scope of
    the function, `$a` will be used exactly as it was at the time of function creation.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Now what happens when we use `$a` as a reference? Let''s take a look:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE115]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Note that we prefixed `$a` with `&` this time. Now the output will be '`different`'.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Since objects are always passed by reference, this should also be true for objects,
    but that is something that will be covered in another chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 4.7: Creating Variable Functions'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this exercise, we will create variable functions and examine how they work
    in PHP:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Open a file and name it `variable-hello.php`. Start your script with the opening
    PHP tag and set the strict type to `1`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE116]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Declare a variable to store the value of  the function as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE117]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: That's all you need and even a bit more, because you have added a `string` type
    hint and a `void` return type, which are both optional. They are good practice,
    so make a habit of using them. Note that the closure does not return output. Instead,
    it prints the greeting directly to `stdOut`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Now continue typing in your `variable-hello.php` script:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE118]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add a newline:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE119]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Verify that the output on the Terminal is `Hello Susan`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 4.16: Printing the output'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/C14196_04_16.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 4.16: Printing the output'
  prefs: []
  type: TYPE_NORMAL
- en: In this exercise, you have learned how to use string concatenation together
    with a function argument and how to print output directly from a function. Although
    this is a bad practice in many cases, it might be useful in other scenarios.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 4.8: Playing with Functions'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this exercise, we will use a couple more predefined functions to learn about
    processing data and writing our processors so that they are reusable. The goal
    of this exercise is to take an array of directors and their movies and sort them
    by the director''s name. We then want to process that array and print out the
    director''s name where the first letter of the first name is in uppercase and
    the last name is all in uppercase. Additionally, for the movies, we want to capitalize
    each title, wrap them in double quotes, and separate them using commas. We will
    build two functions that will handle the processing of the director''s name and
    another function for movies. We will be making use of three new built-in functions
    that we have yet to discuss: `ksort`, `explode`, and `implode`. To learn more
    about these functions, please review the documentation on [https://packt.live/2OxT91A](https://packt.live/2OxT91A):'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we are going to create a new file called `activity-functions.php` and
    start our script with the opening PHP tag:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE120]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then, we will go ahead and define an array that will hold the director''s name
    as a key and an array of their movies for the value:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE121]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now we will write our first function to process our director''s name. Remember,
    we want the first name to have a capitalized first letter and the last name will
    be fully capitalized:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE122]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, we will write a function to process our movie strings. Note that we want
    to wrap the uppercase version of each movie name and separate them with commas:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE123]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Finally, we can sort our array via the array keys, and loop through and process
    the array:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE124]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We can now run this script in the Terminal:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE125]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'You should see an output like the following:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE126]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The third part of `Felix Gary Gray` is truncated in the output. Can you refactor
    the code to fix this bug?
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Activity 4.1: Creating a Calculator'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You are working on a calculator-based web app. You are given all of the user
    interface code but are instructed to build the function that will actually do
    the calculations. You are instructed to make a single function that is reusable
    for all the calculations that are needed within the app.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following steps will help you to complete the activity:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a function that will calculate and return the factorial of the input
    number.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a function that will return the sum of the input numbers (a varying number
    of parameters).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a function that will evaluate the `$number` input, which has to be an
    integer and will return whether the number is a prime number or not. The return
    type of this function is a Boolean (`bool`).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a base `performOperation` function that will handle the predefined mathematical
    operations. The first parameter of the `performOperation` function must be a string,
    either '`factorial`', '`sum`', or '`prime`'. The remaining arguments are passed
    to the mathematical function being called as arguments.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: A factorial is the product of an integer and all of the integers below it.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'The output should look similar to the following. The output values will depend
    on the numbers that you input:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.17: Expected output'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/C14196_04_17.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 4.17: Expected output'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: The solution for this activity can be found on page 511.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, you learned how you can use functions that are built into
    PHP to accomplish many tasks that would otherwise require you to write a lot of
    code to do the same thing much less quickly. You also learned various ways to
    write your own functions: with and without parameters, using default values or
    not, or even with varying amounts of parameters. You gained an understanding of
    functions that are pure and do not meddle with global scope versus functions that
    do have side effects, either because they pull variables from the global scope
    or receive parameters by reference and change them. You learned that you can call
    functions by their name or as callables stored in variables, anonymously or by
    name. Hopefully, you have got a taste of how flexible and powerful functions are
    and how they can help you to write robust code by enforcing strict types.'
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, you will learn how to combine constants, variables, and
    functions that belong together logically into objects. This will give you an even
    higher level of organization in your code and will take information hiding to
    the next level by restricting the access level of variables and functions that
    are part of objects. Please remember that we call variables that live on object
    properties and we call functions that live on objects methods, while constants
    that live on objects are called class constants. Although they have a different
    name, they behave in a very similar way, so you will be able to reuse everything
    you learned in this chapter.
  prefs: []
  type: TYPE_NORMAL
