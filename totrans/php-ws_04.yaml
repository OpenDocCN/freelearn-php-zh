- en: 4\. Functions
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 4. 函数
- en: Overview
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 概述
- en: By the end of this chapter, you will be able to work with built-in functions;
    create user-defined functions; and write anonymous functions.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，你将能够使用内置函数；创建用户定义的函数；并编写匿名函数。
- en: Introduction
  id: totrans-3
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简介
- en: When writing software, we often run into situations where we need to do a specific
    task in different places within the application that we are building. Without
    thinking about it, it can be easy to fall into the habit of rewriting the same
    code over and over again, causing code repetition and making it harder to debug
    errors when they show up. However, as with all other programming languages, PHP
    gives you the ability to structure reusable code in what is known as a **function**,
    which is also sometimes referred to as a method. These two terms will be used
    interchangeably throughout this chapter.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在编写软件时，我们经常遇到需要在构建的应用程序的不同地方执行特定任务的情况。如果不加思考，很容易养成反复重写相同代码的习惯，这会导致代码重复，并在错误出现时更难调试。然而，与其他所有编程语言一样，PHP
    允许你以所谓的**函数**的形式结构化可重用代码，这有时也被称为方法。这两个术语将在本章中交替使用。
- en: Think of a function as a reusable set of instructions or statements. After writing
    it once, you can call it as many times as you like. Functions bundle logic that
    should otherwise be kept inseparably together.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 将函数视为一组可重用的指令或语句。一旦编写，你可以随意多次调用它。函数将本应不可分割地一起保留的逻辑捆绑在一起。
- en: 'Grouping and isolating a set of instructions inside a function comes with a
    number of benefits. The most obvious one is the option to reuse it: once you have
    written your function, you never need to rewrite or reinvent this particular set
    of instructions again. Functions also improve consistency – this means that each
    time you call your function, you can be sure the same set of instructions will
    be applied.'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在函数内部分组和隔离一组指令带来了一系列好处。最明显的好处是可重用性：一旦你编写了函数，你永远不需要再次重写或重新发明这组特定的指令。函数还提高了一致性——这意味着每次你调用函数时，你可以确信将应用相同的指令集。
- en: Another less obvious benefit is that your code becomes much more readable, especially
    when you name your functions so that it is clear what they do.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个不那么明显的优点是，你的代码变得更加易于阅读，尤其是当你给函数命名，使其清晰表明它们的功能时。
- en: Another good thing about a function is that it encloses local variables within
    its scope, so that they do not pollute the global scope. We will discuss scope
    in more detail later.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 函数的另一个优点是它将局部变量包含在其作用域内，因此它们不会污染全局作用域。我们将在稍后更详细地讨论作用域。
- en: 'Here''s an example of a simple function:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是一个简单函数的示例：
- en: '[PRE0]'
  id: totrans-10
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Here''s a function that has been written to calculate the average of the values
    passed to this function:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个编写来计算传递给此函数的值的平均值的函数：
- en: '[PRE1]'
  id: totrans-12
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Note that this is not production-ready code. The function does not check anything
    about its inputs and does not prevent error conditions, such as division by zero,
    if you do not pass any arguments. The `function-average.php` file contains a more
    elaborate example of the same function for you to refer to on the GitHub repository.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，这不是生产就绪的代码。该函数不检查其输入的任何内容，并且如果不传递任何参数，不会防止错误条件，例如除以零。`function-average.php`
    文件包含了一个更详细的相同函数示例，你可以参考 GitHub 仓库。
- en: A function is **callable**. However, note that not all callables are functions.
    Functions can call other functions, functions can pass functions around to other
    functions to be called by them, and functions can create functions. Confused?
    Read on and look at the examples and you will see that it is not complicated at
    all.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 函数是**可调用的**。然而，请注意，并非所有可调用项都是函数。函数可以调用其他函数，函数可以将函数传递给其他函数以供它们调用，并且函数可以创建函数。困惑了吗？继续阅读并查看示例，你会发现这并不复杂。
- en: What is a Callable?
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 什么是可调用项？
- en: Simply put, a callable is a part of your code that you can "call". When we say
    that you can "call" something, we mean that you can tell the program to execute
    it.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，可调用项是你代码的一部分，你可以“调用”。当我们说你可以“调用”某物时，我们的意思是你可以告诉程序执行它。
- en: A callable can be written with parentheses after it, for example, `functionName()`.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 可调用项可以在其后写上括号，例如，`functionName()`。
- en: As previously described, a function is a type of callable, so a function can
    be called (that is, you can tell your program to execute it).
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，函数是一种可调用类型，因此可以调用函数（即，你可以告诉程序执行它）。
- en: 'As an example, consider the following user-defined function:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，考虑以下用户定义的函数：
- en: '[PRE2]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Do not worry about the details of the function right now—we will get into the
    nitty-gritty of it later. This function could be defined anywhere in your code,
    but let's assume that it is defined in a script called `how-many-times-did-we-tell-you.php`.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 目前不必担心函数的细节——我们稍后会深入探讨。这个函数可以在你的代码的任何地方定义，但让我们假设它定义在一个名为 `how-many-times-did-we-tell-you.php`
    的脚本中。
- en: 'The contents of the script would then look like this:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 脚本的内容将如下所示：
- en: '[PRE3]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The function takes a single parameter, `$numberOfTimes`, which must be of the
    `int` (integer) type, and it returns a string. The `int` type hint and the `string`
    return type are optional. We will discuss parameters and returning values later
    in the chapter. Now, `function howManyTimesDidWeTellYou(int $numberOfTimes): string`
    is just the function declaration: it defines the function. The script itself does
    nothing yet.'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: '这个函数接受一个参数，`$numberOfTimes`，它必须是 `int`（整数）类型，并且它返回一个字符串。`int` 类型提示和 `string`
    返回类型是可选的。我们将在本章后面讨论参数和返回值。现在，`function howManyTimesDidWeTellYou(int $numberOfTimes):
    string` 只是函数声明：它定义了函数。脚本本身目前什么也不做。'
- en: 'In order to enable the function to actually do something, we need to call it
    from our code. It is perfectly valid to continue in the same script file and call
    the function that we just defined as follows:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使这个函数真正能做些什么，我们需要从我们的代码中调用它。在同一个脚本文件中继续并调用我们刚刚定义的函数是完全有效的，如下所示：
- en: '[PRE4]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'If you open a Terminal and execute the script, you will see no output. Why
    not? The reason is that while the function does return a string, it does not print
    any output. To generate output, you need to `echo` the return value of the function
    as follows:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你打开一个终端并执行脚本，你将看不到任何输出。为什么？原因在于，虽然函数确实返回一个字符串，但它没有打印任何输出。要生成输出，你需要像以下这样 `echo`
    函数的返回值：
- en: '[PRE5]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Now you will see output if you execute the script.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 现在如果你执行这个脚本，你将看到输出。
- en: 'Execute the script by calling it from the command line in the directory where
    the script lives. You can simply type the following text and press *Enter*:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 通过在脚本所在的目录中从命令行调用它来执行脚本。你可以简单地输入以下文本并按 *Enter* 键：
- en: '[PRE6]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The output is as follows:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE7]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'You will immediately spot a problem with this output: it is grammatically incorrect.
    And what if we were to pass a negative integer? Then, the output would be even
    logically incorrect. Our function is not production-ready at this point.'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 你会立即发现这个输出的一个问题：它是语法错误的。如果我们传递一个负整数呢？那么，输出在逻辑上也会是错误的。我们的函数目前还没有准备好投入生产。
- en: A more elaborate example of the function and how it can be called is to be found
    in the `how-many-times-did-we-tell-you.php` file.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 函数的更详细示例以及如何调用它可以在 `how-many-times-did-we-tell-you.php` 文件中找到。
- en: Note that it is possible to print text from within functions by using `echo`
    inside a function. However, this makes the function less reusable as it will generate
    output as soon as it is called. In some cases, you might want to delay output.
    For example, you may be collecting and combining strings before you output them,
    or you may want to store the string in a database and don't want to display it
    at this stage. Although printing directly from within a function is generally
    considered bad practice, you will see it a lot in systems such as WordPress. Printing
    from a function can be convenient in a context where generating output is the
    most important task.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，你可以在函数内部使用 `echo` 来打印文本。然而，这会使函数的可重用性降低，因为它会在被调用时立即生成输出。在某些情况下，你可能想要延迟输出。例如，你可能在输出之前收集和组合字符串，或者你可能想要将字符串存储在数据库中，而不想在这个阶段显示它。尽管在函数内部直接打印通常被认为是不良的做法，但你将在像
    WordPress 这样的系统中看到很多这样的例子。在生成输出是最重要的任务的情况下，从函数中打印可能是方便的。
- en: 'Exercise 4.1: Using Built-in Functions'
  id: totrans-37
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习 4.1：使用内置函数
- en: 'This exercise is about string manipulation. PHP has many built-in string manipulation
    functions. The one we will be using here is `substr()`. Like most other built-in
    functions, the behavior of `substr()` can be tweaked by passing various parameters:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 这个练习是关于字符串操作。PHP 有许多内置的字符串操作函数。我们将在这里使用的是 `substr()`。像大多数其他内置函数一样，`substr()`
    的行为可以通过传递各种参数来调整：
- en: Create a new directory called `Chapter04`. Then, inside it, create a folder
    named `exercises`.
  id: totrans-39
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `Chapter04` 的新目录。然后，在其内部创建一个名为 `exercises` 的文件夹。
- en: Create a file called `hello.php` in the `Chapter04/exercises` directory.
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Chapter04/exercises` 目录中创建一个名为 `hello.php` 的文件。
- en: 'Write the opening script tag:'
  id: totrans-41
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 写入开头的脚本标签：
- en: '[PRE8]'
  id: totrans-42
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The opening tag tells the parser that, from this point onward, what we write
    is PHP.
  id: totrans-43
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 开头标签告诉解析器，从这一点开始，我们写的内容是PHP。
- en: 'Write the instruction that extracts and prints "Hello" from "Hello World" using
    `substr()`:'
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写指令，使用`substr()`从"Hello World"中提取并打印"Hello"：
- en: '[PRE9]'
  id: totrans-45
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The `echo` command prints the result of the statement that comes after it.
    The statement calls the `substr` function with three arguments: the literal string,
    `Hello World`, and the literal integers `0` and `5`. What this says is "*give
    me the five characters of the input string starting from 0*". In PHP, you can
    think of a string as almost like an array, where each character in that string
    is an element. Like in many other programming languages, array indices start at
    zero instead of one. If you count the characters, you will see that `H e l l o`
    are the first five characters of the `Hello World` input string. They are returned
    from the function as a new string of five characters.'
  id: totrans-46
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`echo`命令打印其后语句的结果。该语句调用`substr`函数，并带有三个参数：字面字符串`Hello World`和字面整数`0`和`5`。这意味着"*从0开始给我五个输入字符串的字符*"。在PHP中，你可以将字符串视为几乎像数组一样，其中字符串中的每个字符都是一个元素。像许多其他编程语言一样，数组索引从零开始而不是一。如果你数一下字符，你会看到`H
    e l l o`是`Hello World`输入字符串的前五个字符。它们作为包含五个字符的新字符串从函数返回。'
- en: 'Optionally, on the next line, `echo` a newline, only for clarity of the output:'
  id: totrans-47
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 可选地，在下一行，`echo`一个换行符，仅为了输出清晰：
- en: '[PRE10]'
  id: totrans-48
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '`PHP_EOL` is a predefined constant that outputs a newline in the correct format
    for the operating system you are on. Using this constant makes your code more
    portable between different operating systems.'
  id: totrans-49
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`PHP_EOL`是一个预定义的常量，可以在正确的格式下输出换行符，适用于你所在的操作系统。使用这个常量可以使你的代码在不同操作系统之间更便携。'
- en: 'Open a Terminal and go to the `Chapter04/exercises` directory where your `hello.php`
    script is placed and execute the file using the following code:'
  id: totrans-50
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开终端并进入存放你的`hello.php`脚本的`Chapter04/exercises`目录，并使用以下代码执行文件：
- en: '[PRE11]'
  id: totrans-51
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Observe that `Hello` and a newline are printed in the Terminal; this is what
    the output looks in the Terminal:'
  id: totrans-52
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意，`Hello`和换行符在终端中打印出来；这就是终端中的输出看起来像什么：
- en: '![Figure 4.1: Printing the output to the Terminal'
  id: totrans-53
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图4.1：将输出打印到终端'
- en: '](img/C14196_04_01.jpg)'
  id: totrans-54
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![img/C14196_04_01.jpg]'
- en: 'Figure 4.1: Printing the output to the Terminal'
  id: totrans-55
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图4.1：将输出打印到终端
- en: Note
  id: totrans-56
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意
- en: Don't worry if your path differs from that of the screenshot as this will depend
    on your system settings.
  id: totrans-57
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果你的路径与截图中的路径不同，不要担心，因为这将取决于你的系统设置。
- en: 'Now change the code to the following:'
  id: totrans-58
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在将代码更改为以下内容：
- en: '[PRE12]'
  id: totrans-59
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Run the script again and notice the output is now `World` (notice the space
    at the start). What happened is that the substring is now taken from position
    5 (the sixth character, the space), to the end of the string.
  id: totrans-60
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 再次运行脚本，注意输出现在是`World`（注意开头的空格）。发生的事情是，现在子字符串是从位置5（第六个字符，空格）到字符串的末尾。
- en: 'Change the code to:'
  id: totrans-61
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将代码更改为：
- en: '[PRE13]'
  id: totrans-62
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Run the script and notice the output will be `orl`. What happens is that now
    the start is negative and counted backward from the end of the string. The length
    is `3` and taken toward the end of the string from the start:'
  id: totrans-63
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 运行脚本，注意输出将是`orl`。发生的事情是，现在开始是负数，从字符串的末尾向前计数。长度是`3`，从开始向字符串的末尾取：
- en: '![Figure 4.2: Printing the sliced string'
  id: totrans-64
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图4.2：打印切片字符串'
- en: '](img/C14196_04_02.jpg)'
  id: totrans-65
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![img/C14196_04_02.jpg]'
- en: 'Figure 4.2: Printing the sliced string'
  id: totrans-66
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图4.2：打印切片字符串
- en: In the preceding screenshot, you can see the output from *step 8*. The output
    looks this way because I used a scratch file in PhpStorm. I added a new scratch
    file and just quickly pasted the code into it and ran it using the green play
    button in PhpStorm. Scratch files are a way of quickly testing some code in files
    while the files are not added to your project.
  id: totrans-67
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在前面的屏幕截图中，你可以看到*步骤8*的输出。输出看起来是这个样子，因为我使用了PhpStorm中的临时文件。我添加了一个新的临时文件，并快速将代码粘贴进去，然后使用PhpStorm中的绿色播放按钮运行它。临时文件是在文件未添加到你的项目时快速测试一些代码的方法。
- en: 'Change the statement to the following:'
  id: totrans-68
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将语句更改为以下内容：
- en: '[PRE14]'
  id: totrans-69
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Note
  id: totrans-70
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意
- en: '`Ideeën` is a Dutch word that means "ideas." However, for this example, we
    need the `ë` character, so we can''t just type "ideas."'
  id: totrans-71
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`Ideeën`是荷兰语单词，意为"想法"。然而，对于这个例子，我们需要`ë`字符，所以我们不能只输入"ideas"。'
- en: 'Run the script again and notice that the output is `ën`. If you have been paying
    attention so far, you should have expected the output to be `eën`: it is three
    characters long, counted from `start = -3`, and counted backward from the end
    of the string until the end of the string. So, why is the output two characters
    long in this case and not three? The explanation is that `ë` is a multibyte character.
    If you need to check whether a string is UTF-8-encoding, you can use an additional
    built-in function called `mb_detect_encoding`, passing the string as the first
    parameter and UTF-8 as the second parameter. The `substr` method just counts bytes
    and does not account for characters that are multiple bytes in length. Now, there
    is a solution for that: `mb_substr`. In fact, for many string manipulation functions,
    there are sister functions that are prefixed with `mb_` to indicate that they
    support multibyte characters. If you always use the `mb_` versions of these methods,
    you will get the expected results.'
  id: totrans-72
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 再次运行脚本，注意输出是 `ën`。如果你一直很注意，你应该预期输出是 `eën`：它由三个字符组成，从 `start = -3` 开始计算，并从字符串的末尾向前计数直到字符串的末尾。那么，为什么在这个情况下输出是两个字符长而不是三个？解释是
    `ë` 是一个多字节字符。如果你需要检查一个字符串是否是 UTF-8 编码，你可以使用一个额外的内置函数 `mb_detect_encoding`，将字符串作为第一个参数，将
    UTF-8 作为第二个参数。`substr` 方法只计算字节，并不考虑长度超过一个字节的字符。现在，有一个解决方案：`mb_substr`。实际上，对于许多字符串操作函数，都有前缀为
    `mb_` 的姐妹函数，以表示它们支持多字节字符。如果你总是使用这些方法的 `mb_` 版本，你将得到预期的结果。
- en: 'Change the statement to the following:'
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将语句更改为以下内容：
- en: '[PRE15]'
  id: totrans-74
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Run the script once more and notice that now you get the expected output of
    `eën`:'
  id: totrans-75
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 再次运行脚本，注意现在你得到了预期的输出 `eën`：
- en: '![Figure 4.3: Printing the output of the sliced strings'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 4.3：打印切片字符串的输出]'
- en: '](img/C14196_04_03.jpg)'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片](img/C14196_04_03.jpg)'
- en: 'Figure 4.3: Printing the output of the sliced strings'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.3：打印切片字符串的输出
- en: Remember to always use the `mb_*` versions of string manipulation functions.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 记住始终使用字符串操作函数的 `mb_*` 版本。
- en: In this section, we were introduced to callables and started to get a glimpse
    of the built-in functions that are available to us. Next, we are going to dive
    a little deeper into the types of callables.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们介绍了可调用对象，并开始了解我们可用的内置函数。接下来，我们将更深入地探讨可调用对象的类型。
- en: Types of Callables
  id: totrans-81
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 可调用对象的类型
- en: 'There are several types of callables:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 有几种类型的可调用对象：
- en: Functions, such as `mb_strtoupper`.
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数，例如 `mb_strtoupper`。
- en: Anonymous functions or closures.
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 匿名函数或闭包。
- en: Variables that hold the name of a function.
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 存储函数名称的变量。
- en: An array with two elements, where the first element is the object and the second
    element is the name of the function you wish to call that exists within the object
    written as a string. An example of this can be found in the `callables.php` document.
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个包含两个元素的数组，其中第一个元素是对象，第二个元素是你希望在该对象中调用的函数的名称，该函数以字符串的形式编写。这个示例可以在 `callables.php`
    文档中找到。
- en: An object that has the `__invoke` magic method defined.
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定义了 `__invoke` 魔术方法的对象。
- en: 'The `__invoke` method is a magic function that can be attached to classes that
    when initialized to a variable will make that assigned variable into a callable
    function. Here''s a simple example of the `__invoke` method:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '`__invoke` 方法是一个可以附加到类上的魔术函数，当将其初始化到变量中时，将使该分配的变量成为一个可调用的函数。以下是一个简单的 `__invoke`
    方法的示例：'
- en: '[PRE16]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The output is as follows:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE17]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: In the preceding example, we declared a `$sparky` object and executed this object
    as a function by calling it `$sparky()`. This function, in turn, invoked its primary
    action and printed the result.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，我们声明了一个 `$sparky` 对象，并通过调用 `$sparky()` 将该对象作为函数执行。这个函数反过来调用了它的主要操作并打印了结果。
- en: To verify whether something is a callable, you can pass it to the built-in `is_callable`
    function. This function will return `true` if its first argument is a callable
    and `false` if not. The `is_callable` function actually takes up to three arguments
    that tweak the behavior of `is_callable`.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 要验证某个东西是否是可调用的，你可以将其传递给内置的 `is_callable` 函数。如果其第一个参数是可调用的，该函数将返回 `true`，如果不是，则返回
    `false`。实际上，`is_callable` 函数可以接受最多三个参数，这些参数会调整 `is_callable` 的行为。
- en: 'Try out the following example:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试以下示例：
- en: '[PRE18]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: You can explore more examples in the `callables.php` script on the GitHub repository.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在 GitHub 仓库中的 `callables.php` 脚本中探索更多示例。
- en: Language Constructs
  id: totrans-97
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 语言构造
- en: '`if` and `while`. Language constructs that act like functions look very much
    like built-in functions in the way they are used. If you want to print a string,
    you can choose to use `echo`, which is a language construct; or `print`, which
    is also a language construct. There are small differences between `echo` and `print`,
    and `echo` is the most commonly used. When comparing the two, `echo` doesn''t
    have a return value and has the option of multiple parameters, whereas `print`
    returns a value that can be used in an expression and allows only one parameter.
    `echo` is the most flexible of the two and is a tiny bit faster. Language constructs
    can be used with or without parentheses. In contrast, callables are always used
    with parentheses:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '`if` 和 `while`。类似于函数的语言构造在用法上与内置函数非常相似。如果你想打印一个字符串，你可以选择使用语言构造 `echo`；或者使用也是语言构造的
    `print`。`echo` 和 `print` 之间有一些小的区别，其中 `echo` 是最常用的。在比较这两个时，`echo` 没有返回值，并且可以选择多个参数，而
    `print` 返回一个可以在表达式中使用的值，并且只允许一个参数。`echo` 是两者中最灵活的，并且稍微快一点。语言构造可以带括号或不带括号使用。相比之下，可调用对象总是使用括号：'
- en: '[PRE19]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Both statements print `hello world`. A language construct has a more efficient
    underlying implementation in C than a function and thus will execute faster. You
    can use parentheses with `echo` and `print`, but it is not mandatory.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 两个语句都打印 `hello world`。在 C 语言中，语言构造的底层实现比函数更高效，因此执行速度更快。你可以使用括号与 `echo` 和 `print`
    一起使用，但这不是强制性的。
- en: Introduction to Built-In Functions
  id: totrans-101
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 内置函数简介
- en: 'PHP comes with many built-in functions, such as `strtoupper`, which changes
    the case of an input string to uppercase:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: PHP 内置了许多函数，例如 `strtoupper`，它将输入字符串的字母转换为大写：
- en: '[PRE20]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: PHP natively comes with a ton of functions. By adding extensions to PHP, you
    add even more built-in functions and classes to it. Built-in functions are precompiled
    in C as this is the language that PHP and its extensions are written in.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: PHP 本身就自带了大量函数。通过向 PHP 添加扩展，你可以添加更多内置函数和类。内置函数是在 C 语言中预编译的，因为 PHP 及其扩展都是用 C
    语言编写的。
- en: Note
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: How to add an extension will differ depending on which operating system you
    are on. So, when searching for it, always add the name of your operating system
    to your search and be sure to consult the most recent results first, as they are
    more likely to outline the correct procedure for installing or compiling extensions
    into PHP.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 如何添加扩展取决于你使用的操作系统。因此，在搜索时，始终将你的操作系统名称添加到搜索中，并确保首先查阅最新的结果，因为它们更有可能概述安装或编译扩展到
    PHP 中的正确程序。
- en: 'There is hardly anything more frustrating than spending days on writing some
    functionality, only to discover toward the end that there is a built-in function
    that does the same thing five times faster. So, before writing functionality yourself,
    try to google or search [https://packt.live/2OxT91A](https://packt.live/2OxT91A)
    for built-in functions. If you are using an IDE, built-in functions will be suggested
    by autocomplete as soon as you start typing in a PHP document. PHP is often called
    a glue language: it is used to tie different systems together. Therefore, there
    is a wealth of functions that talk to databases, file resources, network resources,
    external libraries, and so on.'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 没有什么比花费数天时间编写一些功能，最后发现有一个内置函数能以五倍的速度完成同样的工作更令人沮丧了。因此，在编写自己的功能之前，尝试在 [https://packt.live/2OxT91A](https://packt.live/2OxT91A)
    上搜索内置函数。如果你正在使用 IDE，一旦你在 PHP 文档中开始输入，内置函数就会通过自动完成建议。PHP 通常被称为粘合语言：它用于将不同的系统连接在一起。因此，有许多与数据库、文件资源、网络资源、外部库等通信的函数。
- en: 'If you are using a function that is provided by an extension that is not installed
    or compiled with your PHP version, you will get an error. For example, calling
    `gd_info()` when `GD` is not installed results in `Fatal error: Uncaught Error:
    Call to undefined function gd_info()`. By the way, `GD` is a library used for
    image manipulation.'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你正在使用一个由未安装或与你的 PHP 版本一起编译的扩展提供的函数，你将得到一个错误。例如，当 `GD` 没有安装时调用 `gd_info()`
    将导致 `致命错误：未捕获的错误：调用未定义的函数 gd_info()`。顺便说一句，`GD` 是一个用于图像处理的库。
- en: Note
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: On a side note, in many real-life projects, we handle multibyte strings. When
    handling multibyte strings, you should be using the multibyte-safe string manipulation
    functions. Instead of `strtoupper`, you would be using `mb_strtoupper`.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 顺便提一下，在许多实际项目中，我们处理多字节字符串。在处理多字节字符串时，你应该使用多字节安全的字符串操作函数。而不是使用 `strtoupper`，你会使用
    `mb_strtoupper`。
- en: Finding Built-In Functions
  id: totrans-111
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 查找内置函数
- en: 'To find out which version of PHP you are currently using, open up a Terminal,
    type the following command, and then hit *Enter*:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 要找出你目前正在使用的 PHP 版本，打开终端，输入以下命令，然后按 *Enter* 键：
- en: '[PRE21]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'To find out what extensions are installed on your system, type the following
    command and hit *Enter*:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 要找出系统上安装了哪些扩展，输入以下命令并按 *Enter* 键：
- en: '[PRE22]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: This will list all extensions currently installed and enabled in your PHP installation.
    You can also list the extensions using the built-in `get_loaded_extensions` PHP
    function.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 这将列出当前在你的 PHP 安装中已安装和启用的所有扩展。你还可以使用内置的 `get_loaded_extensions` PHP 函数列出扩展。
- en: 'To make use of that, write a file called `list-extensions.php` with the following
    content:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 要利用这一点，编写一个名为 `list-extensions.php` 的文件，内容如下：
- en: '[PRE23]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Execute the file from the command line as follows:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 按如下方式从命令行执行文件：
- en: '[PRE24]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Note that if you do this, you will have used two built-in functions: `print_r`
    and `get_loaded_extensions`. The `print_r()` function prints its first argument
    in human-readable form. You can use the second argument, a `true` Boolean value,
    to return the output instead of printing it on the screen. That way, you can write
    it to a log file, for example, or pass it on to another function.'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，如果你这样做，你将使用了两个内置函数：`print_r` 和 `get_loaded_extensions`。`print_r()` 函数以人类可读的形式打印其第一个参数。你可以使用第二个参数，一个
    `true` 布尔值，来返回输出而不是将其打印到屏幕上。这样，你可以将其写入日志文件，例如，或者传递给另一个函数。
- en: 'The output should look like the following screenshot (note that the extensions
    may vary on your system):'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 输出应该看起来像以下截图（注意，系统上的扩展可能不同）：
- en: '![Figure 4.4: Listing the extensions'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 4.4：列出扩展](img/C14196_04_04.jpg)'
- en: '](img/C14196_04_04.jpg)'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片](img/C14196_04_04.jpg)'
- en: 'Figure 4.4: Listing the extensions'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.4：列出扩展
- en: 'Another function that you may find useful while exploring the built-in functions
    and the extensions is `get_extension_funcs ( string $module_name ) : array`, which
    you can use to list the functions that an extension provides. Often, it will be
    easier to find the functions in the documentation of the extension.'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: '在探索内置函数和扩展时，你可能还会发现 `get_extension_funcs ( string $module_name ) : array` 函数很有用，你可以使用它来列出扩展提供的函数。通常，在扩展的文档中找到函数会更容易。'
- en: 'Here is the top part of the output:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 这是输出的一部分：
- en: '[PRE25]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'The output is as follows:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '![Figure 4.5: Listing the top extensions'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 4.5：列出顶级扩展](img/C14196_04_05.jpg)'
- en: '](img/C14196_04_05.jpg)'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片](img/C14196_04_05.jpg)'
- en: 'Figure 4.5: Listing the top extensions'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.5：列出顶级扩展
- en: Note
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: You can find more information about built-in functions at [https://packt.live/2oiJPEl](https://packt.live/2oiJPEl).
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在 [https://packt.live/2oiJPEl](https://packt.live/2oiJPEl) 找到更多关于内置函数的信息。
- en: Parameters and Return Values
  id: totrans-135
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参数和返回值
- en: 'Parameters are the variables written within the function declaration. Arguments
    are the values that you pass as these parameters. Return values are the values
    that the function returns when it has completely executed. In the previous example,
    `get_loaded_extensions` was called without any arguments: there was nothing between
    the braces after `get_loaded_extensions`.'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 参数是在函数声明中写入的变量。参数是作为这些参数传递的值。返回值是函数完全执行后返回的值。在之前的例子中，`get_loaded_extensions`
    没有带任何参数被调用：在 `get_loaded_extensions` 后面的大括号中没有内容。
- en: 'The return value of `get_loaded_extensions()` is an array of extensions loaded
    into PHP – extensions that are installed and enabled. That return value was used
    as an argument to `print_r`, which returned a user-friendly string describing
    its input. To clarify this, the `list-extensions.php` script could be rewritten
    as follows:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: '`get_loaded_extensions()` 的返回值是一个包含在 PHP 中加载的扩展的数组 - 已安装并启用的扩展。该返回值被用作 `print_r`
    的参数，它返回一个描述其输入的用户友好的字符串。为了澄清这一点，可以将 `list-extensions.php` 脚本重写如下：'
- en: '[PRE26]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Passing Parameters by Reference
  id: totrans-139
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 通过引用传递参数
- en: Parameters that are objects are always passed by reference. We will go into
    further detail about objects in *Chapter 5*, *Object Oriented Programming*, but
    to give you a little bit of context, think of an object as a container that contains
    scoped variables and functions. This means that an address in memory where that
    object exists is passed into the function so the function can find the actual
    object internally when it needs it. If the function modifies the referenced object,
    then the original object that is held in memory will reflect those changes. If
    you want a copy of the object to work on instead, you need to clone the object
    with the `clone` keyword before working on it. You can think of a clone as a copier
    that will make an exact copy of the object you want to duplicate.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 对象参数总是通过引用传递。我们将在*第五章*，*面向对象编程*中进一步详细介绍对象，但为了给你一些背景信息，可以把对象想象成一个容器，它包含作用域变量和函数。这意味着，存在对象的内存地址会被传递到函数中，这样函数在需要时可以在内部找到实际的对象。如果函数修改了引用的对象，那么内存中持有的原始对象将反映这些更改。如果你想使用对象的副本来工作，你需要在工作之前使用`clone`关键字克隆对象。你可以把克隆想象成一个复制器，它会制作你想要复制的对象的精确副本。
- en: 'An example of the use of the `clone` keyword can be found here:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: '`clone`关键字的用法示例可以在这里找到：'
- en: '[PRE27]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'If the modified copy is required outside the function, you can choose to return
    it from the function. In the following example, `$document` becomes a variable
    that contains an object reference to a `DomDocument` object:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 如果需要在函数外部使用修改后的副本，你可以选择从函数中返回它。在以下示例中，`$document`成为一个包含`DomDocument`对象引用的变量：
- en: '[PRE28]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: With scalar variable parameters, it is the programmer of the function who decides
    whether a parameter is passed by reference or as a copy of the original value.
    Note that only variables can be passed by reference.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 使用标量变量参数时，函数的程序员决定参数是通过引用传递还是作为原始值的副本。请注意，只有变量可以通过引用传递。
- en: 'A scalar variable is a variable that holds a scalar value, such as `$a` in
    the following example:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 标量变量是一个持有标量值的变量，例如以下示例中的`$a`：
- en: '[PRE29]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: As opposed to just `10`, which is an integer value, scalars can be numbers,
    strings, or arrays.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 与仅仅是`10`这样的整数值不同，标量可以是数字、字符串或数组。
- en: If you pass a literal scalar value to a function that expects a reference, you
    will get an error stating that only variables can be passed by reference. This
    is because the PHP parser holds no references to scalars – they are just themselves.
    It is only when you assign a scalar to a variable that a reference to that variable
    will exist internally.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你向期望引用的函数传递一个字面标量值，你会得到一个错误，指出只有变量可以通过引用传递。这是因为PHP解析器不持有标量的引用——它们只是它们自己。只有当你将标量赋值给变量时，该变量的引用才会存在。
- en: Passing Scalar Variables by Reference
  id: totrans-150
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 通过引用传递标量变量
- en: PHP has many functions that work on arrays. They differ a lot as to whether
    they take the array as a reference or not.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: PHP有许多在数组上工作的函数。它们在是否接受数组引用方面有很大差异。
- en: 'Take the following array:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下数组：
- en: '[PRE30]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'The built-in `sort()` function will sort the preceding fruits in alphabetical
    order. The array is passed by reference. So, after calling `sort($fruits);`, the
    original array will be in alphabetical order:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 内置的`sort()`函数将前面的水果按字母顺序排序。数组是通过引用传递的。因此，在调用`sort($fruits);`之后，原始数组将按字母顺序排列：
- en: '[PRE31]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'The output should be as follows:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 输出应该如下：
- en: '[PRE32]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'As opposed to passing by reference, `array_reverse` works on a copy of the
    array passed into it and returns it with its elements in reverse order:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 与通过引用传递相反，`array_reverse`在其传入的数组副本上工作，并返回其元素顺序相反的数组：
- en: '[PRE33]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'The output is as follows:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE34]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: For more elaborate examples, you can refer to `array-pass-by-reference.php`
    and `array-pass-a-copy.php`, which are available on GitHub.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 对于更详细的示例，你可以参考GitHub上的`array-pass-by-reference.php`和`array-pass-a-copy.php`。
- en: 'Another example that you see in real-life code is `preg_match()`. This function
    matches an occurrence of a pattern in a string and stores it in the optional `&$matches`
    parameter, which is passed by reference. This means that you have to declare a
    `$matches` variable before you call the function or even while you are calling
    it. After the function has run, the previously empty `$matches` array will be
    filled with the match. The pattern is a regular expression. Regular expressions
    deserve their own chapter, but the essence is that a regular expression defines
    a pattern that the parser can then recognize in a string and return as a match.
    The `preg_match()` function returns `1` if the pattern exists in the string and
    `matches`, if provided, will contain the actual match:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个你在现实生活中的代码中看到的例子是 `preg_match()`。这个函数会在字符串中匹配一个模式的出现，并将其存储在可选的 `&$matches`
    参数中，该参数通过引用传递。这意味着在调用函数之前，甚至在你调用函数的过程中，你必须声明一个 `$matches` 变量。函数运行后，之前为空的 `$matches`
    数组将被填充。模式是一个正则表达式。正则表达式值得拥有自己的章节，但本质是正则表达式定义了一个模式，解析器可以在字符串中识别该模式并将其作为匹配返回。`preg_match()`
    函数如果模式存在于字符串中并且匹配，则返回 `1`，如果提供了 `matches`，则 `matches` 将包含实际的匹配：
- en: '[PRE35]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'The output is as follows:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE36]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: As you can see, the first occurrence that is found is the single match stored
    in `$matches`. If you want all of the spaces followed by three word characters,
    you should use `preg_match_all()`.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，第一个找到的匹配是存储在 `$matches` 中的单个匹配。如果你想找到所有跟随三个单词字符的空格，你应该使用 `preg_match_all()`。
- en: 'To demonstrate how simply changing the `preg_match` function to `preg_match_all`
    can return all instances of the matches, we will change the following line:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 为了演示如何简单地将 `preg_match` 函数更改为 `preg_match_all` 来返回所有匹配实例，我们将更改以下行：
- en: '[PRE37]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'We will replace it with the following code:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将用以下代码替换它：
- en: '[PRE38]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: This will result in returning all of the sections that match our defined pattern.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 这将导致返回所有与我们的定义模式匹配的部分。
- en: 'The output is as follows:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE39]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Note
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: 'To learn more about regex, take a look at: [https://packt.live/33n2y0n](https://packt.live/33n2y0n).'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解更多关于正则表达式的信息，请查看：[https://packt.live/33n2y0n](https://packt.live/33n2y0n)。
- en: Optional Parameters
  id: totrans-177
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 可选参数
- en: 'You will have noticed that we have used `print_r()` in a lot of examples to
    display a user-friendly representation of variables that would otherwise not make
    much sense. Let''s take the following array:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 你会注意到我们在很多例子中都使用了 `print_r()` 来显示变量的人性化表示，否则这些变量可能不会很有意义。让我们看一下以下数组：
- en: '[PRE40]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Using `echo $values;` would just print `Array` on the screen, while `print_r($values);`
    prints a human-readable format for us to view:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `echo $values;` 只会在屏幕上打印 `Array`，而 `print_r($values);` 会打印出我们可读的格式：
- en: '[PRE41]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Now, suppose that you would like to send information about `$values` to somewhere
    other than the screen. The reason for this could be that you want to send information
    about an error, or that you would like to keep a log of what is going on in your
    application. In the message that you send, you would like to include information
    about the contents of `$values`. If you were to use `print_r` for that, the output
    would not appear in your message but would be written to the screen instead. That
    is not what you want. Now the optional second parameter of `print_r` comes into
    play. If you pass that second argument with your function call and make it `true`,
    the output will not be printed directly, but instead be returned from the function:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，假设你想要将 `$values` 的信息发送到屏幕以外的其他地方。这样做的原因可能是你想要发送有关错误的详细信息，或者你希望记录应用程序中的操作日志。在你发送的消息中，你希望包含有关
    `$values` 内容的信息。如果你使用 `print_r` 来实现这一点，输出将不会出现在你的消息中，而是会被写入屏幕。这并不是你想要的。现在 `print_r`
    的可选第二个参数就派上用场了。如果你在函数调用中传递第二个参数并设置为 `true`，输出将不会直接打印，而是由函数返回：
- en: '[PRE42]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'The `$output` variable now contains the following:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: '`$output` 变量现在包含以下内容：'
- en: '[PRE43]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: This can be used later to compose a message to be sent anywhere you need.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 这可以在以后用来编写需要发送到任何地方的短信。
- en: 'Exercise 4.2: Working with print_r()'
  id: totrans-187
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习 4.2：使用 print_r()
- en: 'In this exercise, we will use the `print_r()` function to print different shapes
    in a human-readable format. To do this, we will execute the following steps:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们将使用 `print_r()` 函数以可读的格式打印不同的形状。为此，我们将执行以下步骤：
- en: Let's start by creating a new file in your project directory and calling it
    `print_r.php`.
  id: totrans-189
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们从在你的项目目录中创建一个新文件并命名为 `print_r.php` 开始。
- en: 'Next, we are going to open our PHP script with the opening tag and define a
    `$shapes` variable with three different shapes:'
  id: totrans-190
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将使用开头标签打开我们的 PHP 脚本，并定义一个包含三个不同形状的 `$shapes` 变量：
- en: '[PRE44]'
  id: totrans-191
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'On the next line, let''s echo out the contents of `$values`:'
  id: totrans-192
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在下一行，让我们输出 `$values` 的内容：
- en: '[PRE45]'
  id: totrans-193
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Let''s go ahead and open the project directory in the Terminal and run it:'
  id: totrans-194
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们打开项目目录并在终端中运行它：
- en: '[PRE46]'
  id: totrans-195
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'You''ll see that all that is printed is the following:'
  id: totrans-196
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 你会看到打印出来的只有以下内容：
- en: '[PRE47]'
  id: totrans-197
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE47]'
- en: This is because `echo` isn't designed to show array contents. However, this
    is where `print_r()` now comes into play.
  id: totrans-198
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这是因为 `echo` 并未设计用于显示数组内容。然而，这正是 `print_r()` 发挥作用的地方。
- en: 'Let''s replace `echo` with `print_r`:'
  id: totrans-199
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们用 `print_r` 替换 `echo`：
- en: '[PRE48]'
  id: totrans-200
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'We''ll run the script using the following command:'
  id: totrans-201
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们将使用以下命令运行脚本：
- en: '[PRE49]'
  id: totrans-202
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Now we can see the values of the array as follows:'
  id: totrans-203
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 现在，我们可以这样看到数组的值：
- en: '![Figure 4.6: Printing the values of an array'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 4.6：打印数组的值'
- en: '](img/C14196_04_06.jpg)'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/C14196_04_06.jpg)'
- en: 'Figure 4.6: Printing the values of an array'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.6：打印数组的值
- en: A Varying Number of Parameters
  id: totrans-207
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 可变数量的参数
- en: 'Functions can accept a varying number of parameters. Take, for example, `printf`,
    which is used to print a string of text from a predefined formatted string, filling
    out placeholders with values:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 函数可以接受可变数量的参数。以 `printf` 为例，它用于从预定义的格式化字符串中打印文本字符串，并用值填充占位符：
- en: '[PRE50]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'This will print the following:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 这将打印以下内容：
- en: '[PRE51]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: While `$format` is a required parameter, the remaining parameters are optional
    and variable in number. The important takeaway here is that you can pass as many
    as you like.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然 `$format` 是必需的参数，但其余参数是可选的，并且数量可变。这里的重要收获是你可以传递任意多的参数。
- en: The number of parameters must match the number of placeholders in the string,
    but that is specific to `printf`. When allowing a varying number of parameters,
    it is up to the designer of the function to decide whether or not to validate
    the number of parameters against certain restrictions.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 参数的数量必须与字符串中的占位符数量相匹配，但这仅适用于 `printf`。当允许参数数量可变时，函数的设计者需要决定是否要验证参数数量是否符合某些限制。
- en: There is also the `sprintf` function, which acts almost the same way; however,
    instead of printing the resulting text, it returns it from the function so that
    you can use the output later.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，还有 `sprintf` 函数，它的工作方式几乎相同；然而，它不是打印结果文本，而是从函数中返回它，以便你可以稍后使用输出。
- en: 'You might have noticed that the placeholders are different: `%d` and `%s`.
    This can be used as a simple validation: `%d` expects a number, while `%s` accepts
    anything that can be cast to a string.'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经注意到占位符不同：`%d` 和 `%s`。这可以用作简单的验证：%d 期望一个数字，而 `%s` 接受任何可以转换为字符串的内容。
- en: Flag Parameters
  id: totrans-216
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 标志参数
- en: 'In earlier examples, we used the `sort()` function with just one parameter:
    the array we want to be sorted for us. The function accepts a second parameter.
    In this case, the second parameter is also defined as a flag, which means only
    values of certain predefined constants, called flags, are accepted. The flag determines
    the way in which `sort()` behaves. If you want to use multiple flags, then you
    can simply use the pipe (`|`) symbol between each flag.'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 在早期的示例中，我们使用 `sort()` 函数并只传递一个参数：我们希望排序的数组。该函数接受第二个参数。在这种情况下，第二个参数也被定义为标志，这意味着只接受某些预定义常数的值，称为标志。标志决定了
    `sort()` 的行为方式。如果您想使用多个标志，则可以在每个标志之间简单地使用管道 (`|`) 符号。
- en: 'Let''s now take a slightly different input array:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们使用一个稍微不同的输入数组：
- en: '[PRE52]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'The output is as follows:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE53]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: The array is now sorted alphabetically as expected. Without the flags, sorting
    would be case-sensitive and `orange` would come last, because it is lowercase.
    The same result can be achieved using `natcasesort($fruits)`. See the example
    in `array-use-sort-with-flags.php` on GitHub.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 数组现在按字母顺序排序，正如预期的那样。如果没有标志，排序将是大小写敏感的，`orange` 将排在最后，因为它是小写的。使用 `natcasesort($fruits)`
    也可以达到相同的结果。请参阅 GitHub 上的 `array-use-sort-with-flags.php` 示例。
- en: In general, it is a good idea, when using a function, to consult the documentation
    about extended possibilities by using extra arguments. Often, a function does
    not exactly do what you want but can be made to do it by passing extra arguments.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，在使用函数时，咨询有关使用额外参数的扩展功能的文档是一个好主意。通常，一个函数并不完全做你想要的事情，但可以通过传递额外的参数来实现。
- en: 'Exercise 4.3: Using Built-In Functions with Arrays'
  id: totrans-224
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习 4.3：使用数组内置函数
- en: 'In this exercise, we will see how the PHP built-in functions work with arrays:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们将看到 PHP 内置函数如何与数组一起工作：
- en: Create a file called `array-functions.php` in the `exercises` directory of `Chapter04`.
  id: totrans-226
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Type the opening tag and the statement that creates the array named `$signal`,
    which contains the different colors in a traffic signal:'
  id: totrans-227
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE54]'
  id: totrans-228
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'Display the array of integers in a human-readable format:'
  id: totrans-229
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE55]'
  id: totrans-230
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'Execute the script using the following command:'
  id: totrans-231
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE56]'
  id: totrans-232
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'The output is as follows:'
  id: totrans-233
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 4.7: Printing the array of traffic signal colors'
  id: totrans-234
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '](img/C14196_04_07.jpg)'
  id: totrans-235
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Figure 4.7: Printing the array of traffic signal colors'
  id: totrans-236
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Notice in the preceding output how the array elements are indexed with colors
    and the first element is at index `0` and the third element at index `2`. These
    are the default indices when you do not declare your own indices.
  id: totrans-237
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Use the `array_reverse` function to reverse the array:'
  id: totrans-238
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE57]'
  id: totrans-239
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE57]'
- en: The `array_reverse()` method will reverse the order of the array elements and
    return the result as a new array while leaving the original array unchanged.
  id: totrans-240
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Print the reversed array:'
  id: totrans-241
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE58]'
  id: totrans-242
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE58]'
- en: Execute the `php array-functions.php` command.
  id: totrans-243
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'The output looks like the following screenshot:'
  id: totrans-244
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 4.8: Printing the reverse array'
  id: totrans-245
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '](img/C14196_04_08.jpg)'
  id: totrans-246
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Figure 4.8: Printing the reverse array'
  id: totrans-247
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Notice how element `3` is now the first element at index `0` of the array and
    element `1` is the last. At index `2`, although the array is reversed, the indices
    stay at the same positions as in the original array.
  id: totrans-248
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Add the following code again to print the original array:'
  id: totrans-249
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE59]'
  id: totrans-250
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'The output is as follows:'
  id: totrans-251
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 4.9: Printing the array'
  id: totrans-252
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '](img/C14196_04_09.jpg)'
  id: totrans-253
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Figure 4.9: Printing the array'
  id: totrans-254
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: This is to demonstrate that the original array will not be changed by `array_reverse`.
  id: totrans-255
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Open a Terminal and go to the directory where you just typed the `array-functions.php`
    script. Run the script and hit *Enter*:'
  id: totrans-256
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE60]'
  id: totrans-257
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'Observe that three arrays are displayed. The output on the screen will look
    like the following screenshot when the array contains only three integers:'
  id: totrans-258
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 4.10: Printing the three arrays'
  id: totrans-259
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '](img/C14196_04_10.jpg)'
  id: totrans-260
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Figure 4.10: Printing the three arrays'
  id: totrans-261
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The first array displays your array with integers, the second is your array
    with integers in reverse order, and the third is the unchanged original array
    with the integers in regular order, as you entered them.
  id: totrans-262
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Change the statement that reverses the array to the following:'
  id: totrans-263
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE61]'
  id: totrans-264
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'What we did here has not always been possible in PHP, but it is possible today:
    we assign `true` to the `$preserve_keys` variable and, at the same time, we pass
    it as the second argument to `array_reverse`. The advantage of doing this is self-documenting
    the operations we are doing, and we can reuse the variable later if we need to.
    However, in general, this type of assignment can be easily overlooked and, if
    you do not need the variable later, it is probably better to just pass `true`.
    You might use this type of assignment depending on what you are building.'
  id: totrans-265
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Look carefully at the output when you run the script again:'
  id: totrans-266
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 4.11: Printing the three arrays again'
  id: totrans-267
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '](img/C14196_04_11.jpg)'
  id: totrans-268
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Figure 4.11: Printing the three arrays again'
  id: totrans-269
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 4.11：再次打印三个数组
- en: When you inspect the output, specifically the array in the middle, you will
    notice that the keys have been preserved in the reversed array. It is true that
    element `3` is now the first element in the array, but note that index `2` is
    now the first index as well. So, `$integers[2]` still contains the value of `3`
    and `$integers[0]` still holds the value of `1`.
  id: totrans-270
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 当你检查输出时，特别是中间的数组，你会注意到键已经被保留在反转后的数组中。确实，元素 `3` 现在是数组中的第一个元素，但请注意，索引 `2` 现在也是第一个索引。所以，`$integers[2]`
    仍然包含 `3` 的值，而 `$integers[0]` 仍然持有 `1` 的值。
- en: 'Now let''s declare another `$streets` array with the names of a few streets:'
  id: totrans-271
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在让我们声明另一个 `$streets` 数组，包含一些街道的名称：
- en: '[PRE62]'
  id: totrans-272
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'Now let''s sort the array with flags combined with the bitwise OR operator:'
  id: totrans-273
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在让我们使用与位或运算符结合的标志来对数组进行排序：
- en: '[PRE63]'
  id: totrans-274
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'The output is as follows:'
  id: totrans-275
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '![Figure 4.12: Printing the array in alphabetical order'
  id: totrans-276
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图 4.12：按字母顺序打印数组'
- en: '](img/C14196_04_12.jpg)'
  id: totrans-277
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![img/C14196_04_12.jpg]'
- en: 'Figure 4.12: Printing the array in alphabetical order'
  id: totrans-278
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 4.12：按字母顺序打印数组
- en: In this case, the `sort()` function sorts the string case-insensitively.
  id: totrans-279
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在这种情况下，`sort()` 函数不区分大小写地排序字符串。
- en: 'If we sort the array using the bitwise AND operator, we will see that the street
    names starting with uppercase letters move to the top of the array and rest of
    the street names print in alphabetical order:'
  id: totrans-280
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果我们使用位与运算符对数组进行排序，我们会看到以大写字母开头的街道名称移动到数组的顶部，其余的街道名称按字母顺序打印：
- en: '[PRE64]'
  id: totrans-281
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'The output is as follows:'
  id: totrans-282
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '![Figure 4.13: Printing the words that start with uppercase letters at the
    top of the array'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 4.13：打印数组顶部以大写字母开头的单词'
- en: '](img/C14196_04_13.jpg)'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: '![img/C14196_04_13.jpg]'
- en: 'Figure 4.13: Printing the words that start with uppercase letters at the top
    of the array'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.13：打印数组顶部以大写字母开头的单词
- en: In this exercise, you have seen one of the many powerful array manipulation
    functions of PHP at work. You learned that this function—`array_reverse` – returns
    a new array rather than modifying the original. You may deduce that the input
    argument, your array, is not passed by reference, because, otherwise, the original
    would have been changed by the reversion. You also learned that the second argument
    to this function – `boolean $preserve_keys` – if `true` does change the behavior
    of the function so that the elements stay at the same indices as before the reversion.
    You may deduce from this that the default value of the second argument is `false`.
    We then explored how to use the `sort` function to arrange the elements of an
    array in a specific order.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，你看到了 PHP 的许多强大的数组操作函数之一在工作。你了解到这个函数——`array_reverse`——返回一个新的数组而不是修改原始数组。你可以推断出输入参数，即你的数组，不是通过引用传递的，因为否则原始数组会被反转所改变。你还了解到这个函数的第二个参数——`boolean
    $preserve_keys`——如果为 `true` 会改变函数的行为，使得元素保持在反转前的相同索引位置。你可以从这个推断出第二个参数的默认值是 `false`。然后我们探讨了如何使用
    `sort` 函数以特定顺序排列数组的元素。
- en: Introduction to User-Defined Functions
  id: totrans-287
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 用户自定义函数简介
- en: A user-defined function is a function that either you or another user has written
    and is not built into PHP itself. Built-in functions are generally faster than
    user-defined functions that do the same thing, as they are already compiled from
    C. Always look for built-in functions before you try to write your own!
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 用户自定义函数是你或另一个用户编写的函数，不是 PHP 本身构建的。内置函数通常比执行相同操作的用户自定义函数更快，因为它们已经从 C 语言编译。在尝试编写自己的函数之前，总是先寻找内置函数！
- en: Naming Functions
  id: totrans-289
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 函数命名
- en: 'Naming things is difficult. Try to choose names for your functions that are
    descriptive but not overly long. Very long function names are unreadable. When
    you read the name, you should ideally be able to guess what the function does.
    The rules for naming identifiers in PHP apply here. Function names are case-insensitive;
    however, by convention, you do not call a function with casing that is different
    from how it was defined. Speaking of conventions, you are free to design the casing
    any way you like, but two flavors generally prevail: `snake_case()` or `camelCase()`.
    In all cases, do what your team agrees upon – consistency is far more important
    than any personal preference, no matter how strong. If you are free to choose
    your coding convention, then, by all means, stick to the PSR-1 standard as recommended
    by PHP-FIG ([https://packt.live/2IBLprS](https://packt.live/2IBLprS)). Although
    it refers to functions as methods (as in class methods), you may safely assume
    that this also applies to (global) functions, which this chapter is about. This
    means that if you are free to choose, you can choose `camelCase()` for functions.'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 命名事物是困难的。尽量为你的函数选择描述性但不过于冗长的名称。非常长的函数名称是不可读的。当你阅读名称时，理想情况下应该能够猜出该函数的功能。PHP 中命名标识符的规则也适用于此处。函数名称不区分大小写；然而，按照惯例，你不会用与定义时不同的大小写来调用函数。说到惯例，你可以自由地以你喜欢的任何方式设计大小写，但通常有两种风格占主导地位：`snake_case()`
    或 `camelCase()`。在所有情况下，做你团队同意的事情——一致性远比任何个人偏好都重要，无论这种偏好有多强烈。如果你可以自由选择编码规范，那么，请务必遵守
    PHP-FIG 推荐的 PSR-1 标准（[https://packt.live/2IBLprS](https://packt.live/2IBLprS)）。尽管它指的是函数作为方法（如类方法），但你可以安全地假设这也适用于（全局）函数，本章就是关于这个的。这意味着如果你可以自由选择，你可以为函数选择
    `camelCase()`。
- en: Do not redeclare a built-in function (that is, do not write a function with
    the same name as a built-in function in the root namespace). Instead, give your
    own function a unique name, or put it in its own namespace. The best practice
    is to never use the name of an existing function for your own function, not even
    within your own namespace, to avoid confusion.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 不要重新声明内置函数（即不要在根命名空间中编写与内置函数同名的函数）。相反，给你的函数一个独特的名称，或者将其放入它自己的命名空间。最佳实践是永远不要使用现有函数的名称来命名你的函数，即使在你的命名空间内也不要，以避免混淆。
- en: Documenting Your Functions
  id: totrans-292
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 函数文档化
- en: 'You may add a comment above a function, which is called a DocBlock. This contains
    annotations, prefixed with the `@` symbol. It also contains a description of what
    the function does. Ideally, it also describes why the function is there:'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在函数上方添加注释，这被称为 DocBlock。它包含以 `@` 符号作为前缀的注释。它还包含对函数功能的描述。理想情况下，它还描述了为什么需要这个函数：
- en: '[PRE65]'
  id: totrans-294
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: Namespaced Functions
  id: totrans-295
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 命名空间函数
- en: '`Date`. If different libraries do this, you cannot use both libraries at the
    same time, because the second time a `Date` class is loaded, PHP will complain
    that you cannot redeclare the `Date` class, since it has already been loaded.'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: '`Date`。如果不同的库这样做，你不能同时使用这两个库，因为当第二次加载 `Date` 类时，PHP 会抱怨你不能重新声明 `Date` 类，因为它已经被加载了。'
- en: To solve this problem, we use namespaces. If two different vendors of libraries
    use their vendor name for the namespace and create their `Date` class within that
    namespace, the names are far less likely to clash.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决这个问题，我们使用命名空间。如果两个不同的库供应商使用他们的供应商名称作为命名空间，并在该命名空间内创建他们的 `Date` 类，那么名称冲突的可能性就小得多。
- en: 'You can think of a namespace as some kind of prefix. Say that `You` and `Me`
    are both vendors and we both want to introduce a `Date` class. Instead of naming
    the classes `MeDate` and `YouDate`, we create them in files that live in a `Me`
    directory and in a `You` directory. The class file will simply be called `Date.php`
    for both vendors. Inside your `Date.php` file, you will write the namespace as
    the very first statement (after the strict types declaration, if any):'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以把命名空间想象成某种前缀。比如说 `You` 和 `Me` 都是供应商，我们都想引入一个 `Date` 类。我们不会将类命名为 `MeDate`
    和 `YouDate`，而是将它们创建在 `Me` 目录和 `You` 目录中的文件里。对于两个供应商，类文件都简单地称为 `Date.php`。在你的 `Date.php`
    文件中，你将命名空间作为第一条语句（如果有严格类型声明，则在声明之后）写入：
- en: '[PRE66]'
  id: totrans-299
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'We will write a `Date.php` file that starts as follows:'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将编写一个 `Date.php` 文件，其起始部分如下：
- en: '[PRE67]'
  id: totrans-301
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: Now, because the classes live in their own namespace, they have a so-called
    `You\Date` and `Me\Date`. Notice that the names are different. You will learn
    more about namespaces in *Chapter 5*, *Object-Oriented Programming*, because they
    matter to objects more than functions.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，因为类生活在它们自己的命名空间中，它们有所谓的 `You\Date` 和 `Me\Date`。注意名称是不同的。你将在 *第5章*，*面向对象编程*
    中了解更多关于命名空间的内容，因为它们对对象的影响比函数更大。
- en: 'Namespaced functions are rare, but they are possible. To write a function in
    a namespace, declare the namespace at the top of the file where you define the
    function:'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 命名空间函数很少见，但它们是可能的。要在命名空间中编写函数，请在定义函数的文件顶部声明命名空间：
- en: '[PRE68]'
  id: totrans-304
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'And then call it in another file in the root namespace (no namespace):'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 然后在根命名空间（没有命名空间）的另一个文件中调用它：
- en: '[PRE69]'
  id: totrans-306
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'We could import the `Chapter04` namespace near the top of the unit test with
    a `use` statement:'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在单元测试的顶部使用 `use` 语句导入 `Chapter04` 命名空间：
- en: '[PRE70]'
  id: totrans-308
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: Pure Functions
  id: totrans-309
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 纯函数
- en: Pure functions do not have side effects. Not-so-pure functions will have side
    effects. So, what is a side effect? Well, when a function has a side effect, it
    changes something that exists outside of the scope of a function.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 纯函数没有副作用。不那么纯的函数会有副作用。那么，什么是副作用呢？嗯，当一个函数有副作用时，它会改变存在于函数作用域之外的东西。
- en: Scope
  id: totrans-311
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 作用域
- en: You can think of scope as a "fence" within which a variable or function can
    operate. Within the function scope are its input, its output, and everything that
    is made available inside the function body. Functions can pull things out of the
    global scope into their own scope and alter them, thus causing side effects. To
    keep things simple, it is best when functions do not have side effects. It makes
    fault finding and unit testing easier when functions do not try to alter the environment
    in which they live, but, instead, just focus on their own responsibility.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以把作用域想象成一个“栅栏”，在这个栅栏内，变量或函数可以操作。在函数作用域内包括它的输入、输出以及函数体内提供的所有内容。函数可以将全局作用域中的内容拉入它们自己的作用域并修改它们，从而产生副作用。为了保持简单，当函数没有副作用时最好。当函数不试图改变它们所在的环境，而是专注于它们自己的职责时，查找错误和单元测试会更容易。
- en: Variables declared outside the function live in the global scope and are available
    within the function. Variables declared within the function body are not available
    outside the function scope, unless extra work is done.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 在函数外部声明的变量生活在全局作用域中，并在函数内部可用。在函数体内声明的变量在函数作用域之外不可用，除非做了额外的工作。
- en: 'In the following examples, two ways are used to demonstrate how variables from
    the global scope can be used inside a function:'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下示例中，使用了两种方法来演示如何使用全局作用域中的变量在函数内部：
- en: '[PRE71]'
  id: totrans-315
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'The output is as follows:'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE72]'
  id: totrans-317
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: After the function was called twice, `$count` will have the value of `2`, which
    is essentially a count of how many times the function was called during a single
    script run. After the next run, the `$count` variable will be `2` again, because
    the value is not preserved between script runs and also because it is initialized
    at `0` each time the script runs. Regardless, values are not preserved between
    script runs, unless you persist them explicitly in a file or some form of cache
    or some other form of persistence layer.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 函数被调用两次之后，`$count` 将具有 `2` 的值，这实际上是函数在单个脚本运行期间被调用的次数的计数。在下次运行之后，`$count` 变量将再次是
    `2`，因为值在脚本运行之间不会被保留，也因为每次脚本运行时都会将其初始化为 `0`。无论如何，值在脚本运行之间不会保留，除非你明确地在文件或某种形式的缓存或其他持久化层中保留它们。
- en: In general, it is better for functions not to have side effects and not to meddle
    with global scope.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，函数没有副作用并且不干涉全局作用域会更好。
- en: The $GLOBALS Superglobal Array
  id: totrans-320
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: $GLOBALS 超全局数组
- en: Global variables are always available inside the special `$GLOBALS` superglobal
    array. So, instead of using the `global` keyword, we could have incremented `$GLOBALS['count'];`
    in the previous example.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 全局变量始终在特殊的 `$GLOBALS` 超全局数组中可用。所以，我们可以在前面的例子中用 `$GLOBALS['count'];` 替代 `global`
    关键字。
- en: 'Exercise 4.4: Using the $GLOBALS array'
  id: totrans-322
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习 4.4：使用 $GLOBALS 数组
- en: 'In this exercise, you will change the function in `count-me-with-GLOBALS.php`
    so that it no longer uses the `global` keyword but uses the `$GLOBALS` superglobal
    array instead:'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，你将修改 `count-me-with-GLOBALS.php` 中的函数，使其不再使用 `global` 关键字，而是使用 `$GLOBALS`
    超全局数组：
- en: 'Take another look at the function used in the previous example:'
  id: totrans-324
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 再看看前面例子中使用的函数：
- en: '[PRE73]'
  id: totrans-325
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'Remove the contents of the function body so that your function looks like this:'
  id: totrans-326
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将函数体的内容删除，使你的函数看起来像这样：
- en: '[PRE74]'
  id: totrans-327
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE74]'
- en: The function is now empty and does nothing.
  id: totrans-328
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 函数现在是空的，什么也不做。
- en: 'Add a new statement to the empty function body that increments `count` in the
    `$GLOBALS` array:'
  id: totrans-329
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在空函数体中添加一个新语句，该语句在`$GLOBALS`数组中增加`count`：
- en: '[PRE75]'
  id: totrans-330
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE75]'
- en: The function now does exactly the same as before, but with less code.
  id: totrans-331
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 函数现在与之前完全一样，但代码更少。
- en: 'Call the `countMe()` function twice. The script should now look like the script
    in `count-me-with-GLOBALS.php`:'
  id: totrans-332
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 调用`countMe()`函数两次。现在脚本应该看起来像`count-me-with-GLOBALS.php`中的脚本：
- en: '[PRE76]'
  id: totrans-333
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'The output looks like the following screenshot when you run the script. The
    output is both a newline and a value of `$count` function:'
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 当你运行脚本时，输出看起来像下面的屏幕截图。输出包括一个换行符和`$count`函数的值：
- en: '![Figure 4.14: Printing the count'
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: '![图4.14：打印计数'
- en: '](img/C14196_04_14.jpg)'
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/C14196_04_14.jpg)'
- en: 'Figure 4.14: Printing the count'
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.14：打印计数
- en: The Single Responsibility Principle
  id: totrans-338
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 单一职责原则
- en: A function is easier to use, more reliable when reused, and easier to test when
    it does only one thing – that is, when it has a single responsibility. When you
    need another task to be performed, do not add it to your existing function; just
    write another one instead.
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个函数只做一件事时——也就是说，当它只有一个职责时——它更容易使用，在重用时更可靠，也更容易测试。当你需要执行另一个任务时，不要将其添加到现有的函数中；而是写一个新的函数。
- en: 'The syntax of a function is as follows:'
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 函数的语法如下：
- en: '[PRE77]'
  id: totrans-341
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: Don't be put off by this apparently complex syntax definition. Functions are
    really easy to write, as the following examples in this chapter will show you.
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 不要被这个看似复杂的语法定义吓倒。函数实际上很容易编写，正如本章中的以下示例将向你展示的。
- en: However, let's now spend some time trying to break this syntax apart.
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，现在让我们花些时间尝试分解这个语法。
- en: The function Keyword
  id: totrans-344
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 函数关键字
- en: The `function` keyword tells the PHP parser that what comes next is a function.
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: '`function`关键字告诉PHP解析器接下来的是函数。'
- en: Identifier
  id: totrans-346
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 标识符
- en: 'The identifier represents the name of the function. Here, the general rules
    for identifiers in PHP will apply. The most important ones to remember are that
    it cannot start with a number and it cannot contain spaces. It can contain Unicode
    characters, although this is relatively uncommon. It is, however, quite common
    to define special, frequently used functions with underscores:'
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 标识符代表函数的名称。在这里，PHP中标识符的一般规则将适用。需要记住的最重要的一点是，它不能以数字开头，也不能包含空格。它可以包含Unicode字符，尽管这相对较少见。然而，定义带有下划线的特殊、常用函数是很常见的：
- en: '[PRE78]'
  id: totrans-348
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: This function is used to translate the text in WordPress templates. The idea
    behind it is that you will spot immediately that this function is something special
    and you won't be tempted to write a function with the same name yourself. It is
    also very easy to type, which is handy for frequently used functions. As you can
    see, it takes a required parameter, `$text`, to be translated. It also takes an
    optional `$domain`, in which the translation is defined, which is the `default`
    domain by default (a `text` domain in translations serves to separate different
    fields of interest that might have the same word for different things, so that
    these words can be translated differently if the other language has different
    words depending on the context). `__` function is what we call a wrapper for the
    translate function. It passes its arguments on to the `translate` function and
    returns the return value of the `translate` function. It is faster to type and
    it takes up less space in templates, making them more readable.
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数用于在WordPress模板中翻译文本。其背后的想法是，你会立即发现这个函数是特殊的，你不会想自己写一个同名函数。它也非常容易输入，这对于常用函数来说很方便。正如你所看到的，它需要一个必需的参数`$text`来翻译。它还接受一个可选的`$domain`参数，其中定义了翻译，默认情况下是`default`域（在翻译中，`text`域用于区分可能对不同事物使用相同单词的不同领域，以便如果其他语言根据上下文有不同的单词，这些单词可以不同地翻译）。`__`函数是我们所说的翻译函数的包装器。它将其参数传递给`translate`函数，并返回`translate`函数的返回值。它输入更快，在模板中占用的空间更少，使模板更易于阅读。
- en: Type Hints
  id: totrans-350
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 类型提示
- en: 'In the function declaration, type hinting is used to specify the expected data
    type of an argument. Type hints for objects have existed since PHP 5.0 and for
    arrays since PHP 5.1\. Type hints for scalars have existed since PHP 7.0\. Nullable
    type hints have existed since PHP 7.1\. A type hint for `object` has existed since
    PHP 7.2\. Consider the following example:'
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  id: totrans-352
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: In the preceding example, there are three type hints. The first one hints that
    `$maxCredits` should be an integer. The second one hints that `$period` should
    be a string, and the third one hints that `$waitDays` must be an integer.
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
- en: If a type hint is prefixed with a question mark, as in `?int`, this indicates
    that the argument must either be the hinted type or `null`. In this case, the
    hinted type is `integer`. This has been possible since PHP 7.1.
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
- en: The Spread Operator (…) with Type Hints
  id: totrans-355
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The spread operator (`…`) is optional and indicates that the parameter has to
    be an array that only contains elements of the hinted type. Although it has existed
    since PHP 5.6, it is a rarely used yet very powerful and useful feature that makes
    your code more robust and reliable, with less code. There is no longer a need
    to check every element of a homogeneous array. When you define a parameter with
    such a type hint, you also need to call the function with the parameter prefixed
    with the spread operator.
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
- en: The following is an example of a fictional function that I made up to demonstrate
    the use of the spread operator. The `processDocuments` function transforms XML
    documents using **eXtensible Stylesheet Language Transformations** (**XSLT**).
    While this is really interesting when you need to transform documents, it doesn't
    really matter for the demonstration of the spread operator.
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
- en: The spread operator is the three dots before `$xmlDocuments` in the function
    signature. It means that `$xmlDocuments` must be an array that contains only objects
    of the `DomDocument` hinted type. A `DomDocument` hinted type is an object that
    can load and hold XML. It can be processed by an object of the `XsltProcessor`
    class, to transform the document into another document. `XsltProcessor` in PHP
    is very powerful and very performant. You can even use PHP functions inside your
    XSL style sheets. This nifty feature should be used with caution, however, because
    it will render your XSL style sheets useless to other processors as they do not
    know PHP.
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
- en: 'The return type of the function is `Generator`. This is caused by the `yield`
    statement inside the `foreach` loop. The `yield` statement causes the function
    to return each value (a document, in our case) as soon as it becomes available.
    This means it is efficient with memory: it does not keep the objects in memory
    in an array to return them all at once, but instead returns them one by one immediately
    after creation. This makes a generator very performant on large sets while also
    using fewer memory resources:'
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  id: totrans-360
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: The preceding function may appear pretty confusing, but it is fairly simple.
    Let's start with the usage of the spread operator; this is used to signify that
    the parameter will be required as an array. Additionally, the parameters are type
    hinted as `DomDocument` objects, meaning that the parameters will be an array
    of `DomDocument` objects. Moving onto the function, we define a new instance of
    `XsltProcessor` and load in a style sheet for the processor. Note that this is
    a conceptual example and more information on `XsltProcessor` and style sheets
    can be found in the PHP documentation at [https://packt.live/2OxT91A](https://packt.live/2OxT91A).
    Finally, we use a `foreach` loop to iterate through the array of documents and
    yield the results of the process method on each document. As document processing
    can be memory intensive, the use case for a generator is apparent if you can imagine
    passing a large array of documents to this function.
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
- en: 'To call this function, use the following code:'
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  id: totrans-363
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: Parameters in User-Defined Functions
  id: totrans-364
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'When defining a function, you are allowed to define parameters for it. When
    you are defining a parameter, consider whether it is expected to always be of
    the same type or whether you can force the developer using your code to always
    pass the same type. For example, when integer values are expected, a type hint
    of `int` is a good idea. Even if a developer passes `2`, which is a string, they
    can easily be educated to cast this to an integer before passing it to your function,
    using `(int) "2"`. More realistically, `2` would be stored in a variable. So,
    now you have a type hint:'
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  id: totrans-366
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: 'Next, you should come up with a good name for your parameter. Ideally, it should
    be descriptive, but not overly long. When you expect a `DomDocument` object, `$domDocument`,
    `$xmlDocument`, or simply `$document` can be fine names, while `$doc` might be
    a little too short and confusing to some people and just `$d` would be just bad:'
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE83]'
  id: totrans-368
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: 'Does a default value make sense for `$offset`? In most cases, it will be `0`,
    because we usually start a process at the beginning of something. So, `0` would
    make a great default value, in this case:'
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE84]'
  id: totrans-370
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: Now we have a parameter with a type hint of `int` and a default of `0`. The
    parameter is now optional and should be defined after the parameters that are
    not optional.
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
- en: If a parameter cannot be expected to always be of the same type, processing
    it in your function may be harder, because you might have to check its type in
    order to decide how you should treat it. This makes unit testing your function
    harder and it complicates fault finding if things go wrong, since your code will
    have several paths of execution, depending on the type of input.
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
- en: When a parameter is prefixed with `&`, it means that if a scalar is passed,
    it will be passed by reference, instead of as a copy or literal. Objects are always
    passed by reference and, therefore, using `&` on an object parameter is redundant
    and does not change the behavior of the function.
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
- en: Return Types in User-Defined Functions
  id: totrans-374
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Return types are written as a colon followed by the type name. Return types
    were introduced in PHP 7\. They make your code more robust because you are more
    explicit about what you expect from your function, and this can be checked at
    compile time rather than failing at runtime when something goes wrong, possibly
    in production. If you use an IDE, it will warn you when a return type does not
    match what you actually return or expect from the function. This means you can
    correct the error before it hits your users.
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
- en: 'In the preceding example, the `processDocuments` function has a return type
    of `Generator`. A `Generator` type generates values and makes them available as
    soon as possible. This can be very performant: you don''t have to wait for all
    the values to become available before processing them further. You can start with
    further processing as soon as the first value comes out of the `Generator` type.
    The `Generator` type churns out a value each time the `yield` language construct
    is used.'
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
- en: '`yield` was introduced in PHP 5\. At the time of writing, we are at PHP 7.3
    and there are still many developers who have never used `yield` or do not even
    know what it does. When you are processing arrays or records from a database,
    for example, and you need extreme performance, consider whether you have a use
    case for a `Generator` type.'
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
- en: You can use `void` as the return type to indicate that nothing is returned from
    the function.
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
- en: Signature
  id: totrans-379
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The following part of the function declaration is called the **signature**:'
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE85]'
  id: totrans-381
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: So, the signature of a function defines its parameters and the return type.
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
- en: Returning a Value
  id: totrans-383
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A function may return a value or not. When the function does not return anything,
    not even `null`, the return type can be void as of PHP 7.1\. Values are returned
    by typing `return` followed by what you want to return. This can be any valid
    expression or just a single variable or literal:'
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE86]'
  id: totrans-385
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: Parameters and Arguments
  id: totrans-386
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Functions accept arguments. An argument is a literal, variable, object, or even
    callable that you pass into a function for the function to act upon. If a parameter
    is defined at the position of the argument, you can use the argument inside your
    function by using the name of the parameter. The number of parameters may be variable
    or fixed. *PHP allows you to pass more parameters than the function signature
    defines*. If you want dynamic parameters, PHP has two built-in functions that
    make this possible; you can get the number of parameters with `func_num_args()`
    and the parameters themselves with `func_get_args()`. To show these functions
    in action, we will take a look at an example.
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s an example of using `func_num_args()`. In this example, we define a
    method that will have no predefined parameters/arguments. But using the built-in
    `func_num_args` function, we will be able to count how many parameters/arguments
    are passed:'
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE87]'
  id: totrans-389
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: 'The output is as follows:'
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE88]'
  id: totrans-391
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: 'Now that we can count the number of arguments, we can combine that function
    with `func_get_args()` to loop through and see what was passed. Here''s an example
    of using `func_get_args()`:'
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE89]'
  id: totrans-393
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: 'The output is as follows:'
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE90]'
  id: totrans-395
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: Optional Parameters
  id: totrans-396
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Parameters to functions are optional when they have default values defined
    for them:'
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE91]'
  id: totrans-398
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: This function defines a parameter, `$name`, with a default value of `John`.
    This means that when calling the function, you do not need to provide the `$name`
    parameter. We say that the `$name` parameter is optional. If you do not provide
    a `$name` parameter, `John` will be passed anyway for the `$name` parameter. Optional
    parameters should be defined at the very end in the function signature, because,
    otherwise, if any required parameters come after the optional ones, you would
    still have to provide the optional parameters when calling the function.
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
- en: The example is in `function-with-default-value.php`. The various usages are
    documented in the `TestSayHello.php` unit test.
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
- en: Parameters Passed by Reference to Our Function
  id: totrans-401
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Remember the `countMe` function? It used a global variable named `$count` to
    keep track of how many times the function was called. This could also have been
    accomplished by passing the `$count` variable by reference, which is also a slightly
    better practice than polluting the global scope from within your function:'
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE92]'
  id: totrans-403
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: 'Use it further down in the same script, as follows:'
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE93]'
  id: totrans-405
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: Please note that calling methods in the same script as they are defined in is
    perfect for exercises and playing with code and also for simple scripts, but doing
    this is actually a violation of PSR-1\. This is a coding convention that states
    that files either define functions (not causing side effects) or use them (causing
    side effects).
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
- en: Default Values for Parameters
  id: totrans-407
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the following example, we are demonstrating the use of default values. By
    defining a default value, you give the developer using the function the ability
    to use the function as is without having to pass their own value.
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider the following example:'
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE94]'
  id: totrans-410
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: Between the parentheses is the function signature, which consists of a single
    parameter, `$systemTempDirectory`, with a type hint of `string` and a default
    value of `/tmp`. This means that if you pass a directory with your function call,
    it must be a string. If you do not pass an argument, the default value will be
    used.
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 4.5: Writing a Function that Adds Two Numbers'
  id: totrans-412
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now that you''ve read through some of the theory behind writing your own functions,
    let''s make a start on actually writing some of our own. In this exercise, we
    will create a simple function that adds two numbers and prints its sum:'
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
- en: Find the `add.php` file in `Chapter04/exercises/`.
  id: totrans-414
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Start typing the following comment in the file and type the function template:'
  id: totrans-415
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE95]'
  id: totrans-416
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE95]'
- en: You start with the `function` keyword; then the name of the function, `add`;
    the opening brace; the `$param1` and `$param2` parameters; the closing brace;
    the colon to announce the return type; the return type, `string`; and, finally,
    the function body, `{}`.
  id: totrans-417
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Inside the function body, type a check to see whether the parameters are numeric
    values by using `is_numeric()`. This built-in function returns `true` if its argument
    represents a numeric value, even when its type is `string`. So, it will return
    `true` for `23` and `0.145` and `10E6`, for example. The latter is a scientific
    notation of 1,000,000:'
  id: totrans-418
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE96]'
  id: totrans-419
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE96]'
- en: We throw an exception when the value is not numeric and cannot be added. Don't
    worry about exceptions now; they will be explained in the next chapter.
  id: totrans-420
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Now that you can be sure that both values are numeric and can be added without
    unexpected results, it is time to actually add them. Continue typing in the function
    body:'
  id: totrans-421
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE97]'
  id: totrans-422
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE97]'
- en: 'Now it is time to compose the requested message. On the next line, type the
    following:'
  id: totrans-423
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE98]'
  id: totrans-424
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE98]'
- en: What you see in action here is called `$param1`, `$param2`, and `$sum` will
    be expanded into the string sentence. They will also be automatically cast to
    a string.
  id: totrans-425
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'String interpolation, although really fast, is still a relatively costly operation
    for the PHP parser. If you need to maximize performance for a use case where every
    nanosecond counts, then it would be better for you to use *string concatenation*
    because it is faster. Here is the same line written using string concatenation:'
  id: totrans-426
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE99]'
  id: totrans-427
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE99]'
- en: The dot (`.`) is the string concatenation operator. It glues two strings together.
    Other types of values are cast to strings automatically before the concatenation
    happens.
  id: totrans-428
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Now you can write the following after your function:'
  id: totrans-429
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE100]'
  id: totrans-430
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE100]'
- en: 'Add a newline for clarity of the output:'
  id: totrans-431
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE101]'
  id: totrans-432
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE101]'
- en: 'Run the script from the `exercises` directory:'
  id: totrans-433
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE102]'
  id: totrans-434
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE102]'
- en: 'The output is as follows:'
  id: totrans-435
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 4.15: Printing the sum'
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
- en: '](img/C14196_04_15.jpg)'
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 4.15: Printing the sum'
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
- en: In this exercise, you have learned how to validate and process the arguments
    to your function and how to format and return some output. You have also learned
    how to perform some very simple math with PHP.
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
- en: Variable Functions
  id: totrans-440
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'If you store a function name in a variable, you can call this variable as a
    function. Here''s an example:'
  id: totrans-441
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE103]'
  id: totrans-442
  prefs: []
  type: TYPE_PRE
  zh: '[PRE103]'
- en: This is not limited to built-in functions. In fact, you can do the same thing
    with your own functions.
  id: totrans-443
  prefs: []
  type: TYPE_NORMAL
- en: Anonymous Functions
  id: totrans-444
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'These are functions without identifiers (refer to the following syntax). They
    can be passed into any function that accepts a callable as input. Consider the
    following example:'
  id: totrans-445
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE104]'
  id: totrans-446
  prefs: []
  type: TYPE_PRE
  zh: '[PRE104]'
- en: The preceding is an anonymous function, also called a closure. It does not have
    a name, so it cannot be called by its name, but it can be passed into another
    function that does accept a callable as input.
  id: totrans-447
  prefs: []
  type: TYPE_NORMAL
- en: 'If you want to call the anonymous function, there are two ways to achieve this:'
  id: totrans-448
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE105]'
  id: totrans-449
  prefs: []
  type: TYPE_PRE
  zh: '[PRE105]'
- en: In the preceding example, the function is created and called immediately with
    the `2.3` argument. The output that is returned will be `1`, because `2.3` is
    greater than `0`. Then `echo` prints the output. In this setup, the anonymous
    function can be called only once – there is no reference to it that would allow
    you to call it again.
  id: totrans-450
  prefs: []
  type: TYPE_NORMAL
- en: 'In the next example, the function will be stored in a variable named `$callable`.
    You may name the variable whatever you like, as long as you stick to the rules
    for naming variables in PHP:'
  id: totrans-451
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE106]'
  id: totrans-452
  prefs: []
  type: TYPE_PRE
  zh: '[PRE106]'
- en: Using a Variable from Outside of Scope Inside an Anonymous Function
  id: totrans-453
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As stated previously in this chapter, you may need to use a variable that was
    defined outside of the scope of the function you are defining. In the following
    exercise, you will see an example of how we can make use of the `use` keyword
    to pass a variable to the anonymous function.
  id: totrans-454
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 4.6: Working with Anonymous Functions'
  id: totrans-455
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this exercise, we will declare an anonymous function and examine how it
    works:'
  id: totrans-456
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new file named `callable.php`. Add your opening PHP tag as follows:'
  id: totrans-457
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE107]'
  id: totrans-458
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE107]'
- en: 'Then, define the initial variable that you want to use:'
  id: totrans-459
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE108]'
  id: totrans-460
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE108]'
- en: 'Now define your callable function and pass your `$a` variable to it:'
  id: totrans-461
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE109]'
  id: totrans-462
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE109]'
- en: 'On the next line, let''s assign a new value to `$a`:'
  id: totrans-463
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE110]'
  id: totrans-464
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE110]'
- en: 'To see what the current value of `$a` is, we will call `$callable` and print
    it to the screen:'
  id: totrans-465
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE111]'
  id: totrans-466
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE111]'
- en: 'Lastly, add a new line for readability:'
  id: totrans-467
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE112]'
  id: totrans-468
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE112]'
- en: 'We can now run this script in the command line using the following command:'
  id: totrans-469
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE113]'
  id: totrans-470
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE113]'
- en: 'The output is as follows:'
  id: totrans-471
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE114]'
  id: totrans-472
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE114]'
- en: So, what's happening here? First, we declare an anonymous function and store
    it in `$callable`. We say it should use `$a` by using the `use` keyword. Then,
    we change the value of `$a` to `different`, call our `$callable` function, and
    then `echo` the result. The result is `15`, which is the initial value of `$a`.
    The reason for this is that when using `use` to import `$a` into the scope of
    the function, `$a` will be used exactly as it was at the time of function creation.
  id: totrans-473
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Now what happens when we use `$a` as a reference? Let''s take a look:'
  id: totrans-474
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE115]'
  id: totrans-475
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE115]'
- en: Note that we prefixed `$a` with `&` this time. Now the output will be '`different`'.
  id: totrans-476
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Since objects are always passed by reference, this should also be true for objects,
    but that is something that will be covered in another chapter.
  id: totrans-477
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 4.7: Creating Variable Functions'
  id: totrans-478
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this exercise, we will create variable functions and examine how they work
    in PHP:'
  id: totrans-479
  prefs: []
  type: TYPE_NORMAL
- en: 'Open a file and name it `variable-hello.php`. Start your script with the opening
    PHP tag and set the strict type to `1`:'
  id: totrans-480
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE116]'
  id: totrans-481
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE116]'
- en: 'Declare a variable to store the value of  the function as follows:'
  id: totrans-482
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE117]'
  id: totrans-483
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE117]'
- en: That's all you need and even a bit more, because you have added a `string` type
    hint and a `void` return type, which are both optional. They are good practice,
    so make a habit of using them. Note that the closure does not return output. Instead,
    it prints the greeting directly to `stdOut`.
  id: totrans-484
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Now continue typing in your `variable-hello.php` script:'
  id: totrans-485
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE118]'
  id: totrans-486
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE118]'
- en: 'Add a newline:'
  id: totrans-487
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE119]'
  id: totrans-488
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE119]'
- en: 'Verify that the output on the Terminal is `Hello Susan`:'
  id: totrans-489
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 4.16: Printing the output'
  id: totrans-490
  prefs: []
  type: TYPE_NORMAL
- en: '](img/C14196_04_16.jpg)'
  id: totrans-491
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 4.16: Printing the output'
  id: totrans-492
  prefs: []
  type: TYPE_NORMAL
- en: In this exercise, you have learned how to use string concatenation together
    with a function argument and how to print output directly from a function. Although
    this is a bad practice in many cases, it might be useful in other scenarios.
  id: totrans-493
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 4.8: Playing with Functions'
  id: totrans-494
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this exercise, we will use a couple more predefined functions to learn about
    processing data and writing our processors so that they are reusable. The goal
    of this exercise is to take an array of directors and their movies and sort them
    by the director''s name. We then want to process that array and print out the
    director''s name where the first letter of the first name is in uppercase and
    the last name is all in uppercase. Additionally, for the movies, we want to capitalize
    each title, wrap them in double quotes, and separate them using commas. We will
    build two functions that will handle the processing of the director''s name and
    another function for movies. We will be making use of three new built-in functions
    that we have yet to discuss: `ksort`, `explode`, and `implode`. To learn more
    about these functions, please review the documentation on [https://packt.live/2OxT91A](https://packt.live/2OxT91A):'
  id: totrans-495
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we are going to create a new file called `activity-functions.php` and
    start our script with the opening PHP tag:'
  id: totrans-496
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE120]'
  id: totrans-497
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE120]'
- en: 'Then, we will go ahead and define an array that will hold the director''s name
    as a key and an array of their movies for the value:'
  id: totrans-498
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE121]'
  id: totrans-499
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE121]'
- en: 'Now we will write our first function to process our director''s name. Remember,
    we want the first name to have a capitalized first letter and the last name will
    be fully capitalized:'
  id: totrans-500
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE122]'
  id: totrans-501
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE122]'
- en: 'Next, we will write a function to process our movie strings. Note that we want
    to wrap the uppercase version of each movie name and separate them with commas:'
  id: totrans-502
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE123]'
  id: totrans-503
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE123]'
- en: 'Finally, we can sort our array via the array keys, and loop through and process
    the array:'
  id: totrans-504
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE124]'
  id: totrans-505
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE124]'
- en: 'We can now run this script in the Terminal:'
  id: totrans-506
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE125]'
  id: totrans-507
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE125]'
- en: 'You should see an output like the following:'
  id: totrans-508
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE126]'
  id: totrans-509
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE126]'
- en: Note
  id: totrans-510
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The third part of `Felix Gary Gray` is truncated in the output. Can you refactor
    the code to fix this bug?
  id: totrans-511
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Activity 4.1: Creating a Calculator'
  id: totrans-512
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You are working on a calculator-based web app. You are given all of the user
    interface code but are instructed to build the function that will actually do
    the calculations. You are instructed to make a single function that is reusable
    for all the calculations that are needed within the app.
  id: totrans-513
  prefs: []
  type: TYPE_NORMAL
- en: 'The following steps will help you to complete the activity:'
  id: totrans-514
  prefs: []
  type: TYPE_NORMAL
- en: Create a function that will calculate and return the factorial of the input
    number.
  id: totrans-515
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a function that will return the sum of the input numbers (a varying number
    of parameters).
  id: totrans-516
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a function that will evaluate the `$number` input, which has to be an
    integer and will return whether the number is a prime number or not. The return
    type of this function is a Boolean (`bool`).
  id: totrans-517
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a base `performOperation` function that will handle the predefined mathematical
    operations. The first parameter of the `performOperation` function must be a string,
    either '`factorial`', '`sum`', or '`prime`'. The remaining arguments are passed
    to the mathematical function being called as arguments.
  id: totrans-518
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Note
  id: totrans-519
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: A factorial is the product of an integer and all of the integers below it.
  id: totrans-520
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'The output should look similar to the following. The output values will depend
    on the numbers that you input:'
  id: totrans-521
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.17: Expected output'
  id: totrans-522
  prefs: []
  type: TYPE_NORMAL
- en: '](img/C14196_04_17.jpg)'
  id: totrans-523
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 4.17: Expected output'
  id: totrans-524
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-525
  prefs: []
  type: TYPE_NORMAL
- en: The solution for this activity can be found on page 511.
  id: totrans-526
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-527
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, you learned how you can use functions that are built into
    PHP to accomplish many tasks that would otherwise require you to write a lot of
    code to do the same thing much less quickly. You also learned various ways to
    write your own functions: with and without parameters, using default values or
    not, or even with varying amounts of parameters. You gained an understanding of
    functions that are pure and do not meddle with global scope versus functions that
    do have side effects, either because they pull variables from the global scope
    or receive parameters by reference and change them. You learned that you can call
    functions by their name or as callables stored in variables, anonymously or by
    name. Hopefully, you have got a taste of how flexible and powerful functions are
    and how they can help you to write robust code by enforcing strict types.'
  id: totrans-528
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, you will learn how to combine constants, variables, and
    functions that belong together logically into objects. This will give you an even
    higher level of organization in your code and will take information hiding to
    the next level by restricting the access level of variables and functions that
    are part of objects. Please remember that we call variables that live on object
    properties and we call functions that live on objects methods, while constants
    that live on objects are called class constants. Although they have a different
    name, they behave in a very similar way, so you will be able to reuse everything
    you learned in this chapter.
  id: totrans-529
  prefs: []
  type: TYPE_NORMAL
