- en: Chapter 4. Eloquent ORM
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapter, we touched on Eloquent, the **object-relational mapper**
    (**ORM**) that ships with Laravel. Eloquent acts as the model layer (the M in
    MVC) in our applications. As it is such a big part of most applications built
    in Laravel, we are going to take a look at Eloquent in more detail.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Reading and writing data to our database
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Relationships between models
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Query scopes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Model events and observers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Collections
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Eloquent conventions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Eloquent has some conventions, which, if followed, will make your life easier.
    This approach is known as **convention over configuration**, which means, if you
    follow these conventions, you will have to do very little configuration for things
    to "just work".
  prefs: []
  type: TYPE_NORMAL
- en: An Eloquent model is contained in a single class and is the "studly-cased",
    singular version of your database table's name. Studly-case is similar to camel-casing,
    but the first letter is uppercase as well. So if you have a database table called
    `cats`, then your model class will be called `Cat`.
  prefs: []
  type: TYPE_NORMAL
- en: 'There is no set place in the filesystem to place your Eloquent models; you
    are free to organize them as you see fit. You can use an Artisan command to create
    a model **stub** (a simple class with the basic structure of an Eloquent model).
    The command is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: By default, Artisan places new model classes in the `app` directory. You are
    free to move your model classes and store them in whatever directory you wish,
    just be sure to update the namespace declaration at the top of the file to reflect
    its new location.
  prefs: []
  type: TYPE_NORMAL
- en: 'Our model stub class will look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: This will attempt to use a table called `cats` by default.
  prefs: []
  type: TYPE_NORMAL
- en: 'Our model class extends the base Eloquent `Model` class, which contains all
    of the goodness we''re going to use over the course of this chapter. The first
    thing you should do after creating a model is define the database table it maps
    to. In our case, the database table will be called `cats`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: This is a working Eloquent model at its simplest and you can now use it to fetch
    records from your database table.
  prefs: []
  type: TYPE_NORMAL
- en: Retrieving data
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Eloquent provides you with numerous ways to fetch records from your database,
    each with their own appropriate use case. You can simply fetch all records in
    one go; a single record based on its primary key; records based on conditions;
    or a paginated list of either all or filtered records.
  prefs: []
  type: TYPE_NORMAL
- en: 'To fetch all records, we can use the aptly-named `all` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'To fetch a record by its primary key, you can use the `find` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Along with the `first` and `all` methods, there are **aggregate** methods.
    These allow you to retrieve aggregate values (rather than a record set) from your
    database tables:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Filtering records
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Eloquent also ships with a feature-rich query builder that allows you to build
    queries in code, without having to write a single line of SQL. This abstraction
    layer makes it easier to swap database platforms, should you ever need to. With
    Laravel, the only thing you need to do is update your database configuration and
    your application will continue to function as before.
  prefs: []
  type: TYPE_NORMAL
- en: 'Laravel''s query builder has methods for common SQL-like directives such as
    `WHERE`, `ORDER`, and `LIMIT`; and more advanced concepts such as joins. For example,
    the previous `find` illustration can be expressed—albeit in longhand—as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: This will retrieve the first record `WHERE 'id' = 1`. We will only expect one
    record when querying based on the primary key, so use the `first` method. If we
    have a more open `WHERE` clause, where we were expecting potentially more than
    one record, we can use the `get` method, as we did in the first code example,
    and it will only return records that matched that clause.
  prefs: []
  type: TYPE_NORMAL
- en: 'Clauses can also be **chained**. This allows you to build up complex query
    conditions by adding clauses together. Consider the following example code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'This will find all male users who were born after February 12, 1989\. Instead
    of specifying dates manually, we can also use **Carbon**, a date and time library.
    Here is an example of using Carbon to find all users who are older than 21 years
    of age:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You can find more information on Carbon and its available functions at its official
    GitHub repository [https://github.com/briannesbitt/Carbon](https://github.com/briannesbitt/Carbon).
    Common Carbon methods are also covered in [Appendix](apa.html "Appendix A. An
    Arsenal of Tools"), *An Arsenal of Tools*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Along with filtering records by `WHERE` conditions, you can also limit the
    number of records by using ranges using the `take` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'This will get the first five female users. You can also specify offsets by
    using the skip method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'In SQL, this will look similar to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Queries can also be ordered by using the `orderBy` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'This will correspond to a SQL statement that looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Saving data
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Applications that display data are great, but they're not very interactive.
    The fun comes when you allow users to submit data, whether these users are trusted
    contributors adding content via a content management system or contributions from
    general users on a site like Wikipedia.
  prefs: []
  type: TYPE_NORMAL
- en: 'When you retrieve a record via Eloquent, you can access its properties as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'We can update attribute values in the same manner:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'This will set the value in the model instance, but we need to persist the change
    to the database. We do this by calling the `save` method afterwards:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'If you have a table with lots of columns, then it will become tiresome to assign
    each property manually like this. To this end, Eloquent allows you to fill models
    by passing an associative array with values, and the keys representing the column
    names. You can fill a model while either creating or updating it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: However, this will throw a `MassAssignmentException` error.
  prefs: []
  type: TYPE_NORMAL
- en: Mass assignment
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The preceding example is an example of **mass assignment**. That is where a
    model's attributes are blindly updated with values *en masse*. If the `$data`
    array in the previous example came from say, a user's form submission, then they
    can update any and all values in the same database.
  prefs: []
  type: TYPE_NORMAL
- en: Consider that you have a `users` table with a column called `is_admin`, which
    determines whether or not that user can view your website's administration area.
    Also consider that users on the public side of your website can update their profile.
    If, during form submission, the user also included a field with the name of `is_admin`
    and a value of `1`, that would update the column value in the database table and
    grant them access to your super secret admin area—this is a huge security concern
    and is exactly what mass-assignment protection prevents.
  prefs: []
  type: TYPE_NORMAL
- en: 'To mark columns whose values are safe to set via mass-assignment (such as `name`,
    `birth_date`, and so on.), we need to update our Eloquent models by providing
    a new property called `$fillable`. This is simply an array containing the names
    of the attributes that are safe to set via mass assignment:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Now, we can create and update models by passing an array of data as before,
    without facing a `MassAssignmentException` being thrown.
  prefs: []
  type: TYPE_NORMAL
- en: Along with creating a new record, there are a couple of sibling methods that
    you can use. There is `firstOrCreate`, where you can pass an array of data—Eloquent
    will first try and find a model with the matching values. If it can't find a match,
    it will instead create the record.
  prefs: []
  type: TYPE_NORMAL
- en: There's also the similarly named `firstOrNew` method. However, instead of immediately
    saving the record to the database, it will instead just return a new Eloquent
    instance with the attribute values set, allowing you to set any other values first
    before manually saving it yourself.
  prefs: []
  type: TYPE_NORMAL
- en: A good time to use these methods is when allowing users to log in by using a
    third-party service such as Facebook or Twitter. These services will usually return
    information identifying the user, such as an e-mail address, allowing you to check
    your database for a matching user. If one exists, you can simply log them in,
    otherwise you can create a new user account for them.
  prefs: []
  type: TYPE_NORMAL
- en: Deleting data
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There are two ways of deleting records. If you have a model instance that you
    have fetched from the database, then you can call the `delete` method on it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Alternatively, you can call the `destroy` method, specifying the IDs of the
    records you want to delete, without having to fetch those records first:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Soft deletion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: By default, Eloquent will **hard-delete** records from your database. This means,
    once it's deleted, it's gone forever. If you need to retain deleted data (that
    is, for auditing), then you can use **soft deletes**. When deleting a model, the
    record is kept in the database but instead a `deleted_at` timestamp is set, and
    any records with this timestamp set will not be included when querying your database.
  prefs: []
  type: TYPE_NORMAL
- en: 'Soft deletes can be easily added to your Eloquent model. All you need to do
    is include the trait:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: We've also designated that the `deleted_at` column should be treated as a date
    column. This will yield the value as a Carbon instance and allow us to perform
    operations on it or display it in a variety of formats, should we need to.
  prefs: []
  type: TYPE_NORMAL
- en: 'You''ll also need to make sure the `deleted_at` column is added to your table
    migration. An example of such a migration is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Including deleted models in results
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'If you find you need to include deleted records when querying your database
    (for example, in an administration area), then you can use the `withTrashed` query
    scope. Query scopes are just methods you can use in chaining:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'This will mix deleted records with non-deleted records. If you find you need
    to retrieve *only* deleted records, then you can use the `onlyTrashed` query scope:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'If you find you need to "un-delete" a record, then the `SoftDeletes` trait
    provides you with a new `restore` method to undo this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Finally, if you find you *really* need to delete a record from your database,
    you can use the `forceDelete` method. As the name implies, once you delete a record
    with this method, it's truly gone.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Query scopes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The previous section introduced you to the concept of query scopes. This builds
    on from the query builder that allows you to build conditions on an ad hoc basis.
    However, what if you need certain conditions to apply to every request? Or a single
    condition that is actually the combination of multiple `WHERE` clauses? This is
    where query scopes come in.
  prefs: []
  type: TYPE_NORMAL
- en: 'Query scopes allow you to define these conditions once in your model, and then
    re-use them without having to manually define the clauses that make up that condition.
    For example, imagine we need to find users above the age of 21 in multiple places
    in our application. We can express this as a query scope:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Thanks to the fluent query builder, we can now use this as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, query scopes are methods that begin with the word "scope",
    take the current query as a parameter, modify it in some way, and then return
    the modified query, ready to be used in another clause. This means you can chain
    query scopes just as you would any other query expression:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Along with simple scopes like these, we can create more "dynamic" scopes that
    accept parameters and can be passed to the scope''s conditions. Consider the following
    example code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'We can then find cats of a specific breed as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: Relationships
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When we built our application in [Chapter 3](ch03.html "Chapter 3. Your First
    Application"), *Your First Application*, we made use of relationships. Each cat
    in our application was of a particular breed. However, instead of storing the
    name of the breed next to every individual cat and potentially having the breed
    repeating numerous times, we created a separate `breeds` table and each cat''s
    breed was a value that referred to the ID of a record in that table. This gave
    us an example of two types of relationships: a cat *belongs to* a breed, but a
    breed can *have many* cats. This is defined as a **one-to-many** relationship.'
  prefs: []
  type: TYPE_NORMAL
- en: 'There are other types of relationships, for each of which Eloquent provides
    good support:'
  prefs: []
  type: TYPE_NORMAL
- en: One-to-one
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Many-to-many
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Has-many-through
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Polymorphic relations
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Many-to-many polymorphic relations
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Here, we will look through them with an example of each.
  prefs: []
  type: TYPE_NORMAL
- en: One-to-one
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Sometimes, you may want to split data across multiple tables for ease of management,
    or because they represent two different parts of one entity. A common example
    is a user, and a user's profile. You may have a `users` table that contains core
    information about that user such as their name, account e-mail address, and password
    hash; however, if it's a social networking website, then they may also have a
    profile with more information, such as their favorite color. This information
    can then be stored in a separate `profiles` table, with a foreign key representing
    the user that the profile belongs to.
  prefs: []
  type: TYPE_NORMAL
- en: 'In your models, this relation will look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'And in the `Profile` model, the relation will look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'When querying `Users`, we can also access their profile separately:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: Relations are accessed using the name of the method used to define it in the
    model. Since in the `User` model we defined the relation in a method called `profile`,
    this is the name of the property we use to access the data of that related model.
  prefs: []
  type: TYPE_NORMAL
- en: Many-to-many
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A many-to-many relationship is more complicated than a one-to-one (where one
    model belongs to exactly one other model) or a one-to-many relationship (where
    many models can belong to one other model). As the name suggests, many models
    can belong to many other models. To accomplish this, instead of just two tables
    being involved, a third is introduced. This can be quite difficult to comprehend,
    so let's look at an example.
  prefs: []
  type: TYPE_NORMAL
- en: 'Imagine you''re building a permissions system to limit what actions each user
    can perform. Instead of assigning permissions on a per-user basis, you instead
    have roles, where each user is given a subset of permissions, depending on which
    role they''ve been assigned. In this description, we''ve identified two entities:
    a `User` and a `Role`. Also in this scenario, a user can have many roles, and
    a role can belong to many users. To map roles to users, we create a third table,
    called a join table. Laravel refers to these tables as **pivot** tables, a term
    you may have heard of if you have worked with spreadsheets before.'
  prefs: []
  type: TYPE_NORMAL
- en: By default, Eloquent expects join tables to contain the singular names of the
    two target tables, listed alphabetically and separated by an underscore. So in
    our scenario, this would be `role_user`. The table itself contains only two columns
    (other than the primary key). These columns represent the foreign key of the `Role`
    model and the `User` model it is creating a relation between. Again in convention
    over configuration, these should be lowercase, singular, with `_id` appended,
    that is, `role_id` and `user_id`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The relationship is defined in both our `User` and `Role` models using the
    `belongsToMany` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'We can now find out what roles a user has been assigned:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'We can also find out all users with a particular role:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'If you need to add a new role to a user, you can do so by using the `attach`
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'And, of course, the opposite of `attach` is `detach`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: Both the `attach` and `detach` methods also accept arrays, allowing you to add/remove
    multiple relations in one operation.
  prefs: []
  type: TYPE_NORMAL
- en: Alternatively, you can use the `sync` method. The difference with `sync` is,
    only after the operation is complete are the IDs that are passed present in the
    join table, rather than adding/removing them from the existing relations.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: Storing data in the pivot table
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Along with storing the primary keys of both the related models in the pivot
    table, you can also store additional data. Imagine we have users and groups in
    an application. Many users can belong to many groups, but users can also be moderators
    of groups. To indicate which users are moderators of a group, we can add a `is_moderator`
    column on the pivot table. To specify the additional data that should be stored
    in the pivot table, we can specify a second parameter when calling the `attach`
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'We can use the same approach when using the `sync` method too:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: Has-many-through
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: With related data, things are simple when you want data from a model that is
    directly related to the current one you're working with; but what happens if you
    want data that is two **hops** away from your current model?
  prefs: []
  type: TYPE_NORMAL
- en: Consider a simple e-commerce website. You may have a `Product` model, an `Order`
    model, and an `OrderItem` model that belongs to both a product and an order. You
    have been tasked with finding all orders that contain a particular product. How
    do you do this if `Product` isn't directly associated with `Order`? Thankfully,
    in our scenario, they have a common relation—the `OrderItem` model.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can use a "has-many-through" relationship to reach orders a product is part
    of via the intermediate `OrderItem` model. We set the relationship up in our `Product`
    model, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'The first parameter in the `hasManyThrough` method is the target model, and
    the second parameter is the intermediate model we go through to get to it. We
    can now easily list the orders a product is part of:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: Polymorphic relations
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Polymorphic relations are difficult to grasp at first; however, once you have
    an understanding of them, they are really powerful. They allow a model to belong
    to more than one other model on a single association.
  prefs: []
  type: TYPE_NORMAL
- en: 'A common use case for a polymorphic relationship is to create an image library
    and then allow your other models to contain images by linking to the relevant
    records in the image library table. A base `Image` model will look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'The `morphTo` method is what makes this model polymorphic. Now, in our other
    models, we can create a relation to the `Image` model, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'You can now fetch any related `Image` models through your `Article` model:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'You may think that this is no different to a one-to-many relationship, but
    the difference becomes apparent when you look at the relation from the other side.
    When retrieving an `Image` instance, if you access the `imageable` relation, you''ll
    receive an instance of whatever model "owns" the image. This may be an `Article`,
    a `Product`, or another model type in your application. Eloquent achieves this
    by not only storing a foreign key value, but also the name of the model class.
    In the case of our `Image` model, the columns would be `imageable_id` and `imageable_type`.
    When creating your migration, there is a method to create these two columns:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: Many-to-many polymorphic relations
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The final relation type we will look at is the **many-to-many polymorphic relation**,
    by far the most complex. Staying with our image library example, we can see that
    it has one drawback, an `Image` can only belong to one other model at a time.
    So, while we can see all images that have been uploaded by models in our application,
    we can't re-use an uploaded image like we would in a true image library. This
    is where a many-to-many polymorphic relation would come in.
  prefs: []
  type: TYPE_NORMAL
- en: 'Keeping our `images` and `articles` tables, we need to introduce a third table,
    `imageables`. The relation data is removed from the `images` table, and instead
    placed in this new table, which also has another column that is a foreign key
    pointing to the `Image` primary key. The three columns are:'
  prefs: []
  type: TYPE_NORMAL
- en: '`image_id`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`imageable_id`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`imageable_type`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'With this schema, a single `Image` can have multiple relations. That is, the
    image can be re-used in multiple models, whether that is multiple `Article` records,
    or models of different types. Our updated model classes then take this form:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'The `Image` model is also updated, containing methods for each of its relationships:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: You can still access the `images` relation as with a normal polymorphic relationship.
  prefs: []
  type: TYPE_NORMAL
- en: Model events
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Eloquent fires numerous events at different points, such as when a model is
    being saved or deleted. The following is a list of methods Eloquent models can
    fire:'
  prefs: []
  type: TYPE_NORMAL
- en: '`creating`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`created`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`updating`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`updated`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`saving`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`saved`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`deleting`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`deleted`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`restoring`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`restored`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The names are self-explanatory. The difference in the past and present participles
    is that events such as `creating` are fired *before* the model is created, whereas
    `created` is fired *after* the model has been created. Therefore, if you were
    to halt execution within a handler for the `creating` event, the record will not
    be saved; whereas, if you halted execution within a handler for the `created`
    event, the record would still be persisted to the database.
  prefs: []
  type: TYPE_NORMAL
- en: Registering event listeners
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'It''s quite open-ended as to where to register listeners for model events.
    One place is in the `boot` method within the `EventServiceProvider` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'Be sure to import the namespace for the `DispatcherContract` at the top of
    the file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'Eloquent models provide a method for each event that you can pass an anonymous
    function to. This anonymous function receives an instance of the model that you
    can then act upon. So if you wanted to create a URL-friendly representation of
    an article headline each time your `Article` model was saved, you can do this
    by listening on the saving event:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: Model observers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As you add more and more model event handlers to your `EventServiceProvider`
    class, you may find it becoming overcrowded and difficult to maintain. This is
    where an alternative to handling model events comes into play—model observers.
  prefs: []
  type: TYPE_NORMAL
- en: 'Model observers are standalone classes that you attach to a model, and implement
    methods for as many events as you need to listen out for. So our slug-creating
    function can be re-factored into a model observer as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'We can then register our observer in our `EventServiceProvider` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: Collections
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Historically, other frameworks that have shipped with their own ORMs and query
    builders have returned result sets as either multidimensional arrays or **Plain
    Old PHP** **Objects** (**POPOs**). Eloquent has taken its cue from other, more
    mature ORMs and instead returns result sets as an instance of a collection object.
  prefs: []
  type: TYPE_NORMAL
- en: The collection object is powerful as it not only contains the data returned
    from the database, but also many helper methods, allowing you to manipulate that
    data before displaying it to the user.
  prefs: []
  type: TYPE_NORMAL
- en: Checking whether a key exists in a collection
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'If you need to find out whether a particular key exists in a collection, you
    can use the `contains` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'When querying models, any relations are also returned as subcollections, allowing
    you to use the exact same methods on relations too:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: By default, models return an instance of `Illuminate\Database\Eloquent\Collection`.
    However, this can be overridden to instead use a different class. This is handy
    if we wanted to add additional methods to collections.
  prefs: []
  type: TYPE_NORMAL
- en: 'Say for a collection of roles and we want to determine if administrator is
    one of those roles. If we imagine the administrator role to have a primary key
    value of `1`, we can create a new method, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'The second part is to then tell the `Role` model to use our new collection:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'Instead of instantiating the default Eloquent collection, it will instead create
    a new instance of our `RoleCollection` class, filling it with the results from
    our query. This means that every time we request roles, we can use our new `containsAdmin`
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: Eloquent collections also have a plethora of other helpful functions for allowing
    you to manipulate, filter, and iterate over items. You can view more information
    on these methods at [http://laravel.com/docs/master/eloquent#collections](http://laravel.com/docs/master/eloquent#collections).
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Although we have covered a lot in this chapter, Eloquent is so feature-rich
    that unfortunately, there isn't room to cover each and every one of its features.
    We have covered the most important aspects of Eloquent, though, and that will
    set you well on your way to saving and retrieving data, creating relations of
    varying complexity between your models, and handling various events raised during
    your models' lifecycle.
  prefs: []
  type: TYPE_NORMAL
- en: The next chapter sees us move on to learn all about testing our application
    so it remains as bulletproof as possible.
  prefs: []
  type: TYPE_NORMAL
