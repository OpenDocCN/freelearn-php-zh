- en: Chapter 8. Multicasting in RxPHP and PHP7 pthreads Extension
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 8 章。RxPHP 和 PHP7 pthreads 扩展中的多播
- en: To make use of multiple CPUs and multiple cores, we've been using subprocesses.
    This is, of course, a very easy and safe method to run code in parallel. In combination
    with Unix sockets, we can make inter-process communication happen with ease. In
    the previous chapter, we combined all of this with RxPHP to make applications
    that were completely separated and run in parallel.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 为了利用多个 CPU 和多个核心，我们一直在使用子进程。这当然是一个非常简单且安全的方法来并行运行代码。结合 Unix 套接字，我们可以轻松实现进程间通信。在前一章中，我们将所有这些与
    RxPHP 结合起来，以创建完全分离且并行运行的应用程序。
- en: In this chapter, we'll have a look at a very interesting PHP7 extension called
    `pthreads`, which allows multithreading in PHP using POSIX threads.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将探讨一个名为 `pthreads` 的非常有趣的 PHP7 扩展，它允许使用 POSIX 线程在 PHP 中实现多线程。
- en: 'In particular, this chapter will cover the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 尤其是本章将涵盖以下主题：
- en: A deeper look into the `Subject` class and its variants.
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 深入了解 `Subject` 类及其变体。
- en: Multicasting operators in RxPHP and all its derivatives
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: RxPHP 及其所有衍生品中的多播操作符
- en: Examples of `ConnectableObservable` and `MulticastObservable`
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ConnectableObservable` 和 `MulticastObservable` 的示例'
- en: Using a single instance of the Subject with multiple source Observables
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用单个 Subject 实例与多个源 Observables
- en: Basics of multithreading in PHP
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: PHP 中多线程的基础
- en: Notes on today's state of the `pthreads` extension, its two major versions,
    and its current practical usage
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 关于今天 `pthreads` 扩展的状态、其两个主要版本及其当前实际使用的说明
- en: Writing a couple of multithreaded applications with the `pthreads` extension
    that'll demonstrate how to use the `Thread`, `Worker`, and `Poll` classes
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `pthreads` 扩展编写几个多线程应用程序，以演示如何使用 `Thread`、`Worker` 和 `Poll` 类
- en: Before we go parallel, we should have a look at yet another feature of Reactive
    Extensions called multicasting, which involves the `multicast()` operator and
    its derivates. Multicasting is build around Subjects so let's first have a better
    look at what different types of Subject are available to us.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们并行处理之前，我们应该看看反应式扩展的另一个特性，即多播，它涉及 `multicast()` 操作符及其衍生品。多播是围绕 Subjects 构建的，所以让我们首先更好地看看我们有哪些不同类型的
    Subject 可用。
- en: Subjects
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 主题
- en: We've been using Subjects in this book since [Chapter 2](part0024_split_000.html#MSDG2-bd355a22cf10407cb10df27e65585b8d
    "Chapter 2. Reactive Programming with RxPHP"), *Reactive Programming with RxPHP*,
    but there're multiple different variants of the `Subject` class for more specific
    use cases where all of them are relevant to multicasting.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 自从 [第 2 章](part0024_split_000.html#MSDG2-bd355a22cf10407cb10df27e65585b8d "第
    2 章。使用 RxPHP 进行响应式编程")，*使用 RxPHP 进行响应式编程*，我们在这本书中一直在使用 Subjects，但 `Subject` 类有多个不同的变体，用于更具体的用例，其中所有这些都与多播相关。
- en: BehaviorSubject
  id: totrans-14
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: BehaviorSubject
- en: 'The `BehaviorSubject` class extends the default `Subject` class and lets us
    set a default value that is passed to its observer right on subscription. Consider
    this very simple example of `BehaviorSubject`:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: '`BehaviorSubject` 类扩展了默认的 `Subject` 类，并允许我们设置一个默认值，该值在订阅时传递给其观察者。考虑以下非常简单的
    `BehaviorSubject` 示例：'
- en: '[PRE0]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: When `DebugSubject` subscribes to the `BehaviorSubject` class, the default value
    `42` is emitted immediately. This is a similar functionality to using the `startWith()`
    operator.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 当 `DebugSubject` 订阅 `BehaviorSubject` 类时，默认值 `42` 立即发出。这与使用 `startWith()` 操作符的功能类似。
- en: 'The output is then just a single line:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 输出结果只是一行：
- en: '[PRE1]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: ReplaySubject
  id: totrans-20
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: ReplaySubject
- en: The `ReplaySubject` class internally contains an array of the last *N* values
    it received and automatically re-emits them to every new observer on subscription.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: '`ReplaySubject` 类内部包含一个数组，其中包含它接收到的最后 *N* 个值，并在订阅时自动将这些值重新发射给每个新的观察者。'
- en: 'In the following example, we subscribe to `RangeObservable`, which immediately
    emits all its values to the `ReplaySubject` class. The last three values are always
    stored in an array and when we later subscribe with the `DebugSubject` class,
    it''ll immediately receive all three of them:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下示例中，我们订阅了 `RangeObservable`，它立即将其所有值发射到 `ReplaySubject` 类。最后三个值始终存储在数组中，当我们稍后使用
    `DebugSubject` 类订阅时，它将立即接收到这三个值：
- en: '[PRE2]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The output consists of the last three values that the `ReplaySubject` class
    received:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 输出结果由 `ReplaySubject` 类接收的最后三个值组成：
- en: '[PRE3]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Notice, that we also received the `complete` signal, which is correct because
    it was emitted by `RangeObservable`.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们还收到了 `complete` 信号，这是正确的，因为它是由 `RangeObservable` 发出的。
- en: AsyncSubject
  id: totrans-27
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: AsyncSubject
- en: The last Subject type RxPHP offers out of the box is called `AsyncSubject`,
    which might seem a little confusing. The only thing this Subject does is that
    it emits only the last value it received before receiving the `complete` signal.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: RxPHP 提供的最后一个 Subject 类型称为 `AsyncSubject`，这可能会有些令人困惑。这个 Subject 唯一做的事情就是只发出它在接收到
    `complete` 信号之前接收到的最后一个值。
- en: 'We''ll demonstrate this Subject on a similar example to the previous one. We''ll
    just switch the order of actions and we''ll subscribe the `DebugSubject` class
    before subscribing to the source Observable to see that it silently suppresses
    all values except the last one:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在与上一个示例类似的一个例子中演示这个 Subject。我们只需改变操作的顺序，并在订阅源 Observable 之前订阅 `DebugSubject`
    类，以看到它默默地抑制了所有值，除了最后一个：
- en: '[PRE4]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The output is only the last value emitted by the source `RangeObservable`:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 输出只有源 `RangeObservable` 发出的最后一个值：
- en: '[PRE5]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Now we know everything we need to start working with multicasting and the `multicast()`
    operator in particular.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经知道了一切，可以开始使用多播以及特定的 `multicast()` 操作符了。
- en: Multicasting in RxPHP
  id: totrans-34
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: RxPHP 中的多播
- en: In Reactive Extensions, multicasting means sharing a single subscription among
    multiple observers via an instance of a `Subject` class. All multicasting operators
    are internally based on the general `multicast()` operator that implements their
    most common functionality. Of course, we're not limited to only using the `Subject`
    class and we'll use `ReplaySubject` and `BehaviorSubject` as well.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 在响应式扩展中，多播意味着通过 `Subject` 类的实例在多个观察者之间共享单个订阅。所有多播操作符在内部都基于通用的 `multicast()`
    操作符，它实现了它们最常用的功能。当然，我们不仅限于只使用 `Subject` 类，我们还会使用 `ReplaySubject` 和 `BehaviorSubject`。
- en: Multicasting is common to all Rx implementations, so knowledge of how it works
    inside is generally useful.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 多播在所有 Rx 实现中都很常见，因此了解其内部工作原理通常很有用。
- en: The multicast() operator and ConnectableObservable
  id: totrans-37
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '`multicast()` 操作符和 ConnectableObservable'
- en: The `multicast()` operator returns `ConnectableObservable` or `MulticastObservable`
    based on what arguments we pass. We'll first have a look at how it works with
    `ConnectableObservable`, because this should be very familiar to us.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '`multicast()` 操作符根据我们传递的参数返回 `ConnectableObservable` 或 `MulticastObservable`。我们首先看看它是如何与
    `ConnectableObservable` 一起工作的，因为这对我们来说应该非常熟悉。'
- en: 'A typical use case could look like the following example:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 一个典型的用例可能看起来像以下示例：
- en: '[PRE6]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Instead of instantiating `ConnectableObservable`, we used the `multicast()`
    operator to do it for us.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 我们没有实例化 `ConnectableObservable`，而是使用了 `multicast()` 操作符来帮我们完成。
- en: In this example, we created a single source Observable and subscribed two observers
    to it. Then, after calling `connect()`, the `ConnectableObservable` class subscribed
    to an instance of `AnonymousObservable` returned from the `Observable::defer`
    static method.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们创建了一个单独的源 Observable，并订阅了两个观察者。然后，在调用 `connect()` 之后，`ConnectableObservable`
    类订阅了由 `Observable::defer` 静态方法返回的 `AnonymousObservable` 实例。
- en: 'As we can see, the `multicast()` operator returns an instance of `ConnectableObservable`.
    The result from this example is as follows:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，`multicast()` 操作符返回一个 `ConnectableObservable` 的实例。这个示例的结果如下：
- en: '[PRE7]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: All observers subscribe to the same instance of the Subject that we passed.
    This is an important implication that we need to be aware of.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 所有观察者都订阅了我们传递的同一个 Subject 实例。这是一个重要的含义，我们需要意识到。
- en: In a moment, we'll have a look at a slightly modified version of this example
    that passes different arguments to `multicast()`.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 在不久的将来，我们将查看这个示例的一个略微修改的版本，它将向 `multicast()` 传递不同的参数。
- en: MulticastObservable
  id: totrans-47
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: MulticastObservable
- en: 'Another Observable used for multicasting is called `MulticastObservable`. Its
    usage is similar to `ConnectableObservable`, but its internal functionality is
    very different. Consider the following example:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个用于多播的 Observable 称为 `MulticastObservable`。它的用法与 `ConnectableObservable` 类似，但其内部功能非常不同。考虑以下示例：
- en: '[PRE8]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: When subscribing to `MulticastObservable`, it internally calls the `multicast()`
    operator on the source Observable (which returns `ConnectableObservable`, as we
    saw in the previous example) and runs the first callable to create an instance
    of the `Subject` class. This is the first major difference to using just `multicast()`,
    where we always shared the same instance of the `Subject` class. The `MulticastObservable`,
    in contrast, creates a new `Subject` for every subscriber.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 当订阅`MulticastObservable`时，它会在源Observable（正如我们在上一个示例中看到的，它返回`ConnectableObservable`）上内部调用`multicast()`操作符，并运行第一个可调用函数来创建`Subject`类的实例。这是与仅使用`multicast()`相比的第一个主要区别，在后者中，我们始终共享相同的`Subject`类实例。相比之下，`MulticastObservable`为每个订阅者创建一个新的`Subject`。
- en: So internally, we have an instance of `ConnectableObservable`. Then it calls
    the second callable with this `ConnectableObservable` passed as an argument, which
    means we can further chain operators to it, or we could even use a completely
    different Observable (just remember this method has to return an Observable because
    the operator will internally subscribe to it).
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在内部，我们有一个`ConnectableObservable`的实例。然后它调用第二个可调用函数，并将这个`ConnectableObservable`作为参数传递，这意味着我们可以进一步链式添加操作符，或者我们甚至可以使用一个完全不同的Observable（只需记住这个方法必须返回一个Observable，因为操作符将内部订阅它）。
- en: This callable is often called the **selector function** because it lets us select
    where we want to subscribe. After that, `MulticastObservable` subscribes to the
    Observable returned and calls the `connect()` method on the `ConnectableObservable`.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 这个可调用函数通常被称为**选择器函数**，因为它允许我们选择我们想要订阅的位置。之后，`MulticastObservable`订阅返回的Observable，并在`ConnectableObservable`上调用`connect()`方法。
- en: In our example, we create a new instance of the `Subject` class for every subscriber
    and then chain `startWith()` with the `ConnectableObservable`, which makes it
    emit a single value before emitting values from the source.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的示例中，我们为每个订阅者创建一个`Subject`类的实例，然后使用`ConnectableObservable`链式添加`startWith()`，这使得它在从源发出值之前发出单个值。
- en: 'The output will look like the following:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 输出将如下所示：
- en: '[PRE9]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Note that the deferred Observable was called twice, which is correct. Each observer
    has its own instances of the Subject and `ConnectableObservable`. We have full
    control of what Subjects we're using for multicasting instead of leaving it to
    the default `multicast()` behavior.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，延迟的Observable被调用了两次，这是正确的。每个观察者都有自己的Subject和`ConnectableObservable`实例。我们完全控制我们用于多播的Subjects，而不是将其留给默认的`multicast()`行为。
- en: The question is, why does it matter whether we're using the same instance of
    the Subject or not?
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 问题是，我们是否使用相同的Subject实例，这究竟有什么关系？
- en: Subjects and their internal state
  id: totrans-58
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Subjects及其内部状态
- en: 'We know how to use Subjects. We also know what the `next`, `complete`, and
    `error` signals do. So what happens if we use a single `Subject` and subscribe
    to a cold Observable multiple times? Consider the following example:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 我们知道如何使用Subjects。我们也知道`next`、`complete`和`error`信号的作用。那么，如果我们使用单个`Subject`并多次订阅冷Observable会发生什么？考虑以下示例：
- en: '[PRE10]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: We'll run this example and talk about what happens inside the `Subject` instance.
    Note that we subscribed to the `Subject` twice where the first observer (represented
    by `DebugSubject`) receives the first three values and then emits the `complete`
    signal.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将运行这个示例，并讨论`Subject`实例内部发生的事情。请注意，我们两次订阅了`Subject`，第一个观察者（由`DebugSubject`表示）接收前三个值，然后发出`complete`信号。
- en: However, what happens with the second observer?
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，第二个观察者会发生什么呢？
- en: '[PRE11]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The second observer received just the `complete` signal, and none of the observers
    received the value `4`.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个观察者只接收了`complete`信号，而没有观察者接收了值`4`。
- en: 'It''s very important to understand what happens internally inside a `Subject`
    class when it receives a `complete` signal (this means it receives a `complete`
    signal or we call the `onCompleted()` method manually):'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 理解当`Subject`类接收到`complete`信号（这意味着它接收到一个`complete`信号或我们手动调用`onCompleted()`方法）时内部发生的事情非常重要：
- en: The `Subject` class checks whether it's already been marked as stopped. If it
    has, then the method returns immediately. If it's not stopped, then it marks itself
    as stopped.
  id: totrans-66
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Subject`类检查它是否已经被标记为停止。如果是，则方法立即返回。如果没有停止，则它将自己标记为停止。'
- en: The complete signals are then sent to all observers.
  id: totrans-67
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 完整的信号随后发送给所有观察者。
- en: The array of observers is emptied.
  id: totrans-68
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 观察者数组被清空。
- en: So now it should make sense. The first three values were emitted as usual. Then
    we called `onComplete()`, which did exactly what we described in these bullet
    points. At this point, this `Subject` instance has no observers (see step 4).
    Then we subscribe with another observer, which is added to the array of observers.
    This observer immediately receives a `complete` signal because the Subject is
    already stopped and didn't end with an error.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 所以现在应该很清楚。前三个值像往常一样发出。然后我们调用了`onComplete()`，它正好做了我们在这几点中描述的事情。此时，这个`Subject`实例没有观察者（参见步骤4）。然后我们用另一个观察者订阅，该观察者被添加到观察者数组中。这个观察者立即收到一个`complete`信号，因为Subject已经停止，并且没有以错误结束。
- en: At this point, calling `onNext(4)` does nothing because the `Subject` instance
    is already stopped (see step 1).
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，调用`onNext(4)`没有任何作用，因为`Subject`实例已经停止了（参见步骤1）。
- en: This principle might be a problem in situations where we purposely want to defer
    creating Observables with, for example, the `Observable::defer` static method
    that will be called multiple times. Once it sends the `complete` signal, all consecutive
    values will be ignored by the `Subject` instance for the reasons we explained.
    We'll have another example featuring this issue later in this chapter.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 这个原则可能在某些情况下成为问题，例如，当我们故意想要延迟使用`Observable::defer`静态方法创建可观察对象时，该方法将被多次调用。一旦它发送了`complete`信号，所有后续的值都将被`Subject`实例忽略，原因我们在前面已经解释过了。我们将在本章后面提供另一个涉及此问题的示例。
- en: This is a very important principle we need to be aware of when using `multicast()`
    operators and the `ConnectableObservable`.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们使用`multicast()`操作符和`ConnectableObservable`时需要了解的一个非常重要的原则。
- en: Whether this applies to `MulticastObservable` is up to us, depending on what
    we return from its first callable. We can use the same instance of `Subject` or
    we can create a new one depending on what we want to achieve.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 这个是否适用于`MulticastObservable`取决于我们对其第一次可调用返回的内容。我们可以使用同一个`Subject`实例，或者根据我们想要达到的目的创建一个新的实例。
- en: Note
  id: totrans-74
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: If this all looks confusing, just remember that Subjects have an internal state.
    When they receive `complete` or `error` notification, they'll never re-emit any
    value further.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 如果这一切看起来很混乱，只需记住Subjects有一个内部状态。当它们收到`complete`或`error`通知时，它们永远不会重新发出任何值。
- en: The multicast() operator and MulticastObservable
  id: totrans-76
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: multicast()操作符和MulticastObservable
- en: So let's go back to the `multicast()` operator and see how `MulticastObservable`
    is related to all this. We said that `multicast()` returns `ConnectableObservable`
    or `MulticastObservable` depending on the arguments we use. This is true when
    we use the second argument to `multicast()`.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 所以让我们回到`multicast()`操作符，看看`MulticastObservable`是如何与所有这些相关的。我们说过，`multicast()`返回`ConnectableObservable`或`MulticastObservable`，这取决于我们使用的参数。当我们使用`multicast()`的第二个参数时，这是正确的。
- en: 'Consider the following example, where we also pass a selector function to the
    `multicast()` operator:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下示例，其中我们还将选择器函数传递给`multicast()`操作符：
- en: '[PRE12]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'If we use the second argument to `multicast()`, it wraps the `$subject` variable
    with a callable before it''s passed to `MulticastObservable`. In fact, `multicast()`
    is internally implemented as the following:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们使用`multicast()`的第二个参数，它会在传递给`MulticastObservable`之前将`$subject`变量包装在一个可调用函数中。实际上，`multicast()`在内部实现如下：
- en: '[PRE13]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: This always guarantees that we're using the same `Subject`. The only thing that
    decides which Observable we'll receive is whether we use the selector function
    or not. The preceding example also adds the `startWith()` and `concat()` operators
    to see what effect this selector function can have.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 这始终保证了我们使用的是同一个`Subject`。唯一决定我们将收到哪个可观察对象的是我们是否使用选择器函数。前面的示例还添加了`startWith()`和`concat()`操作符，以查看这个选择器函数可以产生什么效果。
- en: 'The output for this example is affected by the issue we showed earlier:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 这个示例的输出受到了我们之前展示的问题的影响：
- en: '[PRE14]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The second subscriber hasn't received any value, even though we subscribed twice
    to the source Observable.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个订阅者没有收到任何值，尽管我们两次订阅了源可观察对象。
- en: Comparing ConnectableObservable and MulticastObservable
  id: totrans-86
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 比较可连接可观察对象和MulticastObservable
- en: 'To be extra clear about the difference between these two use cases and `ConnectableObservable`
    and `MulticastObservable`, let''s have a look at these two diagrams:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更清楚地了解这两个用例以及`ConnectableObservable`和`MulticastObservable`之间的区别，让我们看看这两个图：
- en: '![Comparing ConnectableObservable and MulticastObservable](img/00030.jpeg)'
  id: totrans-88
  prefs: []
  type: TYPE_IMG
  zh: '![比较可连接可观察对象和MulticastObservable](img/00030.jpeg)'
- en: Diagram representing a ConnectableObservable with two observers
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 表示具有两个观察者的可连接可观察对象图
- en: In this diagram, we have a single `ConnectableObservable` that internally contains
    one `Subject`. Both observers are subscribed to the same `Subject`.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个图中，我们有一个包含一个`Subject`的单个`ConnectableObservable`，两个观察者都订阅了同一个`Subject`。
- en: 'On the other hand, with `MulticastObservable` we''ll get the following structure:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，使用`MulticastObservable`我们将得到以下结构：
- en: '![Comparing ConnectableObservable and MulticastObservable](img/00031.jpeg)'
  id: totrans-92
  prefs: []
  type: TYPE_IMG
  zh: '![比较ConnectableObservable和MulticastObservable](img/00031.jpeg)'
- en: Diagram representing a MulticastObservable with two observers
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 表示具有两个观察者的`MulticastObservable`的图
- en: The two `ConnectableObservables` inside the grey boxes mean we have no control
    over them (these are created automatically by the internal `multicast()` call,
    as mentioned earlier).
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 灰色框内的两个`ConnectableObservables`意味着我们无法控制它们（这些是由前面提到的内部`multicast()`调用自动创建的）。
- en: As we can see from the examples, with `MulticastObservable` created via the
    `multicast()` call, we won't be able to achieve the same result as we see in this
    image because `multicast()` always forces us to use a single Subject instance.
    Of course, we could always create an instance of `MulticastObservable` ourselves,
    as we saw earlier in this chapter, but there's also an operator for this purpose
    that we can use.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 从示例中我们可以看出，通过`multicast()`调用创建的`MulticastObservable`，我们无法达到图中所示的结果，因为`multicast()`总是强制我们使用单个`Subject`实例。当然，我们也可以像本章前面所看到的那样，自己创建`MulticastObservable`的实例，但还有一个操作符可以用来实现这个目的。
- en: The multicastWithSelector() operator
  id: totrans-96
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '`multicastWithSelector()`操作符'
- en: To simplify creating instances of `MulticastObservable`, we have the `multicastWithSelector()`
    operator, which takes two callables as arguments that have the same purpose as
    calling `MulticastObservable` itself.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 为了简化创建`MulticastObservable`实例的过程，我们提供了`multicastWithSelector()`操作符，它接受两个具有与直接调用`MulticastObservable`相同目的的可调用参数。
- en: 'Consider the following example:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下示例：
- en: '[PRE15]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: This example illustrates the diagram we saw previously. We have two observers
    where each has its own instance of `Subject`. We also made use of the selector
    function that appends a `concat` string at the end of the chain.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 本例说明了我们之前看到的图。我们有两个观察者，每个观察者都有自己的`Subject`实例。我们还使用了选择器函数，在链的末尾添加了一个`concat`字符串。
- en: 'The output is then easily predictable:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 输出结果很容易预测：
- en: '[PRE16]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: This was an introduction to multicasting in Rx and the `multicast()` operator
    in RxPHP. Since there're a few other operators based on `multicast()`, we'll talk
    about them now when we know how `multicast()` behaves internally.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 这是对Rx中的多播和RxPHP中的`multicast()`操作符的介绍。由于还有一些基于`multicast()`的其他操作符，因此在我们了解`multicast()`的内部行为后，我们将讨论它们。
- en: The publish*() and share*() operator groups
  id: totrans-104
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '`publish*()`和`share*()`操作符组'
- en: 'There''re multiple other operators internally using the `multicast()` operator,
    and we can split them into two basic groups:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 内部存在多个使用`multicast()`操作符的其他操作符，我们可以将它们分为两个基本组：
- en: '`publish*()`: Operators starting with the word "publish" wrap the `multicast()`
    operator and call it with one of the `Subject` classes. All `publish*` variants
    accept an optional argument, which is the selector function that we talked about
    earlier. Therefore, all of them can return `ConnectableObservable` or `MulticastObservable`
    just like `multicast()`.'
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`publish*()`：以“publish”开头的操作符包装`multicast()`操作符，并使用其中一个`Subject`类调用它。所有`publish*`变体都接受一个可选参数，即我们之前提到过的选择器函数。因此，所有这些都可以返回`ConnectableObservable`或`MulticastObservable`，就像`multicast()`一样。'
- en: '`share*()`: Operators starting with the word "share" internally use the same
    `publish*` equivalent and chain it with the `refCount()` operator. All `share*`
    operators don''t allow any selector function.'
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`share*()`：以“share”开头的操作符在内部使用相同的`publish*`等效操作符，并将其与`refCount()`操作符链式连接。所有`share*`操作符都不允许任何选择器函数。'
- en: To understand the difference between the two groups, we need to first understand
    what the `refCount()` operator is.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 要理解这两组之间的区别，我们首先需要了解`refCount()`操作符是什么。
- en: The refCount() operator
  id: totrans-109
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '`refCount()`操作符'
- en: 'We already know this very basic usage of `ConnectableObservable`. Let''s consider
    the following example, and first see how we can call the `connect()` method manually
    and then switch to the `refCount()` operator:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经了解了`ConnectableObservable`的这种非常基本的用法。让我们考虑以下示例，首先看看我们如何手动调用`connect()`方法，然后切换到`refCount()`操作符：
- en: '[PRE17]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: This is simple. We have two observers subscribed to the `ConnectableObservable`
    waiting to call `connect()`, which subscribes to the source Observable (in this
    case `AnonymousObservable` with a custom subscribe function) and emits all values
    to both observers at the same time.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 这很简单。我们有两个订阅了 `ConnectableObservable` 的观察者，等待调用 `connect()`，它订阅了源 Observable（在这种情况下是具有自定义订阅函数的
    `AnonymousObservable`）并将所有值同时发送给两个观察者。
- en: 'Note that we''re purposely not using `RangeObservable` because we don''t want
    to emit the `complete` signal:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们故意没有使用 `RangeObservable`，因为我们不想发出 `complete` 信号：
- en: '[PRE18]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: This is pretty simple, but we had to call `connect()` ourselves, which is sometimes
    alright. However, other times we can leave this logic to the `refCount()` operator.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 这很简单，但我们不得不自己调用 `connect()`，这有时是可以接受的。然而，在其他时候，我们可以将这种逻辑留给 `refCount()` 操作符。
- en: Well, actually it's not an operator (it's not lifted to an Observable chain
    with the `lift()` method). It's just a method on `ConnectableObservable` that
    returns an instance of `RefCountObservable`.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 嗯，实际上它不是一个操作符（它没有被提升到使用 `lift()` 方法的 Observable 链）。它只是 `ConnectableObservable`
    上的一个方法，返回一个 `RefCountObservable` 实例。
- en: This Observable internally subscribes and unsubscribes to the source Observable.
    When the first observer subscribes, it also calls `connect()` on the `ConnectableObservable`.
    Then when another observer subscribes, it does nothing because we've already subscribed.
    When unsubscribing, the procedure is exactly the opposite. If even the last observer
    unsubscribes, then `RefCountObservable` also unsubscribes the `ConnectableObservable`.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 这个 Observable 内部订阅和取消订阅源 Observable。当第一个观察者订阅时，它也会在 `ConnectableObservable`
    上调用 `connect()`。然后当另一个观察者订阅时，它什么都不做，因为我们已经订阅了。在取消订阅时，程序正好相反。如果最后一个观察者取消订阅，那么 `RefCountObservable`
    也会取消 `ConnectableObservable` 的订阅。
- en: 'This has some interesting consequences. We can use `refCount()` to automatically
    subscribe when there''s at least one observer, as we can see in this example:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 这有一些有趣的结果。我们可以使用 `refCount()` 在至少有一个观察者时自动订阅，正如我们在这个示例中可以看到的那样：
- en: '[PRE19]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'We have two observers again, but this time we''re not calling `connect()` by
    ourselves. Instead, we''re using `refCount()` to call the `connect()` method for
    us. Since we''re sharing the same subscription to the source, only the first observer
    will receive values. The second observer doesn''t cause another subscription to
    the source (as we can see from the preceding explanation):'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 我们再次有两个观察者，但这次我们不是自己调用 `connect()`。相反，我们使用 `refCount()` 来为我们调用 `connect()` 方法。由于我们共享对源的相同订阅，只有第一个观察者会收到值。第二个观察者不会导致对源的另一个订阅（正如我们从前面的解释中可以看到）：
- en: '[PRE20]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'However, if we unsubscribe after receiving values for the first observer (which
    causes unsubscription from `ConnectableObservable` inside `RefCountObservable`)
    and then subscribe again with the second observer, it''ll make the source emit
    all its values because we have subscribed to it again:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果我们收到第一个观察者的值后取消订阅（这会导致 `RefCountObservable` 内部的 `ConnectableObservable`
    取消订阅）然后再次使用第二个观察者订阅，它将使源发出所有值，因为我们再次订阅了它：
- en: '[PRE21]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: When we called `dispose()`, we made `RefCountObservable` unsubscribe from its
    source because there are no more observers.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们调用 `dispose()` 时，我们使 `RefCountObservable` 取消订阅其源，因为没有更多的观察者。
- en: 'This example prints all values twice:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 这个示例打印了所有值两次：
- en: '[PRE22]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Of course, we need to be sure we don't stop the inner `Subject` in `ConnectableObservable`
    as we talked about before. The `ConnectableObservable` class uses a single instance
    of `Subject`, so if it received a complete signal, then no unsubscription or subscription
    would change this.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，我们需要确保我们不会停止 `ConnectableObservable` 内部的 `Subject`，正如我们之前讨论的那样。`ConnectableObservable`
    类使用一个 `Subject` 的单例，所以如果它收到了完成信号，那么取消订阅或订阅的任何变化都不会改变这一点。
- en: The publish() and share() operators
  id: totrans-128
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: publish() 和 share() 操作符
- en: Now we know what the `multicast()` and `refCount()` operators do, we can finally
    understand what `publish()` and `share()` do.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们知道了 `multicast()` 和 `refCount()` 操作符的作用，我们最终可以理解 `publish()` 和 `share()`
    的作用。
- en: 'Using `publish()` is just a shortcut to calling `multicast()` with the `Subject`
    instance as a parameter. If we rewrote the very first example on the `multicast()`
    operator, it would look almost the same:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `publish()` 只是一个调用带有 `Subject` 实例参数的 `multicast()` 的快捷方式。如果我们重写 `multicast()`
    操作符的第一个示例，它看起来几乎一样：
- en: '[PRE23]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: The output for this demo is exactly the same as for `multicast_01.php`, so we
    don't need to reprint it here.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 这个演示的输出与 `multicast_01.php` 的输出完全相同，所以我们不需要在这里重新打印它。
- en: The `share()` Operator uses the `publish()->refCount()` chain internally, so
    we don't need to call `connect()` any more. However, the output is not the same.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: '`share()`操作符在内部使用`publish()->refCount()`链，因此我们不再需要调用`connect()`。然而，输出并不相同。'
- en: 'The `RangeObservable` sent the complete signal, which marked the internal `Subject`
    in `ConnectableObservable` as stopped, so the second observer won''t receive anything
    except the `complete` signal that is emitted by the `Subject` class right at the
    point of subscription (it''s not emitted by the source Observable):'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: '`RangeObservable`发送了完整的信号，这标志着`ConnectableObservable`中的内部`Subject`已停止，因此第二个观察者除了接收`Subject`类在订阅点发出的`complete`信号外，不会接收到任何东西（它不是由源Observable发出的）：'
- en: '[PRE24]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'From the output, we can see that the source Observable is really created just
    once:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 从输出中，我们可以看到源Observable实际上只创建了一次：
- en: '[PRE25]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: These two basic operators have many variants, but are based on the same principle.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个基本操作符有许多变体，但都是基于相同的原则。
- en: The publishValue() and shareValue() operators
  id: totrans-139
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '`publishValue()`和`shareValue()`操作符'
- en: These operators are based on `BehaviorSubject` instead of just `Subject`. The
    principle is then exactly the same. The `publishValue()` operator calls `multicast()`
    with an instance of `BehaviorSubject`. Then the `shareValue()` operator calls
    `publishValue()->refCount()`.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 这些操作符基于`BehaviorSubject`而不是仅仅基于`Subject`。原理完全相同。`publishValue()`操作符使用`BehaviorSubject`的实例调用`multicast()`。然后`shareValue()`操作符调用`publishValue()->refCount()`。
- en: Using `BehaviorSubject` allows us to set the default value that is emitted to
    all observers when they subscribe.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`BehaviorSubject`允许我们在观察者订阅时向所有观察者发出默认值。
- en: 'We can test this operator on the same example as before:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在之前的示例上测试这个操作符：
- en: '[PRE26]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'The output always starts with the default string because it''s emitted by `BehaviorSubject`
    as the first value:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 输出始终以默认字符串开始，因为它作为第一个值由`BehaviorSubject`发出：
- en: '[PRE27]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Using `shareValue()` is the same as using `share()`, so we don't need to include
    it here.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`shareValue()`与使用`share()`相同，因此我们不需要在这里包含它。
- en: The replay(), shareReplay(), and publishLast() operators
  id: totrans-147
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '`replay()`、`shareReplay()`和`publishLast()`操作符'
- en: All these share exactly the same principle as the previous two operators, just
    based on `ReplaySubject` (`replay()` and `shareReplay()`) or `AsyncSubject` (the `publishLast()`
    operator).
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些操作符与前面的两个操作符具有完全相同的原则，只是基于`ReplaySubject`（`replay()`和`shareReplay()`）或`AsyncSubject`（`publishLast()`操作符）。
- en: We don't need to include examples for those operators here because there would
    be nothing new for us to see.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不需要为这些操作符提供示例，因为我们不会看到任何新的内容。
- en: PHP pthreads extension
  id: totrans-150
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: PHP pthreads扩展
- en: Since the year 2000, PHP can be compiled as **thread safe**, which allows any
    process to run multiple instances of the PHP interpreter in multiple threads (one
    thread per PHP interpreter). Each PHP interpreter has its own isolated context
    which doesn't share any data (the "share nothing" philosophy) with others.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 自2000年以来，PHP可以编译为**线程安全**，这允许任何进程在多个线程中运行多个PHP解释器的多个实例（每个PHP解释器一个线程）。每个PHP解释器都有自己的独立上下文，与其他解释器不共享任何数据（“无共享”哲学）。
- en: This is commonly used in web servers such as Apache (depending on its modules).
    Apache creates multiple subprocesses where each subprocess runs multiple threads
    with multiple PHP interpreters. Running interpreters in threads instead of subprocesses
    has its advantages and disadvantages.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 这通常用于像Apache（取决于其模块）这样的Web服务器。Apache创建了多个子进程，每个子进程运行多个线程，每个线程运行多个PHP解释器。在线程中而不是在子进程中运行解释器有其优点和缺点。
- en: Creating only threads is significantly faster and doesn't consume as much memory
    as creating subprocesses.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 仅创建线程比创建子进程要快得多，并且消耗的内存也少得多。
- en: An obvious disadvantage is isolation. Even though all PHP interpreters run independently
    in threads, if any of them causes, for example, a "segmentation fault" error,
    then the entire process and all of its threads are terminated immediately. This
    even includes threads that didn't cause any error and that might be processing
    an HTTP request from another client at that moment.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 一个明显的缺点是隔离。尽管所有PHP解释器都在线程中独立运行，但如果其中任何一个发生，例如，"段错误"错误，那么整个进程及其所有线程将立即终止。这甚至包括没有引发任何错误且可能正在处理来自另一个客户端的HTTP请求的线程。
- en: This so-called **Server API** (**SAPI**) isn't very helpful to us. We need to
    be able to run our own pieces of code in threads ("user land multithreading").
    The PHP extension pthreads is an object-oriented API that does exactly this. It
    takes our code and creates a new PHP interpreter, which then starts executing
    it.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 这个所谓的**服务器API**（**SAPI**）对我们来说并不很有帮助。我们需要能够在线程中运行我们自己的代码片段（“用户空间多线程”）。PHP扩展pthreads是一个面向对象的API，它正好做到了这一点。它将我们的代码转换成一个新的PHP解释器，然后开始执行它。
- en: Note that the PHP pthreads are based on POSIX threads, which means that when
    we create a thread using pthreads, we're creating a real thread and not forking
    or creating subprocesses underneath.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，PHP的pthreads基于POSIX线程，这意味着当我们使用pthread创建一个线程时，我们实际上是在创建一个真正的线程，而不是在下面进行分叉或创建子进程。
- en: In some languages, such as Python, there are threads that behave like they're
    executing code in parallel, but in fact there's still just one single threaded
    Python interpreter switching from one "thread" to another. So there's no real
    parallelism.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些语言中，例如Python，有看起来像是在并行执行代码的线程，但实际上仍然只有一个单线程的Python解释器在从一个“线程”切换到另一个。所以没有真正的并行性。
- en: However, PHP `pthreads` come with a cost, and it's important to understand at
    least a little of what's going on inside.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，PHP `pthreads`有其代价，并且理解至少一点其内部发生的事情是很重要的。
- en: Prerequisites
  id: totrans-159
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 前置条件
- en: In this chapter, we'll use the new `pthreads` v3, which means we need to use
    PHP7+. There's also the older `pthreads` v2, which is designed for PHP5\. Since
    there are major differences in the internal implementations with these two versions,
    we'll stick only to the new one.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一章中，我们将使用新的`pthreads` v3，这意味着我们需要使用PHP7+。还有一个较老的`pthreads` v2，它是为PHP5设计的。由于这两个版本在内部实现上有重大差异，我们将只使用新的一个。
- en: As we said earlier, in order to use the `pthreads` extension, PHP has to be
    compiled with the **Thread Safety** option enabled. This needs to be enabled when
    compiling PHP and can't be enabled later (if you're only downloading the PHP executable,
    make sure you're downloading the correct one, usually marked as ZTS).
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们之前所说，为了使用`pthreads`扩展，PHP必须编译时启用**线程安全**选项。这需要在编译PHP时启用，不能在之后启用（如果你只下载PHP可执行文件，请确保你下载的是正确的，通常标记为ZTS）。
- en: 'A universal way to install `pthreads` is with the PECL tool, which should work
    on all platforms:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 安装`pthreads`的一个通用方法是使用PECL工具，它应该在所有平台上都适用：
- en: '[PRE28]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Alternatively, if you''re running OS X, you can use a homebrew tool that also
    enables it in PHP config files for you:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，如果你正在运行OS X，你可以使用一个homebrew工具，它也可以为你启用PHP配置文件中的它：
- en: '[PRE29]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Note
  id: totrans-166
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The current pthreads v3 can be enabled only when running PHP code in a standalone
    script. This means pthreads can't be part of any PHP application ran using for
    example `php-fpm`. In other words, we can use pthreads only in console applications
    and not it web applications.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 当在独立脚本中运行PHP代码时，才能启用当前版本的pthreads v3。这意味着pthreads不能是使用例如`php-fpm`运行的任何PHP应用程序的一部分。换句话说，我们只能在控制台应用程序中使用pthreads，而不能在Web应用程序中使用。
- en: Introduction to multithreading with pthreads in PHP7
  id: totrans-168
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: PHP7中pthreads的多线程简介
- en: 'The most basic example of pthreads in PHP can simply be the spawning of multiple
    threads and printing their results. We''ll make random pauses with `sleep()` functions
    to simulate multiple long running tasks. Remember that in PHP the `sleep()` function
    is always blocking (it blocks the interpreter execution for a certain number of
    seconds):'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: PHP中pthreads最基础的例子可以是简单地创建多个线程并打印它们的结果。我们将使用`sleep()`函数来模拟多个长时间运行的任务。记住，在PHP中，`sleep()`函数始终是阻塞的（它会阻塞解释器执行一定的时间）：
- en: '[PRE30]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: A task is represented by a class extending the base `Thread` class and implementing
    its `run()` method. This `run()` method contains code that'll be run in a separate
    thread when we call `start()`. Note that we need to implement the `run()` method
    and not the `start()` method. The `start()` method is an internal method written
    in C that calls `run()` for us.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 一个任务由一个扩展基本`Thread`类并实现其`run()`方法的类来表示。这个`run()`方法包含在我们调用`start()`时将在单独的线程中运行的代码。注意，我们需要实现`run()`方法，而不是`start()`方法。`start()`方法是一个用C编写的内部方法，它会为我们调用`run()`。
- en: After we create and start each thread, we use the `join()` method, which blocks
    the current interpreter and waits until that particular thread finishes. If it's
    already finished, then it'll continue. By looping over all threads and calling
    `join()`, we effectively wait until all of them finish.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
- en: 'When we run this example, we''ll get the following result (you''ll get a different
    order since we''re using random sleep intervals):'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'We won''t go into much depth when using the `pthreads` extension in this chapter.
    There are primarily three reasons for this, as of April 2017:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
- en: '**Documentation on pthreads is very insufficient**: Documentation on most of
    the classes and methods in pthreads contains very little information. There''s
    at most one sentence, usually without any example, so it''s mostly up to the developer
    to guess what it does.'
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Documentation, examples, and other sources of information are often obsolete**:
    The new pthreads v3 works only with PHP7\. However, the official documentation
    at [http://php.net/manual/en/book.pthreads.php](http://php.net/manual/en/book.pthreads.php)
    covers only `pthreads` v2\. In the meantime, `pthreads` internals have changed,
    so you might be surprised that some examples won''t work at all. For example,
    the `Mutex` and `Cond` classes don''t exist at all now.'
  id: totrans-177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Documentation is non-existent**: The new classes coming with pthreads v3
    aren''t documented at all. The official homepage [https://github.com/krakjoe/pthreads](https://github.com/krakjoe/pthreads)
    mentions differences between the two versions, but doesn''t contain any information
    on how to effectively use them. For example, the PHP documentation found at [http://php.net/manual/en/book.pthreads.php](http://php.net/manual/en/book.pthreads.php)
    doesn''t mention the `Volatile` class at all.'
  id: totrans-178
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This all means that using pthreads is a pain at this moment, and getting any
    relevant information is hard.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
- en: There are also caveats regarding having multiple PHP contexts that need to share
    data while staying completely isolated. Since we need to be aware of these issues,
    it's worth spending some time explaining what this means for us.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
- en: Getting/setting data from/to threads
  id: totrans-181
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In PHP, all objects are passed by reference by default. Consider the following
    example, where we pass an instance of `stdClass` to another object, where we modify
    it:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: We created an instance of `stdClass` called `$obj`. Then we reassigned it to
    `$obj2` and compared the two with an identity operator (three equal signs `===`).
    Then we pass the `$obj` to an instance of `TestClass`, where we do the same and
    also add one more property to it called `prop2`.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
- en: 'The output from this example is what we might expect:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: All the variables reference the same object. This is what we're used to and
    what we're using in PHP all the time.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
- en: 'However, this can''t work with `pthreads`. We''re not allowed to share objects
    (memory addresses) among different PHP contexts. These have to always be isolated,
    which is the very basic premise for thread-safe execution. We can test this with
    a very simple example, following on from the previous one:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: In this example, we're using the identity operator to compare `$this->obj` with
    another variable that should be referencing the same object.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
- en: 'Now let''s see what happens when we run this example:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: All the comparisons return `false`. Even the most obvious one, `$this->obj ===
    $this->obj`, returns `false`.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
- en: In `pthreads`, it has to work like this because PHP interpreters are isolated,
    and thus all read and write operations from the parent and other contexts need
    to be performed via copying data. However, there's an exception to this rule.
    Classes coming from the `pthreads` extension (including all their descendants)
    aren't copied, and are just referenced, as we'll see in a later example.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
- en: So in this example, we actually copied the object multiple times. Every call
    to `$this->obj` made a copy to the current context, as well as to the last `$thread->objCopy`
    statement.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
- en: The consequence of this principle is that we have to gather results from threads
    manually; we can't just pass an object to its constructor that will be populated
    with results by the thread itself.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
- en: 'A modified version of the first example would look like this:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: This is basically the same demo as before; we're just storing results for each
    thread in a public property that we can later read after calling `join()`.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
- en: 'The output for this example is as follows:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Although creating threads is simple, if we had multiple threads it'd be hard
    to keep track of which threads are running and which are already finished. In
    real-world applications, it's usually not required to spawn many threads to be
    executed just once. Creating so many threads is inefficient and, most importantly,
    unnecessary.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
- en: Using Thread, Worker, and Pool classes
  id: totrans-203
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `Thread` class represents a single interpreter context and a single task.
    When we want to run the same task multiple times, we need to create multiple instances
    of the same class and then join all the results (to wait until they're done).
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
- en: There's also the `Worker` class. Similar to the `Thread` class, it represents
    a single interpreter context, but instead of doing a single job, it can stack
    jobs and execute them one after another.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
- en: 'We can take the previous `MyThread` class and this time we''ll execute all
    tasks on a single `Worker`:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Since we have a single interpreter context, all tasks will be executed one
    after another. With the call to `shutdown()`, we make the `Worker` class wait
    until all stacked tasks are done. We can also add tasks to the worker after it''s
    started the execution:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Note that tasks are run one after another and not in parallel.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
- en: 'We used the default `Worker` class provided by `pthreads`, but we can make
    our own class extending from `Worker` as well. For example, consider the following
    class:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: This class extends the `run()` method just like the `Thread` class. The `Worker`
    class's `run()` method, however, is called only once when initializing the PHP
    interpreter context, and allows us to set up the `Worker` class.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
- en: We can, of course, create multiple `Worker` instances and stack tasks on them,
    but handling which workers are available and which workers are busy would be tedious.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
- en: For this reason, `pthreads` have the `Pool` class. It can contain a number of
    workers and distribute tasks among them. We don't need to worry about selecting
    the correct worker, and can leave everything to the `Pool` class.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
- en: 'Now let''s consider the following example, where we''ll use a `Pool` of three
    `Worker` classes to perform six tasks in total:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Each `Task` instance makes a three-second-long sleep. Since we're using three
    `Worker` classes, we can run three tasks at the same time, so running this demo
    should take exactly six seconds. Just as we did with the `Worker` class, we call
    `shutdown()`, which waits until all the tasks are processed and then shuts down
    all the workers. This is like calling `join()` on each task.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
- en: 'The `Pool` class takes three arguments: the number of workers to run simultaneously,
    the `Worker` class name that it''ll instantiate (we can obviously use the default
    `Worker::class` as well), and an array of parameters passed to the `Worker` class''s
    constructor.'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
- en: 'The output from this example is as follows:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: The main difference from the developer's perspective is that we're scheduling
    six tasks to be executed on three threads. In our very first example of pthreads,
    we executed six tasks as well, but on six threads.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
- en: The general rule of thumb is to use as few threads as we need. Creating threads
    requires some resource allocations (mostly creating a new PHP interpreter), and
    with tasks that actually do some heavy computing, the code will reach a point
    where the creation of additional threads will no longer produce any performance
    benefit. It's very effective to run in parallel tasks that spend most of their
    time waiting, such as system calls, or downloading data via HTTP. We can create
    many threads for these tasks, and they will all run in parallel and won't require
    practically any CPU time.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
- en: On the other hand, if we had tasks that do require CPU time, then at some point
    adding more threads won't have any effect because there will be no more CPUs/cores
    to run the interpreters, so it'll need to switch from one execution context to
    another. All the threads will run in parallel, but it'll take a long time to finish
    all of them. Whether it's worth it or not depends on what we want to achieve,
    but usually it's better to use a lower number of threads and execute tasks in
    smaller chunks.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-225
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A good number of threads for computationally intensive tasks is usually calculated
    as *(number of CPUs) * (number of cores per CPU)*.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
- en: So this is why we might want to use the `Pool` class. Also, an important aspect
    we haven't seen in the previous example is how we can grab results from the finished
    tasks.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
- en: Retrieving results from thread pools
  id: totrans-228
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The easiest way to get processed data from threads is by keeping their references
    and then iterating them to get results. The most obvious example could look like
    the following:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: This is very simple and works as expected. However, it's not very practical.
    We used the `shutdown()` method to wait for all scheduled tasks to finish and
    then collected all the results from all threads. This would get more complicated
    if we didn't want to wait until all threads have finished and wanted to collect
    results as they're ready. We'd have to go back to something like an event loop
    that periodically checks all threads for their results.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
- en: Of course this is doable, but pthreads proposes another and more elegant way
    of doing this.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
- en: For this reason, the `Pool` class has a method called `collect()`. This method
    takes as an argument a callable that is called on every thread. This callable
    has to decide whether the thread has already finished or not. If it is finished,
    we can grab its result right inside the callable and return `true`, which means
    this thread can be disposed.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
- en: 'Unfortunately, there''s one large BUT. In the current pthreads v3, the behavior
    of `Pool::collect()` has most likely changed. In most examples, you''ll see the
    `collect()` method being used as follows:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: This example is using an anonymous class (a PHP7 feature) to extend `Thread`
    to represent a single task.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
- en: Although this example seems simple and is used in many resources (including
    the [stackoverflow.com](http://stackoverflow.com) answers by the author of pthreads),
    it doesn't collect all the results. We wanted to include this example here to
    show how it should work and most likely will work in the updated version of pthread.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
- en: 'The output of PHP7 and pthreads v3 looks like the following (you''ll probably
    get these lines in a different order):'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: As you can see, the last three threads weren't collected at all.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
- en: 'There are a couple of possible reasons why this doesn''t work:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
- en: With prior versions of pthreads, we had to extend the `Collectable` class instead
    of the `Thread` class. The `Collectable` class used to be a class originally,
    but this has changed, and it's now an interface. This change is documented on
    the pthreads readme page ( [https://github.com/krakjoe/pthreads#php7](https://github.com/krakjoe/pthreads#php7)
    ). Now, the `Thread` class implements `Collectable` automatically. In most resources,
    you'll find `Collectable` used as a class.
  id: totrans-242
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The official documentation on `Pool::collect()` is insufficient. It doesn't
    mention at all that the callables need to return `Boolean` determining whether
    the thread should be disposed. Also, the documentation is for the older `pthreads`
    v2 where the `collect()` method is said to return void. This is not (or maybe
    never was) true since it's always used in a `while` loop (see [http://stackoverflow.com/questions/28416842/how-does-poolcollect-works](http://stackoverflow.com/questions/28416842/how-does-poolcollect-works) or
    [https://gist.github.com/krakjoe/9384409](https://gist.github.com/krakjoe/9384409)).
  id: totrans-243
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Changes to `Pool::collect()` are mentioned in the official readme at [https://github.com/krakjoe/pthreads#php7](https://github.com/krakjoe/pthreads#php7)
    . Quote: "*The `Pool::collect` mechanism was moved from `Pool` to `Worker` for
    a more robust `Worker` and simpler `Pool` inheritance.*" What this means remains
    a mystery.'
  id: totrans-244
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In some examples, you'll see developers extending the `Pool` class and looping
    with `while (count($this->work))`. This was probably meant to loop while there
    is work scheduled. In pthreads v3, the `work` property doesn't exist on the `Pool`
    class. The official readme page listing the breaking changes we mentioned already
    has no record of this change.
  id: totrans-245
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: So our biggest problem is the lack of any reliable information.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
- en: It looks desperate, but there is, in fact, a sane way of collecting all the
    results. We'll make use of yet another undocumented class called `Volatile` and
    pass it to all our threads. As we said earlier when talking about sharing data
    between interpreter contexts, all data needs to be copied. In contrast, classes
    coming from the pthreads extension (and all classes extending them) are referenced
    directly, and we're going to use this to our advantage.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s have a look at this example using the `Volatile` class to collect the
    results from the threads:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: The first part looks very familiar. We created a class extending the `Thread`
    class, and then an instance of `Pool` where we'll schedule four tasks. Each task
    in its constructor takes the same instance of `Volatile`. That's the object where
    we'll append results for all our threads.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
- en: 'With the `Volatile` class, we''re also using three new methods that are useful
    only when executing multithreaded code where we need some sort of synchronization
    between threads:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
- en: '`synchronized()`: This method runs the callable while holding the access lock
    for this object. We need to use this method in our example to be sure that only
    one thread is able to append results at a time. Note that the pthreads are using
    POSIX threads underneath, so the operator `[]` is not an atomic operation at all.
    If we didn''t use locks, then multiple threads might try to modify the resulting
    array, which would lead to completely unpredictable behavior.'
  id: totrans-252
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`wait()`: This method makes the current interpreter context wait until `notify()`
    is called on the same object (it''s a blocking operation). Note that calling `wait()`
    will release the access lock while it is waiting, and then it''ll be reacquired
    after awakening with `notify()`. Therefore, this method needs to be called inside
    `synchronized()`.'
  id: totrans-253
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`notify()`: This method wakes the waiting interpreter context after calling
    the `wait()` method.'
  id: totrans-254
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using `wait()` and `notify()` might be very dangerous if used inappropriately.
    If the thread containing `notify()` called this method before the first thread
    arrived at `wait()`, then the first context would be stuck at `wait()` forever
    because there'd be no other `notify()` call to awaken it.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
- en: So we run `wait()` calls in a loop because we know that only one thread can
    acquire the lock, and therefore each thread will append to `$results` one after
    the other.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
- en: All threads will share the same reference to `Volatile` because, as we said,
    it's a class from the pthreads extension (or its derivate extending the `Threaded`
    class), so it won't be copied on read/write attempts.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
- en: 'When we run this example, we''ll get the expected output:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Note one last thing. When appending our results, we used the following line:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: We're using typecasting with `(array)`, which seems redundant. In fact, we have
    to do this in order not to lose the reference to this array. When setting an array
    to a property of the `Thread` class, it's automatically converted into a `Volatile`
    object unless we typecast it beforehand to an array. Without typecasting, the
    `Volatile` object representing the array would be deallocated when this context
    is shut down, so we need to force typecast it to an array in order to be copied.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
- en: 'There''s actually one more solution to the problem described above with `Pool` 
    class not collection all results correctly (although this solution is not as elegant
    as using `synchronized()` methods). Instead of using the `collect()` method to
    control how long we want to run the while loop, we can manually count the threads
    that have finished, in a similar way to the following example:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: Now the responsibility to run the while loop as long as necessary lies on us
    and not the `collect()` method (that might be bugged).
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
- en: When we run this example with the same anonymous class instances as shown previously,
    we'll correctly collect all the results.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: RxPHP and pthreads
  id: totrans-268
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A good question is how is all this about pthreads related to RxPHP and to Rx
    in general.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
- en: In PHP, we're typically not used to work with asynchronous tasks and if we do,
    the implementation details are well hidden from us. This is for example the case
    with event loops and RxPHP, where we don't need to care what's going on inside
    RxPHP classes under the hood.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we'd like to achieve the same state where we'll have a
    general purpose Observable or an operator that runs tasks in parallel using pthreads.
    Since working with asynchronous code in RxPHP is easy, pthreads is a perfect candidate
    that could add very interesting functionality which can be easily reused anywhere.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-272
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we went through two larger topics. We'll use both of them in
    the next chapter, where we'll write multithreaded applications with pthreads,
    as well as distributed applications with Gearman.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
- en: The two topics we covered were multicasting in RxPHP and all operators related
    to it, and using the PHP7 pthreads v3 extension to write multithreaded PHP7 applications.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
- en: Multicasting in Rx is very useful in order to share a single connection to source
    Observables without resubscribing. This comes with the `refCount()` operator to
    work more easily with `ConnectableObservables`.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
- en: Multithreaded programming in PHP is possible with the pthreads extension. However,
    it's not as simple as it seems, and there are multiple caveats, most importantly
    insufficient documentation and an overall unintuitive approach. In the next chapter,
    we'll use just the most basic functions from pthreads to avoid confusion and eventual
    inconsistency with future updates of pthreads. The goal for the next chapter is
    to write an extendable code quality tool, based on the `nikic/php-parser` project
    ( [https://github.com/nikic/PHP-Parser](https://github.com/nikic/PHP-Parser) ),
    which will allow adding custom rules using RxPHP operator chains. We'll base the
    application on what we've covered in this chapter.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
