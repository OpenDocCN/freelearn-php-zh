- en: Chapter 8. Multicasting in RxPHP and PHP7 pthreads Extension
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To make use of multiple CPUs and multiple cores, we've been using subprocesses.
    This is, of course, a very easy and safe method to run code in parallel. In combination
    with Unix sockets, we can make inter-process communication happen with ease. In
    the previous chapter, we combined all of this with RxPHP to make applications
    that were completely separated and run in parallel.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we'll have a look at a very interesting PHP7 extension called
    `pthreads`, which allows multithreading in PHP using POSIX threads.
  prefs: []
  type: TYPE_NORMAL
- en: 'In particular, this chapter will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: A deeper look into the `Subject` class and its variants.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Multicasting operators in RxPHP and all its derivatives
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Examples of `ConnectableObservable` and `MulticastObservable`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using a single instance of the Subject with multiple source Observables
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Basics of multithreading in PHP
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Notes on today's state of the `pthreads` extension, its two major versions,
    and its current practical usage
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Writing a couple of multithreaded applications with the `pthreads` extension
    that'll demonstrate how to use the `Thread`, `Worker`, and `Poll` classes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Before we go parallel, we should have a look at yet another feature of Reactive
    Extensions called multicasting, which involves the `multicast()` operator and
    its derivates. Multicasting is build around Subjects so let's first have a better
    look at what different types of Subject are available to us.
  prefs: []
  type: TYPE_NORMAL
- en: Subjects
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We've been using Subjects in this book since [Chapter 2](part0024_split_000.html#MSDG2-bd355a22cf10407cb10df27e65585b8d
    "Chapter 2. Reactive Programming with RxPHP"), *Reactive Programming with RxPHP*,
    but there're multiple different variants of the `Subject` class for more specific
    use cases where all of them are relevant to multicasting.
  prefs: []
  type: TYPE_NORMAL
- en: BehaviorSubject
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `BehaviorSubject` class extends the default `Subject` class and lets us
    set a default value that is passed to its observer right on subscription. Consider
    this very simple example of `BehaviorSubject`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: When `DebugSubject` subscribes to the `BehaviorSubject` class, the default value
    `42` is emitted immediately. This is a similar functionality to using the `startWith()`
    operator.
  prefs: []
  type: TYPE_NORMAL
- en: 'The output is then just a single line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: ReplaySubject
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `ReplaySubject` class internally contains an array of the last *N* values
    it received and automatically re-emits them to every new observer on subscription.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following example, we subscribe to `RangeObservable`, which immediately
    emits all its values to the `ReplaySubject` class. The last three values are always
    stored in an array and when we later subscribe with the `DebugSubject` class,
    it''ll immediately receive all three of them:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'The output consists of the last three values that the `ReplaySubject` class
    received:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Notice, that we also received the `complete` signal, which is correct because
    it was emitted by `RangeObservable`.
  prefs: []
  type: TYPE_NORMAL
- en: AsyncSubject
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The last Subject type RxPHP offers out of the box is called `AsyncSubject`,
    which might seem a little confusing. The only thing this Subject does is that
    it emits only the last value it received before receiving the `complete` signal.
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ll demonstrate this Subject on a similar example to the previous one. We''ll
    just switch the order of actions and we''ll subscribe the `DebugSubject` class
    before subscribing to the source Observable to see that it silently suppresses
    all values except the last one:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is only the last value emitted by the source `RangeObservable`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Now we know everything we need to start working with multicasting and the `multicast()`
    operator in particular.
  prefs: []
  type: TYPE_NORMAL
- en: Multicasting in RxPHP
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In Reactive Extensions, multicasting means sharing a single subscription among
    multiple observers via an instance of a `Subject` class. All multicasting operators
    are internally based on the general `multicast()` operator that implements their
    most common functionality. Of course, we're not limited to only using the `Subject`
    class and we'll use `ReplaySubject` and `BehaviorSubject` as well.
  prefs: []
  type: TYPE_NORMAL
- en: Multicasting is common to all Rx implementations, so knowledge of how it works
    inside is generally useful.
  prefs: []
  type: TYPE_NORMAL
- en: The multicast() operator and ConnectableObservable
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `multicast()` operator returns `ConnectableObservable` or `MulticastObservable`
    based on what arguments we pass. We'll first have a look at how it works with
    `ConnectableObservable`, because this should be very familiar to us.
  prefs: []
  type: TYPE_NORMAL
- en: 'A typical use case could look like the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Instead of instantiating `ConnectableObservable`, we used the `multicast()`
    operator to do it for us.
  prefs: []
  type: TYPE_NORMAL
- en: In this example, we created a single source Observable and subscribed two observers
    to it. Then, after calling `connect()`, the `ConnectableObservable` class subscribed
    to an instance of `AnonymousObservable` returned from the `Observable::defer`
    static method.
  prefs: []
  type: TYPE_NORMAL
- en: 'As we can see, the `multicast()` operator returns an instance of `ConnectableObservable`.
    The result from this example is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: All observers subscribe to the same instance of the Subject that we passed.
    This is an important implication that we need to be aware of.
  prefs: []
  type: TYPE_NORMAL
- en: In a moment, we'll have a look at a slightly modified version of this example
    that passes different arguments to `multicast()`.
  prefs: []
  type: TYPE_NORMAL
- en: MulticastObservable
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Another Observable used for multicasting is called `MulticastObservable`. Its
    usage is similar to `ConnectableObservable`, but its internal functionality is
    very different. Consider the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: When subscribing to `MulticastObservable`, it internally calls the `multicast()`
    operator on the source Observable (which returns `ConnectableObservable`, as we
    saw in the previous example) and runs the first callable to create an instance
    of the `Subject` class. This is the first major difference to using just `multicast()`,
    where we always shared the same instance of the `Subject` class. The `MulticastObservable`,
    in contrast, creates a new `Subject` for every subscriber.
  prefs: []
  type: TYPE_NORMAL
- en: So internally, we have an instance of `ConnectableObservable`. Then it calls
    the second callable with this `ConnectableObservable` passed as an argument, which
    means we can further chain operators to it, or we could even use a completely
    different Observable (just remember this method has to return an Observable because
    the operator will internally subscribe to it).
  prefs: []
  type: TYPE_NORMAL
- en: This callable is often called the **selector function** because it lets us select
    where we want to subscribe. After that, `MulticastObservable` subscribes to the
    Observable returned and calls the `connect()` method on the `ConnectableObservable`.
  prefs: []
  type: TYPE_NORMAL
- en: In our example, we create a new instance of the `Subject` class for every subscriber
    and then chain `startWith()` with the `ConnectableObservable`, which makes it
    emit a single value before emitting values from the source.
  prefs: []
  type: TYPE_NORMAL
- en: 'The output will look like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Note that the deferred Observable was called twice, which is correct. Each observer
    has its own instances of the Subject and `ConnectableObservable`. We have full
    control of what Subjects we're using for multicasting instead of leaving it to
    the default `multicast()` behavior.
  prefs: []
  type: TYPE_NORMAL
- en: The question is, why does it matter whether we're using the same instance of
    the Subject or not?
  prefs: []
  type: TYPE_NORMAL
- en: Subjects and their internal state
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We know how to use Subjects. We also know what the `next`, `complete`, and
    `error` signals do. So what happens if we use a single `Subject` and subscribe
    to a cold Observable multiple times? Consider the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: We'll run this example and talk about what happens inside the `Subject` instance.
    Note that we subscribed to the `Subject` twice where the first observer (represented
    by `DebugSubject`) receives the first three values and then emits the `complete`
    signal.
  prefs: []
  type: TYPE_NORMAL
- en: However, what happens with the second observer?
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: The second observer received just the `complete` signal, and none of the observers
    received the value `4`.
  prefs: []
  type: TYPE_NORMAL
- en: 'It''s very important to understand what happens internally inside a `Subject`
    class when it receives a `complete` signal (this means it receives a `complete`
    signal or we call the `onCompleted()` method manually):'
  prefs: []
  type: TYPE_NORMAL
- en: The `Subject` class checks whether it's already been marked as stopped. If it
    has, then the method returns immediately. If it's not stopped, then it marks itself
    as stopped.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The complete signals are then sent to all observers.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The array of observers is emptied.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: So now it should make sense. The first three values were emitted as usual. Then
    we called `onComplete()`, which did exactly what we described in these bullet
    points. At this point, this `Subject` instance has no observers (see step 4).
    Then we subscribe with another observer, which is added to the array of observers.
    This observer immediately receives a `complete` signal because the Subject is
    already stopped and didn't end with an error.
  prefs: []
  type: TYPE_NORMAL
- en: At this point, calling `onNext(4)` does nothing because the `Subject` instance
    is already stopped (see step 1).
  prefs: []
  type: TYPE_NORMAL
- en: This principle might be a problem in situations where we purposely want to defer
    creating Observables with, for example, the `Observable::defer` static method
    that will be called multiple times. Once it sends the `complete` signal, all consecutive
    values will be ignored by the `Subject` instance for the reasons we explained.
    We'll have another example featuring this issue later in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: This is a very important principle we need to be aware of when using `multicast()`
    operators and the `ConnectableObservable`.
  prefs: []
  type: TYPE_NORMAL
- en: Whether this applies to `MulticastObservable` is up to us, depending on what
    we return from its first callable. We can use the same instance of `Subject` or
    we can create a new one depending on what we want to achieve.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If this all looks confusing, just remember that Subjects have an internal state.
    When they receive `complete` or `error` notification, they'll never re-emit any
    value further.
  prefs: []
  type: TYPE_NORMAL
- en: The multicast() operator and MulticastObservable
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: So let's go back to the `multicast()` operator and see how `MulticastObservable`
    is related to all this. We said that `multicast()` returns `ConnectableObservable`
    or `MulticastObservable` depending on the arguments we use. This is true when
    we use the second argument to `multicast()`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider the following example, where we also pass a selector function to the
    `multicast()` operator:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'If we use the second argument to `multicast()`, it wraps the `$subject` variable
    with a callable before it''s passed to `MulticastObservable`. In fact, `multicast()`
    is internally implemented as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: This always guarantees that we're using the same `Subject`. The only thing that
    decides which Observable we'll receive is whether we use the selector function
    or not. The preceding example also adds the `startWith()` and `concat()` operators
    to see what effect this selector function can have.
  prefs: []
  type: TYPE_NORMAL
- en: 'The output for this example is affected by the issue we showed earlier:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: The second subscriber hasn't received any value, even though we subscribed twice
    to the source Observable.
  prefs: []
  type: TYPE_NORMAL
- en: Comparing ConnectableObservable and MulticastObservable
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To be extra clear about the difference between these two use cases and `ConnectableObservable`
    and `MulticastObservable`, let''s have a look at these two diagrams:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Comparing ConnectableObservable and MulticastObservable](img/00030.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Diagram representing a ConnectableObservable with two observers
  prefs: []
  type: TYPE_NORMAL
- en: In this diagram, we have a single `ConnectableObservable` that internally contains
    one `Subject`. Both observers are subscribed to the same `Subject`.
  prefs: []
  type: TYPE_NORMAL
- en: 'On the other hand, with `MulticastObservable` we''ll get the following structure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Comparing ConnectableObservable and MulticastObservable](img/00031.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Diagram representing a MulticastObservable with two observers
  prefs: []
  type: TYPE_NORMAL
- en: The two `ConnectableObservables` inside the grey boxes mean we have no control
    over them (these are created automatically by the internal `multicast()` call,
    as mentioned earlier).
  prefs: []
  type: TYPE_NORMAL
- en: As we can see from the examples, with `MulticastObservable` created via the
    `multicast()` call, we won't be able to achieve the same result as we see in this
    image because `multicast()` always forces us to use a single Subject instance.
    Of course, we could always create an instance of `MulticastObservable` ourselves,
    as we saw earlier in this chapter, but there's also an operator for this purpose
    that we can use.
  prefs: []
  type: TYPE_NORMAL
- en: The multicastWithSelector() operator
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To simplify creating instances of `MulticastObservable`, we have the `multicastWithSelector()`
    operator, which takes two callables as arguments that have the same purpose as
    calling `MulticastObservable` itself.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: This example illustrates the diagram we saw previously. We have two observers
    where each has its own instance of `Subject`. We also made use of the selector
    function that appends a `concat` string at the end of the chain.
  prefs: []
  type: TYPE_NORMAL
- en: 'The output is then easily predictable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: This was an introduction to multicasting in Rx and the `multicast()` operator
    in RxPHP. Since there're a few other operators based on `multicast()`, we'll talk
    about them now when we know how `multicast()` behaves internally.
  prefs: []
  type: TYPE_NORMAL
- en: The publish*() and share*() operator groups
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There''re multiple other operators internally using the `multicast()` operator,
    and we can split them into two basic groups:'
  prefs: []
  type: TYPE_NORMAL
- en: '`publish*()`: Operators starting with the word "publish" wrap the `multicast()`
    operator and call it with one of the `Subject` classes. All `publish*` variants
    accept an optional argument, which is the selector function that we talked about
    earlier. Therefore, all of them can return `ConnectableObservable` or `MulticastObservable`
    just like `multicast()`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`share*()`: Operators starting with the word "share" internally use the same
    `publish*` equivalent and chain it with the `refCount()` operator. All `share*`
    operators don''t allow any selector function.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To understand the difference between the two groups, we need to first understand
    what the `refCount()` operator is.
  prefs: []
  type: TYPE_NORMAL
- en: The refCount() operator
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We already know this very basic usage of `ConnectableObservable`. Let''s consider
    the following example, and first see how we can call the `connect()` method manually
    and then switch to the `refCount()` operator:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: This is simple. We have two observers subscribed to the `ConnectableObservable`
    waiting to call `connect()`, which subscribes to the source Observable (in this
    case `AnonymousObservable` with a custom subscribe function) and emits all values
    to both observers at the same time.
  prefs: []
  type: TYPE_NORMAL
- en: 'Note that we''re purposely not using `RangeObservable` because we don''t want
    to emit the `complete` signal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: This is pretty simple, but we had to call `connect()` ourselves, which is sometimes
    alright. However, other times we can leave this logic to the `refCount()` operator.
  prefs: []
  type: TYPE_NORMAL
- en: Well, actually it's not an operator (it's not lifted to an Observable chain
    with the `lift()` method). It's just a method on `ConnectableObservable` that
    returns an instance of `RefCountObservable`.
  prefs: []
  type: TYPE_NORMAL
- en: This Observable internally subscribes and unsubscribes to the source Observable.
    When the first observer subscribes, it also calls `connect()` on the `ConnectableObservable`.
    Then when another observer subscribes, it does nothing because we've already subscribed.
    When unsubscribing, the procedure is exactly the opposite. If even the last observer
    unsubscribes, then `RefCountObservable` also unsubscribes the `ConnectableObservable`.
  prefs: []
  type: TYPE_NORMAL
- en: 'This has some interesting consequences. We can use `refCount()` to automatically
    subscribe when there''s at least one observer, as we can see in this example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'We have two observers again, but this time we''re not calling `connect()` by
    ourselves. Instead, we''re using `refCount()` to call the `connect()` method for
    us. Since we''re sharing the same subscription to the source, only the first observer
    will receive values. The second observer doesn''t cause another subscription to
    the source (as we can see from the preceding explanation):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'However, if we unsubscribe after receiving values for the first observer (which
    causes unsubscription from `ConnectableObservable` inside `RefCountObservable`)
    and then subscribe again with the second observer, it''ll make the source emit
    all its values because we have subscribed to it again:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: When we called `dispose()`, we made `RefCountObservable` unsubscribe from its
    source because there are no more observers.
  prefs: []
  type: TYPE_NORMAL
- en: 'This example prints all values twice:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Of course, we need to be sure we don't stop the inner `Subject` in `ConnectableObservable`
    as we talked about before. The `ConnectableObservable` class uses a single instance
    of `Subject`, so if it received a complete signal, then no unsubscription or subscription
    would change this.
  prefs: []
  type: TYPE_NORMAL
- en: The publish() and share() operators
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now we know what the `multicast()` and `refCount()` operators do, we can finally
    understand what `publish()` and `share()` do.
  prefs: []
  type: TYPE_NORMAL
- en: 'Using `publish()` is just a shortcut to calling `multicast()` with the `Subject`
    instance as a parameter. If we rewrote the very first example on the `multicast()`
    operator, it would look almost the same:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: The output for this demo is exactly the same as for `multicast_01.php`, so we
    don't need to reprint it here.
  prefs: []
  type: TYPE_NORMAL
- en: The `share()` Operator uses the `publish()->refCount()` chain internally, so
    we don't need to call `connect()` any more. However, the output is not the same.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `RangeObservable` sent the complete signal, which marked the internal `Subject`
    in `ConnectableObservable` as stopped, so the second observer won''t receive anything
    except the `complete` signal that is emitted by the `Subject` class right at the
    point of subscription (it''s not emitted by the source Observable):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'From the output, we can see that the source Observable is really created just
    once:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: These two basic operators have many variants, but are based on the same principle.
  prefs: []
  type: TYPE_NORMAL
- en: The publishValue() and shareValue() operators
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: These operators are based on `BehaviorSubject` instead of just `Subject`. The
    principle is then exactly the same. The `publishValue()` operator calls `multicast()`
    with an instance of `BehaviorSubject`. Then the `shareValue()` operator calls
    `publishValue()->refCount()`.
  prefs: []
  type: TYPE_NORMAL
- en: Using `BehaviorSubject` allows us to set the default value that is emitted to
    all observers when they subscribe.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can test this operator on the same example as before:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'The output always starts with the default string because it''s emitted by `BehaviorSubject`
    as the first value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Using `shareValue()` is the same as using `share()`, so we don't need to include
    it here.
  prefs: []
  type: TYPE_NORMAL
- en: The replay(), shareReplay(), and publishLast() operators
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: All these share exactly the same principle as the previous two operators, just
    based on `ReplaySubject` (`replay()` and `shareReplay()`) or `AsyncSubject` (the `publishLast()`
    operator).
  prefs: []
  type: TYPE_NORMAL
- en: We don't need to include examples for those operators here because there would
    be nothing new for us to see.
  prefs: []
  type: TYPE_NORMAL
- en: PHP pthreads extension
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Since the year 2000, PHP can be compiled as **thread safe**, which allows any
    process to run multiple instances of the PHP interpreter in multiple threads (one
    thread per PHP interpreter). Each PHP interpreter has its own isolated context
    which doesn't share any data (the "share nothing" philosophy) with others.
  prefs: []
  type: TYPE_NORMAL
- en: This is commonly used in web servers such as Apache (depending on its modules).
    Apache creates multiple subprocesses where each subprocess runs multiple threads
    with multiple PHP interpreters. Running interpreters in threads instead of subprocesses
    has its advantages and disadvantages.
  prefs: []
  type: TYPE_NORMAL
- en: Creating only threads is significantly faster and doesn't consume as much memory
    as creating subprocesses.
  prefs: []
  type: TYPE_NORMAL
- en: An obvious disadvantage is isolation. Even though all PHP interpreters run independently
    in threads, if any of them causes, for example, a "segmentation fault" error,
    then the entire process and all of its threads are terminated immediately. This
    even includes threads that didn't cause any error and that might be processing
    an HTTP request from another client at that moment.
  prefs: []
  type: TYPE_NORMAL
- en: This so-called **Server API** (**SAPI**) isn't very helpful to us. We need to
    be able to run our own pieces of code in threads ("user land multithreading").
    The PHP extension pthreads is an object-oriented API that does exactly this. It
    takes our code and creates a new PHP interpreter, which then starts executing
    it.
  prefs: []
  type: TYPE_NORMAL
- en: Note that the PHP pthreads are based on POSIX threads, which means that when
    we create a thread using pthreads, we're creating a real thread and not forking
    or creating subprocesses underneath.
  prefs: []
  type: TYPE_NORMAL
- en: In some languages, such as Python, there are threads that behave like they're
    executing code in parallel, but in fact there's still just one single threaded
    Python interpreter switching from one "thread" to another. So there's no real
    parallelism.
  prefs: []
  type: TYPE_NORMAL
- en: However, PHP `pthreads` come with a cost, and it's important to understand at
    least a little of what's going on inside.
  prefs: []
  type: TYPE_NORMAL
- en: Prerequisites
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this chapter, we'll use the new `pthreads` v3, which means we need to use
    PHP7+. There's also the older `pthreads` v2, which is designed for PHP5\. Since
    there are major differences in the internal implementations with these two versions,
    we'll stick only to the new one.
  prefs: []
  type: TYPE_NORMAL
- en: As we said earlier, in order to use the `pthreads` extension, PHP has to be
    compiled with the **Thread Safety** option enabled. This needs to be enabled when
    compiling PHP and can't be enabled later (if you're only downloading the PHP executable,
    make sure you're downloading the correct one, usually marked as ZTS).
  prefs: []
  type: TYPE_NORMAL
- en: 'A universal way to install `pthreads` is with the PECL tool, which should work
    on all platforms:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Alternatively, if you''re running OS X, you can use a homebrew tool that also
    enables it in PHP config files for you:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The current pthreads v3 can be enabled only when running PHP code in a standalone
    script. This means pthreads can't be part of any PHP application ran using for
    example `php-fpm`. In other words, we can use pthreads only in console applications
    and not it web applications.
  prefs: []
  type: TYPE_NORMAL
- en: Introduction to multithreading with pthreads in PHP7
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The most basic example of pthreads in PHP can simply be the spawning of multiple
    threads and printing their results. We''ll make random pauses with `sleep()` functions
    to simulate multiple long running tasks. Remember that in PHP the `sleep()` function
    is always blocking (it blocks the interpreter execution for a certain number of
    seconds):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: A task is represented by a class extending the base `Thread` class and implementing
    its `run()` method. This `run()` method contains code that'll be run in a separate
    thread when we call `start()`. Note that we need to implement the `run()` method
    and not the `start()` method. The `start()` method is an internal method written
    in C that calls `run()` for us.
  prefs: []
  type: TYPE_NORMAL
- en: After we create and start each thread, we use the `join()` method, which blocks
    the current interpreter and waits until that particular thread finishes. If it's
    already finished, then it'll continue. By looping over all threads and calling
    `join()`, we effectively wait until all of them finish.
  prefs: []
  type: TYPE_NORMAL
- en: 'When we run this example, we''ll get the following result (you''ll get a different
    order since we''re using random sleep intervals):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'We won''t go into much depth when using the `pthreads` extension in this chapter.
    There are primarily three reasons for this, as of April 2017:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Documentation on pthreads is very insufficient**: Documentation on most of
    the classes and methods in pthreads contains very little information. There''s
    at most one sentence, usually without any example, so it''s mostly up to the developer
    to guess what it does.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Documentation, examples, and other sources of information are often obsolete**:
    The new pthreads v3 works only with PHP7\. However, the official documentation
    at [http://php.net/manual/en/book.pthreads.php](http://php.net/manual/en/book.pthreads.php)
    covers only `pthreads` v2\. In the meantime, `pthreads` internals have changed,
    so you might be surprised that some examples won''t work at all. For example,
    the `Mutex` and `Cond` classes don''t exist at all now.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Documentation is non-existent**: The new classes coming with pthreads v3
    aren''t documented at all. The official homepage [https://github.com/krakjoe/pthreads](https://github.com/krakjoe/pthreads)
    mentions differences between the two versions, but doesn''t contain any information
    on how to effectively use them. For example, the PHP documentation found at [http://php.net/manual/en/book.pthreads.php](http://php.net/manual/en/book.pthreads.php)
    doesn''t mention the `Volatile` class at all.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This all means that using pthreads is a pain at this moment, and getting any
    relevant information is hard.
  prefs: []
  type: TYPE_NORMAL
- en: There are also caveats regarding having multiple PHP contexts that need to share
    data while staying completely isolated. Since we need to be aware of these issues,
    it's worth spending some time explaining what this means for us.
  prefs: []
  type: TYPE_NORMAL
- en: Getting/setting data from/to threads
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In PHP, all objects are passed by reference by default. Consider the following
    example, where we pass an instance of `stdClass` to another object, where we modify
    it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: We created an instance of `stdClass` called `$obj`. Then we reassigned it to
    `$obj2` and compared the two with an identity operator (three equal signs `===`).
    Then we pass the `$obj` to an instance of `TestClass`, where we do the same and
    also add one more property to it called `prop2`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The output from this example is what we might expect:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: All the variables reference the same object. This is what we're used to and
    what we're using in PHP all the time.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, this can''t work with `pthreads`. We''re not allowed to share objects
    (memory addresses) among different PHP contexts. These have to always be isolated,
    which is the very basic premise for thread-safe execution. We can test this with
    a very simple example, following on from the previous one:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: In this example, we're using the identity operator to compare `$this->obj` with
    another variable that should be referencing the same object.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now let''s see what happens when we run this example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: All the comparisons return `false`. Even the most obvious one, `$this->obj ===
    $this->obj`, returns `false`.
  prefs: []
  type: TYPE_NORMAL
- en: In `pthreads`, it has to work like this because PHP interpreters are isolated,
    and thus all read and write operations from the parent and other contexts need
    to be performed via copying data. However, there's an exception to this rule.
    Classes coming from the `pthreads` extension (including all their descendants)
    aren't copied, and are just referenced, as we'll see in a later example.
  prefs: []
  type: TYPE_NORMAL
- en: So in this example, we actually copied the object multiple times. Every call
    to `$this->obj` made a copy to the current context, as well as to the last `$thread->objCopy`
    statement.
  prefs: []
  type: TYPE_NORMAL
- en: The consequence of this principle is that we have to gather results from threads
    manually; we can't just pass an object to its constructor that will be populated
    with results by the thread itself.
  prefs: []
  type: TYPE_NORMAL
- en: 'A modified version of the first example would look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: This is basically the same demo as before; we're just storing results for each
    thread in a public property that we can later read after calling `join()`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The output for this example is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: Although creating threads is simple, if we had multiple threads it'd be hard
    to keep track of which threads are running and which are already finished. In
    real-world applications, it's usually not required to spawn many threads to be
    executed just once. Creating so many threads is inefficient and, most importantly,
    unnecessary.
  prefs: []
  type: TYPE_NORMAL
- en: Using Thread, Worker, and Pool classes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `Thread` class represents a single interpreter context and a single task.
    When we want to run the same task multiple times, we need to create multiple instances
    of the same class and then join all the results (to wait until they're done).
  prefs: []
  type: TYPE_NORMAL
- en: There's also the `Worker` class. Similar to the `Thread` class, it represents
    a single interpreter context, but instead of doing a single job, it can stack
    jobs and execute them one after another.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can take the previous `MyThread` class and this time we''ll execute all
    tasks on a single `Worker`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'Since we have a single interpreter context, all tasks will be executed one
    after another. With the call to `shutdown()`, we make the `Worker` class wait
    until all stacked tasks are done. We can also add tasks to the worker after it''s
    started the execution:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: Note that tasks are run one after another and not in parallel.
  prefs: []
  type: TYPE_NORMAL
- en: 'We used the default `Worker` class provided by `pthreads`, but we can make
    our own class extending from `Worker` as well. For example, consider the following
    class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: This class extends the `run()` method just like the `Thread` class. The `Worker`
    class's `run()` method, however, is called only once when initializing the PHP
    interpreter context, and allows us to set up the `Worker` class.
  prefs: []
  type: TYPE_NORMAL
- en: We can, of course, create multiple `Worker` instances and stack tasks on them,
    but handling which workers are available and which workers are busy would be tedious.
  prefs: []
  type: TYPE_NORMAL
- en: For this reason, `pthreads` have the `Pool` class. It can contain a number of
    workers and distribute tasks among them. We don't need to worry about selecting
    the correct worker, and can leave everything to the `Pool` class.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now let''s consider the following example, where we''ll use a `Pool` of three
    `Worker` classes to perform six tasks in total:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: Each `Task` instance makes a three-second-long sleep. Since we're using three
    `Worker` classes, we can run three tasks at the same time, so running this demo
    should take exactly six seconds. Just as we did with the `Worker` class, we call
    `shutdown()`, which waits until all the tasks are processed and then shuts down
    all the workers. This is like calling `join()` on each task.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `Pool` class takes three arguments: the number of workers to run simultaneously,
    the `Worker` class name that it''ll instantiate (we can obviously use the default
    `Worker::class` as well), and an array of parameters passed to the `Worker` class''s
    constructor.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The output from this example is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: The main difference from the developer's perspective is that we're scheduling
    six tasks to be executed on three threads. In our very first example of pthreads,
    we executed six tasks as well, but on six threads.
  prefs: []
  type: TYPE_NORMAL
- en: The general rule of thumb is to use as few threads as we need. Creating threads
    requires some resource allocations (mostly creating a new PHP interpreter), and
    with tasks that actually do some heavy computing, the code will reach a point
    where the creation of additional threads will no longer produce any performance
    benefit. It's very effective to run in parallel tasks that spend most of their
    time waiting, such as system calls, or downloading data via HTTP. We can create
    many threads for these tasks, and they will all run in parallel and won't require
    practically any CPU time.
  prefs: []
  type: TYPE_NORMAL
- en: On the other hand, if we had tasks that do require CPU time, then at some point
    adding more threads won't have any effect because there will be no more CPUs/cores
    to run the interpreters, so it'll need to switch from one execution context to
    another. All the threads will run in parallel, but it'll take a long time to finish
    all of them. Whether it's worth it or not depends on what we want to achieve,
    but usually it's better to use a lower number of threads and execute tasks in
    smaller chunks.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A good number of threads for computationally intensive tasks is usually calculated
    as *(number of CPUs) * (number of cores per CPU)*.
  prefs: []
  type: TYPE_NORMAL
- en: So this is why we might want to use the `Pool` class. Also, an important aspect
    we haven't seen in the previous example is how we can grab results from the finished
    tasks.
  prefs: []
  type: TYPE_NORMAL
- en: Retrieving results from thread pools
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The easiest way to get processed data from threads is by keeping their references
    and then iterating them to get results. The most obvious example could look like
    the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: This is very simple and works as expected. However, it's not very practical.
    We used the `shutdown()` method to wait for all scheduled tasks to finish and
    then collected all the results from all threads. This would get more complicated
    if we didn't want to wait until all threads have finished and wanted to collect
    results as they're ready. We'd have to go back to something like an event loop
    that periodically checks all threads for their results.
  prefs: []
  type: TYPE_NORMAL
- en: Of course this is doable, but pthreads proposes another and more elegant way
    of doing this.
  prefs: []
  type: TYPE_NORMAL
- en: For this reason, the `Pool` class has a method called `collect()`. This method
    takes as an argument a callable that is called on every thread. This callable
    has to decide whether the thread has already finished or not. If it is finished,
    we can grab its result right inside the callable and return `true`, which means
    this thread can be disposed.
  prefs: []
  type: TYPE_NORMAL
- en: 'Unfortunately, there''s one large BUT. In the current pthreads v3, the behavior
    of `Pool::collect()` has most likely changed. In most examples, you''ll see the
    `collect()` method being used as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: This example is using an anonymous class (a PHP7 feature) to extend `Thread`
    to represent a single task.
  prefs: []
  type: TYPE_NORMAL
- en: Although this example seems simple and is used in many resources (including
    the [stackoverflow.com](http://stackoverflow.com) answers by the author of pthreads),
    it doesn't collect all the results. We wanted to include this example here to
    show how it should work and most likely will work in the updated version of pthread.
  prefs: []
  type: TYPE_NORMAL
- en: 'The output of PHP7 and pthreads v3 looks like the following (you''ll probably
    get these lines in a different order):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, the last three threads weren't collected at all.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are a couple of possible reasons why this doesn''t work:'
  prefs: []
  type: TYPE_NORMAL
- en: With prior versions of pthreads, we had to extend the `Collectable` class instead
    of the `Thread` class. The `Collectable` class used to be a class originally,
    but this has changed, and it's now an interface. This change is documented on
    the pthreads readme page ( [https://github.com/krakjoe/pthreads#php7](https://github.com/krakjoe/pthreads#php7)
    ). Now, the `Thread` class implements `Collectable` automatically. In most resources,
    you'll find `Collectable` used as a class.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The official documentation on `Pool::collect()` is insufficient. It doesn't
    mention at all that the callables need to return `Boolean` determining whether
    the thread should be disposed. Also, the documentation is for the older `pthreads`
    v2 where the `collect()` method is said to return void. This is not (or maybe
    never was) true since it's always used in a `while` loop (see [http://stackoverflow.com/questions/28416842/how-does-poolcollect-works](http://stackoverflow.com/questions/28416842/how-does-poolcollect-works) or
    [https://gist.github.com/krakjoe/9384409](https://gist.github.com/krakjoe/9384409)).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Changes to `Pool::collect()` are mentioned in the official readme at [https://github.com/krakjoe/pthreads#php7](https://github.com/krakjoe/pthreads#php7)
    . Quote: "*The `Pool::collect` mechanism was moved from `Pool` to `Worker` for
    a more robust `Worker` and simpler `Pool` inheritance.*" What this means remains
    a mystery.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In some examples, you'll see developers extending the `Pool` class and looping
    with `while (count($this->work))`. This was probably meant to loop while there
    is work scheduled. In pthreads v3, the `work` property doesn't exist on the `Pool`
    class. The official readme page listing the breaking changes we mentioned already
    has no record of this change.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: So our biggest problem is the lack of any reliable information.
  prefs: []
  type: TYPE_NORMAL
- en: It looks desperate, but there is, in fact, a sane way of collecting all the
    results. We'll make use of yet another undocumented class called `Volatile` and
    pass it to all our threads. As we said earlier when talking about sharing data
    between interpreter contexts, all data needs to be copied. In contrast, classes
    coming from the pthreads extension (and all classes extending them) are referenced
    directly, and we're going to use this to our advantage.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s have a look at this example using the `Volatile` class to collect the
    results from the threads:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: The first part looks very familiar. We created a class extending the `Thread`
    class, and then an instance of `Pool` where we'll schedule four tasks. Each task
    in its constructor takes the same instance of `Volatile`. That's the object where
    we'll append results for all our threads.
  prefs: []
  type: TYPE_NORMAL
- en: 'With the `Volatile` class, we''re also using three new methods that are useful
    only when executing multithreaded code where we need some sort of synchronization
    between threads:'
  prefs: []
  type: TYPE_NORMAL
- en: '`synchronized()`: This method runs the callable while holding the access lock
    for this object. We need to use this method in our example to be sure that only
    one thread is able to append results at a time. Note that the pthreads are using
    POSIX threads underneath, so the operator `[]` is not an atomic operation at all.
    If we didn''t use locks, then multiple threads might try to modify the resulting
    array, which would lead to completely unpredictable behavior.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`wait()`: This method makes the current interpreter context wait until `notify()`
    is called on the same object (it''s a blocking operation). Note that calling `wait()`
    will release the access lock while it is waiting, and then it''ll be reacquired
    after awakening with `notify()`. Therefore, this method needs to be called inside
    `synchronized()`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`notify()`: This method wakes the waiting interpreter context after calling
    the `wait()` method.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using `wait()` and `notify()` might be very dangerous if used inappropriately.
    If the thread containing `notify()` called this method before the first thread
    arrived at `wait()`, then the first context would be stuck at `wait()` forever
    because there'd be no other `notify()` call to awaken it.
  prefs: []
  type: TYPE_NORMAL
- en: So we run `wait()` calls in a loop because we know that only one thread can
    acquire the lock, and therefore each thread will append to `$results` one after
    the other.
  prefs: []
  type: TYPE_NORMAL
- en: All threads will share the same reference to `Volatile` because, as we said,
    it's a class from the pthreads extension (or its derivate extending the `Threaded`
    class), so it won't be copied on read/write attempts.
  prefs: []
  type: TYPE_NORMAL
- en: 'When we run this example, we''ll get the expected output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'Note one last thing. When appending our results, we used the following line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: We're using typecasting with `(array)`, which seems redundant. In fact, we have
    to do this in order not to lose the reference to this array. When setting an array
    to a property of the `Thread` class, it's automatically converted into a `Volatile`
    object unless we typecast it beforehand to an array. Without typecasting, the
    `Volatile` object representing the array would be deallocated when this context
    is shut down, so we need to force typecast it to an array in order to be copied.
  prefs: []
  type: TYPE_NORMAL
- en: 'There''s actually one more solution to the problem described above with `Pool` 
    class not collection all results correctly (although this solution is not as elegant
    as using `synchronized()` methods). Instead of using the `collect()` method to
    control how long we want to run the while loop, we can manually count the threads
    that have finished, in a similar way to the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: Now the responsibility to run the while loop as long as necessary lies on us
    and not the `collect()` method (that might be bugged).
  prefs: []
  type: TYPE_NORMAL
- en: When we run this example with the same anonymous class instances as shown previously,
    we'll correctly collect all the results.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: RxPHP and pthreads
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A good question is how is all this about pthreads related to RxPHP and to Rx
    in general.
  prefs: []
  type: TYPE_NORMAL
- en: In PHP, we're typically not used to work with asynchronous tasks and if we do,
    the implementation details are well hidden from us. This is for example the case
    with event loops and RxPHP, where we don't need to care what's going on inside
    RxPHP classes under the hood.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we'd like to achieve the same state where we'll have a
    general purpose Observable or an operator that runs tasks in parallel using pthreads.
    Since working with asynchronous code in RxPHP is easy, pthreads is a perfect candidate
    that could add very interesting functionality which can be easily reused anywhere.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we went through two larger topics. We'll use both of them in
    the next chapter, where we'll write multithreaded applications with pthreads,
    as well as distributed applications with Gearman.
  prefs: []
  type: TYPE_NORMAL
- en: The two topics we covered were multicasting in RxPHP and all operators related
    to it, and using the PHP7 pthreads v3 extension to write multithreaded PHP7 applications.
  prefs: []
  type: TYPE_NORMAL
- en: Multicasting in Rx is very useful in order to share a single connection to source
    Observables without resubscribing. This comes with the `refCount()` operator to
    work more easily with `ConnectableObservables`.
  prefs: []
  type: TYPE_NORMAL
- en: Multithreaded programming in PHP is possible with the pthreads extension. However,
    it's not as simple as it seems, and there are multiple caveats, most importantly
    insufficient documentation and an overall unintuitive approach. In the next chapter,
    we'll use just the most basic functions from pthreads to avoid confusion and eventual
    inconsistency with future updates of pthreads. The goal for the next chapter is
    to write an extendable code quality tool, based on the `nikic/php-parser` project
    ( [https://github.com/nikic/PHP-Parser](https://github.com/nikic/PHP-Parser) ),
    which will allow adding custom rules using RxPHP operator chains. We'll base the
    application on what we've covered in this chapter.
  prefs: []
  type: TYPE_NORMAL
