<html><head></head><body><div class="chapter" title="Chapter&#xA0;2.&#xA0;ORM and Data Collections"><div class="titlepage"><div><div><h1 class="title"><a id="ch02"/>Chapter 2. ORM and Data Collections</h1></div></div></div><p>Collections and models are the bread and butter of everyday Magento development. In this chapter, we will introduce the reader to the Magento ORM system, and we will learn how to work with data collections and the EAV system properly. As most modern systems, Magento implements an <a id="id82" class="indexterm"/>
<span class="strong"><strong>object-relational mapping</strong></span> (<span class="strong"><strong>ORM</strong></span>) system.</p><div class="blockquote"><blockquote class="blockquote"><p><span class="emphasis"><em>Object-relational mapping (ORM, O/RM, and O/R mapping) in computer software is a programming technique for converting data between incompatible type systems in object-oriented programming languages. This creates, in effect, a "virtual object database" that can be used from within the programming language.</em></span></p></blockquote></div><p>In this chapter, we will cover the following topics:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Magento Models</li><li class="listitem" style="list-style-type: disc">Anatomy of a Magento Data Model</li><li class="listitem" style="list-style-type: disc">EAV and EAV models </li><li class="listitem" style="list-style-type: disc">Working with Direct SQL queries</li></ul></div><p>We will also be working with several snippets of code to provide an easy framework to experiment and play around with Magento.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note05"/>Note</h3><p>The interactive examples in this chapter assume you are working either with the default Magento installation inside the VagrantBox or a Magento installation with sample data.</p></div></div><p>For this purpose, I have created the Magento IMC (Interactive Magento Console), which is a shell script specially created for this book and inspired by Ruby's IRB (Interactive Ruby Console). To get started, follow these steps:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">The first thing we will need to do is install the IMC<a id="id83" class="indexterm"/> to download the source files from <a class="ulink" href="https://github.com/amacgregor/mdg_imc">https://github.com/amacgregor/mdg_imc</a> and extract them under your Magento test installation. The IMC is a simple Magento shell script that will allow to test our code in real time.</li><li class="listitem">Once you extract the script, log into the shell of your VirtualBox.</li><li class="listitem">Next, we will need to navigate to our Magento root folder. If you are using the default vagrant box and installation provided, the root folder is located under <code class="literal">/srv/www/ce1720/public_html</code>. We navigate to it by running this command:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ cd /srv/www/ce1720/public_html</strong></span>
</pre></div></li><li class="listitem">Finally, we can start the IMC by running the following command:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ php shell/imc.php</strong></span>
</pre></div></li><li class="listitem">If everything is installed successfully, we will see a new line starting with <code class="literal">magento &gt;</code>.</li></ol></div><div class="section" title="Magento Model anatomy"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec17"/>Magento Model anatomy</h1></div></div></div><p>As we learned <a id="id84" class="indexterm"/>in the previous chapter, Magento data models are used to manipulate and access the data. The model layer is divided into two fundamental types, simple models and EAV:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Simple models</strong></span>: These <a id="id85" class="indexterm"/>model implementations are a simple mapping of one object to one table, meaning our object attributes match each field and our table structure.</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Entity Attribute Value models</strong></span>: This <a id="id86" class="indexterm"/>type of models, known as EAV models, are used to describe entities with a dynamic number of attributes.</li></ul></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note06"/>Note</h3><p>It is important to clarify that not all Magento models extend or make use of the ORM. Observers are a clear example of simpler model classes that are not mapped to a specific database table or entity.</p></div></div><p>In addition to that, each Model type is formed by the following layers:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Model class</strong></span>: This<a id="id87" class="indexterm"/> is where most of our business logic resides. Models are used to manipulate the data, but they don't access it directly.</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Resource Model class</strong></span>: Resource Models<a id="id88" class="indexterm"/> are used to interact with the database on behalf of our models. They are in charge of the actual CRUD operations.</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Model Collection class</strong></span>: Each Data Model <a id="id89" class="indexterm"/>has a collection class. Collections are objects that hold a number of individual Magento Model instances.</li></ul></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note07"/>Note</h3><p>CRUD stands for the four basic types of database operations, namely create, read, update, and delete.</p></div></div><p>Magento Models <a id="id90" class="indexterm"/>don't contain any logic to communicate with the database; they are database agnostic. Instead, this code resides in the Resource Model layer.</p><p>This gives Magento the capacity to support different types of databases and platforms. Although currently, only MySQL is officially supported, it is entirely possible to write a new resource class for a new database without touching any of the Model logic:</p><div class="mediaobject"><img src="graphics/4172_02_01.jpg" alt="Magento Model anatomy"/></div><p>Let's experiment <a id="id91" class="indexterm"/>now by instantiating a product object and setting some of its properties:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Start the Magento interactive console running under your Magento staging installation root:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>php shell/imc.php</strong></span>
</pre></div></li><li class="listitem">Our first step is to create a new product object instance by typing the following code:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>magento&gt; $product = Mage::getModel('catalog/product');</strong></span>
</pre></div></li><li class="listitem">We can confirm this is a blank instance of the product class by running the following code:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>magento&gt; echo get_class($product);</strong></span>
</pre></div></li><li class="listitem">We should see the following as a successful output:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>magento&gt; Magento_Catalog_Model_Product</strong></span>
</pre></div></li><li class="listitem">If we want to know more about the class methods, we can run the following code:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>magento&gt; print_r(get_class_methods($product));</strong></span>
</pre></div></li></ol></div><p>This will return an array with all the available methods inside the class. Let's try to run the following code snippet and modify a product's price and name:</p><div class="informalexample"><pre class="programlisting">$product = Mage::getModel('catalog/product')-&gt;load(2);
$name   = $product-&gt;getName() . '-TEST';
$price   = $product-&gt;getPrice();
$product-&gt;setPrice($price + 15);
$product-&gt;setName($name);
$product-&gt;save();</pre></div><p>On the first <a id="id92" class="indexterm"/>line of code, we instantiate a specific object and then proceed to retrieve the name attribute from the object. Next, we set the price and name, and finally, we save the object.</p><p>If we open our Magento product class <code class="literal">Mage_Catalog_Model_Product</code>, the first thing we will notice is that while both <code class="literal">getName()</code> and <code class="literal">getPrice()</code> are defined inside our class, the <code class="literal">setPrice()</code> and <code class="literal">setName()</code> functions are not defined anywhere.</p><p>However, why, and more importantly how, is Magento <span class="emphasis"><em>magically</em></span> defining each of the product object setter and getter methods? While <code class="literal">getPrice()</code> and <code class="literal">getName()</code> are indeed defined, there is no definition for any of the getter and setter methods for product attributes such as color or manufacturer.</p><div class="section" title="It's magic – methods"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec16"/>It's magic – methods</h2></div></div></div><p>Well it so <a id="id93" class="indexterm"/>happens that the Magento ORM system is indeed magic. To be precise, one of PHP's more powerful features is to implement its getters and setters, the magic <code class="literal">__call()</code> method. Magic methods are used inside Magento to set, unset, check, or retrieve data.</p><p>When we try to call a method that does not actually exist in our corresponding class, PHP will look into each of the parent classes for a declaration of that method. If it can't find the function on any of the parent classes, it will use its last resort and try to use a <code class="literal">__call()</code> method. If found, Magento (or PHP for that matter) will call the magic method, passing the requested method name and its arguments.</p><p>Now, the Product model doesn't have a <code class="literal">__call()</code> method defined, but it gets one from the <code class="literal">Varien_Object</code> that most Magento models inherit from. The inheritance tree for the <code class="literal">Mage_Catalog_Model_Product</code> class is as follows:</p><div class="mediaobject"><img src="graphics/4172_02_02.jpg" alt="It's magic – methods"/></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip03"/>Tip</h3><p>Most Magento Models inherit from the <code class="literal">Varien_Object</code> class.</p></div></div><p>Let's take a closer look at the <a id="id94" class="indexterm"/>
<code class="literal">Varien_Object</code> class:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Open the file located in <code class="literal">magento_root/lib/Varien/Object.php</code>.</li><li class="listitem">The <code class="literal">Varien_Object</code> class not only has a <span class="strong"><strong>__call()</strong></span> method but also has two deprecated <a id="id95" class="indexterm"/>methods, <span class="strong"><strong>__set() </strong></span>and <span class="strong"><strong>__get()</strong></span>. Both of these are replaced by the <span class="strong"><strong>__call()</strong></span> method and are no longer used.<div class="informalexample"><pre class="programlisting">public function __call($method, $args)
{   switch (substr($method, 0, 3)) {
      case 'get' ://Varien_Profiler::start('GETTER: '.get_class($this).'::'.$method);
          $key = $this-&gt;_underscore(substr($method,3));
          $data = $this-&gt;getData($key, isset($args[0]) ? 
          $args[0] : null);
          	
//Varien_Profiler::stop('GETTER: '.get_class($this).'::'.$method);
          return $data;

          case 'set' :
          //Varien_Profiler::start('SETTER: '.get_class($this).'::'.$method);
          $key = $this-&gt;_underscore(substr($method,3));
          $result = $this-&gt;setData($key, isset($args[0]) ? $args[0] : null);
          //Varien_Profiler::stop('SETTER: '.get_class($this).'::'.$method);
            return $result;
          case 'uns' :
          //Varien_Profiler::start('UNS: '.get_class($this).'::'.$method);
         $key = $this-&gt;_underscore(substr($method,3));
         $result = $this-&gt;unsetData($key);
         //Varien_Profiler::stop('UNS: '.get_class($this).'::'.$method);
         return $result;

         case 'has' :
         //Varien_Profiler::start('HAS: '.get_class($this).'::'.$method);
         $key = $this-&gt;_underscore(substr($method,3));
         //Varien_Profiler::stop('HAS: '.get_class($this).'::'.$method);
         return isset($this-&gt;_data[$key]);
    }
    throw new Varien_Exception("Invalid method" . get_class($this)."::".$method."(".print_r($args,1).")");
}</pre></div></li></ol></div><p>Inside<a id="id96" class="indexterm"/> the <code class="literal">__call()</code> method, we have a switch that will handle not only getters and setters but also the <code class="literal">unset</code> and <code class="literal">has</code> functions.</p><p>If we start a debugger and follow the calls of our snippet code to the <code class="literal">__call()</code> method, we will see that it receives two arguments, the method name (for example <code class="literal">setName()</code>) and the arguments from the original call.</p><p>Interestingly, Magento tries to match the corresponding method type based on the first three letters of the method being called. This is done with the switch case argument by calling the substring function:</p><div class="informalexample"><pre class="programlisting">substr($method, 0, 3)</pre></div><p>The first thing<a id="id97" class="indexterm"/> that is called inside each case is the <code class="literal">_underscore()</code> function, which takes as parameter anything after the first three characters in the method name. Following our example, the argument passed will be <code class="literal">Name</code>.</p><p>The <code class="literal">__underscore()</code> function returns a data key. This key is then used by each of the cases to manipulate the data. There are four basic data operations, each is used on the corresponding switch case:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">setData</code> (<code class="literal">$parameters</code>)</li><li class="listitem" style="list-style-type: disc"><code class="literal">getData</code> (<code class="literal">$parameters</code>)</li><li class="listitem" style="list-style-type: disc"><code class="literal">unsetData</code> (<code class="literal">$parameters</code>)</li><li class="listitem" style="list-style-type: disc"><code class="literal">isset</code> (<code class="literal">$parameters</code>)</li></ul></div><p>Each of these functions will interact with the <code class="literal">Varien_Object</code> data array and manipulate it accordingly. In most cases, a magic set/get method will be used to interact with our object attributes. Only in a few exceptions, where additional business logic is required, getters and setters will be defined. In our example, this would be <code class="literal">getName()</code> and <code class="literal">getPrice()</code>:</p><div class="informalexample"><pre class="programlisting">public function getPrice()
{
    if ($this-&gt;_calculatePrice || !$this-&gt;getData('price')) {
      return $this-&gt;getPriceModel()-&gt;getPrice($this);
    } else {
      return $this-&gt;getData('price');
    }
}</pre></div><p>We will not get into details of what the price function is actually doing, but it clearly illustrates that additional logic may be required for certain parts of the models:</p><div class="informalexample"><pre class="programlisting">public function getName()
{
    return $this-&gt;_getData('name');
}</pre></div><p>On the other<a id="id98" class="indexterm"/> hand, the <code class="literal">getName()</code> getter wasn't declared because of the need to implement special logic but by the need to optimize a crucial part of Magento. The <code class="literal">Mage_Catalog_Model_Product</code> <code class="literal">getName()</code> function, which can potentially be called hundreds of times per page load, is one of the most commonly used functions across all Magento. After all, what kind of e-commerce platform would it be if it was not centered around products?</p><p>Frontend and backend will both call the <code class="literal">getName()</code> function at one point or another. For example, loading a category page with 24 products. That's 24 separate calls to the <code class="literal">getName()</code> function. Having each of these calls look for a <code class="literal">getName()</code> method on each of the parent classes and then trying to use the magic <code class="literal">__call()</code> method will result in losing precious milliseconds.</p><p>
<span class="strong"><strong>Resource Models</strong></span><a id="id99" class="indexterm"/> contain all the database-specific logic and they instantiate specific read-and-write adapters for their corresponding data source. Let's go back to our example of working with products and take a look the product Resource Model located in <code class="literal">Mage_Catalog_Model_Resource_Product</code>:</p><div class="mediaobject"><img src="graphics/4172_02_03.jpg" alt="It's magic – methods"/></div><p>Resource Models come in two different types, Entity and Resource. The latter is a pretty standard one-table/one-model association, while the former is far more complicated.</p></div></div></div>
<div class="section" title="The EAV model"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec18"/>The EAV model</h1></div></div></div><p>EAV stands<a id="id100" class="indexterm"/> for entity, attribute, and value and is probably the most difficult concept for new Magento developers to grasp. While the EAV concept is not unique to Magento, it is rarely implemented on modern systems. Additionally, a Magento implementation is not a simple one.</p><div class="mediaobject"><img src="graphics/4172_02_04.jpg" alt="The EAV model"/></div><div class="section" title="What is EAV?"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec17"/>What is EAV?</h2></div></div></div><p>In order to<a id="id101" class="indexterm"/> understand what EAV is and what its role within Magento is, we need to break down parts of the EAV model:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Entity</strong></span>: This<a id="id102" class="indexterm"/> represents the data items (objects) inside Magento products, customers, categories, and orders. Each entity is stored in the database with a unique ID.</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Attribute</strong></span>: These<a id="id103" class="indexterm"/> are our object properties. Instead of having one column per attribute on the product table, attributes are stored on separate sets of tables.</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Value</strong></span>: As the<a id="id104" class="indexterm"/> name implies, it is simply the value link to a particular attribute.</li></ul></div><p>This data model is the secret behind Magento's flexibility and power, allowing entities to add and remove new properties without having to make any changes to the code, templates, or the database schema.</p><p>This model can be seen as a vertical way of growing our database (new attributes and more rows), while the traditional model involves a horizontal growth pattern (new attributes and more columns), which would result in a schema redesign every time new attributes are added.</p><p>The <span class="strong"><strong>EAV</strong></span> model not only allows for the fast evolution of our database, but is also more effective because it only works with non-empty attributes, avoiding the need  to reserve additional space in the database for null values.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip04"/>Tip</h3><p>If you are interested in exploring and learning more about the Magento database structure, I highly recommend visiting <a class="ulink" href="http://www.magereverse.com">www.magereverse.com</a>.</p></div></div><p>Adding a new <a id="id105" class="indexterm"/>product attribute is as simple going to the Magento backend and specifying the new attribute type, be it color, size, brand, or anything else. The opposite is true as well and we can get rid of unused attributes on our products or customer models.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note08"/>Note</h3><p>For more information on managing attributes, visit <a class="ulink" href="http://www.magentocommerce.com/knowledge-base/entry/how-do-attributes-work-in-magento">http://www.magentocommerce.com/knowledge-base/entry/how-do-attributes-work-in-magento</a>.</p></div></div><p>The Magento community edition currently has eight different types of <a id="id106" class="indexterm"/>EAV objects:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Customer</li><li class="listitem" style="list-style-type: disc">Customer Address</li><li class="listitem" style="list-style-type: disc">Products</li><li class="listitem" style="list-style-type: disc">Product Categories</li><li class="listitem" style="list-style-type: disc">Orders</li><li class="listitem" style="list-style-type: disc">Invoices</li><li class="listitem" style="list-style-type: disc">Credit Memos</li><li class="listitem" style="list-style-type: disc">Shipments</li></ul></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note09"/>Note</h3><p>The Magento Enterprise Edition has one additional type called <a id="id107" class="indexterm"/>
<span class="strong"><strong>RMA</strong></span> item, which is part of the <a id="id108" class="indexterm"/>
<span class="strong"><strong>Return Merchandise Authorization</strong></span> (<span class="strong"><strong>RMA</strong></span>) system.</p></div></div><p>All this<a id="id109" class="indexterm"/> flexibility and power is not free; there is a price to pay. Implementing the EAV model results in having our entity data distributed on a large number of tables. For example, just the Product Model is distributed to around 40 different tables.</p><p>The following diagram only shows a few of the tables involved in saving the information of Magento products:</p><div class="mediaobject"><img src="graphics/4172_02_05.jpg" alt="What is EAV?"/></div><p>Other major <a id="id110" class="indexterm"/>downsides of <span class="strong"><strong>EAV</strong></span> are the loss of performance while retrieving large collections of <span class="strong"><strong>EAV</strong></span> objects and an increase in the database query complexity. As the data is more fragmented (stored in more tables), selecting a single record involves several joins.</p><p>One way Magento works around this downside of EAV is by making use of indexes and flat tables. For example, Magento can save all the product information into the <code class="literal">flat_catalog</code> table for easier and faster access.</p><p>Let's continue using Magento products as our example and manually build the query to retrieve a single product.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip05"/>Tip</h3><p>If you have <span class="strong"><strong>phpmyadmin</strong></span> or <span class="strong"><strong>MySQL</strong></span> <span class="strong"><strong>Workbench</strong></span> installed on your development environment, you can experiment with the following queries. Each can be downloaded on the <a id="id111" class="indexterm"/>
<span class="strong"><strong>PHPMyAdmin</strong></span> website at <a class="ulink" href="http://www.phpmyadmin.net/">http://www.phpmyadmin.net/</a> and the <a id="id112" class="indexterm"/>
<span class="strong"><strong>MySQL Workbench</strong></span> website at <a class="ulink" href="http://www.mysql.com/products/workbench/">http://www.mysql.com/products/workbench/</a>.</p></div></div><p>The first <a id="id113" class="indexterm"/>table that we need to use is the <code class="literal">catalog_product_entity</code> table. We can<code class="literal"> </code>consider this our main product <span class="strong"><strong>EAV</strong></span> table<code class="literal"> </code>
<span class="emphasis"><em>since it contains the main entity records for our products</em></span>:</p><div class="mediaobject"><img src="graphics/4172_02_06.jpg" alt="What is EAV?"/></div><p>Let's query the table by running the following SQL query:</p><div class="informalexample"><pre class="programlisting">SELECT * FROM `catalog_product_entity`;</pre></div><p>The table contains the following fields:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">entity_id</code>: This<a id="id114" class="indexterm"/> is our product unique identifier that is used internally by Magento.</li><li class="listitem" style="list-style-type: disc"><code class="literal">entity_type_id</code>: Magento <a id="id115" class="indexterm"/>has several different types of EAV models. Products, customers, and orders are just some of them. Identifying each of these by type allows Magento to retrieve the attributes and values from the appropriate tables.</li><li class="listitem" style="list-style-type: disc"><code class="literal">attribute_set_id</code>: Product <a id="id116" class="indexterm"/>attributes can be grouped locally into attribute sets. Attribute sets allow even further flexibility on the product structure as products are not forced to use all available attributes.</li><li class="listitem" style="list-style-type: disc"><code class="literal">type_id</code>: There are <a id="id117" class="indexterm"/>several different types of products in Magento: simple, configurable, bundled, downloadable, and grouped products; each with unique settings and functionality.</li><li class="listitem" style="list-style-type: disc"><code class="literal">sku</code>: This<a id="id118" class="indexterm"/> stands for Stock Keeping Unit and is a number or code used to identify each unique product or item for sale in a store. This is a user-defined value.</li><li class="listitem" style="list-style-type: disc"><code class="literal">has_options</code>: This <a id="id119" class="indexterm"/>is used to identify if a product has custom options.</li><li class="listitem" style="list-style-type: disc"><code class="literal">required_options</code>: This <a id="id120" class="indexterm"/>is used to identify if any of the custom options that are required.</li><li class="listitem" style="list-style-type: disc"><code class="literal">created_at</code>: This <a id="id121" class="indexterm"/>is the row creation date.</li><li class="listitem" style="list-style-type: disc"><code class="literal">updated_at</code>: This<a id="id122" class="indexterm"/> is the last time the row was modified.</li></ul></div><p>Now we have a basic understanding of the product entity table. Each record represents a single product in our Magento store, but we don't have much information about that product beyond the SKU and the product type.</p><p>So, where are the attributes stored? And how does Magento know the difference between a product attribute and a customer attribute?</p><p>For this, we need to take a look into the <code class="literal">eav_attribute</code> table by running the following SQL query:</p><div class="informalexample"><pre class="programlisting">SELECT * FROM `eav_attribute`;</pre></div><p>As a result, we will not only see the product attributes, but also the attributes corresponding to the customer model, order model, and so on. Fortunately, we already have a key to filter the attributes from this table. Let's run the following query:</p><div class="informalexample"><pre class="programlisting">SELECT * FROM `eav_attribute`
WHERE entity_type_id = 4;</pre></div><p>This query tells the database to only retrieve the attributes where the <code class="literal">entity_type_id</code> column is equal to the product <code class="literal">entity_type_id(4)</code>. Before moving, let's analyze the most important fields inside the <code class="literal">eav_attribute</code> table:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">attribute_id</code>: This<a id="id123" class="indexterm"/> is the unique identifier for each attribute and primary key of the table.</li><li class="listitem" style="list-style-type: disc"><code class="literal">entity_type_id</code>: This <a id="id124" class="indexterm"/>relates each attribute to a specific eav model type.</li><li class="listitem" style="list-style-type: disc"><code class="literal">attribute_code</code>: This<a id="id125" class="indexterm"/> is the name or key of our attribute and is used to generate the getters and setters for our magic methods.</li><li class="listitem" style="list-style-type: disc"><code class="literal">backend_model</code>: These<a id="id126" class="indexterm"/> manage loading and storing data into the database.</li><li class="listitem" style="list-style-type: disc"><code class="literal">backend_type</code>: This <a id="id127" class="indexterm"/>specifies the type of value stored in the backend (database).</li><li class="listitem" style="list-style-type: disc"><code class="literal">backend_table</code>: This<a id="id128" class="indexterm"/> is used to specify if the attribute should be stored on a special table instead of the default EAV table.</li><li class="listitem" style="list-style-type: disc"><code class="literal">frontend_model</code>: These<a id="id129" class="indexterm"/> handle the rendering of the attribute element into a web browser.</li><li class="listitem" style="list-style-type: disc"><code class="literal">frontend_input</code>: Similar <a id="id130" class="indexterm"/>to the frontend model, the frontend input specifies the type of input field the web browser should render.</li><li class="listitem" style="list-style-type: disc"><code class="literal">frontend_label</code>: This<a id="id131" class="indexterm"/> is the label/name of the attribute as it should be rendered by the browser.</li><li class="listitem" style="list-style-type: disc"><code class="literal">source_model</code>: These<a id="id132" class="indexterm"/> are used to populate an attribute with possible values. Magento comes with several predefined source models for countries, yes or no values, regions, and so on.</li></ul></div></div><div class="section" title="Retrieving the data"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec18"/>Retrieving the data</h2></div></div></div><p>At this point, we <a id="id133" class="indexterm"/>have successfully retrieved a product entity and the specific attributes that apply to that entity. Now it's time to start retrieving the actual values. In order to simplify the example (and the query) a little, we will only try to retrieve the name attribute of our products.</p><p>How do we know which table our attribute values are stored on? Well, thankfully, Magento follows a naming convention to name the tables. If we inspect our database structure, we will notice that there are several tables using the <code class="literal">catalog_product_entity</code> prefix:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">catalog_product_entity</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">catalog_product_entity_datetime</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">catalog_product_entity_decimal</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">catalog_product_entity_int</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">catalog_product_entity_text</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">catalog_product_entity_varchar</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">catalog_product_entity_gallery</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">catalog_product_entity_media_gallery</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">catalog_product_entity_tier_price</code></li></ul></div><p>Wait! How do<a id="id134" class="indexterm"/> we know which is the right table to query for our name attribute values? If you were paying attention, I already gave you the answer. Remember that the <code class="literal">eav_attribute</code> table had a column called <code class="literal">backend_type</code>?</p><p>Magento EAV stores each attribute on a different table based on the backend type of that attribute. If we want to confirm the backend type of our name attribute, we can do so by running the following code:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>SELECT * FROM `eav_attribute`</strong></span>
<span class="strong"><strong>WHERE `entity_type_id` =4 AND `attribute_code` = 'name';</strong></span>
</pre></div><p>As a result, we should see that the backend type is varchar and that the values for this attribute are stored in the <code class="literal">catalog_product_entity_varchar</code> table. Let's inspect this table:</p><div class="mediaobject"><img src="graphics/4172_02_07.jpg" alt="Retrieving the data"/></div><p>The <code class="literal">catalog_product_entity_varchar</code> table is formed by only 6 columns:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">value_id</code>: This is <a id="id135" class="indexterm"/>the attribute value unique identifier and primary key</li><li class="listitem" style="list-style-type: disc"><code class="literal">entity_type_id</code>: This<a id="id136" class="indexterm"/> is the entity type ID to which this value belongs</li><li class="listitem" style="list-style-type: disc"><code class="literal">attribute_id</code>: This <a id="id137" class="indexterm"/>is the foreign key that relates the value to our <code class="literal">eav_entity</code> table</li><li class="listitem" style="list-style-type: disc"><code class="literal">store_id</code>: This is <a id="id138" class="indexterm"/>the foreign key matching an attribute value with a storeview</li><li class="listitem" style="list-style-type: disc"><code class="literal">entity_id</code>: This <a id="id139" class="indexterm"/>is the foreign key relating to the corresponding entity table, in this case, <code class="literal">catalog_product_entity</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">value</code>: This is<a id="id140" class="indexterm"/> the actual value that we want to retrieve</li></ul></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip06"/>Tip</h3><p>Depending on the attribute configuration, we can have it as a global value, meaning, it applies across all store views or a value per storeview.</p></div></div><p>Now that we finally <a id="id141" class="indexterm"/>have all the tables that we need to retrieve the product information, we can build our query:</p><div class="informalexample"><pre class="programlisting">SELECT p.entity_id AS product_id, var.value AS product_name, p.sku AS product_sku
FROM catalog_product_entity p, eav_attribute eav, catalog_product_entity_varchar var
WHERE p.entity_type_id = eav.entity_type_id 
   AND var.entity_id = p.entity_id
   AND eav.attribute_code = 'name'
   AND eav.attribute_id = var.attribute_id</pre></div><div class="mediaobject"><img src="graphics/4172_02_08.jpg" alt="Retrieving the data"/></div><p>From our query, we should see a result set with three columns, <code class="literal">product_id</code>, <code class="literal">product_name</code>, and <code class="literal">product_sku</code>. So let's step back for a second in order to get product names with SKUs with raw SQL. We had to write a five-line SQL query, and we only retrieved two values from our products, from one single EAV value table if we want to retrieve a numeric field such as price or a text-value-like product.</p><p>If we didn't have <a id="id142" class="indexterm"/>an <span class="strong"><strong>ORM</strong></span> in place, maintaining Magento would be almost impossible. Fortunately, we do have an ORM in place, and most likely, you will never need to deal with raw SQL to work with Magento.</p><p>That said, let's see how we can retrieve the same product information by using the Magento ORM:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Our first step is going to be to instantiate a product collection:<div class="informalexample"><pre class="programlisting">$collection = Mage::getModel('catalog/product')-&gt;getCollection();</pre></div></li><li class="listitem">Then we will specifically tell Magento to select the name attribute:<div class="informalexample"><pre class="programlisting">$collection-&gt;addAttributeToSelect('name');</pre></div></li><li class="listitem">Then, we will ask it to sort the collection by name:<div class="informalexample"><pre class="programlisting">$collection-&gt;setOrder('name', 'asc');</pre></div></li><li class="listitem">Finally, we will tell Magento to load the collection:<div class="informalexample"><pre class="programlisting">$collection-&gt;load();</pre></div></li><li class="listitem">The end result is a collection of all products in the store sorted by name. We can inspect the actual SQL query by running the following code:<div class="informalexample"><pre class="programlisting">echo $collection-&gt;getSelect()-&gt;__toString();</pre></div></li></ol></div><p>In just three lines of code, we are telling Magento to grab all the products in the store, to specifically select the name, and finally order the products by name.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip07"/>Tip</h3><p>The last line <code class="literal">$collection-&gt;getSelect()-&gt;__toString();</code> allows to see the actual query that Magento is executing in our behalf.</p></div></div><p>The actual query being generated by Magento is as follows:</p><div class="informalexample"><pre class="programlisting">SELECT `e`.*. IF( at_name.value_id &gt;0, at_name.value, at_name_default.value ) AS `name`
FROM `catalog_product_entity` AS `e`
LEFT JOIN `catalog_product_entity_varchar` AS `at_name_default` ON (`at_name_default`.`entity_id` = `e`.`entity_id`)
AND (`at_name_default`.`attribute_id` = '65')
AND `at_name_default`.`store_id` =0
LEFT JOIN `catalog_product_entity_varchar` AS `at_name` ON ( `at_name`.`entity_id` = `e`.`entity_id` )
AND (`at_name`.`attribute_id` = '65')
AND (`at_name`.`store_id` =1)
ORDER BY `name` ASC</pre></div><p>As we can see, the ORM <a id="id143" class="indexterm"/>and the EAV models are wonderful tools that not only put a lot of power and flexibility in the hands of the developers, but they also do it in a way that is comprehensive and easy to use.</p></div></div>
<div class="section" title="Working with Magento collections"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec19"/>Working with Magento collections </h1></div></div></div><p>If you look back <a id="id144" class="indexterm"/>at the previous code example, you will notice that I'm not only instantiating a product model, but I'm also calling the <code class="literal">getCollection()</code> method. The <code class="literal">getCollection()</code> method is part of the <code class="literal">Mage_Core_Model_Abstract</code> class, meaning, every single model inside Magento can call this method.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip08"/>Tip</h3><p>All collections inherit from <code class="literal">Varien_Data_Collection</code>.</p></div></div><p>A Magento collection<a id="id145" class="indexterm"/> is basically a model that contains other models. So instead of using an array to hold a collection of products, we will use a product collection. Collections not only provide a convenient data structure to group models, they also provide special methods that we can use to manipulate and work with a collection of entities.</p><p>Some of the most useful collection methods are:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">addAttributeToSelect</code>: To<a id="id146" class="indexterm"/> add an attribute to the entities in a collection; <code class="literal">*</code> can be used as a wildcard to add all the available attributes</li><li class="listitem" style="list-style-type: disc"><code class="literal">addFieldToFilter</code>: To add <a id="id147" class="indexterm"/>an attribute filter to a collection; this function is used on regular non-EAV models or to filter attributes that are part of the master product table like SKU</li><li class="listitem" style="list-style-type: disc"><code class="literal">addAttributeToFilter</code>: This <a id="id148" class="indexterm"/>method is used to filter a collection of EAV entities</li><li class="listitem" style="list-style-type: disc"><code class="literal">addAttributeToSort</code>: This<a id="id149" class="indexterm"/> method is used to add an attribute to the sort order</li><li class="listitem" style="list-style-type: disc"><code class="literal">addStoreFilter</code>: This<a id="id150" class="indexterm"/> method is used to add a store filter to the current collection. It might not be available on all object types</li><li class="listitem" style="list-style-type: disc"><code class="literal">addWebsiteFilter</code>: This <a id="id151" class="indexterm"/>method is used to add a website filter to a collection</li><li class="listitem" style="list-style-type: disc"><code class="literal">addCategoryFilter</code>: This<a id="id152" class="indexterm"/> method is used to specify a category filter for a product collection</li><li class="listitem" style="list-style-type: disc"><code class="literal">addUrlRewrite</code>: This <a id="id153" class="indexterm"/>method is used to add URL rewrite data to the product collection</li><li class="listitem" style="list-style-type: disc"><code class="literal">setOrder</code>: This <a id="id154" class="indexterm"/>method is used to set the sorting order of a collection</li></ul></div><p>These <a id="id155" class="indexterm"/>are just a few of the collection methods available. Each collection implements different unique methods depending on the entity type they correspond to. For example, the customer collection <code class="literal">Mage_Customer_Model_Resource_Customer_Collection </code>has a unique method called <code class="literal">groupByEmail()</code>, which, as the name correctly implies, groups the entities inside a collection by e-mail.</p><p>As with previous examples, we will continue working with the product models, and in this case, the product collection.</p><div class="mediaobject"><img src="graphics/4172_02_09.jpg" alt="Working with Magento collections"/></div><p>In order to better illustrate how we can use the collection, will be working on the following common product scenarios:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Get a product collection only from a specific category</li><li class="listitem">Get new products since date <span class="emphasis"><em>X</em></span></li><li class="listitem">Get bestseller products</li><li class="listitem">Filter product collections by visibility</li><li class="listitem">Filter products without image</li><li class="listitem">Add multiple sort orders</li></ol></div><div class="section" title="Get product collections only from a specific category"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec19"/>Get product collections only from a specific category</h2></div></div></div><p>The first<a id="id156" class="indexterm"/> thing most developers try to do when starting with Magento is load a product collection with products only from a specific category. While I have seen many approaches by using <code class="literal">addCategoryFilter()</code> or <code class="literal">addAttributeToFilter()</code>, the reality is that for most cases, the approach is much simpler and a bit contra-intuitive to what we have learned so far.</p><p>The easiest way of doing this is not getting a product collection first and then filtering by a category, but actually<a id="id157" class="indexterm"/> instantiating our target category and getting the product collection from there, let's run the following code snippet on IMC:</p><div class="informalexample"><pre class="programlisting">$category = Mage::getModel('catalog/category')-&gt;load(5);
$productCollection = $category-&gt;getProductCollection();</pre></div><p>We can find the <code class="literal">getProductCollection()</code> method declaration inside the <code class="literal">Mage_Catalog_Model_Category </code>class. Let's take a closer look at this method:</p><div class="informalexample"><pre class="programlisting">public function getProductCollection()
{
    $collection = Mage::getResourceModel('catalog/product_collection')
        -&gt;setStoreId($this-&gt;getStoreId())
        -&gt;addCategoryFilter($this);
    return $collection;
}</pre></div><p>As we can see, the function does nothing more than instantiate Resource Model for the product collection, set the store to the current store ID, and pass the current category to the <code class="literal">addCategoryFilter()</code>.</p><p>This is one of those decisions that was taken to optimize Magento's performance and frankly, to simplify the life of the developers working with it, as in most cases, a category is going to be available one way or the other.</p></div><div class="section" title="Get new products added since X date"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec20"/>Get new products added since X date</h2></div></div></div><p>So now that <a id="id158" class="indexterm"/>we know how to get a product collection from a specific category, let's say we are able to apply filters to the resulting products and we only the retrieve the ones matching our conditions. In this particular case, we will request all products added after December 2012. Following our previous example code, we can filter our collection by product creation date by running the following code on IMC:</p><div class="informalexample"><pre class="programlisting">// Product collection from our previous example
$productCollection-&gt;addFieldToFilter('created_at', array('from' =&gt; '2012-12-01));</pre></div><p>It's that simple! We could even add any additional conditions and get the products added between two dates. Let's say we only want to retrieve the products that were created in the month of December:</p><div class="informalexample"><pre class="programlisting">$productCollection-&gt;addFieldToFilter('created_at', array('from' =&gt; '2012-12-01));
$productCollection-&gt;addFieldToFilter('created_at', array('to' =&gt; '2012-12-30));</pre></div><p>Magento <code class="literal">addFieldToFilter</code> supports the following conditions:</p><div class="informaltable"><table border="1"><colgroup><col style="text-align: left"/><col style="text-align: left"/></colgroup><thead><tr><th style="text-align: left" valign="bottom">
<p>Attribute code</p>
</th><th style="text-align: left" valign="bottom">
<p>SQL condition</p>
</th></tr></thead><tbody><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">eq</code>
</p>
</td><td style="text-align: left" valign="top">
<p>=</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">neq</code>
</p>
</td><td style="text-align: left" valign="top">
<p>!=</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">like</code>
</p>
</td><td style="text-align: left" valign="top">
<p>LIKE</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">nlike</code>
</p>
</td><td style="text-align: left" valign="top">
<p>NOT LIKE</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">in</code>
</p>
</td><td style="text-align: left" valign="top">
<p>IN ()</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">nin</code>
</p>
</td><td style="text-align: left" valign="top">
<p>NOT IN ()</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">is</code>
</p>
</td><td style="text-align: left" valign="top">
<p>IS</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">notnull</code>
</p>
</td><td style="text-align: left" valign="top">
<p>NOT NULL</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">null</code>
</p>
</td><td style="text-align: left" valign="top">
<p>NULL</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">moreq</code>
</p>
</td><td style="text-align: left" valign="top">
<p>&gt;=</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">gt</code>
</p>
</td><td style="text-align: left" valign="top">
<p>&gt;</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">lt</code>
</p>
</td><td style="text-align: left" valign="top">
<p>&lt;</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">gteq</code>
</p>
</td><td style="text-align: left" valign="top">
<p>&gt;=</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">lteq</code>
</p>
</td><td style="text-align: left" valign="top">
<p>&lt;=</p>
</td></tr></tbody></table></div><p>We can try other types of filters. For example, let's use the following code on IMC after adding our creation date filter. So we can retrieve only visible products.</p><div class="informalexample"><pre class="programlisting">$productCollection-&gt;addAttributeToFilter('visibility', 4);</pre></div><p>The visibility<a id="id159" class="indexterm"/> attribute is a special attribute used by products to control where products are shown. It has the following values:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Not visible individually</strong></span>: This has a value of 1</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Catalog</strong></span>: This has a value of 2</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Search</strong></span>: This has a value of 3</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Catalog and Search</strong></span>: This has a value of 4</li></ul></div></div><div class="section" title="Get bestseller products"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec21"/>Get bestseller products</h2></div></div></div><p>To try and<a id="id160" class="indexterm"/> get the bestseller products for a specific category, we will need to step up our game and join with the <code class="literal">sales_order</code> table. Retrieving bestseller products will come in handy later to create a special category or custom reporting. We can run the following code on IMC:</p><div class="informalexample"><pre class="programlisting">$category = Mage::getModel('catalog/category')-&gt;load(5);
$productCollection = $category-&gt;getProductCollection();
$productCollection-&gt;getSelect()
            -&gt;join(array('o'=&gt; 'sales_flat_order_item'), 'main_table.entity_id = o.product_id', array('o.row_total','o.product_id'))-&gt;group(array('sku'));</pre></div><p>Let's analyze what's happening on the third line of our snippet. <code class="literal">getSelect()</code> is a method inherited directly from <code class="literal">Varien_Data_Collection_Db</code>, which returns the variable where the select statement is stored. Additionally, collections provide methods to specify a join and a group without actually having to write any SQL.</p><p>This is not the only way of adding a join to a collection. There is, in fact, another way of doing this by using the <code class="literal">joinField()</code> function which will result in a simpler query. Let's rewrite our previous code to make use of this function:</p><div class="informalexample"><pre class="programlisting">$category = Mage::getModel('catalog/category')-&gt;load(5);
$productCollection = $category-&gt;getProductCollection();
$productCollection-&gt;joinField('o', 'sales_flat_order_item', array('o.row_total','o.product_id'), 'main_table.entity_id = o.product_id')
-&gt;group(array('sku'));</pre></div></div><div class="section" title="Filter the product collection by visibility"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec22"/>Filter the product collection by visibility</h2></div></div></div><p>This is <a id="id161" class="indexterm"/>extremely easy to do with the help of <code class="literal">addAttributeToFilter</code>. Magento products have a system attribute called visibility, which has four possible number values ranging from one to four. We are only interested in showing products that have a visibility of four, meaning they can be seen both in the search results and the catalog. Let's run the following code in IMC:</p><div class="informalexample"><pre class="programlisting">$category = Mage::getModel('catalog/category')-&gt;load(5);
$productCollection = $category-&gt;getProductCollection();
$productCollection-&gt;addAttributeToFilter('visibility', 4);</pre></div><p>If we change the visibility code, we can compare the different collection results.</p></div><div class="section" title="Filter products without images"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec23"/>Filter products without images </h2></div></div></div><p>Filtering products<a id="id162" class="indexterm"/> without images comes in handy when you are dealing with any third-party import system, which can at times be unreliable. As with everything we have done so far, product images are attributes of our product:</p><div class="informalexample"><pre class="programlisting">$category = Mage::getModel('catalog/category')-&gt;load(5);
$productCollection = $category-&gt;getProductCollection();
$productCollectio-&gt;addAttributeToFilter('small_image',array('notnull'=&gt;'','neq'=&gt;'no_selection'));</pre></div><p>By adding that extra filter, we are requiring products to have a small image specified. By default, Magento has three product image types, thumbnail, <code class="literal">small_image</code>, and image. These three types are used on different parts of the application. We could even set up a stricter rule for products if we wanted to:</p><div class="informalexample"><pre class="programlisting">$productCollection-&gt;addAttributeToFilter('small_image', array('notnull'=&gt;'','neq'=&gt;'no_selection'));
-&gt;addAttributeToFilter('thumbnail, array('notnull'=&gt;'','neq'=&gt;'no_selection'))
-&gt;addAttributeToFilter('image', array('notnull'=&gt;'','neq'=&gt;'no_selection'));</pre></div><p>Only products that have all of three types of images will be included in our collection. Try experimenting by filter with the different image types.</p></div><div class="section" title="Add multiple sort orders"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec24"/>Add multiple sort orders</h2></div></div></div><p>Finally, let's <a id="id163" class="indexterm"/>take our collection and sort it first by stock status and then by price from highest to lowest. In order to retrieve the stock status information, we will use a method unique to the stock status Resource Model called <code class="literal">addStockStatusToSelect()</code>, which will take care of generating the corresponding SQL for our collection query:</p><div class="informalexample"><pre class="programlisting">$category = Mage::getModel('catalog/category')-&gt;load(5);
$productCollection = $category-&gt;getProductCollection();
$select = $productCollection-&gt;getSelect();
Mage::getResourceModel('cataloginventory/stock_status')-&gt;addStockStatusToSelect($select, Mage::app()-&gt;getWebsite());
$select-&gt;order('salable desc');
$select-&gt;order('price asc');</pre></div><p>Inside this query, Magento will sort products by the salable status, which is either true or false, and by price. The end result is where all the available products show in the order of first ordered, from most expensive to cheapest, and then the out-of-stock products will show from most expensive to cheapest.</p><p>Experiment with different sort order combinations to see how Magento organizes and orders the product collections.</p></div></div>
<div class="section" title="Using Direct SQL"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec20"/>Using Direct SQL</h1></div></div></div><p>So far we<a id="id164" class="indexterm"/> have learned how Magento data models and ORM systems provide a clean and simple way to access, store, and manipulate our data. Before we jump right into this section and learn about the Magento database adapters and how to run raw SQL queries, I feel it is important that we understand why you should avoid using what you are about to learn in this section as much as possible.</p><p>Magento is an extremely <a id="id165" class="indexterm"/>
<span class="strong"><strong>complex system</strong></span>, and as we've also learned in the previous chapter, a framework driven in part by events. Just saving a product will trigger half a dozen different events, each doing a different task. This will not happen if you decide to just create a query and update a product directly. So, as developers, we must be extremely careful and be sure there is a justifiable reason to go outside the ORM.</p><p>That said, there are of course scenarios when being able to work with the database directly comes in extremely handy and is actually simpler than working with the Magento models. For example, when updating the product attribute globally or changing a product collection status, we could load a product collection and loop through each of the individual products, updating and saving them. While this will work fine on smaller collections, as soon we start growing and working with a larger dataset, our performance starts dropping and the script takes several seconds to execute.</p><p>On the other hand, a Direct SQL query will execute much faster (usually under one second) depending on the size of the dataset and the query being executed.</p><p>Out-of-the-box Magento will take care of all the heavy lifting of having to establish a connection to the database by using the <code class="literal">Mage_Core_Model_Resource</code> model. Magento makes three types of connections available to us, <code class="literal">core_read</code>, <code class="literal">core_setup</code> and <code class="literal">core_write</code>. For now, we will only focus on <code class="literal">core_read</code> and <code class="literal">core_write</code>.</p><p>Let's start by instantiating a Resource Model and two connections, one to read and the other to write:</p><div class="informalexample"><pre class="programlisting">$resource = Mage::getModel('core/resource');
$read = $resource-&gt;getConnection('core_read');
$write = $resource-&gt;getConnection('core_write');</pre></div><p>Even if we are working with Direct SQL queries, thanks to Magento, we don't have to worry about setting up <a id="id166" class="indexterm"/>the connection to the DB beyond instantiating a Resource Model and the proper type of connection.</p><div class="section" title="Reading"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec25"/>Reading</h2></div></div></div><p>Let's test our <a id="id167" class="indexterm"/>read connection by executing the following code:</p><div class="informalexample"><pre class="programlisting">$resource = Mage::getModel('core/resource');
$read = $resource-&gt;getConnection('core_read');
$query = 'SELECT * FROM catalog_product_entity';
$results = $read-&gt;fetchAll($query);</pre></div><p>Although this query works and it will return all the products in the <code class="literal">catalog_product_entity</code> table, what will happen if we try to run this same code on a Magento installation that uses table prefixes? Or what if Magento suddenly changes the table name in the next upgrade? This code is not portable or easily maintainable. Fortunately, the Resource Model provides another handy method called <code class="literal">getTableName()</code>.</p><p>The <code class="literal">getTableName()</code> method will take a factory name as a parameter, and based on the configuration established by the config.xml, it will not only find the right table, but will also verify if the table exists in the DB. Let's update our code to use <code class="literal">getTableName()</code>:</p><div class="informalexample"><pre class="programlisting">$resource = Mage::getModel('core/resource');
$read = $resource-&gt;getConnection('core_read');
$query = 'SELECT * FROM ' . $resource-&gt;getTableName('catalog/product');
$results = $read-&gt;fetchAll($query);</pre></div><p>We are also using the <code class="literal">fetchAll()</code> method that will return all the rows returned by our query as an array, but this is not the only available method. We also have <code class="literal">fetchCol()</code> and <code class="literal">fetchOne()</code> at our disposition:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">fetchAll</code>: This <a id="id168" class="indexterm"/>retrieves all the rows returned by the original query.</li><li class="listitem" style="list-style-type: disc"><code class="literal">fetchOne</code>: This<a id="id169" class="indexterm"/> returns only the values from the first database row returned by the query.</li><li class="listitem" style="list-style-type: disc"><code class="literal">fetchCol</code>: This <a id="id170" class="indexterm"/>returns all the columns returned by the query but only the first row. This is useful if you only want to retrieve a single column with unique identifiers such products IDs or SKUs.</li></ul></div></div><div class="section" title="Writing"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec26"/>Writing</h2></div></div></div><p>As we <a id="id171" class="indexterm"/>mentioned before, saving a model in Magento, be it a product, category, customer, or anything else, can be relatively slow due to the amount of observers and events triggered in the backend.</p><p>However, if we are only looking to update simple static values, updating large collections can be a painfully slow process if done through the Magento ORM. Let's say that, for example, we want to make all the products on the site out of stock. Instead of doing this through the Magento backend or creating a custom script that iterates through a collection of all the products, we can simply do as follows:</p><div class="informalexample"><pre class="programlisting">$resource = Mage::getModel('core/resource');
$read = $resource-&gt;getConnection('core_write);
$tablename = $resource-&gt;getTableName('cataloginventory/stock_status');
$query = 'UPDATE {$tablename} SET `is_in_stock` = 0';
$write-&gt;query($query);</pre></div></div></div>
<div class="section" title="Summary"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec21"/>Summary</h1></div></div></div><p>In this chapter, we have learned about Magento models, their inheritance and purpose, and how Magento uses resources and collections to implement its own ORM.</p><p>We also learned about EAV models and how they are structured to provide Magento with data flexibility and extensibility that both merchants and developers can take advantage of.</p><p>Finally, we saw how developers can access the database directly by writing DirectSQL and using the Magento resource adapters.</p><p>The chapters so far have been more theory than practice. This has been done with the intention of guiding you through the complexity of Magento and providing you with the tools and knowledge that you require for the rest of the book. For the remaining chapters of the book, we will take a more hands-on approach and start building extensions, incrementally applying all the concepts we have learned so far.</p><p>Our next chapter is called <span class="emphasis"><em>Frontend Development</em></span> where we will start getting our feet wet and develop our first Magento extension.</p></div></body></html>