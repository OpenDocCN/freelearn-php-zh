<html><head></head><body>
<div id="_idContainer022">
<h1 class="chapter-number" id="_idParaDest-62"><a id="_idTextAnchor063"/><span class="koboSpan" id="kobo.1.1">4</span></h1>
<h1 id="_idParaDest-63"><a id="_idTextAnchor064"/><span class="koboSpan" id="kobo.2.1">Ruby Scripting versus PHP Scripting</span></h1>
<p><span class="koboSpan" id="kobo.3.1">Just like the similarities we found when we looked at Ruby’s and PHP’s syntax, we are going to take things a step further and dive into the similarities between Ruby scripts and PHP scripts. </span><span class="koboSpan" id="kobo.3.2">A script</span><a id="_idIndexMarker185"/><span class="koboSpan" id="kobo.4.1"> is a piece of code that will run a task and then stop its execution. </span><span class="koboSpan" id="kobo.4.2">Said task may be simple or complex, but it is not considered an application as it stops once the task is done and only performs the task. </span><span class="koboSpan" id="kobo.4.3">Let’s take this step together and start writing simple scripts so that we can eventually write </span><span class="No-Break"><span class="koboSpan" id="kobo.5.1">full-fledged applications.</span></span></p>
<p><span class="koboSpan" id="kobo.6.1">With that in mind, in this chapter, we will cover the </span><span class="No-Break"><span class="koboSpan" id="kobo.7.1">following topics:</span></span></p>
<ul>
<li><span class="No-Break"><span class="koboSpan" id="kobo.8.1">Useful scripts</span></span></li>
<li><span class="No-Break"><span class="koboSpan" id="kobo.9.1">Text handling</span></span></li>
<li><span class="No-Break"><span class="koboSpan" id="kobo.10.1">File handling</span></span></li>
<li><span class="No-Break"><span class="koboSpan" id="kobo.11.1">Command-line arguments</span></span></li>
</ul>
<h1 id="_idParaDest-64"><a id="_idTextAnchor065"/><span class="koboSpan" id="kobo.12.1">Technical requirements</span></h1>
<p><span class="koboSpan" id="kobo.13.1">To follow along with this chapter, we will need </span><span class="No-Break"><span class="koboSpan" id="kobo.14.1">the following:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.15.1">Any IDE to view/edit code (for example, SublimeText, Visual Studio Code, Notepad++ Vim, Emacs, and </span><span class="No-Break"><span class="koboSpan" id="kobo.16.1">so on)</span></span></li>
<li><span class="koboSpan" id="kobo.17.1">For macOS users, you will also need to have XCode Command Line </span><span class="No-Break"><span class="koboSpan" id="kobo.18.1">Tools installed</span></span></li>
<li><span class="koboSpan" id="kobo.19.1">Ruby version 2.6 or later must be installed and ready </span><span class="No-Break"><span class="koboSpan" id="kobo.20.1">to use</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.21.1">The code presented in this chapter is available </span><span class="No-Break"><span class="koboSpan" id="kobo.22.1">at </span></span><a href="https://github.com/PacktPublishing/From-PHP-to-Ruby-on-Rails/"><span class="No-Break"><span class="koboSpan" id="kobo.23.1">https://github.com/PacktPublishing/From-PHP-to-Ruby-on-Rails/</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.24.1">.</span></span></p>
<h1 id="_idParaDest-65"><a id="_idTextAnchor066"/><span class="koboSpan" id="kobo.25.1">Beyond Hello World</span></h1>
<p><span class="koboSpan" id="kobo.26.1">In the previous chapter, we learned how to run (or execute) Ruby code. </span><span class="koboSpan" id="kobo.26.2">However, we only focused on the syntax and not the usefulness of the code. </span><span class="koboSpan" id="kobo.26.3">The famous Hello World script we write in any language is, by itself, useless, at least from a practical sense. </span><span class="koboSpan" id="kobo.26.4">So, let’s start learning how to use some tools to give our scripts a little bit </span><span class="No-Break"><span class="koboSpan" id="kobo.27.1">of usefulness.</span></span></p>
<p><span class="koboSpan" id="kobo.28.1">One useful tool</span><a id="_idIndexMarker186"/><span class="koboSpan" id="kobo.29.1"> in any language is having a way to verify the version of the programming language that we are currently using. </span><span class="koboSpan" id="kobo.29.2">Once we obtain the version, we can stop the execution if the version we are using is incorrect. </span><span class="koboSpan" id="kobo.29.3">So, our first step is to get the current Ruby version. </span><span class="koboSpan" id="kobo.29.4">Let’s create a file called </span><strong class="source-inline"><span class="koboSpan" id="kobo.30.1">version_verification.rb</span></strong><span class="koboSpan" id="kobo.31.1"> with the </span><span class="No-Break"><span class="koboSpan" id="kobo.32.1">following code:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.33.1">
# version_verification.rb
puts "We are running Ruby version #{RUBY_VERSION}"</span></pre> <p><span class="koboSpan" id="kobo.34.1">We can run this script on our shell by typing the </span><span class="No-Break"><span class="koboSpan" id="kobo.35.1">following command:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.36.1">
ruby version_verifications.rb</span></pre> <p><span class="koboSpan" id="kobo.37.1">It should output something similar </span><span class="No-Break"><span class="koboSpan" id="kobo.38.1">to this:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.39.1">
We are running Ruby version 2.6.8</span></pre> <p><span class="koboSpan" id="kobo.40.1">In this script, we are using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.41.1">RUBY_VERSION</span></strong><span class="koboSpan" id="kobo.42.1"> constant to get the current version of Ruby that we are using and interpolating this constant with a string to view the whole message regarding the Ruby version. </span><span class="koboSpan" id="kobo.42.2">By itself, this constant is useless, but let’s give it some practical use. </span><span class="koboSpan" id="kobo.42.3">Let’s say we wanted to share our script with other teams, where it would be used in different computers and/or environments. </span><span class="koboSpan" id="kobo.42.4">To make sure our script works properly, we would have to provide certain requirements or conditions for our script. </span><span class="koboSpan" id="kobo.42.5">It would be also useful to verify that said requirements are being met. </span><span class="koboSpan" id="kobo.42.6">We have a couple of options to accomplish this. </span><span class="koboSpan" id="kobo.42.7">We could simply compare the version we obtain from the </span><strong class="source-inline"><span class="koboSpan" id="kobo.43.1">RUBY_VERSION</span></strong><span class="koboSpan" id="kobo.44.1"> constant to another string, such as </span><strong class="source-inline"><span class="koboSpan" id="kobo.45.1">'2.6.8'</span></strong><span class="koboSpan" id="kobo.46.1">. </span><span class="koboSpan" id="kobo.46.2">That would be the most straightforward way to do this. </span><span class="koboSpan" id="kobo.46.3">However, the problem with this approach is that you would have to have the same Ruby version everywhere and that is rarely the case. </span><span class="koboSpan" id="kobo.46.4">We almost always have small variations of the version. </span><span class="koboSpan" id="kobo.46.5">If we were to take the preceding example of </span><strong class="source-inline"><span class="koboSpan" id="kobo.47.1">'2.6.8'</span></strong><span class="koboSpan" id="kobo.48.1">, in other systems, we could get </span><strong class="source-inline"><span class="koboSpan" id="kobo.49.1">'2.6.5'</span></strong><span class="koboSpan" id="kobo.50.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.51.1">'2.6.7'</span></strong><span class="koboSpan" id="kobo.52.1">, or even </span><strong class="source-inline"><span class="koboSpan" id="kobo.53.1">'2.6.9'</span></strong><span class="koboSpan" id="kobo.54.1">. </span><span class="koboSpan" id="kobo.54.2">And all of these versions would not only be equivalent but also valid to what we are requiring. </span><span class="koboSpan" id="kobo.54.3">So, let’s just say our requirement is 2.6 and above, which would be equivalent to any version above </span><strong class="source-inline"><span class="koboSpan" id="kobo.55.1">'2.5.9'</span></strong><span class="koboSpan" id="kobo.56.1">. </span><span class="koboSpan" id="kobo.56.2">We could split the obtained version from the </span><strong class="source-inline"><span class="koboSpan" id="kobo.57.1">RUBY_VERSION</span></strong><span class="koboSpan" id="kobo.58.1"> constant, split its value by the dots, and start comparing away. </span><span class="koboSpan" id="kobo.58.2">However, this is too much work; this is where comes Ruby to the rescue. </span><span class="koboSpan" id="kobo.58.3">Ruby comes with a library called </span><strong class="source-inline"><span class="koboSpan" id="kobo.59.1">stdlib</span></strong><span class="koboSpan" id="kobo.60.1"> that comes with several utilities that are extremely useful when encountering these types of problems. </span><span class="koboSpan" id="kobo.60.2">Specifically, Ruby has the </span><strong class="source-inline"><span class="koboSpan" id="kobo.61.1">Gem::Version</span></strong><span class="koboSpan" id="kobo.62.1"> class, which will solve our problem at hand. </span><span class="koboSpan" id="kobo.62.2">We’ll include it in our example, but to make sure that the validation works, we will compare it to version </span><strong class="source-inline"><span class="koboSpan" id="kobo.63.1">'3.0'</span></strong><span class="koboSpan" id="kobo.64.1">. </span><span class="koboSpan" id="kobo.64.2">Once we’ve tested the validation, we can add the correct version (</span><strong class="source-inline"><span class="koboSpan" id="kobo.65.1">'2.6'</span></strong><span class="koboSpan" id="kobo.66.1">). </span><span class="koboSpan" id="kobo.66.2">Our code now looks </span><span class="No-Break"><span class="koboSpan" id="kobo.67.1">like this:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.68.1">
# version_verification.rb
puts "Incompatible Ruby version" if Gem::Version.new(RUBY_VERSION) &lt; Gem::Version.new('3.0')
puts "We are running Ruby version #{RUBY_VERSION}"</span></pre> <p><span class="koboSpan" id="kobo.69.1">If we were to run this script on our shell, we would get the </span><span class="No-Break"><span class="koboSpan" id="kobo.70.1">following output:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.71.1">
Incompatible Ruby version
We are running Ruby version 2.6.8</span></pre> <p><span class="koboSpan" id="kobo.72.1">Our validation worked, but the problem now is that we are not stopping the execution if we don’t have the correct Ruby version. </span><span class="koboSpan" id="kobo.72.2">The message showing the Ruby version should not be shown. </span><span class="koboSpan" id="kobo.72.3">If we were writing our script in PHP, we could simply use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.73.1">die()</span></strong><span class="koboSpan" id="kobo.74.1"> function (which is </span><a id="_idIndexMarker187"/><span class="koboSpan" id="kobo.75.1">equivalent to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.76.1">exit()</span></strong><span class="koboSpan" id="kobo.77.1"> language construct) and the script would stop then and there. </span><span class="koboSpan" id="kobo.77.2">However, since we are writing scripts, certain practices can make our script even more useful. </span><span class="koboSpan" id="kobo.77.3">If our program was running on the web, we would rely on HTTP response status codes (</span><a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Status"><span class="koboSpan" id="kobo.78.1">https://developer.mozilla.org/en-US/docs/Web/HTTP/Status</span></a><span class="koboSpan" id="kobo.79.1">) to tell the browser that our page was rendered and an error occurred. </span><span class="koboSpan" id="kobo.79.2">Similarly, in scripts, we rely on exit codes (</span><a href="https://www.baeldung.com/linux/status-codes"><span class="koboSpan" id="kobo.80.1">https://www.baeldung.com/linux/status-codes</span></a><span class="koboSpan" id="kobo.81.1">) to tell the shell that our program failed. </span><span class="koboSpan" id="kobo.81.2">Taking that into account, we would then use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.82.1">Kernel::exit()</span></strong><span class="koboSpan" id="kobo.83.1"> method to both stop the execution and send the shell a signal that our script failed. </span><span class="koboSpan" id="kobo.83.2">This method receives an argument that is then sent to the shell. </span><span class="koboSpan" id="kobo.83.3">This argument is an error code that can be used by the operating system. </span><span class="koboSpan" id="kobo.83.4">We will be using error code </span><strong class="source-inline"><span class="koboSpan" id="kobo.84.1">1</span></strong><span class="koboSpan" id="kobo.85.1"> as it refers to a general error. </span><span class="koboSpan" id="kobo.85.2">After making this adjustment, our code would now look </span><span class="No-Break"><span class="koboSpan" id="kobo.86.1">like this:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.87.1">
# version_verification.rb
Kernel::exit(1) if Gem::Version.new(RUBY_VERSION) &lt; Gem::Version.new('3.0')
puts "We are running Ruby version #{RUBY_VERSION}"</span></pre> <p><span class="koboSpan" id="kobo.88.1">If we run this script on the shell, there would be no output as the script stops the execution before the message. </span><span class="koboSpan" id="kobo.88.2">In Unix-based systems, right after our script stops, we can run </span><span class="No-Break"><span class="koboSpan" id="kobo.89.1">the following:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.90.1">
echo $?</span></pre> <p><span class="koboSpan" id="kobo.91.1">This would return </span><strong class="source-inline"><span class="koboSpan" id="kobo.92.1">1</span></strong><span class="koboSpan" id="kobo.93.1">, which is the same as the argument we passed to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.94.1">exit()</span></strong><span class="koboSpan" id="kobo.95.1"> method. </span><strong class="source-inline"><span class="koboSpan" id="kobo.96.1">$?</span></strong><span class="koboSpan" id="kobo.97.1"> returns the exit code of the last command that </span><span class="No-Break"><span class="koboSpan" id="kobo.98.1">was run.</span></span></p>
<p class="callout-heading"><span class="koboSpan" id="kobo.99.1">Note for Windows users</span></p>
<p class="callout"><span class="koboSpan" id="kobo.100.1">For Windows users, the shell will have a different output, depending on what Windows shell you use. </span><span class="koboSpan" id="kobo.100.2">If you’re using Powershell, you could obtain the same output by executing the </span><strong class="source-inline"><span class="koboSpan" id="kobo.101.1">echo $LastExitCode</span></strong><span class="koboSpan" id="kobo.102.1"> command </span><span class="No-Break"><span class="koboSpan" id="kobo.103.1">in PowerShell.</span></span></p>
<p><span class="koboSpan" id="kobo.104.1">Refer to the Windows documentation for more information regarding this </span><span class="No-Break"><span class="koboSpan" id="kobo.105.1">variable: </span></span><a href="https://learn.microsoft.com/en-us/powershell/module/microsoft.powershell.core/about/about_automatic_variables?view=powershell-7.3"><span class="No-Break"><span class="koboSpan" id="kobo.106.1">https://learn.microsoft.com/en-us/powershell/module/microsoft.powershell.core/about/about_automatic_variables?view=powershell-7.3</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.107.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.108.1">There is still one </span><a id="_idIndexMarker188"/><span class="koboSpan" id="kobo.109.1">last tweak we need for our Ruby version verification script to be complete. </span><span class="koboSpan" id="kobo.109.2">As I mentioned previously, we only added version </span><strong class="source-inline"><span class="koboSpan" id="kobo.110.1">'3.0'</span></strong><span class="koboSpan" id="kobo.111.1"> to make sure our code worked, but in reality, we want to verify that our installed version is greater than </span><strong class="source-inline"><span class="koboSpan" id="kobo.112.1">'2.6'</span></strong><span class="koboSpan" id="kobo.113.1">. </span><span class="koboSpan" id="kobo.113.2">So, our final verification will look </span><span class="No-Break"><span class="koboSpan" id="kobo.114.1">like this:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.115.1">
# version_verification.rb
Kernel::exit(1) if Gem::Version.new(RUBY_VERSION) &gt; Gem::Version.new('2.6')
puts "We are running Ruby version #{RUBY_VERSION}"</span></pre> <p><span class="koboSpan" id="kobo.116.1">If we executed our script on the shell, we would get </span><span class="No-Break"><span class="koboSpan" id="kobo.117.1">the following:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.118.1">
We are running Ruby version 2.6.8</span></pre> <p><span class="koboSpan" id="kobo.119.1">And with that, we have </span><a id="_idIndexMarker189"/><span class="koboSpan" id="kobo.120.1">made sure that if our script is executed with a Ruby version lower than </span><strong class="source-inline"><span class="koboSpan" id="kobo.121.1">'2.6'</span></strong><span class="koboSpan" id="kobo.122.1"> (for example, </span><strong class="source-inline"><span class="koboSpan" id="kobo.123.1">'2.5.7'</span></strong><span class="koboSpan" id="kobo.124.1"> or </span><strong class="source-inline"><span class="koboSpan" id="kobo.125.1">'2.2.1'</span></strong><span class="koboSpan" id="kobo.126.1">), then the script will stop and send an error signal. </span><span class="koboSpan" id="kobo.126.2">Congratulations! </span><span class="koboSpan" id="kobo.126.3">We’ve created our first useful piece of code. </span><span class="koboSpan" id="kobo.126.4">This technique is often used by seasoned Ruby developers who are very aware of version changes. </span><span class="koboSpan" id="kobo.126.5">It will be up to you to improve this snippet as you could add an error message and also add an upper limit (for example, greater than </span><strong class="source-inline"><span class="koboSpan" id="kobo.127.1">'2.5.9'</span></strong><span class="koboSpan" id="kobo.128.1"> but lower than </span><strong class="source-inline"><span class="koboSpan" id="kobo.129.1">'3.0'</span></strong><span class="koboSpan" id="kobo.130.1">). </span><span class="koboSpan" id="kobo.130.2">Now that we’ve created our first truly useful script, let’s take a look at some other useful Ruby tools for </span><span class="No-Break"><span class="koboSpan" id="kobo.131.1">handling text.</span></span></p>
<h1 id="_idParaDest-66"><a id="_idTextAnchor067"/><span class="koboSpan" id="kobo.132.1">Text handling</span></h1>
<p><span class="koboSpan" id="kobo.133.1">You will most likely encounter</span><a id="_idIndexMarker190"/><span class="koboSpan" id="kobo.134.1"> strings (texts) in your journey to becoming a Ruby developer, so it’s important to know how to handle and manipulate this type of data. </span><span class="koboSpan" id="kobo.134.2">Whether you need to capitalize, get a partial string, or even trim a string, Ruby comes with a vast arsenal of tools to manipulate text as we see fit. </span><span class="koboSpan" id="kobo.134.3">Most programming languages have this type of tool, and Ruby is not an exception. </span><span class="koboSpan" id="kobo.134.4">As an example, let’s say we wanted to grab a previously entered name and make sure that all the letters were in uppercase or lowercase. </span><span class="koboSpan" id="kobo.134.5">Ruby has two methods to do exactly that: </span><strong class="source-inline"><span class="koboSpan" id="kobo.135.1">upcase()</span></strong><span class="koboSpan" id="kobo.136.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.137.1">downcase()</span></strong><span class="koboSpan" id="kobo.138.1">. </span><span class="koboSpan" id="kobo.138.2">Let’s try them out by creating a file called </span><strong class="source-inline"><span class="koboSpan" id="kobo.139.1">string_cases.rb</span></strong><span class="koboSpan" id="kobo.140.1"> with the </span><span class="No-Break"><span class="koboSpan" id="kobo.141.1">following code:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.142.1">
first_name = "benjamin"
last_name = "BECKER"
puts "My full name is #{first_name} #{last_name}"</span></pre> <p><span class="koboSpan" id="kobo.143.1">So far, we’ve declared two variables and used interpolation to output the full name. </span><span class="koboSpan" id="kobo.143.2">Let’s say we were to run this script on the shell with </span><span class="No-Break"><span class="koboSpan" id="kobo.144.1">the following:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.145.1">
ruby string_cases.rb</span></pre> <p><span class="koboSpan" id="kobo.146.1">The output would be </span><span class="No-Break"><span class="koboSpan" id="kobo.147.1">as follows:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.148.1">
My full name is benjamin BECKER.</span></pre> <p><span class="koboSpan" id="kobo.149.1">The output is nothing unexpected, given that we declared the name with lowercase letters and the last name with uppercase letters. </span><span class="koboSpan" id="kobo.149.2">However, it doesn’t make sense to have a first name in one case and a last name in another. </span><span class="koboSpan" id="kobo.149.3">So, we can either make them both uppercase or both lowercase. </span><span class="koboSpan" id="kobo.149.4">Let’s try </span><span class="No-Break"><span class="koboSpan" id="kobo.150.1">both solutions.</span></span></p>
<h2 id="_idParaDest-67"><a id="_idTextAnchor068"/><span class="koboSpan" id="kobo.151.1">The upcase method</span></h2>
<p><span class="koboSpan" id="kobo.152.1">To make them both </span><a id="_idIndexMarker191"/><span class="koboSpan" id="kobo.153.1">uppercase, we can </span><a id="_idIndexMarker192"/><span class="koboSpan" id="kobo.154.1">use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.155.1">upcase()</span></strong><span class="koboSpan" id="kobo.156.1"> method. </span><span class="koboSpan" id="kobo.156.2">Our code will look </span><span class="No-Break"><span class="koboSpan" id="kobo.157.1">as follows:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.158.1">
first_name = "benjamin"
last_name = "BECKER"
puts "My full name is #{first_name.upcase} #{last_name}"</span></pre> <p><span class="koboSpan" id="kobo.159.1">If we tested this code by running it again on the shell, we would get the </span><span class="No-Break"><span class="koboSpan" id="kobo.160.1">following output:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.161.1">
My full name is BENJAMIN BECKER.</span></pre> <h2 id="_idParaDest-68"><a id="_idTextAnchor069"/><span class="koboSpan" id="kobo.162.1">The downcase method</span></h2>
<p><span class="koboSpan" id="kobo.163.1">Similarly, we could make</span><a id="_idIndexMarker193"/><span class="koboSpan" id="kobo.164.1"> all </span><a id="_idIndexMarker194"/><span class="koboSpan" id="kobo.165.1">characters lowercase with </span><strong class="source-inline"><span class="koboSpan" id="kobo.166.1">downcase()</span></strong><span class="koboSpan" id="kobo.167.1">. </span><span class="koboSpan" id="kobo.167.2">In this case, our code would look </span><span class="No-Break"><span class="koboSpan" id="kobo.168.1">like this:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.169.1">
first_name = "benjamin"
last_name = "BECKER"
puts "My full name is #{first_name} #{last_name.downcase}"</span></pre> <p><span class="koboSpan" id="kobo.170.1">So, with this last change, if we ran the script, we would obtain the </span><span class="No-Break"><span class="koboSpan" id="kobo.171.1">following output:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.172.1">
My full name is benjamin becker</span></pre> <p><span class="koboSpan" id="kobo.173.1">As you can see, we can change the variable’s case with both </span><strong class="source-inline"><span class="koboSpan" id="kobo.174.1">upcase()</span></strong><span class="koboSpan" id="kobo.175.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.176.1">downcase()</span></strong><span class="koboSpan" id="kobo.177.1">. </span><span class="koboSpan" id="kobo.177.2">However, we can also do the same directly to a string and not just a variable. </span><span class="koboSpan" id="kobo.177.3">To see that in action, let’s change our code to </span><span class="No-Break"><span class="koboSpan" id="kobo.178.1">the following:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.179.1">
first_name = "benjamin"
last_name = "BECKER"
puts "My full name is #{first_name} #{last_name}".upcase</span></pre> <p><span class="koboSpan" id="kobo.180.1">This time, we took the whole output string and changed it to uppercase. </span><span class="koboSpan" id="kobo.180.2">The output will be </span><span class="No-Break"><span class="koboSpan" id="kobo.181.1">as follows:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.182.1">
MY FULL NAME IS BENJAMIN BECKER</span></pre> <p><span class="koboSpan" id="kobo.183.1">And while this is</span><a id="_idIndexMarker195"/><span class="koboSpan" id="kobo.184.1"> fun and all, it’s only useful for learning purposes. </span><span class="koboSpan" id="kobo.184.2">So, let’s add some usefulness to our script with an additional method. </span><span class="koboSpan" id="kobo.184.3">For users, reading </span><a id="_idIndexMarker196"/><span class="koboSpan" id="kobo.185.1">the full name in either all uppercase or all lowercase will not make sense and certainly not look professional. </span><span class="koboSpan" id="kobo.185.2">So, let’s capitalize only the first letter of both the </span><strong class="source-inline"><span class="koboSpan" id="kobo.186.1">first_name</span></strong><span class="koboSpan" id="kobo.187.1"> and </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.188.1">last_name</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.189.1"> variables.</span></span></p>
<h2 id="_idParaDest-69"><a id="_idTextAnchor070"/><span class="koboSpan" id="kobo.190.1">The capitalize method</span></h2>
<p><span class="koboSpan" id="kobo.191.1">We can do this </span><a id="_idIndexMarker197"/><span class="koboSpan" id="kobo.192.1">with </span><a id="_idIndexMarker198"/><span class="koboSpan" id="kobo.193.1">the </span><strong class="source-inline"><span class="koboSpan" id="kobo.194.1">capitalize()</span></strong><span class="koboSpan" id="kobo.195.1"> method. </span><span class="koboSpan" id="kobo.195.2">Now, our code will look </span><span class="No-Break"><span class="koboSpan" id="kobo.196.1">like this:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.197.1">
first_name = "benjamin"
last_name = "BECKER"
puts "My full name is #{first_name.capitalize} #{last_name.capitalize}"</span></pre> <p><span class="koboSpan" id="kobo.198.1">If we run this example, the output on the shell will look </span><span class="No-Break"><span class="koboSpan" id="kobo.199.1">like this:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.200.1">
My full name is Benjamin Becker</span></pre> <p><span class="koboSpan" id="kobo.201.1">Note that Ruby “knows” what characters to make uppercase and what characters to make lowercase to get this “capitalized” output. </span><span class="koboSpan" id="kobo.201.2">Ruby has many other methods to handle and manipulate text. </span><span class="koboSpan" id="kobo.201.3">We could spend the rest of this chapter looking at many of these methods, but I’d like to focus more on other tools and challenge you to check out the text methods for yourself. </span><span class="koboSpan" id="kobo.201.4">The documentation for these methods is pretty clear, and it helps that these methods were built using the Ruby philosophy and best practices. </span><span class="koboSpan" id="kobo.201.5">I recommend that you take a look at the </span><strong class="source-inline"><span class="koboSpan" id="kobo.202.1">strip</span></strong><span class="koboSpan" id="kobo.203.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.204.1">lstrip</span></strong><span class="koboSpan" id="kobo.205.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.206.1">rstrip</span></strong><span class="koboSpan" id="kobo.207.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.208.1">start_with?</span></strong><span class="koboSpan" id="kobo.209.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.210.1">end_with?</span></strong><span class="koboSpan" id="kobo.211.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.212.1">rindex, gsub</span></strong><span class="koboSpan" id="kobo.213.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.214.1">chomp</span></strong><span class="koboSpan" id="kobo.215.1">, and </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.216.1">chop</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.217.1"> methods:</span></span></p>
<ul>
<li><a href="https://apidock.com/ruby/String/strip"><span class="No-Break"><span class="koboSpan" id="kobo.218.1">https://apidock.com/ruby/String/strip</span></span></a></li>
<li><a href="https://apidock.com/ruby/String/lstrip"><span class="No-Break"><span class="koboSpan" id="kobo.219.1">https://apidock.com/ruby/String/lstrip</span></span></a></li>
<li><a href="https://apidock.com/ruby/String/rstrip"><span class="No-Break"><span class="koboSpan" id="kobo.220.1">https://apidock.com/ruby/String/rstrip</span></span></a></li>
<li><a href="https://apidock.com/ruby/String/start_with%3F"><span class="No-Break"><span class="koboSpan" id="kobo.221.1">https://apidock.com/ruby/String/start_with%3F</span></span></a></li>
<li><a href="https://apidock.com/ruby/String/end_with%3F"><span class="No-Break"><span class="koboSpan" id="kobo.222.1">https://apidock.com/ruby/String/end_with%3F</span></span></a></li>
<li><a href="https://apidock.com/ruby/String/rindex"><span class="No-Break"><span class="koboSpan" id="kobo.223.1">https://apidock.com/ruby/String/rindex</span></span></a></li>
<li><a href="https://apidock.com/ruby/String/gsub"><span class="No-Break"><span class="koboSpan" id="kobo.224.1">https://apidock.com/ruby/String/gsub</span></span></a></li>
<li><a href="https://apidock.com/ruby/String/chomp"><span class="No-Break"><span class="koboSpan" id="kobo.225.1">https://apidock.com/ruby/String/chomp</span></span></a></li>
<li><a href="https://apidock.com/ruby/String/chop"><span class="No-Break"><span class="koboSpan" id="kobo.226.1">https://apidock.com/ruby/String/chop</span></span></a></li>
</ul>
<p><span class="koboSpan" id="kobo.227.1">You might be more familiar with the names of these methods as PHP has similar methods as the ones I just mentioned: </span><strong class="source-inline"><span class="koboSpan" id="kobo.228.1">trim</span></strong><span class="koboSpan" id="kobo.229.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.230.1">ltrim</span></strong><span class="koboSpan" id="kobo.231.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.232.1">rtrim</span></strong><span class="koboSpan" id="kobo.233.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.234.1">str_starts_with</span></strong><span class="koboSpan" id="kobo.235.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.236.1">str_ends_with</span></strong><span class="koboSpan" id="kobo.237.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.238.1">strpos</span></strong><span class="koboSpan" id="kobo.239.1">, and </span><strong class="source-inline"><span class="koboSpan" id="kobo.240.1">str_replace</span></strong><span class="koboSpan" id="kobo.241.1">. </span><span class="koboSpan" id="kobo.241.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.242.1">chomp</span></strong><span class="koboSpan" id="kobo.243.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.244.1">chop</span></strong><span class="koboSpan" id="kobo.245.1"> methods are very different in PHP, so I suggest that you take a close look at them in Ruby as they can be </span><span class="No-Break"><span class="koboSpan" id="kobo.246.1">extremely useful.</span></span></p>
<p><span class="koboSpan" id="kobo.247.1">The ease of use and usefulness of the aforementioned methods are proof of why we should rely on Ruby’s string methods to do our string manipulation. </span><span class="koboSpan" id="kobo.247.2">We could certainly write all of this functionality on our own, but that would be just reinventing the wheel and we would be wasting time and energy. </span><span class="koboSpan" id="kobo.247.3">Should you choose to do that, I certainly won’t stop you as you would probably learn a lot of Ruby in the process. </span><span class="koboSpan" id="kobo.247.4">However, in this guided tour that I’m giving you, we will stick to learning more of the tools that Ruby provides for us. </span><span class="koboSpan" id="kobo.247.5">Now, let’s look at how Ruby allows us to do another powerful action: </span><span class="No-Break"><span class="koboSpan" id="kobo.248.1">handle files.</span></span></p>
<h1 id="_idParaDest-70"><a id="_idTextAnchor071"/><span class="koboSpan" id="kobo.249.1">File manipulation</span></h1>
<p><span class="koboSpan" id="kobo.250.1">Some decades ago, one </span><a id="_idIndexMarker199"/><span class="koboSpan" id="kobo.251.1">of the few options (if not the only option) for saving information was storing it in files. </span><span class="koboSpan" id="kobo.251.2">All sort of data was stored in these files: passwords, user data, config data, and more. </span><span class="koboSpan" id="kobo.251.3">Saving information in plain text files was, at the time, the most feasible option to save information. </span><span class="koboSpan" id="kobo.251.4">It all came to an end with the advent of </span><strong class="bold"><span class="koboSpan" id="kobo.252.1">databases</span></strong><span class="koboSpan" id="kobo.253.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.254.1">DBs</span></strong><span class="koboSpan" id="kobo.255.1">) and </span><a id="_idIndexMarker200"/><span class="koboSpan" id="kobo.256.1">DB usage. </span><span class="koboSpan" id="kobo.256.2">DBs became a more feasible and popular option, and they now came in different flavors. </span><span class="koboSpan" id="kobo.256.3">While this is still true today, using a DB comes with a quite expensive cost. </span><span class="koboSpan" id="kobo.256.4">I’m not only talking about a monetary cost – I’m talking about it in terms of memory, disk, and processing time. </span><span class="koboSpan" id="kobo.256.5">So, in certain use cases, it’s still a much better option to use plain text files to store information. </span><span class="koboSpan" id="kobo.256.6">To that purpose, most programming languages, including Ruby and PHP, make this task straightforward. </span><span class="koboSpan" id="kobo.256.7">Let’s take a look at how we can take advantage of the file manipulation tooling that comes </span><span class="No-Break"><span class="koboSpan" id="kobo.257.1">with Ruby.</span></span></p>
<p><span class="koboSpan" id="kobo.258.1">Let’s suppose we wanted to grab a user’s first name from a file. </span><span class="koboSpan" id="kobo.258.2">For this, we must create a file. </span><span class="koboSpan" id="kobo.258.3">The file will be called </span><strong class="source-inline"><span class="koboSpan" id="kobo.259.1">name.txt</span></strong><span class="koboSpan" id="kobo.260.1">. </span><span class="koboSpan" id="kobo.260.2">We could name it without the file extension (</span><strong class="source-inline"><span class="koboSpan" id="kobo.261.1">.txt</span></strong><span class="koboSpan" id="kobo.262.1">) and it would have no impact on the functionality of our script, but it’s always a good practice to give hints to our fellow developers as to the intent of our script. </span><span class="koboSpan" id="kobo.262.2">It’s pretty easy to assume that a file named </span><strong class="source-inline"><span class="koboSpan" id="kobo.263.1">name.txt</span></strong><span class="koboSpan" id="kobo.264.1"> will most probably contain text, and that text will be a name. </span><span class="koboSpan" id="kobo.264.2">So, let’s create the text file and add some text </span><span class="No-Break"><span class="koboSpan" id="kobo.265.1">to it:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.266.1">
mary</span></pre> <p><span class="koboSpan" id="kobo.267.1">Now, let’s focus on opening this file. </span><span class="koboSpan" id="kobo.267.2">There are different modes when opening files in Ruby, but for now, we will focus on reading data from the file. </span><span class="koboSpan" id="kobo.267.3">Let’s create a file called </span><strong class="source-inline"><span class="koboSpan" id="kobo.268.1">reading_file.rb</span></strong><span class="koboSpan" id="kobo.269.1"> and add the following code </span><span class="No-Break"><span class="koboSpan" id="kobo.270.1">to it:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.271.1">
# reading_file.rb
File.open("name.txt")</span></pre> <p><span class="koboSpan" id="kobo.272.1">First, we have to get Ruby to open the file so that it can handle and manipulate it. </span><span class="koboSpan" id="kobo.272.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.273.1">File.open()</span></strong><span class="koboSpan" id="kobo.274.1"> method does exactly that. </span><span class="koboSpan" id="kobo.274.2">But now, we need to fetch the file’s contents to be able to use it in our script. </span><span class="koboSpan" id="kobo.274.3">First, we will assign the </span><strong class="source-inline"><span class="koboSpan" id="kobo.275.1">File.open()</span></strong><span class="koboSpan" id="kobo.276.1"> result to a variable. </span><span class="koboSpan" id="kobo.276.2">Our code will look </span><span class="No-Break"><span class="koboSpan" id="kobo.277.1">like this:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.278.1">
# reading_file.rb
file_instance = File.open("name.txt")</span></pre> <p><span class="koboSpan" id="kobo.279.1">With that, we saved the result of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.280.1">File.open()</span></strong><span class="koboSpan" id="kobo.281.1"> method to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.282.1">file_instance</span></strong><span class="koboSpan" id="kobo.283.1"> variable, which, in turn, now lets us have access to the file’s contents. </span><span class="koboSpan" id="kobo.283.2">Ruby has a very intuitive method for grabbing a file’s contents: the </span><strong class="source-inline"><span class="koboSpan" id="kobo.284.1">read()</span></strong><span class="koboSpan" id="kobo.285.1"> method. </span><span class="koboSpan" id="kobo.285.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.286.1">read()</span></strong><span class="koboSpan" id="kobo.287.1"> method grabs a file’s contents and casts it into a string. </span><span class="koboSpan" id="kobo.287.2">So, let’s grab that string and output it to make sure our script is working. </span><span class="koboSpan" id="kobo.287.3">Now, our script looks </span><span class="No-Break"><span class="koboSpan" id="kobo.288.1">like this:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.289.1">
# reading_file.rb
file_instance = File.open("name.txt")
user_name = file_instance.read
puts "The user's name is #{user_name}"</span></pre> <p><span class="koboSpan" id="kobo.290.1">If we were to run </span><a id="_idIndexMarker201"/><span class="koboSpan" id="kobo.291.1">our script on the shell with </span><strong class="source-inline"><span class="koboSpan" id="kobo.292.1">ruby reading_file.rb</span></strong><span class="koboSpan" id="kobo.293.1">, the output would be </span><span class="No-Break"><span class="koboSpan" id="kobo.294.1">as follows:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.295.1">
The user's name is mary</span></pre> <p><span class="koboSpan" id="kobo.296.1">And voilà – we have successfully read a value from a text file. </span><span class="koboSpan" id="kobo.296.2">In the code, we got Ruby to open the </span><strong class="source-inline"><span class="koboSpan" id="kobo.297.1">name.txt</span></strong><span class="koboSpan" id="kobo.298.1"> file. </span><span class="koboSpan" id="kobo.298.2">Then, from the instance we got as a result, we obtained the original file’s contents as a string. </span><span class="koboSpan" id="kobo.298.3">Lastly, we used the value in a string to output something useful to the user. </span><span class="koboSpan" id="kobo.298.4">We can get fancy and capitalize the username with our already acquainted </span><strong class="source-inline"><span class="koboSpan" id="kobo.299.1">capitalize()</span></strong><span class="koboSpan" id="kobo.300.1"> method. </span><span class="koboSpan" id="kobo.300.2">We can also test that our script is reading from the </span><strong class="source-inline"><span class="koboSpan" id="kobo.301.1">name.txt</span></strong><span class="koboSpan" id="kobo.302.1"> file. </span><span class="koboSpan" id="kobo.302.2">Let’s open the </span><strong class="source-inline"><span class="koboSpan" id="kobo.303.1">name.txt</span></strong><span class="koboSpan" id="kobo.304.1"> file and change the name contained in the file to </span><span class="No-Break"><span class="koboSpan" id="kobo.305.1">something else:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.306.1">
nancy</span></pre> <p><span class="koboSpan" id="kobo.307.1">Now, let’s run our script in the shell again with </span><strong class="source-inline"><span class="koboSpan" id="kobo.308.1">ruby reading_file.rb</span></strong><span class="koboSpan" id="kobo.309.1">. </span><span class="koboSpan" id="kobo.309.2">The output should be </span><span class="No-Break"><span class="koboSpan" id="kobo.310.1">as follows:</span></span></p>
<pre class="source-code">
<strong class="bold"><span class="koboSpan" id="kobo.311.1">The user's name is nancy</span></strong></pre> <p><span class="koboSpan" id="kobo.312.1">Regarding reading a file’s contents, this is as easy as it gets. </span><span class="koboSpan" id="kobo.312.2">The code, while not as intuitive as other examples we’ve written, is still simple and readable. </span><span class="koboSpan" id="kobo.312.3">Now, let’s write another example in which we could include the user’s last name. </span><span class="koboSpan" id="kobo.312.4">We could simply add the last name to the text file, and it would be a valid solution, but let’s look at that solution and a couple of variations. </span><span class="koboSpan" id="kobo.312.5">So, let’s add a new text file called </span><strong class="source-inline"><span class="koboSpan" id="kobo.313.1">full_name.txt</span></strong><span class="koboSpan" id="kobo.314.1"> with the </span><span class="No-Break"><span class="koboSpan" id="kobo.315.1">following content:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.316.1">
paul smith</span></pre> <p><span class="koboSpan" id="kobo.317.1">We’re going to manipulate this file with another Ruby script called </span><strong class="source-inline"><span class="koboSpan" id="kobo.318.1">full_name.rb</span></strong><span class="koboSpan" id="kobo.319.1">. </span><span class="koboSpan" id="kobo.319.2">Initially, the script is going to be the same as the </span><strong class="source-inline"><span class="koboSpan" id="kobo.320.1">reading_file.rb</span></strong><span class="koboSpan" id="kobo.321.1"> script. </span><span class="koboSpan" id="kobo.321.2">We can even just copy the file, but we are going to make some tweaks to separate the full name into </span><strong class="source-inline"><span class="koboSpan" id="kobo.322.1">name</span></strong><span class="koboSpan" id="kobo.323.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.324.1">last_name</span></strong><span class="koboSpan" id="kobo.325.1">. </span><span class="koboSpan" id="kobo.325.2">We’ll also change the </span><strong class="source-inline"><span class="koboSpan" id="kobo.326.1">name.txt</span></strong><span class="koboSpan" id="kobo.327.1"> parameter to </span><strong class="source-inline"><span class="koboSpan" id="kobo.328.1">full_name.txt</span></strong><span class="koboSpan" id="kobo.329.1">. </span><span class="koboSpan" id="kobo.329.2">So, let’s look at the code in the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.330.1">full_name.rb</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.331.1"> file:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.332.1">
# full_name.rb
file_instance = File.open("full_name.txt")
user_name = file_instance.read
puts "The user's name is #{user_name}"</span></pre> <p><span class="koboSpan" id="kobo.333.1">If we execute this script</span><a id="_idIndexMarker202"/><span class="koboSpan" id="kobo.334.1"> on the shell with </span><strong class="source-inline"><span class="koboSpan" id="kobo.335.1">ruby full_name.rb</span></strong><span class="koboSpan" id="kobo.336.1">, the output will be </span><span class="No-Break"><span class="koboSpan" id="kobo.337.1">as follows:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.338.1">
The user's name is paul smith</span></pre> <p><span class="koboSpan" id="kobo.339.1">There’s nothing unexpected here as the functionality is pretty much the same as the first script, </span><strong class="source-inline"><span class="koboSpan" id="kobo.340.1">reading_file.rb</span></strong><span class="koboSpan" id="kobo.341.1">. </span><span class="koboSpan" id="kobo.341.2">But what if we wanted to have the name and the last name capitalized? </span><span class="koboSpan" id="kobo.341.3">We could try using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.342.1">capitalize()</span></strong><span class="koboSpan" id="kobo.343.1"> method on the </span><strong class="source-inline"><span class="koboSpan" id="kobo.344.1">user_name</span></strong><span class="koboSpan" id="kobo.345.1"> variable. </span><span class="koboSpan" id="kobo.345.2">Let’s do that. </span><span class="koboSpan" id="kobo.345.3">The line where we output </span><strong class="source-inline"><span class="koboSpan" id="kobo.346.1">user_name</span></strong><span class="koboSpan" id="kobo.347.1"> will look </span><span class="No-Break"><span class="koboSpan" id="kobo.348.1">like this:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.349.1">
puts "The user's name is #{user_name.capitalize}"</span></pre> <p><span class="koboSpan" id="kobo.350.1">However, when we run the script again, the output will be </span><span class="No-Break"><span class="koboSpan" id="kobo.351.1">as follows:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.352.1">
The user's name is Paul smith</span></pre> <p><span class="koboSpan" id="kobo.353.1">Unfortunately for </span><a id="_idIndexMarker203"/><span class="koboSpan" id="kobo.354.1">us, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.355.1">capitalize()</span></strong><span class="koboSpan" id="kobo.356.1"> method only changes the first letter of the first word to uppercase. </span><span class="koboSpan" id="kobo.356.2">But do not despair, as we can accomplish the correct upper casing with just a single line of code. </span><span class="koboSpan" id="kobo.356.3">Before we do that, we will look at three additional methods: </span><strong class="source-inline"><span class="koboSpan" id="kobo.357.1">split()</span></strong><span class="koboSpan" id="kobo.358.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.359.1">map()</span></strong><span class="koboSpan" id="kobo.360.1">, </span><span class="No-Break"><span class="koboSpan" id="kobo.361.1">and </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.362.1">join()</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.363.1">.</span></span></p>
<h2 id="_idParaDest-71"><a id="_idTextAnchor072"/><span class="koboSpan" id="kobo.364.1">The split() method</span></h2>
<p><span class="koboSpan" id="kobo.365.1">We can </span><a id="_idIndexMarker204"/><span class="koboSpan" id="kobo.366.1">use </span><strong class="source-inline"><span class="koboSpan" id="kobo.367.1">split()</span></strong><span class="koboSpan" id="kobo.368.1"> to divide a</span><a id="_idIndexMarker205"/><span class="koboSpan" id="kobo.369.1"> word by spaces into an array. </span><span class="koboSpan" id="kobo.369.2">Simply put, </span><strong class="source-inline"><span class="koboSpan" id="kobo.370.1">split()</span></strong><span class="koboSpan" id="kobo.371.1"> would turn </span><strong class="source-inline"><span class="koboSpan" id="kobo.372.1">paul smith</span></strong><span class="koboSpan" id="kobo.373.1"> into an array of </span><strong class="source-inline"><span class="koboSpan" id="kobo.374.1">[ "paul", "smith" ]</span></strong><span class="koboSpan" id="kobo.375.1">, which we can use in our current situation. </span><span class="koboSpan" id="kobo.375.2">So, let’s incorporate it into </span><span class="No-Break"><span class="koboSpan" id="kobo.376.1">our code:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.377.1">
# full_name.rb
file_instance = File.open("full_name.txt")
user_name = file_instance.read.split
puts "The user's name is #{user_name[0]} #{user_name[1]}"</span></pre> <p><span class="koboSpan" id="kobo.378.1">In the preceding code, we took the string from the file and applied the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.379.1">split()</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.380.1"> method.</span></span></p>
<p><span class="koboSpan" id="kobo.381.1">This method divided the </span><strong class="source-inline"><span class="koboSpan" id="kobo.382.1">paul smith</span></strong><span class="koboSpan" id="kobo.383.1"> into an array of two elements. </span><span class="koboSpan" id="kobo.383.2">In the end, we used the element on the </span><strong class="source-inline"><span class="koboSpan" id="kobo.384.1">0</span></strong><span class="koboSpan" id="kobo.385.1"> slot (</span><strong class="source-inline"><span class="koboSpan" id="kobo.386.1">user_name[0]</span></strong><span class="koboSpan" id="kobo.387.1">) and the </span><strong class="source-inline"><span class="koboSpan" id="kobo.388.1">1</span></strong><span class="koboSpan" id="kobo.389.1"> slot (</span><strong class="source-inline"><span class="koboSpan" id="kobo.390.1">user_name[0]</span></strong><span class="koboSpan" id="kobo.391.1">) and embedded them into the string. </span><span class="koboSpan" id="kobo.391.2">For now, the output is the same, but with the advantage that we have divided the name into two words. </span><span class="koboSpan" id="kobo.391.3">We could apply the </span><strong class="source-inline"><span class="koboSpan" id="kobo.392.1">capitalize()</span></strong><span class="koboSpan" id="kobo.393.1"> method to both elements and be done with our task at hand. </span><span class="koboSpan" id="kobo.393.2">But this is when we have to take a step back and think in more broad terms for our script. </span><span class="koboSpan" id="kobo.393.3">What would happen if someone had a middle name? </span><span class="koboSpan" id="kobo.393.4">Or how would our script behave if a user had two last names? </span><span class="koboSpan" id="kobo.393.5">Our script would truncate part of the name in both of these cases. </span><span class="koboSpan" id="kobo.393.6">It is our job, as developers, to create code that is generic and that will behave properly, even with some unexpected input. </span><span class="koboSpan" id="kobo.393.7">This is where the </span><strong class="source-inline"><span class="koboSpan" id="kobo.394.1">map()</span></strong><span class="koboSpan" id="kobo.395.1"> method </span><span class="No-Break"><span class="koboSpan" id="kobo.396.1">proves useful.</span></span></p>
<h2 id="_idParaDest-72"><a id="_idTextAnchor073"/><span class="koboSpan" id="kobo.397.1">The map() method</span></h2>
<p><span class="koboSpan" id="kobo.398.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.399.1">map()</span></strong><span class="koboSpan" id="kobo.400.1"> method is</span><a id="_idIndexMarker206"/><span class="koboSpan" id="kobo.401.1"> equivalent to iterating through an array and applying a method to </span><a id="_idIndexMarker207"/><span class="koboSpan" id="kobo.402.1">each element of the array in a single line. </span><span class="koboSpan" id="kobo.402.2">It receives a method that we want to apply to each element as a parameter. </span><span class="koboSpan" id="kobo.402.3">So, let’s have another rewrite of </span><span class="No-Break"><span class="koboSpan" id="kobo.403.1">our script:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.404.1">
# full_name.rb
file_instance = File.open("full_name.txt")
user_name = file_instance.read.split.map(&amp;:capitalize)
puts "The user's name is #{user_name}"</span></pre> <p><span class="koboSpan" id="kobo.405.1">Now, the output is something slightly strange, but closer to what we’re looking for. </span><span class="koboSpan" id="kobo.405.2">If we run this script again, we will get the </span><span class="No-Break"><span class="koboSpan" id="kobo.406.1">following output:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.407.1">
The user's name is ["Paul", "Smith"]</span></pre> <p><span class="koboSpan" id="kobo.408.1">We are almost there. </span><span class="koboSpan" id="kobo.408.2">Here, we are reading the name from the file, then dividing it by spaces into words, and finally applying each word to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.409.1">capitalize()</span></strong><span class="koboSpan" id="kobo.410.1"> method. </span><span class="koboSpan" id="kobo.410.2">The problem with the output is that, yes, we’ve capitalized each element of the array, but then we are printing the whole array as a string, so the square brackets (</span><strong class="source-inline"><span class="koboSpan" id="kobo.411.1">'[ ]'</span></strong><span class="koboSpan" id="kobo.412.1">) are included on the string. </span><span class="koboSpan" id="kobo.412.2">We are missing one last step, which is where the </span><strong class="source-inline"><span class="koboSpan" id="kobo.413.1">join()</span></strong><span class="koboSpan" id="kobo.414.1"> method comes </span><span class="No-Break"><span class="koboSpan" id="kobo.415.1">in handy.</span></span></p>
<h2 id="_idParaDest-73"><a id="_idTextAnchor074"/><span class="koboSpan" id="kobo.416.1">The join() method</span></h2>
<p><span class="koboSpan" id="kobo.417.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.418.1">join()</span></strong><span class="koboSpan" id="kobo.419.1"> method does</span><a id="_idIndexMarker208"/><span class="koboSpan" id="kobo.420.1"> the opposite of </span><strong class="source-inline"><span class="koboSpan" id="kobo.421.1">split()</span></strong><span class="koboSpan" id="kobo.422.1">. </span><span class="koboSpan" id="kobo.422.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.423.1">join()</span></strong><span class="koboSpan" id="kobo.424.1"> method</span><a id="_idIndexMarker209"/><span class="koboSpan" id="kobo.425.1"> takes an array, converts it into a string, and glues each element with what we set as a parameter. </span><span class="koboSpan" id="kobo.425.2">So, the last step is to make the </span><strong class="source-inline"><span class="koboSpan" id="kobo.426.1">user_name</span></strong><span class="koboSpan" id="kobo.427.1"> array a string, each element separated by a white space. </span><span class="koboSpan" id="kobo.427.2">So, let’s add that </span><span class="No-Break"><span class="koboSpan" id="kobo.428.1">last touch:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.429.1">
# full_name.rb
file_instance = File.open("full_name.txt")
user_name = file_instance.read.split.map(&amp;:capitalize).join(' ')
puts "The user's name is #{user_name}"</span></pre> <p><span class="koboSpan" id="kobo.430.1">And with that, our generic script is done. </span><span class="koboSpan" id="kobo.430.2">Let’s take it out for a ride. </span><span class="koboSpan" id="kobo.430.3">If we were to run it on the shell, the output would be </span><span class="No-Break"><span class="koboSpan" id="kobo.431.1">as follows:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.432.1">
The user's name is Paul Smith</span></pre> <p><span class="koboSpan" id="kobo.433.1">Now, since we claim that our script is generic, it should not be an issue if we were to add a middle name. </span><span class="koboSpan" id="kobo.433.2">So, let’s change the name in the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.434.1">full_name.txt</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.435.1"> file:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.436.1">
paul isaac smith</span></pre> <p><span class="koboSpan" id="kobo.437.1">If we were to run the script again, the output would be </span><span class="No-Break"><span class="koboSpan" id="kobo.438.1">as follows:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.439.1">
The user's name is Paul Isaac Smith</span></pre> <p><span class="koboSpan" id="kobo.440.1">We are still missing the other use case that I mentioned in which some people in some countries have two last names. </span><span class="koboSpan" id="kobo.440.2">So, let’s change the name one more time in our </span><strong class="source-inline"><span class="koboSpan" id="kobo.441.1">full_name.txt</span></strong><span class="koboSpan" id="kobo.442.1"> file:</span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.443.1">
benjamin eliseo pineda avendaño</span></pre> <p><span class="koboSpan" id="kobo.444.1">As with the other </span><a id="_idIndexMarker210"/><span class="koboSpan" id="kobo.445.1">examples, the script will run correctly and output</span><a id="_idIndexMarker211"/> <span class="No-Break"><span class="koboSpan" id="kobo.446.1">the following:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.447.1">
The user's name is Benjamin Eliseo Pineda Avendaño</span></pre> <p><span class="koboSpan" id="kobo.448.1">We’ve successfully made a truly generic piece of code. </span><span class="koboSpan" id="kobo.448.2">It will work whether we add a single name, a generic name (name and last name), or a special combination of first, middle, and two last names. </span><span class="koboSpan" id="kobo.448.3">While the code is not as readable as other snippets we’ve read, I can guarantee that you will encounter a combination of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.449.1">split()</span></strong><span class="koboSpan" id="kobo.450.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.451.1">map()</span></strong><span class="koboSpan" id="kobo.452.1">, and </span><strong class="source-inline"><span class="koboSpan" id="kobo.453.1">join()</span></strong><span class="koboSpan" id="kobo.454.1"> methods whenever you move into more advanced code. </span><span class="koboSpan" id="kobo.454.2">Once we get to using the Ruby on Rails framework, you will see and use both of these </span><span class="No-Break"><span class="koboSpan" id="kobo.455.1">methods there.</span></span></p>
<p><span class="koboSpan" id="kobo.456.1">So far, we’ve only written code in read-only mode. </span><span class="koboSpan" id="kobo.456.2">Now, let’s look at creating and modifying </span><span class="No-Break"><span class="koboSpan" id="kobo.457.1">file contents.</span></span></p>
<h2 id="_idParaDest-74"><a id="_idTextAnchor075"/><span class="koboSpan" id="kobo.458.1">Creating and modifying file contents</span></h2>
<p><span class="koboSpan" id="kobo.459.1">One practical use of </span><a id="_idIndexMarker212"/><span class="koboSpan" id="kobo.460.1">reading and writing a file would be creating and modifying a counter value saved in a text file. </span><span class="koboSpan" id="kobo.460.2">What if we wanted to keep track of how many times a script has been executed? </span><span class="koboSpan" id="kobo.460.3">We could add a file with a number and each time we run the script, we could increment this value and simply output it to the user. </span><span class="koboSpan" id="kobo.460.4">We’ll start by creating a file called </span><strong class="source-inline"><span class="koboSpan" id="kobo.461.1">counter.rb</span></strong><span class="koboSpan" id="kobo.462.1"> with the </span><span class="No-Break"><span class="koboSpan" id="kobo.463.1">following code:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.464.1">
# counter.rb
file_instance = File.open("counter.txt", "w")
counter = file_instance.read
puts "Time(s) script has been run: #{counter}"</span></pre> <p><span class="koboSpan" id="kobo.465.1">Again, we are opening a file, but in this case, we’ve added an additional parameter (</span><strong class="source-inline"><span class="koboSpan" id="kobo.466.1">"w"</span></strong><span class="koboSpan" id="kobo.467.1">) so that we can write contents to the file. </span><span class="koboSpan" id="kobo.467.2">Additionally, we are going to try to create the file with our script instead of creating it by ourselves. </span><span class="koboSpan" id="kobo.467.3">So, let’s run this script from the shell with </span><strong class="source-inline"><span class="koboSpan" id="kobo.468.1">ruby counter.rb</span></strong><span class="koboSpan" id="kobo.469.1">. </span><span class="koboSpan" id="kobo.469.2">The output should be </span><span class="No-Break"><span class="koboSpan" id="kobo.470.1">as follows:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.471.1">
counter.rb:3:in 'read': not opened for reading (IOError)
     from counter.rb:3:in '&lt;main&gt;'</span></pre> <p><span class="koboSpan" id="kobo.472.1">Unfortunately for us, this is an error. </span><span class="koboSpan" id="kobo.472.2">If we look closer at the error description, it reads </span><strong class="source-inline"><span class="koboSpan" id="kobo.473.1">not opened for reading</span></strong><span class="koboSpan" id="kobo.474.1">. </span><span class="koboSpan" id="kobo.474.2">This is because we set </span><strong class="source-inline"><span class="koboSpan" id="kobo.475.1">"w"</span></strong><span class="koboSpan" id="kobo.476.1"> mode, which is a write-only mode. </span><span class="koboSpan" id="kobo.476.2">We can only write to the file in this mode. </span><span class="koboSpan" id="kobo.476.3">However, we need to both read and write the contents of the file. </span><span class="koboSpan" id="kobo.476.4">Also, notice that the </span><strong class="source-inline"><span class="koboSpan" id="kobo.477.1">counter.txt</span></strong><span class="koboSpan" id="kobo.478.1"> file has been created, and that’s an advantage of </span><strong class="source-inline"><span class="koboSpan" id="kobo.479.1">"w"</span></strong><span class="koboSpan" id="kobo.480.1"> mode. </span><span class="koboSpan" id="kobo.480.2">If the file we are trying to write doesn’t exist, it will create it for us. </span><span class="koboSpan" id="kobo.480.3">We want this behavior, but we also want to be able to read the contents of the file. </span><span class="koboSpan" id="kobo.480.4">So, let’s</span><a id="_idIndexMarker213"/><span class="koboSpan" id="kobo.481.1"> change the mode to </span><strong class="source-inline"><span class="koboSpan" id="kobo.482.1">"a+"</span></strong><span class="koboSpan" id="kobo.483.1"> in </span><span class="No-Break"><span class="koboSpan" id="kobo.484.1">our script:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.485.1">
# counter.rb
file_instance = File.open("counter.txt", "a+")
counter = file_instance.read
puts "Time(s) script has been run: #{counter}"</span></pre> <p><span class="koboSpan" id="kobo.486.1">Don’t forget to delete the </span><strong class="source-inline"><span class="koboSpan" id="kobo.487.1">counter.txt</span></strong><span class="koboSpan" id="kobo.488.1"> file and execute the script again. </span><span class="koboSpan" id="kobo.488.2">The output will now look </span><span class="No-Break"><span class="koboSpan" id="kobo.489.1">like this:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.490.1">
Time(s) script has been run:</span></pre> <p><span class="koboSpan" id="kobo.491.1">If we check the folder in which our script is, we will notice that the </span><strong class="source-inline"><span class="koboSpan" id="kobo.492.1">counter.txt</span></strong><span class="koboSpan" id="kobo.493.1"> file has been created. </span><span class="koboSpan" id="kobo.493.2">However, the value is empty, which is unintended. </span><span class="koboSpan" id="kobo.493.3">So, let’s tweak our script to convert that into </span><span class="No-Break"><span class="koboSpan" id="kobo.494.1">a number:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.495.1">
# counter.rb
file_instance = File.open("counter.txt", "a+")
counter = file_instance.read.to_i
puts "Time(s) script has been run: #{counter}"</span></pre> <p><span class="koboSpan" id="kobo.496.1">Notice that on line 3 of our script, we’ve added </span><strong class="source-inline"><span class="koboSpan" id="kobo.497.1">.to_i</span></strong><span class="koboSpan" id="kobo.498.1"> at the end of the line, which converts the contents of the string into a number. </span><span class="koboSpan" id="kobo.498.2">In this scenario, the file is empty and thus returns an empty string, which, in turn, is converted into a </span><strong class="source-inline"><span class="koboSpan" id="kobo.499.1">0</span></strong><span class="koboSpan" id="kobo.500.1">. </span><span class="koboSpan" id="kobo.500.2">Let’s run this script again. </span><span class="koboSpan" id="kobo.500.3">The output will be </span><span class="No-Break"><span class="koboSpan" id="kobo.501.1">as follows:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.502.1">
Time(s) script has been run: 0</span></pre> <p><span class="koboSpan" id="kobo.503.1">So far, so good. </span><span class="koboSpan" id="kobo.503.2">However, if we</span><a id="_idIndexMarker214"/><span class="koboSpan" id="kobo.504.1"> run it again, the output will remain the same as we have not added the functionality to increment the number. </span><span class="koboSpan" id="kobo.504.2">Let’s do </span><span class="No-Break"><span class="koboSpan" id="kobo.505.1">just that:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.506.1">
# counter.rb
file_instance = File.open("counter.txt", "a+")
counter = file_instance.read.to_i
puts "Time(s) script has been run: #{counter}"
counter += 1
File.write("counter.txt", counter)</span></pre> <p><span class="koboSpan" id="kobo.507.1">With the last two lines, we’ve incremented the counter value by one and written the said value to the same </span><strong class="source-inline"><span class="koboSpan" id="kobo.508.1">counter.txt</span></strong><span class="koboSpan" id="kobo.509.1"> file. </span><span class="koboSpan" id="kobo.509.2">As a final test for this script, let’s delete the </span><strong class="source-inline"><span class="koboSpan" id="kobo.510.1">counter.txt</span></strong><span class="koboSpan" id="kobo.511.1"> file once more and run the script a few times. </span><span class="koboSpan" id="kobo.511.2">This should be </span><span class="No-Break"><span class="koboSpan" id="kobo.512.1">the output:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.513.1">
Time(s) script has been run: 0
Time(s) script has been run: 1
Time(s) script has been run: 2
Time(s) script has been run: 3</span></pre> <p><span class="koboSpan" id="kobo.514.1">With this output, we can confirm that our script has run correctly a couple of times. </span><span class="koboSpan" id="kobo.514.2">As I mentioned previously, even with the existence of DBs, file reading and writing can be useful, be it for saving configuration values or for logging, and it is fast and easy to implement. </span><span class="koboSpan" id="kobo.514.3">You can find additional examples and modes </span><span class="No-Break"><span class="koboSpan" id="kobo.515.1">at </span></span><a href="https://www.rubyguides.com/2015/05/working-with-files-ruby/"><span class="No-Break"><span class="koboSpan" id="kobo.516.1">https://www.rubyguides.com/2015/05/working-with-files-ruby/</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.517.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.518.1">Now that we’ve established how we can read and write to and from files, let’s take a look at the next feature that will help us give our scripts more usefulness: </span><span class="No-Break"><span class="koboSpan" id="kobo.519.1">command-line arguments.</span></span></p>
<h1 id="_idParaDest-75"><a id="_idTextAnchor076"/><span class="koboSpan" id="kobo.520.1">Command-line arguments</span></h1>
<p><span class="koboSpan" id="kobo.521.1">So far, we’ve added both variable and </span><a id="_idIndexMarker215"/><span class="koboSpan" id="kobo.522.1">fixed (either numeric or string) values to our code. </span><span class="koboSpan" id="kobo.522.2">To make our scripts more generic and more usable for other folks, we can add parameters that won’t be hardcoded within the code. </span><span class="koboSpan" id="kobo.522.3">If you’re not familiar with the term, </span><em class="italic"><span class="koboSpan" id="kobo.523.1">hardcoded</span></em><span class="koboSpan" id="kobo.524.1"> is the practice of writing fixed variable values within code. </span><span class="koboSpan" id="kobo.524.2">In our previous examples, we added the filename that we were going to open as a fixed value – that is, to change it, we would have to change the source code. </span><span class="koboSpan" id="kobo.524.3">To avoid that, we could pass the script a value (a filename, in this case) that whoever runs the script can change. </span><span class="koboSpan" id="kobo.524.4">Passing values to a script is what we commonly refer to as command-line arguments. </span><span class="koboSpan" id="kobo.524.5">We can have multiple arguments, a single argument, or as we’ve done so far, no arguments. </span><span class="koboSpan" id="kobo.524.6">Let’s start with a simple example, then work our way up to more complex examples that will help us make our scripts </span><span class="No-Break"><span class="koboSpan" id="kobo.525.1">more generic.</span></span></p>
<p><span class="koboSpan" id="kobo.526.1">Let’s start by taking a string as a command-line argument on a script, format it, and output it to the shell. </span><span class="koboSpan" id="kobo.526.2">We will start by creating a script called </span><strong class="source-inline"><span class="koboSpan" id="kobo.527.1">command_line.rb</span></strong><span class="koboSpan" id="kobo.528.1"> with the </span><span class="No-Break"><span class="koboSpan" id="kobo.529.1">following code:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.530.1">
# command_line.rb
input_arguments = ARGV
puts "Hello #{input_arguments[0]}"</span></pre> <p><span class="koboSpan" id="kobo.531.1">In this script, we are using </span><strong class="source-inline"><span class="koboSpan" id="kobo.532.1">ARGV</span></strong><span class="koboSpan" id="kobo.533.1">, which is an array that contains any parameters passed to our script, then assigns it to a variable, to finally pass its first value to a string to be outputted. </span><span class="koboSpan" id="kobo.533.2">Let’s try running the script. </span><span class="koboSpan" id="kobo.533.3">First, let’s try it with no arguments by running this on </span><span class="No-Break"><span class="koboSpan" id="kobo.534.1">the shell:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.535.1">
ruby command_line.rb</span></pre> <p><span class="koboSpan" id="kobo.536.1">This will output </span><span class="No-Break"><span class="koboSpan" id="kobo.537.1">the following:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.538.1">
Hello</span></pre> <p><span class="koboSpan" id="kobo.539.1">We received this output we have not passed any command-line arguments to our script. </span><span class="koboSpan" id="kobo.539.2">So, how do we pass arguments, you may ask? </span><span class="koboSpan" id="kobo.539.3">Well, it’s as simple as writing the value right after the filename when we run it. </span><span class="koboSpan" id="kobo.539.4">Now, let’s try this with a name value. </span><span class="koboSpan" id="kobo.539.5">On the shell, run </span><span class="No-Break"><span class="koboSpan" id="kobo.540.1">the following:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.541.1">
ruby command_line.rb marco</span></pre> <p><span class="koboSpan" id="kobo.542.1">We will now see the </span><span class="No-Break"><span class="koboSpan" id="kobo.543.1">following output:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.544.1">
Hello marco</span></pre> <p><span class="koboSpan" id="kobo.545.1">As we can see, Ruby detects a single value on the </span><strong class="source-inline"><span class="koboSpan" id="kobo.546.1">ARGV</span></strong><span class="koboSpan" id="kobo.547.1"> array, and as a result, the output shows the same value we passed to the script. </span><span class="koboSpan" id="kobo.547.2">Unlike the value we obtained through opening a file, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.548.1">ARGV</span></strong><span class="koboSpan" id="kobo.549.1"> array works a bit differently. </span><span class="koboSpan" id="kobo.549.2">Let’s try adding a second argument to our script. </span><span class="koboSpan" id="kobo.549.3">Let’s run it with both a different name and a second parameter. </span><span class="koboSpan" id="kobo.549.4">Back in the shell, run the following:</span></p>
<pre class="console"><span class="koboSpan" id="kobo.550.1">
ruby command_line.rb ben franco</span></pre> <p><span class="koboSpan" id="kobo.551.1">The output will be </span><span class="No-Break"><span class="koboSpan" id="kobo.552.1">as follows:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.553.1">
Hello ben</span></pre> <p><span class="koboSpan" id="kobo.554.1">This is because we</span><a id="_idIndexMarker216"/><span class="koboSpan" id="kobo.555.1"> are only using the first value of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.556.1">input_arguments</span></strong><span class="koboSpan" id="kobo.557.1"> array – that is, the value contained in </span><strong class="source-inline"><span class="koboSpan" id="kobo.558.1">input_arguments[0]</span></strong><span class="koboSpan" id="kobo.559.1">. </span><span class="koboSpan" id="kobo.559.2">Ruby takes the string that is passed as an argument, automatically splits it by spaces, and then places each element in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.560.1">ARGV</span></strong><span class="koboSpan" id="kobo.561.1"> array. </span><span class="koboSpan" id="kobo.561.2">Let’s use all of the arguments that are being passed and wrap up this example. </span><span class="koboSpan" id="kobo.561.3">We will take the </span><strong class="source-inline"><span class="koboSpan" id="kobo.562.1">map()</span></strong><span class="koboSpan" id="kobo.563.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.564.1">join()</span></strong><span class="koboSpan" id="kobo.565.1"> combo that we previously used in the file handling examples to glue and show all arguments passed to the script, and since it’s a name, we will capitalize it in the process. </span><span class="koboSpan" id="kobo.565.2">So, let’s tweak our script once more so that it does </span><span class="No-Break"><span class="koboSpan" id="kobo.566.1">just that:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.567.1">
# command_line.rb
input_arguments = ARGV
puts "Hello #{input_arguments.map(&amp;:capitalize).join(' ')}"</span></pre> <p><span class="koboSpan" id="kobo.568.1">Now, let’s run it a couple of times with different names </span><span class="No-Break"><span class="koboSpan" id="kobo.569.1">each time:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.570.1">
ruby command_line.rb ben aaron jones</span></pre> <p><span class="koboSpan" id="kobo.571.1">This will output </span><span class="No-Break"><span class="koboSpan" id="kobo.572.1">the following:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.573.1">
Hello Ben Aaron Jones</span></pre> <p><span class="koboSpan" id="kobo.574.1">Let’s try it with </span><span class="No-Break"><span class="koboSpan" id="kobo.575.1">more parameters:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.576.1">
ruby command_line.rb gaby audra luna WOODHOUSE</span></pre> <p><span class="koboSpan" id="kobo.577.1">This will output </span><span class="No-Break"><span class="koboSpan" id="kobo.578.1">the following:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.579.1">
Hello Gaby Audra Luna Woodhouse</span></pre> <p><span class="koboSpan" id="kobo.580.1">The same goes for running it with fewer arguments. </span><span class="koboSpan" id="kobo.580.2">Let’s give this one more try with a </span><span class="No-Break"><span class="koboSpan" id="kobo.581.1">single name:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.582.1">
ruby command_line.rb al</span></pre> <p><span class="koboSpan" id="kobo.583.1">This will also run but with a single name, just like on the first iteration of the script. </span><span class="koboSpan" id="kobo.583.2">The output will be </span><span class="No-Break"><span class="koboSpan" id="kobo.584.1">as follows:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.585.1">
Hello Al</span></pre> <p><span class="koboSpan" id="kobo.586.1">Now that we </span><a id="_idIndexMarker217"/><span class="koboSpan" id="kobo.587.1">understand the basics of command-line arguments, let’s start giving them a bit more usefulness. </span><span class="koboSpan" id="kobo.587.2">Let’s write a script that will take two arguments, the first being a name and the second being a digit. </span><span class="koboSpan" id="kobo.587.3">We will get our script to get the digit and print the name as many times as that digit. </span><span class="koboSpan" id="kobo.587.4">We will also add an error message if the script is run with fewer or more arguments than what we need for our script to work. </span><span class="koboSpan" id="kobo.587.5">So, let’s start by creating a file called </span><strong class="source-inline"><span class="koboSpan" id="kobo.588.1">validate_arguments.rb</span></strong><span class="koboSpan" id="kobo.589.1"> and add the following code </span><span class="No-Break"><span class="koboSpan" id="kobo.590.1">to it:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.591.1">
# validate_arguments.rb
input_arguments = ARGV
name = input_arguments.first
cycle_times = input_arguments.last.to_i
cycle_times.times { puts name }</span></pre> <p><span class="koboSpan" id="kobo.592.1">In this script, we get the command-line arguments and use the first one as the name and the last one as the counter for our cycle. </span><span class="koboSpan" id="kobo.592.2">With the </span><strong class="source-inline"><span class="koboSpan" id="kobo.593.1">cycle_times</span></strong><span class="koboSpan" id="kobo.594.1"> variable, we’re casting (or converting) the value of the last element of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.595.1">input_arguments</span></strong><span class="koboSpan" id="kobo.596.1"> array from a string into an integer. </span><span class="koboSpan" id="kobo.596.2">Then, we’re using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.597.1">times</span></strong><span class="koboSpan" id="kobo.598.1"> method to repeat a piece of code inside the curly brackets. </span><span class="koboSpan" id="kobo.598.2">Now, let’s try running our script with the </span><span class="No-Break"><span class="koboSpan" id="kobo.599.1">following values:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.600.1">
ruby validate_arguments.rb gabriela 5</span></pre> <p><span class="koboSpan" id="kobo.601.1">As expected, the output of the script is </span><span class="No-Break"><span class="koboSpan" id="kobo.602.1">as follows:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.603.1">
gabriela
gabriela
gabriela
gabriela
gabriela</span></pre> <p><span class="koboSpan" id="kobo.604.1">We may think our work here is done, but we’d be wrong. </span><span class="koboSpan" id="kobo.604.2">This is what we call the </span><em class="italic"><span class="koboSpan" id="kobo.605.1">happy path</span></em><span class="koboSpan" id="kobo.606.1">, in which we feed our script values that the script is expecting and thus the script’s behavior is correct. </span><span class="koboSpan" id="kobo.606.2">However, this is utopic as this never happens in real life. </span><span class="koboSpan" id="kobo.606.3">In real life, the user will forget to feed the script both parameters or will feed the parameters in the wrong order. </span><span class="koboSpan" id="kobo.606.4">We, as coders, need to take this into account and code appropriately. </span><span class="koboSpan" id="kobo.606.5">We need to validate that the input we feed the script is either correct or that we need to tell the user that the parameters are incorrect. </span><span class="koboSpan" id="kobo.606.6">What happens if we invert the parameters? </span><span class="No-Break"><span class="koboSpan" id="kobo.607.1">Let’s see:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.608.1">
ruby validate_arguments.rb 5 gabriela</span></pre> <p><span class="koboSpan" id="kobo.609.1">This outputs nothing. </span><span class="koboSpan" id="kobo.609.2">Let’s try running the script with </span><span class="No-Break"><span class="koboSpan" id="kobo.610.1">no arguments:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.611.1">
ruby validate_arguments.rb</span></pre> <p><span class="koboSpan" id="kobo.612.1">This also outputs nothing. </span><span class="koboSpan" id="kobo.612.2">This is a mistake on our side because we know how our script works, but someone who might be using the script doesn’t. </span><span class="koboSpan" id="kobo.612.3">There is no documentation and the least we can do is output error messages that can guide the user as to the correct usage of the </span><a id="_idIndexMarker218"/><span class="koboSpan" id="kobo.613.1">script. </span><span class="koboSpan" id="kobo.613.2">Additionally, we have to assume that the end user does not know how to program and is not going to open the script to view its usage. </span><span class="koboSpan" id="kobo.613.3">So, let’s start by validating that the script only receives two arguments. </span><span class="koboSpan" id="kobo.613.4">Also, let’s add an error message to help the user out. </span><span class="koboSpan" id="kobo.613.5">Let’s create our validation in our code. </span><span class="koboSpan" id="kobo.613.6">Our </span><strong class="source-inline"><span class="koboSpan" id="kobo.614.1">validate_arguments.rb</span></strong><span class="koboSpan" id="kobo.615.1"> script will now look </span><span class="No-Break"><span class="koboSpan" id="kobo.616.1">like this:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.617.1">
# validate_arguments.rb
if ARGV.size != 2
  puts "Error. </span><span class="koboSpan" id="kobo.617.2">The script has failed!"
</span><span class="koboSpan" id="kobo.617.3">end
input_arguments = ARGV
name = input_arguments.first
cycle_times = input_arguments.last.to_i
cycle_times.times { puts name }</span></pre> <p><span class="koboSpan" id="kobo.618.1">Now, when we run it again without any arguments, we will see an </span><span class="No-Break"><span class="koboSpan" id="kobo.619.1">error message:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.620.1">
Error. </span><span class="koboSpan" id="kobo.620.2">The script has failed!</span></pre> <p><span class="koboSpan" id="kobo.621.1">However, even though we are seeing an error, the script is still going through the whole code, which is not what we want. </span><span class="koboSpan" id="kobo.621.2">To prove this, let’s add another message at the end of </span><span class="No-Break"><span class="koboSpan" id="kobo.622.1">the code:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.623.1">
# validate_arguments.rb
if ARGV.size != 2
  puts "Error. </span><span class="koboSpan" id="kobo.623.2">The script has failed!"
</span><span class="koboSpan" id="kobo.623.3">end
input_arguments = ARGV
name = input_arguments.first
cycle_times = input_arguments.last.to_i
cycle_times.times { puts name }
puts "But we are still running the script"</span></pre> <p><span class="koboSpan" id="kobo.624.1">Let’s run the script again (with </span><span class="No-Break"><span class="koboSpan" id="kobo.625.1">no arguments):</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.626.1">
ruby validate_arguments.rb</span></pre> <p><span class="koboSpan" id="kobo.627.1">The output will be </span><a id="_idIndexMarker219"/><span class="No-Break"><span class="koboSpan" id="kobo.628.1">as follows:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.629.1">
Error. </span><span class="koboSpan" id="kobo.629.2">The script has failed!
</span><span class="koboSpan" id="kobo.629.3">But we are still running the script.</span></pre> <p><span class="koboSpan" id="kobo.630.1">As we learned previously, we need to stop the execution of the script once we’ve figured out that we have errors. </span><span class="koboSpan" id="kobo.630.2">So, let’s fix this and stop the execution with a </span><strong class="source-inline"><span class="koboSpan" id="kobo.631.1">Kernel::exit()</span></strong><span class="koboSpan" id="kobo.632.1"> call. </span><span class="koboSpan" id="kobo.632.2">Let’s also add a suggestion to fix </span><span class="No-Break"><span class="koboSpan" id="kobo.633.1">the problem:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.634.1">
# validate_arguments.rb
if ARGV.size != 2
  puts "Error. </span><span class="koboSpan" id="kobo.634.2">The script has failed!"
</span><span class="koboSpan" id="kobo.634.3">  puts "Usage: ruby validate_arguments.rb name times_to_repeat"
  Kernel::exit(1)
end
input_arguments = ARGV
name = input_arguments.first
cycle_times = input_arguments.last.to_i
cycle_times.times { puts name }
puts "But we are still running the script"</span></pre> <p><span class="koboSpan" id="kobo.635.1">Let’s run the script once again </span><span class="No-Break"><span class="koboSpan" id="kobo.636.1">without arguments:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.637.1">
ruby validate_arguments.rb</span></pre> <p><span class="koboSpan" id="kobo.638.1">This time, we will get the correct output, and the execution will be stopped at the </span><span class="No-Break"><span class="koboSpan" id="kobo.639.1">right point:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.640.1">
Error. </span><span class="koboSpan" id="kobo.640.2">The script has failed!
</span><span class="koboSpan" id="kobo.640.3">Usage: ruby validate_arguments.rb name times_to_repeat</span></pre> <p><span class="koboSpan" id="kobo.641.1">As you can see, we are no longer outputting the </span><strong class="source-inline"><span class="koboSpan" id="kobo.642.1">But we are still running the script.</span></strong><span class="koboSpan" id="kobo.643.1"> message. </span><span class="koboSpan" id="kobo.643.2">This is because once the script does not pass the validation block, its execution is stopped. </span><span class="koboSpan" id="kobo.643.3">This is great progress for our script. </span><span class="koboSpan" id="kobo.643.4">However, we are still missing one piece of validation. </span><span class="koboSpan" id="kobo.643.5">In previous examples, we inverted the arguments by passing the number and then the name. </span><span class="koboSpan" id="kobo.643.6">Even with our tweaks and validations, this is a use case that will still make </span><a id="_idIndexMarker220"/><span class="koboSpan" id="kobo.644.1">our script behave erroneously. </span><span class="koboSpan" id="kobo.644.2">Let’s try </span><span class="No-Break"><span class="koboSpan" id="kobo.645.1">it out:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.646.1">
ruby validate_arguments.rb 3 henry</span></pre> <p><span class="koboSpan" id="kobo.647.1">This will output </span><span class="No-Break"><span class="koboSpan" id="kobo.648.1">the following:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.649.1">
We are still running the script.</span></pre> <p><span class="koboSpan" id="kobo.650.1">Again, we have no information as to why the output is empty, which can be very frustrating to the user. </span><span class="koboSpan" id="kobo.650.2">So, let’s add more validations to our script. </span><span class="koboSpan" id="kobo.650.3">We, as the creators of the script, know that the script is failing because the second argument should be a number – an integer, to be more precise. </span><span class="koboSpan" id="kobo.650.4">However, this validation can be slightly tricky because of the way a lot of programming languages behave, including Ruby and PHP. </span><span class="koboSpan" id="kobo.650.5">The behavior I’m referring to is the way Ruby converts a text string into an integer. </span><span class="koboSpan" id="kobo.650.6">As an example, a string such as </span><strong class="source-inline"><span class="koboSpan" id="kobo.651.1">'22'</span></strong><span class="koboSpan" id="kobo.652.1"> will be converted into an integer, </span><strong class="source-inline"><span class="koboSpan" id="kobo.653.1">22</span></strong><span class="koboSpan" id="kobo.654.1">. </span><span class="koboSpan" id="kobo.654.2">However, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.655.1">'henry'</span></strong><span class="koboSpan" id="kobo.656.1"> string will unexpectedly be converted into a valid </span><strong class="source-inline"><span class="koboSpan" id="kobo.657.1">0</span></strong><span class="koboSpan" id="kobo.658.1">, and while this is not what we need, we can certainly take advantage of this behavior. </span><span class="koboSpan" id="kobo.658.2">For our script, we need the second argument to be larger</span><a id="_idIndexMarker221"/><span class="koboSpan" id="kobo.659.1"> than </span><strong class="source-inline"><span class="koboSpan" id="kobo.660.1">0</span></strong><span class="koboSpan" id="kobo.661.1">. </span><span class="koboSpan" id="kobo.661.2">So, that’s exactly what we are going </span><span class="No-Break"><span class="koboSpan" id="kobo.662.1">to validate:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.663.1">
# validate_arguments.rb
if ARGV.size != 2
  puts "Error. </span><span class="koboSpan" id="kobo.663.2">The script has failed!"
</span><span class="koboSpan" id="kobo.663.3">  puts "Usage: ruby validate_arguments.rb name times_to_repeat"
  Kernel::exit(1)
end
input_arguments = ARGV
name = input_arguments.first
cycle_times = input_arguments.last.to_i
if cycle_times &lt; 1
  puts "Error. </span><span class="koboSpan" id="kobo.663.4">The second argument has to be an integer!"
</span><span class="koboSpan" id="kobo.663.5">  puts "Usage: ruby validate_arguments.rb name times_to_repeat"
  Kernel::exit(1)
end
cycle_times.times { puts name }
puts "But we are still running the script"</span></pre> <p><span class="koboSpan" id="kobo.664.1">Let’s run the script with the incorrect </span><span class="No-Break"><span class="koboSpan" id="kobo.665.1">arguments again:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.666.1">
ruby validate_arguments.rb 3 henry</span></pre> <p><span class="koboSpan" id="kobo.667.1">We will get the </span><span class="No-Break"><span class="koboSpan" id="kobo.668.1">following output:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.669.1">
Error. </span><span class="koboSpan" id="kobo.669.2">The second argument has to be an integer!
</span><span class="koboSpan" id="kobo.669.3">Usage: ruby validate_arguments.rb name times_to_repeat</span></pre> <p><span class="koboSpan" id="kobo.670.1">With that, we have</span><a id="_idIndexMarker222"/><span class="koboSpan" id="kobo.671.1"> successfully made our script validate that the input must be two arguments. </span><span class="koboSpan" id="kobo.671.2">If we feed the script either no arguments, one argument, or more than two arguments, it will fail and send an error message describing the correct usage of the script. </span><span class="koboSpan" id="kobo.671.3">Now that we’ve looked into different ways to add input to our script, let’s look at another way to interact with the user: </span><span class="No-Break"><span class="koboSpan" id="kobo.672.1">user input.</span></span></p>
<h2 id="_idParaDest-76"><a id="_idTextAnchor077"/><span class="koboSpan" id="kobo.673.1">User input</span></h2>
<p><span class="koboSpan" id="kobo.674.1">So far, we’ve made </span><a id="_idIndexMarker223"/><span class="koboSpan" id="kobo.675.1">use of command-line arguments to make our scripts more generic, thus helping with what could be an automated script. </span><span class="koboSpan" id="kobo.675.2">Be it a shell script (as we’ve done so far) or a crontab script to be run at a designated time each day, we’ve learned the basic usage of these arguments that are fed to our scripts. </span><span class="koboSpan" id="kobo.675.3">But there is another type of argument that, while technically not a command-line argument, is closely related and is super useful when making scripts that interact with human users. </span><span class="koboSpan" id="kobo.675.4">In comes </span><em class="italic"><span class="koboSpan" id="kobo.676.1">user input</span></em><span class="koboSpan" id="kobo.677.1">. </span><span class="koboSpan" id="kobo.677.2">User input helps us make a script more interactive with the user as it makes a pause in the execution of the script to wait for the user to type data and resume after the user has typed a carriage return (or the </span><em class="italic"><span class="koboSpan" id="kobo.678.1">Enter</span></em><span class="koboSpan" id="kobo.679.1"> key). </span><span class="koboSpan" id="kobo.679.2">This makes a more user-friendly interaction with the user. </span><span class="koboSpan" id="kobo.679.3">Let’s look at a simple example to see this interaction at play. </span><span class="koboSpan" id="kobo.679.4">We will create a file called </span><strong class="source-inline"><span class="koboSpan" id="kobo.680.1">user_input.rb</span></strong><span class="koboSpan" id="kobo.681.1"> and add the </span><span class="No-Break"><span class="koboSpan" id="kobo.682.1">following code:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.683.1">
# user_input.rb
puts "Enter your name:"
name = gets
puts "Hello #{name}"</span></pre> <p><span class="koboSpan" id="kobo.684.1">Now, let’s run it on </span><span class="No-Break"><span class="koboSpan" id="kobo.685.1">our shell:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.686.1">
ruby user_input.rb</span></pre> <p><span class="koboSpan" id="kobo.687.1">We will notice that the output shows the </span><span class="No-Break"><span class="koboSpan" id="kobo.688.1">following message:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.689.1">
Enter your name:</span></pre> <p><span class="koboSpan" id="kobo.690.1">We will also notice that the shell looks slightly different as it is expecting input from us. </span><span class="koboSpan" id="kobo.690.2">So, let’s do that and type a </span><a id="_idIndexMarker224"/><span class="koboSpan" id="kobo.691.1">name, hitting the </span><em class="italic"><span class="koboSpan" id="kobo.692.1">Enter</span></em><span class="koboSpan" id="kobo.693.1"> key right after </span><span class="No-Break"><span class="koboSpan" id="kobo.694.1">entering it:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.695.1">
Enter your name:
brandon</span></pre> <p><span class="koboSpan" id="kobo.696.1">Immediately, the execution of our script continues and outputs the greeting that we included in </span><span class="No-Break"><span class="koboSpan" id="kobo.697.1">our code:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.698.1">
Enter your name:
brandon
Hello brandon</span></pre> <p><span class="koboSpan" id="kobo.699.1">Notice how interactive our script has become. </span><span class="koboSpan" id="kobo.699.2">It asks for your name; we type the name and immediately we are greeted. </span><span class="koboSpan" id="kobo.699.3">While this is friendlier and more interactive, we still need to fix a couple of things in our code. </span><span class="koboSpan" id="kobo.699.4">The method we are currently using (</span><strong class="source-inline"><span class="koboSpan" id="kobo.700.1">Kernel::gets()</span></strong><span class="koboSpan" id="kobo.701.1">; see </span><a href="https://ruby-doc.org/2.7.7/Kernel.html#method-i-gets"><span class="koboSpan" id="kobo.702.1">https://ruby-doc.org/2.7.7/Kernel.html#method-i-gets</span></a><span class="koboSpan" id="kobo.703.1">) not only includes the name, but it also includes the return of carriage character (</span><strong class="source-inline"><span class="koboSpan" id="kobo.704.1">\n</span></strong><span class="koboSpan" id="kobo.705.1">) or in layman’s terms, the </span><em class="italic"><span class="koboSpan" id="kobo.706.1">Enter</span></em><span class="koboSpan" id="kobo.707.1"> key character. </span><span class="koboSpan" id="kobo.707.2">So, if we tried to compare the input to a string, we would be surprised to see that it wouldn’t behave as we would expect it to. </span><span class="koboSpan" id="kobo.707.3">Let’s try it with the </span><span class="No-Break"><span class="koboSpan" id="kobo.708.1">following code:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.709.1">
# user_input.rb
puts "Enter your name:"
name = gets
puts "Hello #{name}" if name == "brandon"</span></pre> <p><span class="koboSpan" id="kobo.710.1">Now, let’s re-run </span><span class="No-Break"><span class="koboSpan" id="kobo.711.1">our script:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.712.1">
ruby user_input.rb</span></pre> <p><span class="koboSpan" id="kobo.713.1">Let’s input the </span><span class="No-Break"><span class="koboSpan" id="kobo.714.1">name </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.715.1">brandon</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.716.1">:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.717.1">
Enter your name:
brandon</span></pre> <p><span class="koboSpan" id="kobo.718.1">This time, notice that we don’t see the greeting. </span><span class="koboSpan" id="kobo.718.2">And this is not because of a typo. </span><span class="koboSpan" id="kobo.718.3">This is because the </span><strong class="source-inline"><span class="koboSpan" id="kobo.719.1">Kernel::gets()</span></strong><span class="koboSpan" id="kobo.720.1"> method is capturing a character at the end of the name. </span><span class="koboSpan" id="kobo.720.2">In comes another method to save the day: </span><strong class="source-inline"><span class="koboSpan" id="kobo.721.1">chomp()</span></strong><span class="koboSpan" id="kobo.722.1">. </span><span class="koboSpan" id="kobo.722.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.723.1">chomp()</span></strong><span class="koboSpan" id="kobo.724.1"> method removes carriage return characters and trailing new lines from the string. </span><span class="koboSpan" id="kobo.724.2">Please refer to </span><a href="https://apidock.com/ruby/String/chomp"><span class="koboSpan" id="kobo.725.1">https://apidock.com/ruby/String/chomp</span></a><span class="koboSpan" id="kobo.726.1"> for more details regarding this method. </span><span class="koboSpan" id="kobo.726.2">Essentially, it cleans up our string and leaves the original text. </span><span class="koboSpan" id="kobo.726.3">So, let’s modify our code so that it includes this method. </span><span class="koboSpan" id="kobo.726.4">Our code will now look </span><span class="No-Break"><span class="koboSpan" id="kobo.727.1">like this:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.728.1">
# user_input.rb
puts "Enter your name:"
name = gets.chomp
puts "Hello #{name}" if name == "brandon"</span></pre> <p><span class="koboSpan" id="kobo.729.1">Let’s run it </span><span class="No-Break"><span class="koboSpan" id="kobo.730.1">once more:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.731.1">
ruby user_input.rb</span></pre> <p><span class="koboSpan" id="kobo.732.1">If we input </span><a id="_idIndexMarker225"/><span class="koboSpan" id="kobo.733.1">the name </span><strong class="source-inline"><span class="koboSpan" id="kobo.734.1">brandon</span></strong><span class="koboSpan" id="kobo.735.1"> again, we will get the </span><span class="No-Break"><span class="koboSpan" id="kobo.736.1">following result:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.737.1">
Enter your name:
brandon
Hello brandon</span></pre> <p><span class="koboSpan" id="kobo.738.1">We will finally get the correct greeting. </span><span class="koboSpan" id="kobo.738.2">So, from now on, we will get input from the user with </span><strong class="source-inline"><span class="koboSpan" id="kobo.739.1">gets.chomp</span></strong><span class="koboSpan" id="kobo.740.1"> for safe measure. </span><span class="koboSpan" id="kobo.740.2">Now, let’s fetch an integer from the user and run some code multiple times, depending on the number the </span><span class="No-Break"><span class="koboSpan" id="kobo.741.1">user typed:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.742.1">
# user_input.rb
puts "Enter your name:"
name = gets.chomp
puts "Hello #{name}" if name == "brandon"
puts "Enter the number of times to try the process"
repeat_n = gets.chomp.to_i
repeat_n.times do
  puts "trying…"
  sleep(1)
end</span></pre> <p><span class="koboSpan" id="kobo.743.1">Let’s run it on the </span><span class="No-Break"><span class="koboSpan" id="kobo.744.1">shell again:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.745.1">
ruby user_input.rb</span></pre> <p><span class="koboSpan" id="kobo.746.1">Now, let’s input the name </span><strong class="source-inline"><span class="koboSpan" id="kobo.747.1">brandon</span></strong><span class="koboSpan" id="kobo.748.1"> and enter </span><strong class="source-inline"><span class="koboSpan" id="kobo.749.1">3</span></strong><span class="koboSpan" id="kobo.750.1"> afterwards. </span><span class="koboSpan" id="kobo.750.2">This will be the </span><span class="No-Break"><span class="koboSpan" id="kobo.751.1">whole sequence:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.752.1">
Enter your name:
brandon
Hello brandon
Enter times you would like to try the process:
3
trying...
</span><span class="koboSpan" id="kobo.752.2">trying...
</span><span class="koboSpan" id="kobo.752.3">trying...</span></pre> <p><span class="koboSpan" id="kobo.753.1">After</span><a id="_idIndexMarker226"/><span class="koboSpan" id="kobo.754.1"> entering </span><strong class="source-inline"><span class="koboSpan" id="kobo.755.1">brandon</span></strong><span class="koboSpan" id="kobo.756.1">, we now output instructions to enter a digit, and right after that, we fetch an integer from the user. </span><span class="koboSpan" id="kobo.756.2">With this digit, we will print a </span><strong class="source-inline"><span class="koboSpan" id="kobo.757.1">trying…</span></strong><span class="koboSpan" id="kobo.758.1"> message and use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.759.1">sleep()</span></strong><span class="koboSpan" id="kobo.760.1"> method to pause the execution for 1 second. </span><span class="koboSpan" id="kobo.760.2">If you would like more detailed information regarding the </span><strong class="source-inline"><span class="koboSpan" id="kobo.761.1">sleep()</span></strong><span class="koboSpan" id="kobo.762.1"> method, please check out </span><a href="https://apidock.com/ruby/Kernel/sleep"><span class="koboSpan" id="kobo.763.1">https://apidock.com/ruby/Kernel/sleep</span></a><span class="koboSpan" id="kobo.764.1">. </span><span class="koboSpan" id="kobo.764.2">You will notice that the script will show the </span><strong class="source-inline"><span class="koboSpan" id="kobo.765.1">trying…</span></strong><span class="koboSpan" id="kobo.766.1"> message, pause for a second, show the second message, pause again, and finally show the last message, pause one last time, and finish the execution of the script. </span><span class="koboSpan" id="kobo.766.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.767.1">sleep()</span></strong><span class="koboSpan" id="kobo.768.1"> method is useful when we are waiting for a process to finish. </span><span class="koboSpan" id="kobo.768.2">It’s especially useful when working with API calls, which may take some time to finish. </span><span class="koboSpan" id="kobo.768.3">As a final exercise, let’s dive into a script’s friendliness </span><span class="No-Break"><span class="koboSpan" id="kobo.769.1">and usefulness.</span></span></p>
<h1 id="_idParaDest-77"><a id="_idTextAnchor078"/><span class="koboSpan" id="kobo.770.1">Putting it all together</span></h1>
<p><span class="koboSpan" id="kobo.771.1">Reading and understanding someone else’s code is essential to learning Ruby. </span><span class="koboSpan" id="kobo.771.2">With that intent, we will now look at the following example, which was written with some of the techniques we learned about in this chapter, and figure out what the script </span><span class="No-Break"><span class="koboSpan" id="kobo.772.1">is doing:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.773.1">
# main.rb
# Section 1: Ruby version validation
if Gem::Version.new(RUBY_VERSION) &lt; Gem::Version.new('2.6')
  puts "Please verify the Ruby version!"
</span><span class="koboSpan" id="kobo.773.2">  Kernel::exit(1)
end
# Section 2: Open or create user_name file
file_instance = File.open("user_name.txt", "a+")
user_name = file_instance.read
# Section 3: Empty name validation
if user_name.empty?
</span><span class="koboSpan" id="kobo.773.3">  puts "Enter your name:"
  name = gets.chomp
  File.write("user_name.txt", name)
  # Section 4: Program main log
  File.write("main.log", "Writing #{name} as the entry to user_name.txt at #{Time.now}\n", mode: "a")
  user_name =  name
end
# Section 5: Program title
puts "Hello #{user_name.capitalize}"
puts "Welcome to Chapter 4"
puts "Please enter how many times you would like to make a log entry"
# Section 6: Program cycle
repeat_n = gets.chomp.to_i
repeat_n.times do
  puts "Adding log entry..."
</span><span class="koboSpan" id="kobo.773.4">  File.write("main.log", "Adding entry to log at #{Time.now}\n", mode: "a")
  sleep(1)
end</span></pre> <p><span class="koboSpan" id="kobo.774.1">For us to understand the intent of the script, we will divide it into six sections that we have commented on the code itself. </span><span class="koboSpan" id="kobo.774.2">This is not compulsory when writing code, but I’ve taken the liberty to do this for teaching purposes. </span><span class="koboSpan" id="kobo.774.3">So, let’s take a look at the </span><span class="No-Break"><span class="koboSpan" id="kobo.775.1">first section:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.776.1">
…
# Section 1: Ruby version validation
if Gem::Version.new(RUBY_VERSION) &lt; Gem::Version.new('2.6')
  puts "Please verify the Ruby version!"
</span><span class="koboSpan" id="kobo.776.2">  Kernel::exit(1)
end
…</span></pre> <p><span class="koboSpan" id="kobo.777.1">Here, we are comparing our currently installed Ruby version and making sure that the version is higher than 2.6. </span><span class="koboSpan" id="kobo.777.2">If the version is lower than that, we print an error message and exit the program. </span><span class="koboSpan" id="kobo.777.3">This is something you might find very often in scripts as major versions tend to differ in terms of functionality and sometimes </span><span class="No-Break"><span class="koboSpan" id="kobo.778.1">in syntax.</span></span></p>
<p><span class="koboSpan" id="kobo.779.1">Let’s move on to the next section of </span><span class="No-Break"><span class="koboSpan" id="kobo.780.1">our script:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.781.1">
…
# Section 2: Open or create user_name file
file_instance = File.open("user_name.txt", "a+")
user_name = file_instance.read
…</span></pre> <p><span class="koboSpan" id="kobo.782.1">In this section, we are opening a file, but as we’ve seen in previous examples, it’s using </span><strong class="source-inline"><span class="koboSpan" id="kobo.783.1">"a+"</span></strong><span class="koboSpan" id="kobo.784.1"> mode so that if the file does not exist, it creates it. </span><span class="koboSpan" id="kobo.784.2">If the file already exists, it reads its contents. </span><span class="koboSpan" id="kobo.784.3">The script’s intent in this section is to read a user’s name from this file, but if the file is empty, the name will be empty too. </span><span class="koboSpan" id="kobo.784.4">This may seem slightly different from what we’ve been doing so far. </span><span class="koboSpan" id="kobo.784.5">However, let’s look at the next section, where this will make more sense. </span><span class="koboSpan" id="kobo.784.6">In sections 3 and 4, we can see </span><span class="No-Break"><span class="koboSpan" id="kobo.785.1">the following:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.786.1">
…
# Section 3: Empty name validation
if user_name.empty?
</span><span class="koboSpan" id="kobo.786.2">  puts "Enter your name:"
  name = gets.chomp
  File.write("user_name.txt", name)
  # Section 4: Program main log
  File.write("main.log", "Writing #{name} as the entry to user_name.txt at #{Time.now}\n", mode: "a")
  user_name =  name
end
…</span></pre> <p><span class="koboSpan" id="kobo.787.1">In section 3, we can see that if the username fetched from the file is not empty, the script moves on to the next section. </span><span class="koboSpan" id="kobo.787.2">But if the username is empty, then we prompt the user to provide a username. </span><span class="koboSpan" id="kobo.787.3">Once the user types a username, the script will write the name to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.788.1">user_name.txt</span></strong><span class="koboSpan" id="kobo.789.1"> file and move to </span><span class="No-Break"><span class="koboSpan" id="kobo.790.1">section 4.</span></span></p>
<p><span class="koboSpan" id="kobo.791.1">In section 4, the script simply writes a log entry to a </span><strong class="source-inline"><span class="koboSpan" id="kobo.792.1">main.log</span></strong><span class="koboSpan" id="kobo.793.1"> file in which it writes the name obtained from the user and the time in which the user did this. </span><span class="koboSpan" id="kobo.793.2">Lastly, the script assigns the </span><strong class="source-inline"><span class="koboSpan" id="kobo.794.1">user_name</span></strong><span class="koboSpan" id="kobo.795.1"> variable to be used later on in </span><span class="No-Break"><span class="koboSpan" id="kobo.796.1">the script.</span></span></p>
<p><span class="koboSpan" id="kobo.797.1">In section 5, we have </span><span class="No-Break"><span class="koboSpan" id="kobo.798.1">this code:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.799.1">
…
# Section 5: Program title
puts "Hello #{user_name.capitalize}"
puts "Welcome to Chapter 4"
puts "Please enter how many times you would like to make a log entry"
…</span></pre> <p><span class="koboSpan" id="kobo.800.1">In this section, we greet the user by capitalizing the name, print a welcoming message, and then print another aiding message so that the user knows what they’ll do next, which is enter </span><span class="No-Break"><span class="koboSpan" id="kobo.801.1">a number.</span></span></p>
<p><span class="koboSpan" id="kobo.802.1">In our last section, we are doing something similar to what we did in our previous looping example. </span><span class="koboSpan" id="kobo.802.2">Let’s take </span><span class="No-Break"><span class="koboSpan" id="kobo.803.1">a look:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.804.1">
…
# Section 6: Program cycle
repeat_n = gets.chomp.to_i
repeat_n.times do
  puts "Adding log entry..."
</span><span class="koboSpan" id="kobo.804.2">  File.write("main.log", "Adding entry to log at #{Time.now}\n", mode: "a")
  sleep(1)
end
…</span></pre> <p><span class="koboSpan" id="kobo.805.1">In section 6, which is the last section of the script, we’re getting a number from the user, then taking this number and doing a cycle to execute a code the number of times the user provided. </span><span class="koboSpan" id="kobo.805.2">The code to be executed simply shows a message for the user and adds multiple entry logs to the same </span><strong class="source-inline"><span class="koboSpan" id="kobo.806.1">main.log</span></strong><span class="koboSpan" id="kobo.807.1"> file. </span><span class="koboSpan" id="kobo.807.2">In this case, the script is also using the append writing mode so that when the script writes to this file, it will write contents at the end of the file instead of replacing the previous contents. </span><span class="koboSpan" id="kobo.807.3">This type of logging is both common and useful in the scripting and programming realms. </span><span class="koboSpan" id="kobo.807.4">It helps other users debug the functionality of the script, especially when things start failing. </span><span class="koboSpan" id="kobo.807.5">We are only missing one thing now: running the script. </span><span class="koboSpan" id="kobo.807.6">Let’s </span><span class="No-Break"><span class="koboSpan" id="kobo.808.1">run it:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.809.1">
ruby main.rb</span></pre> <p><span class="koboSpan" id="kobo.810.1">The first time we run this file, we will get the following output on </span><span class="No-Break"><span class="koboSpan" id="kobo.811.1">the shell:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.812.1">
Enter your name:</span></pre> <p><span class="koboSpan" id="kobo.813.1">Let’s enter </span><strong class="source-inline"><span class="koboSpan" id="kobo.814.1">daniel</span></strong><span class="koboSpan" id="kobo.815.1">. </span><span class="koboSpan" id="kobo.815.2">After we enter this name, we will get the </span><span class="No-Break"><span class="koboSpan" id="kobo.816.1">following output:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.817.1">
Hello Daniel
Welcome to chapter 4
Please enter how many times you would like to make a log entry</span></pre> <p><span class="koboSpan" id="kobo.818.1">Here, the script requires that we enter a number. </span><span class="koboSpan" id="kobo.818.2">Let’s type </span><strong class="source-inline"><span class="koboSpan" id="kobo.819.1">2</span></strong><span class="koboSpan" id="kobo.820.1">. </span><span class="koboSpan" id="kobo.820.2">The script will respond with the </span><span class="No-Break"><span class="koboSpan" id="kobo.821.1">following output:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.822.1">
Adding log entry...
</span><span class="koboSpan" id="kobo.822.2">Adding log entry...</span></pre> <p><span class="koboSpan" id="kobo.823.1">Initially, this seems simple enough. </span><span class="koboSpan" id="kobo.823.2">However, if we take a look at the contents of the folder where our script resides, we’ll notice two new files: </span><strong class="source-inline"><span class="koboSpan" id="kobo.824.1">main.log</span></strong><span class="koboSpan" id="kobo.825.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.826.1">user_name.txt</span></strong><span class="koboSpan" id="kobo.827.1"> . </span><span class="koboSpan" id="kobo.827.2">If we open the </span><strong class="source-inline"><span class="koboSpan" id="kobo.828.1">user_name.txt</span></strong><span class="koboSpan" id="kobo.829.1"> file, its contents will coincide with the name </span><span class="No-Break"><span class="koboSpan" id="kobo.830.1">we typed:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.831.1">
daniel</span></pre> <p><span class="koboSpan" id="kobo.832.1">And if we look at the </span><strong class="source-inline"><span class="koboSpan" id="kobo.833.1">main.log</span></strong><span class="koboSpan" id="kobo.834.1"> file, we will see the </span><span class="No-Break"><span class="koboSpan" id="kobo.835.1">following output:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.836.1">
Writing daniel as the entry to user_name.txt at 2022-12-25 16:33:24 -0600
Adding entry to log at 2022-12-25 16:34:53 -0600
Adding entry to log at 2022-12-25 16:34:54 -0600</span></pre> <p><span class="koboSpan" id="kobo.837.1">This content coincides with what happened on the initial run of the script. </span><span class="koboSpan" id="kobo.837.2">It wrote </span><strong class="source-inline"><span class="koboSpan" id="kobo.838.1">daniel</span></strong><span class="koboSpan" id="kobo.839.1"> to the log and added two entries to the same log. </span><span class="koboSpan" id="kobo.839.2">Now, let’s run the script </span><span class="No-Break"><span class="koboSpan" id="kobo.840.1">once more:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.841.1">
ruby main.rb</span></pre> <p><span class="koboSpan" id="kobo.842.1">This time, we will notice that the script does not ask for a user, instead using the previous username we entered. </span><span class="koboSpan" id="kobo.842.2">The output will look </span><span class="No-Break"><span class="koboSpan" id="kobo.843.1">like this:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.844.1">
Hello Daniel
Welcome to Chapter 4
Please enter how many times you would like to make a log entry</span></pre> <p><span class="koboSpan" id="kobo.845.1">This is very practical as we don’t need to enter the name every time we run the script. </span><span class="koboSpan" id="kobo.845.2">Lastly, it prompts us for a number to run the log process again. </span><span class="koboSpan" id="kobo.845.3">Let’s type </span><strong class="source-inline"><span class="koboSpan" id="kobo.846.1">1</span></strong><span class="koboSpan" id="kobo.847.1"> and wait for the response, which should look </span><span class="No-Break"><span class="koboSpan" id="kobo.848.1">like this:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.849.1">
Adding log entry...</span></pre> <p><span class="koboSpan" id="kobo.850.1">This time, as we typed </span><strong class="source-inline"><span class="koboSpan" id="kobo.851.1">1</span></strong><span class="koboSpan" id="kobo.852.1">, the cycle only ran the code once, which is what we expected. </span><span class="koboSpan" id="kobo.852.2">I hope you found this reading exercise useful and I hope you make the habit of reading other developer’s code to both learn good practices and understand how to do things </span><span class="No-Break"><span class="koboSpan" id="kobo.853.1">in Ruby.</span></span></p>
<h1 id="_idParaDest-78"><a id="_idTextAnchor079"/><span class="koboSpan" id="kobo.854.1">Summary</span></h1>
<p><span class="koboSpan" id="kobo.855.1">In this chapter, we learned how to write more useful scripts that we will probably reuse in the future. </span><span class="koboSpan" id="kobo.855.2">We also got a glimpse at some of the tools that Ruby has to handle text. </span><span class="koboSpan" id="kobo.855.3">We also learned how to open, read, and write content to and from a file and how this may come in handy when writing scripts. </span><span class="koboSpan" id="kobo.855.4">Lastly, we were exposed to Ruby’s command-line arguments, which make our automation work easier. </span><span class="koboSpan" id="kobo.855.5">We also learned of Ruby’s user input arguments, which make our scripts more interactive for users. </span><span class="koboSpan" id="kobo.855.6">Having learned this, we are now ready to undercover some misconceptions about PHP, Ruby, Ruby on Rails, and </span><span class="No-Break"><span class="koboSpan" id="kobo.856.1">other frameworks.</span></span></p>
</div>
</body></html>