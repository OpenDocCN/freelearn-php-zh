- en: Creating Your First Module
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建您的第一个模块
- en: Now that we have covered some of the introductory aspects of Drupal 8 module
    development, it's time to dive right into the meat of what we are doing here—module
    creation.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了 Drupal 8 模块开发的一些入门方面，现在是时候深入探讨我们在这里所做的工作的核心——模块创建。
- en: 'Here are some of the important topics that we will cover in this chapter:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖的一些重要主题包括：
- en: Creating a new Drupal 8 module—the files that are necessary to get started
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建新的 Drupal 8 模块——启动所需的文件
- en: Creating a route and controller
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建路由和控制器
- en: Creating and using a service
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建和使用服务
- en: Creating a form
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建表单
- en: Creating a custom block
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建自定义块
- en: Working with links
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与链接一起工作
- en: Using the Event Dispatcher
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用事件调度器
- en: Concretely, in this chapter, we will create a new custom module called *Hello
    World*. In this module, we will define a route that maps to a Controller and that
    outputs the age-old programming message. So, this will be our first win.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 具体来说，在本章中，我们将创建一个名为 *Hello World* 的新自定义模块。在这个模块中，我们将定义一个路由，它映射到一个控制器并输出古老的编程信息。所以，这将是我们第一次的成功。
- en: Next, we will define a service that our Controller will use to pimp up our message.
    After all, we don't want the same message presented to the user all day long.
    This simple example, however, will illustrate what services are and how to interact
    with the Service Container in order to make use of them.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将定义一个控制器将使用的服务来提升我们的消息。毕竟，我们不想整天向用户展示相同的信息。然而，这个简单的例子将说明服务是什么以及如何与服务容器交互以使用它们。
- en: Then, we will create a form where an administrator will be able to override
    the message shown on our page. It will be stored in configuration, and we will
    alter our service to make use of that configuration. The key takeaway here will
    be the use of the Form API. However, we will also discuss how to store some basic
    configuration values and add dependencies to our existing services.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将创建一个表单，管理员将能够覆盖我们页面上显示的消息。它将存储在配置中，我们将修改我们的服务以利用该配置。这里的关键收获将是 Form API
    的使用。然而，我们还将讨论如何存储一些基本的配置值并添加依赖到我们现有的服务中。
- en: Finally, we want to become a bit more flexible. Why should users only be greeted
    on a specific page? We will create a custom block that can be placed anywhere
    on the site and will display the same message. Here, we will see how block plugins
    are defined and how they can expose their own configuration forms to be more flexible.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们希望变得更加灵活。为什么用户只能在特定的页面上被问候呢？我们将创建一个自定义块，它可以放置在网站的任何位置并显示相同的信息。在这里，我们将看到如何定义块插件以及它们如何暴露自己的配置表单以实现更大的灵活性。
- en: Although not strictly related to our *Hello World* example, we will also look
    at how to work with links programmatically in Drupal 8\. It's a very common task
    any Drupal 8 developer needs to do very often. Moreover, we will also look at
    using the Event Dispatcher component and, more importantly, subscribing to events.
    We'll illustrate this with a fairly common example of when you'd need to do this—performing
    redirects from incoming requests.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这与我们的 *Hello World* 示例没有严格的关系，但我们还将探讨如何在 Drupal 8 中以编程方式处理链接。这对于任何 Drupal
    8 开发者来说都是非常常见的任务，他们需要经常执行。此外，我们还将探讨使用事件调度器组件，更重要的是，订阅事件。我们将通过一个相当常见的例子来说明这一点——执行来自传入请求的重定向。
- en: By the end of this chapter, you should have the foundational knowledge necessary
    to build your own module from scratch. Moreover, you should be able to understand
    and implement some of the most commonly used techniques in Drupal 8 module development.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，你应该具备构建自己模块所需的基础知识。此外，你应该能够理解和实现 Drupal 8 模块开发中最常用的技术。
- en: Creating a module
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建模块
- en: Creating a simple Drupal 8 module is not difficult. You only need one file to
    get it recognized by the core installation and to be able to enable it. In this
    state, it won't do much, but it will be installable. Let's first take a look at
    how to do this, and then we will progressively add meat to it in order to achieve
    the goals set out at the beginning of the chapter.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个简单的 Drupal 8 模块并不困难。你只需要一个文件就能让核心安装识别它，并能够启用它。在这个状态下，它不会做很多事情，但它将是可安装的。让我们首先看看如何做到这一点，然后我们将逐步添加内容，以达到本章开头设定的目标。
- en: Custom Drupal 8 modules typically belong inside the `/custom` directory of the
    `/modules` folder found inside the root Drupal installation. You would put contributed
    modules inside a `/contrib` directory instead, in order to have a clear distinction.
    This is a standard practice, so that is where we will place our custom module,
    called *Hello World*.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 自定义Drupal 8模块通常位于根Drupal安装中`/modules`文件夹内的`/custom`目录中。您会将贡献模块放在一个`/contrib`目录中，以便有明确的区分。这是一个标准做法，所以我们将把我们的自定义模块放在那里，称为*Hello
    World*。
- en: We will start by creating a folder called `hello_world`. This will also be the
    module's machine name used in many other places. Inside, we will need to create
    an *info* file that describes our module. This file is named `hello_world.info.yml`.
    This naming structure is important—first, the module name, then `info`, followed
    by the `.yml` extension. You will hear this file often referred to as the module's
    `info` file (due to it having had the `.info` extension in past versions of Drupal).
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先创建一个名为`hello_world`的文件夹。这也将是模块在许多其他地方使用的机器名。在里面，我们需要创建一个*信息*文件来描述我们的模块。此文件命名为`hello_world.info.yml`。这种命名结构很重要——首先，模块名称，然后是`info`，最后是`.yml`扩展名。您经常会听到这个文件被称为模块的`info`文件（因为过去版本的Drupal中它有`.info`扩展名）。
- en: 'Inside this file, we will need to add some minimal information that describes
    our module. We will go with something like this:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 在此文件中，我们需要添加一些最小信息来描述我们的模块。我们将采用如下方式：
- en: '[PRE0]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Some of this is self-explanatory, but let''s see what these lines mean:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 其中一些是自解释的，但让我们看看这些行意味着什么：
- en: The first two represent the human-readable name and description of the module.
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 前两个代表模块的可读名称和描述。
- en: The `type` key means that this is a module *info* file rather than a theme.
    In Drupal 8, this has become mandatory.
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`type`关键字表示这是一个模块*信息*文件，而不是主题。在Drupal 8中，这已成为强制性的。'
- en: The `core` key specifies that this module works with version 8 of Drupal, and
    it won't be installable on previous or future versions.
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`core`关键字指定此模块与Drupal 8版本兼容，并且它无法在先前或未来的版本上安装。'
- en: Finally, we place this in a generic `Custom` package so that it gets categorized
    in this group on the modules' administration screen.
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后，我们将它放在通用的`Custom`包中，以便它在模块管理屏幕的这个组中分类。
- en: That is pretty much it. The module can now be enabled either through the UI
    at `/admin/modules` or via Drush using the `drush en hello_world` command.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 大概就是这样。现在，您可以通过`/admin/modules`界面或使用`drush en hello_world`命令通过Drush启用此模块。
- en: 'Before we move on, let''s see what other options you can add (and probably
    will need to add at some point or another) to the info file:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们继续之前，让我们看看您可以在信息文件中添加哪些其他选项（并且可能需要在某个时候添加）：
- en: '*Module dependencies*: If your module depends on other modules, you can specify
    this in its info file like so:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: '*模块依赖性:* 如果您的模块依赖于其他模块，您可以在其信息文件中指定，如下所示：'
- en: '[PRE1]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The dependencies should be named in the `project:module` format, where `project`
    is the project name as it appears in the URL of the project on Drupal.org and
    `module` is the machine name of the module. You can even include version restrictions,
    for example, `ctools:ctools (>=8.x-3.x)`.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 依赖项应按`project:module`格式命名，其中`project`是Drupal.org上项目URL中出现的项目名称，`module`是模块的机器名。您甚至可以包括版本限制，例如，`ctools:ctools
    (>=8.x-3.x)`。
- en: '*Configuration:* If your module has a general configuration form that centralizes
    the configuration options of the module, you can specify the route of that form
    in the info file. Doing so will add a link to that form on the `admin/modules`
    UI page where modules are being installed.'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '*配置:* 如果您的模块有一个集中配置选项的一般配置表单，您可以在信息文件中指定该表单的路由。这样做将在安装模块的`admin/modules` UI页面上添加到该表单的链接。'
- en: Your first hook implementation
  id: totrans-33
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 您的第一个钩子实现
- en: The module as it stands doesn't do much. In fact, it does nothing. However,
    do pat yourself on the back, as you have created your first Drupal 8 module. Before
    we move on to the interesting stuff we planned out, let's implement our first
    hook responsible for providing some helpful information about our module.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 按照目前的状态，此模块并没有做什么。实际上，它什么也不做。然而，请给自己鼓掌，因为您已经创建了您的第一个Drupal 8模块。在我们继续到我们计划的有意思的内容之前，让我们实现我们的第一个钩子，它负责提供有关我们模块的一些有用信息。
- en: As we hinted at in the first chapter, when Drupal encounters an event for which
    there is a hook (and there are hundreds of such events), it will look through
    all of the modules for matching hook implementations. Now, how does it find the
    matching implementations? It looks for the functions that are named in the `module_name_hook_name`
    format, where `hook_name` is replaced by the name of the hook being implemented.
    The name of a hook is whatever comes after `hook_`. We will see an example below
    when we implement `hook_help()`. However, once it finds the implementations, it
    will then execute each of them, one after another. Once all hook implementations
    have been executed, Drupal will continue its processing.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们在第一章中暗示的那样，当Drupal遇到一个存在钩子的事件（并且有数百个这样的事件）时，它会遍历所有模块以查找匹配的钩子实现。那么，它是如何找到匹配的实现呢？它会寻找以`module_name_hook_name`格式命名的函数，其中`hook_name`被正在实现的钩子名称所替换。钩子的名称是`hook_`之后的内容。我们将在实现`hook_help()`时看到一个示例。然而，一旦找到实现，它将依次执行每个实现。一旦所有钩子实现都执行完毕，Drupal将继续其处理。
- en: Depending on the module size, it's recommended that you place all your hook
    implementations inside a `.module` file. There will be cases, however, when you'll
    organize them in other files, either by including those files inside the `.module`
    file yourself or by using specific file naming conventions that gets them included
    by Drupal. However, for now, we stick with the default.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 根据模块的大小，建议你将所有的钩子实现放在一个`.module`文件中。然而，在某些情况下，你可能会将它们组织在其他文件中，要么是你自己将这些文件包含在`.module`文件中，要么是使用特定的文件命名约定，让Drupal包含它们。但是，目前我们坚持使用默认设置。
- en: 'So, let''s create a `.module` file in our module folder called `hello_world.module`
    and place an opening PHP tag at the top. Then, we can have the following `hook_help()`
    implementation inside (and typically all other hook implementations):'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，让我们在我们的模块文件夹中创建一个名为`hello_world.module`的`.module`文件，并在顶部放置一个PHP标签。然后，我们可以在其中放置以下`hook_help()`实现（以及通常所有其他钩子实现）：
- en: '[PRE2]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: As you can see, the name of the function respects the abovementioned format—`module_name_hook_name`—because
    we are implementing `hook_help`. So, we replaced `hook` with the module name and
    `hook_name` with `help`. Moreover, this particular hook takes two parameters that
    we can use inside it; though, in our case, we only use one, that is, the route
    name.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，函数的名称遵循上述格式——`module_name_hook_name`——因为我们正在实现`hook_help`。所以，我们将`hook`替换为模块名称，将`hook_name`替换为`help`。此外，这个特定的钩子接受两个参数，我们可以在其中使用它们；尽管在我们的情况下，我们只使用一个，即路由名称。
- en: 'The purpose of this hook is to provide Drupal some help text about what this
    module does. You won''t always implement this hook, but it''s good to be aware
    of it. The way it works is that each new module receives its own route inside
    the main module, where users can browse this info—ours is `help.page.hello_world`.
    So, in this implementation, we will tell Drupal (and, more specifically, the core
    `Help` module) the following: if a user is looking at our module''s help route
    (page), show the info contained in the `$output` variable. And that''s pretty
    much it.'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 此钩子的目的是为Drupal提供一些关于此模块做什么的帮助文本。你并不总是需要实现此钩子，但了解它是有好处的。它的工作方式是，每个新模块都在主模块内部获得自己的路由，用户可以浏览这些信息——我们的路由是`help.page.hello_world`。因此，在这个实现中，我们将告诉Drupal（以及更具体地说，核心`Help`模块）以下内容：如果用户正在查看我们的模块的帮助路由（页面），则显示`$output`变量中包含的信息。就是这样。
- en: According to the Drupal coding standards, the DocBlock message above the hook
    implementation needs to stay short and concise, as in the preceding example. We
    do not generally document anything further for Drupal core hooks or popular `contrib`
    module hooks because they should be documented elsewhere. If, however, you are
    implementing a custom hook defined in one of your modules, it's okay to add a
    second paragraph describing what it does.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 根据Drupal编码标准，钩子实现上方的DocBlock消息需要保持简短和简洁，就像前面的例子一样。我们通常不会为Drupal核心钩子或流行的`contrib`模块钩子添加任何其他文档，因为它们应该在别处进行文档化。然而，如果你正在实现你模块中定义的自定义钩子，添加一个描述其功能的第二段是可以的。
- en: Users can now reach this page from the module administration page by clicking
    on the Help link for each individual module that has this hook implemented. Easy,
    right?
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 用户现在可以通过点击每个实现此钩子的模块的帮助链接，从模块管理页面访问此页面。简单，对吧？
- en: '![](img/6be3b4cd-9dc3-4b8b-8271-ea4a4a415267.png)'
  id: totrans-43
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/6be3b4cd-9dc3-4b8b-8271-ea4a4a415267.png)'
- en: Even though we are not really providing any useful info through this hook, implementing
    it helped us understand how hooks work and what the naming convention is for using
    them. Additionally, we saw an example of a traditional (procedural) Drupal extension
    point that module developers can use. In doing so, we literally extended the capability
    of the Help module by allowing it to give more info to users.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管我们并没有通过这个钩子提供任何有用的信息，但实现它帮助我们理解了钩子的工作原理以及使用它们的命名约定。此外，我们还看到了一个传统（过程式）的 Drupal
    扩展点的示例，模块开发者可以使用它。通过这样做，我们实际上扩展了帮助模块的功能，允许它向用户提供更多信息。
- en: Now, let's move on to creating something of our own.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们继续创建我们自己的内容。
- en: Route and controller
  id: totrans-46
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 路由和控制器
- en: The first real piece of functionality we set out to create was a simple Drupal
    page that outputs the age-old *Hello World* string. To do this, we will need two
    things—a route and a controller. So, let's start with the first one.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 我们最初着手创建的功能性内容是一个简单的 Drupal 页面，它输出那个古老的 *Hello World* 字符串。为了做到这一点，我们需要两样东西——一个路由和一个控制器。所以，让我们从第一个开始。
- en: The route
  id: totrans-48
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 路由
- en: 'Inside our module, we will need to create our routing file that will hold all
    our statically defined routes. The name of this file will be `hello_world.routing.yml`.
    By now, I assume that you understand what the deal is with the file naming conventions
    in a Drupal 8 module. However, in any case, this is another YAML file in which
    we will need to put the YAML formatted data:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的模块中，我们需要创建一个包含所有静态定义的路由的路由文件。这个文件的名称将是 `hello_world.routing.yml`。到现在为止，我假设你已经理解了
    Drupal 8 模块中的文件命名约定。然而，无论如何，这又是一个我们需要放入 YAML 格式数据的 YAML 文件：
- en: '[PRE3]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: This is our first route definition. It starts with the route name (`hello_world.hello`),
    followed by all the necessary info about it, underneath, in a YAML-formatted multidimensional
    array. The standard practice is to have the route name start with the module name
    it is in, followed by route qualifiers as needed.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们的第一个路由定义。它以路由名称（`hello_world.hello`）开始，然后在其下方以 YAML 格式的多维数组形式提供所有必要的信息。标准做法是让路由名称以它所在的模块名称开始，然后根据需要添加路由限定符。
- en: So, what does the route definition contain? There can be many options here but,
    for now, we will stick with the simple ones that serve our purpose.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，路由定义包含什么呢？这里可以有多个选项，但为了现在，我们将坚持使用那些为我们服务的简单选项。
- en: For more info about all route configuration options, visit the relevant documentation
    page at[ https://www.drupal.org/docs/8/api/routing-system/structure-of-routes](https://www.drupal.org/docs/8/api/routing-system/structure-of-routes).
    It is a good resource to keep on hand.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 想要了解更多关于所有路由配置选项的信息，请访问[https://www.drupal.org/docs/8/api/routing-system/structure-of-routes](https://www.drupal.org/docs/8/api/routing-system/structure-of-routes)的相关文档页面。这是一个很好的参考资料，可以随时查阅。
- en: First, we have a path key, which indicates the path we want this route to work
    on. Then, we have a `defaults` section, which usually contains info relevant to
    the handlers responsible for delivering something when this route is accessed.
    In our case, we set the controller and method responsible for delivering the page,
    as well as its title. Finally, we have a `requirements` section, which usually
    has to do with conditions that need to be met for this route to be accessible
    (or be hit)—things such as permissions and format. In our case, we will require
    users to have the `access content` permission, which most visitors will have.
    Don't worry; we will cover more about access in a later chapter.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们有一个路径键，它表示我们希望这个路由在此路径上工作。然后，我们有一个 `defaults` 部分，它通常包含在访问此路由时需要传递给处理器的相关信息。在我们的例子中，我们设置了负责传递页面的控制器和方法，以及它的标题。最后，我们有一个
    `requirements` 部分，它通常与使此路由可访问（或被触发）需要满足的条件有关——例如权限和格式。在我们的例子中，我们将要求用户拥有 `access
    content` 权限，这大多数访客都会有。不用担心；我们将在后面的章节中详细介绍关于访问的内容。
- en: That is all we need for our first route definition. Now, we will need to create
    the Controller that maps to it and can deliver something to the user.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是我们的第一个路由定义所需的所有内容。现在，我们需要创建一个控制器，它将映射到这个路由，并向用户传递一些内容。
- en: Before we do that, let's look at an example of a very common routing requirement
    you will most likely have to use really soon. We don't need this for the functionality
    we're building in this chapter, so I won't include it in the final code. However,
    it's important that you know how this works.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们这样做之前，让我们看看一个非常常见的路由要求示例，你很可能很快就会用到它。我们在这个章节中构建的功能不需要这个，所以我不会将其包含在最终的代码中。然而，了解它是如何工作的非常重要。
- en: Route variables
  id: totrans-57
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 路由变量
- en: 'A very common requirement is to have a variable route parameter (or more) that
    gets used by the code that maps to the route, for example, the ID or path alias
    of the page you want to show. These parameters can be added by wrapping a certain
    path element into curly braces, like so:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 一个非常常见的需求是拥有一个变量路由参数（或更多），该参数被映射到路由的代码所使用，例如，你想显示的页面的 ID 或路径别名。这些参数可以通过将某个路径元素包裹在花括号中来添加，如下所示：
- en: '[PRE4]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Here, `{param}` will map to a `$param` variable that gets passed as an argument
    to the controller or handler responsible for this route. So, if the user goes
    to the `hello/jack` path, the `$param` variable will have the `jack` value and
    the controller can use that.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`{param}` 将映射到一个 `$param` 变量，该变量作为参数传递给负责此路由的控制器或处理器。因此，如果用户访问 `hello/jack`
    路径，`$param` 变量将具有 `jack` 值，控制器可以使用它。
- en: 'Additionally, Drupal 8 comes with parameter converters that transform the parameter
    into something more meaningful. For example, an entity can be autoloaded and passed
    to the Controller directly instead of an ID. Also, if no entity is found, the
    route acts as a 404, saving us a few good lines of code. To achieve this, we will
    also need to describe the parameter so that Drupal knows how to autoload it. We
    can do so by adding a route option for that parameter:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，Drupal 8 还附带了一些参数转换器，可以将参数转换成更有意义的东西。例如，一个实体可以被自动加载并直接传递给控制器，而不是一个 ID。如果没有找到实体，路由将充当
    404，从而节省了我们一些好的代码行。为了实现这一点，我们还需要描述该参数，以便 Drupal 知道如何自动加载它。我们可以通过为该参数添加路由选项来实现：
- en: '[PRE5]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: So, we have now mapped the `{param}` parameter to the node entity type. Hence,
    if the user goes to `hello/1`, the node with the ID of 1 will be loaded (if it
    exists).
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们现在已经将 `{param}` 参数映射到了节点实体类型。因此，如果用户访问 `hello/1`，将加载 ID 为 1 的节点（如果存在）。
- en: We can do one better. If, instead of `{param},`we name the parameter `{node}`
    (the machine name of the entity type), we can avoid having to write the parameters
    option in the route completely. Drupal will figure out that it is an entity and
    will try to load that node by itself. Neat, no?
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以做得更好。如果我们不是用 `{param}` 而是用 `{node}`（实体类型的机器名）来命名参数，我们就可以完全避免在路由中编写参数选项。Drupal
    会推断出它是一个实体，并会尝试自行加载该节点。很酷，不是吗？
- en: So keep these things in mind the next time you need to write dynamic routes.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，下次你需要编写动态路由时，请记住这些要点。
- en: Namespaces
  id: totrans-66
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 命名空间
- en: Before moving on with the Controller we set out to write, let's break down the
    namespace situation in Drupal 8 and how the folder structure needs to be inside
    a module.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们着手编写控制器之前，让我们先分析一下 Drupal 8 中的命名空间情况以及模块内部文件夹结构应该如何组织。
- en: Drupal 8 uses the PSR-4 namespace autoloading standard. In effect, this means
    that the namespace of all Drupal core and module classes starts with `\Drupal`.
    For modules, the base namespace is `\Drupal\module_name`, where `module_name`
    is the machine name of the module. This then maps to the `/src` folder found inside
    the module directory (for main integration files). For PHPUnit tests, we have
    a different namespace, as we will see later in the book.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: Drupal 8 使用 PSR-4 命名空间自动加载标准。实际上，这意味着所有 Drupal 核心和模块类的命名空间都以 `\Drupal` 开头。对于模块，基本命名空间是
    `\Drupal\module_name`，其中 `module_name` 是模块的机器名。然后它映射到模块目录内的 `/src` 文件夹（对于主要集成文件）。对于
    PHPUnit 测试，我们有一个不同的命名空间，正如我们在本书后面将要看到的。
- en: So essentially, we will need a `/src` folder inside our module to place all
    of our classes that need to be autoloaded. So, we can go ahead and create it.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，本质上，我们将在我们的模块中需要一个 `/src` 文件夹来放置所有需要自动加载的类。因此，我们可以继续创建它。
- en: The Controller
  id: totrans-70
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 控制器
- en: 'Now that we have found out more or less where we have to place our Controller,
    let''s begin by creating a `Controller` folder inside our module''s `/src` folder.
    Although not mandatory, this is a standard practice for Controller placement.
    Inside this folder, we can have our first Controller class file: `HelloWorldController.php`.'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经大致知道了我们需要放置控制器的地方，让我们首先在我们的模块的 `/src` 文件夹内创建一个 `Controller` 文件夹。虽然这不是强制性的，但这是控制器放置的标准做法。在这个文件夹内，我们可以放置我们的第一个控制器类文件：`HelloWorldController.php`。
- en: 'Inside the file, we again have something simple (after the opening PHP tags):'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 在文件内部，我们再次有了一些简单的内容（在 PHP 开头标签之后）：
- en: '[PRE6]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: As expected, we start with the namespace declaration. If you read the preceding
    section, the namespace choice will make sense. Then, we have our Controller class
    that extends the Drupal 8 `ControllerBase`, which happens to provide some helper
    tools (such as the `StringTranslationTrait`, which I will explain later in the
    book when we talk about languages). If you remember our route definition, we have
    a `helloWorld` method that returns an array.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 如预期的那样，我们首先声明命名空间。如果你阅读了前面的部分，命名空间的选择将变得有意义。然后，我们有我们的控制器类，它扩展了Drupal 8的`ControllerBase`，它恰好提供了一些辅助工具（例如`StringTranslationTrait`，我将在本书后面讨论语言时解释）。如果你记得我们的路由定义，我们有一个返回数组的`helloWorld`方法。
- en: If you've worked with previous versions of Drupal, this array (called a *render
    array*) will be familiar. Otherwise, what you need to know right now is that we
    are returning simple markup with the `Hello World` text wrapped in the translation
    service I hinted at in the previous paragraph. After the Controller returns this
    array, there will be an `EventSubscriber` that takes this array, runs it through
    the Drupal theme layer, and returns the HTML page as a response. The actual content
    returned in the Controller will be wrapped in the `Main page content` block that
    is usually placed in the main content region of the theme.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你曾经使用过Drupal的早期版本，这个数组（称为*渲染数组*）将很熟悉。否则，你现在需要知道的是，我们正在返回简单的标记，其中包含在上一段中提到的翻译服务包裹的`Hello
    World`文本。在控制器返回这个数组后，将有一个`EventSubscriber`来接收这个数组，将其通过Drupal主题层运行，并返回作为响应的HTML页面。控制器实际返回的内容将被包裹在通常放置在主题主要内容区域的`主页面内容`块中。
- en: Now, our simple Controller is done. If we clear the cache and go to `/hello`,
    we should encounter a new page that outputs the Our first route title and the
    Hello World content. Success!
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们简单的控制器已经完成。如果我们清除缓存并访问`/hello`，我们应该会遇到一个新页面，该页面输出我们的第一个路由标题和Hello World内容。成功！
- en: '![](img/5100e2d4-a562-4d97-8534-5a6bd99b6e26.png)'
  id: totrans-77
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/5100e2d4-a562-4d97-8534-5a6bd99b6e26.png)'
- en: Services
  id: totrans-78
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 服务
- en: Why don't I like this approach?
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么我不喜欢这种方法？
- en: I don't want the Controller making decisions on how to greet my users. First
    of all, because Controllers need to stay lean. I want my users to be greeted a
    bit more dynamically, depending on the time of day, and that will increase the
    complexity. Second of all, maybe I will want this greeting to be done elsewhere
    as well, and there is no way I am copying and pasting this logic somewhere else,
    nor am I going to misuse the Controller just to be able to call that method. The
    solution? We delegate the logic of constructing the greeting to a service and
    use that service in our Controller to output the greeting.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 我不希望控制器决定如何问候我的用户。首先，因为控制器需要保持简洁。我希望我的用户能够根据一天中的时间动态地被问候，这将增加复杂性。其次，也许我还会希望这种问候在其他地方也能实现，而我绝对不想在其他地方复制粘贴这段逻辑，也不会为了能够调用该方法而滥用控制器。解决方案？我们将构建问候的逻辑委托给一个服务，并在我们的控制器中使用该服务来输出问候。
- en: What is a service?
  id: totrans-81
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 什么是服务？
- en: A service is an object that gets instantiated by a Service Container and is
    used to handle operations in a reusable way, for example, performing calculations
    and interacting with the database, an external API, or any number of things. Moreover,
    it can take dependencies (other services) and use them to help out. Services are
    a core part of the **dependency injection** (**DI**) principle that is commonly
    used in modern PHP applications and in Drupal 8.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 服务是一个由服务容器实例化的对象，用于以可重用的方式处理操作，例如执行计算和与数据库、外部API或任何数量的东西交互。此外，它还可以接受依赖项（其他服务）并使用它们来提供帮助。服务是现代PHP应用程序和Drupal
    8中常用的一种核心原则——**依赖注入**（**DI**）的一部分。
- en: If you don't have any experience with these concepts, an important thing to
    note is also that they are globally registered with the service container and
    instantiated only once per request. This means that altering them after you requested
    them from the container means that they stay altered even if you request them
    again. In essence, they are singletons. So, you should write your services in
    such a way that they stay immutable, and most of the data they need to process
    is either from a dependency or passed in from the client that uses it (and does
    not affect it).
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你对这些概念没有经验，需要注意的是，它们也是全局注册在服务容器中，并且每个请求只实例化一次。这意味着在你从容器中请求它们之后修改它们，它们会保持修改后的状态，即使你再次请求它们。本质上，它们是单例。因此，你应该以保持不可变的方式编写你的服务，并且它们需要处理的大部分数据要么来自依赖项，要么从使用它的客户端传递进来（并且不影响它）。
- en: Many Drupal 8 core service definitions can be found inside the `core.services.yml`
    file located in the root `/core` folder. So, if you are ever looking for service
    names to use, your best bet is to look there. Additionally, core modules also
    have service definitions inside their respective `*.services.yml` files. So, make
    sure that you also check there.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 许多 Drupal 8 核心服务定义可以在位于根 `/core` 文件夹中的 `core.services.yml` 文件中找到。所以，如果你在寻找要使用的服务名称，最好的办法就是查看那里。此外，核心模块也有它们各自的
    `*.services.yml` 文件中的服务定义。所以，请确保你也查看那里。
- en: The HelloWorldSalutation service
  id: totrans-85
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: HelloWorldSalutation 服务
- en: Now that we have a general idea as to what a service is, let's create one to
    see all this in practice.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们对服务有一个大致的了解，让我们创建一个服务来实际看看这一切。
- en: 'As I mentioned earlier, I want my greetings to be more dynamic, that is, I
    want the salutation to depend on the time of day. So, we will create a (`HelloWorldSalutation`)
    class that is responsible for doing that and place it in the `/src` folder (our
    module''s namespace root in a file naturally called `HelloWorldSalutation.php`):'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 如我之前提到的，我希望我的问候语更加动态，也就是说，我希望问候语取决于一天中的时间。因此，我们将创建一个 (`HelloWorldSalutation`)
    类来负责这个功能，并将其放置在 `/src` 文件夹中（我们的模块命名空间根，文件自然命名为 `HelloWorldSalutation.php`）：
- en: '[PRE7]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: From now on I will not always mention the file name a particular class goes
    into. So you can safely assume one file per class, named after the class itself.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 从现在起，我不再总是提及特定类所属的文件名。因此，你可以安全地假设每个类对应一个文件，文件名与类名相同。
- en: By now, I assume that the namespace business is clear, so I won't explain it
    again. Let's see what else we did here. First, we used the `StringTranslationTrait`
    in order to expose the translation function (I will explain this later on). Second,
    we created a rudimentary method that returns a different greeting depending on
    the time of day. This could probably have been done better, but for the purposes
    of this example, it works just fine.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 到现在为止，我假设命名空间的问题已经清楚，所以我就不再解释了。让我们看看我们还做了什么。首先，我们使用了 `StringTranslationTrait`
    来公开翻译函数（我稍后会解释）。其次，我们创建了一个基本的方法，根据一天中的时间返回不同的问候语。这也许可以做得更好，但就这个例子而言，它已经足够好了。
- en: In this example I used the native PHP function `time()` to get the current time.
    And that's ok. But you should know that Drupal has its very own `Drupal\Component\Datetime\Time`
    service that we can use to get the current time. It also has additional methods
    for requesting time specific information, so make sure you check it out and use
    when appropriate.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我使用了原生的 PHP 函数 `time()` 来获取当前时间。这是可以的。但你应该知道 Drupal 有它自己的 `Drupal\Component\Datetime\Time`
    服务，我们可以用它来获取当前时间。它还有额外的请求特定时间信息的方法，所以请确保你查看它并在适当的时候使用。
- en: Now that we have our class, it's time to define it as a service. We don't want
    to be going `new HelloWorldSalutation()` all over our code base, but instead,
    register it with the Service Container and use it from there as a dependency.
    How do we do that?
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了我们的类，是时候将其定义为服务了。我们不想在我们的代码库中到处使用 `new HelloWorldSalutation()`，而是将其注册到服务容器中，并从那里作为依赖项使用。我们如何做到这一点？
- en: 'First, we will need, yet again, a `YAML` file: `hello_world.services.yml`.
    This file starts with the `services` key, under which will be all the service
    definitions of our module. So, our file will look like this (for now):'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们还需要一个 `YAML` 文件：`hello_world.services.yml`。这个文件以 `services` 键开始，下面将包含我们模块的所有服务定义。所以，我们的文件现在看起来是这样的（目前）：
- en: '[PRE8]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: This is the simplest possible service definition you can have. You give it a
    name (`hello_world.salutation`) and map it to a class to be instantiated. It is
    a standard practice to have the service name start with your module name.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 这是你可能拥有的最简单的服务定义。你给它一个名字（`hello_world.salutation`），并将其映射到要实例化的类。通常的做法是让服务名称以你的模块名称开头。
- en: Once we clear the cache, the service will get registered with the Service Container
    and will be available to use.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们清除缓存，服务将注册到服务容器中，并可供使用。
- en: If there is any reason to believe that you will have more than one salutation
    service, you should create an interface this class can implement. This way, you'll
    be able to always type hint that interface instead of the class and make the implementations
    swappable.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 如果有理由相信你将拥有多个问候服务，你应该创建一个这个类可以实现的接口。这样，你就可以始终使用该接口而不是类进行类型提示，并使实现可交换。
- en: Tagged services
  id: totrans-98
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 标签服务
- en: 'Service definitions can also be tagged in order to inform the container if
    they serve a specific purpose. Typically, these are picked up by a collector service
    that uses them for a given subsystem. As an example, if we wanted to tag the `hello_world.salutation`
    service, it would look something this:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 服务定义也可以被标记，以便通知容器它们是否服务于特定目的。通常，这些会被一个收集服务拾取，用于特定的子系统。例如，如果我们想标记`hello_world.salutation`服务，它看起来会是这样：
- en: '[PRE9]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Tags can also get a priority, as we will see in some examples later in this
    book.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 标签也可以获得优先级，正如我们将在本书后面的某些示例中看到的那样。
- en: Using services in Drupal 8
  id: totrans-102
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在Drupal 8中使用服务
- en: Before we go and use our service in the Controller we created, let's take a
    breather and run through the ways you can make use of services once they are registered.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们使用我们创建的控制器中的服务之前，让我们喘口气，回顾一下一旦服务注册后你可以如何利用服务。
- en: There are essentially two ways—statically and injected. The first is done by
    a static call to the Service Container, whereas the second uses dependency injection
    to pass the object through the constructor (or in some rare cases, a setter method).
    However, let's check out how, why, and what is the real difference.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上有两种方式——静态和注入。第一种是通过对服务容器的静态调用完成的，而第二种则使用依赖注入通过构造函数（或在某些罕见情况下，设置器方法）传递对象。然而，让我们来看看如何、为什么以及真正的区别是什么。
- en: 'Statically, you would use the global `Drupal` class to instantiate a service:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 静态地，你会使用全局的`Drupal`类来实例化一个服务：
- en: '[PRE10]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: This is how we use services in the `.module` files and classes which are not
    exposed to the Service Container and into which we cannot inject. Instances of
    the latter are rare though, most of the time we use the static calls only from
    within static contexts.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是我们如何在`.module`文件和类中使用服务，这些类没有暴露给服务容器，也无法注入。后者的实例很少见，大多数时候我们只从静态上下文中使用静态调用。
- en: 'A few popular services also have shorthand methods on the `\Drupal` class:
    for example, `\Drupal::entityTypeManager().` I recommend that you inspect the
    `\Drupal` class and take a look at the ones with shorthand methods available.'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 一些流行的服务在`\Drupal`类上也有简写方法：例如，`\Drupal::entityTypeManager()`。我建议你检查`\Drupal`类，并查看具有简写方法的那些。
- en: It is not best practice and, for me, it is personally unacceptable to use the
    static method of service instantiation inside a Controller, service, plugin or
    any other class where dependency injection is an option. The reason is that it
    defeats much of the purpose of using a service, as it couples the two, making
    it a nightmare to test. Inside hook implementations and other Drupal-specific
    procedural code, on the other hand, we have no choice, and it is normal to do
    so.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 在控制器、服务、插件或其他任何依赖注入是选项的类中使用服务实例化的静态方法并不是最佳实践，对我来说，这是个人无法接受的。原因是它破坏了使用服务的大部分目的，因为它将两者耦合在一起，使得测试变得噩梦般。另一方面，在钩子实现和其他Drupal特定的过程代码中，我们没有选择，这样做是正常的。
- en: Just because a code is inside a `.module` file, it doesn't mean that it should
    be there. In general, these modules should only contain things such as hook implementations
    or any other implementations that require a certain naming convention to be respected.
    They should also be lean and have their work delegated to services.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 只因为代码在`.module`文件中，并不意味着它应该在那里。一般来说，这些模块应仅包含诸如钩子实现或任何其他需要遵守特定命名约定的实现。它们也应该精简，并将工作委托给服务。
- en: The proper way to use services is to inject them where needed. Admittedly, this
    approach is a bit more time-consuming but, as you progress, it will become second
    nature. Also, since there are a few different ways to inject dependencies (based
    on the receiver), we will not cover them here. Instead, we will see how they work
    throughout this book, at the right time. We will take a look at a very important
    example right now in the next section.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 正确使用服务的方法是在需要的地方注入它们。诚然，这种方法稍微耗时一些，但随着你的进步，它将变得自然而然。此外，由于有几种不同的依赖注入方式（基于接收者），我们在这里不会涵盖它们。相反，我们将在本书中适当的时候查看它们是如何工作的。我们现在将在下一节中查看一个非常重要的例子。
- en: Injecting the service into our Controller
  id: totrans-112
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将服务注入我们的控制器
- en: Let's now continue with our module and take a look at how to inject the newly
    created service into our Controller.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们现在继续我们的模块，看看如何将新创建的服务注入到我们的控制器中。
- en: 'We will need to add some code to the Controller (typically at the beginning
    of the class so that we can immediately identify the presence of this code when
    looking at it):'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要在控制器（通常在类开始处，这样我们可以在查看时立即识别出这段代码的存在）中添加一些代码：
- en: '[PRE11]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'In addition to this, ensure that you include the relevant *use* statements
    at the top of the file:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，确保在文件顶部包含相关的*use*语句：
- en: '[PRE12]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: So, what is going on here? First, we give the Controller a constructor method,
    which takes our service as an argument and stores it as a property. For me, this
    is usually the very first method in the class. But how does this constructor get
    its argument? It gets it via the `create()` method, which receives the Service
    Container as a parameter and is free to choose the service(s) needed by the Controller
    constructor. This is usually my second method in a class. I prefer this order
    because it's very easy to check whether they are present. Also, their presence
    is important, especially when inheriting and observing what the parent is injecting.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，这里发生了什么？首先，我们给控制器一个构造函数，它接受我们的服务作为参数并将其存储为一个属性。对我来说，这通常是类中的第一个方法。但是这个构造函数是如何获取它的参数的呢？它是通过`create()`方法获取的，这个方法接收服务容器作为参数，并且可以自由选择控制器构造函数所需的服务。这通常是我类中的第二个方法。我更喜欢这种顺序，因为它很容易检查它们是否存在。此外，它们的存在很重要，尤其是在继承和观察父类注入的内容时。
- en: OK, but how does this injection business work in reality?
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，但是这种注入业务在现实中是如何工作的呢？
- en: In a nutshell, after the route is found and the responsible Controller is resolved,
    a check is made to see whether the latter implements `ContainerInjectionInterface`.
    Our Controller does so via its parent `ControllerBase`. If it does, the Controller
    gets instantiated via the `create()` method and the container is passed to it.
    From there, it is responsible for creating a new static version of itself with
    the required services from the container—not that complicated, really!
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，在找到路由并解析出负责的控制器之后，会检查后者是否实现了`ContainerInjectionInterface`。我们的控制器通过其父类`ControllerBase`做到了这一点。如果是的话，控制器将通过`create()`方法实例化，并将容器传递给它。从那里，它负责使用容器中的所需服务创建一个新的静态版本自己——实际上并不复杂！
- en: The `create()` method is a staple practice in the Drupal 8 dependency injection
    pattern, so you will see it quite a lot. However, one thing to keep in mind is
    that you should never pass the entire container to the class you instantiate with
    it because you are no longer doing dependency injection then.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: '`create()`方法是Drupal 8依赖注入模式的标准实践，所以你会经常看到它。然而，有一点需要注意，你不应该将整个容器传递给你用它实例化的类，因为那时你不再进行依赖注入了。'
- en: A note about `ControllerBase`, which we are extending—it is a standard practice
    to extend it. It provides some nice traits, implements interfaces that are required
    and shows what the class purpose is immediately. However, from the point of view
    of dependency injection, I advise against using the helper methods that return
    services (for example, `entityTypeManager()`). They, unfortunately, load services
    statically, which is not the best practice in this case. You should instead inject
    them yourself, as we did just now.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 关于我们扩展的`ControllerBase`的一些说明——扩展它是标准实践。它提供了一些很好的特性，实现了所需接口，并立即显示了类的用途。然而，从依赖注入的角度来看，我建议不要使用返回服务的辅助方法（例如，`entityTypeManager()`）。不幸的是，它们静态地加载服务，这在这种情况下不是最佳实践。你应该像我们刚才做的那样自己注入它们。
- en: 'Okay, let''s turn back to our example. Now that we have the service injected,
    we can use it to render the dynamic salutation:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，让我们回到我们的例子。现在我们已经注入了服务，我们可以使用它来渲染动态问候语：
- en: '[PRE13]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: There we have it. Now, our greeting is dependent on the time of day and our
    Controller is dependent on our salutation service.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 就这样。现在，我们的问候语取决于一天中的时间，我们的控制器取决于我们的问候语服务。
- en: One thing I would like to specify about our example is that I disregarded caching
    for the sake of simplicity. With the cache turned on, the page would be cached
    and served with potentially the wrong salutation. However, in [Chapter 11](13739cad-2542-40b4-ae42-9a7f9e159716.xhtml), *Caching*,
    we will cover all these intricacies, so there is no point in complicating our
    example now.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 关于我们的示例，我想特别说明的是，为了简单起见，我忽略了缓存。如果开启缓存，页面将被缓存，并可能使用错误的问候语提供服务。然而，在[第11章](13739cad-2542-40b4-ae42-9a7f9e159716.xhtml)，“缓存”，我们将涵盖所有这些复杂性，所以现在没有必要使我们的示例复杂化。
- en: Invoked Controllers
  id: totrans-127
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 调用的控制器
- en: Now that we know what routes, Controllers and services are, I'd also like to
    quickly note that Controllers can be defined as services and *invoked* by the
    routing system. In other words, just as we defined our `hello_world.salutation`
    service, we could define another one that would act as a Controller and reference
    that service ID in the routing file instead of the fully qualified class name.
    Then, in order for Drupal to know which method inside the service to call when
    a user accesses the route, we would need to implement the magic `__invoke` method
    inside the service. And the rest would work pretty much in the same way.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们知道了路由、控制器和服务的概念，我还想快速指出，控制器可以被定义为服务，并由路由系统*调用*。换句话说，就像我们定义了 `hello_world.salutation`
    服务一样，我们还可以定义另一个充当控制器的作用的服务，并在路由文件中引用该服务ID而不是完全限定的类名。然后，为了使 Drupal 知道当用户访问路由时在服务中调用哪个方法，我们需要在服务中实现神奇的
    `__invoke` 方法。其余的将基本上以相同的方式工作。
- en: This capability was introduced in Drupal 8.7 and is typical to the [Action-Domain-Responder](https://en.wikipedia.org/wiki/Action%E2%80%93domain%E2%80%93responder)
    architectural pattern. We won't use it going forward but it's good to know that
    it's available.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 这种功能是在 Drupal 8.7 中引入的，并且是 [Action-Domain-Responder](https://en.wikipedia.org/wiki/Action%E2%80%93domain%E2%80%93responder)
    架构模式的典型特征。我们将来不会使用它，但了解它的可用性是好的。
- en: The form
  id: totrans-130
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 表单
- en: Our page displays a greeting dynamically, depending on the time of day. However,
    we now want an administrator to specify what the greeting should actually be,
    in other words, to override the default behavior of our salutation if they so
    choose.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的页面根据一天中的时间动态显示问候语。然而，我们现在希望管理员指定问候语的实际内容，换句话说，如果他们选择的话，可以覆盖我们问候语的默认行为。
- en: 'The ingredients for achieving this will be as follows:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 实现这一点的要素如下：
- en: A route (a new page) that displays a form where the administrator can set the
    greeting
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个路由（一个新页面），显示一个表单，管理员可以设置问候语
- en: A configuration object that will store the greeting
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个将存储问候语的配置对象
- en: 'In building this functionality, we will also take a look at how to add a dependency
    to our existing service. So, let''s get started with our new route that naturally
    goes inside the `hello_world.routing.yml` file we already created:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 在构建这个功能时，我们还将看看如何向我们的现有服务添加依赖项。所以，让我们开始我们的新路由，它自然位于我们已创建的 `hello_world.routing.yml`
    文件中：
- en: '[PRE14]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Most of this route definition is the same as we saw earlier. There is one change,
    though, in that it maps to a form instead of a Controller. This means that the
    entire page is a form page. Also, since the path is within the administration
    space, it will use the administration theme of the site. What is left to do now
    is to create our form class inside the `/Form` folder of our namespace (a standard
    practice directory for storing forms, but not mandatory).
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 这条路由定义的大部分内容与我们之前看到的相同。不过，有一个变化，那就是它映射到一个表单而不是控制器。这意味着整个页面都是一个表单页面。此外，由于路径位于管理空间内，它将使用站点的管理主题。现在需要做的只是在我们命名空间中的
    `/Form` 文件夹内创建我们的表单类（这是一个存储表单的标准实践目录，但不是强制性的）。
- en: 'Due to the power of inheritance, our form is actually very simple. However,
    I will explain what goes on in the background and guide you on your path to building
    more complex forms. So, here we have our form:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 由于继承的力量，我们的表单实际上非常简单。然而，我将解释后台发生的事情，并指导你构建更复杂的表单的道路。所以，这里是我们的表单：
- en: '[PRE15]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Before going into the explanation, I should say that this is it. Clearing the
    cache and navigating to `admin/config/salutation-configuration` will present you
    with your simple configuration form via which you can save a custom salutation
    message:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 在进行解释之前，我应该说明的是，这就是全部内容。清除缓存并导航到 `admin/config/salutation-configuration` 将会通过一个简单的配置表单展示给你，你可以通过这个表单保存自定义问候消息：
- en: '![](img/71e94a82-012c-4c2b-9ff4-1cfbbb448185.png)'
  id: totrans-141
  prefs: []
  type: TYPE_IMG
  zh: '![](img/71e94a82-012c-4c2b-9ff4-1cfbbb448185.png)'
- en: Later on, we will make use of that value. However, first, let's talk a bit about
    forms in general, and then this form in particular.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，我们将使用这个值。然而，首先，让我们先谈谈表单的一般情况，然后再具体谈谈这个表单。
- en: A form in Drupal 8 is represented by a class that implements `FormInterface`.
    Typically, we either extend from `FormBase` or from `ConfigFormBase`, depending
    on what its purpose is. In this case, we created a configuration form so we extended
    from the latter class.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: Drupal 8中的表单由一个实现 `FormInterface` 的类表示。通常，我们根据其用途要么从 `FormBase` 扩展，要么从 `ConfigFormBase`
    扩展。在这种情况下，我们创建了一个配置表单，因此我们从后者类扩展。
- en: 'There are four main methods that come into play in this interface:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 在此接口中，有四种主要方法被使用：
- en: '`getFormId()`: Returns a unique, machine-readable name for the form.'
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`getFormId()`: 返回表单的唯一、机器可读的名称。'
- en: '`buildForm()`: Returns the form definition (an array of form element definitions
    and some extra metadata, as needed).'
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`buildForm()`: 返回表单定义（一个表单元素定义的数组和一些额外的元数据，如有必要）。'
- en: '`validateForm()`: The handler that gets called to validate the form submission.
    It receives the form definition and a `$form_state` object that contains, among
    others, the submitted values. You can flag invalid values on their respective
    form elements, which means that the form is not submitted but refreshed (with
    the offending elements highlighted).'
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`validateForm()`: 调用来验证表单提交的处理器。它接收表单定义和一个 `$form_state` 对象，其中包含提交的值等。你可以在相应的表单元素上标记无效的值，这意味着表单不会被提交，而是刷新（带有被标记的元素）。'
- en: '`submitForm()`: The handler that gets called when the form is submitted (if
    validation has passed without errors). It receives the same arguments as `validateForm()`.
    You can perform operations such as saving the submitted values or triggering some
    other kind of flow.'
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`submitForm()`: 当表单提交时（如果验证通过且没有错误）会被调用的处理器。它接收与 `validateForm()` 相同的参数。你可以执行诸如保存提交的值或触发其他类型的流程等操作。'
- en: Defining a form, in a nutshell, means creating an array of form element definitions.
    The resulting form is very similar to the render array we mentioned earlier and
    which we will describe in more depth in [Chapter 2](601b4dd0-c521-459e-9342-2645a109642c.xhtml),
    *Creating Your First Module*. When creating your forms, you have a large number
    of form element types to use. A complete reference of what they are and what their
    options are (their definition specificities) can be found on the Drupal Form API
    reference page ([https://api.drupal.org/api/drupal/elements/8.7.x](https://api.drupal.org/api/drupal/elements/8.7.x)).
    Keep this page close to you throughout your Drupal 8 development.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，定义一个表单意味着创建一个表单元素定义的数组。生成的表单与我们之前提到的渲染数组非常相似，我们将在[第2章](601b4dd0-c521-459e-9342-2645a109642c.xhtml)“创建您的第一个模块”中更深入地描述它。在创建表单时，你有大量的表单元素类型可供选择。关于它们是什么以及它们的选项（它们的定义特定性）的完整参考可以在Drupal表单API参考页面上找到（[https://api.drupal.org/api/drupal/elements/8.7.x](https://api.drupal.org/api/drupal/elements/8.7.x)）。在整个Drupal
    8开发过程中，请将此页面放在手边。
- en: From a dependency injection point of view, forms can receive arguments from
    the Service Container in the same way we injected the salutation service into
    our Controller. As a matter of fact, `ConfigFormBase`, which we are extending
    in our preceding form, injects the `config.factory` service because it needs to
    use it for reading and storing configuration values. This is why we extend from
    that form. Drupal is full of these helpful classes we can extend and that provide
    a bunch of useful boilerplate code that is very commonly used across the Drupal
    ecosystem.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 从依赖注入的角度来看，表单可以从服务容器接收参数，就像我们将问候服务注入到我们的控制器中一样。事实上，我们在前面的表单中扩展的 `ConfigFormBase`
    注入了 `config.factory` 服务，因为它需要用它来读取和存储配置值。这就是我们为什么要从那个表单扩展的原因。Drupal充满了我们可以扩展的这些有用的类，它们提供了一堆在Drupal生态系统中非常常用的有用样板代码。
- en: 'If the form you are building is not storing or working with your configuration,
    you will typically extend from `FormBase`, which provides some static methods
    and traits, and also implements some interfaces. The same word of caution goes
    for its helper service methods as for the `ControllerBase`: if you need services,
    you should always inject them.'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你正在构建的表单不存储或处理你的配置，你通常会从`FormBase`扩展，它提供了一些静态方法和特性，并实现了某些接口。对于其辅助服务方法，与`ControllerBase`一样，同样的警告也适用：如果你需要服务，你应该始终注入它们。
- en: Let's turn to our preceding form class and dissect it a bit now that we know
    a thing or two about forms.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们转向我们之前的形式类，现在既然我们对表单有了点了解，就稍微剖析一下它。
- en: 'We have the `getFormId()` method. Check. We also have `buildForm()` and `submitForm()`,
    but not `validateForm()`. The latter is not mandatory, and we don''t actually
    need it for our example, but if we did, we could have something like this:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有`getFormId()`方法。检查。我们还有`buildForm()`和`submitForm()`，但没有`validateForm()`。后者不是必需的，而且在我们这个例子中实际上并不需要它，但如果需要，我们可以有类似这样的东西：
- en: '[PRE16]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: In this validation handler, we basically check whether the submitted value for
    the `salutation` element is longer than 20 characters. If so, we set an error
    on that element (to turn it red usually) and specify an error message on the form
    state specific to this error. The form will then be refreshed and the error will
    be presented, and the submit handler, in this case, will not be called.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个验证处理程序中，我们基本上检查提交给`salutation`元素的值是否超过20个字符。如果是这样，我们在该元素上设置一个错误（通常使其变红）并指定一个针对此错误的表单状态特定错误消息。然后表单将被刷新，错误将被显示，在这种情况下，提交处理程序将不会被调用。
- en: For the purposes of our example, this is, however, not necessary, so I will
    not include it in the final code.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，对于我们的示例来说，这并不是必要的，所以我将不会将其包含在最终的代码中。
- en: Form validation error messages, by default, are printed at the top of the page.
    However, with the core **Inline Form Errors** module we can have the form errors
    printed right beneath the actual elements. This is much better for accessibility,
    as well as for clarity when dealing with large forms. Note that the standard Drupal
    8 installation doesn't have this module enabled so you'll have to enable it yourself
    if you want to use it.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，表单验证错误消息会在页面顶部打印。然而，使用核心**内联表单错误**模块，我们可以将表单错误直接打印在实际元素下方。这对于可访问性来说要好得多，而且在处理大型表单时也更为清晰。请注意，标准的Drupal
    8安装没有启用此模块，所以如果你想使用它，你必须自己启用它。
- en: 'If we turn back to our form class, we also see a strange `getEditableConfigNames()`
    method. This is required by the `ConfigFormBaseTrait`, which is used in the `ConfigFormBase`
    class that we are extending, and it needs to return an array of configuration
    object names that this form intends to edit. This is because there are two ways
    of loading configuration objects: for editing and for reading (immutable). With
    this method, we inform it that we want to edit that configuration item.'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们回到我们的表单类，我们还会看到一个奇怪的`getEditableConfigNames()`方法。这是由我们扩展的`ConfigFormBase`类中使用的`ConfigFormBaseTrait`要求的，它需要返回一个配置对象名称数组，这个表单打算编辑。这是因为有两种加载配置对象的方式：用于编辑和用于读取（不可变）。通过这个方法，我们通知它我们想要编辑那个配置项。
- en: As we see on the first line of `buildForm()`, we are using the `config()` method
    of the abovementioned trait to load up our editable configuration object from
    the Drupal configuration factory. This is to check the value that is currently
    stored in it. Then, we define our form elements (in our case, one—a simple text
    field). As `#default_value` (the value present in the element when the user goes
    to the form), we put whatever is in the configuration object. The rest of the
    element options are self-explanatory and pretty standard across all element types.
    Consult the Form API reference to see what other options are available and for
    which element types. Finally, at the end of the method, we also call the parent
    method because that provides the form's submit button, which for our purposes
    is enough.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在`buildForm()`的第一行看到的，我们正在使用上述特性中的`config()`方法从Drupal配置工厂加载我们的可编辑配置对象。这是为了检查其中当前存储的值。然后，我们定义我们的表单元素（在我们的例子中，只有一个——一个简单的文本字段）。作为`#default_value`（用户访问表单时元素中存在的值），我们放入配置对象中的任何内容。其余的元素选项都是不言自明的，并且在整个元素类型中都很标准。请参考表单API参考以了解其他可用的选项以及适用于哪些元素类型。最后，在方法末尾，我们也调用了父方法，因为这样提供了表单的提交按钮，这对于我们的目的来说已经足够了。
- en: The last method we wrote is the submit handler, which basically loads up the
    editable configuration object, puts the submitted value in it and then saves it.
    Finally, it also calls the parent method, which then simply sets a success message
    to the user on the screen using `Messenger` service—a standard way of showing
    the user a success or error message from a code context.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 我们编写的最后一个方法是提交处理程序，它基本上加载可编辑的配置对象，将提交的值放入其中，然后保存它。最后，它还调用父方法，该方法简单地使用`Messenger`服务将成功消息设置到用户屏幕上——这是从代码上下文中向用户显示成功或错误消息的标准方式。
- en: That is pretty much it; this will work just fine.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 大概就是这样；这会正常工作。
- en: For much of Drupal's lifespan, the way to output such a message to the user
    has been via the `drupal_set_message()` global function. This has been the case
    also in Drupal 8 but has been deprecated starting with version 8.5 in favor of
    the `Messenger` service (accessed by the `messenger` service name). For Drupal
    7 veterans this is quite the adjustment but it's important to understand that
    although using `drupal_set_message()` will still work, it will be removed in Drupal
    9\. So it's best to already start using the correct service instead. Going forward,
    there will be places I use the old version for the sake of avoiding lots of boilerplate
    code in the book. But you should no longer use it in your own code.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 在Drupal的大部分生命周期中，向用户输出此类消息的方式是通过`drupal_set_message()`全局函数。这种情况在Drupal 8中也是如此，但从版本8.5开始已经弃用，转而使用`Messenger`服务（通过`messenger`服务名称访问）。对于Drupal
    7的老用户来说，这是一个很大的调整，但重要的是要理解，尽管使用`drupal_set_message()`仍然有效，但它将在Drupal 9中被移除。因此，最好已经开始使用正确的服务。向前看，我将使用旧版本以避免在书中编写大量样板代码。但你不应该在您的代码中使用它。
- en: From the point of view of configuration, we used `ConfigFormBase` to make our
    lives easier and combine the form aspect with that of the configuration storage.
    In a later chapter, we will talk a bit more about the different types of storage and
    also cover how to work with the configuration objects in more detail, as well
    as what these entail.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 从配置的角度来看，我们使用了`ConfigFormBase`来使我们的生活更轻松，并将表单方面与配置存储结合起来。在后面的章节中，我们将更详细地讨论不同类型的存储方式，以及如何更详细地处理配置对象，以及这些包含的内容。
- en: Altering forms
  id: totrans-164
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 改变形式
- en: Before going ahead with our proposed functionality, I would like to open a parenthesis
    and discuss forms in a bit more detail. An important thing that you will do as
    a module developer is alter forms defined by other modules or Drupal core. So,
    it behooves us to talk about it early on and what better moment than now, when
    defining the form itself is still fresh in our minds.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续我们的提议功能之前，我想开一个括号，更详细地讨论一下表单。作为模块开发者，你将要做的一件重要的事情是更改其他模块或Drupal核心定义的表单。因此，我们最好早点讨论这个问题，什么时候比现在更好，当我们定义表单时，它仍然在我们脑海中清晰。
- en: Obviously, the form we just created belongs to us and we can change it however
    we want. However, many forms out there have been defined by other modules and
    there will be just as many times that you will want to make changes to them. Drupal
    provides us with a very flexible, albeit still procedural way of doing so—a suite
    of *alter* hooks; but what are *alter* hooks?
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，我们刚刚创建的表单属于我们，我们可以随意更改它。然而，许多表单都是由其他模块定义的，你将有很多次想要更改它们。Drupal为我们提供了一个非常灵活的、尽管仍然是程序化的方法来做这件事——一套*alter*钩子；但什么是*alter*钩子？
- en: The first thing we did in this chapter was implement `hook_help()`. That is
    an example of an invoked hook by which a caller (Drupal core or any module) asks
    all other modules to provide input. This input is then aggregated in some way
    and made use of. The other type of hooks we have in Drupal are the *alter* hooks,
    which are used to allow other modules to make changes to an array or an object
    before that array or object is used for whatever it is used for. So, in the case
    of forms, there are some alter hooks that allow modules to make changes to the
    form before it's processed for rendering.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们首先实现了`hook_help()`。这是一个调用钩子的例子，调用者（Drupal核心或任何模块）要求所有其他模块提供输入。然后以某种方式聚合这些输入并加以利用。Drupal中我们还有另一种类型的钩子，即*alter*钩子，它用于允许其他模块在数组或对象被用于任何目的之前对其进行更改。因此，在表单的情况下，有一些alter钩子允许模块在表单被处理以进行渲染之前对其进行更改。
- en: 'You may be wondering why I am saying that, for making changes to a form, we
    have more than one *alter* hook. Let me explain by giving an example of how other
    modules could alter the form we just defined:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能想知道我为什么说，为了修改表单，我们有多于一个的*alter*钩子。让我通过一个例子来解释其他模块如何修改我们刚刚定义的表单：
- en: '[PRE17]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: In the preceding code, we implemented the generic `hook_form_alter()` inside
    a module called `my_module`, which gets fired for all forms when being built.
    The first two arguments are the form and form state (the same as we saw in the
    form definition), the former being passed by reference. This is the typical *alter*
    concept—we make changes to an existing variable and don't return anything. The
    third parameter is the form ID, the one we defined in the `getFormId()` method
    of our form class. We check to ensure that the form is correct and then we can
    make alterations to the form.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们在名为`my_module`的模块中实现了通用的`hook_form_alter()`，它在构建表单时对所有表单都会触发。前两个参数是表单和表单状态（与我们在表单定义中看到的一样），前者是通过引用传递的。这是典型的*alter*概念——我们修改一个现有的变量，不返回任何内容。第三个参数是表单ID，我们在表单类的`getFormId()`方法中定义的。我们检查以确保表单是正确的，然后我们可以对表单进行修改。
- en: 'This is, however, almost always the wrong approach, because the hook is fired
    for all forms indiscriminately. Even if we don''t actually do anything for most
    of them, it''s still a useless function call, not to mention that if we want to
    alter 10 forms in our module, there will be a lot of `if` conditionals in there—the
    price we pay for procedural functions. Instead, though, we can do this:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这几乎总是错误的方法，因为钩子会为所有表单无差别地触发。即使我们实际上对其中大多数没有做任何事情，这仍然是一个无用的函数调用，更不用说如果我们想在模块中修改10个表单，那么将会有很多`if`条件——这是我们为过程函数付出的代价。不过，我们可以这样做：
- en: '[PRE18]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Here, we are implementing `hook_form_FORM_ID_alter()`, which is a dynamic alter
    hook in that its name contains the actual ID of the form we want to alter. So,
    with this approach, we ensure that this function is called only when it's time
    to alter our form, and the other benefit is that if we need to alter another one,
    we can implement the same for that and have our logic neatly separated.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，我们正在实现`hook_form_FORM_ID_alter()`，这是一个动态的修改钩子，因为它的名字包含了我们要修改的实际表单ID。所以，通过这种方法，我们确保这个函数只在我们需要修改表单的时候被调用，另一个好处是，如果我们需要修改另一个表单，我们可以为它实现同样的逻辑，并且使我们的逻辑整洁地分离。
- en: Custom submit handlers
  id: totrans-174
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 自定义提交处理程序
- en: So, up to now, we have seen how other modules can make changes to our form.
    That means adding new form elements, changing existing ones, etc. But what about
    our validation and submit handlers (those methods that get called when the form
    is submitted). How can those be altered?
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经看到了其他模块如何修改我们的表单。这意味着添加新的表单元素，更改现有的元素等。但是，关于我们的验证和提交处理程序（当表单提交时被调用的方法）怎么办？如何修改它们？
- en: 'Typically, for the forms defined as we did, it''s pretty simple. Once we alter
    the form and inspect the `$form` array, we can find a `#submit` key, which is
    an array that has one item—`::submitForm`. This is simply the `submitForm()` method
    on the form class. So, what we can do is either remove this item and add our own
    function, or simply add another item to that array:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 通常情况下，对于像我们这样定义的表单，这很简单。一旦我们修改了表单并检查了`$form`数组，我们就可以找到一个`#submit`键，它是一个包含一个项目的数组——`::submitForm`。这仅仅是表单类上的`submitForm()`方法。所以，我们可以做的是要么移除这个项目并添加我们自己的函数，或者简单地向那个数组中添加另一个项目：
- en: '[PRE19]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'And the callback we added to the `#submit` array above can look like this:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 我们添加到`#submit`数组中的回调函数可以看起来像这样：
- en: '[PRE20]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: So, the cool thing is that you can choose to tack on your own callback or replace
    the existing one. Keep in mind that the order they are in located in that array
    is the order in which they get executed. So, you can also change the order if
    you want.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，酷的地方在于你可以选择添加自己的回调函数或者替换现有的一个。记住，它们在数组中的顺序就是它们被执行的顺序。因此，如果你想的话，也可以改变这个顺序。
- en: There is another case though. If the submit button on the form has a `#submit`
    property specifying its own handler, the default form `#submit` handlers we saw
    just now won't fire anymore. This was not the case with our form. So, in that
    situation, you will need to add your own handler to that array. Hence, the only
    difference is the place you tack on the submit handler. A prominent example of
    such a form is the Node add/edit form.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
- en: Finally, when it comes to the validation handler, it works exactly the same
    as with the submit handler, but it all happens under the `#validate` array key.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
- en: Feel free to experiment with altering existing forms and inspect the variables
    they receive as arguments. I strongly encourage you to become familiar with the
    common form data and keep the documentation on form elements close by ([https://api.drupal.org/api/drupal/elements/8.7.x](https://api.drupal.org/api/drupal/elements/8.7.x)).
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
- en: Rendering forms
  id: totrans-184
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Staying on forms for just a bit longer, let's quickly learn how to render forms
    programmatically. We have already seen how to map a form to a route definition
    so that the page being built contains the form when accessing the route path.
    However, there are times when we need to render a form programmatically, either
    inside a Controller or a block, or wherever you want. We can do this using the
    `FormBuilder` service.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
- en: 'The form builder can be injected using the `form_builder` service key or used
    statically via the shorthand:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Once we have it, we can build a form, like so:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: In the preceding code, `$form` will be a render array of the form that we can
    return, for example, inside a Controller. We'll talk more about render arrays
    a bit later on, and you'll understand how they get turned into actual form markup.
    However, for now, this is all you need to know about rendering forms programmatically—you
    get the form builder and request from it the form using the fully qualified name
    of the form class.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
- en: With this, we can close the parenthesis on forms.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
- en: Service dependencies
  id: totrans-192
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous section we created a form that allows administrators to set
    a custom salutation message to be shown on the page. This message was stored in
    a configuration object that we can now load in our `HelloWorldSalutation` service.
    So, let's do just that in a two-step process.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we will need to alter our service definition to give our service an
    argument—the Drupal 8 configuration factory (the service responsible for loading
    config objects). This is how our service definition should look now:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: The addition is the argument's key, which is an array of service names proceeded
    by `@`. In this case, `config.factory` is the responsible service name, which,
    if we check in the `core.services.yml` file, we note that it maps to the `Drupal\Core\Config\ConfigFactory`
    class.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
- en: 'So, with this change, the `HelloWorldSalutation` class will be passed an instance
    of `ConfigFactory`. All we need to do now is adjust our class to actually receive
    it:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'There''s nothing too complicated going on here. We added a constructor and
    set the config factory service on a property. We can now use it to load our configuration
    object that we saved in the form. However, before we do that, we should also *use*
    the `ConfigFactoryInterface` class at the top of the file:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 这里没有发生什么太复杂的事情。我们添加了一个构造函数，并在一个属性上设置了配置工厂服务。我们现在可以使用它来加载我们在表单中保存的配置对象。然而，在我们这样做之前，我们应该在文件顶部`use``ConfigFactoryInterface`类：
- en: '[PRE25]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Now, at the top of the `getSalutation()` method, we can add the following bit:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在`getSalutation()`方法的顶部，我们可以添加以下内容：
- en: '[PRE26]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: With this addition, we are loading the configuration object we saved in the
    form, and from it, we request the `salutation` key, where if you remember, we
    stored our message. If there is a value in there, we will return it. Otherwise,
    the code will continue, and our previous logic of time-based greeting will apply.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这个添加，我们正在加载我们在表单中保存的配置对象，并从中请求`salutation`键，如果你记得，我们在这里存储了我们的消息。如果其中有一个值，我们将返回它。否则，代码将继续，并应用我们之前基于时间的问候逻辑。
- en: So, now if we reload our initial page, the message we saved through the form
    should show up. If we then return to the form and remove the message, this page
    should default back to the original dynamic greeting. Neat, right?
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，现在如果我们重新加载我们的初始页面，通过表单保存的消息应该会显示出来。如果我们然后返回到表单并删除消息，这个页面应该默认回到原始的动态问候。不错，对吧？
- en: Let's now take a look at how we can create a custom block that we can place
    anywhere we like and which will output the same thing as our page.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看我们如何创建一个自定义块，我们可以将其放置在我们喜欢的任何位置，并且它将输出与我们的页面相同的内容。
- en: Blocks
  id: totrans-206
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 块
- en: Blocks in Drupal 8 are plugins. However, the blocks you create in the UI are
    content entities and the placement of both in the block layout are configuration
    entities. So, the block system is a good example of how entities and plugins work
    hand in hand in Drupal 8\. We will talk in more detail about plugin types and
    entities later in the book.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: Drupal 8中的块是插件。然而，你在UI中创建的块是内容实体，而它们在块布局中的位置都是配置实体。因此，块系统是实体和插件如何在Drupal 8中协同工作的一个很好的例子。我们将在本书的后面更详细地讨论插件类型和实体。
- en: The block system in Drupal 8 is a great shift from its predecessor. Before,
    you had to implement two obligatory hooks plus two optional hooks if you wanted
    the block to have a configuration, and the latter was always saved somewhere that
    had nothing to do with the block itself. In Drupal 8, we work with a simple plugin
    class that can be made container-aware (that is, we can inject dependencies into
    it) and we can store configuration in a logical fashion.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: Drupal 8中的块系统与其前辈相比是一个巨大的转变。在此之前，如果你想使块具有配置，你必须实现两个必需的钩子以及两个可选的钩子，后者总是保存在与块本身无关的地方。在Drupal
    8中，我们使用一个简单的插件类，它可以被容器感知（也就是说，我们可以将其依赖项注入其中），并且我们可以以逻辑的方式存储配置。
- en: So, how do we create a custom block plugin? All we need is one class, placed
    in the right namespace—`Drupal\module_name\Plugin\Block`. In this case (with plugins),
    the folder naming is important. The plugin discoverability is dependent on the
    plugin type itself, and this one has the `Plugin\Block` namespace bit in it. But
    enough talk, let's create a simple block that just renders the same as our Controller
    did previously, and I will explain things along the way.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，我们如何创建一个自定义块插件？我们只需要一个类，放置在正确的命名空间中——`Drupal\module_name\Plugin\Block`。在这种情况下（与插件一起），文件夹命名很重要。插件的发现性取决于插件类型本身，而这个有一个`Plugin\Block`命名空间的部分。但别再说了，让我们创建一个简单的块，它只渲染与我们的控制器之前所做的相同，我会在过程中解释。
- en: Our first block plugin
  id: totrans-210
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 我们的第一个块插件
- en: 'So, this is our plugin class—`HelloWorldSalutationBlock`—that does just that:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，这是我们插件类——`HelloWorldSalutationBlock`——它正是这样做的：
- en: '[PRE27]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Before even going through the explanation, you should know that clearing the
    cache and placing this block through the UI block management will do what we wanted.
    However, let's understand what is going on here first.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 在进行解释之前，你应该知道，清除缓存并通过UI块管理器放置此块将完成我们想要的功能。然而，让我们首先了解这里发生了什么。
- en: Perhaps the strangest thing you'll note is the DocBlock comment at the top of
    the class. This is called an *annotation* and denotes that this class is a `Block`
    plugin. As I mentioned in the first chapter, annotations are the most common discovery
    mechanisms for plugins in Drupal core. In this case, the plugin definition we
    need is made up of an ID and an administration label.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
- en: Properly defined plugin types have an `AnnotationInterface` implementation,
    which describes the properties that can or should be used in the annotation. So
    if you are unsure as to what needs to be there, look for this class for that specific
    plugin type.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
- en: Then, we see that our class extends `BlockBase` and also implements the `ContainerFactoryPluginInterface`.
    The former, similar to the Controller and Form we saw earlier, provides a number
    of helpful things a block plugin needs. However, we cannot really get around extending
    this class because block plugins are quite complex, working with things such as
    context and configuration. So, ensure that you always extend this class. The latter
    is, however, optional. That interface makes this block plugin container-aware,
    that is, at the moment of instantiation, it uses the `create()` method to build
    itself using the container for dependencies and, sure enough, we have our `create()`
    method below.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
- en: 'Before moving on to the actual block building, we need to talk a bit about
    dependency injection in plugins. As you see, the signature of this `create()`
    method is different to the one we saw in the Controller. This is also why we are
    using a different container-aware interface. The reason is that plugins are constructed
    with a few extra parameters: `$configuration`, `$plugin_id`, and `$plugin_definition`.
    The first contains any configuration values that were stored with the plugin (or
    passed when building), the second is the ID set in the plugin annotation (or other
    discovery mechanism), and the third is an array that contains the metadata of
    this plugin (including all the info found in the annotation). However, apart from
    this, it''s business as usual when it comes to dependency injection. If a plugin
    type base class doesn''t implement this interface, you can do so yourself directly
    in your plugin. And this works with most plugins, save for a few exceptions which
    cannot be made container-aware, but this happens very rarely.'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we have a `build()` method, which is responsible for building the block
    content. It needs to return a render array (just like our Controller did), and
    as you can see, we are using our injected service and return the same greeting.
    That is pretty much what we need to do to achieve our goal. There are other important
    aspects to block plugins we will cover later, such as caching and access, but
    we have specific chapters for those topics.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
- en: Block configuration
  id: totrans-219
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before we close the book on our custom block plugin, let's take a look at how
    we can add a configuration form to it. This way, we can practice using some more
    Form API elements and see how we can store and use block configuration.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
- en: Even though our functionality is complete (for the moment), let's imagine that
    we need a Boolean-like control on our block configuration so that when an admin
    places the block, they can toggle something and that value can be used in the
    `build()` method. We could achieve this with three to four methods on our plugin
    class.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we would need to implement the `defaultConfiguration()` method, in which
    we describe the items of configuration that we are storing for this block and
    the default values for these items. So, we could have something like this:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: We return an array of keys and values that will be in the configuration. Also,
    since we said we are going with a Boolean field, we use the number 1 as the value
    to a fictitious key named `enabled`.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we would need to implement the `blockForm()` method which provides our
    form definition for this configuration item:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'With the appropriate extra *use* statement at the top of the file:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: As you can see, this is a typical Form API definition for one form element of
    the type `checkbox`. Additionally, we are using the handy `getConfiguration()`
    method
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
- en: of the parent class to load up the configuration values that get saved with
    this block. If none have been saved, note that the `enabled` key will be present
    in it with the default value we set above (1).
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
- en: 'Lastly, we would need the submit handler that will do the necessaries to "store"
    the configuration. I used inverted commas because we don''t actually have to do
    anything related to storage, but just map the value submitted in the form to the
    relevant key in the configuration. The block system does it for us:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'It couldn''t be simpler than this. Now if we placed our custom block somewhere,
    the form we are presented with would incorporate our form element that allows
    us to toggle the `enabled` key. What remains to be done is to make use of this
    value inside the `build()` method. We could do that similarly to how we loaded
    the configuration values inside the `buildForm()` method:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Alas, we don't really need this configuration in our example block, so we won't
    be adding it to our code. However, it is important for you to know how to do it,
    so we covered it here. Moreover, before moving on, I also want to specify that
    you can use an optional method to handle validation on the configuration form.
    The method name is `blockValidate()`, has the same signature as `blockSubmit()`
    and works the same way as the validation handler we saw when we built our standalone
    form. So, I won't repeat that here.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
- en: Working with links
  id: totrans-236
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One of the principal characteristics of a web application is the myriad of links
    between its resources. They are in fact the glue that brings it together. So,
    in this section, I want to show you a few common techniques used while working
    with links programmatically in Drupal 8.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
- en: There are two main aspects when talking about link building in Drupal—the URL
    and the actual link tag itself. So, creating a link involves a two-step process,
    but can also be shortened into a single call via some helper methods.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
- en: The URL
  id: totrans-239
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: URLs in Drupal 8 are represented with the `Drupal\Core\Url` class, which has
    a number of static methods that allow you to create an instance. The most important
    of these is `::fromRoute()`, which takes a route name, route parameters (if any
    are needed for that route), and an array of options to create a new instance of
    `Url`. There are other such methods available that turn all sorts of other things
    into a `Url`, most notably the `::fromUri()` method which takes an internal or
    external URI. These methods can be very helpful, especially when dealing with
    dynamically obtained data. However, when hardcoding, it's always best to work
    with route names because that allows you to later change the actual path behind
    that route without affecting your code.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
- en: There are many options that can be passed to `Url` when instantiating it, inside
    the `$options` array. You can pass an array of query parameters, a fragment, and
    others. These will then help construct a URL as complex as you need without having
    to deal with strings yourself. I suggest that you check out the documentation
    above the `::fromUri()` method because it describes them all. Also, keep in mind
    that the options are pretty much the same, regardless of the method that you use
    to create the `Url` object.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
- en: The link
  id: totrans-242
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now that we have a `Url` object, we can use it to generate a link. We can do
    this in two ways:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
- en: Use the `LinkGenerator` service (named `link_generator`) and call its `generate()`
    method by passing the link text and the `Url` object we have obtained. This will
    return a `GeneratedLink` object, which contains the actual string representation
    of the link as well as some cache metadata.
  id: totrans-244
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use the `\Drupal\Core\Link` class, which wraps a render element (we will talk
    more about render elements in the `Theming` chapter) to represent the link.
  id: totrans-245
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's take a look at an example of both, from start to finish.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider this example of generating a link using the service:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: We can then directly print `$link` because it implements the `__toString()`
    method.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, consider this example of generating a link using the `Link` class:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: We now have `$link` as a `Link` object whose `toRenderable()` method returns
    a render array of the `#type => 'link'`. Behind the scenes, at render time, it
    will also use the link generator to transform that into a link string.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
- en: 'If we have a `Link` object, we can also use the link generator ourselves to
    generate a link based on its own data:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Which way to link?
  id: totrans-255
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we saw, we have a number of ways to create links and URL representations,
    but when it comes to creating a link, which method should we use? There are advantages
    and disadvantages to each one.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
- en: When it comes to URL, as mentioned, it's a good idea to stick to hardcoding
    routes rather than URIs. However, if you are working with dynamic data, such as
    user input or stored strings, the other methods are perfectly valid. I recommend
    that you look at the `Url` class in detail because you will be using it quite
    a bit as you develop Drupal 8 modules.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
- en: 'Regarding the actual links, using the service to generate a link means that
    you are creating a string at that point in the code. This means that it cannot
    be altered later in the process. However, using the `Link` class falls nicely
    in line with the entire render array rationale of delaying the actual generation
    to the last possible moment. We will talk more about render arrays later on. So,
    the choice you make depends on the link you need to generate and your answer to
    the following question: is the link something that might have to be alterable
    by other modules/themes? If so, proceed with the render array. Otherwise, you
    might consider generating if you can inject the service properly.'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
- en: When it comes to entities, it's always better to use the helper methods on the
    base entity classes to generate links and URLs to these entities. We will talk
    more about entities later in this book.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
- en: Event Dispatcher and redirects
  id: totrans-260
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A common thing you'll have to do as a module developer is to intercept a given
    request and redirect it to another page, and more often than not, this will have
    to be dynamic, depending on the current user or other contextual info. Drupal
    7 developers know very well that this has always been an easy task. Simply implement
    `hook_init()`, which gets called on each request and then use the famous `drupal_goto()`
    function. This, however, is no longer the case in Drupal 8\. What we have to do
    now is subscribe to the `kernel.request` event (remember this from the preceding
    chapter?) and then change the response directly. However, before seeing an example
    of this, let's take a look at how we can perform a simpler redirect from within
    a Controller. You know, since we're on the subject.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
- en: Redirecting from a Controller
  id: totrans-262
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we wrote a Controller that returns a render array. We know
    from the preceding chapter that this is picked up by the theme system and turned
    into a response. In [Chapter 4](feada4d1-f255-4dd6-83b5-8d66bab5f852.xhtml), *Theming*,
    we will go into a bit more detail and see how this process is done. However, this
    render pipeline can also be bypassed if the Controller returns a response directly.
    Let''s consider the following example:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: This will bypass much of that processing and return a blank white page with
    only the "my text" string on it. The `Response` class we're using is from the
    Symfony HTTP Foundation component.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
- en: 'However, we also have a handy `RedirectResponse` class that we can use, and
    it will redirect the browser to another page:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: The first parameter is the URL where we want to redirect. Typically, this should
    be an absolute URL; however, browsers nowadays are smart enough to handle a relative
    path as well. So, in this case, the Controller will redirect us to that path.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
- en: Typically, when returning redirect responses, you'll want to use a child class
    of `RedirectResponse`. For example, we have the `LocalRedirectResponse` and `TrustedRedirectResponse`
    classes which both extend from `SecuredRedirectResponse`. The purpose of these
    utilities is to ensure that redirects are safe.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
- en: Redirecting from a subscriber
  id: totrans-270
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Many times, our business logic dictates that we need to perform a redirect from
    a certain page to another if various conditions match. For these, we can subscribe
    to the request event and simply change the response, essentially bypassing the
    normal process, which would have gone through all the layers of Drupal. However,
    before we see an example, let's talk about the Event Dispatcher for just a bit.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
- en: The central player in this system is the `event_dispatcher` service, which is
    an instance of the `ContainerAwareEventDispatcher` class. This service allows
    the dispatching of named events that take a payload in the form of an `Event`
    object, which wraps the data that needs to be passed around. Typically, when dispatching
    events, you'll create an `Event` subclass with some handy methods for accessing
    the data that needs to be passed around. Finally, instances of `EventSubscriberInterface`
    listen to events that have certain names and can alter the `Event` object that
    has been passed. Essentially, then, this system allows subscribers to change data
    before the business logic uses it for something. In this respect, it is a prime
    example of an extension point in Drupal 8\. Finally, registering event subscribers
    is a matter of creating a service tagged with `event_subscriber` and that implements
    the interface.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
- en: Let's now take a look at an example event subscriber that listens to the `kernel.request`
    event and redirects to the home page if a user with a certain role tries to access
    our *Hello World* page. This will demonstrate both how to subscribe to events
    and how to perform a redirect. It will also show us how to use the current route
    match service to inspect the current route.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s create this subscriber by first writing the service definition for it:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: As you can see, we have the regular service definition with one argument and
    with the `event_subscriber` tag. The dependency is actually the service that points
    to the current user (either logged in or anonymous) in the form of an `AccountProxyInterface`.
    This is a wrapper to the `AccountInterface`, which represents the actual current
    user. Also, when I say *user*, I mean an object that has certain data about the
    user and not the actual entity object with all the field data (the user session
    basically). Certain things about the user are, however, accessible from the `AccountInterface`,
    such as the ID, the name, roles, and email. I recommend that you check out the
    interface for more info. However, for our example, we will use it to check whether
    the user has the `non_grata` role, which will trigger the redirect I mentioned.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, let''s look at the event subscriber class itself:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  id: totrans-278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: As expected, we store the current user as a class property so that we can use
    it later on. Then, we implement the `EventSubscriberInterface::getSubscribedEvents()`
    method. This method needs to return a multidimensional array, which is basically
    a mapping between event names and the class methods to be called if that event
    is intercepted. And this is how we actually register methods to listen to one
    event or another, and we can listen to multiple events in the same subscriber
    class if we want. It's typically a good idea to separate these, however, into
    different, more topical, classes. The callback method name is inside an array
    whose second value represents the priority of this callback compared to others
    you or other modules may define. The higher the number, the higher the priority,
    the earlier in the process it will run. Do check the documentation on the interface
    itself for a good description of the ways you can subscribe to events.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
- en: In our example, we listen to the `kernel.request` event I mentioned in the previous
    chapter. This event is dispatched by Symfony's `HttpKernel`, passing an instance
    of `GetResponseEvent`, which basically wraps the `Request` object. The name of
    the `Event` class usually well describes the purpose of the event. In this case
    it is looking for a `Response` object to deliver to the browser. If we inspect
    the class, we can note that it has a `setResponse()` method on it, which we can
    use to set the response. If a subscriber provides one, it stops the event propagation
    (none of the other listeners with a lower priority are given a chance) and the
    response is returned.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
- en: So, in our `onRequest()` callback method, we check the current path being requested,
    and if it is ours and the current user has the `non_grata` role, we set the `RedirectResponse`
    onto the event to redirect it to the home page. This will do the job we set out
    to do. If you go to the `/hello` page as a user with that role, you should be
    redirected to the home page. That being said, I don't like many aspects about
    this implementation. So, let's fix them.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
- en: First, we hardcoded the `kernel.request` event name (I did, can't blame you
    for that). Any decent code that dispatches events will use a class constant to
    define the event name and the subscribers should also reference that constant.
    Symfony has the `KernelEvents` class just for that purpose. Check it out and see
    what other events are dispatched by the HttpKernel, as they are all referenced
    there.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
- en: 'So, instead of hardcoding the string, we can have this:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Second, the way we do the path handling in the `onRequest()` method is all
    sorts of wrong. We are hardcoding the `/hello` path in this condition. What if
    we change the route path because our boss wants the path to be `/greeting`? I
    also don''t like the way we passed the path to the `RedirectResponse`. The same
    thing applies (although in the case of the home page, not so much): what if the
    path we want to redirect to changes? Let''s fix these problems using routes instead
    of paths. They are system-specific and are unlikely to change because of business
    requirements.'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
- en: 'The problem is that we are unable to understand which route is being accessed
    from the `Request` object. Instead then, we can use the `current_route_match`
    service—a very popular one you''ll use often—which gives us loads of info about
    the current route. So, let''s inject that into our event subscriber. By now, you
    should know how to do this on your own (check the final code if you still have
    trouble). Once that is done, we can do this instead:'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  id: totrans-287
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: From the `CurrentRouteMatch` service, we can figure out the name of the current
    route, the entire route object, parameters from the URL, and other useful things.
    Do check out the class for more info on what you can do, as I guarantee that they
    will come in handy.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
- en: Instead of checking against the pathname, we now check against the route name.
    So, if we change the path in the route definition, our code will still work. Then,
    instead of just adding the path to the `RedirectResponse`, we can build it first
    using the `Url` class we learned about in the previous section. Granted, in our
    example, it is probably overkill, but had we redirected it to a known route, we
    could have built it based on that, and our code would have been more robust. Additionally,
    using the `Url` class, we can also check other things such as access, and its
    `toString()` method simply turns it into a string that can be used for the `RedirectResponse`.
    Finally, instead of the simple `RedirectResponse`, we are using the `LocalRedirectResponse`
    class instead as we are redirecting to a local (safe) path.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
- en: 'With this, we will get the same redirect, but in a much cleaner and more robust
    way. Of course, only after adjusting the *use* statements at the top by removing
    the one for the `RedirectResponse` and adding the following:'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  id: totrans-291
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Dispatching events
  id: totrans-292
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Since we have discussed how to subscribe to events in Drupal 8, we should also
    take a look at how we can dispatch our own events. After all, the Symfony Event
    Dispatcher component is one of the principal vectors of extensibility in Drupal
    8.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
- en: To demonstrate this, we will create an event to be dispatched whenever our `HelloWorldSalutation::getSalutation()`
    method is called. The purpose is to inform other modules that this has happened
    and potentially allow them to alter the message that comes out of the configuration
    object—not really a solid use case, but good enough to demonstrate how we can
    dispatch events.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
- en: 'The first thing that we will need to do is to create an event class that will
    be dispatched. It can go into the root of our module''s namespace:'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  id: totrans-296
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: The main purpose of this event class is that an instance of it will be used
    to transport the value of our salutation message. This is why we created the `$message`
    property on the class and added the getter and setter methods. Moreover, we use
    it to define a constant for the actual name of the event that will be dispatched.
    Finally, the class extends from the base `Event` class that comes with the Event
    Dispatcher component as a standard practice. We could also use that class directly,
    but we would not have our data stored in it as we do now.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, it''s time to inject the Event Dispatcher service into our `HelloWorldSalutation`
    service. We have already injected `config.factory`, so we just need to add a new
    argument to the service definition:'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  id: totrans-299
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Of course, we will also receive it in the constructor and store it as a class
    property:'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  id: totrans-301
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'We will also have the obligatory *use* statement for the `EventDispatcherInterface`
    at the top of the file:'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  id: totrans-303
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Now, we can make use of the dispatcher. So instead of the following code inside
    the `getSalutation()` method:'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  id: totrans-305
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'We can have the following:'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  id: totrans-307
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: So with the above, we decided that if we are to return a salutation message
    from the configuration object, we want to inform other modules and allow them
    to change it. We first create an instance of our Event class and feed it the relevant
    data (the message). Then, we dispatch the named event and pass the event object
    along with it. The Event Dispatcher returns the event that has been dispatched
    with any changes that might have been applied to it by subscribers. Finally, we
    get the data from that instance and return it.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
- en: Pretty simple, isn't it? What can subscribers do? It's very similar to what
    we saw regarding the example on redirects in the preceding section. All a subscriber
    needs to do is listen for the `SalutationEvent::EVENT` event and do something
    based on that. The main thing that it can do is use the `setValue()` method on
    the received event object to change the salutation message. It can also use the
    `stopPropagation()` method from the base `Event` class to inform the Event Dispatcher
    to no longer trigger other listeners that have subscribed to this event.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-310
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we covered a great deal of info about the things you need to
    know when developing Drupal 8 modules. The first thing we did was create our very
    own module skeleton that can be installed on a Drupal 8 site. Then, we saw how
    to create a new page at a specific path (route) and show some basic data on that
    page. Nothing too complex, but enough to illustrate one of the most common tasks
    you will do as a module developer. We then took that to a new level and abstracted
    the logic for that data calculation into a service. Not only that, but we also
    saw how we can use that service and, more importantly, how we *should* use it.
    Next, we saw how we can work with the Form API in Drupal 8 to allow administrators
    to add some configuration to the site. A very important takeaway here was also
    that the Form API page in Drupal 8 will prove invaluable because you have many
    different types of form elements at your disposal. So, keep that close by. Also,
    since we talked about forms, we saw how we can alter existing forms defined by
    other modules—a useful technique for any module developer.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
- en: Next, we created our first custom block which allowed us to reuse our service
    and be more flexible with where we show our data.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
- en: Then, we looked at how to create URLs and links programmatically in Drupal 8\.
    In the functionality we built in this module, we don't need any links, yet. However,
    it is a common practice to work with them, so we had to learn early how to generate
    links and work with URLs properly in Drupal 8.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
- en: In the last section, we explored the Symfony *Event Dispatcher* component, something
    that allows us to dispatch and subscribe to events. We saw some examples of how
    we can subscribe to one of the main Kernel events in order to redirect the page,
    but we also saw how to dispatch our own event. The latter was meant to allow subscribers
    to make changes to our data.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
- en: Most of the topics we covered in this chapter were meant to give you an initial
    boost and the tools to start developing modules in Drupal 8\. They represent the
    absolute most common things—I believe—any new Drupal developer encounters and
    has to do.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will look at two important aspects most applications
    will need to use. One is logging—the better your site logs its errors and important
    actions, the easier it will be to debug and trace back issues. Another is mailing—websites
    usually need to send out emails to users in one way or another, so it's important
    that we see how that works in Drupal 8.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
