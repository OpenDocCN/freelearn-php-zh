<html><head></head><body><div class="chapter" title="Chapter&#xA0;2.&#xA0;Kick-Starting OOP"><div class="titlepage"><div><div><h1 class="title"><a id="ch02"/>Chapter 2. Kick-Starting OOP</h1></div></div></div><p>In this chapter we will learn how to create objects, define their attributes (or properties) and methods. Objects in PHP are always created using a "class" keyword. In this chapter we will learn the details of classes, properties, and methods. We will also learn the scope of methods and about modifiers and the benefits of using interfaces This chapter will also introduce us to other basic OOP features in PHP. As a whole, this chapter is one of the better resources for you to kick-start OOP in PHP.</p><div class="section" title="Let's Bake Some Objects"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec13"/>Let's Bake Some Objects</h1></div></div></div><a id="id32" class="indexterm"/><p>As I said before, you can create an object in PHP using the <code class="literal">class</code> keyword. A class consists of some properties and methods, either public or private. Let's take the <code class="literal">Emailer</code> class that we have seen in our first chapter. We will discuss here what it actually does:</p><div class="informalexample"><pre class="programlisting">&lt;?
//class.emailer.php
class Emailer
{
  private $sender;
  private $recipients;
  private $subject;
  private $body;
 
  function __construct($sender)
  {
    $this-&gt;sender = $sender;
    $this-&gt;recipients = array();
  }
  
  public function addRecipients($recipient)
  {
    array_push($this-&gt;recipients, $recipient);
  }
  
  public function setSubject($subject)
  {
    $this-&gt;subject = $subject;
  }
  
  public function setBody($body)
  {
    $this-&gt;body = $body;
  }
  
  public function sendEmail()
  {
  foreach ($this-&gt;recipients as $recipient)
  {
    $result = mail($recipient, $this-&gt;subject, $this-&gt;body, 
                              "From: {$this-&gt;sender}\r\n");
    if ($result) echo "Mail successfully sent to {$recipient}&lt;br/&gt;";
    }
  }
}
?&gt;</pre></div><p>In this code, we started with <code class="literal">class</code> <code class="literal">Emailer</code>, which means that the name of our class is <code class="literal">Emailer</code>. While naming a class, follow the same naming convention as variables, i.e. you can't start with a numeric letter, etc. </p><a id="id33" class="indexterm"/><p>After that we declared the properties of this class. There are four properties here, namely, <code class="literal">$sender</code>, <code class="literal">$recipient</code>, <code class="literal">$subject</code>, and <code class="literal">$body</code>. Please note that we declare each of them with a keyword <code class="literal">private</code>. A private property means that this property can only be accessed internally from this class. Properties are nothing but variables inside a class. </p><p>If you remember what a method is, it is just a function inside the class. In this class there are five functions, <code class="literal">__construct()</code>, <code class="literal">addRecipient()</code>, <code class="literal">setSubject()</code>, <code class="literal">setBody()</code>, and <code class="literal">sendEmail()</code>. Please note that the last four methods are declared public. That means when someone instantiates this object, they can access these methods. </p><p>The <code class="literal">__construct()</code> is a special method inside a class which is called constructor method. Whenever a new object is created from this class, this method will execute automatically. So if we have to perform some preliminary tasks in our object while initiating it, we will do from this constructor method. For example, in the constructor method of this <code class="literal">Emailer</code> class we just set the <code class="literal">$recipients</code> as a blank array and we also set the sender name. </p><div class="section" title="Accessing Properties and Methods from Inside the Class"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec05"/>Accessing Properties and Methods from Inside the Class</h2></div></div></div><p>Are you wondering how a function can access the class properties from inside its content? Let's see using the following code:</p><div class="informalexample"><pre class="programlisting">  public function setBody($body)
  {
    $this-&gt;body = $body;
  }</pre></div><p>There is a private property named <code class="literal">$body</code> inside our class, and if we want to access it from within the function, we must refer to it with <code class="literal">$this</code>. <code class="literal">$this</code> means a reference to current instance of this object. So we can access the <code class="literal">body</code> property with <code class="literal">$this-&gt;body</code>. Please note that we have to access the properties (i.e class variables) of a class using a "-&gt;" following the instance. </p><p>Similarly, like properties, we can access any member method from inside another member method in this format. For example, we can evoke <code class="literal">setSubject</code> method as <code class="literal">$this-&gt;setSubject()</code>. </p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note02"/>Note</h3><p>Please note that <code class="literal">$this</code> keyword is only valid inside the scope of a method, as long as it is not declared as static. You can not use <code class="literal">$this</code> keyword from outside the class. We will learn about this "static", "private", "public" keywords more in the <span class="emphasis"><em>Modifiers</em></span> section later this chapter. </p></div></div></div></div></div>
<div class="section" title="Using an Object"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec14"/>Using an Object</h1></div></div></div><a id="id34" class="indexterm"/><p>Let's use the newly created <code class="literal">Emailer</code> object from inside our PHP code. We must note some things before using an object. You must initiate an object before using it. After initiating, you can access all its public properties and methods using "-&gt;" after the instance. Let's see using the following code:</p><div class="informalexample"><pre class="programlisting">&lt;?
$emailerobject = new Emailer("hasin@pageflakes.com");
$emailerobject-&gt;addRecipients("hasin@somewherein.net");
$emailerobject-&gt;setSubject("Just a Test");
$emailerobject-&gt;setBody("Hi Hasin, How are you?");
$emailerobject-&gt;sendEmail();
?&gt;</pre></div><p>In the above code piece, we first created an instance of <code class="literal">Emailer</code> class to a variable name <code class="literal">$emailerobject</code> in the first line. Here, there is something important to note: We are supplying a sender address while instantiating this: </p><div class="informalexample"><pre class="programlisting">$emailerobject = new Emailer("hasin@pageflakes.com");</pre></div><p>Remember we had a constructor method in our class as <code class="literal">__construct($sender)</code>. When initiating an object, we said that the constructor method is called automatically. So while initiating this <code class="literal">Emailer</code> class we must supply the proper arguments as declared in the constructor method. For example the following code will create a warning: </p><div class="informalexample"><pre class="programlisting">&lt;?
$emailer = new emailer();
?&gt;</pre></div><p>When you execute the above code, it shows the warning as follows: </p><div class="informalexample"><pre class="programlisting">Warning: Missing argument 1 for emailer::__construct(), 
called in C:\OOP with PHP5\Codes\ch1\class.emailer.php on line 42 
and defined in &lt;b&gt;C:\OOP with PHP5\Codes\ch1\class.emailer.php&lt;/b&gt; 
on line &lt;b&gt;9&lt;/b&gt;&lt;br /&gt;</pre></div><p>See the difference? If your class had no constructor method or a constructor with no arguments, you can instantiate it with the above code.<a id="id35" class="indexterm"/>
</p></div>
<div class="section" title="Modifiers"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec15"/>Modifiers</h1></div></div></div><a id="id36" class="indexterm"/><p>You have seen that we used some keywords like <code class="literal">private</code> or <code class="literal">public</code> in our class. So what are these and why do we need to use them? Well, these keywords are called modifier and introduced in PHP5. They were <span class="emphasis"><em>not</em></span> available in PHP4. These keywords help you to define how these variables and properties will be accessed by the user of this class. Let's see what these modifiers actually do.</p><p>
<span class="strong"><strong>Private</strong></span>: Properties or methods declared as private are not allowed to be called from outside the class. However any method inside the same class can access them without a problem. In our <code class="literal">Emailer</code> class we have all these properties declared as private, so if we execute the following code we will find an error. </p><div class="informalexample"><pre class="programlisting">&lt;?
include_once("class.emailer.php");
$emobject = new Emailer("hasin@somewherein.net");
$emobject-&gt;subject = "Hello world";
?&gt;</pre></div><p>The above code upon execution gives a fatal error as shown below: </p><div class="informalexample"><pre class="programlisting">&lt;b&gt;Fatal error&lt;/b&gt;: Cannot access private property emailer::$subject
 in &lt;b&gt;C:\OOP with PHP5\Codes\ch1\class.emailer.php&lt;/b&gt; on line 
&lt;b&gt;43&lt;/&gt;&lt;br /&gt;</pre></div><p>That means you can't access any private property or method from outside the class. </p><p>
<span class="strong"><strong>Public</strong></span>: Any property or method which is not explicitly declared as private or protected is a public method. You can access a public method from inside or outside the class.  </p><p>
<span class="strong"><strong>Protected:</strong></span> This is another modifier which has a special meaning in OOP. If any property or method is declared as protected, you can only access the method from its subclass. We will learn details about subclass later in this chapter. But to see how a protected method or property actually works, we'll use the following example: </p><p>To start, let's open <code class="literal">class.emailer.php</code> file (the <code class="literal">Emailer</code> class) and change the declaration of the <code class="literal">$sender</code> variable. Make it as follows:</p><div class="informalexample"><pre class="programlisting">protected $sender</pre></div><p>Now create another file name <code class="literal">class.extendedemailer.php</code> with the following code: </p><div class="informalexample"><pre class="programlisting">&lt;?
class ExtendedEmailer extends emailer 
{
function  __construct(){}
   public function setSender($sender)
  {
    $this-&gt;sender = $sender;
  }
}
?&gt;</pre></div><a id="id37" class="indexterm"/><p>Now use this object like this:</p><div class="informalexample"><pre class="programlisting">&lt;?
include_once("class.emailer.php");
include_once("class.extendedemailer.php");
$xemailer = new ExtendedEmailer();
$xemailer-&gt;setSender("hasin@pageflakes.com");
$xemailer-&gt;addRecipients("hasin@somewherein.net");
$xemailer-&gt;setSubject("Just a Test");
$xemailer-&gt;setBody("Hi Hasin, How are you?");
$xemailer-&gt;sendEmail();
?&gt; </pre></div><p>Now if you look carefully at the code of the <code class="literal">ExtendedEmailer</code> class, you will find that we accessed the <code class="literal">$sender</code> property of its parent (which is actually <code class="literal">Emailer</code> class). We have been able to access that property only because it was declared as protected. One more benefit we get here, is that the property <code class="literal">$sender</code> is still inaccessible directly from outside the scope of these two classes. That means if we execute the following code, it will generate a fatal error. </p><div class="informalexample"><pre class="programlisting">&lt;?
include_once("class.emailer.php");
include_once("class.extendedemailer.php");
$xemailer = new ExtendedEmailer();
$xemailer-&gt;sender = "hasin@pageflakes.com";
?&gt;</pre></div><p>Upon execution, it gives the following error:</p><div class="informalexample"><pre class="programlisting">&lt;b&gt;Fatal error&lt;/b&gt;:  Cannot access protected property 
extendedEmailer::$sender in &lt;b&gt;C:\OOP with 
PHP5\Codes\ch1\test.php&lt;/b&gt; on line &lt;b&gt;5&lt;/b&gt;&lt;br /&gt;<a id="id38" class="indexterm"/>
</pre></div></div>
<div class="section" title="Constructors and Destructors"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec16"/>Constructors and Destructors</h1></div></div></div><a id="id39" class="indexterm"/><a id="id40" class="indexterm"/><p>We discussed earlier in this chapter about the constructor method. A constructor method is the method that executes automatically while creating instances of the class. In PHP5, there are two ways you can write a constructor method inside a class. The first one is to create a method with the name <code class="literal">__construct()</code> inside the class. The second is to create a method naming exactly the same as class name. For example if your class name is <code class="literal">Emailer</code>, the name of the constructor method will be <code class="literal">Emailer()</code>. Let's take a look at the following class which calculates the factorial of any number: </p><div class="informalexample"><pre class="programlisting">&lt;?
//class.factorial.php
class factorial
{
  private $result = 1;// you can initialize directly outside
  private $number;
  function __construct($number)
  {
    $this-&gt;number = $number;
    for($i=2; $i&lt;=$number; $i++)
    {
      $this-&gt;result *= $i;
    }
  }
  public function showResult()
  {
    echo "Factorial of {$this-&gt;number} is {$this-&gt;result}. ";
  }
}
?&gt;</pre></div><p>In the code above, we used <code class="literal">__construct()</code> as our constructor function. The behaviour will be same if you rename the <code class="literal">__construct()</code> function as <code class="literal">factorial()</code>. </p><p>Now, you may ask if a class can have constructors in both styles? This means a function named <code class="literal">__construct()</code> and a function named the same as class name. So which constructor will execute, or will they both execute? This is a good question. Actually there is no chance of executing both. If there is a constructor in both styles, PHP5 will give preference to the <code class="literal">__construct()</code> function and the other one will be ignored. Let's take a look using the following example</p><div class="informalexample"><pre class="programlisting">&lt;?
//class.factorial.php
class Factorial
{
  private $result = 1;
  private $number;

  function __construct($number)
  {
    $this-&gt;number = $number;
    for($i=2; $i&lt;=$number; $i++)
    {
      $this-&gt;result*=$i;
    }
    echo "__construct() executed. ";
  }

  function factorial($number)
  {<a id="id41" class="indexterm"/>
<a id="id42" class="indexterm"/>
    $this-&gt;number = $number;
    for($i=2; $i&lt;=$number; $i++)
    {
      $this-&gt;result*=$i;
    }
    echo "factorial() executed. ";
  }

  public function showResult()
  {
    echo "Factorial of {$this-&gt;number} is {$this-&gt;result}. ";
  }
}
?&gt;</pre></div><p>Now if you use this class as shown below:</p><div class="informalexample"><pre class="programlisting">&lt;?
include_once("class.factorial.php");
$fact = new Factorial(5);
$fact-&gt;showResult();
?&gt;</pre></div><p>You will find that the output is:</p><div class="informalexample"><pre class="programlisting">__construct() executed. Factorial of 5 is 120</pre></div><p>Similar to the constructor method, there is a <span class="strong"><strong>destructor</strong></span> method which actually works upon destroying an object. You can explicitly create a destructor method by naming it <code class="literal">__destruct()</code>. This method will be invoked automatically by PHP at the end of the execution of your script. To test this, let's add the following code in our factorial class:</p><div class="informalexample"><pre class="programlisting">function __destruct()
{
  echo " Object Destroyed.";
}</pre></div><p>Now execute the usage script again, you will see the following output this time: </p><div class="informalexample"><pre class="programlisting">__construct() executed. Factorial of 5 is 120. Object Destroyed.<a id="id43" class="indexterm"/>
<a id="id44" class="indexterm"/>
</pre></div></div>
<div class="section" title="Class Constants"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec17"/>Class Constants</h1></div></div></div><a id="id45" class="indexterm"/><p>Hopefully, you will already know that you can create constants in your PHP scripts using the <span class="strong"><strong>define</strong></span> keyword to define (constant name, constant value). But to create constants in the class you have to use the <code class="literal">const</code> keyword. These constants actually work like static variables, the only difference is that they are read-only. Let's see how we can create constants and use them: <a id="id46" class="indexterm"/>
</p><div class="informalexample"><pre class="programlisting">&lt;?
class WordCounter
{
  const ASC=1;  //you need not use $ sign before Constants
  const DESC=2;
  private $words;

  function __construct($filename)
  {
    $file_content = file_get_contents($filename);
    $this-&gt;words = 
         (array_count_values(str_word_count(strtolower
                                           ($file_content),1)));
  }

  public function count($order)
  {
    if ($order==self::ASC)
    asort($this-&gt;words);
    else if($order==self::DESC)
    arsort($this-&gt;words);
    foreach ($this-&gt;words as $key=&gt;$val)
    echo $key ." = ". $val."&lt;br/&gt;";
  }
}
?&gt;</pre></div><p>This <code class="literal">WordCounter</code> class counts the frequency of words in any given file. Here we define two constant names <code class="literal">ASC</code> and <code class="literal">DESC</code> whose values are 1 and 2 respectively. To access these constants from within the class, we reference them with the <code class="literal">self</code> keyword. Please note that we are accessing them with the <code class="literal">::</code> operator, not a <code class="literal">-&gt;</code> operator, because these constants act like a static member. <a id="id47" class="indexterm"/>
</p><p>Finally to use this class, let's create a snippet as shown below. In this snippet we are also accessing those constants: </p><div class="informalexample"><pre class="programlisting">&lt;?
include_once("class.wordcounter.php");
$wc = new WordCounter("words.txt");
$wc-&gt;count(WordCounter::DESC);
?&gt;</pre></div><p>Please note that we are accessing the class constants from outside the class by following the <code class="literal">::</code> operator right after the class name, not after the instance of the class. Now let's test the script, please create a file named <code class="literal">words.txt</code> with the following content in the same directory where you placed the above script:</p><div class="informalexample"><pre class="programlisting">words.txt
Wordpress is an open source blogging engine. If you are not familiar
 with blogging, it is something like keeping a diary on the web. 
A blog stands for web log. Wordpress is totally free and 
released under the GPL.</pre></div><p>Now, if you execute the usage script, this time, you will see the following output. </p><div class="informalexample"><pre class="programlisting">is = 3
a = 2
blogging = 2
web = 2
wordpress = 2
stands = 1
blog = 1
in = 1
diary = 1
for = 1
free = 1
under = 1
gpl = 1
released = 1
and = 1
totally = 1
log = 1
something = 1
if = 1
you = 1
engine = 1
source = 1
an= 1
open = 1
are = 1
not = 1
ï = 1
like = 1
it = 1
with = 1
familiar = 1
keeping = 1</pre></div><p>Nice utility, what do you think?<a id="id48" class="indexterm"/>
</p></div>
<div class="section" title="Extending a Class [Inheritance]"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec18"/>Extending a Class [Inheritance]</h1></div></div></div><a id="id49" class="indexterm"/><a id="id50" class="indexterm"/><p>One of the greatest features in OOP is that you can extend a class and create a completely new object. The new object can retain all the functionality of the parent object from which it is extended or can override. The new object can also introduce some features. Let's extend our <code class="literal">Emailer</code> class and override the <code class="literal">sendEmail</code> function so that it can send HTML mails. </p><div class="informalexample"><pre class="programlisting">&lt;?
class HtmlEmailer extends emailer
{
  public function sendHTMLEmail()
  {
    foreach ($this-&gt;recipients as $recipient)
    {
      $headers  = 'MIME-Version: 1.0' . "\r\n";
      $headers .= 'Content-type: text/html; charset=iso-8859-1' . 
                                                           "\r\n";
      $headers .= 'From: {$this-&gt;sender}' . "\r\n";
      $result = mail($recipient, $this-&gt;subject, $this-&gt;body, 
                                                       $headers);
      if ($result) echo "HTML Mail successfully sent to 
                                              {$recipient}&lt;br/&gt;";
    }
  }
}
?&gt;</pre></div><p>As this class extends the <code class="literal">Emailer</code> class and introduces a new function, <code class="literal">sendHTMLEmail()</code>, you can still have all the methods from its parent. That means the following code is fully valid:</p><div class="informalexample"><pre class="programlisting">&lt;?
include_once("class.htmlemailer.php");
$hm = new HtmlEmailer();
//.... do other things
$hm-&gt;sendEmail();
$hm-&gt;sendHTMLEmail();
?&gt;</pre></div><p>If you want to access any method of the parent class (or you may say superclass) from which it is derived, you can call using the <code class="literal">parent</code> keyword. For example, if you want to access a method named <code class="literal">sayHello</code>, you should write <code class="literal">parent::sayHello();</code>
</p><a id="id51" class="indexterm"/><p>Please note that we didn't write any function named <code class="literal">sendEmail()</code> in <code class="literal">HtmlEmailer</code> class, but that method is working from its parent, <code class="literal">Emailer</code> class. </p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note03"/>Note</h3><p>In the above example, <code class="literal">HtmlEmailer</code> is a subclass of <code class="literal">Emailer</code> class and <code class="literal">Emailer</code> class is a superclass of <code class="literal">HtmlEmailer</code>. You must remember that if the subclass has no constructor in it, the constructor from superclass will be invoked. At the time of writing this book, there is no support for multiple inheritances at class level. This means you can't extend more than one class at a time. However multiple inheritance is supported in interfaces. An interface can extend an arbitrary number of other interfaces at a time. </p></div></div><div class="section" title="Overriding Methods"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec06"/>Overriding Methods</h2></div></div></div><p>In an extended object you can override any method (either declared as protected or public) and perform anything as you wish. So how can you override any method? Simply create a function with the same name that you want to override. For example, if you create a function name <code class="literal">sendEmail</code> in <code class="literal">HtmlEmailer</code> class, it will override the <code class="literal">sendEmail()</code> method of its parent, <code class="literal">Emailer</code> class. If you declare any variable in subclass which is also available in superclass, then when you access that variable, the one from subclass will be accessed. </p></div><div class="section" title="Preventing from Overriding"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec07"/>Preventing from Overriding </h2></div></div></div><a id="id52" class="indexterm"/><p>If you declare any method as a <code class="literal">final</code> method, it can't be overridden in any of its subclass. So if you don't want someone to override your class methods, declare it as final. Let's take a look at the following example:</p><div class="informalexample"><pre class="programlisting">&lt;?
class SuperClass
{
  public <span class="strong"><strong>final</strong></span> function someMethod()
  {
    //..something here
  }
}

class SubClass extends SuperClass 
{
  public function someMethod()
  {
    //..something here again, but it wont run
  }
}
?&gt;</pre></div><p>If you execute the above code, it will generate a fatal error because class <code class="literal">SubClass</code> tried <a id="id53" class="indexterm"/>to override a method in <code class="literal">SuperClass</code> which was declared as <code class="literal">final</code>.</p></div><div class="section" title="Preventing from Extending"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec08"/>Preventing from Extending</h2></div></div></div><a id="id54" class="indexterm"/><p>Similar to a final method, you can declare a class as final, which will prevent anyone from extending it. So if you declare any class, as shown in following example, it is no more extensible. </p><div class="informalexample"><pre class="programlisting">&lt;?
final class aclass
{
}

class bclass extends aclass 
{
}
?&gt;</pre></div><p>If you execute the code above, it will trigger the following error: </p><div class="informalexample"><pre class="programlisting">&lt;b&gt;Fatal error&lt;/b&gt;:  Class bclass may not inherit from final class 
(aclass) in &lt;b&gt;C:\OOP with PHP5\Codes\ch1\class.aclass.php&lt;/b&gt; on 
line &lt;b&gt;8&lt;/b&gt;&lt;br /&gt;</pre></div></div></div>
<div class="section" title="Polymorphism"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec19"/>Polymorphism</h1></div></div></div><a id="id55" class="indexterm"/><p>As we explained before, polymorphism is the process of creating several objects from specific base classes. For example, take a look at the following case in point. We need the three classes that we created earlier in this chapter, <code class="literal">Emailer</code>, <code class="literal">ExtendedEmailer</code> and <code class="literal">HtmlEmailer</code>. Let's take a look at the following code. </p><div class="informalexample"><pre class="programlisting">&lt;?
include("class.emailer.php");
include("class.extendedemailer.php");
include("class.htmlemailer.php");

$emailer = new Emailer("hasin@somewherein.net");
$extendedemailer = new ExtendedEmailer();
$htmlemailer = new HtmlEmailer("hasin@somewherein.net");
if ($extendedemailer instanceof emailer  )
echo "Extended Emailer is Derived from Emailer.&lt;br/&gt;";
if ($htmlemailer instanceof emailer  )
echo "HTML Emailer is also Derived from Emailer.&lt;br/&gt;";
if ($emailer instanceof htmlEmailer )
echo "Emailer is Derived from HTMLEmailer.&lt;br/&gt;";
if ($htmlemailer instanceof extendedEmailer  )
echo "HTML Emailer is Derived from Emailer.&lt;br/&gt;";
?&gt;</pre></div><p>If you execute the script above, you will find the following output:</p><div class="informalexample"><pre class="programlisting">Extended Emailer is Derived from Emailer.
HTML Emailer is also Derived from Emailer.</pre></div><p>This is an example of polymorphism. </p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note04"/>Note</h3><p>You can always check if a class is derived from another class by using the <code class="literal">instanceof</code> operator. </p></div></div></div>
<div class="section" title="Interface"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec20"/>Interface</h1></div></div></div><a id="id56" class="indexterm"/><p>Interface is an empty class which contains only the declaration of methods. So any class which implements this interface must contain the declared functions in it. So, interface is nothing but a strict ruling, which helps to extend any class and strictly implement all methods defined in interface. A class can use any interface by using the <code class="literal">implements</code> keyword. Please note that in interface you can only declare methods, but you cannot write their body. That means the body of all methods must remain blank. </p><p>So why is an interface necessary, you might ask? One of the reasons is it implies strict rules while creating a class. For example, we know that we need to create some driver classes in our application, which can handle DB operations. For MySQL, there will be one class, for PostgreSQL there will be another, For SQLite, another one and so forth. Now your developer team has three developers, who will separately create these three classes. </p><p>Now how will it be if each of them implements their own style in their own classes? The developers who are going to use those driver classes will have to check how they define their methods and following that, the way they have to write their code, which is too boring and hard to maintain. So if you define that, all driver class must have two methods named <code class="literal">connect()</code> and <code class="literal">execute()</code>. Now developers need not worry while changing the driver, because they know that all these classes have the same method definition. Interface helps in this scenario. Let's create the interface here:</p><div class="informalexample"><pre class="programlisting">&lt;?
//interface.dbdriver.php
interface DBDriver
{
  public function connect();
  public function execute($sql);
}
?&gt;</pre></div><p>Did you notice that the functions are empty in an interface? Now let's create our <code class="literal">MySQLDriver</code> class, which implements this interface:</p><div class="informalexample"><pre class="programlisting">&lt;?
//class.mysqldriver.php
include("interface.dbdriver.php");
class MySQLDriver <span class="strong"><strong>implements</strong></span> DBDriver 
{

}
?&gt;</pre></div><a id="id57" class="indexterm"/><p>Now if you execute the code above, it will give the following error because <code class="literal">MySQLDriver</code> class has no <code class="literal">connect()</code> and <code class="literal">execute()</code> function as defined in the interface. Let's run the code and read the error: </p><div class="informalexample"><pre class="programlisting">&lt;b&gt;Fatal error&lt;/b&gt;: Class MySQLDriver contains 2 abstract methods 
and must therefore be declared abstract or implement the remaining 
methods (DBDriver::connect, DBDriver::execute) in &lt;b&gt;C:\OOP with 
PHP5\Codes\ch1\class.mysqldriver.php&lt;/b&gt; on line &lt;b&gt;5&lt;/b&gt;&lt;br /&gt;</pre></div><p>Well, now we have to add those two methods in our <code class="literal">MySQLDriver</code> class. Let's see the code below:</p><div class="informalexample"><pre class="programlisting">&lt;?
include("interface.dbdriver.php");
class MySQLDriver implements DBDriver 
{
  public function connect()
  {
    //connect to database
  }
  public function execute()
  {
    //execute the query and output result
  }
}
?&gt;</pre></div><p>If we run the code now, we get the following error message again:</p><div class="informalexample"><pre class="programlisting">&lt;b&gt;Fatal error&lt;/b&gt;:  Declaration of MySQLDriver::execute() must be 
compatible with that of DBDriver::execute() in &lt;b&gt;C:\OOP with 
PHP5\Codes\ch1\class.mysqldriver.php&lt;/b&gt; on line &lt;b&gt;3&lt;/b&gt;&lt;br /&gt;</pre></div><a id="id58" class="indexterm"/><p>The error message is saying that our <code class="literal">execute()</code> method is not compatible with the <code class="literal">execute()</code> method structure that was defined in the interface. If you now take a look at the interface, you will find that <code class="literal">execute()</code> method should have one argument. So that means whenever we implement an interface in our class, every method structure must exactly be the same as defined in the interface. Let's rewrite our <code class="literal">MySQLDriver</code> class as follows: </p><div class="informalexample"><pre class="programlisting">&lt;?
include("interface.dbdriver.php");
class MySQLDriver implements DBDriver 
{
  public function connect()
  {
    //connect to database
  }
  public function execute($query)
  {
    //execute the query and output result
  }
}
?&gt;</pre></div></div>
<div class="section" title="Abstract Class"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec21"/>Abstract Class</h1></div></div></div><a id="id59" class="indexterm"/><p>An abstract class is almost the same as interface, except that now the methods can contain body. An abstract class must also be "extended", not "implemented". So if the extended classes have some methods with common functionalities, then you can define those functions in an abstract class. Let's see the example below: </p><div class="informalexample"><pre class="programlisting">&lt;?
//abstract.reportgenerator.php
abstract class ReportGenerator
{
  public function generateReport($resultArray)
  {
    //write code to process the multidimensional result array and 
    //generate HTML Report
  }
}
?&gt;</pre></div><p>In our abstract class we have a method named <code class="literal">generateReport</code>, which takes a multidimensional array as argument and then generates an HTML report using it. Now, why did we put this method in an abstract class? Because generating a report will be a common function to all DB Drivers and it doesn't affect the code because it is taking only one array as an argument, not anything relevant to DB itself. Now we can use this abstract class in our <code class="literal">MySQLDriver</code> class as shown below. Please note that all the code to generate the report is already written, so we need not write code for that method in our driver class again as we did for interfaces. <a id="id60" class="indexterm"/>
</p><div class="informalexample"><pre class="programlisting">&lt;?
include("interface.dbdriver.php");
include("abstract.reportgenerator.php");
class MySQLDriver extends ReportGenerator implements DBDriver 
{
  public function connect()
  {
    //connect to database
  }
  public function execute($query)
  {
    //execute the query and output result
  }
  // You need not declare or write the generateReport method here 
  //again as it is extended from the abstract class directly."
}
?&gt;</pre></div><p>Please note that we can use the abstract class and implement an interface concurrently as shown in the above example.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note05"/>Note</h3><p>You cannot declare an abstract class as final, because abstract class means it has to be extended and final class means it can't be extended. So it's totally meaningless to use these two keywords together. PHP won't allow you to use them together.</p></div></div><p>Similar to declaring a class as abstract, you can also declare any method as abstract. When a method is declared as abstract, it means that the subclass must override that method. An abstract method should not contain any body where it is defined. An abstract method can be declared as shown here:<a id="id61" class="indexterm"/>
</p><div class="informalexample"><pre class="programlisting">abstract public function connectDB();</pre></div></div>
<div class="section" title="Static Method and Properties"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec22"/>Static Method and Properties</h1></div></div></div><a id="id62" class="indexterm"/><a id="id63" class="indexterm"/><p>A <code class="literal">static</code> keyword is very important in object oriented programming. Static methods and properties play a vital role in application design and also in design patterns. So what are static methods and properties?</p><p>You have already seen that to access any method or attribute in a class you must create an instance (i.e. using <code class="literal">new</code> keyword, like <code class="literal">$object</code> <code class="literal">=</code> <code class="literal">new</code> <code class="literal">emailer()</code>), otherwise you can't access them. But there is a difference for static methods and properties. You can access a static method or property directly without creating any instance of that class. A static member is like a global member for that class and all instances of that class. Also, static properties persist the last state of what it was assigned, which is very useful in some cases. </p><p>You might ask why someone uses a static method. Well, most of the static methods are similar to utility methods. They perform a very specific task, or return a specific object (static properties and methods are used significantly in design patterns, we will learn that later). So declaring a new object every time for those works might be considered resource extensive. Let's see an example of static methods. </p><p>Consider that in our application we keep support for all three databases, MySQL, PostgreSQL, and SQLite. Now we need to use one particular driver at a time. For that, we are designing a <code class="literal">DBManager</code> class, which can instantiate any driver on demand and return that to us. </p><div class="informalexample"><pre class="programlisting">&lt;?
//class.dbmanager.php
class DBManager
{
  public static function getMySQLDriver()
  {
    //instantiate a new MySQL Driver object and return
  }

  public static function getPostgreSQLDriver()
  {
    //instantiate a new PostgreSQL Driver object and return
  }

  public static function getSQLiteDriver()
  {
    //instantiate a new MySQL Driver object and return
  }
}
?&gt;</pre></div><p>How do we use this class? You can access any static property using a <code class="literal">::</code> operator and not using the <code class="literal">-&gt;</code> operator. Let's see the example below: </p><div class="informalexample"><pre class="programlisting">&lt;?
//test.dbmanager.php
include_once("class.dbmanager.php");
$dbdriver = DBManager::getMySQLDriver();
//now process db operation with this $dbdriver object
?&gt;</pre></div><p>Notice that we didn't create any instance of <code class="literal">DBManager</code> object like <code class="literal">$dbmanager</code> <code class="literal">=</code> <code class="literal">new</code> <code class="literal">DBManager()</code>. Rather we directly access one of its methods using the <code class="literal">::</code> operator. </p><p>So how does this benefit us? Well, we just need a driver object, so no need to create a new <code class="literal">DBManager</code> object and commit it to memory as long as our scripts are executing. Static methods usually perform a specific task and finish it. </p><p>Here are some important things to note. You can't use <code class="literal">$this</code> pseudo object inside a static method. As the class is not instantiated, <code class="literal">$this</code> doesn't exist inside a static method. You should rather use the <code class="literal">self</code> keyword. <a id="id64" class="indexterm"/>
<a id="id65" class="indexterm"/>
</p><p>Let's take a look at the following example. It shows how a static property actually works: </p><div class="informalexample"><pre class="programlisting">&lt;?
//class.statictester.php
class StaticTester
{
  private static $id=0;

  function __construct()
  {
    self::$id +=1;
  }

  public static function checkIdFromStaticMehod()
  {
    echo "Current Id From Static Method is ".self::$id."\n";
  }

  public function checkIdFromNonStaticMethod()
  {
    echo "Current Id From Non Static Method is ".self::$id."\n";
  }
}

$st1 = new StaticTester();
StaticTester::checkIdFromStaticMehod();
$st2 = new StaticTester();
$st1-&gt;checkIdFromNonStaticMethod(); //returns the val of $id as 2
$st1-&gt;checkIdFromStaticMehod();
$st2-&gt;checkIdFromNonStaticMethod();
$st3 = new StaticTester();
StaticTester::checkIdFromStaticMehod();
?&gt;</pre></div><p>You will see the output is as follows:</p><div class="informalexample"><pre class="programlisting">Current Id From Static Method is 1
Current Id From Non Static Method is 2
Current Id From Static Method is 2
Current Id From Non Static Method is 2
Current Id From Static Method is 3</pre></div><p>Whenever we create a new instance, it affects all the instances as the variable is declared as static. Using this special facility, a special design pattern "Singleton" works perfectly in PHP. <a id="id66" class="indexterm"/>
<a id="id67" class="indexterm"/>
</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip02"/>Tip</h3><p>
<span class="strong"><strong>Caution: Using Static Members</strong></span>
</p><p>Static members make object oriented much like old procedural programming; without creating instances, you can directly call any function, like the old days. That's why we use static method with caution. Excessive static methods make no use at all. Unless you have any specific purpose, don't use static members. </p></div></div></div>
<div class="section" title="Accessor Methods"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec23"/>Accessor Methods</h1></div></div></div><a id="id68" class="indexterm"/><p>Accessor methods are simply methods that are solely devoted to get and set the value of any class properties. It's a good practice to access class properties using accessor methods instead of directly setting or getting their value. Though accessor methods are the same as other methods, there are some conventions writing them. </p><a id="id69" class="indexterm"/><p>There are two types of accessor methods. One is called <code class="literal">getter</code>, whose purpose is returning value of any class property. The other is setter that sets a value into a class property. Let's see how to write the <code class="literal">getter</code> and <code class="literal">setter</code> methods for class properties:</p><div class="informalexample"><pre class="programlisting">&lt;?
class Student
{
  private $name;
  private $roll;
  public function setName($name)
  {
    $this-&gt;name= $name;
  }
  public function setRoll($roll)
  {
    $this-&gt;roll =$roll;
  }

  public function getName()
  {
    return $this-&gt;name;
  }
  public function getRoll()
  {
    return $this-&gt;roll;
  }
}
?&gt;</pre></div><p>In the above example there are two <code class="literal">getter</code> methods and two <code class="literal">setter</code> methods. <a id="id70" class="indexterm"/>
<a id="id71" class="indexterm"/>There is a convention in writing <code class="literal">accessor</code> methods. A <code class="literal">setter</code> method should start with <code class="literal">set</code> and the property name with the first character capitalized. A <code class="literal">getter</code> method should start with <code class="literal">get</code> followed by the variable name with the first letter capitalized. That means if we have a property named <code class="literal">email</code>, the getter method should be named as <code class="literal">getEmail</code> and the setter method should be named as <code class="literal">setEmail</code>. That's it. </p><p>So you might ask why someone does these extra jobs, when they can easily set these variables as public and leave everything else as is. Aren't all these the same? Well, no. Using accessor methods, you get some extra benefits. You will have full control while setting or retrieving the value of any property. "So what?" You might ask. Let's use a scenario where you need to filter users' input and set into properties. In this case, a <code class="literal">setter</code> can help you to filter the input before setting them into work. </p><p>Does this mean we have to write 100 <code class="literal">getter</code> and <code class="literal">setter</code> methods if my class contains 100 properties? You ask as good question. PHP is kind enough to relieve you from this boredom. How? Let us see the next section where we discuss using magic methods for setting and getting property values dynamically. Those methods will reduce the stress up to 90%. Don't you believe me? Let's see.</p></div>
<div class="section" title="Using Magic Methods to Set/Get Class Properties"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec24"/>Using Magic Methods to Set/Get Class Properties</h1></div></div></div><a id="id72" class="indexterm"/><p>We discussed in the previous section that writing accessor method for a number of properties will be a real nightmare. To avoid that boredom, you can use magic methods. This process is called property overloading.</p><p>PHP5 introduced some magic methods in classes to reduce the pain of OOP in some cases. Two of those magic methods are introduced to set and get dynamic property values in a class. These two magic methods are named as <code class="literal">__get()</code> and <code class="literal">__set()</code>. Let us see how to use them: </p><div class="informalexample"><pre class="programlisting">&lt;?
//class.student.php
class Student
{
  private $properties = array();
  function __get($property)
  {
    return $this-&gt;properties[$property];
  }

  function __set($property, $value)
  {
    $this-&gt;properties[$property]="AutoSet {$property} as: ".$value;
  }

}
?&gt;</pre></div><p>Now let us see the code in action. Use the class above with the following script:</p><div class="informalexample"><pre class="programlisting">&lt;?
$st = new Student();
$st-&gt;name = "Afif";
$st-&gt;roll=16;
echo $st-&gt;name."\n";
echo $st-&gt;roll;
?&gt;</pre></div><p>When you execute the preceding code, PHP recognizes immediately that no property named <code class="literal">name</code> or <code class="literal">roll</code> exists in the class. Since the named property doesn't exist, the <code class="literal">__set()</code> method is called, which then assigns the value to the newly-created property of the class, allowing you to see the following output:</p><div class="informalexample"><pre class="programlisting">AutoSet name as: Afif
AutoSet roll as: 16</pre></div><p>Seems quite interesting, huh? Using magic methods you still have full control over setting and retrieving property values in classes. However, you have one limitation if you use magic methods. While using reflection API, you can't investigate class properties (we will discuss about reflection API in a later chapter). Moreover, your class lost the "readability" and "maintainability" quite a lot. Why? See the code of previous <code class="literal">Student</code> class and new <code class="literal">Student</code> class and you will understand that for yourself. </p></div>
<div class="section" title="Magic Methods for Overloading Class Methods"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec25"/>Magic Methods for Overloading Class Methods</h1></div></div></div><a id="id73" class="indexterm"/><p>Like overloading, and using the accessor methods, there are magic methods to overload any method call in a class. If you are still not familiar with method overloading, then this is a process of accessing any method that doesn't even exist in the class. Sounds funny, right? Let's take a closer look.</p><p>There is a magic method, which helps to overload any method call in PHP5 class context. The name of that magic method is <code class="literal">__call()</code>. This allows you to provide actions or return values when undefined methods are called on an object. It can be used to simulate method overloading, or even to provide smooth error handling when an undefined method is called on an object. <code class="literal">__call</code> takes two arguments: the name of the method and an array of the arguments passed to the undefined method.</p><p>For example see the code below: </p><div class="informalexample"><pre class="programlisting">&lt;?
class Overloader
{
  function __call($method, $arguments)
  {
    echo "You called a method named {$method} with the following 
                                                arguments &lt;br/&gt;";
    print_r($arguments);
    echo "&lt;br/&gt;";
  }
}

$ol = new Overloader();
$ol-&gt;access(2,3,4);
$ol-&gt;notAnyMethod("boo");
?&gt;</pre></div><p>If you see the code above, then you will see that there is no method called <code class="literal">access</code> and <code class="literal">notAnyMethod</code>. So therefore, it should raise an error, right? However, the method overloader still helps you to call any non existing method. If you execute the code above, you will get the following output.</p><div class="informalexample"><pre class="programlisting">You called a method named access with the following arguments 
Array
(
    [0] =&gt; 2
    [1] =&gt; 3
    [2] =&gt; 4
)

You called a method named notAnyMethod with the following arguments 
Array
(
    [0] =&gt; boo
)</pre></div><p>That means you will get all arguments as an array. There are many more magic methods, which you will learn step-by-step in this book. </p></div>
<div class="section" title="Visually Representing a Class"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec26"/>Visually Representing a Class</h1></div></div></div><a id="id74" class="indexterm"/><p>In OOP, sometimes you have to visually represent your class. Let's learn how to visually represent a class. For this, we will use our <code class="literal">Emailer</code> class this time.</p><div class="mediaobject"><img src="graphics/2561_01_01.jpg" alt="Visually Representing a Class"/></div><p>I<a id="id75" class="indexterm"/>n this graphical representation, there are three sections. At the top most section a class name should be written. In the second section all methods with or without parameters are written. And in the third box all the properties are written. That's it! </p></div>
<div class="section" title="Summary"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec27"/>Summary</h1></div></div></div><p>In this chapter we have learned how to create objects and interact between them. PHP5 brings amazing improvements in object models when compared to PHP4. Zend Engine 2, which is at the core of PHP5, is also very efficient in handling these features with great performance optimization. </p><p>In the next chapter we will go through more details and the core features of OOP in PHP. But before starting next chapter, please practice everything discussed here, otherwise you may get confused in some topics. Practice them as much as you can, try to refactor all your previous code in OOP. The more you practice, the more efficient you become. </p></div></body></html>