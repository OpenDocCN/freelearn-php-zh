<html><head></head><body><div class="chapter" title="Chapter&#xA0;5.&#xA0;Testing &#x2013; It's Easier Than You Think"><div class="titlepage"><div><div><h1 class="title"><a id="ch05"/>Chapter 5. Testing – It's Easier Than You Think</h1></div></div></div><p>Testing is an often-neglected part in PHP development. Compared to languages such as Java and Ruby, where testing is strongly ingrained into the workflow of developers, PHP has been lagging behind. This is mainly because simple PHP applications tend to be tightly coupled and are, therefore, difficult to test. However, thanks to standardization and modularization efforts and frameworks that encourage the separation of concerns, PHP testing has become more accessible and the mentality towards it is slowly changing.</p><p>Laravel 5 is a framework that was built from the ground up to facilitate testing. It comes with all the necessary files to get started, along with different helpers to test your application, thus helping beginners to overcome some of the biggest obstacles.</p><p>In this chapter, we will demonstrate how Laravel makes it very simple to get started with testing, without forcing you to go for a test-first approach, or making you aim for complete test coverage. In this gentle introduction to testing, we will look at the following topics:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The advantages of writing tests for your application</li><li class="listitem" style="list-style-type: disc">How to prepare your tests</li><li class="listitem" style="list-style-type: disc">The software design patterns that Laravel fosters</li><li class="listitem" style="list-style-type: disc">How to use Mockery to test objects in isolation</li><li class="listitem" style="list-style-type: disc">The built-in features and helpers that facilitate testing</li></ul></div><div class="section" title="The benefits of testing"><div class="titlepage"><div><div><h1 class="title"><a id="ch05lvl1sec35"/>The benefits of testing</h1></div></div></div><p>If you have not written <a id="id188" class="indexterm"/>tests for your web applications before, the advantages of testing might not always be obvious to you. After all, preparing and writing tests involves significant time investment, and for short-lived prototypes or hackathon projects, they can even seem to be a complete waste of time. However, in almost all the other cases, when your project is likely to grow in complexity, or when you collaborate with other developers, tests have the potential to save you and other people a lot of time and headaches.</p><p>Tests also introduce some changes to your workflow. In the development stage, you will no longer have to switch back and forth between your code editor and your web browser. Instead, if you are using a text <a id="id189" class="indexterm"/>editor or an IDE that supports it, you could bind a test runner to a keyboard shortcut.</p><p>Once you have proven that a certain bit of functionality works, you will have a way of quickly ensuring that it continues to work as expected, if the source code is changed at a later date. In addition to this, it forces you to clearly and unambiguously define the expected behavior of your application and can therefore complement or replace a significant part of the documentation. This can be particularly helpful, not only for new developers who start collaborating on the project, but also for yourself, if you have not touched the project for a while.</p></div></div>
<div class="section" title="The anatomy of a test"><div class="titlepage"><div><div><h1 class="title"><a id="ch05lvl1sec36"/>The anatomy of a test</h1></div></div></div><p>Your application <a id="id190" class="indexterm"/>tests will reside in <code class="literal">tests/</code>. In this directory, you will find a base test case inside <code class="literal">TestCase.php</code>, which is responsible for bootstrapping the application in the testing environment. This class extends Laravel's main <code class="literal">TestCase</code> class, which in turn extends the <code class="literal">PHPUnit_Framework_TestCase</code> class, along with many helpful testing methods that we will cover later in this chapter. All of your tests will extend this first <code class="literal">TestCase</code> class and define one or more methods that are meant to test one or more features of your application.</p><p>In every test, we <a id="id191" class="indexterm"/>generally perform the following three distinct tasks:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">We <span class="emphasis"><em>arrange </em></span>or initialize some data.</li><li class="listitem">We execute a function to <span class="emphasis"><em>act</em></span> on this data.</li><li class="listitem">We <span class="emphasis"><em>assert </em></span>or verify that the output matches what we expected.</li></ol></div><p>Given we had the following Helper class:</p><div class="informalexample"><pre class="programlisting">class Helper {public static function sum($arr) { return array_sum($arr); }}</pre></div><p>An example test case, <code class="literal">HelperTest.php</code>, which illustrates the three preceding steps, will look like this:</p><div class="informalexample"><pre class="programlisting">class HelperTest extends PHPUnit_Framework_TestCase {
  public function testSum() {
<span class="strong"><strong>    $data = [1,2,3];                   // 1) Arrange</strong></span>
<span class="strong"><strong>    $result = Helper::sum($data);      // 2) Act</strong></span>
<span class="strong"><strong>    $this-&gt;assertEquals(6, $result);   // 3) Assert</strong></span>
  }
  public function testSomethingElse() {
    // ...
  }
}</pre></div><p>When the preceding code snippet is executed, PHPUnit will run each method within the test case and keep track of how many tests failed or passed. With PHPUnit installed on your system, you can run <a id="id192" class="indexterm"/>this test, using the following command:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ phpunit --colors HelperTest.php</strong></span>
</pre></div><p>This will produce the following output:</p><div class="mediaobject"><img src="graphics/B04308_05_01.jpg" alt="The anatomy of a test"/></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip03"/>Tip</h3><p>Most code editors also provide ways to run this directly within the editor by pressing a shortcut key. Examples of such editors include <span class="strong"><strong>PhpStorm</strong></span>. It is even possible to run them automatically before each commit or before you deploy your code to a remote server.</p></div></div></div>
<div class="section" title="Unit testing with PHPUnit"><div class="titlepage"><div><div><h1 class="title"><a id="ch05lvl1sec37"/>Unit testing with PHPUnit</h1></div></div></div><p>A positive effect of testing is that it forces you to split your code into manageable dependencies, so that you can test them in isolation. The testing of these individual classes and methods is referred to as <span class="strong"><strong>unit testing</strong></span>. Since it relies on the PHPUnit testing framework, which already provides a large number of tools to set up test suites, Laravel does not need to provide any additional helpers for this type of testing.</p><p>A great way to learn about <a id="id193" class="indexterm"/>any framework, and at the same time learn about the different ways in which it can be tested, is to look at how its authors have written tests for it. Therefore, our next examples will be taken directly from Laravel's test suite, which is located at <code class="literal">vendor/laravel/framework/tests/</code>.</p><div class="section" title="Defining what you expect with assertions"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec45"/>Defining what you expect with assertions</h2></div></div></div><p>Assertions are the <a id="id194" class="indexterm"/>fundamental components of unit tests. Simply put, they are <a id="id195" class="indexterm"/>used to compare the <span class="emphasis"><em>expected output</em></span> of a function with its <span class="emphasis"><em>actual output</em></span>.</p><p>To see how assertions work, we will examine the test for the <code class="literal">Str::is()</code> helper, which checks whether a given string matches a given pattern.</p><p>The following test can be found near the bottom of the <code class="literal">Support/SupportStrTest.php</code> file:</p><div class="informalexample"><pre class="programlisting">use Illuminate\Support\Str;
class SupportStrTest extends PHPUnit_Framework_TestCase {
  // ...
  public function testIs()
  {
    $this-&gt;assertTrue(Str::is('/', '/'));
    $this-&gt;assertFalse(Str::is('/', ' /'));
    $this-&gt;assertFalse(Str::is('/', '/a'));
    $this-&gt;assertTrue(Str::is('foo/*', 'foo/bar/baz'));
    $this-&gt;assertTrue(Str::is('*/foo', 'blah/baz/foo'));
  }
}</pre></div><p>The preceding test performs five assertions to test whether the method is indeed returning the expected value when called with different parameters.</p><p>PHPUnit provides many other <a id="id196" class="indexterm"/>assertion methods that can, for example, help you test <a id="id197" class="indexterm"/>for numerical values with <code class="literal">assertGreaterThan()</code>, equality with <code class="literal">assertEquals()</code>, types with <code class="literal">assertInstanceOf()</code>, or existence with <code class="literal">assertArrayHasKey()</code>. While there are many more possible assertions, these are the ones you will probably end up using most frequently. In total, PHPUnit provides around 40 different assertion methods, all of which are described in the <a id="id198" class="indexterm"/>official documentation at <a class="ulink" href="http://phpunit.de/manual/">http://phpunit.de/manual/</a>.</p></div><div class="section" title="Preparing the scene and cleaning up objects"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec46"/>Preparing the scene and cleaning up objects</h2></div></div></div><p>If you need to run a <a id="id199" class="indexterm"/>function before each test method to set up <a id="id200" class="indexterm"/>some test data or reduce code duplication, you can use the <code class="literal">setUp()</code> method. If, on the other hand, you need to run some code after each test to clear any objects that were instantiated in your tests, you can define it inside the <code class="literal">tearDown()</code> method. A good example would be to remove any records from a database inserted in the <code class="literal">setUp()</code> method.</p></div><div class="section" title="Expecting exceptions"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec47"/>Expecting exceptions</h2></div></div></div><p>It is also possible <a id="id201" class="indexterm"/>to test for exceptions by decorating your <a id="id202" class="indexterm"/>function with an <code class="literal">@expectedException</code> DocBlock, like Laravel does inside <code class="literal">Database/ DatabaseEloquentModelTest.php</code>:</p><div class="informalexample"><pre class="programlisting">/**
<span class="strong"><strong> * @expectedException Illuminate\Database\Eloquent\MassAssignmentException</strong></span>
 */
public function testGlobalGuarded()
{
  $model = new EloquentModelStub;
  $model-&gt;guard(['*']);
  $model-&gt;fill(['name' =&gt; 'foo', 'age' =&gt; 'bar', 'votes' =&gt; 'baz']);
}</pre></div><p>In this test function, there is no assertion, but the code is expected to throw an exception when it is executed. Also note the use of an <code class="literal">EloquentModelStub</code> object. A stub creates an instance of an object that provides or simulates the methods that our class needs—in this case, an Eloquent <a id="id203" class="indexterm"/>model on which we can call the <code class="literal">guard()</code> and <code class="literal">fill()</code> methods. If you look at the definition of this stub further down in the test, you will <a id="id204" class="indexterm"/>see that it does not actually interact with a database, but it provides canned responses instead.</p></div><div class="section" title="Testing interdependent classes in isolation"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec48"/>Testing interdependent classes in isolation</h2></div></div></div><p>In addition to <a id="id205" class="indexterm"/>stubs, which we looked at in the previous section, there is another way in which you can test one or more interdependent classes in isolation. It is by using <span class="strong"><strong>mocks</strong></span>. In Laravel, mocks are created using the Mockery library, and they help define the methods that should be called during the test, the arguments they should receive, and their return values as well. Laravel heavily relies on mocks in its own tests. An example can be found in the <code class="literal">AuthEloquentUserProviderTest</code> class, where the <code class="literal">Hasher</code> class is mocked:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>use Mockery as M;</strong></span>

class AuthEloquentUserProviderTest extends PHPUnit_Framework_TestCase {

  public function tearDown(){
    <span class="strong"><strong>M::close();</strong></span>
  }
  // ...

  public function getProviderMock() {
    <span class="strong"><strong>$hasher = m::mock('Illuminate\Contracts\Hashing\Hasher');</strong></span>
    return $this-&gt;getMock('Illuminate\Auth\EloquentUserProvider', array('createModel'), array($hasher, 'foo'));
  }
}</pre></div><p>As opposed to stubs, mocks allow us to define which methods need to be called, how many times they should be called, which parameters they should receive, and which parameters they should return. If any of these preconditions are not met, the test will fail.</p><p>To ensure that we <a id="id206" class="indexterm"/>do not have an instance of a mocked object that persists and interferes with future tests, Mockery provides a <code class="literal">close()</code> method that needs to be executed after each test. Thanks to this mock, the class can be tested in complete isolation.</p></div></div>
<div class="section" title="End-to-end testing"><div class="titlepage"><div><div><h1 class="title"><a id="ch05lvl1sec38"/>End-to-end testing</h1></div></div></div><p>When we are confident <a id="id207" class="indexterm"/>that all of the interdependent classes work as expected, we can then conduct another type of testing. It consists of simulating the kind of interaction that a user would have through a web browser. This user would, for example, visit a specific URL, perform certain actions, and expect to see some kind of feedback from the application.</p><p>This is perhaps the most straightforward type of testing, as it mimics the kind of testing that you manually perform each time you refresh your browser after a code change. When you get started, it is absolutely fine to only perform this type of testing. However, you must bear in mind that if any errors occur, you will still have to drill deep down into your code to find the exact component that caused the error.</p><div class="section" title="Testing – batteries included"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec49"/>Testing – batteries included</h2></div></div></div><p>When you start a new <a id="id208" class="indexterm"/>project with Laravel, you are provided with both a configuration file with sensible defaults for PHPUnit at the root of the project inside <code class="literal">phpunit.xml</code> as well as a directory, <code class="literal">tests/</code>, where you are expected to save your tests. This directory even contains an example test that you can use as a starting point.</p><p>With these settings in place, from the root of our project, all we need to do is SSH into our Homestead virtual machine and run the following command:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ phpunit</strong></span>
</pre></div><p>This command will read the XML configuration file and run our tests. If, at this stage, you get an error message telling you that PHPUnit cannot be found, you either need to add the <code class="literal">phpunit</code> command to your <code class="literal">PATH</code> variable or install it with Composer.</p><p>Laravel applications come with PHPUnit already declared in the <code class="literal">autoload-dev</code> block in your <code class="literal">composer.json</code> file. After running <code class="literal">composer update</code>, you will be able to call PHPUnit by using the following command:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ vendor/bin/phpunit</strong></span>
</pre></div></div><div class="section" title="Framework assertions"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec50"/>Framework assertions</h2></div></div></div><p>Now that we know about the <a id="id209" class="indexterm"/>two major types of tests and have PHPUnit installed, we are going to write a few tests for the application that we developed in <a class="link" href="ch03.html" title="Chapter 3. Your First Application">Chapter 3</a>, <span class="emphasis"><em>Your First Application</em></span>.</p><p>This first test will verify whether visitors are redirected to the correct page when they first visit our site:</p><div class="informalexample"><pre class="programlisting">  public function testHomePageRedirection() {
    $this-&gt;call('GET', '/');
    $this-&gt;assertRedirectedTo('cats');
  }</pre></div><p>Here, we made use of the <code class="literal">call()</code> method that simulated a request to our application, which executes the request through Laravel's HTTP kernel. Then, we used one of the assertion methods provided by Laravel to make sure that the response is a redirection to the new location. If you now run the <code class="literal">phpunit</code> command, you should see the following output:</p><p>
<code class="literal">OK (1 test, 2 assertions)</code>
</p><p>Next, we can try to write a test to make sure that the creation form is not accessible to the users that are not logged in; this is shown in the following code snippet:</p><div class="informalexample"><pre class="programlisting">  public function testGuestIsRedirected() {
    $this-&gt;call('GET', '/cats/create');
    $this-&gt;assertRedirectedTo('login');
  }'</pre></div></div><div class="section" title="Impersonating users"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec51"/>Impersonating users</h2></div></div></div><p>Sometimes, you may <a id="id210" class="indexterm"/>wish to run a test as if you were a registered user of the application. This is possible by using the <code class="literal">be()</code> method and passing a <code class="literal">User</code> instance to it or whichever Eloquent model you use, along with Laravel's authentication class:</p><div class="informalexample"><pre class="programlisting">  public function testLoggedInUserCanCreateCat() {
    $user = new App\User([
      'name' =&gt; 'John Doe',
      'is_admin' =&gt; false,
    ]);
    <span class="strong"><strong>$this-&gt;be($user);</strong></span>
    $this-&gt;call('GET', '/cats/create');
    $this-&gt;assertResponseOk();
  }
</pre></div></div><div class="section" title="Testing with a database"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec52"/>Testing with a database</h2></div></div></div><p>While some <a id="id211" class="indexterm"/>developers would advise against writing tests that hit the database, it can often be a simple and effective way of making sure that all the components work together as expected. However, it should only be done once each individual unit has been tested. Let's also not forget that Laravel has support for migrations and seeding; in other words, it has all of the tools that are required to recreate an identical data structure from scratch, before each test.</p><p>To write tests that depend on a database, we need to override the <code class="literal">setUp()</code> method in our tests to migrate and seed the database each time a test is run. It is also important to run the parent <code class="literal">setUp()</code> method, otherwise, the test case will not be able to start properly:</p><div class="informalexample"><pre class="programlisting">  public function setUp(){
    parent::setUp();
    Artisan::call('migrate');
    $this-&gt;seed();
  }</pre></div><p>Then, we need to configure a test database connection in <code class="literal">config/database.php</code>; if the application does not contain any database-specific queries, we can use SQLite's in-memory feature by setting <code class="literal">:memory:</code> instead of a path to the database file. The following configuration also has the potential to speed up our tests:</p><div class="informalexample"><pre class="programlisting">'sqlite' =&gt; [
  'driver'   =&gt; 'sqlite',
  'database' =&gt; ':memory:',
],</pre></div><p>And lastly, since we are going to test the editing and deletion features, we are going to need at least one row in the <code class="literal">cats</code> table of our database, so we prepare a seeder that will insert a cat with a forced <code class="literal">id</code> of value <code class="literal">1</code>:</p><div class="informalexample"><pre class="programlisting">class CatsTableSeeder extends Seeder {
  public function run(){
    Cat::create(['id' =&gt; 1, 'name' =&gt; '''Tom', 'user_id' =&gt; 1]);
  }
}</pre></div><p>Once this is done, we can test the deletion feature as follows:</p><div class="informalexample"><pre class="programlisting">public function testOwnerCanDeleteCat() {
  $user = new App\User(['id' =&gt; 1, 'name' =&gt; 'User #1',
    'is_admin' =&gt; false]);
  $this-&gt;be($user);
  $this-&gt;call('DELETE', '/cats/1');
  $this-&gt;assertRedirectedTo('/cats');
  $this-&gt;assertSessionHas('message');
}
</pre></div><p>Note that this time, we did not need to enable the filters since the permissions are checked by a method in the <code class="literal">User</code> model. Since the database is wiped and re-seeded after each test, we do not need to worry about the fact that the previous test deleted that particular cat. We <a id="id212" class="indexterm"/>can also write a test to ensure that a user who is not an administrator cannot edit someone else's cat profile:</p><div class="informalexample"><pre class="programlisting">public function testNonAdminCannotEditCat() {
  $user = new App\User(['id' =&gt; 2, 'name' =&gt; 'User #2',
    'is_admin' =&gt; false]);
  $this-&gt;be($user);
  $this-&gt;call('DELETE', '/cats/1');
  $this-&gt;assertRedirectedTo('/cats/1');
  $this-&gt;assertSessionHas('error');
}
</pre></div></div><div class="section" title="Inspecting the rendered views"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec53"/>Inspecting the rendered views</h2></div></div></div><p>Since Laravel <a id="id213" class="indexterm"/>ships with Symfony's <code class="literal">DomCrawler</code> and <code class="literal">CssSelector</code> components, it is possible to inspect the contents of a rendered view. By issuing a request through the test client instance with <code class="literal">$this-&gt;client-&gt;request()</code>, you can filter its contents with CSS queries as follows:</p><div class="informalexample"><pre class="programlisting">public function testAdminCanEditCat() {
  $user = new App\User(['id' =&gt; 3, 'name' =&gt; 'Admin',
    'is_admin' =&gt; true));
  $this-&gt;be($user);
  $newName = 'Berlioz';
  $this-&gt;call('PUT', '/cats/1', ['name' =&gt; $newName]);
<span class="strong"><strong>  $crawler = $this-&gt;client-&gt;request('GET', '/cats/1');</strong></span>
<span class="strong"><strong>  $this-&gt;assertCount(1, $crawler-&gt;filter('h2:contains("'.$newName.'")'));</strong></span>
}</pre></div><p>The complete <a id="id214" class="indexterm"/>documentation for the <code class="literal">DomCrawler</code> component can be found at <a class="ulink" href="http://symfony.com/doc/current/components/dom_crawler.html">http://symfony.com/doc/current/components/dom_crawler.html</a>. If you are already familiar with jQuery, its syntax will look familiar to you.</p></div></div>
<div class="section" title="Summary"><div class="titlepage"><div><div><h1 class="title"><a id="ch05lvl1sec39"/>Summary</h1></div></div></div><p>While the main ideas behind testing are easy to grasp, it is often their implementation that can prove to be an obstacle, especially when working with a new framework. However, after reading this chapter, you should have a good overview of how you can test your Laravel applications. The techniques presented in this chapter will enable you to write more robust and future-proof applications.</p><p>In the next chapter, we will explore the possibilities offered by Artisan, Laravel's command-line utility.</p></div></body></html>