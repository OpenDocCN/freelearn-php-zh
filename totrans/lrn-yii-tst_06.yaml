- en: Chapter 6. Testing the API – PHPBrowser to the Rescue
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We are now going to delve into functional testing. In the previous chapter,
    we created the initial steps that deal with the user model, but now we will be
    creating the REST interface that deals with the user.
  prefs: []
  type: TYPE_NORMAL
- en: Before we even start to worry about the REST interface and its tests, we will
    be analyzing what's already available in the Yii basic app and later expand on
    the topic to create more awesome stuff.
  prefs: []
  type: TYPE_NORMAL
- en: 'This chapter is hence divided into three sections with an increasing level
    of difficulty, so keep your eyes peeled and feel free to revisit it multiple times
    until you understand each section which are:'
  prefs: []
  type: TYPE_NORMAL
- en: Functional tests in Yii 2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Functional tests for REST interfaces
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a RESTful web service with Yii 2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Functional tests in Yii 2
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As you saw in [Chapter 3](ch03.html "Chapter 3. Entering Codeception"), *Entering
    Codeception*, we have some basic functional tests preloaded in our basic application.
  prefs: []
  type: TYPE_NORMAL
- en: Let's start digging into that and once you acquire the required knowledge, we're
    going to move on to the tests for the REST interface.
  prefs: []
  type: TYPE_NORMAL
- en: As you know, the basic application is composed of a few pages, a login system,
    and a contact form.
  prefs: []
  type: TYPE_NORMAL
- en: The functional tests cover almost everything, so let's start to see what files
    we have and what's their content.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding and improving the available CEPTs
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The tests contained in `codeception/functional/HomeCept.php` are quite straightforward
    to understand. Thanks to the syntax used by Codeception, you can easily understand
    what the intention of the test is, so let''s break it down and see what each bit
    does:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: You would start by initializing the actor under which the tests will be performed.
    Yii uses a slightly different naming than the one officially used in the documentation
    and guide of Codeception, which is `TestGuy`, so keep that in mind when you're
    confronted with documentation outside of Yii's.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Remember that you can name the actors whatever you want, and their configuration
    is found in the suite YAML file, which for functional tests is `tests/codeception/functional.suite.yml`.
  prefs: []
  type: TYPE_NORMAL
- en: 'This class is located within the same folder as that of the other functional
    tests and is generated automatically by running `codecept build`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'The very first step is to declare the scope of the test in a compact but detailed
    way; this will help you and non-technical people to understand what went wrong
    and if the test is effectively doing what it is meant to be doing in a strong
    and comprehensive way. The method `wantTo()` should be called only once, as any
    following invocations will override what has been set previously:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Our tests need a starting point; the method `amOnPage()` does nothing but load
    the given URL where our actual test will take place:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: In Codeception, assertions are performed through `see*` and `dontSee*` actions,
    ensuring a particular portion of text or link is present/absent in the page.
  prefs: []
  type: TYPE_NORMAL
- en: These actions can be as descriptive as needed, and in the preceding example
    with `see('My Company')`, we are just checking that the text is present somewhere
    in the markup rather than in a particular tag while `seeLink('About')` would be
    the same as writing `see('About', 'a')`. We will shortly see that we could pass
    a second parameter to `seeLink()`, which will allow us to check the URL where
    the link should point to.
  prefs: []
  type: TYPE_NORMAL
- en: 'Interaction with the page in the form of triggering, clicking links with `click()`,
    filling fields with `fillField()`, `checkOption()`, `submitForm()`, and so on
    is all you can do with Codeception functional tests. Anything more complicated
    must be re-evaluated carefully, as you might actually need to move it into acceptance
    tests instead:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding lines, we are triggering the link of the "About" page and expecting
    that the resulting page has a specific copy in it. This specific test just makes
    a point in using links to navigate through our application, as it could have been
    done as described earlier by using `seeLink('About', '/about')` and to leave any
    assertion with the About page within its own test.
  prefs: []
  type: TYPE_NORMAL
- en: 'We might as well extend the test a bit more and make it more relevant to what
    we''re trying to test; what are the functionality parts that we want to make sure
    exist, without which we can consider the page "non-functional"? In our instance,
    we are talking about the title of the page (as it''s already been done), the menu,
    and any other links we always want to have there:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'The beginning is the same, but then we ensure that the title for the page contains
    what we expect it to be:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'The next section instead makes sure that the menu contains all the required
    links to the various pages:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: You have to keep in mind that the links are not strictly checked; this means
    that if you have `$I->seeLink('Something', '/something')`, it will match any link
    that contains `Something`; for example, it can be `Something Else` and any `href`
    attribute like `/something/else`, or even `http://something.com`.
  prefs: []
  type: TYPE_NORMAL
- en: 'In our case, it clearly renders the check for the link to the home page a bit
    irrelevant, so we might well grab the current URL and check against it in the
    following way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: There are different ways to grab content to be reused dynamically in the rest
    of the tests, such as `grabAttributeFrom()`, `grabCookie()`, `grabResponse()`,
    and so on. Once again, your `FunctionalTester` class will contain the details
    of these methods in case your IDE does not support code hinting.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can do the same for any other link that is pointing to the homepage:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'For the rest of the links, it might also be useful to check that our routes
    are well configured; for instance, you need to check if the name of the controller
    doesn''t show up:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: The last bit we want to make sure of is that the `Home` link is marked as selected.
  prefs: []
  type: TYPE_NORMAL
- en: 'For this test, we need to use a very prescriptive selector as the active class
    that identifies the status of our link is in the parent of the actual anchor,
    and as there''s no way to assert that in a simple way, so making use of XPath
    expressions comes particularly handy:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Most of the methods available that require a context selector such as `click()`,
    `see()`, and, `seeElement()` can accept this parameter in various formats, mostly
    as CSS selectors, XPath queries or Locators, which are specific objects made available
    by Codeception.
  prefs: []
  type: TYPE_NORMAL
- en: In its simplest form, selectors can be just a simple word or sentence, which
    means "find me the first context where this word/sentence appears". As you saw
    earlier, `see("Something")` will return the first element that contains `Something`
    as its value (for example, `Something Else)`.
  prefs: []
  type: TYPE_NORMAL
- en: CSS selectors are probably the ones you might be more comfortable with, but
    for more complex stuff, XPath is generally the winner.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the preceding example, the XPath query `//li[@class="active"]/a[contains(.,"Home")]`,
    can be read as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: Find me all the `li` nodes at any level (`//li`)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Filter them by a specific class attribute (`[@class="active"]`);—mind that is
    literal and case-sensitive
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Within those find me the direct descendant `a` nodes (`/a`)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Filter them if they contain a specific text (`[contains(.,"Home")]`)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: XPath 2.0 has been a W3C recommendation since December 2010, and you can read
    more about it at [http://www.w3.org/TR/xpath20/](http://www.w3.org/TR/xpath20/).
  prefs: []
  type: TYPE_NORMAL
- en: 'Locators can ease the process of writing even more complex queries in your
    DOM and let you combine CSS and XPath queries via OR:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: With the preceding statement, we can check the presence of the `Title` string
    in any `h1`, `h2`, or `h3` tag.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another possibly useful feature is a method available in Locator that you can
    use to browse the page via `tabIndex`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The preceding example has been deliberately taken from the documentation page
    of Locator, available at [http://codeception.com/docs/reference/Locator](http://codeception.com/docs/reference/Locator).
  prefs: []
  type: TYPE_NORMAL
- en: Writing reusable page interactions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Testing forms is probably one of the most strenuous tasks any developer and
    tester has probably ever done. You can feel the pain if you think of forms as
    questionnaires of several single and multiple choice questions, spread across
    several pages.
  prefs: []
  type: TYPE_NORMAL
- en: You can clearly see the direct benefit of automating using functional tests.
  prefs: []
  type: TYPE_NORMAL
- en: 'The two examples already available, `LoginCept.php` and `ContactCept.php`,
    are a good starting point. Let''s have a closer look at `LoginCept.php`; if you
    scan through the content of the test, you will immediately notice that the `fillField()`
    method is never called, and in its place we have the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Pages are, in fact, one of the easiest ways to reuse components across tests.
    The sequence of actions that are repeated several times in the same test are likely
    to be taken and put into a page like the one used in our test:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: The only thing needed is the route associated to it and then you can implement
    as many methods as you need to achieve whatever you need, which is the login process
    in the preceding case.
  prefs: []
  type: TYPE_NORMAL
- en: Within the `Page` class, `$this->actor` is a reference to the actor that is
    currently in use in the test.
  prefs: []
  type: TYPE_NORMAL
- en: 'You have two ways to use pages; the first is by opening the page immediately
    and associate it with the current actor, as seen earlier with `LoginPage::openBy($I)`,
    otherwise, you can simply call its constructor and load the page (also with different
    parameters) when needed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Now, as you saw while working with unit tests, being able to keep the content
    of the database under a controlled state is very useful. And, once again, fixtures
    come to our help, even here.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing fixtures
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In [Chapter 4](ch04.html "Chapter 4. Isolated Component Testing with PHPUnit"),
    *Isolated Component Testing with PHPUnit*, you saw how to implement a fixture.
    In functional tests the same classes can be used; the only difference is that
    Codeception's PHPBrowser and its underlying infrastructure doesn't know how to
    load fixtures, so each framework using Codeception, like what Yii does, needs
    to provide the bridging to fill in this gap.
  prefs: []
  type: TYPE_NORMAL
- en: 'The advanced app provides the implementation for `FixtureHelper` that implements
    the Codeception `Module` class and imports the methods from `FixtureTrait`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code is quite simple, and the only important bit is that in the
    `FixtureHelper`, we implement the `fixtures()` method that returns the list of
    models handled and their data files that contain all the rows we want in the database.
    The only difference with the original code that is found in the advanced app is
    the import of the `getFixture()` method as public, and we'll later see why this
    is so.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code is for the `init_login.php` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: As we imported the trait `getFixture()` as public, we can access the fixture
    through `$I->getFixture('user')` in a similar way to what we did in our unit tests.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If you need to load additional fixtures, you can similarly expose the `loadFixtures()`
    method from the `FixtureTrait` trait and use it directly in your tests.
  prefs: []
  type: TYPE_NORMAL
- en: 'The last step is about loading the module in Codeception configuration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: And after running `codecept build`, the fixture will be automatically loaded
    when running the tests in the `_beforeSuite()` and `_afterSuite()` methods.
  prefs: []
  type: TYPE_NORMAL
- en: Pitfalls of functional tests
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A word of advice is that there's plenty of information on functional tests,
    as well as what cannot be tested, in the official documentation.
  prefs: []
  type: TYPE_NORMAL
- en: The most important thing to grab there is all about the underlying technology
    that is used to perform tests; PHPBrowser is in fact a powerful tool, but as the
    whole functional test does not rely on the presence of a web server like you would
    have in a normal client-server situation, your application and functional tests
    will be running in the same memory space.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Normally the memory is cleaned during the `_after()` method execution, but remember
    that if you see any of your tests failing, remember to execute the test file separately,
    before starting to doubt your sanity.
  prefs: []
  type: TYPE_NORMAL
- en: Functional tests for REST interfaces
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Up until now, you have seen what's already been implemented, what is possible
    to do out of the box, and some additional functionalities like the fixtures.
  prefs: []
  type: TYPE_NORMAL
- en: Now let's have a look at what testing a REST interface entails; the default
    functional tests available in Codeception are executed by PHPBrowser, and the
    interface exposed to interact with it is quite limited and can only be used to
    deal and interact with the markup output by the web server. The REST module provided
    by Codeception is something we would love.
  prefs: []
  type: TYPE_NORMAL
- en: Just to cite a few of the features available, you'll have functions to set and
    read headers, such as `seeHttpHeader()` and `haveHttpHeader()`, and specific methods
    to call HTTP requests towards our interface, such as `sendGET()`, `sendPUT()`,
    and `sendOPTIONS()`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Specifically for our interface of the user, our tests will be split into two
    parts:'
  prefs: []
  type: TYPE_NORMAL
- en: Tests on the actual functionality—authentication and interaction with the application
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Some additional tests to ensure that we are exposing the right endpoints
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Now, with this in mind, let''s start having a look at the configuration part;
    in the `functional.suite.yml` file, just add the REST module and configure it
    as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: The last line is quite important, as we will end up making calls by specifying
    only our endpoint without the need of naming the module base path. Clearly things
    need to be adjusted accordingly in case you have more than one REST endpoint you
    need to test.
  prefs: []
  type: TYPE_NORMAL
- en: Now, once again we need to run `codecept build` in order to get everything ready
    before starting to run our tests. This command, as already seen, will take all
    the module's methods and merge them into our actor's class (which in this case
    is `FunctionalTester`).
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s generate our new test file with the following commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that we have the file, we can start implementing our tests:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: We start the file with the initialization of the `FunctionalTester` and the
    definition of the scope of our test.
  prefs: []
  type: TYPE_NORMAL
- en: Defining the API endpoints
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As it's now time to implement the tests for our API endpoints, we need to define
    what these will look like and take our architectural decisions if these haven't
    been taken beforehand.
  prefs: []
  type: TYPE_NORMAL
- en: The basic interaction we want to provide to our clients interacting with our
    APIs is the ability to retrieve the user information, and modify it with the specific
    ability to change the password.
  prefs: []
  type: TYPE_NORMAL
- en: The client would normally know only the username and password. Since our update
    method will leverage on the ID of the user, we need to find a way for the client
    to get it in advance. Depending on the type of authentication protocol you decide
    to use, you can decide to return it right after the authentication has happened,
    otherwise you need to find a different way.
  prefs: []
  type: TYPE_NORMAL
- en: As you will later see, you're going to use the simplest of the authentication
    methods available, that is HTTP Basic Auth, which means that all our requests
    require a username and password to be sent along with them in a header. By doing
    so we clearly can't return the user ID in the response as this should contain
    the answer to the call and not the authentication header, so we can decide to
    provide a "search by username" endpoint. This will clearly make the username a
    unique field in the database, but that's not an issue, rather it's something you
    need to take into consideration if you're providing a user creation interface.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we have the following endpoints to test:'
  prefs: []
  type: TYPE_NORMAL
- en: '`GET users/search/<username>`: This is used to retrieve the ID of the user.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`GET users/<id>`: This is used to retrieve any other information associated
    with the user.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`PUT users/<id>`: This is used to update the password.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing the tests for the API
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As our passwords are passed as encrypted in the fixtures, we need to hardcode
    them in the tests, in order to authenticate appropriately.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is not a good practice as we are going to make things a bit harder to
    maintain. On the other end, if things get more complex, we might want to refactor
    the code and find a better, more unified solution:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that we have some basic information about the user, we can try to grab
    its ID and check if its authentication works altogether:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: The first step is to prepare the request, which is composed of the `Authorization`
    header and the actual request. We don't need to explicitly generate the `Authorization`
    header, as we have an abstraction over it provided by `amHttpAuthenticated()`,
    which would do that for us.
  prefs: []
  type: TYPE_NORMAL
- en: 'The header is then sent alongside the GET request over our endpoint; note how
    the URL omits the `/v1/` part that we would normally use to prefix the API:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Once we''ve sent the request, we can start analyzing the response and do various
    assertions on it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Finally, we grab the user ID from the response, so we can reuse it afterwards.
  prefs: []
  type: TYPE_NORMAL
- en: 'The next step is about fetching the user''s own information knowing their ID,
    which looks particularly straightforward to implement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'As the last step, we have kept the tests on updating the password and ensuring
    that the new password works as expected:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Please note that due to the length of the tests, we will be keeping them all
    in one file as it won't affect their legibility, but you can clearly split them
    in more CEST files to aggregate them in a more concise and logical way.
  prefs: []
  type: TYPE_NORMAL
- en: This should be all you really need to know. We can check that none of the tests
    will pass at this point, and at the end of the chapter, we will ensure that all
    of them are finally passing.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Also note that it's not necessary to call `amHttpAuthenticated()` to send the
    authentication header every time as it will be cached after the first call in
    the CEPT file, and should only be required when the header needs to be updated.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have seen how easy it is to write a functional test, I can leave
    the creation of additional tests to you. If you want, you can start by checking
    that the rest of the interfaces have not been exposed, such as the ability to
    request the list of all users and retrieve or change their passwords.
  prefs: []
  type: TYPE_NORMAL
- en: In the following section of this chapter, we are going to focus on the implementation
    side of the things by looking at some new, shiny features provided by Yii 2.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a RESTful web service with Yii 2
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It's important to remember that a REST web service is by definition a stateless
    service, this will imply some requirements in the way we will test things and
    deal with the information we need to POST or GET.
  prefs: []
  type: TYPE_NORMAL
- en: The big step forward that Yii made with version 2 can be seen in the built-in
    REST classes that provide an immediate solution once provided by third-party implementations.
  prefs: []
  type: TYPE_NORMAL
- en: This means we'll have to introduce several changes to what we've achieved so
    far; the REST part of the application will be developed as a separate module,
    which will give us the ability to extend it and contain its logic. Because of
    this, the routes will be rearranged appropriately as well.
  prefs: []
  type: TYPE_NORMAL
- en: Before seeing what the Yii REST functionality is capable of doing, we'll need
    to first have a quick look at modules in Yii, which we will use to develop our
    API to be tested.
  prefs: []
  type: TYPE_NORMAL
- en: Writing modular code in Yii
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If you've never used modules since you've started working with Yii, well, I
    think it's time to do so. Right now, modules are really easy and straightforward
    to use, and they will help you keep your code architecturally well organized and
    separated from the other components of your application.
  prefs: []
  type: TYPE_NORMAL
- en: Modules are self-contained software units that contain models, views and controllers,
    and other software components, and the end user will be able to access the controller
    once it is installed in the main application. For this reason, modules are considered
    mini-applications, only difference being that they cannot live on their own. As
    an example, a forum or an administrative area can be developed as modules.
  prefs: []
  type: TYPE_NORMAL
- en: Modules can also be composed of submodules; a forum might have an admin submodule
    that contains all the logic and interfaces to moderate and customize the main
    forum module.
  prefs: []
  type: TYPE_NORMAL
- en: Modules can be quite complex in their structure; I would always strongly suggest
    an architectural analysis before deciding to keep everything under the same module,
    in the same way as you need to question your choices if you were to keep all the
    code in the same controller. Always try to keep in mind that you should be able
    to understand your code in one year's time.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a module with Gii
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Developing the REST interface using Yii modules is the easiest way to achieve
    versioning of the API. This way, we can easily switch and make an improved version
    of the API while still continuing to support the old version with minimal maintenance,
    until full deprecation.
  prefs: []
  type: TYPE_NORMAL
- en: So we will start with the creation of the module, using the web interface to
    the code generator called Gii. In case you skipped a few pages, the configuration
    for that is available in [Chapter 4](ch04.html "Chapter 4. Isolated Component
    Testing with PHPUnit"), *Isolated Component Testing with PHPUnit*, where you saw
    how to create a model with it.
  prefs: []
  type: TYPE_NORMAL
- en: Now, we will see how to create a module and what this will mean in terms of
    generated code.
  prefs: []
  type: TYPE_NORMAL
- en: So, head over to the Gii application, which in my case is `http://basic.yii2.sandbox/gii`
    and log in, if you are configured to do so and click on the **Module Generator**
    button.
  prefs: []
  type: TYPE_NORMAL
- en: 'The only two fields we have to fill in are these:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Module Class**: This represents the main name-spaced class name of the module,
    which will be set to `app\modules\v1\Module`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Module ID**: This will be (automatically) set to `v1`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Have a look at the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating a module with Gii](img/B03646_06_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Module generator page within the Gii code generation tool
  prefs: []
  type: TYPE_NORMAL
- en: You can avoid creating the view by deselecting the related checkbox, as we're
    not going to need one. We're going to make more changes to what has been generated.
  prefs: []
  type: TYPE_NORMAL
- en: Click on the **Generate** button, once ready.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If your application will end up being more complex than what we have here, you
    still have a few options.
  prefs: []
  type: TYPE_NORMAL
- en: You can simply adjust the routes for the module, as explained in the documentation
    at [http://www.yiiframework.com/doc-2.0/guide-runtime-routing.html#adding-rules-dynamically](http://www.yiiframework.com/doc-2.0/guide-runtime-routing.html#adding-rules-dynamically).
  prefs: []
  type: TYPE_NORMAL
- en: Otherwise, you can create a module within a module (for example, a container
    module called `api` which will contain the various versions as modules such as
    `v1`, `v2`, and so on). Just remember to namespace it correctly when creating
    it. This is usually the solution I'd recommend from the code organization point
    of view.
  prefs: []
  type: TYPE_NORMAL
- en: The next step is to configure the module in order to be able to use it, and
    then we will see how to transform it into a REST module.
  prefs: []
  type: TYPE_NORMAL
- en: Using modules in Yii 2
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now that we have our basic code for our module ready, we need to see how we
    can use it.
  prefs: []
  type: TYPE_NORMAL
- en: Ideally, the created module can be used straight away without much hassle, which
    is quite helpful in an environment where you want to be able to create reusable
    and, of course, modular code.
  prefs: []
  type: TYPE_NORMAL
- en: The only step that's really needed is instructing Yii that there is a new module,
    and in return, it will take care of auto-loading and calling our module controller
    at the right time.
  prefs: []
  type: TYPE_NORMAL
- en: 'So let''s head over to our configuration file located in `/config/web.php`
    and add the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: With this, you're ready to go. In order to convert the newly created module
    to act as a REST controller, it requires some additional changes, which we will
    explore immediately.
  prefs: []
  type: TYPE_NORMAL
- en: Converting our controller to be a REST controller
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This much anticipated feature of Yii 2 lets you create a REST interface in a
    clear and easy way.
  prefs: []
  type: TYPE_NORMAL
- en: The REST controller we will inherit from will deal with our models without much
    configuration needed and even if there was, it's quite straightforward to do and
    keep in mind.
  prefs: []
  type: TYPE_NORMAL
- en: Our first step is to create `UserController` which will be dealt with the `User`
    model.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s start by defining the namespace and the basic classes we''re going to
    use in our new controller:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: As we can clearly see, we're going to use the `User` model and on top of it
    the REST `ActiveController`. This controller is where the magic happens, and we're
    going to illustrate what it is all about in a moment.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s implement the actual class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: The only thing needed at this point is just the definition of the model class
    that the REST controller is going to manage and that's it.
  prefs: []
  type: TYPE_NORMAL
- en: '`yii\rest\ActiveController` is the controller that will deal with Active Records
    models, such as our `User` model. If you were to manage custom classes (non active
    records) that do not connect to a database or do connect to a custom data source
    (for instance, an online service), you can use the class that `ActiveController`
    is inheriting from, which is `yii\rest\Controller`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The beauty of `ActiveController` is that it provides already implemented actions
    that are available immediately, which are:'
  prefs: []
  type: TYPE_NORMAL
- en: '`index`, which is accessed via `GET` or `HEAD` and returns the list of the
    models and their (database-bound) attributes'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`view`, which is accessed via `GET` and `HEAD` and returns the details of a
    single model'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`create`, which can be accessed only via `POST` and lets you create a new model'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`update`, which is accessed via `PUT` or `PATCH` and does what it says on the
    tin'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`delete`, which is used to delete a model and can be invoked using `DELETE`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`OPTIONS`, which, lastly, you can invoke to see all the allowed HTTP methods'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the actions that you'll be able to implement yourself, you will be dealing
    with the raw models, which are rendered by default in XML and JSON (depending
    on the `Accept` header that was sent along with the request).
  prefs: []
  type: TYPE_NORMAL
- en: We know we'll need to modify the list of exposed endpoints, and we'll see how
    to do it in a moment.
  prefs: []
  type: TYPE_NORMAL
- en: Before getting there, there are a few other bits that need to be addressed first,
    in particular the access credentials, as we don't want anybody to access our endpoints
    without being authenticated.
  prefs: []
  type: TYPE_NORMAL
- en: Adding the access check and security layer
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You might already have asked yourself how to prevent non-authenticated users
    from using certain endpoints of your application. For instance, we might want
    to give a client access to the user endpoint only if it's authenticated and authorized.
  prefs: []
  type: TYPE_NORMAL
- en: The authorization and authentication happen at two different phases.
  prefs: []
  type: TYPE_NORMAL
- en: Authorization is done at controller level by simply overriding the `checkAccess()`
    method and performing the right checks, which might involve establishing if the
    user has been authenticated and if he/she is active, in case this flag exists
    in the user model.
  prefs: []
  type: TYPE_NORMAL
- en: 'In our case, we can simply add the following method to our controller:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: This means that if the user is a guest, we raise a `401` response.
  prefs: []
  type: TYPE_NORMAL
- en: 'Yii will automatically call the method on each request as we can see in the
    `actions()` method in its parent class, which is `\yii\rest\ActiveController`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: Instead, the authentication is done in a completely different way and varies
    depending on the implementation and level of security you want to implement in
    the application.
  prefs: []
  type: TYPE_NORMAL
- en: 'As far as it goes, in case you haven''t touched the argument in depth, you
    have different possibilities, which are:'
  prefs: []
  type: TYPE_NORMAL
- en: '**HTTP Basic Auth**: This is basically the same that you would have by using
    htpasswd and configuring Apache accordingly and is the simplest one available,
    but needs the username and password to be sent in a header with every request.
    This requires the communication to work over HTTPS for obvious reasons.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Query parameter**: Here, the client is already possessing an access token,
    which will be sent to the server as a query parameter as `https://server.com/users?access-token=xxxxxxx`,
    which is quite handy if you don''t have the ability to send additional tokens
    with the request.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There are some other ways that use a combination of different techniques and/or
    asymmetric and symmetric encryption or different types of handshakes to authenticate
    a client. One of the most well-known, although potentially complex, is **OAuth
    2**, which has different implementations as it's considered more of a framework
    than a well-defined protocol. Most of the well-known social websites such as Google,
    Twitter, Facebook, and so on implement it. Its Wikipedia page, available at [http://en.wikipedia.org/wiki/OAuth](http://en.wikipedia.org/wiki/OAuth),
    provides some good links and references to help you explore it further.
  prefs: []
  type: TYPE_NORMAL
- en: As encryption and authentication protocols are outside the scope of this book,
    I've decided to use the simplest solution, which will anyway give us enough hints
    on where to put our hands, should we want to implement something more robust or
    complex.
  prefs: []
  type: TYPE_NORMAL
- en: Building the authentication layer
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'As Yii uses sessions by default, which will violate the stateless constraints
    of a RESTful server according to the fielding dissertation ([http://www.ics.uci.edu/~fielding/pubs/dissertation/rest_arch_style.htm#sec_5_1_3](http://www.ics.uci.edu/~fielding/pubs/dissertation/rest_arch_style.htm#sec_5_1_3)),
    we will want to disable the session in the module''s `init()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: In Yii the actual authentication is then done via the available authenticator
    behavior.
  prefs: []
  type: TYPE_NORMAL
- en: 'Yii provides four different authenticators which are:'
  prefs: []
  type: TYPE_NORMAL
- en: '`HttpBasicAuth`: This is used for HTTP Basic Auth, which we will use here'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`QueryParamAuth`: This is used for query parameter authentication'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`HttpBearerAuth`: This is used for OAuth and similar methods'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`CompositeAuth`: This is a way to use multiple cascading authentication methods'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Again open our `UserController` and let''s define the one we want to use:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: If you were to run the tests against this implementation, you will have problems
    making them pass; the default implementation will use `findIdentityByAccessToken()`
    and use the `$username` part of the header as an access token. So, there's no
    real password check.
  prefs: []
  type: TYPE_NORMAL
- en: HTTP Basic Auth defines that, together with your request, you will also have
    to send an `Authorization` header containing `'Basic '.base64($username.':'.$password);`.
  prefs: []
  type: TYPE_NORMAL
- en: As explained in the documentation of the `HttpBasicAuth` class at [https://github.com/yiisoft/yii2/blob/master/framework/filters/auth/HttpBasicAuth.php#L55](https://github.com/yiisoft/yii2/blob/master/framework/filters/auth/HttpBasicAuth.php#L55),
    you need to override the `$auth` attribute in order to perform the password authentication
    in the way that you want.
  prefs: []
  type: TYPE_NORMAL
- en: 'As you saw, `findIdentityByAccessToken()` is not a method we''re going to need,
    and we have the unit tests that clearly state that. The best way to address this
    is by adding our authenticator method straight in the definition of the behavior
    in the following way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: As explained in the documentation, the `auth` attribute should be a function
    that expects `$username` and `$password` as actual parameters, and returns the
    user identity if the authentication is verified.
  prefs: []
  type: TYPE_NORMAL
- en: With this last method, implementation of our authentication and authorization
    scheme should be complete.
  prefs: []
  type: TYPE_NORMAL
- en: Modifying the existing actions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now that we''ve restricted access to any other user, we need to re-implement
    the view and update actions, in order to allow only the currently logged in user
    to view just his/her details and allow him to update only the password. If you
    have already started implementing the actions, this won''t be enough as the parent
    class, `yii\rest\Controller`, already implements all the default actions, so we
    need to redefine their configuration, which happens to be set within the `actions()`
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'Once we unset the two actions, our own overridden methods will be picked up
    automatically without much else to do:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'The view action just adds a check on the ID of the user and returns a 403 error,
    while the update action can be something along the lines of the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: In the update, we only allow changing of the password, after which we return
    the value of the `save` method. We could have returned a more comprehensive status,
    but for our cause, this is good enough.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We won't actually need to add the check if the request is not a PUT, as the
    current internal implementation restricts it by default. We'll see in [Chapter
    8](ch08.html "Chapter 8. Analyzing Testing Information"), *Analyzing Testing Information*,
    how this will be fixed, using the coverage report information.
  prefs: []
  type: TYPE_NORMAL
- en: Adding a new endpoint with parameters
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: With all we have done, if we try to run the tests on `UserAPICept`, we will
    see that it will fail immediately at the first `sendGET('user/search')command`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Implementing the new `actionSearch()` method won''t be a problem, and it can
    be implemented in the following way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: What is important to note is how we will customize the routes to add this new
    action in a "compliant" way.
  prefs: []
  type: TYPE_NORMAL
- en: 'Switch to the configuration file located at `config/web.php` and let''s start
    by adding the search action to the list of allowed methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: The `UrlRule` class that is used to create routes exposes some variables that
    you can configure, either to extend or entirely re-define the patterns and the
    structure of the tokens. The first are `extraPatterns` and `patterns` respectively.
    Tokens can be used in the patterns and represent the parameters passed to the
    action.
  prefs: []
  type: TYPE_NORMAL
- en: 'In Yii terminology, a pattern is a tuple composed of allowed HTTP method(s),
    the actual structure of the resource to identify, and the corresponding action
    to be called. The following is an example of this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'A token is one or more parameters that can be as complex as a regular expression.
    In the preceding example, `{username}` is a token and can be defined as shown
    in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'Our final list of rules will end up looking like the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: The first thing to note is that we had to re-define all the tokens rather than
    adding them as we are doing with `extraPatterns`.
  prefs: []
  type: TYPE_NORMAL
- en: In the list of rules, we have defined the REST interface rules before any other
    as rules are read top to bottom, and the first one that is found matching will
    be captured. This means that specific rules must stay at the top, while generic
    catch-all rules are at the bottom.
  prefs: []
  type: TYPE_NORMAL
- en: 'The preceding configuration will be fed to `urlManager`, as explained in the
    official guide at [http://www.yiiframework.com/doc-2.0/guide-runtime-routing.html#using-pretty-urls](http://www.yiiframework.com/doc-2.0/guide-runtime-routing.html#using-pretty-urls):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we can check that the tests are passing using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you saw many things such as how to write basic functional tests,
    how to test a REST interface, and the implementation side of things. Given the
    amount of knowledge condensed here, it might be useful for you to revisit the
    chapter later on and give yourself enough time to experiment on the single features
    in more detail and adapt them to your likings.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, you're going to see how to create acceptance tests for
    your interfaces that will overcome some of the limitations of working with PHPBrowser.
  prefs: []
  type: TYPE_NORMAL
