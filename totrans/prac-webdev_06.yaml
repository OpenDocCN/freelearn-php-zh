- en: Chapter 6. PHP and MySQL
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapter, we discussed PHP as a language for server-side programming.
    Its main use is to generate HTML dynamically to create web pages that are delivered
    to the client by the web server, as well as to store, retrieve, and manipulate
    data on the server. We have used files as the containers for that data, but we
    have given more than one hint that as soon as the amount of data becomes large
    and/or complex, we want to use a database instead.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
- en: In this final chapter of the first part of the book, we introduce MySQL, a database
    of choice for many who do web development. You may have heard of the LAMP stack.
    This is the M in **LAMP** (**Linux/Apache/MySQL/PHP**).
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
- en: Before diving into MySQL itself, and the way to interface with it in PHP (hence
    the title of this chapter), we would like to give you a casual introduction to
    databases in general.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
- en: Databases
  id: totrans-4
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A database is nothing more than a collection of data, usually organized in some
    structured way. We use databases everyday although we might not think of them
    as databases. Take a phone directory, for instance. It contains a lot of data.
    The data itself consists of names, addresses, and, of course, phone numbers, typically
    sorted by last name. This paper database has many disadvantages, though. Once
    it is printed, it will be incomplete and out of date. And if we want to look up
    the phone numbers of all the people that live in the same street, we would not
    know where to start. But it is a database, alright.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
- en: Relational databases
  id: totrans-6
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The term **relational databases** dates back to an article written in 1970 by
    Edgar Frank Codd, working at IBM at the time, called *A Relational Model of Data
    for Large Shared Data Banks*.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
- en: It presents a model that shows the relationships between the different elements
    of data and heavily uses tables. In each of those tables, there are several fields
    or columns that can contain data of various types (strings, numbers, dates, and
    so on). Entries in those tables are called **rows**, and the first column in each
    row is an index or primary key, a number, which is usually not changed after it
    has been created.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
- en: So there can be a table containing customer information. The index represents
    the customer ID, and all the other columns or fields are classical things, such
    as first name, last name, address, and so on. You can easily create other tables
    and choose what they can contain. Let's assume that we are going to sell books.
    We could have a table with book information, starting with a book ID, book title,
    author, category (fiction or non-fiction, or more categories), ISBN number, price,
    whether it is hardcover, softcover, or an eBook, and so on.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
- en: You could have a separate table for categories; one for authors too, and then,
    of course, a table for your order information. If you organize your data like
    this and use the customer, category, and book ID in your order information, you
    only need to change things in one place in your database when, for example, the
    customer changes address. The database you are going to learn about in this chapter
    works as we just described.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
- en: The workflow we are proposing is a two-step process. In the first step, we design
    how we want our tables to look and whether they should be part of a single database
    or several. Next, we are going to program our application, our website if you
    like, to use a database and its tables instead of a flat file.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
- en: 'To achieve all of this, you need to learn quite a few new things. It should
    not come as a surprise that one of those things is yet another programming language:
    **SQL**.'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
- en: SQL
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Many people believe that SQL stands for **Standard Query Language**, but actually
    it doesn't - it is just plain SQL. However, it is a language, and is some kind
    of a standard used to perform queries on a database. It is also one of those few
    programming languages that have been around for many years and is not going away
    soon. I started working with C when people thought of it as new, but even then
    it was developed ten years prior.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
- en: 'SQL is used to query a database and can be thought of as a command-line language,
    that is, things that are typed in a computer console. Here is an example:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Here is another example:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: If this reminds you of scenes from *The Streets of San Francisco*, or any other
    crime series of the seventies, you are absolutely right. What they were doing
    on these computer screens was looking up things in a database, and that was mostly
    the only thing computers were used for. In our example, `CRIMINALS` is the name
    of a table and the `SELECT` command is used to look up all records where (hence
    `WHERE`) a certain condition is met.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
- en: 'There is no need to learn the complete language: with just a few commands and
    condition clauses, we will have enough knowledge to create programs that can do
    the basic operations with a database, as soon as we have created our database(s)
    and tables. That set of basic operations is often referred to as **CRUD** (**Create,
    Read, Update**, **and Delete**). In SQL, we can handle this with just five commands:
    `SELECT`, `INSERT`, `CREATE`, `UPDATE`, and `DELETE`. To accommodate getting data
    to come out of two tables rather than just one, you will learn another useful
    SQL feature called `INNER JOIN`.'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
- en: To avoid repetition, we will teach the basics of these commands in the MySQL
    section.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
- en: MySQL
  id: totrans-22
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You do not have to be a mechanic to drive a car, but there has to be an engine
    under the hood or it will not move. To run an application that uses a database,
    there has to be a database engine under the hood. Database servers used to be
    dedicated computers; chances are Karl Malden and Michael Douglas used a database
    server in the TV series I mentioned earlier.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
- en: Today, database servers are usually software packages. Oracle Corporation specializes
    in database software; Microsoft has several SQL Server products. These packages
    can be installed on dedicated computers to function solely as a database server,
    but we can also install them on the same computer that acts as a Web Server, as
    well as on our own development system. The package we are going to use is called
    **MySQL**.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
- en: MySQL is open source, which means free, database server that was created by
    a Swedish company acquired by Sun Microsystems, which was in turn acquired by
    Oracle.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
- en: 'If you have installed a bundle such as **XAMPP** or **WAMPSERVER** ([wampserver.com](http://wampserver.com))
    for Windows, then you already have MySQL. If not, you can download it from [mysql.com](http://mysql.com).
    Installation is very straightforward. Afterwards, you may have to go in your computer
    settings to make sure that the MySQL server is fired up each time the system is
    started. Like UNIX systems, MySQL has the concept of users, and the most powerful
    is **root**. MySQL is installed without a password for root. You want to change
    that right away. You can do this with the `mysqladmin` command. For everything
    else, we will use a tool or program it ourselves. Here is the command to change
    the root password:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: phpMyAdmin
  id: totrans-28
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`phpMyAdmin` is an open source utility written in PHP to help you administer
    your MySQL database(s). You do not have to use it, as there are other options,
    but I made it part of my workflow to create users, databases, and tables, and
    even populate tables initially. This is the equivalent of the set of SQL statements
    that SQL buffs call **schema statements**.'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
- en: I also use `phpMyAdmin` to occasionally remove or change a table row. `phpMyAdmin`
    is part of XAMPP, so if you do not use XAMPP, you will have to download it first.
    It should be straightforward to use once you grasp the concepts that follow. In
    a worst case scenario, you can grab some articles off the Web. There is even an
    entire book on `phpMyAdmin` by Packt Publishing.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
- en: Creating databases
  id: totrans-31
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You could do everything with a single database and just add tables for each
    project. However, if your projects are sufficiently distinct and rather large,
    it is better to create a different database for each project. `phpMyAdmin` lets
    you do that without the need for SQL commands.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
- en: Creating and managing users
  id: totrans-33
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We already mentioned a root password. Root is a user that can do everything.
    When your program accesses the database, you do not want anybody to accidentally
    erase any data in a database. That is why we create other users in MySQL, with
    just enough CRUD privileges for your database. All you want to allow is to create,
    read, update, and delete (which is what CRUD stands for) records in a specific
    database. For that purpose, you create users, give them passwords, and assign
    privileges. Once again, thanks to `phpMyAdmin`, you still do not have to learn
    SQL commands.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
- en: Creating and managing database tables
  id: totrans-35
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Properly planning the tables that your database will contain is essential for
    success. It is best to first draft things on a piece of paper. Once you are close
    to what you want, you can create tables for your database using `phpMyAdmin`.
    You give the table a name, after specifying which database it belongs to, and
    start listing all the columns, or fields, their names, type, and possibly their
    maximum length, with the index as `primary key` first.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
- en: 'Once you have set that up, you can even start propagating those tables with
    data. For a bookstore webshop application, you can use the tool to enter the information
    on all the books you sell; the application itself will take care of adding customer
    data and order data to your database. `customers` and `orders` are of course candidates
    for tables. With `phpMyAdmin` you will always at least create the structure of
    your table, but it may be your web application that fills it with data. Here are
    two examples of tables: **books** and **authors**.'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
- en: 'The books table will have the following data:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating and managing database tables](img/3816_06_01.jpg)'
  id: totrans-39
  prefs: []
  type: TYPE_IMG
- en: 'The authors table will have the following data:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating and managing database tables](img/3816_06_02.jpg)'
  id: totrans-41
  prefs: []
  type: TYPE_IMG
- en: So, how do we get from the application to the database? This brings us back
    to PHP and the **mysqli** object.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
- en: MySQLi in PHP
  id: totrans-43
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Although we omitted this on purpose in [Chapter 5](ch05.html "Chapter 5. PHP"),
    *PHP*, PHP has features found in object-oriented programming languages. So, rather
    than write functions, you can instead create objects and write methods for them.
    This is exactly how the PHP programming interface to MySQL works: there is one
    dedicated object, *mysqli*, and a number of methods. With these methods, you can
    connect to a database, submit queries, fetch the result, and finally close the
    connection.'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
- en: Consider that we have a web application that is an online bookstore. The name
    of our database is `bookstore`, for which we created a user `bookuser`, with `book**4u`
    as the password. The database itself contains at a minimum the table's books and
    authors.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
- en: Let's write our first PHP program using MySQL now.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
- en: Connecting to the database
  id: totrans-47
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'First we need to connect to the database. To do so, we need to identify which
    database we want to connect to, on which host the database server is running,
    and which database user we want to use. The host will almost always be `localhost`.
    So, here is the beginning of our program:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: We probably want to call the statement that calls the connect method from a
    function so that we can add some intelligence to give the user meaningful information
    when, for some reason, the connection to the database fails.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
- en: The statement about the character set is extremely important. I am an I18N guy,
    so I will spare you the details; I will even spare you from explaining what I18N
    stands for. UTF-8 is a code set that covers how letters used in many different
    languages are translated into numbers. This line helps you confirm that data is
    stored the proper way in your database.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
- en: Next, when your data is retrieved and needs to be displayed on a screen it may
    have to be translated into another codeset. But this way, you at least know which
    way you are storing your own data.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
- en: Our first SQL query, really!
  id: totrans-53
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In plain SQL, the simplest query to get something back from a database, stored
    in our table `books`, would be:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'This is what `phpMyAdmin` will suggest as the default SQL query. It can even
    be shorter:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Notice that the query ends in a semicolon and that we do not mention the name
    of the database. We did that when we made the connection. All SQL keywords are
    in uppercase. Our `WHERE` clause is the simplest imaginable, as it is always true.
    We just added it to help us in the examples. The `*` tells the server to get me
    all columns. If you only want the title and the price, you would use:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Now we are going to translate this into a pair of PHP statements. Before you
    read on, I suggest (assuming that you have created a database and a books table
    and put some books in it) that you go into `phpMyAdmin`, select our database,
    click on the **SQL** tab, type in the above query, and examine the result.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
- en: Writing a MySQL query in PHP
  id: totrans-61
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Our first MySQL query in PHP is quite simple. We are going to turn the query
    into a PHP string and call the `query` method to get the result:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Fetching the result
  id: totrans-64
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now, if we typed in everything correctly—at first you may have mistakenly omitted
    one of the semicolons on either side of the closing single quote—MySQL will have
    returned the title and price of every single book in our table. It has done so
    by returning an object that we named `$result`, which we can apply a few methods
    to.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
- en: 'The simplest one will give us the number of rows that were found, the most
    powerful one being `fetch_assoc()`, which will create for us an associative array
    that we can instantly use in a while loop. So, here is how we can generate an
    HTML table with a list of all book titles and prices with just a few lines of
    code:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The keys of the associative array are simply the names of the columns in the
    table.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
- en: Obtaining data from more than one table
  id: totrans-69
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s assume we do not want the list of all books, but just those by a single
    author. We want all the books by John Muir, so here is the SQL:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Wait a minute! How can we tell which `author_id` John Muir has? We cannot.
    Of John Muir, we know the first and last name, and these are stored in the `authors`
    table. So here comes the most profoundly difficult query of the entire chapter:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Alternatively, we could also use:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Notice the subtle difference? We used `a` and `b` as a shorthand notation for
    authors and books. Because we chose our field names wisely, there are no identical
    names showing up in other tables. If that were the case, we would need to specify
    the table name followed by a dot, as we did in the second example. Otherwise,
    an error message complaining about ambiguity would occur.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
- en: The results of the query are all titles and prices of books where the `author_id`
    in the table books is the same as the `author_id` under `authors`, and in that
    one, it matches the ones with `aname` set to Muir and `afirst` set to John. Notice
    that it is possible to get results of two different John Muirs back with this
    query.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
- en: This is how you can obtain data out of several tables. There are nuances, such
    as `LEFT JOIN` and `RIGHT JOIN`, but they are beyond the scope of this book.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
- en: Adding data
  id: totrans-79
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We mentioned using `phpMyAdmin` to propagate our tables. Once our application
    is running, we need to know how to add a date using PHP code, for instance, to
    add an order to the system. We will provide an example that adds a book to the
    books table. All the strings we use can, of course, be replaced by PHP variables.
    The SQL command we need here is `INSERT`:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: This will automatically add a row to your table, create your primary key with
    a value one higher than all others, insert the title, `author_id`, and insert
    the price into that row. All other fields will get the default value you specified
    while building your tables with `phpMyAdmin`.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
- en: The `insert_id` function is quite handy if you want to retrieve the value of
    the newly created primary key. We will use this now to change the price from `38`
    to `39`.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
- en: Updating data
  id: totrans-84
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s assume that we want to change the price of a book or add information
    we did not enter when we issued the `INSERT` command to add data. This is where
    the `UPDATE` command is used. The syntax goes like this:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: This will change the price of the book we just added from `38` to `39`.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
- en: You can find a very comprehensive online manual of all the MySQL commands on
    [mysql.com](http://mysql.com), [php.net](http://php.net), and many other websites;
    just search on Google for `mysql UPDATE` and it will be right there. This is why
    we are only giving you the basics in this chapter.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-89
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we explained how to add a database to the overall web development
    picture. Our database engine of choice is MySQL, as it is open source, has a PHP
    programming interface, and is available on all platforms. We introduced another
    programming language, SQL, and then explained how this fits into the MySQL/PHP
    picture.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们解释了如何将数据库添加到整体网络开发图中。我们选择MySQL作为数据库引擎，因为它开源、具有PHP编程接口，并且可在所有平台上使用。我们介绍了另一种编程语言SQL，并解释了它如何与MySQL/PHP结合。
- en: To create and manage a database, including adding initial data to your tables,
    we talked about using `phpMyAdmin`, a great tool that we recommend adding to your
    workflow.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 为了创建和管理数据库，包括向您的表中添加初始数据，我们讨论了使用`phpMyAdmin`，这是一个我们推荐添加到您的工作流程中的优秀工具。
- en: 'This chapter also concludes the first part of this book, which covers what
    I call classical web development. We walked through all the classical components,
    languages in particular, that people have been using to develop websites, and
    simple web applications: HTML, CSS, JavaScript, PHP, and MySQL.'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 本章也总结了本书的第一部分，这部分内容涵盖了被我称为经典网络开发的内容。我们回顾了所有经典组件，特别是人们用来开发网站和简单网络应用的编程语言：HTML、CSS、JavaScript、PHP和MySQL。
- en: In the second part of the book, we will take it a step further and show you
    how to write shorter code, use a single web page instead of millions to get the
    job done, and write everything in a smarter, different way so that your site or
    app will look great on all devices, from desktop to tablet to smartphone.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书的第二部分，我们将更进一步，向您展示如何编写更短的代码，使用单个网页而不是数百万个网页来完成工作，并以更智能、不同的方式编写一切，以便您的网站或应用在所有设备上看起来都很棒，从桌面到平板电脑再到智能手机。
