- en: Chapter 7. Testing Web Applications
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第7章 测试Web应用程序
- en: We are pretty sure you have heard the term "bug" when speaking about applications.
    Sentences such as "We found a bug in the application that…" followed by some very
    undesirable behavior are more common than you think. Writing code is not the only
    task of a developer; testing it is crucial too. You should not release a version
    of your application that has not been tested. However, could you imagine having
    to test your entire application every time you change a line? It would be a nightmare!
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 当你谈论应用程序时，你很可能已经听说过“bug”这个词。像“我们在应用程序中发现了这样的bug，…”然后是一些非常不希望出现的行为这样的句子比你想象的要常见。编写代码并不是开发者的唯一任务；测试同样至关重要。你不应该发布未经测试的应用程序版本。然而，你能想象每次修改一行代码时都必须测试整个应用程序吗？那将是一场噩梦！
- en: 'Well, we are not the first ones to have this issue, so, luckily enough, developers
    have already found a pretty good solution to this problem. In fact, they found
    more than one solution, turning testing into a very hot topic of discussion. Even
    being a test developer has become quite a common role. In this chapter, we will
    introduce you to one of the approaches of testing your code: unit tests.'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 嗯，我们不是第一个遇到这个问题的人，所以幸运的是，开发者已经找到了一个相当好的解决方案来解决这个问题。事实上，他们找到了不止一个解决方案，使测试成为了一个非常热门的讨论话题。甚至测试开发者已经变成了一个相当常见的角色。在本章中，我们将向你介绍测试代码的一种方法：单元测试。
- en: 'In this chapter, you will learn about:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你将了解：
- en: How unit tests work
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 单元测试的工作原理
- en: Configuring PHPUnit to test your code
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 配置PHPUnit以测试你的代码
- en: Writing tests with assertions, data providers, and mocks
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用断言、数据提供者和模拟编写测试
- en: Good and bad practices when writing unit tests
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写单元测试时的好习惯和坏习惯
- en: The necessity for tests
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试的必要性
- en: When you work on a project, chances are that you are not the only developer
    who will work with this code. Even in the case where you are the only one who
    will ever change it, if you do this a few weeks after creating it, you will probably
    not remember all the places that this piece of code is affected. Okay, let's assume
    that you are the only developer and your memory is beyond limits; would you be
    able to verify that a change on a frequently used object, such as a request, will
    always work as expected? More importantly, would you like to do it every single
    time you make a tiny change?
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 当你在一个项目上工作时，你很可能不是唯一一个会使用这段代码的开发者。即使在你是唯一一个会修改它的案例中，如果你在创建它几周后进行修改，你很可能不会记得所有受这段代码影响的地方。好吧，让我们假设你是唯一一个开发者，你的记忆力是超乎常人的；你能否验证对常用对象（如请求）的更改始终按预期工作？更重要的是，你愿意每次进行微小更改时都这样做吗？
- en: Types of tests
  id: totrans-10
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 测试类型
- en: 'While writing your application, making changes to the existing code, or adding
    new features, it is very important to get good *feedback*. How do you know that
    the feedback you get is good enough? It should accomplish the AEIOU principles:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 当你在编写应用程序、修改现有代码或添加新功能时，获得良好的*反馈*非常重要。你怎么知道你得到的反馈是否足够好？它应该实现AEIOU原则：
- en: '**Automatic**: Getting the feedback should be as painless as possible. Getting
    it by running just one command is always preferable to having to test your application
    manually.'
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**自动化**: 获取反馈应该尽可能不痛苦。通过运行一条命令来获取反馈总是比手动测试应用程序更可取。'
- en: '**Extensive**: We should be able to cover as many use cases as possible, including
    edge cases that are difficult to foresee when writing code.'
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**广泛性**: 我们应该尽可能覆盖尽可能多的用例，包括在编写代码时难以预见的边缘情况。'
- en: '**Immediate**: You should get it as soon as possible. This means that the feedback
    that you get just after introducing a change is way better than the feedback that
    you get after your code is in production.'
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**即时性**: 你应该尽快得到它。这意味着你在引入更改后立即得到的反馈要比你的代码在生产环境中得到的反馈要好得多。'
- en: '**Open**: The results should be transparent, and also, the tests should give
    us insight to other developers as to how to integrate or operate with the code.'
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**开放性**: 结果应该是透明的，而且，测试应该让我们了解其他开发者如何集成或操作代码。'
- en: '**Useful**: It should answer questions such as "Will this change work?", "Will
    it break the application unexpectedly?", or "Is there any edge case that does
    not work properly?".'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**实用性**: 它应该回答诸如“这个更改会起作用吗？”、“它会不会意外地破坏应用程序？”或“有没有不正常工作的边缘情况？”等问题。'
- en: 'So, even though the concept is quite weird at the beginning, the best way to
    test your code is… with more code. Exactly! We will write code with the goal of
    testing the code of our application. Why? Well, it is the best way we know to
    satisfy all the AEIU principles, and it has the following advantages:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，尽管一开始这个概念相当奇怪，但测试你的代码的最佳方式是…用更多的代码。没错！我们将编写代码，目的是测试我们应用程序的代码。为什么？因为这是我们已知的最能满足所有AEIU原则的方法，并且它有以下优点：
- en: We can execute the tests by just running one command from our command line or
    even from our favorite IDE. There is no need to manually test your application
    via a browser continually.
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以通过在命令行或我们喜欢的IDE中运行一个命令来执行测试。没有必要不断地通过浏览器手动测试你的应用程序。
- en: We need to write the test just once. At the beginning, it may be a bit painful,
    but once the code is written, you will not need to repeat it again and again.
    This means that after some work, we will be able to test every single case effortlessly.
    If we had to test it manually, along with all the use cases and edge cases, it
    would be a nightmare.
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们只需要编写一次测试。一开始，可能会有些痛苦，但一旦代码编写完成，你就不需要反复重复它了。这意味着经过一些工作后，我们将能够轻松地测试每一个单独的情况。如果我们不得不手动测试，包括所有用例和边缘情况，那将是一场噩梦。
- en: 'You do not need to have the whole application working in order to know whether
    your code works. Imagine that you are writing your router: in order to know whether
    it works, you will have to wait until your application works in a browser. Instead,
    you can write your tests and run them as soon as you finish your class.'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你不需要整个应用程序都运行正常才能知道你的代码是否工作。想象一下你正在编写你的路由器：为了知道它是否工作，你必须等到你的应用程序在浏览器中工作。相反，你可以在完成课程后立即编写测试并运行它们。
- en: When writing your tests, you will be provided with feedback on what is failing.
    This is very useful to know when a specific function of the router does not work
    and the reason for the failure, which is better than getting a 500 error on our
    browser.
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在编写测试时，你将获得关于哪些测试失败的反馈。当路由器的特定功能不工作以及失败的原因时，这非常有用，这比在浏览器上收到500错误要好得多。
- en: 'We hope that by now we have sold you on the idea that writing tests is indispensable.
    This was the easy part, though. The problem is that we know several different
    approaches. Do we write tests that test the entire application or tests that test
    specific parts? Do we isolate the tested area from the rest? Do we want to interact
    with the database or with other external resources while testing? Depending on
    your answers, you will decide on which type of tests you want to write. Let''s
    discuss the three main approaches that developers agree with:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望到现在你已经接受了编写测试是不可或缺的想法。虽然这很简单，但问题是我们知道几种不同的方法。我们是编写测试来测试整个应用程序，还是测试特定部分？我们在测试时是否要隔离测试区域？我们是否希望在测试时与数据库或其他外部资源交互？根据你的回答，你将决定你想编写哪种类型的测试。让我们讨论开发者一致同意的三个主要方法：
- en: '**Unit tests**: These are tests that have a very focused scope. Their aim is
    to test a single class or method, isolating them from the rest of code. Take your
    `Sale` domain class as an example: it has some logic regarding the addition of
    books, right? A unit test might just instantiate a new sale, add books to the
    object, and verify that the array of books is valid. Unit tests are super fast
    due to their reduced scope, so you can have several different scenarios of the
    same functionality easily, covering all the edge cases you can imagine. They are
    also isolated, which means that we will not care too much about how all the pieces
    of our application are integrated. Instead, we will make sure that each piece
    works perfectly fine.'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**单元测试**：这些测试具有非常集中的范围。它们的目的是测试单个类或方法，将它们从其他代码中隔离出来。以你的`Sale`域类为例：它有关书籍添加的一些逻辑，对吧？一个单元测试可能只是实例化一个新的销售，向对象添加书籍，并验证书籍数组是否有效。由于它们的范围缩小，单元测试非常快，因此你可以轻松地拥有几个不同功能的不同场景，覆盖你所能想象的所有边缘情况。它们也是隔离的，这意味着我们不会太关心我们应用程序的所有部分是如何集成的。相反，我们将确保每个部分都工作得非常好。'
- en: '**Integration tests**: These are tests with a wider scope. Their aim is to
    verify that all the pieces of your application work together, so their scope is
    not limited to a class or function but rather includes a set of classes or the
    whole application. There is still some isolation in case we do not want to use
    a real database or depend on some other external web service. An example in our
    application would be to simulate a `Request` object, send it to the router, and
    verify that the response is as expected.'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**集成测试**：这些测试的范围更广。它们的目的是验证你的应用程序的所有部件是否能够协同工作，因此它们的范围不仅限于一个类或函数，而是包括一组类或整个应用程序。如果我们不想使用真实的数据库或依赖其他外部Web服务，仍然有一些隔离。在我们应用程序中的一个例子是模拟一个`Request`对象，将其发送到路由器，并验证响应是否符合预期。'
- en: '**Acceptance tests**: These are tests with an even wider scope. They try to
    test a whole functionality from the user''s point of view. In web applications,
    this means that we can launch a browser and simulate the clicks that the user
    would make, asserting the response in the browser each time. And yes, all of this
    through code! These tests are slower to run, as you can imagine, because their
    scope is larger and working with a browser slows them down quite a lot too.'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**验收测试**：这些测试的范围更广。它们试图从用户的角度测试整个功能。在Web应用程序中，这意味着我们可以启动一个浏览器并模拟用户会进行的点击，每次都在浏览器中断言响应。是的，所有这些都可以通过代码来实现！正如你所想象的那样，这些测试运行起来较慢，因为它们的范围更广，而且与浏览器一起工作也会使它们变慢很多。'
- en: 'So, with all these types of tests, which one should you write? The answer is
    all of them. The trick is to know when and how many of each type you should write.
    One good approach is to write a lot of unit tests, covering absolutely everything
    in your code, then writing fewer integration tests to make sure that all the components
    of your application work together, and finally writing acceptance tests but testing
    only the main flows of your application. The following test pyramid represents
    this idea:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，有了所有这些测试类型，你应该编写哪一个呢？答案是全部都要。技巧在于知道何时以及每种类型应该编写多少。一种好的方法是编写大量的单元测试，覆盖你代码中的所有内容，然后编写较少的集成测试来确保你的应用程序的所有组件都能协同工作，最后编写验收测试，但只测试应用程序的主要流程。以下测试金字塔图展示了这个想法：
- en: '![Types of tests](img/00029.jpeg)'
  id: totrans-27
  prefs: []
  type: TYPE_IMG
  zh: '![测试类型](img/00029.jpeg)'
- en: 'The reason is simple: your real feedback will come from your unit tests. They
    will tell you if you messed up something with your changes as soon as you finish
    writing them because executing unit tests is easy and fast. Once you know that
    all your classes and functions behave as expected, you need to verify that they
    can work together. However, for this, you do not need to test all the edge cases
    again; you already did this when writing unit tests. Here, you need to write just
    a few integration tests that confirm that all the pieces communicate properly.
    Finally, to make sure that not only that the code works but also the user experience
    is the desired one, we will write acceptance tests that emulate a user going through
    the different views. Here, tests are very slow and only possible once the flow
    is complete, so the feedback comes later. We will add acceptance tests to make
    sure that the main flows work, but we do not need to test every single scenario
    as we already did this with integration and unit tests.'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 原因很简单：你真正的反馈将来自你的单元测试。一旦你完成编写，它们就会告诉你是否因为你的更改而搞错了什么，因为执行单元测试既简单又快捷。一旦你知道所有你的类和函数都按预期工作，你需要验证它们能否协同工作。然而，为此，你不需要再次测试所有边缘情况；你已经在编写单元测试时这样做过了。在这里，你需要编写仅几个集成测试来确认所有部件都能正确通信。最后，为了确保代码不仅能够工作，用户体验也是预期的，我们将编写验收测试来模拟用户遍历不同的视图。在这里，测试非常慢，并且只有在流程完成之后才可能进行，因此反馈来得较晚。我们将添加验收测试以确保主要流程正常工作，但不需要像集成和单元测试那样测试每一个单独的场景。
- en: Unit tests and code coverage
  id: totrans-29
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 单元测试和代码覆盖率
- en: Now that you know what tests are, why we need them, and which types of tests
    we have, we will focus the rest of the chapter on writing good unit tests as they
    will be the ones that will occupy most of your time.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经知道了什么是测试，为什么我们需要它们，以及我们有哪几种测试类型，我们将把本章的剩余部分集中在编写好的单元测试上，因为它们将是占据你大部分时间的测试。
- en: As we explained before, the idea of a unit test is to make sure that a piece
    of code, usually a class or method, works as expected. As the amount of code that
    a method contains should be small, running the test should take almost no time.
    Taking advantage of this, we will run several tests, trying to cover as many use
    cases as possible.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们之前解释的，单元测试的想法是确保一段代码（通常是一个类或方法）按预期工作。由于一个方法包含的代码量应该很小，运行测试应该几乎不需要时间。利用这一点，我们将运行多个测试，试图覆盖尽可能多的用例。
- en: If this is not the first time you've heard about unit tests, you might know
    the concept of **code coverage**. This concept refers to the amount of code that
    our tests execute, that is, the percentage of tested code. For example, if your
    application has 10,000 lines and your tests test a total of 7,500 lines, your
    code coverage is 75%. There are tools that show marks on your code to indicate
    whether a certain line is tested or not, which is very useful in order to identify
    which parts of your application are not tested and thus warn you that it is more
    dangerous to change them.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你不是第一次听说单元测试，你可能知道**代码覆盖率**的概念。这个概念指的是我们的测试执行的代码量，即测试代码的百分比。例如，如果你的应用程序有10,000行代码，而你的测试总共测试了7,500行代码，那么你的代码覆盖率是75%。有一些工具会在你的代码上显示标记，以指示某一行是否被测试，这在确定你的应用程序哪些部分没有被测试以及警告你更改它们可能更危险时非常有用。
- en: However, code coverage is a double-edge sword. Why is this so? This is because
    developers tend to get obsessed with code coverage, aiming for a 100% coverage.
    However, you should be aware that code coverage is just a consequence, not your
    goal. Your goal is to write unit tests that verify all the use cases of certain
    pieces of code in order to make you feel safer each time that you have to change
    this code. This means that for a given method, it might not be enough to write
    one test because the same line with different input values may behave differently.
    However, if your focus was on code coverage, writing one test would satisfy it,
    and you might not need to write any more tests.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，代码覆盖率是一把双刃剑。为什么是这样呢？这是因为开发者往往会沉迷于代码覆盖率，目标是达到100%的覆盖率。然而，你应该意识到代码覆盖率只是一个结果，而不是你的目标。你的目标是编写单元测试，以验证某些代码片段的所有用例，以便每次你不得不更改此代码时都让你感到更安全。这意味着对于给定的方法，可能只写一个测试是不够的，因为相同的行在不同的输入值下可能表现不同。然而，如果你的重点是代码覆盖率，写一个测试就会满足它，你可能不需要再写更多的测试。
- en: Integrating PHPUnit
  id: totrans-34
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 集成PHPUnit
- en: Writing tests is a task that you could do by yourself; you just need to write
    code that throws exceptions when conditions are not met and then run the script
    any time you need. Luckily, other developers were not satisfied with this manual
    process, so they implemented tools to help us automate this process and get good
    feedback. The most used in PHP is **PHPUnit**. PHPUnit is a framework that provides
    a set of tools to write tests in an easier manner, gives us the ability to run
    tests automatically, and delivers useful feedback to the developer.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 编写测试是一个你可以自己完成的任务；你只需要编写当条件不满足时抛出异常的代码，然后在你需要的时候运行脚本。幸运的是，其他开发者对这种手动过程并不满意，所以他们实现了工具来帮助我们自动化这个过程并获得良好的反馈。在PHP中最常用的工具是**PHPUnit**。PHPUnit是一个框架，它提供了一套工具，使我们能够以更简单的方式编写测试，能够自动运行测试，并向开发者提供有用的反馈。
- en: 'In order to use PHPUnit, traditionally, we installed it on our laptop. In doing
    so, we added the classes of the framework to include the path of PHP and also
    the executable to run the tests. This was less than ideal as we forced developers
    to install one more tool on their development machine. Nowadays, Composer (refer
    to [Chapter 6](part0056_split_000.html#1LCVG1-edcc22b134104d5db0bf3aa086c86851
    "Chapter 6. Adapting to MVC"), *Adapting to MVC*, in order to refresh your memory)
    helps us in including PHPUnit as a dependency of the project. This means that
    running Composer, which you will do for sure in order to get the rest of the dependencies,
    will get PHPUnit too. Add, then, the following into `composer.json`:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使用PHPUnit，传统上，我们在我们的笔记本电脑上安装它。这样做，我们将框架的类添加到包含PHP路径的路径中，并将可执行文件添加到运行测试的路径中。这并不理想，因为我们强迫开发者在他们的发展机器上安装一个额外的工具。如今，Composer（参考[第6章](part0056_split_000.html#1LCVG1-edcc22b134104d5db0bf3aa086c86851
    "第6章。适应MVC")，*适应MVC*，以刷新你的记忆）帮助我们包括PHPUnit作为项目的依赖项。这意味着运行Composer（你肯定会这样做，以获取其余的依赖项），也会得到PHPUnit。然后，将以下内容添加到`composer.json`中：
- en: '[PRE0]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Note that this dependency is added as `require-dev`. This means that the dependency
    will be downloaded only when we are on a development environment, but it will
    not be part of the application that we will deploy on production as we do not
    need to run tests there. To get the dependency, as always, run `composer update`.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，这个依赖项是以`require-dev`的方式添加的。这意味着只有在开发环境中，我们才会下载这个依赖项，但在我们部署到生产环境的应用程序中，它不会成为一部分，因为我们不需要在那里运行测试。要获取依赖项，像往常一样，运行`composer
    update`。
- en: A different approach is to install PHPUnit globally so that all the projects
    on your development environment can use it instead of installing it locally each
    time. You can read about how to install tools globally with Composer at [https://akrabat.com/global-installation-of-php-tools-with-composer/](https://akrabat.com/global-installation-of-php-tools-with-composer/).
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种方法是全局安装PHPUnit，这样你开发环境中的所有项目都可以使用它，而不是每次都本地安装。你可以在[https://akrabat.com/global-installation-of-php-tools-with-composer/](https://akrabat.com/global-installation-of-php-tools-with-composer/)上阅读有关如何使用Composer全局安装工具的说明。
- en: The phpunit.xml file
  id: totrans-40
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: phpunit.xml文件
- en: 'PHPUnit needs a `phpunit.xml` file in order to define the way we want to run
    the tests. This file defines a set of rules like where the tests are, what code
    are the tests testing, and so on. Add the following file in your root directory:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: PHPUnit需要一个`phpunit.xml`文件来定义我们想要运行测试的方式。这个文件定义了一系列规则，比如测试在哪里，测试在测试什么代码，等等。在你的根目录中添加以下文件：
- en: '[PRE1]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'This file defines quite a lot of things. The most important are explained as
    follows:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 这个文件定义了很多东西。以下是最重要的解释：
- en: Setting `convertErrorsToExceptions`, `convertNoticesToExceptions`, and `convertWarningsToExceptions`
    to `true` will make your tests fail if there is a PHP error, warning, or notice.
    The goal is to make sure that your code does not contain minor errors on edge
    cases, which are always the source of potential problems.
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将`convertErrorsToExceptions`、`convertNoticesToExceptions`和`convertWarningsToExceptions`设置为`true`会使你的测试在出现PHP错误、警告或通知时失败。目标是确保你的代码在边缘情况下不包含小错误，这些错误总是潜在问题的来源。
- en: The `stopOnFailure` tells PHPUnit whether it should continue executing the rest
    of tests or not when there is a failed test. In this case, we want to run all
    of them to know how many tests are failing and why.
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`stopOnFailure`告诉PHPUnit在出现失败的测试时是否应该继续执行剩余的测试。在这种情况下，我们希望运行所有测试，以了解有多少测试失败以及为什么。'
- en: The `bootstrap` defines which file we should execute before starting to run
    the tests. The most common usage is to include the autoloader, but you could also
    include a file that initializes some dependencies, such as databases or configuration
    readers.
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`bootstrap`定义了在开始运行测试之前我们应该执行哪个文件。最常见的使用方法是包含自动加载器，但你也可以包含一个初始化一些依赖项的文件，例如数据库或配置读取器。'
- en: The `testsuites` defines the directories where PHPUnit will look for tests.
    In our case, we defined `./tests`, but we could add more if we had them in different
    directories.
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`testsuites` 定义了PHPUnit将查找测试的目录。在我们的例子中，我们定义了`./tests`，如果我们有其他目录的话，我们还可以添加更多。'
- en: The `whitelist` defines the list of directories that contain the code that we
    are testing. This can be useful to generate output related to the code coverage.
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`whitelist`定义了包含我们正在测试的代码的目录列表。这可以用来生成与代码覆盖率相关的输出。'
- en: When running the tests with PHPUnit, just make sure that you run the command
    from the same directory where the `phpunit.xml` file is. We will show you how
    in the next section.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用PHPUnit运行测试时，只需确保你从`phpunit.xml`文件所在的目录运行命令。我们将在下一节中向你展示如何操作。
- en: Your first test
  id: totrans-50
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 你的第一个测试
- en: 'Right, that''s enough preparations and theory; let''s write some code. We will
    write tests for the basic customer, which is a domain object with little logic.
    First of all, we need to refactor the `Unique` trait as it still contains some
    unnecessary code after integrating our application with MySQL. We are talking
    about the ability to assign the next available ID, which is now handled by the
    autoincremental field. Remove it, leaving the code as follows:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，准备工作和技术理论就到这里；让我们写一些代码。我们将为基本的客户编写测试，这是一个具有少量逻辑的领域对象。首先，我们需要重构`Unique`特质，因为它在将我们的应用程序与MySQL集成后仍然包含一些不必要的代码。我们谈论的是分配下一个可用ID的能力，现在这由自增字段处理。移除它，代码如下：
- en: '[PRE2]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The tests will be inside the `tests/` directory. The structure of directories
    should be the same as in the `src/` directory so that it is easier to identify
    where each test should be. The file and the class names need to end with `Test`
    so that PHPUnit knows that a file contains tests. Knowing this, our test should
    be in `tests/Domain/Customer/BasicTest.php`, as follows:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 测试将位于 `tests/` 目录中。目录结构应该与 `src/` 目录中的结构相同，这样更容易识别每个测试应该在哪里。文件和类名需要以 `Test`
    结尾，这样 PHPUnit 才知道一个文件包含测试。了解这一点后，我们的测试应该在 `tests/Domain/Customer/BasicTest.php`
    中，如下所示：
- en: '[PRE3]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: As you can note, the `BasicTest` class extends from `PHPUnit_Framework_TestCase`.
    All test classes have to extend from this class. This class comes with a set of
    methods that allow you to make assertions. An assertion in PHPUnit is just a check
    performed on a value. Assertions can be comparisons to other values, a verification
    of some attributes of the values, and so on. If an assertion is not true, the
    test will be marked as failed, outputting the proper error message to the developer.
    The example shows an assertion using the `assertSame` method, which will compare
    two values, expecting that both of them are exactly the same. The third argument
    is an error message that the assertion will show in case it fails.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所注意到的，`BasicTest` 类继承自 `PHPUnit_Framework_TestCase`。所有测试类都必须从这个类继承。这个类提供了一套方法，允许你进行断言。在
    PHPUnit 中，断言只是对一个值进行的检查。断言可以是与其他值的比较，对值的某些属性的验证，等等。如果断言不成立，测试将被标记为失败，并向开发者输出适当的错误消息。示例显示了使用
    `assertSame` 方法的断言，它将比较两个值，期望它们完全相同。第三个参数是断言失败时将显示的错误消息。
- en: Also, note that the function names that start with `test` are the ones executed
    with PHPUnit. In this example, we have one unique test named `testAmountToBorrow`
    that instantiates a basic customer and verifies that the amount of books that
    the customer can borrow is 3\. In the next section, we will show you how to run
    this test and get feedback from it.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，请注意，以 `test` 开头的函数名是使用 PHPUnit 执行的。在这个例子中，我们有一个唯一的测试名为 `testAmountToBorrow`，它实例化了一个基本客户并验证客户可以借阅的书籍数量为
    3。在下一节中，我们将向您展示如何运行此测试并从中获取反馈。
- en: 'Optionally, you could use any function name if you add the `@test` annotation
    in the method''s DocBlock, as follows:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 可选地，如果你在方法的 DocBlock 中添加了 `@test` 注解，可以使用任何函数名，如下所示：
- en: '[PRE4]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Running tests
  id: totrans-59
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 运行测试
- en: In order to run the tests you wrote, you need to execute the script that Composer
    generated in `vendor/bin`. Remember always to run from the root directory of the
    project so that PHPUnit can find your `phpunit.xml` configuration file. Then,
    type `./vendor/bin/phpunit`.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 为了运行你编写的测试，你需要执行 Composer 生成的 `vendor/bin` 中的脚本。请记住，始终从项目的根目录运行，以便 PHPUnit 可以找到你的
    `phpunit.xml` 配置文件。然后，输入 `./vendor/bin/phpunit`。
- en: '![Running tests](img/00030.jpeg)'
  id: totrans-61
  prefs: []
  type: TYPE_IMG
  zh: '![运行测试](img/00030.jpeg)'
- en: 'When executing this program, we will get the feedback given by the tests. The
    output shows us that there is one test (one method) and one assertion and whether
    these were satisfactory. This output is what you would like to see every time
    you run your tests, but you will get more failed tests than you would like. Let''s
    take a look at them by adding the following test:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 当执行此程序时，我们将得到测试给出的反馈。输出显示我们有一个测试（一个方法）和一个断言，以及这些是否令人满意。这正是你每次运行测试时希望看到的结果，但你可能会得到比预期更多的失败测试。让我们通过添加以下测试来查看它们：
- en: '[PRE5]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: This test will fail as we are checking whether `getAmountToBorrow` returns 4,
    but you know that it always returns 3\. Let's run the tests and take a look at
    what kind of output we get.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 此测试将失败，因为我们正在检查 `getAmountToBorrow` 是否返回 4，但你知道它总是返回 3。让我们运行测试并查看我们得到什么样的输出。
- en: '![Running tests](img/00031.jpeg)'
  id: totrans-65
  prefs: []
  type: TYPE_IMG
  zh: '![运行测试](img/00031.jpeg)'
- en: We can quickly note that the output is not good due to the red color. It shows
    us that there is a failure, pointing to the class and test method that failed.
    The feedback points out the type of failure (as 3 is not identical to 4) and optionally,
    the error message we added when invoking the `assert` method.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以快速注意到输出不好，因为红色。它显示我们有一个失败，指向失败的类和测试方法。反馈指出失败类型（因为 3 不等于 4）以及可选的错误消息，我们在调用
    `assert` 方法时添加了它。
- en: Writing unit tests
  id: totrans-67
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编写单元测试
- en: 'Let''s start digging into all the features that PHPUnit offers us in order
    to write tests. We will divide these features in different subsections: setting
    up a test, assertions, exceptions, and data providers. Of course, you do not need
    to use all of these tools each time you write a test.'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始深入了解PHPUnit为我们提供的所有功能，以便编写测试。我们将将这些功能分为不同的子部分：设置测试、断言、异常和数据提供者。当然，您不需要在每次编写测试时都使用所有这些工具。
- en: The start and end of a test
  id: totrans-69
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 测试的开始和结束
- en: 'PHPUnit gives you the opportunity to set up a common scenario for each test
    in a class. For this, you need to use the `setUp` method, which, if present, is
    executed each time that a test of this class is executed. The instance of the
    class that invokes the `setUp` and `test` methods is the same, so you can use
    the properties of the class to save the context. One common use would be to create
    the object that we will use for our tests in case this is always the same. For
    an example, write the following code in `tests/Domain/Customer/BasicTest.php`:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: PHPUnit为您提供了在每个类中的测试中设置共同场景的机会。为此，您需要使用`setUp`方法，如果存在，则每次执行此类测试时都会执行。调用`setUp`和`test`方法的类实例是相同的，因此您可以使用类的属性来保存上下文。一个常见的用途是创建我们将用于测试的对象，如果这个对象始终相同的话。例如，在`tests/Domain/Customer/BasicTest.php`中编写以下代码：
- en: '[PRE6]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: When `testAmountToBorrow` is invoked, the `$customer` property is already initialized
    through the execution of the `setUp` method. If the class had more than one test,
    the `setUp` method would be executed each time.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 当调用`testAmountToBorrow`时，`$customer`属性已经通过`setUp`方法的执行而初始化。如果类中有多个测试，`setUp`方法会在每次测试时执行。
- en: 'Even though it is less common to use, there is another method used to clean
    up the scenario after the test is executed: `tearDown`. This works in the same
    way, but it is executed after each test of this class is executed. Possible uses
    would be to clean up database data, close connections, delete files, and so on.'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管使用较少，但在测试执行后清理场景的另一种方法是`tearDown`。它的工作方式相同，但会在执行此类的每个测试之后执行。可能的用途包括清理数据库数据、关闭连接、删除文件等。
- en: Assertions
  id: totrans-74
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 断言
- en: You have already been introduced to the concept of assertions, so let's just
    list the most common ones in this section. For the full list, we recommend you
    to visit the official documentation at [https://phpunit.de/manual/current/en/appendixes.assertions.html](https://phpunit.de/manual/current/en/appendixes.assertions.html)
    as it is quite extensive; however, to be honest, you will probably not use many
    of them.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 您已经了解了断言的概念，所以让我们只列出本节中最常见的断言。对于完整的列表，我们建议您访问官方文档[https://phpunit.de/manual/current/en/appendixes.assertions.html](https://phpunit.de/manual/current/en/appendixes.assertions.html)，因为它相当详尽；然而，说实话，您可能不会使用其中很多。
- en: 'The first type of assertion that we will see is the Boolean assertion, that
    is, the one that checks whether a value is `true` or `false`. The methods are
    as simple as `assertTrue` and `assertFalse`, and they expect one parameter, which
    is the value to assert, and optionally, a text to display in case of failure.
    In the same `BasicTest` class, add the following test:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将看到的第一个断言类型是布尔断言，即检查一个值是`true`还是`false`。这些方法非常简单，如`assertTrue`和`assertFalse`，它们期望一个参数，即要断言的值，以及可选的失败时显示的文本。在同一个`BasicTest`类中，添加以下测试：
- en: '[PRE7]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'This test makes sure that a basic customer is never exempt of taxes. Note that
    we could do the same assertion by writing the following:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 此测试确保基本客户永远不会免税。注意，我们可以通过以下方式执行相同的断言：
- en: '[PRE8]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'A second group of assertions would be the comparison assertions. The most famous
    ones are `assertSame` and `assertEquals`. You have already used the first one,
    but are you sure of its meaning? Let''s add another test and run it:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 另一组断言将是比较断言。最著名的是`assertSame`和`assertEquals`。您已经使用了第一个，但您确定其含义吗？让我们添加另一个测试并运行它：
- en: '[PRE9]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The result of the test is shown in the following screenshot:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 测试的结果显示在以下屏幕截图中：
- en: '![Assertions](img/00032.jpeg)'
  id: totrans-83
  prefs: []
  type: TYPE_IMG
  zh: '![断言](img/00032.jpeg)'
- en: The test failed! The reason is that `assertSame` is the equivalent to comparing
    using identity, that is, without using type juggling. The result of the `getMonthlyFee`
    method is always a float, and we will compare it with an integer, so it will never
    be the same, as the error message tells us. Change the assertion to `assertEquals`,
    which compares using equality, and the test will pass now.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 测试失败了！原因是`assertSame`等同于使用身份比较，即不使用类型转换。`getMonthlyFee`方法的结果始终是浮点数，我们将它与一个整数进行比较，所以它永远不会相同，正如错误信息所告诉我们的。将断言更改为`assertEquals`，它使用相等性进行比较，这样测试就会通过。
- en: 'When working with objects, we can use an assertion to check whether a given
    object is an instance of the expected class or not. When doing so, remember to
    send the full name of the class as this is a quite common mistake. Even better,
    you could get the class name using `::class`, for example, `Basic::class`. Add
    the following test in `tests/Domain/Customer/CustomerFactoryTest.php`:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 当与对象一起工作时，我们可以使用断言来检查给定的对象是否是预期类的实例。在这样做的时候，请记住发送类的全名，因为这是一个相当常见的错误。更好的是，你可以使用`::class`获取类名，例如，`Basic::class`。在`tests/Domain/Customer/CustomerFactoryTest.php`中添加以下测试：
- en: '[PRE10]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'This test creates a customer using the `customer` factory. As the type of customer
    was `basic`, the result should be an instance of `Basic`, which is what we are
    testing with `assertInstanceOf`. The first argument is the expected class, the
    second is the object that we are testing, and the third is the error message.
    This test also helps us to note the behavior of comparison assertions with objects.
    Let''s create a basic `customer` object as expected and compare it with the result
    of the factory. Then, run the test, as follows:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 此测试使用`customer`工厂创建客户。由于客户类型是`basic`，结果应该是一个`Basic`实例，这是我们使用`assertInstanceOf`进行测试的。第一个参数是预期的类，第二个参数是我们正在测试的对象，第三个参数是错误信息。此测试还帮助我们注意比较断言与对象的行为。让我们创建一个预期的基本`customer`对象，并将其与工厂的结果进行比较。然后，按照以下方式运行测试：
- en: '[PRE11]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The result of this test is shown in the following screenshot:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 此测试的结果如下所示：
- en: '![Assertions](img/00033.jpeg)'
  id: totrans-90
  prefs: []
  type: TYPE_IMG
  zh: '![断言](img/00033.jpeg)'
- en: 'The test failed because when you compare two objects with identity comparison,
    you comparing the object reference, and it will only be the same if the two objects
    are exactly the same instance. If you create two objects with the same properties,
    they will be equal but never identical. To fix the test, change the assertion
    as follows:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 测试失败是因为当你使用身份比较来比较两个对象时，你实际上是在比较对象引用，只有当两个对象是完全相同的实例时，它们才会相同。如果你创建了具有相同属性的两个对象，它们将是相等的，但永远不会相同。为了修复测试，请按以下方式更改断言：
- en: '[PRE12]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Let''s now write the tests for the `sale` domain object at `tests/Domain/SaleTest.php`.
    This class is very easy to test and allows us to use some new assertions, as follows:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来编写`sale`域对象的测试，在`tests/Domain/SaleTest.php`。这个类非常容易测试，并允许我们使用一些新的断言，如下所示：
- en: '[PRE13]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'We added two tests here: one makes sure that for a new `sale` instance, the
    list of books associated with it is empty. For this, we used the `assertEmpty`
    method, which takes an array as an argument and will assert that it is empty.
    The second test is adding a book to the sale and then making sure that the list
    of books has the correct content. For this, we will use the `assertCount` method,
    which verifies that the array, that is, the second argument, has as many elements
    as the first argument provided. In this case, we expect that the list of books
    has only one entry. The second assertion of this test is verifying that the array
    of books contains a specific key, which is the ID of the book, with the `assertArrayHasKey`
    method, in which the first argument is the key, and the second one is the array.
    Finally, we will check with the already known `assertSame` method that the amount
    of books inserted is 1.'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里添加了两个测试：一个确保对于一个新的`sale`实例，与之关联的书籍列表为空。为此，我们使用了`assertEmpty`方法，它接受一个数组作为参数，并断言它是空的。第二个测试是在销售中添加一本书，然后确保书籍列表具有正确的内容。为此，我们将使用`assertCount`方法，它验证数组（即第二个参数）具有与提供的第一个参数一样多的元素。在这种情况下，我们期望书籍列表只有一个条目。此测试的第二个断言是使用`assertArrayHasKey`方法验证书籍数组是否包含一个特定的键，即书籍的ID。在`assertArrayHasKey`方法中，第一个参数是键，第二个参数是数组。最后，我们将使用已知的`assertSame`方法检查插入的书籍数量是否为1。
- en: 'Even though these two new assertion methods are useful sometimes, all the three
    assertions of the last test can be replaced by just an `assertSame` method, comparing
    the whole array of books with the expected one, as follows:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管这两个新的断言方法有时很有用，但最后一个测试的所有三个断言都可以用一个 `assertSame` 方法来替换，比较整个书籍数组与期望的一个，如下所示：
- en: '[PRE14]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The suite of tests for the `sale` domain object would not be enough if we were
    not testing how the class behaves when adding multiple books. In this case, using
    `assertCount` and `assertArrayHasKey` would make the test unnecessarily long,
    so let''s just compare the array with an expected one via the following code:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们不测试类在添加多本书时的行为，那么 `sale` 领域对象的测试套件将是不够的。在这种情况下，使用 `assertCount` 和 `assertArrayHasKey`
    会使测试变得不必要地长，所以让我们通过以下代码比较数组与期望的一个：
- en: '[PRE15]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Expecting exceptions
  id: totrans-100
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 预期异常
- en: 'Sometimes, a method is expected to throw an exception for certain unexpected
    use cases. When this happens, you could try to capture this exception inside the
    test or take advantage of another tool that PHPUnit offers: **expecting exceptions**.
    To mark a test to expect a given exception, just add the `@expectedException`
    annotation followed by the exception''s class full name. Optionally, you can use
    `@expectedExceptionMessage` to assert the message of the exception. Let''s add
    the following tests to our `CustomerFactoryTest` class:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候，一个方法预期会在某些意外的使用情况下抛出异常。当这种情况发生时，你可以在测试中捕获这个异常，或者利用 PHPUnit 提供的另一个工具：**预期异常**。为了标记一个测试期望一个特定的异常，只需添加
    `@expectedException` 注解，后跟异常的全名。可选地，你可以使用 `@expectedExceptionMessage` 来断言异常的消息。让我们向我们的
    `CustomerFactoryTest` 类添加以下测试：
- en: '[PRE16]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: In this test we will try to create a deluxe customer with our factory, but as
    this type of customer does not exist, we will get an exception. The type of the
    expected exception is `InvalidArgumentException`, and the error message is "Wrong
    type". If you run the tests, you will see that they pass.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个测试中，我们将尝试使用我们的工厂创建一个豪华客户，但由于这种类型的客户不存在，我们将得到一个异常。期望的异常类型是 `InvalidArgumentException`，错误信息是
    "类型错误"。如果你运行测试，你会看到它们通过。
- en: 'If we defined an expected exception and the exception is never thrown, the
    test will fail; expecting exceptions is just another type of assertion. To see
    this happen, add the following to your test and run it; you will get a failure,
    and PHPUnit will complain saying that it expected the exception, but it was never
    thrown:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们定义了一个期望的异常，但这个异常从未被抛出，测试将失败；预期异常只是另一种断言类型。为了看到这种情况发生，将以下内容添加到你的测试中并运行它；你将得到一个失败，PHPUnit
    将会抱怨说它期望异常，但它从未被抛出：
- en: '[PRE17]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Data providers
  id: totrans-106
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 数据提供者
- en: If you think about the flow of a test, most of the time, we invoke a method
    with an input and expect an output. In order to cover all the edge cases, it is
    natural that we will repeat the same action with a set of inputs and expected
    outputs. PHPUnit gives us the ability to do so, thus removing a lot of duplicated
    code. This feature is called **data providing**.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你思考一下测试的流程，大多数时候，我们用一个输入调用一个方法并期望得到一个输出。为了覆盖所有边缘情况，我们自然会用一组输入和期望的输出重复相同的操作。PHPUnit
    给我们提供了这样做的能力，从而减少了大量的重复代码。这个特性被称为**数据提供**。
- en: 'A data provider is a public method defined in the `test` class that returns
    an array with a specific schema. Each entry of the array represents a test in
    which the key is the name of the test—optionally, you could use numeric keys—and
    the value is the parameter that the test needs. A test will declare that it needs
    a data provider with the `@dataProvider` annotation, and when executing tests,
    the data provider injects the arguments that the test method needs. Let''s consider
    an example to make it easier. Write the following two methods in your `CustomerFactoryTest`
    class:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 数据提供者是在 `test` 类中定义的一个公共方法，它返回一个具有特定模式的数组。数组的每个条目代表一个测试，键是测试的名称——可选地，你可以使用数字键——值是测试需要的参数。一个测试将声明它需要一个数据提供者，使用
    `@dataProvider` 注解，当执行测试时，数据提供者会注入测试方法需要的参数。让我们通过一个例子来使它更容易理解。在你的 `CustomerFactoryTest`
    类中编写以下两个方法：
- en: '[PRE18]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The test here is `testFactoryValidCustomerTypes`, which expects two arguments:
    `$type` and `$expectedType`. The test uses them to create a customer with the
    factory and verify the type of the result, which we already did by hardcoding
    the types. The test also declares that it needs the `providerFactoryValidCustomerTypes`
    data provider. This data provider returns an array of four entries, which means
    that the test will be executed four times with four different sets of arguments.
    The name of each test is the key of each entry—for example, "Basic customer, lowercase".
    This is very useful in case a test fails because it will be displayed as part
    of the error messages. Each entry is a map with two values, `type` and `expectedType`,
    which are the names of the arguments of the `test` method. The values of these
    entries are the values that the `test` method will get.'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的测试是`testFactoryValidCustomerTypes`，它期望两个参数：`$type`和`$expectedType`。测试使用它们通过工厂创建一个客户并验证结果的类型，这是我们通过硬编码类型已经做到的。测试还声明它需要`providerFactoryValidCustomerTypes`数据提供者。这个数据提供者返回一个包含四个条目的数组，这意味着测试将使用四组不同的参数执行四次。每个测试的名称是每个条目的键——例如，“基本客户，小写”。如果测试失败，这会非常有用，因为它将作为错误消息的一部分显示。每个条目是一个包含两个值的映射，`type`和`expectedType`，它们是`test`方法参数的名称。这些条目的值是`test`方法将获得的值。
- en: The bottom line is that the code we wrote would be the same as if we wrote `testFactoryValidCustomerTypes`
    four times, hardcoding `$type` and `$expectedType` each time. Imagine now that
    the `test` method contains tens of lines of code or we want to repeat the same
    test with tens of datasets; do you see how powerful it is?
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是，我们编写的代码将与我们四次编写`testFactoryValidCustomerTypes`时相同，每次都硬编码`$type`和`$expectedType`。现在想象一下，如果`test`方法包含数十行代码，或者我们想要用数十个数据集重复相同的测试；你看到它的强大之处了吗？
- en: Testing with doubles
  id: totrans-112
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用双倍进行测试
- en: So far, we tested classes that are quite isolated; that is, they do not have
    much interaction with other classes. Nevertheless, we have classes that use several
    classes, such as controllers. What can we do with these interactions? The idea
    of unit tests is to test a specific method and not the whole code base, right?
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们测试了相当孤立的类；也就是说，它们与其他类没有太多交互。尽管如此，我们也有一些使用多个类的类，例如控制器。我们能对这些交互做些什么呢？单元测试的想法是测试一个特定的方法，而不是整个代码库，对吧？
- en: 'PHPUnit allows you to mock these dependencies; that is, you can provide fake
    objects that look similar to the dependencies that the tested class needs, but
    they do not use code from those classes. The goal of this is to provide a dummy
    instance that the class can use and invoke its methods without the side effect
    of what these invocations might have. Imagine as an example the case of the models:
    if the controller uses a real model, then when invoking methods from it, the model
    would access the database each time, making the tests quite unpredictable.'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: PHPUnit 允许你模拟这些依赖项；也就是说，你可以提供看起来与测试类需要的依赖项相似但不需要这些类代码的假对象。这样做的目的是提供一个虚拟实例，类可以使用并调用其方法，而不会产生这些调用可能产生的副作用。以模型为例：如果控制器使用真实模型，那么每次调用其方法时，模型都会访问数据库，这使得测试变得非常不可预测。
- en: If we use a mock as the model instead, the controller can invoke its methods
    as many times as needed without any side effect. Even better, we can make assertions
    of the arguments that the mock received or force it to return specific values.
    Let's take a look at how to use them.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们使用模拟作为模型，控制器可以按需调用其方法，而不会产生任何副作用。更好的是，我们可以对模拟接收到的参数进行断言，或者强制它返回特定的值。让我们看看如何使用它们。
- en: Injecting models with DI
  id: totrans-116
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用依赖注入（DI）注入模型
- en: 'The first thing we need to understand is that if we create objects using `new`
    inside the controller, we will not be able to mock them. This means that we need
    to inject all the dependencies—for example, using a dependency injector. We will
    do this for all of the dependencies but one: the models. In this section, we will
    test the `borrow` method of the `BookController` class, so we will show the changes
    that this method needs. Of course, if you want to test the rest of the code, you
    should apply these same changes to the rest of the controllers.'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先需要理解的是，如果我们使用`new`在控制器内部创建对象，我们将无法对其进行模拟。这意味着我们需要注入所有依赖项——例如，使用依赖注入器。我们将为所有依赖项执行此操作，但有一个例外：模型。在本节中，我们将测试`BookController`类的`borrow`方法，因此我们将展示这个方法需要的变化。当然，如果你想测试其余的代码，你应该将这些相同的更改应用到其余的控制器上。
- en: 'The first thing to do is to add the `BookModel` instance to the dependency
    injector in our `index.php` file. As this class also has a dependency, `PDO`,
    use the same dependency injector to get an instance of it, as follows:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 首件事是在我们的`index.php`文件中将`BookModel`实例添加到依赖注入器中。由于这个类也有一个依赖项，即`PDO`，因此使用相同的依赖注入器来获取它的实例，如下所示：
- en: '[PRE19]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Now, in the `borrow` method of the `BookController` class, we will change the
    new instantiation of the model to the following:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在`BookController`类的`borrow`方法中，我们将更改模型的新实例化为以下内容：
- en: '[PRE20]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Customizing TestCase
  id: totrans-122
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 自定义TestCase
- en: 'When writing your unit test''s suite, it is quite common to have a customized
    `TestCase` class from which all tests extend. This class always extends from `PHPUnit_Framework_TestCase`,
    so we still get all the assertions and other methods. As all tests have to import
    this class, let''s change our autoloader so that it can recognize namespaces from
    the `tests` directory. After this, run `composer update`, as follows:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 当编写单元测试套件时，通常会有一个自定义的`TestCase`类，所有测试都从这个类扩展。这个类始终从`PHPUnit_Framework_TestCase`扩展，所以我们仍然得到所有的断言和其他方法。由于所有测试都必须导入这个类，让我们更改我们的自动加载器，使其能够识别来自`tests`目录的命名空间。之后，运行`composer
    update`，如下所示：
- en: '[PRE21]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: With this change, we will tell Composer that all the namespaces starting with
    `Bookstore\Tests` will be located under the `tests` directory, and the rest will
    follow the previous rules.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这个更改，我们将告诉Composer，所有以`Bookstore\Tests`开头的命名空间都将位于`tests`目录下，其余的将遵循之前的规则。
- en: 'Let''s add now our customized `TestCase` class. The only helper method we need
    right now is one to create mocks. It is not really necessary, but it makes things
    cleaner. Add the following class in `tests/AbstractTestClase.php`:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们现在添加我们的自定义`TestCase`类。我们现在需要的唯一助手方法是创建mock的方法。这并不是真的必要，但它使事情更干净。在`tests/AbstractTestClase.php`中添加以下类：
- en: '[PRE22]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: This method takes the name of a class and tries to figure out whether the class
    is part of the `Bookstore` namespace or not. This will be handy when mocking objects
    of our own codebase as we will not have to write `Bookstore` each time. After
    figuring out what the real full class name is, it uses the mock builder from PHPUnit
    to create one and then returns it.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法以类的名称命名，并试图确定该类是否是`Bookstore`命名空间的一部分。当我们模拟自己的代码库中的对象时，这将非常有用，因为我们不必每次都写`Bookstore`。在确定真正的完整类名之后，它使用PHPUnit的mock构建器来创建一个实例，然后返回它。
- en: 'More helpers! This time, they are for controllers. Every single controller
    will always need the same dependencies: logger, database connection, template
    engine, and configuration reader. Knowing this, let''s create a `ControllerTestCase`
    class from where all the tests covering controllers will extend. This class will
    contain a `setUp` method that creates all the common mocks and sets them in the
    dependency injector. Add it as your `tests/ControllerTestCase.php` file, as follows:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 更多助手！这次，它们是为控制器准备的。每个控制器都将始终需要相同的依赖项：记录器、数据库连接、模板引擎和配置读取器。了解这一点后，让我们从所有覆盖控制器的测试都将扩展的`ControllerTestCase`类开始。这个类将包含一个`setUp`方法，它创建所有常见的mock并设置在依赖注入器中。将其添加为你的`tests/ControllerTestCase.php`文件，如下所示：
- en: '[PRE23]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Using mocks
  id: totrans-131
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用mock
- en: 'Well, we''ve had enough of the helpers; let''s start with the tests. The difficult
    part here is how to play with mocks. When you create one, you can add some expectations
    and return values. The methods are:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，我们已经足够了解助手了；让我们开始测试。这里的难点是如何与mock互动。当你创建一个mock时，你可以添加一些期望值和返回值。方法如下：
- en: '`expects`: This specifies the amount of times the mock''s method is invoked.
    You can send `$this->never()`, `$this->once()`, or `$this->any()` as an argument
    to specify 0, 1, or any invocations.'
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`expects`：这个指定了mock的方法被调用的次数。你可以发送`$this->never()`、`$this->once()`或`$this->any()`作为参数来指定0次、1次或任何调用。'
- en: '`method`: This is used to specify the method we are talking about. The argument
    that it expects is just the name of the method.'
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`method`：这个用于指定我们正在讨论的方法。它期望的参数只是方法的名称。'
- en: '`with`: This is a method used to set the expectations of the arguments that
    the mock will receive when it is invoked. For example, if the mocked method is
    expected to get `basic` as the first argument and `123` as the second, the `with`
    method will be invoked as `with("basic", 123)`. This method is optional, but if
    we set it, PHPUnit will throw an error in case the mocked method does not get
    the expected arguments, so it works as an assertion.'
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`with`：这是一个用于设置模拟在调用时将接收的参数期望的方法。例如，如果模拟的方法预期得到`basic`作为第一个参数和`123`作为第二个参数，则`with`方法将被调用为`with("basic",
    123)`。这个方法不是必需的，但如果设置了它，PHPUnit将在模拟的方法没有接收到预期的参数时抛出一个错误，因此它作为一个断言工作。'
- en: '`will`: This is used to define what the mock will return. The two most common
    usages are `$this->returnValue($value)` or `$this->throwException($exception)`.
    This method is also optional, and if not invoked, the mock will always return
    null.'
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`will`：用于定义模拟将返回的内容。最常用的两种用法是`$this->returnValue($value)`或`$this->throwException($exception)`。这个方法也不是必需的，如果没有调用，模拟将始终返回null。'
- en: 'Let''s add the first test to see how it would work. Add the following code
    to the `tests/Controllers/BookControllerTest.php` file:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们添加第一个测试来看看它会如何工作。将以下代码添加到`tests/Controllers/BookControllerTest.php`文件中：
- en: '[PRE24]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'The first thing the test does is to create a mock of the `BookModel` class.
    Then, it adds an expectation that goes like this: the `get` method will be called
    once with one argument, `123`, and it will throw `NotFoundException`. This makes
    sense as the test tries to emulate a scenario in which we cannot find the book
    in the database.'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 测试的第一件事是创建`BookModel`类的模拟。然后，它添加了一个这样的期望：`get`方法将被调用一次，带有一个参数`123`，并且会抛出`NotFoundException`。这在测试试图模拟我们在数据库中找不到书籍的场景时是有意义的。
- en: The second part of the test consists of adding the expectations of the template
    engine. This is a bit more complex as there are two mocks involved. The `loadTemplate`
    method of `Twig_Environment` is expected to be called once with the `error.twig`
    argument as the template name. This mock should return `Twig_Template`, which
    is another mock. The `render` method of this second mock is expected to be called
    once with the correct error message, returning the response, which is a hardcoded
    string. After all the dependencies are defined, we just need to invoke the `borrow`
    method of the controller and expect a response.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 测试的第二部分包括添加模板引擎的期望。这稍微复杂一些，因为涉及到两个模拟。`Twig_Environment`的`loadTemplate`方法预期会被调用一次，使用`error.twig`作为模板名称。这个模拟应该返回`Twig_Template`，这又是一个模拟。这个第二个模拟的`render`方法预期会被调用一次，使用正确的错误消息，并返回一个硬编码的字符串。定义了所有依赖项之后，我们只需要调用控制器的`borrow`方法并期望得到一个响应。
- en: 'Remember that this test does not have only one assertion, but four: the `assertSame`
    method and the three mock expectations. If any of them are not accomplished, the
    test will fail, so we can say that this method is quite robust.'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，这个测试不仅仅只有一个断言，而是有四个：`assertSame`方法和三个模拟期望。如果其中任何一个没有完成，测试将失败，所以我们可以说这个方法相当稳健。
- en: 'With our first test, we verified that the scenario in which the book is not
    found works. There are two more scenarios that fail as well: when there are not
    enough copies of the book to borrow and when there is a database error when trying
    to save the borrowed book. However, you can see now that all of them share a piece
    of code that mocks the template. Let''s extract this code to a `protected` method
    that generates the mocks when it is given the template name, the parameters are
    sent to the template, and the expected response is received. Run the following:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的第一次测试中，我们验证了当找不到书籍时的场景是有效的。还有两个场景也会失败：当没有足够的书籍副本可以借阅，以及当尝试保存借阅的书籍时出现数据库错误。然而，你现在可以看到，它们都共享一段模拟模板的代码。让我们将这段代码提取到一个`protected`方法中，当给定模板名称时，该方法会生成模拟。将参数发送到模板，并接收预期的响应。运行以下代码：
- en: '[PRE25]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: The only novelty here is when we expect that the `borrow` method is never invoked.
    As we do not expect it to be invoked, there is no reason to use the `with` nor
    `will` method. If the code actually invokes this method, PHPUnit will mark the
    test as failed.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 这里唯一的创新之处在于当我们期望`borrow`方法永远不会被调用时。因为我们不期望它被调用，所以没有必要使用`with`或`will`方法。如果代码实际上调用了这个方法，PHPUnit将标记测试为失败。
- en: 'We already tested and found that all the scenarios that can fail have failed.
    Let''s add a test now where a user can successfully borrow a book, which means
    that we will return valid books and customers from the database, the `save` method
    will be invoked correctly, and the template will get all the correct parameters.
    The test looks as follows:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经测试并发现所有可能失败的场景都已经失败。现在让我们添加一个测试，其中用户可以成功借阅一本书，这意味着我们将从数据库返回有效的书籍和客户信息，`save`方法将被正确调用，模板将获取所有正确的参数。测试如下：
- en: '[PRE26]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: So this is it. You have written one of the most complex tests you will need
    to write during this book. What do you think of it? Well, as you do not have much
    experience with tests, you might be quite satisfied with the result, but let's
    try to analyze it a bit further.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 所以这就是全部了。你已经写下了在这本书中你需要编写的一个最复杂的测试。你对它有什么看法？好吧，由于你没有太多的测试经验，你可能对结果相当满意，但让我们进一步分析一下。
- en: Database testing
  id: totrans-148
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 数据库测试
- en: 'This will be the most controversial of the sections of this chapter by far.
    When it comes to database testing, there are different schools of thought. Should
    we use the database or not? Should we use our development database or one in memory?
    It is quite out of the scope of the book to explain how to mock the database or
    prepare a fresh one for each test, but we will try to summarize some of the techniques
    here:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 这将是本章中最具争议的部分。当涉及到数据库测试时，存在不同的观点。我们应该使用数据库吗？我们应该使用开发数据库还是内存中的数据库？解释如何模拟数据库或为每个测试准备一个新的数据库超出了本书的范围，但我们将尝试在这里总结一些技术：
- en: We will mock the database connection and write expectations to all the interactions
    between the model and the database. In our case, this would mean that we would
    inject a mock of the `PDO` object. As we will write the queries manually, chances
    are that we might introduce a wrong query. Mocking the connection would not help
    us detect this error. This solution would be good if we used ORM instead of writing
    the queries manually, but we will leave this topic out of the book.
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们将模拟数据库连接，并将期望写入模型与数据库之间的所有交互。在我们的案例中，这意味着我们将注入一个`PDO`对象的模拟。由于我们将手动编写查询，我们可能会引入错误的查询。模拟连接并不能帮助我们检测这个错误。如果我们使用ORM而不是手动编写查询，这个解决方案会很好，但我们将把这个话题从书中排除。
- en: For each test, we will create a brand new database in which we add the data
    we would like to have for the specific test. This approach might take a lot of
    time, but it assures you that you will be testing against a real database and
    that there is no unexpected data that might make our tests fail; that is, the
    tests are fully isolated. In most of the cases, this would be the preferable approach,
    even though it might not be the one that performs faster. To solve this inconvenience,
    we will create in-memory databases.
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于每个测试，我们将创建一个新的数据库，在其中添加我们为特定测试想要的数据。这种方法可能需要很多时间，但它确保你将针对真实数据库进行测试，并且没有可能使我们的测试失败的不预期的数据；也就是说，测试是完全隔离的。在大多数情况下，这将是首选的方法，即使它可能不是性能最快的。为了解决这个不便，我们将创建内存数据库。
- en: Tests run against an already existing database. Usually, at the beginning of
    the test we start a transaction that we roll back at the end of the test, leaving
    the database without any change. This approach emulates a real scenario, in which
    we can find all sorts of data and our code should always behave as expected. However,
    using a shared database always has some side effects; for example, if we want
    to introduce changes to the database schema, we will have to apply them to the
    database before running the tests, but the rest of the applications or developers
    that use the database are not yet ready for these changes.
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对现有数据库进行的测试。通常，在测试开始时，我们启动一个事务，在测试结束时回滚，这样数据库就不会有任何变化。这种方法模拟了一个真实场景，我们可以找到各种数据，我们的代码应该始终按预期行为。然而，使用共享数据库总有一些副作用；例如，如果我们想对数据库模式进行更改，我们必须在运行测试之前将这些更改应用到数据库中，但其他使用数据库的应用程序或开发者可能还没有准备好这些更改。
- en: 'In order to keep things small, we will try to implement a mixture of the second
    and third options. We will use our existing database, but after starting the transaction
    of each test, we will clean all the tables involved with the test. This looks
    as though we need a `ModelTestCase` to handle this. Add the following into `tests/ModelTestCase.php`:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 为了保持事情简单，我们将尝试实现第二和第三种选项的混合。我们将使用现有的数据库，但在每个测试开始事务后，我们将清理所有涉及的表。这似乎需要 `ModelTestCase`
    来处理。将以下内容添加到 `tests/ModelTestCase.php`：
- en: '[PRE27]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: The `setUp` method creates a database connection with the same credentials found
    in the `config/app.yml` file. Then, we will start a transaction and invoke the
    `cleanAllTables` method, which iterates the tables in the `$tables` property and
    deletes all the content from them. The `tearDown` method rolls back the transaction.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: '`setUp` 方法使用与 `config/app.yml` 文件中找到的相同凭据创建数据库连接。然后，我们将开始一个事务并调用 `cleanAllTables`
    方法，该方法遍历 `$tables` 属性中的表并删除它们的所有内容。`tearDown` 方法回滚事务。'
- en: Note
  id: totrans-156
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '**Extending from ModelTestCase**'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: '**从 ModelTestCase 扩展**'
- en: If you write a test extending from this class that needs to implement either
    the `setUp` or `tearDown` method, always remember to invoke the ones from the
    parent.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您编写一个扩展此类的测试，需要实现 `setUp` 或 `tearDown` 方法，请始终记住调用父类的这些方法。
- en: 'Let''s write tests for the `borrow` method of the `BookModel` class. This method
    uses books and customers, so we would like to clean the tables that contain them.
    Create the `test` class and save it in `tests/Models/BookModelTest.php`:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们为 `BookModel` 类的 `borrow` 方法编写测试。此方法使用书籍和客户，因此我们希望清理包含它们的表。创建 `test` 类并将其保存到
    `tests/Models/BookModelTest.php`：
- en: '[PRE28]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Note how we also overrode the `setUp` method, invoking the one in the parent
    and creating the model instance that all tests will use, which is safe to do as
    we will not keep any context on this object. Before adding the tests though, let''s
    add some more helpers to `ModelTestCase`: one to create book objects given an
    array of parameters and two to save books and customers in the database. Run the
    following code:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 注意我们如何也覆盖了 `setUp` 方法，调用了父类中的方法，并创建了所有测试都将使用的模型实例，这样做是安全的，因为我们不会保留任何上下文。在添加测试之前，让我们向
    `ModelTestCase` 添加一些额外的辅助工具：一个用于根据参数数组创建书籍对象的方法，以及两个用于在数据库中保存书籍和客户的方法。运行以下代码：
- en: '[PRE29]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: As you can note, we added default values for all the fields, so we are not forced
    to define the whole book/customer each time we want to save one. Instead, we just
    sent the relevant fields and merged them to the default ones.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所注意到的，我们为所有字段添加了默认值，因此我们不必每次想要保存一本书/客户时都定义整个实体。相反，我们只需发送相关的字段并将它们与默认值合并。
- en: Also, note that the `buildBook` method used a new concept, **reflection**, to
    access the private properties of an instance. This is way beyond the scope of
    the book, but if you are interested, you can read more at [http://php.net/manual/en/book.reflection.php](http://php.net/manual/en/book.reflection.php).
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，请注意，`buildBook` 方法使用了一个新概念，**反射**，来访问实例的私有属性。这超出了本书的范围，但如果您对此感兴趣，可以在[http://php.net/manual/en/book.reflection.php](http://php.net/manual/en/book.reflection.php)上阅读更多内容。
- en: 'We are now ready to start writing tests. With all these helpers, adding tests
    will be very easy and clean. The `borrow` method has different use cases: trying
    to borrow a book that is not in the database, trying to use a customer not registered,
    and borrowing a book successfully. Let''s add them as follows:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在准备开始编写测试。有了所有这些辅助工具，添加测试将会非常简单且清晰。`borrow` 方法有不同的使用场景：尝试借阅数据库中不存在的书籍，尝试使用未注册的客户，以及成功借阅书籍。让我们按照以下方式添加它们：
- en: '[PRE30]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Impressed? Compared to the controller tests, these tests are way simpler, mainly
    because their code performs only one action, but also thanks to all the methods
    added to `ModelTestCase`. Once you need to work with other objects, such as `sales`,
    you can add `addSale` or `buildSale` to this same class to make things cleaner.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 感到印象深刻吗？与控制器测试相比，这些测试要简单得多，主要是因为它们的代码只执行一个动作，但也得益于添加到 `ModelTestCase` 中的所有方法。一旦您需要与其他对象一起工作，例如
    `sales`，您可以将 `addSale` 或 `buildSale` 添加到这个相同的类中，使事情更简洁。
- en: Test-driven development
  id: totrans-168
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试驱动开发
- en: 'You might realize already that there is no unique way to do things when talking
    about developing an application. It is out of the scope of this book to show you
    all of them—and by the time you are done reading these lines, more techniques
    will have been incorporated already—but there is one approach that is very useful
    when it comes to writing good, testable code: **test-driven development** (**TDD**).'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经意识到，在谈论开发应用程序时，没有一种独特的方法。这本书的范围不包括展示所有这些方法——而且在你读完这些行的时候，可能已经融入了更多的技术——但有一种方法在编写好的、可测试的代码时非常有用：**测试驱动开发**（**TDD**）。
- en: This methodology consists of writing the unit tests before writing the code
    itself. The idea, though, is not to write all the tests at once and then write
    the class or method but rather to do it in a progressive way. Let's consider an
    example to make it easier. Imagine that your `Sale` class is yet to be implemented
    and the only thing we know is that we have to be able to add books. Rename your
    `src/Domain/Sale.php` file to `src/Domain/Sale2.php` or just delete it so that
    the application does not know about it.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法包括在编写代码之前先编写单元测试。然而，想法并不是一次性编写所有测试，然后再编写类或方法，而是以渐进的方式完成。让我们通过一个例子来简化这个过程。假设你的`Sale`类尚未实现，我们唯一知道的是我们必须能够添加书籍。将`src/Domain/Sale.php`文件重命名为`src/Domain/Sale2.php`或直接删除它，这样应用程序就不会知道它的存在。
- en: Note
  id: totrans-171
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '**Is all this verbosity necessary?**'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: '**所有这些冗长是否必要？**'
- en: You will note in this example that we will perform an excessive amount of steps
    to come up with a very simple piece of code. Indeed, they are too many for this
    example, but there will be times when this amount is just fine. Finding these
    moments comes with experience, so we recommend you to practice first with simple
    examples. Eventually, it will come naturally to you.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，你会注意到我们将执行大量的步骤来得到一个非常简单的代码片段。确实，对于这个例子来说，步骤太多了，但有时候这个数量是合适的。找到这些时刻需要经验，所以我们建议你先从简单的例子开始练习。最终，这会变得自然而然。
- en: 'The mechanics of TDD consist of four steps, as follows:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: TDD的机制包括以下四个步骤：
- en: Write a test for some functionality that is not yet implemented.
  id: totrans-175
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为尚未实现的功能编写一个测试。
- en: Run the unit tests, and they should fail. If they do not, either your test is
    wrong, or your code already implements this functionality.
  id: totrans-176
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行单元测试，它们应该失败。如果它们没有失败，那么要么是你的测试错误，要么你的代码已经实现了这个功能。
- en: Write the minimum amount of code to make the tests pass.
  id: totrans-177
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写最少的代码以使测试通过。
- en: Run the unit tests again. This time, they should pass.
  id: totrans-178
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 再次运行单元测试。这次，它们应该通过。
- en: We do not have the `sale` domain object, so the first thing, as we should start
    from small things and then move on to bigger things, is to assure that we can
    instantiate the `sale` object. Write the following unit test in `tests/Domain/SaleTest.php`
    as we will write all the existing tests, but using TDD; you can remove the existing
    tests in this file.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 我们没有`sale`域对象，所以首先，正如我们应该从小事做起，然后逐步过渡到大事，我们需要确保我们可以实例化`sale`对象。在`tests/Domain/SaleTest.php`中编写以下单元测试，因为我们将会用TDD的方式编写所有现有的测试；你可以删除这个文件中的现有测试。
- en: '[PRE31]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Run the tests to make sure that they are failing. In order to run one specific
    test, you can mention the file of the test when running PHPUnit, as shown in the
    following script:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 运行测试以确保它们失败。为了运行一个特定的测试，你可以在运行PHPUnit时指定测试文件，如下面的脚本所示：
- en: '![Test-driven development](img/00034.jpeg)'
  id: totrans-182
  prefs: []
  type: TYPE_IMG
  zh: '![测试驱动开发](img/00034.jpeg)'
- en: 'Good, they are failing. That means that PHP cannot find the object to instantiate
    it. Let''s now write the minimum amount of code required to make this test pass.
    In this case, creating the class would be enough, and you can do this through
    the following lines of code:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，它们失败了。这意味着PHP找不到要实例化的对象。现在，让我们编写最少的代码来使这个测试通过。在这种情况下，创建一个类就足够了，你可以通过以下代码行来完成：
- en: '[PRE32]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Now, run the tests to make sure that there are no errors.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，运行测试以确保没有错误。
- en: '![Test-driven development](img/00035.jpeg)'
  id: totrans-186
  prefs: []
  type: TYPE_IMG
  zh: '![测试驱动开发](img/00035.jpeg)'
- en: 'This is easy, right? So, what we need to do is repeat this process, adding
    more functionality each time. Let''s focus on the books that a sale holds; when
    created, the book''s list should be empty, as follows:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 这很简单，对吧？所以，我们需要重复这个过程，每次添加更多功能。让我们专注于销售所包含的书籍；当创建时，书籍列表应该是空的，如下所示：
- en: '[PRE33]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Run the tests to make sure that they fail—they do. Now, write the following
    method in the class:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 运行测试以确保它们失败——它们确实会失败。现在，在类中编写以下方法：
- en: '[PRE34]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Now, if you run... wait, what? We are forcing the `getBooks` method to return
    an empty array always? This is not the implementation that we need—nor the one
    we deserve—so why do we do it? The reason is the wording of step 3: "Write the
    minimum amount of code to make the tests pass.". Our test suite should be extensive
    enough to detect this kind of problem, and this is our way to make sure it does.
    This time, we will write bad code on purpose, but next time, we might introduce
    a bug unintentionally, and our unit tests should be able to detect it as soon
    as possible. Run the tests; they will pass.'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果你运行...等等，什么？我们正在强制`getBooks`方法始终返回一个空数组？这不是我们需要的实现——也不是我们应得的——那么我们为什么要这样做呢？原因是步骤3的措辞：“编写最少的代码以使测试通过。”我们的测试套件应该足够广泛，能够检测这类问题，这是我们确保它的方法。这次，我们将故意编写糟糕的代码，但下次，我们可能无意中引入了一个错误，我们的单元测试应该能够尽快检测到它。运行测试；它们将通过。
- en: 'Now, let''s discuss the next functionality. When adding a book to the list,
    we should see this book with amount 1\. The test should be as follows:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们讨论下一个功能。当向列表中添加一本书时，我们应该看到这本书的数量为1。测试应该如下：
- en: '[PRE35]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'This test is very useful. Not only does it force us to implement the `addBook`
    method, but also it helps us fix the `getBooks` method—as it is hardcoded right
    now—to always return an empty array. As the `getBooks` method now expects two
    different results, we cannot trick the tests any more. The new code for the class
    should be as follows:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 这个测试非常有用。它不仅迫使我们实现`addBook`方法，还帮助我们修复了`getBooks`方法——因为它现在硬编码为始终返回一个空数组。由于`getBooks`方法现在期望两个不同的结果，我们不能再欺骗测试了。类的新代码如下：
- en: '[PRE36]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'A new test we can write is the one that allows you to add more than one book
    at a time, sending the amount as the second argument. The test would look similar
    to the following:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以编写的一个新测试是允许你一次添加多本书，将数量作为第二个参数。测试看起来可能如下：
- en: '[PRE37]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Now, the tests do not pass, so we need to fix them. Let''s refactor `addBook`
    so that it can accept a second argument as the amount :'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，测试没有通过，所以我们需要修复它们。让我们重构`addBook`方法，使其能够接受第二个参数作为数量：
- en: '[PRE38]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'The next functionality we would like to add is the same book invoking the method
    several times, keeping track of the total amount of books added. The test could
    be as follows:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 我们想要添加的下一个功能是相同的书籍调用方法多次，同时跟踪添加的书籍总数。测试可以如下：
- en: '[PRE39]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'This test will fail as the current execution will not add all the amounts but
    will instead keep the last one. Let''s fix it by executing the following code:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 这个测试将失败，因为当前的执行不会添加所有数量，而是保留最后一个。让我们通过执行以下代码来修复它：
- en: '[PRE40]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Well, we are almost there. There is one last test we should add, which is the
    ability to add more than one different book. The test is as follows:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，我们几乎完成了。我们还需要添加最后一个测试，这个测试是关于能够添加多本不同书籍的能力。测试如下：
- en: '[PRE41]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'This test fails due to the hardcoded book ID in our implementation. If we did
    not do this, the test would have already passed. Let''s fix it then; run the following:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 这个测试失败是因为我们的实现中硬编码了书籍ID。如果我们没有这样做，测试就已经通过了。那么让我们修复它；运行以下代码：
- en: '[PRE42]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: We are done! Does it look familiar? It is the same code we wrote on our first
    implementation except for the rest of the properties. You can now replace the
    `sale` domain object with the previous one, so you have all the functionalities
    needed.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 我们完成了！看起来熟悉吗？这是我们在第一次实现中写的相同代码，除了其余的属性。你现在可以用之前的`sale`域对象替换它，这样你就有了所有需要的功能。
- en: Theory versus practice
  id: totrans-209
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理论与实际
- en: 'As mentioned before, this is a quite long and verbose process that very few
    experienced developers follow from start to end but one that most of them encourage
    people to follow. Why is this so? When you write all your code first and leave
    the unit tests for the end, there are two problems:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，这是一个相当长且冗长的过程，很少有经验丰富的开发者从头到尾遵循，但大多数人都会鼓励人们遵循。为什么是这样呢？当你首先编写所有代码，然后留到最后一刻编写单元测试时，有两个问题：
- en: Firstly, in too many cases developers are lazy enough to skip tests, telling
    themselves that the code already works, so there is no need to write the tests.
    You already know that one of the goals of tests is to make sure that future changes
    do not break the current features, so this is not a valid reason.
  id: totrans-211
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 首先，在太多的情况下，开发者足够懒惰，以至于跳过测试，告诉自己代码已经工作得很好，所以没有必要编写测试。你已经知道测试的一个目标是要确保未来的更改不会破坏当前的功能，所以这不是一个有效的理由。
- en: Secondly, the tests written after the code usually test the code rather than
    the functionality. Imagine that you have a method that was initially meant to
    perform an action. After writing the method, we will not perform the action perfectly
    due to a bug or bad design; instead, we will either do too much or leave some
    edge cases untreated. When we write the test after writing the code, we will test
    what we see in the method, not what the original functionality was!
  id: totrans-212
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 其次，代码编写之后的测试通常测试的是代码本身而不是功能。想象一下，你有一个最初旨在执行某个操作的方法。在编写方法之后，由于错误或设计不良，我们可能无法完美地执行该操作；相反，我们可能会做太多或者遗漏一些边缘情况。当我们编写代码之后的测试时，我们会测试我们看到的方法，而不是原始功能是什么！
- en: If you instead force yourself to write the tests first and then the code, you
    make sure that you always have tests and that they test what the code is meant
    to do, leading to a code that performs as expected and is fully covered. Also,
    by doing it in small intervals, you get quick feedback and don't have to wait
    for hours to know whether all the tests and code you wrote make sense at all.
    Even though this idea is quite simple and makes a lot of sense, many novice developers
    find it hard to implement.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你强迫自己先编写测试然后再编写代码，你就能确保始终有测试，并且它们能够测试代码的预期功能，从而得到一个按预期执行且完全覆盖的代码。此外，通过分小段进行，你可以快速获得反馈，不必等待数小时才能知道你编写的所有测试和代码是否合理。尽管这个想法很简单并且很有道理，但许多新手开发者发现很难实施。
- en: Experienced developers have written code for several years, so they have already
    internalized all of this. This is the reason why some of them prefer to either
    write several tests before starting with the code or the other way around, that
    is, writing code and then testing it as they are more productive this way. However,
    if there is something that all of them have in common it is that their applications
    will always be full of tests.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 经验丰富的开发者已经编写代码多年，因此他们已经将所有这些知识内化了。这就是为什么他们中的一些人更喜欢在开始编写代码之前先写几个测试，或者反过来，先编写代码然后再测试，因为他们认为这样更有效率。然而，如果他们有什么共同点的话，那就是他们的应用程序总是充满了测试。
- en: Summary
  id: totrans-215
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, you learned the importance of testing your code using unit
    tests. You now know how to configure PHPUnit on your application so that you can
    not only run your tests but also get good feedback. You got a good introduction
    on how to write unit tests properly, and now, it is safer for you to introduce
    changes in your application.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你学习了使用单元测试测试代码的重要性。你现在知道如何配置PHPUnit在你的应用程序上，以便你不仅可以运行测试，还可以获得良好的反馈。你对如何正确编写单元测试有了很好的了解，现在，你在应用程序中引入更改时会更安全。
- en: In the next chapter, we will study some existing frameworks, which you can use
    instead of writing your own every time you start an application. In this way,
    not only will you save time and effort, but also other developers will be able
    to join you and understand your code easily.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将研究一些现有的框架，你可以在每次开始一个应用程序时使用这些框架而不是自己编写。这样，你不仅节省了时间和精力，而且其他开发者也能轻松地加入你并理解你的代码。
