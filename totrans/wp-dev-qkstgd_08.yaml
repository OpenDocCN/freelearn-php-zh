- en: Discovering Key Modules in Development
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Modern website interfaces are mostly built on the concept of blocks, where the
    site owners can drag and drop reusable components to build the interfaces. UI
    components and page builders play a major role in developing these interfaces.
    Therefore, it's important for developers to have the knowledge of integrating
    any third-party UI component to build amazing interfaces with interactivity. On
    the other hand, WordPress is chosen by many developers due to the existing CMS
    features that accelerate the development process. So, developers need thorough
    knowledge of using backend features as well as customizing the existing features
    for custom requirements.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we are going to focus on UI component integration as well as
    customization of common backend features. We begin the chapter by integrating
    a jQuery slider to WordPress while using menu pages to capture the data. Then,
    we will integrate another popular component called accordion by using custom post
    types to capture the data. After this, we will look at the basic steps of integrating
    any UI component using the two integrations for Image Slider and accordion. Also,
    we will look at the importance of modern page builders in site development and
    discuss the basics of creating a custom component with any page builder. Finally,
    we will look at the process of customizing backend features by creating a basic
    dashboard widget and modifying list tables to provide custom features.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Integrating UI components
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Integrating jQuery image slider
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Integrating jQuery accordion
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Identifying the steps for integrating UI components
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding the use of page builders
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating custom dashboard widgets
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Customizing backend list tables
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By the end of this chapter, you will have the ability to customize backend admin
    features as well as integrate UI components into sites with the latest trending
    methods.
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You will be required to have WordPress 4.9.8 installed to follow this procedure.
    Even if you
  prefs: []
  type: TYPE_NORMAL
- en: have a later version of WordPress, the described examples should work with no
    significant problems.
  prefs: []
  type: TYPE_NORMAL
- en: 'The code files of this chapter can be found on GitHub:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://github.com/PacktPublishing/WordPress-Development-Quick-Start-Guide/tree/master/Chapter08](https://github.com/PacktPublishing/WordPress-Development-Quick-Start-Guide/tree/master/Chapter08)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Check out the following video to see the code in action:'
  prefs: []
  type: TYPE_NORMAL
- en: '[http://bit.ly/2yGYX03](http://bit.ly/2yGYX03)'
  prefs: []
  type: TYPE_NORMAL
- en: UI components
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Modern websites are built on top of interactive UI elements. Many premium WordPress
    themes include a wide range of UI components with the support of open source JavaScript
    and CSS libraries. These UI components attract users to a site by simplifying
    the interfaces as well as providing large content in a limited space. Among hundreds
    of UI elements, we find image sliders and galleries, tabs being the most popular
    ones. As a developer, you need to use or build these components to keep up to
    date with rising UI requirements in modern development. So, it's important to
    understand the basic process of integrating any UI component into WordPress using
    plugins or themes. In this section, we are going to look at the integration of
    two UI components. Let’s get started.
  prefs: []
  type: TYPE_NORMAL
- en: Integrating the jQuery image slider
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The image sliders and galleries are the most popular UI elements in WordPress
    sites. You can visit the [wordpress.org](http://wordpress.org) plugin directory
    or a premium marketplace such as Codecanyon to understand the amount of downloads
    and purchases of such plugins. We can use these sliders for displaying a set of
    basic images, as well as to display advanced content and images to promote your
    products, services, and features.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we are going to use Basic jQuery Slider ([http://basicslider.com/](http://basicslider.com/))
    to explain the process of integrating an Image Slider. We will be creating a single
    Image Slider to display product images in the home page of the site or any other
    preferred location.
  prefs: []
  type: TYPE_NORMAL
- en: Image Slider plugins give you the ability to create multiple reusable sliders
    using custom post types or custom forms. In this scenario, we are only focusing
    on a single predefined slider.
  prefs: []
  type: TYPE_NORMAL
- en: Before starting the implementation, we have to create another plugin for this
    chapter. We are going to name it `WPQuick Key Modules` in a directory called `wpquick-key-modules`.
    We will be using this plugin for the implementation of most of the features discussed
    in this chapter. The plugin will have the same structure as the previous plugins,
    with a main class initializing all the other features and classes.
  prefs: []
  type: TYPE_NORMAL
- en: Building a product image slider
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We can use sliders to display any type of content, with the common type of
    content being images. The first step of integrating any UI component is the process
    of capturing the data. In this scenario, the required data will be a set of images.
    So, we need to build an interface to let the administrator upload a set of images
    for the slider. We have two options for creating an interface for such requirements:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Menu pages**: We can use the `add_menu_page` function to create a new menu
    page for the features of our plugin. This will be a top-level menu item in the
    WordPress admin menu with the ability to support sub menu pages. This is suitable
    when you need to highlight the menu of your plugin as well as create different
    menu pages for various features of the plugin. More details about the `add_menu_page`
    function are available at [https://developer.wordpress.org/reference/functions/add_menu_page/](https://developer.wordpress.org/reference/functions/add_menu_page/).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Options pages**: We can use the `add_options_page` function to createa new
    options page for custom settings. This function will create a sub-level menu item
    on the Settings menu item. However, it doesn''t support further levels, and hence
    it will be difficult to use for plugins that require multiple menu pages. This
    is useful for adding general site specific settings rather than plugin settings.
    More details about the `add_options_page` function is available at [https://developer.wordpress.org/reference/functions/add_options_page/](https://developer.wordpress.org/reference/functions/add_options_page/).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In this scenario, we are going to choose menu pages for the image uploading
    interface, as this is a plugin-specific custom requirement. Let's build a menu
    page to upload the images.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a plugin menu page
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'WordPress provides built-in functions to add menu pages through plugins. We
    can add the interfaces as main- menu items or as sub-menu items. Create a class
    called `WQKM_UI_Components` inside the classes directory of our plugin. Then,
    we can do the usual file inclusion and object creation within the `includes` and
    `instance` functions of the main class of our plugin. Next, we can add the following
    line of code within  `admin_menu`  action to register a new menu page:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The first two parameters of this function define titles for the menu page and
    the menu item. The third parameter defines the capability to load this page. Here,
    we have used `manage_options` as the capability to restrict it to the administrator.
    You can change this capability based on the person responsible for using this
    interface. The fourth parameter defines a unique slug to access the menu item
    from the URL. The final parameter defines the callback function to generate the
    content for this interface. These are the main parameters used for this function.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we need to implement the callback function to display the necessary fields
    to upload the images to the slider. Let''s take a look at the structure of the `ui_settings`
    function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'We have already discussed a callback function for template loading in the previous
    chapters, and hence we will not be discussing the code in detail. First, we define
    the global variables for holding the main instance of our plugin and passing the
    data to templates. Then, we load the custom template using the technique we used
    in the previous chapters, with the support of the custom template loader. You
    can refer to the source code for the complete implementation. Next, we have to
    build the custom template to upload files, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s understand the structure of this template for handling image uploads:'
  prefs: []
  type: TYPE_NORMAL
- en: First, we define the global variable to accept the template data passed from
    the `WQKM_UI_Components` class. Initially, this variable will be empty, as we
    don't have any template data or settings.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Then, we have to define a form to enable data submissions. Inside the form,
    we have an empty container called `wqkm-slider-msg` to handle the form error and
    success messages.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Next, we add a file input field to select and upload the images for the slider.
    We also added a DIV element called `wqkm-slider-images-panel`, inline with the
    file field to display the current images uploaded to the slider.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Finally, we add a button instead of a submit button, as we will be using AJAX
    to handle the form submission.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now the interface is prepared to upload images to the slider. You can access
    this interface by using the `UI Component Settings` menu item from the main menu.
  prefs: []
  type: TYPE_NORMAL
- en: Saving slider images using AJAX
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We can use normal post submissions as well as AJAX submissions, as this is a
    backend screen without any other dependencies. However, AJAX gives better user
    experience, and hence we will be submitting the form data through AJAX. First,
    we have to add a new script using the `load_admin_scripts` function to handle
    the AJAX request for saving slider images. We will be using the exact same code
    used for the `WooCommerce Product Files` plugin, and hence you can refer to the
    main file inside the source code directory for the implementation of the `load_admin_scripts`
    function.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we have to handle the form submission process using AJAX. The code for
    the file form submission is available inside the `wqkm-admin.js` file of the source
    codes directory. The implementation will be the same as the one we used in the `wqwpf-admin.js`
    file of the `WQWPF Product Files` plugin, except for the following differences:'
  prefs: []
  type: TYPE_NORMAL
- en: In this case, we have get the custom form using the form ID, instead of using
    a built-in post-submission form
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We use the `wqkm_save_slider_images` action instead of the `wqwpf_save_product_files`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We remove the post-ID parameter, as we are not submitting a form related to
    a post
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Now we come to the final part of the image-saving process by uploading and
    capturing the file data. We have to begin by adding the following action to the
    constructor of the `WQKM_UI_Components` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'This process is only executed by the logged users, and hence we have omitted
    the `wp_ajax_nopriv` action. Let’s take a look at the implementation of the `save_slider_images`
    function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Here''s what the previous code does:'
  prefs: []
  type: TYPE_NORMAL
- en: We begin the function by retrieving the nonce value from the POST request and
    assigning the ID of the logged-in user.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Then, we upload the images in the request using the `process_file_upload` function,
    after completing the nonce verification. We have made a copy of the `process_file_upload`
    function from the **Post Attachments** plugin developed earlier. The only difference
    is the use of image-specific file types instead of the document file types we
    used earlier.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Once the images are uploaded, we use the `get_option` function to retrieve the
    existing images. Then, we add the uploaded image and save the new image set using
    `update_option`. In this scenario, we have stored slider images in the `wp_options`
    table, as it was a predefined slider. In scenarios where we need multiple dynamic
    sliders, we have to use the `wp_posts` table or a custom table to store this data.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Finally, we traverse through the images list and generate the HTML for images
    to be sent as part of the response for an AJAX request. In the AJAX request, we
    have to use the necessary keys and display the existing images list inline with
    the image upload field.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now we have captured the necessary data required for our image slider component.
    The next step is to use this data along with the necessary scripts to generate
    the UI component.
  prefs: []
  type: TYPE_NORMAL
- en: Preparing slider images
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We need to prepare the HTML code to include the slider images with the necessary
    containers. The element structure for each slider varies based on the library.
    Therefore, we need to refer to the documentation of the slider JavaScript library
    and find out the expected structure. So, we have to visit [http://basicslider.com/](http://basicslider.com/)
    and go to the Markup section. This section explains the required elements to implement
    the slider:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we have to use this structure and add the slider images inside `<li>` elements.
    We can directly add the HTML to a WordPress post or a page, to display a slider.
    However, we may need to reuse the slider, and hence it is always a good option
    to implement it as a shortcode or a widget. The shortcode is the perfect solution,
    as it can be also included within widgets. Let''s start the implementation by
    adding a shortcode to the constructor of the `WQKM_UI_Components` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we can implement the shortcode callback function to use the uploaded images
    and generate the HTML structure required for the slider. Consider the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: We begin the function by defining the available shortcode attributes and their
    default values. Here, we have only used the `width` and the `height` of the slider
    as settings. You may need to define more settings depending on the image slider
    library of your choice. Then, we retrieve the list of slider images using the `get_option`
    function with the `wqkm_slider_images` key. Finally, we traverse through the images
    and add the image HTML within the `<li>` elements while using the main `<ul>`
    and `<div>` containers to initialize the slider.
  prefs: []
  type: TYPE_NORMAL
- en: Once the shortcode is added to a post or page, you will see a list of images
    as bullet points, without any sliding functionality.
  prefs: []
  type: TYPE_NORMAL
- en: Integrating jQuery slider
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This is the final part of the integration, where we apply the functionality
    of JavaScript or CSS libraries to initialize the features of the UI component.
    So, we need to understand the required library files and the order of inclusion.
    The required files are shown in the **Usage** section of [http://basicslider.com/](http://basicslider.com/).
    So, we have to download the necessary libraries and add them within our plugin.
    Once the files are added, we can use the following script and style registering
    code inside the `load_scripts` function of the main class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: We have included the `bjqs.css` and `demo.css` files for styles and the `bjqs-1.3.js`
    file for scripts with jQuery as a dependency. The third line registers a plugin-specific
    custom script to initialize the slider. So, we have to use both the jQuery and
    the slider library as dependencies.
  prefs: []
  type: TYPE_NORMAL
- en: Now we need to include these libraries to WordPress requests. We can use the `wp_enqueue_style`
    and the `wp_enqueue_script` functions along with registration code to include
    the files. However, it means these files will be included on every request, even
    when there are no image sliders in pages. As a solution, we can include them inside
    the shortcode function, just after the default values for the shortcode attributes.
    You can refer to the source code for the inclusion of these files.
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, we come to the final step, where we initialize the component using the
    necessary scripts. You can refer to the **Activation** section of [http://basicslider.com/](http://basicslider.com/)
    to understand the initialization process, as shown in the following code. This
    code should be added to the `wqkm-front.js` custom script file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: In this library, `bjqs` acts as the initialization function. We use it on the
    container with the ID `#banner-fade`. We have also assigned the shortcode attribute
    values for `width` and `height` using the data we added with the `wp_localize_script`
    function. Now you can refresh the browser and see an image slider, instead of
    the bullet list.
  prefs: []
  type: TYPE_NORMAL
- en: This is a very basic slider with basic functionality. You can find more advanced
    sliders with images, content, videos, and some amazing effects. You can try different
    sliders, as the process of integration is the same, regardless of the slider.
  prefs: []
  type: TYPE_NORMAL
- en: Reusing the slider as a widget
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We had a brief introduction to widgets and their role in WordPress. Widgets
    was intended to add blocks of features to the sidebar of the site. However, with
    modern themes and widget areas, widgets can be considered as a reusable block
    of features similar to shortcodes. So, we are going to look at the process of
    building a frontend widget in WordPress. Let's start by adding a new file to the
    `classes` directory of our plugin with a class called `WQKM_Product_Slider_Widget`.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this scenario, we will be building a widget to display the product slider
    created in the previous section. So, we can reuse the shortcode functionality
    for this widget. Let''s take a look at the implementation of the widget, using
    the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'WordPress uses the `WP_Widget` class as the base for handling the widget functionality.
    All the widgets, including the core widgets, should extend this class to use the
    widget functionality. Therefore, we have extended this class in our custom `WQKM_Product_Slider_Widget`
    class declaration. Now we can go though the main functions of a widget using the
    following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: '`constructor`: We have to use this function to call the constructor of the
    parent `WP_Widget` class, with the necessary parameters. In this case, we have
    used a unique ID, title, and a description.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`widget`: This function is used to generate the output of the widget in the
    frontend. Here, we have used `wqkm_product_slider` shortcode to generate the output
    for the widget. You can use a shortcode or call a function to generate the output.
    The `$instance` variable contains all the settings for the widget, added to the
    backend. So, we are using the width and height settings as attributes to the shortcode.
    You may also notice the use of the `$args[''before_widget'']` and the `$args[''before_widget'']`
    statements. These are a predefined set of arguments passed to the widget and the
    values of these arguments are specified when registering the widgets. These arguments
    are useful for adding common content before or after each widget.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`form`: This function is used to display the form to capture the settings for
    the widget. We used width and height in the widget function, and hence we need
    settings to define those values. First, we get the existing values for the settings
    using the `$instance` variable passed automatically to this function. Then, we
    generate the input fields for the width and height settings. You may notice the
    use of the `get_field_id` and the `get_field_name` functions. These are functions
    defined in the core `WP_Widget` class to provide access to the widget details
    in a standard way. You should always use these functions without hard-coding names
    and IDs.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`Update`: This function is used to save or update the settings data to the
    database. Once the Save button of a widget is clicked, this function will be called
    with the old values, as well as the submitted new values. We have to make the
    necessary validations and assign the new values to the `$instance` variable with
    the respective keys. Then, the WordPress core widget class will automatically
    save the values in the `$instance` variable.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'This is the standard process for building any custom widget. Once the widget
    class is created, you have to use these four functions to generate the necessary
    settings and output for the widget. Even though we have completed creating the
    widget, it will not be visible in the Appearance | Widgets section. We have to
    register new widgets, before they appear in the widgets section. Let’s consider
    the following code for registering our widget:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: First, we need to include the file inside the `includes` function of the main
    class. Then, we can add the `widgets_init` action to the constructor of the `WQKM_Admin_Features`
    class. Finally, we use `register_widget` with the class name of the widget inside
    the callback function to register the new widget. Now you should be able to use
    the new widget to add the product image slider to your sidebar.
  prefs: []
  type: TYPE_NORMAL
- en: Integrating jQuery accordion
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we are going to look at the integration of another popular
    UI component called **Accordion**. The accordion is a component that allows you
    to display a large amount of content within a limited space using collapsible
    sections. We have chosen the accordion component of the **jQuery UI** library
    ([https://jqueryui.com/accordion/](https://jqueryui.com/accordion/)) as a basic
    solution. You can find many advanced accordion component libraries.
  prefs: []
  type: TYPE_NORMAL
- en: In the image sliders section, we used a menu page to capture data, and limited
    it to a single fixed-image slider. However, it’s also important to have the ability
    to use same component with different content in various places on the site. So,
    we are going to build accordions with the ability to create unlimited components
    with dynamic content. We can either use custom post types and store the data in
    a `wp_posts` table, or we can use a custom table. Since we are developing a UI
    element, we are going to use custom post types to simplify the process. Let’s
    get started.
  prefs: []
  type: TYPE_NORMAL
- en: Creating an accordion model and capturing data
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have chosen to use custom post types for accordions. Therefore, we need to
    register a new custom post type by using the `register_post_type` function with
    necessary settings. We already created a custom post type and discussed the process
    in previous chapters, while working with the property post type. Therefore, you
    can refer to the `WQKM_UI_Components` class inside the source code directory to
    understand the registration.
  prefs: []
  type: TYPE_NORMAL
- en: Unlike properties, accordions are not intended to be displayed as individual
    posts or to achieve page items. Instead, we use them to capture the data to be
    reused in UI elements within posts or pages. Therefore, we have to set the `public`
    attribute to `false` while creating the custom post type. This setting makes sure
    that the accordions are not publicly visible as an individual post type.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once the post type is registered, we need to use metaboxes to include the necessary
    fields and capture the data for accordions. The accordion has many sections with
    dynamic content. So, we need text area fields to capture the content for each
    section. Let''s start by adding a metabox to accordions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we have registered a new meta box for the accordion post type. The `add_meta_boxes`
    action and the post type initialization can be found inside the constructor of
    the `WQKM_UI_Components` class. Now we need to implement the callback function
    using the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: We begin the function by defining the global variables and adding the post type
    and nonce to the global template data variable. Then, we get the existing data
    for the accordion sections using the `get_post_meta` function. Here, we have only
    included one section. You can find three sections in the source code.
  prefs: []
  type: TYPE_NORMAL
- en: We have fixed the accordion sections to three, to simplify the development.
    Ideally, we should allow administrators to dynamically add an unlimited number
    of sections for accordions.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we load a custom template for the input fields of the accordion sections.
    The template for the accordion meta boxes can be found inside the `accordion-meta.php`
    file in the `templates` directory.
  prefs: []
  type: TYPE_NORMAL
- en: 'This template is similar to the one used for the `Properties` post type, and
    hence it''s self-explanatory. However, you may notice the use of the following
    line of code instead of the code for text areas:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: We could have used text area fields for the accordion section. However, these
    sections may contain a considerable amount of HTML, and hence using a text area
    can be difficult. As a solution, we used the `wp_editor` function that generates
    the WordPress content editor field with all the formatting. We have to pass the
    default content and the ID of the content editor. Now we can use the WordPress
    rich content editor to add content to the accordion sections.
  prefs: []
  type: TYPE_NORMAL
- en: We need to save the section data to complete the data capturing process for
    accordions. The saving process is implemented using the `save_post` action and
    the implementation is similar to the property details saving process. The only
    difference is the use of `wp_kses_post` function to filter the section content
    generated by the `wp_editor` function. You can refer to the source code for the
    implementation of the section saving process inside the `WQKM_UI_Components` class.
  prefs: []
  type: TYPE_NORMAL
- en: Preparing accordion content
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We already identified the importance of shortcodes for adding UI elements to
    posts or pages. Therefore, we will be using another shortcode to prepare the content
    for the accordion. Let''s add the following code to the implementation of the
    accordion shortcode:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Here''s what the previous code does:'
  prefs: []
  type: TYPE_NORMAL
- en: We have added a new shortcode called `wqkm_accordian` to the constructor of
    the `WQKM_UI_Components` class. We used custom post types to allow the creation
    of unlimited accordions, and hence we need a way to identify each accordion. So,
    we use the post ID as a shortcode attribute to identify the accordion.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Next, we generate the content sections of accordion by loading the data using
    the ID attribute.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Here, we have used the section title and the section content for each section
    inside a main container. This is the required structure for the chosen accordion
    library. You will have to find the element structure in case you choose different
    library for the implementation.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Finally, we return the output from the shortcode with accordion sections.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now you can create and add an accordion to a post or page using the necessary
    ID. However, like the image slider, you will just see a bunch of HTML sections
    displayed on browser. To enable the accordion functionality, we need to register
    the necessary scripts and styles inside the `load_scripts` function of the main
    class, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'First, we have downloaded and added the `jQuery UI CSS` file to our plugin,
    as it''s not provided within the WordPress core. Then, we have added a custom
    script called `wqkm-accordion.js`, with jQuery and jQuery UI accordion scripts
    as dependencies. The jQuery UI component libraries are available within the WordPress
    core, and hence we can directly call the script handle instead of registering
    the script separately. Then, we can add the following code to the shortcode function
    to enqueue the files:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'We have the accordion script and style included within the shortcode. Finally,
    we have to initialize the accordion by adding the following initialization code
    to the `wqkm-accordion.js` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'The accordion is initialized using the ID of the main container we created
    for the shortcode output. This may vary based on the accordion library of your
    choice. Now we have completed the accordion integration process, and your accordion
    should look similar to the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/7b31dcb2-cbcf-4022-bbe7-055cb270108b.png)'
  prefs: []
  type: TYPE_IMG
- en: As you can see, we can use these UI components in a limited space to display
    a large amount of contents.
  prefs: []
  type: TYPE_NORMAL
- en: Steps for integrating UI components
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Up to this point, we looked at two implementations for integrating the jQuery
    slider and accordion UI components using different data-capturing techniques.
    The implementation may vary based on the type of UI component and its functionality.
    However, the basic process is similar for most of the common UI components. So,
    let''s summarize the keys for integrating any UI component with WordPress:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Identify component data**: Each UI component works on existing data or elements.
    So, we need to identify the data needed to use each UI component and the method
    for storing this data.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Generate component output**: In this step, we have to use the captured data,
    process it, and generate the HTML output needed to enable the features of a UI
    component. Usually, we use a reusable component such as a shortcode or widget
    to add and generate the output for UI components.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Include component libraries**: Most UI components generate their features
    by applying JavaScript or CSS to the generated output. These features of the component
    generally come as an open source library. So, in this step, we need to all the
    necessary scripts and styles for the component, along with the necessary settings.
    In this process, we use `wp_register_style` and `wp_register_script` functions
    to include these resources by adding them inside plugins or themes. Then, you
    can enqueue them conditionally within the main class or inside the UI component
    generation function.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Passing script data**: Some of the UI element libraries directly apples CSS
    or JavaScript features on the generated output. However, some element scripts
    require certain data or settings to initialize the element. In such cases, we
    have to pass the necessary data to necessary scripts using the `wp_localize_script`
    function.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Initialize the element**: Once necessary libraries and HTML output is ready,
    we can initialize the element by using the initialization function of these libraries.
    These initializations generally takes one to a few lines of code. Usually, we
    use a CSS class or HTML element ID on the generated output for this initialization.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Once these steps are completed, you will see the interactive features or styles
    in your UI element. This is the general process for the most common UI elements.
    However, there may be exceptions that require a different process to initialize
    the UI element.
  prefs: []
  type: TYPE_NORMAL
- en: Simplifying development with page builders
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Page builder** is a set of components that simplifies the process of content
    creation or building the features of the site. These components allow developers
    to build complex interfaces in super-quick time by choosing and configuring built-in
    components. Page builders were initially used for simplifying content creation
    with pre-built design elements. However, page builders have now evolved into a
    state where we can use the existing components to add advanced site features such
    as form management, searchable google maps, parallax images, and videos.'
  prefs: []
  type: TYPE_NORMAL
- en: Until recently, developers used the page builders included in themes, as well
    as free and premium page builder plugins. WordPress has introduced a block-based
    content builder called **Gutenberg**. At this stage, Gutenberg editor supports
    content editing with a basic set of elements. Currently, it's nowhere near the
    features offered by popular page builders such as Elementor, Beaver Builder, and
    Visual Composer. However, the future seems bright, as the WordPress team is backing
    the Gutenberg editor by making it a default core feature. So, we will soon see
    more powerful features of the Gutenberg editor, along with the features offered
    by other page builders.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the features of page builders
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As we discussed, page builders offer a wide range of components that can be
    dragged or assigned to any post, page, or custom post type. However, many of these
    page builders provide advanced features beyond using basic built-in components.
    So, it''s important to understand these features to use the existing components,
    as well as making your solutions integrate with page builders. Let''s take a look
    at the main features offered by modern page builders:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Backend and frontend editing**: Usually, we edit or build the site interfaces
    using the backend content editor, and hence we have to switch to frontend to view
    the changes. Most page builders provide frontend editing, allowing previews in
    real time and adjusting them instantly. Also, there is a backend editor, if you
    want to work with other backend features.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Built-in templates**: Many page builders provide built-in template designs
    by using the existing components. So, the developers can use these templates designed
    for common requirements and adjust them as needed without writing a single line
    of code.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Advanced styling**: Each component allows various styling options such as
    margins, paddings, colors and so on. So, you can fine tune the design without
    going into the code.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Responsive design**: This is a must in modern development to cater for different
    devices, such as personal computers, mobiles, tabs, and so on. Usually, we have
    to spend lot of time making our designs fully responsive. Page builder structure
    and components are responsive by default. So, you don''t have to do anything to
    make the content responsive as long as you follow the proper coding standards
    for your own elements.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As you can see, page builder provides a lot of power for building the content
    and design of your site. However, these powerful features also come with some
    limitations. Some of these page builders are completely dependent on shortcodes,
    and hence you will be locked into the plugin. Also, you might experience performance
    issues when using some complex features of page builders. Therefore, you need
    to be responsible with choosing the proper page builder and the features.
  prefs: []
  type: TYPE_NORMAL
- en: Developing components for page builders
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Most popular page builders come with a wide range of built-in components as
    well as additional components using addons. So, we can use the existing components
    to build general purpose WordPress sites. However, when developing advanced applications
    or sites with custom requirements, the default functionality of these components
    may not be sufficient. In such cases, we have to build our own page builder components
    to provide the necessary functionality. We can always create shortcodes and ask
    the clients to use them inside the page builder components. But building our components
    simplifies the process considerably for the client, and hence we have to build
    components whenever necessary.
  prefs: []
  type: TYPE_NORMAL
- en: 'Major page builders provides an API or guide for developing components for
    their plugin. The technique varies for each page builder. So, you need to use
    the documentation to understand and develop a component for each page builder. Developing
    a component from scratch with the necessary explanations is beyond the scope of
    this chapter. However, we will explore the basic steps of component creation using
    the Elementor page builder as the example. Let''s take a look at the main steps
    for building a page builder component:'
  prefs: []
  type: TYPE_NORMAL
- en: Each page builder identifies its components as modules, widgets, blocks, and
    so on. So, there should be a way to register new components for the page builder.
    Elementor uses the `Widget_Base` class and `register_widget_type` function to
    register new components. The other page builders offer similar techniques.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: After registering the component, you need to specify the input fields for capturing
    component data. Most page builders provide different types of input fields to
    capture and save the data for the component. Elementor provides a function called `add_control` on
    the `Widget_Base` class, supporting over 30 different control types. The other
    page builders will have similar functions to add input fields to different field
    types, as well as different data-storing mechanisms.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Finally, we need to provide the output of the component by building the HTML
    code or executing an existing shortcode. Elementor provides a function called `render` for
    retrieving the saved component data and displaying the output. The other page
    builders should have a similar method, with a similar name.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We have used these steps and built a slider component for the Elementor page
    builder. You can find the code for this addon inside the `wpquick-elementor-components` directory
    of the source code for this chapter. The following screenshot previews the component
    generated by the addon with settings:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/09809233-6d65-4b42-adf3-e8d1dbd35719.png)'
  prefs: []
  type: TYPE_IMG
- en: Elementor is one of the most popular and rising page builders at this stage.
    You can access the documentation at [https://developers.elementor.com/creating-an-extension-for-elementor/](https://developers.elementor.com/creating-an-extension-for-elementor/)
    and use the addon code for understanding the step. The process for other page
    builders will be similar, with the support of plugin-specific component creation
    functions.
  prefs: []
  type: TYPE_NORMAL
- en: Simplifying and customizing admin features
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have to use the core features as much as possible to get the maximum benefits
    of using WordPress for site development. This includes the use of frontend theme
    features, as well as the existing backend features, that mainly focuses on post-related
    functionality. So, it's obvious that developers need to customize these features
    to suit the requirements of each website. In this section, we are going to look
    at several customizations of commonly used backend features.
  prefs: []
  type: TYPE_NORMAL
- en: Creating custom dashboard widgets
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We had a brief introduction to the **Dashboard Widget API** in [Chapter 6](e452b581-f38d-4c95-8a41-0c9a54b26a57.xhtml),
    *Practical Usage of WordPress APIs*. Basically, a *dashboard* is a collection
    of widgets built for administration purposes. Unlike frontend theme widgets, we
    don't have an interface for adding or removing admin dashboard widgets. So, we
    have to build custom solutions to build new dashboard widgets as well as remove
    the existing ones. In this section, we are going to look at the process of creating
    a basic dashboard widget.
  prefs: []
  type: TYPE_NORMAL
- en: Registering and building dashboard widgets
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'First, we have to register the dashboard widget by using the `wp_dashboard_setup`
    action, instead of the `widgets_init` we used on the frontend widgets. Consider
    the following code for the widget registration process:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Inside the callback function, we use the `wp_add_dashboard_widget` function
    to register a new widget. The parameters for this function contain a unique widget
    ID, widget title, and the callback function. Then, we have to implement the function
    to display the content for the widget, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Here, we have simplified the process by using a shortcode we developed in earlier
    chapters. Basically, we have a dashboard widget in fewer than 10 lines of code.
    This process is simpler compared to the frontend dashboard widget creation process.
  prefs: []
  type: TYPE_NORMAL
- en: The default dashboard widgets are mostly suitable for blogs. In many circumstances,
    we have to remove the existing widgets and add custom widgets to cater for advanced
    site-specific business requirements. In custom sites, dashboard widgets are frequently
    used for displaying the site statistics, reports, or features that need to be
    executed on a regular basis, without visiting individual screens. You can try
    the existing plugins with dashboard widgets to understand the usage. WooCommerce,
    bbPress, and Easy Digital Downloads are some of the popular plugins with built-in
    custom dashboard widgets.
  prefs: []
  type: TYPE_NORMAL
- en: Customizing backend list tables
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: WordPress provides backend list tables for the main content types. We discussed
    the features of list tables in [Chapter 7](1a709b5f-c476-41f9-bc13-eb5f0541abaa.xhtml),
    *Managing Custom Post Types and Processing Forms*, on custom post types. The default
    features provide data list tables for posts, pages, users, and comments, as well
    as all the registered custom post types. Also, we can extend the core class used
    for list tables and create our own custom data list tables. So, it's important
    to know the existing features as well as customizable features of backend list
    tables. In this section, we are going to look at the some of the common customizations
    on the backend user list. Let's get started.
  prefs: []
  type: TYPE_NORMAL
- en: Creating and executing custom bulk actions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The WordPress list tables contains a dropdown called Bulk Actions in the top
    left-hand section of the list. This feature is used to modify multiple records
    in the table with a single predefined event. We have to choose one or more records,
    select an action from the Bulk Actions dropdown, and click the Apply button to
    complete the process. This is a very useful feature when you want to modify bulk
    records for custom features.
  prefs: []
  type: TYPE_NORMAL
- en: 'The WordPress core actions can be used to modify the Bulk Actions dropdown
    and to include custom actions for our projects. Let''s add the following action
    to the constructor of the `WQKM_Admin_Features` class for understanding the process
    of using custom actions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'This action is used to filter the actions for the users list table. The filter
    consists of the `bulk_action`-prefix followed by the screen name. So, you can
    use the same action for other core list tables by replacing users with the screen
    name for the list. Let''s take a look at the implementation of the custom action:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: In this code, we are adding a custom action to the default backend user list
    by modifying the existing bulk actions list. We have to use a unique slug as the
    array key for this action and define the label as the array value. In this scenario,
    we are building an action that allows us to mark certain users as Featured Users.
    Now you will see a new option in the Bulk Actions dropdown for handling user-featured
    status.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once the records and action is selected, we can click the Apply button to make
    the modifications to the selected records. So, we need to implement the action
    by adding the following action to the constructor of the class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'In this code, we have used `handle_bulk_actions-` filter followed by the screen
    name for user list table. So, let''s take a look at the implementation of the
    custom action:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Here''s what the previous code does:'
  prefs: []
  type: TYPE_NORMAL
- en: This function automatically receives three parameters for the redirect URL,
    the action name, and the list of IDs of the records to be modified.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: First, we check the action and make sure our code executes only for the `wpquick_featured_user`
    action.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Next, we loop through the list of selected user IDs and modify the value to
    mark the user as a featured user. We can use a different action or toggle the
    same action to remove the featured status as well.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Finally, we redirect the user to the list by adding a custom argument to the
    URL called `bulk_featured_users`. This value will be used to filter the request
    and display a custom message using the `bulk_admin_notices` function in the source
    code.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now we have a working custom action for the user list. You can test the feature
    by adding featured status to some of the users and confirming it by checking the
    database values. This is a simple way of modifying or applying custom data to
    multiple records for custom requirements. We can't use input fields for these
    actions, and hence the action should have a fixed feature with predefined values.
  prefs: []
  type: TYPE_NORMAL
- en: Adding custom list columns
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The data list tables contains default set of columns, and these columns vary
    based on the type of the list. In the previous section, we changed the featured
    status of the user. However, we had to use the database to check the value. Instead,
    we can display such important information on the data list table by using custom
    columns. So, in this section, we are going to look at the process of adding custom
    columns to the default users list as well as identifying the necessary hooks for
    other lists. Let''s start by adding the following filter and action to the constructor
    of `WQKM_Admin_Features` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'The `manage_users_columns` filter is used to modify or remove existing columns
    as well as to add new columns to the user list. The following code previews the
    implementation to include the featured status as a column:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Now you should see an additional column in the user list without any data.
    The next step is to display the column data for each user. We have to use the
    `manage_users_custom_column` action to provide the data for our custom column.
    Let''s take a look at the implementation of the callback function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: This function accepts three parameters for the column value, column name, and
    the user ID. We can use these parameters to get the custom column value for the
    selected users. Here, we use `get_user_meta` function as we stored the data on
    `wp_usermeta` table. We can also store these values and display them using custom
    tables. Next, we use a `switch` statement to return the value based on the column.
    It's important to use the `default` case and return the default value, to be compatible
    with other plugins. Now you should see the custom column in the user list with
    the custom values for each user.
  prefs: []
  type: TYPE_NORMAL
- en: Sorting custom column values
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The default list tables provides sorting capabilities for the first column
    and one or more from the remaining columns. However, these are built-in columns
    provided by the WordPress core features. So, we need the ability to sort custom
    column values to effectively use and filter the custom data. WordPress provides
    a built-in filter for specifying sortable columns. Let''s consider the following
    filter and its implementation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'The filter needs to be added inside the constructor of the class. This filter
    accepts the list of existing sortable columns as a parameter. Here, we have added
    the key of our custom column to the sortable columns array and return the list.
    Now you should be able to see a link in custom column to change the sorting value.
    The final step of the process is to change the default query and enable sorting
    on the custom column. Let''s consider the following action and its implementation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s understand the implementation of this function using the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: We can use `pre_user_query` action to modify the default query, just before
    the execution. The `WP_User_Query` object is passed as a parameter to this function.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Next, we check the `orderby` clause of the query using the `query_vars` array
    to make sure our custom code only executes on `featured_user_status` column.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Then, we have to modify the query, staring with the `join` statement on the `from`
    clause to include the `usermeta` table. The modified `where` clause makes sure
    that sorting is only applied to the values of the `featured_user_status` column.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Finally, we change the `orderby` clause to order the list using meta values
    of the `featured_user_status` column.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now the process is complete, and you should be able to click the column title
    to sort the users in both ways using the featured status. The following screenshot
    previews the features we added to the user list:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/4e0c602e-5cd3-4cd6-8786-a6ea8f46edf8.png)'
  prefs: []
  type: TYPE_IMG
- en: You can follow this technique with the necessary filtering to manage more columns
    on the user list.
  prefs: []
  type: TYPE_NORMAL
- en: We looked at the list table customization for the backend user list. Similarly,
    we can apply the same technique to customize the columns of other WordPress list
    tables using necessary actions and filters.
  prefs: []
  type: TYPE_NORMAL
- en: In most scenarios, we need to customize posts and custom post types lists to
    include custom columns. We have to use `manage_edit-{post_type}_columns` filter
    to define the custom columns and the `manage_{post_type}_posts_custom_column` filter
    to add the values for the custom columns. Then, we can use `manage_edit-{post_type}_sortable_columns` filter
    to define sortable columns and use `pre_get_posts` action to modify the query
    for sorting.
  prefs: []
  type: TYPE_NORMAL
- en: So, we need to use these actions and filters whenever necessary to display additional
    data in list tables and avoid the time-consuming visits to the edit section to
    check the values.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The main purpose of using WordPress is to simplify the development process.
    So, we need to understand the process of customizing important backend features.
    Also it's important to use modern user interface components to provide all the
    important in limited space using attractive techniques. We began the chapter by
    understanding the importance of the integration of UI components. So, we integrated
    jQuery Slider and Accordion while using two different data-capturing methods.
    We also looked at the importance of page builders in modern development and the
    steps for developing custom components for page builders. Next, we moved on to
    customizing admin features by building a simple dashboard widget. Finally, we
    looked at the process of adding custom features to built-in WordPress list tables.
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 9](1690ebbf-249c-4892-81db-098b6a9050f5.xhtml), *Enhancing Security,
    Performance, and Maintenance*, we will be completing the content for this book
    by looking at the non-functional aspects of development, such as security, performance,
    testing, and maintenance.
  prefs: []
  type: TYPE_NORMAL
