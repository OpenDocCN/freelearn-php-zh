- en: Discovering Key Modules in Development
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 发现开发中的关键模块
- en: Modern website interfaces are mostly built on the concept of blocks, where the
    site owners can drag and drop reusable components to build the interfaces. UI
    components and page builders play a major role in developing these interfaces.
    Therefore, it's important for developers to have the knowledge of integrating
    any third-party UI component to build amazing interfaces with interactivity. On
    the other hand, WordPress is chosen by many developers due to the existing CMS
    features that accelerate the development process. So, developers need thorough
    knowledge of using backend features as well as customizing the existing features
    for custom requirements.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 现代网站界面大多基于块的概念，网站所有者可以拖放可重复使用的组件来构建界面。UI组件和页面构建器在开发这些界面中扮演着重要角色。因此，对于开发者来说，了解如何集成任何第三方UI组件以构建具有交互性的惊人界面是非常重要的。另一方面，WordPress因其现有的CMS功能而被许多开发者选择，这些功能可以加速开发过程。因此，开发者需要深入了解使用后端功能以及根据定制需求定制现有功能。
- en: In this chapter, we are going to focus on UI component integration as well as
    customization of common backend features. We begin the chapter by integrating
    a jQuery slider to WordPress while using menu pages to capture the data. Then,
    we will integrate another popular component called accordion by using custom post
    types to capture the data. After this, we will look at the basic steps of integrating
    any UI component using the two integrations for Image Slider and accordion. Also,
    we will look at the importance of modern page builders in site development and
    discuss the basics of creating a custom component with any page builder. Finally,
    we will look at the process of customizing backend features by creating a basic
    dashboard widget and modifying list tables to provide custom features.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将重点关注UI组件集成以及常见后端功能的定制。我们首先通过使用菜单页面来捕获数据，将jQuery滑块集成到WordPress中。然后，我们将使用自定义帖子类型来捕获数据，集成另一个流行的组件，称为手风琴。在此之后，我们将查看使用图像滑块和手风琴的两种集成方法来整合任何UI组件的基本步骤。此外，我们还将探讨现代页面构建器在网站开发中的重要性，并讨论使用任何页面构建器创建自定义组件的基础知识。最后，我们将查看通过创建基本仪表板小部件和修改列表表来提供自定义功能的后端功能定制过程。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Integrating UI components
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 集成UI组件
- en: Integrating jQuery image slider
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 集成jQuery图像滑块
- en: Integrating jQuery accordion
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 集成jQuery手风琴
- en: Identifying the steps for integrating UI components
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 确定集成UI组件的步骤
- en: Understanding the use of page builders
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解页面构建器的使用
- en: Creating custom dashboard widgets
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建自定义仪表板小部件
- en: Customizing backend list tables
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定制后端列表表
- en: By the end of this chapter, you will have the ability to customize backend admin
    features as well as integrate UI components into sites with the latest trending
    methods.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，您将能够使用最新的趋势方法定制后端管理功能以及将UI组件集成到网站中。
- en: Technical requirements
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: You will be required to have WordPress 4.9.8 installed to follow this procedure.
    Even if you
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 为了遵循此程序，您需要安装WordPress 4.9.8。即使您有WordPress的更高版本，描述的示例也应无重大问题地工作。
- en: have a later version of WordPress, the described examples should work with no
    significant problems.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您有WordPress的更高版本，描述的示例应无重大问题地工作。
- en: 'The code files of this chapter can be found on GitHub:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的代码文件可以在GitHub上找到：
- en: '[https://github.com/PacktPublishing/WordPress-Development-Quick-Start-Guide/tree/master/Chapter08](https://github.com/PacktPublishing/WordPress-Development-Quick-Start-Guide/tree/master/Chapter08)'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/PacktPublishing/WordPress-Development-Quick-Start-Guide/tree/master/Chapter08](https://github.com/PacktPublishing/WordPress-Development-Quick-Start-Guide/tree/master/Chapter08)'
- en: 'Check out the following video to see the code in action:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 查看以下视频，以查看代码的实际效果：
- en: '[http://bit.ly/2yGYX03](http://bit.ly/2yGYX03)'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: '[http://bit.ly/2yGYX03](http://bit.ly/2yGYX03)'
- en: UI components
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: UI组件
- en: Modern websites are built on top of interactive UI elements. Many premium WordPress
    themes include a wide range of UI components with the support of open source JavaScript
    and CSS libraries. These UI components attract users to a site by simplifying
    the interfaces as well as providing large content in a limited space. Among hundreds
    of UI elements, we find image sliders and galleries, tabs being the most popular
    ones. As a developer, you need to use or build these components to keep up to
    date with rising UI requirements in modern development. So, it's important to
    understand the basic process of integrating any UI component into WordPress using
    plugins or themes. In this section, we are going to look at the integration of
    two UI components. Let’s get started.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 现代网站建立在交互式UI元素之上。许多高级WordPress主题包括由开源JavaScript和CSS库支持的广泛UI组件。这些UI组件通过简化界面以及在小空间内提供大量内容来吸引用户。在数百个UI元素中，我们发现图片滑块和相册、标签是最受欢迎的。作为开发者，您需要使用或构建这些组件以跟上现代开发中日益增长的UI需求。因此，了解使用插件或主题将任何UI组件集成到WordPress中的基本过程非常重要。在本节中，我们将探讨两个UI组件的集成。让我们开始吧。
- en: Integrating the jQuery image slider
  id: totrans-21
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 集成jQuery图片滑块
- en: The image sliders and galleries are the most popular UI elements in WordPress
    sites. You can visit the [wordpress.org](http://wordpress.org) plugin directory
    or a premium marketplace such as Codecanyon to understand the amount of downloads
    and purchases of such plugins. We can use these sliders for displaying a set of
    basic images, as well as to display advanced content and images to promote your
    products, services, and features.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 图片滑块和相册是WordPress网站中最受欢迎的UI元素。您可以访问[wordpress.org](http://wordpress.org)插件目录或像Codecanyon这样的高级市场，以了解此类插件的下载量和购买量。我们可以使用这些滑块来显示一组基本图片，以及显示高级内容和图片以推广您的产品、服务和功能。
- en: In this section, we are going to use Basic jQuery Slider ([http://basicslider.com/](http://basicslider.com/))
    to explain the process of integrating an Image Slider. We will be creating a single
    Image Slider to display product images in the home page of the site or any other
    preferred location.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将使用Basic jQuery滑块([http://basicslider.com/](http://basicslider.com/))来解释集成图片滑块的过程。我们将创建一个单独的图片滑块，用于在网站的首页或其他任何首选位置显示产品图片。
- en: Image Slider plugins give you the ability to create multiple reusable sliders
    using custom post types or custom forms. In this scenario, we are only focusing
    on a single predefined slider.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 图片滑块插件使您能够使用自定义帖子类型或自定义表单创建多个可重复使用的滑块。在这种情况下，我们只关注一个预定义的滑块。
- en: Before starting the implementation, we have to create another plugin for this
    chapter. We are going to name it `WPQuick Key Modules` in a directory called `wpquick-key-modules`.
    We will be using this plugin for the implementation of most of the features discussed
    in this chapter. The plugin will have the same structure as the previous plugins,
    with a main class initializing all the other features and classes.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 在开始实施之前，我们必须为这一章创建另一个插件。我们将将其命名为“WPQuick Key Modules”，并将其放在名为“wpquick-key-modules”的目录中。我们将使用此插件来实现本章讨论的大多数功能。该插件将与之前的插件具有相同的结构，其中主类初始化所有其他功能和类。
- en: Building a product image slider
  id: totrans-26
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建产品图片滑块
- en: 'We can use sliders to display any type of content, with the common type of
    content being images. The first step of integrating any UI component is the process
    of capturing the data. In this scenario, the required data will be a set of images.
    So, we need to build an interface to let the administrator upload a set of images
    for the slider. We have two options for creating an interface for such requirements:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用滑块来显示任何类型的内容，其中最常见的类型是图片。集成任何UI组件的第一步是数据捕获的过程。在这种情况下，所需的数据将是一组图片。因此，我们需要构建一个界面，让管理员上传一组图片用于滑块。我们有两种为这种需求创建界面的选择：
- en: '**Menu pages**: We can use the `add_menu_page` function to create a new menu
    page for the features of our plugin. This will be a top-level menu item in the
    WordPress admin menu with the ability to support sub menu pages. This is suitable
    when you need to highlight the menu of your plugin as well as create different
    menu pages for various features of the plugin. More details about the `add_menu_page`
    function are available at [https://developer.wordpress.org/reference/functions/add_menu_page/](https://developer.wordpress.org/reference/functions/add_menu_page/).'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**菜单页面**：我们可以使用`add_menu_page`函数来为我们的插件创建一个新的菜单页面。这将是一个WordPress管理员菜单中的顶级菜单项，具有支持子菜单页面的能力。当你需要突出显示你的插件菜单以及为插件的各个功能创建不同的菜单页面时，这非常适合。关于`add_menu_page`函数的更多详细信息，请参阅[https://developer.wordpress.org/reference/functions/add_menu_page/](https://developer.wordpress.org/reference/functions/add_menu_page/)。'
- en: '**Options pages**: We can use the `add_options_page` function to createa new
    options page for custom settings. This function will create a sub-level menu item
    on the Settings menu item. However, it doesn''t support further levels, and hence
    it will be difficult to use for plugins that require multiple menu pages. This
    is useful for adding general site specific settings rather than plugin settings.
    More details about the `add_options_page` function is available at [https://developer.wordpress.org/reference/functions/add_options_page/](https://developer.wordpress.org/reference/functions/add_options_page/).'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**选项页面**：我们可以使用`add_options_page`函数来创建一个新的选项页面用于自定义设置。这个函数将在设置菜单项下创建一个子级菜单项。然而，它不支持更高级别的菜单，因此对于需要多个菜单页面的插件来说，使用起来可能会有困难。这对于添加通用的站点特定设置而不是插件设置很有用。关于`add_options_page`函数的更多详细信息，请参阅[https://developer.wordpress.org/reference/functions/add_options_page/](https://developer.wordpress.org/reference/functions/add_options_page/)。'
- en: In this scenario, we are going to choose menu pages for the image uploading
    interface, as this is a plugin-specific custom requirement. Let's build a menu
    page to upload the images.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个场景中，我们将选择用于图片上传界面的菜单页面，因为这是一个插件特定的自定义要求。让我们创建一个用于上传图片的菜单页面。
- en: Creating a plugin menu page
  id: totrans-31
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建插件菜单页面
- en: 'WordPress provides built-in functions to add menu pages through plugins. We
    can add the interfaces as main- menu items or as sub-menu items. Create a class
    called `WQKM_UI_Components` inside the classes directory of our plugin. Then,
    we can do the usual file inclusion and object creation within the `includes` and
    `instance` functions of the main class of our plugin. Next, we can add the following
    line of code within  `admin_menu`  action to register a new menu page:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: WordPress通过插件提供了内置函数来添加菜单页面。我们可以将界面添加为主菜单项或子菜单项。在我们的插件类目录中创建一个名为`WQKM_UI_Components`的类。然后，我们可以在插件主类的`includes`和`instance`函数中执行常规的文件包含和对象创建。接下来，我们可以在`admin_menu`动作中添加以下代码行来注册一个新的菜单页面：
- en: '[PRE0]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The first two parameters of this function define titles for the menu page and
    the menu item. The third parameter defines the capability to load this page. Here,
    we have used `manage_options` as the capability to restrict it to the administrator.
    You can change this capability based on the person responsible for using this
    interface. The fourth parameter defines a unique slug to access the menu item
    from the URL. The final parameter defines the callback function to generate the
    content for this interface. These are the main parameters used for this function.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数的前两个参数定义了菜单页面的标题和菜单项的标题。第三个参数定义了加载此页面的能力。在这里，我们使用了`manage_options`作为能力来限制它只对管理员开放。你可以根据负责使用此界面的人员来更改这个能力。第四个参数定义了一个唯一的slug，可以通过URL访问菜单项。最后一个参数定义了用于生成此界面内容的回调函数。这些都是这个函数使用的主要参数。
- en: 'Now we need to implement the callback function to display the necessary fields
    to upload the images to the slider. Let''s take a look at the structure of the `ui_settings`
    function:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们需要实现回调函数来显示上传图片到滑块的必要字段。让我们看看`ui_settings`函数的结构：
- en: '[PRE1]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'We have already discussed a callback function for template loading in the previous
    chapters, and hence we will not be discussing the code in detail. First, we define
    the global variables for holding the main instance of our plugin and passing the
    data to templates. Then, we load the custom template using the technique we used
    in the previous chapters, with the support of the custom template loader. You
    can refer to the source code for the complete implementation. Next, we have to
    build the custom template to upload files, as shown in the following code:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经在之前的章节中讨论了用于模板加载的回调函数，因此我们将不会详细讨论代码。首先，我们定义全局变量以保存我们插件的主要实例并将数据传递到模板中。然后，我们使用我们在上一章中使用的技术，借助自定义模板加载器加载自定义模板。您可以参考源代码以获取完整的实现。接下来，我们必须构建用于上传文件的自定义模板，如下面的代码所示：
- en: '[PRE2]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Let’s understand the structure of this template for handling image uploads:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们了解此模板的结构，用于处理图像上传：
- en: First, we define the global variable to accept the template data passed from
    the `WQKM_UI_Components` class. Initially, this variable will be empty, as we
    don't have any template data or settings.
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们定义一个全局变量以接受从`WQKM_UI_Components`类传递的模板数据。最初，此变量将为空，因为我们没有模板数据或设置。
- en: Then, we have to define a form to enable data submissions. Inside the form,
    we have an empty container called `wqkm-slider-msg` to handle the form error and
    success messages.
  id: totrans-41
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们必须定义一个表单来启用数据提交。在表单内部，我们有一个名为`wqkm-slider-msg`的空容器，用于处理表单的错误和成功消息。
- en: Next, we add a file input field to select and upload the images for the slider.
    We also added a DIV element called `wqkm-slider-images-panel`, inline with the
    file field to display the current images uploaded to the slider.
  id: totrans-42
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们添加一个文件输入字段来选择和上传滑块的图像。我们还添加了一个名为`wqkm-slider-images-panel`的DIV元素，与文件字段内联，以显示上传到滑块的当前图像。
- en: Finally, we add a button instead of a submit button, as we will be using AJAX
    to handle the form submission.
  id: totrans-43
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们添加一个按钮而不是提交按钮，因为我们将通过AJAX处理表单提交。
- en: Now the interface is prepared to upload images to the slider. You can access
    this interface by using the `UI Component Settings` menu item from the main menu.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 现在界面已准备好上传图像到滑块。您可以通过使用主菜单中的`UI组件设置`菜单项来访问此界面。
- en: Saving slider images using AJAX
  id: totrans-45
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用AJAX保存滑块图像
- en: We can use normal post submissions as well as AJAX submissions, as this is a
    backend screen without any other dependencies. However, AJAX gives better user
    experience, and hence we will be submitting the form data through AJAX. First,
    we have to add a new script using the `load_admin_scripts` function to handle
    the AJAX request for saving slider images. We will be using the exact same code
    used for the `WooCommerce Product Files` plugin, and hence you can refer to the
    main file inside the source code directory for the implementation of the `load_admin_scripts`
    function.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用常规的POST提交以及AJAX提交，因为这是一个没有其他依赖项的后端屏幕。然而，AJAX提供了更好的用户体验，因此我们将通过AJAX提交表单数据。首先，我们必须使用`load_admin_scripts`函数添加一个新的脚本，以处理保存滑块图像的AJAX请求。我们将使用与`WooCommerce
    Product Files`插件相同的代码，因此您可以参考源代码目录中的主文件以了解`load_admin_scripts`函数的实现。
- en: 'Next, we have to handle the form submission process using AJAX. The code for
    the file form submission is available inside the `wqkm-admin.js` file of the source
    codes directory. The implementation will be the same as the one we used in the `wqwpf-admin.js`
    file of the `WQWPF Product Files` plugin, except for the following differences:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们必须使用AJAX处理表单提交过程。文件表单提交的代码可在源代码目录的`wqkm-admin.js`文件中找到。实现将与我们在`WQWPF Product
    Files`插件的`wqwpf-admin.js`文件中使用的实现相同，除了以下差异：
- en: In this case, we have get the custom form using the form ID, instead of using
    a built-in post-submission form
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在这种情况下，我们通过表单ID获取自定义表单，而不是使用内置的POST提交表单
- en: We use the `wqkm_save_slider_images` action instead of the `wqwpf_save_product_files`
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们使用`wqkm_save_slider_images`操作代替`wqwpf_save_product_files`
- en: We remove the post-ID parameter, as we are not submitting a form related to
    a post
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们移除了post-ID参数，因为我们不是提交与帖子相关的表单
- en: 'Now we come to the final part of the image-saving process by uploading and
    capturing the file data. We have to begin by adding the following action to the
    constructor of the `WQKM_UI_Components` class:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来到图像保存过程的最后部分，通过上传和捕获文件数据。我们必须首先在`WQKM_UI_Components`类的构造函数中添加以下操作：
- en: '[PRE3]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'This process is only executed by the logged users, and hence we have omitted
    the `wp_ajax_nopriv` action. Let’s take a look at the implementation of the `save_slider_images`
    function:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 此过程仅由登录用户执行，因此我们省略了`wp_ajax_nopriv`动作。让我们看看`save_slider_images`函数的实现：
- en: '[PRE4]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Here''s what the previous code does:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码做了什么：
- en: We begin the function by retrieving the nonce value from the POST request and
    assigning the ID of the logged-in user.
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们从POST请求中检索nonce值并将其分配给登录用户的ID。
- en: Then, we upload the images in the request using the `process_file_upload` function,
    after completing the nonce verification. We have made a copy of the `process_file_upload`
    function from the **Post Attachments** plugin developed earlier. The only difference
    is the use of image-specific file types instead of the document file types we
    used earlier.
  id: totrans-57
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们在完成nonce验证后，使用`process_file_upload`函数上传请求中的图片。我们已经从之前开发的**Post Attachments**插件中复制了`process_file_upload`函数。唯一的区别是使用图像特定的文件类型，而不是我们之前使用的文档文件类型。
- en: Once the images are uploaded, we use the `get_option` function to retrieve the
    existing images. Then, we add the uploaded image and save the new image set using
    `update_option`. In this scenario, we have stored slider images in the `wp_options`
    table, as it was a predefined slider. In scenarios where we need multiple dynamic
    sliders, we have to use the `wp_posts` table or a custom table to store this data.
  id: totrans-58
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦图片上传，我们使用`get_option`函数检索现有图片。然后，我们添加上传的图片并使用`update_option`保存新的图片集。在这种情况下，我们已在`wp_options`表中存储滑块图片，因为它是一个预定义的滑块。在需要多个动态滑块的情况下，我们必须使用`wp_posts`表或自定义表来存储这些数据。
- en: Finally, we traverse through the images list and generate the HTML for images
    to be sent as part of the response for an AJAX request. In the AJAX request, we
    have to use the necessary keys and display the existing images list inline with
    the image upload field.
  id: totrans-59
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们遍历图片列表并为作为AJAX请求响应一部分的图片生成HTML。在AJAX请求中，我们必须使用必要的键并将现有图片列表内联显示在图片上传字段中。
- en: Now we have captured the necessary data required for our image slider component.
    The next step is to use this data along with the necessary scripts to generate
    the UI component.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经捕获了图像滑块组件所需的所有必要数据。下一步是使用这些数据以及必要的脚本生成UI组件。
- en: Preparing slider images
  id: totrans-61
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备滑块图片
- en: 'We need to prepare the HTML code to include the slider images with the necessary
    containers. The element structure for each slider varies based on the library.
    Therefore, we need to refer to the documentation of the slider JavaScript library
    and find out the expected structure. So, we have to visit [http://basicslider.com/](http://basicslider.com/)
    and go to the Markup section. This section explains the required elements to implement
    the slider:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要准备HTML代码以包含滑块图片和必要的容器。每个滑块的元素结构根据库而异。因此，我们需要参考滑块JavaScript库的文档，找出预期的结构。所以，我们必须访问[http://basicslider.com/](http://basicslider.com/)并转到标记部分。本部分解释了实现滑块所需的元素：
- en: '[PRE5]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Now we have to use this structure and add the slider images inside `<li>` elements.
    We can directly add the HTML to a WordPress post or a page, to display a slider.
    However, we may need to reuse the slider, and hence it is always a good option
    to implement it as a shortcode or a widget. The shortcode is the perfect solution,
    as it can be also included within widgets. Let''s start the implementation by
    adding a shortcode to the constructor of the `WQKM_UI_Components` class:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们必须使用这个结构，并在`<li>`元素内添加滑块图片。我们可以直接将HTML添加到WordPress帖子或页面中，以显示滑块。然而，我们可能需要重用滑块，因此将其实现为短代码或小工具始终是一个好选择。短代码是完美的解决方案，因为它也可以包含在小工具中。让我们从向`WQKM_UI_Components`类的构造函数中添加短代码开始实现：
- en: '[PRE6]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Now we can implement the shortcode callback function to use the uploaded images
    and generate the HTML structure required for the slider. Consider the following
    code:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以实现短代码回调函数，以使用上传的图片并生成滑块所需的HTML结构。考虑以下代码：
- en: '[PRE7]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: We begin the function by defining the available shortcode attributes and their
    default values. Here, we have only used the `width` and the `height` of the slider
    as settings. You may need to define more settings depending on the image slider
    library of your choice. Then, we retrieve the list of slider images using the `get_option`
    function with the `wqkm_slider_images` key. Finally, we traverse through the images
    and add the image HTML within the `<li>` elements while using the main `<ul>`
    and `<div>` containers to initialize the slider.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从定义可用的短代码属性及其默认值开始函数。在这里，我们只使用了滑块的 `width` 和 `height` 作为设置。你可能需要根据你选择的图片滑块库定义更多设置。然后，我们使用
    `get_option` 函数和 `wqkm_slider_images` 键检索滑块图片列表。最后，我们遍历图片，在 `<li>` 元素内添加图片 HTML，同时使用主要的
    `<ul>` 和 `<div>` 容器来初始化滑块。
- en: Once the shortcode is added to a post or page, you will see a list of images
    as bullet points, without any sliding functionality.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦短代码被添加到帖子或页面中，你将看到作为项目符号的图片列表，没有任何滑动功能。
- en: Integrating jQuery slider
  id: totrans-70
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 集成 jQuery 滑块
- en: 'This is the final part of the integration, where we apply the functionality
    of JavaScript or CSS libraries to initialize the features of the UI component.
    So, we need to understand the required library files and the order of inclusion.
    The required files are shown in the **Usage** section of [http://basicslider.com/](http://basicslider.com/).
    So, we have to download the necessary libraries and add them within our plugin.
    Once the files are added, we can use the following script and style registering
    code inside the `load_scripts` function of the main class:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 这是集成的最后一部分，我们将 JavaScript 或 CSS 库的功能应用于初始化 UI 组件的功能。因此，我们需要了解所需的库文件及其包含顺序。所需的文件在
    [http://basicslider.com/](http://basicslider.com/) 的 **用法** 部分中显示。因此，我们必须下载必要的库并将它们添加到我们的插件中。一旦文件被添加，我们就可以在主类的
    `load_scripts` 函数中使用以下脚本和样式注册代码：
- en: '[PRE8]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: We have included the `bjqs.css` and `demo.css` files for styles and the `bjqs-1.3.js`
    file for scripts with jQuery as a dependency. The third line registers a plugin-specific
    custom script to initialize the slider. So, we have to use both the jQuery and
    the slider library as dependencies.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 我们包含了 `bjqs.css` 和 `demo.css` 文件用于样式，以及 `bjqs-1.3.js` 文件用于脚本，jQuery 作为依赖项。第三行注册了一个插件特定的自定义脚本以初始化滑块。因此，我们必须将
    jQuery 和滑块库作为依赖项使用。
- en: Now we need to include these libraries to WordPress requests. We can use the `wp_enqueue_style`
    and the `wp_enqueue_script` functions along with registration code to include
    the files. However, it means these files will be included on every request, even
    when there are no image sliders in pages. As a solution, we can include them inside
    the shortcode function, just after the default values for the shortcode attributes.
    You can refer to the source code for the inclusion of these files.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们需要将这些库包含到 WordPress 请求中。我们可以使用 `wp_enqueue_style` 和 `wp_enqueue_script`
    函数以及注册代码来包含这些文件。然而，这意味着这些文件将在每个请求中包含，即使页面上没有图片滑块。作为一个解决方案，我们可以在短代码属性的默认值之后将这些文件包含在短代码函数中。你可以参考源代码以了解这些文件的包含方式。
- en: 'Then, we come to the final step, where we initialize the component using the
    necessary scripts. You can refer to the **Activation** section of [http://basicslider.com/](http://basicslider.com/)
    to understand the initialization process, as shown in the following code. This
    code should be added to the `wqkm-front.js` custom script file:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们来到最后一步，使用必要的脚本初始化组件。你可以参考 [http://basicslider.com/](http://basicslider.com/)
    的 **激活** 部分，了解初始化过程，如下面的代码所示。此代码应添加到 `wqkm-front.js` 自定义脚本文件中：
- en: '[PRE9]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: In this library, `bjqs` acts as the initialization function. We use it on the
    container with the ID `#banner-fade`. We have also assigned the shortcode attribute
    values for `width` and `height` using the data we added with the `wp_localize_script`
    function. Now you can refresh the browser and see an image slider, instead of
    the bullet list.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个库中，`bjqs` 作为初始化函数。我们将其应用于具有 ID `#banner-fade` 的容器。我们还使用 `wp_localize_script`
    函数添加的数据为 `width` 和 `height` 分配了短代码属性值。现在你可以刷新浏览器，看到图片滑块，而不是项目符号列表。
- en: This is a very basic slider with basic functionality. You can find more advanced
    sliders with images, content, videos, and some amazing effects. You can try different
    sliders, as the process of integration is the same, regardless of the slider.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个非常基本的滑块，具有基本功能。你可以找到更多具有图片、内容、视频和一些惊人效果的先进滑块。你可以尝试不同的滑块，因为无论滑块如何，集成过程都是相同的。
- en: Reusing the slider as a widget
  id: totrans-79
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 重复使用滑块作为小部件
- en: We had a brief introduction to widgets and their role in WordPress. Widgets
    was intended to add blocks of features to the sidebar of the site. However, with
    modern themes and widget areas, widgets can be considered as a reusable block
    of features similar to shortcodes. So, we are going to look at the process of
    building a frontend widget in WordPress. Let's start by adding a new file to the
    `classes` directory of our plugin with a class called `WQKM_Product_Slider_Widget`.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 我们对小部件及其在WordPress中的作用进行了简要介绍。小部件的目的是向网站的侧边栏添加功能块。然而，随着现代主题和小部件区域的出现，小部件可以被视为类似于短代码的可重复使用的功能块。因此，我们将查看在WordPress中构建前端小部件的过程。让我们首先在我们的插件
    `classes` 目录中添加一个名为 `WQKM_Product_Slider_Widget` 的新文件。
- en: 'In this scenario, we will be building a widget to display the product slider
    created in the previous section. So, we can reuse the shortcode functionality
    for this widget. Let''s take a look at the implementation of the widget, using
    the following code:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 在此场景中，我们将构建一个显示在上一节中创建的产品滑块的小部件。因此，我们可以为这个小部件重用短代码功能。让我们看一下以下代码中小部件的实现：
- en: '[PRE10]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'WordPress uses the `WP_Widget` class as the base for handling the widget functionality.
    All the widgets, including the core widgets, should extend this class to use the
    widget functionality. Therefore, we have extended this class in our custom `WQKM_Product_Slider_Widget`
    class declaration. Now we can go though the main functions of a widget using the
    following steps:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: WordPress使用 `WP_Widget` 类作为处理小部件功能的基础。所有的小部件，包括核心小部件，都应该扩展这个类以使用小部件功能。因此，我们在自定义的
    `WQKM_Product_Slider_Widget` 类声明中扩展了这个类。现在我们可以通过以下步骤查看小部件的主要功能：
- en: '`constructor`: We have to use this function to call the constructor of the
    parent `WP_Widget` class, with the necessary parameters. In this case, we have
    used a unique ID, title, and a description.'
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`constructor`: 我们必须使用此函数来调用父 `WP_Widget` 类的构造函数，并使用必要的参数。在这种情况下，我们使用了一个唯一的ID、标题和描述。'
- en: '`widget`: This function is used to generate the output of the widget in the
    frontend. Here, we have used `wqkm_product_slider` shortcode to generate the output
    for the widget. You can use a shortcode or call a function to generate the output.
    The `$instance` variable contains all the settings for the widget, added to the
    backend. So, we are using the width and height settings as attributes to the shortcode.
    You may also notice the use of the `$args[''before_widget'']` and the `$args[''before_widget'']`
    statements. These are a predefined set of arguments passed to the widget and the
    values of these arguments are specified when registering the widgets. These arguments
    are useful for adding common content before or after each widget.'
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`widget`: 此函数用于在前端生成小部件的输出。在这里，我们使用了 `wqkm_product_slider` 短代码来生成小部件的输出。你可以使用短代码或调用一个函数来生成输出。`$instance`
    变量包含所有小部件的设置，这些设置添加到后端。因此，我们使用宽度和高度设置作为短代码的属性。你可能也会注意到对 `$args[''before_widget'']`
    和 `$args[''after_widget'']` 语句的使用。这些是一组预定义的参数，传递给小部件，这些参数的值在注册小部件时指定。这些参数对于在前后每个小部件添加常见内容非常有用。'
- en: '`form`: This function is used to display the form to capture the settings for
    the widget. We used width and height in the widget function, and hence we need
    settings to define those values. First, we get the existing values for the settings
    using the `$instance` variable passed automatically to this function. Then, we
    generate the input fields for the width and height settings. You may notice the
    use of the `get_field_id` and the `get_field_name` functions. These are functions
    defined in the core `WP_Widget` class to provide access to the widget details
    in a standard way. You should always use these functions without hard-coding names
    and IDs.'
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`form`: 此函数用于显示表单以捕获小部件的设置。我们在小部件函数中使用了宽度和高度，因此我们需要设置来定义这些值。首先，我们使用自动传递给此函数的
    `$instance` 变量获取设置的现有值。然后，我们生成宽度和高度设置的输入字段。你可能注意到了对 `get_field_id` 和 `get_field_name`
    函数的使用。这些是在核心 `WP_Widget` 类中定义的函数，用于以标准方式提供对小部件细节的访问。你应该始终使用这些函数，而不是硬编码名称和ID。'
- en: '`Update`: This function is used to save or update the settings data to the
    database. Once the Save button of a widget is clicked, this function will be called
    with the old values, as well as the submitted new values. We have to make the
    necessary validations and assign the new values to the `$instance` variable with
    the respective keys. Then, the WordPress core widget class will automatically
    save the values in the `$instance` variable.'
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`更新`：此函数用于将设置数据保存或更新到数据库中。一旦点击了小部件的“保存”按钮，此函数将使用旧值以及提交的新值被调用。我们必须进行必要的验证并将新值分配给具有相应键的`$instance`变量。然后，WordPress核心小部件类将自动将值保存到`$instance`变量中。'
- en: 'This is the standard process for building any custom widget. Once the widget
    class is created, you have to use these four functions to generate the necessary
    settings and output for the widget. Even though we have completed creating the
    widget, it will not be visible in the Appearance | Widgets section. We have to
    register new widgets, before they appear in the widgets section. Let’s consider
    the following code for registering our widget:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 这是构建任何自定义小部件的标准流程。一旦创建了小部件类，你必须使用这四个函数来生成小部件所需的设置和输出。尽管我们已经完成了小部件的创建，但它不会在“外观
    | 小部件”部分中可见。我们必须在它们出现在小部件部分之前注册新小部件。让我们考虑以下用于注册我们小部件的代码：
- en: '[PRE11]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: First, we need to include the file inside the `includes` function of the main
    class. Then, we can add the `widgets_init` action to the constructor of the `WQKM_Admin_Features`
    class. Finally, we use `register_widget` with the class name of the widget inside
    the callback function to register the new widget. Now you should be able to use
    the new widget to add the product image slider to your sidebar.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要在主类的`includes`函数中包含该文件。然后，我们可以在`WQKM_Admin_Features`类的构造函数中添加`widgets_init`动作。最后，我们在回调函数中使用`register_widget`和类名来注册新小部件。现在你应该能够使用这个新小部件将产品图片滑块添加到你的侧边栏中。
- en: Integrating jQuery accordion
  id: totrans-91
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 集成jQuery手风琴
- en: In this section, we are going to look at the integration of another popular
    UI component called **Accordion**. The accordion is a component that allows you
    to display a large amount of content within a limited space using collapsible
    sections. We have chosen the accordion component of the **jQuery UI** library
    ([https://jqueryui.com/accordion/](https://jqueryui.com/accordion/)) as a basic
    solution. You can find many advanced accordion component libraries.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将探讨另一个流行的UI组件——**手风琴**的集成。手风琴是一个组件，允许你通过可折叠的部分在有限的空间内显示大量内容。我们选择了**jQuery
    UI**库中的手风琴组件（[https://jqueryui.com/accordion/](https://jqueryui.com/accordion/））作为基本解决方案。你可以找到许多高级手风琴组件库。
- en: In the image sliders section, we used a menu page to capture data, and limited
    it to a single fixed-image slider. However, it’s also important to have the ability
    to use same component with different content in various places on the site. So,
    we are going to build accordions with the ability to create unlimited components
    with dynamic content. We can either use custom post types and store the data in
    a `wp_posts` table, or we can use a custom table. Since we are developing a UI
    element, we are going to use custom post types to simplify the process. Let’s
    get started.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 在图片滑块部分，我们使用了一个菜单页面来捕获数据，并将其限制为单个固定的图片滑块。然而，在网站的各个地方使用相同组件并具有不同内容的能力也同样重要。因此，我们将构建具有创建无限组件和动态内容能力的手风琴。我们可以使用自定义文章类型并将数据存储在`wp_posts`表中，或者我们可以使用自定义表。由于我们正在开发一个UI元素，我们将使用自定义文章类型来简化流程。让我们开始吧。
- en: Creating an accordion model and capturing data
  id: totrans-94
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建手风琴模型并捕获数据
- en: We have chosen to use custom post types for accordions. Therefore, we need to
    register a new custom post type by using the `register_post_type` function with
    necessary settings. We already created a custom post type and discussed the process
    in previous chapters, while working with the property post type. Therefore, you
    can refer to the `WQKM_UI_Components` class inside the source code directory to
    understand the registration.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 我们选择使用自定义文章类型来构建手风琴。因此，我们需要使用带有必要设置的`register_post_type`函数注册一个新的自定义文章类型。我们已经在之前的章节中创建了一个自定义文章类型并讨论了与属性文章类型一起工作的过程。因此，你可以参考源代码目录中的`WQKM_UI_Components`类来了解注册过程。
- en: Unlike properties, accordions are not intended to be displayed as individual
    posts or to achieve page items. Instead, we use them to capture the data to be
    reused in UI elements within posts or pages. Therefore, we have to set the `public`
    attribute to `false` while creating the custom post type. This setting makes sure
    that the accordions are not publicly visible as an individual post type.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
- en: 'Once the post type is registered, we need to use metaboxes to include the necessary
    fields and capture the data for accordions. The accordion has many sections with
    dynamic content. So, we need text area fields to capture the content for each
    section. Let''s start by adding a metabox to accordions:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Here, we have registered a new meta box for the accordion post type. The `add_meta_boxes`
    action and the post type initialization can be found inside the constructor of
    the `WQKM_UI_Components` class. Now we need to implement the callback function
    using the following code:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: We begin the function by defining the global variables and adding the post type
    and nonce to the global template data variable. Then, we get the existing data
    for the accordion sections using the `get_post_meta` function. Here, we have only
    included one section. You can find three sections in the source code.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
- en: We have fixed the accordion sections to three, to simplify the development.
    Ideally, we should allow administrators to dynamically add an unlimited number
    of sections for accordions.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we load a custom template for the input fields of the accordion sections.
    The template for the accordion meta boxes can be found inside the `accordion-meta.php`
    file in the `templates` directory.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
- en: 'This template is similar to the one used for the `Properties` post type, and
    hence it''s self-explanatory. However, you may notice the use of the following
    line of code instead of the code for text areas:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: We could have used text area fields for the accordion section. However, these
    sections may contain a considerable amount of HTML, and hence using a text area
    can be difficult. As a solution, we used the `wp_editor` function that generates
    the WordPress content editor field with all the formatting. We have to pass the
    default content and the ID of the content editor. Now we can use the WordPress
    rich content editor to add content to the accordion sections.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
- en: We need to save the section data to complete the data capturing process for
    accordions. The saving process is implemented using the `save_post` action and
    the implementation is similar to the property details saving process. The only
    difference is the use of `wp_kses_post` function to filter the section content
    generated by the `wp_editor` function. You can refer to the source code for the
    implementation of the section saving process inside the `WQKM_UI_Components` class.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
- en: Preparing accordion content
  id: totrans-108
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We already identified the importance of shortcodes for adding UI elements to
    posts or pages. Therefore, we will be using another shortcode to prepare the content
    for the accordion. Let''s add the following code to the implementation of the
    accordion shortcode:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Here''s what the previous code does:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
- en: We have added a new shortcode called `wqkm_accordian` to the constructor of
    the `WQKM_UI_Components` class. We used custom post types to allow the creation
    of unlimited accordions, and hence we need a way to identify each accordion. So,
    we use the post ID as a shortcode attribute to identify the accordion.
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Next, we generate the content sections of accordion by loading the data using
    the ID attribute.
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Here, we have used the section title and the section content for each section
    inside a main container. This is the required structure for the chosen accordion
    library. You will have to find the element structure in case you choose different
    library for the implementation.
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Finally, we return the output from the shortcode with accordion sections.
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now you can create and add an accordion to a post or page using the necessary
    ID. However, like the image slider, you will just see a bunch of HTML sections
    displayed on browser. To enable the accordion functionality, we need to register
    the necessary scripts and styles inside the `load_scripts` function of the main
    class, as shown in the following code:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'First, we have downloaded and added the `jQuery UI CSS` file to our plugin,
    as it''s not provided within the WordPress core. Then, we have added a custom
    script called `wqkm-accordion.js`, with jQuery and jQuery UI accordion scripts
    as dependencies. The jQuery UI component libraries are available within the WordPress
    core, and hence we can directly call the script handle instead of registering
    the script separately. Then, we can add the following code to the shortcode function
    to enqueue the files:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'We have the accordion script and style included within the shortcode. Finally,
    we have to initialize the accordion by adding the following initialization code
    to the `wqkm-accordion.js` file:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The accordion is initialized using the ID of the main container we created
    for the shortcode output. This may vary based on the accordion library of your
    choice. Now we have completed the accordion integration process, and your accordion
    should look similar to the following screenshot:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/7b31dcb2-cbcf-4022-bbe7-055cb270108b.png)'
  id: totrans-123
  prefs: []
  type: TYPE_IMG
- en: As you can see, we can use these UI components in a limited space to display
    a large amount of contents.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
- en: Steps for integrating UI components
  id: totrans-125
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Up to this point, we looked at two implementations for integrating the jQuery
    slider and accordion UI components using different data-capturing techniques.
    The implementation may vary based on the type of UI component and its functionality.
    However, the basic process is similar for most of the common UI components. So,
    let''s summarize the keys for integrating any UI component with WordPress:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
- en: '**Identify component data**: Each UI component works on existing data or elements.
    So, we need to identify the data needed to use each UI component and the method
    for storing this data.'
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Generate component output**: In this step, we have to use the captured data,
    process it, and generate the HTML output needed to enable the features of a UI
    component. Usually, we use a reusable component such as a shortcode or widget
    to add and generate the output for UI components.'
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Include component libraries**: Most UI components generate their features
    by applying JavaScript or CSS to the generated output. These features of the component
    generally come as an open source library. So, in this step, we need to all the
    necessary scripts and styles for the component, along with the necessary settings.
    In this process, we use `wp_register_style` and `wp_register_script` functions
    to include these resources by adding them inside plugins or themes. Then, you
    can enqueue them conditionally within the main class or inside the UI component
    generation function.'
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Passing script data**: Some of the UI element libraries directly apples CSS
    or JavaScript features on the generated output. However, some element scripts
    require certain data or settings to initialize the element. In such cases, we
    have to pass the necessary data to necessary scripts using the `wp_localize_script`
    function.'
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Initialize the element**: Once necessary libraries and HTML output is ready,
    we can initialize the element by using the initialization function of these libraries.
    These initializations generally takes one to a few lines of code. Usually, we
    use a CSS class or HTML element ID on the generated output for this initialization.'
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Once these steps are completed, you will see the interactive features or styles
    in your UI element. This is the general process for the most common UI elements.
    However, there may be exceptions that require a different process to initialize
    the UI element.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
- en: Simplifying development with page builders
  id: totrans-133
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Page builder** is a set of components that simplifies the process of content
    creation or building the features of the site. These components allow developers
    to build complex interfaces in super-quick time by choosing and configuring built-in
    components. Page builders were initially used for simplifying content creation
    with pre-built design elements. However, page builders have now evolved into a
    state where we can use the existing components to add advanced site features such
    as form management, searchable google maps, parallax images, and videos.'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
- en: Until recently, developers used the page builders included in themes, as well
    as free and premium page builder plugins. WordPress has introduced a block-based
    content builder called **Gutenberg**. At this stage, Gutenberg editor supports
    content editing with a basic set of elements. Currently, it's nowhere near the
    features offered by popular page builders such as Elementor, Beaver Builder, and
    Visual Composer. However, the future seems bright, as the WordPress team is backing
    the Gutenberg editor by making it a default core feature. So, we will soon see
    more powerful features of the Gutenberg editor, along with the features offered
    by other page builders.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the features of page builders
  id: totrans-136
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As we discussed, page builders offer a wide range of components that can be
    dragged or assigned to any post, page, or custom post type. However, many of these
    page builders provide advanced features beyond using basic built-in components.
    So, it''s important to understand these features to use the existing components,
    as well as making your solutions integrate with page builders. Let''s take a look
    at the main features offered by modern page builders:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
- en: '**Backend and frontend editing**: Usually, we edit or build the site interfaces
    using the backend content editor, and hence we have to switch to frontend to view
    the changes. Most page builders provide frontend editing, allowing previews in
    real time and adjusting them instantly. Also, there is a backend editor, if you
    want to work with other backend features.'
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Built-in templates**: Many page builders provide built-in template designs
    by using the existing components. So, the developers can use these templates designed
    for common requirements and adjust them as needed without writing a single line
    of code.'
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Advanced styling**: Each component allows various styling options such as
    margins, paddings, colors and so on. So, you can fine tune the design without
    going into the code.'
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Responsive design**: This is a must in modern development to cater for different
    devices, such as personal computers, mobiles, tabs, and so on. Usually, we have
    to spend lot of time making our designs fully responsive. Page builder structure
    and components are responsive by default. So, you don''t have to do anything to
    make the content responsive as long as you follow the proper coding standards
    for your own elements.'
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As you can see, page builder provides a lot of power for building the content
    and design of your site. However, these powerful features also come with some
    limitations. Some of these page builders are completely dependent on shortcodes,
    and hence you will be locked into the plugin. Also, you might experience performance
    issues when using some complex features of page builders. Therefore, you need
    to be responsible with choosing the proper page builder and the features.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
- en: Developing components for page builders
  id: totrans-143
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Most popular page builders come with a wide range of built-in components as
    well as additional components using addons. So, we can use the existing components
    to build general purpose WordPress sites. However, when developing advanced applications
    or sites with custom requirements, the default functionality of these components
    may not be sufficient. In such cases, we have to build our own page builder components
    to provide the necessary functionality. We can always create shortcodes and ask
    the clients to use them inside the page builder components. But building our components
    simplifies the process considerably for the client, and hence we have to build
    components whenever necessary.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
- en: 'Major page builders provides an API or guide for developing components for
    their plugin. The technique varies for each page builder. So, you need to use
    the documentation to understand and develop a component for each page builder. Developing
    a component from scratch with the necessary explanations is beyond the scope of
    this chapter. However, we will explore the basic steps of component creation using
    the Elementor page builder as the example. Let''s take a look at the main steps
    for building a page builder component:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
- en: Each page builder identifies its components as modules, widgets, blocks, and
    so on. So, there should be a way to register new components for the page builder.
    Elementor uses the `Widget_Base` class and `register_widget_type` function to
    register new components. The other page builders offer similar techniques.
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: After registering the component, you need to specify the input fields for capturing
    component data. Most page builders provide different types of input fields to
    capture and save the data for the component. Elementor provides a function called `add_control` on
    the `Widget_Base` class, supporting over 30 different control types. The other
    page builders will have similar functions to add input fields to different field
    types, as well as different data-storing mechanisms.
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Finally, we need to provide the output of the component by building the HTML
    code or executing an existing shortcode. Elementor provides a function called `render` for
    retrieving the saved component data and displaying the output. The other page
    builders should have a similar method, with a similar name.
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We have used these steps and built a slider component for the Elementor page
    builder. You can find the code for this addon inside the `wpquick-elementor-components` directory
    of the source code for this chapter. The following screenshot previews the component
    generated by the addon with settings:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/09809233-6d65-4b42-adf3-e8d1dbd35719.png)'
  id: totrans-150
  prefs: []
  type: TYPE_IMG
- en: Elementor is one of the most popular and rising page builders at this stage.
    You can access the documentation at [https://developers.elementor.com/creating-an-extension-for-elementor/](https://developers.elementor.com/creating-an-extension-for-elementor/)
    and use the addon code for understanding the step. The process for other page
    builders will be similar, with the support of plugin-specific component creation
    functions.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
- en: Simplifying and customizing admin features
  id: totrans-152
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have to use the core features as much as possible to get the maximum benefits
    of using WordPress for site development. This includes the use of frontend theme
    features, as well as the existing backend features, that mainly focuses on post-related
    functionality. So, it's obvious that developers need to customize these features
    to suit the requirements of each website. In this section, we are going to look
    at several customizations of commonly used backend features.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
- en: Creating custom dashboard widgets
  id: totrans-154
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We had a brief introduction to the **Dashboard Widget API** in [Chapter 6](e452b581-f38d-4c95-8a41-0c9a54b26a57.xhtml),
    *Practical Usage of WordPress APIs*. Basically, a *dashboard* is a collection
    of widgets built for administration purposes. Unlike frontend theme widgets, we
    don't have an interface for adding or removing admin dashboard widgets. So, we
    have to build custom solutions to build new dashboard widgets as well as remove
    the existing ones. In this section, we are going to look at the process of creating
    a basic dashboard widget.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
- en: Registering and building dashboard widgets
  id: totrans-156
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'First, we have to register the dashboard widget by using the `wp_dashboard_setup`
    action, instead of the `widgets_init` we used on the frontend widgets. Consider
    the following code for the widget registration process:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Inside the callback function, we use the `wp_add_dashboard_widget` function
    to register a new widget. The parameters for this function contain a unique widget
    ID, widget title, and the callback function. Then, we have to implement the function
    to display the content for the widget, as shown in the following code:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Here, we have simplified the process by using a shortcode we developed in earlier
    chapters. Basically, we have a dashboard widget in fewer than 10 lines of code.
    This process is simpler compared to the frontend dashboard widget creation process.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
- en: The default dashboard widgets are mostly suitable for blogs. In many circumstances,
    we have to remove the existing widgets and add custom widgets to cater for advanced
    site-specific business requirements. In custom sites, dashboard widgets are frequently
    used for displaying the site statistics, reports, or features that need to be
    executed on a regular basis, without visiting individual screens. You can try
    the existing plugins with dashboard widgets to understand the usage. WooCommerce,
    bbPress, and Easy Digital Downloads are some of the popular plugins with built-in
    custom dashboard widgets.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
- en: Customizing backend list tables
  id: totrans-163
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: WordPress provides backend list tables for the main content types. We discussed
    the features of list tables in [Chapter 7](1a709b5f-c476-41f9-bc13-eb5f0541abaa.xhtml),
    *Managing Custom Post Types and Processing Forms*, on custom post types. The default
    features provide data list tables for posts, pages, users, and comments, as well
    as all the registered custom post types. Also, we can extend the core class used
    for list tables and create our own custom data list tables. So, it's important
    to know the existing features as well as customizable features of backend list
    tables. In this section, we are going to look at the some of the common customizations
    on the backend user list. Let's get started.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
- en: Creating and executing custom bulk actions
  id: totrans-165
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The WordPress list tables contains a dropdown called Bulk Actions in the top
    left-hand section of the list. This feature is used to modify multiple records
    in the table with a single predefined event. We have to choose one or more records,
    select an action from the Bulk Actions dropdown, and click the Apply button to
    complete the process. This is a very useful feature when you want to modify bulk
    records for custom features.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
- en: 'The WordPress core actions can be used to modify the Bulk Actions dropdown
    and to include custom actions for our projects. Let''s add the following action
    to the constructor of the `WQKM_Admin_Features` class for understanding the process
    of using custom actions:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'This action is used to filter the actions for the users list table. The filter
    consists of the `bulk_action`-prefix followed by the screen name. So, you can
    use the same action for other core list tables by replacing users with the screen
    name for the list. Let''s take a look at the implementation of the custom action:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: In this code, we are adding a custom action to the default backend user list
    by modifying the existing bulk actions list. We have to use a unique slug as the
    array key for this action and define the label as the array value. In this scenario,
    we are building an action that allows us to mark certain users as Featured Users.
    Now you will see a new option in the Bulk Actions dropdown for handling user-featured
    status.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
- en: 'Once the records and action is selected, we can click the Apply button to make
    the modifications to the selected records. So, we need to implement the action
    by adding the following action to the constructor of the class:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'In this code, we have used `handle_bulk_actions-` filter followed by the screen
    name for user list table. So, let''s take a look at the implementation of the
    custom action:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Here''s what the previous code does:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
- en: This function automatically receives three parameters for the redirect URL,
    the action name, and the list of IDs of the records to be modified.
  id: totrans-177
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: First, we check the action and make sure our code executes only for the `wpquick_featured_user`
    action.
  id: totrans-178
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Next, we loop through the list of selected user IDs and modify the value to
    mark the user as a featured user. We can use a different action or toggle the
    same action to remove the featured status as well.
  id: totrans-179
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Finally, we redirect the user to the list by adding a custom argument to the
    URL called `bulk_featured_users`. This value will be used to filter the request
    and display a custom message using the `bulk_admin_notices` function in the source
    code.
  id: totrans-180
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now we have a working custom action for the user list. You can test the feature
    by adding featured status to some of the users and confirming it by checking the
    database values. This is a simple way of modifying or applying custom data to
    multiple records for custom requirements. We can't use input fields for these
    actions, and hence the action should have a fixed feature with predefined values.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
- en: Adding custom list columns
  id: totrans-182
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The data list tables contains default set of columns, and these columns vary
    based on the type of the list. In the previous section, we changed the featured
    status of the user. However, we had to use the database to check the value. Instead,
    we can display such important information on the data list table by using custom
    columns. So, in this section, we are going to look at the process of adding custom
    columns to the default users list as well as identifying the necessary hooks for
    other lists. Let''s start by adding the following filter and action to the constructor
    of `WQKM_Admin_Features` class:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'The `manage_users_columns` filter is used to modify or remove existing columns
    as well as to add new columns to the user list. The following code previews the
    implementation to include the featured status as a column:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Now you should see an additional column in the user list without any data.
    The next step is to display the column data for each user. We have to use the
    `manage_users_custom_column` action to provide the data for our custom column.
    Let''s take a look at the implementation of the callback function:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: This function accepts three parameters for the column value, column name, and
    the user ID. We can use these parameters to get the custom column value for the
    selected users. Here, we use `get_user_meta` function as we stored the data on
    `wp_usermeta` table. We can also store these values and display them using custom
    tables. Next, we use a `switch` statement to return the value based on the column.
    It's important to use the `default` case and return the default value, to be compatible
    with other plugins. Now you should see the custom column in the user list with
    the custom values for each user.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
- en: Sorting custom column values
  id: totrans-190
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The default list tables provides sorting capabilities for the first column
    and one or more from the remaining columns. However, these are built-in columns
    provided by the WordPress core features. So, we need the ability to sort custom
    column values to effectively use and filter the custom data. WordPress provides
    a built-in filter for specifying sortable columns. Let''s consider the following
    filter and its implementation:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'The filter needs to be added inside the constructor of the class. This filter
    accepts the list of existing sortable columns as a parameter. Here, we have added
    the key of our custom column to the sortable columns array and return the list.
    Now you should be able to see a link in custom column to change the sorting value.
    The final step of the process is to change the default query and enable sorting
    on the custom column. Let''s consider the following action and its implementation:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Let''s understand the implementation of this function using the following steps:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
- en: We can use `pre_user_query` action to modify the default query, just before
    the execution. The `WP_User_Query` object is passed as a parameter to this function.
  id: totrans-196
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Next, we check the `orderby` clause of the query using the `query_vars` array
    to make sure our custom code only executes on `featured_user_status` column.
  id: totrans-197
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Then, we have to modify the query, staring with the `join` statement on the `from`
    clause to include the `usermeta` table. The modified `where` clause makes sure
    that sorting is only applied to the values of the `featured_user_status` column.
  id: totrans-198
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Finally, we change the `orderby` clause to order the list using meta values
    of the `featured_user_status` column.
  id: totrans-199
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now the process is complete, and you should be able to click the column title
    to sort the users in both ways using the featured status. The following screenshot
    previews the features we added to the user list:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/4e0c602e-5cd3-4cd6-8786-a6ea8f46edf8.png)'
  id: totrans-201
  prefs: []
  type: TYPE_IMG
- en: You can follow this technique with the necessary filtering to manage more columns
    on the user list.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
- en: We looked at the list table customization for the backend user list. Similarly,
    we can apply the same technique to customize the columns of other WordPress list
    tables using necessary actions and filters.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
- en: In most scenarios, we need to customize posts and custom post types lists to
    include custom columns. We have to use `manage_edit-{post_type}_columns` filter
    to define the custom columns and the `manage_{post_type}_posts_custom_column` filter
    to add the values for the custom columns. Then, we can use `manage_edit-{post_type}_sortable_columns` filter
    to define sortable columns and use `pre_get_posts` action to modify the query
    for sorting.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
- en: So, we need to use these actions and filters whenever necessary to display additional
    data in list tables and avoid the time-consuming visits to the edit section to
    check the values.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-206
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The main purpose of using WordPress is to simplify the development process.
    So, we need to understand the process of customizing important backend features.
    Also it's important to use modern user interface components to provide all the
    important in limited space using attractive techniques. We began the chapter by
    understanding the importance of the integration of UI components. So, we integrated
    jQuery Slider and Accordion while using two different data-capturing methods.
    We also looked at the importance of page builders in modern development and the
    steps for developing custom components for page builders. Next, we moved on to
    customizing admin features by building a simple dashboard widget. Finally, we
    looked at the process of adding custom features to built-in WordPress list tables.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 9](1690ebbf-249c-4892-81db-098b6a9050f5.xhtml), *Enhancing Security,
    Performance, and Maintenance*, we will be completing the content for this book
    by looking at the non-functional aspects of development, such as security, performance,
    testing, and maintenance.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
