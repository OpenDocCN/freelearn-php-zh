<html><head></head><body><div class="chapter" title="Chapter&#xA0;7.&#xA0;Handling Authentication"><div class="titlepage"><div><div><h1 class="title"><a id="ch07"/>Chapter 7. Handling Authentication</h1></div></div></div><p>In this chapter we will cover:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Understanding Authentication methods</li><li class="listitem" style="list-style-type: disc">Setting up a simple database Authentication</li><li class="listitem" style="list-style-type: disc">Writing a custom Authentication method</li></ul></div><div class="section" title="Introduction"><div class="titlepage"><div><div><h1 class="title"><a id="ch07lvl1sec41"/>Introduction</h1></div></div></div><p>In this chapter we will talk about the different methods of authentication and we will show you some examples on how to authenticate and how to create your own authentication method.</p></div></div>
<div class="section" title="Understanding Authentication methods"><div class="titlepage"><div><div><h1 class="title"><a id="ch07lvl1sec42"/>Understanding Authentication methods</h1></div></div></div><p>In a world <a id="id553" class="indexterm"/>where security on the Internet is such a big issue, the need for great authentication methods is something that cannot be missed. Therefore, Zend Framework 2 provides a range of authentication methods that suits everyone's needs.</p><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch07lvl2sec97"/>Getting ready</h2></div></div></div><p>To make full use of this recipe, I recommend a working Zend Framework 2 skeleton application to be set up.</p></div><div class="section" title="How to do it…"><div class="titlepage"><div><div><h2 class="title"><a id="ch07lvl2sec98"/>How to do it…</h2></div></div></div><p>The following is a list of authentication methods—or as they are called adapters—that are readily available in Zend Framework 2. We will provide a small overview of the adapter, and instructions on how you can use it.</p><div class="section" title="The DbTable adapter"><div class="titlepage"><div><div><h3 class="title"><a id="ch07lvl3sec201"/>The DbTable adapter</h3></div></div></div><p>Constructing<a id="id554" class="indexterm"/> a <code class="literal">DbTable</code> adapter is pretty <a id="id555" class="indexterm"/>easy, if we take a look at the following constructor:</p><div class="informalexample"><pre class="programlisting">public function __construct(
  // The Zend\Db\Adapter\Adapter
  DbAdapter $zendDb,

  // The table table name to query on
  $tableName = null,

  // The column that serves as 'username'
  $identityColumn = null,

  // The column that serves as 'password'
  $credentialColumn = null,

  // Any optional treatment of the password before 
  // checking, such as MD5(?), SHA1(?), etcetera
  $credentialTreatment = null
);</pre></div></div><div class="section" title="The Http adapter"><div class="titlepage"><div><div><h3 class="title"><a id="ch07lvl3sec202"/>The Http adapter</h3></div></div></div><p>After <a id="id556" class="indexterm"/>constructing<a id="id557" class="indexterm"/> the object we need to define the <code class="literal">FileResolver</code> to make sure there are actually user details parsed in.</p><p>Depending on what we configured in the <code class="literal">accept_schemes</code> option, the <code class="literal">FileResolver</code> can either be set as a <code class="literal">BasicResolver</code>, a <code class="literal">DigestResolver</code>, or both.</p><p>Let's take a quick look at how to set a <code class="literal">FileResolver</code> as a <code class="literal">DigestResolver</code> or <code class="literal">BasicResolver</code> (we do this in the <code class="literal">/module/Application/src/Application/Controller/IndexController.php</code> file):</p><div class="informalexample"><pre class="programlisting">&lt;?php

namespace Application;

// Use the FileResolver, and also the Http 
// authentication adapter.
use Zend\Authentication\Adapter\Http\FileResolver;
use Zend\Authentication\Adapter\Http;
use Zend\Mvc\Controller\AbstractActionController;

class IndexController extends AbstractActionController
{
  public function indexAction()
  {
    // Create a new FileResolver and read in our file to use 
    // in the Basic authentication
    $basicResolver = new FileResolver();
    $basicResolver-&gt;setFile(
      '/some/file/with/credentials.txt'
    );

    // Now create a FileResolver to read in our Digest file
    $digestResolver = new FileResolver();
    $digestResolver-&gt;setFile(
      '/some/other/file/with/credentials.txt'
    );

    // Options doesn't really matter at this point, we can 
    // fill them in to anything we like
    $adapter = new Http($options);

    // Now set our DigestResolver/BasicResolver, depending 
    // on our $options set
    $adapter-&gt;setBasicResolver($basicResolver);
    $adapter-&gt;setDigestResolver($digestResolver);
  }
}</pre></div></div></div><div class="section" title="How it works…"><div class="titlepage"><div><div><h2 class="title"><a id="ch07lvl2sec99"/>How it works…</h2></div></div></div><p>After two short examples, let's take a look at the other adapters available.</p><div class="section" title="The DbTable adapter (again)"><div class="titlepage"><div><div><h3 class="title"><a id="ch07lvl3sec203"/>The DbTable adapter (again)</h3></div></div></div><p>Let's<a id="id558" class="indexterm"/> begin with<a id="id559" class="indexterm"/> probably the most used adapter of them all, the <code class="literal">DbTable</code> adapter. This adapter connects to a database and pulls the requested username/password combination from a table and, if all went well, it will return to you an identity, which is nothing more than the record that matched the username details.</p><p>To instantiate<a id="id560" class="indexterm"/> the adapter, it requires a <code class="literal">Zend\Db\Adapter\Adapter</code> in its constructor to connect with the database with the user details; there are also a couple of other options that can be set. Let's take a look at the definition of the constructor:</p><p>The <a id="id561" class="indexterm"/>second (<code class="literal">tableName</code>) option speaks for itself as it is just the table name, which we need to use to get our users, the third and the fourth (<code class="literal">identityColumn</code>, <code class="literal">credentialColumn</code>) options are logical and they represent the username and password (or what we use) columns in our table. The last option, the <code class="literal">credentialTreatment</code> option, however, might not make a lot of sense.</p><p>The <code class="literal">credentialTreatment</code> tells the adapter to treat the <code class="literal">credentialColumn</code> with a function before trying to query it. Examples of this could be to use the <code class="literal">MD5(?)</code> function, <code class="literal">PASSWORD(?)</code>, or <code class="literal">SHA1(?)</code> function, if it was a MySQL database, but obviously this can differ per database as well. To give a small example on how the SQL can look like (the actual adapter builds this query up differently) with and without a credential treatment, take a look at the following examples:</p><p>With credential treatment:</p><div class="informalexample"><pre class="programlisting">SELECT * FROM `users` WHERE `username` = 'some_user' AND `password` = MD5('some_password');</pre></div><p>Without credential treatment:</p><div class="informalexample"><pre class="programlisting">SELECT * FROM `users` WHERE `username` = 'some_user' AND `password` = 'some_password';</pre></div><p>When defining the treatment we should always include a question mark for where the password needs to come, for example, <code class="literal">MD5(?)</code> would create <code class="literal">MD5('some_password')</code>, but without the question mark it would not insert the password.</p><p>Lastly, instead of giving the options through the constructor, we can also use the setter methods for the properties: <code class="literal">setTableName()</code>, <code class="literal">setIdentityColumn()</code>, <code class="literal">setCredentialColumn()</code>, and <code class="literal">setCredentialTreatment()</code>.</p></div><div class="section" title="The Http adapter (again)"><div class="titlepage"><div><div><h3 class="title"><a id="ch07lvl3sec204"/>The Http adapter (again)</h3></div></div></div><p>The <a id="id562" class="indexterm"/>HTTP authentication adapter<a id="id563" class="indexterm"/> is an adapter that we have probably all come across at least once in our Internet lives. We can recognize the authentication when we go to a website and there is a pop up showing where we can fill in our usernames and passwords to continue.</p><p>This form of authentication is very basic, but still very effective in certain implementations, <a id="id564" class="indexterm"/>and therefore, a part of Zend Framework 2. There is only one big massive <span class="emphasis"><em>but</em></span> to this authentication, and that is that it can (when using the basic authentication) send the username and password clear text through the browser (ouch!).</p><p>There is <a id="id565" class="indexterm"/>however a solution to this problem and that is to use the Digest authentication, which is also supported by this adapter.</p><p>If we take a look at the constructor of this adapter, we would see the following code line:</p><div class="informalexample"><pre class="programlisting">public function __construct(array $config);</pre></div><p>The constructor accepts a load of keys in its <code class="literal">config</code> parameter, which are as follows:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">accept_schemes</code>: This refers to what we want to accept authentication wise; this can be <code class="literal">basic</code>, <code class="literal">digest</code>, or <code class="literal">basic digest</code>.</li><li class="listitem" style="list-style-type: disc"><code class="literal">realm</code>: This is a description of the realm we are in, for example <code class="literal">Member's area</code>. This is for the user only and is only to describe what the user is logging in for.</li><li class="listitem" style="list-style-type: disc"><code class="literal">digest_domains</code>: These are URLs for which this authentication is working. So if a user logs in with his details on any of the URLs defined, they will work. The URLs should be defined in a space-separated (weird, right?) list, for example <code class="literal">/members/area /members/login</code>.</li><li class="listitem" style="list-style-type: disc"><code class="literal">nonce_timeout</code>: This will set the number of seconds the nonce (the hash users login with when we are using Digest authentication) is valid. Note, however, that nonce tracking and stale support are not implemented in Version 2.2 yet, which means it will authenticate again every time the nonce times out.</li><li class="listitem" style="list-style-type: disc"><code class="literal">use_opaque</code>: This is either true or false (by default is true) and tells our adapter to send the opaque header to the client. The opaque header is a string sent by the server, which needs to be returned back on authentication. This does not work sometimes on Microsoft Internet Explorer browsers though, as they seem to ignore that header. Ideally the opaque header is an ever-changing string, to reduce predictability, but ZF 2 doesn't randomize the string and always returns the same hash.</li><li class="listitem" style="list-style-type: disc"><code class="literal">algorithm</code>: This includes the algorithm to use for the authentication, it needs to be a supported algorithm that is defined in the <code class="literal">supportedAlgos</code> property. At the moment there is only MD5 though.</li><li class="listitem" style="list-style-type: disc"><code class="literal">proxy_auth</code>: This boolean (by default is false) tells us if the authentication used is a proxy Authentication or not.</li></ul></div><p>It should be noted that there is a slight difference in files when using either Digest or Basic. Although both files have the same layout, they cannot be used interchangeably as the Digest requires the credentials to be MD5 hashed, while the Basic requires the credentials to be plain text. There should also always be a new line after every credential, meaning that the last line in the credential file should be empty.</p><p>The layout of a credential file is as follows:</p><div class="informalexample"><pre class="programlisting">username:realm:credentials</pre></div><p>For example:</p><div class="informalexample"><pre class="programlisting">some_user:My Awesome Realm:clear text password</pre></div><p>Instead of a <code class="literal">FileResolver</code>, one can also use the <code class="literal">ApacheResolver</code> which can be used to read out <code class="literal">htpasswd</code> generated files, which comes in handy when there is already such a file in place.</p></div><div class="section" title="The Digest adapter"><div class="titlepage"><div><div><h3 class="title"><a id="ch07lvl3sec205"/>The Digest adapter</h3></div></div></div><p>The <a id="id566" class="indexterm"/>
<code class="literal">Digest</code> adapter is basically the <code class="literal">Http</code> adapter without<a id="id567" class="indexterm"/> any Basic authentication. As the idea behind it is the same as the <code class="literal">Http</code> adapter, we will just go on and talk about the constructor, as that is a bit different in implementation:</p><div class="informalexample"><pre class="programlisting">public function __construct($filename = null, $realm = null, $identity = null, $credential = null);</pre></div><p>As we can see the following options can be set when constructing the object:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">filename</code>: This is the direct filename of the file to use with the Digest credentials, so no need to use a <code class="literal">FileResolver</code> with this one.</li><li class="listitem" style="list-style-type: disc"><code class="literal">realm</code>: This identifies to the user what he/she is logging on to, for example <code class="literal">My Awesome Realm</code> or <code class="literal">The Dragonborn's lair</code>. As we are immediately trying to log on when constructing this, it does need to correspond with the credential file (see <span class="emphasis"><em>The Http adapter</em></span> for the credential file layout).</li><li class="listitem" style="list-style-type: disc"><code class="literal">identity</code>: This is the username we are trying to log on with, and again it needs to resemble a user that is defined in the credential file to work.</li><li class="listitem" style="list-style-type: disc"><code class="literal">credential</code>: This is the Digest password we try to log on with, and this again needs to match the password exactly like the one in the credential file.</li></ul></div><p>We can then, for example, just run <code class="literal">$digestAdapter-&gt;getIdentity()</code> to find out if we are successfully authenticated or not, resulting in <code class="literal">NULL</code> if we are not, and resulting in the identity column value if we are.</p></div><div class="section" title="The LDAP adapter"><div class="titlepage"><div><div><h3 class="title"><a id="ch07lvl3sec206"/>The LDAP adapter</h3></div></div></div><p>Using<a id="id568" class="indexterm"/> the <a id="id569" class="indexterm"/>LDAP authentication is obviously a little more difficult to explain, so we will not go in to that in full as that would take quite a while. What we will do is show the constructor of the <code class="literal">LDAP</code> adapter and explain its various options. However, if we want to know more about setting up an LDAP connection, we should take a look at the documentation of ZF2, as it is explained in there very well:</p><div class="informalexample"><pre class="programlisting">public function __construct(array $options = array(), $identity = null, $credential = null);</pre></div><p>The options parameter in the construct refers to an array of configuration options that are compatible with the <code class="literal">Zend\Ldap\Ldap</code> configuration. There are literally dozens of options that can be set here so we advise to go and look at the LDAP documentation of ZF2 to know more about that. The next two parameters identity and credential are respectively the username and password again, so that explains itself really.</p><p>Once you have set up the connection with the LDAP there isn't much left to do but to get the identity and see whether we were successfully validated or not.</p></div><div class="section" title="About Authentication"><div class="titlepage"><div><div><h3 class="title"><a id="ch07lvl3sec207"/>About Authentication</h3></div></div></div><p>Authentication<a id="id570" class="indexterm"/> in Zend Framework 2 works through specific adapters, which are always an implementation of the <code class="literal">Zend\Authentication\Adapter\AdapterInterface</code> and thus, always provides the methods defined in there. However, the methods of Authentication are all different, and strong knowledge of the methods displayed previously is always a requirement. Some work through the browser, like the <code class="literal">Http</code> and <code class="literal">Digest</code> adapter, and others just require us to create a whole implementation like the <code class="literal">LDAP</code> and the <code class="literal">DbTable</code> adapter.</p></div></div></div>
<div class="section" title="Setting up a simple database Authentication"><div class="titlepage"><div><div><h1 class="title"><a id="ch07lvl1sec43"/>Setting up a simple database Authentication</h1></div></div></div><p>After seeing all the <a id="id571" class="indexterm"/>authentication methods available, it is time to see how it will actually work when we have a database authentication in place. This recipe will explain all the ins and outs of this specific method.</p><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch07lvl2sec100"/>Getting ready</h2></div></div></div><p>A working Zend Framework 2 skeleton application with the PHP sqlite extension loaded and enabled.</p></div><div class="section" title="How to do it…"><div class="titlepage"><div><div><h2 class="title"><a id="ch07lvl2sec101"/>How to do it…</h2></div></div></div><p>Database <a id="id572" class="indexterm"/>authentication can very well be the most widely used authentication method there is. In this recipe we will set up our own database authentication.</p><div class="section" title="Setting up the module initialization"><div class="titlepage"><div><div><h3 class="title"><a id="ch07lvl3sec208"/>Setting up the module initialization</h3></div></div></div><p>We will<a id="id573" class="indexterm"/> create our database as soon as possible after initialization of the modules, so we will attach it to an event called route or <code class="literal">MvcEvent::EVENT_ROUTE</code>. As a template for the <code class="literal">Module.php</code> we can just copy over the <code class="literal">Application/Module.php</code> file and change the namespace; we will be working in the <code class="literal">onBootstrap</code> method anyway, and the rest of the <code class="literal">Module</code> class can stay the same (but don't forget to change the namespace!).</p><p>Let's take a look at the code of our <code class="literal">/module/Authentication/Module.php</code> file:</p><div class="informalexample"><pre class="programlisting">// We can assume the rest of the Module class file is 
// exactly the same as the default 
// Application/Module.php file, except of course the 
// namespace.
public function onBootstrap(MvcEvent $e)
{
  // This is also default    
  $eventManager = $e-&gt;getApplication()-&gt;getEventManager();
  $moduleRouteListener = new ModuleRouteListener();
  $moduleRouteListener-&gt;attach($eventManager);
  // And now we let the magic happen (this is the bit we 
  // will insert)
  $eventManager-&gt;attach(
    // We want to attach to the route event, which means   
    // it happens before our controllers are initialized 
    // (because that would mean we already found the 
    // route)
    MvcEvent::EVENT_ROUTE,

    // We are using this function as our callback 
    function (MvcEvent $event) 
    {
     // Get the database adapter from the configuration
     $dbAdapter = $event-&gt;getApplication()
                         -&gt;getServiceManager()
                         -&gt;get('db');

     // Our example is an in memory database, so the 
     // table never exists, but better sure than sorry
     $result = $dbAdapter-&gt;query("
             SELECT name 
            FROM sqlite_master 
           WHERE type='table' AND name='users'
     ")-&gt;execute();

      // If we couldn't find a users table, we will 
      // create one now (with an in memory db this is 
      // always the case)
     if ($result-&gt;current() === false) {
       try {
         // The user table doesn't exist yet, so let's 
         // just create some sample data
         $result = $dbAdapter-&gt;query("
            CREATE TABLE `users` (
              `id` INT(10) NOT NULL,
              `username` VARCHAR(20) NOT NULL,
              `password` CHAR(32) NOT NULL,
            PRIMARY KEY (`id`)
            )
           ")-&gt;execute();

         // Now insert some users
         $dbAdapter-&gt;query("
         INSERT INTO `users` VALUES 
           (1, 'admin', '". md5("adminpassword"). "')
          ")-&gt;execute();

         $dbAdapter-&gt;query("
           INSERT INTO `users` VALUES 
             (2, 'test', '". md5("testpassword"). "')
             ")-&gt;execute();		
        } catch (\Exception $e) {
        \Zend\Debug\Debug::dump($e-&gt;getMessage());
      }
    }
  });
}</pre></div><p>We have now <a id="id574" class="indexterm"/>created an event that will be triggered when we start routing. If we look carefully enough we can find one big mistake that will crash this code for sure. The problem of course being the db key in the <code class="literal">ServiceManager</code>, as we refer to a service we have yet to create. So let's get cracking and create that <code class="literal">/module/Authentication/config/module.config.php</code> file…</p><div class="informalexample"><pre class="programlisting">&lt;?php

return array(
  // Let's initialize the ServiceManager
  'service_manager' =&gt; array(
    'factories' =&gt; array(
      // Create a Db Adapter on initialization of the 
      // ServiceManager
      'Zend\Db\Adapter\Adapter' =&gt;
          'Zend\Db\Adapter\AdapterServiceFactory',
    ),

    // Let's give this Db Adapter the alias db
    'aliases' =&gt; array(
      'db' =&gt; 'Zend\Db\Adapter\Adapter',
    ),
  ),
 
  // We will now configure our Sqlite database, for 
  // which we only need these two lines
  'db' =&gt; array(
    'driver' =&gt; 'Pdo_Sqlite',
    'database' =&gt; ':memory:',
  ),
);</pre></div><p>That's it; our basic configuration to get the database going is done, and if we run the code now we can be<a id="id575" class="indexterm"/> certain our database is created.</p></div><div class="section" title="Creating the authentication service"><div class="titlepage"><div><div><h3 class="title"><a id="ch07lvl3sec209"/>Creating the authentication service</h3></div></div></div><p>The next <a id="id576" class="indexterm"/>thing we want to do is to create our Authentication service, the service that will help our application do all the authentication functionality. Let's create this service in the <code class="literal">Authentication\Service</code> namespace, and let's call the class <code class="literal">Authentication</code> (the file is <code class="literal">/module/Authentication/src/Authentication/Service/Authentication.php</code>).</p><div class="informalexample"><pre class="programlisting">&lt;?php

// Set the namespace
namespace Authentication\Service;

use Zend\ServiceManager\ServiceLocatorAwareInterface;

// We give this one an alias, because otherwise 
// DbTable might confuse us in thinking that it is  
// an actual db table
use Zend\Authentication\Adapter\DbTable as AuthDbTable;
use Zend\Authentication\Storage\Session;

// We want to make a service, so we implement the 
// ServiceLocatorAwareInterface for that as well
class Authentication implements ServiceLocatorAwareInterface
{
  // Storage for our service locator
  private $servicelocator;

  // Get the ServiceManager
  public function getServiceLocator() 
  {
    return $this-&gt;servicelocator;
  }
 
  // Set the ServiceManager
  public function setServiceLocator(\Zend\ServiceManager\ServiceLocatorInterface $serviceLocator) 
  {
    $this-&gt;servicelocator = $serviceLocator;
  }</pre></div><p>Well that was easy; we just created our service… which does absolutely nothing at the moment. Let's first <a id="id577" class="indexterm"/>create a method that checks if we are authenticated or not. We do this by checking the authentication session, and see if it is empty or not. Assuming that in this case we only have a (authentication!) session when are actually authenticated, we can safely agree that we will be logged in;</p><div class="informalexample"><pre class="programlisting">  /**
   * Lets us know if we are authenticated or not.
   * 
   * @return boolean
   */
  public function isAuthenticated()
  {
    // Check if the authentication session is empty, if 
    // not we assume we are authenticated
    $session = new Session();

    // Return false if the session IS empty, and true if 
    // the session ISN'T empty
    return !$session-&gt;isEmpty();
  }</pre></div><p>We can easily just open a session as the namespace of the session will only be used for authentication purposes.</p><p>Let's now create our authentication, which will authenticate a username and password, and return a boolean stating that we are or aren't successful in authenticating:</p><div class="informalexample"><pre class="programlisting">  /**
   * Authenticates the user against the Authentication 
   * adapter.
   * 
   * @param string $username
   * @param string $password
   * @return boolean
   */
  public function authenticate($username, $password)
  {
    // Create our authentication adapter, and set our 
    // DbAdapter (the one we created before) by getting 
    // it from the ServiceManager. Also tell the adapter 
    // to use table 'users', where 'username' is the 
    // identity and 'password' is the credential column
    $authentication = new AuthDbTable(
      $this-&gt;getServiceLocator()-&gt;get('db'),
      'users',
      'username',
      'password'
    );

    // We use md5 in here because SQLite doesn't have 
    // any functionality to encrypt strings
    $result = $authentication-&gt;setIdentity($username)
                             -&gt;setCredential(md5($password))
                             -&gt;authenticate();

    // Check if we are successfully authenticated or not
    if ($result-&gt;isValid() === true) {
      // Now save the identity to the session
      $session = new Session();
      $session-&gt;write($result-&gt;getIdentity());
    }

    return $result-&gt;isValid();
  }</pre></div><p>As we saw <a id="id578" class="indexterm"/>in the previous code snippet, we created a simple authentication method that returns either true or false, depending on if we are authenticated or not. What it also does is save the identity to the authentication session, so we can see in our previous method if we were authenticated or not. We also need the identity in the session for when we want to get the username from our logged in user, which will retrieve with the following method:</p><div class="informalexample"><pre class="programlisting">  /**
   * Gets the identity of the user, if available, 
   * otherwise returns false.
   * @return array
   */
  public function getIdentity()
  {
    // Clear out the session, we are done here
    $session = new Session();

    // Check if the session is empty, if not return the 
    // identity of the logged in user
    if ($session-&gt;isEmpty() === false) {
      return $session-&gt;read();
    } else {
      return false;
    }
  }</pre></div><p>Now that we <a id="id579" class="indexterm"/>got our identity, it is also important that we are able to logout. In our case it is as simple as just clearing the session, because why would we make it more difficult than just that?</p><div class="informalexample"><pre class="programlisting">  /**
   * Logs the user out by clearing the session.
   */
  public function logout()
  {
    // Clear out the session, we are done here
    $session = new Session();
    $session-&gt;clear();
  }

  // This is our last method, close the bracket for the 
  // class as well!
}</pre></div><p>We have now created a simple authentication service, and the only part left now is to register it in the service manager so that it will be instantiated when we boot up. We can do this in the <code class="literal">/module/Authentication/config/module.config.php</code> file as usual, and because we already have a <code class="literal">service_manager</code> configuration there, we can just plant the invokable in there:</p><div class="informalexample"><pre class="programlisting">&lt;?php
return array(
  'service_manager' =&gt; array(
    // [The rest of the service manager configuration 
    // comes here]

    // And our new invokable can be put here
    'invokables' =&gt; array(
    'AuthService' =&gt; 'Authentication\Service\Authentication',
    ),
  ),
);</pre></div><p>And that's it for the service! All that is left now to do is create the <code class="literal">login/logout</code> action and then check <a id="id580" class="indexterm"/>if we are logged in or not. Let's begin with the <code class="literal">login/logout</code> action so that we are actually able to login!</p></div><div class="section" title="Setting up the controller and action"><div class="titlepage"><div><div><h3 class="title"><a id="ch07lvl3sec210"/>Setting up the controller and action</h3></div></div></div><p>Let's first <a id="id581" class="indexterm"/>change the <code class="literal">/module/Authentication/config/module.config.php</code> file while we are still in there so we can access our <code class="literal">login/logout</code> action, which is kind of crucial to us:</p><div class="informalexample"><pre class="programlisting">&lt;?php
return array(
  // [The configuration that we have now resides here..]

  // And our route configuration comes here..
  'router' =&gt; array(
    'routes' =&gt; array(
      'authentication' =&gt; array(
        'type'    =&gt; 'Literal',
        'options' =&gt; array(
          'route'    =&gt; '/authentication',
          'defaults' =&gt; array(
          '__NAMESPACE__' =&gt; 
                  'Authentication\Controller',
          'controller'    =&gt; 'Index',
          'action'        =&gt; 'login',
        ),
      ),
      'may_terminate' =&gt; true,
      'child_routes' =&gt; array(
        'default' =&gt; array(
          'type'    =&gt; 'Segment',
          'options' =&gt; array(
            'route'    =&gt; '[/:action]',
            'constraints' =&gt; array(
              'action'     =&gt; '[a-zA-Z][a-zA-Z0-9_-]*',
            ),
            'defaults' =&gt; array(),
          ),
        ),
      ),
    ),
  ),
),

// Make our controller invokable
'controllers' =&gt; array(
  'invokables' =&gt; array(
    'Authentication\Controller\Index' =&gt;   
          'Authentication\Controller\IndexController'
    ),
  ),

  // Make sure our template path is set correctly
  'view_manager' =&gt; array(
    'template_path_stack' =&gt; array(
      __DIR__ . '/../view',
    ),
  ),

);</pre></div><p>This basic <a id="id582" class="indexterm"/>route just makes <code class="literal">/authentication</code> redirect to our <code class="literal">loginAction</code> and because of the segment route we can simply do <code class="literal">/authentication/logout</code> to redirect to our <code class="literal">logoutAction</code>; if more explanation is required for the routes, we can review <a class="link" href="ch01.html" title="Chapter 1. Zend Framework 2 Basics">Chapter 1</a>, <span class="emphasis"><em>Zend Framework 2 Basics</em></span>, and look in the <span class="emphasis"><em>Handling routines</em></span> recipe.</p><p>Let's continue creating our /<code class="literal">module/Authentication/src/Authentication/Controller/IndexController</code> in the <code class="literal">Authentication\Controller</code> namespace:</p><div class="informalexample"><pre class="programlisting">&lt;?php

namespace Authentication\Controller;

use Zend\Mvc\Controller\AbstractActionController;
use Zend\View\Model\ViewModel;

class IndexController extends AbstractActionController
{
}</pre></div><p>We have <a id="id583" class="indexterm"/>simply declared our controller; now let's add the <code class="literal">logoutAction</code> (we will begin with that, as it is incredibly simple) and the <code class="literal">loginAction</code>:</p><div class="informalexample"><pre class="programlisting">public function logoutAction()
{
  // Log out the user
  $this-&gt;getServiceLocator()
       -&gt;get('AuthService')
       -&gt;logout();

  // Redirect the user back to the login screen
  $this-&gt;redirect()
       -&gt;toRoute('authentication');
}</pre></div><p>As we can see this is almost too simple, but we won't complain if it works. Now let us create our <code class="literal">loginAction</code>, which basically looks if there is a post and if there is tries to login, otherwise shows a login form. Upon successful login we will be redirected to the <code class="literal">/application</code> route, and if not successful we will just display an error message:</p><div class="informalexample"><pre class="programlisting">public function loginAction()
{
  // See if we are trying to authenticate
  if ($this-&gt;params()-&gt;fromPost('username') !== null) {
    // Try to authenticate with our post variables from 
    // the form we just send
    $done = $this-&gt;getServiceLocator()
                 -&gt;get('AuthService')
                 -&gt;authenticate(
        $this-&gt;params()-&gt;fromPost('username'),
        $this-&gt;params()-&gt;fromPost('password')
    );

    if ($done === true) {
      $this-&gt;redirect()
           -&gt;toRoute('application');
    } else {
      \Zend\Debug\Debug::dump(
        "Username/password unknown!"
      );
    }
  }
 
  // On an unsuccessful attempt or just a get request 
  // show the form.
  return new ViewModel();
}</pre></div><p>As we can see <a id="id584" class="indexterm"/>the <code class="literal">loginAction</code> is merely checking if we have anything posted, and if we do, it lets the <code class="literal">AuthService</code> handle it. This way is not perfect as it doesn't check for malicious parameters or anything, but it does show how clean a controller is supposed to be with no login in there except the bare minimum parsing of variables.</p><p>The <code class="literal">logoutAction</code> doesn't contain a view script, as that action only redirects the user and never has a response of its own. The <code class="literal">loginAction</code>, however, does have view script, as it needs to show a form. Let's quickly build a view script for the <code class="literal">loginAction</code> now (the file is <code class="literal">/module/Authentication/view/authentication/index/login.phtml</code>):</p><div class="informalexample"><pre class="programlisting">&lt;form action="/authentication" method="post"&gt;
  &lt;label for="username"&gt;Username:&lt;/label&gt;
  &lt;input type="text" name="username" /&gt;

  &lt;label for="password"&gt;Password:&lt;/label&gt;
  &lt;input type="password" name="password" /&gt;

  &lt;button type="submit"&gt;Login&lt;/button&gt;
&lt;/form&gt;</pre></div><p>A simple form to login and in my opinion doesn't require any explanation.</p><p>The last thing that we want to do know is to make sure nobody can access anything in the application other than the authentication if he/she is not logged in. We can do that by a new event in the Module (the file is <code class="literal">/module/Authentication/Module.php</code>) class of the Authentication module, which will check if we are logged in, and if not redirects us before any output is done to the screen:</p><div class="informalexample"><pre class="programlisting">public function onBootstrap(MvcEvent $e)
{
  // Get the event manager from the event
  $eventManager = $e-&gt;getApplication()-&gt;getEventManager();

  // Attach the module route listeners
  $moduleRouteListener = new ModuleRouteListener();
  $moduleRouteListener-&gt;attach($eventManager);

  // Do this event when dispatch is triggered, on the 
  // highest priority (1)
  $eventManager-&gt;attach(
      MvcEvent::EVENT_DISPATCH, 
      function (MvcEvent $event) {
      // We don't have to redirect if we are in a 
      // 'public' area, so don't even try
      if ($event-&gt;getRouteMatch()-&gt;getMatchedRouteName() 
                  === 'authentication') return;

      // See if we are authenticated, if not lets 
      // redirect to our login page
      if ($event-&gt;getApplication()-&gt;getServiceManager()
                -&gt;get('AuthService')-&gt;isAuthenticated() === 
          false) 
      {
        // Get the response from the event
        $response = $event-&gt;getResponse();

        // Clear current headers and add our Location 
        // redirection
        $response-&gt;getHeaders()
                 -&gt;clearHeaders()
                 -&gt;addHeaderLine(
             'Location', '/authentication'
        );

        // Set the status code to redirect
        $response-&gt;setStatusCode(302)
                 -&gt;sendHeaders();

        // Don't forget to exit the application, as we 
        // don't want anything to overrule at this point
        exit;
      }
  }, 

  // Give this event priority 1
  1);
}</pre></div><p>That's the<a id="id585" class="indexterm"/> event that we need, what happens is that we will simply be redirected to the login page whenever we try to reach a route which is not our authentication route.</p></div></div><div class="section" title="How it works…"><div class="titlepage"><div><div><h2 class="title"><a id="ch07lvl2sec102"/>How it works…</h2></div></div></div><p>What<a id="id586" class="indexterm"/> we are going to do is create a simple database authentication that works through an in-memory SQLite database. This means that the database isn't stored and that all the tables and records need building up every time we request the page. Obviously this is highly inconvenient to use in a production environment, it is, however, excellent to show off how it works and is really handy to get something going quickly.</p><p>Assuming we are working on a default Zend Skeleton application, let's create a new module Authentication. This new module will contain the database connection, the authentication itself and the login and logout actions. When we created the directory for the new module, we should also be wary to add the new module in the <code class="literal">application.config.php</code> file, otherwise we might end up having trouble finding out why it doesn't do anything (oh yes, I am talking from experience).</p><p>First of all we built our in-memory database in the <code class="literal">Module.php</code> for the authentication. We then created a table called <code class="literal">users</code>, with a unique ID, username, and password. The ID consist of an integer, the username a variable character of 20 positions, and the password will be a character of 32, as that is the size of an MD5 encrypted string.</p><p>Because we set up a user table, and connected that table to the authentication adapter, we were able to authenticate the username and password simply. As an extra measure we made sure the user can't go to any other page than the login page when he isn't logged in, which we did by using an event that happens before the output was send to the user.</p></div></div>
<div class="section" title="Writing a custom Authentication method"><div class="titlepage"><div><div><h1 class="title"><a id="ch07lvl1sec44"/>Writing a custom Authentication method</h1></div></div></div><p>Sometimes<a id="id587" class="indexterm"/> the standard methods just don't cut it, and that is okay. That is why this recipe gives a clear insight into how to create our own authentication method.</p><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch07lvl2sec103"/>Getting ready</h2></div></div></div><p>For this recipe it would be preferred if there is a web environment that has SSL enabled. Configuring such an environment is outside the scope but it would be beneficial for the execution of this recipe.</p><p>An example of an environment like this would be an Apache 2 web server with <code class="literal">mod_ssl</code> correctly configured. To enable the certificate verification on Apache2, one needs to place the following code in their <code class="literal">public/.htaccess</code> file:</p><div class="informalexample"><pre class="programlisting"># Only execute the following code when mod_ssl is 
# enabled
&lt;IfModule mod_ssl.c&gt;
  # This means the client can present their 
  # certificate, but it doesn't need to be verifiable 
  # by the server
  SSLVerifyClient optional_no_ca

  # This depth means the certificate can only be self-
  # signed otherwise it will be denied
  SSLVerifyDepth 0

  # We want to export the standard variables but also 
  # the certificate data as well to use in PHP
  SSLOptions +StdEnvVars +ExportCertData 
&lt;/IfModule&gt;</pre></div><p>Another thing that is important to mention is that PHP should be configured (and compiled) with the <code class="literal">--with-openssl</code> parameter, otherwise the code to parse the certificate will not exist and thus, we would not be able to use the code. More information on how to do this can be found at <a class="ulink" href="http://www.php.net/manual/en/book.openssl.php">http://www.php.net/manual/en/book.openssl.php</a>.</p></div><div class="section" title="How to do it…"><div class="titlepage"><div><div><h2 class="title"><a id="ch07lvl2sec104"/>How to do it…</h2></div></div></div><p>Authentication by<a id="id588" class="indexterm"/> certification might be rare, but it is sometimes used when the level of security is a little bit higher than the average web application. In this recipe we will show an example of a certificate-based authentication.</p><div class="section" title="Creating our adapter"><div class="titlepage"><div><div><h3 class="title"><a id="ch07lvl3sec211"/>Creating our adapter</h3></div></div></div><p>Let's get <a id="id589" class="indexterm"/>started by creating our new adapter, which will be an implementation of <code class="literal">Zend\Authentication\Adapter\AdapterInterface</code> as we want to integrate as much as possible with the current authentication adapters.</p><p>As we already have an Authentication module from the previous recipe, we will just take that as the namespace in which we are going to work; just as easy as described earlier.</p><p>First let's create the adapter (the file is <code class="literal">/module/Authentication/src/Authentication/Adapter/Certificate.php</code>).</p></div><div class="section" title="The adapter outline"><div class="titlepage"><div><div><h3 class="title"><a id="ch07lvl3sec212"/>The adapter outline</h3></div></div></div><p>We'll <a id="id590" class="indexterm"/>first start with our basic class outline:</p><div class="informalexample"><pre class="programlisting">// Set the right namespace
namespace Authentication\Adapter;

// We will use this to implement the right methods
use Zend\Authentication\Adapter\AdapterInterface;

// Out class name, not to forget the implementation
class Certificate implements AdapterInterface
{
  // Currently authenticate is the only method required 
  // for the AdapterInterface; lucky us!
  public function authenticate() {}
}</pre></div></div><div class="section" title="Creating a getter and setter for any error messages"><div class="titlepage"><div><div><h3 class="title"><a id="ch07lvl3sec213"/>Creating a getter and setter for any error messages</h3></div></div></div><p>Normally<a id="id591" class="indexterm"/> we would come up with error messages as we go in development. But as this code is already made, we already have the error messages defined. There is no good way to describe these getters and setters, so we will just show them in the following piece of code so that it is at least clear what is going on (the file is <code class="literal">/module/Authentication/src/Authentication/Adapter/Certificate.php</code>):</p><div class="informalexample"><pre class="programlisting">// After coding the adapter we found the following 
// errors that need to be relayed to the user/developer

// Invalid certificate, there is no certificate set
const AUTH_FAIL_INV_CERT = 0;

// Insecure connection, no HTTPS
const AUTH_FAIL_NO_HTTPS = 1;

// Couldn't parse the certificate, invalid certificate
const AUTH_FAIL_PARSE_CERT = 2;

// Certificate is expired
const AUTH_FAIL_EXP_CERT = 3;

// Not all the required fields we need are in the 
// certificate, thus rendering it invalid
const AUTH_FAIL_NOT_ALL_FIELDS = 4;

// No Database adapter was provided
const AUTH_FAIL_NO_DB_ADAPTER = 5;

// An error occurred in the SQL
const AUTH_FAIL_SQL_ERR = 6;

// The user requested couldn't be found
const AUTH_FAIL_NO_USER = 7;

// By default we have no error
private $error = -1;</pre></div><p>These are the <a id="id592" class="indexterm"/>error messages we thought of and will be used somewhere in the code later on. Now let's create the setter for these error messages so that the getter can easily retrieve them later on:</p><div class="informalexample"><pre class="programlisting">/**
 * Sets an error.
 * 
 * @param int $error
 */
private function setError($error) 
{
  $this-&gt;error = $error;
}</pre></div><p>Well that <a id="id593" class="indexterm"/>was exciting. Let's create the getter now, which is slightly more elaborate, but only just a little:</p><div class="informalexample"><pre class="programlisting">/**
 * Gets the latest error message back.
 * 
 * @return string
 */
public function getErrorMessage() 
{
  switch ($this-&gt;error) {
    case self::AUTH_FAIL_SQL_ERR:
      $retval = "SQL error occurred while checking " 
              . "for the user.";
      break;
    case self::AUTH_FAIL_INV_CERT:
      $retval = "Certificate provided is invalid.";
      break;
    case self::AUTH_FAIL_PARSE_CERT:
      $retval = "Certificate provided couldn't be "
              . "parsed.";
      break;
    case self::AUTH_FAIL_EXP_CERT:
      $retval = "Certificate has expired.";
      break;
    case self::AUTH_FAIL_NO_DB_ADAPTER:
      $retval = "No Database adapter set.";
      break;
    case self::AUTH_FAIL_NOT_ALL_FIELDS:
      $retval = "Not all the fields required are " 
              . "available.";
      break;
    case self::AUTH_FAIL_NO_USER:
      $retval = "The user could not be found.";
      break;
    case self::AUTH_FAIL_NO_HTTPS:
      $retval = "Connection is not secure.";
      break;
    case -1:
      $retval = "No error occurred.";
      break;
    default:
      $retval = "Unknown error occurred.";
      break;
  }

  // Reset the error
  $this-&gt;error = -1;

  // Return the string with the error message
  return $retval;
}</pre></div></div><div class="section" title="Making sure we have a secure connection"><div class="titlepage"><div><div><h3 class="title"><a id="ch07lvl3sec214"/>Making sure we have a secure connection</h3></div></div></div><p>Although <a id="id594" class="indexterm"/>certificates are only sent when we do have an SSL connection, an extra check isn't that bad as we want to be certain that the user is using a secure connection.</p><div class="informalexample"><pre class="programlisting">/**
 * Returns true if the current connection is through 
 * HTTPS.
 * 
 * @return boolean
 */
private function isHTTPS()
{
  return isset($_SERVER['HTTPS']) ? true : false;
} </pre></div><p>Wow, that must have been the best method ever! All joking aside, it is fairly simple as the <code class="literal">HTTPS</code> key is given in the <code class="literal">$_SERVER</code> variable, whenever a secure connection through HTTPS is set up. When the key is present, we can assume that there is a secure connection.</p></div><div class="section" title="Checking if the certificate is an actual certificate"><div class="titlepage"><div><div><h3 class="title"><a id="ch07lvl3sec215"/>Checking if the certificate is an actual certificate</h3></div></div></div><p>Next up is to <a id="id595" class="indexterm"/>check if the certificate is valid or not, but before we can do that we should also make sure there is a way to set the certificate as well:</p><div class="informalexample"><pre class="programlisting">// This property will store our certificate array
private $certificate;

/**
 * Sets (and parses) a certificate, returns false if the 
 * certificate couldn't be parsed.
 * 
 * @param string $certificateContent
 * @return boolean
 */
public function setCertificate($certificateContent) 
{
  // This function is part of the OpenSSL extension in 
  // PHP. This means that if OpenSSL is not installed 
  // into PHP this function will not exist and thus give 
  // a fatal error. This function deciphers the 
  // information received in the certificate to a great 
  // array with variables.
  $certificate = openssl_x509_parse(
               $certificateContent
  );

  // If the certificate can't be parsed (i.e. it is 
  // invalid) the function above will return false
  if ($certificate !== false) {
    // We can be sure the certificate is valid at least 
    // in raw state now
    $this-&gt;certificate = $certificate;

    // Done here
    return true;
  } else {
    // Use the failure to parse certificate here to make 
    // sure the developer/user will know what is going 
    // on
    $this-&gt;setError(self::AUTH_FAIL_PARSE_CERT);
    return false;
  }
}</pre></div><p>This method did a basic check to see if we actually got a certificate that is at least valid, even if it is expired or doesn't have  any of our fields.</p></div><div class="section" title="Checking if we have all the certificate fields"><div class="titlepage"><div><div><h3 class="title"><a id="ch07lvl3sec216"/>Checking if we have all the certificate fields</h3></div></div></div><p>As we want<a id="id596" class="indexterm"/> to check the e-mail address in our certificate, we need to make sure we actually have an e-mail address in there as well. And while we are at it, we will also check for a couple of other fields that are not relevant to our authentication, but would be nice to have anyway:</p><div class="informalexample"><pre class="programlisting">/**
 * Checks if all our fields (issuer, issuer[O], 
 * issuer[CN], issuer[emailAddress], serialNumber) are 
 * in the certificate.
 * 
 * @return boolean
 */
private function checkRequiredFields()
{
  // First get our certificate
  $certificate = $this-&gt;getCertificate();

  // Check if our certificate at least is valid
  if ($certificate !== false) {
    // We want to check if the following fields (and 
    // subfields) are in the certificate
    $required = array(
      'issuer' =&gt; array('O', 'CN', 'emailAddress'), 
      'serialNumber' =&gt; null
    );

    // Loop through the primary fields
    foreach ($required as $field=&gt;$value) {
      if (in_array($field, $certificate) === true) {
        // The primary field is in there, check if 
        // there are any secondary fields we need to 
        // check
        if (is_array($value &amp;&amp; is_array($certificate[$field) {
          // Loop through the secondary fields
          foreach ($value as $key) {
            // Now check of our values are in there
            if (in_array(
              $key, 
              array_keys(
                $certificate[$field])) === false) 
              {
                return false;
              }
            }
          }
        } else {
          return false;
        }
      }

      // If we reach this point, we are always ok to go
      $retval = true;

      unset($required);
    }

  unset($certificate);

  return isset($retval) ? $retval : false;
}</pre></div><p>We check <a id="id597" class="indexterm"/>if the fields are in there, and if the field isn't in there we will return false.</p></div><div class="section" title="Checking if the certificate isn't expired yet"><div class="titlepage"><div><div><h3 class="title"><a id="ch07lvl3sec217"/>Checking if the certificate isn't expired yet</h3></div></div></div><p>Now we <a id="id598" class="indexterm"/>want to know if the certificate is still valid in terms of time, as certificates usually expire after a set time (this can be months, weeks, years, anything really):</p><div class="informalexample"><pre class="programlisting">/**
 * Checks if the current certificate is valid or not.
 * 
 * @return boolean
 */
private function isCertificateValid()
{
  // Get our certificate again
  $certificate = $this-&gt;getCertificate();

  // Again make sure it is not false (highly unlikely 
  // here, but hey, never be sure
  if ($certificate !== false) {
    // Check if the valid from and to fields are set, 
    // because if they are not, we won't be able to 
    // check if the certificate is valid or not
    if (isset($certificate['validFrom_time_t']) === true &amp;&amp; isset($certificate['validTo_time_t']) === true)  
    { 
      // Check if the from time is smaller than our 
      // current time and the to time is bigger than the 
      // current time
    if (time() &gt;= $certificate['validFrom_time_t'] &amp;&amp; time() &lt; $certificate['validTo_time_t']) 
      {
        $retval = true;
      }
    }
  }

  unset($certificate);

  return isset($retval) ? $retval : false;
}</pre></div><p>If this method <a id="id599" class="indexterm"/>returns true, we can be sure that we have a certificate that isn't expired.</p></div><div class="section" title="Creating a getter and setter for the Database adapter"><div class="titlepage"><div><div><h3 class="title"><a id="ch07lvl3sec218"/>Creating a getter and setter for the Database adapter</h3></div></div></div><p>Now we <a id="id600" class="indexterm"/>need a simple getter and setter for our database adapter, before we can actually do the authentication:</p><div class="informalexample"><pre class="programlisting">/**
 * Our Database adapter property.
 * 
 * @var \Zend\Db\Adapter\Adapter
 */
private $dbAdapter;
	
/**
 * Sets the Db adapter.
 *	
 * @param \Zend\Db\Adapter\Adapter $db
 */
public function setDbAdapter(\Zend\Db\Adapter\Adapter $db) 
{
  $this-&gt;dbAdapter = $db;
}
	
/**
 * Returns the Db adapter.
 * 
 * @return \Zend\Db\Adapter\Adapter
 */
private function getDbAdapter()
{
  return $this-&gt;dbAdapter;
}</pre></div><p>Of course <a id="id601" class="indexterm"/>this was again very simple, as it requires no logic at all. Now that we have set our database adapter, we can actually begin authenticating the user.</p></div><div class="section" title="Creating the authenticate method"><div class="titlepage"><div><div><h3 class="title"><a id="ch07lvl3sec219"/>Creating the authenticate method</h3></div></div></div><p>This <a id="id602" class="indexterm"/>method will implement all our previously defined methods and if they are all successful, it will authenticate through the database and see if our user is there (or not). But first, we need another method to get fields from our certificate, which is a neater way, and a method to get our identity once authenticated:</p><div class="informalexample"><pre class="programlisting">// We will store our identity in here, once 
// authenticated
private $identity;

/**
 * Retrieves a variable from the certificate, returns 
 * null if not found.
 * 
 * @param string $variable
 * @return string
 */
private function getCertificateVariable($variable)
{
  if (is_array($this-&gt;certificate) === true &amp;&amp; isset($this-&gt;certificate[$variable]) === true) 
  {
    return $this-&gt;certificate[$variable];
  } else if (is_array($this-&gt;certificate) === true &amp;&amp; isset($this-&gt;certificate['issuer'][$variable) 
  {
    return $this-&gt;certificate['issuer'][$variable];
  } else {
    return null;
  }
}

/**
 * Retrieves the identity of the user.
 * 
 * @return array
 */
public function getIdentity() 
{
  return $this-&gt;identity;
}</pre></div><p>And now <a id="id603" class="indexterm"/>for the supreme moment, after a long wait, finally the <code class="literal">authenticate</code> method!</p><div class="informalexample"><pre class="programlisting">/**
 * Tries to authenticate the user through the 
 * certificate.
 * 
 * @return boolean
 */
public function authenticate() 
{
  $continue = true;

  if ($this-&gt;getDbAdapter() !== null) {
    // Check if we are on a secure connection
    if ($this-&gt;isHTTPS() === true) {
      // Check if the certificate is valid
      if ($this-&gt;getCertificate() !== false) {
        // Check if the fields we require are available
        if ($this-&gt;checkRequiredFields() === true) {
          // Check if the certificate isn't expired
          if ($this-&gt;isCertificateValid() === false) {
            // Certificate is expired!
            $this-&gt;setError(self::AUTH_FAIL_EXP_CERT);
            $continue = false;
          }
        } else {
          // Not all the fields are available
          $this-&gt;setError(
              self::AUTH_FAIL_NOT_ALL_FIELDS
          );
          $continue = false;
        }
      } else {
        // This is an invalid certificate
        $this-&gt;setError(self::AUTH_FAIL_INV_CERT);
        $continue = false;
      }
    } else {
      // Oh, oh, no secure connection
      $this-&gt;setError(self::AUTH_FAIL_NO_HTTPS);
      $continue = false;
    }
  } else {
    // We don't have a db adapter
    $this-&gt;setError(self::AUTH_FAIL_NO_DB_ADAPTER);
    $continue = false;
  }

  if ($continue === true) {
    // Now we are going to check with the database if 
    // the email address is in there
    $statement = $this-&gt;getDbAdapter()-&gt;createStatement(
      "SELECT * FROM users WHERE email = :email"
    );

    try { 
      // Input the email address in the statement and 
      // execute it on the database adapter
      $result = $statement-&gt;execute(array(
        'email' =&gt; $this-&gt;getCertificateVariable(
            'emailAddress'
        )
      ));

      // Check if we have one result
      if ($result-&gt;count() === 1) {
        // One result found, put it in the identity kit
        $this-&gt;identity = $result-&gt;current();

        // Because we are super-cool add some of our 
        // certificate variables as well
        $this-&gt;identity['serialNumber'] = 
          $this-&gt;getCertificateVariable('serialNumber');
        
        $this-&gt;identity['organization'] = 
          $this-&gt;getCertificateVariable('O');

        $this-&gt;identity['commonName'] = 
          $this-&gt;getCertificateVariable('CN');

        // We successfully found our user
        $retval = true;
      } else {
        $this-&gt;setError(self::AUTH_FAIL_NO_USER);
      }
    } catch (\Exception $e) {
      $this-&gt;setError(self::AUTH_FAIL_SQL_ERR);
      error_log($e-&gt;getMessage());
    }
  }

  // Return the retval is we have one, otherwise just 
  // false
  return isset($retval) ? $retval : false;
}</pre></div><p>And that's it! The <code class="literal">authenticate</code> method will either return true on successful authentication <a id="id604" class="indexterm"/>or false, and will set an error at the same time so that we can see what exactly went wrong!</p></div></div><div class="section" title="How it works…"><div class="titlepage"><div><div><h2 class="title"><a id="ch07lvl2sec105"/>How it works…</h2></div></div></div><p>Now that we have created our own <code class="literal">authentication</code> adapter, it is time to sit back and review what we just did.</p><div class="section" title="What are we trying to achieve"><div class="titlepage"><div><div><h3 class="title"><a id="ch07lvl3sec220"/>What are we trying to achieve</h3></div></div></div><p>On some websites the access is prohibited on such a level that usernames and passwords are a thing of the past. In environments where we want to check every customer that comes in without them needing to type the username and password themselves, we might use certificate authentication.</p><p>Certificate authentication works because the client will send a certificate with every server request they do. This certificate then shows the server <span class="emphasis"><em>who</em></span> the user is, who is trying to browse their pages. Usually one or more fields in the certificate are used to identify the user. In our example we will use the e-mail address, which is a common field to be used for identification.</p><p>What we will do first off, is create an adapter that will get the certificate either from manual input (easier testing that way) or the browser, whichever works really. We will then check if the e-mail address exists in our database, and if so we consider the user logged in. Obviously our server will not be configured so strictly that no certificate will be allowed, as in this stage basically every certificate with a right e-mail address gets access. If we want to know how we can prevent users from using any certificate, we can take a look at the <span class="emphasis"><em>There's more…</em></span> section, where we will look in the direction of securing your server a bit further, and restricting the certificate use.</p><p>From an application point of view, however, we just presume that all the certificates that we get, are valid.</p><p>The <code class="literal">AdapterInterface</code> only requires us to have an authenticate method. But before we can go ahead we want to make sure that the following items are checked:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">We want to make sure the user is coming through a secure connection (HTTPS)</li><li class="listitem" style="list-style-type: disc">We also want to make sure the certificate is valid (obviously)</li><li class="listitem" style="list-style-type: disc">While we are checking, we'll make sure our certificate has the fields we require for authentication</li><li class="listitem" style="list-style-type: disc">And we need to know if the certificate is still valid and not expired</li><li class="listitem" style="list-style-type: disc">Last but not least, we also need to make sure that we have a database adapter to check the values against</li></ul></div></div><div class="section" title="About certificates"><div class="titlepage"><div><div><h3 class="title"><a id="ch07lvl3sec221"/>About certificates</h3></div></div></div><p>In general the<a id="id605" class="indexterm"/> certificates are validated on the server before they reach the application. The validation usually happens against some sort of CA, or Certificate Authority, which is basically an entity on the server site that issues certificates, and therefore can vouch for any certificates carrying its signature. Of course in real life this is way more complicated than just described, but the idea is the same. So when a certain level of checking is being done on the server to verify the identity of the certificate, and if it is valid against the CA provided by the server, it will then parse it through to our application.</p><p>By the time it reaches our application, we usually assume that the user got the certificate from us, and therefore should be allowed in, as he knew the password at the door. But although he knew the password, that doesn't mean we know who it is! That is why a second authentication (the one we just made) verifies if a user actually belongs in our application or not, that is, if it is a valid certificate or not!</p></div></div><div class="section" title="There's more…"><div class="titlepage"><div><div><h2 class="title"><a id="ch07lvl2sec106"/>There's more…</h2></div></div></div><p>Securing a server is the most important part of this kind of validation, as we really (really, really) need to be sure that the user carrying the certificate is actually valid. Usually building complex servers like this are done with server engineers and not the task of the developer, but if it is then it would be a great idea to read up on the subject first.</p><p>Personally, I am a fan of Apache and would recommend anyone to read up on the <code class="literal">mod_ssl</code> configuration, as it is very thorough on the subject of securing a server and it has a lot of resources to find out how to configure it just right.</p><p>But in the end configuring SSL without the proper know-how is a very tedious and error-prone process and it is likely that properly configuring a server is a bit over the head of a developer. In that case getting a server engineer to do it for us is the best way, and the laziest, which lets us concentrate on our work!</p></div></div></body></html>