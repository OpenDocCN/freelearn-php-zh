<html><head></head><body><div class="chapter" title="Chapter&#xA0;3.&#xA0;Pushing the Search"><div class="titlepage"><div><div><h1 class="title"><a id="ch03"/>Chapter 3. Pushing the Search</h1></div></div></div><p>In this chapter, we will cover:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Performing GROUP and COUNT queries</li><li class="listitem" style="list-style-type: disc">Using virtual fields</li><li class="listitem" style="list-style-type: disc">Building queries with ad-hoc JOINs</li><li class="listitem" style="list-style-type: disc">Searching for all items that match search terms</li><li class="listitem" style="list-style-type: disc">Implementing a custom find type</li><li class="listitem" style="list-style-type: disc">Paginating a custom find type</li><li class="listitem" style="list-style-type: disc">Implementing AJAX-based pagination</li></ul></div><div class="section" title="Introduction"><div class="titlepage"><div><div><h1 class="title"><a id="ch03lvl1sec01"/>Introduction</h1></div></div></div><p>Using models to fetch data is one of the most important aspects of any CakePHP application. As such, a good use of the find functions the framework provides can certainly guarantee the success of our application, and as importantly ensure that our code is readable and maintainable.</p><p>CakePHP provides the following basic find types:<a id="id70" class="indexterm"/>
</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">all</code>: To find all records that match the given find options.<a id="id71" class="indexterm"/></li><li class="listitem" style="list-style-type: disc"><code class="literal">count</code>: To count how many records match the given options.<a id="id72" class="indexterm"/></li><li class="listitem" style="list-style-type: disc"><code class="literal">first</code>: To find the first record that matches the given find options.<a id="id73" class="indexterm"/></li><li class="listitem" style="list-style-type: disc"><code class="literal">list</code>: To find all records that match the given find options, and formats them as a list, using the format provided.<a id="id74" class="indexterm"/></li><li class="listitem" style="list-style-type: disc"><code class="literal">neighbors</code>: To find the previous and after records of a matching record, based on the value of a particular field.<a id="id75" class="indexterm"/></li><li class="listitem" style="list-style-type: disc"><code class="literal">threaded</code>: To finds a set of results, and return them in a hierarchy, based on the value of a field named<code class="literal"> parent_id</code>.<a id="id76" class="indexterm"/></li></ul></div><p>Mastering these types is as easy as understanding the available find options all types deal with. In this chapter, we have several recipes to make the most out of these options, and to resort to manual SQL based queries when the need arises.</p><p>CakePHP also lets us define our custom find types that will extend the three basic ones, allowing our code to be even more readable. The last recipes in this chapter show us how to create our own find type, with pagination support.</p></div></div>
<div class="section" title="Performing GROUP and COUNT queries"><div class="titlepage"><div><div><h1 class="title"><a id="ch03lvl1sec02"/>Performing GROUP and COUNT queries</h1></div></div></div><p>This recipe shows how to use CakePHP's built-in find types to perform relatively complex<code class="literal"> GROUP</code> and<code class="literal"> COUNT</code> queries, including the combination of both.<a id="id77" class="indexterm"/>
</p><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec01"/>Getting ready</h2></div></div></div><p>To go through this recipe we need some sample tables to work with.</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Create a table named<code class="literal"> users</code>, using the following SQL statement:<div class="informalexample"><pre class="programlisting">CREATE TABLE `users`(
`id` INT UNSIGNED AUTO_INCREMENT NOT NULL,
`name` VARCHAR(255) NOT NULL,
`email` VARCHAR(255) NOT NULL,
PRIMARY KEY(`id`)
);
</pre></div></li><li class="listitem">Create a table named<code class="literal"> blogs</code>, using the following SQL statement:<div class="informalexample"><pre class="programlisting">CREATE TABLE `blogs`(
`id` INT UNSIGNED AUTO_INCREMENT NOT NULL,
`user_id` INT UNSIGNED NOT NULL,
`name` VARCHAR(255) NOT NULL,
PRIMARY KEY(`id`),
KEY `user_id`(`user_id`),
CONSTRAINT `blogs__users` FOREIGN KEY(`user_id`) REFERENCES `users`(`id`)
);
</pre></div></li><li class="listitem">Create a table named<code class="literal"> posts</code>, using the following SQL statement:<div class="informalexample"><pre class="programlisting">CREATE TABLE `posts`(
`id` INT UNSIGNED AUTO_INCREMENT NOT NULL,
`blog_id` INT UNSIGNED NOT NULL,
`title` VARCHAR(255) NOT NULL,
`body` TEXT NOT NULL,
`created` DATETIME NOT NULL,
`modified` DATETIME NOT NULL,
PRIMARY KEY(`id`),
KEY `blog_id`(`blog_id`),
CONSTRAINT `posts__blogs` FOREIGN KEY(`blog_id`) REFERENCES `blogs`(`id`)
);
</pre></div></li><li class="listitem">Add some sample data, using the following SQL statements:<a id="id78" class="indexterm"/><div class="informalexample"><pre class="programlisting">INSERT INTO `users`(`id`, `name`, `email`) VALUES
(1, 'John Doe', 'john.doe@example.com'),
(2, 'Jane Doe', 'jane.doe@example.com');
INSERT INTO `blogs`(`user_id`, `name`) VALUES
(1, 'John Doe\'s Blog'),
(2, 'Jane Doe\'s Blog');
INSERT INTO `posts`(`blog_id`, `title`, `body`, `created`, `modified`) VALUES
(1, 'John\'s Post 1', 'Body for John\'s Post 1', '2010-04-19 14:00:00', '2010-04-19 14:00:00'),
(1, 'John\'s Post 2', 'Body for John\'s Post 2', '2010-04-19 14:30:00', '2010-04-19 14:30:00'),
(1, 'John\'s Post 3', 'Body for John\'s Post 3', '2010-04-20 14:00:00', '2010-04-20 14:00:00'),
(1, 'John\'s Post 4', 'Body for John\'s Post 4', '2010-05-03 14:00:00', '2010-05-03 14:00:00'),
(2, 'Jane\'s Post 1', 'Body for Jane\'s Post 1', '2010-04-19 15:00:00', '2010-04-19 15:00:00'),
(2, 'Jane\'s Post 2', 'Body for Jane\'s Post 2', '2010-06-18 15:00:00', '2010-06-18 15:00:00'),
(2, 'Jane\'s Post 3', 'Body for Jane\'s Post 3', '2010-10-06 15:00:00', '2010-10-06 15:00:00');
</pre></div></li><li class="listitem">We proceed now to create the required model. Create the model<code class="literal"> Post</code> in a file named<code class="literal"> post.php</code> and place it in your<code class="literal"> app/models</code> folder with the following contents:<div class="informalexample"><pre class="programlisting">&lt;?php
class Post extends AppModel {
public $belongsTo = array('Blog');
}
?&gt;
</pre></div></li><li class="listitem">We will put all our example code in the<code class="literal"> index()</code> method of a controller. Create a file named<code class="literal"> posts_controller.php</code> and place it in your<code class="literal"> app/controllers</code> folder with the following contents:<div class="informalexample"><pre class="programlisting">&lt;?php
class PostsController extends AppController {
public function index() {
$this-&gt;set(compact('data'));
}
}
?&gt;
</pre></div></li><li class="listitem">Now, create a folder named<code class="literal"> posts</code> and place it in your<code class="literal"> app/views</code> folder. Inside this newly created folder, create a file named<code class="literal"> index.ctp</code>, with the following contents:<a id="id79" class="indexterm"/><div class="informalexample"><pre class="programlisting">&lt;?php debug($data); ?&gt;
</pre></div></li></ol></div><div class="section" title="How to do it..."><div class="titlepage"><div><div><h3 class="title"><a id="ch03lvl2sec02"/>How to do it...</h3></div></div></div><p>Grouping rows by a certain field is as simple as specifying the group setting when issuing a<code class="literal"> find</code> operation. For example, the following statement, while not exactly practical by itself, shows how to use the setting:</p><div class="informalexample"><pre class="programlisting">$data = $this-&gt;Post-&gt;find('all', array(
'group' =&gt; array('Blog.id')
));
</pre></div><p>If we also want to obtain the number of rows for each grouped set, which in our case means the number of posts per blog, we would do:</p><div class="informalexample"><pre class="programlisting">$data = $this-&gt;Post-&gt;find('all', array(
'fields' =&gt; array('COUNT(Post.id) AS total', 'Blog.*'),
'group' =&gt; array('Blog.id')
));
</pre></div><p>The preceding query will return the following data structure:</p><div class="informalexample"><pre class="programlisting">array(
array(
0 =&gt; array(
'total' =&gt; 4
),
'Blog' =&gt; array(
'id' =&gt; 1,
'user_id' =&gt; 1,
'name' =&gt; 'John Doe\'s Blog'
)
),
array(
0 =&gt; array(
'total' =&gt; 3
),
'Blog' =&gt; array(
'id' =&gt; 2,
'user_id' =&gt; 2,
'name' =&gt; 'Jane Doe\'s Blog'
)
)
)
</pre></div><p>Let us now make sure that every time we have a calculated field (which come in the index<code class="literal"> 0</code> of each resulting row), they become part of the resulting model, for easier readability. To do so, we override the<code class="literal"> afterFind()</code> method. If you don't have one already, create a file named<code class="literal"> app_model.php</code> in your<code class="literal"> app/</code> folder. Make sure your<code class="literal"> AppModel</code> class includes the following contents:<a id="id80" class="indexterm"/>
</p><div class="informalexample"><pre class="programlisting">&lt;?php
class AppModel extends Model {
public function afterFind($results, $primary = false) {
if (!empty($results)) {
foreach($results as $i =&gt; $row) {
if (!empty($row[0])) {
foreach($row[0] as $field =&gt; $value) {
if (!empty($row[$this-&gt;alias][$field])) {
$field = 'total_' . $field;
}
$results[$i][$this-&gt;alias][$field] = $value;
}
unset($results[$i][0]);
}
}
}
return parent::afterFind($results, $primary);
}
}
?&gt;
</pre></div><div class="note" title="Note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="note10"/>Note</h3><p>Whenever you override a model method, such as<code class="literal"> beforeFind()</code> or<code class="literal"> afterFind()</code>, make sure you call the parent implementation by using the<code class="literal"> parent</code> keyword.</p></div><p>As a result, the previous query, which uses<code class="literal"> GROUP</code> and<code class="literal"> COUNT</code>, will now look like a much more readable result set:</p><div class="informalexample"><pre class="programlisting">array(
array(
'Blog' =&gt; array(
'id' =&gt; 1,
'user_id' =&gt; 1,
'name' =&gt; 'John Doe\'s Blog'
),
'Post' =&gt; array(
'total' =&gt; 4
)
),
array(
'Blog' =&gt; array(
'id' =&gt; 2,
'user_id' =&gt; 2,
'name' =&gt; 'Jane Doe\'s Blog'
),
'Post' =&gt; array(
'total' =&gt; 3
)
)
)
</pre></div><p>If we want to subdivide the post counts for each blog according to the month they were created on, we would have to add another level of grouping:<a id="id81" class="indexterm"/>
</p><div class="informalexample"><pre class="programlisting">$data = $this-&gt;Post-&gt;find('all', array(
'fields' =&gt; array(
'CONCAT(YEAR(Post.created), \'-\', MONTH(Post.created)) AS period',
'COUNT(Post.id) AS total',
'Blog.*'
),
'group' =&gt; array('Blog.id', 'period')
));
</pre></div><p>Considering our<code class="literal"> afterFind</code> implementation, the preceding query would produce the following results:</p><div class="informalexample"><pre class="programlisting">array(
array(
'Blog' =&gt; array(
'id' =&gt; 1,
'user_id' =&gt; 1,
'name' =&gt; 'John Doe\'s Blog'
),
'Post' =&gt; array(
'period' =&gt; '2010-4',
'total' =&gt; 4
)
),
array(
'Blog' =&gt; array(
'id' =&gt; 1,
'user_id' =&gt; 1,
'name' =&gt; 'John Doe\'s Blog'
),
'Post' =&gt; array(
'period' =&gt; '2010-5',
'total' =&gt; 1
)
),
array(
'Blog' =&gt; array(
'id' =&gt; 2,
'user_id' =&gt; 2,
'name' =&gt; 'Jane Doe\'s Blog'
),
'Post' =&gt; array(
'period' =&gt; '2010-10',
'total' =&gt; 1
)
),
array(
'Blog' =&gt; array(
'id' =&gt; 2,
'user_id' =&gt; 2,
'name' =&gt; 'Jane Doe\'s Blog'
),
'Post' =&gt; array(
'period' =&gt; '2010-4',
'total' =&gt; 1
)
)
array(
'Blog' =&gt; array(
'id' =&gt; 2,
'user_id' =&gt; 2,
'name' =&gt; 'Jane Doe\'s Blog'
),
'Post' =&gt; array(
'period' =&gt; '2010-6',
'total' =&gt; 1
)
)
)
</pre></div></div><div class="section" title="How it works..."><div class="titlepage"><div><div><h3 class="title"><a id="ch03lvl2sec03"/>How it works...</h3></div></div></div><p>We use the<code class="literal"> group</code> find setting to specify what fields will be used for grouping the resulting rows. That setting is given as an array, where each element is a field to group in. When we specify more than one field, such as the last example in the recipe, grouping of rows occurs in the given order of grouping fields.</p><p>Calculated fields, that is, expressions that result in a value (such as the<code class="literal"> COUNT(*) AS total</code> expression used throughout the recipe) are placed in the index<code class="literal"> 0</code> of each resulting row, because they are not real fields defined in the model. Because of that, we overrode the<code class="literal"> afterFind()</code> method, executed after a result for a find operation is obtained, and with some basic logic we make sure those calculated fields get included in the resulting row within a much more readable index: the model name.</p><p>The last example in the recipe shows not only how to group on more than one field, but how to properly use some SQL methods (such as<code class="literal"> MONTH</code> and<code class="literal"> YEAR</code>) with an alias, so we can easily return the value of that expression and also use it to group or optionally order the rows.</p></div><div class="section" title="See also"><div class="titlepage"><div><div><h3 class="title"><a id="ch03lvl2sec04"/>See also</h3></div></div></div><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><span class="emphasis"><em>Using virtual fields</em></span></li></ul></div></div></div></div>
<div class="section" title="Using virtual fields"><div class="titlepage"><div><div><h1 class="title"><a id="ch03lvl1sec03"/>Using virtual fields</h1></div></div></div><p>In the recipe,<span class="emphasis"><em> Performing GROUP and COUNT queries</em></span>, we learnt how to add computed SQL expressions to a<code class="literal"> find</code> operation. Some of these expressions may be needed regularly for a model, introducing the need for virtual fields.<a id="id82" class="indexterm"/>
</p><p>Using virtual fields, we get the resulting values of our SQL expressions as if they were real fields of our models. They allow us to get the same results shown in the previous recipe in a much more transparent way, without needing the override of<code class="literal"> afterFind</code>.</p><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec05"/>Getting ready</h2></div></div></div><p>We need some sample models and data to work with. Follow the<span class="emphasis"><em> Getting ready</em></span> section of the recipe,<span class="emphasis"><em> Performing GROUP and COUNT queries</em></span>.</p></div><div class="section" title="How to do it..."><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec06"/>How to do it...</h2></div></div></div><p>Open the<code class="literal"> Post</code> model and add the<code class="literal"> virtualfields</code> definition shown as follows:</p><div class="informalexample"><pre class="programlisting">&lt;?php
class Post extends AppModel {
public $belongsTo = array('Blog');
<span class="strong"><strong>public $virtualFields = array(
'period' =&gt; 'CONCAT(YEAR(Post.created), \'-\', MONTH(Post.created))',
'total' =&gt; 'COUNT(*)'
);</strong></span>
}
?&gt;
</pre></div><p>To obtain a count of all the posts per blog, grouped by the period they were created, we do:</p><div class="informalexample"><pre class="programlisting">$data = $this-&gt;Post-&gt;find('all', array(
'fields' =&gt; array(
'period',
'total',
'Blog.*'
),
'group' =&gt; array('Blog.id', 'period')
));
</pre></div><p>Using our sample data, the preceding query will result in the following array structure, which is exactly the same result as the one obtained in the last example shown in the recipe<span class="emphasis"><em> Performing GROUP and COUNT queries</em></span>:
<a id="id83" class="indexterm"/>
</p><div class="informalexample"><pre class="programlisting">array(
array(
'Blog' =&gt; array(
'id' =&gt; 1,
'user_id' =&gt; 1,
'name' =&gt; 'John Doe\'s Blog'
),
'Post' =&gt; array(
'period' =&gt; '2010-4',
'total' =&gt; 4
)
),
array(
'Blog' =&gt; array(
'id' =&gt; 1,
'user_id' =&gt; 1,
'name' =&gt; 'John Doe\'s Blog'
),
'Post' =&gt; array(
'period' =&gt; '2010-5',
'total' =&gt; 1
)
),
array(
'Blog' =&gt; array(
'id' =&gt; 2,
'user_id' =&gt; 2,
'name' =&gt; 'Jane Doe\'s Blog'
),
'Post' =&gt; array(
'period' =&gt; '2010-10',
'total' =&gt; 1
)
),
array(
'Blog' =&gt; array(
'id' =&gt; 2,
'user_id' =&gt; 2,
'name' =&gt; 'Jane Doe\'s Blog'
),
'Post' =&gt; array(
'period' =&gt; '2010-4',
'total' =&gt; 1
)
)
array(
'Blog' =&gt; array(
'id' =&gt; 2,
'user_id' =&gt; 2,
'name' =&gt; 'Jane Doe\'s Blog'
),
'Post' =&gt; array(
'period' =&gt; '2010-6',
'total' =&gt; 1
)
)
)
</pre></div><p>Virtual fields are always obtained when issuing a<code class="literal"> find</code> operation on the model. The only real way to avoid including them is specifying a list of fields to obtain in the find, and omitting the virtual fields:<a id="id84" class="indexterm"/>
</p><div class="informalexample"><pre class="programlisting">$data = $this-&gt;Post-&gt;find('all', array(
'fields' =&gt; array_keys($this-&gt;Post-&gt;schema())
));
</pre></div><div class="note" title="Note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="note11"/>Note</h3><p>The<code class="literal"> schema()</code> model function returns the list of real fields in the model, with information about each field, such as data type, and length.</p></div><p>We will now add a way for us to manage which virtual fields, if any, are returned. To do so, we override the<code class="literal"> beforeFind()</code> and<code class="literal"> afterFind()</code> model methods. If you don't have one already, create a file named<code class="literal"> app_model.php</code> in your<code class="literal"> app/</code> folder. Make sure your<code class="literal"> AppModel</code> class includes the following contents:</p><div class="informalexample"><pre class="programlisting">&lt;?php
class AppModel extends Model {
public function beforeFind($query) {
if (!empty($this-&gt;virtualFields)) {
$virtualFields = isset($query['virtualFields']) ?
$query['virtualFields'] :
array_keys($this-&gt;virtualFields);
if ($virtualFields !== true) {
$this-&gt;_backVirtualFields = $this-&gt;virtualFields;
$this-&gt;virtualFields = !empty($virtualFields) ?
array_intersect_key($this-&gt;virtualFields, array_flip((array) $virtualFields)) :
array();
}
}
return parent::beforeFind($query);
}
public function afterFind($results, $primary = false) {
if (!empty($this-&gt;_backVirtualFields)) {
$this-&gt;virtualFields = $this-&gt;_backVirtualFields;
}
return parent::afterFind($results, $primary);
}
}
?&gt;
</pre></div><p>If we want to disable virtual fields when issuing a<code class="literal"> find</code> operation, we can easily do so by specifying the<code class="literal"> virtualFields</code> find setting to<code class="literal"> false</code>. We can also set it to the list of virtual fields we want to include. For example, to only include the<code class="literal"> period</code> virtual field, we do:<a id="id85" class="indexterm"/>
</p><div class="informalexample"><pre class="programlisting">$person = $this-&gt;Post-&gt;find('all', array(
<span class="strong"><strong>'virtualFields' =&gt; array('period')</strong></span>
));
</pre></div></div><div class="section" title="How it works..."><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec07"/>How it works...</h2></div></div></div><p>CakePHP treats virtual fields almost as if they were real model fields. They are not exactly like real fields because we cannot specify a value for a virtual field when creating / editing a model record. However, in regards to<code class="literal"> find</code> operations, they are treated like any other field.</p><p>Virtual fields are included on every<code class="literal"> find</code> operation performed against the model to which they belong. However, there are times were we don't want or need certain virtual fields. This is particularly important when we include virtual fields that depend on grouping expressions, such as<code class="literal"> COUNT</code>, as they affect the number of rows returned. In these cases, we want to be able to specify what, or even if, virtual fields should be returned.</p><p>To allow us to control virtual fields returned from a<code class="literal"> find</code> operation, we add a new find setting by overriding the<code class="literal"> beforeFind</code> and<code class="literal"> afterFind</code> model callbacks. In the<code class="literal"> beforeFind</code> callback, executed before a<code class="literal"> find</code> operation is executed, we check for the existence of a<code class="literal"> virtualFields</code> setting. If such setting is defined, we use its value to check if virtual fields should be returned or not.<a id="id86" class="indexterm"/>
</p><p>Based on these setting values, we alter the real value of the model<code class="literal"> virtualFields</code> property. We backup its original value, and then restore it after the<code class="literal"> find</code> operation is completed, that is, in the<code class="literal"> afterFind</code> callback.</p></div><div class="section" title="See also"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec08"/>See also</h2></div></div></div><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><span class="emphasis"><em>Performing GROUP and COUNT queries</em></span></li></ul></div></div></div>
<div class="section" title="Building queries with ad-hoc JOINs"><div class="titlepage"><div><div><h1 class="title"><a id="ch03lvl1sec04"/>Building queries with ad-hoc JOINs</h1></div></div></div><p>CakePHP has a very easy way to handle bindings, and through the use of the<code class="literal"> Containable</code> behavior, as shown in several recipes in <a class="link" href="ch02.html" title="Chapter 2. Model Bindings">Chapter 2</a>, <span class="emphasis"><em>Model Bindings</em></span>, we have a lot of flexibility when dealing with bindings.<a id="id87" class="indexterm"/>
</p><p>However, there are times where we need to fall outside of a normal find operation and perform queries that join several models, without using normal binding operations, to save us some valuable queries. In this recipe, we will see how to specify<code class="literal"> JOIN</code> operations when performing a find on a model.</p><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec09"/>Getting ready</h2></div></div></div><p>We need some sample models and data to work with. Follow the<span class="emphasis"><em> Getting ready</em></span> section of the recipe,<span class="emphasis"><em> Performing GROUP and COUNT queries</em></span>.</p><p>To illustrate the difference between normal binding operations and what is shown in this recipe, we need the<code class="literal"> Containable</code> behavior. Create a file named<code class="literal"> app_model.php</code> and place it in your<code class="literal"> app/</code> folder, with the following contents. If you already have one, make sure that, either you add the<code class="literal"> actsAs</code> property shown as follows, or your<code class="literal"> actsAs</code> property includes<code class="literal"> Containable</code>.</p><div class="informalexample"><pre class="programlisting">&lt;?php
class AppModel extends Model {
public $actsAs = array('Containable');
}
?&gt;
</pre></div><p>We also need the<code class="literal"> Blog</code> model. Create a file named<code class="literal"> blog.php</code> and place it in your<code class="literal"> app/models</code> folder with the following contents:<a id="id88" class="indexterm"/>
</p><div class="informalexample"><pre class="programlisting">&lt;?php
class Blog extends AppModel {
public $belongsTo = array('User');
}
?&gt;
</pre></div></div><div class="section" title="How to do it..."><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec10"/>How to do it...</h2></div></div></div><p>We want to obtain the first post with the<code class="literal"> Blog</code> it belongs to, and the<code class="literal"> User</code> information that owns the<code class="literal"> Blog</code>. Using<code class="literal"> Containable</code> (refer to the recipe<span class="emphasis"><em> Limiting the bindings returned in a find</em></span> in <a class="link" href="ch02.html" title="Chapter 2. Model Bindings">Chapter 2</a>, <span class="emphasis"><em>Model Bindings</em></span> for more information), we do:<a id="id89" class="indexterm"/>
</p><div class="informalexample"><pre class="programlisting">$post = $this-&gt;Post-&gt;find('first', array(
'contain' =&gt; array(
'Blog' =&gt; array(
'fields' =&gt; array('name'),
'User' =&gt; array('fields' =&gt; array('name'))
)
)
));
</pre></div><p>This operation is performed by CakePHP using three SQL queries:</p><div class="informalexample"><pre class="programlisting">SELECT `Post`.`id`, `Post`.`blog_id`, `Post`.`title`, `Post`.`body`, `Post`.`created`, `Post`.`modified`, `Blog`.`name`, `Blog`.`user_id` FROM `posts` AS `Post` LEFT JOIN `blogs` AS `Blog` ON (`Post`.`blog_id` = `Blog`.`id`) WHERE 1 = 1 LIMIT 1;
SELECT `Blog`.`name`, `Blog`.`user_id` FROM `blogs` AS `Blog` WHERE `Blog`.`id` = 1;
SELECT `User`.`name` FROM `users` AS `User` WHERE `User`.`id` = 1;
</pre></div><p>We can save some of these queries if we<code class="literal"> JOIN</code> the relevant tables into one single operation. We specify these<code class="literal"> JOIN</code> statements using the appropriate join find setting:</p><div class="informalexample"><pre class="programlisting">$post = $this-&gt;Post-&gt;find('first', array(
'fields' =&gt; array(
'Post.id',
'Post.title',
'Blog.name',
'User.name'
),
'joins' =&gt; array(
array(
'type' =&gt; 'inner',
'alias' =&gt; 'Blog',
'table' =&gt; $this-&gt;Post-&gt;Blog-&gt;table,
'conditions' =&gt; array(
'Blog.id = Post.blog_id'
)
),
array(
'type' =&gt; 'inner',
'alias' =&gt; 'User',
'table' =&gt; $this-&gt;Post-&gt;Blog-&gt;User-&gt;table,
'conditions' =&gt; array(
'User.id = Blog.user_id'
)
)
),
'recursive' =&gt; -1
));
</pre></div><p>The preceding statement will produce the following SQL query:<a id="id90" class="indexterm"/>
</p><div class="informalexample"><pre class="programlisting">SELECT `Post`.`id`, `Post`.`blog_id`, `Post`.`title`, `Post`.`body`, `Post`.`created`, `Post`.`modified` FROM `posts` AS `Post` inner JOIN blogs AS `Blog` ON (`Blog`.`id` = `Post`.`blog_id`) inner JOIN users AS `User` ON (`User`.`id` = `Blog`.`user_id`) WHERE 1 = 1 LIMIT 1
And would generate the following data structure:
array(
'Post' =&gt; array(
'id' =&gt; 1,
'title' =&gt; 'John\'s Post 1'
),
'Blog' =&gt; array(
'name' =&gt; 'John Doe\'s Blog'
),
'User' =&gt; array(
'name' =&gt; 'John Doe'
)
)
</pre></div></div><div class="section" title="How it works..."><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec11"/>How it works...</h2></div></div></div><p>The<code class="literal"> joins</code> find setting allows us to define which<code class="literal"> JOIN</code> statements to add to the generated SQL query. We have full control when defining the operation, being able to change the<code class="literal"> type</code> (one of<code class="literal"> left, right</code>, and<code class="literal"> inner</code>), the<code class="literal"> table</code> to which to join, the<code class="literal"> alias</code> to use, and the<code class="literal"> conditions</code> used when joining.</p><p>We used this setting to join the<code class="literal"> Post</code> model with two models:<code class="literal"> Blog</code>, by means of its table and required condition, and<code class="literal"> User</code>, using its appropriate table and condition. As the<code class="literal"> Post</code> model<code class="literal"> belongsTo</code> the<code class="literal"> Blog</code> model, CakePHP will automatically try to do a<code class="literal"> LEFT JOIN</code> with it, unless we tell it not to.</p><p>We therefore set<code class="literal"> recursive</code> to<code class="literal"> -1</code>, forcing CakePHP to only use our defined<code class="literal"> JOIN</code>. If the recursive statement is removed, we would have to choose a different<code class="literal"> alias</code> for our<code class="literal"> Blog JOIN</code> definition, as it would conflict with CakePHP's built-in binding.<a id="id91" class="indexterm"/>
</p></div><div class="section" title="See also"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec12"/>See also</h2></div></div></div><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><span class="emphasis"><em>Adding Containable</em></span> in <a class="link" href="ch02.html" title="Chapter 2. Model Bindings">Chapter 2</a>, <span class="emphasis"><em>Model Bindings</em></span></li></ul></div></div></div>
<div class="section" title="Searching for all items that match search terms"><div class="titlepage"><div><div><h1 class="title"><a id="ch03lvl1sec06"/>Searching for all items that match search terms</h1></div></div></div><p>Finding records that match a set of search terms is almost a must-have on most web applications. Even when there is a good number of more in-depth, complex search solutions, sometimes a simple search is all we need.<a id="id92" class="indexterm"/>
</p><p>This recipe shows how to implement a<code class="literal"> LIKE-based</code> search to find records that match some terms.</p><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec13"/>Getting ready</h2></div></div></div><p>We need some sample models and data to work with. Follow the<span class="emphasis"><em> Getting ready</em></span> section of the recipe,<span class="emphasis"><em> Performing GROUP and COUNT queries</em></span>.</p></div><div class="section" title="How to do it..."><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec14"/>How to do it...</h2></div></div></div><p>If we want to find all posts that have the word<code class="literal"> Post 1</code> or the word<code class="literal"> Post 2</code>, either in its title, or post, we do:</p><div class="informalexample"><pre class="programlisting">$posts = $this-&gt;Post-&gt;find('all', array(
'fields' =&gt; array('Post.id', 'Post.title'),
'conditions' =&gt; array('or' =&gt; array(
array('Post.title LIKE ?' =&gt; '%Post 1%'),
array('Post.body LIKE ?' =&gt; '%Post 1%'),
array('Post.title LIKE ?' =&gt; '%Post 2%'),
array('Post.body LIKE ?' =&gt; '%Post 2%'),
)),
'recursive' =&gt; -1
));
</pre></div><p>The preceding statement will produce the following result:</p><div class="informalexample"><pre class="programlisting">array(
'Post' =&gt; array(
'id' =&gt; 1,
'title' =&gt; 'John\'s Post 1'
),
'Post' =&gt; array(
'id' =&gt; 2,
'title' =&gt; 'John\'s Post 2'
),
'Post' =&gt; array(
'id' =&gt; 5,
'title' =&gt; 'Jane\'s Post 1'
),
'Post' =&gt; array(
'id' =&gt; 6,
'title' =&gt; 'Jane\'s Post 2'
)
)
</pre></div></div><div class="section" title="How it works..."><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec15"/>How it works...</h2></div></div></div><p>
<code class="literal">LIKE-based</code> conditions are like any other model find condition, except that they are specified in a special form: they become part of the key of the condition and use the character<code class="literal"> ?</code> to tell where the actual value will be inserted, the value being an actual<code class="literal"> LIKE</code> expression. Therefore, the following condition:<a id="id93" class="indexterm"/>
</p><div class="informalexample"><pre class="programlisting">array('Post.title LIKE ?' =&gt; '%term%')
</pre></div><p>will be evaluated to SQL like so:</p><div class="informalexample"><pre class="programlisting">`Post`.`title` LIKE '%term%'
</pre></div><p>As the<code class="literal"> LIKE</code> expression is specified as an array index, it's important to note that we need to wrap each expression in an array of its own, avoiding the override of a previous expression. To illustrate this, let us add another condition for the<code class="literal"> Post.title</code> field.</p><div class="informalexample"><pre class="programlisting">array(
'Post.title LIKE ?' =&gt; '%term%',
'Post.title LIKE ?' =&gt; '%anotherTerm%'
)
</pre></div><p>This would be translated to the following SQL expression:</p><div class="informalexample"><pre class="programlisting">`Post`.`title` LIKE '%anotherTerm%'
</pre></div><p>Naturally, the second index is overriding the first, because they are both the same. We therefore have to wrap both expressions in an array, to avoid overriding the already used indexes:</p><div class="informalexample"><pre class="programlisting">array(
array('Post.title LIKE ?' =&gt; '%term%'),
array('Post.title LIKE ?' =&gt; '%anotherTerm%')
)
</pre></div><p>which would be translated to the following SQL statement:<a id="id94" class="indexterm"/>
</p><div class="informalexample"><pre class="programlisting">`Post`.`title` LIKE '%term%' OR `Post`.`title` LIKE '%anotherTerm%'
</pre></div></div><div class="section" title="See also"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec16"/>See also</h2></div></div></div><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><span class="emphasis"><em>Implementing a custom find type</em></span></li></ul></div></div></div>
<div class="section" title="Implementing a custom find type"><div class="titlepage"><div><div><h1 class="title"><a id="ch03lvl1sec07"/>Implementing a custom find type</h1></div></div></div><p>The recipe,<span class="emphasis"><em> Searching for all items that match search terms</em></span>, gives us a great starting point to create a custom find type. Custom find types allow us to extend the basic find types any model has, allowing our code to become more readable and extensible.<a id="id95" class="indexterm"/>
</p><p>This recipe shows how to create a custom find type to allow the<code class="literal"> Post</code> model to be searched against a set of terms, thus extending the functionality shown in the previous recipe.</p><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec17"/>Getting ready</h2></div></div></div><p>We need some sample models and data to work with. Follow the<span class="emphasis"><em> Getting ready</em></span> section of the recipe,<span class="emphasis"><em> Performing GROUP and COUNT queries</em></span>.</p></div><div class="section" title="How to do it..."><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec18"/>How to do it...</h2></div></div></div><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Open the<code class="literal"> post.php</code> file and add the<code class="literal"> search</code> find type to the list of find methods using the<code class="literal"> _findMethods</code> property, together with the actual implementation of the<code class="literal"> _findSearch()</code> method.<div class="informalexample"><pre class="programlisting">&lt;?php
class Post extends AppModel {
public $belongsTo = array('Blog');
public $_findMethods = array('search' =&gt; true);
protected function _findSearch($state, $query, $results = array()) {
if ($state == 'before') {
if (!empty($query['terms'])) {
$fields = array('title', 'body');
$conditions = array();
foreach ((array) $query['terms'] as $term) {
foreach ($fields as $field) {
$model = $this-&gt;alias;
if (strpos($field, '.') !== false) {
list($model, $field) = explode('.', $field);
}
$conditions[] = array(
$model . '.' . $field . ' LIKE ?' =&gt; '%'.$term.'%'
);
}
}
if (empty($query['fields'])) {
$query['fields'] = array('Post.title', 'Post.body');
}
$query['conditions'][] = array('or' =&gt; $conditions);
}
return array_diff_key($query, array('terms'=&gt;null));
}
return $results;
}
}
?&gt;
</pre></div></li><li class="listitem">We can now use these custom find types by specifying the list of terms to search with using the<code class="literal"> search</code> find setting:<a id="id96" class="indexterm"/><div class="informalexample"><pre class="programlisting">$posts = $this-&gt;Post-&gt;find('search', array(
'terms' =&gt; array(
'Post 1',
'Post 2'
),
'recursive' =&gt; -1
));
</pre></div></li><li class="listitem">If we now browse to <code class="literal">http://localhost/posts</code>, we get the<code class="literal"> id</code> and<code class="literal"> title</code> fields for four posts, as it is partially shown in the following screenshot:<div class="mediaobject"><img src="graphics/1926_03_01.jpg" alt="How to do it..."/></div></li><li class="listitem">Let us now also allow the execution of count operations for custom find types. Because we want a generic solution, we will add this to<code class="literal"> AppModel</code>. Open the file<code class="literal"> app_model.php</code> in your<code class="literal"> app/</code> folder (create it if you don't have one), and override the<code class="literal"> find()</code> method as shown below:<a id="id97" class="indexterm"/><div class="informalexample"><pre class="programlisting">&lt;?php
class AppModel extends Model {
public function find($conditions=null, $fields=array(), $order=null, $recursive=null) {
if (
is_string($conditions) &amp;&amp; $conditions=='count' &amp;&amp;
is_array($fields) &amp;&amp; !empty($fields['type']) &amp;&amp;
array_key_exists($fields['type'],$this-&gt;_findMethods)
) {
$fields['operation'] = 'count';
return parent::find($fields['type'], array_diff_key(
$fields,
array('type'=&gt;null)
));
}
return parent::find($conditions, $fields, $order, $recursive);
}
}
?&gt;
</pre></div></li><li class="listitem">Now edit your<code class="literal"> app/models/post.php</code> file and make the following changes to the<code class="literal"> _findSearch()</code> method:<a id="id98" class="indexterm"/><div class="informalexample"><pre class="programlisting">protected function _findSearch($state, $query, $results = array()) {
if ($state == 'before') {
if (!empty($query['terms'])) {
$fields = array('title', 'body');
$conditions = array();
foreach ((array) $query['terms'] as $term) {
foreach ($fields as $field) {
$model = $this-&gt;alias;
if (strpos($field, '.') !== false) {
list($model, $field) = explode('.', $field);
}
$conditions[] = array(
$model . '.' . $field . ' LIKE ?' =&gt; '%'.$term.'%'
);
}
}
if (empty($query['fields'])) {
$query['fields'] = array('Post.title', 'Post.body');
}
<span class="strong"><strong>if (!empty($query['operation']) &amp;&amp; $query['operation'] == 'count') {
$query['fields'] = 'COUNT(*) AS total';
}</strong></span>
$query['conditions'][] = array('or' =&gt; $conditions);
}
return array_diff_key($query, array('terms'=&gt;null));
<span class="strong"><strong>} elseif (
$state == 'after' &amp;&amp; !empty($query['operation']) &amp;&amp;
$query['operation'] == 'count'
) {
return (!empty($results[0][0]['total']) ? $results[0][0]['total'] : 0);</strong></span>
}
return $results;
}
</pre></div></li><li class="listitem">If we wanted to obtain the number of posts that match a set of terms, we would do:<a id="id99" class="indexterm"/><div class="informalexample"><pre class="programlisting">$count = $this-&gt;Post-&gt;find('count', array(
'type' =&gt; 'search',
'terms' =&gt; array(
'Post 1',
'Post 2'
)
));
</pre></div><p>Which would correctly return 4.
</p></li></ol></div></div><div class="section" title="How it works..."><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec19"/>How it works...</h2></div></div></div><p>Custom find types are defined in the model<code class="literal"> _findMethods</code> property. We add types by adding the name of the find type to the property as its index, and setting<code class="literal"> true</code> as its value in the model that contains the find type.<a id="id100" class="indexterm"/>
</p><p>The method responsible for dealing with the actual find type is named using the following syntax:<code class="literal"> _findType()</code>, where<code class="literal"> Type</code> is the find type name, with its first case in uppercase. For a find type of name popular, the method would be named<code class="literal"> _findPopular()</code>.</p><p>Every find type method receives three arguments:<a id="id101" class="indexterm"/>
</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">state</code>: The state at which the<code class="literal"> find</code> operation is currently on. This can be<code class="literal"> before</code> (used right before the find operation is to be executed), or<code class="literal"> after</code> (executed after the find operation is finished, and the perfect place to modify the obtained results.) The<code class="literal"> before</code> state is where we change the query parameters to meet our needs.</li><li class="listitem" style="list-style-type: disc"><code class="literal">query</code>: The data for the query, containing typical find settings (such as<code class="literal"> fields</code> or<code class="literal"> conditions</code>), and any extra settings specified in the<code class="literal"> find</code> operation (in our case,<code class="literal"> terms</code>).</li><li class="listitem" style="list-style-type: disc"><code class="literal">results</code>: Only applicable when the state is set to<code class="literal"> after</code>, and includes the result of the<code class="literal"> find</code> operation.</li></ul></div><p>When the state of the find is set to<code class="literal"> before</code>, the custom find type implementation needs to return the query, as an array of find settings. Therefore, in our implementation, we look for a custom find setting named<code class="literal"> terms</code>. If there are terms specified, we use them to add<code class="literal"> LIKE-</code> based conditions to a fixed list of fields. Once we are done, we return the modified query.</p><p>When the state is set to<code class="literal"> after</code>, the implementation needs to return the results. This is the opportunity to modify the resulting rows, if needed, before returning them. In our implementation, we simply return them as they were sent to us.</p><p>The last part of the recipe shows us how to add count support for our custom find types. This is something that CakePHP does not offer out of the box, so we implement our own solution. We do so by overriding the<code class="literal"> find()</code> method and checking to make sure a set of conditions are met:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">The<code class="literal"> find</code> operation being executed is set to<code class="literal"> count</code></li><li class="listitem">There's a<code class="literal"> type</code> setting specified in the query</li><li class="listitem">The<code class="literal"> type</code> setting is in fact a valid custom find type</li></ol></div><p>When these conditions are met, we add a new query parameter named<code class="literal"> operation</code>, setting it to<code class="literal"> count</code>, and we then call the parent<code class="literal"> find()</code> implementation using the custom find type. This way, our find implementation can check for the<code class="literal"> operation</code> find setting, and when it is set to<code class="literal"> count</code>, it forces the<code class="literal"> fields</code> find setting to<code class="literal"> COUNT(*)</code> in the<code class="literal"> before</code> state, and correctly gets the result of the count operation in the<code class="literal"> after</code> state.<a id="id102" class="indexterm"/>
</p></div><div class="section" title="See also"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec20"/>See also</h2></div></div></div><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><span class="emphasis"><em>Paginating a custom find type</em></span></li><li class="listitem" style="list-style-type: disc"><span class="emphasis"><em>Searching for all items that match search terms</em></span></li></ul></div></div></div>
<div class="section" title="Paginating a custom find type"><div class="titlepage"><div><div><h1 class="title"><a id="ch03lvl1sec08"/>Paginating a custom find type</h1></div></div></div><p>The recipe,<span class="emphasis"><em> Implementing a custom find type</em></span>, showed us the power of extending the built-in model find types, including support to use the implemented custom types for fetching records or counting them.<a id="id103" class="indexterm"/>
</p><p>Now that we know how to fetch and count custom find types, we can easily paginate a set of resulting rows. This recipe shows how to use CakePHP's built-in pagination support to paginate a set of rows that come as a result of a custom find type.</p><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec21"/>Getting ready</h2></div></div></div><p>We need some sample models and data to work with, and we need the override of the<code class="literal"> find()</code> method in<code class="literal"> AppModel</code> to allow<code class="literal"> count</code> operations on custom find types. Therefore, make sure you follow the entire recipe,<span class="emphasis"><em> Implementing a custom find type</em></span>, including its<span class="emphasis"><em> Getting ready</em></span> section.</p></div><div class="section" title="How to do it..."><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec22"/>How to do it...</h2></div></div></div><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Create a file named<code class="literal"> posts_controller.php</code> in your<code class="literal"> app/controllers</code> folder. If you already have one, make sure its<code class="literal"> index()</code> method is as follows:<div class="informalexample"><pre class="programlisting">&lt;?php
class PostsController extends AppController {
public function index() {
$this-&gt;paginate['Post'] = array(
'search',
'fields' =&gt; array(
'Post.id',
'Post.title'
),
'terms' =&gt; array(
'Post 1',
'Post 2'
),
'limit' =&gt; 3
);
$posts = $this-&gt;paginate('Post');
$this-&gt;set(compact('posts'));
}
}
?&gt;
</pre></div></li><li class="listitem">Create the view for the<code class="literal"> index</code> action. If you don't have a folder named<code class="literal"> posts</code> in your<code class="literal"> app/views</code> folder, create it. Next, create a file named<code class="literal"> index.ctp</code> in your<code class="literal"> app/views</code> folder with the following contents:<a id="id104" class="indexterm"/><div class="informalexample"><pre class="programlisting">&lt;p&gt;
&lt;?php echo $this-&gt;Paginator-&gt;prev(); ?&gt;
&amp;nbsp;
&lt;?php echo $this-&gt;Paginator-&gt;numbers(); ?&gt;
&amp;nbsp;
&lt;?php echo $this-&gt;Paginator-&gt;next(); ?&gt;
&lt;/p&gt;
&lt;ul&gt;
&lt;?php foreach($posts as $post) { ?&gt;
&lt;li&gt;#&lt;?php echo $post['Post']['id']; ?&gt;: &lt;?php echo $post['Post']['title']; ?&gt;&lt;/li&gt;
&lt;?php } ?&gt;
&lt;/ul&gt;
</pre></div></li><li class="listitem">If we now browse to <code class="literal">http://localhost/posts</code>, we see a paginated list of matching posts, showing the first three posts out of two pages, as shown in the following screenshot:<div class="mediaobject"><img src="graphics/1926_03_02.jpg" alt="How to do it..."/></div></li></ol></div></div><div class="section" title="How it works..."><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec23"/>How it works...</h2></div></div></div><p>To paginate a custom find type, we need to specify the name of the find type as the value for index<code class="literal"> 0</code> of the pagination settings (or the first value if no index is defined). We can then pass any custom find settings as part of the pagination settings, as shown in the following code snippet:<a id="id105" class="indexterm"/>
</p><div class="informalexample"><pre class="programlisting">$this-&gt;paginate['Post'] = array(
<span class="strong"><strong>'search',
'terms' =&gt; array(
'Post 1',
'Post 2'
),</strong></span>
'limit' =&gt; 3
);
</pre></div><p>CakePHP's<code class="literal"> paginate()</code> method will first issue a<code class="literal"> count</code> (specifying the find type name in the<code class="literal"> type</code> find setting) to get the total number of rows, and then a<code class="literal"> find</code> operation using the custom find type to get the rows for the current page.</p></div><div class="section" title="See also"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec24"/>See also</h2></div></div></div><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><span class="emphasis"><em>Implementing AJAX based pagination</em></span></li></ul></div></div></div>
<div class="section" title="Implementing AJAX based pagination"><div class="titlepage"><div><div><h1 class="title"><a id="ch03lvl1sec09"/>Implementing AJAX based pagination</h1></div></div></div><p>The previous recipe,<span class="emphasis"><em> Paginating a custom find type</em></span>, showed us how to paginate a custom find type. Each page link changes the browser location, forcing the reload of all the elements in the page.<a id="id106" class="indexterm"/>
</p><p>This recipe allows us to use AJAX (using the<code class="literal"> jQuery javascript library</code>) to only load what is really needed, so that every time a page is changed, only the set of rows is changed without having to load a whole new page.</p><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec25"/>Getting ready</h2></div></div></div><p>We need some sample models and data to work with, and we need a fully working pagination of a custom find type. Follow the entire recipe,<span class="emphasis"><em> Paginating a custom find type</em></span>, including its<span class="emphasis"><em> Getting ready</em></span> section.</p></div><div class="section" title="How to do it..."><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec26"/>How to do it...</h2></div></div></div><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">We start by adding the<code class="literal"> jQuery javascript</code> library to our layout. If you don't have one already, create a file named<code class="literal"> default.ctp</code> in your<code class="literal"> app/views/layouts</code> directory. Make sure you add the link to the jQuery library (here we are using the Google-hosted one), the place holder for a loading message (to be shown when an AJAX connection is in progress), and that you wrap the view content with a DIV with an ID set to<code class="literal"> content</code>.<div class="informalexample"><pre class="programlisting">&lt;head&gt;
&lt;title&gt;&lt;?php echo $title_for_layout; ?&gt;&lt;/title&gt;
<span class="strong"><strong>&lt;?php echo $this-&gt;Html-&gt;script('http://ajax.googleapis.com/ajax/libs/jquery/1.4.2/jquery.min.js'); ?&gt;</strong></span>
&lt;/head&gt;
&lt;body&gt;
&lt;div id="main"&gt;
<span class="strong"><strong>&lt;div id="loading" style="display: none; float: right;"&gt;Loading...&lt;/div&gt;
&lt;div id="content"&gt;</strong></span>
&lt;?php echo $content_for_layout; ?&gt;
<span class="strong"><strong>&lt;/div&gt;</strong></span>
&lt;/div&gt;
&lt;/body&gt;
&lt;/html&gt;
</pre></div></li><li class="listitem">Open the<code class="literal"> PostsController</code> and add the<code class="literal"> RequestHandler</code> component, and the<code class="literal"> Jquery</code> helper engine (the rest of the controller remains unmodified:<div class="informalexample"><pre class="programlisting">&lt;?php
class PostsController extends AppController {
<span class="strong"><strong>public $components = array('RequestHandler');
public $helpers = array('Js' =&gt; 'Jquery');</strong></span>
public function index() {
$this-&gt;paginate['Post'] = array(
'search',
'terms' =&gt; array(
'Post 1',
'Post 2'
),
'limit' =&gt; 3
);
$posts = $this-&gt;paginate('Post');
$this-&gt;set(compact('posts'));
}
}
?&gt;
</pre></div></li><li class="listitem">Now let the<code class="literal"> Paginator</code> helper know that we are using AJAX-based pagination. Edit the view file<code class="literal"> app/views/posts/index.ctp</code> and add the highlighted lines:<a id="id107" class="indexterm"/><div class="informalexample"><pre class="programlisting"><span class="strong"><strong>&lt;?php
$this-&gt;Paginator-&gt;options(array(
'evalScripts' =&gt; true,
'update' =&gt; '#content',
'before' =&gt; $this-&gt;Js-&gt;get('#loading')-&gt;effect('fadeIn', array('speed'=&gt;'fast')),
'complete' =&gt; $this-&gt;Js-&gt;get('#loading')-&gt;effect('fadeOut', array('speed'=&gt;'fast')),
));
?&gt;</strong></span>
&lt;p&gt;
&lt;?php echo $this-&gt;Paginator-&gt;prev(); ?&gt;
&amp;nbsp;
&lt;?php echo $this-&gt;Paginator-&gt;numbers(); ?&gt;
&amp;nbsp;
&lt;?php echo $this-&gt;Paginator-&gt;next(); ?&gt;
&lt;/p&gt;
&lt;ul&gt;
&lt;?php foreach($posts as $post) { ?&gt;
&lt;li&gt;#&lt;?php echo $post['Post']['id']; ?&gt;: &lt;?php echo $post['Post']['title']; ?&gt;&lt;/li&gt;
&lt;?php } ?&gt;
&lt;/ul&gt;
<span class="strong"><strong>&lt;?php echo $this-&gt;Js-&gt;writeBuffer(); ?&gt;</strong></span>
</pre></div></li></ol></div><div class="section" title="How it works..."><div class="titlepage"><div><div><h3 class="title"><a id="ch03lvl2sec27"/>How it works...</h3></div></div></div><p>When the update setting is specified to the<code class="literal"> options()</code> method of the<code class="literal"> Paginator</code> helper, the<code class="literal"> Paginator</code> knows it is dealing with an AJAX-based pagination. The update setting points to the ID of the DOM element holding the content that changes when each pagination link is clicked. In our case, that DOM element is a DIV with an ID set to<code class="literal"> content</code>, defined in the layout.<a id="id108" class="indexterm"/>
</p><p>The other option we specify to the<code class="literal"> Paginator</code> helper is<code class="literal"> evalScripts</code>, which tells the helper to evaluate any Javascript code that is being obtained as a result of an AJAX request. That way, when a page with results is being obtained through AJAX, the Javascript code that is automatically added by the JQuery engine will be executed. Similarly, we need to print out this generated code, and we do so by calling the<code class="literal"> writeBuffer()</code> method at the end of the<code class="literal"> index.ctp</code> view.</p><p>The other two options we use are<code class="literal"> before</code>, and<code class="literal"> complete</code>, which are sent directly to the AJAX operation. The<code class="literal"> before</code> option, executed before an AJAX request is made, is an ideal place for us to show the loading DIV. The<code class="literal"> complete</code> option, executed after an AJAX operation is completed, is utilized to hide the loading DIV.</p><p>We could also specify Javascript code to the<code class="literal"> before</code> and<code class="literal"> complete</code> options, rather than utilizing the helper methods provided by the jQuery engine. The same effect could be achieved by changing the options as follows:</p><div class="informalexample"><pre class="programlisting">&lt;?php
$this-&gt;Paginator-&gt;options(array(
'evalScripts' =&gt; true,
'update' =&gt; '#content',
<span class="strong"><strong>'before' =&gt; '$("#loading").fadeIn("fast");',
'complete' =&gt; '$("#loading").fadeOut("fast");'</strong></span>
));
?&gt;
</pre></div></div></div></div></body></html>