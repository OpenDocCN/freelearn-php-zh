- en: '[*Chapter 8*](B17606_08_Final_PD_ePub.xhtml#_idTextAnchor152): Exploring the
    Shopify Ajax API'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '[*第8章*](B17606_08_Final_PD_ePub.xhtml#_idTextAnchor152)：探索Shopify Ajax API'
- en: In the previous chapters, we learned about the basics of Shopify and Liquid,
    which provided us with some solid groundwork for future development. After setting
    up a proper foundation for our future learning, we learned how Liquid core works.
    By learning about objects, tags, and filters, we have learned how to create complex
    functionalities using a somewhat simple and insignificant set of features. Lastly,
    we learned how to create easily configurable elements throughout the store using
    various input type settings, combined with the `sections` and `blocks` attributes.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的章节中，我们学习了Shopify和Liquid的基础知识，这为我们未来的开发提供了坚实的基础。在为我们的未来学习打下适当的基础后，我们学习了Liquid核心的工作原理。通过了解对象、标签和过滤器，我们学会了如何使用相对简单且不显眼的特性集创建复杂的功能。最后，我们学习了如何使用各种输入类型设置以及`sections`和`blocks`属性，在商店中创建易于配置的元素。
- en: Throughout these chapters, we have learned how to create elements with static
    content. *However, what if we were looking to update the content of our pages
    dynamically?* This is where the Shopify Ajax API comes to help. In this final
    chapter, we will go over the Shopify Ajax API, explain its requirements and limitations,
    as well as its possible use cases.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在这些章节中，我们学习了如何使用静态内容创建元素。*然而，如果我们想动态更新页面内容呢？*这正是Shopify Ajax API发挥作用的地方。在本章的最后，我们将探讨Shopify
    Ajax API，解释其要求和限制，以及可能的用例。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Introduction to the Shopify Ajax API
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Shopify Ajax API 简介
- en: Updating the cart session with a POST request
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用POST请求更新购物车会话
- en: Retrieving data with a GET request
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用GET请求获取数据
- en: After completing this chapter, we will understand what the Shopify Ajax API
    is and the types of requests we can make, such as retrieving product information,
    adding products to the cart, or even reading the cart's current content. Additionally,
    we will learn about the typical uses cases for the Shopify Ajax API by working
    on some of our previous projects and improving them with the Ajax API.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 完成本章后，我们将了解Shopify Ajax API是什么，以及我们可以发起的类型请求，例如获取产品信息、将产品添加到购物车，甚至读取购物车当前的内容。此外，我们将通过改进一些我们的先前项目来学习Shopify
    Ajax API的典型用例。
- en: Lastly, we will learn how to pull and render an automatically generated list
    of recommended products based on Shopify's algorithms, and then turn a general
    search input into a predictive search feature that's often requested by store
    owners.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将学习如何根据Shopify的算法自动生成推荐产品列表，并将其转换为通常由店主要求的预测搜索功能。
- en: Technical requirements
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: While we will explain each topic and present it with the accompanying graphics,
    we will need an internet connection to follow the steps outlined in this chapter,
    considering that **Shopify** is a hosted service.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管我们将解释每个主题并配合相应的图形展示，但由于**Shopify**是一个托管服务，我们需要网络连接来跟随本章中概述的步骤。
- en: The code for this chapter is available on GitHub at [https://github.com/PacktPublishing/Shopify-Theme-Customization-with-Liquid/tree/main/Chapter08](https://github.com/PacktPublishing/Shopify-Theme-Customization-with-Liquid/tree/main/Chapter08).
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的代码可在GitHub上找到：[https://github.com/PacktPublishing/Shopify-Theme-Customization-with-Liquid/tree/main/Chapter08](https://github.com/PacktPublishing/Shopify-Theme-Customization-with-Liquid/tree/main/Chapter08)。
- en: While this chapter will contain several real-life examples and use cases for
    each topic, we will need a basic understanding and knowledge of Ajax to be able
    to follow this chapter thoroughly.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管本章将包含每个主题的多个真实示例和用例，但我们仍需要具备基本的Ajax理解和知识，以便彻底理解本章内容。
- en: Note that we will only show examples and work on projects related to the Shopify
    API and not Ajax in general. For detailed information on Ajax, we can consult
    [https://www.w3schools.com/js/js_ajax_intro.asp](https://www.w3schools.com/js/js_ajax_intro.asp),
    which provides a great introduction to Ajax.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们只会展示与Shopify API相关的示例和项目，而不是通用的Ajax。有关Ajax的详细信息，我们可以参考[https://www.w3schools.com/js/js_ajax_intro.asp](https://www.w3schools.com/js/js_ajax_intro.asp)，它提供了Ajax的出色介绍。
- en: 'The Code in Action video for the chapter can be found here: [https://bit.ly/2VUZ7Qp](https://bit.ly/2VUZ7Qp)'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的“代码实战”视频可在此找到：[https://bit.ly/2VUZ7Qp](https://bit.ly/2VUZ7Qp)
- en: Introduction to the Shopify Ajax API
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Shopify Ajax API 简介
- en: '**Ajax**, or **Asynchronous JavaScript and XML**, is a method that we can use
    to exchange small amounts of data with the server and update the parts of any
    page, without the need to reload it in its entirety. *So, what exactly is the
    Shopify Ajax API?*'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: '**Ajax**，或**异步JavaScript和XML**，是一种我们可以用来与服务器交换少量数据并更新任何页面的部分内容的方法，而无需重新加载整个页面。*那么，Shopify
    Ajax API究竟是什么呢？*'
- en: The Shopify Ajax API is a REST API endpoint through which we can send out requests
    to read or update certain information. For example, we can use a **GET** request
    to read the product or even the current cart data, or we can use a **POST** request
    to update the current content session of the cart.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: Shopify Ajax API是一个REST API端点，通过该端点我们可以发送请求来读取或更新某些信息。例如，我们可以使用**GET**请求来读取产品或甚至当前的购物车数据，或者我们可以使用**POST**请求来更新当前的内容会话。
- en: Shopify Ajax is an unauthenticated API, which means that it does not require
    any tokens or API keys to gain access to store information. Shopify also provides
    us with an authenticated API named the **Shopify Admin API**, which apps and services
    use to communicate with Shopify servers.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: Shopify Ajax是一个未认证的API，这意味着它不需要任何令牌或API密钥即可访问商店信息。Shopify还为我们提供了一个名为**Shopify
    Admin API**的认证API，应用程序和服务使用该API与Shopify服务器通信。
- en: Through the Shopify API, we can access most of our store data, whose responses
    will return JSON-formatted data, though we can't read customer and order data
    or update any store data – we can only do this using the Shopify Admin API.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 通过Shopify API，我们可以访问我们大部分的商店数据，其响应将返回JSON格式的数据，尽管我们无法读取客户和订单数据或更新任何商店数据——我们只能使用Shopify
    Admin API来完成这些操作。
- en: Note that Shopify has certain rate limitations regarding the Ajax API to prevent
    abuse (sending an unlimited number of requests to Shopify servers). One such limitation
    is that there's a maximum input array size limit, currently limited to 250\. Let's
    say that we are looking to pull information about all the products in a collection
    of over 1,000 products. We will have to use multiple queries to achieve this since
    we are limited to a maximum of 250 products per query.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，Shopify对Ajax API有一定的速率限制，以防止滥用（向Shopify服务器发送无限数量的请求）。其中一项限制是最大输入数组大小限制，目前限制为250。假设我们正在查找有关超过1,000个产品的集合中所有产品的信息。由于我们每个查询最多只能限制为250个产品，因此我们将不得不使用多个查询来实现这一点。
- en: 'Tip:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 小贴士：
- en: To keep everything concise and to the point, we won't mention all of the rate
    limitations here. For more information on Ajax API rate limitations, please refer
    to [https://shopify.dev/api/usage/rate-limits](https://shopify.dev/api/usage/rate-limits).
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 为了保持简洁并切中要点，我们在此不会提及所有速率限制。有关Ajax API速率限制的更多信息，请参阅[https://shopify.dev/api/usage/rate-limits](https://shopify.dev/api/usage/rate-limits)。
- en: Now that we have familiarized ourselves with the need-to-know Shopify Ajax API
    basics, we can learn more about the Ajax API from a practical standpoint.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经熟悉了需要了解的Shopify Ajax API基础知识，我们可以从实际的角度了解更多关于Ajax API的内容。
- en: Updating the cart session with a POST request
  id: totrans-24
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用POST请求更新购物车会话
- en: 'Previously, we mentioned that we can use a POST request to update the current
    cart session. Depending on the type of action we are looking to perform, we can
    pair the POST request with the following cart endpoints:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 此前，我们提到可以使用POST请求来更新当前的购物车会话。根据我们想要执行的操作类型，我们可以将POST请求与以下购物车端点配对：
- en: '`/cart/add.js`'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/cart/add.js`'
- en: '`/cart/update.js`'
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/cart/update.js`'
- en: '`/cart/change.js`'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/cart/change.js`'
- en: '`/cart/clear.js`'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/cart/clear.js`'
- en: While this might sound trivial, it is an essential aspect of today's e-commerce
    stores, where we expect to perform an action without refreshing an entire page.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这听起来可能微不足道，但它是当今电子商务商店的一个基本方面，我们期望在不刷新整个页面的情况下执行操作。
- en: The /cart/add.js endpoint
  id: totrans-31
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '`/cart/add.js`端点'
- en: 'As its name suggests, the `/cart/add.js` endpoint allows us to add one or multiple
    product variants to the cart, without the need to refresh the cart. To perform
    this action, we need to create an array named `items` with an object inside containing
    the following two keys:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 如其名称所示，`/cart/add.js`端点允许我们添加一个或多个产品变体到购物车，而无需刷新购物车。要执行此操作，我们需要创建一个名为`items`的数组，其中包含一个对象，该对象包含以下两个键：
- en: The `id` key, whose value should contain the number type value of the variant
    ID we are adding to the cart.
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`id`键的值应包含我们要添加到购物车的变体ID的数字类型值。'
- en: The `quantity` key, whose value should contain the number type value of the
    quantity we are adding to the cart.
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`quantity`键的值应包含我们要添加到购物车的数量的数字类型值。'
- en: 'If we need to include multiple variants, we can simply append multiple objects
    inside the `items` array:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们需要包含多个变体，我们可以在`items`数组内部简单地追加多个对象：
- en: '[PRE0]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: In the previous example, we can see an array with two objects containing a different
    set of variant `id` and `quantity` keys. However, note that the first object does
    not contain the `quantity` key. The reason for this is that the `quantity` key
    is entirely optional, and if we fail to include it, it assumes that the `quantity`
    value is equal to `1`.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，我们可以看到一个包含两个对象的数组，这些对象包含一组不同的变体`id`和`quantity`键。然而，请注意，第一个对象不包含`quantity`键。这是因为`quantity`键完全是可选的，如果我们没有包含它，它假定`quantity`的值等于`1`。
- en: 'Let''s look at how we could use this in a real-life example:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看我们如何在现实生活中的例子中使用它：
- en: 'As you may recall, in [*Chapter 4*](B17606_04_Final_PD_ePub.xhtml#_idTextAnchor079),
    *Diving into Liquid Core with Objects*, and later in [*Chapter 5*](B17606_05_Final_PD_ePub.xhtml#_idTextAnchor097),
    *Diving into Liquid Core with Filters*, we worked on a `Custom collection` project
    by adding the additional collection to the collection template. However, the current
    functionality is that if we click on the `Custom collection` form that we developed
    through [*Chapter 4*](B17606_04_Final_PD_ePub.xhtml#_idTextAnchor079), *Diving
    into Liquid Core with Objects*, and [*Chapter 5*](B17606_05_Final_PD_ePub.xhtml#_idTextAnchor097),
    *Diving into Liquid Core with Filters*. We can find the `Custom collection` form
    inside the `Snippet` directory, under `collection-form.liquid`:'
  id: totrans-39
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如您所回忆的，在[*第4章*](B17606_04_Final_PD_ePub.xhtml#_idTextAnchor079)，*使用对象深入液态核心*，以及后来在[*第5章*](B17606_05_Final_PD_ePub.xhtml#_idTextAnchor097)，*使用过滤器深入液态核心*中，我们通过向集合模板添加额外的集合来开展了一个`自定义集合`项目。然而，当前的功能是，如果我们点击通过[*第4章*](B17606_04_Final_PD_ePub.xhtml#_idTextAnchor079)，*使用对象深入液态核心*，和[*第5章*](B17606_05_Final_PD_ePub.xhtml#_idTextAnchor097)，*使用过滤器深入液态核心*开发的`自定义集合`表单，我们可以在`Snippet`目录下的`collection-form.liquid`中找到`自定义集合`表单：
- en: '[PRE1]'
  id: totrans-40
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'As we can see, the collection form that we have created already contains the
    two necessary things we need: the `submit` button and the variant `id` that we
    have stored inside a hidden input. For more straightforward navigation, let''s
    start by assigning a new class called `collection-submit` to the `submit` button:'
  id: totrans-41
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如我们所见，我们已创建的集合表单已经包含了我们需要的两个必要元素：提交按钮和存储在隐藏输入中的变体`id`。为了更直接的导航，让我们首先将一个名为`collection-submit`的新类分配给提交按钮：
- en: '[PRE2]'
  id: totrans-42
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'With the proper selector in place, we can now use an `addEventListener` on
    the `submit` button to capture the click event and pass the object to the function
    that we will create next:'
  id: totrans-43
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在适当的选择器到位后，我们现在可以在提交按钮上使用`addEventListener`来捕获点击事件并将对象传递给我们将要创建的函数：
- en: '[PRE3]'
  id: totrans-44
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'In the preceding example, we created an `addSelector` constant for capturing
    the click event. Using `preventDefault()`, we canceled any current events'' flows
    and passed the object of the clicked element to the `addCart` function. Now, let''s
    look at creating the `addCart` function:'
  id: totrans-45
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在前面的例子中，我们创建了一个`addSelector`常量来捕获点击事件。使用`preventDefault()`，我们取消了任何当前事件的流程，并将点击元素的`object`传递给`addCart`函数。现在，让我们看看如何创建`addCart`函数：
- en: '[PRE4]'
  id: totrans-46
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: We started by creating an arrow function with an `el` parameter that we will
    pass the object of the previously clicked element to. Inside the `addCart` function,
    we created a local variable, inside which we assigned an array. This array contains
    an object that contains the `id` property of the variable we want to add to the
    cart.
  id: totrans-47
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们首先创建了一个带有`el`参数的箭头函数，我们将传递之前点击元素的`object`。在`addCart`函数内部，我们创建了一个局部变量，在其中我们分配了一个数组。这个数组包含一个对象，该对象包含我们想要添加到购物车的变量的`id`属性。
- en: 'Considering that we previously passed the clicked-on object to the arrow function,
    we used `previousElementSibling` to select the correct input element and return
    its value accordingly. Now that we have all the necessary assets in place, all
    we need to do is use the `fetch` request to `POST` the data to the Shopify server
    and update the current cart session:'
  id: totrans-48
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 考虑到我们之前将点击的对象传递给了箭头函数，我们使用了`previousElementSibling`来选择正确的输入元素并相应地返回其值。现在我们已经准备好了所有必要的资产，我们只需要使用`fetch`请求将数据`POST`到Shopify服务器并更新当前的购物车会话：
- en: '[PRE5]'
  id: totrans-49
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: With that, we have successfully created a fully functional Ajax API POST request,
    allowing us to add any number of items to the current cart session without reloading
    the page. Additionally, we included the `then()` and `catch()` methods to return
    `success` and `error` messages inside the console log.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这个，我们已经成功创建了一个完全功能的 Ajax API POST 请求，允许我们在不重新加载页面的情况下向当前的购物车会话添加任意数量的项目。此外，我们还包含了
    `then()` 和 `catch()` 方法，以便在控制台日志中返回 `success` 和 `error` 消息。
- en: We also learned how to add specific products in selected quantities to the current
    cart session through the `/cart/add.js` endpoint. *However, what if we had certain
    line item properties on the specific product that we were looking to carry over
    to the cart?*
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还学会了如何通过 `/cart/add.js` 端点将特定数量的产品添加到当前的购物车会话中。*然而，如果我们想要将特定产品的某些行项目属性携带到购物车中，那会怎样呢？*
- en: 'We can easily resolve this by simply including an additional parameter, `properties`,
    which accepts a key-value type object:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过简单地包含一个额外的参数 `properties` 来轻松解决这个问题，它接受一个键值类型的对象：
- en: '[PRE6]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: We should set the key so that it's equal to the name of the line item's input
    or the first part of the line item property, where the value should equal the
    value that was retrieved from the input or the second part of the line item property.
    Suppose we need to recall how line item properties work. In that case, we can
    revisit [*Chapter 4*](B17606_04_Final_PD_ePub.xhtml#_idTextAnchor079), *Diving
    into Liquid Core with Objects*, where, in the *Product customization* subtopic,
    located in the *Working with global objects* section, we explained how line item
    properties work.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 我们应该设置键，使其等于行项目输入的名称或行项目属性的第一个部分，其中值应该等于从输入或行项目属性的第二个部分检索到的值。假设我们需要回忆行项目属性是如何工作的。在这种情况下，我们可以回顾
    [*第4章*](B17606_04_Final_PD_ePub.xhtml#_idTextAnchor079)，*使用对象深入液态核心*，其中在 *产品定制*
    子主题中，位于 *使用全局对象* 部分中，我们解释了行项目属性是如何工作的。
- en: 'If we need to pass a hidden line item that will only be visible in the order
    section part of the admin, we will need to append an *underscore* to the key:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们需要传递一个仅在管理员订单部分可见的隐藏行项目，我们需要在键名后附加一个 *下划线*：
- en: '[PRE7]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'If we decide to use `jQuery`, we can make the code a lot more compact:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们决定使用 `jQuery`，我们可以使代码更加紧凑：
- en: '[PRE8]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: However, we should check whether the theme we are working on already contains
    a `jQuery` library. Otherwise, we should avoid introducing a new library to the
    theme.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，我们应该检查我们正在工作的主题是否已经包含一个 `jQuery` 库。否则，我们应该避免向主题引入新的库。
- en: By covering both the `JavaScript` and `jQuery` solutions, we are now sure that
    we will be able to use our skills to produce the necessary Ajax API code. *However,
    what if we accidentally added a much higher quantity than we needed, and we need
    to update the product's quantity?*
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 通过涵盖 `JavaScript` 和 `jQuery` 解决方案，我们现在可以确信我们将能够使用我们的技能来生成必要的 Ajax API 代码。*但是，如果我们不小心添加了比所需数量多得多的数量，我们需要更新产品的数量怎么办？*
- en: The /cart/update.js endpoint
  id: totrans-61
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '`/cart/update.js` 端点'
- en: As its name suggests, the `/cart/update.js` endpoint allows us to update the
    line item values inside the current cart session.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 正如其名称所暗示的，`/cart/update.js` 端点允许我们更新当前购物车会话中的行项目值。
- en: 'While `/cart/update.js` works similarly to `/cart/update.js`, there are a few
    noticeable differences. For example, in `/cart/add.js`, we had to create a separate
    object when working with multiple variants, whereas with `/cart/update.js`, we
    only have to create a single object:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然 `/cart/update.js` 与 `/cart/update.js` 的工作方式类似，但有一些明显的区别。例如，在 `/cart/add.js`
    中，当我们处理多个变体时，我们必须创建一个单独的对象，而与 `/cart/update.js` 不同，我们只需要创建一个单一的对象：
- en: '[PRE9]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Notice that instead of using two sets of key values, we use only one here,
    where the key is represented by the variant ID and the `quantity` value represents
    the key value. Additionally, instead of items, we are now using updates. Let''s
    create a function that will help us test out our new knowledge:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，在这里我们使用的是一组键值，而不是两组，其中键由变体 ID 表示，`quantity` 值代表键值。此外，我们现在使用的是更新，而不是项目。让我们创建一个函数来帮助我们测试我们的新知识：
- en: '[PRE10]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: As we can see, the general code for updating the cart session is similar to
    adding the product cart, which is not surprising. Besides updating the cart's
    content, `/cart/update.js` also allows us to add the product to the current cart
    session.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所见，更新购物车会话的通用代码与添加产品购物车相似，这并不令人惊讶。除了更新购物车的内容外，`/cart/update.js` 还允许我们将产品添加到当前的购物车会话中。
- en: By using `/cart/update.js`, we can easily update the quantity of every item
    inside the cart by using the variant ID to identify which variant we are looking
    to update. *But what if the variant we are looking to update is not present inside
    the cart?* This is where the `/cart/update.js` alternate function triggers, updating
    the current cart session by adding the product variant to the cart with the selected
    quantity.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用 `/cart/update.js`，我们可以通过使用变体 ID 来识别我们想要更新的变体来轻松更新购物车中每个项目的数量。*但如果我们想要更新的变体不在购物车中呢？*
    这就是 `/cart/update.js` 交替函数触发的地方，通过将产品变体添加到购物车中并选择数量来更新当前的购物车会话。
- en: For example, in the previous `updateCart` function, we set the `quantity` value
    to a static value of `5`. No matter how many times we call the preceding function,
    the total quantity of any variant inside the cart will never exceed `5`. For this
    reason, we recommend always using `/cart/update.js` to update the existing cart
    items and `/cart/add.js` to add additional items to the cart.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，在之前的 `updateCart` 函数中，我们将 `quantity` 值设置为静态值 `5`。无论我们调用前面的函数多少次，购物车中任何变体的总数量永远不会超过
    `5`。因此，我们建议始终使用 `/cart/update.js` 来更新现有的购物车项目，并使用 `/cart/add.js` 来添加额外的项目到购物车。
- en: With that, we have learned how to update the line items in the current cart
    session. However, as you may recall from [*Chapter 4*](B17606_04_Final_PD_ePub.xhtml#_idTextAnchor079),
    *Diving into Liquid Core with Objects*, in the *Product customization* subtopic,
    located in the *Working with global objects* section, we learned that it is possible
    to implement a different type of customization using line items. Consequently,
    this will sort the same product variants into different lines if their customization
    differs.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，我们就已经学会了如何在当前的购物车会话中更新行项目。然而，正如你可能从 [*第 4 章*](B17606_04_Final_PD_ePub.xhtml#_idTextAnchor079)
    中回忆起来的，“使用对象深入液态核心”，在 *产品定制* 子主题中，位于 *使用全局对象* 部分中，我们了解到可以使用行项目实现不同类型的定制。因此，如果它们的定制不同，这将把相同的产品变体排序到不同的行中。
- en: While these products might be on different lines, they will all have the same
    variant ID. *So, what will happen if we run* `/cart/update.js` *to update the
    specific variant on three different lines?*
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这些产品可能位于不同的行上，但它们都将具有相同的变体 ID。*那么，如果我们运行* `/cart/update.js` *来更新三个不同行上的特定变体会发生什么？*
- en: The `/cart/update.js` endpoint would successfully perform its operation. However,
    since it does not know which line item we are looking to update, it will only
    update the first occurrence of the line item with the matching variant ID, and
    then it will stop. It will not update any additional occurrence with the same
    variant ID. *But what if we were looking to update a specific line item and not
    the first occurrence?*
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '`/cart/update.js` 端点将成功执行其操作。然而，由于它不知道我们想要更新哪个行项目，它只会更新匹配变体 ID 的行项目的第一个出现，然后停止。它不会更新具有相同变体
    ID 的任何其他出现。*但如果我们想要更新特定的行项目而不是第一个出现呢？*'
- en: The /cart/change.js endpoint
  id: totrans-73
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '`/cart/change.js` 端点'
- en: The `/cart/change.js` endpoint works similarly to the `/cart/update.js` endpoint
    as it allows us to update the line item inside the current cart session. However,
    two crucial differences are that we can only modify a single line item at a time
    and that (more importantly) we can specify exactly which line item we are looking
    to change.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: '`/cart/change.js` 端点与 `/cart/update.js` 端点类似，因为它允许我们在当前的购物车会话中更新行项目。然而，有两个关键的区别：我们一次只能修改一个行项目，而且（更重要的是）我们可以指定我们想要更改的确切行项目。'
- en: 'Similar to the `/cart/add.js` endpoint, the `/cart/change.js` endpoint also
    uses an object with two key-value pairs – one to identify the line item and one
    to assign the needed quantity:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 与 `/cart/add.js` 端点类似，`/cart/change.js` 端点也使用一个包含两个键值对的对象——一个用于识别行项目，另一个用于分配所需的数量：
- en: '[PRE11]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'While using `id` and the variant ID to identify the line item will not cause
    any errors, this will not resolve our problem as we can have multiple line items
    with the same variant ID in the cart. To resolve this, we can use the `line` property
    to identify the specific line item we want to change:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用 `id` 和变体 ID 来识别行项目时，这不会引起任何错误，但这并不能解决我们的问题，因为我们购物车中可能会有多个具有相同变体 ID 的行项目。为了解决这个问题，我们可以使用
    `line` 属性来识别我们想要更改的具体行项目：
- en: '[PRE12]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The `line` value is based on the index position of the line items inside the
    current cart session, where the base value starts with `1`. For example, if we
    have four items within the cart and we are looking to update the line item at
    the third position, we can set the `line` value to `3`, as per our previous example.
    Note that the most common use for the `/cart/change.js` endpoint is to easily
    update the quantity of each line item inside the cart page.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '`line`值基于当前购物车会话中行项的索引位置，其中基本值从`1`开始。例如，如果我们购物车中有四个项目，并且我们正在尝试更新第三个位置的行项，我们可以将`line`值设置为`3`，正如我们之前的例子。请注意，`/cart/change.js`端点最常见的用途是轻松更新购物页面中每个行项的数量。'
- en: 'Perform the following steps to implement the `/cart/update.js` endpoint successfully:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下步骤以成功实现`/cart/update.js`端点：
- en: 'As we mentioned previously, to use the `/cart/update.js` endpoint successfully,
    we need two things: the `quantity` value, which we can quickly return from the
    input value that we modify, and the current position of the line item. To determine
    the position of the line item, we can use the JavaScript `indexOf()` method. Alternatively,
    we can introduce a `data` attribute and set its value to `forloop.index` if the
    quantity input is inside a Liquid `for` loop. We will use the second approach
    to add `forloop.index` as a `data` attribute here:'
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 正如我们之前提到的，要成功使用`/cart/update.js`端点，我们需要两样东西：`quantity`值，我们可以快速从我们修改的输入值中返回它，以及行项的当前位置。为了确定行项的位置，我们可以使用JavaScript的`indexOf()`方法。或者，如果我们想在Liquid的`for`循环中设置`quantity`输入的`data`属性并设置其值为`forloop.index`，我们可以采用第二种方法。在这里，我们将使用第二种方法来添加`forloop.index`作为`data`属性：
- en: '[PRE13]'
  id: totrans-82
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'After making sure that we have all the necessary attributes in place, all we
    need to do is use `addEventListener` to detect the `change` event on the input,
    and then pass the object to the `changeCart()` arrow function:'
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在确保我们已放置所有必要的属性后，我们只需要使用`addEventListener`来检测输入上的`change`事件，然后将对象传递给`changeCart()`箭头函数：
- en: '[PRE14]'
  id: totrans-84
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The `changeCart()` arrow function is similar to the previous functions that
    we have created. The only difference is that now, we are using the `/cart/change.js`
    endpoint and no longer using static values for key-value pairs. Instead, we are
    pulling both values from the object that we passed previously.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '`changeCart()`箭头函数与我们之前创建的函数类似。唯一的区别是，现在我们正在使用`/cart/change.js`端点，而不是使用静态值作为键值对。相反，我们从之前传递的对象中获取这两个值。'
- en: While we can use both `/cart/update.js` and `/cart/change.js` to remove the
    item from the cart by simply setting the `quantity` value to `0`, we would have
    to adjust the quantity of each `line` item to `0` manually. *But what if we wanted
    an easy way to clear out the entire cart with a single click?*
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我们可以使用`/cart/update.js`和`/cart/change.js`通过将`quantity`值设置为`0`来简单地从购物车中移除项目，但我们必须手动调整每个`line`项的数量到`0`。*但如果我们想要一个简单的方法，通过单次点击就能清空整个购物车呢？*
- en: The /cart/clear.js endpoint
  id: totrans-87
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '`/cart/clear.js`端点'
- en: 'The `/cart/clear.js` endpoint is pretty simple to use compared to the previous
    endpoints as it does not accept any parameters. All we have to do is simply submit
    a POST request with `/cart/clear.js` and the cart will automatically clear all
    present items:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 与之前的端点相比，`/cart/clear.js`端点非常简单易用，因为它不接受任何参数。我们只需提交一个带有`/cart/clear.js`的POST请求，购物车就会自动清空所有现有项目：
- en: '[PRE15]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Note that if we were to run the preceding code on the cart, we would successfully
    clear all the items from the cart. However, we would still have to refresh the
    cart page to see the change because although we have cleared all the items from
    the current cart session, we have not removed the items from the actual DOM. We
    can implement a short `while` statement inside the `success` function and remove
    all line item elements to resolve this:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，如果我们要在购物车中运行前面的代码，我们会成功清除购物车中的所有项目。然而，我们仍然需要刷新购物车页面才能看到变化，因为尽管我们已经从当前的购物车会话中清除了所有项目，但我们并没有从实际的DOM中移除这些项目。我们可以在`success`函数中实现一个短的`while`语句，并移除所有行项目元素以解决这个问题：
- en: '[PRE16]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Using the preceding code example, we have successfully removed all the items
    from our current cart session and the DOM. Notice that there are many additional
    fine-tuning aspects that we will need to handle, such as clearing the price, removing
    the cart table, and displaying a message stating that the cart is empty. However,
    to keep this book concise and to the point, we will not be getting into this,
    but you are free (and it is advisable) to keep upgrading the preceding code as
    you will only benefit from it.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 使用前面的代码示例，我们已经成功从当前的购物车会话和 DOM 中移除了所有项目。请注意，还有许多其他需要处理的微调方面，例如清除价格、移除购物车表格，并显示一条消息，说明购物车为空。然而，为了使这本书简洁明了，我们不会深入探讨这一点，但你可以自由（并且建议）根据需要升级前面的代码，因为这将只会对你有益。
- en: So far, we have learned how to add products to the current cart session using
    the `/cart/add.js` endpoint, update the existing line items using `/cart/update.js`
    and `/cart/change.js`, and how to clear the current cart session using the `/cart/clear.js`
    endpoint. However, as we had a chance to see, while we could add easily, update,
    or even clear items from the current cart session, we still had to reload the
    page to see specific results, such as updating the item `counter` near the *cart*
    icon inside the header or the line item price when updating the item quantity.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经学习了如何使用 `/cart/add.js` 端点向当前购物车会话添加产品，使用 `/cart/update.js` 和 `/cart/change.js`
    更新现有行项目，以及如何使用 `/cart/clear.js` 端点清除当前购物车会话。然而，正如我们所看到的，虽然我们可以轻松添加、更新或甚至清除当前购物车会话中的项目，但我们仍然需要重新加载页面才能看到特定的结果，例如更新位于页眉中
    *购物车* 图标附近的项目 `counter` 或更新项目数量时的行项目价格。
- en: While it would do so, we could quickly simply increment the item `counter` by
    the number of products we are adding to the cart. A more straightforward solution
    to achieve this is to use a GET request in combination with the Shopify Ajax API,
    which will allow us to retrieve all kinds of data from Shopify servers, including
    the number of products in the current cart session.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们这样做时，我们可以快速简单地通过添加到购物车中的产品数量来增加项目 `counter`。实现这一点的更直接的方法是使用与 Shopify Ajax
    API 结合的 GET 请求，这将允许我们从 Shopify 服务器检索所有类型的数据，包括当前购物车会话中的产品数量。
- en: Retrieving data with a GET request
  id: totrans-95
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 GET 请求检索数据
- en: 'As we mentioned previously, using a GET request, we can pull all types of data
    from Shopify servers, except for customer and order information, which can only
    be accessed using an authenticated Shopify Admin API. Depending on the type of
    action we are looking to perform, we can pair the GET request with the following
    endpoints:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们之前提到的，使用 GET 请求，我们可以从 Shopify 服务器获取所有类型的数据，除了客户和订单信息，这些信息只能通过认证的 Shopify
    Admin API 访问。根据我们想要执行的操作类型，我们可以将 GET 请求与以下端点配对：
- en: '`/cart.js`'
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/cart.js`'
- en: '`/products/{product-handle}.js`'
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/products/{product-handle}.js`'
- en: '`/recommendations/products.json`'
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/recommendations/products.json`'
- en: '`/search/suggest.json`'
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/search/suggest.json`'
- en: The GET request is a pretty powerful method that we will commonly use in combination
    with a POST request to retrieve data after making changes to the current cart
    session. However, we can also use a GET request to retrieve and create complex
    functionalities, as we are about to learn.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: GET 请求是一种相当强大的方法，我们将经常与 POST 请求结合使用，在更改当前购物车会话后检索数据。然而，我们也可以使用 GET 请求来检索和创建复杂的功能，正如我们即将学习的。
- en: The /cart.js endpoint
  id: totrans-102
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '`/cart.js` 端点'
- en: 'The `/cart.js` endpoint, as its name suggests, allows us to access the current
    cart session and retrieve all the information about the cart, as well as products
    inside the cart. We can use it to dynamically update the cart page or even create
    a cart drawer for the store and improve the purchase flow significantly. Let''s
    take a look:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 如其名称所示，`/cart.js` 端点允许我们访问当前的购物车会话并检索有关购物车以及购物车中产品的所有信息。我们可以使用它来动态更新购物车页面，甚至为商店创建购物车抽屉，从而显著改善购买流程。让我们看看：
- en: 'We can retrieve information about the cart using the following `fetch` method:'
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以使用以下 `fetch` 方法检索有关购物车的信息：
- en: '[PRE17]'
  id: totrans-105
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Note that the response of a successful GET request is a JSON object. The following
    example shows the response we will receive using the previous code to fetch the
    cart data:'
  id: totrans-106
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意，成功的 GET 请求的响应是一个 JSON 对象。以下示例显示了使用前面的代码获取购物车数据时我们将收到的响应：
- en: '[PRE18]'
  id: totrans-107
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Now that we have learned how to retrieve current cart session information,
    we can combine it with the `POST` request for `/cart/add.js` that we worked on
    previously, and then ensure that the cart counter is updated correctly each time
    we add a new product to the cart:'
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们已经学会了如何检索当前购物车会话信息，我们可以将其与之前我们工作的 `/cart/add.js` 的 `POST` 请求结合起来，并确保每次我们向购物车添加新产品时购物车计数器都能正确更新：
- en: '[PRE19]'
  id: totrans-109
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: We now have all the knowledge necessary to retrieve different types of information
    from the current cart session. However, notice that the price values are pure
    strings within the cart response and have no currency format.
  id: totrans-110
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们现在拥有从当前购物车会话中检索不同类型信息所需的所有知识。然而，请注意，在购物车响应中价格值是纯字符串，没有货币格式。
- en: 'For example, let''s say that we were looking to update the total price on the
    cart page every time we update the product quantity. To start, we will use the
    `fetch` method to retrieve the total price value:'
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 例如，假设我们想在更新产品数量时更新购物页面的总价格。首先，我们将使用 `fetch` 方法检索总价格值：
- en: '[PRE20]'
  id: totrans-112
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'While we successfully retrieved the price, all that we have received is an
    unformatted string value, which is not that useful to us:'
  id: totrans-113
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 虽然我们成功检索到了价格，但我们收到的只是一个未格式化的字符串值，这对我们来说并不那么有用：
- en: '[PRE21]'
  id: totrans-114
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: The easiest way to resolve this would be to look into how the theme developer
    has defined the currency formatting helper function throughout the theme. We can
    usually find it inside the theme `master js` file. In our case, this will be `theme.js`.
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 解决这个问题最简单的方法是查看主题开发者如何在主题中定义货币格式化辅助函数。我们通常可以在主题的 `master js` 文件中找到它。在我们的例子中，这将是一个
    `theme.js` 文件。
- en: 'After identifying the keywords that we need, we simply need to apply the formatting
    to the value that we are looking to format:'
  id: totrans-116
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在确定我们需要的关键词后，我们只需将格式应用到我们想要格式化的值上：
- en: '[PRE22]'
  id: totrans-117
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Note that the formatting we have used in the previous example will work without
    any modifications in most cases. However, we might need to make some adjustments
    to specific themes – it all depends on how the theme developer defined the function.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们在前面的示例中使用过的格式在大多数情况下无需修改即可正常工作。然而，我们可能需要根据特定的主题进行调整——这完全取决于主题开发者如何定义该函数。
- en: Previously, we learned how to retrieve information about the current cart session
    and any data about any product inside the cart. *However, what if we wanted to
    retrieve product information more directly?*
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 之前，我们学习了如何检索当前购物车会话的信息以及购物车中任何产品的数据。*然而，如果我们想更直接地检索产品信息呢？*
- en: The /products/{product-handle}.js endpoint
  id: totrans-120
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '`/products/{product-handle}.js` 端点'
- en: 'The `/products/{product-handle}.js` endpoint is a simple endpoint that we can
    use in combination with a GET request to retrieve information about any product
    in the store easily. Similarly, as with the `/cart.js` endpoint, `/products/{product-handle}.js`
    is relatively easy to use as it only requires us to include the handle of a product
    we are looking to retrieve data about:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: '`/products/{product-handle}.js` 端点是一个简单的端点，我们可以将其与 GET 请求结合使用，轻松检索商店中任何产品的信息。同样，与
    `/cart.js` 端点一样，`/products/{product-handle}.js` 相对容易使用，因为它只需要我们包含我们想要检索数据的产品的处理程序：'
- en: '[PRE23]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: The return value that we will receive from the preceding example will include
    the product ID, which we will be using in the following example.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 从前面的示例中我们将收到的返回值将包括产品ID，我们将在下面的示例中使用它。
- en: The most common use for this endpoint is when creating on-click functionalities,
    such as the quick view feature, where we need to load a lot of product information
    dynamically to avoid cluttering the DOM and slowing down the store.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 这个端点最常用的用途是在创建点击功能时，例如快速查看功能，我们需要动态加载大量产品信息以避免DOM杂乱无章并减慢商店速度。
- en: The /recommendations/products.json endpoint
  id: totrans-125
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '`/recommendations/products.json` 端点'
- en: The `/recommendations/products.json` endpoint allows us to retrieve a list of
    JSON objects regarding the recommended products for the selected product based
    on Shopify algorithms, which we can use to construct a dynamic recommended section.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: '`/recommendations/products.json` 端点允许我们根据 Shopify 算法检索关于所选产品的推荐产品列表的 JSON 对象，我们可以使用这些对象构建动态推荐部分。'
- en: 'Through this endpoint, we can use three parameters, one of which is mandatory,
    while the other two are optional:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这个端点，我们可以使用三个参数，其中一个是必需的，而其他两个是可选的：
- en: The `product_id` parameter is a mandatory parameter whose value should be set
    to the ID of the product whose recommendation list we are looking to retrieve.
    Note that the product ID is not the same as the variant ID. They are two different
    attributes that we can retrieve through the `product` object.
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`product_id`参数是一个必填参数，其值应设置为我们要检索推荐列表的产品ID。请注意，产品ID与变体ID不同，它们是两个不同的属性，我们可以通过`product`对象来获取。'
- en: The `limit` parameter is an optional parameter that allows us to select the
    maximum number of recommended products we should receive per request. We cannot
    retrieve more than 10 recommended products per request due to Shopify limitations.
    This is the default value if we do not set the `limit` parameter.
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`limit`参数是一个可选参数，允许我们选择每次请求应接收的最大推荐产品数量。由于Shopify的限制，我们每次请求不能检索超过10个推荐产品。如果我们没有设置`limit`参数，这将默认值。'
- en: Last but not least is the `section_id` parameter, which, while optional, is
    quite an interesting parameter as it allows us to change the type of response
    that we will receive. By including the ID of a section as the `section_id` parameter
    value, we can select the parent element where we would like to render the recommended
    products. More importantly, we can also change the JSON response to an HTML string,
    which we can then use in combination with the `recommendations` object to output
    the recommended products dynamically.
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后但同样重要的是`section_id`参数，虽然它是可选的，但这个参数相当有趣，因为它允许我们更改我们将接收的响应类型。通过将部分ID作为`section_id`参数值包含，我们可以选择我们想要渲染推荐产品的父元素。更重要的是，我们还可以将JSON响应更改为HTML字符串，然后我们可以将其与`recommendations`对象结合使用，以动态输出推荐产品。
- en: Now that we have familiarized ourselves with all the attributes that we can
    use with the `/recommendations/products.json` endpoint, it is time to see them
    in action.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经熟悉了所有可以与`/recommendations/products.json`端点一起使用的属性，是时候看看它们在实际中的应用了。
- en: 'In the following example, we have used a `fetch` request, paired with the `/recommendations/products.json`
    endpoint, to generate a JSON object list and output them in the console log:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的示例中，我们使用了一个`fetch`请求，配合`/recommendations/products.json`端点，生成一个JSON对象列表并在控制台日志中输出：
- en: '[PRE24]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: As we can see, retrieving a JSON object for the recommended products is quite
    simple, as the only thing that we need to do now is pass the product ID to the
    `productId` parameter. As you may recall, the `limit` parameter is optional and
    will default to the maximum value of `10` when not included. Now, let's look at
    how we can include `section_id` and learn how to retrieve HTML strings instead.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，检索推荐产品的JSON对象相当简单，因为我们现在需要做的只是将产品ID传递给`productId`参数。如您所回忆，`limit`参数是可选的，如果不包含，将默认为最大值`10`。现在，让我们看看如何包含`section_id`并学习如何检索HTML字符串。
- en: Before we can modify the `fetch` request to accomplish this, we need to make
    specific preparations. The first thing we need to do is create a new section in
    the `Sections` directory. For our example, we will name it `recommended-products`.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们能够修改`fetch`请求以实现这一点之前，我们需要做一些具体的准备。我们首先需要做的是在`Sections`目录中创建一个新的部分。在我们的例子中，我们将命名为`recommended-products`。
- en: Since we already have a recommended products section on the product page template
    and are only creating a new section to learn how this works, let's include this
    new section at the bottom of the `theme.liquid` layout file, just above the `</body>`
    tag. Now that we have created the section file and successfully included it, we
    must familiarize ourselves with the `recommendations` object.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们在产品页面模板上已经有了推荐产品部分，现在只是创建一个新的部分来了解它是如何工作的，所以让我们将这个新部分包含在`theme.liquid`布局文件的底部，正好在`</body>`标签之上。现在我们已经创建了部分文件并成功包含它，我们必须熟悉`recommendations`对象。
- en: As its name suggests, the `recommendations` object allows us to retrieve products
    from the product recommendations list. However, this particular object only works
    in combination with the `/recommendations/products` endpoint.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 如其名所示，`recommendations`对象允许我们从产品推荐列表中检索产品。然而，这个特定的对象仅与`/recommendations/products`端点结合使用。
- en: 'As we can see, the `recommendations` object is relatively simple to use as
    it only contains three attributes:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，`recommendations`对象相对简单易用，因为它只包含三个属性：
- en: The `performed` attribute returns a Boolean, depending on whether we have placed
    the `recommendations` object inside the section whose content we are rendering
    by combining the `recommendations` endpoint and the necessary parameters.
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`performed`属性返回一个布尔值，取决于我们是否将`recommendations`对象放置在通过组合`recommendations`端点和必要的参数而渲染内容的部分中。'
- en: The `products_count` attribute provides us with a number value for the number
    of products in the recommendation list.
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`products_count`属性为我们提供了推荐列表中产品数量的数值。'
- en: Last but not least, the `products` attribute allows us to retrieve an array
    of recommended product objects. We can combine the `products` attribute with the
    `for` tag to provide an output the same way as we did previously for the `Custom
    collection` project in [*Chapter 5*](B17606_05_Final_PD_ePub.xhtml#_idTextAnchor097),
    *Diving into Liquid Core with Filters*.
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后但同样重要的是，`products`属性允许我们检索推荐产品对象的数组。我们可以将`products`属性与`for`标签结合使用，以提供与我们在[*第五章*](B17606_05_Final_PD_ePub.xhtml#_idTextAnchor097)，“使用过滤器深入液态核心”的`Custom
    collection`项目中相同的方式提供输出。
- en: 'Let''s return to the `recommended-products` section file we created and use
    the `recommendations` object to output the recommended products array:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回到我们创建的`recommended-products`部分文件，并使用`recommendations`对象输出推荐产品数组：
- en: '[PRE25]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: With that, we have created a proper layout for the future recommendations list.
    However, if we were to preview the results on the theme, we would notice that
    the section does not render anything inside the `product-recommendations` div.
    As we mentioned previously, the `recommendations` object only works in combination
    with the `recommendations` endpoint, so let's look at how to use the endpoint
    to generate the necessary HTML strings to output the recommended product list.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，我们就为未来的推荐列表创建了一个合适的布局。然而，如果我们预览主题上的结果，我们会注意到该部分在`product-recommendations`div内没有渲染任何内容。正如我们之前提到的，`recommendations`对象仅与`recommendations`端点结合使用，所以让我们看看如何使用端点生成必要的HTML字符串以输出推荐产品列表。
- en: 'To achieve this, we need to make a few adjustments to our previous `fetch`
    request:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现这一点，我们需要对我们的之前的`fetch`请求做一些调整：
- en: The first thing that we need to do is include the additional parameters for
    the `productRecommendations` function that we will pass the section ID value to.
    Additionally, we will need to include the `section_id` parameter and its value
    to the fetch URL.
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要做的第一件事是为`productRecommendations`函数包含额外的参数，我们将传递部分ID值。此外，我们还需要将`section_id`参数及其值包含到fetch
    URL中。
- en: The second and more important step is to remove `.json` from the fetch URL.
    Otherwise, we will not be able to retrieve the JSON HTML string.
  id: totrans-147
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 第二个且更为重要的步骤是移除fetch URL中的`.json`。否则，我们将无法检索到JSON HTML字符串。
- en: Last but not least, we will need to replace `.json()` with `.text()` inside
    the first `then` method.
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后但同样重要的是，我们需要在第一个`then`方法中将`.json()`替换为`.text()`。
- en: 'At this point, we have all the necessary elements to retrieve the JSON HTML
    string. Let''s test it out by calling the products inside the console log:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经拥有了检索JSON HTML字符串所需的所有必要元素。让我们通过在控制台日志中调用产品来测试它：
- en: '[PRE26]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'However, before we can test this out, we need to pass the three values to our
    function:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在我们能够测试之前，我们需要将三个值传递给我们的函数：
- en: For `productId`, we can use the product ID value that we retrieved while learning
    about the `/products/{product-handle}.js` endpoint. Alternatively, we can use
    `product.id` inside any product template and copy the value that we receive.
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于`productId`，我们可以使用我们在学习`/products/{product-handle}.js`端点时检索到的产品ID值。或者，我们可以在任何产品模板中使用`product.id`并复制我们收到的值。
- en: For `limit`, we can use any number value up to `10`, which is the maximum number
    of products we can receive as a response.
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于`limit`，我们可以使用任何不超过`10`的数字值，这是我们可以作为响应接收的最大产品数量。
- en: For `sectionId`, we should include a string value equal to the name of the section
    we are looking to display the recommended products inside. In our case, the value
    is `recommended-products`.
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于`sectionId`，我们应该包含一个等于我们想要在内部显示推荐产品的部分名称的字符串值。在我们的例子中，值是`recommended-products`。
- en: 'The following is an example of passing all three values to our function:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是将所有三个值传递给我们的函数的示例：
- en: '[PRE27]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: If we were to preview our duplicate theme and check the console log inside the
    previous `fetch` function, we would see that we have successfully retrieved the
    JSON HTML string values for the recommended products.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们要预览我们的重复主题并检查之前`fetch`函数中的控制台日志，我们会看到我们已经成功检索到了推荐产品的JSON HTML字符串值。
- en: 'Now that we have confirmed that everything works well, the only thing left
    to do is use the retrieved value and output the recommended products lists:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经确认一切正常，我们唯一要做的就是使用检索到的值并输出推荐产品列表：
- en: '[PRE28]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: With that, we have successfully learned how to render a list of recommended
    products according to the layout that we previously defined inside the `recommended-products`
    section. Additionally, the product list will automatically update itself based
    on Shopify's algorithms.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这些，我们已经成功学习了如何根据我们在`recommended-products`部分之前定义的布局渲染推荐产品列表。此外，产品列表将根据Shopify的算法自动更新。
- en: While having a recommended list of products is a great feature for finding similar
    products, we still have to navigate to a specific product, and even then, we can't
    be sure that we will receive the exact results we needed. To help us with this,
    we can use a predictive search feature.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然有一个推荐的产品列表是一个很好的功能，用于查找类似的产品，但我们仍然需要导航到特定的产品，即使如此，我们也不能确定我们会收到我们需要的确切结果。为了帮助我们，我们可以使用预测搜索功能。
- en: The /search/suggest.json endpoint
  id: totrans-162
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '`/search/suggest.json`端点'
- en: As its name suggests, the `/search/suggest.json` endpoint allows us to create
    a predictive search that will automatically provide us with a list of products
    that matches our query, either partially or completely.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 如其名所示，`/search/suggest.json`端点允许我们创建一个预测搜索，该搜索将自动为我们提供一个与我们的查询部分或完全匹配的产品列表。
- en: 'Besides allowing us to use predictive search on products, we can also search
    for collections, pages, and even articles, depending on the type of parameters
    that we include. `/search/suggest.json` allows us to use seven different types
    of parameters. However, to keep everything concise and to the point, we will only
    cover the most important ones that are needed to make the predictive search functionality
    work:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 除了允许我们在产品上使用预测搜索外，我们还可以根据我们包含的参数类型搜索集合、页面甚至文章。`/search/suggest.json`允许我们使用七种不同的参数类型。然而，为了保持简洁并切中要点，我们只会介绍使预测搜索功能正常工作所需的最重要的一些参数：
- en: The first parameter on our list is the `q` parameter, which is a mandatory string
    type parameter whose value should be equal to the search query.
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们列表中的第一个参数是`q`参数，这是一个必填的字符串类型参数，其值应等于搜索查询。
- en: 'The `type` parameter allows us to specify the type of result we are looking
    to receive. We can include the following comma-separated values: `product`, `page`,
    `article`, and `collection`. The `type` parameter is also mandatory.'
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`type`参数允许我们指定我们想要接收的结果类型。我们可以包含以下以逗号分隔的值：`product`、`page`、`article`和`collection`。`type`参数也是必填的。'
- en: The `limit` parameter is an optional integer parameter that allows us to set
    the number of results we should receive per request. Note that if we do not include
    the `limit` attribute, it defaults to `10`, which is the maximum number of results
    we can receive per request.
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`limit`参数是一个可选的整数参数，允许我们设置每次请求应接收的结果数量。请注意，如果我们不包括`limit`属性，它默认为`10`，这是我们每次请求可以接收的最大结果数量。'
- en: The `resources` attribute is a mandatory hash type parameter that requests resource
    results for the query based on the `type` and `limit` fields.
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`resources`属性是一个必填的哈希类型参数，它根据`type`和`limit`字段请求查询的资源结果。'
- en: 'In the following example, we have used a `fetch` request, paired with the `/search/suggest.json`
    endpoint, to generate a JSON object list that matches our search query and outputs
    it in the console log:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下示例中，我们使用了一个`fetch`请求，配合`/search/suggest.json`端点，生成一个与我们的搜索查询匹配的JSON对象列表，并在控制台日志中输出：
- en: '[PRE29]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'As we can see, retrieving predictive search results based on the search query
    is relatively simple, since the only thing we need to do now is pass down the
    required values to our function:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，根据搜索查询检索预测搜索结果相对简单，因为我们现在唯一需要做的是将所需的值传递给我们的函数：
- en: '[PRE30]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: By typing a search query inside the search field, we will notice that we have
    successfully retrieved a combined list of up to four products, pages, articles,
    or collections of JSON objects that partially or fully match our search query
    inside the console log. The only thing left to do now is use the response values
    to generate the results inside the DOM.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 在搜索框内输入搜索查询后，我们会注意到我们已经在控制台日志中成功检索到了最多四个产品、页面、文章或JSON对象的集合，这些集合部分或完全符合我们的搜索查询。现在我们唯一要做的就是使用响应值在DOM内生成结果。
- en: With the `/products/{product-handle}.js` endpoint, we had a parameter that allowed
    us to retrieve a JSON HTML string to output the results into the DOM easily. This
    is not the case with the `/search/suggest.json` endpoint, however; to render these
    results, we will need to use JavaScript to create the layout and functionality
    that we need. To keep everything concise and to the point, we will not be covering
    that in this book. However, we recommend finishing the project as it will be some
    excellent practice that will help you with everything you have learned so far.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `/products/{product-handle}.js` 端点，我们有一个参数允许我们检索一个 JSON HTML 字符串，以便轻松将其输出到
    DOM 中。然而，对于 `/search/suggest.json` 端点来说并非如此；为了渲染这些结果，我们需要使用 JavaScript 来创建所需的布局和功能。为了保持简洁并直击要点，我们不会在本书中涵盖这一点。然而，我们建议完成这个项目，因为它将是一个极好的实践，将帮助你巩固迄今为止所学的一切。
- en: For additional information on predictive search parameters and their general
    requirements and limitations, please consult [https://shopify.dev/api/ajax/reference/predictive-search](https://shopify.dev/api/ajax/reference/predictive-search).
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 如需有关预测搜索参数及其一般要求和限制的更多信息，请参阅[https://shopify.dev/api/ajax/reference/predictive-search](https://shopify.dev/api/ajax/reference/predictive-search)。
- en: Summary
  id: totrans-176
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: Throughout this final chapter, we have familiarized ourselves with the Shopify
    Ajax API and learned about different types of use cases. First, we learned how
    to upgrade the current purchase flow using the `/cart/add.js` endpoint, through
    which we can add any number of products, quantities, and line item customizations,
    whether they are public or private, directly to the current cart session.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的最后，我们熟悉了 Shopify Ajax API，并了解了不同类型的用例。首先，我们学习了如何使用 `/cart/add.js` 端点升级当前的购买流程，通过这个端点，我们可以将任何数量的产品、数量和行项目定制直接添加到当前的购物车会话中。
- en: By learning how to handle the `/cart/change.js` endpoint, we gained the necessary
    knowledge to create a feature that includes a specific product and quantity, such
    as an automatic gift or upsells feature. Using `/cart/update.js` in combination
    with the `/cart.js` endpoint, we learned how to update the cart's content dynamically
    and retrieve it. We can then use this to create a cart drawer feature.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 通过学习如何处理 `/cart/change.js` 端点，我们获得了创建包含特定产品和数量的功能所需的知识，例如自动赠品或升级销售功能。结合使用 `/cart/update.js`
    和 `/cart.js` 端点，我们学会了如何动态更新购物车的内容并检索它。然后我们可以利用这一点来创建购物车抽屉功能。
- en: Additionally, we learned how to use the `/products/{product-handle}.js` endpoint
    to retrieve an automatic list of recommended products and render their content
    into a section of our choice.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们还学会了如何使用 `/products/{product-handle}.js` 端点检索推荐产品的自动列表，并将它们的内容渲染到我们选择的区域。
- en: Lastly, we learned about the `/search/suggest.json` endpoint, which allows us
    to create a predictive search functionality, one of the most requested features
    by store owners.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们了解了 `/search/suggest.json` 端点，它允许我们创建预测搜索功能，这是店主们最常请求的功能之一。
- en: From the very beginning of this book, we have worked together on pushing the
    limits of our knowledge and creating a solid flow of understanding that will help
    us on our path of becoming a Shopify expert. While we haven't gone over every
    piece of Liquid code, we have worked on some exciting projects where we have learned
    about something a lot more beneficial. Our goal was not to simply create a list
    of where we would list all the different methods and attributes, which we can
    always find by looking through the Shopify documentation, but also to learn how
    both Shopify and Liquid work.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 从这本书的最初开始，我们就一起努力拓展我们的知识边界，并建立了一个坚实的理解流程，这将帮助我们成为 Shopify 专家的道路上。虽然我们没有覆盖每一行
    Liquid 代码，但我们参与了一些令人兴奋的项目，从中我们学到了很多更有益的知识。我们的目标不仅仅是创建一个列表，列出所有不同的方法和属性，这些我们总是可以通过查阅
    Shopify 文档找到，而是要学习 Shopify 和 Liquid 如何工作。
- en: While it suffices to say that through the knowledge we've gained here, we should
    be ready to start working on the Shopify theme independently, note that our adventure
    is not ending – it is only just beginning.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然可以说，通过在这里获得的知识，我们应该准备好独立开始 Shopify 主题的开发工作，但请注意，我们的冒险之旅并未结束——它才刚刚开始。
- en: 'Shopify is a constantly evolving platform, and it will require us to stay up
    to date with all the latest announcements and approaches. Luckily, Shopify offers
    various communities to improve our knowledge further or get assistance from other
    Shopify experts on various topics. Last but not least, we have a Discord channel
    at our disposal, where we can talk with other developers and both get assistance
    when we need it or share our knowledge with other developers: [https://discord.gg/shopifydevs](https://discord.gg/shopifydevs).'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: Shopify是一个不断发展的平台，我们需要跟上所有最新的公告和策略。幸运的是，Shopify提供了各种社区，以进一步丰富我们的知识或从其他Shopify专家那里获得各种主题的帮助。最后但同样重要的是，我们有一个可用的Discord频道，我们可以与其他开发者交谈，在我们需要时获得帮助，或者与开发者分享我们的知识：[https://discord.gg/shopifydevs](https://discord.gg/shopifydevs).
- en: Further reading
  id: totrans-184
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: 'Shopify official documentation: [https://shopify.dev/](https://shopify.dev/)'
  id: totrans-185
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Shopify官方文档：[https://shopify.dev/](https://shopify.dev/)
- en: 'Shopify cheat sheet: [http://cheat.markdunkley.com/](http://cheat.markdunkley.com/)'
  id: totrans-186
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Shopify速查表：[http://cheat.markdunkley.com/](http://cheat.markdunkley.com/)
- en: 'Developer changelog: [https://shopify.dev/changelog](https://shopify.dev/changelog%20)'
  id: totrans-187
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 开发者变更日志：[https://shopify.dev/changelog](https://shopify.dev/changelog%20)
- en: 'Official community: [https://community.shopify.com/](https://community.shopify.com/%20)'
  id: totrans-188
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 官方社区：[https://community.shopify.com/](https://community.shopify.com/%20)
- en: 'Twitter announcements: [https://twitter.com/shopifydevs](https://twitter.com/shopifydevs%20)'
  id: totrans-189
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Twitter公告：[https://twitter.com/shopifydevs](https://twitter.com/shopifydevs%20)
- en: 'Shopify Developer YouTube channel: [https://www.youtube.com/channel/UCcYsEEKJtpxoO9T-keJZrEw](https://www.youtube.com/channel/UCcYsEEKJtpxoO9T-keJZrEw%20)'
  id: totrans-190
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Shopify开发者YouTube频道：[https://www.youtube.com/channel/UCcYsEEKJtpxoO9T-keJZrEw](https://www.youtube.com/channel/UCcYsEEKJtpxoO9T-keJZrEw%20)
- en: 'Shopify official blog for all the latest information about the world of Shopify:
    [https://www.shopify.com/partners/blog](https://www.shopify.com/partners/blog)'
  id: totrans-191
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Shopify官方博客，提供关于Shopify世界的最新信息：[https://www.shopify.com/partners/blog](https://www.shopify.com/partners/blog)
