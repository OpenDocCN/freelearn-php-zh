- en: 7\. Data Persistence
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 7. 数据持久性
- en: Overview
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 概述
- en: By the end of this chapter, you will be able to perform filesystem-related operations
    (read, write, copy, move, and remove); read big files line by line and read CSV
    files one record at a time; download files via the browser using PHP; connect
    to MySQL RDBMS using PHP; create a database and a table, and insert records into
    a MySQL database using PHP; query, update, and delete data from MySQL DB using
    PHP; and secure MySQL queries using prepared statements in PHP.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，你将能够执行与文件系统相关的操作（读取、写入、复制、移动和删除）；逐行读取大文件，一次读取一个CSV文件记录；使用PHP通过浏览器下载文件；使用PHP连接到MySQL关系数据库管理系统；使用PHP创建数据库和表，并将记录插入到MySQL数据库中；使用PHP查询、更新和删除MySQL数据库中的数据；以及使用PHP中的预处理语句来确保MySQL查询的安全性。
- en: Introduction
  id: totrans-3
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简介
- en: In the previous chapter, we saw how to deal with user input using PHP superglobals
    and applied sanitization and validation in order to secure the application. We
    also learned how to keep the user's session on the server and built a small application.
    In that application, we used the session to store data, which vanished with every
    session destroyed (or logout).
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们看到了如何使用PHP超级全局变量处理用户输入，并应用了清理和验证以确保应用程序的安全性。我们还学习了如何将用户的会话保持在服务器上，并构建了一个小型应用程序。在那个应用程序中，我们使用会话来存储数据，这些数据随着每个会话的销毁（或注销）而消失。
- en: In this chapter, we will learn how we can store and read persistent data using
    PHP. Specifically, we will learn how to handle file I/O (open, read, and write)
    and disk operations (change the current directory, create a new file/directory,
    remove a file or directory, and so on). This is useful when you would like to
    use the filesystem for precious application logs, to generate all kinds of reports,
    to handle uploaded user images, and so on. We will also learn how to connect to
    a MySQL database and how to query the data, insert new records, and update or
    delete data from the database. This is helpful when you want to store data in
    a structured way, which can then be easily accessed by many other applications;
    for instance, user-specific data, such as a first name, a last name, an email
    address, and password hashes. And not only this – most probably, your application
    will perform data manipulation, on the data which will be stored somewhere to
    have it ready to read on request. This kind of data might represent elements of
    the business domain and could include product lists, prices, discount coupons,
    orders, subscriptions, and suchlike. We will deal with security in this chapter
    as well. Hence, we'll learn how we can protect our database against potentially
    malicious user input.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将学习如何使用PHP存储和读取持久数据。具体来说，我们将学习如何处理文件I/O（打开、读取和写入）和磁盘操作（更改当前目录、创建新文件/目录、删除文件或目录等）。当你想使用文件系统来存储重要的应用程序日志、生成各种报告、处理上传的用户图像等时，这非常有用。我们还将学习如何连接到MySQL数据库以及如何查询数据、插入新记录以及更新或删除数据库中的数据。当你想以结构化的方式存储数据，以便其他许多应用程序可以轻松访问时，这很有帮助；例如，用户特定的数据，如名字、姓氏、电子邮件地址和密码散列。不仅如此——很可能，你的应用程序将对存储在某个地方以备请求读取的数据进行数据操作。这类数据可能代表业务领域的元素，可能包括产品列表、价格、折扣券、订单、订阅等。我们还将在本章中处理安全问题。因此，我们将学习如何保护我们的数据库免受潜在的恶意用户输入的侵害。
- en: File I/O Handling
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 文件I/O处理
- en: Filesystem operations are some of the most important in programming. We can
    enumerate session data storage in PHP; user-uploaded files, generated report files,
    cached data, logs – all of them utilize the filesystem. Of course, there are many
    other alternatives for persistent storage, but knowing how to operate the filesystem
    in a language is especially important due to its availability. It is basically
    present anywhere and can be used immediately.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 文件系统操作在编程中非常重要。我们可以列举PHP中的会话数据存储；用户上传的文件、生成的报告文件、缓存数据、日志等，它们都使用了文件系统。当然，还有许多其他持久化存储的替代方案，但了解如何在一种语言中操作文件系统尤其重要，因为它无处不在且可以立即使用。
- en: Working with the filesystem, sometimes, you might want to read or write into
    a file that is stored in a known location relative to the script file location.
    For example, for a script that is created in the `/app/demo/` directory that wants
    to read files from `source/` relative to its location (in other words, `/app/demo/source/`),
    it would be better to know the script location.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在处理文件系统时，有时您可能想要读取或写入存储在相对于脚本文件位置的已知位置的文件。例如，对于在 `/app/demo/` 目录中创建的脚本，它想要从相对于其位置的
    `source/` 目录（换句话说，`/app/demo/source/`）读取文件，了解脚本位置会更好。
- en: 'This is different to the current working directory, because you may run the
    script from other locations as well. For example, if the current working directory
    is `/root`, you can run the script providing one of the following is present:
    the relative path, `php ../app/demo/the-script.php`, or the absolute path, `php
    /app/demo/the-script.php`. In this case, the current working directory is `/root`,
    while the script directory is `/app/demo`.'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 这与当前工作目录不同，因为您也可能从其他位置运行脚本。例如，如果当前工作目录是 `/root`，您可以通过提供以下之一来运行脚本：相对路径，`php ../app/demo/the-script.php`，或绝对路径，`php
    /app/demo/the-script.php`。在这种情况下，当前工作目录是 `/root`，而脚本目录是 `/app/demo`。
- en: 'This leads to the next point. PHP offers some "magic constants"; values of
    which change across the scripts depending on where are they used. The list of
    magic constants is as follows:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 这引出了下一个要点。PHP 提供了一些“魔法常量”；它们的值根据它们的使用位置在脚本之间变化。魔法常量的列表如下：
- en: '![Figure 7.1: Magic constants and their descriptions'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 7.1：魔法常量和它们的描述](img/C14196_07_01.jpg)'
- en: '](img/C14196_07_01.jpg)'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 7.1：魔法常量和它们的描述](img/C14196_07_01.jpg)'
- en: 'Figure 7.1: Magic constants and their descriptions'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.1：魔法常量和它们的描述
- en: In our case, we would want to make use of the `__DIR__` constant in the script.
    The directory the script would have to look into would be `$lookupDir = __DIR__
    . '/source';`.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的情况下，我们希望使用脚本中的 `__DIR__` 常量。脚本需要查找的目录将是 `$lookupDir = __DIR__ . '/source';`。
- en: Reading Files with PHP
  id: totrans-15
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 PHP 读取文件
- en: Dealing with files in PHP is one of the easiest things to do. PHP has several
    functions to handle file operations for creating, reading, and updating/editing.
    No additional installation is needed to use PHP filesystem functions.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在 PHP 中处理文件是做起来最容易的事情之一。PHP 有几个函数用于处理文件操作，包括创建、读取和更新/编辑。使用 PHP 文件系统函数不需要额外的安装。
- en: A Simple File Read
  id: totrans-17
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 简单文件读取
- en: 'One of the simplest functions to use for reading a file is `file_get_contents()`.
    This function can be used to fetch all the content of a file and put it into a
    variable, for example. The syntax is as follows:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 用于读取文件的最简单函数之一是 `file_get_contents()`。这个函数可以用来获取文件的所有内容并将其放入一个变量中，例如。其语法如下：
- en: '[PRE0]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '`$filename`: The first argument is required and should be a valid file path
    to read from.'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`$filename`: 第一个参数是必需的，应该是一个有效的文件路径，用于读取。'
- en: '`use_include_path`: This is optional and tells `file_get_contents` to look
    for `$Filename` in the `include_path` list of directories.'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`use_include_path`: 这是一个可选参数，告诉 `file_get_contents` 在 `include_path` 目录列表中查找
    `$Filename`。'
- en: '`$context`: This is optional and is a valid context resource created with `stream_context_create()`.'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`$context`: 这是一个可选参数，是一个使用 `stream_context_create()` 创建的有效上下文资源。'
- en: '`$offset`: This is optional. The offset count begins on the original stream.'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`$offset`: 这是一个可选参数。偏移计数从原始流开始。'
- en: '`$maxlen`: This is an optional argument and denotes the maximum length of the
    data that is to be read. By default, it reads until the end of the file.'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`$maxlen`: 这是一个可选参数，表示要读取的数据的最大长度。默认情况下，它读取到文件末尾。'
- en: The `file_get_contents()` function reads the file content into memory before
    giving any output, until the entire file has been read. This is a drawback that
    makes this function unsuitable for use when the input file size is not known.
    In the case of large files, let's say in excess of 1 GB, the PHP process would
    very quickly fill the allocated RAM memory, and this would make the script crash.
    Therefore, this function is only suitable for use when the expected file size
    is smaller than the `memory_limit` configuration entry in PHP.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: '`file_get_contents()` 函数在给出任何输出之前将文件内容读入内存，直到整个文件被读取。这是一个缺点，使得这个函数在不知道输入文件大小时不适用。在处理大文件的情况下，比如说超过
    1 GB，PHP 进程会非常快地填满分配的 RAM 内存，这会导致脚本崩溃。因此，这个函数仅在预期文件大小小于 PHP 中的 `memory_limit`
    配置条目时适用。'
- en: 'Exercise 7.1: A Simple File Read (All at Once)'
  id: totrans-26
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习 7.1：简单文件读取（一次性读取）
- en: Let's say you are required to develop a script that will be able to import a
    short list of users from a CSV format file into a current application.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你需要开发一个脚本，该脚本能够从 CSV 格式的文件中导入用户列表到当前应用程序中。
- en: 'First, let''s prepare the environment:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们准备环境：
- en: Create a `sample` directory in the current working directory.
  id: totrans-29
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在当前工作目录中创建一个 `sample` 目录。
- en: Download the CSV file called `users_list.csv` from the code repository and put
    it into the `sample` directory.
  id: totrans-30
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从代码仓库下载名为 `users_list.csv` 的 CSV 文件，并将其放入 `sample` 目录中。
- en: 'In this exercise, we will invoke `file_get_contents()` by providing the path
    to the CSV file:'
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这个练习中，我们将通过提供 CSV 文件的路径来调用 `file_get_contents()`：
- en: '[PRE1]'
  id: totrans-32
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: We are invoking the `file_get_contents()` function, specifying the file path,
    and what we are receiving is the full file content. For the file path, we are
    using the `__DIR__` magic constant, which gets replaced with the file directory
    path at compile time.
  id: totrans-33
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们正在调用 `file_get_contents()` 函数，指定文件路径，我们接收的是完整的文件内容。对于文件路径，我们使用 `__DIR__` 魔术常量，它在编译时会被替换为文件目录路径。
- en: Save the preceding PHP script in a file called `file_get_contents.php` in the
    parent directory of the `sample` directory.
  id: totrans-34
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 将前面的 PHP 脚本保存为 `file_get_contents.php` 文件，存放在 `sample` 目录的父目录中。
- en: 'Run `php file_get_contents.php` in your Terminal:'
  id: totrans-35
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在你的终端中运行 `php file_get_contents.php`：
- en: '![Figure 7.2: Printing contents of the file'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 7.2：打印文件内容]'
- en: '](img/C14196_07_02.jpg)'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片 C14196_07_02](img/C14196_07_02.jpg)'
- en: 'Figure 7.2: Printing contents of the file'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 7.2：打印文件内容]'
- en: You will get the CSV file output, as above.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 你将得到如上所示的 CSV 文件输出。
- en: Reading Files with the fread Function
  id: totrans-40
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 fread 函数读取文件
- en: As discussed previously, the `file_get_contents()` function is not suitable
    for use on large files, since the entire file content is first read into memory,
    before any output, which would make the script very inefficient in terms of resource
    usage, as well as in terms of performance.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，`file_get_contents()` 函数不适合用于处理大文件，因为它首先将整个文件内容读入内存，然后再进行任何输出，这会使脚本在资源使用和性能方面都非常低效。
- en: In the following exercise, we will explore some functions that will allow us
    to parse large files, keeping the system memory safe. This means we will use a
    technique that will allow us to read chunks of the file content at a time, which
    can be achieved using a group of PHP built-in functions, and a data stream PHP
    *resource*. A resource in PHP is a reference to the external resource; in our
    case, it will be a reference to a data stream resource (for example, a system
    file, or a URL).
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的练习中，我们将探索一些函数，这些函数将允许我们解析大文件，同时确保系统内存安全。这意味着我们将使用一种技术，允许我们一次读取文件内容的一部分，这可以通过使用一组
    PHP 内置函数和一个数据流 PHP 资源来实现。在 PHP 中，资源是对外部资源的引用；在我们的例子中，它将是对数据流资源的引用（例如，系统文件或 URL）。
- en: '`fopen()` is one of PHP''s built-in functions, used to create stream resources
    in PHP. To achieve greater flexibility with regard to working with files (or any
    other data stream), we will use the `fopen()` function. The `fopen()` function
    accepts two required arguments, `$filename` being the first argument, and the
    access mode being the second one. The access mode describes the stream resource
    access type (read, write, read and write) and resolves to a set of instructions
    while creating the stream. It can have one of the following values:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '`fopen()` 是 PHP 的内置函数之一，用于在 PHP 中创建流资源。为了在处理文件（或任何其他数据流）方面获得更大的灵活性，我们将使用 `fopen()`
    函数。`fopen()` 函数接受两个必需的参数，`$filename` 是第一个参数，访问模式是第二个参数。访问模式描述了流资源的访问类型（读取、写入、读写）并在创建流时解析为一系列指令。它可以有以下值之一：'
- en: '![](img/C14196_07_03.jpg)'
  id: totrans-44
  prefs: []
  type: TYPE_IMG
  zh: '![图片 C14196_07_03](img/C14196_07_03.jpg)'
- en: 'Figure 7.3: Different access modes and their descriptions'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.3：不同的访问模式及其描述
- en: You will notice the "file pointer" concept in the preceding table. You can think
    about this simple yet powerful concept in the same way as the cursor in a text
    file. So, for example, if we deal with the stream resource of a file with the
    `Learning PHP fundamentals` content, having the file pointer on position nine
    means it is located right before the word PHP. Reading the stream from that position
    until the end would result in the `PHP fundamentals` output.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 你会在前面的表中注意到“文件指针”的概念。你可以将这个简单而强大的概念想象成文本文件中的光标。例如，如果我们处理的是包含 `Learning PHP fundamentals`
    内容的文件流资源，文件指针在位置九意味着它位于单词 PHP 之前。从该位置读取到文件末尾将产生 `PHP fundamentals` 输出。
- en: The `fopen()` function returns a file pointer resource or `false` if the operation
    fails.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '`fopen()` 函数返回文件指针资源或 `false`，如果操作失败。'
- en: To read from the data stream, we will use the `fread()` function. This function
    requires two parameters, a resource variable being the first, and the length of
    bytes to read. It returns the read string or Boolean as `false` in the event of
    failure.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 要从数据流中读取，我们将使用 `fread()` 函数。此函数需要两个参数，第一个是资源变量，第二个是要读取的字节数。如果失败，它返回读取的字符串或 `false`。
- en: Other functions that can be used to read from stream resources are `fgets()`
    and `fgetcsv()`, to name a couple. `fgets()` returns a line from the file pointer;
    it requires the stream resource as the first parameter and accepts the optional
    read length (bytes) as the second parameter. `fgetcsv()` is similar to `fgets()`
    – it returns a line of data as an array containing the read CSV fields, except
    this line is parsed data as CSV (meaning more than one line of string data might
    be read, since one CSV field can contain multiline data). The `fgetcsv()` function
    accepts several parameters, but the required stream resource (the first parameter)
    is often enough to do a good job of parsing and returning CSV line data.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 可以用于从流资源中读取的其他函数有 `fgets()` 和 `fgetcsv()`，仅举两例。`fgets()` 从文件指针返回一行；它需要流资源作为第一个参数，并接受可选的读取长度（字节）作为第二个参数。`fgetcsv()`
    与 `fgets()` 类似——它返回包含读取 CSV 字段的行作为数组，但此行是解析为 CSV 的数据行（这意味着可能读取多行字符串数据，因为一个 CSV
    字段可以包含多行数据）。`fgetcsv()` 函数接受多个参数，但通常只需要所需的流资源（第一个参数）就可以很好地解析并返回 CSV 行数据。
- en: While reading from a stream, we might want to know when the end-of-file is hit.
    We can use the `feof()` function for this, which will test for the file pointer's
    presence at the end of the file (EOF). This function returns `true` if the file
    pointer is at EOF or errors occurred. It returns `false` otherwise.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 在从流中读取时，我们可能想知道何时遇到文件末尾。我们可以使用 `feof()` 函数来实现这一点，该函数将检查文件指针是否位于文件末尾（EOF）。如果文件指针位于EOF或发生错误，该函数返回
    `true`。否则返回 `false`。
- en: Note
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: '`feof()` returns `false` for invalid streams as well, so it is recommended
    to test your stream resource before invoking `feof()`.'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '`feof()` 对于无效的流也返回 `false`，因此建议在调用 `feof()` 之前测试您的流资源。'
- en: 'Exercise 7.2: Reading Files with the fread Function'
  id: totrans-53
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习 7.2：使用 fread() 函数读取文件
- en: 'Let''s suppose you are asked to optimize your user''s import script in order
    to work with large data files of the magnitude of tens of gigabytes:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你被要求优化用户的导入脚本，以便能够处理十几个吉字节的大数据文件：
- en: Create an `fread.php` file and insert the following content.
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个 `fread.php` 文件并插入以下内容。
- en: 'First, we define the file path, and then use it when calling `fopen()` to get
    the file pointer resource. We check whether `fopen()` has returned the expected
    resource (not `false`). In the case of failure, the script will exit:'
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们定义文件路径，然后在调用 `fopen()` 获取文件指针资源时使用它。我们检查 `fopen()` 是否返回了预期的资源（不是 `false`）。如果失败，脚本将退出：
- en: '[PRE2]'
  id: totrans-57
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Now, we will make use of the `fread()` function, which will read the file in
    chunks, allowing us to operate on small chunks of data in turn until the file
    is read completely. Next, we define the length to read, in bytes.
  id: totrans-58
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们将使用 `fread()` 函数，该函数将分块读取文件，允许我们依次操作小数据块，直到文件完全读取。接下来，我们定义要读取的长度，以字节为单位。
- en: '[PRE3]'
  id: totrans-59
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Read from the `$fileResource` resource using `fread()` and test for EOF with
    `feof()` in the `while` loop:'
  id: totrans-60
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `fread()` 从 `$fileResource` 资源中读取，并在 `while` 循环中使用 `feof()` 检查 EOF：
- en: '[PRE4]'
  id: totrans-61
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Finally, we close the file pointer resource, as we no longer need it, and print
    the number of iterations:'
  id: totrans-62
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们关闭文件指针资源，因为我们不再需要它，并打印迭代次数：
- en: '[PRE5]'
  id: totrans-63
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Run the file in your Terminal using the `php fread.php` command. The output
    will be as follows:'
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `php fread.php` 命令在您的终端中运行文件。输出将如下所示：
- en: '![Figure 7.4: File output using fread file()'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 7.4：使用 fread() 文件读取的文件输出]'
- en: '](img/C14196_07_04.jpg)'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 7.4：使用 fread() 文件读取的文件输出](img/C14196_07_04.jpg)'
- en: 'Figure 7.4: File output using fread file()'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.4：使用 fread() 文件读取的文件输出
- en: Since the file contains 65 characters and the chunk size was set to 64, the
    file was read twice. This means that, at the first iteration, `fread()` filled
    the memory with 64 bytes of data that was then returned and the occupied memory
    was freed; at the second iteration, `fread()` filled the memory with 1 byte (the
    remaining file content) before it returned this and freed the memory. The advantages
    of this approach are that we can operate with small pieces of content at a time,
    at each read iteration, using a small amount of memory resources, rather than
    loading the whole file in memory and then iterating and processing content line
    by line.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 由于文件包含65个字符，并且块大小设置为64，因此文件被读取了两次。这意味着在第一次迭代中，`fread()`用64字节的数据填充内存，然后返回并释放占用的内存；在第二次迭代中，`fread()`在返回之前用1字节（剩余的文件内容）填充内存并释放内存。这种方法的优势在于，我们可以每次读取迭代时使用小块内容，同时使用少量的内存资源，而不是将整个文件加载到内存中，然后逐行迭代和处理内容。
- en: Benchmark File Reading
  id: totrans-69
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 文件读取基准测试
- en: In previous examples, we saw the difference between the two approaches to reading
    a file, but here, you will evaluate metrics to benchmark each of the file reading
    methods.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，我们看到了两种读取文件方法的区别，但在这里，你将评估指标以基准测试每种文件读取方法。
- en: We will use the same scripts but will add a number of measurements.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用相同的脚本，但将添加一些测量值。
- en: We will make use of the `memory_get_peak_usage()` function to retrieve the peak
    memory usage at some point, as the name suggests. This function accepts one optional
    argument, set to `false` by default when its value is not specified; you should
    set it to `true` when you want the allocated memory to be reported (which we will
    do in the following exercises), rather than the actual memory usage.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用`memory_get_peak_usage()`函数来检索某个时间点的峰值内存使用量，正如其名所示。此函数接受一个可选参数，默认设置为`false`，除非指定值；当你想要报告分配的内存时（我们将在以下练习中这样做），而不是实际的内存使用量时，你应该将其设置为`true`。
- en: 'In the following exercises, we will make use of the `DIRECTORY_SEPARATOR` constant,
    which exists in PHP implicitly, and which is set with the directory separator
    as follows:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下练习中，我们将使用PHP隐含存在的`DIRECTORY_SEPARATOR`常量，它如下设置目录分隔符：
- en: 'Windows: the "\" character'
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Windows：反斜杠字符"\\"
- en: 'Non-Windows: the "/" character'
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 非Windows：斜杠字符"/"
- en: 'Exercise 7.3: Benchmark File Reading'
  id: totrans-76
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习7.3：文件读取基准测试
- en: 'In this exercise, we will evaluate metrics to benchmark each of the file reading
    methods:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们将评估指标以基准测试每种文件读取方法：
- en: First, we will need a pretty big file, and we will generate it with the `dd`
    command.
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们需要一个相当大的文件，我们将使用`dd`命令生成它。
- en: Note
  id: totrans-79
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意
- en: '`dd` is a command-line utility for Unix and Unix-like operating systems that
    exists in any of these distributions.'
  id: totrans-80
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`dd`是Unix和Unix-like操作系统的命令行实用程序，存在于以下任何一种发行版中。'
- en: 'Run the following command to generate a file in `sample/test-256-mb.txt` that
    is full of zeroes, 256 MB in size:'
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行以下命令以在`sample/test-256-mb.txt`中生成一个充满零的文件，大小为256 MB：
- en: '[PRE6]'
  id: totrans-82
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: This file will most likely terminate the script that uses `file_get_contents()`
    to read it, since most PHP installations, by default, do not allow a memory limit
    of more than 128 MB per process. This limit is stored in the `php.ini` configuration
    file by default, under the `memory_limit` parameter, as previously indicated.
    Hence, we will create another file, 10 MB in size, using `dd if=/dev/zero of=sample/test-10-mb.txt
    count=1024 bs=10240`.
  id: totrans-83
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这个文件很可能会终止使用`file_get_contents()`读取它的脚本，因为大多数PHP安装默认情况下不允许每个进程超过128 MB的内存限制。这个限制默认存储在`php.ini`配置文件中的`memory_limit`参数下，如前所述。因此，我们将使用`dd`创建另一个文件，大小为10
    MB，命令如下：`dd if=/dev/zero of=sample/test-10-mb.txt count=1024 bs=10240`。
- en: 'Create `file_get_contents-memory.php` with the following content:'
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下内容创建`file_get_contents-memory.php`：
- en: '[PRE7]'
  id: totrans-85
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Here, we are making use of the first command-line argument (`$argv[1]`), which
    will be the file path to read, relative to the script path. We are adding the
    memory peak metric as well, using the `memory_get_peak_usage()` function.
  id: totrans-86
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在这里，我们使用第一个命令行参数（`$argv[1]`），它将是相对于脚本路径的文件路径。我们还将添加内存峰值指标，使用`memory_get_peak_usage()`函数。
- en: 'Run the following command to check the resource usage:'
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行以下命令以检查资源使用情况：
- en: '[PRE8]'
  id: totrans-88
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'You should essentially get the following output:'
  id: totrans-89
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 你应该基本上得到以下输出：
- en: '[PRE9]'
  id: totrans-90
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Note
  id: totrans-91
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意
- en: We have used the `time` Linux command here, which will run the command and print
    the resource usage.
  id: totrans-92
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们在这里使用了`time` Linux命令，它将运行命令并打印资源使用情况。
- en: The memory value of 12.01 MB in this example output is reported by the `memory_get_peak_usage()`
    function and it shows us that this is the RAM memory amount necessary for a PHP
    script to read a 10 MB file.
  id: totrans-93
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在这个示例输出中，12.01 MB的内存值是由`memory_get_peak_usage()`函数报告的，它显示这是PHP脚本读取10 MB文件所需的RAM内存量。
- en: 'Let''s now run the same script, but for the bigger file:'
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们运行相同的脚本，但针对更大的文件：
- en: '[PRE10]'
  id: totrans-95
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'In the output, we will see an error message like this:'
  id: totrans-96
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在输出中，我们将看到如下错误信息：
- en: '[PRE11]'
  id: totrans-97
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: As expected, trying to read a 256 MB file into memory fails because the limit
    of 128 MB per process is exceeded.
  id: totrans-98
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如预期的那样，尝试将256 MB的文件读入内存失败，因为每个进程的128 MB限制被超过了。
- en: 'Now, let''s check the other approach, using `fread()` to read chunks of data
    from the file one at a time. Create a file called `fread-memory.php` and insert
    the following content. We store the `$filePath` variable based on the user''s
    first input argument and we create the resource for that file path, stored under
    the `$fileResource` variable:'
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们检查另一种方法，使用`fread()`一次读取文件中的一块数据。创建一个名为`fread-memory.php`的文件，并插入以下内容。我们根据用户的第一个输入参数存储`$filePath`变量，并为该文件路径创建资源，存储在`$fileResource`变量下：
- en: '[PRE12]'
  id: totrans-100
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'If the resource is invalid, the script will be terminated:'
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果资源无效，脚本将被终止：
- en: '[PRE13]'
  id: totrans-102
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'We store the second input argument in the `$readLength` variable, which will
    take the value of the second input argument, with a fallback to `4096` if the
    second argument is not present. This is the length in bytes that the `fread()`
    function will use to read from `$fileResource`. We also initiate the `$iterations`
    variable with a start value of zero:'
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将第二个输入参数存储在`$readLength`变量中，它将采用第二个参数的值，如果第二个参数不存在，则回退到`4096`。这是`fread()`函数将从`$fileResource`读取的字节长度。我们还以零为起始值初始化`$iterations`变量：
- en: '[PRE14]'
  id: totrans-104
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'We read the entire file using the `while` loop, as in the previous exercise.
    The difference here is that the output of the `fread()` function is not used.
    For each iteration, we increment the `$iterations` variable as well:'
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们使用`while`循环读取整个文件，就像之前的练习一样。这里的区别在于`fread()`函数的输出没有被使用。对于每次迭代，我们增加`$iterations`变量：
- en: '[PRE15]'
  id: totrans-106
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Finally, we close the stream and print the number of iterations performed and
    the memory usage necessary to read the file:'
  id: totrans-107
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们关闭流并打印执行迭代次数和读取文件所需的内存使用量：
- en: '[PRE16]'
  id: totrans-108
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: What has changed from the previous `file_get_contents-memory.php` script is
    that we are reading chunks of data one at a time from the file, using the `$readLength`
    variable.
  id: totrans-109
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 从之前的`file_get_contents-memory.php`脚本中改变的是，我们正在一次读取文件中的一块数据，使用`$readLength`变量。
- en: 'Now, let''s run some tests, reading the 10 MB file:'
  id: totrans-110
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们运行一些测试，读取10 MB的文件：
- en: '[PRE17]'
  id: totrans-111
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The output is as follows:'
  id: totrans-112
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE18]'
  id: totrans-113
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: As we can see, to read the entire 10 MB file, it took 2,561 read iterations
    of 4 KB (the second `script` argument is missing, and the default 4,096 bytes
    are set for the `$readLength` variable). The total duration of the script was
    0.05 seconds, compared to 0.03 seconds when using `file_get_contents()`. The main
    difference to note is the memory usage – 2 MB, which is the minimum the PHP script
    allocates per process, compared to 12.01 MB when using the `file_get_contents()`
    function.
  id: totrans-114
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如我们所见，为了读取整个10 MB文件，它进行了2,561次4 KB的读取迭代（第二个`script`参数缺失，默认将4,096字节设置为`$readLength`变量）。脚本的总时长为0.05秒，而使用`file_get_contents()`时为0.03秒。需要注意的是主要区别是内存使用量——2
    MB，这是PHP脚本每个进程分配的最小内存量，而使用`file_get_contents()`函数时为12.01 MB。
- en: 'What about reading a chunk of 1 MB instead of the default 4 KB? Let''s run
    the following command with 1,048,576 bytes (which are the equivalent of 1 MB):'
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果读取1 MB的数据块而不是默认的4 KB会怎样？让我们使用1,048,576字节（相当于1 MB）运行以下命令：
- en: '[PRE19]'
  id: totrans-116
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'The output is now as follows:'
  id: totrans-117
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 输出现在如下：
- en: '[PRE20]'
  id: totrans-118
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Now, the entire 10 MB file read used only 11 iterations, with a peak of 4 MB
    of RAM memory. This time, the script took 0.03 seconds, as in the case of using
    the `file_get_contents()` function.
  id: totrans-119
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 现在，读取整个10 MB文件只用了11次迭代，峰值RAM内存为4 MB。这次，脚本耗时0.03秒，与使用`file_get_contents()`函数的情况相同。
- en: 'And now, let''s read the big file, which could not be read using `file_get_contents()`.
    Run the following command:'
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们读取大文件，该文件无法使用`file_get_contents()`读取。运行以下命令：
- en: '[PRE21]'
  id: totrans-121
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'The output is as follows:'
  id: totrans-122
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE22]'
  id: totrans-123
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: In this case, the read length is 4 KB, and the complete file read required 65,537
    iterations, using a peak of 2 MB of memory. The script took 0.3 seconds to read
    the entire file, which is not bad, but could be improved by increasing the read
    length to a bigger value; and this is what we will do in the next step.
  id: totrans-124
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在这种情况下，读取长度为4 KB，完整文件读取需要65,537次迭代，使用峰值2 MB的内存。脚本读取整个文件耗时0.3秒，这并不坏，但可以通过增加读取长度到一个更大的值来改进；这正是我们下一步要做的。
- en: 'Now, run the same command, specifying the chunk size of 1 MB:'
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，运行相同的命令，指定1 MB的块大小：
- en: '[PRE23]'
  id: totrans-126
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'The output is now this:'
  id: totrans-127
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 现在的输出如下：
- en: '[PRE24]'
  id: totrans-128
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: As expected, the time needed to read the entire 256 MB file decreased (from
    0.3 seconds to 0.08 seconds), since the read length is higher (1 MB versus 4 KB,
    resulting in peak memory usage of 4 MB versus 2 MB), and the number of iterations
    required decreased to 257.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 如预期的那样，读取整个256 MB文件所需的时间减少了（从0.3秒减少到0.08秒），因为读取长度更高（1 MB与4 KB相比，导致峰值内存使用量为4
    MB与2 MB），并且所需的迭代次数减少到257次。
- en: Now, having a look at this data, we can come up with our own ideas as to what
    is happening behind the scenes. In the case of `file_get_contents()`, a peak of
    12.01 MB memory is used reading the 10 MB file; that's because the whole file
    was loaded into memory using this approach. The 256 MB file caused the script
    shutdown because the limit of 128 MB was hit.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，看看这些数据，我们可以提出自己的想法，了解幕后发生的事情。在`file_get_contents()`的情况下，读取10 MB文件时使用了12.01
    MB的峰值内存；这是因为整个文件都是使用这种方法加载到内存中的。256 MB的文件导致脚本关闭，因为达到了128 MB的限制。
- en: On the other hand, it seems the `fread` approach did pretty well, both in terms
    of duration and memory usage. Reading the 10 MB file in chunks of 4 KB, the script
    uses 2 MB of memory, compared to 12 MB in the case of `file_get_contents`, while
    the read time is significantly bigger (0.05 for `fread()` versus 0.03 for `file_get_contents()`).
    Reading the same file though, but in chunks of 1 MB, we get similar results in
    terms of performance, but we still use much less memory than in the case of `file_get_contents`
    (4 MB versus 12 MB).
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，似乎`fread`方法在持续时间和内存使用方面都做得很好。以4 KB的数据块读取10 MB文件，脚本使用2 MB的内存，而`file_get_contents`的情况下为12
    MB，而读取时间显著更长（`fread()`为0.05秒，而`file_get_contents()`为0.03秒）。尽管如此，以1 MB的数据块读取相同的文件，我们在性能方面得到了类似的结果，但我们仍然比`file_get_contents`情况下使用的内存少得多（4
    MB与12 MB相比）。
- en: Now, what happens when we increase the scale a bit? Reading the 256 MB file
    was not possible with `file_get_contents()` on account of exhausted memory. But
    look at the second approach – not only is the file read entirely but also, only
    2 MB of memory is used for this process! It takes about 0.3 seconds to read, which
    is not very satisfactory, but let's see what happens when the read length is increased
    and, therefore, the number of iterations is decreased. We get much better results
    now – a read time of 0.08 seconds and a memory peak of 4 MB.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果我们稍微增加一下规模，会发生什么呢？使用`file_get_contents()`读取256 MB文件因内存耗尽而无法完成。但看看第二种方法——不仅整个文件被读取，而且在这个过程中只使用了2
    MB的内存！读取耗时大约0.3秒，这并不令人满意，但让我们看看当读取长度增加，因此迭代次数减少时会发生什么。现在我们得到了更好的结果——读取时间为0.08秒，内存峰值4
    MB。
- en: As you can see, the convenient way – using `file_get_contents()` – is more suitable
    for small or very small files, whereas dealing with large files requires you to
    use different approaches, such as `fread()`, which reads chunks of data; `fgets()`,
    which gets an entire line at a time from the file pointer; and `fgetcsv()`, which
    is similar to `fgets()` but, in addition, parses the CSV string line into an array
    with data.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所见，方便的方法——使用`file_get_contents()`——更适合处理小文件或非常小的文件，而处理大文件则需要你使用不同的方法，例如`fread()`，它读取数据块；`fgets()`，它从文件指针一次读取整行；以及`fgetcsv()`，它与`fgets()`类似，但除此之外，它还将CSV字符串行解析成包含数据的数组。
- en: Reading Files Line by Line
  id: totrans-134
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 逐行读取文件
- en: As indicated earlier, there are more ways to perform optimized reading from
    big files. In the following exercise, you will learn how to use PHP to read a
    file line by line. This helps especially when one entry record corresponds to
    one line, as in access or error logs, for example, so that reading the file allows
    one data record to be processed at a time.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，还有更多方法可以从大文件中进行优化读取。在接下来的练习中，你将学习如何使用PHP逐行读取文件。这特别有助于当一条记录对应一行时，例如在访问或错误日志中，这样读取文件可以一次处理一个数据记录。
- en: 'Exercise 7.4: Reading Files Line by Line'
  id: totrans-136
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习7.4：逐行读取文件
- en: 'In this exercise, we will open a file and read it line by line:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们将打开一个文件并逐行读取它：
- en: 'Create a file called `fgets.php` and add the following content. As in the previous
    example, we define the file path and get the file pointer. In the event of failure,
    the script will exit with an error message:'
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `fgets.php` 的文件，并添加以下内容。和前面的例子一样，我们定义文件路径并获取文件指针。如果失败，脚本将带错误信息退出：
- en: '[PRE25]'
  id: totrans-139
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Next, we initialize the `$lineNumber` variable with the value `0`. And then,
    as in the case of `fread()`, we perform iterations to read the data in slices.
    This time, using `fgets()`, we will get one line at a time. The line is then numbered
    and printed to output. At the end, we close the file resource pointer, since we
    no longer need it:'
  id: totrans-140
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将 `$lineNumber` 变量初始化为值 `0`。然后，就像在 `fread()` 的情况下一样，我们执行迭代以分块读取数据。这次，使用
    `fgets()`，我们将一次获取一行。然后，该行被编号并打印到输出。最后，我们关闭文件资源指针，因为我们不再需要它：
- en: '[PRE26]'
  id: totrans-141
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Run the preceding script using the command-line tool, `php fgets.php`. The
    output will look like this:'
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用命令行工具 `php fgets.php` 运行前面的脚本。输出将如下所示：
- en: '[PRE27]'
  id: totrans-143
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: As you will notice, we have a line without content – that is actually an empty
    line in a CSV file. Please pay attention when dealing with file lines when trying
    to process data; check for a non-empty line at least before proceeding with processing.
  id: totrans-144
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如你所注意到的，我们有一个没有内容的行——这实际上是一个 CSV 文件中的空行。在尝试处理数据时，请注意处理文件行；在继续处理之前，至少检查非空行。
- en: Reading CSV Files
  id: totrans-145
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 读取 CSV 文件
- en: The previous example shows a handy way to read one line at a time from a file.
    It turns out in our case that it's about a CSV file, a very simple one, with a
    comma as a delimiter, and that's pretty much it. But what if you have to deal
    with a complicated CSV document? Luckily, PHP provides a built-in function for
    that, called `fgetcsv()`. Using it, we can get one record at a time; that's right,
    one record, not one line, as the record can be spread over several lines, containing
    enclosed data (for example, multiline data wrapped between quotes).
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的示例展示了逐行读取文件的一个便捷方法。在我们的案例中，这是一个 CSV 文件，一个非常简单的文件，以逗号作为分隔符，就这么多。但是，如果你必须处理一个复杂的
    CSV 文档呢？幸运的是，PHP 提供了一个内置函数来处理这种情况，称为 `fgetcsv()`。使用它，我们可以一次获取一条记录；没错，一条记录，而不是一行，因为记录可以分布在多行中，包含封装的数据（例如，在引号之间包装的多行数据）。
- en: 'Exercise 7.5: Reading CSV Files'
  id: totrans-147
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习 7.5：读取 CSV 文件
- en: 'In this exercise, we will read the data from CSV files:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们将从 CSV 文件中读取数据：
- en: 'Create a file called `fgetcsv.php` and add the following content. As before,
    we declare the file path and get the file pointer. In the event of an error, the
    script will exit with an error message:'
  id: totrans-149
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `fgetcsv.php` 的文件，并添加以下内容。和之前一样，我们声明文件路径并获取文件指针。如果发生错误，脚本将带错误信息退出：
- en: '[PRE28]'
  id: totrans-150
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Then, we initialize the `$recordNumber` variable with the value `0`; we will
    need it to print to output for each line. And we read one CSV record at a time
    using the `fgetcsv()` function, in a `while` loop, printing the record number
    and its content:'
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们将 `$recordNumber` 变量初始化为值 `0`；我们将需要它来为每一行打印输出。然后，我们使用 `fgetcsv()` 函数在 `while`
    循环中逐条读取 CSV 记录，打印记录编号及其内容：
- en: '[PRE29]'
  id: totrans-152
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Create a file called `users_list_enclosed.csv` inside the `sample/` directory
    with the following content:'
  id: totrans-153
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `sample/` 目录下创建一个名为 `users_list_enclosed.csv` 的文件，内容如下：
- en: '[PRE30]'
  id: totrans-154
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Run the script with `php fgetcsv.php` and the output will look like this:'
  id: totrans-155
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `php fgetcsv.php` 运行脚本，输出将如下所示：
- en: '![Figure 7.5: Printing the arrays'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 7.5：打印数组'
- en: '](img/C14196_07_05.jpg)'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: '![img/C14196_07_05.jpg]'
- en: 'Figure 7.5: Printing the arrays'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.5：打印数组
- en: As you will notice, the `fgetcsv()` function does a very good job, parsing the
    CSV entries for us correctly. It does not matter whether the CSV content has a
    custom delimiter, enclosure, or escape character; all these parameters can be
    passed as function arguments to `fgetcsv()` to make the parser understand the
    format and perform the appropriate parsing
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所注意到的，`fgetcsv()` 函数做得非常好，为我们正确地解析了 CSV 条目。无论 CSV 内容是否有自定义分隔符、封装符或转义字符，所有这些参数都可以作为函数参数传递给
    `fgetcsv()`，以便解析器理解格式并执行适当的解析。
- en: Downloading a File with PHP
  id: totrans-160
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 PHP 下载文件
- en: We saw how we can make the script read the files using a variety of means in
    order to allow us to *do something* with that content. But there is also downloading,
    when we need the file to be read by the script and sent back to the user, as a
    response to the HTTP request, and we don't want the PHP process to overload the
    memory by doing this, something along the lines of reading in chunks and sending
    the user small pieces at a time. Fortunately, there is a function for that, which
    is called `readfile()`. This function reads the file and writes it directly to
    the output buffer. The `readfile()` function requires only the file path to read
    from. The other optional arguments are a Boolean, which tells the function to
    search for the file in the `include_path` of PHP, and a context stream resource
    as a third argument.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 我们看到了如何使用各种方法让脚本读取文件，以便我们可以对内容进行操作。但还有下载的情况，当我们需要脚本读取文件并将其作为对 HTTP 请求的响应发送给用户时，我们不希望
    PHP 进程因这样做而超载内存，类似于分块读取并发送用户小部分内容。幸运的是，有一个函数可以做到这一点，它被称为 `readfile()`。这个函数读取文件并将其直接写入输出缓冲区。`readfile()`
    函数只需要读取的文件路径。其他可选参数是一个布尔值，它告诉函数在 PHP 的 `include_path` 中搜索文件，以及一个作为第三个参数的上下文流资源。
- en: A context stream is a set of options for a specific wrapper (a piece of code
    that builds other code) that modify or enhance the behavior of a stream. For example,
    when we want to read a remote file, using FTP, we pass the file path as the first
    argument of the `readfile()` function, and a valid FTP context stream variable
    as a third argument. We will not use context streams in the following exercises.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 上下文流是一组针对特定包装器（构建其他代码的代码片段）的选项，它修改或增强流的行为。例如，当我们想使用 FTP 读取远程文件时，我们将文件路径作为 `readfile()`
    函数的第一个参数传递，并将有效的 FTP 上下文流变量作为第三个参数。在接下来的练习中，我们将不会使用上下文流。
- en: 'Exercise 7.6: Downloading a File'
  id: totrans-163
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习 7.6：下载文件
- en: 'In this exercise, we will download a file and save it to the specified destination
    using PHP:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们将使用 PHP 下载一个文件并将其保存到指定的位置：
- en: 'Create a file called `download.php` and insert the following content. First,
    we define the existing file path, and then proceed to set headers, where we make
    use of the `filesize()` function to return the file size in bytes for the file
    being downloaded, and `basename()`, which returns the last component of the path;
    in other words, it will cut the directory structure except for the file name.
    Finally, we call `readfile()` so that PHP can send the file back to the server
    and client, as a response to the HTTP request:'
  id: totrans-165
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `download.php` 的文件，并插入以下内容。首先，我们定义现有文件路径，然后继续设置头部信息，在这里我们使用 `filesize()`
    函数来返回正在下载的文件字节数，以及 `basename()` 函数，它返回路径的最后一个组成部分；换句话说，它将裁剪目录结构，只保留文件名。最后，我们调用
    `readfile()` 函数，以便 PHP 可以将文件发送回服务器和客户端，作为对 HTTP 请求的响应：
- en: '[PRE31]'
  id: totrans-166
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Make sure you have started the built-in server in this directory (which is `/app`
    in my case) running `php -S 127.0.0.1` in your Terminal, and that the file exists.
  id: totrans-167
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 确保您已在本目录（在我的例子中是 `/app`）中启动了内置服务器，并在终端中运行 `php -S 127.0.0.1`，并且文件确实存在。
- en: 'Then, access the script at `http://127.0.0.1:8080/download.php`. You should
    then see a pop-up box asking where to save the CSV file, or it will save the file
    automatically to a set destination, depending on your browser''s configuration:'
  id: totrans-168
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，访问 `http://127.0.0.1:8080/download.php` 上的脚本。您应该会看到一个弹出框询问保存 CSV 文件的位置，或者根据您的浏览器配置，它将自动保存到设置的位置：
- en: '![Figure 7.6: Downloading the CSV file'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 7.6：下载 CSV 文件'
- en: '](img/C14196_07_06.jpg)'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/C14196_07_06.jpg)'
- en: 'Figure 7.6: Downloading the CSV file'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.6：下载 CSV 文件
- en: Note
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: One should check whether the file exists on disk or not and treat each case
    accordingly. When the file is missing, `readfile()` will output nothing and the
    browser might receive the output of the PHP script (output of `download.php` in
    our case).
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 应该检查文件是否在磁盘上存在，并相应地处理每种情况。当文件缺失时，`readfile()` 将不输出任何内容，浏览器可能会接收到 PHP 脚本的输出（在我们的例子中是
    `download.php` 的输出）。
- en: Writing a File with PHP
  id: totrans-174
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 PHP 写入文件
- en: Writing files with PHP is possible using a variety of methods, the majority
    involving the `fwrite()` and `file_put_contents()` built-in functions.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 PHP 写入文件是可能的，可以使用多种方法，其中大多数涉及 `fwrite()` 和 `file_put_contents()` 内置函数。
- en: The `fwrite()` function accepts two required arguments, the first is the file
    pointer, and the second one is the string to write to the file. The function returns
    the number of bytes written or the Boolean `false` in the event of failure.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: '`fwrite()` 函数接受两个必需的参数，第一个是文件指针，第二个是要写入文件的字符串。函数返回写入的字节数或失败时的布尔 `false`。'
- en: '`file_put_contents()` is the equivalent of calling the `fopen()`, `fwrite()`,
    and `fclose()` sequence.'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: '`file_put_contents()` 等同于调用 `fopen()`、`fwrite()` 和 `fclose()` 序列。'
- en: Note
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: When a file is written several times in a single PHP process, the `fwrite()`
    method is preferred, for performance reasons, since the stream resource is reused,
    and the file open and close operations (`fopen()` and `fclose()`) are avoided
    for each write as it happens with the `file_put_contents()` function. A good example
    of using `fwrite()` over `file_put_contents()` is the case of file loggers, when
    a PHP process might write several times in the same file during its lifetime.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 当在单个 PHP 进程中多次写入文件时，出于性能考虑，建议使用 `fwrite()` 方法，因为流资源被重用，并且避免了每次写入时都发生的文件打开和关闭操作（`fopen()`
    和 `fclose()`）。使用 `fwrite()` 而不是 `file_put_contents()` 的一个很好的例子是文件日志记录器，在 PHP 进程的生命周期内可能会多次写入同一个文件。
- en: 'The first required argument is the filename, and the second one is the data
    to write to the file. The data can be a string, a resource stream, or a single
    dimension array of strings, rows of which are written in sequence. The third argument
    is optional and accepts the flags for a write operation. This can be any combination
    of the following values:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个必需的参数是文件名，第二个是要写入文件的数据。数据可以是字符串、资源流或字符串的单维数组，行将按顺序写入。第三个参数是可选的，接受写入操作的标志。这可以是以下值的任意组合：
- en: '![Figure 7.7: Different flags for file_put_contents() function, and their descriptions'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 7.7：file_put_contents() 函数的不同标志及其描述'
- en: '](img/C14196_07_07.jpg)'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/C14196_07_07.jpg)'
- en: 'Figure 7.7: Different flags for file_put_contents() function, and their descriptions'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.7：file_put_contents() 函数的不同标志及其描述
- en: 'When using the `fwrite` method, we may want to use the same data stream resource
    to read from; for example, to move the pointer at the beginning of the file after
    writing, or to read the last N bytes of data. In this case, we would use the `fseek()`
    function. This function sets the file pointer (remember the cursor analogy before?)
    to a specific position. The function signature is as follows:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用 `fwrite` 方法时，我们可能希望使用相同的数据流资源进行读取；例如，在写入后移动文件指针到文件开头，或读取数据的最后 N 个字节。在这种情况下，我们将使用
    `fseek()` 函数。此函数将文件指针（记得之前的光标类比？）设置到特定位置。函数签名如下：
- en: '[PRE32]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: The new position, measured in bytes, is obtained by adding an offset to the
    position specified by `$whence`.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 新位置，以字节为单位，是通过将偏移量添加到 `$whence` 指定的位置获得的。
- en: '`$whence` values can be:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: '`$whence` 的值可以是：'
- en: '`SEEK_SET` – Sets the position of the file pointer equal to `offset` bytes.
    This is the default option if none was specified.'
  id: totrans-188
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SEEK_SET` – 将文件指针的位置设置为 `offset` 字节。如果没有指定，这是默认选项。'
- en: '`SEEK_CUR` – Sets the position of the file pointer equal to the current location
    plus `offset`.'
  id: totrans-189
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SEEK_CUR` – 将文件指针的位置设置为当前位置加上 `offset`。'
- en: '`SEEK_END` – Sets the position of the file pointer equal to EOF plus `offset`.'
  id: totrans-190
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SEEK_END` – 将文件指针的位置设置为 EOF 加上 `offset`。'
- en: 'Exercise 7.7: Writing to Files'
  id: totrans-191
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习 7.7：向文件写入
- en: 'In the following exercise, we will perform write operations in files using
    both of the `fwrite()` and `file_put_contents()` functions described previously:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的练习中，我们将使用前面描述的 `fwrite()` 和 `file_put_contents()` 函数在文件中执行写入操作：
- en: 'Create a file called `write.php` and insert the following content:'
  id: totrans-193
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `write.php` 的文件，并插入以下内容：
- en: '[PRE33]'
  id: totrans-194
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: First, we define the file path to write to, and then we open the file pointer
    using the `fopen()` function.
  id: totrans-195
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 首先，我们定义要写入的文件路径，然后使用 `fopen()` 函数打开文件指针。
- en: Note
  id: totrans-196
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意
- en: Always make sure to have the directory structure created before trying to open
    or put content into a file. Following our example, you should make sure the `sample/`
    directory exists in the current working directory.
  id: totrans-197
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在尝试打开或向文件中写入内容之前，务必确保已创建目录结构。按照我们的示例，你应该确保当前工作目录中存在 `sample/` 目录。
- en: 'Next, we attempt to write to the file using the `fwrite()` function, storing
    the output in the `$written` variable:'
  id: totrans-198
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们尝试使用 `fwrite()` 函数向文件写入，并将输出存储在 `$written` 变量中：
- en: '[PRE34]'
  id: totrans-199
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: If the write fails (`$written` is the Boolean `false`), then we print an error
    message and continue the script. Otherwise, we print the success message, indicating
    the number of bytes written. After that, in order to read from the file, we move
    the pointer at the beginning of the file, at position zero, using the `fseek()`
    function. Then, we just print the file content to test the written data.
  id: totrans-200
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果写入失败（`$written` 是布尔值 `false`），则我们打印错误消息并继续脚本。否则，我们打印成功消息，指示写入的字节数。之后，为了从文件中读取，我们使用
    `fseek()` 函数将指针移动到文件开头，位置为零。然后，我们只打印文件内容以测试写入的数据。
- en: 'To test the second approach, we define the `write-with-fpc.txt` file inside
    the `sample/` directory, and then call the `file_put_contents()` function in an
    attempt to write to the file, and store the output in the same `$written` variable:'
  id: totrans-201
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要测试第二种方法，我们在 `sample/` 目录内定义 `write-with-fpc.txt` 文件，然后尝试使用 `file_put_contents()`
    函数写入文件，并将输出存储在相同的 `$written` 变量中：
- en: '[PRE35]'
  id: totrans-202
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'As in the previous example, if we failed to write to the file, then we print
    an error message and continue the script. In the case of a successful write, we
    print the message indicating the number of bytes written into the file followed
    by the actual file content:'
  id: totrans-203
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 与前一个例子一样，如果我们未能写入文件，则打印错误消息并继续脚本。在写入成功的情况下，我们打印消息，指示写入文件中的字节数，然后是实际文件内容：
- en: '[PRE36]'
  id: totrans-204
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Note
  id: totrans-205
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意
- en: The whole script can be referred at [https://packt.live/2MCkeOJ](https://packt.live/2MCkeOJ).
  id: totrans-206
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 整个脚本可以在 [https://packt.live/2MCkeOJ](https://packt.live/2MCkeOJ) 上找到。
- en: 'Run the script from the command line with `php write.php`. The output should
    look like this:'
  id: totrans-207
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `php write.php` 从命令行运行脚本。输出应该如下所示：
- en: '![Figure 7.8: Writing into files using different methods'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 7.8：使用不同方法写入文件'
- en: '](img/C14196_07_08.jpg)'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/C14196_07_08.jpg)'
- en: 'Figure 7.8: Writing into files using different methods'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.8：使用不同方法写入文件
- en: In this exercise, we wrote string sequences in two different files using two
    different methods – `file_put_contents()` and `fwrite()`.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们使用两种不同的方法——`file_put_contents()` 和 `fwrite()`——在两个不同的文件中写入字符串序列。
- en: Congratulations! You just managed to write files using PHP.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 恭喜！你刚刚成功使用 PHP 写入了文件。
- en: 'Exercise 7.8: Appending Content in Files'
  id: totrans-213
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习 7.8：在文件中追加内容
- en: 'We have seen how it is possible to write fresh content in files, but often,
    you just want to add to an existing file – think about some sort of log, for example.
    In this exercise, you will learn how it is possible to append content to a file,
    using PHP:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到如何在文件中写入新内容，但通常，你只是想向现有文件中添加内容——比如某种日志，例如。在这个练习中，你将学习如何使用 PHP 向文件追加内容：
- en: 'Create a file called `write-append.php` and use the code from the previous
    exercise with two minor modifications. First, we want to change the `fopen()`
    mode, from `w+` to `a+` (from write and read to write-append and read):'
  id: totrans-215
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `write-append.php` 的文件，并使用前一个练习中的代码，进行两项小的修改。首先，我们想要更改 `fopen()` 模式，从
    `w+` 改为 `a+`（从读写改为写入追加和读取）：
- en: '[PRE37]'
  id: totrans-216
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Add the third parameter to the `file_put_contents()` function – the `FILE_APPEND`
    constant:'
  id: totrans-217
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 `file_put_contents()` 函数的第三个参数添加为 `FILE_APPEND` 常量：
- en: '[PRE38]'
  id: totrans-218
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Run the script from the command-line interface with `php write-append.php`
    and you will get the following result:'
  id: totrans-219
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `php write-append.php` 从命令行界面运行脚本，你将得到以下结果：
- en: '![Figure 7.9: Result of the script'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 7.9：脚本的结果'
- en: '](img/C14196_07_09.jpg)'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/C14196_07_09.jpg)'
- en: 'Figure 7.9: Result of the script'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.9：脚本的结果
- en: Running the script over and over again will print you the same success message,
    and, with each run, the number of sentences will increase in each file, due to
    the `append` instruction.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 重复运行脚本会打印相同的成功消息，并且由于 `append` 指令，每次运行后每个文件中的句子数量都会增加。
- en: Appending content in files is very useful in the case of logging and generating
    content in files in order to perform further downloads, to name but a couple of
    use cases.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 在文件中追加内容在日志记录和生成文件内容以执行进一步下载等用例中非常有用。
- en: Other Filesystem Functions
  id: totrans-225
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 其他文件系统函数
- en: PHP offers generous support when it comes to handling filesystems. All of the
    functions can be explored at [https://packt.live/2MAsLmw](https://packt.live/2MAsLmw).
    In addition, we will cover some of the most widely used filesystem functions in
    PHP.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 当涉及到处理文件系统时，PHP 提供了丰富的支持。所有这些函数都可以在 [https://packt.live/2MAsLmw](https://packt.live/2MAsLmw)
    上探索。此外，我们还将介绍 PHP 中一些最广泛使用的文件系统函数。
- en: Deleting a File with PHP
  id: totrans-227
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 PHP 删除文件
- en: '`unlink()` is the delete files function. It requires the file path as the first
    parameter and accepts an optional context stream. It returns `TRUE` if the file
    is deleted successfully, or `FALSE` otherwise.'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: '`unlink()`是删除文件的函数。它需要一个文件路径作为第一个参数，并接受一个可选的上下文流。如果文件成功删除，则返回`TRUE`，否则返回`FALSE`。'
- en: Before deleting a file, it is good to check first whether the file path points
    to an actual file, and, to achieve this, we can use the `is_file()` function.
    This function requires only the file path as the first parameter. It returns `TRUE`
    if a file is located and is a regular file, otherwise `FALSE`.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 在删除文件之前，最好先检查文件路径是否指向一个实际的文件，为此我们可以使用`is_file()`函数。此函数只需要文件路径作为第一个参数。如果找到文件并且是常规文件，则返回`TRUE`，否则返回`FALSE`。
- en: 'Exercise 7.9: Deleting a File with PHP'
  id: totrans-230
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习7.9：使用PHP删除文件
- en: 'When working with file content in PHP, it is highly likely that you will want
    to clean some older files. In this exercise, we will write code to delete a file
    using PHP:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 当在PHP中处理文件内容时，你很可能想要清理一些旧文件。在这个练习中，我们将编写使用PHP删除文件的代码：
- en: Create an empty file called `to-delete.txt` in the `sample/` directory. This
    is the file we will delete with PHP.
  id: totrans-232
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`sample/`目录中创建一个名为`to-delete.txt`的空文件。这是我们用PHP要删除的文件。
- en: 'Create a file called `delete.php`, and insert the following code:'
  id: totrans-233
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`delete.php`的文件，并插入以下代码：
- en: '[PRE39]'
  id: totrans-234
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE39]'
- en: In this script, we check whether the file exists and is a regular file, using
    the `is_file()` function. In the case of a regular file, next, we test the file
    deletion; that is, the output of the `unlink()` function that is responsible for
    this, and then print the appropriate message based on the output. If the file
    does not exist, a message providing a notification of this will be printed.
  id: totrans-235
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在这个脚本中，我们使用`is_file()`函数检查文件是否存在并且是一个常规文件。对于常规文件，接下来我们测试文件删除；即负责此操作的`unlink()`函数的输出，然后根据输出打印适当的消息。如果文件不存在，将打印一个通知此情况的提示信息。
- en: 'Run the script in the command-line interface. With `php delete.php`, you will
    notice the following output:'
  id: totrans-236
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在命令行界面中运行脚本。使用`php delete.php`，你会注意到以下输出：
- en: '[PRE40]'
  id: totrans-237
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Running the script again will print the following:'
  id: totrans-238
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 再次运行脚本将打印以下内容：
- en: '[PRE41]'
  id: totrans-239
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE41]'
- en: This means the `delete` operation was indeed executed successfully.
  id: totrans-240
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这意味着`delete`操作确实已成功执行。
- en: In this exercise, when running the script for the first time, all the conditions
    were met in order to run file deletion, and the file was indeed deleted. When
    running the script for the second time, the script cannot find the file for the
    specified path, so the script returns the `file does not exist` message immediately,
    prior to exiting.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，当第一次运行脚本时，所有条件都满足以运行文件删除，并且文件确实被删除了。当第二次运行脚本时，脚本无法找到指定路径的文件，因此脚本在退出之前立即返回`文件不存在`的消息。
- en: Moving Files with PHP
  id: totrans-242
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用PHP移动文件
- en: On occasion, you may need to move files to a new location, for example, to the
    archive. This might be the case with a database data dump or log files, to name
    but two. PHP provides a function for moving functionality, called `rename()`,
    which requires the actual file path as a first argument, and the target file path
    as a second argument. This function returns `TRUE` if successful and `FALSE` in
    the event of failure, and can be used for both files and directories.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，你可能需要将文件移动到新的位置，例如，移动到存档中。这可能适用于数据库数据转储或日志文件等情况。PHP提供了一个用于移动功能的函数，称为`rename()`，它需要一个实际的文件路径作为第一个参数，以及目标文件路径作为第二个参数。此函数在成功时返回`TRUE`，在失败时返回`FALSE`，并且可以用于文件和目录。
- en: 'Sometimes, the target directory might not yet exist and, in these cases, it
    is supposed to be created with the script. There is a function for creating directories,
    called `mkdir()`, which accepts the following arguments: the directory path to
    create, the mode (which is `0777`, by default, meaning full permissions for any
    user), a recursive directory creation instruction, and the context resource.'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，目标目录可能尚未存在，在这些情况下，应该由脚本创建。有一个用于创建目录的函数，称为`mkdir()`，它接受以下参数：要创建的目录路径、模式（默认为`0777`，意味着任何用户都有完全权限）、递归创建目录指令和上下文资源。
- en: 'Exercise 7.10: Creating Directories and Moving Files to the Archive'
  id: totrans-245
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习7.10：创建目录并将文件移动到存档
- en: 'In this exercise, you will move a file to your local server, using PHP. Let''s
    say you are assigned the task of creating a script that will move generated log
    files to an "archive location," on a daily basis:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，你将使用PHP将文件移动到本地服务器。假设你被分配了一个创建脚本的任务，该脚本将每天将生成的日志文件移动到“存档位置”：
- en: Create an empty file called `to-move.txt`. This is the file we will move using
    PHP, considering it to be the generated log file.
  id: totrans-247
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`to-move.txt`的空文件。这是我们使用PHP移动的文件，将其视为生成的日志文件。
- en: 'Create a file called `move.php` and insert the following content. First, we
    define the file path to move and the target directory that the file should be
    moved to. Then, we check whether the file path exists and is a regular file and,
    in the event of failure, the script will print an error message and will stop
    the execution:'
  id: totrans-248
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`move.php`的文件，并插入以下内容。首先，我们定义要移动的文件路径和文件应移动到的目标目录。然后，我们检查文件路径是否存在并且是一个常规文件，如果失败，脚本将打印错误消息并停止执行：
- en: '[PRE42]'
  id: totrans-249
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Then, we check whether the target directory exists and is a directory, and
    if there''s no such directory, then we will try to create one. A message is printed
    in this regard, letting you know that the directory is being created. Then, the
    `mkdir()` function is used to create the target directory, in a recursive fashion
    (setting the third parameter to `true` will instruct the script to create any
    parent directory if it''s missing). If the action fails, then an error message
    is printed and the script stops the execution. Otherwise, the successful message,
    `Done`, is printed:'
  id: totrans-250
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们检查目标目录是否存在并且是一个目录，如果没有这样的目录，那么我们将尝试创建一个。关于此的消息将被打印出来，让你知道目录正在被创建。然后，使用`mkdir()`函数以递归方式创建目标目录（将第三个参数设置为`true`将指示脚本在缺少的情况下创建任何父目录）。如果操作失败，则打印错误消息并停止脚本执行。否则，将打印成功的消息“完成”：
- en: '[PRE43]'
  id: totrans-251
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Next, we will define the target file path, and this will comprise the target
    directory and the file base name. Then, the `move` process is effected by using
    the `rename()` function. A message is printed for both a successful or a failed
    operation:'
  id: totrans-252
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将定义目标文件路径，它将包括目标目录和文件基本名称。然后，使用`rename()`函数执行移动过程。对于成功或失败的操作都会打印一条消息：
- en: '[PRE44]'
  id: totrans-253
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Note
  id: totrans-254
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意
- en: 'The complete script file can be referred at : [https://packt.live/35wmDmK](https://packt.live/35wmDmK).'
  id: totrans-255
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 完整的脚本文件可以参考：[https://packt.live/35wmDmK](https://packt.live/35wmDmK)。
- en: 'Run the script in the command-line interface, with `php move.php`. The output,
    during the first run, should look like this:'
  id: totrans-256
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在命令行界面中运行脚本，使用`php move.php`。第一次运行时的输出应该如下所示：
- en: '[PRE45]'
  id: totrans-257
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Checking the file tree, you will notice that the file has indeed moved:'
  id: totrans-258
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 检查文件树，你会发现文件确实已经移动了：
- en: '![Figure 7.10: Screenshot of the file tree'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: '![图7.10：文件树截图'
- en: '](img/C14196_07_10.jpg)'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: '![img/C14196_07_10.jpg](img/C14196_07_10.jpg)'
- en: 'Figure 7.10: Screenshot of the file tree'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.10：文件树截图
- en: 'In addition to this, when running the script for the second time, you should
    get the following output:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，当第二次运行脚本时，你应该得到以下输出：
- en: '[PRE46]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: In this exercise, you succeeded in moving a file from one location to another,
    using PHP with its built-in filesystem functions, validating the input as well,
    so as to make sure that you were not attempting to move a non-existent file.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，你成功使用PHP及其内置的文件系统函数将文件从一个位置移动到另一个位置，同时验证输入，以确保你没有尝试移动一个不存在的文件。
- en: Copying Files Using PHP
  id: totrans-265
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用PHP复制文件
- en: Copying files is yet another straightforward task for which PHP offers support.
    The `copy()` function accepts two required arguments – the source file path and
    the destination path, and an optional one – the stream context. Using the `copy()`
    function is very useful in scenarios such as choosing your profile picture from
    a list of available pictures on the server (in this case, you want to leave the
    picture list intact, so you will only want to create a copy of the selected picture),
    or restoring files copied from a backup (again, you want to leave the original
    files intact, so `copy()` is again appropriate in this case).
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 复制文件是PHP提供的另一个简单任务的支持。`copy()`函数接受两个必需参数——源文件路径和目标路径，以及一个可选参数——流上下文。使用`copy()`函数在以下场景中非常有用，例如从服务器上可用的图片列表中选择你的个人资料图片（在这种情况下，你希望保持图片列表完整，因此你只希望创建所选图片的副本），或者恢复从备份中复制的文件（再次，你希望保持原始文件完整，因此在这种情况下`copy()`也是合适的）。
- en: Note
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Using the `copy()` function, if the destination file exists already, it will
    be overwritten.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`copy()`函数，如果目标文件已存在，它将被覆盖。
- en: 'Exercise 7.11: Copying Files'
  id: totrans-269
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习 7.11：复制文件
- en: 'You are required to write a script that will copy specific files to a backup
    location. The copied files should have the `.bak` extension prepended:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要编写一个脚本，将特定的文件复制到备份位置。复制的文件应该具有 `.bak` 扩展名前缀：
- en: Create an empty file called `to-copy.txt` inside the `sample` directory.
  id: totrans-271
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `sample` 目录内创建一个名为 `to-copy.txt` 的空文件。
- en: 'Create the `copy.php` file with the following content:'
  id: totrans-272
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个包含以下内容的 `copy.php` 文件：
- en: '[PRE47]'
  id: totrans-273
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE47]'
- en: First, we define the source and target file paths, and then check whether the
    source file exists. If the source file does not exist, an error message is printed
    and the execution of the script stops.
  id: totrans-274
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 首先，我们定义源文件路径和目标文件路径，然后检查源文件是否存在。如果源文件不存在，会打印出错误消息，并且脚本执行停止。
- en: 'Next, we try to copy the file, using the `copy()` function. An appropriate
    message is printed, based on the `copy()` function response:'
  id: totrans-275
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们尝试使用 `copy()` 函数复制文件。根据 `copy()` 函数的响应，会打印出适当的消息：
- en: '[PRE48]'
  id: totrans-276
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE48]'
- en: Note
  id: totrans-277
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意
- en: The complete script can be referred at [https://packt.live/2plXtXu](https://packt.live/2plXtXu).
  id: totrans-278
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 完整的脚本可以参考 [https://packt.live/2plXtXu](https://packt.live/2plXtXu)。
- en: 'Run the file in the command-line interface, with `php copy.php`, and check
    the results; in the event of a successful `copy` operation, you should get the
    following output:![Figure 7.11: Copying file successfully'
  id: totrans-279
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在命令行界面中运行文件，使用 `php copy.php` 并检查结果；在成功执行 `copy` 操作的情况下，你应该得到以下输出：![图 7.11：成功复制文件
- en: '](img/C14196_07_11.jpg)'
  id: totrans-280
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/C14196_07_11.jpg)'
- en: 'Figure 7.11: Copying file successfully'
  id: totrans-281
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 7.11：成功复制文件
- en: 'Change `$sourceFilePath` in the script to a non-existent file path (for example,
    `wrong-file-path.txt`) and run the script again. The output will be as follows:'
  id: totrans-282
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将脚本中的 `$sourceFilePath` 改为一个不存在的文件路径（例如，`wrong-file-path.txt`），然后再次运行脚本。输出将如下所示：
- en: '![Figure 7.12: Trying to copy a nonexistent file'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 7.12：尝试复制一个不存在的文件'
- en: '](img/C14196_07_12.jpg)'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/C14196_07_12.jpg)'
- en: 'Figure 7.12: Trying to copy a nonexistent file'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.12：尝试复制一个不存在的文件
- en: As you can see, copying files with PHP turns out to be a pretty straightforward
    process.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，使用 PHP 复制文件是一个相当直接的过程。
- en: In this exercise, you learned how to deal with files using PHP, starting with
    file create and write, and continuing with append, rewrite and delete, and copy
    and move, and then reading large files line by line and sending files to download.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，你学习了如何使用 PHP 处理文件，从文件创建和写入开始，继续到追加、重写和删除，然后是复制和移动，最后是逐行读取大文件并将文件发送下载。
- en: Databases
  id: totrans-288
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 数据库
- en: In the previous section, we saw how we can use PHP to manipulate and store data
    in files. But when an application relies on structured data, it gets pretty complicated
    using the filesystem, especially when the application grows, and so does your
    data. Imagine a social media website, with tons of relationships between the data,
    including post comments, interests, friendships, groups, and a plethora of other
    linked data. Also, as your application grows, scalability is an important factor.
    This is when you want to use a database, to be able to query the data in different
    ways – ordered, filtered, partial data, combined data (joined), and, at the same
    time, in a very performant way. A **database management system** (**DBMS**) is
    used for performing operations on database data (create, read, update, and delete).
    Also, since different types of data are related to other data types in a database,
    you may want accuracy, consistency, and reliability for your data storage. In
    this case, you would prefer a relational DBMS.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节中，我们看到了如何使用 PHP 操作和存储文件中的数据。但是当应用程序依赖于结构化数据时，使用文件系统会变得相当复杂，尤其是在应用程序增长，数据也随之增长的情况下。想象一下一个社交媒体网站，其中包含大量的数据关系，包括帖子评论、兴趣、友谊、群组和大量的其他关联数据。此外，随着应用程序的增长，可扩展性成为一个重要的因素。这就是你想要使用数据库的时候，以便能够以不同的方式查询数据——排序、过滤、部分数据、组合数据（连接），并且同时以非常高效的方式进行。**数据库管理系统**（**DBMS**）用于对数据库数据进行操作（创建、读取、更新和删除）。此外，由于数据库中的不同类型的数据与其他数据类型相关联，你可能希望你的数据存储具有准确性、一致性和可靠性。在这种情况下，你更倾向于使用关系型DBMS。
- en: MySQL is a **Relational Database Management System** (**RDBMS**) and is the
    most commonly used with PHP. It is very fast, reliable, easy to use (it uses **Structured
    Query Language** (**SQL**) queries), and it's free to use. It suits a wide range
    of applications, from small to large. It's very powerful, fast, secure, and scalable.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: MySQL 是一个**关系型数据库管理系统**（**RDBMS**），并且与 PHP 最常用。它非常快，可靠，易于使用（它使用**结构化查询语言**（**SQL**）查询），并且免费使用。它适用于从小到大的各种应用程序。它非常强大，快速，安全且可扩展。
- en: A MySQL database stores data in tables, just like any other relational database.
    A table is composed of related data, organized in rows (records) and columns (record
    fields).
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: MySQL数据库以表格形式存储数据，就像任何其他关系型数据库一样。一个表由相关的数据组成，这些数据按行（记录）和列（记录字段）组织。
- en: PHP supports a wide variety of databases, such as MySQL, PostgreSQL, SQLite,
    MongoDB, MSSQL, and others, but, in this chapter, we will work with MySQL, as
    it's by far the most widely used database management system with PHP.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: PHP支持多种数据库，如MySQL、PostgreSQL、SQLite、MongoDB、MSSQL等，但在这个章节中，我们将使用MySQL，因为它是目前与PHP配合使用最广泛的数据管理系统。
- en: GUI Clients
  id: totrans-293
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 图形用户界面客户端
- en: Often, graphical user interface (GUI or "desktop applications") clients are
    very useful when it comes to performing miscellaneous operations in a database,
    such as verifying data, altering tables or columns, exporting or importing data,
    and migrating a database.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，图形用户界面（GUI或“桌面应用程序”）客户端在执行数据库中的各种操作时非常有用，例如验证数据、更改表或列、导出或导入数据以及迁移数据库。
- en: 'For MySQL, three clients are recommended:'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 对于MySQL，推荐使用三个客户端：
- en: 'MySQL Workbench: a desktop application; cross-platform; can be downloaded from
    [https://packt.live/32iaZd6](https://packt.live/32iaZd6)'
  id: totrans-296
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: MySQL Workbench：一个桌面应用程序；跨平台；可以从[https://packt.live/32iaZd6](https://packt.live/32iaZd6)下载
- en: 'PhpMyAdmin: a browser application; can be downloaded from [https://packt.live/2McXnu9](https://packt.live/2McXnu9)'
  id: totrans-297
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: PhpMyAdmin：一个浏览器应用程序；可以从[https://packt.live/2McXnu9](https://packt.live/2McXnu9)下载
- en: 'Adminer: a lightweight browser application; can be downloaded from [https://packt.live/35yBTzB](https://packt.live/35yBTzB)'
  id: totrans-298
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Adminer：一个轻量级的浏览器应用程序；可以从[https://packt.live/35yBTzB](https://packt.live/35yBTzB)下载
- en: In addition, for screenshots, I'll use Workbench to test the data in MySQL Server,
    but any of these tools could be used.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，对于截图，我将使用Workbench来测试MySQL服务器中的数据，但可以使用这些工具中的任何一个。
- en: Connecting to MySQL
  id: totrans-300
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 连接到MySQL
- en: To use MySQL Server with PHP, some extensions need to be installed. Usually,
    an extension is a component that exposes an `mysqli` and `PDO` extensions. These
    are very similar in terms of functionality and syntax, and, unless you need a
    specific feature from one of the extensions, choosing an extension to work with
    should not cause any difficulties. Just pick one.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用MySQL服务器与PHP一起工作，需要安装一些扩展。通常，一个扩展是一个组件，它公开了`mysqli`和`PDO`扩展。它们在功能和语法方面非常相似，除非你需要从某个扩展中获取特定功能，否则选择要与之工作的扩展不应造成任何困难。只需选择一个即可。
- en: Since PDO appears to be the most widely used option, we will pick this extension
    for further exercises.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 由于PDO似乎是使用最广泛的选择，我们将选择这个扩展进行进一步的练习。
- en: '**PHP Data Objects** (**PDO**) is a lightweight and lean interface for accessing
    databases with PHP.'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: '**PHP数据对象**（**PDO**）是一个轻量级且紧凑的接口，用于通过PHP访问数据库。'
- en: To continue, make sure you have MySQL installed, as described in the preface.
    Furthermore, consider the MySQL server listening on `127.0.0.1`, port `3306`,
    with the username set to `php-user` and the password set as `php-pass`.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 要继续，请确保您已按照前言中描述的安装MySQL。此外，请考虑MySQL服务器正在监听`127.0.0.1`，端口`3306`，用户名设置为`php-user`，密码设置为`php-pass`。
- en: Note
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: For Windows OS, the database username php-user in code snippets for chapter
    7 will need to be replaced with php_user. This is because the Windows installer
    for MySQL does not allow hyphens in usernames.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 对于Windows操作系统，第7章代码片段中的数据库用户名php-user需要替换为php_user。这是因为MySQL的Windows安装程序不允许用户名中包含连字符。
- en: Make sure you have the `PDO` extension and the `pdo_mysql` driver installed
    to facilitate the establishment of connections and send queries to the MySQL Server.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 确保您已安装`PDO`扩展和`pdo_mysql`驱动程序，以便建立连接并向MySQL服务器发送查询。
- en: Note
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: The `pdo_mysql` driver is an extension that provides an interface to the aforementioned
    PDO extension. This driver is a component that makes communication with the MySQL
    Server possible, translating instructions between the two parties.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: '`pdo_mysql`驱动程序是一个提供上述PDO扩展接口的扩展。此驱动程序是一个组件，它使得与MySQL服务器通信成为可能，在双方之间翻译指令。'
- en: 'Checking for an enabled PHP extension in the Terminal is possible by running
    `php -m` to list all installed and enabled extensions or `php -m | grep -i pdo`
    to list only those entries that match the `pdo` string fragment. The latter should
    output these two entries:'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 在终端中通过运行`php -m`来列出所有已安装和启用的扩展，或通过`php -m | grep -i pdo`来列出仅匹配`pdo`字符串片段的条目。后者应输出以下两个条目：
- en: '![](img/C14196_07_13.jpg)'
  id: totrans-311
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/C14196_07_13.jpg)'
- en: 'Figure 7.13: Checking for the enabled extensions'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.13：检查已启用的扩展
- en: Note
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: '`grep` is a Unix function that searches for text in files or in string input,
    and returns the matching lines in output by default. The `|` (pipe) token is used
    to forward the previous command''s output (`php -m`) to the next command, as input.'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: '`grep` 是一个Unix函数，用于在文件或字符串输入中搜索文本，并默认通过输出返回匹配的行。`|`（管道）标记用于将前一个命令的输出（`php -m`）作为输入传递给下一个命令。'
- en: In order to proceed further, let's create a new directory where we will write
    the database-related exercises (for example, `database`).
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 为了进一步进行，让我们创建一个新的目录，我们将在此目录中编写数据库相关的练习（例如，`database`）。
- en: Connecting to MySQL
  id: totrans-316
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 连接到MySQL
- en: Connections to MySQL are initiated by instantiating the PDO object. This accepts
    the database source (DSN) as the first argument, and optionally, the username,
    password, and PDO options, if required.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: MySQL连接是通过实例化PDO对象来发起的。它接受数据库源（DSN）作为第一个参数，可选地，如果需要，还包括用户名、密码和PDO选项。
- en: 'The syntax is as follows:'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 语法如下：
- en: '[PRE49]'
  id: totrans-319
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Parameters:'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 参数：
- en: 'Data Source Name: `mysql:` followed by a list of key-value pairs separated
    by semicolons; these elements will be listed here.'
  id: totrans-321
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据源名称：`mysql:` 后跟由分号分隔的键值对列表；这些元素将在此列出。
- en: 'username: the username used to connect to the database.'
  id: totrans-322
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: username：用于连接数据库的用户名。
- en: 'password: the password used to authenticate the username.'
  id: totrans-323
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: password：用于验证用户名的密码。
- en: 'options: an associative array of MySQL (driver-specific) connection options.'
  id: totrans-324
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'options: MySQL（特定驱动程序）连接选项的关联数组。'
- en: 'The DSN allows the following elements:'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: DSN允许以下元素：
- en: 'host: the hostname where the database is located.'
  id: totrans-326
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: host：数据库所在的主机名。
- en: 'port: the database server listens to this port number.'
  id: totrans-327
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: port：数据库服务器监听此端口号。
- en: 'dbname: the name of the database.'
  id: totrans-328
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: dbname：数据库名称。
- en: 'charset: the character set for the connection (the data will be transferred
    using this character set).'
  id: totrans-329
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: charset：连接的字符集（数据将使用此字符集传输）。
- en: 'unix_socket: The MySQL Unix socket; to be used as an alternative to the host
    and port connection type.'
  id: totrans-330
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: unix_socket：MySQL Unix套接字；用作主机和端口连接类型的替代。
- en: By way of good practice, it is recommended to set the connection character set
    to `utf8mb4`; that will save you from further difficulties if you have to store
    and fetch UTF-8 characters using this connection (and you will have to, at some
    point).
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 作为良好的实践，建议将连接字符集设置为 `utf8mb4`；这样，如果你必须使用此连接存储和检索UTF-8字符，你将避免进一步的困难（你最终必须这样做）。
- en: One of the methods of the `PDO` class is `getAttribute()`, which returns a database
    connection attribute, such as server information and the connection status. The
    `PDO::getAttribute()` method requires and accepts only one parameter, the integer
    type; that is, one of the `PDO::ATTR_*` constants. For a complete list of PDO
    attributes and other constants, visit the official documentation page at [https://www.php.net/manual/en/pdo.constants.php](https://www.php.net/manual/en/pdo.constants.php).
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: '`PDO` 类的一个方法是 `getAttribute()`，它返回数据库连接属性，例如服务器信息和连接状态。`PDO::getAttribute()`
    方法需要并接受一个整数类型的参数；即 `PDO::ATTR_*` 常量之一。有关PDO属性和其他常量的完整列表，请访问官方文档页面 [https://www.php.net/manual/en/pdo.constants.php](https://www.php.net/manual/en/pdo.constants.php)。'
- en: 'Exercise 7.12: Connecting to MySQL'
  id: totrans-333
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习7.12：连接到MySQL
- en: In this exercise, you will connect to a MySQL server using PDO.
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，你将使用PDO连接到MySQL服务器。
- en: 'Create a file called `connect.php` and add the following content. In our script,
    we first define the DSN for our MySQL database, pointing the host to `127.0.0.1`
    and the port to `3306`:'
  id: totrans-335
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `connect.php` 的文件，并添加以下内容。在我们的脚本中，我们首先定义MySQL数据库的DSN，将主机指向 `127.0.0.1`，端口指向
    `3306`：
- en: '[PRE50]'
  id: totrans-336
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Next, we set the PDO options, under the `$options` variable, where we specify
    the fetch mode, to have all the records fetched as an associative array by default.
    We would also want to set the error mode to `Exceptions`, to make it easier to
    handle query errors, but for now, we will make use of the `PDO::errorCode()` and
    `PDO::errorInfo()` methods:'
  id: totrans-337
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们设置PDO选项，在 `$options` 变量下，我们指定获取模式，默认将所有记录作为关联数组获取。我们还想将错误模式设置为 `Exceptions`，以便更容易处理查询错误，但到目前为止，我们将使用
    `PDO::errorCode()` 和 `PDO::errorInfo()` 方法：
- en: '[PRE51]'
  id: totrans-338
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE51]'
- en: Note
  id: totrans-339
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意
- en: We will learn about exceptions and error handling in the next chapter.
  id: totrans-340
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们将在下一章学习异常和错误处理。
- en: 'In the next line, we invoke the `PDO` object, thereby creating a connection
    to the database, using the DSN defined previously, the username, password, and
    the aforementioned `PDO` option. If the connection is unsuccessful, an exception
    will be thrown (of the `PDOException` type) and the execution of the script will
    stop:'
  id: totrans-341
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在下一行，我们调用`PDO`对象，从而使用之前定义的DSN、用户名、密码和上述`PDO`选项建立到数据库的连接。如果连接失败，将抛出异常（`PDOException`类型）并停止脚本的执行：
- en: '[PRE52]'
  id: totrans-342
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'In the final step, we want to print the connection info, using the `PDO::getAttribute()`
    method:'
  id: totrans-343
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在最后一步，我们希望打印连接信息，使用`PDO::getAttribute()`方法：
- en: '[PRE53]'
  id: totrans-344
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Run the file in the command-line interface with `php connect.php`. When the
    connection is successful, the output will look like this:'
  id: totrans-345
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在命令行界面中运行文件`php connect.php`。当连接成功时，输出将如下所示：
- en: '[PRE54]'
  id: totrans-346
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'In the event of a connection failure, the output will look like this:'
  id: totrans-347
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在连接失败的情况下，输出将如下所示：
- en: '[PRE55]'
  id: totrans-348
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE55]'
- en: In the event of a connection failure, it would be better to treat the error
    and fall back gracefully to a nice-looking error page, providing a user-friendly
    error message. In this case, though, we will leave the script as it is now because
    PHP exceptions will be covered in the next chapter.
  id: totrans-349
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在连接失败的情况下，最好处理错误并以优雅的方式回退到一个看起来不错的错误页面，提供友好的错误信息。然而，在这种情况下，我们将保持脚本现状，因为PHP异常将在下一章中介绍。
- en: Here, you made a connection to MySQL, with a username and password, using PDO,
    and you set some options as well, for the `PDO` object. You also printed the server
    version and connection status, from the PDO connection attributes.
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，你使用PDO和用户名、密码连接到MySQL，并且为`PDO`对象设置了一些选项。你还从PDO连接属性中打印了服务器版本和连接状态。
- en: Creating a Database
  id: totrans-351
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建数据库
- en: Now that we have learned how to establish a connection with a MySQL Server,
    let's move forward and see how we can create a database.
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经学习了如何与MySQL服务器建立连接，让我们继续看看如何创建数据库。
- en: To do this, we will have to run SQL queries; this is where we get to use the
    `PDO` methods.
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 要做到这一点，我们不得不运行SQL查询；这就是我们使用`PDO`方法的地方。
- en: 'We will invoke the `PDO::exec()` method to send the SQL queries to MySQL Server.
    It requires and accepts only one parameter: the SQL query string, and returns
    the Boolean `false` in the event of an error, or the number of affected rows in
    the event of success.'
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将调用`PDO::exec()`方法将SQL查询发送到MySQL服务器。它只接受一个参数：SQL查询字符串，在出错时返回布尔`false`，在成功时返回受影响的行数。
- en: 'Warning: Since this function can return a Boolean `false` and also `0` (zero),
    which evaluates to `false`, make sure you use the `===` or `!==` operator when
    testing the result, so as to avoid false positives when checking for errors.'
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 警告：由于此函数可以返回布尔`false`和`0`（零），它们都评估为`false`，所以在测试结果时，请确保使用`===`或`!==`运算符，以避免在检查错误时出现假阳性。
- en: 'In the event of a query failure (`PDO::exec()` returns `false`), we may invoke
    the `PDO::errorInfo()` method to get the error codes and the error message. This
    method returns a numeric array containing the following data:'
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 在查询失败的情况下（`PDO::exec()`返回`false`），我们可以调用`PDO::errorInfo()`方法来获取错误代码和错误信息。此方法返回一个包含以下数据的数字数组：
- en: '![Figure 7.14: Description of the type of data in the array returned by the
    PDO::errorInfo()'
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: '![图7.14：PDO::errorInfo()返回的数组中数据类型的描述](img/Figure_7.14.jpg)'
- en: '](img/C14196_07_14.jpg)'
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片](img/C14196_07_14.jpg)'
- en: 'Figure 7.14: Description of the type of data in the array returned by the PDO::errorInfo()'
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.14：PDO::errorInfo()返回的数组中数据类型的描述
- en: 'The query to run in order to create a new database has the following syntax:'
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 创建新数据库的查询具有以下语法：
- en: '`CREATE SCHEMA db_name`, where `db_name` should be replaced with the name of
    the database you want to create.'
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: '`CREATE SCHEMA db_name`，其中`db_name`应替换为你想要创建的数据库的名称。'
- en: Note
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: The `CREATE SCHEMA` string is an SQL statement. It can be executed in a SQL
    server using any SQL client. The syntax and more information can be found on the
    official documentation page at [https://packt.live/32ewQSK](https://packt.live/32ewQSK).
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: '`CREATE SCHEMA` 是一个SQL语句。它可以在任何SQL客户端中使用SQL服务器执行。语法和更多信息可以在官方文档页面上找到，链接为 [https://packt.live/32ewQSK](https://packt.live/32ewQSK)。'
- en: 'Exercise 7.13: Creating a Database'
  id: totrans-364
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习7.13：创建数据库
- en: 'In this exercise, we will create a database and run queries:'
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们将创建一个数据库并运行查询：
- en: 'Create a file called `connection-no-db.php` and insert the following code:'
  id: totrans-366
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`connection-no-db.php`的文件，并插入以下代码：
- en: '[PRE56]'
  id: totrans-367
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE56]'
- en: This is similar to what we did in the previous exercise, except that instead
    of printing the connection information, we return the `PDO` instance. In this
    file, we do not specify a database name, since we have not yet created one.
  id: totrans-368
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这与我们在上一个练习中做的是类似的，只是我们不是打印连接信息，而是返回 `PDO` 实例。在这个文件中，我们没有指定数据库名，因为我们还没有创建一个。
- en: 'Create a file called `create-schema.php` and insert the following code. First,
    we require the `PDO` instance from the `connection-no-db.php` file we created
    previously:'
  id: totrans-369
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `create-schema.php` 的文件，并插入以下代码。首先，我们从之前创建的 `connection-no-db.php` 文件中需要
    `PDO` 实例：
- en: '[PRE57]'
  id: totrans-370
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'Then, we write our SQL query under the `$sql` variable, which will create a
    database with the name `demo`:'
  id: totrans-371
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 然后，我们在 `$sql` 变量下编写我们的 SQL 查询，这将创建一个名为 `demo` 的数据库：
- en: '[PRE58]'
  id: totrans-372
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'Run the query using the `PDO::exec()` method, and check for successful statement
    execution (the result is not a Boolean `false`). In the event of success, we print
    a simple success message. In the event of an error, we print the error message:'
  id: totrans-373
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `PDO::exec()` 方法运行查询，并检查语句执行是否成功（结果不是布尔值 `false`）。在成功的情况下，我们打印一个简单的成功消息。在出错的情况下，我们打印错误消息：
- en: '[PRE59]'
  id: totrans-374
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'Run the code from the command-line interface with `php create-schema.php`.
    When running the code for the very first time, you will get the following output:![Figure
    7.15: Creating a schema successfully'
  id: totrans-375
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用命令行界面运行代码 `php create-schema.php`。当第一次运行代码时，你会得到以下输出：![图 7.15：成功创建模式
- en: '](img/C14196_07_15.jpg)'
  id: totrans-376
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/C14196_07_15.jpg)'
- en: 'Figure 7.15: Creating a schema successfully'
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.15：成功创建模式
- en: 'Running the code successively, you will get the following error message:'
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: 依次运行代码，你会得到以下错误消息：
- en: '![Figure 7.16: Error in creating the schema'
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 7.16：创建模式错误'
- en: '](img/C14196_07_16.jpg)'
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/C14196_07_16.jpg)'
- en: 'Figure 7.16: Error in creating the schema'
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.16：创建模式错误
- en: In this exercise, you learned how we can create a database and how to test for
    the successful execution of the SQL statement, `CREATE SCHEMA`.
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，你学习了我们可以如何创建数据库以及如何测试 SQL 语句 `CREATE SCHEMA` 的成功执行。
- en: Creating a Table
  id: totrans-383
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建表
- en: Let's now see how we can create a table that will actually hold the data in
    an organized way. We will use the `CREATE TABLE` SQL statement to achieve this.
    The syntax of this statement is more complex and also involves table column definitions.
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来看看我们如何创建一个将数据以有组织的方式存储的表。我们将使用 `CREATE TABLE` SQL 语句来实现这一点。这个语句的语法更复杂，还涉及到表列定义。
- en: 'Standard `CREATE TABLE` syntax is as follows:'
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: 标准的 `CREATE TABLE` 语法如下：
- en: '[PRE60]'
  id: totrans-386
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'The parameters are as follows:'
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: 参数如下：
- en: '`tbl_name`: The table name to be created.'
  id: totrans-388
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`tbl_name`：要创建的表名。'
- en: '`col_name`: The column name.'
  id: totrans-389
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`col_name`：列名。'
- en: '`data_type`: The type of data the column holds, such as date, timestamp, integer,
    string, and JSON. More information can be found at [https://packt.live/32CWosP](https://packt.live/32CWosP).'
  id: totrans-390
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`data_type`：列持有的数据类型，如日期、时间戳、整数、字符串和 JSON。更多信息可以在 [https://packt.live/32CWosP](https://packt.live/32CWosP)
    找到。'
- en: '`default_value`: The default value when the `insert` statement provides no
    data for this row column.'
  id: totrans-391
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`default_value`：当 `insert` 语句没有为该行列提供数据时的默认值。'
- en: 'A sample `CREATE TABLE` query can be as follows:'
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: 一个示例 `CREATE TABLE` 查询可以如下所示：
- en: '[PRE61]'
  id: totrans-393
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'In this statement, we point to the table name – `users`, with three columns,
    as follows:'
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个语句中，我们指向表名 – `users`，有三个列，如下所示：
- en: '`id`: An integer type; not null; a primary key with auto-incrementing; these
    constraints tell MySQL that the column is a primary key, meaning that it is unique
    in the table and will be used to identify unique records in the table. The `AUTO_INCREMENT`
    keyword tells MySQL that we want this value to be set automatically with an "auto-increment"
    value, which is the next higher integer after the last inserted record ID, when
    we do not specify it in our `INSERT` statements. This is helpful because we can
    execute `INSERT` statements without knowing which should be the next ID value.'
  id: totrans-395
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`id`：整数类型；不为空；自增的主键；这些约束告诉 MySQL，该列是主键，意味着它在表中是唯一的，并将用于识别表中的唯一记录。`AUTO_INCREMENT`
    关键字告诉 MySQL，我们希望这个值自动设置为“自增”值，即在我们不指定它时，是最后一条插入记录 ID 的下一个更高整数。这很有用，因为我们可以在不知道下一个
    ID 值的情况下执行 `INSERT` 语句。'
- en: '`email`: A variable-length character type with a maximum length of 254; not
    null; and unique among the records. In respect to this rule, when inserting another
    record with the same "`email`" value, the statement will be rejected by MySQL
    Server and an error will be returned.'
  id: totrans-396
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`email`: 一种长度可变字符类型，最大长度为254；不可为空；且在记录中是唯一的。关于此规则，当插入具有相同"`email`"值的另一条记录时，MySQL服务器将拒绝该语句，并返回错误。'
- en: '`signup_time`: A datetime type; defaulting to the current time; not null. Not
    specifying this value in the `insert` query will result in the current datetime
    value being set by MySQL Server.'
  id: totrans-397
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`signup_time`: 日期时间类型；默认为当前时间；不可为空。在`insert`查询中未指定此值时，MySQL服务器将设置当前日期时间值。'
- en: Warning
  id: totrans-398
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 警告
- en: Be aware that the "current datetime" will be the value set using the MySQL Server
    time zone offset, which may differ from the application server. For example, when
    you deploy your application on a server from a data center that is located in
    a different time zone to yours, it is possible that the system time zone of the
    remote server is set to the local time zone offset. You may want to make sure
    that your server's settings do not apply time offset – using the UTC time zone,
    or you may want to use a timestamp value instead of a human-readable date.
  id: totrans-399
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意，“当前日期时间”将是使用MySQL服务器时区偏移设置的值，这可能与应用程序服务器不同。例如，当您将应用程序部署到位于不同时区的数据中心的服务器上时，远程服务器的系统时区可能设置为本地时区偏移。您可能想确保您的服务器设置不应用时区偏移——使用UTC时区，或者您可能想使用时间戳值而不是可读日期。
- en: You can find the full syntax and more information at [https://packt.live/2MAGloG](https://packt.live/2MAGloG).
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在[https://packt.live/2MAGloG](https://packt.live/2MAGloG)找到完整的语法和更多信息。
- en: 'Exercise 7.14: Creating the Table'
  id: totrans-401
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习7.14：创建表
- en: 'In this exercise, we will learn how to select a database with PDO, and how
    to create a table using the `PDO` instance:'
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们将学习如何使用PDO选择数据库，以及如何使用`PDO`实例创建表：
- en: 'Create a file called `create-table.php` and insert the following code. What
    we do, after getting the `PDO` instance, is to define the `CREATE TABLE` statement:'
  id: totrans-403
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`create-table.php`的文件，并插入以下代码。在获取`PDO`实例后，我们定义`CREATE TABLE`语句：
- en: '[PRE62]'
  id: totrans-404
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'After executing the statement, in the event of failure, the error message will
    be printed and execution or the script will stop. Otherwise, a success message
    will be printed to output:'
  id: totrans-405
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 执行语句后，如果失败，将打印错误消息，并停止执行或脚本。否则，将打印成功消息到输出：
- en: '[PRE63]'
  id: totrans-406
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'Run the script in the command-line interface with `php create-table.php`. Expect
    the following error output:![Figure 7.17: Error in creating the table'
  id: totrans-407
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在命令行界面中运行`php create-table.php`脚本。预期以下错误输出：![图7.17：创建表错误
- en: '](img/C14196_07_17.jpg)'
  id: totrans-408
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图片](img/C14196_07_17.jpg)'
- en: 'Figure 7.17: Error in creating the table'
  id: totrans-409
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图7.17：创建表错误
- en: We get an error message, indicating that no database is selected. What we understand
    from this statement is that a MySQL server can store several databases, and, when
    executing a statement, we should indicate the database we want to run it into.
    To achieve this, we should either include the database name inside the SQL statements
    (for example, `CREATE TABLE demo.users` ...) or specify the database name inside
    DSN, before creating the connection to MySQL Server.
  id: totrans-410
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们得到一个错误消息，指示未选择数据库。从该语句中我们了解到，MySQL服务器可以存储多个数据库，并且在执行语句时，我们应该指明我们想要在其中运行的数据库。为了实现这一点，我们可以在SQL语句中包含数据库名（例如，`CREATE
    TABLE demo.users` ...）或在与MySQL服务器建立连接之前在DSN中指定数据库名。
- en: 'Copy the `connection-no-db.php` file to `connection.php` and add the database
    name to DSN, inside the `connection.php` file. Replace the `$dsn` variable with
    the following value:'
  id: totrans-411
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`connection-no-db.php`文件复制到`connection.php`，并在`connection.php`文件中将数据库名添加到DSN中。将`$dsn`变量替换为以下值：
- en: '[PRE64]'
  id: totrans-412
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE64]'
- en: Note
  id: totrans-413
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意
- en: We will require this `connection.php` file further, in all exercises, to reuse
    the code instead of typing this block of code in every file where we use the database
    connection.
  id: totrans-414
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在所有练习中，我们将需要此`connection.php`文件，以重用代码，而不是在每次使用数据库连接的文件中键入此代码块。
- en: 'Require the `connection.php` file in the `create-table.php` script, instead
    of `connection-no-db.php`:'
  id: totrans-415
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`create-table.php`脚本中引入`connection.php`文件，而不是`connection-no-db.php`：
- en: '[PRE65]'
  id: totrans-416
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'Let''s run our script once more: `php create-table.php`. Expect the following
    output:'
  id: totrans-417
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们再次运行我们的脚本：`php create-table.php`。预期以下输出：
- en: '![Figure 7.18: Creating tables successfully'
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
  zh: '![图7.18：成功创建表'
- en: '](img/C14196_07_18.jpg)'
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片](img/C14196_07_18.jpg)'
- en: 'Figure 7.18: Creating tables successfully'
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.18：成功创建表
- en: Great! You successfully created the first table in the `demo` database.
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
  zh: 太好了！您已成功在`demo`数据库中创建了第一个表。
- en: In this exercise, you learned how to select a database at connection time, and
    how to create a table in a SQL database. Notice that the queries begin with an
    action (`CREATE`) followed by the object type (schema/database or table), followed
    by the object definition where required. Also, you probably noticed that the column
    names are followed by the date type declaration (integer, string, date, and so
    on) and then by additional constraints (`NOT NULL`, `PRIMARY KEY`, `UNIQUE`, and
    so on).
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，您学习了如何在连接时选择数据库，以及如何在SQL数据库中创建表。请注意，查询以一个动作（`CREATE`）开始，然后是对象类型（模式/数据库或表），然后是所需的对象定义。您可能还注意到，列名称后面跟着数据类型声明（整数、字符串、日期等），然后是额外的约束（`NOT
    NULL`、`PRIMARY KEY`、`UNIQUE`等）。
- en: As you can see, SQL statements are pretty descriptive and easy to learn and
    remember. So, let's advance with more exciting examples!
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，SQL语句非常描述性，易于学习和记忆。所以，让我们通过更多令人兴奋的例子来继续前进！
- en: Inserting Data into a MySQL Database Table
  id: totrans-424
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 向MySQL数据库表插入数据
- en: Since we already know how to create a table in a MySQL database, let's add some
    data to it.
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们已经知道如何在MySQL数据库中创建表，让我们向其中添加一些数据。
- en: Before inserting data into a table, we must craft the script in such a way that
    the data to be inserted will match the table's column definition. This means we
    will not be able to store strings in a column defined with an integer data type.
    In such cases, MySQL Server will reject the query and will respond with an error.
    Also bear in mind, since most of the data will come from user input, that you
    should always validate it before sending it to a database server, and, at the
    same time, escape it properly, so as to avoid another security issue, called SQL
    injection, covered later in the chapter.
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
  zh: 在将数据插入到表中之前，我们必须以这种方式编写脚本，以便要插入的数据将与表的列定义相匹配。这意味着我们无法将字符串存储在定义为整数数据类型的列中。在这种情况下，MySQL服务器将拒绝查询并返回错误。同时，请注意，由于大部分数据将来自用户输入，因此在将其发送到数据库服务器之前，您应该始终对其进行验证，并且同时正确地转义它，以避免另一个称为SQL注入的安全问题，该问题将在本章后面介绍。
- en: 'Standard `INSERT` statement syntax is as follows:'
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
  zh: 标准的`INSERT`语句语法如下：
- en: '[PRE66]'
  id: totrans-428
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'Where `value_list` is:'
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
  zh: 当前的`value_list`是：
- en: '[PRE67]'
  id: totrans-430
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: Note
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: The number of values specified in `value_list` should match the `col_name` count.
    The complete syntax of the `INSERT` statement can be found on the official documentation
    page at [https://packt.live/32fXkmP](https://packt.live/32fXkmP).
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
  zh: 在`value_list`中指定的值数量应与`col_name`计数匹配。`INSERT`语句的完整语法可以在官方文档页面[https://packt.live/32fXkmP](https://packt.live/32fXkmP)找到。
- en: 'An example `INSERT` query may appear as follows:'
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
  zh: 一个示例`INSERT`查询可能如下所示：
- en: '[PRE68]'
  id: totrans-434
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: In this case, two rows will be inserted in the `employees` table, setting the
    values from `VALUES` to the corresponding position column from the column list;
    for example, `john.smith@mail.com` is assigned to the `email` column, and the
    `John` value is assigned to the `first_name` column.
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
  zh: 在此情况下，将在`employees`表中插入两行，将`VALUES`中的值设置到列列表中相应的位置列；例如，`john.smith@mail.com`被分配到`email`列，而`John`值被分配到`first_name`列。
- en: 'Exercise 7.15: Inserting Data into a Table'
  id: totrans-436
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习7.15：向表中插入数据
- en: 'In this exercise, we will become familiar with the `INSERT` statement, learning
    how we can add data to a table:'
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们将熟悉`INSERT`语句，了解我们如何向表中添加数据：
- en: 'Create a file called `insert.php`. After getting the `PDO` instance, we store
    the `INSERT` statement under the `$insertStmt` variable. This statement inserts
    the value `john.smith@mail.com` into the `email` column of the `users` table.
    We did not specify the ID value; therefore, it must be set automatically with
    the `auto_increment` value, which, for the first entry, would be `1`. We are also
    missing the `signup_time` column, which, by default, will set the time when the
    record was added. Add the following code to the `insert.php` file:'
  id: totrans-438
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`insert.php`的文件。在获取`PDO`实例后，我们将`INSERT`语句存储在`$insertStmt`变量下。此语句将值`john.smith@mail.com`插入到`users`表的`email`列中。我们没有指定ID值；因此，它必须使用`auto_increment`值自动设置，对于第一条记录，这将是一个`1`。我们还缺少`signup_time`列，它默认将设置记录添加时的时间。将以下代码添加到`insert.php`文件中：
- en: '[PRE69]'
  id: totrans-439
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'If the statement execution fails, the script will print the error message and
    will not continue further; otherwise, the success message will be printed, including
    the ID of the row that was just inserted, using the `PDO::lastInsertId()` method:'
  id: totrans-440
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果语句执行失败，脚本将打印错误消息并不会继续执行；否则，将打印成功消息，包括刚刚插入的行的ID，使用`PDO::lastInsertId()`方法：
- en: '[PRE70]'
  id: totrans-441
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'Run the script with `php insert.php`. The first output will be as follows:![Figure
    7.19: Inserting a record into the table'
  id: totrans-442
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`php insert.php`运行脚本。第一个输出将如下所示：![图7.19：向表中插入记录
- en: '](img/C14196_07_19.jpg)'
  id: totrans-443
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图片](img/C14196_07_19.jpg)'
- en: 'Figure 7.19: Inserting a record into the table'
  id: totrans-444
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图7.19：向表中插入记录
- en: 'Run the script once more. Now, you should expect the following response in
    the output:![Figure 7.20: Duplicate entry error'
  id: totrans-445
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 再次运行脚本。现在，您应该期望在输出中看到以下响应：![图7.20：重复条目错误
- en: '](img/C14196_07_20.jpg)'
  id: totrans-446
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图片](img/C14196_07_20.jpg)'
- en: 'Figure 7.20: Duplicate entry error'
  id: totrans-447
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图7.20：重复条目错误
- en: This proves that the previous script execution succeeded, and that the `UNIQUE`
    constraint in the email column is working as expected.
  id: totrans-448
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这证明了之前的脚本执行成功，并且电子邮件列中的`UNIQUE`约束按预期工作。
- en: 'Let''s now look at the data in the `users` table, using the Workbench client:'
  id: totrans-449
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在让我们使用Workbench客户端查看`users`表中的数据：
- en: '![Figure 7.21: Checking the data in DB using the Workbench client'
  id: totrans-450
  prefs: []
  type: TYPE_NORMAL
  zh: '![图7.21：使用Workbench客户端检查数据库中的数据'
- en: '](img/C14196_07_21.jpg)'
  id: totrans-451
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片](img/C14196_07_21.jpg)'
- en: 'Figure 7.21: Checking the data in DB using the Workbench client'
  id: totrans-452
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.21：使用Workbench客户端检查数据库中的数据
- en: As expected, we have a single row, with `id = 1`, `john.smith@mail.com` for
    the `email` column, and the signup time set by MySQL Server at the time of the
    row insertion.
  id: totrans-453
  prefs: []
  type: TYPE_NORMAL
  zh: 如预期，我们有一行数据，`id = 1`，`email`列的`john.smith@mail.com`，以及MySQL服务器在行插入时设置的注册时间。
- en: Congratulations on adding in the initial data to a database table! It was pretty
    easy. Now, knowing that we should work with user input, we must ensure that the
    script will run the queries in complete safety, avoiding SQL injection, which
    may lead to data leaks and system compromise.
  id: totrans-454
  prefs: []
  type: TYPE_NORMAL
  zh: 恭喜您已成功将初始数据添加到数据库表中！这很简单。现在，既然我们知道需要处理用户输入，我们必须确保脚本将以完全安全的方式运行查询，避免SQL注入，这可能导致数据泄露和系统被破坏。
- en: SQL Injection
  id: totrans-455
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: SQL注入
- en: So, what is SQL injection anyway? SQL injection is one of the most common vulnerabilities
    in the wild web nowadays. It is a technique used to steal data, gain control of
    users' accounts, or destroy a database, and is performed by sending malicious
    query chunks via HTML form inputs.
  id: totrans-456
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，SQL注入究竟是什么呢？SQL注入是当今野网中最常见的漏洞之一。它是一种用于窃取数据、控制用户账户或破坏数据库的技术，通过通过HTML表单输入发送恶意查询片段来执行。
- en: 'To better understand this, here is a simple example of how you can drop a table
    using the SQL injection technique, given a query that accepts user input without
    sanitizing and/or validating it:'
  id: totrans-457
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更好地理解这一点，这里有一个简单的例子，说明您如何使用SQL注入技术删除表，给定一个接受用户输入但不进行清理和/或验证的查询：
- en: '[PRE71]'
  id: totrans-458
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'When the email input value is `""); DROP TABLE users; /**`, then the query
    will become:'
  id: totrans-459
  prefs: []
  type: TYPE_NORMAL
  zh: 当电子邮件输入值为`""); DROP TABLE users; /**`时，查询将变为：
- en: '[PRE72]'
  id: totrans-460
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: What happens is easy to understand; the `INSERT` statement is executed, adding
    an empty value to the `email` column, and then the query to drop the table is
    executed, making the `users` table vanish, while the `/**)` part is ignored, since
    `/**` marks the beginning of a comment in a SQL query.
  id: totrans-461
  prefs: []
  type: TYPE_NORMAL
  zh: 发生的事情很容易理解；执行了`INSERT`语句，将空值添加到`email`列，然后执行了删除表的查询，使`users`表消失，而`/**)`部分被忽略，因为`/**`在SQL查询中标记了注释的开始。
- en: Prepared Statements
  id: totrans-462
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 预处理语句
- en: In order to prevent SQL injection, we should escape the input data. PDO offers
    an alternative –so-called `prepared statements` (the `PDOStatement` class). These
    statements are templates and look like regular SQL queries, with the difference
    that, instead of values, they contain placeholders, which will be replaced with
    escaped values at execution time. The placeholders' mapping is done using the
    `PDOStatement::bindParam()` method, or by providing the mapping at execution time,
    as an argument of the `PDOStatement::execute()` method.
  id: totrans-463
  prefs: []
  type: TYPE_NORMAL
  zh: 为了防止SQL注入，我们应该转义输入数据。PDO提供了一个替代方案——所谓的`预处理语句`（`PDOStatement`类）。这些语句是模板，看起来像常规的SQL查询，不同之处在于，它们不包含值，而是包含占位符，这些占位符将在执行时被转义后的值替换。占位符的映射是通过`PDOStatement::bindParam()`方法完成的，或者通过在执行时提供映射，作为`PDOStatement::execute()`方法的参数。
- en: 'There are two types of placeholders:'
  id: totrans-464
  prefs: []
  type: TYPE_NORMAL
  zh: 占位符有两种类型：
- en: Positional placeholders, `?`
  id: totrans-465
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 位置占位符，`?`
- en: 'Query example:'
  id: totrans-466
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 查询示例：
- en: '[PRE73]'
  id: totrans-467
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE73]'
- en: Named placeholders, with names prepended with a colon, `:`
  id: totrans-468
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 命名占位符，名称前加冒号，`:`
- en: 'Query example:'
  id: totrans-469
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 查询示例：
- en: '[PRE74]'
  id: totrans-470
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'The use of prepared statements offers major benefits:'
  id: totrans-471
  prefs: []
  type: TYPE_NORMAL
  zh: 使用预处理语句提供了主要的好处：
- en: The parameters of prepared statements should not be quoted, as this is handled
    by PDO automatically, while it will also handle the escaping of values when necessary.
    This means that you can be sure that no SQL injection is possible using prepared
    statements with placeholders.
  id: totrans-472
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 预处理语句的参数不应加引号，因为这由PDO自动处理，同时它也会在必要时处理值的转义。这意味着您可以使用带有占位符的预处理语句确保没有SQL注入。
- en: The query is sent and parsed only once by MySQL Server, meaning that the same
    statement can be executed many times, sending only the placeholders' data. This
    results in faster execution times and lower bandwidth usage.
  id: totrans-473
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 查询只由MySQL服务器发送和解析一次，这意味着相同的语句可以多次执行，只发送占位符的数据。这导致执行时间更快，带宽使用更低。
- en: Note
  id: totrans-474
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 备注
- en: By default, PDO will emulate prepared statements as support for databases that
    don't have this feature and, if you want to benefit from genuine prepared statements
    in MySQL Server, you should set `PDO::ATTR_EMULATE_PREPARES` to `false` in the
    connection options.
  id: totrans-475
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 默认情况下，PDO会模拟预处理语句以支持没有此功能的数据库，如果您想在MySQL服务器上真正地使用预处理语句，您应该在连接选项中将`PDO::ATTR_EMULATE_PREPARES`设置为`false`。
- en: Emulating prepared statements means that the query will not be sent to the server
    and checked when `PDO::prepare()` is invoked. Instead, PDO will escape the bind
    parameters from `PDO::execute()`, and will make the placeholders' replacements
    on its own. Then, the raw SQL query is sent to the database server, meaning that,
    this way, you do not benefit from performance optimizations that the database
    could carry out when using prepared statements that are then executed many times.
  id: totrans-476
  prefs: []
  type: TYPE_NORMAL
  zh: 模拟预处理语句意味着在调用`PDO::prepare()`时，查询不会被发送到服务器进行检查。相反，PDO将在`PDO::execute()`中转义绑定参数，并自行替换占位符。然后，原始SQL查询被发送到数据库服务器，这意味着，这种方式下，您无法从数据库在多次执行预处理语句时可能进行的性能优化中受益。
- en: Using Prepared Statements
  id: totrans-477
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用预处理语句
- en: To obtain a prepared statement, you must invoke the `PDO::prepare()` method,
    providing the statement as a first argument. The output is an instance of the
    `PDOStatement` class (the prepared statement), which is then used to bind parameters'
    values and execute the statement.
  id: totrans-478
  prefs: []
  type: TYPE_NORMAL
  zh: 要获取一个预处理语句，您必须调用`PDO::prepare()`方法，并提供语句作为第一个参数。输出是`PDOStatement`类的实例（预处理语句），然后用于绑定参数值并执行语句。
- en: '`PDO::bindParam()` is used to bind prepared statements'' parameters, and has
    the following syntax:'
  id: totrans-479
  prefs: []
  type: TYPE_NORMAL
  zh: '`PDO::bindParam()`用于绑定预处理语句的参数，其语法如下：'
- en: '[PRE75]'
  id: totrans-480
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'Accepted input parameters:'
  id: totrans-481
  prefs: []
  type: TYPE_NORMAL
  zh: 接受的输入参数：
- en: '`parameter`: The parameter identifier; for a prepared statement using named
    placeholders, this will be a parameter name of the form `:name`. For a prepared
    statement using question mark placeholders, this will be the one-indexed position
    of the parameter.'
  id: totrans-482
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`parameter`：参数标识符；对于使用命名占位符的预处理语句，这将是一个形式为`:name`的参数名称。对于使用问号占位符的预处理语句，这将是指参数的一个索引位置。'
- en: '`variable`: The name of the PHP variable to bind to the SQL statement parameter;
    be aware that this parameter is passed by reference, meaning that if we modify
    the variable before we execute the statement, the new value will be sent to the
    server when `PDO::execute()` is invoked.'
  id: totrans-483
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`variable`：要绑定到SQL语句参数的PHP变量名称；请注意，此参数是通过引用传递的，这意味着如果我们执行语句之前修改了变量，新值将在调用`PDO::execute()`时发送到服务器。'
- en: '`data_type`: The data type for the parameter using the `PDO::PARAM_*` constants;
    for example, `PDO::PARAM_INT`.'
  id: totrans-484
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`data_type`：使用`PDO::PARAM_*`常量指定的参数数据类型；例如，`PDO::PARAM_INT`。'
- en: '`length`: The length of the data type. To indicate that a parameter is an `OUT`
    parameter from a stored procedure, you must explicitly set the length.'
  id: totrans-485
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`length`：数据类型的长度。要表示参数是从存储过程的一个`OUT`参数，您必须显式设置长度。'
- en: '`driver_options`: Self-explanatory.'
  id: totrans-486
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`driver_options`：自解释。'
- en: The `PDO::bindParam()` method returns `true` if successful, otherwise `false`.
  id: totrans-487
  prefs: []
  type: TYPE_NORMAL
  zh: '`PDO::bindParam()`方法在成功时返回`true`，否则返回`false`。'
- en: 'To execute the prepared statement, use the `PDO::execute()` method. The syntax
    is the following:'
  id: totrans-488
  prefs: []
  type: TYPE_NORMAL
  zh: 要执行预处理语句，请使用`PDO::execute()`方法。语法如下：
- en: '[PRE76]'
  id: totrans-489
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: The only accepted parameter is an optional `$input_parameters` array with values
    for the statement placeholders. All values of the array are treated as `PDO::PARAM_STR`.
  id: totrans-490
  prefs: []
  type: TYPE_NORMAL
  zh: 唯一接受的参数是一个可选的`$input_parameters`数组，其中包含用于语句占位符的值。数组的所有值都被视为`PDO::PARAM_STR`。
- en: This method returns `true` if successful, otherwise `false`.
  id: totrans-491
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法在成功时返回 `true`，否则返回 `false`。
- en: 'The following is a sample query using a prepared statement with positional
    placeholders:'
  id: totrans-492
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是一个使用位置占位符的预处理语句的示例查询：
- en: '[PRE77]'
  id: totrans-493
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: 'Or it can be written as follows:'
  id: totrans-494
  prefs: []
  type: TYPE_NORMAL
  zh: 或者可以写成如下形式：
- en: '[PRE78]'
  id: totrans-495
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: 'The following is a sample query using a prepared statement with named placeholders:'
  id: totrans-496
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是一个使用命名占位符的预处理语句的示例查询：
- en: '[PRE79]'
  id: totrans-497
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: 'Or it could be written as follows:'
  id: totrans-498
  prefs: []
  type: TYPE_NORMAL
  zh: 或者可以写成如下形式：
- en: '[PRE80]'
  id: totrans-499
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: Notice that the `$email` variable is assigned to the `:email` placeholder only
    once, while its data changes twice, each change being followed by the execution
    of the statement. Each statement will send the current value of the `$email` variable,
    at that point of execution, this being possible as a result of using the variable
    reference in the `PDO::bindParam()` method, rather than passing the variable by
    value.
  id: totrans-500
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，`$email` 变量只被分配给 `:email` 占位符一次，而其数据改变了两次，每次改变后都会执行相应的语句。每个语句都会发送 `$email`
    变量在该执行点的当前值，这是由于在 `PDO::bindParam()` 方法中使用变量引用而不是按值传递变量而成为可能的。
- en: 'Exercise 7.16: Inserting Data Using Prepared Statements'
  id: totrans-501
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习 7.16：使用预处理语句插入数据
- en: 'In this exercise, you will create a script that inserts new user emails from
    user input, using prepared statements:'
  id: totrans-502
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，你将创建一个脚本，使用预处理语句从用户输入中插入新的用户电子邮件：
- en: 'Create a file called `insert-prepared.php` and add the following code. As before,
    we get the `PDO` instance, and then its `prepare()` method, providing the query
    template. In return, we get an instance of `PDOStatement`, which we store in the
    `$insertStmt` variable:'
  id: totrans-503
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `insert-prepared.php` 的文件，并添加以下代码。和之前一样，我们获取 `PDO` 实例，然后是其 `prepare()`
    方法，提供查询模板。作为回报，我们得到一个 `PDOStatement` 实例，我们将其存储在 `$insertStmt` 变量中：
- en: '[PRE81]'
  id: totrans-504
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE81]'
- en: 'Then, we invoke the `execute()` method of `PDOStatement`, providing the placeholder-value
    map. In this case, the value will be the first argument provided to the script
    at execution time. We check the result and, if unsuccessful, an error message
    is printed and the execution of the script stops. Otherwise, a successful message
    is printed:'
  id: totrans-505
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们调用 `PDOStatement` 的 `execute()` 方法，提供占位符-值映射。在这种情况下，值将是脚本执行时提供的第一个参数。我们检查结果，如果失败，则打印错误消息并停止脚本的执行。否则，打印成功消息：
- en: '[PRE82]'
  id: totrans-506
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE82]'
- en: 'Run the script with `php insert-prepared.php john.smith@mail.com`. The output
    should be as follows:![Figure 7.22: Duplicate entry error'
  id: totrans-507
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `php insert-prepared.php john.smith@mail.com` 运行脚本。输出应该如下所示：![图 7.22：重复条目错误
- en: '](img/C14196_07_22.jpg)'
  id: totrans-508
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![img/C14196_07_22.jpg](img/C14196_07_22.jpg)'
- en: 'Figure 7.22: Duplicate entry error'
  id: totrans-509
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 7.22：重复条目错误
- en: This is an expected error, because we have already added this email before,
    and the `UNIQUE` keyword ensures that no other entries will be added that have
    the same email address. For a table definition, please refer to *Exercise 7.14*,
    *Creating the Table*.
  id: totrans-510
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这是一个预期的错误，因为我们已经添加了此电子邮件，并且 `UNIQUE` 关键字确保不会添加具有相同电子邮件地址的其他条目。有关表定义，请参阅 *练习
    7.14*，*创建表*。
- en: 'Run the script with `php insert-prepared.php jane.smith@mail.com`. This time,
    you should expect an output message similar to this:![Figure 7.23: Record inserted'
  id: totrans-511
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `php insert-prepared.php jane.smith@mail.com` 运行脚本。这次，你应该期望得到一个类似以下的消息输出：![图
    7.23：插入的记录
- en: '](img/C14196_07_23.jpg)'
  id: totrans-512
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![img/C14196_07_23.jpg](img/C14196_07_23.jpg)'
- en: 'Figure 7.23: Record inserted'
  id: totrans-513
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 7.23：插入的记录
- en: 'Let''s check the records using Workbench:'
  id: totrans-514
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 让我们使用 Workbench 检查记录：
- en: '![Figure 7.24: Records displayed by Workbench'
  id: totrans-515
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图 7.24：Workbench 显示的记录'
- en: '](img/C14196_07_24.jpg)'
  id: totrans-516
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![img/C14196_07_24.jpg](img/C14196_07_24.jpg)'
- en: 'Figure 7.24: Records displayed by Workbench'
  id: totrans-517
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 7.24：Workbench 显示的记录
- en: It looks good. You have successfully run a prepared statement with PDO. You
    will notice that the ID of `jane.smith@mail.com` is not `2`, but `5`. This is
    because the prepared statements that ran before, even the failed ones, increased
    the `AUTO_INCREMENT` value.
  id: totrans-518
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 看起来不错。你已经成功运行了一个 PDO 预处理语句。你会注意到 `jane.smith@mail.com` 的 ID 不是 `2`，而是 `5`。这是因为之前运行的预处理语句，即使是失败的，也增加了
    `AUTO_INCREMENT` 的值。
- en: 'Let''s check the protection against SQL injection by running the script that
    includes the malicious query chunk:'
  id: totrans-519
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们通过运行包含恶意查询片段的脚本来检查对 SQL 注入的保护：
- en: '[PRE83]'
  id: totrans-520
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE83]'
- en: 'The output is similar to this:'
  id: totrans-521
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 输出类似于以下内容：
- en: '![Figure 7.25: Record inserted'
  id: totrans-522
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 7.25：插入的记录'
- en: '](img/C14196_07_25.jpg)'
  id: totrans-523
  prefs: []
  type: TYPE_NORMAL
  zh: '![img/C14196_07_25.jpg](img/C14196_07_25.jpg)'
- en: 'Figure 7.25: Record inserted'
  id: totrans-524
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.25：插入的记录
- en: 'Let''s check the results using Workbench:'
  id: totrans-525
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用 Workbench 检查结果：
- en: '![Figure 7.26: Displaying all records with the Workbench client'
  id: totrans-526
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 7.26：使用 Workbench 客户端显示所有记录'
- en: '](img/C14196_07_26.jpg)'
  id: totrans-527
  prefs: []
  type: TYPE_NORMAL
  zh: '![img/C14196_07_26.jpg](img/C14196_07_26.jpg)'
- en: 'Figure 7.26: Displaying all records with the Workbench client'
  id: totrans-528
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.26：使用 Workbench 客户端显示所有记录
- en: They look good. We are protected against SQL injection, but ended up with corrupt
    data, since the input was not validated nor sanitized before the query ran. Please
    refer to the *Sanitizing and Validating the User Input* section of *Chapter 6*,
    *Using HTTP*.
  id: totrans-529
  prefs: []
  type: TYPE_NORMAL
  zh: 它们看起来不错。我们已经防止了 SQL 注入，但由于在查询运行之前没有验证或清理输入，最终得到了损坏的数据。请参阅 *第 6 章*，*使用 HTTP*
    中的 *清理和验证用户输入* 部分。
- en: Fetching Data from MySQL
  id: totrans-530
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 从 MySQL 获取数据
- en: So far, you have learned how to create a database and a table, and also how
    to insert data into tables, in a secure manner. Now, it's time to fetch and display
    some data using PHP.
  id: totrans-531
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，你已经学习了如何以安全的方式创建数据库和表，以及如何将数据插入到表中。现在，是时候使用 PHP 获取并显示一些数据了。
- en: 'To accomplish this, we use the `SELECT` statement, which has the following
    minimal syntax:'
  id: totrans-532
  prefs: []
  type: TYPE_NORMAL
  zh: 要完成这个任务，我们使用 `SELECT` 语句，它具有以下最小语法：
- en: '[PRE84]'
  id: totrans-533
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: 'The preceding query would return all the records from the table since no limitation
    is set. It is therefore recommended (if not mandatory in some cases) to use the
    `LIMIT` clause in one of its forms:'
  id: totrans-534
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的查询将返回表中的所有记录，因为没有设置限制。因此，建议（在某些情况下可能是强制性的）在以下形式之一中使用 `LIMIT` 子句：
- en: '`LIMIT row_count`: will return the first `row_count` rows'
  id: totrans-535
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`LIMIT row_count`: 将返回前 `row_count` 行'
- en: '`LIMIT offset`, `row_count`: will return `row_count` rows starting with the
    `offset` position (for example, `LIMIT 20, 10` will return `10` rows starting
    with position `20`; another example, `LIMIT 0, 10` is equivalent to `LIMIT 10`,
    since the offset is zero by default)'
  id: totrans-536
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`LIMIT offset`, `row_count`: 将从 `offset` 位置开始返回 `row_count` 行（例如，`LIMIT 20,
    10` 将从位置 `20` 开始返回 `10` 行；另一个例子，`LIMIT 0, 10` 等同于 `LIMIT 10`，因为默认偏移量为零）'
- en: '`LIMIT row_count OFFSET` `offset`: identical to `LIMIT` `offset`, `row_count`'
  id: totrans-537
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`LIMIT row_count OFFSET` `offset`: 与 `LIMIT` `offset`, `row_count` 相同'
- en: A part of the `LIMIT` clause, the `SELECT` statement is rich in clauses that
    can be used to filter, join, group, or sort data. You can check the `SELECT` statement
    syntax of the official documentation page at [https://dev.mysql.com/doc/refman/5.7/en/select.html](https://dev.mysql.com/doc/refman/5.7/en/select.html).
  id: totrans-538
  prefs: []
  type: TYPE_NORMAL
  zh: '`LIMIT` 子句的一部分，`SELECT` 语句包含丰富的子句，可用于过滤、连接、分组或排序数据。您可以在官方文档页面检查 `SELECT` 语句的语法[https://dev.mysql.com/doc/refman/5.7/en/select.html](https://dev.mysql.com/doc/refman/5.7/en/select.html)。'
- en: 'A very simple `SELECT` statement looks like this:'
  id: totrans-539
  prefs: []
  type: TYPE_NORMAL
  zh: 一个非常简单的 `SELECT` 语句看起来像这样：
- en: '[PRE85]'
  id: totrans-540
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: This statement queries the first 10 records from the `employees` table.
  id: totrans-541
  prefs: []
  type: TYPE_NORMAL
  zh: 此语句查询 `employees` 表的前 10 条记录。
- en: Note
  id: totrans-542
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Using an asterisk, `*`, instead of column names in `SELECT` statements will
    make MySQL perform an additional lookup query to retrieve the column list of the
    queried table, and replace the `*` in the original query with this list of columns.
    This has a performance impact on SQL queries, which is not significant for low-traffic
    applications; yet it is considered good practice to specify the column list instead
    of `*`, irrespective of the project size or the estimated traffic load.
  id: totrans-543
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `SELECT` 语句中使用星号 `*` 而不是列名，将使 MySQL 执行额外的查找查询以检索查询表的列列表，并将原始查询中的 `*` 替换为该列列表。这会对
    SQL 查询的性能产生影响，对于低流量应用程序来说影响并不显著；然而，无论项目大小或估计的流量负载如何，指定列列表而不是 `*` 被认为是良好的实践。
- en: Now, let's examine, step by step, how we can get the data we want from a MySQL
    database, using various examples.
  id: totrans-544
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们一步一步地检查如何使用各种示例从 MySQL 数据库中获取我们想要的数据。
- en: 'Exercise 7.17: Fetching Data from MySQL'
  id: totrans-545
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习 7.17：从 MySQL 获取数据
- en: 'In this exercise, you will learn how you can query data from a MySQL database
    in the most simplistic way, getting a slice of records in the result set, filtering
    the data, and ordering the data by a specific column:'
  id: totrans-546
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，你将学习如何以最简单的方式从 MySQL 数据库查询数据，获取结果集中的记录片段，通过特定列过滤数据，并按特定列排序数据：
- en: 'Create the `select-all.php` file and add the following code. We get the `PDO`
    instance and store the `SELECT` query in the `$statement` variable. Then, we invoke
    the `query()` method of the `PDO` object instance, and will either get as output
    a Boolean `false`, in the event of failure, or an instance of `PDOStatement` if
    successful:'
  id: totrans-547
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建 `select-all.php` 文件并添加以下代码。我们获取 `PDO` 实例并将 `SELECT` 查询存储在 `$statement` 变量中。然后，我们调用
    `PDO` 对象实例的 `query()` 方法，在失败的情况下将输出一个布尔值 `false`，在成功的情况下将返回一个 `PDOStatement` 实例：
- en: '[PRE86]'
  id: totrans-548
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE86]'
- en: 'In the event of a query failure, we print the error message and interrupt the
    script execution. Otherwise, we print the `All records` line and iterate over
    all the result set records and print them, joining the record data using the tab
    delimiter:'
  id: totrans-549
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在查询失败的情况下，我们打印错误消息并中断脚本执行。否则，我们打印`All records`行，并遍历所有结果集记录并打印它们，使用制表符分隔记录数据：
- en: '[PRE87]'
  id: totrans-550
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE87]'
- en: 'We repeat the operation with a slightly modified query, adding the `LIMIT`
    clause (and, without checking for query failure anymore), and we then print the
    `Use LIMIT 2` line followed by all the records in the result set:'
  id: totrans-551
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们使用略微修改的查询重复此操作，添加`LIMIT`子句（并且不再检查查询失败），然后打印`Use LIMIT 2`行，随后是结果集中的所有记录：
- en: '[PRE88]'
  id: totrans-552
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE88]'
- en: 'We run another query, using the `WHERE` clause to filter the result set and
    only return the records with an ID value greater than `3`. Then, we print the
    `Use WHERE id > 3` line followed by all the records in the result set:'
  id: totrans-553
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们运行另一个查询，使用`WHERE`子句过滤结果集，并仅返回ID值大于`3`的记录。然后，我们打印`Use WHERE id > 3`行，随后是结果集中的所有记录：
- en: '[PRE89]'
  id: totrans-554
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE89]'
- en: 'Lastly, we run one more query, using the `ORDER BY` clause to sort the output
    by the `id` column in descending order. We print the `Use ORDER BY id DESC` line,
    followed by all the records in the result set:'
  id: totrans-555
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们运行另一个查询，使用`ORDER BY`子句按`id`列降序排序输出。我们打印`Use ORDER BY id DESC`行，随后是结果集中的所有记录：
- en: '[PRE90]'
  id: totrans-556
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE90]'
- en: Note
  id: totrans-557
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意
- en: The final file can be referred at [https://packt.live/31daUWP](https://packt.live/31daUWP).
  id: totrans-558
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 最终文件可以在[https://packt.live/31daUWP](https://packt.live/31daUWP)中查阅。
- en: 'Run the script with `php select-all.php`. Expect the following output:'
  id: totrans-559
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`php select-all.php`运行脚本。预期以下输出：
- en: '![Figure 7.27: Fetching the records using different conditions'
  id: totrans-560
  prefs: []
  type: TYPE_NORMAL
  zh: '![图7.27：使用不同条件获取记录](img/C14196_07_27.jpg)'
- en: '](img/C14196_07_27.jpg)'
  id: totrans-561
  prefs: []
  type: TYPE_NORMAL
  zh: '![图7.27：使用不同条件获取记录](img/C14196_07_27.jpg)'
- en: 'Figure 7.27: Fetching the records using different conditions'
  id: totrans-562
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.27：使用不同条件获取记录
- en: 'Congratulations! You successfully fetched data from the MySQL database in different
    ways: sorting, filtering, and slicing the entire data in the table.'
  id: totrans-563
  prefs: []
  type: TYPE_NORMAL
  zh: 恭喜！您已成功以不同的方式从MySQL数据库中获取数据：排序、过滤和切片表中的整个数据。
- en: By now, we have got a glimpse into the power of a database. This is just the
    beginning.
  id: totrans-564
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经领略了数据库的强大功能。这仅仅是开始。
- en: Updating Records in MySQL
  id: totrans-565
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: MySQL中的更新记录
- en: To update records in MySQL, the `UPDATE` statement is used. This is usually
    used together with the `WHILE` clause to filter the rows to which the update is
    applied.
  id: totrans-566
  prefs: []
  type: TYPE_NORMAL
  zh: 要在MySQL中更新记录，使用`UPDATE`语句。这通常与`WHILE`子句一起使用，以过滤要应用更新的行。
- en: Warning
  id: totrans-567
  prefs: []
  type: TYPE_NORMAL
  zh: 警告
- en: Not using `WHERE` in an `UPDATE` statement will cause the update to apply to
    all records in the table.
  id: totrans-568
  prefs: []
  type: TYPE_NORMAL
  zh: 在`UPDATE`语句中不使用`WHERE`会导致更新应用于表中的所有记录。
- en: The `PDOStatement::rowCount()` method returns the number of rows affected by
    the last `INSERT`, `UPDATE`, or `DELETE` statement executed by the corresponding
    `PDOStatement` object.
  id: totrans-569
  prefs: []
  type: TYPE_NORMAL
  zh: '`PDOStatement::rowCount()`方法返回由相应的`PDOStatement`对象执行的最后一个`INSERT`、`UPDATE`或`DELETE`语句影响的行数。'
- en: 'Exercise 7.18: Updating Records in MySQL'
  id: totrans-570
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习7.18：在MySQL中更新记录
- en: 'In this exercise, you will learn how to perform an update to a MySQL database
    `users` table, setting the email `john.doe@mail.com` for a record with incorrect
    data in the email column (ID 6 in our case):'
  id: totrans-571
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，您将学习如何对MySQL数据库的`users`表执行更新，将电子邮件设置为`john.doe@mail.com`，用于电子邮件列中数据不正确的记录（在我们的例子中是ID
    6）：
- en: 'Create a file called `update.php` and add the following code. First, we get
    the `PDO` instance and update parameters. We need the record `id`, which has to
    be updated, and this value will be retrieved from the first input argument of
    the script, defaulting to `0` (zero). We also need the updated value for the `email`
    column, which will be retrieved from the second input argument of the script.
    Note that these values can be retrieved from the `$_POST` superglobal, when the
    update action is performed using an HTML form in a web page:'
  id: totrans-572
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`update.php`的文件，并添加以下代码。首先，我们获取`PDO`实例并更新参数。我们需要更新的记录`id`，这个值将从脚本的第一个输入参数中检索，默认为`0`（零）。我们还需要从脚本的第二个输入参数中检索`email`列的更新值。注意，这些值可以在使用网页中的HTML表单执行更新操作时从`$_POST`超级全局变量中检索：
- en: '[PRE91]'
  id: totrans-573
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE91]'
- en: 'Then, we prepare the `UPDATE` statement using two placeholders – `id` and `email`:'
  id: totrans-574
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们使用两个占位符`id`和`email`准备`UPDATE`语句：
- en: '[PRE92]'
  id: totrans-575
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE92]'
- en: 'We execute the `UPDATE` statement, providing the placeholders'' values map
    in an argument, and test the result; if unsuccessful, the error message will be
    displayed and the script will return (ending the execution). Otherwise, the success
    message is displayed:'
  id: totrans-576
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们执行`UPDATE`语句，提供一个参数中的占位符值映射，并测试结果；如果失败，将显示错误消息，并且脚本将返回（结束执行）。否则，将显示成功消息：
- en: '[PRE93]'
  id: totrans-577
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE93]'
- en: 'Run the script with `php update.php 6 john.doe@mail.com` and check the result.
    The expected output is as follows:![Figure 7.28: Updating a record'
  id: totrans-578
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`php update.php 6 john.doe@mail.com`运行脚本并检查结果。预期的输出如下：![图7.28：更新记录
- en: '](img/C14196_07_28.jpg)'
  id: totrans-579
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/C14196_07_28.jpg)'
- en: 'Figure 7.28: Updating a record'
  id: totrans-580
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图7.28：更新记录
- en: 'Let''s check the result in Workbench:![Figure 7.29: Displaying database table
    data using the Workbench client'
  id: totrans-581
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们在Workbench中检查结果：![图7.29：使用Workbench客户端显示数据库表数据
- en: '](img/C14196_07_29.jpg)'
  id: totrans-582
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/C14196_07_29.jpg)'
- en: 'Figure 7.29: Displaying database table data using the Workbench client'
  id: totrans-583
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图7.29：使用Workbench客户端显示数据库表数据
- en: The email for the record with the `id` 6 was changed to the value provided.
    It looks great! Note that if you have another `id` for the record with incorrect
    data in the `email` field, then you should use that `id` in *step 2* when running
    the command.
  id: totrans-584
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`id`为6的记录的电子邮件已更改为提供的值。看起来很棒！注意，如果你有另一个`id`，该记录的`email`字段中有错误数据，那么在运行命令时应该使用该`id`在*步骤2*中。'
- en: 'Now, let''s see what happens when we run the `UPDATE` query for an `ID` that
    does not exist:'
  id: totrans-585
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们看看当我们为不存在的`ID`运行`UPDATE`查询时会发生什么：
- en: '[PRE94]'
  id: totrans-586
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE94]'
- en: 'Expect the following output:'
  id: totrans-587
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 预期以下输出：
- en: '![Figure 7.30: Output of the UPDATE query'
  id: totrans-588
  prefs: []
  type: TYPE_NORMAL
  zh: '![图7.30：UPDATE查询的输出'
- en: '](img/C14196_07_30.jpg)'
  id: totrans-589
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/C14196_07_30.jpg)'
- en: 'Figure 7.30: Output of the UPDATE query'
  id: totrans-590
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.30：UPDATE查询的输出
- en: 'We end up with no row being affected by this query, and the logic seems pretty
    straightforward: the `UPDATE` statement filters the rows to update, using the
    conditions from the `WHERE` clause; in our case, filtering by `id=16` resulted
    in no rows qualifying for an update.'
  id: totrans-591
  prefs: []
  type: TYPE_NORMAL
  zh: 我们最终发现此查询没有行受到影响，逻辑看起来相当简单：`UPDATE`语句使用`WHERE`子句中的条件过滤要更新的行；在我们的情况下，通过`id=16`过滤没有行符合更新条件。
- en: Note
  id: totrans-592
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Trying to update a record column value with the same, identical value will result
    in no count for the affected row aggregation; in other words, `PDOStatement::rowCount()`
    will return `0` (zero).
  id: totrans-593
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试使用相同的、完全相同的值更新记录列的值，将导致受影响的行聚合计数为0；换句话说，`PDOStatement::rowCount()`将返回`0`（零）。
- en: Deleting Records from MySQL
  id: totrans-594
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 从MySQL中删除记录
- en: To delete records from MySQL, we should use the `DELETE` statement. This is
    often (if not always) used together with the `WHERE` clause to indicate matching
    records to delete.
  id: totrans-595
  prefs: []
  type: TYPE_NORMAL
  zh: 要从MySQL中删除记录，我们应该使用`DELETE`语句。这通常（如果不是总是）与`WHERE`子句一起使用，以指示要删除的匹配记录。
- en: Warning
  id: totrans-596
  prefs: []
  type: TYPE_NORMAL
  zh: 警告
- en: Failure to provide the `WHERE` clause in a `DELETE` statement will cause all
    records to be deleted from the table.
  id: totrans-597
  prefs: []
  type: TYPE_NORMAL
  zh: 在`DELETE`语句中未提供`WHERE`子句将导致表中所有记录被删除。
- en: 'Usually, in the `WHERE` clause of a `DELETE` statement, the id columns are
    used. This is the case when a precisely indicated row is deleted. But the `WHERE`
    clause can be used to its full potential in `DELETE` statements as well. Let''s
    say we want to delete records using a partial match for string columns. To achieve
    this, we will use the `LIKE` operator, which is simple, yet powerful, pattern
    matching. With this operator, we can use two wildcards:'
  id: totrans-598
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，在`DELETE`语句的`WHERE`子句中，使用id列。这是精确指示删除行的情况。但`WHERE`子句也可以在`DELETE`语句中充分发挥其潜力。假设我们想要使用字符串列的部分匹配来删除记录。为了实现这一点，我们将使用`LIKE`运算符，这是一个简单而强大的模式匹配。使用此运算符，我们可以使用两个通配符：
- en: '`_` (underscore): matches exactly one character'
  id: totrans-599
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`_`（下划线）：匹配恰好一个字符'
- en: '`%` (percent): matches any number of characters, including no characters'
  id: totrans-600
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`%`（百分号）：匹配任意数量的字符，包括没有字符'
- en: For example, `LIKE` `php_` will match the `php7` column value but will not match
    `php` or `php70`.
  id: totrans-601
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，`LIKE` `php_`将匹配`php7`列的值，但不会匹配`php`或`php70`。
- en: On the other hand, `LIKE` "`php7%`" will match `php7`, `php70`, but will not
    match `php`.
  id: totrans-602
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，`LIKE` `"php7%"`将匹配`php7`、`php70`，但不会匹配`php`。
- en: To know how many records were deleted, we will use the `PDOStatement::rowCount()`
    method mentioned before.
  id: totrans-603
  prefs: []
  type: TYPE_NORMAL
  zh: 要知道删除了多少条记录，我们将使用之前提到的`PDOStatement::rowCount()`方法。
- en: 'Exercise 7.19: Deleting Records from MySQL'
  id: totrans-604
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习7.19：从MySQL中删除记录
- en: 'In this exercise, you will learn how to delete records from MySQL using a partial
    match in the `WHERE` clause:'
  id: totrans-605
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，你将学习如何使用`WHERE`子句中的部分匹配来从MySQL中删除记录：
- en: Create a file called `delete.php`.
  id: totrans-606
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `delete.php` 的文件。
- en: 'First, we get the `PDO` instance, as usual, then retrieve the string to match
    from the input argument, and then we prepare the `DELETE` statement using the
    `:partialMatch` placeholder:'
  id: totrans-607
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们像往常一样获取 `PDO` 实例，然后从输入参数中检索要匹配的字符串，然后使用 `:partialMatch` 占位符准备 `DELETE`
    语句：
- en: '[PRE95]'
  id: totrans-608
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE95]'
- en: 'We then execute the statement by passing the string from input and, in the
    event of an execution failure, we print the error message. Note that the `:partialMatch`
    pattern value is the `$partialMatch` variable value enclosed with `%`, meaning
    we will look for a match anywhere in the column value, be it at the beginning,
    the end, or somewhere inside the string value:'
  id: totrans-609
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后通过传递输入字符串执行该语句，在执行失败的情况下，我们打印错误信息。注意，`:partialMatch` 模式值是 `%$partialMatch`
    变量值，这意味着我们将在列值中的任何位置寻找匹配，无论是开始、结束还是字符串值内部：
- en: '[PRE96]'
  id: totrans-610
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE96]'
- en: 'If the statement executed successfully, then we want to know how many records
    were affected (deleted), and we will use the `PDOStatement::rowCount()` method
    for that. We store the value inside the `$rowCount` variable for further usage,
    and evaluate its value. If the value is `0` (zero), it means no records were deleted,
    and an appropriate message will be printed to output, including the lookup term
    (the partial match string). Otherwise, the success message will be printed, indicating
    the number of rows deleted for the lookup term:'
  id: totrans-611
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果语句执行成功，那么我们想知道影响了多少记录（被删除），我们将使用 `PDOStatement::rowCount()` 方法来做到这一点。我们将值存储在
    `$rowCount` 变量中以便进一步使用，并评估其值。如果值为 `0`（零），则表示没有记录被删除，并且将打印出适当的消息到输出，包括查找项（部分匹配字符串）。否则，将打印出成功消息，指示删除的行数：
- en: '[PRE97]'
  id: totrans-612
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE97]'
- en: Note
  id: totrans-613
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意
- en: The full script can be referred at [https://packt.live/2MCeswE](https://packt.live/2MCeswE).
  id: totrans-614
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 完整脚本可参考 [https://packt.live/2MCeswE](https://packt.live/2MCeswE)。
- en: 'Run the file with `php delete.php smith`, and expect the following output:![Figure
    7.31: Deleting records'
  id: totrans-615
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `php delete.php smith` 运行文件，并期待以下输出：![图 7.31：删除记录截图](img/C14196_07_31.jpg)
- en: '](img/C14196_07_31.jpg)'
  id: totrans-616
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图 7.31：删除记录截图](img/C14196_07_31.jpg)'
- en: 'Figure 7.31: Deleting records'
  id: totrans-617
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图 7.31：删除记录截图](img/C14196_07_31.jpg)'
- en: 'Run the preceding command once again. Now, you should expect the following
    output:![Figure 7.32: Error deleting data'
  id: totrans-618
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 再次运行前面的命令。现在，你应该期待以下输出：![图 7.32：删除数据错误截图](img/C14196_07_32.jpg)
- en: '](img/C14196_07_32.jpg)'
  id: totrans-619
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图 7.32：删除数据错误截图](img/C14196_07_32.jpg)'
- en: 'Figure 7.32: Error deleting data'
  id: totrans-620
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 7.32：删除数据错误
- en: 'Check the records using Workbench:'
  id: totrans-621
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 Workbench 检查记录：
- en: '![Figure 7.33: Displaying database table data using the Workbench client'
  id: totrans-622
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 7.33：使用 Workbench 客户端显示数据库表数据](img/C14196_07_33.jpg)'
- en: '](img/C14196_07_33.jpg)'
  id: totrans-623
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 7.33：使用 Workbench 客户端显示数据库表数据](img/C14196_07_33.jpg)'
- en: 'Figure 7.33: Displaying database table data using the Workbench client'
  id: totrans-624
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 7.33：使用 Workbench 客户端显示数据库表数据](img/C14196_07_33.jpg)'
- en: All the records matching `smith` have gone.
  id: totrans-625
  prefs: []
  type: TYPE_NORMAL
  zh: 所有匹配 `smith` 的记录都已删除。
- en: You successfully completed the deletion of records from the database table by
    matching them using the `LIKE` operator. For a complete list of operators, refer
    at [https://packt.live/2OHMB0B](https://packt.live/2OHMB0B).
  id: totrans-626
  prefs: []
  type: TYPE_NORMAL
  zh: 您通过使用 `LIKE` 操作符匹配记录成功完成了从数据库表中删除记录。有关操作符的完整列表，请参阅 [https://packt.live/2OHMB0B](https://packt.live/2OHMB0B)。
- en: The Singleton Pattern
  id: totrans-627
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 单例模式
- en: The `private`) and by defining a public static method that returns the sole
    instance of the class.
  id: totrans-628
  prefs: []
  type: TYPE_NORMAL
  zh: 通过定义一个私有构造函数（`private`) 并通过定义一个公共静态方法来返回该类的唯一实例。
- en: This is useful when precisely one object (the first instance) is needed to perform
    actions across the application. For a database connection class, this is particularly
    useful since it does not only limit multiple instantiations of the class but also
    avoids repetitive connection and disconnection operations with the MySQL Server,
    making the first established connection available across the application for the
    lifetime of a single request-response cycle.
  id: totrans-629
  prefs: []
  type: TYPE_NORMAL
  zh: 当需要精确地一个对象（第一个实例）来在应用程序中执行操作时，这很有用。对于数据库连接类来说，这尤其有用，因为它不仅限制了类的多次实例化，还避免了与 MySQL
    服务器的重复连接和断开操作，使得第一次建立的连接在整个请求-响应周期内对应用程序可用。
- en: 'To test (or demonstrate) the singleton implementation in PHP, a simple script
    file would be sufficient:'
  id: totrans-630
  prefs: []
  type: TYPE_NORMAL
  zh: 要测试（或演示）PHP 中的单例实现，一个简单的脚本文件就足够了：
- en: '[PRE98]'
  id: totrans-631
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: 'Running the preceding script would always return the following:'
  id: totrans-632
  prefs: []
  type: TYPE_NORMAL
  zh: 运行前面的脚本将始终返回以下内容：
- en: '![Figure 7.34: Screenshot of the output'
  id: totrans-633
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 7.34：输出截图](img/C14196_07_34.jpg)'
- en: '](img/C14196_07_34.jpg)'
  id: totrans-634
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 7.34：输出截图](img/C14196_07_34.jpg)'
- en: 'Figure 7.34: Screenshot of the output'
  id: totrans-635
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.34：输出截图
- en: Note
  id: totrans-636
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: When comparing objects using the identity operator (`===`), object variables
    are identical if, and only if, they refer to the same instance of the same class.
  id: totrans-637
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用身份运算符（`===`）比较对象时，只有当对象变量引用的是同一类的相同实例时，它们才是相同的。
- en: So far in this chapter, you have learned how to use a database, starting with
    the connection, creating a database and tables, before moving on to adding, querying,
    updating, and deleting records, and then to securing queries by using prepared
    statements and anonymous or named placeholders. Undoubtedly, MySQL has much more
    to offer—it merits an entire book, but the essentials were all briefly covered
    here.
  id: totrans-638
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，在本章中，你已经学习了如何使用数据库，从连接开始，创建数据库和表，然后转到添加、查询、更新和删除记录，最后通过使用预处理语句和匿名或命名占位符来保护查询。毫无疑问，MySQL还有更多要提供——它值得一本整本书，但这里简要地涵盖了所有基本内容。
- en: 'Activity 7.1: Contact Management Application'
  id: totrans-639
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 活动7.1：联系人管理应用程序
- en: You are required to build a website where users can create an account and then
    log in to manage a private list of contacts. The website will make use of databases
    to store user login data, as well as to store each user's contacts.
  id: totrans-640
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要构建一个网站，用户可以在其中创建账户并登录来管理私人联系名单。该网站将使用数据库来存储用户登录数据，以及存储每个用户的联系信息。
- en: Along with the database functionality that you have learned in this chapter,
    you will be required to use functionality from previous chapters in order to build
    the website (for example, conditionals from *Chapter 3*, *Control Statements*;
    functions from *Chapter 4*, *Functions*; OOP from *Chapter 5*, *Object-Oriented
    Programming*; and form validation from *Chapter 6*, *Using HTTP*). You may need
    to refer to previous chapters for a reminder of how to implement the required
    functionality.
  id: totrans-641
  prefs: []
  type: TYPE_NORMAL
  zh: 除了本章中学习的数据库功能外，你还需要使用之前章节中的功能来构建网站（例如，来自*第3章*，*控制语句*的条件；来自*第4章*，*函数*的函数；来自*第5章*，*面向对象编程*的OOP；以及来自*第6章*，*使用HTTP*的表单验证）。你可能需要参考之前的章节来提醒如何实现所需的功能。
- en: 'The required pages are as follows:'
  id: totrans-642
  prefs: []
  type: TYPE_NORMAL
  zh: 所需的页面如下：
- en: Home page
  id: totrans-643
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 主页
- en: Login and Sign up pages
  id: totrans-644
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 登录和注册页面
- en: Profile page
  id: totrans-645
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 个人资料页面
- en: Contacts list and add/edit contact form page
  id: totrans-646
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 联系人列表和添加/编辑联系人表单页面
- en: '**Layout and Briefing**'
  id: totrans-647
  prefs: []
  type: TYPE_NORMAL
  zh: '**布局和概述**'
- en: 'The layout is as shown:'
  id: totrans-648
  prefs: []
  type: TYPE_NORMAL
  zh: 布局如下所示：
- en: The home page
  id: totrans-649
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 主页
- en: '![Figure 7.35: Home page layout'
  id: totrans-650
  prefs: []
  type: TYPE_NORMAL
  zh: '![图7.35：主页布局'
- en: '](img/C14196_07_35.jpg)'
  id: totrans-651
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/C14196_07_35.jpg)'
- en: 'Figure 7.35: Home page layout'
  id: totrans-652
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.35：主页布局
- en: There is a horizontal navigation bar at the top of the page, featuring the website
    title on the left, and the `Login` button on the right. After a successful login,
    the `Login` button will be replaced by the username, which will link to the Profile
    page, the Contacts page link, and the Logout link.
  id: totrans-653
  prefs: []
  type: TYPE_NORMAL
  zh: 页面顶部有一个水平导航栏，左侧显示网站标题，右侧显示`登录`按钮。登录成功后，`登录`按钮将被用户名替换，该用户名将链接到个人资料页面、联系人页面链接和注销链接。
- en: 'The content is a message with two call-to-action links: `Sign up` and `Login`.'
  id: totrans-654
  prefs: []
  type: TYPE_NORMAL
  zh: 内容是一条包含两个行动号召链接的消息：`注册`和`登录`。
- en: 'The Login page will look as follows:'
  id: totrans-655
  prefs: []
  type: TYPE_NORMAL
  zh: 登录页面将如下所示：
- en: '![Figure 7.36: Authentication layout'
  id: totrans-656
  prefs: []
  type: TYPE_NORMAL
  zh: '![图7.36：认证布局'
- en: '](img/C14196_07_36.jpg)'
  id: totrans-657
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/C14196_07_36.jpg)'
- en: 'Figure 7.36: Authentication layout'
  id: totrans-658
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.36：认证布局
- en: The login is based on the username and password, so the content is a simple
    login form, with `Username` and `Password` fields, and a `Login` button. The last
    sentence is a `Sign up` call-to-action link.
  id: totrans-659
  prefs: []
  type: TYPE_NORMAL
  zh: 登录基于用户名和密码，因此内容是一个简单的登录表单，包含`用户名`和`密码`字段，以及一个`登录`按钮。最后一句话是一个`注册`行动号召链接。
- en: After logging in, the user is redirected to the `Profile` page.
  id: totrans-660
  prefs: []
  type: TYPE_NORMAL
  zh: 登录后，用户将被重定向到`个人资料`页面。
- en: 'The Sign up page will look as follows:'
  id: totrans-661
  prefs: []
  type: TYPE_NORMAL
  zh: 注册页面将如下所示：
- en: '![Figure 7.37: Sign up page layout'
  id: totrans-662
  prefs: []
  type: TYPE_NORMAL
  zh: '![图7.37：注册页面布局'
- en: '](img/C14196_07_37.jpg)'
  id: totrans-663
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/C14196_07_37.jpg)'
- en: 'Figure 7.37: Sign up page layout'
  id: totrans-664
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.37：注册页面布局
- en: 'The content is the `Sign up` form, with the following inputs:'
  id: totrans-665
  prefs: []
  type: TYPE_NORMAL
  zh: 内容是`注册`表单，包含以下输入：
- en: '`Username`'
  id: totrans-666
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`用户名`'
- en: '`Password`'
  id: totrans-667
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`密码`'
- en: '`Password` **verify**'
  id: totrans-668
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`密码` **验证**'
- en: 'The username is required to be at least three characters long, and just alphanumeric.
    The password should be at least six characters long and should be verified by
    a second password input at signup. Any form error should be displayed under the
    input where the data came from, for example:'
  id: totrans-669
  prefs: []
  type: TYPE_NORMAL
  zh: 用户名至少需要三个字符长，且仅限字母数字。密码至少需要六个字符长，并在注册时通过第二个密码输入进行验证。任何表单错误都应该显示在数据来源的输入下方，例如：
- en: '![Figure 7.38: Validation error'
  id: totrans-670
  prefs: []
  type: TYPE_NORMAL
  zh: '![图7.38：验证错误'
- en: '](img/C14196_07_38.jpg)'
  id: totrans-671
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/C14196_07_38.jpg)'
- en: 'Figure 7.38: Validation error'
  id: totrans-672
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.38：验证错误
- en: 'The registered accounts should also retain the signup date. After signing up,
    the user is redirected to the Profile page:'
  id: totrans-673
  prefs: []
  type: TYPE_NORMAL
  zh: 注册的账户还应保留注册日期。注册后，用户将被重定向到个人资料页面：
- en: 'The Profile page will look as follows:'
  id: totrans-674
  prefs: []
  type: TYPE_NORMAL
  zh: 个人资料页面将如下所示：
- en: '![Figure 7.39: Profile page layout'
  id: totrans-675
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 7.39：个人资料页面布局'
- en: '](img/C14196_07_39.jpg)'
  id: totrans-676
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/C14196_07_39.jpg)'
- en: 'Figure 7.39: Profile page layout'
  id: totrans-677
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.39：个人资料页面布局
- en: This will contain a greeting, the profile data, and the session login time.
    While the username and signup date are stored in the database, the session login
    time can be stored in the current session.
  id: totrans-678
  prefs: []
  type: TYPE_NORMAL
  zh: 这将包含问候语、个人资料数据和会话登录时间。虽然用户名和注册日期存储在数据库中，但会话登录时间可以存储在当前会话中。
- en: 'The Contacts page will look as follows:'
  id: totrans-679
  prefs: []
  type: TYPE_NORMAL
  zh: 联系人页面将如下所示：
- en: '![Figure 7.40: Contact page layout'
  id: totrans-680
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 7.40：联系人页面布局'
- en: '](img/C14196_07_40.jpg)'
  id: totrans-681
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/C14196_07_40.jpg)'
- en: 'Figure 7.40: Contact page layout'
  id: totrans-682
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.40：联系人页面布局
- en: 'The content is split into two: the contacts list and the contact add/edit form:'
  id: totrans-683
  prefs: []
  type: TYPE_NORMAL
  zh: 内容分为两部分：联系人列表和联系人添加/编辑表单：
- en: '![Figure 7.41: Edit and delete options for data'
  id: totrans-684
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 7.41：数据编辑和删除选项'
- en: '](img/C14196_07_41.jpg)'
  id: totrans-685
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/C14196_07_41.jpg)'
- en: 'Figure 7.41: Edit and delete options for data'
  id: totrans-686
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.41：数据编辑和删除选项
- en: The contacts list will list the contact records, each record having the `Edit`
    and `Delete` links. If the list is empty, then display the appropriate message
    instead of rendering the empty table.
  id: totrans-687
  prefs: []
  type: TYPE_NORMAL
  zh: 联系人列表将列出联系人记录，每个记录都有`编辑`和`删除`链接。如果列表为空，则显示适当的消息而不是渲染空表。
- en: 'The contact form will have the following field names:'
  id: totrans-688
  prefs: []
  type: TYPE_NORMAL
  zh: 联系人表单将具有以下字段名称：
- en: '`Name`: required; at least two characters'
  id: totrans-689
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`姓名`：必填；至少两个字符'
- en: '`Phone`: optional; must only allow `+-() 1234567890`'
  id: totrans-690
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`电话`：可选；必须只允许 `+-() 1234567890`'
- en: '`Email`: required; must be validated'
  id: totrans-691
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`电子邮件`：必填；必须进行验证'
- en: '`Address`: optional; maximum 255 characters'
  id: totrans-692
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`地址`：可选；最大 255 个字符'
- en: 'It should look similar to the following:'
  id: totrans-693
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 它应该看起来类似于以下内容：
- en: '![Figure 7.42: Contact form'
  id: totrans-694
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 7.42：联系人表单'
- en: '](img/C14196_07_42.jpg)'
  id: totrans-695
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/C14196_07_42.jpg)'
- en: 'Figure 7.42: Contact form'
  id: totrans-696
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.42：联系人表单
- en: Error messages for invalid data should be placed under the inputs from which
    the data emanated.
  id: totrans-697
  prefs: []
  type: TYPE_NORMAL
  zh: 对于无效数据，错误信息应放置在数据来源的输入下方。
- en: Accessing the Contacts page, the form is ready to use to create new contacts.
    Once the **Edit** button of a contact is pressed, then the contact info will be
    filled in the form; submitting the form updates the existing contact.
  id: totrans-698
  prefs: []
  type: TYPE_NORMAL
  zh: 访问联系人页面，表单已准备好用于创建新的联系人。一旦按下联系人的**编辑**按钮，联系人信息将被填写到表单中；提交表单更新现有联系人。
- en: When an authenticated user accesses the Home page, Login page, or Sign up page,
    they will be redirected to the Profile page.
  id: totrans-699
  prefs: []
  type: TYPE_NORMAL
  zh: 当认证用户访问主页、登录页面或注册页面时，他们将被重定向到个人资料页面。
- en: The default page title is `Contacts list`.
  id: totrans-700
  prefs: []
  type: TYPE_NORMAL
  zh: 默认页面标题为“联系人列表”。
- en: Now, where should you start? While, in most cases, frameworks are used to simplify
    the "getting started" process of each project, and since we will cover the frameworks
    in a later chapter, let's stick with our bootstrap example. Therefore, let's have
    the previous activity as a starting point for this one (please refer to the activity
    in *Chapter 6*, *Using* *HTTP*). Since the code of the current activity will change,
    you may want to create a copy of the code from the previous activity.
  id: totrans-701
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你应该从哪里开始呢？虽然，在大多数情况下，框架被用来简化每个项目的“入门”过程，而且由于我们将在后面的章节中介绍框架，所以让我们继续使用我们的 Bootstrap
    示例。因此，让我们以前一个活动作为这个活动的起点（请参阅*第 6 章*，*使用* *HTTP*）。由于当前活动的代码将会改变，你可能想要从前一个活动中复制一份代码。
- en: That having been said, I'll give you some guidelines here and there.
  id: totrans-702
  prefs: []
  type: TYPE_NORMAL
  zh: 话虽如此，我会在这里和那里给你一些指导。
- en: '**Steps to perform**:'
  id: totrans-703
  prefs: []
  type: TYPE_NORMAL
  zh: '**执行步骤**：'
- en: 'Let''s see what is needed for the new requirements, compared to the previous
    activity:'
  id: totrans-704
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看与以前的活动相比，新要求需要什么：
- en: First, there are some new pages, such as Sign up and the Contacts list page,
    that require a template and the request handler (the function that will handle
    the HTTP requests for a particular URI).
  id: totrans-705
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，有一些新的页面，例如注册页面和联系人列表页面，它们需要一个模板和请求处理器（将处理特定 URI 的 HTTP 请求的函数）。
- en: The Sign up handler will redirect authenticated users to the Profile page. Otherwise,
    it will print the signup form template and, in the case of a `POST` request, will
    handle the form. After successful signup, the user is authenticated and redirected
    to the Profile page.
  id: totrans-706
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 注册处理器将认证用户重定向到个人资料页面。否则，它将打印注册表单模板，并在`POST`请求的情况下处理表单。注册成功后，用户被认证并重定向到个人资料页面。
- en: The Contacts handler first checks whether there is an authenticated user on
    the website; if not, it sends them the login form. This handler will print the
    current list of contacts and the Contact add/edit form. Also, this handler will
    be responsible for processing the submitted contact form data, and for deleting
    contact entries as well.
  id: totrans-707
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 联系人处理器首先检查网站上是否有已认证的用户；如果没有，它将发送登录表单。此处理器将打印当前的联系列表和联系人添加/编辑表单。此外，此处理器将负责处理提交的联系人表单数据，以及删除联系人条目。
- en: To ensure this new functionality, a database is necessary, so it would be appropriate
    to use PDO with MySQL RDBMS; perhaps consider using a database component, to keep
    the `PDO` instance, and perform specific `PDO` operations in dedicated methods
    (functions).
  id: totrans-708
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了确保这项新功能，需要一个数据库，因此使用PDO与MySQL RDBMS一起使用可能是合适的；也许可以考虑使用数据库组件，以保持`PDO`实例，并在专用方法（函数）中执行特定的`PDO`操作。
- en: Since authentication is performed during login and after signup, now would be
    a good time to save the data authentication in a single place, such as a new component
    that we can call `Auth`, which may take care of other commonly used authentication-related
    tasks. The `Auth` component would deal mainly with the PHP session, setting the
    authenticated user ID and login timestamp in the session, getting the session
    login timestamp from the session, getting the user based on the user ID stored
    in the current session, and other authentication-related tasks.
  id: totrans-709
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于身份验证是在登录和注册后执行的，现在将数据身份验证保存在一个地方是个好主意，比如一个我们可以称之为`Auth`的新组件，它可能负责其他常用的身份验证相关任务。`Auth`组件将主要处理PHP会话，设置会话中的已认证用户ID和登录时间戳，从会话中获取登录时间戳，根据当前会话中存储的用户ID获取用户，以及其他身份验证相关任务。
- en: Then, since we will have to use a user's data across the website, it would probably
    be a good idea to create a model class (for example, `User`); this will contain
    a single row of data from the database, and may bundle some related functionality
    (such as checking the input password against the existing password hash). We will
    have the contacts in the database as well, but since we're only printing the contacts
    in a table or form, without using them for anything more across the website, maybe
    we can skip the Contact model.
  id: totrans-710
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于我们将在整个网站上使用用户数据，因此创建一个模型类（例如，`User`）可能是个好主意；这将包含数据库中的一行数据，并且可能包含一些相关功能（例如，检查输入密码与现有密码散列是否匹配）。我们数据库中也有联系信息，但由于我们只是在表格或表单中打印联系信息，而没有在网站的其他地方使用它们，也许我们可以跳过`Contact`模型。
- en: On top of this, some handlers will require some refactoring; for example, in
    the login handler, the data source should be changed, from an inline-defined array
    to a database. In the profile handler, all the profile picture lists and upload
    functionality will go away, together with the Support contact functionality –
    now, it will be a simple page displaying a user's data from the database.
  id: totrans-711
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 此外，一些处理器将需要进行重构；例如，在登录处理器中，数据源应从内联定义的数组更改为数据库。在用户资料处理器中，所有用户资料图片列表和上传功能都将消失，连同支持联系功能——现在，它将是一个简单的页面，显示从数据库中获取的用户数据。
- en: 'Here are the steps to perform the activity:'
  id: totrans-712
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是执行此活动的步骤：
- en: '`Create` the new page templates – the Sign up and Contacts list pages.'
  id: totrans-713
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`创建`新的页面模板——注册和联系列表页面。'
- en: Create the request handlers for the Sign up and Contact pages.
  id: totrans-714
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为注册和联系人页面创建请求处理器。
- en: Add the `Database` component, where the `PDO` object will be invoked to operate
    with the MySQL server.
  id: totrans-715
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加`Database`组件，其中将调用`PDO`对象以与MySQL服务器进行操作。
- en: Add the `Auth` component, which will take care of other commonly used authentication-related
    tasks (for example, check whether the user is logged in).
  id: totrans-716
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加`Auth`组件，它将负责其他常用的身份验证相关任务（例如，检查用户是否已登录）。
- en: Create the `User` class, as a table row model (in the `src/models/` directory),
    which will bundle some related functionality (such as checking the input password
    against the existing password hash).
  id: totrans-717
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建`User`类，作为一个表格行模型（在`src/models/`目录中），它将包含一些相关功能（例如，检查输入密码与现有密码散列是否匹配）。
- en: Refactor the login handler to use the database as a data source for users.
  id: totrans-718
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 重构登录处理器，使其使用数据库作为用户的数据源。
- en: Refactor the profile handler to only fetch the user from the database and then
    send it to the template.
  id: totrans-719
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 重构用户资料处理器，使其仅从数据库中获取用户信息，然后将其发送到模板。
- en: Note
  id: totrans-720
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意
- en: The solution for this activity can be found on page 534.
  id: totrans-721
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 此活动的解决方案可以在第534页找到。
- en: Summary
  id: totrans-722
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: 'In this chapter, you learned how to handle files with PHP, which includes creating,
    writing, reading, and other filesystem-related operations. You also performed
    some basic, yet powerful, operations against a MySQL database server, creating
    a database structure and inserting, modifying, and deleting data. Although it
    might look a bit complex or overwhelming at the beginning, remember: it''s like
    riding a bike – once practiced enough, until you get comfortable with it, you
    will never forget it (and it will actually get you from point A to point B way
    faster). In the next chapter, we will cover the concept of error handling, which
    is essential to identify potential problems in an application, and prevent important
    details leaking out to your users in the form of nasty error messages.'
  id: totrans-723
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你学习了如何使用PHP处理文件，这包括创建、写入、读取以及其他与文件系统相关的操作。你还对MySQL数据库服务器执行了一些基本但强大的操作，创建了数据库结构，并插入、修改和删除数据。虽然一开始可能看起来有点复杂或令人不知所措，但请记住：这就像骑自行车一样——一旦练习得足够多，直到你感到舒适，你就永远不会忘记它（而且实际上它会让你从A点快速到达B点）。在下一章中，我们将介绍错误处理的概念，这对于识别应用程序中的潜在问题至关重要，并防止重要细节以令人讨厌的错误消息的形式泄露给用户。
