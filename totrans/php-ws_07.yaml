- en: 7\. Data Persistence
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Overview
  prefs: []
  type: TYPE_NORMAL
- en: By the end of this chapter, you will be able to perform filesystem-related operations
    (read, write, copy, move, and remove); read big files line by line and read CSV
    files one record at a time; download files via the browser using PHP; connect
    to MySQL RDBMS using PHP; create a database and a table, and insert records into
    a MySQL database using PHP; query, update, and delete data from MySQL DB using
    PHP; and secure MySQL queries using prepared statements in PHP.
  prefs: []
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapter, we saw how to deal with user input using PHP superglobals
    and applied sanitization and validation in order to secure the application. We
    also learned how to keep the user's session on the server and built a small application.
    In that application, we used the session to store data, which vanished with every
    session destroyed (or logout).
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will learn how we can store and read persistent data using
    PHP. Specifically, we will learn how to handle file I/O (open, read, and write)
    and disk operations (change the current directory, create a new file/directory,
    remove a file or directory, and so on). This is useful when you would like to
    use the filesystem for precious application logs, to generate all kinds of reports,
    to handle uploaded user images, and so on. We will also learn how to connect to
    a MySQL database and how to query the data, insert new records, and update or
    delete data from the database. This is helpful when you want to store data in
    a structured way, which can then be easily accessed by many other applications;
    for instance, user-specific data, such as a first name, a last name, an email
    address, and password hashes. And not only this – most probably, your application
    will perform data manipulation, on the data which will be stored somewhere to
    have it ready to read on request. This kind of data might represent elements of
    the business domain and could include product lists, prices, discount coupons,
    orders, subscriptions, and suchlike. We will deal with security in this chapter
    as well. Hence, we'll learn how we can protect our database against potentially
    malicious user input.
  prefs: []
  type: TYPE_NORMAL
- en: File I/O Handling
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Filesystem operations are some of the most important in programming. We can
    enumerate session data storage in PHP; user-uploaded files, generated report files,
    cached data, logs – all of them utilize the filesystem. Of course, there are many
    other alternatives for persistent storage, but knowing how to operate the filesystem
    in a language is especially important due to its availability. It is basically
    present anywhere and can be used immediately.
  prefs: []
  type: TYPE_NORMAL
- en: Working with the filesystem, sometimes, you might want to read or write into
    a file that is stored in a known location relative to the script file location.
    For example, for a script that is created in the `/app/demo/` directory that wants
    to read files from `source/` relative to its location (in other words, `/app/demo/source/`),
    it would be better to know the script location.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is different to the current working directory, because you may run the
    script from other locations as well. For example, if the current working directory
    is `/root`, you can run the script providing one of the following is present:
    the relative path, `php ../app/demo/the-script.php`, or the absolute path, `php
    /app/demo/the-script.php`. In this case, the current working directory is `/root`,
    while the script directory is `/app/demo`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'This leads to the next point. PHP offers some "magic constants"; values of
    which change across the scripts depending on where are they used. The list of
    magic constants is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.1: Magic constants and their descriptions'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/C14196_07_01.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 7.1: Magic constants and their descriptions'
  prefs: []
  type: TYPE_NORMAL
- en: In our case, we would want to make use of the `__DIR__` constant in the script.
    The directory the script would have to look into would be `$lookupDir = __DIR__
    . '/source';`.
  prefs: []
  type: TYPE_NORMAL
- en: Reading Files with PHP
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Dealing with files in PHP is one of the easiest things to do. PHP has several
    functions to handle file operations for creating, reading, and updating/editing.
    No additional installation is needed to use PHP filesystem functions.
  prefs: []
  type: TYPE_NORMAL
- en: A Simple File Read
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'One of the simplest functions to use for reading a file is `file_get_contents()`.
    This function can be used to fetch all the content of a file and put it into a
    variable, for example. The syntax is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: '`$filename`: The first argument is required and should be a valid file path
    to read from.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`use_include_path`: This is optional and tells `file_get_contents` to look
    for `$Filename` in the `include_path` list of directories.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`$context`: This is optional and is a valid context resource created with `stream_context_create()`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`$offset`: This is optional. The offset count begins on the original stream.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`$maxlen`: This is an optional argument and denotes the maximum length of the
    data that is to be read. By default, it reads until the end of the file.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `file_get_contents()` function reads the file content into memory before
    giving any output, until the entire file has been read. This is a drawback that
    makes this function unsuitable for use when the input file size is not known.
    In the case of large files, let's say in excess of 1 GB, the PHP process would
    very quickly fill the allocated RAM memory, and this would make the script crash.
    Therefore, this function is only suitable for use when the expected file size
    is smaller than the `memory_limit` configuration entry in PHP.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 7.1: A Simple File Read (All at Once)'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let's say you are required to develop a script that will be able to import a
    short list of users from a CSV format file into a current application.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, let''s prepare the environment:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a `sample` directory in the current working directory.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Download the CSV file called `users_list.csv` from the code repository and put
    it into the `sample` directory.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In this exercise, we will invoke `file_get_contents()` by providing the path
    to the CSV file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We are invoking the `file_get_contents()` function, specifying the file path,
    and what we are receiving is the full file content. For the file path, we are
    using the `__DIR__` magic constant, which gets replaced with the file directory
    path at compile time.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Save the preceding PHP script in a file called `file_get_contents.php` in the
    parent directory of the `sample` directory.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Run `php file_get_contents.php` in your Terminal:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 7.2: Printing contents of the file'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/C14196_07_02.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 7.2: Printing contents of the file'
  prefs: []
  type: TYPE_NORMAL
- en: You will get the CSV file output, as above.
  prefs: []
  type: TYPE_NORMAL
- en: Reading Files with the fread Function
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As discussed previously, the `file_get_contents()` function is not suitable
    for use on large files, since the entire file content is first read into memory,
    before any output, which would make the script very inefficient in terms of resource
    usage, as well as in terms of performance.
  prefs: []
  type: TYPE_NORMAL
- en: In the following exercise, we will explore some functions that will allow us
    to parse large files, keeping the system memory safe. This means we will use a
    technique that will allow us to read chunks of the file content at a time, which
    can be achieved using a group of PHP built-in functions, and a data stream PHP
    *resource*. A resource in PHP is a reference to the external resource; in our
    case, it will be a reference to a data stream resource (for example, a system
    file, or a URL).
  prefs: []
  type: TYPE_NORMAL
- en: '`fopen()` is one of PHP''s built-in functions, used to create stream resources
    in PHP. To achieve greater flexibility with regard to working with files (or any
    other data stream), we will use the `fopen()` function. The `fopen()` function
    accepts two required arguments, `$filename` being the first argument, and the
    access mode being the second one. The access mode describes the stream resource
    access type (read, write, read and write) and resolves to a set of instructions
    while creating the stream. It can have one of the following values:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/C14196_07_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 7.3: Different access modes and their descriptions'
  prefs: []
  type: TYPE_NORMAL
- en: You will notice the "file pointer" concept in the preceding table. You can think
    about this simple yet powerful concept in the same way as the cursor in a text
    file. So, for example, if we deal with the stream resource of a file with the
    `Learning PHP fundamentals` content, having the file pointer on position nine
    means it is located right before the word PHP. Reading the stream from that position
    until the end would result in the `PHP fundamentals` output.
  prefs: []
  type: TYPE_NORMAL
- en: The `fopen()` function returns a file pointer resource or `false` if the operation
    fails.
  prefs: []
  type: TYPE_NORMAL
- en: To read from the data stream, we will use the `fread()` function. This function
    requires two parameters, a resource variable being the first, and the length of
    bytes to read. It returns the read string or Boolean as `false` in the event of
    failure.
  prefs: []
  type: TYPE_NORMAL
- en: Other functions that can be used to read from stream resources are `fgets()`
    and `fgetcsv()`, to name a couple. `fgets()` returns a line from the file pointer;
    it requires the stream resource as the first parameter and accepts the optional
    read length (bytes) as the second parameter. `fgetcsv()` is similar to `fgets()`
    – it returns a line of data as an array containing the read CSV fields, except
    this line is parsed data as CSV (meaning more than one line of string data might
    be read, since one CSV field can contain multiline data). The `fgetcsv()` function
    accepts several parameters, but the required stream resource (the first parameter)
    is often enough to do a good job of parsing and returning CSV line data.
  prefs: []
  type: TYPE_NORMAL
- en: While reading from a stream, we might want to know when the end-of-file is hit.
    We can use the `feof()` function for this, which will test for the file pointer's
    presence at the end of the file (EOF). This function returns `true` if the file
    pointer is at EOF or errors occurred. It returns `false` otherwise.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: '`feof()` returns `false` for invalid streams as well, so it is recommended
    to test your stream resource before invoking `feof()`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 7.2: Reading Files with the fread Function'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s suppose you are asked to optimize your user''s import script in order
    to work with large data files of the magnitude of tens of gigabytes:'
  prefs: []
  type: TYPE_NORMAL
- en: Create an `fread.php` file and insert the following content.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'First, we define the file path, and then use it when calling `fopen()` to get
    the file pointer resource. We check whether `fopen()` has returned the expected
    resource (not `false`). In the case of failure, the script will exit:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Now, we will make use of the `fread()` function, which will read the file in
    chunks, allowing us to operate on small chunks of data in turn until the file
    is read completely. Next, we define the length to read, in bytes.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Read from the `$fileResource` resource using `fread()` and test for EOF with
    `feof()` in the `while` loop:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Finally, we close the file pointer resource, as we no longer need it, and print
    the number of iterations:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Run the file in your Terminal using the `php fread.php` command. The output
    will be as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 7.4: File output using fread file()'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/C14196_07_04.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 7.4: File output using fread file()'
  prefs: []
  type: TYPE_NORMAL
- en: Since the file contains 65 characters and the chunk size was set to 64, the
    file was read twice. This means that, at the first iteration, `fread()` filled
    the memory with 64 bytes of data that was then returned and the occupied memory
    was freed; at the second iteration, `fread()` filled the memory with 1 byte (the
    remaining file content) before it returned this and freed the memory. The advantages
    of this approach are that we can operate with small pieces of content at a time,
    at each read iteration, using a small amount of memory resources, rather than
    loading the whole file in memory and then iterating and processing content line
    by line.
  prefs: []
  type: TYPE_NORMAL
- en: Benchmark File Reading
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In previous examples, we saw the difference between the two approaches to reading
    a file, but here, you will evaluate metrics to benchmark each of the file reading
    methods.
  prefs: []
  type: TYPE_NORMAL
- en: We will use the same scripts but will add a number of measurements.
  prefs: []
  type: TYPE_NORMAL
- en: We will make use of the `memory_get_peak_usage()` function to retrieve the peak
    memory usage at some point, as the name suggests. This function accepts one optional
    argument, set to `false` by default when its value is not specified; you should
    set it to `true` when you want the allocated memory to be reported (which we will
    do in the following exercises), rather than the actual memory usage.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following exercises, we will make use of the `DIRECTORY_SEPARATOR` constant,
    which exists in PHP implicitly, and which is set with the directory separator
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Windows: the "\" character'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Non-Windows: the "/" character'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Exercise 7.3: Benchmark File Reading'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this exercise, we will evaluate metrics to benchmark each of the file reading
    methods:'
  prefs: []
  type: TYPE_NORMAL
- en: First, we will need a pretty big file, and we will generate it with the `dd`
    command.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`dd` is a command-line utility for Unix and Unix-like operating systems that
    exists in any of these distributions.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Run the following command to generate a file in `sample/test-256-mb.txt` that
    is full of zeroes, 256 MB in size:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This file will most likely terminate the script that uses `file_get_contents()`
    to read it, since most PHP installations, by default, do not allow a memory limit
    of more than 128 MB per process. This limit is stored in the `php.ini` configuration
    file by default, under the `memory_limit` parameter, as previously indicated.
    Hence, we will create another file, 10 MB in size, using `dd if=/dev/zero of=sample/test-10-mb.txt
    count=1024 bs=10240`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Create `file_get_contents-memory.php` with the following content:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Here, we are making use of the first command-line argument (`$argv[1]`), which
    will be the file path to read, relative to the script path. We are adding the
    memory peak metric as well, using the `memory_get_peak_usage()` function.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Run the following command to check the resource usage:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'You should essentially get the following output:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: We have used the `time` Linux command here, which will run the command and print
    the resource usage.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The memory value of 12.01 MB in this example output is reported by the `memory_get_peak_usage()`
    function and it shows us that this is the RAM memory amount necessary for a PHP
    script to read a 10 MB file.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Let''s now run the same script, but for the bigger file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In the output, we will see an error message like this:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: As expected, trying to read a 256 MB file into memory fails because the limit
    of 128 MB per process is exceeded.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Now, let''s check the other approach, using `fread()` to read chunks of data
    from the file one at a time. Create a file called `fread-memory.php` and insert
    the following content. We store the `$filePath` variable based on the user''s
    first input argument and we create the resource for that file path, stored under
    the `$fileResource` variable:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'If the resource is invalid, the script will be terminated:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We store the second input argument in the `$readLength` variable, which will
    take the value of the second input argument, with a fallback to `4096` if the
    second argument is not present. This is the length in bytes that the `fread()`
    function will use to read from `$fileResource`. We also initiate the `$iterations`
    variable with a start value of zero:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We read the entire file using the `while` loop, as in the previous exercise.
    The difference here is that the output of the `fread()` function is not used.
    For each iteration, we increment the `$iterations` variable as well:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Finally, we close the stream and print the number of iterations performed and
    the memory usage necessary to read the file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: What has changed from the previous `file_get_contents-memory.php` script is
    that we are reading chunks of data one at a time from the file, using the `$readLength`
    variable.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Now, let''s run some tests, reading the 10 MB file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: As we can see, to read the entire 10 MB file, it took 2,561 read iterations
    of 4 KB (the second `script` argument is missing, and the default 4,096 bytes
    are set for the `$readLength` variable). The total duration of the script was
    0.05 seconds, compared to 0.03 seconds when using `file_get_contents()`. The main
    difference to note is the memory usage – 2 MB, which is the minimum the PHP script
    allocates per process, compared to 12.01 MB when using the `file_get_contents()`
    function.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'What about reading a chunk of 1 MB instead of the default 4 KB? Let''s run
    the following command with 1,048,576 bytes (which are the equivalent of 1 MB):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The output is now as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Now, the entire 10 MB file read used only 11 iterations, with a peak of 4 MB
    of RAM memory. This time, the script took 0.03 seconds, as in the case of using
    the `file_get_contents()` function.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'And now, let''s read the big file, which could not be read using `file_get_contents()`.
    Run the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In this case, the read length is 4 KB, and the complete file read required 65,537
    iterations, using a peak of 2 MB of memory. The script took 0.3 seconds to read
    the entire file, which is not bad, but could be improved by increasing the read
    length to a bigger value; and this is what we will do in the next step.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Now, run the same command, specifying the chunk size of 1 MB:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The output is now this:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: As expected, the time needed to read the entire 256 MB file decreased (from
    0.3 seconds to 0.08 seconds), since the read length is higher (1 MB versus 4 KB,
    resulting in peak memory usage of 4 MB versus 2 MB), and the number of iterations
    required decreased to 257.
  prefs: []
  type: TYPE_NORMAL
- en: Now, having a look at this data, we can come up with our own ideas as to what
    is happening behind the scenes. In the case of `file_get_contents()`, a peak of
    12.01 MB memory is used reading the 10 MB file; that's because the whole file
    was loaded into memory using this approach. The 256 MB file caused the script
    shutdown because the limit of 128 MB was hit.
  prefs: []
  type: TYPE_NORMAL
- en: On the other hand, it seems the `fread` approach did pretty well, both in terms
    of duration and memory usage. Reading the 10 MB file in chunks of 4 KB, the script
    uses 2 MB of memory, compared to 12 MB in the case of `file_get_contents`, while
    the read time is significantly bigger (0.05 for `fread()` versus 0.03 for `file_get_contents()`).
    Reading the same file though, but in chunks of 1 MB, we get similar results in
    terms of performance, but we still use much less memory than in the case of `file_get_contents`
    (4 MB versus 12 MB).
  prefs: []
  type: TYPE_NORMAL
- en: Now, what happens when we increase the scale a bit? Reading the 256 MB file
    was not possible with `file_get_contents()` on account of exhausted memory. But
    look at the second approach – not only is the file read entirely but also, only
    2 MB of memory is used for this process! It takes about 0.3 seconds to read, which
    is not very satisfactory, but let's see what happens when the read length is increased
    and, therefore, the number of iterations is decreased. We get much better results
    now – a read time of 0.08 seconds and a memory peak of 4 MB.
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, the convenient way – using `file_get_contents()` – is more suitable
    for small or very small files, whereas dealing with large files requires you to
    use different approaches, such as `fread()`, which reads chunks of data; `fgets()`,
    which gets an entire line at a time from the file pointer; and `fgetcsv()`, which
    is similar to `fgets()` but, in addition, parses the CSV string line into an array
    with data.
  prefs: []
  type: TYPE_NORMAL
- en: Reading Files Line by Line
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As indicated earlier, there are more ways to perform optimized reading from
    big files. In the following exercise, you will learn how to use PHP to read a
    file line by line. This helps especially when one entry record corresponds to
    one line, as in access or error logs, for example, so that reading the file allows
    one data record to be processed at a time.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 7.4: Reading Files Line by Line'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this exercise, we will open a file and read it line by line:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a file called `fgets.php` and add the following content. As in the previous
    example, we define the file path and get the file pointer. In the event of failure,
    the script will exit with an error message:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, we initialize the `$lineNumber` variable with the value `0`. And then,
    as in the case of `fread()`, we perform iterations to read the data in slices.
    This time, using `fgets()`, we will get one line at a time. The line is then numbered
    and printed to output. At the end, we close the file resource pointer, since we
    no longer need it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Run the preceding script using the command-line tool, `php fgets.php`. The
    output will look like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: As you will notice, we have a line without content – that is actually an empty
    line in a CSV file. Please pay attention when dealing with file lines when trying
    to process data; check for a non-empty line at least before proceeding with processing.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Reading CSV Files
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The previous example shows a handy way to read one line at a time from a file.
    It turns out in our case that it's about a CSV file, a very simple one, with a
    comma as a delimiter, and that's pretty much it. But what if you have to deal
    with a complicated CSV document? Luckily, PHP provides a built-in function for
    that, called `fgetcsv()`. Using it, we can get one record at a time; that's right,
    one record, not one line, as the record can be spread over several lines, containing
    enclosed data (for example, multiline data wrapped between quotes).
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 7.5: Reading CSV Files'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this exercise, we will read the data from CSV files:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a file called `fgetcsv.php` and add the following content. As before,
    we declare the file path and get the file pointer. In the event of an error, the
    script will exit with an error message:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then, we initialize the `$recordNumber` variable with the value `0`; we will
    need it to print to output for each line. And we read one CSV record at a time
    using the `fgetcsv()` function, in a `while` loop, printing the record number
    and its content:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create a file called `users_list_enclosed.csv` inside the `sample/` directory
    with the following content:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Run the script with `php fgetcsv.php` and the output will look like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 7.5: Printing the arrays'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/C14196_07_05.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 7.5: Printing the arrays'
  prefs: []
  type: TYPE_NORMAL
- en: As you will notice, the `fgetcsv()` function does a very good job, parsing the
    CSV entries for us correctly. It does not matter whether the CSV content has a
    custom delimiter, enclosure, or escape character; all these parameters can be
    passed as function arguments to `fgetcsv()` to make the parser understand the
    format and perform the appropriate parsing
  prefs: []
  type: TYPE_NORMAL
- en: Downloading a File with PHP
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We saw how we can make the script read the files using a variety of means in
    order to allow us to *do something* with that content. But there is also downloading,
    when we need the file to be read by the script and sent back to the user, as a
    response to the HTTP request, and we don't want the PHP process to overload the
    memory by doing this, something along the lines of reading in chunks and sending
    the user small pieces at a time. Fortunately, there is a function for that, which
    is called `readfile()`. This function reads the file and writes it directly to
    the output buffer. The `readfile()` function requires only the file path to read
    from. The other optional arguments are a Boolean, which tells the function to
    search for the file in the `include_path` of PHP, and a context stream resource
    as a third argument.
  prefs: []
  type: TYPE_NORMAL
- en: A context stream is a set of options for a specific wrapper (a piece of code
    that builds other code) that modify or enhance the behavior of a stream. For example,
    when we want to read a remote file, using FTP, we pass the file path as the first
    argument of the `readfile()` function, and a valid FTP context stream variable
    as a third argument. We will not use context streams in the following exercises.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 7.6: Downloading a File'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this exercise, we will download a file and save it to the specified destination
    using PHP:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a file called `download.php` and insert the following content. First,
    we define the existing file path, and then proceed to set headers, where we make
    use of the `filesize()` function to return the file size in bytes for the file
    being downloaded, and `basename()`, which returns the last component of the path;
    in other words, it will cut the directory structure except for the file name.
    Finally, we call `readfile()` so that PHP can send the file back to the server
    and client, as a response to the HTTP request:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Make sure you have started the built-in server in this directory (which is `/app`
    in my case) running `php -S 127.0.0.1` in your Terminal, and that the file exists.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Then, access the script at `http://127.0.0.1:8080/download.php`. You should
    then see a pop-up box asking where to save the CSV file, or it will save the file
    automatically to a set destination, depending on your browser''s configuration:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 7.6: Downloading the CSV file'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/C14196_07_06.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 7.6: Downloading the CSV file'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: One should check whether the file exists on disk or not and treat each case
    accordingly. When the file is missing, `readfile()` will output nothing and the
    browser might receive the output of the PHP script (output of `download.php` in
    our case).
  prefs: []
  type: TYPE_NORMAL
- en: Writing a File with PHP
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Writing files with PHP is possible using a variety of methods, the majority
    involving the `fwrite()` and `file_put_contents()` built-in functions.
  prefs: []
  type: TYPE_NORMAL
- en: The `fwrite()` function accepts two required arguments, the first is the file
    pointer, and the second one is the string to write to the file. The function returns
    the number of bytes written or the Boolean `false` in the event of failure.
  prefs: []
  type: TYPE_NORMAL
- en: '`file_put_contents()` is the equivalent of calling the `fopen()`, `fwrite()`,
    and `fclose()` sequence.'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: When a file is written several times in a single PHP process, the `fwrite()`
    method is preferred, for performance reasons, since the stream resource is reused,
    and the file open and close operations (`fopen()` and `fclose()`) are avoided
    for each write as it happens with the `file_put_contents()` function. A good example
    of using `fwrite()` over `file_put_contents()` is the case of file loggers, when
    a PHP process might write several times in the same file during its lifetime.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first required argument is the filename, and the second one is the data
    to write to the file. The data can be a string, a resource stream, or a single
    dimension array of strings, rows of which are written in sequence. The third argument
    is optional and accepts the flags for a write operation. This can be any combination
    of the following values:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.7: Different flags for file_put_contents() function, and their descriptions'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/C14196_07_07.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 7.7: Different flags for file_put_contents() function, and their descriptions'
  prefs: []
  type: TYPE_NORMAL
- en: 'When using the `fwrite` method, we may want to use the same data stream resource
    to read from; for example, to move the pointer at the beginning of the file after
    writing, or to read the last N bytes of data. In this case, we would use the `fseek()`
    function. This function sets the file pointer (remember the cursor analogy before?)
    to a specific position. The function signature is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: The new position, measured in bytes, is obtained by adding an offset to the
    position specified by `$whence`.
  prefs: []
  type: TYPE_NORMAL
- en: '`$whence` values can be:'
  prefs: []
  type: TYPE_NORMAL
- en: '`SEEK_SET` – Sets the position of the file pointer equal to `offset` bytes.
    This is the default option if none was specified.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`SEEK_CUR` – Sets the position of the file pointer equal to the current location
    plus `offset`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`SEEK_END` – Sets the position of the file pointer equal to EOF plus `offset`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Exercise 7.7: Writing to Files'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In the following exercise, we will perform write operations in files using
    both of the `fwrite()` and `file_put_contents()` functions described previously:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a file called `write.php` and insert the following content:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: First, we define the file path to write to, and then we open the file pointer
    using the `fopen()` function.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Always make sure to have the directory structure created before trying to open
    or put content into a file. Following our example, you should make sure the `sample/`
    directory exists in the current working directory.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Next, we attempt to write to the file using the `fwrite()` function, storing
    the output in the `$written` variable:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: If the write fails (`$written` is the Boolean `false`), then we print an error
    message and continue the script. Otherwise, we print the success message, indicating
    the number of bytes written. After that, in order to read from the file, we move
    the pointer at the beginning of the file, at position zero, using the `fseek()`
    function. Then, we just print the file content to test the written data.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'To test the second approach, we define the `write-with-fpc.txt` file inside
    the `sample/` directory, and then call the `file_put_contents()` function in an
    attempt to write to the file, and store the output in the same `$written` variable:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'As in the previous example, if we failed to write to the file, then we print
    an error message and continue the script. In the case of a successful write, we
    print the message indicating the number of bytes written into the file followed
    by the actual file content:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The whole script can be referred at [https://packt.live/2MCkeOJ](https://packt.live/2MCkeOJ).
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Run the script from the command line with `php write.php`. The output should
    look like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 7.8: Writing into files using different methods'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/C14196_07_08.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 7.8: Writing into files using different methods'
  prefs: []
  type: TYPE_NORMAL
- en: In this exercise, we wrote string sequences in two different files using two
    different methods – `file_put_contents()` and `fwrite()`.
  prefs: []
  type: TYPE_NORMAL
- en: Congratulations! You just managed to write files using PHP.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 7.8: Appending Content in Files'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We have seen how it is possible to write fresh content in files, but often,
    you just want to add to an existing file – think about some sort of log, for example.
    In this exercise, you will learn how it is possible to append content to a file,
    using PHP:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a file called `write-append.php` and use the code from the previous
    exercise with two minor modifications. First, we want to change the `fopen()`
    mode, from `w+` to `a+` (from write and read to write-append and read):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add the third parameter to the `file_put_contents()` function – the `FILE_APPEND`
    constant:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Run the script from the command-line interface with `php write-append.php`
    and you will get the following result:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 7.9: Result of the script'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/C14196_07_09.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 7.9: Result of the script'
  prefs: []
  type: TYPE_NORMAL
- en: Running the script over and over again will print you the same success message,
    and, with each run, the number of sentences will increase in each file, due to
    the `append` instruction.
  prefs: []
  type: TYPE_NORMAL
- en: Appending content in files is very useful in the case of logging and generating
    content in files in order to perform further downloads, to name but a couple of
    use cases.
  prefs: []
  type: TYPE_NORMAL
- en: Other Filesystem Functions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: PHP offers generous support when it comes to handling filesystems. All of the
    functions can be explored at [https://packt.live/2MAsLmw](https://packt.live/2MAsLmw).
    In addition, we will cover some of the most widely used filesystem functions in
    PHP.
  prefs: []
  type: TYPE_NORMAL
- en: Deleting a File with PHP
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`unlink()` is the delete files function. It requires the file path as the first
    parameter and accepts an optional context stream. It returns `TRUE` if the file
    is deleted successfully, or `FALSE` otherwise.'
  prefs: []
  type: TYPE_NORMAL
- en: Before deleting a file, it is good to check first whether the file path points
    to an actual file, and, to achieve this, we can use the `is_file()` function.
    This function requires only the file path as the first parameter. It returns `TRUE`
    if a file is located and is a regular file, otherwise `FALSE`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 7.9: Deleting a File with PHP'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'When working with file content in PHP, it is highly likely that you will want
    to clean some older files. In this exercise, we will write code to delete a file
    using PHP:'
  prefs: []
  type: TYPE_NORMAL
- en: Create an empty file called `to-delete.txt` in the `sample/` directory. This
    is the file we will delete with PHP.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create a file called `delete.php`, and insert the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In this script, we check whether the file exists and is a regular file, using
    the `is_file()` function. In the case of a regular file, next, we test the file
    deletion; that is, the output of the `unlink()` function that is responsible for
    this, and then print the appropriate message based on the output. If the file
    does not exist, a message providing a notification of this will be printed.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Run the script in the command-line interface. With `php delete.php`, you will
    notice the following output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Running the script again will print the following:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This means the `delete` operation was indeed executed successfully.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: In this exercise, when running the script for the first time, all the conditions
    were met in order to run file deletion, and the file was indeed deleted. When
    running the script for the second time, the script cannot find the file for the
    specified path, so the script returns the `file does not exist` message immediately,
    prior to exiting.
  prefs: []
  type: TYPE_NORMAL
- en: Moving Files with PHP
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: On occasion, you may need to move files to a new location, for example, to the
    archive. This might be the case with a database data dump or log files, to name
    but two. PHP provides a function for moving functionality, called `rename()`,
    which requires the actual file path as a first argument, and the target file path
    as a second argument. This function returns `TRUE` if successful and `FALSE` in
    the event of failure, and can be used for both files and directories.
  prefs: []
  type: TYPE_NORMAL
- en: 'Sometimes, the target directory might not yet exist and, in these cases, it
    is supposed to be created with the script. There is a function for creating directories,
    called `mkdir()`, which accepts the following arguments: the directory path to
    create, the mode (which is `0777`, by default, meaning full permissions for any
    user), a recursive directory creation instruction, and the context resource.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 7.10: Creating Directories and Moving Files to the Archive'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this exercise, you will move a file to your local server, using PHP. Let''s
    say you are assigned the task of creating a script that will move generated log
    files to an "archive location," on a daily basis:'
  prefs: []
  type: TYPE_NORMAL
- en: Create an empty file called `to-move.txt`. This is the file we will move using
    PHP, considering it to be the generated log file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create a file called `move.php` and insert the following content. First, we
    define the file path to move and the target directory that the file should be
    moved to. Then, we check whether the file path exists and is a regular file and,
    in the event of failure, the script will print an error message and will stop
    the execution:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then, we check whether the target directory exists and is a directory, and
    if there''s no such directory, then we will try to create one. A message is printed
    in this regard, letting you know that the directory is being created. Then, the
    `mkdir()` function is used to create the target directory, in a recursive fashion
    (setting the third parameter to `true` will instruct the script to create any
    parent directory if it''s missing). If the action fails, then an error message
    is printed and the script stops the execution. Otherwise, the successful message,
    `Done`, is printed:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, we will define the target file path, and this will comprise the target
    directory and the file base name. Then, the `move` process is effected by using
    the `rename()` function. A message is printed for both a successful or a failed
    operation:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'The complete script file can be referred at : [https://packt.live/35wmDmK](https://packt.live/35wmDmK).'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Run the script in the command-line interface, with `php move.php`. The output,
    during the first run, should look like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Checking the file tree, you will notice that the file has indeed moved:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 7.10: Screenshot of the file tree'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/C14196_07_10.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 7.10: Screenshot of the file tree'
  prefs: []
  type: TYPE_NORMAL
- en: 'In addition to this, when running the script for the second time, you should
    get the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: In this exercise, you succeeded in moving a file from one location to another,
    using PHP with its built-in filesystem functions, validating the input as well,
    so as to make sure that you were not attempting to move a non-existent file.
  prefs: []
  type: TYPE_NORMAL
- en: Copying Files Using PHP
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Copying files is yet another straightforward task for which PHP offers support.
    The `copy()` function accepts two required arguments – the source file path and
    the destination path, and an optional one – the stream context. Using the `copy()`
    function is very useful in scenarios such as choosing your profile picture from
    a list of available pictures on the server (in this case, you want to leave the
    picture list intact, so you will only want to create a copy of the selected picture),
    or restoring files copied from a backup (again, you want to leave the original
    files intact, so `copy()` is again appropriate in this case).
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Using the `copy()` function, if the destination file exists already, it will
    be overwritten.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 7.11: Copying Files'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You are required to write a script that will copy specific files to a backup
    location. The copied files should have the `.bak` extension prepended:'
  prefs: []
  type: TYPE_NORMAL
- en: Create an empty file called `to-copy.txt` inside the `sample` directory.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create the `copy.php` file with the following content:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: First, we define the source and target file paths, and then check whether the
    source file exists. If the source file does not exist, an error message is printed
    and the execution of the script stops.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Next, we try to copy the file, using the `copy()` function. An appropriate
    message is printed, based on the `copy()` function response:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The complete script can be referred at [https://packt.live/2plXtXu](https://packt.live/2plXtXu).
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Run the file in the command-line interface, with `php copy.php`, and check
    the results; in the event of a successful `copy` operation, you should get the
    following output:![Figure 7.11: Copying file successfully'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/C14196_07_11.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Figure 7.11: Copying file successfully'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Change `$sourceFilePath` in the script to a non-existent file path (for example,
    `wrong-file-path.txt`) and run the script again. The output will be as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 7.12: Trying to copy a nonexistent file'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/C14196_07_12.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 7.12: Trying to copy a nonexistent file'
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, copying files with PHP turns out to be a pretty straightforward
    process.
  prefs: []
  type: TYPE_NORMAL
- en: In this exercise, you learned how to deal with files using PHP, starting with
    file create and write, and continuing with append, rewrite and delete, and copy
    and move, and then reading large files line by line and sending files to download.
  prefs: []
  type: TYPE_NORMAL
- en: Databases
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous section, we saw how we can use PHP to manipulate and store data
    in files. But when an application relies on structured data, it gets pretty complicated
    using the filesystem, especially when the application grows, and so does your
    data. Imagine a social media website, with tons of relationships between the data,
    including post comments, interests, friendships, groups, and a plethora of other
    linked data. Also, as your application grows, scalability is an important factor.
    This is when you want to use a database, to be able to query the data in different
    ways – ordered, filtered, partial data, combined data (joined), and, at the same
    time, in a very performant way. A **database management system** (**DBMS**) is
    used for performing operations on database data (create, read, update, and delete).
    Also, since different types of data are related to other data types in a database,
    you may want accuracy, consistency, and reliability for your data storage. In
    this case, you would prefer a relational DBMS.
  prefs: []
  type: TYPE_NORMAL
- en: MySQL is a **Relational Database Management System** (**RDBMS**) and is the
    most commonly used with PHP. It is very fast, reliable, easy to use (it uses **Structured
    Query Language** (**SQL**) queries), and it's free to use. It suits a wide range
    of applications, from small to large. It's very powerful, fast, secure, and scalable.
  prefs: []
  type: TYPE_NORMAL
- en: A MySQL database stores data in tables, just like any other relational database.
    A table is composed of related data, organized in rows (records) and columns (record
    fields).
  prefs: []
  type: TYPE_NORMAL
- en: PHP supports a wide variety of databases, such as MySQL, PostgreSQL, SQLite,
    MongoDB, MSSQL, and others, but, in this chapter, we will work with MySQL, as
    it's by far the most widely used database management system with PHP.
  prefs: []
  type: TYPE_NORMAL
- en: GUI Clients
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Often, graphical user interface (GUI or "desktop applications") clients are
    very useful when it comes to performing miscellaneous operations in a database,
    such as verifying data, altering tables or columns, exporting or importing data,
    and migrating a database.
  prefs: []
  type: TYPE_NORMAL
- en: 'For MySQL, three clients are recommended:'
  prefs: []
  type: TYPE_NORMAL
- en: 'MySQL Workbench: a desktop application; cross-platform; can be downloaded from
    [https://packt.live/32iaZd6](https://packt.live/32iaZd6)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'PhpMyAdmin: a browser application; can be downloaded from [https://packt.live/2McXnu9](https://packt.live/2McXnu9)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Adminer: a lightweight browser application; can be downloaded from [https://packt.live/35yBTzB](https://packt.live/35yBTzB)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In addition, for screenshots, I'll use Workbench to test the data in MySQL Server,
    but any of these tools could be used.
  prefs: []
  type: TYPE_NORMAL
- en: Connecting to MySQL
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To use MySQL Server with PHP, some extensions need to be installed. Usually,
    an extension is a component that exposes an `mysqli` and `PDO` extensions. These
    are very similar in terms of functionality and syntax, and, unless you need a
    specific feature from one of the extensions, choosing an extension to work with
    should not cause any difficulties. Just pick one.
  prefs: []
  type: TYPE_NORMAL
- en: Since PDO appears to be the most widely used option, we will pick this extension
    for further exercises.
  prefs: []
  type: TYPE_NORMAL
- en: '**PHP Data Objects** (**PDO**) is a lightweight and lean interface for accessing
    databases with PHP.'
  prefs: []
  type: TYPE_NORMAL
- en: To continue, make sure you have MySQL installed, as described in the preface.
    Furthermore, consider the MySQL server listening on `127.0.0.1`, port `3306`,
    with the username set to `php-user` and the password set as `php-pass`.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: For Windows OS, the database username php-user in code snippets for chapter
    7 will need to be replaced with php_user. This is because the Windows installer
    for MySQL does not allow hyphens in usernames.
  prefs: []
  type: TYPE_NORMAL
- en: Make sure you have the `PDO` extension and the `pdo_mysql` driver installed
    to facilitate the establishment of connections and send queries to the MySQL Server.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: The `pdo_mysql` driver is an extension that provides an interface to the aforementioned
    PDO extension. This driver is a component that makes communication with the MySQL
    Server possible, translating instructions between the two parties.
  prefs: []
  type: TYPE_NORMAL
- en: 'Checking for an enabled PHP extension in the Terminal is possible by running
    `php -m` to list all installed and enabled extensions or `php -m | grep -i pdo`
    to list only those entries that match the `pdo` string fragment. The latter should
    output these two entries:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/C14196_07_13.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 7.13: Checking for the enabled extensions'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: '`grep` is a Unix function that searches for text in files or in string input,
    and returns the matching lines in output by default. The `|` (pipe) token is used
    to forward the previous command''s output (`php -m`) to the next command, as input.'
  prefs: []
  type: TYPE_NORMAL
- en: In order to proceed further, let's create a new directory where we will write
    the database-related exercises (for example, `database`).
  prefs: []
  type: TYPE_NORMAL
- en: Connecting to MySQL
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Connections to MySQL are initiated by instantiating the PDO object. This accepts
    the database source (DSN) as the first argument, and optionally, the username,
    password, and PDO options, if required.
  prefs: []
  type: TYPE_NORMAL
- en: 'The syntax is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Data Source Name: `mysql:` followed by a list of key-value pairs separated
    by semicolons; these elements will be listed here.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'username: the username used to connect to the database.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'password: the password used to authenticate the username.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'options: an associative array of MySQL (driver-specific) connection options.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The DSN allows the following elements:'
  prefs: []
  type: TYPE_NORMAL
- en: 'host: the hostname where the database is located.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'port: the database server listens to this port number.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'dbname: the name of the database.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'charset: the character set for the connection (the data will be transferred
    using this character set).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'unix_socket: The MySQL Unix socket; to be used as an alternative to the host
    and port connection type.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By way of good practice, it is recommended to set the connection character set
    to `utf8mb4`; that will save you from further difficulties if you have to store
    and fetch UTF-8 characters using this connection (and you will have to, at some
    point).
  prefs: []
  type: TYPE_NORMAL
- en: One of the methods of the `PDO` class is `getAttribute()`, which returns a database
    connection attribute, such as server information and the connection status. The
    `PDO::getAttribute()` method requires and accepts only one parameter, the integer
    type; that is, one of the `PDO::ATTR_*` constants. For a complete list of PDO
    attributes and other constants, visit the official documentation page at [https://www.php.net/manual/en/pdo.constants.php](https://www.php.net/manual/en/pdo.constants.php).
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 7.12: Connecting to MySQL'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this exercise, you will connect to a MySQL server using PDO.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a file called `connect.php` and add the following content. In our script,
    we first define the DSN for our MySQL database, pointing the host to `127.0.0.1`
    and the port to `3306`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, we set the PDO options, under the `$options` variable, where we specify
    the fetch mode, to have all the records fetched as an associative array by default.
    We would also want to set the error mode to `Exceptions`, to make it easier to
    handle query errors, but for now, we will make use of the `PDO::errorCode()` and
    `PDO::errorInfo()` methods:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: We will learn about exceptions and error handling in the next chapter.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'In the next line, we invoke the `PDO` object, thereby creating a connection
    to the database, using the DSN defined previously, the username, password, and
    the aforementioned `PDO` option. If the connection is unsuccessful, an exception
    will be thrown (of the `PDOException` type) and the execution of the script will
    stop:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In the final step, we want to print the connection info, using the `PDO::getAttribute()`
    method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Run the file in the command-line interface with `php connect.php`. When the
    connection is successful, the output will look like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In the event of a connection failure, the output will look like this:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In the event of a connection failure, it would be better to treat the error
    and fall back gracefully to a nice-looking error page, providing a user-friendly
    error message. In this case, though, we will leave the script as it is now because
    PHP exceptions will be covered in the next chapter.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Here, you made a connection to MySQL, with a username and password, using PDO,
    and you set some options as well, for the `PDO` object. You also printed the server
    version and connection status, from the PDO connection attributes.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a Database
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now that we have learned how to establish a connection with a MySQL Server,
    let's move forward and see how we can create a database.
  prefs: []
  type: TYPE_NORMAL
- en: To do this, we will have to run SQL queries; this is where we get to use the
    `PDO` methods.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will invoke the `PDO::exec()` method to send the SQL queries to MySQL Server.
    It requires and accepts only one parameter: the SQL query string, and returns
    the Boolean `false` in the event of an error, or the number of affected rows in
    the event of success.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Warning: Since this function can return a Boolean `false` and also `0` (zero),
    which evaluates to `false`, make sure you use the `===` or `!==` operator when
    testing the result, so as to avoid false positives when checking for errors.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In the event of a query failure (`PDO::exec()` returns `false`), we may invoke
    the `PDO::errorInfo()` method to get the error codes and the error message. This
    method returns a numeric array containing the following data:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.14: Description of the type of data in the array returned by the
    PDO::errorInfo()'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/C14196_07_14.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 7.14: Description of the type of data in the array returned by the PDO::errorInfo()'
  prefs: []
  type: TYPE_NORMAL
- en: 'The query to run in order to create a new database has the following syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '`CREATE SCHEMA db_name`, where `db_name` should be replaced with the name of
    the database you want to create.'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: The `CREATE SCHEMA` string is an SQL statement. It can be executed in a SQL
    server using any SQL client. The syntax and more information can be found on the
    official documentation page at [https://packt.live/32ewQSK](https://packt.live/32ewQSK).
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 7.13: Creating a Database'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this exercise, we will create a database and run queries:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a file called `connection-no-db.php` and insert the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This is similar to what we did in the previous exercise, except that instead
    of printing the connection information, we return the `PDO` instance. In this
    file, we do not specify a database name, since we have not yet created one.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Create a file called `create-schema.php` and insert the following code. First,
    we require the `PDO` instance from the `connection-no-db.php` file we created
    previously:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then, we write our SQL query under the `$sql` variable, which will create a
    database with the name `demo`:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Run the query using the `PDO::exec()` method, and check for successful statement
    execution (the result is not a Boolean `false`). In the event of success, we print
    a simple success message. In the event of an error, we print the error message:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Run the code from the command-line interface with `php create-schema.php`.
    When running the code for the very first time, you will get the following output:![Figure
    7.15: Creating a schema successfully'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/C14196_07_15.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Figure 7.15: Creating a schema successfully'
  prefs: []
  type: TYPE_NORMAL
- en: 'Running the code successively, you will get the following error message:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.16: Error in creating the schema'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/C14196_07_16.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 7.16: Error in creating the schema'
  prefs: []
  type: TYPE_NORMAL
- en: In this exercise, you learned how we can create a database and how to test for
    the successful execution of the SQL statement, `CREATE SCHEMA`.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a Table
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let's now see how we can create a table that will actually hold the data in
    an organized way. We will use the `CREATE TABLE` SQL statement to achieve this.
    The syntax of this statement is more complex and also involves table column definitions.
  prefs: []
  type: TYPE_NORMAL
- en: 'Standard `CREATE TABLE` syntax is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'The parameters are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`tbl_name`: The table name to be created.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`col_name`: The column name.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`data_type`: The type of data the column holds, such as date, timestamp, integer,
    string, and JSON. More information can be found at [https://packt.live/32CWosP](https://packt.live/32CWosP).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`default_value`: The default value when the `insert` statement provides no
    data for this row column.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'A sample `CREATE TABLE` query can be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'In this statement, we point to the table name – `users`, with three columns,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`id`: An integer type; not null; a primary key with auto-incrementing; these
    constraints tell MySQL that the column is a primary key, meaning that it is unique
    in the table and will be used to identify unique records in the table. The `AUTO_INCREMENT`
    keyword tells MySQL that we want this value to be set automatically with an "auto-increment"
    value, which is the next higher integer after the last inserted record ID, when
    we do not specify it in our `INSERT` statements. This is helpful because we can
    execute `INSERT` statements without knowing which should be the next ID value.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`email`: A variable-length character type with a maximum length of 254; not
    null; and unique among the records. In respect to this rule, when inserting another
    record with the same "`email`" value, the statement will be rejected by MySQL
    Server and an error will be returned.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`signup_time`: A datetime type; defaulting to the current time; not null. Not
    specifying this value in the `insert` query will result in the current datetime
    value being set by MySQL Server.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Warning
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Be aware that the "current datetime" will be the value set using the MySQL Server
    time zone offset, which may differ from the application server. For example, when
    you deploy your application on a server from a data center that is located in
    a different time zone to yours, it is possible that the system time zone of the
    remote server is set to the local time zone offset. You may want to make sure
    that your server's settings do not apply time offset – using the UTC time zone,
    or you may want to use a timestamp value instead of a human-readable date.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: You can find the full syntax and more information at [https://packt.live/2MAGloG](https://packt.live/2MAGloG).
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 7.14: Creating the Table'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this exercise, we will learn how to select a database with PDO, and how
    to create a table using the `PDO` instance:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a file called `create-table.php` and insert the following code. What
    we do, after getting the `PDO` instance, is to define the `CREATE TABLE` statement:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'After executing the statement, in the event of failure, the error message will
    be printed and execution or the script will stop. Otherwise, a success message
    will be printed to output:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Run the script in the command-line interface with `php create-table.php`. Expect
    the following error output:![Figure 7.17: Error in creating the table'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/C14196_07_17.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Figure 7.17: Error in creating the table'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: We get an error message, indicating that no database is selected. What we understand
    from this statement is that a MySQL server can store several databases, and, when
    executing a statement, we should indicate the database we want to run it into.
    To achieve this, we should either include the database name inside the SQL statements
    (for example, `CREATE TABLE demo.users` ...) or specify the database name inside
    DSN, before creating the connection to MySQL Server.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Copy the `connection-no-db.php` file to `connection.php` and add the database
    name to DSN, inside the `connection.php` file. Replace the `$dsn` variable with
    the following value:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: We will require this `connection.php` file further, in all exercises, to reuse
    the code instead of typing this block of code in every file where we use the database
    connection.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Require the `connection.php` file in the `create-table.php` script, instead
    of `connection-no-db.php`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Let''s run our script once more: `php create-table.php`. Expect the following
    output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 7.18: Creating tables successfully'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/C14196_07_18.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 7.18: Creating tables successfully'
  prefs: []
  type: TYPE_NORMAL
- en: Great! You successfully created the first table in the `demo` database.
  prefs: []
  type: TYPE_NORMAL
- en: In this exercise, you learned how to select a database at connection time, and
    how to create a table in a SQL database. Notice that the queries begin with an
    action (`CREATE`) followed by the object type (schema/database or table), followed
    by the object definition where required. Also, you probably noticed that the column
    names are followed by the date type declaration (integer, string, date, and so
    on) and then by additional constraints (`NOT NULL`, `PRIMARY KEY`, `UNIQUE`, and
    so on).
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, SQL statements are pretty descriptive and easy to learn and
    remember. So, let's advance with more exciting examples!
  prefs: []
  type: TYPE_NORMAL
- en: Inserting Data into a MySQL Database Table
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Since we already know how to create a table in a MySQL database, let's add some
    data to it.
  prefs: []
  type: TYPE_NORMAL
- en: Before inserting data into a table, we must craft the script in such a way that
    the data to be inserted will match the table's column definition. This means we
    will not be able to store strings in a column defined with an integer data type.
    In such cases, MySQL Server will reject the query and will respond with an error.
    Also bear in mind, since most of the data will come from user input, that you
    should always validate it before sending it to a database server, and, at the
    same time, escape it properly, so as to avoid another security issue, called SQL
    injection, covered later in the chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'Standard `INSERT` statement syntax is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: 'Where `value_list` is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: The number of values specified in `value_list` should match the `col_name` count.
    The complete syntax of the `INSERT` statement can be found on the official documentation
    page at [https://packt.live/32fXkmP](https://packt.live/32fXkmP).
  prefs: []
  type: TYPE_NORMAL
- en: 'An example `INSERT` query may appear as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: In this case, two rows will be inserted in the `employees` table, setting the
    values from `VALUES` to the corresponding position column from the column list;
    for example, `john.smith@mail.com` is assigned to the `email` column, and the
    `John` value is assigned to the `first_name` column.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 7.15: Inserting Data into a Table'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this exercise, we will become familiar with the `INSERT` statement, learning
    how we can add data to a table:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a file called `insert.php`. After getting the `PDO` instance, we store
    the `INSERT` statement under the `$insertStmt` variable. This statement inserts
    the value `john.smith@mail.com` into the `email` column of the `users` table.
    We did not specify the ID value; therefore, it must be set automatically with
    the `auto_increment` value, which, for the first entry, would be `1`. We are also
    missing the `signup_time` column, which, by default, will set the time when the
    record was added. Add the following code to the `insert.php` file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'If the statement execution fails, the script will print the error message and
    will not continue further; otherwise, the success message will be printed, including
    the ID of the row that was just inserted, using the `PDO::lastInsertId()` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Run the script with `php insert.php`. The first output will be as follows:![Figure
    7.19: Inserting a record into the table'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/C14196_07_19.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Figure 7.19: Inserting a record into the table'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Run the script once more. Now, you should expect the following response in
    the output:![Figure 7.20: Duplicate entry error'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/C14196_07_20.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Figure 7.20: Duplicate entry error'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: This proves that the previous script execution succeeded, and that the `UNIQUE`
    constraint in the email column is working as expected.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Let''s now look at the data in the `users` table, using the Workbench client:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 7.21: Checking the data in DB using the Workbench client'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/C14196_07_21.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 7.21: Checking the data in DB using the Workbench client'
  prefs: []
  type: TYPE_NORMAL
- en: As expected, we have a single row, with `id = 1`, `john.smith@mail.com` for
    the `email` column, and the signup time set by MySQL Server at the time of the
    row insertion.
  prefs: []
  type: TYPE_NORMAL
- en: Congratulations on adding in the initial data to a database table! It was pretty
    easy. Now, knowing that we should work with user input, we must ensure that the
    script will run the queries in complete safety, avoiding SQL injection, which
    may lead to data leaks and system compromise.
  prefs: []
  type: TYPE_NORMAL
- en: SQL Injection
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: So, what is SQL injection anyway? SQL injection is one of the most common vulnerabilities
    in the wild web nowadays. It is a technique used to steal data, gain control of
    users' accounts, or destroy a database, and is performed by sending malicious
    query chunks via HTML form inputs.
  prefs: []
  type: TYPE_NORMAL
- en: 'To better understand this, here is a simple example of how you can drop a table
    using the SQL injection technique, given a query that accepts user input without
    sanitizing and/or validating it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: 'When the email input value is `""); DROP TABLE users; /**`, then the query
    will become:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: What happens is easy to understand; the `INSERT` statement is executed, adding
    an empty value to the `email` column, and then the query to drop the table is
    executed, making the `users` table vanish, while the `/**)` part is ignored, since
    `/**` marks the beginning of a comment in a SQL query.
  prefs: []
  type: TYPE_NORMAL
- en: Prepared Statements
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In order to prevent SQL injection, we should escape the input data. PDO offers
    an alternative –so-called `prepared statements` (the `PDOStatement` class). These
    statements are templates and look like regular SQL queries, with the difference
    that, instead of values, they contain placeholders, which will be replaced with
    escaped values at execution time. The placeholders' mapping is done using the
    `PDOStatement::bindParam()` method, or by providing the mapping at execution time,
    as an argument of the `PDOStatement::execute()` method.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two types of placeholders:'
  prefs: []
  type: TYPE_NORMAL
- en: Positional placeholders, `?`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Query example:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Named placeholders, with names prepended with a colon, `:`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Query example:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The use of prepared statements offers major benefits:'
  prefs: []
  type: TYPE_NORMAL
- en: The parameters of prepared statements should not be quoted, as this is handled
    by PDO automatically, while it will also handle the escaping of values when necessary.
    This means that you can be sure that no SQL injection is possible using prepared
    statements with placeholders.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The query is sent and parsed only once by MySQL Server, meaning that the same
    statement can be executed many times, sending only the placeholders' data. This
    results in faster execution times and lower bandwidth usage.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: By default, PDO will emulate prepared statements as support for databases that
    don't have this feature and, if you want to benefit from genuine prepared statements
    in MySQL Server, you should set `PDO::ATTR_EMULATE_PREPARES` to `false` in the
    connection options.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Emulating prepared statements means that the query will not be sent to the server
    and checked when `PDO::prepare()` is invoked. Instead, PDO will escape the bind
    parameters from `PDO::execute()`, and will make the placeholders' replacements
    on its own. Then, the raw SQL query is sent to the database server, meaning that,
    this way, you do not benefit from performance optimizations that the database
    could carry out when using prepared statements that are then executed many times.
  prefs: []
  type: TYPE_NORMAL
- en: Using Prepared Statements
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To obtain a prepared statement, you must invoke the `PDO::prepare()` method,
    providing the statement as a first argument. The output is an instance of the
    `PDOStatement` class (the prepared statement), which is then used to bind parameters'
    values and execute the statement.
  prefs: []
  type: TYPE_NORMAL
- en: '`PDO::bindParam()` is used to bind prepared statements'' parameters, and has
    the following syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: 'Accepted input parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '`parameter`: The parameter identifier; for a prepared statement using named
    placeholders, this will be a parameter name of the form `:name`. For a prepared
    statement using question mark placeholders, this will be the one-indexed position
    of the parameter.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`variable`: The name of the PHP variable to bind to the SQL statement parameter;
    be aware that this parameter is passed by reference, meaning that if we modify
    the variable before we execute the statement, the new value will be sent to the
    server when `PDO::execute()` is invoked.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`data_type`: The data type for the parameter using the `PDO::PARAM_*` constants;
    for example, `PDO::PARAM_INT`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`length`: The length of the data type. To indicate that a parameter is an `OUT`
    parameter from a stored procedure, you must explicitly set the length.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`driver_options`: Self-explanatory.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `PDO::bindParam()` method returns `true` if successful, otherwise `false`.
  prefs: []
  type: TYPE_NORMAL
- en: 'To execute the prepared statement, use the `PDO::execute()` method. The syntax
    is the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: The only accepted parameter is an optional `$input_parameters` array with values
    for the statement placeholders. All values of the array are treated as `PDO::PARAM_STR`.
  prefs: []
  type: TYPE_NORMAL
- en: This method returns `true` if successful, otherwise `false`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is a sample query using a prepared statement with positional
    placeholders:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: 'Or it can be written as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is a sample query using a prepared statement with named placeholders:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: 'Or it could be written as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: Notice that the `$email` variable is assigned to the `:email` placeholder only
    once, while its data changes twice, each change being followed by the execution
    of the statement. Each statement will send the current value of the `$email` variable,
    at that point of execution, this being possible as a result of using the variable
    reference in the `PDO::bindParam()` method, rather than passing the variable by
    value.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 7.16: Inserting Data Using Prepared Statements'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this exercise, you will create a script that inserts new user emails from
    user input, using prepared statements:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a file called `insert-prepared.php` and add the following code. As before,
    we get the `PDO` instance, and then its `prepare()` method, providing the query
    template. In return, we get an instance of `PDOStatement`, which we store in the
    `$insertStmt` variable:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then, we invoke the `execute()` method of `PDOStatement`, providing the placeholder-value
    map. In this case, the value will be the first argument provided to the script
    at execution time. We check the result and, if unsuccessful, an error message
    is printed and the execution of the script stops. Otherwise, a successful message
    is printed:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Run the script with `php insert-prepared.php john.smith@mail.com`. The output
    should be as follows:![Figure 7.22: Duplicate entry error'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/C14196_07_22.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Figure 7.22: Duplicate entry error'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: This is an expected error, because we have already added this email before,
    and the `UNIQUE` keyword ensures that no other entries will be added that have
    the same email address. For a table definition, please refer to *Exercise 7.14*,
    *Creating the Table*.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Run the script with `php insert-prepared.php jane.smith@mail.com`. This time,
    you should expect an output message similar to this:![Figure 7.23: Record inserted'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/C14196_07_23.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Figure 7.23: Record inserted'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Let''s check the records using Workbench:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 7.24: Records displayed by Workbench'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '](img/C14196_07_24.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Figure 7.24: Records displayed by Workbench'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: It looks good. You have successfully run a prepared statement with PDO. You
    will notice that the ID of `jane.smith@mail.com` is not `2`, but `5`. This is
    because the prepared statements that ran before, even the failed ones, increased
    the `AUTO_INCREMENT` value.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Let''s check the protection against SQL injection by running the script that
    includes the malicious query chunk:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The output is similar to this:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 7.25: Record inserted'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/C14196_07_25.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 7.25: Record inserted'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s check the results using Workbench:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.26: Displaying all records with the Workbench client'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/C14196_07_26.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 7.26: Displaying all records with the Workbench client'
  prefs: []
  type: TYPE_NORMAL
- en: They look good. We are protected against SQL injection, but ended up with corrupt
    data, since the input was not validated nor sanitized before the query ran. Please
    refer to the *Sanitizing and Validating the User Input* section of *Chapter 6*,
    *Using HTTP*.
  prefs: []
  type: TYPE_NORMAL
- en: Fetching Data from MySQL
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: So far, you have learned how to create a database and a table, and also how
    to insert data into tables, in a secure manner. Now, it's time to fetch and display
    some data using PHP.
  prefs: []
  type: TYPE_NORMAL
- en: 'To accomplish this, we use the `SELECT` statement, which has the following
    minimal syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding query would return all the records from the table since no limitation
    is set. It is therefore recommended (if not mandatory in some cases) to use the
    `LIMIT` clause in one of its forms:'
  prefs: []
  type: TYPE_NORMAL
- en: '`LIMIT row_count`: will return the first `row_count` rows'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`LIMIT offset`, `row_count`: will return `row_count` rows starting with the
    `offset` position (for example, `LIMIT 20, 10` will return `10` rows starting
    with position `20`; another example, `LIMIT 0, 10` is equivalent to `LIMIT 10`,
    since the offset is zero by default)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`LIMIT row_count OFFSET` `offset`: identical to `LIMIT` `offset`, `row_count`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A part of the `LIMIT` clause, the `SELECT` statement is rich in clauses that
    can be used to filter, join, group, or sort data. You can check the `SELECT` statement
    syntax of the official documentation page at [https://dev.mysql.com/doc/refman/5.7/en/select.html](https://dev.mysql.com/doc/refman/5.7/en/select.html).
  prefs: []
  type: TYPE_NORMAL
- en: 'A very simple `SELECT` statement looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: This statement queries the first 10 records from the `employees` table.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Using an asterisk, `*`, instead of column names in `SELECT` statements will
    make MySQL perform an additional lookup query to retrieve the column list of the
    queried table, and replace the `*` in the original query with this list of columns.
    This has a performance impact on SQL queries, which is not significant for low-traffic
    applications; yet it is considered good practice to specify the column list instead
    of `*`, irrespective of the project size or the estimated traffic load.
  prefs: []
  type: TYPE_NORMAL
- en: Now, let's examine, step by step, how we can get the data we want from a MySQL
    database, using various examples.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 7.17: Fetching Data from MySQL'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this exercise, you will learn how you can query data from a MySQL database
    in the most simplistic way, getting a slice of records in the result set, filtering
    the data, and ordering the data by a specific column:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create the `select-all.php` file and add the following code. We get the `PDO`
    instance and store the `SELECT` query in the `$statement` variable. Then, we invoke
    the `query()` method of the `PDO` object instance, and will either get as output
    a Boolean `false`, in the event of failure, or an instance of `PDOStatement` if
    successful:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In the event of a query failure, we print the error message and interrupt the
    script execution. Otherwise, we print the `All records` line and iterate over
    all the result set records and print them, joining the record data using the tab
    delimiter:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE87]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We repeat the operation with a slightly modified query, adding the `LIMIT`
    clause (and, without checking for query failure anymore), and we then print the
    `Use LIMIT 2` line followed by all the records in the result set:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE88]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We run another query, using the `WHERE` clause to filter the result set and
    only return the records with an ID value greater than `3`. Then, we print the
    `Use WHERE id > 3` line followed by all the records in the result set:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE89]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Lastly, we run one more query, using the `ORDER BY` clause to sort the output
    by the `id` column in descending order. We print the `Use ORDER BY id DESC` line,
    followed by all the records in the result set:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE90]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The final file can be referred at [https://packt.live/31daUWP](https://packt.live/31daUWP).
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Run the script with `php select-all.php`. Expect the following output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 7.27: Fetching the records using different conditions'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/C14196_07_27.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 7.27: Fetching the records using different conditions'
  prefs: []
  type: TYPE_NORMAL
- en: 'Congratulations! You successfully fetched data from the MySQL database in different
    ways: sorting, filtering, and slicing the entire data in the table.'
  prefs: []
  type: TYPE_NORMAL
- en: By now, we have got a glimpse into the power of a database. This is just the
    beginning.
  prefs: []
  type: TYPE_NORMAL
- en: Updating Records in MySQL
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To update records in MySQL, the `UPDATE` statement is used. This is usually
    used together with the `WHILE` clause to filter the rows to which the update is
    applied.
  prefs: []
  type: TYPE_NORMAL
- en: Warning
  prefs: []
  type: TYPE_NORMAL
- en: Not using `WHERE` in an `UPDATE` statement will cause the update to apply to
    all records in the table.
  prefs: []
  type: TYPE_NORMAL
- en: The `PDOStatement::rowCount()` method returns the number of rows affected by
    the last `INSERT`, `UPDATE`, or `DELETE` statement executed by the corresponding
    `PDOStatement` object.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 7.18: Updating Records in MySQL'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this exercise, you will learn how to perform an update to a MySQL database
    `users` table, setting the email `john.doe@mail.com` for a record with incorrect
    data in the email column (ID 6 in our case):'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a file called `update.php` and add the following code. First, we get
    the `PDO` instance and update parameters. We need the record `id`, which has to
    be updated, and this value will be retrieved from the first input argument of
    the script, defaulting to `0` (zero). We also need the updated value for the `email`
    column, which will be retrieved from the second input argument of the script.
    Note that these values can be retrieved from the `$_POST` superglobal, when the
    update action is performed using an HTML form in a web page:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE91]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then, we prepare the `UPDATE` statement using two placeholders – `id` and `email`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE92]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We execute the `UPDATE` statement, providing the placeholders'' values map
    in an argument, and test the result; if unsuccessful, the error message will be
    displayed and the script will return (ending the execution). Otherwise, the success
    message is displayed:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE93]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Run the script with `php update.php 6 john.doe@mail.com` and check the result.
    The expected output is as follows:![Figure 7.28: Updating a record'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/C14196_07_28.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Figure 7.28: Updating a record'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Let''s check the result in Workbench:![Figure 7.29: Displaying database table
    data using the Workbench client'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/C14196_07_29.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Figure 7.29: Displaying database table data using the Workbench client'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The email for the record with the `id` 6 was changed to the value provided.
    It looks great! Note that if you have another `id` for the record with incorrect
    data in the `email` field, then you should use that `id` in *step 2* when running
    the command.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Now, let''s see what happens when we run the `UPDATE` query for an `ID` that
    does not exist:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE94]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Expect the following output:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 7.30: Output of the UPDATE query'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/C14196_07_30.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 7.30: Output of the UPDATE query'
  prefs: []
  type: TYPE_NORMAL
- en: 'We end up with no row being affected by this query, and the logic seems pretty
    straightforward: the `UPDATE` statement filters the rows to update, using the
    conditions from the `WHERE` clause; in our case, filtering by `id=16` resulted
    in no rows qualifying for an update.'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Trying to update a record column value with the same, identical value will result
    in no count for the affected row aggregation; in other words, `PDOStatement::rowCount()`
    will return `0` (zero).
  prefs: []
  type: TYPE_NORMAL
- en: Deleting Records from MySQL
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To delete records from MySQL, we should use the `DELETE` statement. This is
    often (if not always) used together with the `WHERE` clause to indicate matching
    records to delete.
  prefs: []
  type: TYPE_NORMAL
- en: Warning
  prefs: []
  type: TYPE_NORMAL
- en: Failure to provide the `WHERE` clause in a `DELETE` statement will cause all
    records to be deleted from the table.
  prefs: []
  type: TYPE_NORMAL
- en: 'Usually, in the `WHERE` clause of a `DELETE` statement, the id columns are
    used. This is the case when a precisely indicated row is deleted. But the `WHERE`
    clause can be used to its full potential in `DELETE` statements as well. Let''s
    say we want to delete records using a partial match for string columns. To achieve
    this, we will use the `LIKE` operator, which is simple, yet powerful, pattern
    matching. With this operator, we can use two wildcards:'
  prefs: []
  type: TYPE_NORMAL
- en: '`_` (underscore): matches exactly one character'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`%` (percent): matches any number of characters, including no characters'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For example, `LIKE` `php_` will match the `php7` column value but will not match
    `php` or `php70`.
  prefs: []
  type: TYPE_NORMAL
- en: On the other hand, `LIKE` "`php7%`" will match `php7`, `php70`, but will not
    match `php`.
  prefs: []
  type: TYPE_NORMAL
- en: To know how many records were deleted, we will use the `PDOStatement::rowCount()`
    method mentioned before.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 7.19: Deleting Records from MySQL'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this exercise, you will learn how to delete records from MySQL using a partial
    match in the `WHERE` clause:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a file called `delete.php`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'First, we get the `PDO` instance, as usual, then retrieve the string to match
    from the input argument, and then we prepare the `DELETE` statement using the
    `:partialMatch` placeholder:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE95]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We then execute the statement by passing the string from input and, in the
    event of an execution failure, we print the error message. Note that the `:partialMatch`
    pattern value is the `$partialMatch` variable value enclosed with `%`, meaning
    we will look for a match anywhere in the column value, be it at the beginning,
    the end, or somewhere inside the string value:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE96]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'If the statement executed successfully, then we want to know how many records
    were affected (deleted), and we will use the `PDOStatement::rowCount()` method
    for that. We store the value inside the `$rowCount` variable for further usage,
    and evaluate its value. If the value is `0` (zero), it means no records were deleted,
    and an appropriate message will be printed to output, including the lookup term
    (the partial match string). Otherwise, the success message will be printed, indicating
    the number of rows deleted for the lookup term:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE97]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The full script can be referred at [https://packt.live/2MCeswE](https://packt.live/2MCeswE).
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Run the file with `php delete.php smith`, and expect the following output:![Figure
    7.31: Deleting records'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/C14196_07_31.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Figure 7.31: Deleting records'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Run the preceding command once again. Now, you should expect the following
    output:![Figure 7.32: Error deleting data'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/C14196_07_32.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Figure 7.32: Error deleting data'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Check the records using Workbench:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 7.33: Displaying database table data using the Workbench client'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/C14196_07_33.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 7.33: Displaying database table data using the Workbench client'
  prefs: []
  type: TYPE_NORMAL
- en: All the records matching `smith` have gone.
  prefs: []
  type: TYPE_NORMAL
- en: You successfully completed the deletion of records from the database table by
    matching them using the `LIKE` operator. For a complete list of operators, refer
    at [https://packt.live/2OHMB0B](https://packt.live/2OHMB0B).
  prefs: []
  type: TYPE_NORMAL
- en: The Singleton Pattern
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `private`) and by defining a public static method that returns the sole
    instance of the class.
  prefs: []
  type: TYPE_NORMAL
- en: This is useful when precisely one object (the first instance) is needed to perform
    actions across the application. For a database connection class, this is particularly
    useful since it does not only limit multiple instantiations of the class but also
    avoids repetitive connection and disconnection operations with the MySQL Server,
    making the first established connection available across the application for the
    lifetime of a single request-response cycle.
  prefs: []
  type: TYPE_NORMAL
- en: 'To test (or demonstrate) the singleton implementation in PHP, a simple script
    file would be sufficient:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE98]'
  prefs: []
  type: TYPE_PRE
- en: 'Running the preceding script would always return the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.34: Screenshot of the output'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/C14196_07_34.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 7.34: Screenshot of the output'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: When comparing objects using the identity operator (`===`), object variables
    are identical if, and only if, they refer to the same instance of the same class.
  prefs: []
  type: TYPE_NORMAL
- en: So far in this chapter, you have learned how to use a database, starting with
    the connection, creating a database and tables, before moving on to adding, querying,
    updating, and deleting records, and then to securing queries by using prepared
    statements and anonymous or named placeholders. Undoubtedly, MySQL has much more
    to offer—it merits an entire book, but the essentials were all briefly covered
    here.
  prefs: []
  type: TYPE_NORMAL
- en: 'Activity 7.1: Contact Management Application'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You are required to build a website where users can create an account and then
    log in to manage a private list of contacts. The website will make use of databases
    to store user login data, as well as to store each user's contacts.
  prefs: []
  type: TYPE_NORMAL
- en: Along with the database functionality that you have learned in this chapter,
    you will be required to use functionality from previous chapters in order to build
    the website (for example, conditionals from *Chapter 3*, *Control Statements*;
    functions from *Chapter 4*, *Functions*; OOP from *Chapter 5*, *Object-Oriented
    Programming*; and form validation from *Chapter 6*, *Using HTTP*). You may need
    to refer to previous chapters for a reminder of how to implement the required
    functionality.
  prefs: []
  type: TYPE_NORMAL
- en: 'The required pages are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Home page
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Login and Sign up pages
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Profile page
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Contacts list and add/edit contact form page
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Layout and Briefing**'
  prefs: []
  type: TYPE_NORMAL
- en: 'The layout is as shown:'
  prefs: []
  type: TYPE_NORMAL
- en: The home page
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![Figure 7.35: Home page layout'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/C14196_07_35.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 7.35: Home page layout'
  prefs: []
  type: TYPE_NORMAL
- en: There is a horizontal navigation bar at the top of the page, featuring the website
    title on the left, and the `Login` button on the right. After a successful login,
    the `Login` button will be replaced by the username, which will link to the Profile
    page, the Contacts page link, and the Logout link.
  prefs: []
  type: TYPE_NORMAL
- en: 'The content is a message with two call-to-action links: `Sign up` and `Login`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The Login page will look as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.36: Authentication layout'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/C14196_07_36.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 7.36: Authentication layout'
  prefs: []
  type: TYPE_NORMAL
- en: The login is based on the username and password, so the content is a simple
    login form, with `Username` and `Password` fields, and a `Login` button. The last
    sentence is a `Sign up` call-to-action link.
  prefs: []
  type: TYPE_NORMAL
- en: After logging in, the user is redirected to the `Profile` page.
  prefs: []
  type: TYPE_NORMAL
- en: 'The Sign up page will look as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.37: Sign up page layout'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/C14196_07_37.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 7.37: Sign up page layout'
  prefs: []
  type: TYPE_NORMAL
- en: 'The content is the `Sign up` form, with the following inputs:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Username`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Password`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Password` **verify**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The username is required to be at least three characters long, and just alphanumeric.
    The password should be at least six characters long and should be verified by
    a second password input at signup. Any form error should be displayed under the
    input where the data came from, for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.38: Validation error'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/C14196_07_38.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 7.38: Validation error'
  prefs: []
  type: TYPE_NORMAL
- en: 'The registered accounts should also retain the signup date. After signing up,
    the user is redirected to the Profile page:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The Profile page will look as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.39: Profile page layout'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/C14196_07_39.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 7.39: Profile page layout'
  prefs: []
  type: TYPE_NORMAL
- en: This will contain a greeting, the profile data, and the session login time.
    While the username and signup date are stored in the database, the session login
    time can be stored in the current session.
  prefs: []
  type: TYPE_NORMAL
- en: 'The Contacts page will look as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.40: Contact page layout'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/C14196_07_40.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 7.40: Contact page layout'
  prefs: []
  type: TYPE_NORMAL
- en: 'The content is split into two: the contacts list and the contact add/edit form:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.41: Edit and delete options for data'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/C14196_07_41.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 7.41: Edit and delete options for data'
  prefs: []
  type: TYPE_NORMAL
- en: The contacts list will list the contact records, each record having the `Edit`
    and `Delete` links. If the list is empty, then display the appropriate message
    instead of rendering the empty table.
  prefs: []
  type: TYPE_NORMAL
- en: 'The contact form will have the following field names:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Name`: required; at least two characters'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Phone`: optional; must only allow `+-() 1234567890`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Email`: required; must be validated'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Address`: optional; maximum 255 characters'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'It should look similar to the following:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 7.42: Contact form'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/C14196_07_42.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 7.42: Contact form'
  prefs: []
  type: TYPE_NORMAL
- en: Error messages for invalid data should be placed under the inputs from which
    the data emanated.
  prefs: []
  type: TYPE_NORMAL
- en: Accessing the Contacts page, the form is ready to use to create new contacts.
    Once the **Edit** button of a contact is pressed, then the contact info will be
    filled in the form; submitting the form updates the existing contact.
  prefs: []
  type: TYPE_NORMAL
- en: When an authenticated user accesses the Home page, Login page, or Sign up page,
    they will be redirected to the Profile page.
  prefs: []
  type: TYPE_NORMAL
- en: The default page title is `Contacts list`.
  prefs: []
  type: TYPE_NORMAL
- en: Now, where should you start? While, in most cases, frameworks are used to simplify
    the "getting started" process of each project, and since we will cover the frameworks
    in a later chapter, let's stick with our bootstrap example. Therefore, let's have
    the previous activity as a starting point for this one (please refer to the activity
    in *Chapter 6*, *Using* *HTTP*). Since the code of the current activity will change,
    you may want to create a copy of the code from the previous activity.
  prefs: []
  type: TYPE_NORMAL
- en: That having been said, I'll give you some guidelines here and there.
  prefs: []
  type: TYPE_NORMAL
- en: '**Steps to perform**:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s see what is needed for the new requirements, compared to the previous
    activity:'
  prefs: []
  type: TYPE_NORMAL
- en: First, there are some new pages, such as Sign up and the Contacts list page,
    that require a template and the request handler (the function that will handle
    the HTTP requests for a particular URI).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The Sign up handler will redirect authenticated users to the Profile page. Otherwise,
    it will print the signup form template and, in the case of a `POST` request, will
    handle the form. After successful signup, the user is authenticated and redirected
    to the Profile page.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The Contacts handler first checks whether there is an authenticated user on
    the website; if not, it sends them the login form. This handler will print the
    current list of contacts and the Contact add/edit form. Also, this handler will
    be responsible for processing the submitted contact form data, and for deleting
    contact entries as well.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: To ensure this new functionality, a database is necessary, so it would be appropriate
    to use PDO with MySQL RDBMS; perhaps consider using a database component, to keep
    the `PDO` instance, and perform specific `PDO` operations in dedicated methods
    (functions).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Since authentication is performed during login and after signup, now would be
    a good time to save the data authentication in a single place, such as a new component
    that we can call `Auth`, which may take care of other commonly used authentication-related
    tasks. The `Auth` component would deal mainly with the PHP session, setting the
    authenticated user ID and login timestamp in the session, getting the session
    login timestamp from the session, getting the user based on the user ID stored
    in the current session, and other authentication-related tasks.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Then, since we will have to use a user's data across the website, it would probably
    be a good idea to create a model class (for example, `User`); this will contain
    a single row of data from the database, and may bundle some related functionality
    (such as checking the input password against the existing password hash). We will
    have the contacts in the database as well, but since we're only printing the contacts
    in a table or form, without using them for anything more across the website, maybe
    we can skip the Contact model.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: On top of this, some handlers will require some refactoring; for example, in
    the login handler, the data source should be changed, from an inline-defined array
    to a database. In the profile handler, all the profile picture lists and upload
    functionality will go away, together with the Support contact functionality –
    now, it will be a simple page displaying a user's data from the database.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Here are the steps to perform the activity:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Create` the new page templates – the Sign up and Contacts list pages.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create the request handlers for the Sign up and Contact pages.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add the `Database` component, where the `PDO` object will be invoked to operate
    with the MySQL server.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add the `Auth` component, which will take care of other commonly used authentication-related
    tasks (for example, check whether the user is logged in).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create the `User` class, as a table row model (in the `src/models/` directory),
    which will bundle some related functionality (such as checking the input password
    against the existing password hash).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Refactor the login handler to use the database as a data source for users.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Refactor the profile handler to only fetch the user from the database and then
    send it to the template.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The solution for this activity can be found on page 534.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, you learned how to handle files with PHP, which includes creating,
    writing, reading, and other filesystem-related operations. You also performed
    some basic, yet powerful, operations against a MySQL database server, creating
    a database structure and inserting, modifying, and deleting data. Although it
    might look a bit complex or overwhelming at the beginning, remember: it''s like
    riding a bike – once practiced enough, until you get comfortable with it, you
    will never forget it (and it will actually get you from point A to point B way
    faster). In the next chapter, we will cover the concept of error handling, which
    is essential to identify potential problems in an application, and prevent important
    details leaking out to your users in the form of nasty error messages.'
  prefs: []
  type: TYPE_NORMAL
