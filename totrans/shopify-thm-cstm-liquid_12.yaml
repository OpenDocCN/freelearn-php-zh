- en: Assessments
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '[*Chapter 1*](B17606_01_Final_PD_ePub.xhtml#_idTextAnchor015), Getting Started
    with Shopify'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Question 1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What is the Partners program?
  prefs: []
  type: TYPE_NORMAL
- en: Answer
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Partners program is a platform created by Shopify that assembles people
    from all over the world. Through this platform, we can build new ecommerce stores
    for store owners, design themes, develop apps, refer new clients to Shopify, and
    most importantly, create a development store for us to practice. We can remind
    ourselves of this within the *How to start?* topic.
  prefs: []
  type: TYPE_NORMAL
- en: Question 2
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: How can we disable the password protection of the development type store?
  prefs: []
  type: TYPE_NORMAL
- en: Answer
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We can disable our password protection store by clicking on the **See store
    password** button within the banner on the **Themes** section, located under the
    Online store section, or by selecting the **Online store** and subsequently clicking
    the **Preferences** inside the expanded dropdown. Once inside, we can easily remove
    the password protection on the regular store. However, since our store is in development
    mode, this option is currently disabled. We can remind ourselves of this within
    the *Sidebar* subtopic, in the *Understanding theme structure* topic.
  prefs: []
  type: TYPE_NORMAL
- en: Question 3
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What is the difference between the Layout and Templates directory files?
  prefs: []
  type: TYPE_NORMAL
- en: Answer
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The **Layout** directory is the main directory of our theme. It contains the
    essential files, and it is where all other files, including the template files,
    will render. The template files are a group of files that allow us to easily create
    and manage the look of multiple pages all at once. We can remind ourselves of
    this within the *Sidebar* subtopic, in the *Understanding theme structure* topic.
  prefs: []
  type: TYPE_NORMAL
- en: Question 4
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Under what circumstances will the new template file be visible inside the admin
    section of your page?
  prefs: []
  type: TYPE_NORMAL
- en: Answer
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Considering that the admin side of Shopify can only read values from the currently
    published theme, we must meet two conditions. Besides creating a new template
    file, we also need to ensure that the same template file exists within the currently
    live theme or to publish our duplicate theme live. We can remind ourselves of
    this within the *Templates* subtopic, in the *Understanding theme structure* topic.
  prefs: []
  type: TYPE_NORMAL
- en: Question 5
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What type of files and under what conditions will allow us to access the variables
    within the parent file scope?
  prefs: []
  type: TYPE_NORMAL
- en: Answer
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The **Snippets** files allow us to re-use repetitive pieces of code over **Templates**/**Sections**
    by referencing their names. Besides allowing us to re-use parts of code, the **Snippets**
    will enable us to access the variables inside the parent element for as long as
    we pass those variables to the snippet as parameters.
  prefs: []
  type: TYPE_NORMAL
- en: '[*Chapter 2*](B17606_02_Final_PD_ePub.xhtml#_idTextAnchor030), The Basic Flow
    of Liquid'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Question 1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What type of delimiter should we use if we are expecting an output as a result?
  prefs: []
  type: TYPE_NORMAL
- en: Answer
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If we expect output from Liquid code, we should use a double bracket delimiter,
    as we should only use a bracket with a percentage when performing a certain logic.
    We can remind ourselves about this within the *Understanding Liquid and its delimiters*
    section.
  prefs: []
  type: TYPE_NORMAL
- en: Question 2
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What will the result of the following conditional be, and why?
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Answer
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Considering that `collection.all_products_count` by default returns a number
    as its value, where the value we are comparing it against is a string since it
    is encapsulated inside the parentheses. Since we cannot compare values of different
    types, the conditional will return `false`, and our message will not be shown.
    We can remind ourselves about this within the *Learning the comparison operators*
    section.
  prefs: []
  type: TYPE_NORMAL
- en: Question 3
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What are the two methods to access an item inside an array?
  prefs: []
  type: TYPE_NORMAL
- en: Answer
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We can access the items inside an array using two methods. The first method
    allows us to use the index position of an item to recover the exact item that
    we are looking for, while the second method allows us to loop over all of the
    items inside an array. We can remind ourselves about this within the *Array* subsection,
    in the *Understand the type of data* section.
  prefs: []
  type: TYPE_NORMAL
- en: Question 4
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What is the correct way of accessing an object using its handle?
  prefs: []
  type: TYPE_NORMAL
- en: Answer
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We can access the object using its handle by pluralizing the object's name we
    are trying to access, followed by either a squared bracket (`[]`) or dot (`.`)
    notation. Both methods of accessing the object are correct. However, they each
    have their use. We can remind ourselves about this within the *EmptyDrop* subsection,
    in the *Understand the type of data* section.
  prefs: []
  type: TYPE_NORMAL
- en: Question 5
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What are the two problems inside the following block of code?
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Answer
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Since nil is a special data type that returns an empty value, it does not have
    a visual representation, which is the first problem. We can remind ourselves about
    this within the *Nil* subsection, in the *Understand the type of data* section.
    The second problem is that we have added a hyphen to both sides of our `customer.name`
    output. While the hyphen on the right side of our output will clear the unwanted
    whitespace before the exclamation mark, we have also added a hyphen on the left
    side, removing the spacing between the word "Welcome" and our customer's name.
    We can remind ourselves about this within the *Controlling the Whitespace* section.
  prefs: []
  type: TYPE_NORMAL
- en: '[*Chapter 3*](B17606_03_Final_PD_ePub.xhtml#_idTextAnchor047), Diving into
    Liquid Core with Tags'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Question 1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What parameters should we use inside a `for` loop if we want to show a maximum
    of seven iterations while also skipping the first three iterations?
  prefs: []
  type: TYPE_NORMAL
- en: Answer
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If we are looking to create a loop that will skip the first three iterations
    and output a maximum of seven iterations, we should use a combination of the `offset`
    and `limit` parameters. The `offset` tag will allow us to skip any number of iterations,
    depending on the value we assign to it. The `limit` parameter will allow us to
    limit the number of iterations the tag should perform. We can remind ourselves
    of this by revisiting the *for parameters* subsection of the *Iterations tags*
    section.
  prefs: []
  type: TYPE_NORMAL
- en: Question 2
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What types of data can we assign to a variable created using the `capture` tag?
  prefs: []
  type: TYPE_NORMAL
- en: Answer
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We can assign any type of data to a variable created using the `capture` tag.
    However, a variable created using the `capture` tag will always return string
    data as a result. We can remind ourselves of this by revisiting the *capture*
    subsection of the *Variable tags* section.
  prefs: []
  type: TYPE_NORMAL
- en: Question 3
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What are the two problems in the following block of code?
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Answer
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: While using the `liquid` tag allows us to eliminate the brace delimiters within
    the code block we should not remove them from the `liquid` tag. We should place
    an opening brace delimiter with a percentage symbol on the left side of the `liquid`
    tag. The second issue with our code is that we are missing an `echo` tag in front
    of the `product.title`, which replaces the double curly brace delimiters. We can
    remind ourselves of this by revisiting the *The liquid and echo tags* subsection,
    in the *Theme tags* section.
  prefs: []
  type: TYPE_NORMAL
- en: Question 4
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What approach should we take to modify an HTML-generated product form by replacing
    the existing class attribute with a combination of a string and a variable?
  prefs: []
  type: TYPE_NORMAL
- en: Answer
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Considering that the `form` tag does not accept a combination of strings and
    variables as its parameter, we should first assign these values to a variable
    using the `capture` tag and then pass it to the `form` tag. We can remind ourselves
    of this by revisiting the *form* subsection, under the *Theme tags* section.
  prefs: []
  type: TYPE_NORMAL
- en: Question 5
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What parameter should we use if we want to pass an object from the parent element?
  prefs: []
  type: TYPE_NORMAL
- en: Answer
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The only tag that allows us to pass down objects from the parent element is
    the `render` tag, and even then, we can only do so by using the `with` and `as`
    parameters. We should set the value of the `with` parameter to the object we are
    looking to pass, and the value of the `as` parameter should be the name of the
    variable we will use within our snippet file. We can remind ourselves of this
    by revisiting the *render* subsection, in the *Theme tags* section.
  prefs: []
  type: TYPE_NORMAL
- en: '[*Chapter 4*](B17606_04_Final_PD_ePub.xhtml#_idTextAnchor079), Diving into
    Liquid Core with Objects'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Question 1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What are we missing in the following block of code to make `form` functional?
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Answer
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: While we have introduced the `id` variant, which is necessary to create a working
    product form, we didn't use a `name` attribute with `id` as its value. We can
    remind ourselves of how this works by going back to the *Custom collection* subtopic,
    in the *Working with global objects* section.
  prefs: []
  type: TYPE_NORMAL
- en: Question 2
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: How can we get access to the `product` object through a link defined in the
    admin navigation?
  prefs: []
  type: TYPE_NORMAL
- en: Answer
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To access the `product` object through the navigation menu, we will need to
    use a `for` tag to iterate over the navigation menu. Once we have found which
    menu item is `product_type`, we can use that menu item, followed by the `object`
    attribute, to access that specific `product` object. We can remind ourselves of
    how this works by going back to the *Custom navigation* subtopic, in the *Working
    with global objects* section.
  prefs: []
  type: TYPE_NORMAL
- en: Question 3
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What are the two approaches to accessing single and multiple `metafield` objects?
  prefs: []
  type: TYPE_NORMAL
- en: Answer
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We can access the single `metafield` object using the object of the page we
    are looking to recover `metafield` from, followed by the `metafields` object,
    followed by `namespace`, and finally followed by `key`. If we are looking to recover
    multiple `metafields` objects, we will need to use a `for` tag to iterate over
    all the metafields with their namespace. We can remind ourselves of how this works
    by going back to the *Improving the workflow with metafields* section.
  prefs: []
  type: TYPE_NORMAL
- en: Question 4
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What adjustment do we need to make to the input element if we were looking to
    capture the `line_item` value and hide it on the checkout page?
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Answer
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If we were looking to capture the `line_item` value, we would need to introduce
    an underscore as a first character inside the square bracket. By introducing this
    underscore within the `line_item` input, we will automatically hide the specific
    `line_item` from the checkout page. However, this will not hide it on the cart
    page. The cart page will require some manual adjustments. We can remind ourselves
    of how this works by going back to the *Custom navigation* subtopic, in the *Working
    with global objects* section.
  prefs: []
  type: TYPE_NORMAL
- en: '[*Chapter 5*](B17606_05_Final_PD_ePub.xhtml#_idTextAnchor097), Diving into
    Liquid Core with Filters'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Question 1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Suppose that we have an array named `product_handles` with handles of 30 products.
    What issue in the following code would prevent us from outputting the images of
    all 30 products successfully?
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Answer
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Since we are looking to output more than 20 products, in this case, 30 products,
    we cannot use the `all_products` object, as the `all_products` object has a limitation
    that we can only call it 20 times on a single page. If we are looking to recover
    data from more than 20 products, we need to assign them to a collection and then
    perform a loop over those products. We can remind ourselves of the `all_products`
    object by visiting the *Working with HTML and URL filters* section.
  prefs: []
  type: TYPE_NORMAL
- en: Question 2
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Why is only using the `model_viewer_tag` tag not recommended when creating the
    product media gallery?
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Answer
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: While `model_viewer_tag` will correctly output the necessary HTML media tag
    for each media type, we should only use `model_viewer_tag` as a fallback if all
    other media tags fail to render the proper tag. Using `model_viewer_tag` will
    prevent us from including any of the specific parameters for each `media` tag.
    We can remind ourselves of the `media` object by looking over one of the previous
    projects we have completed in this chapter, enhancing the product media gallery.
  prefs: []
  type: TYPE_NORMAL
- en: Question 3
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Which filter could we use if we were looking to access an item at a specific
    location inside the array?
  prefs: []
  type: TYPE_NORMAL
- en: Answer
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If we are looking to access an item at a specific location, we will need to
    use an array type filter named `index`. Using the `index` filter, we can access
    the specified index location in an array and return its value. We can remind ourselves
    of the index parameter by looking over one of the previous projects we have completed
    in this chapter, product accordions.
  prefs: []
  type: TYPE_NORMAL
- en: Question 4
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What filter can we use to quickly update any occurrence of a string value inside
    the theme files?
  prefs: []
  type: TYPE_NORMAL
- en: Answer
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To easily update any occurrence of a string value, we will need to use the t
    (translation) filter. By defining the translation keys, we can quickly update
    or even translate any string value without the need to update the hardcoded string
    values across multiple files manually.
  prefs: []
  type: TYPE_NORMAL
- en: '[*Chapter 6*](B17606_06_Final_PD_ePub.xhtml#_idTextAnchor116), Configuring
    the Theme Settings'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Question 1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What are the two types of input settings?
  prefs: []
  type: TYPE_NORMAL
- en: Answer
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The first set of settings is called basic input types, and it consists of six
    types of settings, which allow us to output basic HTML input elements through
    which we can dynamically output certain content. The second set of settings, otherwise
    called specialized settings, allows us to generate specialized selector type fields
    to access various objects through the store and output their content using their
    attributes. We can remind ourselves of the basic and specialized input types of
    settings by visiting the *Basic input types* and *Specialized input settings*
    sections in [*Chapter 6*](B17606_06_Final_PD_ePub.xhtml#_idTextAnchor116), *Configuring
    the Theme Settings*.
  prefs: []
  type: TYPE_NORMAL
- en: Question 2
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What's the issue that will cause an error with the following piece of code?
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Answer
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: While the code structure is correct, we have accidentally included an extra
    comma after the last attribute inside the text setting type, which will cause
    a JSON error and prevent us from saving the changes. We can remind ourselves of
    the strict JSON format by visiting the *Basic JSON settings* section in [*Chapter
    6*](B17606_06_Final_PD_ePub.xhtml#_idTextAnchor116), *Configuring the Theme Settings*.
  prefs: []
  type: TYPE_NORMAL
- en: Question 3
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: How can we include a custom font file within Shopify and use it throughout the
    theme editor?
  prefs: []
  type: TYPE_NORMAL
- en: Answer
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: While `font_picker` allows us to access a significant number of fonts within
    Shopify, we have no way of including the custom font in this library. To include
    a custom set of fonts, we will have to use a `select` input type of settings,
    where we can manually create a list of fonts we wish to include. We can remind
    ourselves of how to include custom fonts by visiting *The select input* subsection
    in the *Basic input types* section from [*Chapter 6*](B17606_06_Final_PD_ePub.xhtml#_idTextAnchor116),
    *Configuring the Theme Settings*.
  prefs: []
  type: TYPE_NORMAL
- en: Question 4
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What are the two issues that will prevent us from executing the following piece
    of code?
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Answer
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Considering that each `range` slider can have a maximum of 100 steps, the first
    issue is that the `min` and `max` attribute values are too far apart, which we
    can resolve by decreasing one of the two values so that they do not have more
    than 100 steps. An alternative solution is to increase `step` to a higher value,
    consequently reducing the number of steps between the `min` and `max` values.
  prefs: []
  type: TYPE_NORMAL
- en: The second issue is that the `default` attribute value is currently exceeding
    the `max` attribute value. We can resolve this by decreasing the `default` value
    or increasing the `max` attribute value. After ensuring that the `default` attribute
    value does not exceed the `max` value, we also need to ensure that the `default`
    value is also higher than the `min` attribute value. We can remind ourselves of
    the `range` type setting format by visiting *The range input* subsection in the
    *Basic input types* section from [*Chapter 6*](B17606_06_Final_PD_ePub.xhtml#_idTextAnchor116),
    *Configuring the Theme Settings*.
  prefs: []
  type: TYPE_NORMAL
- en: '[*Chapter 7*](B17606_07_Final_PD_ePub.xhtml#_idTextAnchor131), Working with
    Static and Dynamic Sections'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Question 1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What is the main difference between the static and dynamic sections?
  prefs: []
  type: TYPE_NORMAL
- en: Answer
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The main difference between the static and dynamic sections is that we can only
    add the dynamic section to the JSON templates and the home page using the **Add
    section** button inside the theme editor. Additionally, we can repeat this any
    number of times with different content.
  prefs: []
  type: TYPE_NORMAL
- en: On the other hand, the static section needs to be included manually inside a
    theme template using the `section` tag. We can include the same static section
    inside multiple templates. However, each section will display the same content
    as we can only have one instance of a static section. We can remind ourselves
    of static and dynamic sections by visiting the *Static versus dynamic sections*
    section.
  prefs: []
  type: TYPE_NORMAL
- en: Question 2
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What object can we use to access the block input value? Write some code that
    will allow us to access the specific `blocks` module input value.
  prefs: []
  type: TYPE_NORMAL
- en: Answer
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We can access the block''s input value through the `section` object and combine
    it with the `blocks` attribute, which will return an array of block objects:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: We can remind ourselves how to access the block input types by visiting the
    *Building with blocks* section.
  prefs: []
  type: TYPE_NORMAL
- en: Question 3
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What is the difference between the `limit` and `max_blocks` attributes?
  prefs: []
  type: TYPE_NORMAL
- en: Answer
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The main difference between the `limit` and `max_blocks` attributes is that
    the `limit` attribute only allows us to limit how many times we can repeat a particular
    block type. The `max_blocks` attribute, on the other hand, allows us to limit
    how many blocks we can include inside a particular section, regardless of the
    block type. We can remind ourselves how to use the `limit` and `max_blocks` attributes
    and the differences between the two by visiting the *Building with blocks* and
    *The max_blocks attribute* sections.
  prefs: []
  type: TYPE_NORMAL
- en: Question 4
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: How can we apply section-specific CSS styling?
  prefs: []
  type: TYPE_NORMAL
- en: Answer
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If we need to include a section-specific CSS, we can do this using the `{% style
    %}{% endstyle %}` tag, which will allow us to use Liquid code. However, besides
    the `style` tag, we will also need to define a unique identifier that we will
    call later as the selector. We can do this using the `section` object and `id`
    attribute, which will return a dynamic ID for the dynamic section or a section
    filename for the static section. We can remind ourselves how to create section-specific
    CSS by visiting *The style tag* section.
  prefs: []
  type: TYPE_NORMAL
- en: 'Please note that the solutions for all the four projects are available on GitHub:
    [https://github.com/PacktPublishing/Shopify-Theme-Customization-with-Liquid/tree/main/Projects](https://github.com/PacktPublishing/Shopify-Theme-Customization-with-Liquid/tree/main/Projects)'
  prefs: []
  type: TYPE_NORMAL
