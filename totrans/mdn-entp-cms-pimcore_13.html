<html><head></head><body>
		<div id="_idContainer209">
			<h1 id="_idParaDest-226"><em class="italic"><a id="_idTextAnchor228"/>Chapter 13</em>: Implementing Master Data Management</h1>
			<p>In the previous chapter, you learned about the concept of <strong class="bold">Product Information Management </strong>(<strong class="bold">PIM</strong>), and how to properly create a Pimcore class to represent products. Through some coding examples, you learned how to create product variants and bundle products, and how to define different types of products by extending the defined class with Objectbricks.</p>
			<p>In this chapter, we will present the concept of <strong class="bold">Master Data Management </strong>(<strong class="bold">MDM</strong>), and how to expose Pimcore objects to third-party applications using the <strong class="bold">Datahub</strong> Pimcore bundle. The chapter is organized as follows:</p>
			<ul>
				<li>Turning Pimcore into MDM</li>
				<li>Activating the Pimcore Datahub bundle</li>
				<li>Exposing entities</li>
				<li>Using mutation queries</li>
				<li>Creating a custom mutation</li>
				<li>Defining custom reports</li>
			</ul>
			<p>Starting with a definition of <strong class="bold">Master Data Management</strong>, we will see how to turn Pimcore into MDM. Then, we will present the Pimcore Datahub bundle and explain how to install it. After that, we will see how to expose created objects, how to use mutation queries to create new objects, and how to create custom mutations. Last but not least, we will see how to define custom reports.</p>
			<h1 id="_idParaDest-227"><a id="_idTextAnchor229"/>Technical requirements</h1>
			<p>As you have done in previous chapters, all you need to do to run the demo connected with this chapter is to navigate to the <strong class="source-inline">13. Implementing Master Data Management</strong> folder in the official book repository and start a Docker environment.</p>
			<p>To do so, just follow these instructions:</p>
			<ol>
				<li>Run Docker with the following command:<p class="source-code"><strong class="bold">docker-compose up</strong></p></li>
				<li>Then, to restore all the settings on your local machine, just open a new shell and type the following command:<p class="source-code"><strong class="bold">docker-compose exec php bash restore.sh</strong></p></li>
				<li>Navigate to http://localhost/admin and log in with your admin/pimcore credentials.</li>
			</ol>
			<p>You can access the official book repository to get the source code through the following link:</p>
			<p><a href="https://github.com/PacktPublishing/Modernizing-Enterprise-CMS-using-Pimcore/tree/main/13.%20Implementing%20Master%20Data%20Management">https://github.com/PacktPublishing/Modernizing-Enterprise-CMS-using-Pimcore/tree/main/13.%20Implementing%20Master%20Data%20Management</a></p>
			<p>Now you are ready to navigate through the demo to discover all aspects related to this chapter.</p>
			<h1 id="_idParaDest-228"><a id="_idTextAnchor230"/>Turning Pimcore into MDM</h1>
			<p>In <a href="B17073_01_ePub_RK.xhtml#_idTextAnchor014"><em class="italic">Chapter 1</em></a>, <em class="italic">Introducting Pimcore</em>, we briefly introduced the concept of Master Data Management. MDM<a id="_idIndexMarker828"/> is a fundamental process used to manage, centralize, organize, categorize, locate, synchronize, and enrich critical data based on your company's sales, marketing, and operational strategies. In this section, we will explain this concept better to let you understand how easily you can put into practice the learnings from the previous chapters to turn Pimcore into an MDM system.</p>
			<p>We have <a id="_idIndexMarker829"/>already seen in <a href="B17073_12_ePub_RK.xhtml#_idTextAnchor211"><em class="italic">Chapter 12</em></a>, <em class="italic">Implementing Product Information Management,</em> the potential that <a id="_idIndexMarker830"/>Pimcore has in terms of data management, but it has one big limitation: it's strictly related to the concept of products.</p>
			<p>In many company scenarios, products are not the only kind of data that needs to be defined, managed, and shared through the company users or distributed in different channels. For example, if we think in terms of e-commerce purposes, we may want to store orders and customers or define the details of our physical shops to create a store locator page on an e-commerce site.</p>
			<p>To provide a <a id="_idIndexMarker831"/>completely different example, the classes created<a id="_idIndexMarker832"/> in <a href="B17073_09_ePub_RK.xhtml#_idTextAnchor166"><em class="italic">Chapter 9</em></a>, <em class="italic">Configuring Entities and Rendering Data</em><em class="italic">,</em> to store articles and categories can be intended, in a certain sense, as a possible implementation of MDM.</p>
			<p>That said, the first step that we must do to turn Pimcore into an MDM system is to create a class for each concept that we need to represent, and we can easily do this through the Pimcore class-definition interface. This alone is not sufficient, but think about how easy it is to create Pimcore classes through the out-of-the-box interface, as you learned in <a href="B17073_05_ePub_RK.xhtml#_idTextAnchor093"><em class="italic">Chapter 5</em></a>, <em class="italic">Exploring Objects and Classes</em>, and how this produces a strong and easy-to-maintain structure without writing a single line of code.</p>
			<p>Since you have already learned how to create Pimcore classes in the previous chapter, we will not repeat the process in this chapter as well. If you followed the instructions provided in the <em class="italic">Technical requirements</em> section, you should find some already defined classes.</p>
			<p>Once the structure is defined, we can take advantage of Pimcore potentials to implement the data management processes, among which we can cite the following:</p>
			<ul>
				<li><strong class="bold">Data validation</strong>: For class <a id="_idIndexMarker833"/>attributes, we can define a few validation rules—for example, we can decide whether each attribute is mandatory for a class and, for text attributes, add a regular expression to validate the content. This can be useful, but it does not permit defined complex validation scenarios such as (for example) cross-attribute validation. This can be done by implementing event listeners, as you learned in the previous chapter.</li>
				<li><strong class="bold">Data quality</strong>: Data quality consists of a set of tools and processes needed to give qualitative and quantitative consistency to our data—for example, we may want to check whether translations for our objects are complete or not. We can accomplish this by creating specific kinds of attributes that are <strong class="bold">Calculated Value</strong> and <strong class="bold">Dynamic Text Label</strong> attributes (we will see an example of these in the next section).</li>
				<li><strong class="bold">Versioning</strong>: One of the<a id="_idIndexMarker834"/> main characteristics of <strong class="bold">PIM</strong>, <strong class="bold">DAM</strong>, and <strong class="bold">MDM</strong> is the possibility to share objects. Every user that has write permission can edit products and other objects, and different users may access and save the same object. For this reason, it's important to keep track of object versions to have a clear view of which user has made changes.</li>
			</ul>
			<p>Now that we have defined the main characteristics of an MDM system, let's see an example of a Data Quality implementation.</p>
			<h2 id="_idParaDest-229"><a id="_idTextAnchor231"/>Implementing Data Quality</h2>
			<p>In the previous section, we<a id="_idIndexMarker835"/> introduced the definition of Master Data Management, and you learned what the main characteristics of an MDM system are.</p>
			<p>In this section, through an example, we will see how to implement <strong class="bold">data quality</strong>. As we mentioned in the previous section, we can accomplish this using two different kinds of attributes, which are <strong class="bold">Calculated Value</strong> and <strong class="bold">Dynamic Text Label</strong> attributes.</p>
			<p>These particular kinds of attributes require the development of a <strong class="bold">PHP: Hypertext Preprocessor</strong> (<strong class="bold">PHP</strong>) class whose methods are automatically called when an object is opened. Once this class is developed, we must write the class namespace in the attribute configuration, as you can see in the following screenshot:</p>
			<div>
				<div id="_idContainer195" class="IMG---Figure">
					<img src="image/Figure_13.01_B17073.jpg" alt="Figure 13.1: Calculated value configuration&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 13.1: Calculated value configuration</p>
			<p>As you can see in the <a id="_idIndexMarker836"/>previous screenshot, we can put the class namespace in the <strong class="bold">Calculator class</strong> input in the attribute configuration. Once the input is filled, you can click on the <strong class="bold">Save</strong> button to apply the changes to the class. The same configuration can be done for the <strong class="bold">Dynamic Text Label</strong> attributes.</p>
			<p>Now that we have seen how to configure the attributes, in the following code snippet, we will see how to implement the <strong class="source-inline">Calculator</strong> class:</p>
			<p class="source-code">&lt;?php</p>
			<p class="source-code">namespace App\CalculatedValue;</p>
			<p class="source-code">use Pimcore\Model\DataObject\ClassDefinition\CalculatorClassInterface;</p>
			<p class="source-code">use Pimcore\Model\DataObject\Concrete;</p>
			<p class="source-code">use Pimcore\Model\DataObject\Data\CalculatedValue;</p>
			<p class="source-code">use Pimcore\Model\DataObject\Product;</p>
			<p class="source-code">use Pimcore\Tool;</p>
			<p class="source-code">class DataQualityCalculator implements CalculatorClassInterface</p>
			<p class="source-code">{</p>
			<p class="source-code">    public function compute(Concrete $object, CalculatedValue     $context): string</p>
			<p class="source-code">    {</p>
			<p class="source-code">        return $this-&gt;getCalculatedValueForEditMode($object,         $context);</p>
			<p class="source-code">    }</p>
			<p class="source-code">    public function getCalculatedValueForEditMode(Concrete     $object, CalculatedValue $context): string</p>
			<p class="source-code">    {</p>
			<p class="source-code">        if ($object instanceof Product) {</p>
			<p class="source-code">            $language = $context-&gt;getPosition();</p>
			<p class="source-code">            if(empty($object-&gt;getName($language)) </p>
			<p class="source-code">                || empty($object-&gt;getShort_                description($language))</p>
			<p class="source-code">                || empty($object-&gt;getDescription($language))){</p>
			<p class="source-code">                return "no";</p>
			<p class="source-code">            }</p>
			<p class="source-code">            return "yes";</p>
			<p class="source-code">        }</p>
			<p class="source-code">        return '';</p>
			<p class="source-code">    }</p>
			<p class="source-code">}</p>
			<p>In the previous code snippet, you can see how to realize a PHP class suitable for <strong class="bold">Calculated Values</strong>. As you can see, this class must implement the <strong class="source-inline">CalculatorClassInterface</strong> interface, which involves implementing the following two methods:</p>
			<ul>
				<li>The <strong class="source-inline">compute</strong> method is called on the object save, to store the calculated value in the database.</li>
				<li>The <strong class="source-inline">getCalculatedValueForEditMode</strong> method is invoked to display the value in the object edit modal. </li>
			</ul>
			<p>These two functions <a id="_idIndexMarker837"/>are typically expected to return the same value, so it's a best practice to let one function return the value of the other one to avoid code duplication.</p>
			<p>These functions take the object instance and the attribute context as input that contains useful information such as the <strong class="source-inline">fieldname</strong> attribute. For localized fields, the current language is defined in the <strong class="source-inline">position</strong> property of the context. </p>
			<p>In this specific example, we first check whether the object is a product, which is the class for which we have set the <strong class="bold">Calculated Value</strong> attribute. Then, we check whether for each language all the localized fields are empty or not.</p>
			<p>In the following code snippet, we will see how to implement a method needed to render the dynamic text label:</p>
			<p class="source-code">&lt;?php</p>
			<p class="source-code">namespace App\CalculatedValue;</p>
			<p class="source-code">use Pimcore\Model\DataObject\ClassDefinition\Layout\DynamicTextLabelInterface;</p>
			<p class="source-code">use Pimcore\Model\DataObject\Concrete;</p>
			<p class="source-code">use Pimcore\Model\DataObject\Data\CalculatedValue;</p>
			<p class="source-code">use Pimcore\Model\DataObject\Product;</p>
			<p class="source-code">use Pimcore\Tool;</p>
			<p class="source-code">class DataQualityCalculator implements DynamicTextLabelInterface</p>
			<p class="source-code">{</p>
			<p class="source-code">    public function renderLayoutText($data, $object, $params)</p>
			<p class="source-code">    {</p>
			<p class="source-code">        if ($object instanceof Product) {</p>
			<p class="source-code">            $htmlTable = '&lt;table style="border: 1px solid             black"&gt;';</p>
			<p class="source-code">            $htmlTable .= '&lt;thead&gt;&lt;tr&gt;</p>
			<p class="source-code">&lt;td style="border: 1px solid black"&gt;Language&lt;/td&gt;</p>
			<p class="source-code">&lt;td style="border: 1px solid black"&gt;Translation Status&lt;/td&gt;</p>
			<p class="source-code">&lt;/tr&gt;&lt;/thead&gt;';</p>
			<p class="source-code">            foreach (Tool::getValidLanguages() as $language) {</p>
			<p class="source-code">                $htmlTable .= '&lt;tr&gt;';</p>
			<p class="source-code">                $htmlTable .= '&lt;td style="border: 1px solid                 black"&gt;'.$language.'&lt;/td&gt;';</p>
			<p class="source-code">                $htmlTable .= '&lt;td style="border: 1px solid                 black"&gt;'.($object-                &gt;getTranslationCompleted($language) == "yes" ?                 "completed" : "not completed").'&lt;/td&gt;';</p>
			<p class="source-code">                $htmlTable .= '&lt;/tr&gt;';</p>
			<p class="source-code">            }</p>
			<p class="source-code">            $htmlTable .= '&lt;/table&gt;';</p>
			<p class="source-code">            return "&lt;h2 style='margin-top: 0'&gt;Translations             Summary&lt;/h2&gt;" . $htmlTable;</p>
			<p class="source-code">        }</p>
			<p class="source-code">        return '';</p>
			<p class="source-code">    }</p>
			<p class="source-code">}</p>
			<p>As you can see in the <a id="_idIndexMarker838"/>previous code snippet, the class is similar to the previously created one. To render the dynamic text label, the class must implement the <strong class="source-inline">DynamicTextLabelInterface</strong> interface. This interface presents the <strong class="source-inline">renderLayoutText</strong> method, which we must implement.</p>
			<p>In the <strong class="source-inline">renderLayoutText</strong> method, we can return <strong class="bold">HyperText Markup Language</strong> (<strong class="bold">HTML</strong>) text that will be rendered in the label. In this specific example, we have realized a simple HTML table that shows whether the localized fields are completed for each language, using the previously created calculated value.</p>
			<p>In the following screenshot, you can see what these attributes look like:</p>
			<div>
				<div id="_idContainer196" class="IMG---Figure">
					<img src="image/Figure_13.02_B17073.jpg" alt="Figure 13.2: Calculated values result&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 13.2: Calculated values result</p>
			<p>As you can see in the<a id="_idIndexMarker839"/> previous screenshot, the dynamic text label shows the completeness status for each language, while the calculated value shows whether the selected language fields have been completed.</p>
			<p>To summarize, in this section, you learned about the concept of <strong class="bold">Master Data Management</strong> (<strong class="bold">MDM</strong>), and how you can take advantage of Pimcore potentials to implement the data management processes, turning Pimcore into an MDM system. Later, you learned how to implement calculated values to realize data quality.</p>
			<p>In the following section, you will learn how to activate the Pimcore Datahub bundle that you can use to expose Pimcore objects to third-party applications.</p>
			<h1 id="_idParaDest-230"><a id="_idTextAnchor232"/>Activating the Pimcore Datahub bundle</h1>
			<p>In the previous section, you<a id="_idIndexMarker840"/> learned how to implement data management processes, such as the data quality process. These processes, the name of what? unclear, are key aspects of the MDM concept. Another fundamental feature for MDM systems is the possibility to expose entities to third-party applications and sites.</p>
			<p>In this section, you will learn how to activate the Pimcore <strong class="bold">Datahub</strong> bundle and how to configure that bundle properly. Later in this chapter, you will learn how to use this bundle to expose Pimcore objects and let external applications create new objects.</p>
			<p>As you learned in the <em class="italic">Installing a Bundle</em> section of <a href="B17073_07_ePub_RK.xhtml#_idTextAnchor129"><em class="italic">Chapter 7</em></a>, <em class="italic">Administrating Pimcore Sites</em>, Pimcore bundles can be downloaded through the <strong class="source-inline">composer</strong> package manager; to download the Datahub bundle, you just need to follow these instructions:</p>
			<ol>
				<li value="1">Open a shell and<a id="_idIndexMarker841"/> point to the chapter folder of the book source code.</li>
				<li>Run the following command to jump inside the Docker container:<p class="source-code"><strong class="bold">docker-compose php bash</strong></p></li>
				<li>Run the following command to download the Datahub bundle:<p class="source-code"><strong class="bold">composer require pimcore/data-hub</strong></p></li>
			</ol>
			<p>Once the bundle is downloaded, it must be enabled and installed to be able to use it. You can do this through the <strong class="bold">Tools </strong>|<strong class="bold"> Bundles</strong> menu, as shown in the following screenshot:</p>
			<div>
				<div id="_idContainer197" class="IMG---Figure">
					<img src="image/Figure_13.03_B17073.jpg" alt="Figure 13.3: Datahub Bundle Installation&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 13.3: Datahub Bundle Installation</p>
			<p>As you can see in the previous screenshot, the Datahub bundle must first be enabled and then installed. The installation of the bundle will create additional tables inside the database structure.</p>
			<p>These operations can be accomplished alternatively through the following Bash commands:</p>
			<p class="source-code">php bin/console pimcore:bundle:enablePimcoreDatahubBundle</p>
			<p class="source-code">php bin/console pimcore:bundle:installPimcoreDatahubBundle</p>
			<p>Please note that running these commands is just an alternative to the operations made through the <a id="_idIndexMarker842"/>extension manager interface; only one method should be used.</p>
			<p>Now that you have learned how to install the Datahub bundle, let's see how to create Datahub configuration models.</p>
			<h2 id="_idParaDest-231"><a id="_idTextAnchor233"/>Creating a Datahub configuration</h2>
			<p>In the previous section, you <a id="_idIndexMarker843"/>learned how to install and activate the Pimcore Datahub bundle. In this section, you will learn how to create configurations for Datahub. These configurations will govern how third-party applications can interact with Pimcore to retrieve, create, or update objects.</p>
			<p>To open the Datahub configuration panel, just go through <strong class="bold">Settings </strong>|<strong class="bold"> Datahub Config</strong> in the Pimcore menu. To create a new configuration, just follow the next instructions:</p>
			<ol>
				<li value="1">Click on the <strong class="bold">Add Configuration</strong> button.</li>
				<li>Write the configuration name inside the window that appears.</li>
				<li>Click on the <strong class="bold">OK</strong> button to confirm the creation.</li>
			</ol>
			<p>In the following screenshot, you can see a representation of the previous instructions:</p>
			<div>
				<div id="_idContainer198" class="IMG---Figure">
					<img src="image/Figure_13.04_B17073.jpg" alt="Figure 13.4: Creating a Datahub configuration&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 13.4: Creating a Datahub configuration</p>
			<p>As you can see in the previous screenshot, once the configuration is created it is visible in the left-side menu. If you click on the created configuration, the configuration will open in the edit mode. The setup of the configuration can be made through three different panels, as we are about to see.</p>
			<p>The <strong class="bold">General</strong> panel contains general information about the configuration, such as the configuration name. We can<a id="_idIndexMarker844"/> see what this panel looks like in the following screenshot:</p>
			<div>
				<div id="_idContainer199" class="IMG---Figure">
					<img src="image/Figure_13.05_B17073.jpg" alt="Figure 13.5: General panel&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 13.5: General panel</p>
			<p>Let's now describe each property that we see in the preceding screenshot, as follows:</p>
			<ul>
				<li><strong class="bold">Active</strong>: If enabled, the configuration is active and can be exposed to external applications.</li>
				<li><strong class="bold">Type</strong>: The configuration type. In the current version, only the GraphQL typology exists.</li>
				<li><strong class="bold">Name</strong>: The configuration name, defined during the configuration creation. This may not be changed.</li>
				<li><strong class="bold">Description</strong>: This lets you write a textual description for the configuration.</li>
				<li><strong class="bold">SQL Condition</strong>: In this property, you can add a <strong class="bold">Structured Query Language</strong> (<strong class="bold">SQL</strong>) condition that will be used to do a pre-filtering of all the queries.</li>
			</ul>
			<p>In the <strong class="bold">Schema Definition</strong> panel, we<a id="_idIndexMarker845"/> can define which classes are enabled for queries and mutations. We can see what this panel looks like in the following screenshot:</p>
			<div>
				<div id="_idContainer200" class="IMG---Figure">
					<img src="image/Figure_13.06_B17073.jpg" alt="Figure 13.6: Schema Definition panel&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 13.6: Schema Definition panel</p>
			<p>Let's now describe each property that we see in the preceding screenshot, as follows:</p>
			<ul>
				<li><strong class="bold">Query Schema</strong>: In this section, we can select one or more classes, with objects that will be available for queries. For each selected class, it's possible to define which attributes must <a id="_idIndexMarker846"/>be exposed in queries. We will see this concept in the <em class="italic">Exposing entities</em> section.</li>
				<li><strong class="bold">Mutation Schema</strong>: Similar to the <strong class="bold">Query Schema</strong> section, in this section we can select classes that could be available for mutation queries. For each class, we can define whether objects can be created, updated, and deleted. We will see more on mutation queries later in this chapter, in the <em class="italic">Using mutation queries</em> section.</li>
				<li><strong class="bold">Generic Types</strong>: Here, we can define whether assets, documents, and folders must be exposed for queries and mutations. For example, if we enable the <strong class="bold">Read </strong>option for object folders, we can retrieve all the objects that are contained in one folder.</li>
			</ul>
			<p>In the <strong class="bold">Security Definition</strong> panel, we <a id="_idIndexMarker847"/>can manage authentication rules and restrict the visibility of entities to specific folders. We can see what this panel looks like in the following screenshot:</p>
			<div>
				<div id="_idContainer201" class="IMG---Figure">
					<img src="image/Figure_13.07_B17073.jpg" alt="Figure 13.7: Security Definition panel&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 13.7: Security Definition panel</p>
			<p>Let's now describe each property that we see in the preceding screenshot, as follows:</p>
			<ul>
				<li><strong class="bold">Method</strong>: The authentication method. In the current version, only authentication through an <strong class="bold">Application Programming Interface</strong> (<strong class="bold">API</strong>) key is available.</li>
				<li><strong class="bold">Datahub API Key</strong>: The API key that will be required for authentication. This can be generated by clicking on the lightning bolt icon on the right.</li>
				<li><strong class="bold">Skip Permission Check</strong>: If enabled, the check for mandatory fields' completeness is skipped when performing a mutation query.</li>
				<li><strong class="bold">Workspaces</strong>: In this <a id="_idIndexMarker848"/>section, we must specify specific <strong class="bold">Documents</strong>, <strong class="bold">Assets</strong>, and <strong class="bold">Objects</strong> folders to which we want to expose queries and mutations.</li>
			</ul>
			<p>Once you have completed the configuration, click on the <strong class="bold">Save</strong> button to apply the changes.</p>
			<p>After the configuration is saved, queries can be tested in two different ways, as follows:</p>
			<ul>
				<li>Through an integrated <strong class="bold">inline frame</strong> (<strong class="bold">Iframe</strong>), which could be opened in a new panel in the Pimcore interface by clicking the <strong class="bold">Open</strong> in<strong class="bold"> Iframe</strong> button</li>
				<li>In a new browser tab, which could be opened by clicking the <strong class="bold">Open in Tab</strong> button</li>
			</ul>
			<p>For third-party applications, queries can be made by performing <strong class="bold">HyperText Transfer Protocol</strong> (<strong class="bold">HTTP</strong>) calls to the following endpoint:</p>
			<p class="source-code">/pimcore-graphql-webservices/{configurationname}?apikey={yourApiKey}</p>
			<p>In the previous endpoint, you can see that the configuration name and the API key are variables, so you must substitute the placeholders with the values defined in the configuration.</p>
			<p>All the defined configurations are stored in a <strong class="source-inline">var/config/Datahub-configurations.php</strong> file. If you want to share the same configuration between different environments, you can commit this file in the code base and rebuild the Datahub configurations running the following Bash command:</p>
			<p class="source-code">php bin/console Datahub:graphql:rebuild-definitions</p>
			<p>To summarize, in this section, you have learned how to download and activate the Pimcore Datahub bundle and how to create a configuration for that bundle. In the following section, you will learn how to expose entities and how to perform queries on Datahub, testing them through the integrated Iframe.</p>
			<h1 id="_idParaDest-232"><a id="_idTextAnchor234"/>Exposing entities</h1>
			<p>In the previous section, you <a id="_idIndexMarker849"/>learned how to activate a Datahub bundle and how to create a new configuration. In this section, you will learn how to set up the configuration to expose entities and how to perform queries on Datahub.</p>
			<p>As we mentioned in the previous section, in the <strong class="bold">Schema Definition</strong> panel of the Datahub configurations, we must select which classes should be available for queries, and add them in the <strong class="bold">Query Schema</strong> section. </p>
			<p>For each class, we must define which fields can be exposed for queries. This can be done by clicking on the <strong class="bold">Settings</strong> icon for each added class. In the following screenshot, you can see how to select the fields to expose:</p>
			<div>
				<div id="_idContainer202" class="IMG---Figure">
					<img src="image/Figure_13.08_B17073.jpg" alt="Figure 13.8: Query Schema fields &#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 13.8: Query Schema fields </p>
			<p>As you can see in the previous screenshot, on the left side you can find a list of the class fields. If you double-click one of these fields or drag and drop a field on the right column, that field will be exposed and will be available for queries. Once you have selected all the fields you <a id="_idIndexMarker850"/>want to expose, just click on the <strong class="bold">Apply</strong> button to confirm your choice.</p>
			<p>Now we have learned how to configure a query schema, in the following section, you will see how to perform GraphQL queries on Datahub.</p>
			<h2 id="_idParaDest-233"><a id="_idTextAnchor235"/>Performing GraphQL queries</h2>
			<p>In the previous section, you<a id="_idIndexMarker851"/> learned how to expose classes and fields to let them be queryable. In this section, you will learn how to perform queries for your created configurations, seeing some query examples.</p>
			<p>As we previously mentioned in the <em class="italic">Creating a Datahub configuration</em> section, the only supported configuration type is GraphQL. GraphQL is a query language for building APIs and a tool for serving these APIs with real data. GraphQL provides a complete and understandable description of your API data, giving clients the power to request only what they need and nothing else. This allows easy integration with external software and allows you to easily maintain and evolve the APIs over time.</p>
			<p>GraphQL queries always return a predictable result, and therefore applications that use GraphQL are fast and reliable because they are in control of the data they require, not the server.</p>
			<p>GraphQL queries, in addition to accessing the data of a resource, can follow references with other entities. This eventually allows you to retrieve all the data needed by an application in a single call, unlike a typical <strong class="bold">REpresentational State Transfer</strong> (<strong class="bold">REST</strong>) API, which typically requires multiple calls to get data.</p>
			<p>GraphQL APIs are therefore organized in terms of types and not endpoints; all data can be accessed with a single endpoint and the use of types ensures that external applications can only request what is allowed, which allows you to provide clear and useful error messages.</p>
			<p>Now that we have introduced what GraphQL is, let's have a look at the Pimcore Datahub Iframe environment. In the following screenshot, you can see what this environment looks like:</p>
			<div>
				<div id="_idContainer203" class="IMG---Figure">
					<img src="image/Figure_13.09_B17073.jpg" alt="Figure 13.9: Datahub Iframe Environment&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 13.9: Datahub Iframe Environment</p>
			<p>As you can see in the <a id="_idIndexMarker852"/>previous screenshot, the Iframe is divided into two panels. In the left panel, we can write a query that we want to run, while in the right panel, the query results are shown. As you can see, in the left panel, suggestions are shown when we write field names, giving the possibility to have auto-completeness. Once a query is ready, you can run it by clicking the <strong class="bold">Play</strong> button.</p>
			<p>Now that we have seen how to perform queries, let's have a look at some query examples that cover the various field types.</p>
			<h3>Getting an Object Listing</h3>
			<p>In this example, you <a id="_idIndexMarker853"/>will learn how to perform object listing. In the following code snippet, you can see how a listing query is formed:</p>
			<p class="source-code">{</p>
			<p class="source-code">    getProductListing(first: 10, after: 0, filter: "{\"o_    type\": \"object\"}") {</p>
			<p class="source-code">        edges {</p>
			<p class="source-code">            node {</p>
			<p class="source-code">                id</p>
			<p class="source-code">                name</p>
			<p class="source-code">                short_description</p>
			<p class="source-code">                    }</p>
			<p class="source-code">                }</p>
			<p class="source-code">        totalCount</p>
			<p class="source-code">    }</p>
			<p class="source-code">}</p>
			<p>As you can see in the previous code snippet, the query statement is composed of a <strong class="source-inline">get</strong> prefix, the class name, and a <strong class="source-inline">Listing</strong> suffix. The listing function has the following input attributes:</p>
			<ul>
				<li><strong class="source-inline">first</strong>: The<a id="_idIndexMarker854"/> number of results to retrieve.</li>
				<li><strong class="source-inline">after</strong>: The number of objects to skip. Combined with the previous parameter, this can be used to perform pagination.</li>
				<li><strong class="source-inline">ids</strong>: A list of the <strong class="bold">identifiers</strong> (<strong class="bold">IDs</strong>) of objects to retrieve. If omitted, all products that respect the other filters are retrieved.</li>
				<li><strong class="source-inline">fullpaths</strong>: Similarly to the previous property, we can specify the paths of the objects to retrieve.</li>
				<li><strong class="source-inline">filter</strong>: One or more composed filters that will be applied to filter the objects to retrieve.</li>
				<li><strong class="source-inline">published</strong>: Specify whether the query must include unpublished objects.</li>
				<li><strong class="source-inline">defaultLanguage</strong>: Specify the default language for localized fields.</li>
				<li><strong class="source-inline">sortBy</strong>: The field to sort the results by.</li>
				<li><strong class="source-inline">sortOrder</strong>: The sorting order for the specified field.</li>
			</ul>
			<p>The query content<a id="_idIndexMarker855"/> consists of an <strong class="source-inline">edges</strong> component, in which you can specify a list of fields to retrieve for each <strong class="source-inline">node</strong>, and a <strong class="source-inline">totalCount</strong> component, which always retrieves the total number of results despite the current page parameters.</p>
			<p>In the following examples, we will see how to retrieve a single object and how to retrieve values for different kinds of fields.</p>
			<h3>Getting a single object</h3>
			<p>In this example, we <a id="_idIndexMarker856"/>will see how to retrieve a single object. You can see how to perform this query in the following code snippet:</p>
			<p class="source-code">{</p>
			<p class="source-code">getProduct(id: 162, defaultLanguage: "en"){</p>
			<p class="source-code">    name</p>
			<p class="source-code">    name_it: name(language: "it")</p>
			<p class="source-code">    price{</p>
			<p class="source-code">        value</p>
			<p class="source-code">        unit{</p>
			<p class="source-code">            abbreviation</p>
			<p class="source-code">        }</p>
			<p class="source-code">        toString</p>
			<p class="source-code">    }</p>
			<p class="source-code">  }</p>
			<p class="source-code">}</p>
			<p>As you can see in the previous code snippet, the query statement is composed of the <strong class="source-inline">get</strong> prefix and the class name. In the query function, we must define the object <strong class="source-inline">id</strong> or the object <strong class="source-inline">fullpath</strong>. </p>
			<p>Then, we can optionally define the default language for localized fields. In the query content, you can see that for localized fields we can define a different language despite the default one. </p>
			<p>In this example, you<a id="_idIndexMarker857"/> can also see how to query for <strong class="source-inline">QuantityValue</strong> fields. As you can see in the previous code snippet, you can require the field value, the unit of measure, and the composition of value and unit by the <strong class="source-inline">toString</strong> property.</p>
			<p>In the following example, you will learn how to retrieve details of object relations.</p>
			<h3>Getting relation details</h3>
			<p>In the following<a id="_idIndexMarker858"/> code snippet, you can see how to get details for standard relations and advanced relations:</p>
			<p class="source-code">{</p>
			<p class="source-code">    getProduct(id: 162){</p>
			<p class="source-code">        category{</p>
			<p class="source-code">            ... on object_Category{</p>
			<p class="source-code">                id</p>
			<p class="source-code">                name</p>
			<p class="source-code">      }</p>
			<p class="source-code">    }</p>
			<p class="source-code">    materials{</p>
			<p class="source-code">        element{</p>
			<p class="source-code">            id</p>
			<p class="source-code">            name</p>
			<p class="source-code">      }</p>
			<p class="source-code">      metadata{</p>
			<p class="source-code">          name</p>
			<p class="source-code">          value</p>
			<p class="source-code">      }</p>
			<p class="source-code">    }</p>
			<p class="source-code">  }</p>
			<p class="source-code">}</p>
			<p>As you can see in the previous code snippet, for standard relations, as category one, we must specify the related class. In GraphQL syntax, this can be made by adding three dots, followed by the <strong class="source-inline">on object_</strong> keyword and the class name. For the related class, you can specify the fields to retrieve.</p>
			<p>For advanced<a id="_idIndexMarker859"/> relations, in the <strong class="source-inline">element</strong> component, you can specify the fields to retrieve for the related object, while in the <strong class="source-inline">metadata</strong> component, you can retrieve the name and the value for each relation metadata.</p>
			<p>In the following example, you will learn how to retrieve values for Fieldcollections and how to require image details.</p>
			<h3>Getting Image Details</h3>
			<p>In this example, we will see<a id="_idIndexMarker860"/> how the same syntax can be used for <strong class="bold">Fieldcollections</strong>, and you will learn how to retrieve image details. In the following code snippet, you can see how to perform this kind of query:</p>
			<p class="source-code">{</p>
			<p class="source-code">    getProduct(id: 162){</p>
			<p class="source-code">        images{</p>
			<p class="source-code">            ... on fieldcollection_ImageInfo {</p>
			<p class="source-code">                image{</p>
			<p class="source-code">                    id</p>
			<p class="source-code">                    filename</p>
			<p class="source-code">                    fullpath</p>
			<p class="source-code">                    filesize</p>
			<p class="source-code">                    data</p>
			<p class="source-code">               }</p>
			<p class="source-code">           }</p>
			<p class="source-code">       }</p>
			<p class="source-code">    }</p>
			<p class="source-code">}</p>
			<p>As you can see in the<a id="_idIndexMarker861"/> previous code snippet, the syntax is quite similar to the previous one that we have seen for object relations. For each image, we can require image details such as filename and file size, but we also can get Base64 image content by the <strong class="source-inline">data</strong> attribute.</p>
			<h3>Getting Object Variants</h3>
			<p>In this example, you<a id="_idIndexMarker862"/> will learn how to get object variants. In the following code snippet, you can see how to get object children:</p>
			<p class="source-code">{</p>
			<p class="source-code">getProduct(id: 162){</p>
			<p class="source-code">    children(objectTypes:["variant"]){</p>
			<p class="source-code">        ... on object_Product{</p>
			<p class="source-code">            id</p>
			<p class="source-code">            color{</p>
			<p class="source-code">                ... on object_Color{</p>
			<p class="source-code">                    name</p>
			<p class="source-code">                }</p>
			<p class="source-code">             }</p>
			<p class="source-code">          }</p>
			<p class="source-code">       }</p>
			<p class="source-code">    }</p>
			<p class="source-code">}</p>
			<p>As you can see in the previous code snippet, you can retrieve the object variants using the <strong class="source-inline">getChildren</strong> function. To get variants, you must specify that you require them by using the <strong class="source-inline">objectTypes</strong> property.</p>
			<p>To summarize, in <a id="_idIndexMarker863"/>this section, you learned how to expose entities for Datahub configurations. After having seen what an integrated Iframe looks like, through some query examples you learned how to perform queries to retrieve object listing and details for different kinds of attributes.</p>
			<p>In the following section, you will learn how to perform mutation queries to create, update, and delete objects.</p>
			<h1 id="_idParaDest-234"><a id="_idTextAnchor236"/>Using mutation queries</h1>
			<p>In the previous section, you <a id="_idIndexMarker864"/>learned how to expose entities for Datahub configurations and how to perform queries to retrieve object data. In this section, you will learn how to expose entities for mutations and how to perform queries to create, update, and delete objects.</p>
			<p>As we mentioned in the <em class="italic">Activating the Pimcore Datahub bundle</em> section, in the <strong class="bold">Schema Definition</strong> panel of Datahub configurations, we must select which classes should be available for mutations and add them to the <strong class="bold">Mutation Schema</strong> section. </p>
			<p>As we did for classes in the <strong class="bold">Query Schema</strong> section, we can define which fields can be exposed for mutation queries by clicking on the <strong class="bold">Settings</strong> icon for each added class. Besides, for each class, we can decide whether we want to make it available for creation, update, or deletion.</p>
			<p>Throughout this section, we will learn how to perform mutation queries for creating, updating, and deleting objects.</p>
			<h2 id="_idParaDest-235"><a id="_idTextAnchor237"/>Creating Objects</h2>
			<p>In this section, you will<a id="_idIndexMarker865"/> learn how to perform a mutation query to create a new object. In the following code snippet, you will see the query syntax for mutation queries, and a specific one that creates a new object:</p>
			<p class="source-code">mutation{</p>
			<p class="source-code">    createProduct(path:"/Products", key:"Running Shoes",     input:{</p>
			<p class="source-code">        sku: "0003"</p>
			<p class="source-code">        name: "Runner Shoes"</p>
			<p class="source-code">        category: {id: 177}</p>
			<p class="source-code">        }){</p>
			<p class="source-code">        success</p>
			<p class="source-code">        message</p>
			<p class="source-code">        output{</p>
			<p class="source-code">            id</p>
			<p class="source-code">            sku</p>
			<p class="source-code">            name</p>
			<p class="source-code">        }</p>
			<p class="source-code">    }</p>
			<p class="source-code">}</p>
			<p>As you can see in the previous snippet, all mutation queries must start with the <strong class="source-inline">mutation</strong> keyword. Then, the query function is composed of the desired operation as a prefix, which is one of <strong class="source-inline">create</strong>, <strong class="source-inline">update</strong>, or <strong class="source-inline">delete</strong>, followed by the name of the class.</p>
			<p>In the function arguments, you can specify the following attributes:</p>
			<ul>
				<li><strong class="source-inline">key</strong>: The key of the object. This will be shown in the object tree.</li>
				<li><strong class="source-inline">path</strong>: The path in which the object is created. This could be a folder or a parent product.</li>
				<li><strong class="source-inline">parentId</strong>: This can be used as an alternative to the <strong class="source-inline">path</strong> argument to define the parent folder or object.</li>
				<li><strong class="source-inline">published</strong>: If <strong class="source-inline">false</strong>, a product is created in the unpublished status.</li>
				<li><strong class="source-inline">omitMandatoryCheck</strong>: If <strong class="source-inline">true</strong>, an object is created even if all the mandatory fields are not filled.</li>
				<li><strong class="source-inline">type</strong>: We<a id="_idIndexMarker866"/> can specify if a created object must be an object or a variant.</li>
				<li><strong class="source-inline">input</strong>: In this attribute, we can specify the field values for an object that we want to create.</li>
			</ul>
			<p>The query content consists of three components, outlined as follows:</p>
			<ul>
				<li><strong class="source-inline">success</strong>: A Boolean flag that will be <strong class="source-inline">true</strong> if the query runs successfully and <strong class="source-inline">false</strong> otherwise.</li>
				<li><strong class="source-inline">message</strong>: A successful message if the query runs successfully.</li>
				<li><strong class="source-inline">output</strong>: If an object is created successfully, this will show the object fields requested in the query.</li>
			</ul>
			<p>Running the previously defined query will return the following result:</p>
			<p class="source-code">{</p>
			<p class="source-code">  "data": {</p>
			<p class="source-code">    "createProduct": {</p>
			<p class="source-code">      "success": true,</p>
			<p class="source-code">      "message": "object created: 178",</p>
			<p class="source-code">      "output": {</p>
			<p class="source-code">        "id": "178",</p>
			<p class="source-code">        "sku": "0003",</p>
			<p class="source-code">        "name": "Runner Shoes"</p>
			<p class="source-code">      }</p>
			<p class="source-code">    }</p>
			<p class="source-code">  }</p>
			<p class="source-code">}</p>
			<p>As you can<a id="_idIndexMarker867"/> see in the previous code snippet, if the object is created correctly, the object <strong class="source-inline">id</strong> is returned. This can be used to perform queries to update or delete an object.</p>
			<p>Now that we have seen how to create a new object, let's see how to perform a query to update a previously created object.</p>
			<h2 id="_idParaDest-236"><a id="_idTextAnchor238"/>Updating objects</h2>
			<p>In the previous section, you<a id="_idIndexMarker868"/> learned how to create new objects using mutation queries. In this section, you will learn how to update previously created objects.</p>
			<p>In the following code snippet, you can see the syntax for an update mutation query:</p>
			<p class="source-code">mutation{</p>
			<p class="source-code">        updateProduct(id:178, input:{</p>
			<p class="source-code">            short_description: "The classic model of low             sneakers is certainly very comfortable and             practical and defines a personal style"</p>
			<p class="source-code">        }){</p>
			<p class="source-code">            success</p>
			<p class="source-code">            message</p>
			<p class="source-code">            output{</p>
			<p class="source-code">                   id</p>
			<p class="source-code">                   sku</p>
			<p class="source-code">                   name</p>
			<p class="source-code">                   short_description</p>
			<p class="source-code">            }</p>
			<p class="source-code">      }</p>
			<p class="source-code">}</p>
			<p>As you can see in the previous code snippet, the mutation query function starts with the <strong class="source-inline">update</strong> keyword. The object <strong class="source-inline">id</strong> must be passed as a function argument, and an error message will be<a id="_idIndexMarker869"/> returned if an object with the provided <strong class="source-inline">id</strong> does not exist.</p>
			<p>Now that we have seen how to update a previously created object, let's see how to perform a query to delete that object.</p>
			<h2 id="_idParaDest-237"><a id="_idTextAnchor239"/>Deleting Objects</h2>
			<p>In the previous<a id="_idIndexMarker870"/> section, you learned how to update objects using mutation queries. In this section, you will learn how to delete an object.</p>
			<p>In the following code snippet, you can see the syntax for a delete mutation query:</p>
			<p class="source-code">mutation{</p>
			<p class="source-code">    deleteProduct(id:178){</p>
			<p class="source-code">        success</p>
			<p class="source-code">        message</p>
			<p class="source-code">    }</p>
			<p class="source-code">}</p>
			<p>As you can see in the previous code snippet, the mutation query function starts with the <strong class="source-inline">delete</strong> keyword. The<a id="_idIndexMarker871"/> object <strong class="source-inline">id</strong> must be passed as a function argument, and an error message will be returned if an object with the provided <strong class="source-inline">id</strong> does not exist.</p>
			<p>To summarize, in this section, you learned the syntax of mutation queries. In particular, we have seen how to create, update, and delete objects through specific queries. In the following section, you will learn how to create a custom mutation query function.</p>
			<h1 id="_idParaDest-238"><a id="_idTextAnchor240"/>Creating a custom mutation</h1>
			<p>In the<a id="_idIndexMarker872"/> previous section, you learned how to use mutation queries to create, update, and delete objects. These kinds of queries work well for simple scenarios but present some limitations in terms of the kinds of attributes that we can update or for the interdependence of multiple attributes. For example, on standard mutation queries, the <strong class="source-inline">QuantityValue</strong> fields cannot be filled.</p>
			<p>In this section, you will learn how to create a custom mutation function and how to use that to update values that cannot be updated through standard mutation queries.</p>
			<p>To create a new custom mutation function, we need to add a function definition to the Datahub configuration schema. This can be made by implementing a listener for the <strong class="source-inline">pimcore.Datahub.graphql.mutation.preBuild</strong> event.</p>
			<p>In <a href="B17073_12_ePub_RK.xhtml#_idTextAnchor211"><em class="italic">Chapter 12</em></a>, <em class="italic">Implementing Product Information Management</em>, you learned how to implement an <strong class="bold">EventListener</strong>. In the following code snippet, you will see an example that will show how to implement a listener that will affect the Datahub configuration schema:</p>
			<p class="source-code">&lt;?php</p>
			<p class="source-code">namespace App\EventListener;</p>
			<p class="source-code">class DatahubListener {</p>
			<p class="source-code">    public function onMutationEventsPreBuild (MutationTypeEvent $event) {</p>
			<p class="source-code">        $config = $event-&gt;getConfig();</p>
			<p class="source-code">        $opName = "updateProductPrice";</p>
			<p class="source-code">        $inputType = new \GraphQL\Type</p>
			<p class="source-code">        \Definition\InputObjectType([</p>
			<p class="source-code">            'name' =&gt; "priceType",</p>
			<p class="source-code">            'fields' =&gt; [</p>
			<p class="source-code">                'priceValue' =&gt; ['type' =&gt;Type::float()],</p>
			<p class="source-code">                'unit' =&gt; ['type' =&gt;Type::string()]</p>
			<p class="source-code">            ]</p>
			<p class="source-code">        ]);</p>
			<p class="source-code">        $operation = [</p>
			<p class="source-code">            'type' =&gt;Type::string(), </p>
			<p class="source-code">            'args' =&gt; [</p>
			<p class="source-code">                'id' =&gt; ['type' =&gt;</p>
			<p class="source-code">                 Type::nonNull(Type::int())],</p>
			<p class="source-code">                'input' =&gt; ['type' =&gt; $inputType],</p>
			<p class="source-code">            ], 'resolve' =&gt; function ($source, $args, $context,             ResolveInfo $info) {</p>
			<p class="source-code">                $id = $args['id'];</p>
			<p class="source-code">                $product = Product::getById($id);</p>
			<p class="source-code">                if(empty($product)){</p>
			<p class="source-code">                    throw new \Exception("Product with id '$id'                     does not exists.");</p>
			<p class="source-code">                }</p>
			<p class="source-code">                $value = $args['input']['priceValue'];</p>
			<p class="source-code">                $uom = $args['input']['unit'];</p>
			<p class="source-code">                $unit = Unit::getByAbbreviation($uom);</p>
			<p class="source-code">                if(empty($unit)){</p>
			<p class="source-code">                    throw new \Exception("Unit of measure                     '$uom' does not exists.");</p>
			<p class="source-code">                }</p>
			<p class="source-code">                $price = new QuantityValue();</p>
			<p class="source-code">                $price-&gt;setValue($value);</p>
			<p class="source-code">                $price-&gt;setUnitId($unit-&gt;getId());</p>
			<p class="source-code">                $product-&gt;setPrice($price);</p>
			<p class="source-code">                $product-&gt;save();</p>
			<p class="source-code">                return "Price updated for product with id                 '$id'";</p>
			<p class="source-code">            }</p>
			<p class="source-code">        ];</p>
			<p class="source-code">        $config['fields'][$opName] = $operation;</p>
			<p class="source-code">        $event-&gt;setConfig($config);</p>
			<p class="source-code">    }</p>
			<p class="source-code">}</p>
			<p>In the<a id="_idIndexMarker873"/> previous code snippet, we have implemented a simple function that will set the product price. As you can see in the example, the listener function has an input argument of type <strong class="source-inline">MutationTypeEvent</strong>. That event variable has a <strong class="source-inline">config</strong> property that contains the Datahub configuration schema. To add a new mutation function, we must add a new operation to this configuration.</p>
			<p>The first step is to create an object of type <strong class="source-inline">InputObjectType</strong>. This object must contain a <strong class="source-inline">fields</strong> property, which has to be an array that must define the name and the type for each property that must be filled in the <strong class="source-inline">input</strong> argument of the mutation query function.</p>
			<p>We must then create an array that will define a new operation. This array must contain the operation arguments, such as the object <strong class="source-inline">id</strong> and the previously defined <strong class="source-inline">input</strong> argument, and must define a <strong class="source-inline">resolve</strong> function that, in our case, will set up the product price given the price value and unit.</p>
			<p>Once you<a id="_idIndexMarker874"/> have defined this operation, you must add that to the configuration attribute. As a result, the created function will be selectable in the Iframe, as you can see in the following screenshot:</p>
			<div>
				<div id="_idContainer204" class="IMG---Figure">
					<img src="image/Figure_13.10_B17073.jpg" alt="Figure 13.10: Custom Mutation Query&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 13.10: Custom Mutation Query</p>
			<p>As you can see in the previous screenshot, in the left panel you can select the previously defined function and fill in the value and the unit for the product price. In the right panel, you can see the result message that was defined for the mutation query.</p>
			<p>To summarize, in this section, you learned how to create a custom mutation query. This can be useful to set up object attributes for complex scenarios. As an example, you learned how to implement an event listener to create a custom mutation query that will set the product price.</p>
			<p>In the next section, you will learn how to define custom reports to create tabular or chart reports with filtering and export functionalities.</p>
			<h1 id="_idParaDest-239"><a id="_idTextAnchor241"/>Defining custom reports</h1>
			<p><strong class="bold">Custom Reports</strong> is a <a id="_idIndexMarker875"/>report engine that is integrated directly into Pimcore. These reports are based on direct SQL queries on the database, and it's possible to render them both as tables and charts. To define or generate a new custom report, follow these steps:</p>
			<ol>
				<li value="1">To create a new report, go to the <strong class="bold">Marketing</strong> menu and click on the <strong class="bold">Custom Reports</strong> menu option.</li>
				<li>Then, click on the <strong class="bold">Add</strong> button and insert the report name. After having created the report, you can start configuring it. In the following screenshot, you can see how to set up a <a id="_idIndexMarker876"/>report's general settings:<div id="_idContainer205" class="IMG---Figure"><img src="image/Figure_13.11_B17073.jpg" alt="Figure 13.11: General settings&#13;&#10;"/></div><p class="figure-caption">Figure 13.11: General settings</p><p>As you can see in the previous screenshot, the report <strong class="bold">Name</strong> is the one that was inserted before. </p></li>
				<li>Then, add a user-friendly label and eventually group the reports in folders. </li>
				<li>Click on the <strong class="bold">Create Shortcut in Menu</strong> checkbox, and the report will be directly available in the <strong class="bold">Marketing</strong> menu. </li>
				<li>After having configured <a id="_idIndexMarker877"/>the general settings, the next step is to configure the data source. This can be done by directly defining an SQL query, as you can see in the following screenshot:<div id="_idContainer206" class="IMG---Figure"><img src="image/Figure_13.12_B17073.jpg" alt="Figure 13.12: Source definition&#13;&#10;"/></div><p class="figure-caption">Figure 13.12: Source definition</p><p>As you can see in the previous screenshot, you can add a direct SQL query as a source definition. This gives you the possibility to design complex scenarios but requires advanced knowledge of the database structure. In this specific example, we want to count the number of products per category.</p></li>
				<li>After having <a id="_idIndexMarker878"/>defined a data source, define how to render data. You can see how to manage the column configuration in the following screenshot:<div id="_idContainer207" class="IMG---Figure"><img src="image/Figure_13.13_B17073.jpg" alt="Figure 13.13: Managing the Column Configuration&#13;&#10;"/></div><p class="figure-caption">Figure 13.13: Managing the Column Configuration</p><p>As you can see in the previous screenshot, if a query is well formed, the columns are automatically detected. For each column, we can specify whether the column must be shown in the report and whether the column can be exported and sorted. Then, we can also define whether each column can be filterable, along with the filter type to apply, and then specify the width and the label for them. If a column contains an object <strong class="source-inline">id</strong>, we can also specify an <strong class="bold">Open Object</strong> action. As we will see in the next step, this will add a button that lets you open the corresponding object by the report table.</p><p>After having defined the column configuration, you can define the chart type, choosing from <strong class="bold">Pie Chart</strong>, <strong class="bold">Bar Chart</strong>, and <strong class="bold">Line Chart</strong>. For pie charts, you must then specify<a id="_idIndexMarker879"/> which column must be used to define the values list, and which one contains the data count.</p></li>
				<li>Once the configuration is completed, go to the <strong class="bold">Marketing</strong> | <strong class="bold">Reports</strong> menu to see how the report is rendered. You can see what a defined example looks like in the following screenshot:</li>
			</ol>
			<div>
				<div id="_idContainer208" class="IMG---Figure">
					<img src="image/Figure_13.14_B17073.jpg" alt="Figure 13.14: Report Visualization&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 13.14: Report Visualization</p>
			<p>As you can see in the<a id="_idIndexMarker880"/> previous screenshot, the report is shown as a pie chart as we defined, with categories' names, a list of the different values, and a count of the products that form the pie slices.</p>
			<p>At the bottom, you can see the report in a tabular version. In particular, you can see the <strong class="bold">Open</strong> button, which lets you open the linked category object. If you don't specify a chart type, only the tabular version is shown. The report table can be exported in a <strong class="bold">comma-separated values</strong> (<strong class="bold">CSV</strong>) file.</p>
			<p>To summarize, in this section, you learned how to configure and render reports using the <strong class="bold">Custom Reports</strong> engine. Starting from the general settings, you learned how to configure a data source and how to properly render data in the report.</p>
			<h1 id="_idParaDest-240"><a id="_idTextAnchor242"/>Summary</h1>
			<p>In this chapter, you learned the concept of Master Data Management and how to expose Pimcore objects to third-party applications using the Datahub Pimcore bundle.</p>
			<p>After having defined that concept, you have seen an example of how to implement the concept of data quality, which is a key feature of MDM systems.</p>
			<p>Later in the chapter, you learned how to activate a Datahub Pimcore Bundle and how to create a configuration for that bundle, and how to set up the configuration to expose objects and other entities with external applications.</p>
			<p>After having introduced the GraphQL query language, you learned how to perform queries to retrieve object data through some query examples, as well as how to create, update, and delete objects through mutation queries. Then, you learned how to implement a custom mutation query function, which is useful for defining complex scenarios.</p>
			<p>In the last section, you learned how to configure and render custom reports, which let you present and export the data.</p>
			<p>In the next chapter, you will learn how to perform Data Integration in Pimcore, with a specific focus on how to import and export objects and on when the standard functionalities are supposed to be used, and otherwise when they have limitations that make the implementation of a custom solution necessary.</p>
		</div>
	</body></html>