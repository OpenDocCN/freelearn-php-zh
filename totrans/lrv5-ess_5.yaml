- en: Chapter 5. Testing – It's Easier Than You Think
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Testing is an often-neglected part in PHP development. Compared to languages
    such as Java and Ruby, where testing is strongly ingrained into the workflow of
    developers, PHP has been lagging behind. This is mainly because simple PHP applications
    tend to be tightly coupled and are, therefore, difficult to test. However, thanks
    to standardization and modularization efforts and frameworks that encourage the
    separation of concerns, PHP testing has become more accessible and the mentality
    towards it is slowly changing.
  prefs: []
  type: TYPE_NORMAL
- en: Laravel 5 is a framework that was built from the ground up to facilitate testing.
    It comes with all the necessary files to get started, along with different helpers
    to test your application, thus helping beginners to overcome some of the biggest
    obstacles.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will demonstrate how Laravel makes it very simple to get
    started with testing, without forcing you to go for a test-first approach, or
    making you aim for complete test coverage. In this gentle introduction to testing,
    we will look at the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: The advantages of writing tests for your application
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to prepare your tests
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The software design patterns that Laravel fosters
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to use Mockery to test objects in isolation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The built-in features and helpers that facilitate testing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The benefits of testing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you have not written tests for your web applications before, the advantages
    of testing might not always be obvious to you. After all, preparing and writing
    tests involves significant time investment, and for short-lived prototypes or
    hackathon projects, they can even seem to be a complete waste of time. However,
    in almost all the other cases, when your project is likely to grow in complexity,
    or when you collaborate with other developers, tests have the potential to save
    you and other people a lot of time and headaches.
  prefs: []
  type: TYPE_NORMAL
- en: Tests also introduce some changes to your workflow. In the development stage,
    you will no longer have to switch back and forth between your code editor and
    your web browser. Instead, if you are using a text editor or an IDE that supports
    it, you could bind a test runner to a keyboard shortcut.
  prefs: []
  type: TYPE_NORMAL
- en: Once you have proven that a certain bit of functionality works, you will have
    a way of quickly ensuring that it continues to work as expected, if the source
    code is changed at a later date. In addition to this, it forces you to clearly
    and unambiguously define the expected behavior of your application and can therefore
    complement or replace a significant part of the documentation. This can be particularly
    helpful, not only for new developers who start collaborating on the project, but
    also for yourself, if you have not touched the project for a while.
  prefs: []
  type: TYPE_NORMAL
- en: The anatomy of a test
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Your application tests will reside in `tests/`. In this directory, you will
    find a base test case inside `TestCase.php`, which is responsible for bootstrapping
    the application in the testing environment. This class extends Laravel's main
    `TestCase` class, which in turn extends the `PHPUnit_Framework_TestCase` class,
    along with many helpful testing methods that we will cover later in this chapter.
    All of your tests will extend this first `TestCase` class and define one or more
    methods that are meant to test one or more features of your application.
  prefs: []
  type: TYPE_NORMAL
- en: 'In every test, we generally perform the following three distinct tasks:'
  prefs: []
  type: TYPE_NORMAL
- en: We *arrange* or initialize some data.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We execute a function to *act* on this data.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We *assert* or verify that the output matches what we expected.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Given we had the following Helper class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'An example test case, `HelperTest.php`, which illustrates the three preceding
    steps, will look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'When the preceding code snippet is executed, PHPUnit will run each method within
    the test case and keep track of how many tests failed or passed. With PHPUnit
    installed on your system, you can run this test, using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'This will produce the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The anatomy of a test](img/B04308_05_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Most code editors also provide ways to run this directly within the editor by
    pressing a shortcut key. Examples of such editors include **PhpStorm**. It is
    even possible to run them automatically before each commit or before you deploy
    your code to a remote server.
  prefs: []
  type: TYPE_NORMAL
- en: Unit testing with PHPUnit
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A positive effect of testing is that it forces you to split your code into manageable
    dependencies, so that you can test them in isolation. The testing of these individual
    classes and methods is referred to as **unit testing**. Since it relies on the
    PHPUnit testing framework, which already provides a large number of tools to set
    up test suites, Laravel does not need to provide any additional helpers for this
    type of testing.
  prefs: []
  type: TYPE_NORMAL
- en: A great way to learn about any framework, and at the same time learn about the
    different ways in which it can be tested, is to look at how its authors have written
    tests for it. Therefore, our next examples will be taken directly from Laravel's
    test suite, which is located at `vendor/laravel/framework/tests/`.
  prefs: []
  type: TYPE_NORMAL
- en: Defining what you expect with assertions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Assertions are the fundamental components of unit tests. Simply put, they are
    used to compare the *expected output* of a function with its *actual output*.
  prefs: []
  type: TYPE_NORMAL
- en: To see how assertions work, we will examine the test for the `Str::is()` helper,
    which checks whether a given string matches a given pattern.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following test can be found near the bottom of the `Support/SupportStrTest.php`
    file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The preceding test performs five assertions to test whether the method is indeed
    returning the expected value when called with different parameters.
  prefs: []
  type: TYPE_NORMAL
- en: PHPUnit provides many other assertion methods that can, for example, help you
    test for numerical values with `assertGreaterThan()`, equality with `assertEquals()`,
    types with `assertInstanceOf()`, or existence with `assertArrayHasKey()`. While
    there are many more possible assertions, these are the ones you will probably
    end up using most frequently. In total, PHPUnit provides around 40 different assertion
    methods, all of which are described in the official documentation at [http://phpunit.de/manual/](http://phpunit.de/manual/).
  prefs: []
  type: TYPE_NORMAL
- en: Preparing the scene and cleaning up objects
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If you need to run a function before each test method to set up some test data
    or reduce code duplication, you can use the `setUp()` method. If, on the other
    hand, you need to run some code after each test to clear any objects that were
    instantiated in your tests, you can define it inside the `tearDown()` method.
    A good example would be to remove any records from a database inserted in the
    `setUp()` method.
  prefs: []
  type: TYPE_NORMAL
- en: Expecting exceptions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'It is also possible to test for exceptions by decorating your function with
    an `@expectedException` DocBlock, like Laravel does inside `Database/ DatabaseEloquentModelTest.php`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: In this test function, there is no assertion, but the code is expected to throw
    an exception when it is executed. Also note the use of an `EloquentModelStub`
    object. A stub creates an instance of an object that provides or simulates the
    methods that our class needs—in this case, an Eloquent model on which we can call
    the `guard()` and `fill()` methods. If you look at the definition of this stub
    further down in the test, you will see that it does not actually interact with
    a database, but it provides canned responses instead.
  prefs: []
  type: TYPE_NORMAL
- en: Testing interdependent classes in isolation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In addition to stubs, which we looked at in the previous section, there is
    another way in which you can test one or more interdependent classes in isolation.
    It is by using **mocks**. In Laravel, mocks are created using the Mockery library,
    and they help define the methods that should be called during the test, the arguments
    they should receive, and their return values as well. Laravel heavily relies on
    mocks in its own tests. An example can be found in the `AuthEloquentUserProviderTest`
    class, where the `Hasher` class is mocked:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: As opposed to stubs, mocks allow us to define which methods need to be called,
    how many times they should be called, which parameters they should receive, and
    which parameters they should return. If any of these preconditions are not met,
    the test will fail.
  prefs: []
  type: TYPE_NORMAL
- en: To ensure that we do not have an instance of a mocked object that persists and
    interferes with future tests, Mockery provides a `close()` method that needs to
    be executed after each test. Thanks to this mock, the class can be tested in complete
    isolation.
  prefs: []
  type: TYPE_NORMAL
- en: End-to-end testing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When we are confident that all of the interdependent classes work as expected,
    we can then conduct another type of testing. It consists of simulating the kind
    of interaction that a user would have through a web browser. This user would,
    for example, visit a specific URL, perform certain actions, and expect to see
    some kind of feedback from the application.
  prefs: []
  type: TYPE_NORMAL
- en: This is perhaps the most straightforward type of testing, as it mimics the kind
    of testing that you manually perform each time you refresh your browser after
    a code change. When you get started, it is absolutely fine to only perform this
    type of testing. However, you must bear in mind that if any errors occur, you
    will still have to drill deep down into your code to find the exact component
    that caused the error.
  prefs: []
  type: TYPE_NORMAL
- en: Testing – batteries included
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When you start a new project with Laravel, you are provided with both a configuration
    file with sensible defaults for PHPUnit at the root of the project inside `phpunit.xml`
    as well as a directory, `tests/`, where you are expected to save your tests. This
    directory even contains an example test that you can use as a starting point.
  prefs: []
  type: TYPE_NORMAL
- en: 'With these settings in place, from the root of our project, all we need to
    do is SSH into our Homestead virtual machine and run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: This command will read the XML configuration file and run our tests. If, at
    this stage, you get an error message telling you that PHPUnit cannot be found,
    you either need to add the `phpunit` command to your `PATH` variable or install
    it with Composer.
  prefs: []
  type: TYPE_NORMAL
- en: 'Laravel applications come with PHPUnit already declared in the `autoload-dev`
    block in your `composer.json` file. After running `composer update`, you will
    be able to call PHPUnit by using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Framework assertions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now that we know about the two major types of tests and have PHPUnit installed,
    we are going to write a few tests for the application that we developed in [Chapter
    3](ch03.html "Chapter 3. Your First Application"), *Your First Application*.
  prefs: []
  type: TYPE_NORMAL
- en: 'This first test will verify whether visitors are redirected to the correct
    page when they first visit our site:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we made use of the `call()` method that simulated a request to our application,
    which executes the request through Laravel''s HTTP kernel. Then, we used one of
    the assertion methods provided by Laravel to make sure that the response is a
    redirection to the new location. If you now run the `phpunit` command, you should
    see the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '`OK (1 test, 2 assertions)`'
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we can try to write a test to make sure that the creation form is not
    accessible to the users that are not logged in; this is shown in the following
    code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Impersonating users
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Sometimes, you may wish to run a test as if you were a registered user of the
    application. This is possible by using the `be()` method and passing a `User`
    instance to it or whichever Eloquent model you use, along with Laravel''s authentication
    class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Testing with a database
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: While some developers would advise against writing tests that hit the database,
    it can often be a simple and effective way of making sure that all the components
    work together as expected. However, it should only be done once each individual
    unit has been tested. Let's also not forget that Laravel has support for migrations
    and seeding; in other words, it has all of the tools that are required to recreate
    an identical data structure from scratch, before each test.
  prefs: []
  type: TYPE_NORMAL
- en: 'To write tests that depend on a database, we need to override the `setUp()`
    method in our tests to migrate and seed the database each time a test is run.
    It is also important to run the parent `setUp()` method, otherwise, the test case
    will not be able to start properly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we need to configure a test database connection in `config/database.php`;
    if the application does not contain any database-specific queries, we can use
    SQLite''s in-memory feature by setting `:memory:` instead of a path to the database
    file. The following configuration also has the potential to speed up our tests:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'And lastly, since we are going to test the editing and deletion features, we
    are going to need at least one row in the `cats` table of our database, so we
    prepare a seeder that will insert a cat with a forced `id` of value `1`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Once this is done, we can test the deletion feature as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that this time, we did not need to enable the filters since the permissions
    are checked by a method in the `User` model. Since the database is wiped and re-seeded
    after each test, we do not need to worry about the fact that the previous test
    deleted that particular cat. We can also write a test to ensure that a user who
    is not an administrator cannot edit someone else''s cat profile:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Inspecting the rendered views
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Since Laravel ships with Symfony''s `DomCrawler` and `CssSelector` components,
    it is possible to inspect the contents of a rendered view. By issuing a request
    through the test client instance with `$this->client->request()`, you can filter
    its contents with CSS queries as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: The complete documentation for the `DomCrawler` component can be found at [http://symfony.com/doc/current/components/dom_crawler.html](http://symfony.com/doc/current/components/dom_crawler.html).
    If you are already familiar with jQuery, its syntax will look familiar to you.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: While the main ideas behind testing are easy to grasp, it is often their implementation
    that can prove to be an obstacle, especially when working with a new framework.
    However, after reading this chapter, you should have a good overview of how you
    can test your Laravel applications. The techniques presented in this chapter will
    enable you to write more robust and future-proof applications.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will explore the possibilities offered by Artisan, Laravel's
    command-line utility.
  prefs: []
  type: TYPE_NORMAL
