<html><head></head><body>
        <section>

                            <header>
                    <h1 class="header-title">Managing Database Structure, Storage, and Retrieval</h1>
                </header>
            
            <article>
                
<p>The database is the primary location for storing application data. WordPress provides a built-in database with pre-defined tables, compared to traditional web applications, where the database is designed from scratch. Getting used to the pros and cons of the existing database table is the key to developing quality themes and plugins.</p>
<p>In this chapter, we will learn the power and limitations of the existing database tables in Wordpress. You will get an overview of existing database tables and their role, while understanding how data is managed in common functions such as post creation, user creation, media uploads, and so on. You will also learn the uses of custom tables in development, and using the query functions to retrieve data. </p>
<p>In this chapter, we will cover the following topics:</p>
<ul>
<li>Understanding the role of default database tables</li>
<li>Tracking and understanding database usage of primary features</li>
<li>Creating and managing custom tables</li>
<li>Implementing CRUD operations</li>
<li>A brief overview of the multisite database structure</li>
</ul>
<p>By the end of this chapter, you will have the necessary knowledge to maximize the use of existing database tables in development, while using custom tables for advanced use cases.</p>
<p class="mce-root"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Introduction to the WordPress database</h1>
                </header>
            
            <article>
                
<p>The process of planning and designing a database is one of the most critical phases of any project. A well-planned database design eases the process for future growth while increasing performance in data storage and retrieval. Usually, it's the responsibility of the development team to identify the entities and relationships between these entities. WordPress, on the other hand, is a CMS and hence offers an existing database to handle core features. So, the process of planning a database is not part of the responsibility as a developer in most scenarios. Instead, developers have a tougher task of understanding the core tables and managing the data needs with its limitations. Of course, you can create and use your own database tables for any requirement. But, doing so eliminates the whole purpose of developing on top of WordPress.</p>
<p>The WordPress database currently supports MySQL and MariaDB, with <span>MariaDB</span> being the most preferred choice. However, most of the existing WordPress sites still use MySQL. On successful installation, WordPress will create eleven database tables to cater for the core functionality. Since its inception, backward compatibility was one of the top priorities of the WordPress team. Therefore, you may not see major changes in these eleven tables in the near future. </p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Understanding the role of built-in database tables</h1>
                </header>
            
            <article>
                
<p>The WordPress database structure is designed to store a minimum amount of data required for core features. Therefore, developers need to have a thorough understanding of the existing tables in order to use them effectively to build flexible websites. Let's take a look at the entity relationship diagram of the latest WordPress versions:</p>
<div class="packt_figref CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-269 image-border" src="assets/936a56ee-be42-4989-925b-6c807c7e327f.png" style="width:38.08em;height:53.67em;"/></div>
<p>As may notice, all the existing tables don't have more than one or two relationships with other tables, and hence understanding and working with the database becomes a simpler task. Now, we are going to look at each database table with important columns, its role, and how it works with other tables. You need to refer to the preceding diagram to visualize the points in our discussion.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Posts-related database tables</h1>
                </header>
            
            <article>
                
<p>Three database tables are directly involved with posts and six tables handle posts-related data. Many of the existing WordPress sites are either basic sites with a few pages, or blogs with hundreds of posts. So, the data of the majority of the sites are managed by these six database tables. Let's take a look at the two tables directly related to posts.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">wp_posts </h1>
                </header>
            
            <article>
                
<p>This is the primary data storage location of many WordPress sites and applications. This table consists of the main data for posts, pages, and custom post types. This table consists of twenty-three columns. Let's identify some of the most important columns in this table:</p>
<table border="1" style="border-collapse: collapse;width: 100%">
<tbody>
<tr>
<td class="CDPAlignCenter CDPAlign" style="width: 35.9504%"><kbd><span>post_author</span></kbd></td>
<td style="width: 63.2231%"><span>This is where you find the ID of the user who created the post or page. This column is used to form the relationship with the</span> <kbd>wp_users</kbd><span> table.</span></td>
</tr>
<tr>
<td class="CDPAlignCenter CDPAlign" style="width: 35.9504%"><kbd><span>post_content</span></kbd></td>
<td style="width: 63.2231%"><span>The complete content of the post/page is stored in this column. So, the data in this column can range from a few words to thousands of words and images.</span></td>
</tr>
<tr>
<td class="CDPAlignCenter CDPAlign" style="width: 35.9504%"><kbd><span>post_title</span></kbd></td>
<td style="width: 63.2231%"><span>The title of the post/page is stored in this column. It's used to identify the page in the backend as well as highlight the title in the frontend.</span></td>
</tr>
<tr>
<td class="CDPAlignCenter CDPAlign" style="width: 35.9504%"><kbd><span>post_excerpt</span></kbd></td>
<td style="width: 63.2231%"><span>The data in this column is optional and used for keeping a summary of the post/page. Usually, this is used in post lists (archive) pages to show a glimpse of what the post is about, and encourage users to read the entire post.</span></td>
</tr>
<tr>
<td class="CDPAlignCenter CDPAlign" style="width: 35.9504%"><kbd><span>post_status</span></kbd></td>
<td style="width: 63.2231%"><span>WordPress-specific post statuses are stored in this column. These statuses defines a step in the life cycle of a post. Default statuses include publish, pending, private, future, inherit, trash, draft, and auto-draft. Most of these statuses are self-explanatory. However, you may need explanations on the  inherit and auto-draft statuses. WordPress provides the ability to store revisions of posts in the database. When we update a post, the previous post data in the database automatically becomes a revision with the status marked as </span><strong>inherit</strong><span>. Also, WordPress automatically saves posts at certain time intervals, and those revisions are marked as </span><strong>auto-draft</strong><span>.</span></td>
</tr>
<tr>
<td class="CDPAlignCenter CDPAlign" style="width: 35.9504%"><kbd><span>post_password</span></kbd></td>
<td style="width: 63.2231%"><span>This stores the password of password-protected posts or pages.</span></td>
</tr>
<tr>
<td class="CDPAlignCenter CDPAlign" style="width: 35.9504%"><kbd><span>post_parent</span></kbd></td>
<td style="width: 63.2231%"><span>This column stores the ID of the parent post. WordPress supports child posts for attachments, pages, and post revisions.</span></td>
</tr>
<tr>
<td class="CDPAlignCenter CDPAlign" style="width: 35.9504%"><kbd>guid</kbd><span> </span></td>
<td style="width: 63.2231%"><span>The complete URL of the post/page is stored in this column.</span></td>
</tr>
<tr>
<td class="CDPAlignCenter CDPAlign" style="width: 35.9504%"><kbd>post_type</kbd><span> </span></td>
<td style="width: 63.2231%"><span>This stores the type post with a unique key. Default post types includes post, page, revision, attachment, and <kbd>nav_menu_item</kbd>. Apart from these types, you can create any new type using custom post types.</span></td>
</tr>
</tbody>
</table>
<p> </p>
<p>Usually, this table is intended for built-in types such as posts, pages, menus, and attachments. With the introduction of custom post types, this table is used widely for storing data such as products, forum topics, properties, and anything that you can think of.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">wp_postmeta </h1>
                </header>
            
            <article>
                
<p>This is the secondary storage for posts where optional data related to posts and pages are stored. This table consists of four columns. Let's identify some of the most important columns in this table:</p>
<table border="1" style="border-collapse: collapse;width: 100%">
<tbody>
<tr>
<td class="CDPAlignCenter CDPAlign" style="width: 36.7769%"><kbd><span>post_id</span></kbd></td>
<td style="width: 62.3967%"><span>This is where you find the ID of the post for these additional data. This column is used to form the relationship with the</span> <kbd>wp_posts</kbd><span> table.</span></td>
</tr>
<tr>
<td class="CDPAlignCenter CDPAlign" style="width: 36.7769%"><kbd><span>meta_key</span></kbd></td>
<td style="width: 62.3967%"><span>All the additional post data is saved as key-value pairs. This column defines the identification for post data. A unique key should be used for this column with alpha numeric characters, underscores, and dashes. By default, WordPress stores </span><strong>edit lock</strong><span> info for posts and pages. As you add data to posts or create menus, you will see more keys stored with underscore prefixes. This is different to what we have used as developers, where we store such data in a different table with these keys as columns.</span></td>
</tr>
<tr>
<td class="CDPAlignCenter CDPAlign" style="width: 36.7769%"><kbd><span>meta_value</span></kbd></td>
<td style="width: 62.3967%"><span>This column contains the posts-related data for the specified meta keys. Usually, these values are stored as plain text or serialized values.</span></td>
</tr>
</tbody>
</table>
<p class="mce-root"/>
<p class="mce-root"/>
<p>Usually, this table is used to store administration-level values and custom fields added from the post edit screen. In large sites with custom post types, this table becomes crucial. In such sites, we can store data such as product options in an online store, property details in real-estate sites, and job details in a job management site.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Terms-related tables</h1>
                </header>
            
            <article>
                
<p>We can find four tables in this section, targeted for handling post-specific categorization. We use the term <em>taxonomoy</em> in WordPress for these categorizations. By default, we have two taxonomies called categories and tags. These tables are capable of handling these two taxonomy types as well as your own taxonomy types. Let's take a look at each of these four tables in detail.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">wp_terms </h1>
                </header>
            
            <article>
                
<p>This is used to store the choices for taxonomies. You should be aware of categories and tags in WordPress posts. We call those types taxonomies. The choice inside a taxonomy is called a term. <strong>Category</strong> is a taxonomy and choices we create such as Health, Sports, and Travel are considered terms. This table consists of four columns. Let's identify some of the most important columns in this table:</p>
<table border="1" style="border-collapse: collapse;width: 100%">
<tbody>
<tr>
<td class="CDPAlignLeft CDPAlign" style="width: 34.573%"><kbd><span>name</span></kbd></td>
<td style="width: 64.6006%"><span>Stores the title of the term that displays on the frontend of the site</span></td>
</tr>
<tr>
<td class="CDPAlignLeft CDPAlign" style="width: 34.573%"><kbd><span>slug</span></kbd></td>
<td style="width: 64.6006%"><span>Stores the unique identifier for the term</span></td>
</tr>
</tbody>
</table>
<p> </p>
<p>Initial WordPress installation generates two taxonomies, called category and post tag. However, no terms are created by default and only contains <strong>Uncategorized</strong> as a term. We can use this table to create post tags or category choices. Also, we can use this in custom scenarios for creating terms such as WordPress, PHP, and jQuery for job skills in a job management site.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">wp_termmeta </h1>
                </header>
            
            <article>
                
<p>This is the secondary location for storing data for terms. This table consists of four columns and works similar to other metadata tables using key-value pairs.</p>
<p>By default, this table is not used frequently. You may use this table to store additional details of your own terms. Assume you have terms for articles such as sports, health, travel. You want to display the archive pages of each of these categories using a different design. In such a scenario, you can store the CSS, images, templates in a term metatable and use this info to load the design.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">wp_term_relationships </h1>
                </header>
            
            <article>
                
<p>This used to form the relationship between posts and terms. This table consists of three columns and only IDs are used as data. Let's identify some of the most important columns in this table:</p>
<table border="1" style="border-collapse: collapse;width: 100%">
<tbody>
<tr>
<td class="CDPAlignLeft CDPAlign" style="width: 39.3939%"><kbd><span>object_id</span></kbd></td>
<td style="width: 59.7796%"><span>Stores the ID of the post or custom post type that connects with the taxonomy</span></td>
</tr>
<tr>
<td class="CDPAlignLeft CDPAlign" style="width: 39.3939%"><kbd><span>term_taxonomy_id</span></kbd></td>
<td style="width: 59.7796%"><span>Stores the ID of the taxonomy</span></td>
</tr>
</tbody>
</table>
<p>This is purely an associative table, which connects two tables using IDs. As a developer, you just need to assign the relationship, and this table doesn't have different uses based on the type of the site.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">wp_term_taxonomy </h1>
                </header>
            
            <article>
                
<p>This table stores the type of categorizations called taxonomies. This table consists of six columns. Let's identify some of the most important columns in this table:</p>
<table border="1" style="border-collapse: collapse;width: 100%">
<tbody>
<tr>
<td class="CDPAlignCenter CDPAlign" style="width: 37.741%"><kbd><span>term_id</span></kbd></td>
<td style="width: 61.4325%"><span>This is the ID of the term and is used to form the connection with the</span> <kbd>wp_terms</kbd><span> table.</span></td>
</tr>
<tr>
<td class="CDPAlignCenter CDPAlign" style="width: 37.741%"><kbd><span>taxonomy</span></kbd></td>
<td style="width: 61.4325%"><span>This is the unique slug for the taxonomy. Default taxonomies are category and </span><kbd>post_tag</kbd><span>.</span></td>
</tr>
<tr>
<td class="CDPAlignCenter CDPAlign" style="width: 37.741%"><kbd><span>parent</span></kbd></td>
<td style="width: 61.4325%"><span>Stores the parent term when using sub-terms in your site.</span></td>
</tr>
<tr>
<td class="CDPAlignCenter CDPAlign" style="width: 37.741%"><kbd><span>count</span></kbd></td>
<td style="width: 61.4325%"><span>Stores the number of posts and custom post types that belong to this taxonomy.</span></td>
</tr>
</tbody>
</table>
<p>This table contains default taxonomies for category and <kbd>post_tag</kbd>, to be used in normal WordPress posts. We can create custom taxonomies such as job skills in a job management site, product types in an online store, property features in a real-estate site, and so on.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">User-related tables</h1>
                </header>
            
            <article>
                
<p>User data is managed using two tables in the existing database. By default, we have very basic details about users stored in these tables. Modern sites bring the concept of personalized content, and hence user management is becoming more and more important. So, you see extensive use of these tables in many websites. Let's take a look at each of these two tables in detail.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">wp_users </h1>
                </header>
            
            <article>
                
<p>This is the primary storage location for users, consisting of ten columns. Let's identify some of the most important columns in this table:</p>
<table border="1" style="border-collapse: collapse;width: 100%">
<tbody>
<tr>
<td class="CDPAlignCenter CDPAlign" style="width: 35.8127%"><kbd><span>user_login</span></kbd></td>
<td style="width: 63.3609%"><span>Used as the username for the site. You can allow users to change it using your own implementations. However, this value needs to be unique.</span></td>
</tr>
<tr>
<td class="CDPAlignCenter CDPAlign" style="width: 35.8127%"><kbd><span>user_pass</span></kbd></td>
<td style="width: 63.3609%"><span>Stores the encrypted password for the user.</span></td>
</tr>
<tr>
<td class="CDPAlignCenter CDPAlign" style="width: 35.8127%"><kbd><span>user_email</span></kbd></td>
<td style="width: 63.3609%"><span>Used as the email of the user. Since WordPress allows users to login with email, this value needs to be unique for each user.</span></td>
</tr>
<tr>
<td class="CDPAlignCenter CDPAlign" style="width: 35.8127%"><kbd><span>user_registered</span></kbd></td>
<td style="width: 63.3609%"><span>Stores the registration date and is often used to sort the list of users or assign the membership period on membership-based sites.</span></td>
</tr>
</tbody>
</table>
<p> </p>
<p>The data in this table doesn't change based on the type of site you are developing, and hence you only need to have knowledge on inserting, updating, and deleting users in this table.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">wp_usermeta</h1>
                </header>
            
            <article>
                
<p>Used as the secondary location for user data. By default, it keeps track of names, descriptions, capabilities, and so on. This table consists of four columns. Let's identify some of the most important columns in this table:</p>
<table border="1" style="border-collapse: collapse;width: 100%">
<tbody>
<tr>
<td class="CDPAlignCenter CDPAlign" style="width: 35.551%"><kbd><span>user_id</span></kbd></td>
<td style="width: 62.449%"><span>This is where you find the ID of the user that this data belongs to. This column is used to form the relationship with the</span> <kbd>wp_users</kbd><span> table.</span></td>
</tr>
<tr>
<td class="CDPAlignCenter CDPAlign" style="width: 35.551%"><kbd><span>meta_key</span></kbd></td>
<td style="width: 62.449%"><span>All the additional user data is saved as key-value pairs. This column defines the identification for user data. A unique key should be used for this column with alpha numeric characters, underscores, and dashes. This is different to what we have used as developers, where we store such data in a different table with these keys as columns.</span></td>
</tr>
<tr>
<td class="CDPAlignCenter CDPAlign" style="width: 35.551%"><kbd><span>meta_value</span></kbd></td>
<td style="width: 62.449%"><span>This column contains the user-related data for the specified metakeys. Usually, these values are stored as plain text or serialized values.</span></td>
</tr>
</tbody>
</table>
<p> </p>
<p>Apart from default options, we can use this table to store simple custom user data such as date of birth, country, city, and advanced user data such as interests, and profile pictures.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Options and comments tables</h1>
                </header>
            
            <article>
                
<p>This section consists of three tables used for configurations and comments. Let's take a look at these tables in detail.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">wp_options </h1>
                </header>
            
            <article>
                
<p>This stores all the built-in and custom settings for WordPress. This is another table similar to <kbd>wp_postmeta</kbd> and <kbd>wp_usermeta</kbd>, where key-value pairs are used for keeping data. Default options in this table include the site URL, site description, date format, and so on.</p>
<p>Developers can use this table to store settings for their themes or plugins. Usually, plugin or theme settings are stored as a single row in this table as a serialized value. However, you can store as many options based on your preference.</p>
<p class="mce-root"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">wp_comments </h1>
                </header>
            
            <article>
                
<p>This stores comments for posts, pages, and custom post types. This table consists of fifteen columns. Let's identify some of the most important in the following table:</p>
<table border="1" style="border-collapse: collapse;width: 100%">
<tbody>
<tr>
<td class="CDPAlignCenter CDPAlign" style="width: 35.3994%"><kbd><span>comment_post_ID</span></kbd></td>
<td style="width: 63.7741%"><span>Stores the post, page, or custom post type ID where the comment belongs.</span></td>
</tr>
<tr>
<td class="CDPAlignCenter CDPAlign" style="width: 35.3994%"><kbd><span>comment_author</span></kbd></td>
<td style="width: 63.7741%"><span>Keeps the name of the user who created this comment.</span></td>
</tr>
<tr>
<td class="CDPAlignCenter CDPAlign" style="width: 35.3994%"><kbd><span>comment_content</span></kbd></td>
<td style="width: 63.7741%"><span>Used to keep the comment added by the user. This column can contain plain text values as well as HTML depending on the allowed options in the site.</span></td>
</tr>
<tr>
<td class="CDPAlignCenter CDPAlign" style="width: 35.3994%"><kbd><span>comment_approved</span></kbd></td>
<td style="width: 63.7741%"><span>In most sites, a comment needs to be approved before it appears for public. This column stores Boolean status on whether a comment is approved or pending approval.</span></td>
</tr>
<tr>
<td class="CDPAlignCenter CDPAlign" style="width: 35.3994%"><kbd><span>comment_type</span></kbd></td>
<td style="width: 63.7741%"><span>Stores the type of comment. Default comment types includes comment, pingbacks, and trackbacks. We can also use custom comment types.</span></td>
</tr>
<tr>
<td class="CDPAlignCenter CDPAlign" style="width: 35.3994%"><kbd><span>user_id</span></kbd></td>
<td style="width: 63.7741%"><span>ID of the user who created the comment. This column is used to form the connection with the</span> <kbd>wp_users</kbd><span> table.</span></td>
</tr>
</tbody>
</table>
<p> </p>
<p>Usually, this table is used for basic comments of posts, pages, and custom post types. However, we can think beyond the convention by using comments in innovative ways. We can use comments for features such as answers of a question-based site such as stackoverflow, user messages in a forum topic, or reviews in an online product marketplace.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">wp_commentmeta </h1>
                </header>
            
            <article>
                
<p>This is used as the secondary location for storing additional comment data. This table consists of four columns and works similar to other metadata tables in WordPress.</p>
<p>There are no default usages of this table. We can use this table to store additional data such as ratings in a product review site, verified status in a question-answer site, and so on.</p>
<p>In this section, we looked at all eleven default database tables in WordPress and their role in development. You have to understand each and every column of these tables with the possible values, as most of the WordPress development is done on top of the core features.</p>
<p class="mce-root"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Understanding the importance of database usage</h1>
                </header>
            
            <article>
                
<p>In today's world, many of the developers doesn't have in-depth knowledge of WordPress core features and yet, capable of turning your requirement into a working solution. However, these solutions are often based on assumptions, rather than knowing the exact process and data usage under the hood.</p>
<p>Tracking database usage and knowing the exact data needs of any given process is crucial for building flexible and extendable solutions that integrate perfectly with other parts of the site. Let's identify some of the use cases where you need perfect knowledge of data usage in WordPress features:</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Building existing features on the frontend</h1>
                </header>
            
            <article>
                
<p>WordPress offers a powerful backend with many features for administration-level users. Post creation and user management are some of the top features in backend. Comparatively, existing WordPress frontend features are less powerful and mainly focus on displaying data. So, it’s a common requirement to transfer these backend features to the frontend, allowing users with lesser permissions to create content from the frontend without giving access to the backend.</p>
<p>In such scenarios, we need to know the exact data used in the backend process, so that we can emulate it on the frontend process. Often, developers don't have necessary knowledge of all data stored in such a process. So, the frontend aspect of this feature works perfectly, but breaks the backend due to lack of data.</p>
<p>Let's consider a simple scenario where you want to let users upload files using a form on your site, and store the files in a WordPress media library. At first glance, you will see that media files are stored in the <kbd>wp_posts</kbd> table and contains the necessary data. So, you will save the data to the <kbd>wp_posts</kbd> table. However, you may not notice that additional metadata for files are stored in the <kbd>wp_postmeta</kbd> table. Therefore, your frontend implementation may break the core features or other plugins that rely on this data.</p>
<p class="mce-root"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Customizing existing plugins</h1>
                </header>
            
            <article>
                
<p>Use of other existing plugins is almost certain in WordPress site development. Often, these plugins don't fit directly for our needs, and hence the customization becomes an obvious choice. Understanding the use of data becomes even more crucial since some of these custom plugins lack documentation and code quality compared to core features. Customizing a plugin without knowing its data usage can lead to major conflicts compared to core features.</p>
<p><strong> </strong>In such scenarios, we need a thorough examination of documentation to manually track database usage and when possible get the support of the developer to build custom solutions. Let me pick up and example from one of our own plugins. We have a user profile management plugin where we store additional user details in the <kbd>wp_usermeta</kbd> table. Since searching hundreds of rows per user in the <kbd>wp_usermeta</kbd> table is a cumbersome task, we also store all additional data in a single row as a search cache. We have seen many developers customizing the plugin to update user data, without knowing the need for a search cache value. Even though user data is updated, users don't appear in search results due to the missing search cache value. Such scenarios are common in plugin customizations and it's a must identify and avoid them using data tracking methods.</p>
<p>We have looked at the most common situations where tracking and knowing the data usage becomes critical. You may find other less common situations where consistency of the data becomes essential.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How to track database usage in WordPress</h1>
                </header>
            
            <article>
                
<p>We identified the importance of tracking and knowing the data needs of core features as well as custom features. The next question is how we can track and understand data to avoid potential conflicts. So, we need a method that logs/shows all queries run within a user request. There are numerous ways to track database queries, including premium enterprise tools and the command line. As you are beginning WordPress development, we are going to look at some of the simpler and useful methods that expand your knowledge.</p>
<p class="mce-root"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Using MySQL/MariaDB log files </h1>
                </header>
            
            <article>
                
<p>This is one of the simpler and must-know methods as a developer. Both MySQL and MariaDB allow us to create a log file where we can track all the steps in connecting, initializing, and executing queries in a database. First, we need to add some configurations to the MySQL/<span>MariaDB</span> <kbd>ini</kbd> file. Since we are using WAMP for the development tasks of this book, you can click on the WAMP icon, go to the MySQL section, and open the <kbd>my.ini</kbd> file. You can use the same process for MAMP or any other tools that offer MySQL/<span>MariaDB</span> configuration.</p>
<div class="packt_infobox">In Linux servers, the MySQL/MariaDB configuration file is often <kbd>/etc/mysql/my.cnf</kbd>; if you don't find it try to locate it using <kbd>sudo updatedb ; locate my.cnf</kbd>.</div>
<p>Next, you can add the following lines to the end of the file to configure the log file output:</p>
<pre>[mysqld]<br/>log-output = FILE<br/>general-log = 1<br/>general_log_file=C:/wamp/logs/general-query.log</pre>
<div class="packt_infobox">In linux servers, you can use <kbd>/var/log/mysql/mysql-debug.log</kbd> instead of <kbd>C:/wamp/logs/general-query.log</kbd> for the log file path. After modifying, restart MySQL/MariaDB server like this: <kbd>/etc/init.d/mysql restart</kbd>.</div>
<p>Once the rules are added, you should save and restart the WAMP server. Now, you can refresh your WordPress site to test a user request.</p>
<div class="packt_infobox"><span>Keep in mind that many of the hosting providers don't allow access to MySQL/MariaDB logs.</span></div>
<p>Then, open the log file in given location and you will see many queries executed within that request. So, you can use this method to track database changes by clearing the file, executing the request, and viewing the updated log file. The limitation of this method is that it shows all queries including numerous <kbd>SELECT</kbd> queries. Since we only want to track <kbd>INSERT</kbd>, <kbd>UPDATE</kbd>, and <kbd>DELETE</kbd> queries, it's not the perfect method.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Comparing database backups </h1>
                </header>
            
            <article>
                
<p>This is one of the easier methods to compare the changes, instead of reviewing executed queries, and identify them. In this method, we take a database backup using <kbd>phpMyAdmin</kbd>, execute the user request, and take another database backup. Then, we can use a file compare tool like <strong>MELD</strong> (<a href="http://meldmerge.org/">http://meldmerge.org/</a>) to check how the database is changed within the request. The limitation of this process is that you need to manually take database backups, and comparing may become time-consuming for larger databases.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Creating a manual query logger </h1>
                </header>
            
            <article>
                
<p>This is the ideal method where we create our own query logger and specify which queries we need to track. Let's look at the implementation of this method using the following code:</p>
<pre>function wpc_filter_query( $query ) {<br/>  if (strpos($query, 'INSERT') !== false || strpos($query, 'UPDATE') !== false || strpos($query, 'DELETE') !== false)<br/>    error_log('#### $query', 0);<br/><br/>  return $query;<br/>};<br/>add_filter( ‘query', ‘wpc_filter_query', 10, 1 );</pre>
<p>The preceding code uses WordPress <strong>query</strong> filter to filter all the queries that are executed in user request. A complete <kbd>sql</kbd> query is parsed as a parameter and we filter <kbd>INSERT</kbd>, <kbd>UPDATE</kbd>, and <kbd>DELETE</kbd> queries. Then, we can log the queries to a preferred file. Here, we are adding the queries to PHP error log for illustration purposes. You can check the expected queries using the log file at <kbd>wamp/logs/php_error.log</kbd>. You can include this code in the <kbd>functions.php</kbd> file of the theme, until we get into plugin development.</p>
<p>You can choose one of the preferred methods or an external database tool to track database usage for any user request, and understand the must-use data of different processes.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Tracking database usage of common WordPress features</h1>
                </header>
            
            <article>
                
<p>At this point, you should be able to configure and track database usage for both backend and frontend user requests. In this section, we will be looking at the usage of database in the most common WordPress features, and understand the need for storing the specified data.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Post creation</h1>
                </header>
            
            <article>
                
<p>Being the most frequently used feature in WordPress sites, you need thorough understanding of the database usage. First, you need to go to <strong><span class="packt_screen">Posts</span></strong> | <strong><span class="packt_screen">Add New</span></strong> section and clear the existing query logs. Then, you can add the data and publish a post to track the database usage. The <span class="packt_screen">Post creation</span> screen offers wide range of features and hence database usage may vary based on the amount of options you use. Let's track the queries by using the most common options in post creation:</p>
<pre>INSERT INTO `wp_posts` (`post_author`, `post_date`...........) VALUES (1, '2018-07-13 08:43:22'.....)<br/>UPDATE `wp_posts` SET `post_author` = 1, `post_date` = '2018-07-13 08:43:30' ..... WHERE `ID` = 48<br/>INSERT INTO `wp_postmeta` (`post_id`, `meta_key`, `meta_value`) VALUES (48, 'test field', '1')<br/>INSERT INTO `wp_term_relationships` (`object_id`, `term_taxonomy_id`) VALUES (48, 23)<br/>UPDATE `wp_term_taxonomy` SET `count` = 3 WHERE `term_taxonomy_id` = 23<br/>INSERT INTO `wp_term_relationships` (`object_id`, `term_taxonomy_id`) VALUES (48, 24)<br/>UPDATE `wp_term_taxonomy` SET `count` = 4 WHERE `term_taxonomy_id` = 24</pre>
<p>The log file will contain a large amount of queries. Many of them are generated due to the WordPress autosaving process and temporary data storage for transients, cache, and admin-level options. We have omitted such queries and included the essential ones for understanding post creation.</p>
<p>In this scenario, we have assigned existing categories, tags and custom fields, along with the main post content. As you can see, the process starts with a INSERT query to the <kbd>wp_posts</kbd> table, where all primary post-specific data is stored. This query is executed as soon as you load the post creation screen. Then, WordPress updates the already created post when you hit the <span class="packt_screen">Publish</span> button. The next query adds the custom field data to the <kbd>wp_postmeta</kbd> table. If you have multiple custom fields, you will see multiple such queries, one for each field.</p>
<p>Next, two queries relate the post with the category and update the post count for that specific category. The remaining two queries use the same process for tags instead of category. Here, we have seen the use of four database tables in post creation. Instead of using existing categories and tags, we can create new ones to analyze the use of all six post related tables in post creation. I recommend you further track the database usage by changing post statuses, adding a featured image, changing post formats, and changing post visibility.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Page creation</h1>
                </header>
            
            <article>
                
<p>This is similar to post creation process where we use <strong><span class="packt_screen">Pages</span></strong> | <strong><span class="packt_screen">Add New</span></strong> section to load the page creation screen. We have less options in page creation compared to post creation process. Therefore, we should notice a decrease in the number of queries executed in this process. Let's take a look at the executed queries:</p>
<pre>INSERT INTO `wp_posts` (`post_author`, `post_date`, ........) VALUES (1, '2018-07-13 09:09:15',.......)<br/>UPDATE `wp_posts` SET `post_author` = 1, `post_date` = '2018-07-13 09:09:31', ..... WHERE `ID` = 49</pre>
<p>As we anticipated, only two queries executed in this process. The first one creates the page on screen load and the next one updates the content when the user hits the <span class="packt_screen"><strong>Publish</strong></span> button. So, it's easier to manage pages as a developer, compared to posts.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">User creation</h1>
                </header>
            
            <article>
                
<p>Many websites consist of just one or two administrators, with the registration feature blocked for public. However, the need for user registrations is rising in modern websites due the need of personalized content, rather than same content for all users. So, frontend registration becomes a common implementation. Let's track the database usage by creating user from the backend <strong><span class="packt_screen">Users</span></strong> | <strong><span class="packt_screen">Add New</span></strong> section:</p>
<pre>INSERT INTO `wp_users` (`user_pass`, `user_email`, `user_url`, `user_nicename`, `display_name`, `user_registered`, `user_login`)<br/>VALUES ('$P$B.NS/td6lI7ug01eNW64p.', 'testuseremail@gmail.com', '', 'testuser', 'john doe', '2018-07-13 09:14:21', 'testuser')<br/>INSERT INTO `wp_usermeta` (`user_id`, `meta_key`, `meta_value`) VALUES (4, 'nickname', 'testuser')<br/>INSERT INTO `wp_usermeta` (`user_id`, `meta_key`, `meta_value`) VALUES (4, 'first_name', 'john')<br/>INSERT INTO `wp_usermeta` (`user_id`, `meta_key`, `meta_value`) VALUES (4, 'locale', '')<br/>INSERT INTO `wp_usermeta` (`user_id`, `meta_key`, `meta_value`) VALUES (4, 'wp_capabilities', 'a:1:{s:10:\"subscriber\";b:1;}')</pre>
<p>The process starts by inserting a new user to the <kbd>wp_users</kbd> table with primary details such as username, email, password, and registered date. The additional details of users goes to <kbd>wp_usermeta</kbd> table with key-value pairs. Again, this is different to what we have used as developers, where we store such data in a different table with these keys as columns. We can see many INSERT queries to store details such as names, description, language, and so on. Among these values, <kbd>locale</kbd> and <kbd>wp_capabilities</kbd> are crucial ones where we define the language for the user and maintain the user roles and capabilities. Developers can use the <kbd>wp_usermeta</kbd> table to store custom data required for their websites.</p>
<p class="mce-root"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Media uploads</h1>
                </header>
            
            <article>
                
<p>We rarely see only full text-based content in modern websites. Most posts and pages are designed to use images and videos. So, media manager becomes a must user feature for many site owners. Using and developing with the WordPress media uploader could be different compared to building file upload forms from scratch. Let's review the use of database for media uploads using <strong><span class="packt_screen">Media</span></strong> | <strong><span class="packt_screen">Add New</span></strong> section:</p>
<pre>INSERT INTO `wp_posts` (`post_author`, `post_date`, ...........) VALUES (1, '2018-07-13 09:16:26',....)<br/>INSERT INTO `wp_postmeta` (`post_id`, `meta_key`, `meta_value`) VALUES (50, '_wp_attached_file', '2018/07/test.png')<br/>INSERT INTO `wp_postmeta` (`post_id`, `meta_key`, `meta_value`) VALUES (50, '_wp_attachment_metadata', 'a:5:{s:5:\"width\";i:512;s:6:\"height\";i:512.....')</pre>
<p>In conventional development, we use a separate table to store the uploaded file details. However, WordPress uses a different approach by considering media as a post type. It might not be the ideal implementation as a large amount of media files could affect the performance of loading important posts and pages. But, we need to get used to the process. So, the main media file details are stored in the <kbd>wp_posts</kbd> table. Apart from that, two metafields are created in the <kbd>wp_postmeta</kbd> table to handle path and metadata such as captions, width, height. As a developer, we can use the postmeta table to store many additional data required for media files in your projects.</p>
<p>We used four of the most frequently used scenarios to track database usage. You might have already understood the importance of consistent data and use of database tracking to achieve it. Here, we have tracked the queries in a default WordPress installation. As we use more and more plugins, these scenarios becomes extremely complex. So, I recommend you use this technique to track data for the features of popular WordPress plugins, and understand how we can customize the features without breaking other parts.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Overview of the multisite database structure</h1>
                </header>
            
            <article>
                
<p>Multisite network is a feature that allows creation of multiple sites within the same WordPress installation, while sharing the available resources. Developers moving to WordPress from pure PHP development may be unfamiliar with this concept. The whole database structure changes in multisite in a way that we can't anticipate. So, it's important to get an idea of how multisite database works in case you are planning to develop multisite compatible plugins and themes. The following is a simple illustration of the changes in multisite compared to single site installations:</p>
<p class="mce-root"/>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-270 image-border" src="assets/f24dbb0b-bf0e-4167-8cd9-4c62cad3da06.png" style="width:36.42em;height:37.33em;"/></p>
<p>As you can see, six new tables have been added to the database and the existing tables have increased. This image only illustrates how tables are connected in multisite environment. However, this not a precise relationship diagram between the tables. Let's identify the role of six new tables in the preceding diagram:</p>
<ul>
<li><kbd>wp_site</kbd>: It is the main database table where all your network details are stored. WordPress allows you to create multiple networks in same installation. However, we rarely see real applications with more than one network in the same installation. This means this table will only have one record to store the network details, such as network domain and path.</li>
<li><kbd>wp_sitemeta</kbd>: It stores the options and settings for networks and works similar to the <kbd>wp_options</kbd> table.</li>
<li><kbd>wp_blogs</kbd>: It is the primary storage location for sites in network. Since you are running a multisite network, this table will contain two more records for site details including domain, path, created dates, and site-specific statuses.</li>
<li><kbd>wp_blog_versions</kbd>: It stores current database version of the sites available in network. WordPress will require certain database versions for its version upgrades. In such cases, this table will be used to track the database version.</li>
<li><kbd>wp_registration_log</kbd>: It stores the admin user details of each site in the network.</li>
<li><kbd>wp_signups</kbd>: It stores the new users added through the registration process of WordPress with the metadata for the respective site. These are also stored in the <kbd>wp_users</kbd> table of the respective site.</li>
</ul>
<p>We had a brief introduction to the multisite-specific tables. Let's see how other tables are connected in a multisite environment. Developers who are used to working with conventional database concepts such as normalization may find it tough to understand and get used the WordPress way of handling multisite. Usually, we design database tables with relationships between the necessary tables in way that everything is connected. However, in this scenario, we see some tables not connected with any other tables, while some tables are connected with other tables without table relationships. So, it's important to understand how these tables work within multisites.</p>
<p>The purpose of a multisite network is to share WordPress installation, themes, and plugins. However, we still need different database tables to handle data for each site in the network. WordPress creates multiple versions of the same database table in a multisite network. So, default tables are assigned to the first site of the multisite. The newly created sites in the network will have the same set of tables created with the prefix of <kbd>wp_2</kbd>, <kbd>wp_3</kbd>, and so on. The illustration shows that these core tables are connected with the <kbd>wp_blogs</kbd> table. However, there are no relationships between <kbd>wp_blogs</kbd> and other tables. Instead, when a site is loaded, WordPress identifies the loaded blog ID and then uses the tables with the prefix of the blog ID. Each site in the network shares WordPress installation, plugins, and themes while using separate database tables with the prefix of blog ID.</p>
<p>In development, a multisite structure may not become a major issue unless you don't follow the recommended ways of accessing the database. However, understanding where the data is stored for each site is important to test and resolve conflicts.</p>
<p class="mce-root"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Creating and managing custom tables</h1>
                </header>
            
            <article>
                
<p>A default WordPress database can be extended by any number of custom tables to suit our project's requirements. The only thing we have to consider is the creation of custom tables over existing ones. There are two major reasons for creating custom tables:</p>
<ul>
<li><strong>Difficulty of matching data to existing tables</strong>: Existing database tables are flexible enough to handle many common requirements. However, we need to be wise enough to choose custom tables in certain scenarios. Assume we have a requirement where we need to store user's previous job history. If we consider existing tables, we can only match this requirement to <kbd>wp_usermeta</kbd> table as key-value pairs. However, it's extremely difficult to implement proper search for these data by using the same metakey with multiple values. In such requirements, we need a custom table to create predefined columns and make user job searching a simpler process.</li>
<li><strong>Increased data volume</strong>: The posts table plays a major role in WordPress sites. When it comes to large-scale websites or applications with a sizeable amount of data, it's not recommended to keep all the data in a posts table. Let's assume that we are building a product catalog that creates millions of orders. Storing order details in the posts table as a custom post type is not the ideal implementation. In such circumstances, the posts table will go out of control due to the large dataset. The same theory applies to the existing meta tables as well. In these cases, it's wise to separate different datasets into their own tables to improve performance and keep things manageable.</li>
</ul>
<p>Now, we can look at the process of working with custom database tables.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Creating custom tables</h1>
                </header>
            
            <article>
                
<p>In pure PHP development, we create the database tables manually before moving onto the implementation phase. With the WordPress plugin-based architecture, it's certain that we might need to create custom tables using plugins in the later stages of the projects. Creating custom tables through plugins involves certain predefined procedures recommended by WordPress. Since table creation is a one-time task, we should implement the process on plugin activation or installation. Let's take a look at the code for creating custom database tables:</p>
<pre>function create_custom_tables() {<br/>  global $wpdb;<br/>  require_once( ABSPATH . 'wp-admin/includes/upgrade.php' );<br/>  $custom_table = $wpdb-&gt;prefix.'user_job_history'; <br/>  if($wpdb-&gt;get_var("show tables like '$custom_table'") != $custom_table) {<br/>    $sql = "CREATE TABLE $custom_table (<br/>              id mediumint(9) NOT NULL AUTO_INCREMENT,<br/>              time datetime DEFAULT '0000-00-00 00:00:00' NOT NULL,<br/>              user_id mediumint(9) NOT NULL,<br/>              job_title mediumint(9) NOT NULL,<br/>              job_description longtext NOT NULL,<br/>              job_period var varchar(255) NOT NULL,<br/>              UNIQUE KEY id (id<br/>                );";<br/>    dbDelta( $sql );<br/>  } <br/>}</pre>
<p>Firstly, we have to include the <kbd>upgrade.php</kbd> file to make use of the <kbd>dbDelta</kbd> function. The next most important thing is to use the prefix for database tables. By default, WordPress creates a prefix called <kbd>wp_</kbd> for all the tables. We should change the prefix in the installation process covered in <a href="205a9625-512c-4925-a3a8-bfe8a1784773.xhtml" target="_blank">Chapter 1</a>, <em>Introduction to WordPress Development</em>. It's important to use the existing prefix to maintain consistency and avoid issues in multisite scenarios. Next, we have to check the existence of a database table using the <strong>show tables</strong> query. Finally, you can define your table creation query and use the <kbd>dBDelta</kbd> function to implement it on the database.</p>
<div class="packt_infobox">Check out the guidelines for creating a table creation query at <a href="http://codex.wordpress.org/Creating_Tables_with_Plugins">http://codex.wordpress.org/Creating_Tables_with_Plugins</a>, as the <kbd>dbDelta</kbd> function can be tricky in certain scenarios.</div>
<p>We should only use plugin installation/uninstallation to create and delete custom tables to avoid unnecessary queries. Since we have not started plugin development yet, you need to wait for later sections of the book to understand how and where to use this code.</p>
<p>We looked at the necessity of custom tables in WordPress sites. Even though custom tables offer you more flexibility within WordPress, there will be a considerable number of limitations, as listed here:</p>
<ul>
<li>WordPress default backups will not include custom tables.</li>
<li>There are no built-in functions for the accessing database. All the queries, filtering, and validation needs to be done from scratch using the existing <kbd>$wpdb</kbd> variable.</li>
<li>User interfaces for displaying these tables' data need to be created from scratch.</li>
</ul>
<p>Therefore, you should avoid creating custom tables in all possible circumstances, unless they would be advantageous in the context of your application.</p>
<p class="mce-root"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Executing basic CRUD operations on existing tables</h1>
                </header>
            
            <article>
                
<p>WordPress provides well-optimized built-in methods for accessing the existing database tables. Therefore, we don't need to write our own queries. Let's see how basic <strong>Create, Read, Update, Delete</strong> (<strong>CRUD</strong>) operations are executed on existing tables.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Inserting records</h1>
                </header>
            
            <article>
                
<p>All the existing tables contain a pre-built insert functions for creating new records. Some of these functions uses a predefined set of parameters while other functions accepts array of information for inserting the record. Let's take a look at some of the frequently used insert functions:</p>
<table border="1" style="border-collapse: collapse;width: 100%">
<tbody>
<tr>
<td class="CDPAlignCenter CDPAlign" style="width: 39.9449%"><kbd>wp_insert_post</kbd></td>
<td style="width: 59.2287%"><span>Creates a new post or page in the </span><kbd>wp_posts</kbd><span> table. If this is used on an existing post, it will update the existing record. Accepts an array type parameter with all post details.</span></td>
</tr>
<tr>
<td class="CDPAlignCenter CDPAlign" style="width: 39.9449%"><kbd><span>add_option</span></kbd></td>
<td style="width: 59.2287%"><span>Creates a new option in the </span><kbd>wp_options</kbd><span> table, if it doesn’t already exist. Accepts key and value as parameters.</span></td>
</tr>
<tr>
<td class="CDPAlignCenter CDPAlign" style="width: 39.9449%"><kbd><span>wp_insert_user</span></kbd></td>
<td style="width: 59.2287%"><span>Creates a new user in the</span> <kbd>wp_users</kbd><span> table. Accepts an array type parameter with all post details.</span></td>
</tr>
</tbody>
</table>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Updating records</h1>
                </header>
            
            <article>
                
<p>All the existing tables contain a pre-built update method for updating existing records. The following list illustrates a few of the built-in update functions:</p>
<table border="1" style="border-collapse: collapse;width: 100%">
<tbody>
<tr>
<td style="width: 38.7052%"><kbd><span>update_post_meta</span></kbd></td>
<td style="width: 60.4683%"><span>This creates or updates additional details about posts in the </span><kbd>wp_postmeta</kbd><span> table. Accepts post ID, key, and value as parameters.</span></td>
</tr>
<tr>
<td style="width: 38.7052%"><kbd><span>wp_update_term</span></kbd></td>
<td style="width: 60.4683%"><span>This updates existing terms in the </span><kbd>wp_terms</kbd><span> table. Accepts term ID and taxonomy as parameters.</span></td>
</tr>
<tr>
<td style="width: 38.7052%"><kbd><span>update_user_meta</span></kbd></td>
<td style="width: 60.4683%"><span>This updates user meta details in the </span><kbd>wp_usermeta</kbd><span> table based on the user ID. Accepts user ID, key, and value as parameters.</span></td>
</tr>
</tbody>
</table>
<p class="mce-root"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Deleting records</h1>
                </header>
            
            <article>
                
<p>We have similar methods for deleting records in each of the existing tables as we have for updating records. The following list illustrates a few of the built-in delete functions:</p>
<table border="1" style="border-collapse: collapse;width: 100%">
<tbody>
<tr>
<td class="CDPAlignCenter CDPAlign" style="width: 39.1736%"><kbd><span>delete_post_meta</span></kbd></td>
<td style="width: 58.8264%"><span>This deletes custom fields using the specified key in the </span><kbd>wp_postmeta</kbd><span> table. Accepts post ID, key, and value as parameters.</span></td>
</tr>
<tr>
<td class="CDPAlignCenter CDPAlign" style="width: 39.1736%"><kbd><span>wp_delete_post</span></kbd></td>
<td style="width: 58.8264%"><span>This removes existing posts, pages, or attachments from the </span><kbd>wp_posts</kbd><span> table. Accepts post ID as parameter.</span></td>
</tr>
<tr>
<td class="CDPAlignCenter CDPAlign" style="width: 39.1736%"><kbd><span>delete_user_meta</span></kbd></td>
<td style="width: 58.8264%"><span>This removes the metadata matching criteria from a user from the </span><kbd>wp_usermeta</kbd><span> table. Accepts user ID, key, and value as parameters.</span></td>
</tr>
</tbody>
</table>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Selecting records</h1>
                </header>
            
            <article>
                
<p>As usual, there is a set of built-in functions for selecting records from the existing tables. The following list contains a few of the data-selecting functions:</p>
<table border="1" style="border-collapse: collapse;width: 100%">
<tbody>
<tr>
<td class="CDPAlignCenter CDPAlign" style="width: 36.2259%"><kbd><span>get_posts</span></kbd></td>
<td style="width: 62.9477%"><span>This retrieves the posts as an array from the </span><kbd>wp_posts</kbd><span> table based on the passed arguments. Also, we can use the </span><kbd>WP_Query</kbd><span> class with the necessary arguments to get the post list from the OOP method. Accepts an array type parameter with all post details.</span></td>
</tr>
<tr>
<td class="CDPAlignCenter CDPAlign" style="width: 36.2259%"><kbd><span>get_option</span></kbd></td>
<td style="width: 62.9477%"><span>This retrieves the option value of the given key from the </span><kbd>wp_options</kbd><span> table. Accepts a key parameter.</span></td>
</tr>
<tr>
<td class="CDPAlignCenter CDPAlign" style="width: 36.2259%"><kbd><span>get_users</span></kbd></td>
<td style="width: 62.9477%"><span>This retrieves a list of users as an array from the </span><kbd>wp_user</kbd><span> table. Accepts an array type parameter with all post details.</span></td>
</tr>
</tbody>
</table>
<p> </p>
<p>Most of the database operations on exiting tables can be executed using these built-in functions, and you rarely find scenarios for creating your own queries.</p>
<p class="mce-root"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Executing basic CRUD operations on custom tables</h1>
                </header>
            
            <article>
                
<p>WordPress provides a built-in class called <kbd>wpdb</kbd> for handling database queries. This class is located inside the <kbd>wp-includes</kbd> directory. The <kbd>wpdb</kbd> class will be available inside your plugins and themes as a global variable and provides access to all the tables inside the WordPress database, including custom tables. Using this class for queries adds an extra layer of security as well as optimizes the database queries.</p>
<div class="packt_infobox">Using the <kbd>wpdb</kbd> class for CRUD operations is straightforward with its built-in methods. A complete guide for using the <kbd>wpdb</kbd> class can be found at <a href="http://codex.wordpress.org/Class_Reference/wpdb">http://codex.wordpress.org/Class_Reference/wpdb</a>.</div>
<p>Basically, there are no built-in methods for accessing custom tables using direct functions, so it's a must to use the <kbd>wpdb</kbd> class for handling custom tables.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Inserting records</h1>
                </header>
            
            <article>
                
<p>The <kbd>wpdb</kbd> class provides a built-in insert function to insert records to custom database tables. So, we need to use it for better performance, instead of writing <kbd>INSERT</kbd> queries from scratch. Let's take look at the syntax of insert function:</p>
<pre>$wpdb-&gt;insert(<br/>  'table',<br/>  array( 'column1' =&gt; 'value1', 'column2' =&gt; 'value2' ),<br/>  array( '%s', '%d' )<br/>);</pre>
<p>The first parameter takes the table name. You need to specify the custom table name with the WordPress database prefix. The next parameter uses an array of column names and respective values. The final parameter defines the correct format for the fields defined in the previous array. We can get number of affected rows on success and false as a return value on failure.</p>
<p class="mce-root"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Updating and deleting records</h1>
                </header>
            
            <article>
                
<p>These operations works similar to insert, by using the update and delete functions of the <kbd>wpdb</kbd> class. Let's take a look at the syntaxes:</p>
<pre>$wpdb-&gt;update(<br/>  'table',<br/>  array( 'column1' =&gt; 'value1' ),<br/>  array( 'ID' =&gt; 1 ),<br/>  array( '%s' ),<br/>  array( '%d' )<br/>);</pre>
<p>In this method, clause conditions as an array for the third parameter and format of the columns in where clause as fifth parameter. Other parameters are exactly the same as the insert function:</p>
<pre>$wpdb-&gt;delete( 'table', array( 'ID' =&gt; 1 ), array( '%d' ) );</pre>
<p>In this method, we only have to pass the delete conditions as an array and respective formats of the columns. The preceding query will delete the record with an ID equal to <kbd>1</kbd>.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Selecting records</h1>
                </header>
            
            <article>
                
<p>We can pass the query to various <kbd>wpdb</kbd> class functions such as <kbd>get_results</kbd>, <kbd>query</kbd>, and <kbd>get_var</kbd>, and get the result dataset. The following section illustrates the use of these functions:</p>
<table border="1" style="border-collapse: collapse;width: 100%">
<tbody>
<tr>
<td class="CDPAlignCenter CDPAlign" style="width: 44.3526%"><kbd><span>$wpdb-&gt;get_results( 'select query' )</span></kbd></td>
<td style="width: 54.8209%"><span>This can be used to select a set of records from any database table.</span></td>
</tr>
<tr>
<td class="CDPAlignCenter CDPAlign" style="width: 44.3526%"><kbd><span>$wpdb-&gt;query('query')</span></kbd></td>
<td style="width: 54.8209%"><span>This can be used to execute any custom query. This is typically used to update and delete statements instead of select statements, as it only provides the affected rows count as the result.</span></td>
</tr>
<tr>
<td class="CDPAlignCenter CDPAlign" style="width: 44.3526%"><kbd><span>$wpdb-&gt;get_row('query')</span></kbd></td>
<td style="width: 54.8209%"><span>This can be used to retrieve a single row from the database as an object, an associative array, or as a numerically indexed array.</span></td>
</tr>
</tbody>
</table>
<p> </p>
<p>In this section, we had a brief overview of the techniques used for querying the database as well as built-in functions that simplify the database operations. In the upcoming chapters, we will be working with these functions as well as advanced query techniques while developing themes and plugins.</p>
<p class="mce-root"/>
<p class="mce-root"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Summary</h1>
                </header>
            
            <article>
                
<p>The goal of this chapter was to understand the role of default database tables and how we can adapt them to our requirements. We started by analyzing the database relationship diagram and identifying connections between tables. We also looked at the role of each database table with commonly used data.</p>
<p>We identified the need for knowing proper database usage of core features, and explored various ways of tracking database usage for each feature. Then, we had a brief overview of database structure in multisites and how it varies from that of a single site database. Finally, we looked at various functions for querying both default tables and custom tables.</p>
<p>In <a href="94db5df8-bbb4-4e75-ae88-fa38a9aabe05.xhtml" target="_blank">Chapter 3</a>, <em>Designing Flexible Frontends with Theme Development</em>, we will be starting the development process by working with child themes, theme templates, and dynamic theme components.</p>


            </article>

            
        </section>
    </body></html>