- en: Chapter 7. Handling Authentication
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第7章. 处理身份验证
- en: 'In this chapter we will cover:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖：
- en: Understanding Authentication methods
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解身份验证方法
- en: Setting up a simple database Authentication
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设置简单的数据库身份验证
- en: Writing a custom Authentication method
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写自定义身份验证方法
- en: Introduction
  id: totrans-5
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简介
- en: In this chapter we will talk about the different methods of authentication and
    we will show you some examples on how to authenticate and how to create your own
    authentication method.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将讨论不同的身份验证方法，并展示一些如何进行身份验证以及如何创建自己的身份验证方法的示例。
- en: Understanding Authentication methods
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解身份验证方法
- en: In a world where security on the Internet is such a big issue, the need for
    great authentication methods is something that cannot be missed. Therefore, Zend
    Framework 2 provides a range of authentication methods that suits everyone's needs.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在互联网安全如此重要的情况下，对强大身份验证方法的需求是不可或缺的。因此，Zend Framework 2提供了一系列适合每个人需求的身份验证方法。
- en: Getting ready
  id: totrans-9
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: To make full use of this recipe, I recommend a working Zend Framework 2 skeleton
    application to be set up.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 为了充分利用这个配方，我建议设置一个可工作的Zend Framework 2骨架应用程序。
- en: How to do it…
  id: totrans-11
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何实现...
- en: The following is a list of authentication methods—or as they are called adapters—that
    are readily available in Zend Framework 2\. We will provide a small overview of
    the adapter, and instructions on how you can use it.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是在Zend Framework 2中 readily 可用的身份验证方法列表——或称为适配器。我们将提供适配器的小概览以及如何使用它的说明。
- en: The DbTable adapter
  id: totrans-13
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: DbTable适配器
- en: 'Constructing a `DbTable` adapter is pretty easy, if we take a look at the following
    constructor:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 构建`DbTable`适配器相当简单，如果我们看看以下构造函数：
- en: '[PRE0]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The Http adapter
  id: totrans-16
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Http适配器
- en: After constructing the object we need to define the `FileResolver` to make sure
    there are actually user details parsed in.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在构建对象之后，我们需要定义`FileResolver`以确保确实解析了用户详情。
- en: Depending on what we configured in the `accept_schemes` option, the `FileResolver`
    can either be set as a `BasicResolver`, a `DigestResolver`, or both.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 根据我们在`accept_schemes`选项中配置的内容，`FileResolver`可以设置为`BasicResolver`、`DigestResolver`或两者兼而有之。
- en: 'Let''s take a quick look at how to set a `FileResolver` as a `DigestResolver`
    or `BasicResolver` (we do this in the `/module/Application/src/Application/Controller/IndexController.php`
    file):'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们快速了解一下如何将`FileResolver`设置为`DigestResolver`或`BasicResolver`（我们在`/module/Application/src/Application/Controller/IndexController.php`文件中这样做）：
- en: '[PRE1]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: How it works…
  id: totrans-21
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: After two short examples, let's take a look at the other adapters available.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在两个简短的示例之后，让我们看看其他可用的适配器。
- en: The DbTable adapter (again)
  id: totrans-23
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: DbTable适配器（再次）
- en: Let's begin with probably the most used adapter of them all, the `DbTable` adapter.
    This adapter connects to a database and pulls the requested username/password
    combination from a table and, if all went well, it will return to you an identity,
    which is nothing more than the record that matched the username details.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从所有适配器中最常用的一个开始，即`DbTable`适配器。这个适配器连接到数据库，并从表中提取所需的用户名/密码组合，如果一切顺利，它将返回一个身份，这不过是一个与用户名详情匹配的记录。
- en: 'To instantiate the adapter, it requires a `Zend\Db\Adapter\Adapter` in its
    constructor to connect with the database with the user details; there are also
    a couple of other options that can be set. Let''s take a look at the definition
    of the constructor:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 要实例化适配器，它需要在构造函数中提供一个`Zend\Db\Adapter\Adapter`以连接到数据库并使用用户详情；还有一些其他选项可以设置。让我们看看构造函数的定义：
- en: The second (`tableName`) option speaks for itself as it is just the table name,
    which we need to use to get our users, the third and the fourth (`identityColumn`,
    `credentialColumn`) options are logical and they represent the username and password
    (or what we use) columns in our table. The last option, the `credentialTreatment`
    option, however, might not make a lot of sense.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个（`tableName`）选项不言自明，因为它只是表名，我们需要用它来获取我们的用户，第三个和第四个（`identityColumn`，`credentialColumn`）选项是逻辑上的，它们代表我们表中的用户名和密码（或我们使用的）列。然而，最后一个选项`credentialTreatment`可能不太容易理解。
- en: 'The `credentialTreatment` tells the adapter to treat the `credentialColumn`
    with a function before trying to query it. Examples of this could be to use the
    `MD5(?)` function, `PASSWORD(?)`, or `SHA1(?)` function, if it was a MySQL database,
    but obviously this can differ per database as well. To give a small example on
    how the SQL can look like (the actual adapter builds this query up differently)
    with and without a credential treatment, take a look at the following examples:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: '`credentialTreatment`告诉适配器在尝试查询之前用函数处理`credentialColumn`。如果是在MySQL数据库中，这可以是`MD5(?)`函数、`PASSWORD(?)`或`SHA1(?)`函数，但显然这也可以根据数据库的不同而有所不同。为了给出一个关于SQL如何看起来的小例子（实际的适配器会以不同的方式构建这个查询），请看以下示例：'
- en: 'With credential treatment:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 有凭证处理：
- en: '[PRE2]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Without credential treatment:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 没有凭证处理：
- en: '[PRE3]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: When defining the treatment we should always include a question mark for where
    the password needs to come, for example, `MD5(?)` would create `MD5('some_password')`,
    but without the question mark it would not insert the password.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 当定义处理时，我们应该始终包括一个问号，表示密码需要出现的位置，例如，`MD5(?)`将创建`MD5('some_password')`，但没有问号则不会插入密码。
- en: 'Lastly, instead of giving the options through the constructor, we can also
    use the setter methods for the properties: `setTableName()`, `setIdentityColumn()`,
    `setCredentialColumn()`, and `setCredentialTreatment()`.'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们不仅可以通过构造函数提供选项，还可以使用属性设置器方法：`setTableName()`、`setIdentityColumn()`、`setCredentialColumn()`和`setCredentialTreatment()`。
- en: The Http adapter (again)
  id: totrans-34
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Http适配器（再次）
- en: The HTTP authentication adapter is an adapter that we have probably all come
    across at least once in our Internet lives. We can recognize the authentication
    when we go to a website and there is a pop up showing where we can fill in our
    usernames and passwords to continue.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: HTTP认证适配器是我们可能在互联网生活中至少遇到过一次的适配器。当我们访问一个网站并且弹出一个窗口显示我们可以填写用户名和密码以继续时，我们可以识别出这种认证。
- en: This form of authentication is very basic, but still very effective in certain
    implementations, and therefore, a part of Zend Framework 2\. There is only one
    big massive *but* to this authentication, and that is that it can (when using
    the basic authentication) send the username and password clear text through the
    browser (ouch!).
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 这种认证方式非常基础，但在某些实现中仍然非常有效，因此它是Zend Framework 2的一部分。然而，这种认证有一个很大的问题，那就是（在使用基本认证时）它可以通过浏览器发送用户名和密码的明文（ouch!）。
- en: There is however a solution to this problem and that is to use the Digest authentication,
    which is also supported by this adapter.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，有一个解决方案，那就是使用摘要认证，这种认证也由这个适配器支持。
- en: 'If we take a look at the constructor of this adapter, we would see the following
    code line:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们查看这个适配器的构造函数，我们会看到以下代码行：
- en: '[PRE4]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The constructor accepts a load of keys in its `config` parameter, which are
    as follows:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 构造函数接受其`config`参数中的大量键，如下所示：
- en: '`accept_schemes`: This refers to what we want to accept authentication wise;
    this can be `basic`, `digest`, or `basic digest`.'
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`accept_schemes`：这指的是我们想要接受的认证方式；这可以是`basic`、`digest`或`basic digest`。'
- en: '`realm`: This is a description of the realm we are in, for example `Member''s
    area`. This is for the user only and is only to describe what the user is logging
    in for.'
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`realm`：这是我们对所在领域的描述，例如“会员区域”。这是针对用户的，仅用于描述用户登录的目的。'
- en: '`digest_domains`: These are URLs for which this authentication is working.
    So if a user logs in with his details on any of the URLs defined, they will work.
    The URLs should be defined in a space-separated (weird, right?) list, for example
    `/members/area /members/login`.'
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`digest_domains`：这是认证正在工作的URLs。所以如果用户在任何定义的URL上使用他的详细信息登录，它们将有效。URLs应该定义在一个空格分隔的（奇怪，对吧？）列表中，例如
    `/members/area /members/login`。'
- en: '`nonce_timeout`: This will set the number of seconds the nonce (the hash users
    login with when we are using Digest authentication) is valid. Note, however, that
    nonce tracking and stale support are not implemented in Version 2.2 yet, which
    means it will authenticate again every time the nonce times out.'
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`nonce_timeout`：这将设置nonce（当我们使用摘要认证时，用户登录时使用的哈希）有效的秒数。请注意，然而，nonce跟踪和过时支持在2.2版本中尚未实现，这意味着每次nonce超时时都会重新认证。'
- en: '`use_opaque`: This is either true or false (by default is true) and tells our
    adapter to send the opaque header to the client. The opaque header is a string
    sent by the server, which needs to be returned back on authentication. This does
    not work sometimes on Microsoft Internet Explorer browsers though, as they seem
    to ignore that header. Ideally the opaque header is an ever-changing string, to
    reduce predictability, but ZF 2 doesn''t randomize the string and always returns
    the same hash.'
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`use_opaque`：这是一个布尔值（默认为 true），告诉我们的适配器向客户端发送不透明头。不透明头是服务器发送的字符串，需要在身份验证时返回。不过，在
    Microsoft Internet Explorer 浏览器上有时不起作用，因为它们似乎忽略了该头。理想情况下，不透明头应该是一个不断变化的字符串，以减少可预测性，但
    ZF 2 不随机化字符串，总是返回相同的哈希。'
- en: '`algorithm`: This includes the algorithm to use for the authentication, it
    needs to be a supported algorithm that is defined in the `supportedAlgos` property.
    At the moment there is only MD5 though.'
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`algorithm`：这包括用于身份验证的算法，它需要是一个在 `supportedAlgos` 属性中定义的支持算法。目前只有 MD5。'
- en: '`proxy_auth`: This boolean (by default is false) tells us if the authentication
    used is a proxy Authentication or not.'
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`proxy_auth`：这个布尔值（默认为 false）告诉我们所使用的身份验证是否是代理身份验证。'
- en: It should be noted that there is a slight difference in files when using either
    Digest or Basic. Although both files have the same layout, they cannot be used
    interchangeably as the Digest requires the credentials to be MD5 hashed, while
    the Basic requires the credentials to be plain text. There should also always
    be a new line after every credential, meaning that the last line in the credential
    file should be empty.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 应该注意的是，在使用 Digest 或 Basic 时，文件之间略有差异。尽管这两个文件具有相同的布局，但它们不能互换使用，因为 Digest 需要将凭证进行
    MD5 哈希，而 Basic 需要将凭证作为纯文本。在每条凭证之后都应该有一个新行，这意味着凭证文件中的最后一行应该是空的。
- en: 'The layout of a credential file is as follows:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 凭证文件的布局如下：
- en: '[PRE5]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'For example:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 例如：
- en: '[PRE6]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Instead of a `FileResolver`, one can also use the `ApacheResolver` which can
    be used to read out `htpasswd` generated files, which comes in handy when there
    is already such a file in place.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 除了 `FileResolver`，还可以使用 `ApacheResolver`，它可以用来读取 `htpasswd` 生成的文件，这在已经有此类文件的情况下非常有用。
- en: The Digest adapter
  id: totrans-54
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Digest 适配器
- en: 'The `Digest` adapter is basically the `Http` adapter without any Basic authentication.
    As the idea behind it is the same as the `Http` adapter, we will just go on and
    talk about the constructor, as that is a bit different in implementation:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '`Digest` 适配器基本上是没有任何基本身份验证的 `Http` 适配器。由于它的理念与 `Http` 适配器相同，我们只需继续讨论构造函数，因为它的实现略有不同：'
- en: '[PRE7]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'As we can see the following options can be set when constructing the object:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，在构建对象时可以设置以下选项：
- en: '`filename`: This is the direct filename of the file to use with the Digest
    credentials, so no need to use a `FileResolver` with this one.'
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`filename`：这是用于 Digest 凭证的直接文件名，因此无需使用 `FileResolver`。'
- en: '`realm`: This identifies to the user what he/she is logging on to, for example
    `My Awesome Realm` or `The Dragonborn''s lair`. As we are immediately trying to
    log on when constructing this, it does need to correspond with the credential
    file (see *The Http adapter* for the credential file layout).'
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`realm`：这用于向用户标识他/她正在登录的系统，例如 `My Awesome Realm` 或 `The Dragonborn''s lair`。由于我们在构建此文件时立即尝试登录，因此它确实需要与凭证文件（参见
    *Http 适配器* 中的凭证文件布局）相匹配。'
- en: '`identity`: This is the username we are trying to log on with, and again it
    needs to resemble a user that is defined in the credential file to work.'
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`identity`：这是我们尝试登录的用户名，并且它需要与凭证文件中定义的用户相似才能正常工作。'
- en: '`credential`: This is the Digest password we try to log on with, and this again
    needs to match the password exactly like the one in the credential file.'
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`credential`：这是我们尝试登录的 Digest 密码，并且它需要与凭证文件中的密码完全匹配。'
- en: We can then, for example, just run `$digestAdapter->getIdentity()` to find out
    if we are successfully authenticated or not, resulting in `NULL` if we are not,
    and resulting in the identity column value if we are.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，例如，我们可以运行 `$digestAdapter->getIdentity()` 来找出我们是否成功进行了身份验证，如果没有成功，则返回 `NULL`，如果成功，则返回身份列的值。
- en: The LDAP adapter
  id: totrans-63
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: LDAP 适配器
- en: 'Using the LDAP authentication is obviously a little more difficult to explain,
    so we will not go in to that in full as that would take quite a while. What we
    will do is show the constructor of the `LDAP` adapter and explain its various
    options. However, if we want to know more about setting up an LDAP connection,
    we should take a look at the documentation of ZF2, as it is explained in there
    very well:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 LDAP 认证显然要难解释一些，所以我们不会全面介绍，因为这会花费相当长的时间。我们将展示 `LDAP` 适配器的构造函数并解释其各种选项。然而，如果我们想了解更多关于设置
    LDAP 连接的信息，我们应该查看 ZF2 的文档，因为那里解释得很好：
- en: '[PRE8]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The options parameter in the construct refers to an array of configuration options
    that are compatible with the `Zend\Ldap\Ldap` configuration. There are literally
    dozens of options that can be set here so we advise to go and look at the LDAP
    documentation of ZF2 to know more about that. The next two parameters identity
    and credential are respectively the username and password again, so that explains
    itself really.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 构造函数中的选项参数指的是一个与 `Zend\Ldap\Ldap` 配置兼容的配置选项数组。这里可以设置的实际选项有数十种，所以我们建议查看 ZF2 的
    LDAP 文档以了解更多信息。接下来的两个参数 identity 和 credential 分别是用户名和密码，这一点很容易理解。
- en: Once you have set up the connection with the LDAP there isn't much left to do
    but to get the identity and see whether we were successfully validated or not.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦与 LDAP 建立了连接，就没有太多的事情要做，只剩下获取身份并查看我们是否成功验证。
- en: About Authentication
  id: totrans-68
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 关于认证
- en: Authentication in Zend Framework 2 works through specific adapters, which are
    always an implementation of the `Zend\Authentication\Adapter\AdapterInterface`
    and thus, always provides the methods defined in there. However, the methods of
    Authentication are all different, and strong knowledge of the methods displayed
    previously is always a requirement. Some work through the browser, like the `Http`
    and `Digest` adapter, and others just require us to create a whole implementation
    like the `LDAP` and the `DbTable` adapter.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Zend Framework 2 中，认证通过特定的适配器实现，这些适配器始终是 `Zend\Authentication\Adapter\AdapterInterface`
    的实现，因此始终提供了那里定义的方法。然而，认证的方法各不相同，对之前显示的方法有深入了解始终是必需的。有些方法通过浏览器工作，如 `Http` 和 `Digest`
    适配器，而有些则要求我们创建整个实现，如 `LDAP` 和 `DbTable` 适配器。
- en: Setting up a simple database Authentication
  id: totrans-70
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置简单的数据库认证
- en: After seeing all the authentication methods available, it is time to see how
    it will actually work when we have a database authentication in place. This recipe
    will explain all the ins and outs of this specific method.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 在看到所有可用的认证方法后，是时候看看当设置了数据库认证时它实际上会如何工作了。这个菜谱将解释这个特定方法的方方面面。
- en: Getting ready
  id: totrans-72
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: A working Zend Framework 2 skeleton application with the PHP sqlite extension
    loaded and enabled.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 一个带有 PHP sqlite 扩展已加载和启用的有效 Zend Framework 2 框架应用骨架。
- en: How to do it…
  id: totrans-74
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作…
- en: Database authentication can very well be the most widely used authentication
    method there is. In this recipe we will set up our own database authentication.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 数据库认证可能是最广泛使用的认证方法。在这个菜谱中，我们将设置自己的数据库认证。
- en: Setting up the module initialization
  id: totrans-76
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 设置模块初始化
- en: We will create our database as soon as possible after initialization of the
    modules, so we will attach it to an event called route or `MvcEvent::EVENT_ROUTE`.
    As a template for the `Module.php` we can just copy over the `Application/Module.php`
    file and change the namespace; we will be working in the `onBootstrap` method
    anyway, and the rest of the `Module` class can stay the same (but don't forget
    to change the namespace!).
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在模块初始化后尽快创建数据库，因此我们将它附加到名为 route 或 `MvcEvent::EVENT_ROUTE` 的事件。作为 `Module.php`
    的模板，我们只需复制 `Application/Module.php` 文件并更改命名空间；我们无论如何都会在 `onBootstrap` 方法中工作，`Module`
    类的其余部分可以保持不变（但别忘了更改命名空间！）。
- en: 'Let''s take a look at the code of our `/module/Authentication/Module.php` file:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看我们的 `/module/Authentication/Module.php` 文件的代码：
- en: '[PRE9]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: We have now created an event that will be triggered when we start routing. If
    we look carefully enough we can find one big mistake that will crash this code
    for sure. The problem of course being the db key in the `ServiceManager`, as we
    refer to a service we have yet to create. So let's get cracking and create that
    `/module/Authentication/config/module.config.php` file…
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在创建了一个事件，当开始路由时会触发。如果我们仔细观察，我们可以找到一个肯定会导致代码崩溃的大错误。问题当然在于 `ServiceManager`
    中的 db key，因为我们引用了一个尚未创建的服务。所以让我们开始动手，创建那个 `/module/Authentication/config/module.config.php`
    文件…
- en: '[PRE10]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: That's it; our basic configuration to get the database going is done, and if
    we run the code now we can be certain our database is created.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 就这样；我们的基本配置已经完成，以便数据库开始运行，如果我们现在运行代码，我们可以确信数据库已经创建。
- en: Creating the authentication service
  id: totrans-83
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建认证服务
- en: The next thing we want to do is to create our Authentication service, the service
    that will help our application do all the authentication functionality. Let's
    create this service in the `Authentication\Service` namespace, and let's call
    the class `Authentication` (the file is `/module/Authentication/src/Authentication/Service/Authentication.php`).
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 我们接下来要做的事情是创建我们的认证服务，这个服务将帮助我们的应用程序完成所有的认证功能。让我们在`Authentication\Service`命名空间中创建这个服务，并将其命名为`Authentication`（文件位于`/module/Authentication/src/Authentication/Service/Authentication.php`）。
- en: '[PRE11]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Well that was easy; we just created our service… which does absolutely nothing
    at the moment. Let's first create a method that checks if we are authenticated
    or not. We do this by checking the authentication session, and see if it is empty
    or not. Assuming that in this case we only have a (authentication!) session when
    are actually authenticated, we can safely agree that we will be logged in;
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，这很简单；我们只是创建了一个服务……但目前它实际上什么都没做。让我们首先创建一个检查我们是否已经认证的方法。我们通过检查认证会话，看它是否为空来完成这个操作。假设在这种情况下，我们只有当实际上已经认证时才有一个（认证！）会话，我们可以安全地同意我们将登录；
- en: '[PRE12]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: We can easily just open a session as the namespace of the session will only
    be used for authentication purposes.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以轻松地打开一个会话，因为会话的命名空间仅用于认证目的。
- en: 'Let''s now create our authentication, which will authenticate a username and
    password, and return a boolean stating that we are or aren''t successful in authenticating:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们现在创建我们的认证服务，它将验证用户名和密码，并返回一个布尔值，表示我们是否成功认证：
- en: '[PRE13]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'As we saw in the previous code snippet, we created a simple authentication
    method that returns either true or false, depending on if we are authenticated
    or not. What it also does is save the identity to the authentication session,
    so we can see in our previous method if we were authenticated or not. We also
    need the identity in the session for when we want to get the username from our
    logged in user, which will retrieve with the following method:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在之前的代码片段中看到的，我们创建了一个简单的认证方法，它返回true或false，这取决于我们是否已经认证。它还做的一件事是将身份保存到认证会话中，这样我们就可以在我们的上一个方法中看到我们是否已经认证。当我们想要从登录用户那里获取用户名时，我们也需要在会话中获取身份，这可以通过以下方法实现：
- en: '[PRE14]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Now that we got our identity, it is also important that we are able to logout.
    In our case it is as simple as just clearing the session, because why would we
    make it more difficult than just that?
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经获取了我们的身份，我们能够注销也同样重要。在我们的情况下，这很简单，只需清除会话即可，因为我们为什么要让它比这更复杂呢？
- en: '[PRE15]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'We have now created a simple authentication service, and the only part left
    now is to register it in the service manager so that it will be instantiated when
    we boot up. We can do this in the `/module/Authentication/config/module.config.php`
    file as usual, and because we already have a `service_manager` configuration there,
    we can just plant the invokable in there:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经创建了一个简单的认证服务，现在剩下的唯一部分就是将其注册到服务管理器中，以便在启动时自动实例化。我们可以像往常一样在`/module/Authentication/config/module.config.php`文件中完成这项操作，因为我们已经有一个`service_manager`配置在那里，我们只需将可调用的实例放入其中：
- en: '[PRE16]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: And that's it for the service! All that is left now to do is create the `login/logout`
    action and then check if we are logged in or not. Let's begin with the `login/logout`
    action so that we are actually able to login!
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 对于服务来说这就结束了！现在我们唯一要做的就是创建`login/logout`操作，然后检查我们是否已经登录。让我们从`login/logout`操作开始，这样我们实际上能够登录！
- en: Setting up the controller and action
  id: totrans-98
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 设置控制器和操作
- en: 'Let''s first change the `/module/Authentication/config/module.config.php` file
    while we are still in there so we can access our `login/logout` action, which
    is kind of crucial to us:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在那里修改`/module/Authentication/config/module.config.php`文件，这样我们就可以访问我们的`login/logout`操作，这对我们来说非常重要：
- en: '[PRE17]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: This basic route just makes `/authentication` redirect to our `loginAction`
    and because of the segment route we can simply do `/authentication/logout` to
    redirect to our `logoutAction`; if more explanation is required for the routes,
    we can review [Chapter 1](ch01.html "Chapter 1. Zend Framework 2 Basics"), *Zend
    Framework 2 Basics*, and look in the *Handling routines* recipe.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 这个基本的路由只是将 `/authentication` 重定向到我们的 `loginAction`，由于段路由，我们可以简单地通过 `/authentication/logout`
    重定向到我们的 `logoutAction`；如果需要更多关于路由的解释，我们可以回顾[第1章](ch01.html "第1章。Zend Framework
    2 基础")，*Zend Framework 2 基础*，并查看 *Handling routines* 菜单。
- en: 'Let''s continue creating our /`module/Authentication/src/Authentication/Controller/IndexController`
    in the `Authentication\Controller` namespace:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续在 `Authentication\Controller` 命名空间中创建我们的 `/module/Authentication/src/Authentication/Controller/IndexController`：
- en: '[PRE18]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'We have simply declared our controller; now let''s add the `logoutAction` (we
    will begin with that, as it is incredibly simple) and the `loginAction`:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经简单地声明了我们的控制器；现在让我们添加 `logoutAction`（我们将从它开始，因为它非常简单）和 `loginAction`：
- en: '[PRE19]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'As we can see this is almost too simple, but we won''t complain if it works.
    Now let us create our `loginAction`, which basically looks if there is a post
    and if there is tries to login, otherwise shows a login form. Upon successful
    login we will be redirected to the `/application` route, and if not successful
    we will just display an error message:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，这几乎是太简单了，但如果它能工作，我们不会抱怨。现在让我们创建我们的 `loginAction`，它基本上检查是否有帖子，如果有，就尝试登录，否则显示登录表单。登录成功后，我们将被重定向到
    `/application` 路由，如果没有成功，我们只显示一个错误消息：
- en: '[PRE20]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: As we can see the `loginAction` is merely checking if we have anything posted,
    and if we do, it lets the `AuthService` handle it. This way is not perfect as
    it doesn't check for malicious parameters or anything, but it does show how clean
    a controller is supposed to be with no login in there except the bare minimum
    parsing of variables.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，`loginAction` 只是在检查是否有任何帖子，如果有，它就允许 `AuthService` 处理它。这种方式并不完美，因为它不检查恶意参数或任何东西，但它确实展示了控制器应该是多么干净，除了必要的变量解析之外，没有登录。
- en: 'The `logoutAction` doesn''t contain a view script, as that action only redirects
    the user and never has a response of its own. The `loginAction`, however, does
    have view script, as it needs to show a form. Let''s quickly build a view script
    for the `loginAction` now (the file is `/module/Authentication/view/authentication/index/login.phtml`):'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '`logoutAction` 不包含视图脚本，因为这个动作只是重定向用户，并且永远不会有自己的响应。然而，`loginAction` 确实包含视图脚本，因为它需要显示一个表单。现在让我们快速为
    `loginAction` 建立一个视图脚本（文件位于 `/module/Authentication/view/authentication/index/login.phtml`）：'
- en: '[PRE21]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: A simple form to login and in my opinion doesn't require any explanation.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 一个简单的登录表单，在我看来不需要任何解释。
- en: 'The last thing that we want to do know is to make sure nobody can access anything
    in the application other than the authentication if he/she is not logged in. We
    can do that by a new event in the Module (the file is `/module/Authentication/Module.php`)
    class of the Authentication module, which will check if we are logged in, and
    if not redirects us before any output is done to the screen:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 我们最后想要确保的是，如果用户未登录，他们不能访问应用程序中的任何内容，除了认证。我们可以通过在 Authentication 模块的 Module（文件位于
    `/module/Authentication/Module.php`）类中添加一个新的事件来实现这一点，该事件将检查我们是否已登录，如果没有，则在屏幕输出任何内容之前将我们重定向：
- en: '[PRE22]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: That's the event that we need, what happens is that we will simply be redirected
    to the login page whenever we try to reach a route which is not our authentication
    route.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 需要的事件就是这样的，发生的情况是，每次我们尝试访问非认证路由时，我们都会被重定向到登录页面。
- en: How it works…
  id: totrans-115
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: What we are going to do is create a simple database authentication that works
    through an in-memory SQLite database. This means that the database isn't stored
    and that all the tables and records need building up every time we request the
    page. Obviously this is highly inconvenient to use in a production environment,
    it is, however, excellent to show off how it works and is really handy to get
    something going quickly.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要创建的是一个简单的数据库认证，它通过内存中的 SQLite 数据库工作。这意味着数据库不会被存储，每次我们请求页面时，所有表和记录都需要重新构建。显然，这在生产环境中使用非常不方便，但它确实可以很好地展示它是如何工作的，并且对于快速启动非常有用。
- en: Assuming we are working on a default Zend Skeleton application, let's create
    a new module Authentication. This new module will contain the database connection,
    the authentication itself and the login and logout actions. When we created the
    directory for the new module, we should also be wary to add the new module in
    the `application.config.php` file, otherwise we might end up having trouble finding
    out why it doesn't do anything (oh yes, I am talking from experience).
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们正在使用默认的Zend Skeleton应用程序，让我们创建一个新的认证模块。这个新模块将包含数据库连接、认证本身以及登录和注销操作。当我们为新的模块创建目录时，我们还应该小心地将新模块添加到`application.config.php`文件中，否则我们可能会遇到麻烦，不知道为什么它不起作用（哦，是的，我是在从经验中说的）。
- en: First of all we built our in-memory database in the `Module.php` for the authentication.
    We then created a table called `users`, with a unique ID, username, and password.
    The ID consist of an integer, the username a variable character of 20 positions,
    and the password will be a character of 32, as that is the size of an MD5 encrypted
    string.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们在`Module.php`中为认证构建了我们的内存数据库。然后我们创建了一个名为`users`的表，包含一个唯一的ID、用户名和密码。ID由一个整数组成，用户名是一个20位的可变字符，密码将是一个32个字符，因为这是MD5加密字符串的大小。
- en: Because we set up a user table, and connected that table to the authentication
    adapter, we were able to authenticate the username and password simply. As an
    extra measure we made sure the user can't go to any other page than the login
    page when he isn't logged in, which we did by using an event that happens before
    the output was send to the user.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 因为我们已经设置了一个用户表，并将其连接到认证适配器，所以我们能够简单地验证用户名和密码。作为额外的措施，我们确保用户在没有登录的情况下不能访问除登录页面之外的任何页面，这是通过使用在输出发送给用户之前发生的事件来实现的。
- en: Writing a custom Authentication method
  id: totrans-120
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编写自定义认证方法
- en: Sometimes the standard methods just don't cut it, and that is okay. That is
    why this recipe gives a clear insight into how to create our own authentication
    method.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候，标准方法可能不够用，这是完全可以接受的。这就是为什么这个食谱清楚地说明了如何创建我们自己的认证方法。
- en: Getting ready
  id: totrans-122
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: For this recipe it would be preferred if there is a web environment that has
    SSL enabled. Configuring such an environment is outside the scope but it would
    be beneficial for the execution of this recipe.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个食谱，如果有一个启用了SSL的Web环境会更好。配置这样的环境超出了范围，但它对执行这个食谱会有好处。
- en: 'An example of an environment like this would be an Apache 2 web server with
    `mod_ssl` correctly configured. To enable the certificate verification on Apache2,
    one needs to place the following code in their `public/.htaccess` file:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 这样的一个环境示例将是正确配置了`mod_ssl`的Apache 2 Web服务器。要在Apache2上启用证书验证，需要在他们的`public/.htaccess`文件中放置以下代码：
- en: '[PRE23]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Another thing that is important to mention is that PHP should be configured
    (and compiled) with the `--with-openssl` parameter, otherwise the code to parse
    the certificate will not exist and thus, we would not be able to use the code.
    More information on how to do this can be found at [http://www.php.net/manual/en/book.openssl.php](http://www.php.net/manual/en/book.openssl.php).
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个需要提到的重要事情是，PHP应该配置（和编译）带有`--with-openssl`参数，否则解析证书的代码将不存在，因此我们无法使用该代码。有关如何做到这一点的更多信息，请参阅[http://www.php.net/manual/en/book.openssl.php](http://www.php.net/manual/en/book.openssl.php)。
- en: How to do it…
  id: totrans-127
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: Authentication by certification might be rare, but it is sometimes used when
    the level of security is a little bit higher than the average web application.
    In this recipe we will show an example of a certificate-based authentication.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 证书认证可能很少见，但有时当安全性略高于普通Web应用时，会使用它。在这个食谱中，我们将展示一个基于证书的认证示例。
- en: Creating our adapter
  id: totrans-129
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建我们的适配器
- en: Let's get started by creating our new adapter, which will be an implementation
    of `Zend\Authentication\Adapter\AdapterInterface` as we want to integrate as much
    as possible with the current authentication adapters.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始创建我们的新适配器，这将是我们想要尽可能与当前认证适配器集成的`Zend\Authentication\Adapter\AdapterInterface`的实现。
- en: As we already have an Authentication module from the previous recipe, we will
    just take that as the namespace in which we are going to work; just as easy as
    described earlier.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们已经有了一个来自上一个食谱的认证模块，我们只需将其作为我们将要工作的命名空间即可；就像之前描述的那样简单。
- en: First let's create the adapter (the file is `/module/Authentication/src/Authentication/Adapter/Certificate.php`).
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们创建适配器（文件位于`/module/Authentication/src/Authentication/Adapter/Certificate.php`）。
- en: The adapter outline
  id: totrans-133
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 适配器概述
- en: 'We''ll first start with our basic class outline:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先从我们的基本类轮廓开始：
- en: '[PRE24]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Creating a getter and setter for any error messages
  id: totrans-136
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 为任何错误消息创建getter和setter
- en: 'Normally we would come up with error messages as we go in development. But
    as this code is already made, we already have the error messages defined. There
    is no good way to describe these getters and setters, so we will just show them
    in the following piece of code so that it is at least clear what is going on (the
    file is `/module/Authentication/src/Authentication/Adapter/Certificate.php`):'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 通常我们会在开发过程中逐步想出错误消息。但因为这个代码已经完成，我们已经有定义好的错误消息。没有很好的方法来描述这些getter和setter，所以我们将在以下代码片段中展示它们，以便至少可以清楚地了解发生了什么（文件位于`/module/Authentication/src/Authentication/Adapter/Certificate.php`）：
- en: '[PRE25]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'These are the error messages we thought of and will be used somewhere in the
    code later on. Now let''s create the setter for these error messages so that the
    getter can easily retrieve them later on:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是我们考虑到的错误消息，稍后将在代码的某个地方使用。现在让我们创建这些错误消息的setter，以便getter可以轻松地在以后检索它们：
- en: '[PRE26]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Well that was exciting. Let''s create the getter now, which is slightly more
    elaborate, but only just a little:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，那真是有趣。现在让我们创建getter，它稍微复杂一些，但只是稍微复杂一点：
- en: '[PRE27]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Making sure we have a secure connection
  id: totrans-143
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 确保我们有一个安全的连接
- en: Although certificates are only sent when we do have an SSL connection, an extra
    check isn't that bad as we want to be certain that the user is using a secure
    connection.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然证书只有在我们有SSL连接时才会发送，但额外的检查并不坏，因为我们想确保用户正在使用安全的连接。
- en: '[PRE28]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Wow, that must have been the best method ever! All joking aside, it is fairly
    simple as the `HTTPS` key is given in the `$_SERVER` variable, whenever a secure
    connection through HTTPS is set up. When the key is present, we can assume that
    there is a secure connection.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 哇，那肯定是有史以来最好的方法！开个玩笑，它相当简单，因为`HTTPS`键在`$_SERVER`变量中给出，每当通过HTTPS建立安全连接时。当键存在时，我们可以假设存在一个安全连接。
- en: Checking if the certificate is an actual certificate
  id: totrans-147
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 检查证书是否为实际证书
- en: 'Next up is to check if the certificate is valid or not, but before we can do
    that we should also make sure there is a way to set the certificate as well:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来是检查证书是否有效，但在我们可以这样做之前，我们也应该确保有方法设置证书：
- en: '[PRE29]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: This method did a basic check to see if we actually got a certificate that is
    at least valid, even if it is expired or doesn't have any of our fields.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法进行了基本检查，以查看我们是否真的得到了至少有效的证书，即使它已过期或没有我们的任何字段。
- en: Checking if we have all the certificate fields
  id: totrans-151
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 检查我们是否拥有所有证书字段
- en: 'As we want to check the e-mail address in our certificate, we need to make
    sure we actually have an e-mail address in there as well. And while we are at
    it, we will also check for a couple of other fields that are not relevant to our
    authentication, but would be nice to have anyway:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 因为我们想检查证书中的电子邮件地址，我们需要确保我们确实有一个电子邮件地址在那里。同时，我们还将检查几个与我们认证无关但仍然很不错的字段：
- en: '[PRE30]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: We check if the fields are in there, and if the field isn't in there we will
    return false.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 我们检查字段是否在其中，如果字段不在其中，我们将返回false。
- en: Checking if the certificate isn't expired yet
  id: totrans-155
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 检查证书尚未过期
- en: 'Now we want to know if the certificate is still valid in terms of time, as
    certificates usually expire after a set time (this can be months, weeks, years,
    anything really):'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们想知道证书在时间上是否仍然有效，因为证书通常在设定的时间后过期（这可能是一月、一周、一年，实际上可以是任何时间）：
- en: '[PRE31]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: If this method returns true, we can be sure that we have a certificate that
    isn't expired.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 如果此方法返回true，我们可以确信我们有一个未过期的证书。
- en: Creating a getter and setter for the Database adapter
  id: totrans-159
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 为数据库适配器创建getter和setter
- en: 'Now we need a simple getter and setter for our database adapter, before we
    can actually do the authentication:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们需要一个简单的getter和setter来处理我们的数据库适配器，在我们实际上进行认证之前：
- en: '[PRE32]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Of course this was again very simple, as it requires no logic at all. Now that
    we have set our database adapter, we can actually begin authenticating the user.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，这又很简单，因为它根本不需要任何逻辑。现在我们已经设置了数据库适配器，我们实际上可以开始认证用户了。
- en: Creating the authenticate method
  id: totrans-163
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建认证方法
- en: 'This method will implement all our previously defined methods and if they are
    all successful, it will authenticate through the database and see if our user
    is there (or not). But first, we need another method to get fields from our certificate,
    which is a neater way, and a method to get our identity once authenticated:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法将实现我们之前定义的所有方法，如果它们都成功了，它将通过数据库进行身份验证，看看我们的用户是否在那里（或者不在）。但是首先，我们需要另一种方法来从我们的证书中获取字段，这是一种更整洁的方法，以及一种在认证后获取我们身份的方法：
- en: '[PRE33]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: And now for the supreme moment, after a long wait, finally the `authenticate`
    method!
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是最高潮的时刻，经过漫长的等待，终于到了`authenticate`方法！
- en: '[PRE34]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: And that's it! The `authenticate` method will either return true on successful
    authentication or false, and will set an error at the same time so that we can
    see what exactly went wrong!
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 就这样！`authenticate`方法将在认证成功时返回true，或者在失败时返回false，同时设置一个错误，这样我们就可以看到到底出了什么问题！
- en: How it works…
  id: totrans-169
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: Now that we have created our own `authentication` adapter, it is time to sit
    back and review what we just did.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经创建了我们的`authentication`适配器，是时候坐下来回顾我们刚才所做的一切了。
- en: What are we trying to achieve
  id: totrans-171
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 我们试图实现什么
- en: On some websites the access is prohibited on such a level that usernames and
    passwords are a thing of the past. In environments where we want to check every
    customer that comes in without them needing to type the username and password
    themselves, we might use certificate authentication.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些网站上，访问被禁止到了这种程度，以至于用户名和密码已成为过去式。在我们希望检查每个进入的顾客而不需要他们自己输入用户名和密码的环境中，我们可能会使用证书认证。
- en: Certificate authentication works because the client will send a certificate
    with every server request they do. This certificate then shows the server *who*
    the user is, who is trying to browse their pages. Usually one or more fields in
    the certificate are used to identify the user. In our example we will use the
    e-mail address, which is a common field to be used for identification.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 证书认证之所以有效，是因为客户端将在每次向服务器发送请求时发送一个证书。这个证书随后会向服务器显示用户是谁，谁正在尝试浏览他们的页面。通常，证书中的一个或多个字段被用来识别用户。在我们的例子中，我们将使用电子邮件地址，这是一个常见的用于身份验证的字段。
- en: What we will do first off, is create an adapter that will get the certificate
    either from manual input (easier testing that way) or the browser, whichever works
    really. We will then check if the e-mail address exists in our database, and if
    so we consider the user logged in. Obviously our server will not be configured
    so strictly that no certificate will be allowed, as in this stage basically every
    certificate with a right e-mail address gets access. If we want to know how we
    can prevent users from using any certificate, we can take a look at the *There's
    more…* section, where we will look in the direction of securing your server a
    bit further, and restricting the certificate use.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先要做的是创建一个适配器，它将从手动输入（这样测试起来更简单）或浏览器中获取证书，哪个可行就用哪个。然后我们将检查电子邮件地址是否存在于我们的数据库中，如果是的话，我们就认为用户已经登录。显然，我们的服务器不会配置得那么严格，以至于不允许任何证书，因为在这一阶段，基本上所有带有正确电子邮件地址的证书都能获得访问权限。如果我们想知道如何防止用户使用任何证书，我们可以查看“更多内容…”部分，在那里我们将进一步探讨如何保护您的服务器，并限制证书的使用。
- en: From an application point of view, however, we just presume that all the certificates
    that we get, are valid.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，从应用程序的角度来看，我们只是假设我们得到的所有证书都是有效的。
- en: 'The `AdapterInterface` only requires us to have an authenticate method. But
    before we can go ahead we want to make sure that the following items are checked:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: '`AdapterInterface`只要求我们有一个认证方法。但在我们继续之前，我们想要确保以下项目已被检查：'
- en: We want to make sure the user is coming through a secure connection (HTTPS)
  id: totrans-177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们想确保用户是通过一个安全的连接（HTTPS）来的
- en: We also want to make sure the certificate is valid (obviously)
  id: totrans-178
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们还想要确保证书是有效的（显然）
- en: While we are checking, we'll make sure our certificate has the fields we require
    for authentication
  id: totrans-179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在检查的过程中，我们将确保我们的证书具有我们用于认证所需的字段
- en: And we need to know if the certificate is still valid and not expired
  id: totrans-180
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们还需要知道证书是否仍然有效且未过期
- en: Last but not least, we also need to make sure that we have a database adapter
    to check the values against
  id: totrans-181
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后但同样重要的是，我们还需要确保我们有一个数据库适配器来检查值
- en: About certificates
  id: totrans-182
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 关于证书
- en: In general the certificates are validated on the server before they reach the
    application. The validation usually happens against some sort of CA, or Certificate
    Authority, which is basically an entity on the server site that issues certificates,
    and therefore can vouch for any certificates carrying its signature. Of course
    in real life this is way more complicated than just described, but the idea is
    the same. So when a certain level of checking is being done on the server to verify
    the identity of the certificate, and if it is valid against the CA provided by
    the server, it will then parse it through to our application.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，在证书到达应用程序之前，服务器会对证书进行验证。验证通常是对某种CA，即证书颁发机构进行的，这基本上是服务器端的一个实体，它颁发证书，因此可以为带有其签名的任何证书作证。当然，在现实生活中，这比描述的要复杂得多，但基本思想是相同的。所以当服务器上进行某种程度的检查以验证证书的身份，并且如果它与服务器提供的CA有效时，它将解析它并通过到我们的应用程序。
- en: By the time it reaches our application, we usually assume that the user got
    the certificate from us, and therefore should be allowed in, as he knew the password
    at the door. But although he knew the password, that doesn't mean we know who
    it is! That is why a second authentication (the one we just made) verifies if
    a user actually belongs in our application or not, that is, if it is a valid certificate
    or not!
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 当它到达我们的应用程序时，我们通常假设用户已经从我们这里获得了证书，因此应该被允许进入，因为他知道门上的密码。但尽管他知道密码，这并不意味着我们知道他是谁！这就是为什么第二次认证（我们刚刚进行的认证）验证用户实际上是否属于我们的应用程序，也就是说，证书是否有效！
- en: There's more…
  id: totrans-185
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: Securing a server is the most important part of this kind of validation, as
    we really (really, really) need to be sure that the user carrying the certificate
    is actually valid. Usually building complex servers like this are done with server
    engineers and not the task of the developer, but if it is then it would be a great
    idea to read up on the subject first.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 保护服务器是这种验证最重要的部分，因为我们真的（真的，真的）需要确保携带证书的用户是有效的。通常，构建这样的复杂服务器是由服务器工程师完成的，而不是开发者的任务，但如果这样的话，先了解一下这个主题会是个好主意。
- en: Personally, I am a fan of Apache and would recommend anyone to read up on the
    `mod_ssl` configuration, as it is very thorough on the subject of securing a server
    and it has a lot of resources to find out how to configure it just right.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 个人来说，我是Apache的粉丝，并建议任何人都去了解`mod_ssl`配置，因为它在保护服务器方面非常全面，并且有很多资源可以帮助你正确配置它。
- en: But in the end configuring SSL without the proper know-how is a very tedious
    and error-prone process and it is likely that properly configuring a server is
    a bit over the head of a developer. In that case getting a server engineer to
    do it for us is the best way, and the laziest, which lets us concentrate on our
    work!
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 但最终，如果没有适当的了解，配置SSL是一个非常繁琐且容易出错的流程，而且很可能正确配置服务器超出了开发者的能力范围。在这种情况下，让服务器工程师为我们完成这项工作是最好的，也是最偷懒的方法，这样我们就可以专注于我们的工作了！
