- en: Chapter 7. Handling Authentication
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter we will cover:'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding Authentication methods
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Setting up a simple database Authentication
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Writing a custom Authentication method
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter we will talk about the different methods of authentication and
    we will show you some examples on how to authenticate and how to create your own
    authentication method.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding Authentication methods
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In a world where security on the Internet is such a big issue, the need for
    great authentication methods is something that cannot be missed. Therefore, Zend
    Framework 2 provides a range of authentication methods that suits everyone's needs.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To make full use of this recipe, I recommend a working Zend Framework 2 skeleton
    application to be set up.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The following is a list of authentication methods—or as they are called adapters—that
    are readily available in Zend Framework 2\. We will provide a small overview of
    the adapter, and instructions on how you can use it.
  prefs: []
  type: TYPE_NORMAL
- en: The DbTable adapter
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Constructing a `DbTable` adapter is pretty easy, if we take a look at the following
    constructor:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The Http adapter
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: After constructing the object we need to define the `FileResolver` to make sure
    there are actually user details parsed in.
  prefs: []
  type: TYPE_NORMAL
- en: Depending on what we configured in the `accept_schemes` option, the `FileResolver`
    can either be set as a `BasicResolver`, a `DigestResolver`, or both.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take a quick look at how to set a `FileResolver` as a `DigestResolver`
    or `BasicResolver` (we do this in the `/module/Application/src/Application/Controller/IndexController.php`
    file):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: After two short examples, let's take a look at the other adapters available.
  prefs: []
  type: TYPE_NORMAL
- en: The DbTable adapter (again)
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Let's begin with probably the most used adapter of them all, the `DbTable` adapter.
    This adapter connects to a database and pulls the requested username/password
    combination from a table and, if all went well, it will return to you an identity,
    which is nothing more than the record that matched the username details.
  prefs: []
  type: TYPE_NORMAL
- en: 'To instantiate the adapter, it requires a `Zend\Db\Adapter\Adapter` in its
    constructor to connect with the database with the user details; there are also
    a couple of other options that can be set. Let''s take a look at the definition
    of the constructor:'
  prefs: []
  type: TYPE_NORMAL
- en: The second (`tableName`) option speaks for itself as it is just the table name,
    which we need to use to get our users, the third and the fourth (`identityColumn`,
    `credentialColumn`) options are logical and they represent the username and password
    (or what we use) columns in our table. The last option, the `credentialTreatment`
    option, however, might not make a lot of sense.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `credentialTreatment` tells the adapter to treat the `credentialColumn`
    with a function before trying to query it. Examples of this could be to use the
    `MD5(?)` function, `PASSWORD(?)`, or `SHA1(?)` function, if it was a MySQL database,
    but obviously this can differ per database as well. To give a small example on
    how the SQL can look like (the actual adapter builds this query up differently)
    with and without a credential treatment, take a look at the following examples:'
  prefs: []
  type: TYPE_NORMAL
- en: 'With credential treatment:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Without credential treatment:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: When defining the treatment we should always include a question mark for where
    the password needs to come, for example, `MD5(?)` would create `MD5('some_password')`,
    but without the question mark it would not insert the password.
  prefs: []
  type: TYPE_NORMAL
- en: 'Lastly, instead of giving the options through the constructor, we can also
    use the setter methods for the properties: `setTableName()`, `setIdentityColumn()`,
    `setCredentialColumn()`, and `setCredentialTreatment()`.'
  prefs: []
  type: TYPE_NORMAL
- en: The Http adapter (again)
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The HTTP authentication adapter is an adapter that we have probably all come
    across at least once in our Internet lives. We can recognize the authentication
    when we go to a website and there is a pop up showing where we can fill in our
    usernames and passwords to continue.
  prefs: []
  type: TYPE_NORMAL
- en: This form of authentication is very basic, but still very effective in certain
    implementations, and therefore, a part of Zend Framework 2\. There is only one
    big massive *but* to this authentication, and that is that it can (when using
    the basic authentication) send the username and password clear text through the
    browser (ouch!).
  prefs: []
  type: TYPE_NORMAL
- en: There is however a solution to this problem and that is to use the Digest authentication,
    which is also supported by this adapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we take a look at the constructor of this adapter, we would see the following
    code line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'The constructor accepts a load of keys in its `config` parameter, which are
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`accept_schemes`: This refers to what we want to accept authentication wise;
    this can be `basic`, `digest`, or `basic digest`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`realm`: This is a description of the realm we are in, for example `Member''s
    area`. This is for the user only and is only to describe what the user is logging
    in for.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`digest_domains`: These are URLs for which this authentication is working.
    So if a user logs in with his details on any of the URLs defined, they will work.
    The URLs should be defined in a space-separated (weird, right?) list, for example
    `/members/area /members/login`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`nonce_timeout`: This will set the number of seconds the nonce (the hash users
    login with when we are using Digest authentication) is valid. Note, however, that
    nonce tracking and stale support are not implemented in Version 2.2 yet, which
    means it will authenticate again every time the nonce times out.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`use_opaque`: This is either true or false (by default is true) and tells our
    adapter to send the opaque header to the client. The opaque header is a string
    sent by the server, which needs to be returned back on authentication. This does
    not work sometimes on Microsoft Internet Explorer browsers though, as they seem
    to ignore that header. Ideally the opaque header is an ever-changing string, to
    reduce predictability, but ZF 2 doesn''t randomize the string and always returns
    the same hash.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`algorithm`: This includes the algorithm to use for the authentication, it
    needs to be a supported algorithm that is defined in the `supportedAlgos` property.
    At the moment there is only MD5 though.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`proxy_auth`: This boolean (by default is false) tells us if the authentication
    used is a proxy Authentication or not.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It should be noted that there is a slight difference in files when using either
    Digest or Basic. Although both files have the same layout, they cannot be used
    interchangeably as the Digest requires the credentials to be MD5 hashed, while
    the Basic requires the credentials to be plain text. There should also always
    be a new line after every credential, meaning that the last line in the credential
    file should be empty.
  prefs: []
  type: TYPE_NORMAL
- en: 'The layout of a credential file is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Instead of a `FileResolver`, one can also use the `ApacheResolver` which can
    be used to read out `htpasswd` generated files, which comes in handy when there
    is already such a file in place.
  prefs: []
  type: TYPE_NORMAL
- en: The Digest adapter
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `Digest` adapter is basically the `Http` adapter without any Basic authentication.
    As the idea behind it is the same as the `Http` adapter, we will just go on and
    talk about the constructor, as that is a bit different in implementation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'As we can see the following options can be set when constructing the object:'
  prefs: []
  type: TYPE_NORMAL
- en: '`filename`: This is the direct filename of the file to use with the Digest
    credentials, so no need to use a `FileResolver` with this one.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`realm`: This identifies to the user what he/she is logging on to, for example
    `My Awesome Realm` or `The Dragonborn''s lair`. As we are immediately trying to
    log on when constructing this, it does need to correspond with the credential
    file (see *The Http adapter* for the credential file layout).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`identity`: This is the username we are trying to log on with, and again it
    needs to resemble a user that is defined in the credential file to work.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`credential`: This is the Digest password we try to log on with, and this again
    needs to match the password exactly like the one in the credential file.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We can then, for example, just run `$digestAdapter->getIdentity()` to find out
    if we are successfully authenticated or not, resulting in `NULL` if we are not,
    and resulting in the identity column value if we are.
  prefs: []
  type: TYPE_NORMAL
- en: The LDAP adapter
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Using the LDAP authentication is obviously a little more difficult to explain,
    so we will not go in to that in full as that would take quite a while. What we
    will do is show the constructor of the `LDAP` adapter and explain its various
    options. However, if we want to know more about setting up an LDAP connection,
    we should take a look at the documentation of ZF2, as it is explained in there
    very well:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: The options parameter in the construct refers to an array of configuration options
    that are compatible with the `Zend\Ldap\Ldap` configuration. There are literally
    dozens of options that can be set here so we advise to go and look at the LDAP
    documentation of ZF2 to know more about that. The next two parameters identity
    and credential are respectively the username and password again, so that explains
    itself really.
  prefs: []
  type: TYPE_NORMAL
- en: Once you have set up the connection with the LDAP there isn't much left to do
    but to get the identity and see whether we were successfully validated or not.
  prefs: []
  type: TYPE_NORMAL
- en: About Authentication
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Authentication in Zend Framework 2 works through specific adapters, which are
    always an implementation of the `Zend\Authentication\Adapter\AdapterInterface`
    and thus, always provides the methods defined in there. However, the methods of
    Authentication are all different, and strong knowledge of the methods displayed
    previously is always a requirement. Some work through the browser, like the `Http`
    and `Digest` adapter, and others just require us to create a whole implementation
    like the `LDAP` and the `DbTable` adapter.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up a simple database Authentication
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: After seeing all the authentication methods available, it is time to see how
    it will actually work when we have a database authentication in place. This recipe
    will explain all the ins and outs of this specific method.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A working Zend Framework 2 skeleton application with the PHP sqlite extension
    loaded and enabled.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Database authentication can very well be the most widely used authentication
    method there is. In this recipe we will set up our own database authentication.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up the module initialization
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We will create our database as soon as possible after initialization of the
    modules, so we will attach it to an event called route or `MvcEvent::EVENT_ROUTE`.
    As a template for the `Module.php` we can just copy over the `Application/Module.php`
    file and change the namespace; we will be working in the `onBootstrap` method
    anyway, and the rest of the `Module` class can stay the same (but don't forget
    to change the namespace!).
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take a look at the code of our `/module/Authentication/Module.php` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: We have now created an event that will be triggered when we start routing. If
    we look carefully enough we can find one big mistake that will crash this code
    for sure. The problem of course being the db key in the `ServiceManager`, as we
    refer to a service we have yet to create. So let's get cracking and create that
    `/module/Authentication/config/module.config.php` file…
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: That's it; our basic configuration to get the database going is done, and if
    we run the code now we can be certain our database is created.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the authentication service
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The next thing we want to do is to create our Authentication service, the service
    that will help our application do all the authentication functionality. Let's
    create this service in the `Authentication\Service` namespace, and let's call
    the class `Authentication` (the file is `/module/Authentication/src/Authentication/Service/Authentication.php`).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Well that was easy; we just created our service… which does absolutely nothing
    at the moment. Let's first create a method that checks if we are authenticated
    or not. We do this by checking the authentication session, and see if it is empty
    or not. Assuming that in this case we only have a (authentication!) session when
    are actually authenticated, we can safely agree that we will be logged in;
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: We can easily just open a session as the namespace of the session will only
    be used for authentication purposes.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s now create our authentication, which will authenticate a username and
    password, and return a boolean stating that we are or aren''t successful in authenticating:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'As we saw in the previous code snippet, we created a simple authentication
    method that returns either true or false, depending on if we are authenticated
    or not. What it also does is save the identity to the authentication session,
    so we can see in our previous method if we were authenticated or not. We also
    need the identity in the session for when we want to get the username from our
    logged in user, which will retrieve with the following method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Now that we got our identity, it is also important that we are able to logout.
    In our case it is as simple as just clearing the session, because why would we
    make it more difficult than just that?
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'We have now created a simple authentication service, and the only part left
    now is to register it in the service manager so that it will be instantiated when
    we boot up. We can do this in the `/module/Authentication/config/module.config.php`
    file as usual, and because we already have a `service_manager` configuration there,
    we can just plant the invokable in there:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: And that's it for the service! All that is left now to do is create the `login/logout`
    action and then check if we are logged in or not. Let's begin with the `login/logout`
    action so that we are actually able to login!
  prefs: []
  type: TYPE_NORMAL
- en: Setting up the controller and action
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Let''s first change the `/module/Authentication/config/module.config.php` file
    while we are still in there so we can access our `login/logout` action, which
    is kind of crucial to us:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: This basic route just makes `/authentication` redirect to our `loginAction`
    and because of the segment route we can simply do `/authentication/logout` to
    redirect to our `logoutAction`; if more explanation is required for the routes,
    we can review [Chapter 1](ch01.html "Chapter 1. Zend Framework 2 Basics"), *Zend
    Framework 2 Basics*, and look in the *Handling routines* recipe.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s continue creating our /`module/Authentication/src/Authentication/Controller/IndexController`
    in the `Authentication\Controller` namespace:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'We have simply declared our controller; now let''s add the `logoutAction` (we
    will begin with that, as it is incredibly simple) and the `loginAction`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'As we can see this is almost too simple, but we won''t complain if it works.
    Now let us create our `loginAction`, which basically looks if there is a post
    and if there is tries to login, otherwise shows a login form. Upon successful
    login we will be redirected to the `/application` route, and if not successful
    we will just display an error message:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: As we can see the `loginAction` is merely checking if we have anything posted,
    and if we do, it lets the `AuthService` handle it. This way is not perfect as
    it doesn't check for malicious parameters or anything, but it does show how clean
    a controller is supposed to be with no login in there except the bare minimum
    parsing of variables.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `logoutAction` doesn''t contain a view script, as that action only redirects
    the user and never has a response of its own. The `loginAction`, however, does
    have view script, as it needs to show a form. Let''s quickly build a view script
    for the `loginAction` now (the file is `/module/Authentication/view/authentication/index/login.phtml`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: A simple form to login and in my opinion doesn't require any explanation.
  prefs: []
  type: TYPE_NORMAL
- en: 'The last thing that we want to do know is to make sure nobody can access anything
    in the application other than the authentication if he/she is not logged in. We
    can do that by a new event in the Module (the file is `/module/Authentication/Module.php`)
    class of the Authentication module, which will check if we are logged in, and
    if not redirects us before any output is done to the screen:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: That's the event that we need, what happens is that we will simply be redirected
    to the login page whenever we try to reach a route which is not our authentication
    route.
  prefs: []
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: What we are going to do is create a simple database authentication that works
    through an in-memory SQLite database. This means that the database isn't stored
    and that all the tables and records need building up every time we request the
    page. Obviously this is highly inconvenient to use in a production environment,
    it is, however, excellent to show off how it works and is really handy to get
    something going quickly.
  prefs: []
  type: TYPE_NORMAL
- en: Assuming we are working on a default Zend Skeleton application, let's create
    a new module Authentication. This new module will contain the database connection,
    the authentication itself and the login and logout actions. When we created the
    directory for the new module, we should also be wary to add the new module in
    the `application.config.php` file, otherwise we might end up having trouble finding
    out why it doesn't do anything (oh yes, I am talking from experience).
  prefs: []
  type: TYPE_NORMAL
- en: First of all we built our in-memory database in the `Module.php` for the authentication.
    We then created a table called `users`, with a unique ID, username, and password.
    The ID consist of an integer, the username a variable character of 20 positions,
    and the password will be a character of 32, as that is the size of an MD5 encrypted
    string.
  prefs: []
  type: TYPE_NORMAL
- en: Because we set up a user table, and connected that table to the authentication
    adapter, we were able to authenticate the username and password simply. As an
    extra measure we made sure the user can't go to any other page than the login
    page when he isn't logged in, which we did by using an event that happens before
    the output was send to the user.
  prefs: []
  type: TYPE_NORMAL
- en: Writing a custom Authentication method
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Sometimes the standard methods just don't cut it, and that is okay. That is
    why this recipe gives a clear insight into how to create our own authentication
    method.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For this recipe it would be preferred if there is a web environment that has
    SSL enabled. Configuring such an environment is outside the scope but it would
    be beneficial for the execution of this recipe.
  prefs: []
  type: TYPE_NORMAL
- en: 'An example of an environment like this would be an Apache 2 web server with
    `mod_ssl` correctly configured. To enable the certificate verification on Apache2,
    one needs to place the following code in their `public/.htaccess` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Another thing that is important to mention is that PHP should be configured
    (and compiled) with the `--with-openssl` parameter, otherwise the code to parse
    the certificate will not exist and thus, we would not be able to use the code.
    More information on how to do this can be found at [http://www.php.net/manual/en/book.openssl.php](http://www.php.net/manual/en/book.openssl.php).
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Authentication by certification might be rare, but it is sometimes used when
    the level of security is a little bit higher than the average web application.
    In this recipe we will show an example of a certificate-based authentication.
  prefs: []
  type: TYPE_NORMAL
- en: Creating our adapter
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Let's get started by creating our new adapter, which will be an implementation
    of `Zend\Authentication\Adapter\AdapterInterface` as we want to integrate as much
    as possible with the current authentication adapters.
  prefs: []
  type: TYPE_NORMAL
- en: As we already have an Authentication module from the previous recipe, we will
    just take that as the namespace in which we are going to work; just as easy as
    described earlier.
  prefs: []
  type: TYPE_NORMAL
- en: First let's create the adapter (the file is `/module/Authentication/src/Authentication/Adapter/Certificate.php`).
  prefs: []
  type: TYPE_NORMAL
- en: The adapter outline
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We''ll first start with our basic class outline:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Creating a getter and setter for any error messages
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Normally we would come up with error messages as we go in development. But
    as this code is already made, we already have the error messages defined. There
    is no good way to describe these getters and setters, so we will just show them
    in the following piece of code so that it is at least clear what is going on (the
    file is `/module/Authentication/src/Authentication/Adapter/Certificate.php`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'These are the error messages we thought of and will be used somewhere in the
    code later on. Now let''s create the setter for these error messages so that the
    getter can easily retrieve them later on:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Well that was exciting. Let''s create the getter now, which is slightly more
    elaborate, but only just a little:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Making sure we have a secure connection
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Although certificates are only sent when we do have an SSL connection, an extra
    check isn't that bad as we want to be certain that the user is using a secure
    connection.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Wow, that must have been the best method ever! All joking aside, it is fairly
    simple as the `HTTPS` key is given in the `$_SERVER` variable, whenever a secure
    connection through HTTPS is set up. When the key is present, we can assume that
    there is a secure connection.
  prefs: []
  type: TYPE_NORMAL
- en: Checking if the certificate is an actual certificate
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Next up is to check if the certificate is valid or not, but before we can do
    that we should also make sure there is a way to set the certificate as well:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: This method did a basic check to see if we actually got a certificate that is
    at least valid, even if it is expired or doesn't have any of our fields.
  prefs: []
  type: TYPE_NORMAL
- en: Checking if we have all the certificate fields
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'As we want to check the e-mail address in our certificate, we need to make
    sure we actually have an e-mail address in there as well. And while we are at
    it, we will also check for a couple of other fields that are not relevant to our
    authentication, but would be nice to have anyway:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: We check if the fields are in there, and if the field isn't in there we will
    return false.
  prefs: []
  type: TYPE_NORMAL
- en: Checking if the certificate isn't expired yet
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Now we want to know if the certificate is still valid in terms of time, as
    certificates usually expire after a set time (this can be months, weeks, years,
    anything really):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: If this method returns true, we can be sure that we have a certificate that
    isn't expired.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a getter and setter for the Database adapter
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Now we need a simple getter and setter for our database adapter, before we
    can actually do the authentication:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: Of course this was again very simple, as it requires no logic at all. Now that
    we have set our database adapter, we can actually begin authenticating the user.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the authenticate method
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'This method will implement all our previously defined methods and if they are
    all successful, it will authenticate through the database and see if our user
    is there (or not). But first, we need another method to get fields from our certificate,
    which is a neater way, and a method to get our identity once authenticated:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: And now for the supreme moment, after a long wait, finally the `authenticate`
    method!
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: And that's it! The `authenticate` method will either return true on successful
    authentication or false, and will set an error at the same time so that we can
    see what exactly went wrong!
  prefs: []
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now that we have created our own `authentication` adapter, it is time to sit
    back and review what we just did.
  prefs: []
  type: TYPE_NORMAL
- en: What are we trying to achieve
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: On some websites the access is prohibited on such a level that usernames and
    passwords are a thing of the past. In environments where we want to check every
    customer that comes in without them needing to type the username and password
    themselves, we might use certificate authentication.
  prefs: []
  type: TYPE_NORMAL
- en: Certificate authentication works because the client will send a certificate
    with every server request they do. This certificate then shows the server *who*
    the user is, who is trying to browse their pages. Usually one or more fields in
    the certificate are used to identify the user. In our example we will use the
    e-mail address, which is a common field to be used for identification.
  prefs: []
  type: TYPE_NORMAL
- en: What we will do first off, is create an adapter that will get the certificate
    either from manual input (easier testing that way) or the browser, whichever works
    really. We will then check if the e-mail address exists in our database, and if
    so we consider the user logged in. Obviously our server will not be configured
    so strictly that no certificate will be allowed, as in this stage basically every
    certificate with a right e-mail address gets access. If we want to know how we
    can prevent users from using any certificate, we can take a look at the *There's
    more…* section, where we will look in the direction of securing your server a
    bit further, and restricting the certificate use.
  prefs: []
  type: TYPE_NORMAL
- en: From an application point of view, however, we just presume that all the certificates
    that we get, are valid.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `AdapterInterface` only requires us to have an authenticate method. But
    before we can go ahead we want to make sure that the following items are checked:'
  prefs: []
  type: TYPE_NORMAL
- en: We want to make sure the user is coming through a secure connection (HTTPS)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We also want to make sure the certificate is valid (obviously)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: While we are checking, we'll make sure our certificate has the fields we require
    for authentication
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: And we need to know if the certificate is still valid and not expired
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Last but not least, we also need to make sure that we have a database adapter
    to check the values against
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: About certificates
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In general the certificates are validated on the server before they reach the
    application. The validation usually happens against some sort of CA, or Certificate
    Authority, which is basically an entity on the server site that issues certificates,
    and therefore can vouch for any certificates carrying its signature. Of course
    in real life this is way more complicated than just described, but the idea is
    the same. So when a certain level of checking is being done on the server to verify
    the identity of the certificate, and if it is valid against the CA provided by
    the server, it will then parse it through to our application.
  prefs: []
  type: TYPE_NORMAL
- en: By the time it reaches our application, we usually assume that the user got
    the certificate from us, and therefore should be allowed in, as he knew the password
    at the door. But although he knew the password, that doesn't mean we know who
    it is! That is why a second authentication (the one we just made) verifies if
    a user actually belongs in our application or not, that is, if it is a valid certificate
    or not!
  prefs: []
  type: TYPE_NORMAL
- en: There's more…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Securing a server is the most important part of this kind of validation, as
    we really (really, really) need to be sure that the user carrying the certificate
    is actually valid. Usually building complex servers like this are done with server
    engineers and not the task of the developer, but if it is then it would be a great
    idea to read up on the subject first.
  prefs: []
  type: TYPE_NORMAL
- en: Personally, I am a fan of Apache and would recommend anyone to read up on the
    `mod_ssl` configuration, as it is very thorough on the subject of securing a server
    and it has a lot of resources to find out how to configure it just right.
  prefs: []
  type: TYPE_NORMAL
- en: But in the end configuring SSL without the proper know-how is a very tedious
    and error-prone process and it is likely that properly configuring a server is
    a bit over the head of a developer. In that case getting a server engineer to
    do it for us is the best way, and the laziest, which lets us concentrate on our
    work!
  prefs: []
  type: TYPE_NORMAL
