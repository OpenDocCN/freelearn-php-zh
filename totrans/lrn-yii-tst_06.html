<html><head></head><body><div class="chapter" title="Chapter&#xA0;6.&#xA0;Testing the API &#x2013; PHPBrowser to the Rescue"><div class="titlepage"><div><div><h1 class="title"><a id="ch06"/>Chapter 6. Testing the API – PHPBrowser to the Rescue</h1></div></div></div><p>We are now going to delve into functional testing. In the previous chapter, we created the initial steps that deal with the user model, but now we will be creating the REST interface that deals with the user.</p><p>Before we even start to worry about the REST interface and its tests, we will be analyzing what's already available in the Yii basic app and later expand on the topic to create more awesome stuff.</p><p>This chapter is hence divided into three sections with an increasing level of difficulty, so keep your eyes peeled and feel free to revisit it multiple times until you understand each section which are:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Functional tests in Yii 2</li><li class="listitem" style="list-style-type: disc">Functional tests for REST interfaces</li><li class="listitem" style="list-style-type: disc">Creating a RESTful web service with Yii 2</li></ul></div><div class="section" title="Functional tests in Yii 2"><div class="titlepage"><div><div><h1 class="title"><a id="ch06lvl1sec36"/>Functional tests in Yii 2</h1></div></div></div><p>As you<a id="id296" class="indexterm"/> saw in <a class="link" href="ch03.html" title="Chapter 3. Entering Codeception">Chapter 3</a>, <span class="emphasis"><em>Entering Codeception</em></span>, we have some basic functional tests preloaded in our basic application.</p><p>Let's start digging into that and once you acquire the required knowledge, we're going to move on to the tests for the REST interface.</p><p>As you know, the basic application is composed of a few pages, a login system, and a contact form.</p><p>The functional tests cover almost everything, so let's start to see what files we have and what's their content.</p><div class="section" title="Understanding and improving the available CEPTs"><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec40"/>Understanding and improving the available CEPTs</h2></div></div></div><p>The tests <a id="id297" class="indexterm"/>contained in <code class="literal">codeception/functional/HomeCept.php</code> are quite straightforward to understand. Thanks to the syntax used by Codeception, you can easily understand what the intention of the test is, so let's break it down and see what each bit does:</p><div class="informalexample"><pre class="programlisting">$I = new FunctionalTester($scenario);</pre></div><p>You would start by initializing the actor under which the tests will be performed. Yii uses a slightly different naming than the one officially used in the documentation and guide of Codeception, which is <code class="literal">TestGuy</code>, so keep that in mind when you're confronted with documentation outside of Yii's.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip13"/>Tip</h3><p>Remember that you can name the actors whatever you want, and their configuration is found in the suite YAML file, which for functional tests is <code class="literal">tests/codeception/functional.suite.yml</code>.</p></div></div><p>This class is located within the same folder as that of the other functional tests and is generated automatically by running <code class="literal">codecept build</code>:</p><div class="informalexample"><pre class="programlisting">$I-&gt;wantTo('ensure that home page works');</pre></div><p>The very first step is to<a id="id298" class="indexterm"/> declare the scope of the test in a compact but detailed way; this will help you and non-technical people to understand what went wrong and if the test is effectively doing what it is meant to be doing in a strong and comprehensive way. The method <code class="literal">wantTo()</code> should be called only once, as any following invocations will override what has been set previously:</p><div class="informalexample"><pre class="programlisting">$I-&gt;amOnPage(Yii::$app-&gt;homeUrl);</pre></div><p>Our tests need a starting point; the method <code class="literal">amOnPage()</code> does nothing but load the given URL where our actual test will take place:</p><div class="informalexample"><pre class="programlisting">$I-&gt;see('My Company');
$I-&gt;seeLink('About');</pre></div><p>In Codeception, assertions are performed through <code class="literal">see*</code> and <code class="literal">dontSee*</code> actions, ensuring a particular portion of text or link is present/absent  in the page.</p><p>These actions can be as descriptive as needed, and in the preceding example with <code class="literal">see('My Company')</code>, we are just checking that the text is present somewhere in the markup rather than in a particular tag while <code class="literal">seeLink('About')</code> would be the same as writing <code class="literal">see('About', 'a')</code>. We will shortly see that we could pass a second parameter to <code class="literal">seeLink()</code>, which will allow us to check the URL where the link should point to.</p><p>Interaction with the page in the form of triggering, clicking links with <code class="literal">click()</code>, filling fields with <code class="literal">fillField()</code>, <code class="literal">checkOption()</code>, <code class="literal">submitForm()</code>, and so on is all you can do with Codeception functional tests. Anything more complicated must be re-evaluated carefully, as you might actually need to move it into acceptance tests instead:</p><div class="informalexample"><pre class="programlisting">$I-&gt;click('About');
$I-&gt;see('This is the About page.');</pre></div><p>In the preceding lines, we <a id="id299" class="indexterm"/>are triggering the link of the "About" page and expecting that the resulting page has a specific copy in it. This specific test just makes a point in using links to navigate through our application, as it could have been done as  described earlier by using <code class="literal">seeLink('About', '/about')</code> and to leave any assertion with the About page within its own test.</p><p>We might as well extend the test a bit more and make it more relevant to what we're trying to test; what are the functionality parts that we want to make sure exist, without which we can consider the page "non-functional"? In our instance, we are talking about the title of the page (as it's already been done), the menu, and any other links we always want to have there:</p><div class="informalexample"><pre class="programlisting">$I = new FunctionalTester($scenario);
$I-&gt;wantTo('ensure that home page works');
$I-&gt;amOnPage(Yii::$app-&gt;homeUrl);</pre></div><p>The beginning is the same, but then we ensure that the title for the page contains what we expect it to be:</p><div class="informalexample"><pre class="programlisting">$I-&gt;expect('the title to be set correctly');
$I-&gt;seeInTitle('My Yii Application');</pre></div><p>The next section instead makes sure that the menu contains all the required links to the various pages:</p><div class="informalexample"><pre class="programlisting">$I-&gt;expectTo('see all the links of the menu');
$I-&gt;seeLink('Home', '/');
$I-&gt;seeLink('About', '/about');
$I-&gt;seeLink('Login', '/login');
$I-&gt;seeLink('Contact', '/contact');</pre></div><p>You have to keep in mind that the links are not strictly checked; this means that if you have <code class="literal">$I-&gt;seeLink('Something', '/something')</code>, it will match any link that contains <code class="literal">Something</code>; for example, it can be <code class="literal">Something Else</code> and any <code class="literal">href</code> attribute like <code class="literal">/something/else</code>, or even <code class="literal">http://something.com</code>.</p><p>In our case, it clearly renders the check for the link to the home page a bit irrelevant, so we might well grab the current URL and check against it in the following way:</p><div class="informalexample"><pre class="programlisting">$url = $I-&gt;grabFromCurrentUrl();
$I-&gt;seeLink('Home', $url);</pre></div><p>There are different<a id="id300" class="indexterm"/> ways to grab content to be reused dynamically in the rest of the tests, such as <code class="literal">grabAttributeFrom()</code>, <code class="literal">grabCookie()</code>, <code class="literal">grabResponse()</code>, and so on. Once again, your <code class="literal">FunctionalTester</code> class will contain the details of these methods in case your IDE does not support code hinting.</p><p>We can do the same for any other link that is pointing to the homepage:</p><div class="informalexample"><pre class="programlisting">$I-&gt;expectTo('see a self-referencing link to my company homepage');
$I-&gt;seeLink('My Company', $url);</pre></div><p>For the rest of the links, it might also be useful to check that our routes are well configured; for instance, you need to check if the name of the controller doesn't show up:</p><div class="informalexample"><pre class="programlisting">$I-&gt;dontSeeLink('About', 'site/about');
$I-&gt;dontSeeLink('Login', 'site/login');
$I-&gt;dontSeeLink('About', 'site/contact');</pre></div><p>The last bit we want to make sure of is that the <code class="literal">Home</code> link is marked as selected.</p><p>For this test, we need to use a very prescriptive selector as the active class that identifies the status of our link is in the parent of the actual anchor, and as there's no way to assert that in a simple way, so making use of XPath expressions comes particularly handy:</p><div class="informalexample"><pre class="programlisting">$I-&gt;expectTo('see the link of the homepage as selected');
$I-&gt;seeElement('//li[@class="active"]/a[contains(.,"Home")]');</pre></div><p>Most of the methods available that require a context selector such as <code class="literal">click()</code>, <code class="literal">see()</code>, and, <code class="literal">seeElement()</code> can accept this parameter in various formats, mostly as CSS selectors, XPath queries or Locators, which are specific objects made available by Codeception.</p><p>In its simplest form, selectors can be just a simple word or sentence, which means "find me the first context where this word/sentence appears". As you saw earlier, <code class="literal">see("Something")</code> will return the first element that contains <code class="literal">Something</code> as its value (for example, <code class="literal">Something Else)</code>.</p><p>CSS selectors are probably the ones you might be more comfortable with, but for more complex stuff, XPath is generally the winner.</p><p>In the preceding example, the XPath query <code class="literal">//li[@class="active"]/a[contains(.,"Home")]</code>, can be read as shown here:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Find me all the <code class="literal">li</code> nodes at any level (<code class="literal">//li</code>)</li><li class="listitem" style="list-style-type: disc">Filter them by a specific class attribute (<code class="literal">[@class="active"]</code>);—mind that is literal and case-sensitive</li><li class="listitem" style="list-style-type: disc">Within those find me the direct descendant <code class="literal">a</code> nodes (<code class="literal">/a</code>)</li><li class="listitem" style="list-style-type: disc">Filter them if they contain a specific text (<code class="literal">[contains(.,"Home")]</code>)</li></ul></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note23"/>Note</h3><p>XPath 2.0<a id="id301" class="indexterm"/> has been a W3C recommendation since December 2010, and you can<a id="id302" class="indexterm"/> read more about it at <a class="ulink" href="http://www.w3.org/TR/xpath20/">http://www.w3.org/TR/xpath20/</a>.</p></div></div><p>Locators can <a id="id303" class="indexterm"/>ease the process of writing even more complex queries in your DOM and let you combine CSS and XPath queries via OR:</p><div class="informalexample"><pre class="programlisting">use \Codeception\Util\Locator;

$I-&gt;see('Title', Locator::combine('h1','h2','h3'));</pre></div><p>With the preceding statement, we can check the presence of the <code class="literal">Title</code> string in any <code class="literal">h1</code>, <code class="literal">h2</code>, or <code class="literal">h3</code> tag.</p><p>Another possibly useful feature is a method available in Locator that you can use to browse the page via <code class="literal">tabIndex</code>:</p><div class="informalexample"><pre class="programlisting">&lt;?php
use \Codeception\Util\Locator;

$I-&gt;fillField(Locator::tabIndex(1), 'davert');
$I-&gt;fillField(Locator::tabIndex(2) , 'qwerty');
$I-&gt;click('Login');</pre></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note24"/>Note</h3><p>The preceding example has been deliberately taken from the documentation page of<a id="id304" class="indexterm"/> Locator, available at <a class="ulink" href="http://codeception.com/docs/reference/Locator">http://codeception.com/docs/reference/Locator</a>.</p></div></div></div><div class="section" title="Writing reusable page interactions"><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec41"/>Writing reusable page interactions</h2></div></div></div><p>Testing forms <a id="id305" class="indexterm"/>is probably one of the most strenuous tasks any developer and tester has probably ever done. You can feel the pain if you think of forms as questionnaires of several single and multiple choice questions, spread across several pages.</p><p>You can clearly see the direct benefit of automating using functional tests.</p><p>The two examples already available, <code class="literal">LoginCept.php</code> and <code class="literal">ContactCept.php</code>, are a good starting point. Let's have a closer look at <code class="literal">LoginCept.php</code>; if you scan through the content of the test, you will immediately notice that the <code class="literal">fillField()</code> method is never called, and in its place we have the following command:</p><div class="informalexample"><pre class="programlisting">$loginPage = <span class="strong"><strong>LoginPage::openBy($I);</strong></span>

$I-&gt;see('Login', 'h1');
$I-&gt;amGoingTo('try to login with empty credentials');
<span class="strong"><strong>$loginPage-&gt;login('', '');</strong></span>
</pre></div><p>Pages are, in fact, one of the easiest ways to reuse components across tests. The sequence of actions that are repeated several times in the same test are likely to be taken and put into a page like the one used in our test:</p><div class="informalexample"><pre class="programlisting">namespace tests\codeception\_pages;

use yii\codeception\BasePage;

/**
 * Represents login page
 * @property \AcceptanceTester|\FunctionalTester $actor
 */
class LoginPage extends BasePage
{
    public $route = 'site/login';

    /**
     * @param string $username
     * @param string $password
     */
    public function login($username, $password)
    {
        $this-&gt;actor-&gt;fillField(
            'input[name="LoginForm[username]"]', $username
        );
        $this-&gt;actor-&gt;fillField(
            'input[name="LoginForm[password]"]', $password
        );
        $this-&gt;actor-&gt;click('login-button');
    }
}</pre></div><p>The only thing<a id="id306" class="indexterm"/> needed is the route associated to it and then you can implement as many methods as you need to achieve whatever you need, which is the login process in the preceding case.</p><p>Within the <code class="literal">Page</code> class, <code class="literal">$this-&gt;actor</code> is a reference to the actor that is currently in use in the test.</p><p>You have two ways to use pages; the first is by opening the page immediately and associate it with the current actor, as seen earlier with <code class="literal">LoginPage::openBy($I)</code>, otherwise, you can simply call its constructor and load the page (also with different parameters) when needed:</p><div class="informalexample"><pre class="programlisting">$loginPage = new LoginPage($I);
$loginPage-&gt;getUrl();</pre></div><p>Now, as you saw while working with unit tests, being able to keep the content of the database under a controlled state is very useful. And, once again, fixtures come to our help, even here.</p></div><div class="section" title="Implementing fixtures"><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec42"/>Implementing fixtures</h2></div></div></div><p>In <a class="link" href="ch04.html" title="Chapter 4. Isolated Component Testing with PHPUnit">Chapter 4</a>, <span class="emphasis"><em>Isolated Component Testing with PHPUnit</em></span>, you saw how to implement a fixture. In<a id="id307" class="indexterm"/> functional tests the same classes can be used; the only difference is that Codeception's PHPBrowser and its underlying infrastructure doesn't know how to load fixtures, so each framework using Codeception, like what Yii does, needs to provide the bridging to fill in this gap.</p><p>The advanced app provides the implementation for <code class="literal">FixtureHelper</code> that implements the Codeception <code class="literal">Module</code> class and imports the methods from <code class="literal">FixtureTrait</code>:</p><div class="informalexample"><pre class="programlisting">&lt;?php

namespace tests\codeception\_support;

use tests\codeception\fixtures\UserFixture;
use Codeception\Module;
use yii\test\FixtureTrait;

/**
 * This helper is used to populate database with needed 
 * fixtures before any tests should be run.
 * For example - populate database with demo login user 
 * that should be used in acceptance and functional tests.
 * All fixtures will be loaded before suite will be
 * started and unloaded after it.
 */
class FixtureHelper extends Module
{

    /**
     * Redeclare visibility because Codeception includes
     * all public methods that not starts from "_"
     * and not excluded by module settings, in actor class.
     */
    use FixtureTrait {
        loadFixtures as protected;
        fixtures as protected;
        globalFixtures as protected;
        unloadFixtures as protected;
        getFixtures as protected;
        <span class="strong"><strong>getFixture as public;</strong></span>
    }

    /**
     * Method called before any suite tests run. 
     * Loads User fixture login user
     * to use in acceptance and functional tests.
     * @param array $settings
     */
    public function _beforeSuite($settings = [])
    {
        $this-&gt;loadFixtures();
    }

    /**
     * Method is called after all suite tests run
     */
    public function _afterSuite()
    {
        $this-&gt;unloadFixtures();
    }

    /**
     * @inheritdoc
     */
    public function fixtures()
    {
        return [
            'user' =&gt; [
                'class' =&gt; UserFixture::className(),
                'dataFile' =&gt; '@tests/codeception/fixtures/data/init_login.php',
            ],
        ];
    }
}</pre></div><p>The preceding <a id="id308" class="indexterm"/>code is quite simple, and the only important bit is that in the <code class="literal">FixtureHelper</code>, we implement the <code class="literal">fixtures()</code> method that returns the list of models handled and their data files that contain all the rows we want in the database. The only difference with the original code that is found in the advanced app is the import of the <code class="literal">getFixture()</code> method as public, and we'll later see why this is so.</p><p>The following code is for the <code class="literal">init_login.php</code> file:</p><div class="informalexample"><pre class="programlisting">&lt;?php

return [
    'basic' =&gt; [
        'username' =&gt; 'user',
        'authkey' =&gt; uniqid(),
        'password' =&gt; Yii::$app-&gt;security-&gt;generatePasswordHash(
            'something'
        ),
    ],
];</pre></div><p>As we imported the trait <code class="literal">getFixture()</code> as public, we can access the fixture through <code class="literal">$I-&gt;getFixture('user')</code> in a similar  way to what we did in our unit tests.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip14"/>Tip</h3><p>If you need to load additional fixtures, you can similarly expose the <code class="literal">loadFixtures()</code> method from the <code class="literal">FixtureTrait</code> trait and use it directly in your tests.</p></div></div><p>The last step is<a id="id309" class="indexterm"/> about loading the module in Codeception configuration:</p><div class="informalexample"><pre class="programlisting"># tests/codeception/functional.suite.yml

modules:
    enabled:
      - ...
      - tests\codeception\_support\FixtureHelper</pre></div><p>And after running <code class="literal">codecept build</code>, the fixture will be automatically loaded when running the tests in the <code class="literal">_beforeSuite()</code> and <code class="literal">_afterSuite()</code> methods.</p></div><div class="section" title="Pitfalls of functional tests"><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec43"/>Pitfalls of functional tests</h2></div></div></div><p>A <a id="id310" class="indexterm"/>word of advice is that there's plenty of information on functional tests, as well as what cannot be tested, in the official documentation.</p><p>The most important thing to grab there is all about the underlying technology that is used to perform tests; PHPBrowser is in fact a powerful tool, but as the whole functional test does not rely on the presence of a web server like you would have in a normal client-server situation, your application and functional tests will be running in the same memory space.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip15"/>Tip</h3><p>Normally the memory is cleaned during the <code class="literal">_after()</code> method execution, but remember that if you see any of your tests failing, remember to execute the test file separately, before starting to doubt your sanity.</p></div></div></div></div></div>
<div class="section" title="Functional tests for REST interfaces"><div class="titlepage"><div><div><h1 class="title"><a id="ch06lvl1sec37"/>Functional tests for REST interfaces</h1></div></div></div><p>Up until now, you <a id="id311" class="indexterm"/>have seen what's already been implemented, what is possible to do out of the box, and some additional functionalities like the fixtures.</p><p>Now let's have a look at what testing a REST interface entails; the default functional tests available in Codeception are executed by PHPBrowser, and the interface exposed to interact with it is quite limited and can only be used to deal and interact with the markup output by the web server. The REST module provided by Codeception is something we would love.</p><p>Just to cite a<a id="id312" class="indexterm"/> few of the features available, you'll have functions to set and read headers, such as <code class="literal">seeHttpHeader()</code> and <code class="literal">haveHttpHeader()</code>, and specific methods to call HTTP requests towards our interface, such as <code class="literal">sendGET()</code>, <code class="literal">sendPUT()</code>, and <code class="literal">sendOPTIONS()</code>.</p><p>Specifically for our interface of the user, our tests will be split into two parts:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Tests on the actual functionality—authentication and interaction with the application</li><li class="listitem" style="list-style-type: disc">Some additional tests to ensure that we are exposing the right endpoints</li></ul></div><p>Now, with this in mind, let's start having a look at the configuration part; in the <code class="literal">functional.suite.yml</code> file, just add the REST module and configure it as shown in the following code:</p><div class="informalexample"><pre class="programlisting"># tests/codeception/functional.suite.yml

modules:
    enabled:

      - Filesystem
      - Yii2
      - <span class="strong"><strong>REST</strong></span>
      - tests\codeception\_support\FixtureHelper
    config:
        Yii2:
            configFile: 'codeception/config/functional.php'
        PhpBrowser:
            url: 'http://basic-dev.yii2.sandbox'
        <span class="strong"><strong>REST</strong></span>:
            <span class="strong"><strong>url: 'http://basic-dev.yii2.sandbox/v1/'</strong></span>
</pre></div><p>The last line is quite important, as we will end up making calls by specifying only our endpoint without the need of naming the module base path. Clearly things need to be adjusted accordingly in case you have more than one REST endpoint you need to test.</p><p>Now, once again we need to run <code class="literal">codecept build</code> in order to get everything ready before starting to run our tests. This command, as already seen, will take all the module's methods and merge them into our actor's class (which in this case is <code class="literal">FunctionalTester</code>).</p><p>Let's generate our new test file with the following commands:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ cd tests/</strong></span>
<span class="strong"><strong>$ ../vendor/bin/codecept generate:cept functional UserAPICept</strong></span>
<span class="strong"><strong>Test was created in UserAPICept.php</strong></span>
</pre></div><p>Now that we <a id="id313" class="indexterm"/>have the file, we can start implementing our tests:</p><div class="informalexample"><pre class="programlisting">&lt;?php
// tests/codeception/functional/UserAPICept.php

$I = new FunctionalTester($scenario);
$I-&gt;wantTo('test the user REST API');</pre></div><p>We start the file with the initialization of the <code class="literal">FunctionalTester</code> and the definition of the scope of our test.</p><div class="section" title="Defining the API endpoints"><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec44"/>Defining the API endpoints</h2></div></div></div><p>As it's now<a id="id314" class="indexterm"/> time to implement the tests for our API endpoints, we need to define what these will look like and take our architectural decisions if these haven't been taken beforehand.</p><p>The basic interaction we want to provide to our clients interacting with our APIs is the ability to retrieve the user information, and modify it with the specific ability to change the password.</p><p>The client would normally know only the username and password. Since our update method will leverage on the ID of the user, we need to find a way for the client to get it in advance. Depending on the type of authentication protocol you decide to use, you can decide to return it right after the authentication has happened, otherwise you need to find a different way.</p><p>As you will later see, you're going to use the simplest of the authentication methods available, that is HTTP Basic Auth, which means that all our requests require a username and password to be sent along with them in a header. By doing so we clearly can't return the user ID in the response as this should contain the answer to the call and not the authentication header, so we can decide to provide a "search by username" endpoint. This will clearly make the username a unique field in the database, but that's not an issue, rather it's something you need to take into consideration if you're providing a user creation interface.</p><p>Now, we have <a id="id315" class="indexterm"/>the following endpoints to test:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">GET users/search/&lt;username&gt;</code>: This is used to retrieve the ID of the user.</li><li class="listitem" style="list-style-type: disc"><code class="literal">GET users/&lt;id&gt;</code>: This is used to retrieve any other information associated with the user.</li><li class="listitem" style="list-style-type: disc"><code class="literal">PUT users/&lt;id&gt;</code>: This is used to update the password.</li></ul></div></div><div class="section" title="Implementing the tests for the API"><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec45"/>Implementing the tests for the API</h2></div></div></div><p>As our <a id="id316" class="indexterm"/>passwords are passed as encrypted in the fixtures, we need to hardcode them in the tests, in order to authenticate appropriately.</p><p>This is not a good practice as we are going to make things a bit harder to maintain. On the other end, if things get more complex, we might want to refactor the code and find a better, more unified solution:</p><div class="informalexample"><pre class="programlisting">$userFixtures = $I-&gt;getFixture('user');
$user = $userFixtures['basic'];
$userPassword = 'something';</pre></div><p>Now that we have some basic information about the user, we can try to grab its ID and check if its authentication works altogether:</p><div class="informalexample"><pre class="programlisting">$I-&gt;amGoingTo('authenticate to search for my own user');
$I-&gt;amHttpAuthenticated($user['username'], $userPassword);
$I-&gt;sendGET('users/search/'.$user['username']);</pre></div><p>The first step is to prepare the request, which is composed of the <code class="literal">Authorization</code> header and the actual request. We don't need to explicitly generate the <code class="literal">Authorization</code> header, as we have an abstraction over it provided by <code class="literal">amHttpAuthenticated()</code>, which would do that for us.</p><p>The header is then sent alongside the GET request over our endpoint; note how the URL omits the <code class="literal">/v1/</code> part that we would normally use to prefix the API:</p><div class="informalexample"><pre class="programlisting">$I-&gt;seeResponseCodeIs(200);
$I-&gt;seeResponseIsJson();
$I-&gt;seeResponseContains($user['username']);
$I-&gt;seeResponseContains('password');
$I-&gt;seeResponseContains('id');</pre></div><p>Once we've sent the request, we can start analyzing the response and do various assertions on it:</p><div class="informalexample"><pre class="programlisting">$userId = $I-&gt;grabDataFromJsonResponse('id');</pre></div><p>Finally, we grab the user ID from the response, so we can reuse it afterwards.</p><p>The next step<a id="id317" class="indexterm"/> is about fetching the user's own information knowing their ID, which looks particularly straightforward to implement:</p><div class="informalexample"><pre class="programlisting">$I-&gt;amGoingTo('ensure I can fetch my own information while being authenticated');
$I-&gt;amHttpAuthenticated($user['username'], $userPassword);
$I-&gt;sendGET('users/'.$userId);
$I-&gt;seeResponseCodeIs(200);
$I-&gt;seeResponseIsJson();
$I-&gt;seeResponseContains($user['username']);
$I-&gt;seeResponseContains('password');
$I-&gt;seeResponseContains('id');</pre></div><p>As the last step, we have kept the tests on updating the password and ensuring that the new password works as expected:</p><div class="informalexample"><pre class="programlisting">$I-&gt;amGoingTo('update my own password');
$I-&gt;amHttpAuthenticated($user['username'], $userPassword);
$newPassword = 'something else';
$I-&gt;sendPUT(
    'users/' . $userId,
    ['password' =&gt; $newPassword, 'authkey' =&gt; 'updated']
);
$I-&gt;seeResponseIsJson();
$I-&gt;seeResponseContains('true');
$I-&gt;seeResponseCodeIs(200);

$I-&gt;amGoingTo('check my new password works');
$I-&gt;amHttpAuthenticated($user['username'], $newPassword);
$I-&gt;sendHEAD('users/'.$userId);
$I-&gt;seeResponseIsJson();
$I-&gt;seeResponseContains($user['username']);
$I-&gt;seeResponseCodeIs(200);</pre></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note25"/>Note</h3><p>Please note that due to the length of the tests, we will be keeping them all in one file as it won't affect their legibility, but you can clearly split them in more CEST files to aggregate them in a more concise and logical way.</p></div></div><p>This should be <a id="id318" class="indexterm"/>all you really need to know. We can check that none of the tests will pass at this point, and at the end of the chapter, we will ensure that all of them are finally passing.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note26"/>Note</h3><p>Also note that it's not necessary to call <code class="literal">amHttpAuthenticated()</code> to send the authentication header every time as it will be cached after the first call in the CEPT file, and should only be required when the header needs to be updated.</p></div></div><p>Now that we have seen how easy it is to write a functional test, I can leave the creation of additional tests to you. If you want, you can start by checking that the rest of the interfaces have not been exposed, such as the ability to request the list of all users and retrieve or change their passwords.</p><p>In the following section of this chapter, we are going to focus on the implementation side of the things by looking at some new, shiny features provided by Yii 2.</p></div></div>
<div class="section" title="Creating a RESTful web service with Yii 2"><div class="titlepage"><div><div><h1 class="title"><a id="ch06lvl1sec38"/>Creating a RESTful web service with Yii 2</h1></div></div></div><p>It's important<a id="id319" class="indexterm"/> to remember that a REST web service is by definition a stateless service, this will imply some requirements in the way we will test things and deal with the information we need to POST or GET.</p><p>The big step forward that Yii made with version 2 can be seen in the built-in REST classes that provide an immediate solution once provided by third-party implementations.</p><p>This means we'll have to introduce several changes to what we've achieved so far; the REST part of the application will be developed as a separate module, which will give us the ability to extend it and contain its logic. Because of this, the routes will be rearranged appropriately as well.</p><p>Before seeing what the Yii REST functionality is capable of doing, we'll need to first have a quick look at modules in Yii, which we will use to develop our API to be tested.</p><div class="section" title="Writing modular code in Yii"><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec46"/>Writing modular code in Yii</h2></div></div></div><p>If you've <a id="id320" class="indexterm"/>never used modules since you've started working with Yii, well, I think it's time to do so. Right now, modules are really easy and straightforward to use, and they will help you keep your code architecturally well organized and separated from the other components of your application.</p><p>Modules are self-contained software units that contain models, views and controllers, and other software components, and the end user will be able to access the controller once it is installed in the main application. For this reason, modules are considered mini-applications, only difference being that they cannot live on their own. As an example, a forum or an administrative area can be developed as modules.</p><p>Modules can also be composed of submodules; a forum might have an admin submodule that contains all the logic and interfaces to moderate and customize the main forum module.</p><p>Modules can be quite complex in their structure; I would always strongly suggest an architectural analysis before deciding to keep everything under the same module, in the same way as you need to question your choices if you were to keep all the code in the same controller. Always try to keep in mind that you should be able to understand your code in one year's time.</p></div><div class="section" title="Creating a module with Gii"><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec47"/>Creating a module with Gii</h2></div></div></div><p>Developing<a id="id321" class="indexterm"/> the REST interface using Yii modules is the easiest way to achieve versioning of the API. This way, we can easily switch and make an improved version of the API while still continuing to support the old version with minimal maintenance, until full deprecation.</p><p>So we will start with the creation of the module, using the web interface to the code generator called Gii. In case you skipped a few pages, the configuration for that is available in <a class="link" href="ch04.html" title="Chapter 4. Isolated Component Testing with PHPUnit">Chapter 4</a>, <span class="emphasis"><em>Isolated Component Testing with PHPUnit</em></span>, where you saw how to create a model with it.</p><p>Now, we will see how to create a module and what this will mean in terms of generated code.</p><p>So, head over to the Gii application, which in my case is <code class="literal">http://basic.yii2.sandbox/gii</code> and log in, if you are configured to do so and click on the <span class="strong"><strong>Module Generator</strong></span> button.</p><p>The only two fields we have to fill in are these:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Module Class</strong></span>: This represents the main name-spaced class name of the module, which will be set to <code class="literal">app\modules\v1\Module</code>.</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Module ID</strong></span>: This will be (automatically) set to <code class="literal">v1</code>.</li></ul></div><p>Have a <a id="id322" class="indexterm"/>look at the following screenshot:</p><div class="mediaobject"><img src="graphics/B03646_06_01.jpg" alt="Creating a module with Gii"/><div class="caption"><p>Module generator page within the Gii code generation tool</p></div></div><p>You can avoid creating the view by deselecting the related checkbox, as we're not going to need one. We're going to make more changes to what has been generated.</p><p>Click on the <span class="strong"><strong>Generate</strong></span> button, once ready.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note27"/>Note</h3><p>If your application will end up being more complex than what we have here, you still have a few options.</p><p>You can simply adjust the routes for the module, as explained in the documentation at <a class="ulink" href="http://www.yiiframework.com/doc-2.0/guide-runtime-routing.html#adding-rules-dynamically">http://www.yiiframework.com/doc-2.0/guide-runtime-routing.html#adding-rules-dynamically</a>.</p><p>Otherwise, you can create a module within a module (for example, a container module called <code class="literal">api</code> which will contain the various versions as modules such as <code class="literal">v1</code>, <code class="literal">v2</code>, and so on). Just remember to namespace it correctly when creating it. This is usually the solution I'd recommend from the code organization point of view.</p></div></div><p>The next <a id="id323" class="indexterm"/>step is to configure the module in order to be able to use it, and then we will see how to transform it into a REST module.</p></div><div class="section" title="Using modules in Yii 2"><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec48"/>Using modules in Yii 2</h2></div></div></div><p>Now that we <a id="id324" class="indexterm"/>have our basic code for our module ready, we need to see how we can use it.</p><p>Ideally, the created module can be used straight away without much hassle, which is quite helpful in an environment where you want to be able to create reusable and, of course, modular code.</p><p>The only step that's really needed is instructing Yii that there is a new module, and in return, it will take care of auto-loading and calling our module controller at the right time.</p><p>So let's head over to our configuration file located in <code class="literal">/config/web.php</code> and add the following code:</p><div class="informalexample"><pre class="programlisting">// /config/web.php

$config = [
    // ...
    'modules' =&gt; [
        'v1' =&gt; [
            'class' =&gt; 'app\modules\v1\Module',
        ],
    ],
    // ...
];</pre></div><p>With this, you're ready to go. In order to convert the newly created module to act as a REST controller, it requires<a id="id325" class="indexterm"/> some additional changes, which we will explore immediately.</p></div><div class="section" title="Converting our controller to be a REST controller"><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec49"/>Converting our controller to be a REST controller</h2></div></div></div><p>This <a id="id326" class="indexterm"/>much anticipated feature of Yii 2 lets you create a REST interface in a clear and easy way.</p><p>The REST controller we will inherit from will deal with our models without much configuration needed and even if there was, it's quite straightforward to do and keep in mind.</p><p>Our first step is to create <code class="literal">UserController</code> which will be dealt with the <code class="literal">User</code> model.</p><p>Let's start by defining the namespace and the basic classes we're going to use in our new controller:</p><div class="informalexample"><pre class="programlisting">// /modules/v1/controllers/UserController.php

namespace app\modules\v1\controllers;

use app\models\User;
use yii\rest\ActiveController;</pre></div><p>As we can clearly see, we're going to use the <code class="literal">User</code> model and on top of it the REST <code class="literal">ActiveController</code>. This controller is where the magic happens, and we're going to illustrate what it is all about in a moment.</p><p>Now, let's implement the actual class:</p><div class="informalexample"><pre class="programlisting">// /modules/v1/controllers/UserController.php

class UserController extends ActiveController
{
    public $modelClass = 'app\models\User';
}</pre></div><p>The only thing needed at this point is just the definition of the model class that the REST controller is going to manage and that's it.</p><p>
<code class="literal">yii\rest\ActiveController</code> is the controller that will deal with Active Records models, such as our <code class="literal">User</code> model. If you were to manage custom classes (non active records) that do not connect to a database or do connect to a custom data source (for instance, an online service), you can use the class that <code class="literal">ActiveController</code> is inheriting from, which is <code class="literal">yii\rest\Controller</code>.</p><p>The beauty of <code class="literal">ActiveController</code> is that it provides already implemented actions<a id="id327" class="indexterm"/> that are available immediately, which are:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">index</code>, which is accessed via <code class="literal">GET</code> or <code class="literal">HEAD</code> and returns the list of the models and their (database-bound) attributes</li><li class="listitem" style="list-style-type: disc"><code class="literal">view</code>, which is accessed via <code class="literal">GET</code> and <code class="literal">HEAD</code> and returns the details of a single model</li><li class="listitem" style="list-style-type: disc"><code class="literal">create</code>, which can be accessed only via <code class="literal">POST</code> and lets you create a new model</li><li class="listitem" style="list-style-type: disc"><code class="literal">update</code>, which is accessed via <code class="literal">PUT</code> or <code class="literal">PATCH</code> and does what it says on the tin</li><li class="listitem" style="list-style-type: disc"><code class="literal">delete</code>, which is used to delete a model and can be invoked using <code class="literal">DELETE</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">OPTIONS</code>, which, lastly, you can invoke to see all the allowed HTTP methods</li></ul></div><p>In the <a id="id328" class="indexterm"/>actions that you'll be able to implement yourself, you will be dealing with the raw models, which are rendered by default in XML and JSON (depending on the <code class="literal">Accept</code> header that was sent along with the request).</p><p>We know we'll need to modify the list of exposed endpoints, and we'll see how to do it in a moment.</p><p>Before getting there, there are a few other bits that need to be addressed first, in particular the access credentials, as we don't want anybody to access our endpoints without being authenticated.</p></div><div class="section" title="Adding the access check and security layer"><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec50"/>Adding the access check and security layer</h2></div></div></div><p>You<a id="id329" class="indexterm"/> might already have asked yourself how to prevent non-authenticated users from using certain endpoints of your application. For instance, we might want to give a client access to the user endpoint only if it's authenticated and authorized.</p><p>The authorization and authentication happen at two different phases.</p><p>Authorization is done at controller level by simply overriding the <code class="literal">checkAccess()</code> method and performing the right checks, which might involve establishing if the user has been authenticated and if he/she is active, in case this flag exists in the user model.</p><p>In our case, we can simply add the following method to our controller:</p><div class="informalexample"><pre class="programlisting">// /modules/v1/controllers/UserController.php

public function checkAccess($action, $model = null, $params = [])
{
    if (\Yii::$app-&gt;user-&gt;isGuest) {
        throw new UnauthorizedHttpException;
    }
}</pre></div><p>This means <a id="id330" class="indexterm"/>that if the user is a guest, we raise a <code class="literal">401</code> response.</p><p>Yii will automatically call the method on each request as we can see in the <code class="literal">actions()</code> method in its parent class, which is <code class="literal">\yii\rest\ActiveController</code>:</p><div class="informalexample"><pre class="programlisting">class ActiveController extends Controller
{
    // ...

    public function actions()
    {
        return [
            'index' =&gt; [
                'class' =&gt; 'yii\rest\IndexAction',
                'modelClass' =&gt; $this-&gt;modelClass,
                'checkAccess' =&gt; [$this, 'checkAccess'],
            ],
            // ...
        ];
    }
    
    // ...
}</pre></div><p>Instead, the authentication is done in a completely different way and varies depending on the implementation and level of security you want to implement in the application.</p><p>As far as it goes, in case you haven't touched the argument in depth, you have different possibilities, which are:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>HTTP Basic Auth</strong></span>: This is<a id="id331" class="indexterm"/> basically the same that you would have by using htpasswd and configuring Apache accordingly and is the simplest one available, but needs the username and password to be sent in a header with every request. This requires the communication to work over HTTPS for obvious reasons.</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Query parameter</strong></span>: Here, the<a id="id332" class="indexterm"/> client is already possessing an access token, which will be sent to the server as a query parameter as <code class="literal">https://server.com/users?access-token=xxxxxxx</code>, which is quite handy if you don't have the ability to send additional tokens with the request. </li></ul></div><p>There are <a id="id333" class="indexterm"/>some other ways that use a combination of different techniques and/or asymmetric and symmetric encryption or different types of handshakes to authenticate a client. One of the most well-known, although potentially complex, is <a id="id334" class="indexterm"/>
<span class="strong"><strong>OAuth 2</strong></span>, which has different implementations as it's considered more of a framework than a well-defined protocol. Most of the well-known social websites such as Google, Twitter, Facebook, and so on implement it. Its <a id="id335" class="indexterm"/>Wikipedia page, available at <a class="ulink" href="http://en.wikipedia.org/wiki/OAuth">http://en.wikipedia.org/wiki/OAuth</a>, provides some good links and references to help you explore it further.</p><p>As encryption and authentication protocols are outside the scope of this book, I've decided to use the simplest solution, which will anyway give us enough hints on where to put our hands, should we want to implement something more robust or complex.</p><div class="section" title="Building the authentication layer"><div class="titlepage"><div><div><h3 class="title"><a id="ch06lvl3sec10"/>Building the authentication layer</h3></div></div></div><p>As Yii uses<a id="id336" class="indexterm"/> sessions by default, which will violate the stateless constraints of a RESTful server according to the fielding dissertation (<a class="ulink" href="http://www.ics.uci.edu/~fielding/pubs/dissertation/rest_arch_style.htm#sec_5_1_3">http://www.ics.uci.edu/~fielding/pubs/dissertation/rest_arch_style.htm#sec_5_1_3</a>), we will want to disable the session in the module's <code class="literal">init()</code> method:</p><div class="informalexample"><pre class="programlisting">// /modules/v1/Module.php

public function init()
{
    parent::init();
    // custom initialization code goes here
    // disable the user session
    \Yii::$app-&gt;user-&gt;enableSession = false;
}</pre></div><p>In Yii the actual authentication is then done via the available authenticator behavior.</p><p>Yii provides four different authenticators which are:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">HttpBasicAuth</code>: This <a id="id337" class="indexterm"/>is used for HTTP Basic Auth, which we will use here</li><li class="listitem" style="list-style-type: disc"><code class="literal">QueryParamAuth</code>: This <a id="id338" class="indexterm"/>is used for query parameter authentication</li><li class="listitem" style="list-style-type: disc"><code class="literal">HttpBearerAuth</code>: This<a id="id339" class="indexterm"/> is used for OAuth and similar methods</li><li class="listitem" style="list-style-type: disc"><code class="literal">CompositeAuth</code>: This <a id="id340" class="indexterm"/>is a way to use multiple cascading authentication methods</li></ul></div><p>Again open<a id="id341" class="indexterm"/> our <code class="literal">UserController</code> and let's define the one we want to use:</p><div class="informalexample"><pre class="programlisting">// /modules/v1/controllers/UserController.php

public function behaviors()
{
    $behaviors = parent::behaviors();

    $behaviors['authenticator'] = [
        'class' =&gt; HttpBasicAuth::className(),
    ];

    return $behaviors;
}</pre></div><p>If you were to run the tests against this implementation, you will have problems making them pass; the default implementation will use <code class="literal">findIdentityByAccessToken()</code> and use the <code class="literal">$username</code> part of the header as an access token. So, there's no real password check.</p><p>HTTP Basic Auth defines that, together with your request, you will also have to send an <code class="literal">Authorization</code> header containing <code class="literal">'Basic '.base64($username.':'.$password);</code>. </p><p>As explained in the documentation of the<a id="id342" class="indexterm"/> <code class="literal">HttpBasicAuth</code> class at <a class="ulink" href="https://github.com/yiisoft/yii2/blob/master/framework/filters/auth/HttpBasicAuth.php#L55">https://github.com/yiisoft/yii2/blob/master/framework/filters/auth/HttpBasicAuth.php#L55</a>, you need to override the <code class="literal">$auth</code> attribute in order to perform the password authentication in the way that you want.</p><p>As you saw, <code class="literal">findIdentityByAccessToken()</code> is not a method we're going to need, and we have the unit tests that clearly state that. The best way to address this is by adding our authenticator method straight in the definition of the behavior in the following way:</p><div class="informalexample"><pre class="programlisting">// modules/v1/controllers/UserController.php    

public function behaviors()
{
    $behaviors = parent::behaviors();

    $behaviors['authenticator'] = [
        'class' =&gt; HttpBasicAuth::className(),
        'auth' =&gt; function ($username, $password) {
                /** @var User $user */
                $user = User::findByUsername($username);
                if ($user &amp;&amp; $user-&gt;validatePassword($password)) {
                    return $user;
                }
            }
    ];

    return $behaviors;
}</pre></div><p>As explained in<a id="id343" class="indexterm"/> the documentation, the <code class="literal">auth</code> attribute should be a function that expects <code class="literal">$username</code> and <code class="literal">$password</code> as actual parameters, and returns the user identity if the authentication is verified.</p><p>With this last method, implementation of our authentication and authorization scheme should be complete.</p></div></div><div class="section" title="Modifying the existing actions"><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec51"/>Modifying the existing actions</h2></div></div></div><p>Now that we've<a id="id344" class="indexterm"/> restricted access to any other user, we need to re-implement the view and update actions, in order to allow only the currently logged in user to view just his/her details and allow him to update only the password. If you have already started implementing the actions, this won't be enough as the parent class, <code class="literal">yii\rest\Controller</code>, already implements all the default actions, so we need to redefine their configuration, which happens to be set within the <code class="literal">actions()</code> method:</p><div class="informalexample"><pre class="programlisting">public function actions()
{
    $actions = parent::actions();
    unset($actions['view'], $actions['update']);
    return $actions;
}</pre></div><p>Once we unset the two actions, our own overridden methods will be picked up automatically without much else to do:</p><div class="informalexample"><pre class="programlisting">public function actionView($id)
{
    if ($id == Yii::$app-&gt;user-&gt;getId()) {
        return User::findOne($id);
    }
    throw new ForbiddenHttpException;
}</pre></div><p>The view <a id="id345" class="indexterm"/>action just adds a check on the ID of the user and returns a 403 error, while the update action can be something along the lines of the following code:</p><div class="informalexample"><pre class="programlisting">public function actionUpdate($id)
{
    if (! Yii::$app-&gt;request-&gt;isPut) {
        return new HttpRequestMethodException();
    }

    /** @var User $user */
    $user = User::findIdentity($id);

    if (Yii::$app-&gt;request-&gt;post('password') !== null) {
        $user-&gt;setPassword(Yii::$app-&gt;request-&gt;post('password'));
    }

    return $user-&gt;save();
}</pre></div><p>In the update, we only allow changing of the password, after which we return the value of the <code class="literal">save</code> method. We could have returned a more comprehensive status, but for our cause, this is good enough.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note28"/>Note</h3><p>We won't actually need to add the check if the request is not a PUT, as the current internal implementation restricts it by default. We'll see in <a class="link" href="ch08.html" title="Chapter 8. Analyzing Testing Information">Chapter 8</a>, <span class="emphasis"><em>Analyzing Testing Information</em></span>, how this will be fixed, using the coverage report information.</p></div></div></div><div class="section" title="Adding a new endpoint with parameters"><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec52"/>Adding a new endpoint with parameters</h2></div></div></div><p>With all <a id="id346" class="indexterm"/>we have done, if we try to run the tests on <code class="literal">UserAPICept</code>, we will see that it will fail immediately at the first <code class="literal">sendGET('user/search')command</code>.</p><p>Implementing the new <code class="literal">actionSearch()</code> method won't be a problem, and it can be implemented in the following way:</p><div class="informalexample"><pre class="programlisting">public function actionSearch($username)
{
    /** @var User $user */
    $user = User::findByUsername($username);
    if ($user &amp;&amp; $user-&gt;id === Yii::$app-&gt;user-&gt;getId()) {
        return $user;
    }
    throw new ForbiddenHttpException;
}</pre></div><p>What is important to note is how we will customize the routes to add this new action in a "compliant" way.</p><p>Switch to the configuration file located at <code class="literal">config/web.php</code> and let's start by adding the search action to the list of allowed methods:</p><div class="informalexample"><pre class="programlisting">'only' =&gt; ['view', 'update', 'search', 'options']</pre></div><p>The <code class="literal">UrlRule</code> class that is used to create routes exposes some variables that you can configure, either to extend or entirely re-define the patterns and the structure of the tokens. The first are <code class="literal">extraPatterns</code> and <code class="literal">patterns</code> respectively. Tokens can be used in the patterns and represent the parameters passed to the action.</p><p>In Yii terminology, a pattern is a tuple composed of allowed HTTP method(s), the actual structure of the resource to identify, and the corresponding action to be called. The following is an example of this:</p><div class="informalexample"><pre class="programlisting">'GET search/{username}' =&gt; 'search'</pre></div><p>A token is one or more parameters that can be as complex as a regular expression. In the preceding example, <code class="literal">{username}</code> is a token and can be defined as shown in the following code:</p><div class="informalexample"><pre class="programlisting">'{username}' =&gt; '&lt;username:\\w+&gt;'</pre></div><p>Our final list of rules will end up looking like the following code:</p><div class="informalexample"><pre class="programlisting">// config/web.php

'rules' =&gt; [
    [
        'class' =&gt; 'yii\rest\UrlRule',
        'controller' =&gt; 'v1/user',
        'tokens' =&gt; [
            '{id}' =&gt; '&lt;id:\\d[\\d,]*&gt;',
            '{username}' =&gt; '&lt;username:\\w+&gt;'
        ],
        'extraPatterns' =&gt; [
            'GET search/{username}' =&gt; 'search',
        ],
        'only' =&gt; ['view', 'update', 'search', 'options']
    ],
    '/' =&gt; 'site/index',
    '&lt;action:\w+&gt;' =&gt; 'site/&lt;action&gt;',
    '&lt;controller:\w+&gt;/&lt;id:\d+&gt;' =&gt; '&lt;controller&gt;/view',
    '&lt;controller:\w+&gt;/&lt;action:\w+&gt;/&lt;id:\d+&gt;' =&gt; '&lt;controller&gt;/&lt;action&gt;',
    '&lt;controller:\w+&gt;/&lt;action:\w+&gt;' =&gt; '&lt;controller&gt;/&lt;action&gt;',
]</pre></div><p>The first thing<a id="id347" class="indexterm"/> to note is that we had to re-define all the tokens rather than adding them as we are doing with <code class="literal">extraPatterns</code>.</p><p>In the list of rules, we have defined the REST interface rules before any other as rules are read top to bottom, and the first one that is found matching will be captured. This means that specific rules must stay at the top, while generic catch-all rules are at the bottom.</p><p>The preceding configuration will be fed to <code class="literal">urlManager</code>, as explained in the official guide at <a class="ulink" href="http://www.yiiframework.com/doc-2.0/guide-runtime-routing.html#using-pretty-urls">http://www.yiiframework.com/doc-2.0/guide-runtime-routing.html#using-pretty-urls</a>:</p><div class="informalexample"><pre class="programlisting">'urlManager' =&gt; [
    'enablePrettyUrl' =&gt; true,
    'showScriptName' =&gt; false,
    'enableStrictParsing' =&gt; true,
    'rules' =&gt; [ ... ]
]</pre></div><p>Now we can check <a id="id348" class="indexterm"/>that the tests are passing using the following command:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>../vendor/bin/codecept run functional UserAPICept.php</strong></span>
<span class="strong"><strong>Codeception PHP Testing Framework v2.0.8</strong></span>
<span class="strong"><strong>Powered by PHPUnit 4.5-ge3692ba by Sebastian Bergmann and contributors.</strong></span>

<span class="strong"><strong>Functional Tests (1) ------------------------------------------------</strong></span>
<span class="strong"><strong>Trying to test the user REST API (UserAPICept)                     Ok</strong></span>
<span class="strong"><strong>---------------------------------------------------------------------</strong></span>


<span class="strong"><strong>Time: 9.8 seconds, Memory: 14.50Mb</strong></span>

<span class="strong"><strong>OK (1 test, 18 assertions)</strong></span>
</pre></div></div></div>
<div class="section" title="Summary"><div class="titlepage"><div><div><h1 class="title"><a id="ch06lvl1sec39"/>Summary</h1></div></div></div><p>In this chapter, you saw many things such as how to write basic functional tests, how to test a REST interface, and the implementation side of things. Given the amount of knowledge condensed here, it might be useful for you to revisit the chapter later on and give yourself enough time to experiment on the single features in more detail and adapt them to your likings.</p><p>In the next chapter, you're going to see how to create acceptance tests for your interfaces that will overcome some of the limitations of working with PHPBrowser.</p></div></body></html>