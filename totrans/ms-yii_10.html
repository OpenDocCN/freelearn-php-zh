<html><head></head><body>
<div id="page" style="height:0pt"/><div class="book" title="Chapter&#xA0;10.&#xA0;Testing with Codeception" id="1P71O1-ad3e09b384df46aea690d9c8897d5fe7"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch10" class="calibre1"/>Chapter 10. Testing with Codeception</h1></div></div></div><p class="calibre9">An important but often overlooked aspect of software development is testing our application to ensure that it performs as expected. There are three basic ways in which we can test our applications:</p><div class="book"><ul class="itemizedlist"><li class="listitem">Unit testing</li><li class="listitem">Functional testing</li><li class="listitem">Acceptance testing</li></ul></div><p class="calibre9">
<span class="strong"><strong class="calibre2">Unit testing</strong></span> enables <a id="id512" class="calibre1"/>us to test individual sections of code before <a id="id513" class="calibre1"/>coupling it with our application. <span class="strong"><strong class="calibre2">Functional testing</strong></span> allows<a id="id514" class="calibre1"/> us to test the functional aspects of code within a simulated browser, and <span class="strong"><strong class="calibre2">acceptance testing</strong></span> allows us to test our application within a real browser and verify that it does what we built it to do. With Yii2, we can use a tool called Codeception to create and execute unit, functional, and acceptance testing for our application. In this chapter, we'll cover how to create and run unit, functional, and acceptance testing in Yii2. In addition to these three types of testing, we can mock our data using fixtures, which we can use to bring our application to a fixed state before testing.</p><div class="note" title="Note"><h3 class="title2"><a id="tip160" class="calibre1"/>Tip</h3><p class="calibre9">As we work through this chapter, we'll be using much of the code from previous chapters. For <a id="id515" class="calibre1"/>your convenience, the source code for this chapter is provided on GitHub at <a class="calibre1" href="https://github.com/masteringyii/chapter10">https://github.com/masteringyii/chapter10</a> and is broken into three distinct branches. We'll use the <code class="email">unit</code> branch in the unit testing section, the <code class="email">functional_and_acceptance</code> branch in the functional and acceptance testing section, and the <code class="email">fixture</code> branch in the fixtures section.</p></div></div>

<div class="book" title="Chapter&#xA0;10.&#xA0;Testing with Codeception" id="1P71O1-ad3e09b384df46aea690d9c8897d5fe7">
<div class="book" title="Reasons for testing"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_1"><a id="ch10lvl1sec54" class="calibre1"/>Reasons for testing</h1></div></div></div><p class="calibre9">Most <a id="id516" class="calibre1"/>software developers will admit that testing is a good thing, but many developers don't write tests for their application for a variety of reasons, such as the following:</p><div class="book"><ul class="itemizedlist"><li class="listitem">The fear of testing</li><li class="listitem">Not knowing how to write tests</li><li class="listitem">Thinking that their application is too small for testing</li><li class="listitem">Not having enough time</li><li class="listitem">Budgetary reasons</li></ul></div><p class="calibre9">While many of these reasons are valid, testing can have a profound effect on your application and can drastically improve the quality of your code. The following list provides several reasons why tests should be added to your codebase:</p><div class="book"><ul class="itemizedlist"><li class="listitem">Testing can reduce bugs as new features are added</li><li class="listitem">Testing verifies that your code does what you think it does</li><li class="listitem">Testing verifies that your code does what your client wants</li><li class="listitem">Features can be constrained by testing</li><li class="listitem">Testing forces us to slow down and break our applications into small, manageable components with constraining features</li><li class="listitem">Testing reduces the cost of change by ensuring that a change to a single feature doesn't break another feature</li><li class="listitem">Testing provides documentation of what our code is supposed to do</li><li class="listitem">Testing reduces the fear that a change will break something in our application</li></ul></div></div></div>

<div class="book" title="Chapter&#xA0;10.&#xA0;Testing with Codeception" id="1P71O1-ad3e09b384df46aea690d9c8897d5fe7">
<div class="book" title="Reasons for testing">
<div class="book" title="How to approach testing"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_2"><a id="ch10lvl2sec116" class="calibre1"/>How to approach testing</h2></div></div></div><p class="calibre9">There <a id="id517" class="calibre1"/>are many factors that go into modern development, costs and development time being the chief among them. There are several realistic approaches that we can take for testing in order to work around these constraints.</p><div class="book" title="Testing manually"><div class="book"><div class="book"><div class="book"><h3 class="title2"><a id="ch10lvl3sec48" class="calibre1"/>Testing manually</h3></div></div></div><p class="calibre9">The most<a id="id518" class="calibre1"/> rudimentary approach to testing we can take is to test manually as we're writing code. Whether you realize it or not, every time you make a code change and reload your browser, you're testing your code. At a cursory glance, manual testing lets us verify new features and bug fixes that are working, but it requires us to manually verify the state of our applications after every change. Furthermore, manual testing requires us to remember every test case we've created. Automated testing with a tool such as Codeception can reduce this cognitive burden and free up our time to perform<a id="id519" class="calibre1"/> other tasks.</p></div></div></div></div>

<div class="book" title="Chapter&#xA0;10.&#xA0;Testing with Codeception" id="1P71O1-ad3e09b384df46aea690d9c8897d5fe7">
<div class="book" title="Reasons for testing">
<div class="book" title="Testing a few core components"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_3"><a id="ch10lvl2sec117" class="calibre1"/>Testing a few core components</h2></div></div></div><p class="calibre9">A better<a id="id520" class="calibre1"/> approach to testing is to automate the testing of just the core components of our applications. With this approach, we add tests for only the critical paths in our application, which enables us to verify the important bits of our application at the cost of reduced tests elsewhere. In situations where time and budget are constrained but you want to automate the verification of important flows and paths, this approach is a realistic alternative to no testing whatsoever.</p><div class="book" title="Test-driven development"><div class="book"><div class="book"><div class="book"><h3 class="title2"><a id="ch10lvl3sec49" class="calibre1"/>Test-driven development</h3></div></div></div><p class="calibre9">
<span class="strong"><strong class="calibre2">Test-driven development</strong></span> (<span class="strong"><strong class="calibre2">TDD</strong></span>) is the philosophy that we should create tests for our application <a id="id521" class="calibre1"/>as we're building it. The primary idea behind TDD is that we can verify that our code is working by writing a test for it beforehand. With TDD, we generally write a test beforehand (which will fail), then we write code in order to make it pass the test, and then we continuously iterate between tests and code until our feature is completed and our test passes. TDD also forces us to ensure that we write usable code by passing tests before checking it into our versioning system, which then encourages us to write good tests.</p><p class="calibre9">With TDD, our goal is to have a test for every feature and component and have many tests that thoroughly cover our application. In an ideal world, TDD is the best approach to take when working with testing at the cost of requiring more time and budget to implement.</p></div></div></div></div>
<div class="book" title="Configuring Codeception with Yii2" id="1Q5IA1-ad3e09b384df46aea690d9c8897d5fe7"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch10lvl1sec55" class="calibre1"/>Configuring Codeception with Yii2</h1></div></div></div><p class="calibre9">Before <a id="id522" class="calibre1"/>we can use Codeception to test our code, we first <a id="id523" class="calibre1"/>need to configure Codeception to work with Yii2:</p><div class="book"><ol class="orderedlist"><li class="listitem" value="1">The preferred way to set up Codeception with Yii2 is to install both the <code class="email">yii2-codeception</code> package and the Codeception base package via Composer:<div class="note"><pre class="programlisting"><span class="strong"><strong class="calibre2">$ composer require --dev codeception/codeception</strong></span>
<span class="strong"><strong class="calibre2">$ composer require --dev yiisoft/yii2-codeception</strong></span>
<span class="strong"><strong class="calibre2">$ composer require --dev yiisoft/yii2-faker</strong></span>
</pre></div><div class="note1" title="Note"><h3 class="title2"><a id="tip161" class="calibre1"/>Tip</h3><p class="calibre9">The <code class="email">--dev</code> flag on our composer command ensures that development packages are not installed in our production environment. Packages installed with<code class="email"> –dev</code> will be added to the <code class="email">require-dev </code>section of our <code class="email">composer.json</code> file. Storing Codeception and other testing code reduces the dependencies we need in production and makes our code more secure.</p></div><p class="calibre14">The first package contains the Codeception binary that we'll use to generate and execute our tests, while the second package contains Yii2-specific helpers and bindings that Codeception will use to tightly integrate into Yii2.</p><div class="note1" title="Note"><h3 class="title2"><a id="note21" class="calibre1"/>Note</h3><p class="calibre9">This process may take a long time as Codeception is dependent upon many different packages, including PHPUnit.</p></div></li><li class="listitem" value="2">After <a id="id524" class="calibre1"/>installing Codeception, we can execute <a id="id525" class="calibre1"/>the command by running the following command:<div class="note"><pre class="programlisting"><span class="strong"><strong class="calibre2">$ ./vendor/bin/codecept</strong></span>
</pre></div><p class="calibre14">By itself, <code class="email">codecept</code> will output all the available commands that Codeception has to offer.</p><div class="mediaobject"><img src="../images/00040.jpeg" alt="Configuring Codeception with Yii2" class="calibre10"/></div><p class="calibre25"> </p></li><li class="listitem" value="3">After <a id="id526" class="calibre1"/>verifying that Codeception is <a id="id527" class="calibre1"/>installed, we need to bootstrap Codeception by running the following command:<div class="note"><pre class="programlisting"><span class="strong"><strong class="calibre2">$ ./vendor/bin/codecept bootstrap</strong></span>
</pre></div><div class="mediaobject"><img src="../images/00041.jpeg" alt="Configuring Codeception with Yii2" class="calibre10"/></div><p class="calibre25"> </p></li><li class="listitem" value="4">The <a id="id528" class="calibre1"/>bootstrap process will create<a id="id529" class="calibre1"/> several files. The first file is called <code class="email">codeception.yml</code> and lives within the root of our application. The remaining files exist within the <code class="email">tests</code> folder and will be the directory to which we add our <code class="email">tests</code>.</li><li class="listitem" value="5">Next, we need to configure Codeception to work with the Yii2 Codeception module in our <code class="email">codeception.yml</code> file. The required additions are highlighted in the following code block:<div class="note"><pre class="programlisting">actor: Tester
paths:
    tests: tests
    log: tests/_output
    data: tests/_data
    support: tests/_support
    envs: tests/_envs
settings:
    bootstrap: _bootstrap.php
    colors: true
    memory_limit: 1024M
extensions:
    enabled:
        - Codeception\Extension\RunFailed</pre></div></li><li class="listitem" value="6">Additionally, we need to tell Codeception to autoload our composer dependencies and Yii2. We can do this by updating the <code class="email">tests/_bootstrap.php</code> file. To ensure that we test our application in a manner <a id="id530" class="calibre1"/>similar to our <code class="email">web/index.php</code> loads data, we should add the following:<div class="note"><pre class="programlisting">&lt;?php

// Define our application_env variable as provided by nginx/apache
if (!defined('APPLICATION_ENV'))
{
    if (getenv('APPLICATION_ENV') != false)
        define('APPLICATION_ENV', getenv('APPLICATION_ENV'));
    else 
       define('APPLICATION_ENV', 'prod');
}

$env = require(__DIR__ . '/../config/env.php');

// comment out the following two lines when deployed to production
defined('YII_DEBUG') or define('YII_DEBUG', $env['debug']);
defined('YII_ENV') or define('YII_ENV', APPLICATION_ENV);

require(__DIR__ . '/../vendor/autoload.php');
require(__DIR__ . '/../vendor/yiisoft/yii2/Yii.php');
$config = require(__DIR__ . '/../config/web.php');

(new yii\web\Application($config));</pre></div></li><li class="listitem" value="7">With<a id="id531" class="calibre1"/> Codeception now configured, we can run all of our tests by running the following command:<div class="note"><pre class="programlisting"><span class="strong"><strong class="calibre2">$ ./vendor/bin/codecept run</strong></span>
</pre></div><p class="calibre14">The run command will output the following:</p><div class="mediaobject"><img src="../images/00042.jpeg" alt="Configuring Codeception with Yii2" class="calibre10"/></div><p class="calibre25"> </p></li></ol><div class="calibre15"/></div></div>

<div id="page" style="height:0pt"/><div class="book" title="Unit testing"><div class="book" id="1R42S2-ad3e09b384df46aea690d9c8897d5fe7"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch10lvl1sec56" class="calibre1"/>Unit testing</h1></div></div></div><p class="calibre9">The most <a id="id532" class="calibre1"/>basic type of tests we can create are called unit tests. As the name suggests, <span class="strong"><strong class="calibre2">unit tests</strong></span> are designed to test a unit of work (whether that be a single method, function, or a larger work unit), and then check a single assumption about that unit of work. A good unit test will be composed of the following components:</p><div class="book"><ul class="itemizedlist"><li class="listitem"><span class="strong"><strong class="calibre2">Fully automated</strong></span>: A good unit test is a test that can be fully automated without <a id="id533" class="calibre1"/>human intervention.</li><li class="listitem"><span class="strong"><strong class="calibre2">Thorough</strong></span>: Thorough<a id="id534" class="calibre1"/> unit tests provide good coverage of the code block they are testing.</li><li class="listitem"><span class="strong"><strong class="calibre2">Independent</strong></span>: Good <a id="id535" class="calibre1"/>unit tests can be run in any order, and their output should have no effect or side effect on other tests that occur. Furthermore, each unit test should only test a single logical unit of code. Tests that fail should pinpoint the exact section of code that failed.</li><li class="listitem"><span class="strong"><strong class="calibre2">Consistent and repeatable</strong></span>: Unit<a id="id536" class="calibre1"/> tests should always produce the same result and should be dependent upon static data as opposed to generated or random data.</li><li class="listitem"><span class="strong"><strong class="calibre2">Fast</strong></span>: Unit tests need to execute quickly. Long tests mean that fewer tests will be run in a given amount of time, and tests that take too long to execute will encourage developers to either write fewer tests or skip writing tests altogether. As<a id="id537" class="calibre1"/> unit tests are intended to test small individual<a id="id538" class="calibre1"/> units of code, long-running tests can also be an indicator of a bad or incomplete test.</li><li class="listitem"><span class="strong"><strong class="calibre2">Readable</strong></span>: Good <a id="id539" class="calibre1"/>unit tests should be readable and should be either self-explanatory or thoroughly documented if they require additional explanation.</li><li class="listitem"><span class="strong"><strong class="calibre2">Maintainable</strong></span>: Finally, good unit tests should be maintainable. A test we don't<a id="id540" class="calibre1"/> maintain is a test that we don't use or work with.</li></ul></div><div class="note" title="Note"><h3 class="title2"><a id="tip162" class="calibre1"/>Tip</h3><p class="calibre9">In <a id="id541" class="calibre1"/>this section, we'll be using the source code in the <code class="email">unit</code> branch located at <a class="calibre1" href="https://github.com/masteringyii/chapter10">https://github.com/masteringyii/chapter10</a>.</p></div></div>

<div class="book" title="Unit testing">
<div class="book" title="Generating unit tests"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_1"><a id="ch10lvl2sec118" class="calibre1"/>Generating unit tests</h2></div></div></div><p class="calibre9">If you're <a id="id542" class="calibre1"/>familiar with PHPUnit, writing tests in Codeception should feel very familiar. For unit testing, Codeception can generate a PHPUnit-like test, but it can also generate a Codeception-specific unit test that doesn't require PHPUnit to execute.</p><p class="calibre9">To generate PHPUnit-specific tests, we can run the following command, which will generate a PHPUnit unit test called <code class="email">Example</code>:</p><div class="note"><pre class="programlisting"><span class="strong"><strong class="calibre2">$ ./vendor/bin/codecept generate:phpunit unit Example</strong></span>
</pre></div><p class="calibre9">Alternatively, we can generate a Codeception-specific test called <code class="email">Example</code> by running the following command:</p><div class="note"><pre class="programlisting"><span class="strong"><strong class="calibre2">$ ./vendor/bin/codecept generate:test unit Example</strong></span>
</pre></div><div class="note" title="Note"><h3 class="title2"><a id="tip163" class="calibre1"/>Tip</h3><p class="calibre9">Unless you have a specific need for PHPUnit-like tests, Codeception unit tests should be preferred.</p></div><p class="calibre9">After generating our Codeception test, a file called <code class="email">tests/unit/ExampleTest.php</code> will be generated, and it will contain the following code. Before we start writing unit tests for our application, let's explore the basic structure of a Codeception unit test class:</p><div class="note"><pre class="programlisting">&lt;?php


class ExampleTest extends \Codeception\TestCase\Test
{
    /**
     * @var \UnitTester
     */
    protected $tester;

    protected function _before()
    {
    }

    protected function _after()
    {
    }

    // tests
    public function testMe()
    {

    }
}</pre></div><p class="calibre9">By default, our<a id="id543" class="calibre1"/> Codeception unit tests will extend <code class="email">\Codeception\TestCase\Test</code>, and will implement two protected methods (<code class="email">_before()</code> and <code class="email">_after()</code>) and a protected property called <code class="email">$tester</code> for Codeception to use internally. The <code class="email">_before()</code> and <code class="email">_after()</code> methods are intended to set up and tear down tasks that execute immediately before and after each of our predefined tests within our class.</p><p class="calibre9">After the <code class="email">_before()</code> and <code class="email">_after()</code> methods, we have all of the tests that we want to run. In general, any test that we want to run should be in a public method with a method name prefix of <code class="email">test</code>. Any public method with this signature will be executed as a test. As a brief example, let's modify our <code class="email">testMe()</code> method to make a simple assertion (a statement of whether a given predicate (a function, method, or variable) evaluates to a boolean value which we can verify is true):</p><div class="note"><pre class="programlisting">public function testMe()
{
    // Assert that the boolean value "true" is indeed true
    $this-&gt;assertTrue(true);
}</pre></div><p class="calibre9">Using this simple assertion as an example, we can verify our tests run by running this:</p><div class="note"><pre class="programlisting"><span class="strong"><strong class="calibre2">$ ./vendor/bin/codecept run</strong></span>
</pre></div><p class="calibre9">Alternatively, we<a id="id544" class="calibre1"/> can just run our unit tests by running the following command:</p><div class="note"><pre class="programlisting"><span class="strong"><strong class="calibre2">$ ./vendor/bin/codecept run unit</strong></span>
</pre></div><div class="mediaobject"><img src="../images/00043.jpeg" alt="Generating unit tests" class="calibre10"/></div><p class="calibre11"> </p><p class="calibre9">As you can see from the previous screenshot, our unit test case executed successfully. We can add extra unit tests by defining additional test methods, as shown in the following example:</p><div class="note"><pre class="programlisting">public function testMeToo()
{
    $this-&gt;assertFalse(false);
}</pre></div><p class="calibre9">Running a second test will then show up in our Codeception output.</p><div class="mediaobject"><img src="../images/00044.jpeg" alt="Generating unit tests" class="calibre10"/></div><p class="calibre11"> </p></div></div>

<div class="book" title="Unit testing">
<div class="book" title="Unit test examples"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_2"><a id="ch10lvl2sec119" class="calibre1"/>Unit test examples</h2></div></div></div><p class="calibre9">Now that<a id="id545" class="calibre1"/> we know the basics of unit testing with Codeception, let's explore a couple of examples we can test within applications we've built previously. Starting with the source code we developed in <a class="calibre1" title="Chapter 9. RESTful APIs" href="part0052_split_000.html#1HIT82-ad3e09b384df46aea690d9c8897d5fe7">Chapter 9</a>, <span class="strong"><em class="calibre13">RESTful APIs</em></span>, let's write a few unit tests for our models.</p><div class="book" title="Testing User model methods"><div class="book"><div class="book"><div class="book"><h3 class="title2"><a id="ch10lvl3sec50" class="calibre1"/>Testing User model methods</h3></div></div></div><div class="book"><ol class="orderedlist"><li class="listitem" value="1">Our <a id="id546" class="calibre1"/>User model is a significant part of our application. Since we've added both custom code and custom validators, we can write unit tests to verify that our validators are accurate and that our custom code works as expected. To get started, let's create a new unit test for our User model:<div class="note"><pre class="programlisting"><span class="strong"><strong class="calibre2">$ ./vendor/bin/codecept generate:test unit User</strong></span>
</pre></div></li><li class="listitem" value="2">Since we're testing our User model, we need to explicitly specify that we want to use that model within our test:<div class="note"><pre class="programlisting">&lt;?php

<span class="strong"><strong class="calibre2">namespace app\tests\unit\UserTest;</strong></span>

<span class="strong"><strong class="calibre2">use Codeception\TestCase\Test;</strong></span>
<span class="strong"><strong class="calibre2">use app\models\User;</strong></span>
<span class="strong"><strong class="calibre2">use Yii;</strong></span>

class UserTest extends Test {}</pre></div></li><li class="listitem" value="3">Next, let's define a method to test that our <code class="email">app\models\User::setFullName()</code> method works:<div class="note"><pre class="programlisting">public function testSetFullName()
{   
    $user = new User;
    $user-&gt;setFullName('John Doe');

    // Asser the setFullName method works
    $this-&gt;assertTrue($user-&gt;first_name == "John");
    $this-&gt;assertTrue($user-&gt;last_name == "Doe");
    $this-&gt;assertFalse($user-&gt;first_name == "Jane");
    unset($user);

    $user = new User;
    $user-&gt;fullName = 'John Doe';
    
    // Asser the full_name setter method works
    $this-&gt;assertTrue($user-&gt;first_name == "John");
    $this-&gt;assertTrue($user-&gt;last_name == "Doe");
    $this-&gt;assertFalse($user-&gt;first_name == "Jane");

    unset($user);
}</pre></div></li><li class="listitem" value="4">After<a id="id547" class="calibre1"/> executing our tests, we can verify our newly passed test case by viewing the output.<div class="mediaobject"><img src="../images/00045.jpeg" alt="Testing User model methods" class="calibre10"/></div><p class="calibre25"> </p><div class="note1" title="Note"><h3 class="title2"><a id="tip164" class="calibre1"/>Tip</h3><p class="calibre9">The test cases illustrated here are very rudimentary. Try expanding upon this test case to ensure complete code coverage of this method.</p></div></li></ol><div class="calibre15"/></div><p class="calibre9">Let's write<a id="id548" class="calibre1"/> another test to the <code class="email">app\models\User::validatePassword()</code> method that correctly validates the password of an existing user:</p><div class="book"><ol class="orderedlist"><li class="listitem" value="1">For this test case, we'll be relying upon the data supplied by our migrations. Before creating the test, ensure that you migrate the database:<div class="note"><pre class="programlisting"><span class="strong"><strong class="calibre2">$ ./yii migrate/up --interactive=0</strong></span>
</pre></div></li><li class="listitem" value="2">Next, we'll add a test case that will load our four default users and verify that their passwords match, as we expect:<div class="note"><pre class="programlisting">public function testValidatePassword()
{   
    $user = User::find()-&gt;where(['id' =&gt; 1])-&gt;one();
    $this-&gt;assertTrue($user-&gt;validatePassword('password1'));
    $this-&gt;assertFalse($user-&gt;validatePassword('password2'));
    
    $user = User::find()-&gt;where(['id' =&gt; 2])-&gt;one();
    $this-&gt;assertTrue($user-&gt;validatePassword('password2'));
    $this-&gt;assertFalse($user-&gt;validatePassword('password1'));

    $user = User::find()-&gt;where(['id' =&gt; 3])-&gt;one();
    $this-&gt;assertTrue($user-&gt;validatePassword('password3'));
    $this-&gt;assertFalse($user-&gt;validatePassword('password4'));
        
    $user = User::find()-&gt;where(['id' =&gt; 4])-&gt;one();
    $this-&gt;assertTrue($user-&gt;validatePassword('admin'));
    $this-&gt;assertFalse($user-&gt;validatePassword('notadmin'));
}</pre></div><div class="note1" title="Note"><h3 class="title2"><a id="tip165" class="calibre1"/>Tip</h3><p class="calibre9">In this case, information about our users is being loaded from our migrations, which in some cases makes sense if we want to provide our end users with sensible defaults. Later on in this chapter, we'll explore how we can use fixtures to create and populate defaults for testing, which will eliminate the need to have these defaults as part of our migration file.</p></div></li><li class="listitem" value="3">After<a id="id549" class="calibre1"/> running our unit tests, we should see the following output:<div class="mediaobject"><img src="../images/00046.jpeg" alt="Testing User model methods" class="calibre10"/></div><p class="calibre25"> </p></li></ol><div class="calibre15"/></div><div class="note" title="Note"><h3 class="title2"><a id="tip166" class="calibre1"/>Tip</h3><p class="calibre9">Note how in the previous test case, we tested both the expected result and the several results that we were expecting to fail. An important part of unit testing is verifying that both the expected passing cases pass and invalid or wrong input is not accepted. This ensures that our application does what we want, while not allowing rogue or bad inputs to be accepted.</p></div><p class="calibre9">Have you gotten the hang of unit testing yet? Before moving on to functional testing, let's write a test case to verify that our validators are working:</p><div class="book"><ol class="orderedlist"><li class="listitem" value="1">Since the validator for our <code class="email">User</code> model validates several different attributes, we're going check whether our <code class="email">app\models\User::validate()</code> method returns the expected <code class="email">true</code> or <code class="email">false</code> result and whether the appropriate validator is called.</li><li class="listitem" value="2">To make<a id="id550" class="calibre1"/> our test output more readable, we can include the <code class="email">codeception/specify</code> composer module in our project, which will allow us to specify what the expected result for each test section in the output of our tests is in the event that a test fails. This package can be installed by running the following command:<div class="note"><pre class="programlisting"><span class="strong"><strong class="calibre2">$ composer require codeception/specify</strong></span>
</pre></div><p class="calibre14">To use <code class="email">specify</code>, we need to use it inside our <code class="email">UserTest</code> class, as shown in the following example:</p><div class="note"><pre class="programlisting">&lt;?php

namespace app\tests\unit\UserTest;

use Codeception\TestCase\Test;

use app\models\User;
use yii\codeception\TestCase;
use Yii;

class UserTest extends Test
{
    <span class="strong"><strong class="calibre2">use \Codeception\Specify;</strong></span>
}</pre></div></li><li class="listitem" value="3"><code class="email">specify</code> can then be used as follows:<div class="note"><pre class="programlisting">public function testValidate()
{
    $this-&gt;specify('false is false', function() {
        $this-&gt;assertFalse(false);
    });
}</pre></div><p class="calibre14">Now if we run our test case, we should see the following output indicate specifically that our "false is false" test case has failed:</p><div class="note"><pre class="programlisting"><span class="strong"><strong class="calibre2">Test validate (app\tests\unit\UserTest\UserTest::/</strong></span>
<span class="strong"><strong class="calibre2">testValidate)            Ok</strong></span>
</pre></div></li><li class="listitem" value="4">Now<a id="id551" class="calibre1"/> that we know how to use the specify module, let's write several test cases for our validator:<div class="note"><pre class="programlisting">public function testValidate()
{
    $this-&gt;specify('email and password are required', function() {
        $user = new User;
        // Verify our validation fails as we didn't provide any attributes
        $this-&gt;assertFalse($user-&gt;validate());

        // Verify that the email and password properties are required
        $this-&gt;assertTrue($user-&gt;hasErrors('email'));
        $this-&gt;assertTrue($user-&gt;hasErrors('password'));
        $user-&gt;email = 'user@example.com';
        $user-&gt;password =  password_hash('example', PASSWORD_BCRYPT, ['cost' =&gt; 13]);
        $this-&gt;assertTrue($user-&gt;validate());
    });

    $this-&gt;specify('email is unique', function() {
        $user = new User;
        // Verify email is unique
        $user-&gt;email = 'jane.doe@example.com';
        $user-&gt;password =  password_hash('example', PASSWORD_BCRYPT, ['cost' =&gt; 13]);
        $this-&gt;assertFalse($user-&gt;validate());
        $this-&gt;assertTrue($user-&gt;hasErrors('email'));
    });

    $this-&gt;specify('first and last name are strings', function() {
        $user = new User;
        $user-&gt;email = 'user@example.com';
        $user-&gt;password =  password_hash('example', PASSWORD_BCRYPT, ['cost' =&gt; 13]);
        // Verify first and last name has to be strings
        $user-&gt;first_name = (int)7;
        $user-&gt;last_name = (int)5;

        $this-&gt;assertFalse($user-&gt;validate());
        $this-&gt;assertTrue($user-&gt;hasErrors('first_name'));
        $this-&gt;assertTrue($user-&gt;hasErrors('last_name'));

        // Verify that strings work
        $user-&gt;setFullName('Example User');
        $this-&gt;assertTrue($user-&gt;validate());
    });
}</pre></div></li><li class="listitem" value="5">After<a id="id552" class="calibre1"/> running our unit tests, we should see the following output, indicating that our tests have passed. If our tests fail at any point, the specify module will output the first parameter, indicating what specific part of the test failed. As our test passes, we will see the following output:<div class="mediaobject"><img src="../images/00047.jpeg" alt="Testing User model methods" class="calibre10"/></div><p class="calibre25"> </p><div class="note1" title="Note"><h3 class="title2"><a id="tip167" class="calibre1"/>Tip</h3><p class="calibre9">Yii2 already has a test case for <code class="email">yii\db\ActiveRecord::validate()</code>. Adding our own test case isn't to verify that this method works but rather to verify that we have the correct validators in place.</p><p class="calibre9">For<a id="id553" class="calibre1"/> more information on the specify module, refer to <a class="calibre1" href="https://github.com/Codeception/Specify">https://github.com/Codeception/Specify</a>.</p></div></li></ol><div class="calibre15"/></div></div></div></div>

<div id="page" style="height:0pt"/><div class="book" title="Functional testing"><div class="book" id="1S2JE2-ad3e09b384df46aea690d9c8897d5fe7"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch10lvl1sec57" class="calibre1"/>Functional testing</h1></div></div></div><p class="calibre9">The next type of tests that we can generate are called functional tests. <span class="strong"><strong class="calibre2">Functional tests</strong></span> allow us<a id="id554" class="calibre1"/> to emulate our application without running it through a web <a id="id555" class="calibre1"/>server. This provides us with a way to quickly test the output of our application without introducing the overhead of a web server.</p><p class="calibre9">This emulation process is achieved by directly manipulating the <code class="email">$_REQUEST</code>, <code class="email">$_POST</code>, and <code class="email">$_GET</code> parameters before executing our application. As a side effect of this behavior, however, certain variables, such as <code class="email">$_SESSION</code> and <code class="email">$_COOKIE</code>, as well as headers, can result in <code class="email">junk</code> errors being thrown, which wouldn't necessarily be thrown in a real environment. Moreover, with Codeception, our functional tests will be executing within a single memory container, which may result in a test failing when run as part of a group as opposed to running a single test. Additionally, unlike acceptance testing, functional testing can't emulate JavaScript and Ajax requests.</p><p class="calibre9">Overall, functional testing provides us with a fast and easy way to prove that the output of our code does both what we programmed it to do and what our end users and customers expect it to do. Despite the minor issues functional testing brings up, at a high level, the report it provides can give us confidence that our code works as expected and that future changes in our codebase won't change our application significantly. In this section, we'll go over how to generate and run functional tests within our application.</p><div class="note" title="Note"><h3 class="title2"><a id="tip168" class="calibre1"/>Tip</h3><p class="calibre9">In this<a id="id556" class="calibre1"/> section, we'll be using the source code in the <code class="email">functional_and_acceptance</code> branch located at <a class="calibre1" href="https://github.com/masteringyii/chapter10">https://github.com/masteringyii/chapter10</a>.</p></div></div>

<div class="book" title="Functional testing">
<div class="book" title="Setting up functional tests"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_1"><a id="ch10lvl2sec120" class="calibre1"/>Setting up functional tests</h2></div></div></div><p class="calibre9">Since<a id="id557" class="calibre1"/> functional testing and API don't really make sense, we'll be writing our functional tests using the code we wrote earlier in <a class="calibre1" title="Chapter 6. Asset Management" href="part0039_split_000.html#1565U2-ad3e09b384df46aea690d9c8897d5fe7">Chapter 6</a>, <span class="strong"><em class="calibre13">Asset Management</em></span>, as the code outlined in that chapter has several good components we can test. Functional tests behave quite differently from unit tests, so before we can start writing test code, we need to make a few changes to our test configuration:</p><div class="book"><ol class="orderedlist"><li class="listitem" value="1">To get started with functional tests, we first need to make sure that Codeception is initially installed and configured. This process is identical to what we performed in the previous section:<div class="book"><ul class="itemizedlist1"><li class="listitem">Install the required composer dependencies:<div class="note"><pre class="programlisting"><span class="strong"><strong class="calibre2">$ composer require --dev codeception/codeception</strong></span>
<span class="strong"><strong class="calibre2">$ composer require --dev yiisoft/yii2-codeception</strong></span>
<span class="strong"><strong class="calibre2">$ composer require --dev yiisoft/yii2-faker</strong></span>
<span class="strong"><strong class="calibre2">$ composer require --dev codeception/specify</strong></span>
</pre></div></li><li class="listitem">Install Bootstrap Codeception:<div class="note"><pre class="programlisting"><span class="strong"><strong class="calibre2">$ ./vendor/bin/codecept bootstrap</strong></span>
</pre></div></li><li class="listitem">Add <a id="id558" class="calibre1"/>the required configuration to <code class="email">tests/_bootstrap.php</code>. Note that because we're emulating a complete request flow, we need to prepopulate several variables, such as <code class="email">$_SERVER['SCRIPT_FILENAME']</code> and<code class="email"> $_SERVER['SCRIPT_NAME']</code>. The relevant sections are highlighted as follows:<div class="note"><pre class="programlisting">&lt;?php
define('DS', DIRECTORY_SEPARATOR);

<span class="strong"><strong class="calibre2">defined('YII_TEST_ENTRY_URL') or define('YII_TEST_ENTRY_URL', parse_url(\Codeception\Configuration::config()['config']['test_entry_url'], PHP_URL_PATH));</strong></span>
<span class="strong"><strong class="calibre2">defined('YII_TEST_ENTRY_FILE') or define('YII_TEST_ENTRY_FILE', dirname(__DIR__) . '/web/index-test.php');</strong></span>

// Define our application_env variable as provided by nginx/apache
if (!defined('APPLICATION_ENV'))
{
    if (getenv('APPLICATION_ENV') != false)
        define('APPLICATION_ENV', getenv('APPLICATION_ENV'));
    else 
       define('APPLICATION_ENV', 'prod');
}
$env = require(__DIR__ . '/../config/env.php');
// comment out the following two lines when deployed to production
defined('YII_DEBUG') or define('YII_DEBUG', $env['debug']);
defined('YII_ENV') or define('YII_ENV', APPLICATION_ENV);
require(__DIR__ . '/../vendor/autoload.php');
require(__DIR__ . '/../vendor/yiisoft/yii2/Yii.php');
$config = require(__DIR__ . '/../config/web.php');

<span class="strong"><strong class="calibre2">$_SERVER['SCRIPT_FILENAME'] = YII_TEST_ENTRY_FILE;</strong></span>
<span class="strong"><strong class="calibre2">$_SERVER['SCRIPT_NAME'] = YII_TEST_ENTRY_URL;</strong></span>
<span class="strong"><strong class="calibre2">$_SERVER['SERVER_NAME'] = parse_url(\Codeception\Configuration::config()['config']['test_entry_url'], PHP_URL_HOST);</strong></span>
<span class="strong"><strong class="calibre2">$_SERVER['SERVER_PORT'] =  parse_url(\Codeception\Configuration::config()['config']['test_entry_url'], PHP_URL_PORT) ?: '80';</strong></span>

<span class="strong"><strong class="calibre2">Yii::setAlias('@tests', dirname(__DIR__));</strong></span>

(new yii\web\Application($config));</pre></div></li><li class="listitem">Verify that Codeception is running:<div class="note"><pre class="programlisting">$ ./vendor/bin/codecept bootstrap</pre></div></li></ul></div></li><li class="listitem" value="2">The <a id="id559" class="calibre1"/>first change we need to make is the inclusion of the Yii2 Codeception module. This module will enable us to take advantage of Yii2-specific bindings within our test that will help us test our Yii2 application better. Rather than enabling our module for all of our test types, we can just enable it for our functional tests by adding the following to<code class="email"> tests/functional.suite.yml</code>:<div class="note"><pre class="programlisting"># Codeception Test Suite Configuration
#
# Suite for functional (integration) tests
# Emulate web requests and make application process them
# Include one of framework modules (Symfony2, Yii2, Laravel5) to use it

class_name: FunctionalTester
modules:
    enabled:
      - Filesystem
      - Yii2
    config:
        Yii2:
            configFile: 'tests/config/functional.php'</pre></div></li><li class="listitem" value="3">Next, we need to disable cross-site request forgery (CSRF) validation on our forms. Rather than making a global configuration change to our <code class="email">config/web.php</code> file, we can create a custom configuration in <code class="email">tests/config/functional.php</code> that includes our <code class="email">config/web.php</code> file and disables<a id="id560" class="calibre1"/> CSRF validation in that file:<div class="note"><pre class="programlisting">&lt;?php
$_SERVER['SCRIPT_FILENAME'] = YII_TEST_ENTRY_FILE;
$_SERVER['SCRIPT_NAME'] = YII_TEST_ENTRY_URL;
/**
 * Application configuration for functional tests
 */
return yii\helpers\ArrayHelper::merge(
    require(__DIR__ . '/../../config/web.php'),
    [
        'components' =&gt; [
            'request' =&gt; [
                'enableCsrfValidation' =&gt; false,
            ],
        ],
    ]
);</pre></div></li><li class="listitem" value="4">Next, we need to enable our Yii2 module. To enable a new module in Codeception, we simply need to run the following command:<div class="note"><pre class="programlisting"><span class="strong"><strong class="calibre2">$ ./vendor/bin/codecept build</strong></span>
</pre></div><div class="mediaobject"><img src="../images/00048.jpeg" alt="Setting up functional tests" class="calibre10"/></div><p class="calibre25"> </p></li><li class="listitem" value="5">Finally, we can execute the run command of Codeception to verify that our changes took place:<div class="note"><pre class="programlisting"><span class="strong"><strong class="calibre2">$ ./vendor/bin/codecept run</strong></span>
</pre></div></li><li class="listitem" value="6">If successful, we should see output similar to what is shown in the following figure:<div class="mediaobject"><img src="../images/00049.jpeg" alt="Setting up functional tests" class="calibre10"/></div><p class="calibre25"> </p></li></ol><div class="calibre15"/></div></div></div>

<div class="book" title="Functional testing">
<div class="book" title="Generating functional tests"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_2"><a id="ch10lvl2sec121" class="calibre1"/>Generating functional tests</h2></div></div></div><p class="calibre9">Unlike <a id="id561" class="calibre1"/>unit tests, functional tests are not executed within a generated class. Instead, they run within a plain PHP file within the <code class="email">tests/functional</code> folder. To get started with generating functional tests, we need to use the <code class="email">generate:cept</code> command once again:</p><div class="note"><pre class="programlisting"><span class="strong"><strong class="calibre2">$ ./vendor/bin/codecept generate:cept functional Page</strong></span>
</pre></div><p class="calibre9">Our functional test will then be generated in <code class="email">tests/functional/PageCept.php</code> and will contain the following:</p><div class="note"><pre class="programlisting">&lt;?php 
$I = new FunctionalTester($scenario);
$I-&gt;wantTo('perform actions and see result');</pre></div><p class="calibre9">Now if we execute our tests again, we should see the following:</p><div class="mediaobject"><img src="../images/00050.jpeg" alt="Generating functional tests" class="calibre10"/></div><p class="calibre11"> </p></div></div>

<div class="book" title="Functional testing">
<div class="book" title="Examples of functional tests"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_3"><a id="ch10lvl2sec122" class="calibre1"/>Examples of functional tests</h2></div></div></div><p class="calibre9">Now<a id="id562" class="calibre1"/> that we know how to generate functional tests, let's explore a few examples of functional testing. If you remember from <a class="calibre1" title="Chapter 6. Asset Management" href="part0039_split_000.html#1565U2-ad3e09b384df46aea690d9c8897d5fe7">Chapter 6</a>, <span class="strong"><em class="calibre13">Asset Management</em></span>, our home page looks as follows:</p><div class="mediaobject"><img src="../images/00051.jpeg" alt="Examples of functional tests" class="calibre10"/></div><p class="calibre11"> </p><p class="calibre9">Let's write a quick functional test to verify that our home page loads and contains the elements we see on screen:</p><div class="book"><ol class="orderedlist"><li class="listitem" value="1">With Yii2's Codeception binding, we have several ways to navigate to and load the data from a page. Within our <code class="email">tests/functional/PageCept.php</code> test, we can write the following to verify that the home page loads. We can do this using the <code class="email">FunctionalTester::amOnPage()</code> method, which verifies that <code class="email">FunctionalTester</code> was able to access the given page:<div class="note"><pre class="programlisting">&lt;?php 
$I = new FunctionalTester($scenario);
$I-&gt;wantTo('Verify that homepage loads');
<span class="strong"><strong class="calibre2">$I-&gt;amOnPage('/');</strong></span>
<span class="strong"><strong class="calibre2">$I-&gt;amOnPage('site/index');</strong></span>
<span class="strong"><strong class="calibre2">$I-&gt;amOnPage(['/site/index']);</strong></span>
</pre></div></li><li class="listitem" value="2">As you<a id="id563" class="calibre1"/> can see, we can load the home page either by querying the root URI or the <code class="email">site/index</code> action either as a string or an array. If we use the array syntax, we can pass additional parameters to our page as GET parameters.</li><li class="listitem" value="3">Now that we've verified that we're on the home page, let's verify that the <code class="email">'Now you're thinking with widgets!'</code> string is displayed. With Codeception, this is exceptionally easy with the following line of code:<div class="note"><pre class="programlisting">$I-&gt;see('Now you\'re thinking with widgets!');</pre></div></li><li class="listitem" value="4">We can additionally verify that the <code class="email">'Home'</code>, <code class="email">'Register'</code>, and <code class="email">'Login'</code> link text is displayed using the <code class="email">FunctionalTester::see()</code> method, which scans the requested document for the presence of the provided text:<div class="note"><pre class="programlisting">$I-&gt;see('Home');
$I-&gt;see('Register');
$I-&gt;see('Login');</pre></div></li><li class="listitem" value="5">Now let's run our functional tests. As an alternative to running both our unit and acceptance tests with every run, we can just run our functional tests by specifying the test type we want to run, as shown in the following example:<div class="note"><pre class="programlisting"><span class="strong"><strong class="calibre2">$ ./vendor/bin/codecept run functional</strong></span>
</pre></div><div class="mediaobject"><img src="../images/00052.jpeg" alt="Examples of functional tests" class="calibre10"/></div><p class="calibre25"> </p><div class="note1" title="Note"><h3 class="title2"><a id="tip169" class="calibre1"/>Tip</h3><p class="calibre9">Even though we're running several different tests, Codeception will only report a pass <a id="id564" class="calibre1"/>or fail result for the entire test file we created. To gain more insight into what Codeception is doing, we can tell Codeception to be more verbose by passing the "-v" flag to our command. Additional verbosity can be added by adding more "v" flags to our verbose flag (for example, "-vv" or even "-vvv"):</p><div class="note"><pre class="programlisting"><span class="strong"><strong class="calibre2">$ ./vendor/bin/codecept run functional –vv</strong></span>
</pre></div><div class="mediaobject1"><img src="../images/00053.jpeg" alt="Examples of functional tests" class="calibre10"/></div><p class="calibre11"> </p></div></li><li class="listitem" value="6">Since <a id="id565" class="calibre1"/>we're creating a new test, we should first create a new functional test file for us to work with. Running the following command will generate a test file at <code class="email">tests/functional/LoginCept.php</code>:<div class="note"><pre class="programlisting"><span class="strong"><strong class="calibre2">$ ./vendor/bin/codecept generate:cept functional Login</strong></span>
</pre></div></li><li class="listitem" value="7">First, let's write a test to verify that we can click on the "Login" link on our home page and navigate to our login page:<div class="note"><pre class="programlisting">&lt;?php 
$I = new FunctionalTester($scenario);
$I-&gt;wantTo('Verify login page');

// Verify homepage link works
$I-&gt;amOnPage('/');
$I-&gt;click('Login');
$I-&gt;amOnPage(['site/login']);</pre></div></li><li class="listitem" value="8">After <a id="id566" class="calibre1"/>verifying that our tests pass, we can verify that the form is present and that there aren't any errors using the <code class="email">seeElement()</code> and <code class="email">dontSeeElement()</code> methods:<div class="note"><pre class="programlisting">// Verify form is present
$I-&gt;seeElement('input', ['id' =&gt; 'userform-email']);
$I-&gt;seeElement('input', ['id' =&gt; 'userform-password']);</pre></div></li><li class="listitem" value="9">Then, after verifying that we can see the form elements on the page, let's test whether our form works by first submitting an invalid username and password and then submitting a valid username and password combination:<div class="note"><pre class="programlisting">// Verify bad user/pass fails
$I-&gt;fillField(['id' =&gt; 'userform-email'], 'foo');
$I-&gt;fillField(['id' =&gt; 'userform-password'], 'bar');
$I-&gt;click("Submit");

$I-&gt;SeeCurrentUrlEquals('/site/login');

// Verify bad user/pass fails
$I-&gt;fillField(['id' =&gt; 'userform-email'], 'admin@example.com');
$I-&gt;fillField(['id' =&gt; 'userform-password'], 'admin');
$I-&gt;click("Submit");

$I-&gt;SeeCurrentUrlEquals('/site/index');</pre></div></li><li class="listitem" value="10">Now let's run our Login test. We can run this test independently of all other tests by calling it directly, as shown in the following example:<div class="note"><pre class="programlisting"><span class="strong"><strong class="calibre2">$ ./vendor/bin/codecept functional LoginCept –vv</strong></span>
</pre></div></li><li class="listitem" value="11">As shown in the following screenshot, our functional test iterates through all of our test and verifies that the login form flow works as expected:<div class="mediaobject"><img src="../images/00054.jpeg" alt="Examples of functional tests" class="calibre10"/></div><p class="calibre25"> </p></li></ol><div class="calibre15"/></div><div class="note" title="Note"><h3 class="title2"><a id="tip170" class="calibre1"/>Tip</h3><p class="calibre9">The <a id="id567" class="calibre1"/>Yii2 module provides several methods that can be used when running both functional and unit tests. For a complete list of the methods provided by the Yii2 Codeception  module, ensure that you refer to the<a id="id568" class="calibre1"/> Yii2 Codeception module page at <a class="calibre1" href="http://codeception.com/docs/modules/Yii2">http://codeception.com/docs/modules/Yii2</a>.</p></div></div></div>

<div id="page" style="height:0pt"/><div class="book" title="Acceptance testing" id="1T1401-ad3e09b384df46aea690d9c8897d5fe7"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch10lvl1sec58" class="calibre1"/>Acceptance testing</h1></div></div></div><p class="calibre9">The<a id="id569" class="calibre1"/> last type of testing we can automate with Codeception is called acceptance testing. It is very similar to functional testing, with the exception that your application is tested using a real browser rather than a simulated one. This gives the advantage of being able to completely simulate end user behavior. Acceptance testing doesn't have many of the limitations of functional testing, such as memory limitations, <code class="email">$_COOKIE</code>, <code class="email">$_SESSION</code>, and header limitations. Moreover, acceptance testing can be done by anyone on your team, as what is tested using acceptance testing replicates the work you would do to test manually. In fact, one of the only downsides of running acceptance tests is that due to the entire browser flow, acceptance tests can be extremely slow for specific tests. In this section, we'll cover how to set up and run acceptance testing with Codeception.</p><div class="note" title="Note"><h3 class="title2"><a id="tip171" class="calibre1"/>Tip</h3><p class="calibre9">In this<a id="id570" class="calibre1"/> section, we'll be using the source code on the <code class="email">functional_and_acceptance</code> branch located at <a class="calibre1" href="https://github.com/masteringyii/chapter10">https://github.com/masteringyii/chapter10</a>.</p></div></div>

<div class="book" title="Acceptance testing" id="1T1401-ad3e09b384df46aea690d9c8897d5fe7">
<div class="book" title="Setting up acceptance testing"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_1"><a id="ch10lvl2sec123" class="calibre1"/>Setting up acceptance testing</h2></div></div></div><p class="calibre9">Like<a id="id571" class="calibre1"/> functional testing, acceptance testing requires some setup in order to get working with Yii2:</p><div class="book"><ol class="orderedlist"><li class="listitem" value="1">To get started, we first need to specify the browser we want to use. In our case, we'll be using a combination of PHP and browser. To do this, we first need to add the following to our <code class="email">tests/acceptance.suite.yml</code> file. Additionally, since we want to take advantage of Yii2-specific plugins, we'll enable the Yii2 module as well:<div class="note"><pre class="programlisting">--- 
class_name: AcceptanceTester
modules: 
  enabled: 
    - 
      PhpBrowser: 
        url: "http://localhost:8082"
    - \Helper\Acceptance
    - Yii2
  config:
        Yii2:
            configFile: 'tests/config/acceptance.php'</pre></div><div class="note1" title="Note"><h3 class="title2"><a id="tip172" class="calibre1"/>Tip</h3><p class="calibre9">If we want to use a real browser, we can do that by enabling the WebDriver module by adding the following to our <code class="email">modules:enabled</code> section:</p><div class="note"><pre class="programlisting">- WebDriver:
    url: http://localhost
    browser: firefox
    restart: true</pre></div></div></li><li class="listitem" value="2">Next, we<a id="id572" class="calibre1"/> need to rebuild our tests to include the added modules:<div class="note"><pre class="programlisting"><span class="strong"><strong class="calibre2">$ ./vendor/bin/codecept build</strong></span>
</pre></div></li><li class="listitem" value="3">Then, we need to configure our <code class="email">tests/acceptance/_bootstrap.php</code> file so that we can load our Yii2 app in our tests. Fortunately, this is more or less the same as our functional test bootstrap file:<div class="note"><pre class="programlisting">&lt;?php
    define('DS', DIRECTORY_SEPARATOR);
    
    defined('YII_TEST_ENTRY_URL') or define('YII_TEST_ENTRY_URL', parse_url(\Codeception\Configuration::config()['config']['test_entry_url'], PHP_URL_PATH));
        defined('YII_TEST_ENTRY_FILE') or define('YII_TEST_ENTRY_FILE', dirname(dirname(__DIR__)) . '/web/index-test.php');

    // Define our application_env variable as provided by nginx/apache
    if (!defined('APPLICATION_ENV'))
    {
        if (getenv('APPLICATION_ENV') != false)
            define('APPLICATION_ENV', getenv('APPLICATION_ENV'));
        else 
        define('APPLICATION_ENV', 'prod');
     }
     $env = require(__DIR__ . '/../../config/env.php');
    
    // comment out the following two lines when deployed to production
    defined('YII_DEBUG') or define('YII_DEBUG', $env['debug']);
    defined('YII_ENV') or define('YII_ENV', APPLICATION_ENV);
    require(__DIR__ . '/../../vendor/autoload.php');
    require(__DIR__ . '/../../vendor/yiisoft/yii2/Yii.php');
    $config = require(__DIR__ . '/../../config/web.php');
    
    Yii::setAlias('@tests', dirname(__DIR__));
    
    (new yii\web\Application($config));</pre></div></li><li class="listitem" value="4">Next, we<a id="id573" class="calibre1"/> need to define our <code class="email">tests/config/acceptance.php</code> file as follows:<div class="note"><pre class="programlisting">&lt;?php
$_SERVER['SCRIPT_FILENAME'] = YII_TEST_ENTRY_FILE;
$_SERVER['SCRIPT_NAME'] = YII_TEST_ENTRY_URL;

/**
 * Application configuration for functional tests
 */
return require(__DIR__ . '/../../config/web.php');</pre></div></li><li class="listitem" value="5">Then, we need to generate our first acceptance test using the <code class="email">generate:cept</code> command:<div class="note"><pre class="programlisting"><span class="strong"><strong class="calibre2">$ ./vendor/bin/codecept generate:cept acceptance Page</strong></span>
</pre></div></li><li class="listitem" value="6">Finally, we can run our newly created test by running the run command:<div class="note"><pre class="programlisting"><span class="strong"><strong class="calibre2">$ ./vendor/bin/codecept run acceptance</strong></span>
</pre></div><div class="mediaobject"><img src="../images/00055.jpeg" alt="Setting up acceptance testing" class="calibre10"/></div><p class="calibre25"> </p><div class="note1" title="Note"><h3 class="title2"><a id="tip173" class="calibre1"/>Tip</h3><p class="calibre9">Note<a id="id574" class="calibre1"/> that we're passing the required <code class="email">APPLICATION_ENV</code> variable to our built-in server. Additionally, we're using a <code class="email">8082</code> high port, as defined previously in our <code class="email">tests/acceptance.suite.yml</code> file. The high port number is to avoid the need to run PHP's built-in server with root access, which is required for ports under <code class="email">1024</code>.</p></div></li></ol><div class="calibre15"/></div></div></div>

<div class="book" title="Acceptance testing" id="1T1401-ad3e09b384df46aea690d9c8897d5fe7">
<div class="book" title="Examples of acceptance tests"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_2"><a id="ch10lvl2sec124" class="calibre1"/>Examples of acceptance tests</h2></div></div></div><p class="calibre9">Since <a id="id575" class="calibre1"/>acceptance tests are extremely similar to functional tests, we can reuse a lot of the same tools and methods we used in the previous section. For instance, we can write an acceptance test to check the home page for the links and text we looked for earlier in our functional tests, as follows:</p><div class="note"><pre class="programlisting">&lt;?php 
<code class="email">$I = new AcceptanceTester($scenario);</code>
$I-&gt;wantTo('Verify that homepage loads');
$I-&gt;amOnPage('/');
$I-&gt;amOnPage('site/index');
$I-&gt;see('Now you\'re thinking with widgets!');
$I-&gt;see('Home');
$I-&gt;see('Login');
$I-&gt;see('Register');</pre></div><p class="calibre9">Note that the only substantial difference here is the usage of <code class="email">AcceptanceTester</code> instead <a id="id576" class="calibre1"/>of <code class="email">FunctionalTester</code>. Running our tests in the verbose mode now will reveal the following:</p><div class="note"><pre class="programlisting"><span class="strong"><strong class="calibre2">$ ./vendor/bin/codecept run acceptance –vv</strong></span>
</pre></div><div class="mediaobject"><img src="../images/00056.jpeg" alt="Examples of acceptance tests" class="calibre10"/></div><p class="calibre11"> </p></div></div>

<div id="page" style="height:0pt"/><div class="book" title="Fixtures"><div class="book" id="1TVKI2-ad3e09b384df46aea690d9c8897d5fe7"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch10lvl1sec59" class="calibre1"/>Fixtures</h1></div></div></div><p class="calibre9">The last <a id="id577" class="calibre1"/>testing component we'll talk about in this chapter is fixtures. <span class="strong"><strong class="calibre2">Fixtures</strong></span> are an important part of testing as they enable us to set up our application state to a known and precise state before running our unit tests. Unlike these other test types, however, fixtures are provided directly by Yii2 and integrate into Codeception via <a id="id578" class="calibre1"/>the Yii2 Codeception module.</p><div class="note" title="Note"><h3 class="title2"><a id="tip174" class="calibre1"/>Tip</h3><p class="calibre9">In this <a id="id579" class="calibre1"/>section, we'll be using the source code on the <code class="email">fixtures</code> branch located at <a class="calibre1" href="https://github.com/masteringyii/chapter10">https://github.com/masteringyii/chapter10</a>.</p></div></div>

<div class="book" title="Fixtures">
<div class="book" title="Creating fixtures"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_1"><a id="ch10lvl2sec125" class="calibre1"/>Creating fixtures</h2></div></div></div><p class="calibre9">To get<a id="id580" class="calibre1"/> started with using fixtures, we first need to install the required composer dependencies and then add some configuration to our <code class="email">config/console.php</code> file:</p><div class="book"><ol class="orderedlist"><li class="listitem" value="1">First, we need to make sure that the <code class="email">yii2-faker composer</code> package is installed:<div class="note"><pre class="programlisting"><span class="strong"><strong class="calibre2">$ composer require --dev yii2-faker</strong></span>
</pre></div></li><li class="listitem" value="2">Alternatively, the <code class="email">yii2-faker</code> extension can be installed by adding the following to the <code class="email">require-dev</code> section of <code class="email">composer.json</code> and then by executing <code class="email">composer update</code>:<div class="note"><pre class="programlisting">"yiisoft/yii2-faker": "*",</pre></div></li><li class="listitem" value="3">Then, we need to add the relevant section to our console configuration file:<div class="note"><pre class="programlisting">&lt;?php

Yii::setAlias('@tests', dirname(__DIR__) . '/tests');

return [
    // [...],
    <span class="strong"><strong class="calibre2">'controllerMap' =&gt; [</strong></span>
<span class="strong"><strong class="calibre2">        'fixture' =&gt; [</strong></span>
<span class="strong"><strong class="calibre2">            'class' =&gt; 'yii\faker\FixtureController',</strong></span>
<span class="strong"><strong class="calibre2">        ],</strong></span>
<span class="strong"><strong class="calibre2">    ],</strong></span>
    'controllerNamespace' =&gt; 'app\commands',
    // [...]
];</pre></div></li><li class="listitem" value="4">Finally, we need to define a configuration file for our unit tests to load from <code class="email">tests/config/unit.php</code>. To keep things simple, we'll just load our web configuration file:<div class="note"><pre class="programlisting">&lt;?php
/**
 * Application configuration for functional tests
 */
return require(__DIR__ . '/../../config/web.php');</pre></div></li></ol><div class="calibre15"/></div><p class="calibre9">With the <a id="id581" class="calibre1"/>required extension installed, we can create and load fixtures into our app via the <code class="email">./yii</code> command-line tool:</p><div class="note"><pre class="programlisting"><span class="strong"><strong class="calibre2">./yii help fixture</strong></span>
</pre></div><div class="mediaobject"><img src="../images/00057.jpeg" alt="Creating fixtures" class="calibre10"/></div><p class="calibre11"> </p></div></div>

<div class="book" title="Fixtures">
<div class="book" title="Defining fixtures"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_2"><a id="ch10lvl2sec126" class="calibre1"/>Defining fixtures</h2></div></div></div><p class="calibre9">To define<a id="id582" class="calibre1"/> new fixtures, we can either extend <code class="email">yii\test\Fixture</code> (for general fixtures) or <code class="email">yii\test\ActiveFixture</code> (for ActiveRecord entries) and place our newly created classes in the <code class="email">tests/fixtures</code> folder of our application. After defining a new fixture, we'll then want to declare the model class we'll want to use for fixtures. As an example, let's create a fixture of our <code class="email">app\models\User</code> class, as shown in the following example:</p><div class="note"><pre class="programlisting">&lt;?php
namespace app\tests\fixtures;

use yii\test\ActiveFixture;

class UserFixture extends ActiveFixture
{
    public $modelClass = 'app\models\User';
}</pre></div><p class="calibre9">Now that we've defined our fixture class, we need to create the data that our fixture will populate. When using <code class="email">yii\test\ActiveFixture</code>, we'll want to place our data files in <code class="email">@tests/fixtures/data/&lt;database_table_name&gt;.php</code> or <code class="email">@tests/fixtures/data/user.php</code>, in our case. In this fixture file, we'll provide all the required mock<a id="id583" class="calibre1"/> data that we want to test against:</p><div class="note"><pre class="programlisting">&lt;?php return [
    'user1' =&gt; [
        'id'       =&gt; 1,
        'email'        =&gt; 'jane.doe@example.com',
        'password' =&gt; '$2y$13$iqINH3RvfW29zPupoz2Zeu9cTXUPosjn1V
.yhihP0iZEWFkEPSl6.',
        'first_name'  =&gt; 'Jane',
        'last_name'  =&gt; 'Doe',
        'role_id'     =&gt; 1,
        'created_at'  =&gt; 1448926013,
        'updated_at'  =&gt; 1448926013
    ],
    'admin' =&gt; [ 
        'id'       =&gt; 4,
        'email'     =&gt; 'admin@example.com',
        'password'     =&gt; '$2y$13$uHCvsJWJr.M0vRcDlhWhVO9tTPLh8qD9.ngnhwThzzwGNC62.Ugl6',
        'first_name' 	=&gt; 'Site',
        'last_name' 	=&gt; 'Administrator',
        'role_id' 		=&gt; 2,
        'created_at' 	=&gt; 1448926013,
        'updated_at' 	=&gt; 1448926013
    ]
];</pre></div><p class="calibre9">Our fixtures can be loaded by calling the <code class="email">fixture</code> command with the appropriate namespace:</p><div class="note"><pre class="programlisting"><span class="strong"><strong class="calibre2">$ ./yii fixture/load User --namespace=app/tests/fixtures</strong></span>
</pre></div><p class="calibre9">Fixtures can then be unloaded using the <code class="email">fixture/unload</code> command:</p><div class="note"><pre class="programlisting"><span class="strong"><strong class="calibre2">$ ./yii fixture/unload User --namespace=app/tests/fixtures</strong></span>
</pre></div><p class="calibre9">By default, Yii2 will try to load our fixtures from the <code class="email">@app/tests/unit/fixtures</code> folder. In the previous examples, we overwrote this behavior by supplying the <code class="email">--namespace</code> parameter. To avoid having to write this each time, we can modify our console configuration<a id="id584" class="calibre1"/> file as follows:</p><div class="note"><pre class="programlisting">&lt;?php

<code class="email">Yii::setAlias('@tests', dirname(__DIR__) . '/tests');</code>

return [
    // [...],
    'controllerMap' =&gt; [
        'fixture' =&gt; [
            'class' =&gt; 'yii\faker\FixtureController',
            <span class="strong"><strong class="calibre2">'namespace' =&gt; 'tests\fixtures',</strong></span>
        ],
    ],
    // [...]
];</pre></div><p class="calibre9">With this change, we can load and unload our fixtures without the need to specify a namespace.</p></div></div>

<div class="book" title="Fixtures">
<div class="book" title="Using fixtures in unit tests"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_3"><a id="ch10lvl2sec127" class="calibre1"/>Using fixtures in unit tests</h2></div></div></div><p class="calibre9">Now<a id="id585" class="calibre1"/> that we know how to create and load fixtures, let's explore <a id="id586" class="calibre1"/>how to load them as part of our tests. To get started with testing with fixtures, we first need to create a new unit test for our fixtures to run in. As a reminder, new unit tests in Codeception can be generated as follows:</p><div class="note"><pre class="programlisting"><span class="strong"><strong class="calibre2">$ ./vendor/bin/codecept generate:test un it UserFixture</strong></span>
</pre></div><p class="calibre9">After creating our unit test, we need to modify our newly created <code class="email">UserFixtureTest</code> in <code class="email">tests/unit/UnitFixtureTest.php</code> with several changes:</p><div class="book"><ol class="orderedlist"><li class="listitem" value="1">First, we need to properly namespace our test and include our <code class="email">UserFixture</code> class:<div class="note"><pre class="programlisting">&lt;?php

namespace app\tests\unit\UserFixtureTest;

use app\tests\fixtures\UserFixture;
use app\models\User;
use Yii;</pre></div></li><li class="listitem" value="2">Next, we need to have our <code class="email">UserFixtureTest</code> extend <code class="email">\yii\codeception\DbTestCase</code> and include the unit test configuration file that we created previously:<div class="note"><pre class="programlisting">class UserFixtureTest extends \yii\codeception\DbTestCase
{
    /**
     * @var \UnitTester
     */
    protected $tester;

    public $appConfig = "@app/tests/config/unit.php";
}</pre></div></li><li class="listitem" value="3">Finally, we<a id="id587" class="calibre1"/> need to tell our test case to<a id="id588" class="calibre1"/> load our <code class="email">UserFixture</code> class:<div class="note"><pre class="programlisting">public function fixtures()
{
    return [
        'users' =&gt; UserFixture::className(),
    ];
}</pre></div></li></ol><div class="calibre15"/></div><p class="calibre9">Now, after every test we create within our newly created <code class="email">UserFixtureTest</code> class, our previously created fixtures will be loaded into our database before each test and then removed after the test is complete. For instance, we can create the following test to verify that password verification works:</p><div class="note"><pre class="programlisting">public function testValidatePassword()
{
    $user = User::find()-&gt;where(['id' =&gt; 1])-&gt;one();
    $this-&gt;assertTrue($user-&gt;validatePassword('password1'));
    $this-&gt;assertFalse($user-&gt;validatePassword('password2'));
    unset($user);
    
    $user = User::find()-&gt;where(['id' =&gt; 4])-&gt;one();
    $this-&gt;assertTrue($user-&gt;validatePassword('admin'));
    $this-&gt;assertFalse($user-&gt;validatePassword('notadmin'));
    unset($user);
}</pre></div><p class="calibre9">Our newly created tests and fixtures can then be run with the following command:</p><div class="note"><pre class="programlisting"><span class="strong"><strong class="calibre2">$ ./vendor/bin/codecept run unit</strong></span>
</pre></div><div class="mediaobject"><img src="../images/00058.jpeg" alt="Using fixtures in unit tests" class="calibre10"/></div><p class="calibre11"> </p><p class="calibre9">At the<a id="id589" class="calibre1"/> beginning of this test, our fixtures will be loaded, and <a id="id590" class="calibre1"/>then our tests will run. After our test runs, our fixtures will be unloaded, and then we can run another test. The use of fixtures in this case prevents the results of one test from affecting the results of another.</p></div></div>
<div class="book" title="Automatic change testing" id="1UU541-ad3e09b384df46aea690d9c8897d5fe7"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch10lvl1sec60" class="calibre1"/>Automatic change testing</h1></div></div></div><p class="calibre9">An<a id="id591" class="calibre1"/> important aspect of testing is ensuring that your tests are run regularly and often. If you're following the test-driven development philosophy, you should be writing your tests before writing code and adapting your tests as new code is added. While this will give you a good idea of what is working and what isn't, it can be extremely time-consuming, and it doesn't cover cases where team members make changes but either don't write tests or don't run them before committing and pushing them to your DCVS repository.</p><p class="calibre9">The best way to ensure that your tests are run after every change is to use a third-party service, such as Travis CI. A tool such as Travis CI will add a webbook to your repository, and after every commit, it can be configured to run all your tests and notify you if and when your tests ever start failing.</p><div class="note" title="Note"><h3 class="title2"><a id="tip175" class="calibre1"/>Tip</h3><p class="calibre9">In general, you should always verify that your code runs and that your tests pass before committing it to your repository.</p></div><p class="calibre9">Using Travis CI as an example, let's add our repository to Travis CI and enable automated builds:</p><div class="book"><ol class="orderedlist"><li class="listitem" value="1">To get<a id="id592" class="calibre1"/> started with Travis CI, we first need to log in to <a class="calibre1" href="https://travis-ci.org">https://travis-ci.org</a> with our GitHub account and then navigate to our profile at <a class="calibre1" href="https://travis-ci.org/profile">https://travis-ci.org/profile</a>.<div class="note1" title="Note"><h3 class="title2"><a id="tip176" class="calibre1"/>Tip</h3><p class="calibre9">Travis CI has<a id="id593" class="calibre1"/> tight coupling with GitHub and does not work with other services, such as GitLab or Bitbucket. The service is free only for public repositories. There are many other services, however, that can perform the same service as Travis CI, such as Atlassian Bamboo, drone.io, circleci.com, GitLab CI, and others. Before using a continuous integration tool, ensure that you do your research to determine what is best for your team. For projects that you don't mind being public, Travis CI provides a good free option.</p></div></li><li class="listitem" value="2">After<a id="id594" class="calibre1"/> navigating to your profile, you need to enable Travis CI for your repository. Thanks to the tight coupling Travis CI has with GitHub, this is as simple as toggling a single switch.<div class="mediaobject"><img src="../images/00059.jpeg" alt="Automatic change testing" class="calibre10"/></div><p class="calibre25"> </p></li><li class="listitem" value="3">After establishing your connection to Travis CI, you need to create a <code class="email">.travis.yml</code> file in your repository. This file contains instructions on how to build and test your project. While there are many different possible configurations and matrices that Travis CI can work with, we'll be using a relatively simple one, as shown in the next section:<div class="note"><pre class="programlisting">sudo: false

env:
  - "APPLICATION_ENV=dev"
  
language: php

cache:
  directories:
    - vendor

php:
  - 5.6
  - 7

install:
  - composer selfupdate
  - composer global require "fxp/composer-asset-plugin:~1.0"
  - composer install -o -n

before_script:
  - ./yii migrate/up --interactive=0
  
script: 
  - ./vendor/bin/codecept run</pre></div></li><li class="listitem" value="4">Our <code class="email">.travis.yml</code> file<a id="id595" class="calibre1"/> contains several sections:<div class="book"><ul class="itemizedlist1"><li class="listitem">The <code class="email">language</code> section defines what language we want to use when Travis CI runs our build.</li><li class="listitem">The <code class="email">cache</code> option exists simply to speed up our build and test process. At the end of each successful build, Travis CI will cache the contents of our <code class="email">vendor/folder</code>, which will reduce the time it takes for Composer to install all the required dependencies.</li><li class="listitem">The <code class="email">php</code> section lists all the PHP versions we want to test against. Generally, we want to test against the current and next versions of PHP so that when that version comes out, we're ready to start using it. Testing against future versions of PHP allows us to quickly adapt our code to take advantage of new performance enhancements of new PHP versions.</li><li class="listitem">The <code class="email">install</code> section allows us to define software that needs to be installed before our build runs. In this section, we define things such as the composer-asset-plugin and our composer dependencies.</li><li class="listitem">The <code class="email">before_script</code> section defines things that should occur before our <code class="email">build/test</code> script executes.</li><li class="listitem">Finally, the <code class="email">script</code> section defines what we want to build or test.</li></ul></div></li><li class="listitem" value="5">After<a id="id596" class="calibre1"/> defining our <code class="email">.travis.yml</code> file, we need to simply commit the file to our repository. Since we've already linked Travis CI to our GitHub project, pushing our project will automatically trigger a build that we can view on Travis CI. On Travis CI, we can view a history of all the builds that have occurred for our project. In the event that someone pushes code to our repository that breaks our build, we will receive a notification and can notify the person who broke our tests to fix their code before trying again. Additionally, we can view a complete build output for each commit, which gives us insight into what is happening in each build.<div class="note1" title="Note"><h3 class="title2"><a id="tip177" class="calibre1"/>Tip</h3><p class="calibre9">As an example, the repository for this chapter was linked to Travis CI. You can see <a id="id597" class="calibre1"/>builds in action by navigating to <a class="calibre1" href="https://travis-ci.org/masteringyii">https://travis-ci.org/masteringyii</a>.</p></div></li></ol><div class="calibre15"/></div></div>
<div class="book" title="Summary" id="1VSLM1-ad3e09b384df46aea690d9c8897d5fe7"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch10lvl1sec61" class="calibre1"/>Summary</h1></div></div></div><p class="calibre9">We learned quite a bit about testing in this chapter! We first covered how to set up and configure Codeception to run within our project. We then covered how to set up unit, functional, and acceptance testing in order to ensure that we had adequate test coverage of our code base. Next, we covered how to create and use fixtures to mock data so that our tests run with a consistent test base. Finally, we covered how to automate the testing of our code with Travis CI, a third-party continuous integration service.</p><p class="calibre9">In the next chapter, we'll cover how to use Yii2's internationalization and localization features to make our applications capable of running in multiple languages.</p></div></body></html>