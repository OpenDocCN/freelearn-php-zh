- en: '[*Chapter 7*](B17606_07_Final_PD_ePub.xhtml#_idTextAnchor131): Working with
    Static and Dynamic Sections'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapter, we familiarized ourselves with the different types
    of inputs, whether they're basic or specialized, and how we can use them to create
    global settings that we can easily configure through the theme editor.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will not only get to use the previously mentioned inputs,
    but we will also learn how to create easily configurable and reusable sections
    that we can use to change the page or even templates' layouts easily.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will learn about the following topics in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Static versus dynamic sections
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Working with the section schema
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Building with blocks
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Enhancing pages with JSON templates
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Exploring section-specific tags
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By the time we complete this chapter, we will understand what sections are,
    when to use them, and how to create one. We will also learn about the difference
    between static and dynamic sections, and how we can configure them through the
    theme editor.
  prefs: []
  type: TYPE_NORMAL
- en: By learning about the section schema and the different attributes that we can
    use, we will also learn how to create reusable block modules within a section
    that we can use to repeat and receive different results. After familiarizing ourselves
    with sections and blocks, we will learn how to improve these concepts by learning
    about JSON templates and built-in metafields. Lastly, we will learn about the
    different types of specialized tags that we can use within section files, which
    will help us create reusable and dynamic modules.
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: While we will explain each topic and have it presented with the accompanying
    graphics, we will need an internet connection to follow the steps outlined in
    this chapter, considering that Shopify is a hosted service.
  prefs: []
  type: TYPE_NORMAL
- en: 'The code for this chapter is available on GitHub: [https://github.com/PacktPublishing/Shopify-Theme-Customization-with-Liquid/tree/main/Chapter07](https://github.com/PacktPublishing/Shopify-Theme-Customization-with-Liquid/tree/main/Chapter07).'
  prefs: []
  type: TYPE_NORMAL
- en: 'The Code in Action video for the chapter can be found here: [https://bit.ly/3hQzhVg](https://bit.ly/3hQzhVg)'
  prefs: []
  type: TYPE_NORMAL
- en: Static versus dynamic sections
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In [*Chapter 1*](B17606_01_Final_PD_ePub.xhtml#_idTextAnchor015), *Getting Started
    with Shopify*, while discussing the theme structure, we briefly mentioned section
    files, *but what exactly are sections?*
  prefs: []
  type: TYPE_NORMAL
- en: Besides being the name of one of the directories in the theme file, a **section**
    is a type of file that allows us to create reusable modules that we can customize
    using the theme editor, as we learned previously. However, as opposed to the global
    settings that we have learned about, the major difference is that the JSON settings
    for sections are defined inside each section file and are section-specific.
  prefs: []
  type: TYPE_NORMAL
- en: Section-specific settings allow us to reuse the same section module multiple
    times on the page and select a different set of options for each occurrence, making
    it a pretty powerful feature. For example, we can create a featured collections
    section and repeat it three times to display three products from three separate
    collections.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before we proceed, let''s navigate to the theme editor by clicking the **Customize**
    button from the code editor and see the section files in action. Clicking the
    **Customize** button will automatically open the theme editor and position us
    on the home page, with the page preview on the right-hand side and a sidebar on
    the left. Within the sidebar, we can see several sections that are available on
    this specific page:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.1 – Example of page sections within the theme editor'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_7.01_B17606.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 7.1 – Example of page sections within the theme editor
  prefs: []
  type: TYPE_NORMAL
- en: At first glance, we can see that the **Header** and **Footer** sections are
    separated from the rest of the sections by a thin border. This tells us that the
    **Header** and **Footer** sections are static sections whose positions we cannot
    change from within the theme editor.
  prefs: []
  type: TYPE_NORMAL
- en: 'Similarly, as with snippet files, `section` theme tag:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: By including the `section` tag, we will automatically render the content of
    the section to the position where we have included the tag and be able to customize
    it further using its JSON settings. Note that since this is a static section that
    we have manually included within the theme files, any settings that we apply to
    this specific section through the theme editor will be visible across all the
    pages where we have included this section.
  prefs: []
  type: TYPE_NORMAL
- en: For example, the theme developers have included the header and footer section
    files inside the `theme.liquid` layout file, which is our theme master file, meaning
    that the header and footer sections will be visible on any page on our store.
    On the other hand, if we were to navigate to a different page within our theme
    editor, we would see a header, a footer, and an entirely different set of sections
    between those two than those we previously saw on the home page.
  prefs: []
  type: TYPE_NORMAL
- en: By including the header and footer sections inside the `theme.liquid` file,
    we have made them visible across the entire theme on any page. However, we will
    not include all the sections within the `theme.liquid` file as they are not needed.
    Instead, we will include certain template-specific sections inside their respective
    template files so that they can only be accessed when visiting pages with the
    specific template assigned.
  prefs: []
  type: TYPE_NORMAL
- en: Let's say that we wanted to include the related products section on the product
    pages. Here, we would navigate to the `product.liquid` template and include the
    `section` tag at any position, which would make the related products section visible
    on any product that uses this particular template.
  prefs: []
  type: TYPE_NORMAL
- en: As we recall from [*Chapter 4*](B17606_04_Final_PD_ePub.xhtml#_idTextAnchor079),
    *Diving into Liquid Core with Objects*, in *The Please apply P-Italics here content_for_layout
    object* section, we mentioned that the `content_for_layout` object allows us to
    connect the other templates to the `theme.liquid` file by loading the dynamically
    generated content, including the section files from other templates, into the
    `theme.liquid` file.
  prefs: []
  type: TYPE_NORMAL
- en: 'Since `content_for_layout` outputs the content of all other templates, by placing
    it between the header and footer sections, we have ensured that we will position
    all the section files from other template files in between the header and footer
    sections. Let''s look at the `theme.liquid` layout file; we will notice that we
    positioned `content_for_layout` between the `header` and `footer` sections, as
    depicted in the following block of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Note that including the same section file across multiple templates will result
    in the same content being visible across all templates. By configuring the static
    section from the theme editor, we can save the selected data inside the `settings_data.json`
    file, which will return the exact data for any occurrence of the same section.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we need to repeat the static section multiple times with different content,
    we would need to create a new section file using a different name:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: So far, we have seen what static sections are and how to use them to create
    a template-based configurable layout. But we also have access to dynamic sections,
    which we do not have to include every time we want to reposition a section manually.
  prefs: []
  type: TYPE_NORMAL
- en: 'As the name suggests, **dynamic sections** are a set of sections that we can
    add, remove, reposition, or repeat any number of times with different content,
    without touching a single line of code, all from the theme editor. Let''s return
    to the home page within the theme editor and look at some of the existing dynamic
    sections:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.2 – Example of page sections within the theme editor'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_7.02_B17606.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 7.2 – Example of page sections within the theme editor
  prefs: []
  type: TYPE_NORMAL
- en: We can easily distinguish the static section from the dynamic section by simply
    hovering over the section itself. We will notice two icons to the right of the
    dynamic section's name – an *eye* icon and *six dots* – by hovering over it. The
    eye icon will allow us to toggle the section's visibility on and off. By clicking
    and holding onto the six dots icon, we can reposition the section by moving it
    above or below the other sections.
  prefs: []
  type: TYPE_NORMAL
- en: Additionally, at the bottom of the dynamic sections, we will notice an **Add
    section** button, which, once clicked, will show a dropdown that we can use to
    include any number of sections that exist in our store by simply clicking on them.
    Any section that's added to the theme via the **Add section** button will allow
    us to include different content for any occurrence, and we can repeat this as
    many times as we want.
  prefs: []
  type: TYPE_NORMAL
- en: Until recently, the home page was the only place where we could use dynamic
    sections. For all other templates, we had to rely on using static sections. However,
    since the Shopify Unite 2021 event, Shopify has introduced JSON type templates,
    which we briefly mentioned in [*Chapter 1*](B17606_01_Final_PD_ePub.xhtml#_idTextAnchor015),
    *Getting Started with Shopify*. JSON templates, which we will learn more about
    later in this chapter, add dynamic sections to any page and bring the store's
    entire functionality to a whole new level.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have learned about what sections are and how we can use them, it
    is time to learn how to create them.
  prefs: []
  type: TYPE_NORMAL
- en: Working with the section schema
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapter, we learned how to use JSON to create global settings,
    which has a similar format to the JSON for section files. However, sectional JSON
    comes with a few distinct differences.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first major difference is that we need to define JSON inside the section
    file instead of the `settings_schema.json` file. To do this, we will need to introduce
    the `schema` tag:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The `schema` tag is a Liquid tag that does not have any output on its own. It
    simply allows us to write JSON code inside the section files. Note that each section
    file can only contain a single `schema` tag, which must stand on its own. It cannot
    be nested inside any kind of other Liquid tags.
  prefs: []
  type: TYPE_NORMAL
- en: Once we have the `schema` tag in place, we are ready to familiarize ourselves
    with the types of attributes that we can use within the `schema` tags.
  prefs: []
  type: TYPE_NORMAL
- en: The name attribute
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As its name suggests, the `name` attribute allows us to set the section name,
    which we will use to identify the section inside the theme editor later:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: With that, we have learned how to define the name of the section file, *but
    what if we wanted to create an international store where we can easily translate
    not only the store content, but also the store setting labels, inside the theme
    editor?*
  prefs: []
  type: TYPE_NORMAL
- en: 'We can easily translate most of the attributes inside the `schema` tag by including
    the translation keys in the `name` attribute value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: The first value represents the name of the file inside the `Locales` directory,
    whereas the second one represents the translated value. By introducing the translating
    keys, we have ensured that as soon as we change our store language, the `name`
    value will automatically adjust and present the value of the currently selected
    language file.
  prefs: []
  type: TYPE_NORMAL
- en: Note that we can include the translation keys for different kinds of attributes,
    including some of the input settings that we learned about in the previous chapter.
    The attributes that we can use the translation keys with include `name`, `info`,
    `label`, `group`, `placeholder`, `unit`, `content`, and `category`.
  prefs: []
  type: TYPE_NORMAL
- en: Note that `name` is a mandatory attribute. However, the `name` attribute does
    not have to be unique compared to the other sections, so we should pay attention
    when creating new sections to avoid confusion.
  prefs: []
  type: TYPE_NORMAL
- en: The class attribute
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`class` is a simple attribute that allows us to add additional classes to the
    `div` element, which wraps around the section content:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Through this optional attribute, we can easily include any number of classes
    in the parent element wrapping around our section, as shown in the following code
    block:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Note that while we can include any number of classes, we cannot dynamically
    modify them since the `class` attribute only accepts string values.
  prefs: []
  type: TYPE_NORMAL
- en: The settings attribute
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Using the `settings` attribute, we can create section-specific settings, which
    allows us to configure the section using the theme editor:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Once we have defined the `settings` attribute, we can start including any input
    settings, whether they''re basic or specialized, that we have previously learned
    about to create the flow that we need. Since we are working on creating an announcement
    bar, we can include the following inputs:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'With the introduction of `settings` and input settings, we have successfully
    created the first section, whose text and text color values can be adjusted within
    the theme editor. If we were to try and include this section as a static section,
    the two input settings that we created previously would immediately be visible
    under the respective section:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: However, if we were to navigate to the home page and include the announcement
    section via the **Add section** button, we would not find it. We are still missing
    one attribute, which we need to create a section that we can dynamically add to
    the home page.
  prefs: []
  type: TYPE_NORMAL
- en: The presets attribute
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `presets` attribute allows us to define the default configuration of a
    section, which makes the section accessible from the `presets` attribute can contain
    the following attributes:'
  prefs: []
  type: TYPE_NORMAL
- en: The `name` attribute is mandatory and will define how the section will appear
    under the **Add section** dropdown.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `category` attribute is not mandatory. We can use it to group different
    sections under a single category for more straightforward navigation.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Note that it is advisable to use a unique name for the `presets` section to
    avoid confusion, even though Shopify does not strictly require it. Otherwise,
    we might end up with multiple sections with similar names:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Note that we should only include the `presets` attribute for dynamic sections.
    If we plan on using it as a static section, we should remove the `presets` attribute.
  prefs: []
  type: TYPE_NORMAL
- en: If we were to open the theme editor now and click on the **Add section** button
    on the home page, we would see the **Announcement Bar** section, with the text
    and color settings that we defined earlier.
  prefs: []
  type: TYPE_NORMAL
- en: 'Accessing the section-specific JSON input values is relatively similar to how
    we access the settings inside the `settings_schema.json` file. The only difference
    is that the only way to access the section''s `settings` object is through the
    `section` object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: For additional information on the `section` object, please refer to [https://shopify.dev/api/liquid/objects/section](https://shopify.dev/api/liquid/objects/section).
  prefs: []
  type: TYPE_NORMAL
- en: So far, we have learned what sections are, the differences between static and
    dynamic sections, and how to use them. However, looking over the announcement
    section project that we have worked on, it is clear that the entire section is
    pretty basic as it only allows us to create a single announcement.
  prefs: []
  type: TYPE_NORMAL
- en: We can include a few more text input options that we can use to create multiple
    announcements, but that would require us to manually edit the JSON code every
    time we need to include an additional announcement. *What if we're looking to
    create a section that would allow us to add any number of announcements, without
    modifying the JSON code every time we need to include an additional announcement?*
    For this, we can use the `blocks` attribute.
  prefs: []
  type: TYPE_NORMAL
- en: Building with blocks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `blocks` attribute is one of the most potent tools in Shopify. By using
    them, we can create modules that we can reuse any number of times and reorder
    the section content from within the theme editor. At this point, this might be
    confusing as it sounds similar to what we just learned about regarding dynamic
    sections. However, the key difference is that `blocks` sections allow us to reorder
    the content within the section, not the sections themselves, which allows us to
    create more complex features.
  prefs: []
  type: TYPE_NORMAL
- en: Additionally, we can combine the `blocks` attributes with static sections to
    create a dynamic section functionality that's similar to what we currently have
    on the home page, and then include it on any page. However, instead of rearranging
    sections, we will be rearranging the blocks.
  prefs: []
  type: TYPE_NORMAL
- en: The `blocks` attribute allows us to create different types of blocks using the
    object format, under which each object type will act as a unique module. Here,
    we can include a different set of input settings options under each of those modules.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are the steps for creating and using a `blocks` module:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s learn how to modify the previously created announcement bar section
    by introducing the `blocks` attribute. Additionally, we will remove certain features,
    such as translation keys and the `class` attributes, for the code to remain concise
    and readable:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, let''s learn how to include the previously mentioned `blocks` module attributes
    inside the section schema. Note that we will only show the code that''s inside
    the `blocks` attribute to keep the code concise and to the point:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now that we have all the necessary attributes in place, all we need to do is
    populate the `settings` attribute with the necessary input settings. Since we
    have already created the text and text color input settings, we can simply migrate
    the text input setting inside the `blocks` module:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Let's see what this looks like by navigating to the theme editor and clicking
    on the `settings` object:![Figure 7.3 – Example of a section inside the theme
    editor
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/Figure_7.03_B17606.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Figure 7.3 – Example of a section inside the theme editor
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Since we have only migrated the text input and left the text color input inside
    the section `settings` object, we can use it to style the text color of all the
    blocks at once. Let's click on the arrow to the left of the `blocks` module in
    action.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'We will notice that besides the **Add section** button, we also have an **Add
    Announcement** button under the **Announcement Bar** section that we created:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 7.4 – Example of a section block module'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '](img/Figure_7.04_B17606.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Figure 7.4 – Example of a section block module
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Clicking `settings` object, whereby clicking on the `blocks` module and immediately
    position us inside the block. Here, we can define the announcement text input.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'After defining all the inputs inside the `blocks` module''s object settings,
    we can click on the arrow on the left-hand side of the `blocks` modules. However,
    note that since we have introduced a `limit` attribute with a value of `3`, we
    can only repeat the **Announcement** block up to 3 times, as shown here:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 7.5 – Example of a limited number of section block modules'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_7.05_B17606.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 7.5 – Example of a limited number of section block modules
  prefs: []
  type: TYPE_NORMAL
- en: Once we have included the maximum number of modules, as per the defined value,
    the `blocks` modules. Similarly, as with the dynamic sections, hovering over the
    `blocks` modules will reveal two icons. These will allow us to hide the currently
    selected block or rearrange the block's order using the drag-and-drop feature.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have learned how to create and use a `blocks` module, we need to
    learn how to output the values of the `blocks` module''s input settings:'
  prefs: []
  type: TYPE_NORMAL
- en: 'We can access the `blocks` module''s object settings similar to how we accessed
    the `section` object: we will need to use a `section` object in combination with
    the `blocks` attribute. This combination of the `section` object and the `blocks`
    attribute will return an array of sections blocks that we can access using a simple
    `for` loop:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Once we have created the `for` loop, the only thing left to do is output the
    values of each block, as we did with the sections. The only difference is that
    this time, we will use the variable that we defined in the `for` loop instead
    of using the `sections` keyword:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: So far, we have learned how to create the entire section schema, through which
    we can create static and dynamic sections and build `blocks` modules. We have
    also learned how to output the values of both the `sections` and `blocks` modules'
    input settings. However, in the previous example, we only had one type of block;
    *what if we had multiple block types?*
  prefs: []
  type: TYPE_NORMAL
- en: 'The true power of section blocks is that we can create multiple `blocks` module
    types inside a single `section` element, which we can do by simply creating multiple
    section `blocks` objects with different type values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Note that all of the `name` and `type` attribute values need to be unique across
    the entire section, whereas the `id` attributes of the input settings only need
    to be unique inside a single block.
  prefs: []
  type: TYPE_NORMAL
- en: 'As we can see, creating multiple `blocks` module elements is relatively simple.
    While we have only created two simple `blocks` modules in our example, we can
    create any number of `blocks` modules that we can rearrange through the theme
    editor to create complex layouts:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.6 – Example of multiple blocks modules inside a section'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_7.6_B17606.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 7.6 – Example of multiple blocks modules inside a section
  prefs: []
  type: TYPE_NORMAL
- en: As we can see from our example, we have four different types of blocks (**Text**,
    **Collection**, **Image**, and **Video**) that we can use to create a layout that
    the store owners can easily configure, without having to modify the code themselves.
  prefs: []
  type: TYPE_NORMAL
- en: Previously, we learned how to loop over the array of blocks by using the `for`
    tags that `section.blocks` returns. However, if we have more than one `blocks`
    module type, we will need to introduce an additional step.
  prefs: []
  type: TYPE_NORMAL
- en: Suppose that, as in the preceding example, we had a section with four types
    of blocks. *How would we recognize the block types and know what layout we should
    output for which block?* To solve this problem, we can use the `block` object
    paired with the `type` attribute, which will allow us to recover the block type
    value.
  prefs: []
  type: TYPE_NORMAL
- en: For additional information on the `block` object, please refer to [https://shopify.dev/api/liquid/objects/block](https://shopify.dev/api/liquid/objects/block).
  prefs: []
  type: TYPE_NORMAL
- en: 'Once we have identified each block type, we can use an `if` statement or `case/when`
    control flow tags to execute the correct code for the respective value. Suppose
    we need to remind ourselves how to use statements or `case/when` control tags;
    we can revisit [*Chapter 3*](B17606_03_Final_PD_ePub.xhtml#_idTextAnchor047),
    *Diving into Liquid Code with Tags*, and consult the *Controlling the flow of
    Liquid* section for this, where we outlined the process of using control flow
    tags:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: In the previous example, we used the `case/when` control flow tags in combination
    with `block.type` to identify the types of blocks that we are currently looping
    over. After identifying the block type, we rendered the snippet file containing
    the correct layout for the respective block.
  prefs: []
  type: TYPE_NORMAL
- en: Note that we have passed the `block` object to each snippet. As you may recall,
    the snippet files are the only type of files that can access the variables defined
    in the parent directory. However, even the snippet files cannot automatically
    access these variables. Instead, we need to pass the values as parameters.
  prefs: []
  type: TYPE_NORMAL
- en: Suppose we need to remind ourselves how to pass values to snippet files; we
    can revisit [*Chapter 3*](B17606_03_Final_PD_ePub.xhtml#_idTextAnchor047), *Diving
    into Liquid Code with Tags*, and consult the *The render tag* section, located
    under the *Theme tags* section, where we outlined the process of working with
    snippet files.
  prefs: []
  type: TYPE_NORMAL
- en: Besides learning how to create `blocks` modules, we learned about the `limit`
    attribute, which we can use to limit how many times we can repeat a particular
    type of `blocks` module. This worked well when we had a single type block. *However,
    what if we wanted to create a limitation so that we can have a maximum number
    of any combination of blocks inside a section?*
  prefs: []
  type: TYPE_NORMAL
- en: The max_blocks attribute
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `max_blocks` attribute, similar to the `limit` attribute, allows us to
    limit how many `blocks` modules we can create inside a section. However, they
    have one significant difference: the `limit` attribute only allows us to limit
    the number of times we can repeat a particular block type, whereas the `max_blocks`
    attribute allows us to limit a specific section to a maximum number of any type
    of block.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Note that the `max_blocks` attribute is optional and only accepts number data
    as its value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: The most common use of the `max_blocks` attribute is inside the footer section.
    With it, the store owner can easily rearrange the blocks in any order, whether
    by repeating a single block five times or by using five different blocks, all
    while ensuring that the layout of the entire section maintains the proper flow.
  prefs: []
  type: TYPE_NORMAL
- en: Previously, we learned how to create `blocks` modules, as well as how to identify
    different types of block types and access each block object accordingly. Now that
    we have learned how we can use `max_blocks` to limit the number of products inside
    a section, we have all the necessary knowledge to build any type of `blocks` module.
  prefs: []
  type: TYPE_NORMAL
- en: As we saw, blocks are quite powerful and allow us to create anything from basic
    text features to complex layout features, intertwined with different types of
    blocks that store owners can use to tell the story of their products.
  prefs: []
  type: TYPE_NORMAL
- en: With that, we have learned about the differences between static sections, which
    we can manually embed on any page, and dynamic sections, which allow us to add
    any number of sections to the home page dynamically. However, as we mentioned
    at the beginning of this chapter, Shopify has recently provided us with the means
    to include sections on any page through JSON templates dynamically. By using JSON
    templates, we can combine the static and dynamic sections into a new feature that
    we can control from within the theme editor.
  prefs: []
  type: TYPE_NORMAL
- en: Enhancing pages with JSON templates
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In [*Chapter 1*](B17606_01_Final_PD_ePub.xhtml#_idTextAnchor015), *Getting Started
    with Shopify*, while discussing the theme structure, we briefly mentioned JSON
    templates, *but what exactly are they?*
  prefs: []
  type: TYPE_NORMAL
- en: The `.json` type templates generally have the same purpose as their counterpart
    `.liquid` templates, as they both allow us to create and manage the look of multiple
    pages through a single template. However, the significant difference between the
    two is that while the `.liquid` type template serves only as a markup file, the
    `.json` file serves as a data type file, which allows us to easily add, remove,
    or rearrange the sections on any page, similar to what we can do on the home page.
  prefs: []
  type: TYPE_NORMAL
- en: The `.json` type templates also share similarities with the `Section` directory
    files, where we need to include a valid schema setting inside the section file.
    The `.json` type template needs to be a valid `.json` file, with the JSON code
    defined inside the template. While we can create any number of `.json` type files,
    the template files' names must be unique in the `.liquid` or `.json` file. For
    example, if we create a `product.json` file template, we cannot create a `product.liquid`
    file as well.
  prefs: []
  type: TYPE_NORMAL
- en: Additionally, JSON files have one limitation. We can render a maximum of 20
    sections per template with up to 16 blocks per section, which is a reasonably
    high number, but we should probably rethink our page layout if we ever reach this
    limit.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have some general knowledge of what JSON type templates are and
    how they work, let's learn how to create our first JSON type file.
  prefs: []
  type: TYPE_NORMAL
- en: Building a JSON template structure
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Instead of simply listing the necessary attributes for creating the file, we
    will learn how to create a JSON template by migrating the current `product.liquid`
    type template into a JSON template.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s begin by creating a JSON-type template by opening the `Templates` directory
    and clicking the `alternate`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.7 – Example of creating a new JSON type template'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_7.07_B17606.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 7.7 – Example of creating a new JSON type template
  prefs: []
  type: TYPE_NORMAL
- en: Once we have created a new JSON file, Shopify will automatically redirect us
    to the newly created file. We will see an almost empty file containing only two
    attributes. So, let's start creating the necessary attributes and begin our migration
    process.
  prefs: []
  type: TYPE_NORMAL
- en: 'As we mentioned previously, a JSON template must be a valid JSON file whose
    root is an object that can contain some of the following attributes:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `name` attribute is a mandatory string type attribute where, as its name
    suggests, we can define the template''s name:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The `layout` attribute is an optional attribute that accepts two types of values,
    a string or false, depending on what we are trying to achieve. The string value
    should represent the name of the layout file, without the `.liquid` extension
    that we would like to use with this specific template. If you need to learn more
    about layout files, please revisit [*Chapter 3*](B17606_03_Final_PD_ePub.xhtml#_idTextAnchor047),
    *Diving into Liquid Core with Tags*, where we learned about `layout` tags in the
    *Theme tags* sections. Note that if we do not include the `layout` attribute,
    Shopify will default to the `theme.liquid` layout. However, for learning purposes,
    we will manually add and select the `theme` layout:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The `wrapper` attribute is a string type attribute that allows us to select
    the type of HTML wrapper we would like to include around each section inside the
    template. We can use the following HTML tags here:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`div`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`main`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`section`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Note that besides selecting the HTML wrapper''s type, we can also include any
    additional attributes that we may need, such as `class`, `id`, or `data`. Note
    that the `wrapper` attribute is entirely optional:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The `sections` attribute is a mandatory object type attribute that uses the
    names of the sections as keys and the `section` data as values. Inside the `sections`
    object, we can define which sections we would like to include inside our page:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '{'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '"name": "JSON product template",'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '"layout": "theme",'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '"wrapper": "div.product-wrapper[data-type=product]",'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '"sections": {'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'sections attribute uses the same format as the section attribute that we learned
    about previously, we will also need to include some additional attributes inside
    the sections object. For example, we will need to include the type attribute,
    whose value should have the name of the section we are looking to include, and
    if needed, the settings or blocks attribute:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '{'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '"name": "JSON product template",'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '"layout": "theme",'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '"wrapper": "div.product-wrapper[data-type=product]",'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '"sections": {'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '"main-block": {'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '"type": "name-of-the-section",'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '"settings": {'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: main and recommendations) are not preset values and that we can change their
    names to any values we like. When dealing with the `sections` object, there are
    three crucial things that we need to keep in mind:*   We need to have at least
    one block set inside the `sections` object.*   All block names must be unique
    across the entire `sections` object.*   The value of the `type` attribute needs
    to match the name of the section we are looking to include.By including the `main`
    and `recommendations` sections in our new JSON template, we have ensured that
    these two sections will always be visible inside the theme editor when previewing
    the page with the specific JSON type template assigned. However, while these sections
    are considered static, we can hide them and rearrange them, similar to dynamic
    sections.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE27]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The last attribute is the `order` attribute, which is a mandatory attribute.
    The `order` attribute is an array-type attribute. Here, we can include the IDs
    of the `sections` blocks that we previously set inside the `sections` object and
    arrange them:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: And with the `order` attribute in place, our JSON template is ready! Let's navigate
    to the theme editor and test it out.
  prefs: []
  type: TYPE_NORMAL
- en: 'To test the new product template, follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Navigate to **Products** from the admin dashboard.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on any product and then select the new template name from the **Template
    suffix** drop-down menu, which is located under the **Theme templates** area.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Important note:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The **Template suffix** drop-down menu can only read values from the current
    live theme. What this means is that the newly created template file will not be
    visible in our admin dashboard until we either publish or duplicate them live,
    or until we create the same template file within our currently live team. If we
    opt for the latter choice, note that we need to create the file with the same
    name; we do not have to make any changes to the file's content.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'However, with this new type of template, we also have a new way to preview
    templates. Note that the following method only allows us to preview the template.
    We still need to assign the template by navigating to the admin dashboard''s product
    page and selecting the template from inside the dropdown:'
  prefs: []
  type: TYPE_NORMAL
- en: Let's begin by navigating to the theme editor, clicking on the dropdown in the
    middle of the screen, and selecting the **product** option. This will show you
    the templates we currently have under the theme that we are currently working
    on. Let's select the new JSON type template that we created by clicking on it:![Figure
    7.8 – Example of selecting a template through the theme editor
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/Figure_7.08_B17606.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Figure 7.8 – Example of selecting a template through the theme editor
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Clicking on the **alternate** template will automatically redirect us to a random
    product, allowing us to preview the template that we have selected.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Important note:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Similar to the dynamic sections on the home page, only sections with preset
    attributes present inside the sections schema will be visible under the **Add
    section** dropdown.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'If we have done everything correctly, we should see two sections and the **Add
    section** button in the left sidebar:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 7.9 – Example of previewing the JSON type template inside the theme
    editor'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '](img/Figure_7.09_B17606.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Figure 7.9 – Example of previewing the JSON type template inside the theme editor
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Now, try and click on any of the two sections, update any settings, or add a
    new section through the `.json` type template we created by clicking on the **X**
    next to its name, and then open it again.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We will notice that **Shopify** has updated the template file and that it now
    contains all the settings and their values.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Since we can find all of the settings and their values inside the template file,
    if we assign the JSON template file to multiple products, they will use the layout
    with the same settings. If we wanted to create an additional JSON template that
    would allow us to create a different layout, we could manually create a new JSON
    template and copy the code or do this through the theme editor.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Let''s return to the theme editor, click on the dropdown in the middle of the
    screen, and select the **product** option. But this time, we will click on the
    **Create template** button, which will cause the following popup to appear:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 7.10 – Example of creating a new JSON type template through the theme
    editor'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_7.10_B17606.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 7.10 – Example of creating a new JSON type template through the theme
    editor
  prefs: []
  type: TYPE_NORMAL
- en: As we can see, inside the popup, we can easily set a new template name and select
    the JSON template whose content we should copy.
  prefs: []
  type: TYPE_NORMAL
- en: With that, we have learned how to create any number of templates for any number
    of pages, *but what if we wanted to use the same layout for multiple pages and
    only use different content for each page?* This is where metafields come to the
    rescue!
  prefs: []
  type: TYPE_NORMAL
- en: Upgrading a JSON template with metafields
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As you may recall from [*Chapter 4*](B17606_04_Final_PD_ePub.xhtml#_idTextAnchor079),
    *Diving into Liquid Core with Objects*, while going through the *Improving the
    workflow with metafields* section, we mentioned that Shopify has introduced a
    feature that allows us to use metafields without having to rely on third-party
    apps.
  prefs: []
  type: TYPE_NORMAL
- en: 'Besides allowing us to create metafields within the dashboard, Shopify has
    provided us with a whole new set of different types of metafields that we can
    create:'
  prefs: []
  type: TYPE_NORMAL
- en: Start by navigating to the **Settings** options inside our dashboard, located
    at the bottom-left corner of our screen, and click on the **Metafields** options.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Once inside, we will see that we have no metafields set and that we can only
    use products and variants metafields; the others are still pending. Let's proceed
    by clicking on the **Products** metafield link.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Considering that we have no metafields currently set, we can immediately click
    on the **Add definition** button. This will redirect us to a page where we can
    create a metafield definition. While most of the fields should be familiar from
    when you learned about metafields in [*Chapter 4*](B17606_04_Final_PD_ePub.xhtml#_idTextAnchor079),
    *Diving into Liquid Core with Objects*, we now have a new field. Let's click on
    the **Select content type** field, which will show us a dropdown containing all
    the available types of metafields we can create:![Figure 7.11 – Example of the
    available metafields type fields
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/Figure_7.11_B17606.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Figure 7.11 – Example of the available metafields type fields
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Note that each type of metafield will create a selector inside the dashboard
    of our product page. We can select the text input, which will automatically show
    us an additional set of settings. However, we won't be changing those now.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: After selecting the text type of the metafield, all we need to do is set its
    name. For our purposes, we will select one of the predefined metafield values
    by clicking on the **Name** field and selecting **Product subtitle**, which will
    automatically fill in all the other fields. Note that we will need to press the
    **Save** button to save the newly created metafield:![Figure 7.12 – Example of
    the metafields inside the product dashboard
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Figure 7.12 – Example of the metafields inside the product dashboard
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '](img/Figure_7.12_B17606.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Figure 7.12 – Example of the metafields inside the product dashboard
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Now that we have created a product metafield, let's click on the **Products**
    link located in the top-left corner of our admin dashboard and click on any product
    of our choosing. If we scroll down to the bottom of the page, we will notice that
    the metafield we created is now part of our product pages.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: As we can see, by simply creating a product metafield definition, we have automatically
    added the same metafield to every product, allowing us to update the metafield's
    values a lot easier than when using a third-party app. Let's update the metafield's
    value by adding any string value and pressing the **Save** button.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now, return to the theme editor, navigate to the JSON template, and find any
    text input type from the sections that we have available. For our purposes, we
    have added a new section named `Image with text`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Looking through this section, we will notice new icons next to specific types
    of fields:![](img/Figure_7.13_B17606.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Figure 7.13 – Example of the metafields icon inside the theme editor
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Clicking on the bottom icon next to the **Heading** text input will promptly
    show us a list of all the metafields that we can pull from this particular product.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Select the **Product subtitle** metafield that we selected previously and click
    the **Insert** button. This will automatically add the value of the selected metafield
    and output it in the input field that we have selected:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/Figure_7.14_B17606.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.14 – Example of the metafields icon inside the theme editor
  prefs: []
  type: TYPE_NORMAL
- en: With that, we have learned how to dynamically update the values of the sections
    settings by using metafields, without having to create a new JSON template for
    each product. The only thing we have to do now is create the proper layout by
    arranging the necessary sections inside the JSON template.
  prefs: []
  type: TYPE_NORMAL
- en: Note that by using metafields, we can update all kinds of inputs, such as images,
    URLs, or even color swatches. However, we should create an appropriate metafield
    to ensure that the metafield value and the input-type value match.
  prefs: []
  type: TYPE_NORMAL
- en: As we saw previously, sections alone are pretty powerful. Mixing sections with
    JSON templates and metafields makes them even more impressive. It allows merchants
    to easily configure each page differently, without having to create new templates
    for each page or manually inserting sections.
  prefs: []
  type: TYPE_NORMAL
- en: Besides what we have learned so far, we know that Shopify also provides us with
    some additional section-specific tags that we can use to create even more powerful
    elements.
  prefs: []
  type: TYPE_NORMAL
- en: Exploring section-specific tags
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: While we can easily define styling or include the JavaScript code inside the
    theme's respective asset files, Shopify provides us with three types of tags that
    we can use to include CSS and JavaScript directly in the section file.
  prefs: []
  type: TYPE_NORMAL
- en: The stylesheet tag
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Similar to the `schema` tag, the `stylesheet` tag is a Liquid tag that does
    not have any output on its own. It simply allows us to write CSS code inside the
    section files. Note that each section file can only contain a single `stylesheet`
    tag, which must stand on its own. It cannot be nested inside any other kind of
    Liquid tag:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: Although this might not look like a great idea at first, since we end up having
    CSS code spread over multiple files, Shopify will automatically collect all the
    CSS files from the different section files, combine them into one stylesheet file,
    and inject it into the theme file through the `content_for_header` global object.
  prefs: []
  type: TYPE_NORMAL
- en: 'Important note:'
  prefs: []
  type: TYPE_NORMAL
- en: The `stylesheet` tag only accepts CSS values. We cannot include Liquid code
    inside the tag.
  prefs: []
  type: TYPE_NORMAL
- en: Note that bundled assets are not section- or block-specific. For section- and
    block-specific stylesheets, we will need to use the `style` tag.
  prefs: []
  type: TYPE_NORMAL
- en: The style tag
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `style` tag works similarly to the `stylesheet` tag as it allows us to
    write CSS code directly into the section file. However, the `style` tag has two
    significant differences compared to the `stylesheet` tag:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The first difference is that the `style` tag is equal to using an HTML `<style>`
    tag, meaning that Shopify will not collect and bundle the CSS code that we included
    through the `style` tag. Instead, Shopify will render the HTML `style` tag and
    its content in the same place where we have included it:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The second and more important difference is that the `style` tag allows us
    to include Liquid code, which we can use to modify the CSS content by using the
    theme editor dynamically:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Note that as opposed to the input settings defined inside the `settings_schema.json`
    file, whose values can be accessed globally within any file, the section and block
    input values can only be accessed inside the section file itself or within the
    snippet file, after we pass the value as a parameter.
  prefs: []
  type: TYPE_NORMAL
- en: In the previous example, we saw how to output the section input values and use
    them to modify the CSS code dynamically. However, in our example, we have used
    a static class, meaning that the `background-color` CSS we applied will affect
    every single section and block similarly. *But what if we wanted to apply a different
    color to each section or block?*
  prefs: []
  type: TYPE_NORMAL
- en: 'To apply a unique styling to a specific element, we will need to use a `section`
    or `block` object, combined with the `id` attribute, to create a unique identifier
    that we can call later:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: Note that `section.id` will return a dynamically generated ID for dynamic sections
    and a section filename, without the Liquid extension for static sections. `block.id`
    will always return a dynamically generated ID.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have generated unique selectors, all we need to do is include the
    same selectors inside the `style` tag:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: Now that we know how to generate and call unique selectors, we can easily create
    different styling for both section and block elements. Note that it is also possible
    to include CSS with dynamic values in HTML using the `style` attribute.
  prefs: []
  type: TYPE_NORMAL
- en: The javascript tag
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `javascript` tag works in the same way as the `stylesheet` tag. The tag
    does not have any output on its own; it simply allows us to write JavaScript code
    directly inside the section files. We can only include a single `javascript` tag
    in a section, which must stand on its own, and it cannot be nested inside other
    Liquid tags:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: Similarly, as with the `stylesheet` tag, the `javascript` tag only accepts JavaScript
    code. We cannot include any Liquid code inside the tag. Additionally, Shopify
    will automatically bundle any code inside the `javascript` tag and inject it into
    the theme file through the `content_for_header` global object.
  prefs: []
  type: TYPE_NORMAL
- en: 'Since we cannot use Liquid code inside the `javascript` tag, one way to apply
    section-specific JavaScript would be to use data attributes, which will output
    the specific input value and recover the value with JavaScript later:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: Considering that bundled assets are not section- or block-specific, if we needed
    to create some section- or block-specific JavaScript code, we would need to use
    an HTML `<script>` tag. Note that currently, Shopify does not have a Liquid tag
    that accepts Liquid code.
  prefs: []
  type: TYPE_NORMAL
- en: 'With the HTML `<script>` tag, we can now write section- and block-specific
    JavaScript and directly include the input settings values. However, note that
    when directly including the input settings values inside the JavaScript, you should
    include the values with whitespace control to ensure no extra whitespaces are
    included:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: If you need to remind yourself how to use whitespace control, please revisit
    [*Chapter 2*](B17606_02_Final_PD_ePub.xhtml#_idTextAnchor030), *The Basic Flow
    of Liquid*, and consult the *Controlling whitespace* section, where we outlined
    the process of controlling whitespace.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we learned how to combine our previously attained knowledge
    of basic and specialized inputs with the section schema. This allows us to create
    everything from simple to complex layouts that we can easily configure throughout
    the theme editor.
  prefs: []
  type: TYPE_NORMAL
- en: By learning the difference between static and dynamic sections, we learned how
    to extend a section's functionality and make it accessible on any type of page.
    Additionally, besides learning how to create different types of sections, we have
    also gained knowledge of how to create different types of `blocks` modules, which
    will allow us to rearrange the layouts of a single section to make it easy to
    configure.
  prefs: []
  type: TYPE_NORMAL
- en: Lastly, we learned about the different types of section-specific tags that we
    can use to develop the content of the section further, as well as creating a unique
    experience for specific sections or even `blocks` modules.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will learn about what Shopify Ajax is and how we can
    utilize it to implement advanced functionalities and make a store more dynamic.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What is the main difference between the static and dynamic sections?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What object can we use to access the block input value? Write some code that
    will allow us to access the specific `blocks` module input value.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the difference between the `limit` and `max_blocks` attributes?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How can we apply section-specific CSS styling?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Practice makes perfect
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As with the projects in the previous chapters, this project will contain detailed
    information about what we need to do and the appropriate instructions to help
    you achieve the results.
  prefs: []
  type: TYPE_NORMAL
- en: We recommend working on each project independently from the previous chapters
    since this will ensure you have truly understood what you have learned so far.
  prefs: []
  type: TYPE_NORMAL
- en: Not a single project has a correct or incorrect solution. However, if by any
    chance you get stuck, you can always consult the project solution, which can be
    found at the end of this book.
  prefs: []
  type: TYPE_NORMAL
- en: Project 4
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'For our fourth project, we will work on creating a section schema with multiple
    block types. While we can include any number of block types, we should make sure
    to include the following types:'
  prefs: []
  type: TYPE_NORMAL
- en: The text type, which will render a single rich text input
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The product type, which will render a single product element with a product
    name, price, image, and link
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The list type, which will render a one-level navigation list configurable from
    the Navigation admin section
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The video type, which will render a video from either the YouTube or Vimeo video
    platform
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Here are the instructions for the assets:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new section file called `featured-content.liquid`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a separate snippet file for each section while also passing the proper
    object to each snippet.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The following are the instructions for this assignment:'
  prefs: []
  type: TYPE_NORMAL
- en: Include all the necessary attributes that we need for a dynamic section.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create the four block modules according to the specification provided.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Limit the video block type to a maximum of two repetitions, where all the other
    blocks should be limited to one occurrence.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The total number of blocks present at any time should not exceed four blocks.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We should configure each block's width separately by using the predefined drop-down
    values and apply the selected width to each block via a class, not by directly
    applying the value. The values are 100%, 50%, 33.33%, and 25%.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Only include the section or block-specific CSS inside the section file. We should
    include all other CSS stylings inside the theme's respective CSS file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Define the following input settings inside the section block settings for each
    snippet file: `font-size`, `font-family`, text `color`, and `background-color`.
    We should be able to select the font family from the Shopify `font` library.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a text input element inside the section, which we will use to define
    the H1 heading for the entire section. If the input field is empty, we should
    hide the h1 HTML element.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Migrate the entire project into a `.json` page type template.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
