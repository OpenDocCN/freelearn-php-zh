<html><head></head><body>
<div class="book" title="Chapter&#xA0;3.&#xA0;Writing a Reddit Reader with RxPHP"><div class="book" id="VF2I2-bd355a22cf10407cb10df27e65585b8d"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch03" class="calibre1"/>Chapter 3. Writing a Reddit Reader with RxPHP</h1></div></div></div><p class="calibre8">In previous chapters, we talked a lot about asynchronous programming in PHP and how this relates to reactive programming, in particular, how to start using RxPHP, and how to use common PHP functions such as <code class="literal">proc_open()</code> and <code class="literal">cURL</code> asynchronously.</p><p class="calibre8">This chapter will cover writing a CLI Reddit reader app using RxPHP, Symfony Console, and Symfony Process components. We're also going to use most of what we've learned in the previous chapter:</p><div class="book"><ul class="itemizedlist"><li class="listitem">We'll look in more depth into what happens internally when creating Observable chains and subscribing to Observables.</li><li class="listitem">We'll see how Disposables are used in the default classes that come with RxPHP, and how these are going to be useful for unsubscribing from Observables in our app.</li><li class="listitem">Subjects can sometimes simplify our lives when working with operator chains.</li><li class="listitem">How to use <code class="literal">Observable::create()</code> and <code class="literal">Observable::defer()</code> static methods to create new Observables with custom logic on subscription.</li><li class="listitem">Symfony Console library is going to be our tool of choice for most CLI interactions throughout this book. Before we start using it, we'll have a quick look at what its practical benefits are.</li><li class="listitem">The event loop from the previous chapter is going to be the center of our app. We're going to use it to make the app responsive (we could also say, reactive) at any given time.</li><li class="listitem">To easily work with subprocesses, we'll use Symfony Process component, which handles all the heavy work related to managing subprocesses for us.</li><li class="listitem">We'll use non-blocking stream handling we've seen already in practice, in combination with input from terminal and output from a subprocesses.</li><li class="listitem">We'll list disposable classes provided by RxPHP.</li></ul></div><p class="calibre8">Before we dive in, now is a good time to have a closer look at the internal functionality of RxPHP, which hasn't been very important thus far. Nonetheless, this knowledge is going to be crucial in this and most of the upcoming chapters.</p></div>

<div class="book" title="Chapter&#xA0;3.&#xA0;Writing a Reddit Reader with RxPHP">
<div class="book" title="Examining RxPHP's internals"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_1"><a id="ch03lvl1sec25" class="calibre1"/>Examining RxPHP's internals</h1></div></div></div><p class="calibre8">In the previous chapter, we briefly mentioned disposables as a means for releasing resources used by observers, Observables, Subjects, and so on. In practice, a disposable is returned, for example, when subscribing to an Observable. Consider the following code from the default <code class="literal">Rx\Observable::subscribe()</code> method:</p><pre class="programlisting">function subscribe(ObserverI $observer, $scheduler = null) { 
    $this-&gt;observers[] = $observer; 
    $this-&gt;started = true; 
 
    return new CallbackDisposable(function () use ($observer) { 
        $this-&gt;removeObserver($observer); 
    }); 
} 
</pre><p class="calibre8">This method first adds the observer to the array of all subscribed observers. It then marks this Observable as started (remember the difference between "cold" and "hot" Observables from <a class="calibre1" title="Chapter 2. Reactive Programming with RxPHP" href="part0024_split_000.html#MSDG2-bd355a22cf10407cb10df27e65585b8d">Chapter 2</a>, <span class="strong"><em class="calibre18">Reactive Programming with RxPHP</em></span>) and, at the end, it returns a new instance of the <code class="literal">CallbackDisposable</code> class. This class takes a Closure as an argument and invokes it when it's disposed. This is probably the most common use case for disposables.</p><p class="calibre8">This disposable just removes the observer from the array, and therefore, it receives no more values emitted from this Observable.</p></div></div>

<div class="book" title="Chapter&#xA0;3.&#xA0;Writing a Reddit Reader with RxPHP">
<div class="book" title="Examining RxPHP's internals">
<div class="book" title="A closer look at subscribing to Observables"><div class="book"><div class="book"><div class="book"><h2 class="title2" id="calibre_pb_2"><a id="ch03lvl2sec24" class="calibre1"/>A closer look at subscribing to Observables</h2></div></div></div><p class="calibre8">It should be obvious that Observables need to work in such a way that all their subscribed observers can be iterated. Then, unsubscribing via a disposable will need to remove one particular observer from the array of all subscribed observers.</p><p class="calibre8">However, if we have a look at how most of the default Observables work, we find out that they always override the <code class="literal">Observable::subscribe()</code> method and usually completely omit the part where it should hold an array of subscribers. Instead, they just emit all available values to the subscribed observer and finish with the <code class="literal">onComplete()</code> signal immediately after that. For example, we can have a look at the actual source code of the <code class="literal">subscribe()</code> method of the <code class="literal">Rx\ReturnObservable</code> class in RxPP 1:</p><pre class="programlisting">function subscribe(ObserverI $obs, SchedulerI $sched = null) { 
    $value = $this-&gt;value; 
    $scheduler = $scheduler ?: new ImmediateScheduler(); 
    $disp = new CompositeDisposable(); 
 
    $disp-&gt;add($scheduler-&gt;schedule(function() use ($obs, $val) { 
        $obs-&gt;onNext($val); 
    })); 
    $disp-&gt;add($scheduler-&gt;schedule(function() use ($obs) { 
        $obs-&gt;onCompleted(); 
    })); 
 
    return $disp; 
} 
</pre><p class="calibre8">The <code class="literal">ReturnObservable</code> class takes a single value in its constructor and emits this value to every observer as they subscribe.</p><p class="calibre8">The following is a nice example of how the lifecycle of an Observable might look:</p><div class="book"><ul class="itemizedlist"><li class="listitem">When an observer subscribes, it checks whether a Scheduler was also passed as an argument. Usually, it's not, so it creates an instance of<code class="literal">ImmediateScheduler</code>. Note that in RxPHP 2 the Scheduler can be set only in the class constructor.</li><li class="listitem">Then, an instance of <code class="literal">CompositeDisposable</code> is created, which is going to keep an array of all disposables used by this method. When calling <code class="literal">CompositeDisposable::dispose()</code>, it iterates all disposables it contains and calls their respective <code class="literal">dispose()</code> methods.</li><li class="listitem">Right after that, we start populating our <code class="literal">CompositeDisposable</code> with the following:</li></ul></div><pre class="programlisting">        $disposable-&gt;add($scheduler-&gt;schedule(function() { ... })); 
</pre><div class="book"><ul class="itemizedlist"><li class="listitem">This is something we'll see very often. The  <code class="literal">SchedulerInterface::schedule()</code> method returns a <code class="literal">DisposableInterface</code>, which is responsible for canceling the action and releasing resources. In this case, when we're using <code class="literal">ImmediateScheduler</code>, which has no other logic, it just evaluates the Closure immediately:</li></ul></div><pre class="programlisting">        function () use ($obs, $val) { 
            $observer-&gt;onNext($val); 
        } 
</pre><div class="book"><ul class="itemizedlist"><li class="listitem">Since <code class="literal">ImmediateScheduler::schedule()</code> doesn't need to release any resources (it didn't use any), it just returns an instance of <code class="literal">Rx\Disposable\EmptyDisposable</code> that does literally nothing.</li><li class="listitem">Then the disposable is returned, and could be used to unsubscribe from this Observable. However, as we saw in the preceding source code, this Observable doesn't let you unsubscribe, and if we think about it, it doesn't even make sense because <code class="literal">ReturnObservable</code> class's value is emitted immediately on subscription.</li></ul></div><p class="calibre8">The same applies to other similar <code class="literal">Observables</code>, such as <code class="literal">IteratorObservable</code>, <code class="literal">RangeObservable</code> or <code class="literal">ArrayObservable</code>. These just contain recursive calls with Schedulers, but the principle is the same.</p><p class="calibre8">A good question is, why on Earth is this so complicated? All the preceding code does could be stripped into the following three lines (assuming we're not interested in using Schedulers):</p><pre class="programlisting">function subscribe(ObserverI $observer) { 
    $observer-&gt;onNext($this-&gt;value); 
    $observer-&gt;onCompleted(); 
} 
</pre><p class="calibre8">Well, for <code class="literal">ReturnObservable</code> this might be true, but in real applications, we very rarely use any of these primitive Observables. Another very important use case for Schedulers is testing. We can provide a test Scheduler that simulates delayed execution, to make sure our Observables and operators emit values in the correct order. We'll go into this topic in depth in <a class="calibre1" title="Chapter 5. Testing RxPHP Code" href="part0043_split_000.html#190861-bd355a22cf10407cb10df27e65585b8d">Chapter 5</a>, <span class="strong"><em class="calibre18">Testing RxPHP Code</em></span>.</p><p class="calibre8">The ability to unsubscribe from Observables or clean up any resources when unsubscribing is very important, and we'll use it in a few moments.</p><div class="book" title="Emitting multiple values with Schedulers"><div class="book"><div class="book"><div class="book"><h3 class="title1"><a id="ch03lvl3sec8" class="calibre1"/>Emitting multiple values with Schedulers</h3></div></div></div><p class="calibre8">We've seen how to use <code class="literal">RangeObservable</code> already. Now, when we know why using <code class="literal">Scheduler-&gt;schedule()</code> is important, we can for tutorial purposes think about how we could implement <code class="literal">RangeObservable</code> Observable's functionality ourselves.</p><p class="calibre8">For example, it could look like the following:</p><pre class="programlisting">// custom_range_01.php 
use Rx\Observable; 
use Rx\ObserverInterface; 
 
class CustomRangeObservable extends Observable { 
  private $min; 
  private $max; 
 
  public function __construct($min, $max) { 
    $this-&gt;min = $min; 
    $this-&gt;max = $max; 
  } 
 
  public function subscribe($observer, $sched = null) { 
    if (null === $sched) { 
      $sched = new \Rx\Scheduler\ImmediateScheduler(); 
    } 
 
    return $sched-&gt;schedule(function() use ($observer) { 
      for ($i = $this-&gt;min; $i &lt;= $this-&gt;max; $i++) { 
        $observer-&gt;onNext($i); 
      } 
      $observer-&gt;onCompleted(); 
    }); 
  } 
} 
 
(new CustomRangeObservable(1, 5)) 
    -&gt;subscribe(new DebugSubject()); 
</pre><p class="calibre8">When we run this example, we'll see that it produces the correct results:</p><pre class="programlisting">
<span class="strong"><strong class="calibre17">$ php custom_range_01.php</strong></span>
<span class="strong"><strong class="calibre17">1</strong></span>
<span class="strong"><strong class="calibre17">2</strong></span>
<span class="strong"><strong class="calibre17">3</strong></span>
<span class="strong"><strong class="calibre17">4</strong></span>
<span class="strong"><strong class="calibre17">5</strong></span>
</pre><p class="calibre8">However, the original <code class="literal">RangeObservable</code> has one interesting feature. It's able to unsubscribe inside the loop, which means that we can stop generating values any time we want.</p><p class="calibre8">Consider the following example, where we unsubscribe inside the observer's callable:</p><pre class="programlisting">// range_01.php 
use Rx\Observable; 
use Rx\Scheduler\EventLoopScheduler; 
use React\EventLoop\StreamSelectLoop; 
 
$loop = new StreamSelectLoop(); 
$scheduler = new EventLoopScheduler($loop); 
 
$disposable = Observable::range(1, 5) 
    -&gt;subscribeCallback(function($val) use (&amp;$disposable) { 
        echo "$val\n"; 
        if ($val == 3) { 
            $disposable-&gt;dispose(); 
        } 
    }, null, null, $scheduler); 
 
$scheduler-&gt;start(); 
</pre><p class="calibre8">This example emits only the first three values and then unsubscribes using <code class="literal">$disposable-&gt;dispose()</code>.</p><div class="informaltable" title="Note"><h3 class="title1"><a id="note16" class="calibre1"/>Note</h3><p class="calibre8">We had to use an asynchronous <code class="literal">EventLoopScheduler</code>, because we want to start executing scheduled actions after we subscribe. With <code class="literal">EventLoopScheduler</code>, the execution starts by calling <code class="literal">$scheduler-&gt;start()</code>. If we use the default <code class="literal">ImmediateScheduler</code>, then the <code class="literal">$disposable</code> variable will always be null (unassigned), because all the scheduled actions would be executed inside <code class="literal">subscribeCallback()</code> method and the <code class="literal">$disposable</code> variable will never be assigned.</p></div><p class="calibre8">When we run this demo we'll see just the first three numbers:</p><pre class="programlisting">
<span class="strong"><strong class="calibre17">$ php range_01.php </strong></span>
<span class="strong"><strong class="calibre17">1</strong></span>
<span class="strong"><strong class="calibre17">2</strong></span>
<span class="strong"><strong class="calibre17">3</strong></span>
</pre><p class="calibre8">If we try the same with our <code class="literal">CustomRangeObservable</code> we've just created, we'll see that it doesn't unsubscribe and we always receive all values. To deal with such use cases, Scheduler has a <code class="literal">scheduleRecursive()</code> method that behaves just like <code class="literal">schedule()</code> but its callable takes one argument, which is a callable itself to reschedule another emission.</p><p class="calibre8">In practice, we can rewrite <code class="literal">CustomRangeObservable::subscribe()</code> method to use <code class="literal">scheduleRecursive()</code> instead of <code class="literal">schedule()</code>:</p><pre class="programlisting">public function subscribe($observer, $sched = null) { 
  if (null === $sched) { 
    $sched = new \Rx\Scheduler\ImmediateScheduler(); 
  } 
  $i = $this-&gt;min; 
 
  return $sched-&gt;scheduleRecursive( 
      function($reschedule) use ($observer, &amp;$i) { 
    if ($i &lt;= $this-&gt;max) { 
      $observer-&gt;onNext($i); 
      $i++; 
      $reschedule(); 
    } else { 
      $observer-&gt;onCompleted(); 
    } 
  }); 
} 
</pre><p class="calibre8">Notice that we're not creating any loops ourselves and we let <code class="literal">$reschedule()</code> recursively call itself. Now we can properly call <code class="literal">dispose()</code> on the disposable object returned from <code class="literal">$sched-&gt;scheduleRecursive()</code> to stop scheduling more actions. We can test this with the same scenario as we used with <code class="literal">RangeObservable</code>:</p><pre class="programlisting">// php custom_range_02.php 
$loop = new StreamSelectLoop(); 
$scheduler = new EventLoopScheduler($loop); 
 
$disposable = (new CustomRangeObservable(1, 5)) 
    -&gt;subscribeCallback(function($val) use (&amp;$disposable) { 
        echo "$val\n"; 
        if ($val == 3) { 
            $disposable-&gt;dispose(); 
        } 
    }, null, null, $scheduler); 
 
$scheduler-&gt;start(); 
</pre><p class="calibre8">Now it prints only the first three numbers:</p><pre class="programlisting">
<span class="strong"><strong class="calibre17">$ php custom_range_02.php </strong></span>
<span class="strong"><strong class="calibre17">1</strong></span>
<span class="strong"><strong class="calibre17">2</strong></span>
<span class="strong"><strong class="calibre17">3</strong></span>
</pre></div></div></div></div>

<div class="book" title="Chapter&#xA0;3.&#xA0;Writing a Reddit Reader with RxPHP">
<div class="book" title="Examining RxPHP's internals">
<div class="book" title="A closer look at operator chains"><div class="book"><div class="book"><div class="book"><h2 class="title2" id="calibre_pb_3"><a id="ch03lvl2sec25" class="calibre1"/>A closer look at operator chains</h2></div></div></div><p class="calibre8">We already used operator chains in the previous chapter. Before we start writing our Reddit reader, we should talk briefly about an interesting situation that might occur, so that it doesn't catch us unprepared later.</p><p class="calibre8">We're also going to introduce a new type of Observable, called <code class="literal">ConnectableObservable</code>. Consider this simple operator chain with two subscribers:</p><pre class="programlisting">// rxphp_filter_observables_01.php 
use Rx\Observable\RangeObservable; 
use Rx\Observable\ConnectableObservable; 
 
$connObs = new ConnectableObservable(new RangeObservable(0, 6)); 
$filteredObs = $connObs 
    -&gt;map(function($val) { 
        return $val ** 2; 
    }) 
    -&gt;filter(function($val) { 
        return $val % 2; 
    }); 
 
$disposable1 = $filteredObs-&gt;subscribeCallback(function($val) { 
    echo "S1: ${val}\n"; 
}); 
$disposable2 = $filteredObs-&gt;subscribeCallback(function($val) { 
    echo "S2: ${val}\n"; 
}); 
 
$connObs-&gt;connect(); 
</pre><p class="calibre8">The <code class="literal">ConnectableObservable</code> class is a special type of Observable that behaves similarly to the Subject (in fact, internally, it really uses an instance of the <code class="literal">Subject</code> class). Any other Observable emits all available values right after you subscribe to it. However, 
<code class="literal">ConnectableObservable</code> takes another Observable (the source Observable) as an argument and lets you subscribe observers to it without emitting anything. When you call 
<code class="literal">ConnectableObservable::connect()</code>, it subscribes to the source Observables, and all values go one by one to all subscribers.</p><p class="calibre8">Internally, it contains an instance of the <code class="literal">Subject</code> class, and when we called
the <code class="literal">subscribe()</code> method, it just subscribed each observer to its internal Subject. Then when we called the <code class="literal">connect()</code> method, it subscribed the internal Subject to the source Observable.</p><p class="calibre8">In the <code class="literal">$filteredObs</code> variable we keep a reference to the Observable returned from <code class="literal">filter()</code> operator, which is an instance of <code class="literal">AnnonymousObservable</code> where, on the next few lines, we subscribe both observers.</p><p class="calibre8">Now, let's see what this operator chain prints:</p><pre class="programlisting">$ php rxphp_filter_observables_01.php 
S1: 1 
S2: 1 
S1: 9 
S2: 9 
S1: 25 
S2: 25 
</pre><p class="calibre8">As we can see, all values went through both observers in the order they were emitted. Just out of curiosity, we can also have a look at what would happen if we didn't use <code class="literal">ConnectableObservable</code>, and used just the <code class="literal">RangeObservable</code> instead:</p><pre class="programlisting">$ php rxphp_filter_observables_02.php 
S1: 1 
S1: 9 
S1: 25 
S2: 1 
S2: 9 
S2: 25 
</pre><p class="calibre8">This time, <code class="literal">RangeObservable</code> emitted all values to the first observer and then, again, all values to the second observer. We can see that the source Observable had to generate all the values twice, which is inefficient, and with a large dataset, this might cause a performance bottleneck.</p><div class="book" title="Subscribing to ConnectableObservable"><div class="book"><div class="book"><div class="book"><h3 class="title1"><a id="ch03lvl3sec9" class="calibre1"/>Subscribing to ConnectableObservable</h3></div></div></div><p class="calibre8">Let's go back to the first example with <code class="literal">ConnectableObservable</code>, and modify the <code class="literal">filter()</code> call so it prints all the values that go through:</p><pre class="programlisting">$filteredObservable = $connObservable 
    -&gt;map(function($val) { 
        return $val ** 2; 
    }) 
    -&gt;filter(function($val) { 
        echo "Filter: $val\n"; 
        return $val % 2; 
    }); 
</pre><p class="calibre8">Now we run the code again and see what happens:</p><pre class="programlisting">
<span class="strong"><strong class="calibre17">$ php rxphp_filter_observables_03.php</strong></span>
<span class="strong"><strong class="calibre17">Filter: 0</strong></span>
<span class="strong"><strong class="calibre17">Filter: 0</strong></span>
<span class="strong"><strong class="calibre17">Filter: 1</strong></span>
<span class="strong"><strong class="calibre17">S1: 1</strong></span>
<span class="strong"><strong class="calibre17">Filter: 1</strong></span>
<span class="strong"><strong class="calibre17">S2: 1</strong></span>
<span class="strong"><strong class="calibre17">Filter: 4</strong></span>
<span class="strong"><strong class="calibre17">Filter: 4</strong></span>
<span class="strong"><strong class="calibre17">Filter: 9</strong></span>
<span class="strong"><strong class="calibre17">S1: 9</strong></span>
<span class="strong"><strong class="calibre17">Filter: 9</strong></span>
<span class="strong"><strong class="calibre17">S2: 9</strong></span>
<span class="strong"><strong class="calibre17">Filter: 16</strong></span>
<span class="strong"><strong class="calibre17">Filter: 16</strong></span>
<span class="strong"><strong class="calibre17">Filter: 25</strong></span>
<span class="strong"><strong class="calibre17">S1: 25</strong></span>
<span class="strong"><strong class="calibre17">Filter: 25</strong></span>
<span class="strong"><strong class="calibre17">S2: 25</strong></span>
</pre><p class="calibre8">Well, this is unexpected! Each value is printed twice, even though we're using <code class="literal">ConnectableObservable</code>. This doesn't always mean that the Observable has to generate all the values twice, however (as we'll see in <a class="calibre1" title="Chapter 8. Multicasting in RxPHP and PHP7 pthreads Extension" href="part0061_split_000.html#1Q5IA1-bd355a22cf10407cb10df27e65585b8d">Chapter 8</a>, <span class="strong"><em class="calibre18">Multicasting in RxPHP and PHP7 pthreads Extension</em></span>). It's not obvious at first sight what happened, but the problem is that we subscribed to the Observable at the end of the operator chain.</p><p class="calibre8">As stated previously, <code class="literal">$filteredObservable</code> is an instance of <code class="literal">AnnonymousObservable</code> that holds many nested Closures. By calling its <code class="literal">subscribe()</code> method, it runs a Closure that's created by its predecessor, and so on. This leads to the fact that every call to <code class="literal">subscribe()</code> has to invoke the entire chain. While this might not be an issue in many use cases, there are situations where we might want to do a special operation inside one of the filters.</p><p class="calibre8">The operator chain for this example looks like the following diagram, where each subscription is represented by an arrow:</p><p class="calibre8">
</p><div class="mediaobject"><img src="../images/00010.jpeg" alt="Subscribing to ConnectableObservable" class="calibre19"/></div><p class="calibre20"> </p><p class="calibre8">
</p><p class="calibre8">The most important consequence of all this is that neither operators nor <code class="literal">AnnonymousObservable</code> class share values that go through them. In fact, none of them keep track of subscribed observers either.</p><p class="calibre8">Also, note that calls to the <code class="literal">subscribe()</code> method might be out of our control, performed by another developer who wanted to use an Observable we created for them.</p><p class="calibre8">It's good to know that such a situation might occur and could lead to unwanted behavior.</p><div class="informaltable" title="Note"><h3 class="title1"><a id="note17" class="calibre1"/>Note</h3><p class="calibre8">It's sometimes hard to see what's going on inside Observables. It's very easy to get lost, especially when we have to deal with multiple nested Closures in PHP. Schedulers are prime examples. Feel free to experiment with the examples shown here and use debugger to examine step-by-step what code gets executed and in what order.</p></div><p class="calibre8">So, let's figure out how to fix this. One way could be restructuring our code where we'll turn <code class="literal">$filteredObservable</code> into <code class="literal">ConnectableObservable</code> and not <code class="literal">RangeObservable</code> directly. Consider the following code:</p><pre class="programlisting">// rxphp_filter_observables_04.php 
$source = new RangeObservable(0, 6); 
$filteredObservable = $source 
    -&gt;map(function($val) { 
        return $val ** 2; 
    }) 
    -&gt;filter(function($val) { 
        echo "Filter: $val\n"; 
        return $val % 2; 
    }); 
 
$connObs = new ConnectableObservable($filteredObservable); 
 
$disposable1 = $connObs-&gt;subscribeCallback(function($val) { 
    echo "S1: ${val}\n"; 
}); 
$disposable2 = $connObs-&gt;subscribeCallback(function($val) { 
    echo "S2: ${val}\n"; 
}); 
$connObs-&gt;connect(); 
</pre><p class="calibre8">When we run this code, we can see the <code class="literal">filter()</code> operator is called just once for each value:</p><pre class="programlisting">
<span class="strong"><strong class="calibre17">$ php rxphp_filter_observables_04.php </strong></span>
<span class="strong"><strong class="calibre17">Filter: 0</strong></span>
<span class="strong"><strong class="calibre17">Filter: 1</strong></span>
<span class="strong"><strong class="calibre17">S1: 1</strong></span>
<span class="strong"><strong class="calibre17">S2: 1</strong></span>
<span class="strong"><strong class="calibre17">Filter: 4</strong></span>
<span class="strong"><strong class="calibre17">Filter: 9</strong></span>
<span class="strong"><strong class="calibre17">S1: 9</strong></span>
<span class="strong"><strong class="calibre17">S2: 9</strong></span>
<span class="strong"><strong class="calibre17">Filter: 16</strong></span>
<span class="strong"><strong class="calibre17">Filter: 25</strong></span>
<span class="strong"><strong class="calibre17">S1: 25</strong></span>
<span class="strong"><strong class="calibre17">S2: 25</strong></span>
</pre><p class="calibre8">To better understand what is different to the previous example, we can have a look at a diagram representing this operator chain:</p><p class="calibre8">
</p><div class="mediaobject"><img src="../images/00011.jpeg" alt="Subscribing to ConnectableObservable" class="calibre19"/></div><p class="calibre20"> </p><p class="calibre8">
</p><p class="calibre8">We can see that the <code class="literal">ConnectableObservable</code> was moved down the chain and it subscribes to the <code class="literal">filter()</code> operator instead of <code class="literal">RangeObservable</code>.</p></div><div class="book" title="Using Subject instead of ConnectableObservable"><div class="book"><div class="book"><div class="book"><h3 class="title1"><a id="ch03lvl3sec10" class="calibre1"/>Using Subject instead of ConnectableObservable</h3></div></div></div><p class="calibre8">We said we don't want to subscribe at the end of the chain multiple times, so we can create an instance of <code class="literal">Subject</code> class, where we'll subscribe both observers, and the <code class="literal">Subject</code> class itself will subscribe to the <code class="literal">$filteredObservable</code>, as discussed a moment ago:</p><pre class="programlisting">// rxphp_filter_observables_05.php 
use Rx\Subject\Subject; 
 
$subject = new Subject(); 
$source = new RangeObservable(0, 6); 
$filteredObservable = $source 
    -&gt;map(function($val) { 
        return $val ** 2; 
    }) 
    -&gt;filter(function($val) { 
        echo "Filter: $val\n"; 
        return $val % 2; 
    }) 
    -&gt;subscribe($subject); 
 
$disposable1 = $subject-&gt;subscribeCallback(function($val) { 
    echo "S1: ${val}\n"; 
}); 
$disposable2 = $subject-&gt;subscribeCallback(function($val) { 
    echo "S2: ${val}\n"; 
}); 
$filteredObservable-&gt;subscribe($subject); 
</pre><p class="calibre8">We can run the script and see that it returns exactly the same output as the previous example:</p><pre class="programlisting">
<span class="strong"><strong class="calibre17">$ php rxphp_filter_observables_05.php</strong></span>
<span class="strong"><strong class="calibre17">Filter: 0</strong></span>
<span class="strong"><strong class="calibre17">Filter: 1</strong></span>
<span class="strong"><strong class="calibre17">S1: 1</strong></span>
<span class="strong"><strong class="calibre17">S2: 1</strong></span>
<span class="strong"><strong class="calibre17">Filter: 4</strong></span>
<span class="strong"><strong class="calibre17">Filter: 9</strong></span>
<span class="strong"><strong class="calibre17">S1: 9</strong></span>
<span class="strong"><strong class="calibre17">S2: 9</strong></span>
<span class="strong"><strong class="calibre17">Filter: 16</strong></span>
<span class="strong"><strong class="calibre17">Filter: 25</strong></span>
<span class="strong"><strong class="calibre17">S1: 25</strong></span>
<span class="strong"><strong class="calibre17">S2: 25</strong></span>
</pre><p class="calibre8">This might look like an edge case, but soon we'll see that this issue, left unhandled, could lead to some very unpredictable behavior. We'll bring out both these issues (proper usage of disposables and operator chains) when we start writing our Reddit reader.</p></div></div></div></div>

<div class="book" title="Observable::create() and Observable::defer()" id="10DJ41-bd355a22cf10407cb10df27e65585b8d"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch03lvl1sec26" class="calibre1"/>Observable::create() and Observable::defer()</h1></div></div></div><p class="calibre8">We know how to create Observables using <code class="literal">ReturnObservable</code> or <code class="literal">RangeObservable</code>. We've also written a custom <code class="literal">CURLObservable</code> as well. However, in some situations we might want to create an Observable with some custom logic that isn't easily reproducible with already existing Observable classes. Of course, we could write another Observable inheriting the base Observable class, but if we need to deal with a very specific, single use-case scenario, there's an easier way with static methods <code class="literal">Observable::create()</code> and <code class="literal">Observable::defer()</code>.</p></div>

<div class="book" title="Observable::create() and Observable::defer()" id="10DJ41-bd355a22cf10407cb10df27e65585b8d">
<div class="book" title="Creating Observables with Observable::create()"><div class="book"><div class="book"><div class="book"><h2 class="title2" id="calibre_pb_1"><a id="ch03lvl2sec26" class="calibre1"/>Creating Observables with Observable::create()</h2></div></div></div><p class="calibre8">With <code class="literal">Observable::create()</code>, we can create an Observable that automatically pushes values into each of its observers on subscription. Consider the following example:</p><pre class="programlisting">// observable_create_01.php 
use Rx\Observable; 
use Rx\ObserverInterface; 
 
$source = Observable::create(function(ObserverInterface $obs) { 
    echo "Observable::create\n"; 
    $obs-&gt;onNext(1); 
    $obs-&gt;onNext('Hello, World!'); 
    $obs-&gt;onNext(2); 
    $obs-&gt;onCompleted(); 
}); 
 
$source-&gt;subscribe(new DebugSubject()); 
$source-&gt;subscribe(new DebugSubject()); 
</pre><p class="calibre8">The callable passed to <code class="literal">Observable::create()</code> takes as a parameter an observer where it can immediately start emitting values. It's important to remember that this callable is going to be called for each observer. This example prints the following output:</p><pre class="programlisting">
<span class="strong"><strong class="calibre17">$ php observable_create_01.php</strong></span>
<span class="strong"><strong class="calibre17">Observable::create</strong></span>
<span class="strong"><strong class="calibre17">21:00:52 [] onNext: 1 (integer)</strong></span>
<span class="strong"><strong class="calibre17">21:00:52 [] onNext: Hello, World! (string)</strong></span>
<span class="strong"><strong class="calibre17">21:00:52 [] onNext: 2 (integer)</strong></span>
<span class="strong"><strong class="calibre17">21:00:52 [] onCompleted</strong></span>
<span class="strong"><strong class="calibre17">Observable::create</strong></span>
<span class="strong"><strong class="calibre17">21:00:52 [] onNext: 1 (integer)</strong></span>
<span class="strong"><strong class="calibre17">21:00:52 [] onNext: Hello, World! (string)</strong></span>
<span class="strong"><strong class="calibre17">21:00:52 [] onNext: 2 (integer)</strong></span>
<span class="strong"><strong class="calibre17">21:00:52 [] onCompleted</strong></span>
</pre><p class="calibre8">Notice that string <code class="literal">Observable::create</code> is printed twice. Also, notice we called <code class="literal">onCompleted</code> ourselves to properly complete the Observable.</p><p class="calibre8">The callable can optionally return an instance of <code class="literal">Rx\DisposableInterface</code> that'll be disposed when unsubscribing/completing the Observable. We can modify the same example to return an instance of <code class="literal">CallbackDisposable</code>:</p><pre class="programlisting">$source = Observable::create(function(ObserverInterface $obs) { 
    ... 
    return new CallbackDisposable(function() { 
        echo "disposed\n"; 
    }); 
}); 
</pre><p class="calibre8">Now each <code class="literal">CallbackDisposable</code> will be called to properly cleanup resources for each observer.</p></div></div>

<div class="book" title="Observable::create() and Observable::defer()" id="10DJ41-bd355a22cf10407cb10df27e65585b8d">
<div class="book" title="Creating Observables with Observable::defer()"><div class="book"><div class="book"><div class="book"><h2 class="title2" id="calibre_pb_2"><a id="ch03lvl2sec27" class="calibre1"/>Creating Observables with Observable::defer()</h2></div></div></div><p class="calibre8">Imagine a use case where we want to generate a random range of numbers for each observer that subscribes to our Observable. This means we want each observer to have a different range of numbers.</p><p class="calibre8">Lets see what would happen if we used just <code class="literal">RangeObservable</code>:</p><pre class="programlisting">// observable_defer_01.php  
use Rx\Observable; 
$source = Observable::range(0, rand(1, 10)); 
 
$source-&gt;subscribe(new DebugSubject('#1')); 
$source-&gt;subscribe(new DebugSubject('#2')); 
</pre><p class="calibre8">Since we created a single source Observable, both observers will always receive the same range of numbers. Range dimensions are set once when calling <code class="literal">Observable::range()</code>. So, for example, the output from this script could look like the following:</p><pre class="programlisting">
<span class="strong"><strong class="calibre17">$ php observable_defer_01.php </strong></span>
<span class="strong"><strong class="calibre17">21:38:29 [#1] onNext: 0 (integer)</strong></span>
<span class="strong"><strong class="calibre17">21:38:29 [#1] onNext: 1 (integer)</strong></span>
<span class="strong"><strong class="calibre17">21:38:29 [#1] onNext: 2 (integer)</strong></span>
<span class="strong"><strong class="calibre17">21:38:29 [#1] onCompleted</strong></span>
<span class="strong"><strong class="calibre17">21:38:29 [#2] onNext: 0 (integer)</strong></span>
<span class="strong"><strong class="calibre17">21:38:29 [#2] onNext: 1 (integer)</strong></span>
<span class="strong"><strong class="calibre17">21:38:29 [#2] onNext: 2 (integer)</strong></span>
<span class="strong"><strong class="calibre17">21:38:29 [#2] onCompleted</strong></span>
</pre><p class="calibre8">We could of course create two source Observables, but there's a more elegant way using <code class="literal">Observable::defer()</code> static method:</p><pre class="programlisting">// observable_defer_02.php 
use Rx\Observable; 
$source = Observable::defer(function() { 
    return Observable::range(0, rand(1, 10)); 
}); 
 
$source-&gt;subscribe(new DebugSubject('#1')); 
$source-&gt;subscribe(new DebugSubject('#2')); 
</pre><p class="calibre8">Static method <code class="literal">Observable::defer()</code> takes as argument a callable that is called every time an observer subscribes similarly to <code class="literal">Observable::create()</code>. However, this callable needs to return another Observable where the observer will subscribe. Instead of creating a <code class="literal">RangeObservable</code> just once, we're creating a new one for each observer.</p><p class="calibre8">The output for this example could look like the following:</p><pre class="programlisting">
<span class="strong"><strong class="calibre17">$ php observable_defer_02.php
</strong></span>
<span class="strong"><strong class="calibre17">21:40:58 [#1] onNext: 0 (integer)
</strong></span>
<span class="strong"><strong class="calibre17">21:40:58 [#1] onNext: 1 (integer)
</strong></span>
<span class="strong"><strong class="calibre17">21:40:58 [#1] onNext: 2 (integer)
</strong></span>
<span class="strong"><strong class="calibre17">21:40:58 [#1] onNext: 3 (integer)
</strong></span>
<span class="strong"><strong class="calibre17">21:40:58 [#1] onCompleted
</strong></span>
<span class="strong"><strong class="calibre17">21:40:58 [#2] onNext: 0 (integer)
</strong></span>
<span class="strong"><strong class="calibre17">21:40:58 [#2] onCompleted</strong></span>
</pre><p class="calibre8">Notice that each observer received a different range of numbers.</p></div></div>

<div class="book" title="Writing a Reddit reader using RxPHP"><div class="book" id="11C3M2-bd355a22cf10407cb10df27e65585b8d"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch03lvl1sec27" class="calibre1"/>Writing a Reddit reader using RxPHP</h1></div></div></div><p class="calibre8">This and many upcoming apps we're going to build will be pure CLI apps. That said, it'll be helpful to have some unified library that'll help us with things common in the CLI environment:</p><p class="calibre8">
</p><div class="mediaobject"><img src="../images/00012.jpeg" alt="Writing a Reddit reader using RxPHP" class="calibre19"/></div><p class="calibre20"> </p><p class="calibre8">
</p><p class="calibre8">The tool of choice for us is going to be Symfony Console component (<a class="calibre1" href="http://symfony.com/doc/current/components/console.html">
http://symfony.com/doc/current/components/console.html
</a>). It's an  open-source library developed along with the Symfony framework, but it's designed to be used independently in any project, which is ideal for us.</p><p class="calibre8">It handles everything from inputs to outputs, and on top of that, it comes with a few very nifty helpers as well. In particular, we're going to use the following:</p><div class="book"><ul class="itemizedlist"><li class="listitem">Coloring and formatting the console output</li><li class="listitem">Splitting a CLI app into multiple independent commands</li><li class="listitem">Automatically generating help from an input parameter definition</li><li class="listitem">Handling input parameters, including validation and default values</li><li class="listitem">Creating a unified set of functions to handle user input</li></ul></div><p class="calibre8">In this example, we're going to use just the first two bullet points, but in later chapters, we'll use all the features listed here.</p></div>

<div class="book" title="Writing a Reddit reader using RxPHP">
<div class="book" title="Using the Symfony Console component"><div class="book"><div class="book"><div class="book"><h2 class="title2" id="calibre_pb_1"><a id="ch03lvl2sec28" class="calibre1"/>Using the Symfony Console component</h2></div></div></div><p class="calibre8">Start by installing the Symfony Console component via composer:</p><pre class="programlisting">
<span class="strong"><strong class="calibre17">$ composer require symfony/console</strong></span>
</pre><p class="calibre8">Each CLI app is divided into multiple commands that can be run on their own. We'll set one default command because our app is very simple and we can put all its logic into a single command.</p><p class="calibre8">The entrance point of our app is just going to register the command and then let the Console library handle everything for us:</p><pre class="programlisting">// console_reddit.php 
require_once __DIR__ . '/../vendor/autoload.php'; 
require_once 'RedditCommand.php'; 
 
$application = new Symfony\Component\Console\Application(); 
$application-&gt;setDefaultCommand('reddit'); 
$application-&gt;add(new RedditCommand()); 
$application-&gt;run(); 
</pre><p class="calibre8">Running the <code class="literal">$application::run()</code> method checks CLI parameters from PHP globals and chooses the right command based on that. Since our app has only one command, we don't need to pass any parameters from terminal; the app will use the default one, <code class="literal">RedditCommand</code>, which we'll start writing right now.</p><p class="calibre8">Each command inherits the <code class="literal">Symfony\Component\Console\Command</code> class and should at least define its name:</p><pre class="programlisting">// RedditCommand.php 
use Symfony\Component\Console\Command\Command; 
use Symfony\Component\Console\Input\InputInterface as InputI; 
use Symfony\Component\Console\Output\OutputInterface as OutputI; 
 
class RedditCommand extends Command { 
    protected function configure() { 
        $this-&gt;setName('reddit'); 
        $this-&gt;setDescription( 
            'CLI Reddit reader created using RxPHP library.'); 
    } 
 
    protected function execute(InputI $input, OutputI $output) { 
        $output-&gt;writeln('&lt;info&gt;Hello, World!&lt;/info&gt;'); 
    } 
} 
</pre><p class="calibre8">This command's name is <code class="literal">reddit</code>, which needs to match the name we set using <code class="literal">setDefaultCommand()</code>.</p><p class="calibre8">Notice that we can use tags similar to HTML for some basic styling, which is very limited, but it's enough for the purposes of typical CLI apps. There are four predefined colors that we'll use, but if you want to go into more detail feel free to check the documentation on coloring outputs at <a class="calibre1" href="http://symfony.com/doc/current/console/coloring.html">
http://symfony.com/doc/current/console/coloring.html
</a>:</p><div class="book"><ul class="itemizedlist"><li class="listitem"><code class="literal">&lt;info&gt;</code> = <code class="literal">green</code></li><li class="listitem"><code class="literal">&lt;comment&gt;</code> = <code class="literal">yellow</code></li><li class="listitem"><code class="literal">&lt;question&gt;</code> = <code class="literal">black</code> on cyan background</li><li class="listitem"><code class="literal">&lt;error&gt;</code> = <code class="literal">white</code> text on red background</li></ul></div><p class="calibre8">When Symfony Console library recognizes a command, it calls its <code class="literal">execute()</code> method while passing two objects used to handle inputs and outputs. We don't usually want to handle input or output by ourselves because there are inconsistencies across different platforms and Console library can do everything for us.</p><p class="calibre8">One suitable exception is when we want to use non-blocking user input instead of the built-in question helper. As it happens, this is exactly what we're going to do in a moment, but let's first see how to run this command from terminal:</p><pre class="programlisting">
<span class="strong"><strong class="calibre17">$ php console_reddit.php</strong></span>
<span class="strong"><strong class="calibre17">Hello, World!</strong></span>
</pre><p class="calibre8">Since <code class="literal">RedditCommand</code> is also the default command, we didn't have to set any CLI parameters to execute it. This is actually identical to running the following:</p><pre class="programlisting">
<span class="strong"><strong class="calibre17">$ php console_reddit.php reddit</strong></span>
</pre><p class="calibre8">One CLI app can hold multiple commands, as stated previously. We can list all commands supported by this app with the following:</p><pre class="programlisting">
<span class="strong"><strong class="calibre17">$ php console_reddit.php list</strong></span>
</pre><p class="calibre8">This prints a nicely colored overview of all commands, and some common options allowed by all apps by default:</p><p class="calibre8">
</p><div class="mediaobject"><img src="../images/00013.jpeg" alt="Using the Symfony Console component" class="calibre19"/></div><p class="calibre20"> </p><p class="calibre8">
</p><p class="calibre8">Among them, there's also our <code class="literal">reddit</code> command with the description we set above. We could also use the <code class="literal">help</code> command to get detailed information about a particular command, but since our <code class="literal">reddit</code> command has no input parameters, we won't see anything interesting, so we'll keep it for later.</p><div class="informaltable" title="Note"><h3 class="title1"><a id="note18" class="calibre1"/>Note</h3><p class="calibre8">Notice that <code class="literal">help</code> and <code class="literal">list</code> are just commands like any other.</p></div></div></div>

<div class="book" title="Writing a Reddit reader using RxPHP">
<div class="book" title="Non-blocking user input and an event loop"><div class="book"><div class="book"><div class="book"><h2 class="title2" id="calibre_pb_2"><a id="ch03lvl2sec29" class="calibre1"/>Non-blocking user input and an event loop</h2></div></div></div><p class="calibre8">At the end of the previous chapter, we talked about blocking and non-blocking streams in PHP using <code class="literal">proc_open()</code> and <code class="literal">stream_set_blocking()</code>. We also mentioned that we need some kind of event loop that, while periodically checking for user input, doesn't block the execution thread, in order to make the app responsive at any time.</p><p class="calibre8">The basic principles that we're going to use for our command are as follows: We'll create an Observable that emits a value for every line of input it receives (that's a string followed by <span class="strong"><em class="calibre18">Enter</em></span> key). This Observable will have multiple observers that will subscribe and unsubscribe based on the current app's internal state. We'll always have at least one observer active, which is going to look for the <code class="literal">q</code> (quit) string that terminates the event loop and ends the app.</p><p class="calibre8">Let's extend the <code class="literal">execute()</code> method to read a user's input from terminal and the event loop itself:</p><pre class="programlisting">use Rx\Observable\IntervalObservable; 
 
class RedditCommand extends Command { 
  /** @var \Rx\Subject\Subject */ 
  private $subject; 
  private $interval; 
 
  protected function execute(InputI $input, OutputI $output) { 
    $this-&gt;subject = new \Rx\Subject\Subject(); 
    $stdin = fopen('php://stdin', 'r'); 
    stream_set_blocking($stdin, false); 
 
    $loop = new React\EventLoop\StreamSelectLoop();
    $scheduler = new Rx\Scheduler\EventLoopScheduler($loop); 
    $this-&gt;interval = new IntervalObservable(100, $scheduler); 
 
    $disposable = $this-&gt;interval 
      -&gt;map(function($count) use ($stdin) { 
        return trim(fread($stdin, 1024)); 
      }) 
      -&gt;filter(function($str) { 
        return strlen($str) &gt; 0; 
      }) 
      -&gt;subscribe($this-&gt;subject); 
    $loop-&gt;run(); 
  } 
} 
</pre><p class="calibre8">There are already a few concepts used worth noting, so let's take a look at each of them separately:</p><div class="book"><ul class="itemizedlist"><li class="listitem">We opened an input stream with <code class="literal">fopen('php://stdin', 'r')</code> and made it non-blocking using the <code class="literal">stream_set_blocking()</code> function. This is exactly the same principle as we used in the previous chapter, with <code class="literal">proc_open()</code>.</li><li class="listitem">The event loop works exactly the same way as we saw in the previous chapter. We use it here to create a stable timer that fires (or "ticks," as it's referred in <code class="literal">EventLoopScheduler</code>) every 100 ms.</li><li class="listitem">All user input is buffered, which means that <code class="literal">fread()</code> will always return an empty string until we hit the <span class="strong"><em class="calibre18">
<span class="strong"><strong class="calibre17">Enter</strong></span>
</em></span> key.</li><li class="listitem">With the <code class="literal">filter()</code> operator, we filter out all empty strings.</li><li class="listitem">Values that successfully go through this operator chain are then observed by a <code class="literal">Subject</code> class. This is the class where we'll subscribe our observers later, and it emits only valid user inputs.</li></ul></div><p class="calibre8">Using <code class="literal">EventLoopScheduler</code> is in fact very simple. It makes sure it emits values at precise intervals, even though there's always some code executed down the operator chain. It internally measures the time it fired the last time and the time it spent in propagating the value and then sleeps only for the interval necessary.</p><p class="calibre8">Note that we've already addressed the issue regarding operator chains we explained at the beginning of this chapter. The Observable where we'll subscribe/unsubscribe is always <code class="literal">$this-&gt;subject</code>, and never the <code class="literal">IntervalObservable</code> directly.</p><p class="calibre8">Also, note that we're creating a <code class="literal">$disposable</code> variable that holds a <code class="literal">Disposable</code> object created by calling <code class="literal">subscribe($this-&gt;subject)</code>. This is basically the subscription to the <code class="literal">IntervalObservable</code>. If we unsubscribe (this means invoking <code class="literal">$disposable-&gt;dispose()</code>) the event loop will end automatically, and so will the entire app.</p></div></div>

<div class="book" title="Writing a Reddit reader using RxPHP">
<div class="book" title="Subscribing to user inputs"><div class="book"><div class="book"><div class="book"><h2 class="title2" id="calibre_pb_3"><a id="ch03lvl2sec30" class="calibre1"/>Subscribing to user inputs</h2></div></div></div><p class="calibre8">We've already mentioned that when a user enters <code class="literal">q</code>, the app should gracefully end. We can implement this functionality right now. Once we have our instance of Subject prepared, we can start subscribing to it:</p><pre class="programlisting">protected function execute(InputI $input, OutputI $output) { 
  // The rest of the method is the same as above 
 
  $this-&gt;subject 
    -&gt;filter(function($value) { 
      return strval($value) == 'q'; 
    }) 
    -&gt;take(1) 
    -&gt;subscribeCallback(null, null, 
        function() use ($disposable, $output, $stdin) { 
      fclose($stdin); 
      $output-&gt;writeln('&lt;comment&gt;Good bye!&lt;/comment&gt;'); 
      $disposable-&gt;dispose(); 
    } 
  ); 
 
  $loop-&gt;run(); 
} 
</pre><div class="informaltable" title="Note"><h3 class="title1"><a id="note19" class="calibre1"/>Note</h3><p class="calibre8">To save space and keep code examples short, we're omitting class name, indentation, and already defined methods that remain unchanged.</p></div><p class="calibre8">This works exactly the same as subscribing to any other Observable. What's interesting here is that we pass the <code class="literal">$disposable</code> variable to the Closure, where we call its <code class="literal">dispose()</code> method, which unsubscribes the Subject from the <code class="literal">IntervalObservable</code> and in turn terminates the event loop. This time, we don't need to keep any reference to a <code class="literal">Disposable</code> object return from <code class="literal">subscribeCallback()</code>, because we know we'll never want to unsubscribe this observer.</p><p class="calibre8">Notice that we're using <code class="literal">take(1)</code> to accept always at most one quit signal. Then the following <code class="literal">subscribe()</code> call defines only one callable for complete signal and completely ignores the remaining two.</p><p class="calibre8">We addressed this at the beginning of this chapter when we talked about disposables and how these are, in fact, necessary.</p><p class="calibre8">We obviously want to let users choose their favorite <code class="literal">subreddit</code>. This is going to be just another subscriber to <code class="literal">$this-&gt;subject</code>, but this time we'll keep its disposable, because later, we need to be able to subscribe other observers and unsubscribe this one, which needs to be subscribed only to enter <code class="literal">subreddit</code> name and nothing more:</p><pre class="programlisting">/** @var string */ 
private $subreddit; 
/** @var \Rx\DisposableInterface */ 
private $subredditDisposable; 
 
protected function execute(InputI $input, OutputI $output) { 
  // The rest of the method is the same as above 
  $this-&gt;askSubreddit(); 
 
  $loop-&gt;run(); 
} 

protected function askSubreddit() {
  $this-&gt;output-&gt;write('Enter subreddit name: ');
  $this-&gt;subredditDisposable =
    $this-&gt;subject-&gt;subscribeCallback(function($value) {
      $this-&gt;subreddit = $value;
      $this-&gt;subredditDisposable-&gt;dispose();
      $this-&gt;refreshList();
    });
}
</pre><p class="calibre8">Right before we start the event loop, we schedule an action that asks the user for the name of the <code class="literal">subreddit</code> they want to download and then subscribe a new observer. When it receives a valid value, we store it in the <code class="literal">$this-&gt;subreddit</code> variable and then it unsubscribes itself using <code class="literal">$this-&gt;subredditDisposable-&gt;dispose()</code>.</p><p class="calibre8">We can already see that there's a call to another method, called <code class="literal">refreshList()</code>. This method will download posts for this <code class="literal">subreddit</code> via Reddit API in JSON and print a list with their titles, where the user can choose which one of them they want to read by entering the post's index number.</p><p class="calibre8">To download the list, we're going to use the cURL PHP module. We've already used it in <a class="calibre1" title="Chapter 2. Reactive Programming with RxPHP" href="part0024_split_000.html#MSDG2-bd355a22cf10407cb10df27e65585b8d">Chapter 2</a>, <span class="strong"><em class="calibre18">Reactive Programming with RxPHP</em></span>, where we created <code class="literal">CURLObservable</code> for this purpose, which comes in handy here as well. Also, we've already written <code class="literal">JSONDecodeOperator</code> for decoding JSON strings, which we'll also use:</p><pre class="programlisting">const API_URL = 'https://www.reddit.com/r/%s/new.json'; 
 
protected function refreshList() {
  $curlObservable = new CurlObservable( 
      sprintf(self::API_URL, $this-&gt;subreddit)); 
 
  $curlObservable 
    -&gt;filter(function($value) { 
      return is_string($value); 
    }) 
    -&gt;lift(function() { 
      return new JSONDecodeOperator(); 
    }) 
    -&gt;subscribeCallback(function(array $response) { 
      $articles = $response['data']['children']; 
      foreach ($articles as $i =&gt; $entry) { 
        $this-&gt;output-&gt;writeln("&lt;info&gt;${i}&lt;/info&gt; " . 
            $entry['data']['title']); 
      } 
 
      $this-&gt;printHelp(); 
      $template = ', &lt;info&gt;[%d-%d]&lt;/info&gt;: Read article'; 
      $this-&gt;output-&gt;writeln( 
          sprintf($template, 0, count($articles))); 
 
      $this-&gt;chooseArticleDetail($articles); 
    }), function($e) { 
      $this-&gt;output-&gt;writeln( 
          '&lt;error&gt;Unable to download data&lt;/error&gt;'); 
    }); 
} 
</pre><p class="calibre8">This is what we've already seen and it should be very easy to follow. We use <code class="literal">CURLObservable</code> to download the URL, and then <code class="literal">JSONDecodeOperator</code> to decode it from a JSON to a PHP array. We then iterate the list of all articles it contains and print their indices and titles.</p><p class="calibre8">We introduced one more small method, called <code class="literal">printHelp()</code>, which only prints a hint that typing <code class="literal">q</code> and hitting <span class="strong"><em class="calibre18">
<span class="strong"><strong class="calibre17">Enter</strong></span>
</em></span> will quit the app. We then append some more hints relative only to the current state, such as <span class="strong"><strong class="calibre17">[b] Back to the list</strong></span>, as we can see in the following screenshot:</p><p class="calibre8">
</p><div class="mediaobject"><img src="../images/00014.jpeg" alt="Subscribing to user inputs" class="calibre19"/></div><p class="calibre20"> </p><p class="calibre8">
</p><p class="calibre8">Then, similarly, it calls <code class="literal">chooseArticleDetail()</code>, which lets the user enter the index number of the article they want to see.</p><p class="calibre8">This could go on and on but the principle is always the same. We subscribe an observer to the main <code class="literal">Subject</code> class stored in <code class="literal">$this-&gt;subject</code>, check only values relevant to the current application state, perform some action, and then unsubscribe. It's probably not necessary to include the complete source code here because it would be very repetitive.</p><div class="informaltable" title="Note"><h3 class="title1"><a id="note20" class="calibre1"/>Note</h3><p class="calibre8">If you want to see all methods for this app implemented, then check out the full source codes for this chapter.</p></div><p class="calibre8">Instead, let's focus on another thing related to <code class="literal">CURLObservable</code> and subprocesses, with Symfony Process component.</p></div></div>

<div class="book" title="Non-blocking CURLObservable"><div class="book" id="12AK82-bd355a22cf10407cb10df27e65585b8d"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch03lvl1sec28" class="calibre1"/>Non-blocking CURLObservable</h1></div></div></div><p class="calibre8">In our Reddit reader app, we download data from a remote API using PHP's cURL. Even when using its asynchronous callbacks, such as <code class="literal">CURLOPT_PROGRESSFUNCTION</code>, it's important to keep in mind that <code class="literal">curl_exec()</code> is still a blocking call, no matter what options we choose.</p><p class="calibre8">This is due to the fact that PHP runs in a single execution thread and when it starts executing <code class="literal">curl_exec()</code>, everything else needs to wait until it finishes. It's true that this method might call some callback functions, but if any of them got stuck, for example, in an infinite loop, the <code class="literal">curl_exec()</code> function would never end.</p><p class="calibre8">This has serious implications for the actual responsiveness of our Reddit reader. While <code class="literal">CURLObservable</code> is downloading data, it doesn't respond to any user input, which is probably not what we want.</p><p class="calibre8">When we talked about <code class="literal">IntervalObservable</code> and how it's able to keep the desired interval very precisely, we didn't mention that this is, in fact, a type of situation it can't handle.</p><p class="calibre8">Let's make a small script that demonstrates such behavior. We'll use <code class="literal">IntervalObservable</code> to fire every second:</p><pre class="programlisting">use Rx\Observable\IntervalObservable; 
 
function getTime() { 
    $t = microtime(true); 
    $micro = sprintf("%06d", ($t - floor($t)) * 1000000); 
    return date('H:i:s') . '.' . $micro; 
} 
 
$loop = new React\EventLoop\StreamSelectLoop(); 
$scheduler = new Rx\Scheduler\EventLoopScheduler($loop); 
$observable = new IntervalObservable(1000, $scheduler); 
 
$observable-&gt;map(function($tick) { 
    printf("%s Map: %d\n", getTime(), $tick); 
    return $tick; 
})-&gt;subscribeCallback(function($tick) { 
    printf("%s Observer: %d\n", getTime(), $tick); 
}); 
$loop-&gt;run(); 
</pre><p class="calibre8">This example prints the current time very precisely, including microseconds. If we keep it running for a while, we'll still see that it holds to microseconds pretty well while incrementing by one second:</p><pre class="programlisting">
<span class="strong"><strong class="calibre17">$ php blocked_intervalobservable.php</strong></span>
<span class="strong"><strong class="calibre17">00:27:14.306441 Map: 0</strong></span>
<span class="strong"><strong class="calibre17">00:27:14.306509 Observer: 0</strong></span>
<span class="strong"><strong class="calibre17">00:27:15.305033 Map: 1</strong></span>
<span class="strong"><strong class="calibre17">00:27:15.305116 Observer: 1</strong></span>
<span class="strong"><strong class="calibre17">...</strong></span>
<span class="strong"><strong class="calibre17">00:28:22.306071 Map: 68</strong></span>
<span class="strong"><strong class="calibre17">00:28:22.306124 Observer: 68</strong></span>
</pre><p class="calibre8">We can already observe that the <code class="literal">map()</code> operator is called shortly before the observer. Now, let's add a <code class="literal">usleep(1250 * 1000);</code> call into the <code class="literal">map()</code> operator. We can see that the gap is even larger than the 1-second interval of <code class="literal">IntervalObservable</code>, which makes it completely out of sync:</p><pre class="programlisting">
<span class="strong"><strong class="calibre17">$ php blocked_intervalobservable.php</strong></span>
<span class="strong"><strong class="calibre17">00:41:25.606327 Map: 0</strong></span>
<span class="strong"><strong class="calibre17">00:41:26.859891 Observer: 0</strong></span>
<span class="strong"><strong class="calibre17">00:41:26.860455 Map: 1</strong></span>
<span class="strong"><strong class="calibre17">00:41:28.113972 Observer: 1</strong></span>
</pre><p class="calibre8">This implies that, even when we rely on <code class="literal">IntervalObservable</code> to do all the timing necessary, it can't do anything when there's code anywhere in the operator chain blocking the execution. This is what happened to us with <code class="literal">CURLObservable</code>, and the app not responding when <code class="literal">curl_exec()</code> is running.</p><p class="calibre8">Unfortunately, PHP itself, without any extra modules, doesn't give us many options to write non-blocking code.</p><p class="calibre8">But in the previous chapter, we used <code class="literal">proc_open()</code> and <code class="literal">stream_set_blocking()</code> to run a non-blocking subprocess, so we can use the same technique and wrap <code class="literal">CURLObservable</code> into a standalone app that we can run as a subprocess.</p><p class="calibre8">Since we already know how to write CLI apps using Symfony Console component, we're going to use it here as well:</p><pre class="programlisting">// wrap_curl.php 
use Symfony\Component\Console\Command\Command; 
use Symfony\Component\Console\Input\InputInterface as InputI; 
use Symfony\Component\Console\Output\OutputInterface as OutputI; 
use Symfony\Component\Console\Input\InputArgument; 
 
class CURLCommand extends Command { 
  protected function configure() { 
    $this-&gt;setName('curl'); 
    $this-&gt;setDescription( 
        'Wrapped CURLObservable as a standalone app'); 
    $this-&gt;addArgument('url', 
        InputArgument::REQUIRED, 'URL to download'); 
  } 
 
  protected function execute(InputI $input, OutputI $output) { 
    $returnCode = 0; 
    (new CURLObservable($input-&gt;getArgument('url'))) 
      -&gt;subscribeCallback(function($res) use ($output) { 
        if (!is_float($response)) { 
          $output-&gt;write($res); 
        } 
      }, function() use (&amp;$returnCode) { 
        $returnCode = 1; 
      }); 
    return $returnCode; 
  } 
} 
 
$application = new Symfony\Component\Console\Application(); 
$application-&gt;add(new CURLCommand()); 
$application-&gt;run(); 
</pre><p class="calibre8">This command has one required argument, which is the URL it's supposed to download. It uses <code class="literal">CURLObservable</code> internally to download the URL, and then just prints the response to its standard output. It also sets proper UNIX return code when an error occurs.</p><p class="calibre8">If we try to run the command without any arguments, it prints an error telling us that this command has to have exactly one argument:</p><p class="calibre8">
</p><div class="mediaobject"><img src="../images/00015.jpeg" alt="Non-blocking CURLObservable" class="calibre19"/></div><p class="calibre20"> </p><p class="calibre8">
</p><p class="calibre8">We can test the command manually; for example with the following:</p><pre class="programlisting">
<span class="strong"><strong class="calibre17">$ php wrapped_curl.php curl https://www.reddit.com/r/php/new.json</strong></span>
<span class="strong"><strong class="calibre17">{"kind": "Listing", "data": {"modhash": "", "children": ...</strong></span>
</pre><p class="calibre8">Now, we could use <code class="literal">proc_open()</code> like in the previous chapter, but apart from just spawning the process, there are a lot of things to handle by ourselves, so it's easier to leave all the heavy work to another library.</p></div>

<div class="book" title="Non-blocking CURLObservable">
<div class="book" title="Using Symfony Process component"><div class="book"><div class="book"><div class="book"><h2 class="title2" id="calibre_pb_1"><a id="ch03lvl2sec31" class="calibre1"/>Using Symfony Process component</h2></div></div></div><p class="calibre8">As usual, we'll install this library using composer:</p><pre class="programlisting">
<span class="strong"><strong class="calibre17">$ php composer require symfony/process</strong></span>
</pre><p class="calibre8">This library lets us create new processes, read their outputs in a non-blocking way, send inputs, send signals, use timeouts, terminate processes, and so on.</p><p class="calibre8">To test things out, we'll make a small script that uses <code class="literal">IntervalObservable</code> to print a number every second while waiting for the subprocess to finish:</p><pre class="programlisting"> 
// php curl_subprocess.php 
use Symfony\Component\Process\Process; 
use Rx\Observable\IntervalObservable; 
 
$c='php wrap_curl.php curl https://www.reddit.com/r/php/new.json'; 
$process = new Process($c); 
$process-&gt;start(); 
 
$loop = new React\EventLoop\StreamSelectLoop(); 
$scheduler = new Rx\Scheduler\EventLoopScheduler($loop); 
 
(new IntervalObservable(1000, $scheduler)) 
    -&gt;takeWhile(function($ticks) use ($process) { 
        return $process-&gt;isRunning(); 
    }) 
    -&gt;subscribeCallback(function($ticks) { 
        printf("${ticks}\n"); 
    }, function() {}, function() use ($process) { 
        echo $process-&gt;getOutput(); 
    }); 
$loop-&gt;run(); 
</pre><p class="calibre8">The <code class="literal">Process</code> class takes in its constructor a full command it's supposed to execute. Then, calling <code class="literal">Process::start()</code> will start the subprocess in an asynchronous non-blocking way, just like we did before. We can check for available output anytime with the <code class="literal">getOutput()</code> method. Then, the <code class="literal">isSuccessful()</code> and <code class="literal">isRunning()</code> methods return <code class="literal">true</code> when the process has successfully terminated (return code equals 0), and whether the process is still running, respectively.</p><div class="book" title="The takeWhile() operator"><div class="book"><div class="book"><div class="book"><h3 class="title1"><a id="ch03lvl3sec11" class="calibre1"/>The takeWhile() operator</h3></div></div></div><p class="calibre8">We have also used one new operator, called <code class="literal">takeWhile()</code>. This operator takes a predicate Closure as an argument, which is executed for every value it receives. If the predicate returns <code class="literal">true</code>, it passes the value down the chain (by calling <code class="literal">onNext()</code> on its observer), but if the predicate returns <code class="literal">false</code>, it signals <code class="literal">onComplete()</code>, and therefore, the loop ends because there are no other observers subscribed to it. It's exactly the same situation we saw earlier in this chapter, when we used disposable to unsubscribe from <code class="literal">IntervalObservable</code> and end the app. The following Marble diagram represents <code class="literal">takeWhile()</code> operator in RxJS (<a class="calibre1" href="http://reactivex.io/rxjs/class/es6/Observable.js">http://reactivex.io/rxjs/class/es6/Observable.js</a>):</p><p class="calibre8">
</p><div class="mediaobject"><img src="../images/00016.jpeg" alt="The takeWhile() operator" class="calibre19"/></div><p class="calibre20"> </p><p class="calibre8">
</p><p class="calibre8">If we run this example, it'll print a few ticks, then dump the entire response and end. This is exactly what we need. So, we can remove the temporary <code class="literal">printf()</code> statement and use this subprocess in our Reddit reader app.</p></div></div></div>

<div class="book" title="Non-blocking CURLObservable">
<div class="book" title="Implementing subprocesses into the Reddit reader app"><div class="book"><div class="book"><div class="book"><h2 class="title2" id="calibre_pb_2"><a id="ch03lvl2sec32" class="calibre1"/>Implementing subprocesses into the Reddit reader app</h2></div></div></div><p class="calibre8">This final improvement will require some modifications to the existing code. First, the method <code class="literal">refreshList()</code> doesn't need to use either <code class="literal">CURLObservable</code> or <code class="literal">JSONDecodeOperator</code>, because we'll read the response from the instance of the <code class="literal">Process</code> class directly.</p><p class="calibre8">Also, both the main <code class="literal">Subject</code> class checking for user input and the observer checking whether the subprocess has terminated need to use the same instance of Scheduler. It's easier to share the same instance of <code class="literal">IntervalObservable</code> than create a new one every time we want to refresh the list of posts, so we'll keep its reference as a <code class="literal">property</code> class in <code class="literal">$this-&gt;intervalObservable</code>:</p><pre class="programlisting">protected function refreshList() { 
  $url = sprintf(self::API_URL, $this-&gt;subreddit); 
  $this-&gt;process = new Process( 
      'php wrap_curl.php curl '.$url); 
  $this-&gt;process-&gt;start(); 
 
  $this-&gt;intervalObservable 
    -&gt;takeWhile(function() { 
      return $this-&gt;process-&gt;isRunning(); 
    }) 
    -&gt;subscribeCallback(null, null, function() { 
      $jsonString = $this-&gt;process-&gt;getOutput(); 
      if (!$jsonString) { 
        return; 
      } 
 
      $response = json_decode($jsonString, true); 
      $articles = $response['data']['children']; 
      // ... the rest is unchanged 
</pre><p class="calibre8">Then, when we want to quit the app, we have to make sure the subprocess has already terminated, or eventually terminate by ourselves. If we don't terminate it, the PHP interpreter will have to wait until it finishes.</p><p class="calibre8">This is what the updated observer checking for the quit entry will look like:</p><pre class="programlisting">$this-&gt;subject-&gt;filter(function($value) { 
  return strval($value) == 'q'; 
}) 
-&gt;take(1) 
-&gt;subscribeCallback(null, null, 
  function() use ($disposable, $output, $stdin) { 
    fclose($stdin); 
    $output-&gt;writeln('&lt;comment&gt;Good bye!&lt;/comment&gt;'); 
    if ($this-&gt;process &amp;&amp; $this-&gt;process-&gt;isRunning()) { 
      $this-&gt;process-&gt;stop(); 
    } 
    $disposable-&gt;dispose(); 
  } 
); 
</pre><p class="calibre8">So, at the end, this all allows us to quit (or perform any other action) any time we want, even when cURL is downloading data at that very moment, because we run the download as a separate non-blocking process that we check periodically for a response in the same event loop as all user input.</p><div class="informaltable" title="Note"><h3 class="title1"><a id="note21" class="calibre1"/>Note</h3><p class="calibre8">In <a class="calibre1" title="Chapter 6. PHP Streams API and Higher-Order Observables" href="part0050_split_000.html#1FLS41-bd355a22cf10407cb10df27e65585b8d">Chapter 6</a>, <span class="strong"><em class="calibre18">PHP Streams API and Higher-Order Observables</em></span>, we'll see how to use <code class="literal">StreamSelectLoop</code> to directly read from file handles created with <code class="literal">fopen()</code>.</p></div></div></div>
<div class="book" title="Types of disposable classes" id="1394Q1-bd355a22cf10407cb10df27e65585b8d"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch03lvl1sec29" class="calibre1"/>Types of disposable classes</h1></div></div></div><p class="calibre8">Throughout this chapter, we've been subscribing and unsubscribing to Observables a lot. Although we know what disposables are, we haven't talked about what different types of disposable classes are available out of the box in RxPHP.</p><p class="calibre8">We're not going to write examples for each one of them, because these are very simple classes and if you're not sure about their implementation details, feel free to check their source code.</p><div class="book"><ul class="itemizedlist"><li class="listitem"><code class="literal">BinaryDisposable</code>: A class internally containing two more disposable objects. Then by calling its <code class="literal">dispose()</code> it automatically calls <code class="literal">dispose()</code> on the two internal disposables as well.</li><li class="listitem"><code class="literal">CallbackDisposable</code>: This class wraps a callable that is executed later when calling <code class="literal">dispose()</code>.</li><li class="listitem"><code class="literal">CompositeDisposable</code>: A collection of disposables that'll be disposed all together.</li><li class="listitem"><code class="literal">EmptyDisposable</code>: A dummy disposable that does nothing. Sometimes it's required to pass or return an instance of <code class="literal">DisposableInterface</code> even when we have nothing to dispose.</li><li class="listitem"><code class="literal">RefCountDisposable</code>: A disposable containing another disposable and a counter that'll be disposed when the counter reaches 0 (basically the same principle as automatic reference counting in programming languages).</li><li class="listitem"><code class="literal">ScheduledDisposable</code>: This class wraps another disposable that won't be disposed directly but scheduled with <code class="literal">Scheduler::schedule()</code> instead.</li><li class="listitem"><code class="literal">SerialDisposable</code>: A collection of disposables where, when adding a new disposable, the previous one is automatically disposed (the <code class="literal">Scheduler::scheduleRecursive()</code> method returns this type of disposable).</li><li class="listitem"><code class="literal">SingleAssignmentDisposable</code>: A wrapper around another disposable that can be assigned only once. If we try to assign this disposable twice, it'll result in exception.</li></ul></div><div class="informaltable" title="Note"><h3 class="title1"><a id="note22" class="calibre1"/>Note</h3><p class="calibre8">Since RxPHP is based mostly on RxJS 4, it uses its style of disposables. If you're coming from RxJS 5, you're used to always using only <code class="literal">Subscription</code> class, which is very similar to <code class="literal">CompositeDisposable</code>.</p></div></div>
<div class="book" title="Summary" id="147LC1-bd355a22cf10407cb10df27e65585b8d"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch03lvl1sec30" class="calibre1"/>Summary</h1></div></div></div><p class="calibre8">In this chapter, we looked in more depth at how to use disposables and operators, how these work internally, and what it means for us. We also saw how to use <code class="literal">Observable::create()</code> and <code class="literal">Observable::defer()</code> to create new Observables with custom logic.</p><p class="calibre8">The app that we have built was meant to be a simple Reddit reader that combines all the aspects of RxPHP we've learned so far. We also saw how we can achieve a truly responsive app by making all long running tasks non-blocking. We used Symfony Console component to handle user input and output from terminal. Also, we used Symfony Process component to easily spawn and have control over subprocesses.</p><p class="calibre8">We also looked at a couple of new classes from RxPHP, such as <code class="literal">ConnectableObservable</code>, <code class="literal">CompositeDisposable</code>, or <code class="literal">takeWhile()</code> operator.</p><p class="calibre8">In the following chapter, we'll work with some event-based systems used in popular PHP frameworks, such as Symfony, Silex, and Zend Framework, and see how we can combine them with the principles of reactive programming.</p></div></body></html>