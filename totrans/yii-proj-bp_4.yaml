- en: Chapter 4. Developing an Issue-tracking Application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapters, we worked on very simple and practical applications.
    As we move forward, our applications will become more complex and intricate. For
    our next project, we will develop an issue-tracking system that will allow customers
    to report issues and allow us to manage those users and issues from a single application.
    In this application, we will also provide support to create and update issues
    over e-mail. Finally, we'll be expanding upon our user management system to allow
    per-user roles.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we''ll cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Creating a user management interface
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding role-based authorization
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Sending and receiving e-mails from a Yii application
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Integrating third-party libraries and tools into our application
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Prerequisites
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Before we get started, there are a couple of things that we''ll need to have
    set up and working:'
  prefs: []
  type: TYPE_NORMAL
- en: Since we'll send and receive e-mails from our application, we're going to need
    a registered and active domain name. If you do not already have a working domain
    name, you can purchase one from a domain registrar such as [www.namecheap.com](http://www.namecheap.com),
    [www.name.com](http://www.name.com), or [www.gandi.net](http://www.gandi.net).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We'll also need the ability to modify the Domain Name System (DNS) records for
    this domain. For our application to receive e-mails, we'll need to be able to
    modify the DNS records for our domain. Most registrars provide a rudimentary DNS
    management system. If yours does not, you can use a free DNS hosting service,
    such as [www.cloudflare.com](http://www.cloudflare.com) or [http://www.rackspace.com/cloud/dns](http://www.rackspace.com/cloud/dns).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Next, you'll need to have a web server with a public facing IP address. This
    will allow e-mails to be sent to our application. Many cloud **Virtual Private
    Server** (**VPS**) providers are available to use for low monthly or hourly prices.
    Such services include [www.digitalocean.com](http://www.digitalocean.com), [www.linode.com](http://www.linode.com),
    and [http://www.rackspace.com/cloud/servers](http://www.rackspace.com/cloud/servers).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Rather than create, configure, and maintain our own e-mail server and SMTP relay,
    we can take advantage of third-party tools and libraries. This will allow us to
    focus on the development of our application rather than the maintenance of a secondary
    service. Using this service and its accompanying PHP library, we can take advantage
    of code that has already been thoroughly tested and vetted, which allows us as
    developers to get straight to coding. To take advantage of SendGrid, we'll create
    a free SendGrid developer account, which can be set up at [https://www.sendgrid.com/developers](https://www.sendgrid.com/developers).
    For now, simply set up your account. Later in the chapter, we'll go through the
    process of setting up our application to receive e-mails from this service.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In this chapter, we'll once again use the latest version of MySQL (at the time
    of this writing, MySQL 5.6). Make sure that your MySQL server is set up and running
    on your server.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Finally, we'll need to download and install Composer from [https://getcomposer.org/](https://getcomposer.org/).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Once you have acquired everything listed in the preceding steps, create a subdomain
    on the domain name you are using, and point it to your server. In this chapter,
    I'll be using `chapter4.example.com` to refer to this subdomain. After everything
    is set up and your server is responding to that domain name, we can get started.
  prefs: []
  type: TYPE_NORMAL
- en: Describing the project
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Our issue-tracking project can be broken down into the following three main
    components:'
  prefs: []
  type: TYPE_NORMAL
- en: Users who will create and respond to issues
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Issues that can be updated by the end user or a supporter (a specific type of
    user that will support our end users)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A publicly available endpoint for SendGrid to POST to with any emails we may
    receive
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Users
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The first component of our application is the user who will be using it. For
    this application, we will be using the same database structure that we did in
    [Chapter 3](ch03.html "Chapter 3. Scheduled Reminders"), *Scheduled Reminders*,
    with the addition of a new column called `role_id`, which will allow us to distinguish
    which position the user has within our application. For this application, we will
    expand upon our login process to ensure that the user's role is available for
    us to reference and manipulate within our application.
  prefs: []
  type: TYPE_NORMAL
- en: Roles
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Rather than have a single administrator who is capable of managing our system,
    in this application, we can have multiple users who we can promote or demote to
    different roles within our application. The role that we associate with our user
    will allow us to determine what users of that role are permitted to do within
    our application.
  prefs: []
  type: TYPE_NORMAL
- en: 'For this application, we will be supporting three basic roles: a customer who
    will submit issues and updates, a supporter who has the same permissions as a
    customer in addition to being able to update issues that belong to other customers,
    and an administrator who has the same permissions as a supporter and can also
    manage the roles of other users.'
  prefs: []
  type: TYPE_NORMAL
- en: To store this information, we'll use a simple roles table in our database setup
    as follows. We'll then set up a relationship between users and role so that this
    information is automatically associated with our users.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Issues
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The second component of our application is the issue that users will create.
    An issue is an item that can be created either within the application or from
    outside of it by sending an e-mail to our application. Issues can also be updated
    from within the application or by an e-mail sent by the customer. Issues will
    also have a status associated with them that will help our supporters track the
    current project of a particular issue. The database that we''ll be using will
    look as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Statuses
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Associated with each issue will be a unique status. These statuses will allow
    our supporters to track the project of an issue and will allow us to trigger specific
    events when an issue changes from one status to another. Our table for these records
    will look identical to our roles table:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Updates
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Also associated with each issue is an update. Each issue can have one or many
    updates attached to them, which will allow supporters to see what work has been
    done to a particular issue and which will serve as a medium for the user to communicate
    with our supporters. Each update will be associated with both a user and an issue.
    Our database table for this information will look as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Receiving e-mails
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The final component of our application will allow customers to create new issues
    and update existing issues via e-mail. To the end user, this process will feel
    seamless, yet it will allow our supporters to keep track of the work and updates
    that are done to a given issue. This custom endpoint will also allow us to seamlessly
    create new users within our application and associate information with those users
    as necessary.
  prefs: []
  type: TYPE_NORMAL
- en: Initializing the project
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: By now, you should be comfortable with creating projects from scratch. To provide
    us with a common starting ground, a skeleton project has been included with the
    project resources for this chapter. Included with this skeleton project are the
    necessary migrations, data files, controllers, and views to get us started. Also
    included is the login system that we'll use for authentication throughout this
    chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ll start by copying the skeleton project included with the chapter resources
    to our web server and configure it so that it responds to `chapter4.example.com`
    as outlined in the beginning of the chapter, and then follow the next steps to
    make sure everything is set up:'
  prefs: []
  type: TYPE_NORMAL
- en: Since a skeleton project was provided, begin by adjusting the path to Yii framework
    in `index.php` to point to your Yii installation path. At this point, you'll also
    want to adjust the permissions on the `assets` and `protected/runtime` folders.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Next, create the MySQL user and database table that our application will use.
    If you don''t want to alter the main configuration file that is provided, the
    following MySQL commands will create the database and user for you:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, we''ll need to run the initial migrations and then import the sample
    data that is provided in the `protected/data` folder. This sample data will allow
    us to immediately log in to our application and start using it once the application
    is running. Navigate to the root of the project, and then run the following commands:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We need to update `params.php` at `protected/config/` with our SendGrid information.
    Your username and password will correspond to your SendGrid username and password.
    In keeping with our example domain, set the from address to `noreply@chapter4.example.com`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Finally, we need to install the necessary composer dependencies:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'After performing these steps, you should be able to navigate to `chapter4.example.com`
    in your browser and see a login page to our application. After logging in to our
    application using one of the credentials that are provided in the table just after
    this paragraph, you should see the page following this table load:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Username | Password |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `customer@example.com` | `test` |'
  prefs: []
  type: TYPE_TB
- en: '| `supporter@example.com` | `test` |'
  prefs: []
  type: TYPE_TB
- en: '| `admin@example.com` | `test` |'
  prefs: []
  type: TYPE_TB
- en: '![Initializing the project](img/7734OS_04_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Managing users
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before we can begin working on issues, we first need to make sure that users
    can be both created and managed from within our application. In [Chapter 3](ch03.html
    "Chapter 3. Scheduled Reminders"), *Scheduled Reminders*, we used a command-line
    tool to do this. In this chapter, we will create a complete user management tool
    from a web interface to supplement that tool.
  prefs: []
  type: TYPE_NORMAL
- en: Roles and authentication
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Before we get into managing our users, let''s take a look at how authentication
    and roles are handled within our application. Within the `UserController` and
    `IssueController` provided with the skeleton application is a more complex `accessRules()`
    method that has a new attribute added to it. Let''s take a look at this method
    within `UserController`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, we now have a new attribute called `expression` listed within
    this method. Internally, Yii will evaluate this expression to a Boolean value.
    If that expression resolves to true, and the actions and user condition match,
    then a user is allowed to proceed to the action. In our case, we are checking
    that `Yii::app()->user->role` has a particular value.
  prefs: []
  type: TYPE_NORMAL
- en: 'Out of the box, Yii doesn''t know what that value should be, so unless we define
    it, it will be undefined. Since `Yii::app()->user` is a `CWebUser` object, we
    can add additional information to it when we create the `UserIdentity` component.
    If we take a look at the `UserIdentity` component supplied with the project, we
    can see this attribute being added via the `CUserIdentity setState()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Yii will then store this information within our `$_SESSION` variable once the
    user logs in, allowing us to reference it as long as the session is active.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: While using simple Boolean expressions is easy, should we ever want to change
    which users have access to our system, we would have to refactor our controller
    methods rather than data in our database. Consider instead creating a model method,
    such as `User::isSupporter()` or `User::isAdmin()`. These methods make it more
    clear who has access to our actions and will make your application easier to maintain
    in the future.
  prefs: []
  type: TYPE_NORMAL
- en: Listing users
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now that we know how roles work within our application, let's start building
    our controller methods for our `UserController`. Open `protected/controllers/UserController.php`,
    and you can see that we already have definitions for the methods we will be implementing.
  prefs: []
  type: TYPE_NORMAL
- en: 'To display a list of our users, we''ll be using the `User::search()` method
    within our controller and a `CGridView` widget within our view:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Within our `index.php` file at `views/user/`, we''ll load a `CGridView` instance:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Within our `CGridView` instance's columns attribute, we've defined a custom
    column called `CButtonColumn`. `CButtonColumn` allows us to add a series of useful
    buttons to a `CGridView` instance, such as a view button, an update button, and
    a delete button, with all the necessary JavaScript. By taking advantage of this
    column, we now have quick access to these actions from within our view.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You can read more about `CButtonColumn` on its Yii Class Reference page located
    at [http://www.yiiframework.com/doc/api/1.1/CButtonColumn](http://www.yiiframework.com/doc/api/1.1/CButtonColumn).
  prefs: []
  type: TYPE_NORMAL
- en: Deleting users
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Next, we should implement an `actionDelete()` method to work with our delete
    button. To make things easier, we can add a helpful `loadModel()` method as well
    to perform all the necessary checks for us. Have a look at the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Creating and updating users
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Next, we can create our `actionSave()` method that will handle both creating
    and updating our users. Since our view will be passing us all the information
    we need, we use a simple `$user->save()` call to save our information. Have a
    look at the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: In this action, we've also deliberately thrown a `try`/`catch` block around
    our `save` method. We've done this because we've put a unique index constraint
    on the `email` field of our database. If we attempt to save two users to our database
    with the same e-mail, Yii will throw an internal error since it doesn't know how
    to handle the constraint. Within our controller, we can catch this error and simply
    return a more friendly error to the user in `$form->errorSummary($model)` in our
    view via the `$user->addError()` method.
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, copy the `view/user/save.php` file from the project resources folder
    into your project. Within our view, we can populate a select dropdown of all the
    roles currently in our database using `CHtml::listData()`. Using this method allows
    us to add new roles to our database without having to alter a view in the future:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Viewing users and associated issues
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Finally, we should create a view to display a particular user and all the unresolved
    issues currently assigned to them. For our `actionView()` method, add the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, copy the `view.php` file at `views/user/` from the project resources
    folder into our project, and open it. At the bottom of this file, you''ll see
    a call to `renderPartial()` to render a view that we haven''t created yet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In Yii, the `//` notation before a layout indicates that Yii should search for
    the view file in the main application `views` folder. You can read more about
    how Yii loads view files at [http://www.yiiframework.com/doc/api/1.1/CController#getLayoutFile-detail](http://www.yiiframework.com/doc/api/1.1/CController#getLayoutFile-detail).
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ll use this view file across our application to ensure that all of our
    lists look consistent. Before moving on, let''s create this issue view. Create
    a new file in `views/issues/issue.php` and add the following `CGridView` widget:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: While our view will now render, we don't yet have any issues in our database
    to display, so results will not be shown. Once we've added issues, we can come
    back to this view to see all the issues associated with a user.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing the issue-management component
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: At the core of our application are the issues that users will submit. For this
    application, we'll assume that users will submit new issues for themselves, and
    that supporters will be supporting those issues. To ensure that issues are created
    for just the logged-in user, we have to make a few changes to our Issues model.
    Open `protected/models/Issues.php`, and let's get started.
  prefs: []
  type: TYPE_NORMAL
- en: The Issues model
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Provided at the top of our skeleton model are properties designed to help us
    later in the model:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: The first property `$_isNewRecord` is a Boolean value that we'll use within
    our `afterSave()` method to determine what e-mail will be sent. While `CActiveRecord`
    provides a property called `$isNewRecord`, Yii changes this value to FALSE before
    the `afterSave()` method.
  prefs: []
  type: TYPE_NORMAL
- en: The second property `$_isEmailCreate` is also a Boolean value. Since the e-mails
    we receive won't have a session associated with them, we need to know what user
    to associate the issue with. Since we'll restrict issues' owners to the currently
    logged-in user, we need a way to override this behavior for e-mail submissions.
  prefs: []
  type: TYPE_NORMAL
- en: 'After verifying that these properties are added, we can begin work on the other
    methods that we need to add to this model:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The first method we''ll need to implement in our Issue model is a `beforeSave()`
    method to restrict the customer of an issue. Within this method, we''ll want to
    also set the status of new issues to `New`, and flag our `$_isNewRecord` property
    so that we can use it in our `afterSave()` method. Additionally, we''ll want to
    prevent accidental changes to `customer_id` should it somehow be changed on an
    existing issue:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, we need to update the `afterSave()` method so that it sends e-mails to
    the customer. For this model, we''ll send an e-mail to the user if an issue has
    been created for them or if an issue''s status has been resolved. To do this,
    we''ll use SendGrid. Before adding this method, verify that your `params.php`
    file at `protected/config/` has the correct credentials in it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The final change we''ll need to make to the Issue model is in the `search()`
    method. Ideally, we''d like our supporters to be able to search for an issue by
    either the ID of the issue or a keyword in the title or description. To do this,
    we can simply repurpose the `Issue::search()` method by changing the `$criteria->compare()`
    call on those two attributes to `$criteria->addSearchCondition()`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The Issues Update model
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Before working on the `IssueController`, we'll also need to make a few changes
    to our `protected/models/Update.php` model. These changes will allow us to automatically
    assign the correct owner of an update to the update and help us send an e-mail
    to the user when an update is added to the issue.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once again in our model, we have a property that we can use to find out whether
    this update came from an e-mail or not:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: In this model, we're using this attribute to determine whether an e-mail should
    be sent to the user or not as we shouldn't notify the user of an update that they
    submitted.
  prefs: []
  type: TYPE_NORMAL
- en: 'Additionally, we''ll need to make two updates to our model methods:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The first update we need to make to our model is in the `beforeSave()` method.
    If the user is logged in, the author of that update should be assigned to that
    user. Have a look at the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then we should update our `afterSave()` method so that the e-mail is sent to
    the user in the appropriate instances:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Showing issues that belong to the user
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'With the updates to our models completed, we can now start working on the `IssueController`.
    The first method that we should implement is `actionIndex()`, which will show
    the logged-in users all the unresolved issues currently assigned to them:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Then in our `index.php` file at `views/issue/`, we can reuse the partial view
    that we created earlier to display all of these issues:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Searching for issues
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The next method we need to implement is the `actionSearch()` method that will
    allow us to search for issues either by the issue ID or by a keyword in the title
    or description. To do this, we''ll create a search view that will post to our
    action with the search parameters. If that `$_GET` parameter is numeric, and we
    can find an issue with that ID, we''ll immediately redirect to it. Otherwise,
    we''ll use the `Issue::search()` method that we modified earlier to search through
    all the issues in our database. Our controller action will look as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, our `search.php` file at `views/issue/` will look as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Creating issues
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Next, we''ll need to implement an action and view to create new issues. Since
    new issues won''t have updates associated with them, create and update actions
    will need to be separate. For the `actionCreate()` method, we''ll simply populate
    the values from the `$_POST` parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Then, copy the `create.php` file located at `views/issue/` from our project
    resources folder into your project.
  prefs: []
  type: TYPE_NORMAL
- en: 'Within this controller action is another reference to our `CWebUser` object.
    In previous chapters, every time we made a change to a database item from our
    controllers, we either reloaded the page or redirected to a new page. To make
    our applications more user friendly, we can set flash messages that will only
    show up once. To set these messages, we''ll use the `setFlash()` method of our
    `CWebUser` object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, from within our views, we can see whether a flash message exists for
    a particular key using `hasFlash()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, display that flash message using `getFlash()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Alternatively, if we don''t want to look for flash messages in a particular
    view, we can tell our layout to find all flash messages and display them. Have
    a look at the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: Viewing and updating issues
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now that we can create and find issues, we need to be able to view and update
    them. For this action, we''ll be consolidating both functions into a single action.
    Because users of different roles will be accessing this action, we need to adjust
    it so that users of a particular role can only perform certain tasks:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we should generate a `loadModel()` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then we''ll need to create the `actionUpdate()` function. We''ll start by loading
    the model with that ID and creating a new `Update` object in case an update is
    sent over `$_POST`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then, we should make sure that only administrators, supporters, or the issue
    owner can view the issue. Have a look at the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then, we should allow administrators and supporters to modify the `Issue` object
    itself as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then, allow any user to submit an update as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Finally, we should render the view. When rendering the view, we are also going
    to pass down a `CMarkdownParser` object. Rendering the issue updates in Markdown
    syntax will allow us to easily have access to many different formatting features,
    such as line breaks, text styles, and quoting features. Rendering the updates
    in Markdown will also give us protection against simple XSS attacks, such as JavaScript
    injection attempts:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You can learn more about the Markdown syntax and how to use Markdown at [http://daringfireball.net/projects/markdown/](http://daringfireball.net/projects/markdown/).
  prefs: []
  type: TYPE_NORMAL
- en: Finally we'll create an update view that will allow us to see the issue and
    updates from different roles. Copy the `update.php` view located at `view/issue/`
    from the project resources folder into your project.
  prefs: []
  type: TYPE_NORMAL
- en: E-mail views
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Before we can start using our application, we need to create three different
    e-mail views, one for each type of e-mail that will be sent to the user. These
    views will contain information about the issue itself and information about whatever
    change was applied to it. It will also contain special formatting that will enable
    the user to reply to that e-mail and allow us to understand what parts of the
    e-mail should be included as an update:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The first view that we should create is a created view. This view will have
    information about a newly created issue. It will also contain a special marker
    that our application will be able to identify so that only the user''s response
    is included in the update. Create a new file in `views/email/created.php`, and
    add the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then create an updated view in `views/email/updated.php`. This e-mail will
    tell the user that their issue was updated and will contain the update that was
    applied to the issue. Once again, it will contain a special marker so that if
    the user replies to our e-mail, we know what content to include in the update
    and what content to ignore:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Finally, we need to create a view to notify the user that their issue has been
    resolved. Open `resolved.php` at `views/email/` and add the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Testing our application
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Since the domain `example.com` is not a valid domain to send e-mails, create
    for yourself a new user with a valid e-mail address, log in as that user, and
    create several issues. For each issue you create, a new e-mail will be sent to
    you notifying you that the issue has been created. Moreover, updating an issue
    as any supporter or administrator will notify the current supporter of the issue
    via e-mail with the provided update. Finally, if you have a supporter or an administrator
    resolve an issue, then you will receive an e-mail to notify you that the issue
    was resolved.
  prefs: []
  type: TYPE_NORMAL
- en: Once you have verified that all the functionality is working, we can move on
    to handling and parsing inbound e-mails with SendGrid.
  prefs: []
  type: TYPE_NORMAL
- en: Handling inbound e-mail parsing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: While there are many different ways of handling inbound e-mail parsing, one
    of the easiest ways is to send that e-mail to a third party, who will then parse
    the contents for us, and send it as a `$_POST` request to an open endpoint in
    our application. This is exactly what SendGrid will do for us. However, before
    we can start using SendGrid, we need to make a couple of changes to our DNS server
    for our domain and to our SendGrid account.
  prefs: []
  type: TYPE_NORMAL
- en: Sending e-mails to SendGrid
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To direct our e-mails to SendGrid in order to pass, we first need to make a
    change to our DNS settings. In keeping with our example domain `chapter4.example.com`,
    we first need to log in to our DNS host and add a new Mail Exchange (MX) record
    to our subdomain. Specifically, we need to add an MX record with a priority of
    `10` to `mx.sendgrid.net`. In most DNS systems, that record would look as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'Alternatively, if you''re using a service like CloudFlare to handle your DNS,
    your entry may look as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Sending e-mails to SendGrid](img/7734OS_04_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Depending upon your DNS provider, DNS settings may take up to 24 to 48 hours
    to propagate. Before leaving this step, verify that the MX record was added and
    propagated using either a command-line tool, such as a DIG or a free, online web
    tool.
  prefs: []
  type: TYPE_NORMAL
- en: Adjusting SendGrid Parse settings
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Once you''ve updated your DNS settings, you then need to update your SendGrid
    Parse API settings so that SendGrid knows where to send your e-mails. Navigate
    to [www.sendgrid.com/developer/reply](http://www.sendgrid.com/developer/reply),
    and then fill in the parse settings page as follows and submit the record:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Adjusting SendGrid Parse settings](img/7734OS_04_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Once you've added the record, you should see confirmation at the bottom of the
    page. Once this has been completed, you can now send e-mails to `*@chapter4.example.com`,
    and SendGrid will parse it and forward it onto your `actionEmailUpdate()` method
    of our `IssueController`.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You can read more about the SendGrid Parse API webhook at [http://sendgrid.com/docs/API_Reference/Webhooks/parse.html](http://sendgrid.com/docs/API_Reference/Webhooks/parse.html).
  prefs: []
  type: TYPE_NORMAL
- en: Creating and updating issues over e-mail
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now that our DNS settings and SendGrid account are set, we need to add the
    necessary functionality to both create and update issues over e-mail. Then, the
    action that we create will also create new users in our database if a new user
    creates an issue for us:'
  prefs: []
  type: TYPE_NORMAL
- en: 'With SendGrid configured, our `actionEmailUpdate()` method will receive a `POST`
    request from SendGrid anytime someone sends an e-mail to our application.. All
    the information that we will need to work with will be in a `$_POST` variable
    once it arrives. However, some of this information may not be readily accessible.
    For instance, the e-mail address will reach us as `Example User" <test@chapter4.example.com>"`
    which isn''t very useful to us. To make this e-mail more useful, we need to create
    a utility function that will break this information apart for us in our `IssueController`
    as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then, within our `actionEmailUpdate()` method, we''ll begin by retrieving this
    information:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then, we''ll need to search for the subject of the e-mail for the ID of our
    issue. In the e-mails we''re sending out, the subject has the format `[Issue #<ID>]
    <info>`. Have a look at the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then, we need to find a user in our system with that e-mail address. If we
    are unable to find that user, we need to create a new user with that e-mail address:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then, we need to locate an issue with that ID. If an issue with that ID doesn''t
    exist, or the issue doesn''t belong to the user we''re working with, we should
    create a new issue rather than updating an existing one:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Finally, if we have a good user and issue, we should apply the update. At this
    point, we''ll split the contents of our e-mail along our special marker and only
    include the contents above it in our update. This reduces the amount of data we
    need to store in our database and keeps our interface looking clean and clear
    of e-mail clutter:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Now that our application can receive e-mails, reply to one of the e-mails you
    received earlier. After a short while, you will be able to navigate to that issue
    and see that your update sent over e-mail was indeed applied. Alternatively, you
    can send a new e-mail to your application. In a short while, a new issue will
    be created, and the application will respond to you with an e-mail notifying you
    that a new issue was created.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We covered a lot of ground in this chapter! We went over creating and managing
    users from within our application, sending e-mails about certain events, and how
    to receive e-mails and incorporate that information into our application. We also
    added roles to our users and made our application only respond to certain actions
    of users with a particular role.
  prefs: []
  type: TYPE_NORMAL
- en: Before continuing, think of ways in which you could improve this application,
    and try to implement them. For example, you could change it so that the access
    rules expressions are answered by the models rather than hard-coded values. Alternatively,
    you could add new statuses to the application and send out different e-mails when
    those statuses change. Think of all the ways you could make this application better
    to use for the end user.
  prefs: []
  type: TYPE_NORMAL
- en: After adding some new features, go through the Yii documentation located at
    [http://www.yiiframework.com/doc/](http://www.yiiframework.com/doc/) to help you
    better understand some of the methods and properties we used in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will be expanding upon our knowledge to implement a
    micro blogging platform similar to Twitter. To our micro-blogging platform, we'll
    add a registration and password reset system for our end users and allow our end
    users to manage their own accounts. Once you're ready, turn the page and get ready
    to dive deeper into Yii!
  prefs: []
  type: TYPE_NORMAL
