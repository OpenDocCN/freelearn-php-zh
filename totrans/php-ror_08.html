<html><head></head><body>
<div id="_idContainer056">
<h1 class="chapter-number" id="_idParaDest-112"><a id="_idTextAnchor114"/><span class="koboSpan" id="kobo.1.1">8</span></h1>
<h1 id="_idParaDest-113"><a id="_idTextAnchor115"/><span class="koboSpan" id="kobo.2.1">Models, DBs, and Active Record</span></h1>
<p><span class="koboSpan" id="kobo.3.1">The </span><strong class="bold"><span class="koboSpan" id="kobo.4.1">M</span></strong><span class="koboSpan" id="kobo.5.1"> in the </span><strong class="bold"><span class="koboSpan" id="kobo.6.1">MVC</span></strong><span class="koboSpan" id="kobo.7.1"> application design pattern stands for </span><strong class="bold"><span class="koboSpan" id="kobo.8.1">model</span></strong><span class="koboSpan" id="kobo.9.1">, and in this context, we will be using Ruby’s model </span><a id="_idIndexMarker402"/><span class="koboSpan" id="kobo.10.1">abstraction to connect</span><a id="_idIndexMarker403"/><span class="koboSpan" id="kobo.11.1"> to a database using another design pattern called Active Record. </span><span class="koboSpan" id="kobo.11.2">We must remember that while models are mostly used to connect to databases, they can also be used to connect to other data sources. </span><span class="koboSpan" id="kobo.11.3">We could have a model connect to a filesystem, a web service, and so on. </span><span class="koboSpan" id="kobo.11.4">The purpose behind a model is to organize our business rules, and that purpose may include connecting to various </span><span class="No-Break"><span class="koboSpan" id="kobo.12.1">data sources.</span></span></p>
<p><span class="koboSpan" id="kobo.13.1">In this chapter, we will first generate a model using some of our command-line generators in Rails. </span><span class="koboSpan" id="kobo.13.2">Then, we will use this model to connect to our database. </span><span class="koboSpan" id="kobo.13.3">Finally, we will look at Active Record and perform operations inside our database in a very </span><span class="No-Break"><span class="koboSpan" id="kobo.14.1">intuitive way.</span></span></p>
<p><span class="koboSpan" id="kobo.15.1">With this purpose and Active Record in mind, in this chapter, we will cover the </span><span class="No-Break"><span class="koboSpan" id="kobo.16.1">following topics:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.17.1">Generating models </span><span class="No-Break"><span class="koboSpan" id="kobo.18.1">using Rails</span></span></li>
<li><span class="koboSpan" id="kobo.19.1">Connecting to </span><span class="No-Break"><span class="koboSpan" id="kobo.20.1">a database</span></span></li>
<li><span class="koboSpan" id="kobo.21.1">Active </span><span class="No-Break"><span class="koboSpan" id="kobo.22.1">Record operations</span></span></li>
</ul>
<h1 id="_idParaDest-114"><a id="_idTextAnchor116"/><span class="koboSpan" id="kobo.23.1">Technical requirements</span></h1>
<p><span class="koboSpan" id="kobo.24.1">To follow along with this chapter, you will need </span><span class="No-Break"><span class="koboSpan" id="kobo.25.1">the following:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.26.1">Any IDE to view/edit code (e.g. </span><span class="koboSpan" id="kobo.26.2">SublimeText, Visual Studio Code, Notepad++ Vim, </span><span class="No-Break"><span class="koboSpan" id="kobo.27.1">Emacs, etc.)</span></span></li>
<li><span class="koboSpan" id="kobo.28.1">For macOS users, you will also need to have the Xcode command line </span><span class="No-Break"><span class="koboSpan" id="kobo.29.1">tools installed</span></span></li>
<li><span class="koboSpan" id="kobo.30.1">Ruby version 2.6 or later installed and ready </span><span class="No-Break"><span class="koboSpan" id="kobo.31.1">to use</span></span></li>
<li><span class="koboSpan" id="kobo.32.1">Git client installed on your </span><span class="No-Break"><span class="koboSpan" id="kobo.33.1">local machine</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.34.1">The code presented in this chapter is available </span><span class="No-Break"><span class="koboSpan" id="kobo.35.1">at </span></span><a href="https://github.com/PacktPublishing/From-PHP-to-Ruby-on-Rails/"><span class="No-Break"><span class="koboSpan" id="kobo.36.1">https://github.com/PacktPublishing/From-PHP-to-Ruby-on-Rails/</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.37.1">.</span></span></p>
<h1 id="_idParaDest-115"><a id="_idTextAnchor117"/><span class="koboSpan" id="kobo.38.1">Generating models using Rails</span></h1>
<p><span class="koboSpan" id="kobo.39.1">Models are abstractions</span><a id="_idIndexMarker404"/><span class="koboSpan" id="kobo.40.1"> of objects we might find in everyday life. </span><span class="koboSpan" id="kobo.40.2">Whether they are people, books, or cars, a model</span><a id="_idIndexMarker405"/><span class="koboSpan" id="kobo.41.1"> serves as a representation of those objects on the database. </span><span class="koboSpan" id="kobo.41.2">And just like controllers, Rails comes with generators that help us create models in a very easy and intuitive way. </span><span class="koboSpan" id="kobo.41.3">But first, let’s set up our environment. </span><span class="koboSpan" id="kobo.41.4">You can either start where we left off in the previous chapter, or download the example code for this chapter. </span><span class="koboSpan" id="kobo.41.5">If you haven’t yet done so, open a terminal and type the following </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.42.1">git</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.43.1"> command:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.44.1">
git clone https://github.com/PacktPublishing/From-PHP-to-Ruby-on-Rails.git</span></pre> <p><span class="koboSpan" id="kobo.45.1">If you have already done so, then just navigate to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.46.1">chapter08</span></strong><span class="koboSpan" id="kobo.47.1"> folder within your project by running the </span><span class="No-Break"><span class="koboSpan" id="kobo.48.1">following command:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.49.1">
cd From-PHP-to-Ruby-on-Rails/chapter08/rails5_models/</span></pre> <p><span class="koboSpan" id="kobo.50.1">Again, let’s install our dependencies with the </span><span class="No-Break"><span class="koboSpan" id="kobo.51.1">following command:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.52.1">
bundle install</span></pre> <p><span class="koboSpan" id="kobo.53.1">And to confirm our setup was done correctly, let’s run the </span><span class="No-Break"><span class="koboSpan" id="kobo.54.1">following command:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.55.1">
bundle exec rails --version</span></pre> <p><span class="koboSpan" id="kobo.56.1">The output should read something like </span><span class="No-Break"><span class="koboSpan" id="kobo.57.1">the following:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.58.1">
Rails 5.1.7</span></pre> <p><span class="koboSpan" id="kobo.59.1">And now we are ready to generate our model. </span><span class="koboSpan" id="kobo.59.2">We will generate a model that represents people. </span><span class="koboSpan" id="kobo.59.3">We will add an attribute called </span><strong class="source-inline"><span class="koboSpan" id="kobo.60.1">name</span></strong><span class="koboSpan" id="kobo.61.1"> for each person, and another attribute called </span><strong class="source-inline"><span class="koboSpan" id="kobo.62.1">birthday</span></strong><span class="koboSpan" id="kobo.63.1">. </span><span class="koboSpan" id="kobo.63.2">To generate our model, let’s type the following command on </span><span class="No-Break"><span class="koboSpan" id="kobo.64.1">our shell:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.65.1">
bundle exec rails generate model Person name:string birthday:date</span></pre> <p><span class="koboSpan" id="kobo.66.1">With this command, we are telling our Rails</span><a id="_idIndexMarker406"/><span class="koboSpan" id="kobo.67.1"> generator to create</span><a id="_idIndexMarker407"/><span class="koboSpan" id="kobo.68.1"> a model called </span><strong class="source-inline"><span class="koboSpan" id="kobo.69.1">Person</span></strong><span class="koboSpan" id="kobo.70.1"> with an attribute called </span><strong class="source-inline"><span class="koboSpan" id="kobo.71.1">name</span></strong><span class="koboSpan" id="kobo.72.1">, and another attribute called </span><strong class="source-inline"><span class="koboSpan" id="kobo.73.1">birthday</span></strong><span class="koboSpan" id="kobo.74.1">. </span><span class="koboSpan" id="kobo.74.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.75.1">name</span></strong><span class="koboSpan" id="kobo.76.1"> attribute will be a string, and the </span><strong class="source-inline"><span class="koboSpan" id="kobo.77.1">birthday</span></strong><span class="koboSpan" id="kobo.78.1"> attribute a date. </span><span class="koboSpan" id="kobo.78.2">Once we press the </span><em class="italic"><span class="koboSpan" id="kobo.79.1">Enter</span></em><span class="koboSpan" id="kobo.80.1"> key, we should see the </span><span class="No-Break"><span class="koboSpan" id="kobo.81.1">following output:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.82.1">
bundle exec rails generate model Person name:string birthday:date
Running via Spring preloader in process 32161
      invoke  active_record
      create    db/migrate/20230727031200_create_people.rb
      create    app/models/person.rb
      invoke    test_unit
      create      test/models/person_test.rb
      create      test/fixtures/people.yml</span></pre> <p><span class="koboSpan" id="kobo.83.1">If we look closely at this output, we should notice two important files that have been created, the migration and the model itself. </span><span class="koboSpan" id="kobo.83.2">Let’s first open our migration file, </span><strong class="source-inline"><span class="koboSpan" id="kobo.84.1">db/migrate/20230727031200_create_people.rb</span></strong><span class="koboSpan" id="kobo.85.1">. </span><span class="koboSpan" id="kobo.85.2">Its contents should look something </span><span class="No-Break"><span class="koboSpan" id="kobo.86.1">like this:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.87.1">
class CreatePeople &lt; Active Record::Migration[5.1]
  def change
    create_table :people do |t|
      t.string :name
      t.date :birthday
      t.timestamps
    end
  end
end</span></pre> <p><span class="koboSpan" id="kobo.88.1">This file includes the instructions</span><a id="_idIndexMarker408"/><span class="koboSpan" id="kobo.89.1"> to generate our database structure. </span><span class="koboSpan" id="kobo.89.2">If we look</span><a id="_idIndexMarker409"/><span class="koboSpan" id="kobo.90.1"> closely, it states that it will create a </span><strong class="source-inline"><span class="koboSpan" id="kobo.91.1">people</span></strong><span class="koboSpan" id="kobo.92.1"> table with the </span><strong class="source-inline"><span class="koboSpan" id="kobo.93.1">name</span></strong><span class="koboSpan" id="kobo.94.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.95.1">birthday</span></strong><span class="koboSpan" id="kobo.96.1">, and </span><strong class="source-inline"><span class="koboSpan" id="kobo.97.1">timestamps</span></strong><span class="koboSpan" id="kobo.98.1"> columns. </span><span class="koboSpan" id="kobo.98.2">Why was this file needed? </span><span class="koboSpan" id="kobo.98.3">To answer that question, we need to take a look at what Rails </span><span class="No-Break"><span class="koboSpan" id="kobo.99.1">migrations are.</span></span></p>
<h2 id="_idParaDest-116"><a id="_idTextAnchor118"/><span class="koboSpan" id="kobo.100.1">Rails migrations</span></h2>
<p><span class="koboSpan" id="kobo.101.1">In the old days, keeping track of a </span><strong class="bold"><span class="koboSpan" id="kobo.102.1">database</span></strong><span class="koboSpan" id="kobo.103.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.104.1">DB</span></strong><span class="koboSpan" id="kobo.105.1">) was a hassle. </span><span class="koboSpan" id="kobo.105.2">Whenever you worked on a project with other developers</span><a id="_idIndexMarker410"/><span class="koboSpan" id="kobo.106.1"> that required a DB, someone had to create the DB</span><a id="_idIndexMarker411"/><span class="koboSpan" id="kobo.107.1"> and its tables, and often also populate it with testing data. </span><span class="koboSpan" id="kobo.107.2">If someone new joined the team, you would just hand them a copy of the DB and off they would go. </span><span class="koboSpan" id="kobo.107.3">But wait – what would happen if someone made changes to the DB structure? </span><span class="koboSpan" id="kobo.107.4">What if we needed a new field? </span><span class="koboSpan" id="kobo.107.5">What if a field was no longer needed? </span><span class="koboSpan" id="kobo.107.6">Then, whoever was in charge of this DB would have to make the change and then hand out the new copy of the DB to all the developers in the team. </span><span class="koboSpan" id="kobo.107.7">You can see how this might get out of control, especially if you have more than two developers working on the same project. </span><span class="koboSpan" id="kobo.107.8">In comes migrations to </span><span class="No-Break"><span class="koboSpan" id="kobo.108.1">the rescue!</span></span></p>
<p><span class="koboSpan" id="kobo.109.1">A migration is a series of commands to rebuild the structure of a DB in sequence. </span><span class="koboSpan" id="kobo.109.2">In the same hypothetical example that I just outlined, migrations would solve the problem with no issues. </span><span class="koboSpan" id="kobo.109.3">Initially, you would create a migration that created a table with certain fields. </span><span class="koboSpan" id="kobo.109.4">If the table required a new field, you would create another migration to create that new field. </span><span class="koboSpan" id="kobo.109.5">If a field was no longer required, you would create a migration to remove that field. </span><span class="koboSpan" id="kobo.109.6">And, as you may have noticed, the name of the migration has a timestamp. </span><span class="koboSpan" id="kobo.109.7">This is to run the migrations in sequence – we would first create the table, then add a field, and lastly remove a field. </span><span class="koboSpan" id="kobo.109.8">If a new developer joined the team, they could just run all the migrations and have the exact same database structure that everyone else has. </span><span class="koboSpan" id="kobo.109.9">Back to the migration at hand, we have the instructions (migration) but we still need to execute these instructions to impact the DB. </span><span class="koboSpan" id="kobo.109.10">So now, let’s run the command to execute this migration. </span><span class="koboSpan" id="kobo.109.11">On the command shell, type the </span><span class="No-Break"><span class="koboSpan" id="kobo.110.1">following command:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.111.1">
bundle exec rails db:migrate</span></pre> <p><span class="koboSpan" id="kobo.112.1">This should output </span><span class="No-Break"><span class="koboSpan" id="kobo.113.1">the following:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.114.1">
== 20230727031200 CreatePeople: migrating
=====================================
-- create_table(:people)
   -&gt; 0.0002s
== 20230727031200 CreatePeople: migrated (0.0002s)
============================</span></pre> <p><span class="koboSpan" id="kobo.115.1">This means that our DB structure has been created, with a table called </span><strong class="source-inline"><span class="koboSpan" id="kobo.116.1">people</span></strong><span class="koboSpan" id="kobo.117.1">. </span><span class="koboSpan" id="kobo.117.2">This is part of the Rails magic. </span><span class="koboSpan" id="kobo.117.3">We have not configured any DB on our project, yet if this command is successful, it means that Rails is connected to a DB. </span><span class="koboSpan" id="kobo.117.4">The reason behind this is that the Rails developers wanted you to have a ready-to-use project out of the box, and to do this, they made the initial</span><a id="_idIndexMarker412"/><span class="koboSpan" id="kobo.118.1"> project connect to a database called SQLite by default. </span><span class="koboSpan" id="kobo.118.2">SQLite is a series of libraries that allow us to have a ready-to-use, lightweight database based on a </span><strong class="source-inline"><span class="koboSpan" id="kobo.119.1">sqlite3</span></strong><span class="koboSpan" id="kobo.120.1"> file in your project. </span><span class="koboSpan" id="kobo.120.2">If you’re interested in this topic, I recommend</span><a id="_idIndexMarker413"/><span class="koboSpan" id="kobo.121.1"> you read the SQLite official </span><span class="No-Break"><span class="koboSpan" id="kobo.122.1">page: </span></span><a href="https://www.sqlite.org/index.html"><span class="No-Break"><span class="koboSpan" id="kobo.123.1">https://www.sqlite.org/index.html</span></span></a></p>
<p><span class="koboSpan" id="kobo.124.1">We’ve now generated our model</span><a id="_idIndexMarker414"/><span class="koboSpan" id="kobo.125.1"> and we’re ready to move on to the next section, where we will connect to our database using our model and the </span><span class="No-Break"><span class="koboSpan" id="kobo.126.1">Rails configuration.</span></span></p>
<h1 id="_idParaDest-117"><a id="_idTextAnchor119"/><span class="koboSpan" id="kobo.127.1">Connecting to a database</span></h1>
<p><span class="koboSpan" id="kobo.128.1">So far, we’ve created a </span><strong class="source-inline"><span class="koboSpan" id="kobo.129.1">Person</span></strong><span class="koboSpan" id="kobo.130.1"> model and the migrations needed for the structure of our database. </span><span class="koboSpan" id="kobo.130.2">Now we are ready to connect to our database. </span><span class="koboSpan" id="kobo.130.3">But wait, we’ve already connected to a database! </span><span class="koboSpan" id="kobo.130.4">As previously</span><a id="_idIndexMarker415"/><span class="koboSpan" id="kobo.131.1"> stated, if we were able to run our migration successfully, it means that we did indeed connect to the SQLite database. </span><span class="koboSpan" id="kobo.131.2">Now let’s take a look at how Rails</span><a id="_idIndexMarker416"/><span class="koboSpan" id="kobo.132.1"> is configured to do this. </span><span class="koboSpan" id="kobo.132.2">Let’s examine our Gemfile, and in doing so, we’ll see the </span><span class="No-Break"><span class="koboSpan" id="kobo.133.1">following line:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.134.1">
…
# Use sqlite3 as the database for Active Record
gem 'sqlite3'
…</span></pre> <p><span class="koboSpan" id="kobo.135.1">The preceding line installs the </span><strong class="source-inline"><span class="koboSpan" id="kobo.136.1">sqlite3</span></strong><span class="koboSpan" id="kobo.137.1"> gem that allows Rails to communicate with a SQLite database. </span><span class="koboSpan" id="kobo.137.2">But wait, there’s more. </span><span class="koboSpan" id="kobo.137.3">If we open the </span><strong class="source-inline"><span class="koboSpan" id="kobo.138.1">app/config/database.yml</span></strong><span class="koboSpan" id="kobo.139.1"> file, we will also see some of the database settings for </span><span class="No-Break"><span class="koboSpan" id="kobo.140.1">our project:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.141.1">
…
default: &amp;default
  adapter: sqlite3
  pool: &lt;%= ENV.fetch("RAILS_MAX_THREADS") { 5 } %&gt;
  timeout: 5000
development:
  &lt;&lt;: *default
  database: db/development.sqlite3
…</span></pre> <p><span class="koboSpan" id="kobo.142.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.143.1">default</span></strong><span class="koboSpan" id="kobo.144.1"> stanza defines the database adapter as </span><strong class="source-inline"><span class="koboSpan" id="kobo.145.1">sqlite3</span></strong><span class="koboSpan" id="kobo.146.1"> and the environment sets the database source file to be in </span><strong class="source-inline"><span class="koboSpan" id="kobo.147.1">db/development.sqlite3</span></strong><span class="koboSpan" id="kobo.148.1"> . </span><span class="koboSpan" id="kobo.148.2">If we check this, we’ll see that the file is indeed there. </span><span class="koboSpan" id="kobo.148.3">The Rails migration command is the one responsible for creating this file. </span><span class="koboSpan" id="kobo.148.4">Don’t bother opening the file as it is a binary file and unless you have a plugin to read SQLite files</span><a id="_idIndexMarker417"/><span class="koboSpan" id="kobo.149.1"> on your IDE, you’ll only see data that only makes sense to computers</span><a id="_idIndexMarker418"/><span class="koboSpan" id="kobo.150.1"> and not to humans. </span><span class="koboSpan" id="kobo.150.2">Now let’s use this newly acquired information to actually manipulate data in the database with the </span><span class="No-Break"><span class="koboSpan" id="kobo.151.1">Rails console.</span></span></p>
<h2 id="_idParaDest-118"><a id="_idTextAnchor120"/><span class="koboSpan" id="kobo.152.1">The Rails console</span></h2>
<p><span class="koboSpan" id="kobo.153.1">The creators of Rails </span><a id="_idIndexMarker419"/><span class="koboSpan" id="kobo.154.1">have made an enormous effort to make Ruby on Rails the framework of choice to pair with Rails. </span><span class="koboSpan" id="kobo.154.2">As such, they were</span><a id="_idIndexMarker420"/><span class="koboSpan" id="kobo.155.1"> inspired by some of the tools that come with Ruby, and more specifically the </span><strong class="bold"><span class="koboSpan" id="kobo.156.1">Interactive Ruby </span></strong><span class="koboSpan" id="kobo.157.1">(</span><strong class="bold"><span class="koboSpan" id="kobo.158.1">IRB</span></strong><span class="koboSpan" id="kobo.159.1">) console. </span><span class="koboSpan" id="kobo.159.2">Rails comes with a similar console but tweaked to be able to load and query Rails components. </span><span class="koboSpan" id="kobo.159.3">Let’s try it out with the </span><span class="No-Break"><span class="koboSpan" id="kobo.160.1">following command:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.161.1">
Bundle exec rails console</span></pre> <p><span class="koboSpan" id="kobo.162.1">This will show the following output and enable us to interact </span><span class="No-Break"><span class="koboSpan" id="kobo.163.1">with Rails:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.164.1">
Running via Spring preloader in process 85479
Loading development environment (Rails 5.1.7)
irb(main):001:0&gt;</span></pre> <p><span class="koboSpan" id="kobo.165.1">And this is where our </span><strong class="source-inline"><span class="koboSpan" id="kobo.166.1">Person</span></strong><span class="koboSpan" id="kobo.167.1"> model comes in handy. </span><span class="koboSpan" id="kobo.167.2">Let’s create a new object called </span><strong class="source-inline"><span class="koboSpan" id="kobo.168.1">single_person</span></strong><span class="koboSpan" id="kobo.169.1"> and add some data to our database. </span><span class="koboSpan" id="kobo.169.2">Inside this Rails console, let’s run the </span><span class="No-Break"><span class="koboSpan" id="kobo.170.1">following command:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.171.1">
single_person = Person.new</span></pre> <p><span class="koboSpan" id="kobo.172.1">This will create an object based on the </span><strong class="source-inline"><span class="koboSpan" id="kobo.173.1">Person</span></strong><span class="koboSpan" id="kobo.174.1"> model that we defined with our </span><strong class="source-inline"><span class="koboSpan" id="kobo.175.1">Model</span></strong><span class="koboSpan" id="kobo.176.1"> file and the migrations. </span><span class="koboSpan" id="kobo.176.2">The previous command will output </span><span class="No-Break"><span class="koboSpan" id="kobo.177.1">the following:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.178.1">
=&gt; #&lt;Person id: nil, name: nil, birthday: nil, created_at: nil, updated_at: nil&gt;
irb(main):002:0&gt;</span></pre> <p><span class="koboSpan" id="kobo.179.1">We can see that we’ve created</span><a id="_idIndexMarker421"/><span class="koboSpan" id="kobo.180.1"> an empty object that has no ID, no name, and no birthday. </span><span class="koboSpan" id="kobo.180.2">Now let’s set the object’s name and birthday. </span><span class="koboSpan" id="kobo.180.3">We’ll do this by first typing the </span><span class="No-Break"><span class="koboSpan" id="kobo.181.1">following command:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.182.1">
single_person.name = "Benjamin"</span></pre> <p><span class="koboSpan" id="kobo.183.1">Our prompt will confirm with the following output that we’ve set </span><span class="No-Break"><span class="koboSpan" id="kobo.184.1">the name:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.185.1">
=&gt; "Benjamin"</span></pre> <p><span class="koboSpan" id="kobo.186.1">Now let’s set the birthday with the </span><span class="No-Break"><span class="koboSpan" id="kobo.187.1">following command:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.188.1">
single_person.birthday = "1986-02-03"</span></pre> <p><span class="koboSpan" id="kobo.189.1">We’re setting a date in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.190.1">year-month-day</span></strong><span class="koboSpan" id="kobo.191.1"> format. </span><span class="koboSpan" id="kobo.191.2">The preceding command sets the birth date to February 3, 1986. </span><span class="koboSpan" id="kobo.191.3">And just like the previous command, it will confirm this by returning the value we’ve </span><span class="No-Break"><span class="koboSpan" id="kobo.192.1">just set:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.193.1">
=&gt; "1986-02-03"</span></pre> <p><span class="koboSpan" id="kobo.194.1">We can go a little further with our object and see what attributes we’ve set so far by just typing the name of our </span><strong class="source-inline"><span class="koboSpan" id="kobo.195.1">single_person</span></strong><span class="koboSpan" id="kobo.196.1"> variable and view the contents of the object. </span><span class="koboSpan" id="kobo.196.2">Let’s do that </span><span class="No-Break"><span class="koboSpan" id="kobo.197.1">as follows:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.198.1">
single_person</span></pre> <p><span class="koboSpan" id="kobo.199.1">The preceding comand will return the </span><span class="No-Break"><span class="koboSpan" id="kobo.200.1">following output:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.201.1">
=&gt; #&lt;Person id: nil, name: "Benjamin", birthday: "1986-02-03", created_at: nil, updated_at: nil&gt;</span></pre> <p><span class="koboSpan" id="kobo.202.1">One thing to remember</span><a id="_idIndexMarker422"/><span class="koboSpan" id="kobo.203.1"> is that this information is still only available in memory. </span><span class="koboSpan" id="kobo.203.2">We have not persisted (or written) the data into the database. </span><span class="koboSpan" id="kobo.203.3">You’ll hear the term </span><em class="italic"><span class="koboSpan" id="kobo.204.1">persist</span></em><span class="koboSpan" id="kobo.205.1"> often when dealing with databases, and it refers to writing the data into the database. </span><span class="koboSpan" id="kobo.205.2">As it stands now, if we were to leave the Rails console, the data would be lost. </span><span class="koboSpan" id="kobo.205.3">How do we persist the data, you may ask? </span><span class="koboSpan" id="kobo.205.4">Simple: we call the </span><strong class="source-inline"><span class="koboSpan" id="kobo.206.1">save</span></strong><span class="koboSpan" id="kobo.207.1"> method from our </span><strong class="source-inline"><span class="koboSpan" id="kobo.208.1">single_person</span></strong><span class="koboSpan" id="kobo.209.1"> object. </span><span class="koboSpan" id="kobo.209.2">But before we do that, let’s confirm that there is no data in our database. </span><span class="koboSpan" id="kobo.209.3">We will do so by typing the following static method from our </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.210.1">Person</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.211.1"> class:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.212.1">
Person.all</span></pre> <p><span class="koboSpan" id="kobo.213.1">This will output </span><span class="No-Break"><span class="koboSpan" id="kobo.214.1">the following:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.215.1">
Person Load (0.7ms)  SELECT  "people".* FROM "people" LIMIT ?  [["LIMIT", 11]]
=&gt; #&lt;Active Record::Relation []&gt;</span></pre> <p><span class="koboSpan" id="kobo.216.1">This output shows a command in the </span><strong class="bold"><span class="koboSpan" id="kobo.217.1">Structured Query Language</span></strong><span class="koboSpan" id="kobo.218.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.219.1">SQL</span></strong><span class="koboSpan" id="kobo.220.1">) used by databases to manipulate data. </span><span class="koboSpan" id="kobo.220.2">SQL is a standard language</span><a id="_idIndexMarker423"/><span class="koboSpan" id="kobo.221.1"> used to “talk” to databases. </span><span class="koboSpan" id="kobo.221.2">Many databases use this language, so you don’t have to learn a different language for each one. </span><span class="koboSpan" id="kobo.221.3">If you wish to know more about SQL, I recommend</span><a id="_idIndexMarker424"/><span class="koboSpan" id="kobo.222.1"> you take a look at </span><span class="No-Break"><span class="koboSpan" id="kobo.223.1">this page:</span></span></p>
<p><a href="https://aws.amazon.com/what-is/sql/"><span class="No-Break"><span class="koboSpan" id="kobo.224.1">https://aws.amazon.com/what-is/sql/</span></span></a></p>
<p><span class="koboSpan" id="kobo.225.1">If you have not encountered SQL commands before, this might seem a little cryptic, but believe me, it is not so bad in reality. </span><span class="koboSpan" id="kobo.225.2">The first part of the output tells us Rails is loading a SQL command, the command being </span><strong class="source-inline"><span class="koboSpan" id="kobo.226.1">SELECT "people".* FROM "people"</span></strong><span class="koboSpan" id="kobo.227.1">. </span><span class="koboSpan" id="kobo.227.2">The star (</span><strong class="source-inline"><span class="koboSpan" id="kobo.228.1">*</span></strong><span class="koboSpan" id="kobo.229.1">) is a filter to select all of the fields associated with the </span><strong class="source-inline"><span class="koboSpan" id="kobo.230.1">people</span></strong><span class="koboSpan" id="kobo.231.1"> table. </span><span class="koboSpan" id="kobo.231.2">In this case, it means that Rails will fetch the ID, </span><strong class="source-inline"><span class="koboSpan" id="kobo.232.1">name</span></strong><span class="koboSpan" id="kobo.233.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.234.1">birthday</span></strong><span class="koboSpan" id="kobo.235.1">, and </span><strong class="source-inline"><span class="koboSpan" id="kobo.236.1">timestamp</span></strong><span class="koboSpan" id="kobo.237.1"> fields. </span><span class="koboSpan" id="kobo.237.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.238.1">FROM</span></strong><span class="koboSpan" id="kobo.239.1"> part of the command tells the database engine to fetch entries from the </span><strong class="source-inline"><span class="koboSpan" id="kobo.240.1">people</span></strong><span class="koboSpan" id="kobo.241.1"> table without any filters. </span><span class="koboSpan" id="kobo.241.2">Lastly, the last line of the output tells us that there are no entries in the people table. </span><span class="koboSpan" id="kobo.241.3">As I mentioned before, the data is still in memory, so now let’s persist the data into the database with the </span><strong class="source-inline"><span class="koboSpan" id="kobo.242.1">save</span></strong><span class="koboSpan" id="kobo.243.1"> method. </span><span class="koboSpan" id="kobo.243.2">Let’s type the following command in the </span><span class="No-Break"><span class="koboSpan" id="kobo.244.1">Rails console:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.245.1">
single_person.save</span></pre> <p><span class="koboSpan" id="kobo.246.1">This will output a message confirming that we saved our data into </span><span class="No-Break"><span class="koboSpan" id="kobo.247.1">the database:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.248.1">
irb(main):006:0&gt; person.save
   (3.1ms)  begin transaction
  SQL (5.8ms)  INSERT INTO "people" ("name", "birthday", "created_at", "updated_at") VALUES (?, ?, ?, ?)  [["name", "Benjamin"], ["birthday", "1986-02-03"], ["created_at", "2023-08-06 22:11:54.475516"], ["updated_at", "2023-08-06 22:11:54.475516"]]
   (0.4ms)  commit transaction
=&gt; true</span></pre> <p><span class="koboSpan" id="kobo.249.1">Now let’s again fetch all of the entries in the database with the </span><span class="No-Break"><span class="koboSpan" id="kobo.250.1">following command:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.251.1">
Person.all</span></pre> <p><span class="koboSpan" id="kobo.252.1">This will return the </span><span class="No-Break"><span class="koboSpan" id="kobo.253.1">following output:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.254.1">
  Person Load (0.9ms)  SELECT  "people".* FROM "people" LIMIT ?  [["LIMIT", 11]]
=&gt; #&lt;Active Record::Relation [#&lt;Person id: 1, name: "Benjamin", birthday: "1986-02-03", created_at: "2023-08-06 22:11:54", updated_at: "2023-08-06 22:11:54"&gt;]&gt;</span></pre> <p><span class="koboSpan" id="kobo.255.1">The last line states that we have indeed persisted information in the database. </span><span class="koboSpan" id="kobo.255.2">If we closed the Rails console and opened it up again, and fetched all the records, we would get the same result as we did just now. </span><span class="koboSpan" id="kobo.255.3">Congratulations, we have successfully connected to a DB using simple but powerful</span><a id="_idIndexMarker425"/><span class="koboSpan" id="kobo.256.1"> commands. </span><span class="koboSpan" id="kobo.256.2">Now it’s time to take full advantage of </span><span class="No-Break"><span class="koboSpan" id="kobo.257.1">Active Record.</span></span></p>
<h1 id="_idParaDest-119"><a id="_idTextAnchor121"/><span class="koboSpan" id="kobo.258.1">Active Record operations</span></h1>
<p><span class="koboSpan" id="kobo.259.1">Active Record is a design pattern</span><a id="_idIndexMarker426"/><span class="koboSpan" id="kobo.260.1"> created to simplify communication with the DB. </span><span class="koboSpan" id="kobo.260.2">Historically, SQL is a standard for communicating with most databases. </span><span class="koboSpan" id="kobo.260.3">However, each database has adopted its own unique set of SQL commands and standards. </span><span class="koboSpan" id="kobo.260.4">While they are all very similar, each one has its own peculiarities, in part because not all databases have the same set of features. </span><span class="koboSpan" id="kobo.260.5">A great article detailing some of the concepts regarding</span><a id="_idIndexMarker427"/><span class="koboSpan" id="kobo.261.1"> the Active Record design pattern is </span><span class="No-Break"><span class="koboSpan" id="kobo.262.1">this one:</span></span></p>
<p><a href="https://blog.savetchuk.com/overview-of-the-active-record-pattern"><span class="No-Break"><span class="koboSpan" id="kobo.263.1">https://blog.savetchuk.com/overview-of-the-active-record-pattern</span></span></a></p>
<p><span class="koboSpan" id="kobo.264.1">As an example, PostgreSQL offers a more sophisticated set of data types than MySQL. </span><span class="koboSpan" id="kobo.264.2">Another example is SQLite in web applications, which is very easy to set up, but does not work well in large applications. </span><span class="koboSpan" id="kobo.264.3">In Rails, SQLite is mostly used for quick setups and development. </span><span class="koboSpan" id="kobo.264.4">Where does Active Record</span><a id="_idIndexMarker428"/><span class="koboSpan" id="kobo.265.1"> come into the picture? </span><span class="koboSpan" id="kobo.265.2">Active Record uses a technique called </span><strong class="bold"><span class="koboSpan" id="kobo.266.1">Object Relational Mapper</span></strong><span class="koboSpan" id="kobo.267.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.268.1">ORM</span></strong><span class="koboSpan" id="kobo.269.1">). </span><span class="koboSpan" id="kobo.269.2">This technique involves “mapping” a database object into a programming object. </span><span class="koboSpan" id="kobo.269.3">An example of this mapping is where an entry on a table becomes an object, and each column becomes an attribute of said object. </span><span class="koboSpan" id="kobo.269.4">Why would we do this? </span><span class="koboSpan" id="kobo.269.5">The simple answer is that, as we are developers, it’s easier to handle objects than SQL commands. </span><span class="koboSpan" id="kobo.269.6">The more complex answer is that Active Record</span><a id="_idIndexMarker429"/><span class="koboSpan" id="kobo.270.1"> uses the same language (objects) and translates these objects into any particular flavor of SQL used by a database. </span><span class="koboSpan" id="kobo.270.2">You could potentially switch the database type (PostgreSQL, MySQL, SQLite, etc.) with very little effort on the developer side. </span><span class="koboSpan" id="kobo.270.3">Actions on the database are executed using more readable commands than SQL syntax. </span><span class="koboSpan" id="kobo.270.4">It’s much easier to learn a few intuitive commands than the whole syntax required for SQL. </span><span class="koboSpan" id="kobo.270.5">We’ve already seen this in action, but let’s see the difference between a simple Active Record command and a SQL command. </span><span class="koboSpan" id="kobo.270.6">While still inside the Rails console, let’s type </span><span class="No-Break"><span class="koboSpan" id="kobo.271.1">the following:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.272.1">
Active Record::Base.connection.execute("Select * from people")</span></pre> <p><span class="koboSpan" id="kobo.273.1">This will return an array of entries inside </span><span class="No-Break"><span class="koboSpan" id="kobo.274.1">our database:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.275.1">
   (4.4ms)  Select * from people
=&gt; [{"id"=&gt;1, "name"=&gt;"Benjamin", "birthday"=&gt;"1986-02-03", "created_at"=&gt;"2023-08-06 22:11:54.475516", "updated_at"=&gt;"2023-08-06 22:11:54.475516"}]</span></pre> <p><span class="koboSpan" id="kobo.276.1">We can get the same result by using the ORM technique used by Active Record with the </span><span class="No-Break"><span class="koboSpan" id="kobo.277.1">following command:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.278.1">
Person.all</span></pre> <p><span class="koboSpan" id="kobo.279.1">The preceding command also returns an array </span><span class="No-Break"><span class="koboSpan" id="kobo.280.1">of entries:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.281.1">
  Person Load (1.9ms)  SELECT  "people".* FROM "people" LIMIT ?  [["LIMIT", 11]]
=&gt; #&lt;Active Record::Relation [#&lt;Person id: 1, name: "Benjamin", birthday: "1986-02-03", created_at: "2023-08-06 22:11:54", updated_at: "2023-08-06 22:11:54"&gt;]&gt;</span></pre> <p><span class="koboSpan" id="kobo.282.1">I don’t know about you, but I think it’s easier to remember </span><strong class="source-inline"><span class="koboSpan" id="kobo.283.1">Person.all</span></strong><span class="koboSpan" id="kobo.284.1"> than </span><strong class="source-inline"><span class="koboSpan" id="kobo.285.1">SELECT * FROM people</span></strong><span class="koboSpan" id="kobo.286.1">. </span><span class="koboSpan" id="kobo.286.2">Don’t get me wrong – it is always</span><a id="_idIndexMarker430"/><span class="koboSpan" id="kobo.287.1"> an advantage having a developer who knows SQL syntax. </span><span class="koboSpan" id="kobo.287.2">However, it’s more advantageous to both know SQL syntax and how to exploit Active Record. </span><span class="koboSpan" id="kobo.287.3">Let’s see other operations we can do with </span><span class="No-Break"><span class="koboSpan" id="kobo.288.1">Active Record.</span></span></p>
<p><span class="koboSpan" id="kobo.289.1">At this point, I believe it would be very useful to install a client to analyze our SQLite data visually. </span><span class="koboSpan" id="kobo.289.2">There are many clients and browser plugins for this task, but I recommend DB Browser</span><a id="_idIndexMarker431"/><span class="koboSpan" id="kobo.290.1"> for SQLite. </span><span class="koboSpan" id="kobo.290.2">You can check out its </span><span class="No-Break"><span class="koboSpan" id="kobo.291.1">page here:</span></span></p>
<p><a href="https://sqlitebrowser.org/"><span class="No-Break"><span class="koboSpan" id="kobo.292.1">https://sqlitebrowser.org/</span></span></a></p>
<p><span class="koboSpan" id="kobo.293.1">This will accomplish the goal of visualizing data on Windows and Mac, and even some distributions of Linux, but for those platforms for which this tool is not available, you can also rely on Chrome’s SQLite</span><a id="_idIndexMarker432"/><span class="koboSpan" id="kobo.294.1"> Manager for Google </span><span class="No-Break"><span class="koboSpan" id="kobo.295.1">Chrome plugin:</span></span></p>
<p><a href="https://chrome.google.com/webstore/detail/sqlite-manager-for-google/aejlocbcokogiclkcfddhfnpajhejmeb"><span class="No-Break"><span class="koboSpan" id="kobo.296.1">https://chrome.google.com/webstore/detail/sqlite-manager-for-google/aejlocbcokogiclkcfddhfnpajhejmeb</span></span></a></p>
<p><span class="koboSpan" id="kobo.297.1">They all work in a similar manner, and besides, we just want to use the tool as a visual </span><span class="No-Break"><span class="koboSpan" id="kobo.298.1">data browser.</span></span></p>
<p><span class="koboSpan" id="kobo.299.1">Once we’ve installed the tool, let’s open the database file. </span><span class="koboSpan" id="kobo.299.2">In this case, the DB file is in </span><strong class="source-inline"><span class="koboSpan" id="kobo.300.1">chapter08/rails5_models/db/development.sqlite3</span></strong><span class="koboSpan" id="kobo.301.1">. </span><span class="koboSpan" id="kobo.301.2">With the DB Browser for SQLite app open, let’s click on the </span><strong class="bold"><span class="koboSpan" id="kobo.302.1">Open Database</span></strong><span class="koboSpan" id="kobo.303.1"> button </span><span class="No-Break"><span class="koboSpan" id="kobo.304.1">shown here:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer046">
<span class="koboSpan" id="kobo.305.1"><img alt="Figure 8.1 – Open Database button in DB Browser for SQLite" src="image/B19230_08_01.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.306.1">Figure 8.1 – Open Database button in DB Browser for SQLite</span></p>
<p><span class="koboSpan" id="kobo.307.1">Then let’s navigate into our </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.308.1">development.sqlite3</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.309.1"> file:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer047">
<span class="koboSpan" id="kobo.310.1"><img alt="Figure 8.2 – Navigating into the sqlite3 file" src="image/B19230_08_02.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.311.1">Figure 8.2 – Navigating into the sqlite3 file</span></p>
<p><span class="koboSpan" id="kobo.312.1">Once we open that file, we will be able to view</span><a id="_idIndexMarker433"/><span class="koboSpan" id="kobo.313.1"> the tables that we’ve created so far, along with a few others that Rails creates on </span><span class="No-Break"><span class="koboSpan" id="kobo.314.1">its own.</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer048">
<span class="koboSpan" id="kobo.315.1"><img alt="Figure 8.3 – Open the people table on DB Browser for SQLite" src="image/B19230_08_03.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.316.1">Figure 8.3 – Open the people table on DB Browser for SQLite</span></p>
<p><span class="koboSpan" id="kobo.317.1">We can ignore all the other tables</span><a id="_idIndexMarker434"/><span class="koboSpan" id="kobo.318.1"> for now, and just focus on the </span><strong class="source-inline"><span class="koboSpan" id="kobo.319.1">people</span></strong><span class="koboSpan" id="kobo.320.1"> table. </span><span class="koboSpan" id="kobo.320.2">As you can see, we have the same columns (</span><strong class="source-inline"><span class="koboSpan" id="kobo.321.1">id</span></strong><span class="koboSpan" id="kobo.322.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.323.1">name</span></strong><span class="koboSpan" id="kobo.324.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.325.1">birthday</span></strong><span class="koboSpan" id="kobo.326.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.327.1">created_at</span></strong><span class="koboSpan" id="kobo.328.1">, and </span><strong class="source-inline"><span class="koboSpan" id="kobo.329.1">updated_at</span></strong><span class="koboSpan" id="kobo.330.1">) as we saw on the </span><strong class="source-inline"><span class="koboSpan" id="kobo.331.1">Person</span></strong><span class="koboSpan" id="kobo.332.1"> object when we created an instance of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.333.1">Person</span></strong><span class="koboSpan" id="kobo.334.1"> model. </span><span class="koboSpan" id="kobo.334.2">But more than the structure, we’re interested in the entries (or records) inside this table. </span><span class="koboSpan" id="kobo.334.3">Let’s right-click on the </span><strong class="source-inline"><span class="koboSpan" id="kobo.335.1">people</span></strong><span class="koboSpan" id="kobo.336.1"> table and let’s select the </span><strong class="bold"><span class="koboSpan" id="kobo.337.1">Browse Table</span></strong><span class="koboSpan" id="kobo.338.1"> option, as shown in the </span><span class="No-Break"><span class="koboSpan" id="kobo.339.1">following screenshot:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer049">
<span class="koboSpan" id="kobo.340.1"><img alt="Figure 8.4 – Browse table data on DB Browser for SQLite" src="image/B19230_08_04.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.341.1">Figure 8.4 – Browse table data on DB Browser for SQLite</span></p>
<p><span class="koboSpan" id="kobo.342.1">Now we should see the single entry that we added when playing around with the </span><span class="No-Break"><span class="koboSpan" id="kobo.343.1">Rails console:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer050">
<span class="koboSpan" id="kobo.344.1"><img alt="Figure 8.5 – Entries on the people table shown on DB Browser for SQLite" src="image/B19230_08_05.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.345.1">Figure 8.5 – Entries on the people table shown on DB Browser for SQLite</span></p>
<p><span class="koboSpan" id="kobo.346.1">The entry should have the same data that we fed to the </span><span class="No-Break"><span class="koboSpan" id="kobo.347.1">Rails console.</span></span></p>
<p><span class="koboSpan" id="kobo.348.1">We’ve confirmed the initial data</span><a id="_idIndexMarker435"/><span class="koboSpan" id="kobo.349.1"> was set correctly, but now it’s time to use Active Record to create new records on </span><span class="No-Break"><span class="koboSpan" id="kobo.350.1">the database.</span></span></p>
<h2 id="_idParaDest-120"><a id="_idTextAnchor122"/><span class="koboSpan" id="kobo.351.1">Creating records</span></h2>
<p><span class="koboSpan" id="kobo.352.1">We previously saw that we could add </span><a id="_idIndexMarker436"/><span class="koboSpan" id="kobo.353.1">entries to our database by creating a </span><strong class="source-inline"><span class="koboSpan" id="kobo.354.1">Person</span></strong><span class="koboSpan" id="kobo.355.1"> object, adding attributes (</span><strong class="source-inline"><span class="koboSpan" id="kobo.356.1">name</span></strong><span class="koboSpan" id="kobo.357.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.358.1">birthday</span></strong><span class="koboSpan" id="kobo.359.1">), and finally saving the record. </span><span class="koboSpan" id="kobo.359.2">But there is a one-liner that does the same thing. </span><span class="koboSpan" id="kobo.359.3">Let’s try the following line inside our </span><span class="No-Break"><span class="koboSpan" id="kobo.360.1">Rails console:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.361.1">
Person.create(name: "Oscarr", birthday: "1981-02-19")</span></pre> <p><span class="koboSpan" id="kobo.362.1">It should output </span><span class="No-Break"><span class="koboSpan" id="kobo.363.1">the following:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.364.1">
   (2.7ms)  begin transaction
  SQL (7.6ms)  INSERT INTO "people" ("name", "birthday", "created_at", "updated_at") VALUES (?, ?, ?, ?)  [["name", "Oscarr"], ["birthday", "1980-02-19"], ["created_at", "2023-08-07 01:14:35.044370"], ["updated_at", "2023-08-07 01:14:35.044370"]]
   (0.5ms)  commit transaction
=&gt; #&lt;Person id: 2, name: "Oscarr", birthday: "1981-02-19", created_at: "2023-08-07 01:14:35", updated_at: "2023-08-07 01:14:35"&gt;</span></pre> <p><span class="koboSpan" id="kobo.365.1">The value for the name </span><strong class="source-inline"><span class="koboSpan" id="kobo.366.1">"Oscarr"</span></strong><span class="koboSpan" id="kobo.367.1"> is on purpose. </span><span class="koboSpan" id="kobo.367.2">As we can see, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.368.1">create</span></strong><span class="koboSpan" id="kobo.369.1"> method generates a SQL statement</span><a id="_idIndexMarker437"/><span class="koboSpan" id="kobo.370.1"> to create a record on the same table we’ve been working on but with different attributes. </span><span class="koboSpan" id="kobo.370.2">The more attributes we have, the more lines of code we would need had we used the other method to add data. </span><span class="koboSpan" id="kobo.370.3">Both ways are valid ways to insert data into our database. </span><span class="koboSpan" id="kobo.370.4">I just wanted to demonstrate both options so that you can choose the one that is more convenient for your specific use case. </span><span class="koboSpan" id="kobo.370.5">Now, let’s confirm that this new entry does in fact exist on the database. </span><span class="koboSpan" id="kobo.370.6">Let’s go back to the DB Browser for SQLite app, and refresh the view either with the refresh button or by pressing </span><em class="italic"><span class="koboSpan" id="kobo.371.1">CMD + R</span></em><span class="koboSpan" id="kobo.372.1"> for Mac users or </span><em class="italic"><span class="koboSpan" id="kobo.373.1">Ctrl + R</span></em><span class="koboSpan" id="kobo.374.1"> for Windows and Linux users. </span><span class="koboSpan" id="kobo.374.2">This should now show the new entry on </span><span class="No-Break"><span class="koboSpan" id="kobo.375.1">the table:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer051">
<span class="koboSpan" id="kobo.376.1"><img alt="Figure 8.6 – New entries on the people table shown on DB Browser for SQLite" src="image/B19230_08_06.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.377.1">Figure 8.6 – New entries on the people table shown on DB Browser for SQLite</span></p>
<p><span class="koboSpan" id="kobo.378.1">Oh, but wait. </span><span class="koboSpan" id="kobo.378.2">We’ve made two mistakes. </span><span class="koboSpan" id="kobo.378.3">I made typo by adding the name </span><strong class="source-inline"><span class="koboSpan" id="kobo.379.1">"Oscarr"</span></strong><span class="koboSpan" id="kobo.380.1"> when I meant to type just </span><strong class="source-inline"><span class="koboSpan" id="kobo.381.1">"Oscar"</span></strong><span class="koboSpan" id="kobo.382.1">. </span><span class="koboSpan" id="kobo.382.2">I also made a mistake with the year, as I meant to add </span><strong class="source-inline"><span class="koboSpan" id="kobo.383.1">1980</span></strong><span class="koboSpan" id="kobo.384.1"> instead of </span><strong class="source-inline"><span class="koboSpan" id="kobo.385.1">1981</span></strong><span class="koboSpan" id="kobo.386.1">. </span><span class="koboSpan" id="kobo.386.2">This fortunate mistake</span><a id="_idIndexMarker438"/><span class="koboSpan" id="kobo.387.1"> brings us to the next </span><span class="No-Break"><span class="koboSpan" id="kobo.388.1">operation: </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.389.1">SELECT</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.390.1">.</span></span></p>
<h2 id="_idParaDest-121"><a id="_idTextAnchor123"/><span class="koboSpan" id="kobo.391.1">Selecting record(s)</span></h2>
<p><span class="koboSpan" id="kobo.392.1">So far, we’ve seen one method</span><a id="_idIndexMarker439"/><span class="koboSpan" id="kobo.393.1"> to select all of our entries: the </span><strong class="source-inline"><span class="koboSpan" id="kobo.394.1">all</span></strong><span class="koboSpan" id="kobo.395.1"> method. </span><span class="koboSpan" id="kobo.395.2">But Active Record comes with two other very useful methods: </span><strong class="source-inline"><span class="koboSpan" id="kobo.396.1">first</span></strong><span class="koboSpan" id="kobo.397.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.398.1">last</span></strong><span class="koboSpan" id="kobo.399.1"> . </span><span class="koboSpan" id="kobo.399.2">As the name implies, we can select the first record of any selection. </span><span class="koboSpan" id="kobo.399.3">Let’s do that by typing the following command on the </span><span class="No-Break"><span class="koboSpan" id="kobo.400.1">Rails console:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.401.1">
Person.all.first</span></pre> <p><span class="koboSpan" id="kobo.402.1">This should return the </span><span class="No-Break"><span class="koboSpan" id="kobo.403.1">following output:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.404.1">
  Person Load (0.9ms)  SELECT  "people".* FROM "people" ORDER BY "people"."id" ASC LIMIT ?  [["LIMIT", 1]]
=&gt; #&lt;Person id: 1, name: "Benjamin", birthday: "1986-02-03", created_at: "2023-08-06 22:11:54", updated_at: "2023-08-07 02:20:36"&gt;</span></pre> <p><span class="koboSpan" id="kobo.405.1">As you can see, the command selects the very first entry from our </span><strong class="source-inline"><span class="koboSpan" id="kobo.406.1">people</span></strong><span class="koboSpan" id="kobo.407.1"> table. </span><span class="koboSpan" id="kobo.407.2">Now let’s try the </span><strong class="source-inline"><span class="koboSpan" id="kobo.408.1">last</span></strong><span class="koboSpan" id="kobo.409.1"> method by typing the following on the </span><span class="No-Break"><span class="koboSpan" id="kobo.410.1">Rails console:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.411.1">
Person.all.last</span></pre> <p><span class="koboSpan" id="kobo.412.1">This should output </span><span class="No-Break"><span class="koboSpan" id="kobo.413.1">the following:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.414.1">
  Person Load (1.8ms)  SELECT  "people".* FROM "people" ORDER BY "people"."id" DESC LIMIT ?  [["LIMIT", 1]]
=&gt; #&lt;Person id: 2, name: "Oscarr", birthday: "1981-02-19", created_at: "2023-08-07 01:14:35", updated_at: "2023-08-07 02:24:21"&gt;</span></pre> <p><span class="koboSpan" id="kobo.415.1">We’ve selected the last record on our database. </span><span class="koboSpan" id="kobo.415.2">These methods come in handy when looking for test data. </span><span class="koboSpan" id="kobo.415.3">Now let’s use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.416.1">where</span></strong><span class="koboSpan" id="kobo.417.1"> method to filter data by a determined field. </span><span class="koboSpan" id="kobo.417.2">Let’s try the following code on the </span><span class="No-Break"><span class="koboSpan" id="kobo.418.1">Rails console:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.419.1">
Person.where( name: "Benjamin" )</span></pre> <p><span class="koboSpan" id="kobo.420.1">This will output </span><span class="No-Break"><span class="koboSpan" id="kobo.421.1">the following:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.422.1">
  Person Load (0.9ms)  SELECT  "people".* FROM "people" WHERE "people"."name" = ? </span><span class="koboSpan" id="kobo.422.2">LIMIT ?  [["name", "Benjamin"], ["LIMIT", 11]]
=&gt; #&lt;Active Record::Relation [#&lt;Person id: 1, name: "Benjamin", birthday: "1986-02-03", created_at: "2023-08-06 22:11:54", updated_at: "2023-08-07 02:20:36"&gt;]&gt;</span></pre> <p><span class="koboSpan" id="kobo.423.1">This code has selected all entries</span><a id="_idIndexMarker440"/><span class="koboSpan" id="kobo.424.1"> that have the name </span><strong class="source-inline"><span class="koboSpan" id="kobo.425.1">"Benjamin"</span></strong><span class="koboSpan" id="kobo.426.1">. </span><span class="koboSpan" id="kobo.426.2">In this case, there is just one entry. </span><span class="koboSpan" id="kobo.426.3">However, there is a little catch here that we should be careful with. </span><span class="koboSpan" id="kobo.426.4">Notice that after the word </span><strong class="source-inline"><span class="koboSpan" id="kobo.427.1">Relation</span></strong><span class="koboSpan" id="kobo.428.1"> in the previous output, there is a square bracket (</span><strong class="source-inline"><span class="koboSpan" id="kobo.429.1">[</span></strong><span class="koboSpan" id="kobo.430.1">), which is eventually closed almost at the end of the line (</span><strong class="source-inline"><span class="koboSpan" id="kobo.431.1">&gt;]&gt;</span></strong><span class="koboSpan" id="kobo.432.1">). </span><span class="koboSpan" id="kobo.432.2">This is because when we use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.433.1">where</span></strong><span class="koboSpan" id="kobo.434.1"> method, it always returns an array of objects. </span><span class="koboSpan" id="kobo.434.2">This is useful when displaying data on a grid or table on the view, but can be tricky when we want to select a single entry. </span><span class="koboSpan" id="kobo.434.3">Now, let’s talk about selecting single records. </span><span class="koboSpan" id="kobo.434.4">Before updating any record, we need to select which record we’re going to modify. </span><span class="koboSpan" id="kobo.434.5">For that purpose, the implementation of Active Record on Rails comes with two handy methods. </span><span class="koboSpan" id="kobo.434.6">The first one is </span><strong class="source-inline"><span class="koboSpan" id="kobo.435.1">find_by</span></strong><span class="koboSpan" id="kobo.436.1">. </span><span class="koboSpan" id="kobo.436.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.437.1">find_by</span></strong><span class="koboSpan" id="kobo.438.1"> method requires a parameter in the form of a hash that includes the attribute that we want to filter, followed by the value. </span><span class="koboSpan" id="kobo.438.2">In this case, we want to filter by the </span><strong class="source-inline"><span class="koboSpan" id="kobo.439.1">name</span></strong><span class="koboSpan" id="kobo.440.1"> attribute and the </span><strong class="source-inline"><span class="koboSpan" id="kobo.441.1">Oscarr</span></strong><span class="koboSpan" id="kobo.442.1"> value. </span><span class="koboSpan" id="kobo.442.2">Let’s test this by typing the following on the </span><span class="No-Break"><span class="koboSpan" id="kobo.443.1">Rails console:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.444.1">
found_person = Person.find_by name:"Oscarr"</span></pre> <p><span class="koboSpan" id="kobo.445.1">This will return the </span><span class="No-Break"><span class="koboSpan" id="kobo.446.1">following output:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.447.1">
irb(main):002:0&gt; found_person = Person.find_by name:"Oscarr"
  Person Load (0.8ms)  SELECT  "people".* FROM "people" WHERE "people"."name" = ? </span><span class="koboSpan" id="kobo.447.2">LIMIT ?  [["name", "Oscarr"], ["LIMIT", 1]]
=&gt; #&lt;Person id: 2, name: "Oscarr", birthday: "1981-02-19", created_at: "2023-08-07 01:14:35", updated_at: "2023-08-07 01:14:35"&gt;</span></pre> <p><span class="koboSpan" id="kobo.448.1">Rails returns the first entry that it finds with the criteria that we supplied to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.449.1">find_by</span></strong><span class="koboSpan" id="kobo.450.1"> method. </span><span class="koboSpan" id="kobo.450.2">In this case, it finds the first entry that complies with having the name equal to </span><strong class="source-inline"><span class="koboSpan" id="kobo.451.1">"Oscarr"</span></strong><span class="koboSpan" id="kobo.452.1">. </span><span class="koboSpan" id="kobo.452.2">We can confirm this by typing any attribute and viewing its contents. </span><span class="koboSpan" id="kobo.452.3">Let’s try this by typing the following line in the </span><span class="No-Break"><span class="koboSpan" id="kobo.453.1">Rails console:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.454.1">
found_person.id</span></pre> <p><span class="koboSpan" id="kobo.455.1">And this will return the </span><span class="No-Break"><span class="koboSpan" id="kobo.456.1">following output:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.457.1">
2</span></pre> <p><span class="koboSpan" id="kobo.458.1">We can do the same with any other attribute. </span><span class="koboSpan" id="kobo.458.2">Let’s try it with the </span><strong class="source-inline"><span class="koboSpan" id="kobo.459.1">birthday</span></strong><span class="koboSpan" id="kobo.460.1"> attribute. </span><span class="koboSpan" id="kobo.460.2">Let’s type the following on our </span><span class="No-Break"><span class="koboSpan" id="kobo.461.1">Rails console:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.462.1">
found_person.birthday</span></pre> <p><span class="koboSpan" id="kobo.463.1">And we should get the </span><span class="No-Break"><span class="koboSpan" id="kobo.464.1">following output:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.465.1">
Thu, 19 Feb 1981</span></pre> <p><span class="koboSpan" id="kobo.466.1">So, as you can see, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.467.1">found_person</span></strong><span class="koboSpan" id="kobo.468.1"> object has the entry that we were looking for. </span><span class="koboSpan" id="kobo.468.2">However, this comes with a caveat. </span><span class="koboSpan" id="kobo.468.3">There may be more than one person with the same name. </span><span class="koboSpan" id="kobo.468.4">If we were looking to select the second person, then our code would fail as the </span><strong class="source-inline"><span class="koboSpan" id="kobo.469.1">find_by</span></strong><span class="koboSpan" id="kobo.470.1"> method automatically returns the first found entry. </span><span class="koboSpan" id="kobo.470.2">To solve this conundrum, Active Record provides a special method called </span><strong class="source-inline"><span class="koboSpan" id="kobo.471.1">find</span></strong><span class="koboSpan" id="kobo.472.1">. </span><span class="koboSpan" id="kobo.472.2">This method assumes that our table has an </span><strong class="source-inline"><span class="koboSpan" id="kobo.473.1">id</span></strong><span class="koboSpan" id="kobo.474.1"> column, which is unique for each entry. </span><span class="koboSpan" id="kobo.474.2">So, in our previous use case, if there were two people with the same name, we would just filter it by the unique ID. </span><span class="koboSpan" id="kobo.474.3">In this case, we would just type the following in our </span><span class="No-Break"><span class="koboSpan" id="kobo.475.1">Rails console:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.476.1">
found_person = Person.find(2)</span></pre> <p><span class="koboSpan" id="kobo.477.1">And this would output the same </span><span class="No-Break"><span class="koboSpan" id="kobo.478.1">as before:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.479.1">
irb(main):015:0&gt; Person.find(2)
  Person Load (4.6ms)  SELECT  "people".* FROM "people" WHERE "people"."id" = ? </span><span class="koboSpan" id="kobo.479.2">LIMIT ?  [["id", 2], ["LIMIT", 1]]
=&gt; #&lt;Person id: 2, name: "Oscarr", birthday: "1981-02-19", created_at: "2023-08-07 01:14:35", updated_at: "2023-08-07 01:14:35"&gt;</span></pre> <p><span class="koboSpan" id="kobo.480.1">Should there be another entry with the same</span><a id="_idIndexMarker441"/><span class="koboSpan" id="kobo.481.1"> name, it wouldn’t matter to us. </span><span class="koboSpan" id="kobo.481.2">Our code would select the one with the </span><strong class="source-inline"><span class="koboSpan" id="kobo.482.1">id</span></strong><span class="koboSpan" id="kobo.483.1"> equal to </span><strong class="source-inline"><span class="koboSpan" id="kobo.484.1">2</span></strong><span class="koboSpan" id="kobo.485.1">. </span><span class="koboSpan" id="kobo.485.2">Now that we’ve selected an entry, let’s move on to updating </span><span class="No-Break"><span class="koboSpan" id="kobo.486.1">its contents.</span></span></p>
<h2 id="_idParaDest-122"><a id="_idTextAnchor124"/><span class="koboSpan" id="kobo.487.1">Updating records</span></h2>
<p><span class="koboSpan" id="kobo.488.1">Just like creating records, there are a couple</span><a id="_idIndexMarker442"/><span class="koboSpan" id="kobo.489.1"> of ways that we can update a record in the database. </span><span class="koboSpan" id="kobo.489.2">Since we’ve already selected our record that has a typo in the name, let’s see the first option we can use to update records. </span><span class="koboSpan" id="kobo.489.3">Let’s say we typed the following code into our </span><span class="No-Break"><span class="koboSpan" id="kobo.490.1">Rails console:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.491.1">
found_person</span></pre> <p><span class="koboSpan" id="kobo.492.1">This would output the </span><span class="No-Break"><span class="koboSpan" id="kobo.493.1">following record:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.494.1">
=&gt; #&lt;Person id: 2, name: "Oscarr", birthday: "1981-02-19", created_at: "2023-08-07 01:14:35", updated_at: "2023-08-07 01:14:35"&gt;</span></pre> <p><span class="koboSpan" id="kobo.495.1">With this, we can confirm that this is the right record we want to modify. </span><span class="koboSpan" id="kobo.495.2">To modify the name, we would type the following code on our </span><span class="No-Break"><span class="koboSpan" id="kobo.496.1">Rails console:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.497.1">
found_person.name = "Oscar"</span></pre> <p><span class="koboSpan" id="kobo.498.1">This would just output the string we have just assigned to our </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.499.1">name</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.500.1"> attribute:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.501.1">
=&gt; "Oscar"</span></pre> <p><span class="koboSpan" id="kobo.502.1">But remember what we said about the object: this change is still only in memory. </span><span class="koboSpan" id="kobo.502.2">We need to persist the change. </span><span class="koboSpan" id="kobo.502.3">We would use the same </span><strong class="source-inline"><span class="koboSpan" id="kobo.503.1">save</span></strong><span class="koboSpan" id="kobo.504.1"> method as before. </span><span class="koboSpan" id="kobo.504.2">Let’s type the following on the </span><span class="No-Break"><span class="koboSpan" id="kobo.505.1">Rails console:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.506.1">
found_person.save</span></pre> <p><span class="koboSpan" id="kobo.507.1">This would output </span><span class="No-Break"><span class="koboSpan" id="kobo.508.1">the following:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.509.1">
irb(main):019:0&gt; found_person.save
   (0.3ms)  begin transaction
  SQL (0.4ms)  UPDATE "people" SET "name" = ?, "updated_at" = ? </span><span class="koboSpan" id="kobo.509.2">WHERE "people"."id" = ?  [["name", "Oscar"], ["updated_at", "2023-08-07 02:14:06.188761"], ["id", 2]]
   (0.9ms)  commit transaction
=&gt; true</span></pre> <p><span class="koboSpan" id="kobo.510.1">This will save our change into the database and return a true value. </span><span class="koboSpan" id="kobo.510.2">This true value will come in handy later on in the next chapter. </span><span class="koboSpan" id="kobo.510.3">But for now, we can just confirm this change by opening DB Browser for SQLite and refreshing the view. </span><span class="koboSpan" id="kobo.510.4">It should now show the </span><span class="No-Break"><span class="koboSpan" id="kobo.511.1">correct name:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer052">
<span class="koboSpan" id="kobo.512.1"><img alt="Figure 8.7 – Modified entry on the people table as shown in DB Browser for SQLite" src="image/B19230_08_07.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.513.1">Figure 8.7 – Modified entry on the people table as shown in DB Browser for SQLite</span></p>
<p><span class="koboSpan" id="kobo.514.1">That was one way to modify a record. </span><span class="koboSpan" id="kobo.514.2">However, there is another way using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.515.1">update</span></strong><span class="koboSpan" id="kobo.516.1"> method. </span><span class="koboSpan" id="kobo.516.2">Let’s try it with the following code on the </span><span class="No-Break"><span class="koboSpan" id="kobo.517.1">Rails console:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.518.1">
found_person.update(birthday: "1980-02-19")</span></pre> <p><span class="koboSpan" id="kobo.519.1">This would output </span><span class="No-Break"><span class="koboSpan" id="kobo.520.1">the following:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.521.1">
   (0.4ms)  begin transaction
  SQL (0.4ms)  UPDATE "people" SET "birthday" = ?, "updated_at" = ? </span><span class="koboSpan" id="kobo.521.2">WHERE "people"."id" = ?  [["birthday", "1980-02-19"], ["updated_at", "2023-08-07 02:24:21.753388"], ["id", 2]]
   (0.7ms)  commit transaction
=&gt; true</span></pre> <p><span class="koboSpan" id="kobo.522.1">Now let’s confirm the change</span><a id="_idIndexMarker443"/><span class="koboSpan" id="kobo.523.1"> again on the DB Browser for SQLite app. </span><span class="koboSpan" id="kobo.523.2">Let’s just refresh the view and we should see the change </span><span class="No-Break"><span class="koboSpan" id="kobo.524.1">show up:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer053">
<span class="koboSpan" id="kobo.525.1"><img alt="Figure 8.8 – Updated entry on the people table as shown in DB Browser for SQLite" src="image/B19230_08_08.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.526.1">Figure 8.8 – Updated entry on the people table as shown in DB Browser for SQLite</span></p>
<p><span class="koboSpan" id="kobo.527.1">So as you can see, we’ve updated our record in two different ways. </span><span class="koboSpan" id="kobo.527.2">Again, both of these methods are valid and you can choose</span><a id="_idIndexMarker444"/><span class="koboSpan" id="kobo.528.1"> whichever method fits your needs more. </span><span class="koboSpan" id="kobo.528.2">Now let’s look at the last method (for now), which is the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.529.1">destroy</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.530.1"> method.</span></span></p>
<h2 id="_idParaDest-123"><a id="_idTextAnchor125"/><span class="koboSpan" id="kobo.531.1">Deleting record(s)</span></h2>
<p><span class="koboSpan" id="kobo.532.1">So far, we’ve created, selected, and updated </span><a id="_idIndexMarker445"/><span class="koboSpan" id="kobo.533.1">records in our database. </span><span class="koboSpan" id="kobo.533.2">The last Active Record action we’re going to look at is the destroy action. </span><span class="koboSpan" id="kobo.533.3">You should be especially careful with this action as this deletes data from your database without any confirmation required beforehand. </span><span class="koboSpan" id="kobo.533.4">Furthermore, this action is permanent – once the destroy action has been done, it cannot be reverted. </span><span class="koboSpan" id="kobo.533.5">So, let’s first create another entry with the following command on the </span><span class="No-Break"><span class="koboSpan" id="kobo.534.1">Rails console:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.535.1">
Person.create( name: "Bernard", birthday: "1981-07-16" )</span></pre> <p><span class="koboSpan" id="kobo.536.1">This should output </span><span class="No-Break"><span class="koboSpan" id="kobo.537.1">the following:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.538.1">
   (0.5ms)  begin transaction
  SQL (1.0ms)  INSERT INTO "people" ("name", "birthday", "created_at", "updated_at") VALUES (?, ?, ?, ?)  [["name", "Bernard"], ["birthday", "1981-07-16"], ["created_at", "2023-08-07 02:37:29.615141"], ["updated_at", "2023-08-07 02:37:29.615141"]]
   (0.4ms)  commit transaction
=&gt; #&lt;Person id: 3, name: "Bernard", birthday: "1981-07-16", created_at: "2023-08-07 02:37:29", updated_at: "2023-08-07 02:37:29"&gt;</span></pre> <p><span class="koboSpan" id="kobo.539.1">And once again, let’s refresh</span><a id="_idIndexMarker446"/><span class="koboSpan" id="kobo.540.1"> our view on the DB Browser for </span><span class="No-Break"><span class="koboSpan" id="kobo.541.1">SQLite app:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer054">
<span class="koboSpan" id="kobo.542.1"><img alt="Figure 8.9 – New entry on the people table as shown in DB Browser for SQLite" src="image/B19230_08_09.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.543.1">Figure 8.9 – New entry on the people table as shown in DB Browser for SQLite</span></p>
<p><span class="koboSpan" id="kobo.544.1">Now that we’ve confirmed that the new entry exists, we can proceed to delete it. </span><span class="koboSpan" id="kobo.544.2">Just like the </span><strong class="source-inline"><span class="koboSpan" id="kobo.545.1">update</span></strong><span class="koboSpan" id="kobo.546.1"> method, we first must select an entry on the database. </span><span class="koboSpan" id="kobo.546.2">Let’s do this by typing the following on the </span><span class="No-Break"><span class="koboSpan" id="kobo.547.1">Rails console:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.548.1">
person_to_delete = Person.find(3)</span></pre> <p><span class="koboSpan" id="kobo.549.1">This should output </span><span class="No-Break"><span class="koboSpan" id="kobo.550.1">the following:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.551.1">
  Person Load (0.4ms)  SELECT  "people".* FROM "people" WHERE "people"."id" = ? </span><span class="koboSpan" id="kobo.551.2">LIMIT ?  [["id", 3], ["LIMIT", 1]]
=&gt; #&lt;Person id: 3, name: "Bernard", birthday: "1981-07-16", created_at: "2023-08-07 02:39:56", updated_at: "2023-08-07 02:39:56"&gt;</span></pre> <p><span class="koboSpan" id="kobo.552.1">With this, we confirm that we’ve selected the right record. </span><span class="koboSpan" id="kobo.552.2">Finally, let’s delete the record with the following code on our </span><span class="No-Break"><span class="koboSpan" id="kobo.553.1">Rails console:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.554.1">
person_to_delete.destroy</span></pre> <p><span class="koboSpan" id="kobo.555.1">This would output </span><span class="No-Break"><span class="koboSpan" id="kobo.556.1">the following:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.557.1">
   (0.5ms)  begin transaction
  SQL (0.5ms)  DELETE FROM "people" WHERE "people"."id" = ?  [["id", 3]]
   (0.9ms)  commit transaction
=&gt; #&lt;Person id: 3, name: "Bernard", birthday: "1981-07-16", created_at: "2023-08-07 02:39:56", updated_at: "2023-08-07 02:39:56"&gt;</span></pre> <p><span class="koboSpan" id="kobo.558.1">As you can see, it generated </span><a id="_idIndexMarker447"/><span class="koboSpan" id="kobo.559.1">and executed the code to delete the entry. </span><span class="koboSpan" id="kobo.559.2">If we go to our DB Browser for SQLite app and refresh the view, we should see that the entry no </span><span class="No-Break"><span class="koboSpan" id="kobo.560.1">longer exists:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer055">
<span class="koboSpan" id="kobo.561.1"><img alt="Figure 8.9 – Deleted entry on the people table as shown in DB Browser for SQLite" src="image/B19230_08_10.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.562.1">Figure 8.10 – Deleted entry on the people table as shown in DB Browser for SQLite</span></p>
<p><span class="koboSpan" id="kobo.563.1">As we can see, the entry has been deleted and is forever gone. </span><span class="koboSpan" id="kobo.563.2">I cannot stress enough how dangerous this operation can be when developing an application. </span><span class="koboSpan" id="kobo.563.3">All I can say is, be careful while </span><span class="No-Break"><span class="koboSpan" id="kobo.564.1">using it.</span></span></p>
<p><span class="koboSpan" id="kobo.565.1">You may have noticed that all the data manipulation on the database was done through the Rails console. </span><span class="koboSpan" id="kobo.565.2">This is because I believe the Rails console is the easiest way to understand and learn how to use Active Record actions. </span><span class="koboSpan" id="kobo.565.3">Once we have mastered these easy-to-use intuitive methods, then applying this knowledge in our controllers and views can be achieved without any difficulty whatsoever. </span><span class="koboSpan" id="kobo.565.4">Should you wish to learn more about these Active Record actions, please</span><a id="_idIndexMarker448"/><span class="koboSpan" id="kobo.566.1"> take a look at the</span><a id="_idIndexMarker449"/><span class="koboSpan" id="kobo.567.1"> Active Record </span><span class="No-Break"><span class="koboSpan" id="kobo.568.1">basics page:</span></span></p>
<p><a href="https://guides.rubyonrails.org/active_record_basics.html"><span class="No-Break"><span class="koboSpan" id="kobo.569.1">https://guides.rubyonrails.org/active_record_basics.html</span></span></a></p>
<h1 id="_idParaDest-124"><a id="_idTextAnchor126"/><span class="koboSpan" id="kobo.570.1">Summary</span></h1>
<p><span class="koboSpan" id="kobo.571.1">In this chapter, we learned about models, migrations, and the Rails console as the go-to tool to easily manipulate data on a database. </span><span class="koboSpan" id="kobo.571.2">We also learned how useful the implementation of Active Record is on Rails and how we can communicate with a database with very easy-to-use commands. </span><span class="koboSpan" id="kobo.571.3">Now we are ready to put it all together by fetching data from a database and displaying it on the view, which is what we’ll be doing in the </span><span class="No-Break"><span class="koboSpan" id="kobo.572.1">next chapter.</span></span></p>
</div>
</body></html>