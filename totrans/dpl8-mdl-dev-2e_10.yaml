- en: Access Control
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 访问控制
- en: We've already talked about quite a few topics in the previous chapters, but
    we have been purposefully omitting an important aspect in many of them—access
    control. Much of what we covered deals in some way or another with access, but
    we have kept it out of our discussions to keep things more to the point. However,
    access control is an immensely important topic for Drupal development because
    it has implications in almost everything we do. So, for this purpose, we have
    a chapter dedicated to it in which we will cover the most important things you
    need to know in order to keep your application secure.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的章节中，我们已经讨论了许多主题，但我们故意在许多主题中省略了一个重要的方面——访问控制。我们涵盖的大部分内容以某种方式或另一种方式涉及访问，但我们将其排除在我们的讨论之外，以使事情更加直接。然而，访问控制对于Drupal开发来说是一个极其重要的主题，因为它几乎影响我们做的每一件事。因此，为此目的，我们有一个专门的章节，我们将涵盖你需要知道的最重要的事情，以便保持你的应用程序安全。
- en: When I say secure, I don't mean writing code in a secure way to avoid your site
    getting hacked. For that, we have an appendix at the end of the book to give you
    some pointers. Instead, I mean handling access control programmatically to ensure
    that your pages and any other resources are only accessible to the right users.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 当我说“安全”时，我并不是指以安全的方式编写代码来防止你的网站被黑客攻击。为此，我们在书的末尾有一个附录，为你提供一些指导。相反，我的意思是程序化地处理访问控制，以确保你的页面和任何其他资源只对正确的用户可访问。
- en: In this chapter, aside from introducing new concepts that stand on their own,
    we'll be revisiting some of the previous topics and seeing how we can apply access
    control in that context. We will start by talking about how Drupal sees access
    restrictions at a high level, but then dive deep into more specific and complex
    examples. Also, as usual, we will see code in order to better understand what
    we're talking about.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，除了介绍一些独立的概念之外，我们还将回顾一些先前的主题，并了解我们如何在那个环境中应用访问控制。我们将从讨论Drupal在高级别如何看待访问限制开始，然后深入到更具体和复杂的例子。同样，我们还将看到代码，以便更好地理解我们在谈论什么。
- en: However, what exactly are we going to learn in this chapter?
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，我们将在本章中具体学习什么呢？
- en: First, we will introduce the Drupal access system of roles and permissions and
    see how we can create them in our code. Even more importantly for us as module
    developers, we will see how we can check whether users have permissions programmatically.
    This is still while keeping things general.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将介绍Drupal的角色和权限访问系统，并了解我们如何在代码中创建它们。对我们作为模块开发者来说，更重要的是，我们将了解我们如何以编程方式检查用户是否有权限。这仍然是在保持事情一般性的同时进行的。
- en: Next, we will dive into more exciting things by looking at route permissions.
    We have enormous flexibility here and we'll explore a number of approaches we
    can use to restrict access to custom and existing routes—ranging from simply permission-based
    access control to dynamic service-oriented access handlers.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将通过查看路由权限来深入了解更多有趣的内容。在这里，我们有巨大的灵活性，我们将探讨我们可以用来限制对自定义和现有路由的访问的多种方法——从简单的基于权限的访问控制到动态面向服务的访问处理器。
- en: After covering routes, we will look at entities and how access control works
    with them. In doing so, we will work a bit on the Product entity we created in
    [Chapter 7](392cdb70-e52a-42d1-b782-28d6eb726810.xhtml), *Your Own Custom Entity
    and Plugin Types*. Moreover, we will also talk about the *Node Access Grants*
    system, which is a powerful way to control access specific to the Node entity
    type.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在覆盖了路由之后，我们将查看实体以及访问控制如何与它们一起工作。在这个过程中，我们将对我们在第7章中创建的“你自己的自定义实体和插件类型”的Product实体进行一些工作。[第7章](392cdb70-e52a-42d1-b782-28d6eb726810.xhtml)。此外，我们还将讨论*节点访问权限*系统，这是一个针对节点实体类型的特定访问控制的有力方式。
- en: Finally, we will also look at Block plugins and see how we can control access
    and ensure that they are rendered on the page. Blocks can have certain contextual
    rules that determine whether they are displayed on a certain page in the region
    they have been added to. So, we will talk about that a bit as well.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们还将查看块插件，并了解我们如何控制访问以及确保它们在页面上渲染。块可以有一些上下文规则，这些规则决定了它们是否在添加到的区域中的某个页面上显示。因此，我们也会就此进行一些讨论。
- en: The purpose of this chapter is to bring together all aspects related to access
    control that you need to get started as a Drupal 8 module developer. However,
    you can expect even more than that, and for this reason, this chapter can also
    serve as a resource for coming back and reading up on certain approaches to access
    control you may want to use in your own project, rather than having them scattered
    across the book.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: '本章的目的是汇集您作为Drupal 8模块开发者开始所需的所有与访问控制相关的方面。然而，您可以期待更多，因此，本章也可以作为资源，用于返回阅读您可能在自己的项目中想要使用的某些访问控制方法，而不是让它们散布在书中。 '
- en: Introduction to the Drupal access system
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Drupal访问系统简介
- en: If you've been doing some site building in Drupal 8 or have experience with
    previous versions of Drupal, you may already know a thing or two about roles and
    permissions. If not, no need to worry, as we will talk a bit about how these work.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您已经在Drupal 8中做过一些站点构建或对之前的Drupal版本有经验，您可能已经对角色和权限有所了解。如果没有，无需担心，因为我们将简要讨论这些是如何工作的。
- en: 'Essentially, one of the things that makes Drupal special is the flexible access
    system it has out of the box, based on user roles and permissions. Roles are attributes
    that can be given to a user. The latter can have multiple roles assigned, but
    always has at least the default *Authenticated User *role. Permissions are the
    individual access indicators that can be assigned to roles. By the transitive
    property, users have all the permissions assigned to the roles they have been
    assigned. So, the end result is a matrix of permissions by role, and that''s actually
    how it is visualized in the UI at `admin/people/permissions`:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，使Drupal特别的一个因素是其开箱即用的灵活访问系统，该系统基于用户角色和权限。角色是可以赋予用户的属性。后者可以分配多个角色，但始终至少有默认的*认证用户*角色。权限是可以分配给角色的个别访问指示器。通过传递属性，用户拥有分配给他们的所有角色的权限。因此，最终结果是按角色划分的权限矩阵，这正是它在UI中的`admin/people/permissions`视图中所展示的：
- en: '![](img/60a2b1dd-bc57-4238-ada7-44f14ad3cec6.png)'
  id: totrans-13
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/60a2b1dd-bc57-4238-ada7-44f14ad3cec6.png)'
- en: Drupal core, by default, comes with three roles—**ANONYMOUS USER**, **AUTHENTICATED
    USER**, and **ADMINISTRATOR**. Also, by default, there are a large number of permissions
    already defined by Drupal core (and contributed) modules, ready to be assigned
    to various roles.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: Drupal核心默认包含三个角色——**匿名用户**、**认证用户**和**管理员**。此外，默认情况下，Drupal核心（和贡献）模块已经定义了大量权限，可供分配给各种角色。
- en: The anonymous user role is pretty self-explanatory and can be used as a bucket
    for the permissions all anonymous users should have—that is, users who are not
    authenticated. Similarly, the authenticated user role is automatically assigned
    to all users upon logging in (and cannot be removed). So, it can be used as a
    bucket of permissions that all authenticated users should have.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 匿名用户角色相当直观，可以用作所有匿名用户应拥有的权限的集合——即未认证的用户。同样，认证用户角色在登录时自动分配给所有用户（且不能被移除）。因此，它可以用作所有认证用户应拥有的权限的集合。
- en: The super admin user (the one with the ID = 1) actually has all the permissions
    on the site without having to explicitly assign roles or permissions. Most of
    the time, it bypasses most of the access control in any given subsystem.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 超级管理员用户（ID为1的那个用户）实际上拥有该网站的所有权限，无需显式分配角色或权限。大多数情况下，它绕过了任何给定子系统中大部分的访问控制。
- en: Roles and permissions under the hood
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 内部角色和权限
- en: Roles are configuration entities (`user_role`) represented by the `Role` entity
    type class. They can be created through the UI and exported as configuration to
    be available on all the environments. As such, there is not much you need to do
    in your code to define a role, but simply create them as needed in the UI and
    export them to configuration. As you remember, if you want your role to be provided
    by your module, add the exported YAML file to the `config/install` folder (and
    remove the UUID). Refer to [Chapter 6](77cab458-5612-468c-8010-12385708eb81.xhtml),
    *Data Modeling and Storage*, for more information.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 角色是配置实体（`user_role`），由`Role`实体类型类表示。它们可以通过UI创建，并作为配置导出，以便在所有环境中可用。因此，在您的代码中定义角色时，您不需要做很多事情，只需在UI中按需创建它们并将它们导出到配置即可。如您所记得的，如果您想由您的模块提供角色，请将导出的YAML文件添加到`config/install`文件夹中（并删除UUID）。有关更多信息，请参阅[第6章](77cab458-5612-468c-8010-12385708eb81.xhtml)，*数据建模和存储*。
- en: Permissions, on the other hand, are a custom construct. In Drupal 7 they used
    to be defined by implementing `hook_permissions()`, but are now created using
    a YAML file (very similar to how we define menu links). However, they are not
    plugins, but a custom construct created by the core User module. The `PermissionHandler`
    service is responsible for reading all the YAML files and figuring out all the
    existing permissions on the site. This is not something you need to worry about,
    as you won't be interacting with this service. You'll mostly be interested in
    defining new permissions and checking whether a user has them, or setting those
    permissions in various access contexts.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，权限是一个自定义构造。在 Drupal 7 中，它们通过实现 `hook_permissions()` 来定义，但现在是通过 YAML 文件创建的（与我们定义菜单链接的方式非常相似）。然而，它们不是插件，而是由核心用户模块创建的自定义构造。`PermissionHandler`
    服务负责读取所有 YAML 文件并确定网站上所有现有的权限。这不是你需要担心的事情，因为你不会与这个服务交互。你主要会对定义新权限、检查用户是否拥有这些权限，或在各种访问上下文中设置这些权限感兴趣。
- en: Defining permissions
  id: totrans-20
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 定义权限
- en: 'The way to create permissions in a custom module is by creating a `*.permissions.yml`
    file and adding the definitions in there. Consider the following example:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 在自定义模块中创建权限的方式是创建一个 `*.permissions.yml` 文件，并在其中添加定义。考虑以下示例：
- en: '[PRE0]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'In this example, `administer my feature` is the machine name of the permission
    and actually the most important part. This is what you will use in your code to
    reference it. Then, we have a title that shows up on the permissions management
    page we saw earlier. Finally, we have a `restrict access` key by which we can
    specify whether we need a warning to be output on the permissions management page
    regarding the security implications, as follows: *Warning: Give to trusted roles
    only; this permission has security implications:*'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，`administer my feature` 是权限的机器名称，实际上是最重要的部分。这就是你将在代码中用它来引用的部分。然后，我们有一个标题，它会在我们之前看到的权限管理页面上显示。最后，我们有一个
    `restrict access` 键，通过它可以指定我们是否需要在权限管理页面上输出有关安全影响的警告，如下所示：*警告：仅授予可信角色；此权限具有安全影响：*
- en: '![](img/a4867b53-2cfb-4659-a529-d15487528cfe.png)'
  id: totrans-24
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/a4867b53-2cfb-4659-a529-d15487528cfe.png)'
- en: This is to indicate that our permission is more sensitive and administrators
    should pay attention to who they assign it to. This option can, however, be left
    out (as you will see in most cases actually).
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 这是为了表明我们的权限更加敏感，管理员应该注意将它们分配给谁。然而，这个选项可以省略（实际上在大多数情况下都是这样）。
- en: You may have noticed the static nature of this way of defining permissions.
    In other words, we hardcoded the permission name and only have one permission.
    In most cases, this will be fine. However, there can be times where you will need
    multiple permissions defined dynamically based on some other factors in your application.
    For this, we can use a permission callback.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经注意到这种定义权限的静态性质。换句话说，我们硬编码了权限名称，并且只有一个权限。在大多数情况下，这将是可行的。然而，有时你可能需要根据应用程序中的其他因素动态定义多个权限。为此，我们可以使用权限回调。
- en: 'For example, the Node module defines individual permissions to manage each
    of its bundles, and this makes sense. Some roles should have access to some bundles
    while other roles should have access to other bundles. However, there is no way
    it can know which bundles it will have at any given point. So, it uses a permission
    callback:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，节点模块为管理其每个捆绑包定义了单独的权限，这是有意义的。一些角色应该有权访问某些捆绑包，而其他角色应该有权访问其他捆绑包。然而，它无法知道在任何给定时刻它将有哪些捆绑包。因此，它使用权限回调：
- en: '[PRE1]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: This is found in the `node.permissions.yml` file just like the statically defined
    ones, but it delegates the responsibility of getting the permissions to the `nodeTypePermissions`
    method of the `NodePermissions` class. This is the same notation we use to define
    Controllers in the route. As a matter of fact, the same class resolver is used
    to instantiate it.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 这可以在 `node.permissions.yml` 文件中找到，就像静态定义的那样，但它将获取权限的责任委托给 `NodePermissions`
    类的 `nodeTypePermissions` 方法。这是我们用来在路由中定义控制器相同的符号。事实上，相同的类解析器被用来实例化它。
- en: Checking the user credentials
  id: totrans-30
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 检查用户凭据
- en: 'You can easily check whether a given user should access a certain resource
    as long as you have that user account at hand. Here, you can encounter two scenarios:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 只要你有那个用户账户，你就可以轻松地检查一个给定的用户是否应该访问某个特定资源。在这里，你可能会遇到两种情况：
- en: You want to "interrogate" the current user.
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你想“调查”当前用户。
- en: You want to "interrogate" a given user, not necessarily the current one.
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您想“调查”的是特定用户，而不一定是当前用户。
- en: 'As we saw in [Chapter 2](601b4dd0-c521-459e-9342-2645a109642c.xhtml), *Creating
    Your First Module*, the current user is represented by a service that implements
    the `AccountProxyInterface` interface. This service can be accessed by the `current_user`
    key or statically with this shorthand:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在[第2章](601b4dd0-c521-459e-9342-2645a109642c.xhtml)，“创建您的第一个模块”中看到的，当前用户由一个实现`AccountProxyInterface`接口的服务表示。这个服务可以通过`current_user`键或使用以下简写静态访问：
- en: '[PRE2]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'From this account proxy we can request the `AccountInterface` which represents
    the actual logged-in user account (the `UserSession` object). It holds a reference
    to the User entity, with a few of its account-related data, but that is pretty
    much it. If we need to access its entity fields, we need to load the entity as
    we normally do:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 从这个账户代理中，我们可以请求代表实际已登录用户账户的`AccountInterface`（即`UserSession`对象）。它持有对用户实体的引用，以及一些与其账户相关的数据，但基本上就是这样。如果我们需要访问其实体字段，我们需要像通常那样加载实体：
- en: '[PRE3]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The resulting `UserInterface`, by the way, also implements the same `AccountInterface`,
    so these common methods can be used on both objects. So, the `User` entity type
    is essentially the storage facility for the `AccountInterface` that represents
    a user who is browsing the site. However, for the moment, the User entity is not
    so relevant, so we will get back to the account, which we can retrieve from the
    proxy, like so:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 顺便说一句，生成的`UserInterface`也实现了相同的`AccountInterface`，因此这些常用方法可以用于这两个对象。因此，`User`实体类型基本上是代表浏览网站的用户的`AccountInterface`的存储设施。然而，目前，用户实体并不那么相关，所以我们将回到账户，我们可以从代理中检索它，如下所示：
- en: '[PRE4]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The methods on this interface allow us to "interrogate" the account (either
    the current user account or the one represented by a given User entity) as to
    its credentials. Also, many of them are also present in the `AccountProxy`, meaning
    that you can ask it directly for these.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 该接口上的方法允许我们“调查”账户（无论是当前用户账户还是由给定用户实体表示的账户）的凭据。其中许多也存在于`AccountProxy`中，这意味着您可以直接询问这些。
- en: 'Two very general but often helpful methods are the following:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 以下两种非常通用但经常很有帮助的方法是：
- en: '[PRE5]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: These check whether the account is anonymous or not, without taking any roles
    or permissions into account. Sometimes, your access control is solely based on
    this distinction.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 这些检查账户是否匿名，不考虑任何角色或权限。有时，您的访问控制仅基于这种区分。
- en: 'We can also get a list of roles the account has, as follows:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以获取账户拥有的角色列表，如下所示：
- en: '[PRE6]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Even more important, check whether the user has a given permission:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 乃至更重要的是，检查用户是否具有特定的权限：
- en: '[PRE7]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Where `$permission` is a string (the machine name of the permission as we saw
    it defined earlier). This method is very helpful because it checks all the roles
    the user has for the specified permission.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 其中`$permission`是一个字符串（权限的机器名，正如我们之前所定义的）。这个方法非常有用，因为它检查用户对指定权限的所有角色。
- en: You can use these methods anywhere in your code when you need to check whether
    a user should be accessing certain parts of your functionality.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 当您需要检查用户是否应该访问您功能的一部分时，您可以在代码的任何地方使用这些方法。
- en: Route access
  id: totrans-50
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 路由访问
- en: Now that we've seen how the access system works in Drupal 8 at a basic level
    and how we can define permissions and check user credentials, it's time to talk
    about routes.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经看到了Drupal 8中访问系统在基本层面的工作原理以及我们如何定义权限和检查用户凭据，是时候讨论路由了。
- en: As we saw from the very first time we wrote code in this book, routes are the
    entry points into your application. Also, as a developer, it is one of the main
    things you'll be dealing with, so controlling who can access these routes is the
    responsibility of the access system.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们从本书第一次编写代码时所见，路由是进入您应用程序的入口点。此外，作为一名开发者，这也是您将主要处理的事情之一，因此控制谁可以访问这些路由是访问系统的责任。
- en: There are a number of ways we can ensure that routes are only accessible to
    the right users, so let's see what these are.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有几种方法可以确保路由只能被正确的用户访问，所以让我们看看这些方法。
- en: 'The simplest way is by checking for a permission. We actually did that in [Chapter
    2](601b4dd0-c521-459e-9342-2645a109642c.xhtml), *Creating Your First Module*,
    when we defined our `hello_world.hello` route:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 最简单的方法是检查权限。我们在[第2章](601b4dd0-c521-459e-9342-2645a109642c.xhtml)，“创建您的第一个模块”中实际上就是这样做的，当我们定义我们的`hello_world.hello`路由时：
- en: '[PRE8]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The `requirements` key in a route definition contains all the data that the
    request trying to reach this route must have. This contains mostly access-like
    information but also things such as the request format.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 路由定义中的`requirements`键包含请求尝试到达此路由必须具有的所有数据。这主要包含类似访问的信息，但也包括诸如请求格式之类的信息。
- en: 'The requirement in the previous example is `_permission` (all these options
    typically start with an underscore). It is used to specify that the user accessing
    this route needs to have that permission, similar to how we checked whether a
    user has it earlier:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 之前示例中的要求是`_permission`（所有这些选项通常以下划线开头）。它用于指定访问此路由的用户需要拥有该权限，类似于我们之前检查用户是否拥有它的方式：
- en: '[PRE9]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The `access content` permission is something defined by Drupal core and is basically
    the one you'd use when the restrictions are very lax, meaning that all users should
    be able to access the resource. By default, this permission is also present on
    the *Anonymous* user role.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: '`访问内容`权限是由Drupal核心定义的，基本上是在限制非常宽松时使用的，这意味着所有用户都应该能够访问资源。默认情况下，此权限也存在于*匿名*用户角色中。'
- en: 'Speaking of lax restrictions, there is one option that is even more open, fully
    open:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 说到宽松的限制，还有一个选项甚至更加开放，完全开放：
- en: '[PRE10]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: This essentially opens up the route to basically everybody under any circumstance—not
    something you'll probably use often, but it's handy in some cases.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 这实际上是在任何情况下都将路由向几乎所有的人开放——你可能不会经常使用，但在某些情况下很有用。
- en: 'Returning to permissions, we can also include multiple permissions in this
    requirement. For example, to check whether a user has **either** of two permissions,
    we separate them by a comma:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 回到权限方面，我们还可以将多个权限包含在这个要求中。例如，为了检查用户是否拥有两个权限中的**任何一个**，我们用逗号将它们分开：
- en: '[PRE11]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'For checking whether the user has **all** the given permissions, we separate
    them by a plus (+) sign:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 为了检查用户是否拥有所有给定的权限，我们用加号（+）将它们分开：
- en: '[PRE12]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: So, we can already see quite some flexibility.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们已能看到相当大的灵活性。
- en: The `administer site configuration` is another staple permission from Drupal
    core which we can use to ensure that the user is an administrator; it is typically
    a sensitive permission given only to these users.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '`管理网站配置`是Drupal核心的另一个基本权限，我们可以用它来确保用户是管理员；这通常是一个敏感权限，仅授予这些用户。'
- en: 'Next, we also have a requirement by which we can check whether the user has
    a given role. In a similar manner, we can include multiple roles to check, depending
    on whether we want to do AND or OR checking:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们还有一个要求，可以用来检查用户是否具有特定的角色。以类似的方式，我们可以包含多个角色进行检查，具体取决于我们想要进行AND或OR检查：
- en: '[PRE13]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: This approach is not as flexible as using permissions and it's a little "hardcody".
    By this I mean that you are hardcoding an access rule based on site configuration
    (as roles are configuration entities). If that configuration is removed, you may
    have broken code. Permissions, on the other hand, are also code, as they are defined
    in a module (or Drupal core). However, the option is there if you need it.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法不如使用权限灵活，它有点“硬编码”。我的意思是，你正在根据网站配置（因为角色是配置实体）硬编码一个访问规则。如果该配置被删除，你的代码可能会出错。另一方面，权限也是代码，因为它们是在模块（或Drupal核心）中定义的。然而，如果你需要，这个选项是存在的。
- en: The next type of requirement we should be covering here is `_entity_access`.
    However, understanding this requires us to first know a bit about entity-level
    access, so we will skip it now; we'll definitely come back to it later in the
    chapter. Instead, we will talk about the mother of all route access approaches—the
    custom one.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 我们接下来应该在这里介绍的要求类型是`_entity_access`。然而，理解这一点需要我们首先了解实体级别的访问，所以我们现在将跳过它；我们肯定会在本章的后面回到它。相反，我们将讨论所有路由访问方法之母——自定义方法。
- en: Route access requirements can also be stacked, which means that we can add more
    than one access requirement to a route and the access will be given if all of
    them grant access. If one denies it, access is denied to the route. This is done
    by simply adding multiple requirements to the route.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 路由访问要求也可以堆叠，这意味着我们可以向路由添加多个访问要求，并且只有当所有这些要求都允许访问时，才会授予访问权限。如果其中一个拒绝，则拒绝访问该路由。这是通过简单地向路由添加多个要求来完成的。
- en: Custom route access
  id: totrans-74
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 自定义路由访问
- en: The previous ways of controlling routes are powerful and relatively flexible,
    but static. We are hardcoding the rules into a file and expect the incoming user
    to abide by them. However, what if things are more complicated than that, and
    we need a more dynamic approach? Trust me, things get complicated, fast. We can
    use the `_custom_access` option of the route requirements.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 之前控制路由的方法功能强大且相对灵活，但它们是静态的。我们将规则硬编码到文件中，并期望来宾用户遵守这些规则。然而，如果事情比这更复杂，我们需要一个更动态的方法怎么办？相信我，事情会很快变得复杂。我们可以使用路由要求的`_custom_access`选项。
- en: In this subsection, we will see how these work and how we can create our custom
    access checkers; just something simple to demonstrate the process. Then, we will
    see a more advanced implementation that will have us work a bit with routes programmatically.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 在本小节中，我们将看到这些是如何工作的，以及我们如何创建我们的自定义访问检查器；只是简单演示一下这个过程。然后，我们将看到一种更高级的实现，这将让我们在程序上对路由进行一些操作。
- en: 'There are two ways custom access checkers can be created and used with a route,
    and they both involve creating a class. The way this class is used makes the distinction:
    we can either reference it directly (statically) or make it into a service and
    reference it like so. We will see an example of both later in this chapter.'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 创建和使用自定义访问检查器与路由结合的方式有两种，它们都涉及到创建一个类。这个类是如何被使用的决定了区别：我们既可以直接（静态地）引用它，也可以将其变成一个服务并这样引用。我们将在本章后面看到这两个示例。
- en: To demonstrate, let's say that we want to make sure that our Hello World route
    is only accessible to users who don't have a specific role—`editor`. Doesn't make
    much sense, but it's a simple example we can run with.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 为了演示，假设我们想要确保我们的Hello World路由只能对没有特定角色——`editor`——的用户可访问。这听起来不太合理，但这是一个我们可以运行的简单示例。
- en: Static approach
  id: totrans-79
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 静态方法
- en: 'The static approach involves creating a method on our Controller (or somewhere
    else), usually called `access()`, and referencing it from the route definition.
    So, inside our controller we can have this:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 静态方法涉及到在我们的控制器（或其他地方）创建一个方法，通常称为`access()`，并从路由定义中引用它。因此，在我们的控制器中我们可以有如下代码：
- en: '[PRE14]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'And the new *use* statements:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 以及新的`use`语句：
- en: '[PRE15]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'This method receives the current user''s `AccountInterface`, which we can use
    to determine the roles. Moreover, if we type hint some extra parameters, Drupal
    will pass them to the method as well:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 这个方法接收当前用户的`AccountInterface`，我们可以用它来确定角色。此外，如果我们对一些额外的参数进行类型提示，Drupal也会将它们传递给这个方法：
- en: '`\Symfony\Component\Routing\Route $route`'
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`\Symfony\Component\Routing\Route $route`'
- en: '`\Drupal\Core\Routing\RouteMatch $route_match`'
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`\Drupal\Core\Routing\RouteMatch $route_match`'
- en: We've already discussed the `CurrentRouteMatch` service in [Chapter 2](601b4dd0-c521-459e-9342-2645a109642c.xhtml),
    *Creating Your First Module*, and we saw that we can use it to find out things
    about the route that has just been accessed. In reality, that service simply uses
    `RouteMatch` objects underneath. So in case our access rules for this route depend
    on something that relates to the route, this argument can be very important. Soon,
    I will demonstrate why that is in further detail.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经在[第二章](601b4dd0-c521-459e-9342-2645a109642c.xhtml)“创建您的第一个模块”中讨论了`CurrentRouteMatch`服务，我们了解到我们可以用它来了解刚刚访问的路由的信息。实际上，这个服务只是简单地使用了`RouteMatch`对象。因此，如果我们的路由访问规则依赖于与路由相关的东西，这个参数可能非常重要。很快，我将更详细地演示这一点。
- en: Similarly, we can also type hint the actual `Route` object that contains data
    about the route. This plays to the same point I just made, and we can also use
    it in our logic. But alas, for our use case, these won't be necessary, so we will
    stick with the `AccountInterface`.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，我们也可以对包含路由数据的实际`Route`对象进行类型提示。这与我刚才提到的观点一致，我们也可以在逻辑中使用它。但是，不幸的是，对于我们的用例，这些将不是必需的，所以我们将坚持使用`AccountInterface`。
- en: 'What we are returning in this method is very important, as it needs to be an
    instance of `AccessResultInterface`. This is the standard interface the access
    system in Drupal 8 works with. The following are the three main implementations
    of this interface you will often encounter:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个方法中我们返回的内容非常重要，因为它需要是一个`AccessResultInterface`的实例。这是Drupal 8中访问系统使用的标准接口。以下是你经常会遇到的三种主要接口实现：
- en: '`AccessResultAllowed`'
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`AccessResultAllowed`'
- en: '`AccessResultNeutral`'
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`AccessResultNeutral`'
- en: '`AccessResultForbidden`'
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`AccessResultForbidden`'
- en: The gateway to these objects, however, is typically the `AccessResult` abstract
    base class (which all of these implementations extend as well) and its static
    methods. As you saw in the previous example, we used the `allowed()` and `forbidden()`
    methods to instantiate these objects. Of course, there is also the corresponding
    `neutral()` method we can use to indicate that we don't have a say in the matter.
    Typically, this is used when there are multiple actors involved in deciding access
    to a certain resource and one such actor encounters a resource for which they
    don't need to control access.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这些对象的入口通常是`AccessResult`抽象基类（所有这些实现都扩展了它）及其静态方法。正如你在前面的示例中看到的，我们使用了`allowed()`和`forbidden()`方法来实例化这些对象。当然，我们还有一个相应的`neutral()`方法，可以用来表示我们没有在事情上发言。通常，这用于涉及多个决定访问特定资源的参与者的情况，其中一个参与者遇到了他们不需要控制访问的资源。
- en: 'With Drupal 8.3, the neutral and forbidden access results also support a reason.
    This is typically used in REST scenarios to display a message as to why the access
    has been denied or skipped. So for example, we can return something like this
    when denying access:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 在Drupal 8.3中，中性和禁止的访问结果也支持原因。这通常用于REST场景，以显示为什么访问被拒绝或跳过。例如，当我们拒绝访问时，我们可以返回如下内容：
- en: '[PRE16]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Some other built-in capabilities of the `AccessResult` base class are related
    to cacheability, but it also has convenience methods to achieve a bit more complex
    access logic. For example, the following methods can prove handy:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: '`AccessResult`基类的一些其他内置功能与缓存性相关，但它也有方便的方法来实现更复杂的访问逻辑。例如，以下方法可能很有用：'
- en: '`allowedIf($condition)`'
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`allowedIf($condition)`'
- en: '`forbiddenIf($condition)`'
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`forbiddenIf($condition)`'
- en: You simply pass a Boolean to these methods and they return the right access
    object. Do keep in mind that these methods return an `AccessResultNeutral` object
    if the condition evaluates to FALSE. So, you cannot use these methods if you need
    to map a Boolean to an explicitly allowed or explicitly denied result.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 你只需传递一个布尔值给这些方法，它们就会返回正确的访问对象。当然，请记住，如果条件评估为FALSE，这些方法返回一个`AccessResultNeutral`对象。所以，如果你需要将布尔值映射到显式允许或显式拒绝的结果，你不能使用这些方法。
- en: 'Additionally, we have methods like the following:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们还有以下类似的方法：
- en: '`allowedIfHasPermission()`'
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`allowedIfHasPermission()`'
- en: '`allowedIfHasPermissions()`'
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`allowedIfHasPermissions()`'
- en: This will check whether a given account has one or more permissions and returns
    the right access object depending on the case.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 这将检查给定的账户是否具有一个或多个权限，并根据情况返回正确的访问对象。
- en: Finally, we also have the `orIf()` and `andIf()` methods with which we can build
    more complex access structures that combine multiple `AccessResultInterface` results.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们还有`orIf()`和`andIf()`方法，我们可以用它们构建更复杂的访问结构，这些结构结合了多个`AccessResultInterface`结果。
- en: 'Closing the parentheses on the `AccessResultInterface`, let''s reference this
    method in our route in order to actually make use of it. This is what the route
    definition looks like now:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 在`AccessResultInterface`的括号上关闭，让我们在我们的路由中引用这个方法，以便真正使用它。这就是现在的路由定义看起来像这样：
- en: '[PRE17]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Instead of the `_permission` requirement, we use `_custom_access` with a reference
    to our Controller method. After clearing the cache, our new access checker will
    "kick out" those pesky `editor` users.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不再使用`_permission`需求，而是使用带有对我们控制器方法引用的`_custom_access`。在清除缓存后，我们新的访问检查器将“踢出”那些讨厌的`editor`用户。
- en: This static approach, as you can imagine, is slightly more powerful than using
    permission or roles-based access checking because it allows you to write PHP logic
    in order to determine the access. However, it falls short in a number of respects,
    and this is where the service-based approach can be used.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所想，这种静态方法比使用基于权限或角色的访问检查更强大，因为它允许你编写PHP逻辑来确定访问。然而，它在许多方面都存在不足，这就是基于服务的方法可以发挥作用的地方。
- en: Service approach
  id: totrans-109
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 服务方法
- en: 'The service approach involves creating a tagged service and referencing that
    in the route definition as a requirement. There are a number of advantages to
    this method compared to the one we''ve just seen:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 服务方法涉及创建一个标记的服务，并在路由定义中将其作为需求进行引用。与我们所看到的方法相比，这种方法有许多优点：
- en: Allows you to encapsulate complex access logic in its own class
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 允许你将复杂的访问逻辑封装在其自己的类中
- en: Allows you to inject dependencies and make use of them in calculating the access
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 允许你在计算访问时注入依赖项并使用它们
- en: Allows you to reuse the access checker on multiple routes
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 允许你在多个路由上重用访问检查器
- en: Let's take a look at how we can implement this for our Hello World route. We
    will replace the previous approach, but keep the goal of denying access to editors.
    However, to increase a bit complexity, editors will be allowed if the Hello World
    salutation has not been overridden via the configuration form. If you recall,
    in [Chapter 2](601b4dd0-c521-459e-9342-2645a109642c.xhtml), *Creating Your First
    Module*, we created a form where the salutation message can be overridden and
    stored in a configuration object.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看我们如何为我们的Hello World路由实现这一点。我们将替换之前的方法，但保持拒绝编辑访问的目标。然而，为了增加一点复杂性，如果Hello
    World问候没有被配置表单覆盖，编辑将被允许。如果你还记得，在[第2章](601b4dd0-c521-459e-9342-2645a109642c.xhtml)，*创建你的第一个模块*中，我们创建了一个表单，其中问候消息可以被覆盖并存储在配置对象中。
- en: 'First, let''s create our class. Typically, access-related classes go inside
    the `Access` folder of the module namespace—it''s not necessarily so, but it makes
    sense to put them there. Then, we can have something like this:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们创建我们的类。通常，与访问相关的类放在模块命名空间的`Access`文件夹中——这并不一定是这样，但将其放在那里是有意义的。然后，我们可以有如下内容：
- en: '[PRE18]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Right off the bat, I would like to mention that the `AccessInterface` we're
    implementing is at this point a bit up in the air. If you look inside, you'll
    see that it has no methods. This is because of the dynamic argument resolving
    we talked about earlier, by which we can get the route and route match if we type-hint
    them. There was an ongoing discussion at the time of writing this book on marking
    it deprecated and maybe eventually removing it completely (or finding another
    solution). So, it's something worth paying attention to in the long run.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 一开始，我想提到，我们正在实现的`AccessInterface`目前还处于不确定的状态。如果你查看内部结构，你会发现它没有任何方法。这是因为我们之前讨论过的动态参数解析，通过它可以获取路由和路由匹配，如果我们对它们进行类型提示的话。在撰写本书时，有一个关于将其标记为已弃用并可能最终完全移除（或找到另一种解决方案）的持续讨论。因此，这是长期值得关注的点。
- en: Also, since there is no interface, the `access()` method naming is not enforced.
    However, we will need it because that is the name being looked for by the access
    system when using the service. As before, we get the user making the request from
    which we can get the roles. Moreover, we injected the configuration factory and
    checked whether the salutation text had been overridden. Only if that is the case
    will editors be denied access. It's nothing too complicated for us at this point.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，由于没有接口，`access()`方法命名不是强制性的。然而，我们仍然需要它，因为这是访问系统在调用服务时寻找的名称。和之前一样，我们获取发起请求的用户，从而可以获取角色。此外，我们注入了配置工厂并检查问候文本是否已被覆盖。只有在这种情况发生时，编辑才会被拒绝访问。对我们来说，这并不复杂。
- en: 'Now, let''s take a look at how we define this as a service to be used by our
    route as an access checker:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看我们如何定义它作为一个服务，供我们的路由作为访问检查器使用：
- en: '[PRE19]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'As you can see, tagged services are very important in Drupal 8 and are a great
    example of an extension point with which we can contribute our own code to an
    existing set of functionality. In this example, apart from tagging it for access
    checking, we also see another option to this tag: `applies_to`. The corresponding
    string is what we can now use in our route definition to target this particular
    access checker. So instead of the following line:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，标记服务在Drupal 8中非常重要，它是我们可以贡献自己的代码到现有功能集的一个很好的扩展点示例。在这个例子中，除了为访问检查标记它之外，我们还看到了这个标记的另一个选项：`applies_to`。相应的字符串是我们现在可以在我们的路由定义中使用以针对这个特定的访问检查器的字符串。所以，而不是以下这一行：
- en: '[PRE20]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'We have this one:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有这个：
- en: '[PRE21]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: The `TRUE` value we set doesn't make much of a difference. If we wanted, we
    could add a string value that could actually be used by the access checker internally.
    However, we'll use a different approach for that later. So, for now, the standard
    thing to do is just use `TRUE`.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 我们设置的`TRUE`值并没有太大的影响。如果我们愿意，我们可以添加一个字符串值，这个值实际上可以被访问检查器内部使用。然而，我们将稍后使用不同的方法来处理。所以，现在，标准做法就是只使用`TRUE`。
- en: After clearing the cache, our new access checker will kick in and that is pretty
    much it.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 清除缓存后，我们新的访问检查器将启动，这就是全部。
- en: Programmatically checking access on routes
  id: totrans-127
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 对路由进行程序化访问检查
- en: If we defined routes, and users go to those routes, Drupal would check access
    for us automatically (according to the requirements set forth in the route definition).
    However, we may often need to check access to a given route programmatically,
    for example, to know whether we should show a link to it to the current user.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们定义了路由，并且用户访问这些路由，Drupal会自动为我们检查访问权限（根据路由定义中设定的要求）。然而，我们可能经常需要以编程方式检查特定路由的访问权限，例如，确定是否应该向当前用户显示该链接。
- en: 'In [Chapter 2](601b4dd0-c521-459e-9342-2645a109642c.xhtml), *Creating Your
    First Module*, we saw how to work with `Url` objects to create links, and we can
    use these very `Url` objects to check access on a given route; consider the following
    example:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [第二章](601b4dd0-c521-459e-9342-2645a109642c.xhtml)，*创建您的第一个模块* 中，我们看到了如何使用
    `Url` 对象来创建链接，并且我们可以使用这些 `Url` 对象来检查给定路由的访问权限；考虑以下示例：
- en: '[PRE22]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: The `access()` method on the `Url` object works only with *routed* URLs, those
    which have been determined to have a route behind them. It will obviously not
    work with things such as external URLs, so, in these cases, it will always return
    TRUE. Also, we can pass an `AccountInterface` to this method in case we want to
    check whether a specific user has access to that route. Without an argument, it
    defaults to the current user.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: '`Url` 对象上的 `access()` 方法仅与 *路由* URL 一起工作，即那些已经确定后面有路由的 URL。显然，它不会与外部 URL 等事物一起工作，因此在这些情况下，它总是返回
    TRUE。此外，如果我们想检查特定用户是否有权访问该路由，我们可以向此方法传递一个 `AccountInterface`。如果没有参数，它默认为当前用户。'
- en: 'Under the hood, the `Url` class uses the `AccessManager` service statically
    to check the access of the route. This is done statically, so if you want, you
    can inject the service yourself (`access_manager`) and check the route access:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 在底层，`Url` 类使用 `AccessManager` 服务静态地检查路由的访问权限。这是静态完成的，所以如果您愿意，您可以自己注入服务（`access_manager`）并检查路由访问权限：
- en: '[PRE23]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: The empty array we pass as a second argument is an array of parameters that
    the route needs. You remember how route parameters work from [Chapter 2](601b4dd0-c521-459e-9342-2645a109642c.xhtml),
    *Creating Your First Module*, right?
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 我们传递的空数组作为第二个参数是路由需要的参数数组。您还记得从 [第二章](601b4dd0-c521-459e-9342-2645a109642c.xhtml)，*创建您的第一个模块*
    中如何使用路由参数，对吧？
- en: I mentioned earlier that it's very important to use the account, route, and
    route match that are being passed to the access checker as dynamic arguments if
    you need them for calculating the access logic, as opposed to injecting the current
    user or current route match services and using those. Maybe, now, you can start
    to understand why. Let me break it down.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 我之前提到，如果您需要使用账户、路由和路由匹配来计算访问逻辑，那么使用这些动态参数而不是注入当前用户或当前路由匹配服务非常重要。也许现在，您可以开始理解为什么。让我来解释一下。
- en: One of my earlier points was that an advantage of the service-based access checking
    approach is that it allows us to use the same service on multiple routes. This
    means that we can have highly dynamic access rules by which we can check route
    options within the access checker and calculate access based on those, and this
    is quite powerful.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 我之前提到的一个优点是，基于服务的访问检查方法允许我们在多个路由上使用相同的服务。这意味着我们可以拥有高度动态的访问规则，通过这些规则我们可以在访问检查器中检查路由选项并基于这些选项计算访问权限，这非常强大。
- en: However, if you inject the current route match service and make use of that,
    your access rules will work only when that route is being requested in the browser,
    so, basically, when the user is trying to go to that path. This is because the
    current route just happens to be the same as the route the access checker is using
    (the injected one). However, if you programmatically check access on that route
    from another page (as we just saw), the current route match will be of that other
    page instead of the one you actually want to check access to.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果您注入当前路由匹配服务并使用它，您的访问规则只有在浏览器请求该路由时才会生效，所以基本上，当用户试图访问该路径时。这是因为当前路由恰好与访问检查器使用的路由（注入的那个）相同。然而，如果您从另一个页面（正如我们刚才看到的）以编程方式检查该路由的访问权限，当前路由匹配将是那个其他页面的路由，而不是您实际想要检查访问权限的路由。
- en: You'll see this happen even if you don't manually check access on routes with
    menu links. If a given route is used in a menu link and printed on a page, Drupal
    will do the access checking automatically to ensure that users have access to
    that link. Moreover, recall from [Chapter 5](9e989509-bdf4-4a74-ace2-deeaa0c73a3b.xhtml),
    *Menus and Menu Links*, that if you want to render menu links programmatically,
    one of the things you'll typically do is run the menu tree through a set of manipulators.
    An important manipulator is that which checks whether the current user has access
    to that route.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 即使您没有手动检查带有菜单链接的路由的访问权限，您也会看到这种情况发生。如果一个给定的路由被用于菜单链接并在页面上打印出来，Drupal 将会自动进行访问检查，以确保用户可以访问该链接。此外，回想一下[第5章](9e989509-bdf4-4a74-ace2-deeaa0c73a3b.xhtml)，*菜单和菜单链接*，如果您想以编程方式渲染菜单链接，您通常会执行的操作之一是通过一系列操作器运行菜单树。一个重要的操作器是检查当前用户是否有权访问该路由。
- en: In these cases, you have the same problem. So, do remember to type hint your
    access checker with the route and/or route match objects and do not inject them.
    Of course, do not inject the current user service either (unless you have a very
    specific reason for doing so).
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 在这些情况下，您会遇到相同的问题。所以，请记住为您的访问检查器使用路由和/或路由匹配对象进行类型提示，并且不要注入它们。当然，也不要注入当前用户服务（除非您有非常具体的原因这样做）。
- en: Bonus—dynamic route options for access control
  id: totrans-140
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 奖励——动态路由选项用于访问控制
- en: We've seen how to create a service-based access checker that we can use on our
    routes. Using this technique, I want to demonstrate the flexibility of using the
    service on multiple routes. Imagine that we have multiple routes that display
    some user information. However, these routes are specific to a user type, and
    hence accessible only for that user type. In this example, a user type will be
    defined based on the value of a simple text field on the user entity, and we want
    to specify in the route definition for which user type it should be accessible.
    The code we write for this demonstration will go inside a new `user_types` module.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到了如何创建一个基于服务的访问检查器，我们可以在我们的路由上使用它。使用这种技术，我想展示在多个路由上使用服务的灵活性。想象一下，我们有多条路由用于显示一些用户信息。然而，这些路由是特定于用户类型的，因此只有该用户类型可以访问。在这个例子中，用户类型将基于用户实体上的一个简单文本字段的值来定义，我们希望在路由定义中指定它应该对哪种用户类型可访问。我们为这个演示编写的代码将放在一个新的`user_types`模块中。
- en: An alternative approach to checking the access inside a route for this example
    is to simply verify inside the Controller that the current user should access
    it. If not, throwing an `AccessDeniedHttpException` inside a Controller method
    will turn the request into a 403 (access denied). However, this is almost always
    the wrong approach because the route can no longer be verified for access, and
    we'll end up with links on our site that potentially lead to 403 pages. And we
    don't want that. For this reason, if the page has access rules, they belong in
    the access system and not in the Controller.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个例子，检查路由内部访问的另一种方法是简单地验证控制器中的当前用户是否有权访问它。如果没有，在控制器方法中抛出`AccessDeniedHttpException`将请求转换为403（访问拒绝）。然而，这几乎总是错误的方法，因为路由将无法再进行访问验证，我们最终会在网站上放置可能导向403页面的链接。我们不希望这样。因此，如果页面有访问规则，它们属于访问系统，而不是控制器。
- en: 'We''ll go into this example with the assumption that the user entity has a
    field called `field_user_type` already on it; that we have users of three types:
    `board_member`, `manager`, and `employee`; and that we have the following four
    route definitions:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们假设用户实体上已经有一个名为`field_user_type`的字段；我们有三种类型的用户：`board_member`、`manager`和`employee`；并且我们有以下四个路由定义：
- en: '[PRE24]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: These routes don't have any access requirements yet, as it is our job to create
    them now. However, you can already understand what kind of users should be able
    to access these routes. The `user_types.board_members` route is for board members,
    `user_types.manager` is for managers, `user_types.employee` is for both employees
    and managers (since both are actual employees), and `user_types.leadership` is
    for the board members and managers. So, a bit of mix and match to highlight the
    need for flexibility in our access checker.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 这些路由目前还没有任何访问要求，因为我们的任务是现在创建它们。然而，您已经可以理解哪些类型的用户应该能够访问这些路由。`user_types.board_members`路由是为董事会成员设计的，`user_types.manager`是为经理设计的，`user_types.employee`是为员工和经理（因为两者都是真正的员工）设计的，而`user_types.leadership`是为董事会成员和经理设计的。所以，一些混合匹配来强调我们访问检查器中灵活性的需求。
- en: Obviously, we don't want to write a service for each combination of user types
    to handle the access here. Using the static approach is not suitable either because
    we need to inject a dependency, and we also don't want to duplicate the logic
    using different callables.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，我们不想为处理这里的每种用户类型的组合编写一个服务。使用静态方法也不合适，因为我们需要注入一个依赖项，而且我们也不想使用不同的可调用项重复逻辑。
- en: 'So, let''s define our service definition for this access checker:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，让我们为这个访问检查器定义我们的服务定义：
- en: '[PRE25]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: We inject the entity type manager service so that we can load the user entity
    corresponding to the user whose access is being checked. As you remember, the
    `AccountInterface` is not enough to read field data from that user.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 我们注入实体类型管理器服务，以便我们可以加载与正在检查访问的用户对应的用户实体。正如你所记得的，`AccountInterface`不足以从该用户读取字段数据。
- en: 'Now, we can update our route requirements (for all four routes) to make use
    of this access checker:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以更新我们的路由要求（针对所有四个路由）以利用这个访问检查器：
- en: '[PRE26]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Earlier, we saw the static access checker being referenced using the `_custom_access`
    requirement. This is the same as the one we are creating now, but provided by
    Drupal core and which maps to the `CustomAccessCheck` service (instead of the
    custom one we are now writing). This, in turn, delegates the responsibility to
    the class method set in the definition.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 之前，我们看到静态访问检查器是通过`_custom_access`要求引用的。这与我们现在创建的是同一个，但由Drupal核心提供，映射到`CustomAccessCheck`服务（而不是我们现在编写的自定义服务）。这反过来又委托了责任到定义中设置的类方法。
- en: Now, it's time to make the distinction between our four routes in terms of the
    types of users that should have access to them, and we can use *route options*
    for this. Options are a set of arbitrary pieces of data that we can put on a route
    definition and retrieve later programmatically. If you remember, in [Chapter 2](601b4dd0-c521-459e-9342-2645a109642c.xhtml), *Creating
    Your First Module*, parameter converters are such an example that can be defined
    as an option in the route.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，是时候根据应该有权访问它们的用户类型来区分我们的四个路由了，我们可以使用*路由选项*来做这件事。选项是一组任意的数据片段，我们可以将其放在路由定义上并在以后程序化地检索。如果你还记得，在[第2章](601b4dd0-c521-459e-9342-2645a109642c.xhtml)，*创建您的第一个模块*中，参数转换器就是一个可以作为选项在路由中定义的例子。
- en: 'Let''s take a look at just one of the routes as an example in full, and you''ll
    extrapolate what the other routes will have to look like:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们以一个路由为例，全面地看一下，然后你将推断出其他路由将是什么样的：
- en: '[PRE27]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Route options are placed under the `options` key and are conventionally named
    with an underscore at the beginning (however, this is not mandatory). In a standard
    YAML notation, we have a sequence of string values underneath our `_user_types`
    option, which will be turned into a PHP array when read into the Route object.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 路由选项放在`options`键下，并且传统上以一个下划线开头（然而，这并非强制要求）。在标准的YAML表示法中，我们在`_user_types`选项下有一个字符串值的序列，当将其读入路由对象时，将转换为PHP数组。
- en: 'Now, we can create our access checker service and make use of all this for
    controlling access:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以创建我们的访问检查器服务，并利用所有这些来控制访问：
- en: '[PRE28]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: As per the service definition, we inject the entity type manager as a dependency.
    This is something we could not have done using the static approach. Then, in our
    `access()` method, we also type hint the route on which this service is used for
    evaluating access. Now comes the fun part.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 根据服务定义，我们注入实体类型管理器作为依赖项。这是使用静态方法无法做到的。然后，在我们的`access()`方法中，我们还对使用此服务进行访问评估的路由进行类型提示。现在，有趣的部分来了。
- en: We inspect the route and try to retrieve our option by name. Just as a fail-safe,
    we deny access if the option is missing. This should never be the case, as we
    only use this access checker on routes that do have the option, but you never
    know. Additionally, we also deny access if the user is anonymous. Anonymous users
    are sure not to have any user type field value.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 我们检查路由并尝试通过名称检索我们的选项。作为一个安全措施，如果选项缺失，我们将拒绝访问。这种情况不应该发生，因为我们只在这个具有选项的路由上使用这个访问检查器，但你永远不知道。此外，如果用户是匿名用户，我们也会拒绝访问。匿名用户肯定不会有任何用户类型字段值。
- en: Then, we load the user entity of the current account and simply check that field
    value and return access according to whether it is within the allowed ones for
    the route. I recommend that you inspect the Route class and see what other handy
    data you can make use of.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们加载当前账户的用户实体，简单地检查该字段值，并根据它是否在路由允许的范围内返回访问权限。我建议你检查`Route`类，看看你可以利用哪些其他方便的数据。
- en: This is it. Now we have a flexible access-checking service that we can use on
    any number of routes that need this *user type* access control.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 就这样。现在我们有一个灵活的访问检查服务，我们可以在需要此 *用户类型* 访问控制的任何数量的路由上使用它。
- en: A key takeaway from this bonus technique is that you can build incredibly flexible
    architectures using options on routes. In this example, we used them for access,
    but you can also use them for other functionalities that tie to, and can be controlled
    from, the route.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 从这个附加技术中得出的一个关键教训是，您可以使用路由上的选项构建极其灵活的架构。在这个例子中，我们使用了它们来处理访问，但您也可以将它们用于其他与路由相关联并可以从路由控制的功能。
- en: CSRF protection on routes
  id: totrans-164
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 路由的 CSRF 保护
- en: Drupal comes equipped with various tools for handling CSRF protection.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: Drupal 配备了各种处理 CSRF 保护的工具。
- en: Cross Site Request Forgery (CSRF) is an attack that forces an end user to execute
    unwanted actions on a web application in which they're currently authenticated.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 跨站请求伪造（CSRF）是一种攻击，它强制最终用户在当前已认证的 Web 应用程序中执行他们不希望执行的操作。
- en: —(OWASP)
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: ——(OWASP)
- en: One such tool is for handling the addition of a CSRF token to a route built
    using the Drupal API automatically. Let's take a look at an example.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 其中一个工具是用于处理将 CSRF 令牌添加到使用 Drupal API 自动构建的路由。让我们看看一个例子。
- en: Imagine that you have a route that is used as some sort of a callback. Hitting
    this route triggers a process (for logged-in users), so you need to make sure
    that users only end up on this route from the place they should come (part of
    the flow that needs to trigger that process). Tokens can be used for this, and
    Drupal 8 has this covered.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下，您有一个用作某种回调的路由。击中此路由会触发一个过程（对于已登录用户），因此您需要确保用户只能从他们应该来的地方到达这个路由（需要触发该过程的流程的一部分）。令牌可以用于此，Drupal
    8 已经提供了这个功能。
- en: 'There are two things we need to do: add a requirement to the route for CSRF
    protection and then build that link using the regular Drupal API we saw in [Chapter
    2](601b4dd0-c521-459e-9342-2645a109642c.xhtml), *Creating Your First Module*.
    Here''s the requirement:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要做两件事：为 CSRF 保护添加路由要求，然后使用我们在第 2 章[创建您的第一个模块](601b4dd0-c521-459e-9342-2645a109642c.xhtml)中看到的常规
    Drupal API 构建该链接。以下是要求：
- en: '[PRE29]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Also, note that this can go together with other access-based requirements such
    as the ones we've been talking about in this section.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，请注意，这可以与其他基于访问的要求一起使用，例如我们在本节中讨论的那些。
- en: 'Adding the CSRF token requirement now makes the route inaccessible if simply
    accessed by navigating to the path in the browser. To make it accessible, we will
    need to print a link to it somewhere using the Drupal API:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 现在添加 CSRF 令牌要求后，如果仅通过在浏览器中导航到路径来访问路由，则该路由将不可访问。为了使其可访问，我们需要使用 Drupal API 在某处打印出指向它的链接：
- en: '[PRE30]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'This is one way, but we can also use the `LinkGenerator` service or the `Link`
    class, as we''ve seen in [Chapter 2](601b4dd0-c521-459e-9342-2645a109642c.xhtml),
    *Creating Your First Module*. They will all render the link with a token appended
    to the URL as a query parameter. Drupal will then evaluate that token as part
    of the access control and make sure that it is valid. As a matter of fact, the
    link building actually plays no role. It is the URL generator that handles it.
    So, if you get the string URL this way, you will have the token on it automatically:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一种方法，但我们也可以使用 `LinkGenerator` 服务或 `Link` 类，就像我们在第 2 章[创建您的第一个模块](601b4dd0-c521-459e-9342-2645a109642c.xhtml)中看到的那样。它们都会将带有附加到
    URL 作为查询参数的令牌的链接渲染出来。然后 Drupal 将评估该令牌作为访问控制的一部分，并确保它是有效的。事实上，链接构建实际上不起作用。处理它的是
    URL 生成器。因此，如果您以这种方式获取字符串 URL，则它将自动包含令牌：
- en: '[PRE31]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Under the hood, to manage the creation and validation of the tokens, Drupal
    uses the `CsrfTokenGenerator` service, which we can also use if we need to. For
    example, after getting our hands on the service (`csrf_token`), we can create
    a token:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 在底层，为了管理令牌的创建和验证，Drupal 使用 `CsrfTokenGenerator` 服务，我们也可以使用它。例如，在获得服务（`csrf_token`）之后，我们可以创建一个令牌：
- en: '[PRE32]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Here, `my_value` is an optional string that the generator can use to make the
    token unique. It also uses the current user session and the private site key.
    Keep in mind that if the user is anonymous and no session has been started, the
    token will be unique on each request.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`my_value` 是生成器可以用来使令牌唯一的可选字符串。它还使用当前用户会话和私有站点密钥。请注意，如果用户是匿名用户且未启动会话，则令牌在每个请求上都是唯一的。
- en: 'We can then validate this token as follows:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以按以下方式验证此令牌：
- en: '[PRE33]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Here, `$generator` is the same service we used for creating it.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，`$generator` 是我们用于创建它的相同服务。
- en: Using the token generator manually can be handy, but as we saw, it is very easy
    to just put a requirement on the route, and let Drupal do the rest. Moreover,
    CSRF protection is embedded in the Form API, so we don't have to do anything at
    all when it comes to forms for additional protection.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 使用令牌生成器手动操作可能很方便，但正如我们所见，只需在路由上添加一个要求，让Drupal完成其余的工作就非常简单了。此外，CSRF保护已经嵌入到表单API中，因此当涉及到需要额外保护的形式时，我们根本不需要做任何事情。
- en: Altering routes
  id: totrans-184
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 修改路由
- en: We've seen so far how to create access rules on our own routes. However, it
    would not be Drupal if it wasn't also easy to alter existing routes and change
    their access rules to whatever we want. This is yet another small extension point
    with which our custom modules can contribute to an existing functionality.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到了如何在我们自己的路由上创建访问规则。然而，如果修改现有路由并更改它们的访问规则不是那么容易，那么它就不是Drupal了。这是我们的自定义模块可以贡献给现有功能的另一个小的扩展点。
- en: Altering route access is done by altering the routes themselves. Of course,
    access is not the only reason why routes may be altered, as you can change just
    about anything else on the definition. So let's see how you can alter routes for
    any purpose you might need.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 通过修改路由本身来修改路由访问。当然，访问不是修改路由的唯一原因，因为你可以更改定义中的几乎所有其他内容。那么，让我们看看你如何根据需要修改路由。
- en: Routes can be altered by subscribing to an event, just as we've seen in [Chapter
    2](601b4dd0-c521-459e-9342-2645a109642c.xhtml), *Creating Your First Module*,
    when we subscribed to the `kernel.request` event. This event is dispatched at
    the moment all the routes are being built and before they get cached. So the alteration
    will not happen dynamically (upon someone accessing the route), but only when
    they all get rebuilt. Let's take a look at how we can subscribe to that event.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 通过订阅一个事件，可以修改路由，正如我们在[第2章](601b4dd0-c521-459e-9342-2645a109642c.xhtml)“创建您的第一个模块”中看到的，当时我们订阅了`kernel.request`事件。此事件在所有路由正在构建并且它们被缓存之前被触发。因此，修改不会动态发生（当有人访问路由时），而只会在它们全部重建时发生。让我们看看我们如何订阅这个事件。
- en: Unlike most other subscribers, the `EventSubscriberInterface` class for routes
    typically goes in the `Routing` namespace of the module, so that's where we'll
    put it. Moreover, the event we're listening to is `RoutingEvents::ALTER`. However,
    the routing system provides us with a base subscriber class that we can extend
    and that contains all this boilerplate code, leaving us to do only the alterations
    themselves.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 与大多数其他订阅者不同，路由的`EventSubscriberInterface`类通常位于模块的`Routing`命名空间中，所以我们将把它放在那里。此外，我们正在监听的事件是`RoutingEvents::ALTER`。然而，路由系统为我们提供了一个基类订阅者，我们可以扩展它，它包含所有这些样板代码，只留下我们进行修改。
- en: 'And these alterations can look like this:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 这些修改可能看起来像这样：
- en: '[PRE34]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: We extended `RouteSubscriberBase`, which subscribes to the event and provides
    us with the `alterRoutes()` method and a collection of all the routes on the site.
    I encourage you to look into the `RouteCollection` class as it's a very handy
    one to know when working with routes. One important feature is that we can retrieve
    routes based on their name, which we did in the previous example.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 我们扩展了`RouteSubscriberBase`，它订阅了该事件，并为我们提供了`alterRoutes()`方法和网站上所有路由的集合。我鼓励你研究一下`RouteCollection`类，因为它在处理路由时非常有用。一个重要的特性是我们可以根据名称检索路由，就像我们在上一个例子中所做的那样。
- en: Then, we will work with `Route` objects like we did a bit earlier. We can see
    two examples, all with comments I will not repeat here. The second example does
    not make any sense in a real-world scenario, as we cannot have logged-in users
    register for new accounts anyway. However, it serves to illustrate how we can
    add our own access checker to an existing route.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将像之前稍微早些时候做的那样处理`Route`对象。我们可以看到两个示例，所有这些注释我都不会在这里重复。第二个示例在现实世界的场景中没有任何意义，因为我们不能让已登录的用户注册新账户。然而，它有助于说明我们如何向现有路由添加自己的访问检查器。
- en: 'Similar to how we manipulate access requirements, we can change a lot of other
    things: options, parameters, the controller, and even the actual route path. For
    this, I encourage you to familiarize yourself with the `Route` class methods and
    see what you can set on the new route. Couple this information with the documentation
    ([https://www.drupal.org/docs/8/api/routing-system/structure-of-routes](https://www.drupal.org/docs/8/api/routing-system/structure-of-routes))
    on all the things you can add to routes for a better understanding.'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 与我们如何操作访问要求类似，我们可以改变很多其他事情：选项、参数、控制器，甚至实际的路由路径。为此，我鼓励您熟悉`Route`类的各种方法，看看您可以在新路由上设置什么。结合关于您可以在路由上添加的所有内容的文档([https://www.drupal.org/docs/8/api/routing-system/structure-of-routes](https://www.drupal.org/docs/8/api/routing-system/structure-of-routes))，以获得更好的理解。
- en: 'The only thing left for this to work is to register the subscriber as a tagged
    service, just like we did in [Chapter 2](601b4dd0-c521-459e-9342-2645a109642c.xhtml),
    *Creating Your First Module*:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 要使这项工作起作用，唯一剩下的事情就是将订阅者注册为带标签的服务，就像我们在[第2章](601b4dd0-c521-459e-9342-2645a109642c.xhtml)，“创建您的第一个模块”中所做的那样：
- en: '[PRE35]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: And with this we are done with altering our routes.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，我们就完成了对路由的修改。
- en: Entity access
  id: totrans-197
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实体访问
- en: Now that we've covered how access control works on routes, let's dive into the
    entity access system and see how we can ensure that only the right users interact
    with our entities. To demonstrate these, we will work with the Product entity
    type we created in [Chapter 7](392cdb70-e52a-42d1-b782-28d6eb726810.xhtml), *Your
    Own Custom Entity and Plugin Types*.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经介绍了如何在路由上实现访问控制，让我们深入了解实体访问系统，看看我们如何确保只有正确的用户与我们的实体进行交互。为了演示这些，我们将使用我们在[第7章](392cdb70-e52a-42d1-b782-28d6eb726810.xhtml)，“您自己的自定义实体和插件类型”中创建的产品实体类型。
- en: When we created the Product entity type, the annotation we wrote had an `admin_permission`
    property where we referenced the general permission to be used for any interaction
    with the entities of this type. Since we didn't reference and implement an access
    control handler, this is the only access checking done on products. In many cases,
    this is enough. After all, entity types can be created for the sole purpose of
    structuring some data that nobody even needs to interact with in the UI. However,
    many other cases require more granular access control on operating with the entities,
    especially the content-oriented ones, such as Node.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们创建产品实体类型时，我们写的注解中有一个`admin_permission`属性，其中我们引用了用于与该类型实体进行任何交互的通用权限。由于我们没有引用并实现访问控制处理程序，这是对产品进行的唯一访问检查。在许多情况下，这已经足够了。毕竟，实体类型可以仅用于结构化一些数据，甚至没有人需要在UI中与之交互。然而，许多其他情况需要对操作实体进行更细粒度的访问控制，尤其是面向内容的，如节点。
- en: 'There are four operations for which we can control access when it comes to
    entities: `view`, `create`, `update`, and `delete`. The first one is clearly the
    most common one, but we always need to account for the rest as well. Let''s first
    define permissions for all these operations (you remember how, right?):'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 在实体访问方面，我们可以控制访问的四个操作是：`view`、`create`、`update`和`delete`。第一个显然是最常见的，但我们始终需要考虑到其余的操作。让我们首先为所有这些操作定义权限（你还记得吗？）：
- en: '[PRE36]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: These are four simple permissions that map to the operations that can be performed
    on Product entities.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是四个简单的权限，它们映射到可以在产品实体上执行的操作。
- en: Now, let's go ahead and create an access control handler for our Product entity
    type. You remember what these handlers are from [Chapter 6](77cab458-5612-468c-8010-12385708eb81.xhtml),
    *Data Modeling and Storage*, don't you?
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们继续为我们的产品实体类型创建一个访问控制处理程序。你还记得从[第6章](77cab458-5612-468c-8010-12385708eb81.xhtml)，“数据建模和存储”中了解到的这些处理程序吗？
- en: 'First, we will reference the class we build on the product annotation:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将引用我们在产品注解上构建的类：
- en: '[PRE37]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: I choose to put this handler in the `Access` namespace of the module, but feel
    free to put it where you want.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 我选择将此处理程序放在模块的`Access`命名空间中，但请随意将其放在您想要的位置。
- en: 'Second, we will need the actual class:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 其次，我们需要实际的类：
- en: '[PRE38]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'As I mentioned in [Chapter 6](77cab458-5612-468c-8010-12385708eb81.xhtml),
    *Data Modeling and Storage*, entity access control handlers need to extend the
    `EntityAccessControlHandler` base class. If one is not specifically provided,
    that is actually the handler the entity type defaults to. Also, there are two
    methods we will need to implement here (override):'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 如我在[第6章](77cab458-5612-468c-8010-12385708eb81.xhtml)“数据建模和存储”中提到的，实体访问控制处理程序需要扩展
    `EntityAccessControlHandler` 基类。如果没有提供特定的实现，那么实际上就是实体类型默认的处理程序。此外，我们还需要在这里实现两个方法（重写）：
- en: '`checkAccess()`, which is used to control access on the view, update and delete
    operations'
  id: totrans-210
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`checkAccess()` 方法，用于控制视图、更新和删除操作上的访问'
- en: '`checkCreateAccess()`, which is used to control access on the create operation'
  id: totrans-211
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`checkCreateAccess()` 方法，用于控制创建操作上的访问'
- en: The reason why these are separate is that for the create operation we don't
    have an entity we can inspect in the process.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是分开的原因是，对于创建操作，我们在这个过程中没有可以检查的实体。
- en: Our access rules for the Product entity type are very simple. For each operation,
    we allow access if the user has the relevant permission; otherwise, access is
    neutral. However, what happens in this case?
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 我们对产品实体类型的访问规则非常简单。对于每个操作，如果用户拥有相关的权限，我们就允许访问；否则，访问是中性的。然而，在这种情况下会发生什么呢？
- en: It's worth looking into the `EntityAccessControlHandler` base class and understanding
    what is going on. The main access entry points are the `access()` and `createAccess()`
    methods. We should never override these because the logic happening in there is
    quite standardized and is expected behavior by everyone. Instead, our rules go
    inside the two methods we saw in our own handler subclass.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 值得研究的是 `EntityAccessControlHandler` 基类，并了解其中发生的情况。主要的访问入口点是 `access()` 和 `createAccess()`
    方法。我们永远不应该重写这些方法，因为那里的逻辑相当标准化，并且是每个人的预期行为。相反，我们的规则应该放在我们自己的处理程序子类中看到的两个方法内部。
- en: The `access()` and `createAccess()` methods invoke entity access hooks (we'll
    talk about those in a minute). If those do not come back with an access denied
    message, they call their respective access methods we are overriding in our own
    subclass, and the results of these are combined with the ones from the access
    hooks inside an `orIf()` access result. Remember earlier when we talked about
    the `AccessResult` base class and its handy `orIf()` and `andIf()` methods?
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: '`access()` 和 `createAccess()` 方法会调用实体访问钩子（我们稍后会讨论这些）。如果它们没有返回访问拒绝的消息，它们会调用我们自己在子类中重写的相应访问方法，并将这些方法的输出与访问钩子内部的
    `orIf()` 访问结果结合起来。还记得我们之前提到的 `AccessResult` 基类及其方便的 `orIf()` 和 `andIf()` 方法吗？'
- en: It's important to note how access is determined with all these factors. If at
    least one of the hook implementations grants access and none deny it, the user
    will have access, unless we deny access in our access handler. Neutral access
    plays no role in this equation, except if all hook implementations and the access
    handler return neutral access (so no specific access being granted), then the
    access will be denied.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要注意如何通过所有这些因素来确定访问权限。如果至少有一个钩子实现授予访问权限且没有拒绝访问，则用户将有权访问，除非我们在访问处理程序中拒绝访问。中性访问在这个等式中不起作用，除非所有钩子实现和访问处理程序都返回中性访问（即没有授予特定的访问权限），那么访问将被拒绝。
- en: In our example, we defined permissions, and the handler simply checks for these.
    Already this is pretty flexible because administrators can now assign these permissions
    to roles and control which users can perform any of these operations. However,
    there is nothing stopping us from adding more logic to these methods. For example,
    we can even inspect the entities (and/or the user account) and determine access
    based on some given values. Moreover, we can inject services into the access handler
    and make use of them in these calculations.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的示例中，我们定义了权限，处理程序只是简单地检查这些权限。这已经相当灵活，因为管理员现在可以将这些权限分配给角色，并控制哪些用户可以执行这些操作中的任何一项。然而，我们并没有阻止在这些方法中添加更多逻辑。例如，我们甚至可以检查实体（以及/或用户账户）并根据一些给定的值确定访问权限。此外，我们可以将服务注入访问处理程序，并在这些计算中使用它们。
- en: Injecting services into Entity handlers
  id: totrans-218
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将服务注入实体处理程序
- en: One of the powers of using the access handler is that we can make it aware of
    the service container and inject whatever services we might need to determine
    access. However, it's not immediately clear how you can do this, so we'll break
    it down here.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 使用访问处理程序的一个优点是，我们可以使其了解服务容器，并注入我们可能需要的任何服务以确定访问权限。然而，这并不立即清楚如何做到这一点，所以我们将在这里分解它。
- en: 'The first thing we will need is to have our access handler implement the `\Drupal\core\Entity\EntityHandlerInterface`.
    Note that this applies in the same way to the other types of handlers, not just
    access-related. This interface has one method, which will receive the container
    and the entity type definition: `createInstance()`.'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先需要确保我们的访问处理器实现了`\Drupal\core\Entity\EntityHandlerInterface`接口。请注意，这同样适用于其他类型的处理器，而不仅仅是与访问相关的处理器。此接口有一个方法，它将接收容器和实体类型定义：`createInstance()`。
- en: 'Knowing this, the rest is very similar to how we injected services into Controllers
    and Forms using the `create()` method, which only takes the container as argument,
    or into plugins, which also takes some plugin information:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 了解这一点后，其余部分与使用`create()`方法将服务注入到控制器和表单中非常相似，该方法只接受容器作为参数，或者注入到插件中，后者也接受一些插件信息：
- en: '[PRE39]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'And the new *use* statements:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 以及新的*使用*语句：
- en: '[PRE40]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: With this, we have injected the entity type manager into the access handler,
    and if we want, we can use it. Of course, if we don't need it, we should not inject
    it in the first place.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这种方式，我们已经将实体类型管理器注入到访问处理器中，如果我们需要，我们可以使用它。当然，如果我们不需要它，我们最初就不应该注入它。
- en: Entity access hooks
  id: totrans-226
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实体访问钩子
- en: 'As I mentioned, the core entity access handler invokes access hooks that modules
    that don''t own the entity type can implement in order to have their say in the
    access to an entity. There are two sets of access hooks to speak of. The first
    set covers *create* operations, as follows:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我提到的，核心实体访问处理器会调用模块实现的访问钩子，这些模块不拥有实体类型，以便它们可以在实体的访问中发表意见。有两个访问钩子集要讨论。第一组涵盖了*创建*操作，如下所示：
- en: '`hook_entity_create_access()`'
  id: totrans-228
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`hook_entity_create_access()`'
- en: '`hook_[entity_type]_create_access()`'
  id: totrans-229
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`hook_[entity_type]_create_access()`'
- en: 'The second set covers `view`, `update`, and `delete` operations:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 第二组涵盖了`view`、`update`和`delete`操作：
- en: '`hook_entity_access()`'
  id: totrans-231
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`hook_entity_access()`'
- en: '`hook_[entity_type]_access()`'
  id: totrans-232
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`hook_[entity_type]_access()`'
- en: For each set, we have two hooks invoked at the same time that go from generic
    to entity type-specific. For example, when trying to view a node, the second hook
    that is invoked is `hook_node_access()`.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 对于每一组，我们同时调用两个钩子，从通用到实体类型特定。例如，当尝试查看一个节点时，被调用的第二个钩子是`hook_node_access()`。
- en: The entity access hook implementations, as you remember from our earlier discussion,
    also have to return an `AccessResultInterface`. This is because the result is
    used inside the `orIf()` combination with the access result of the access handler.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 如您从我们之前的讨论中记得，实体访问钩子实现还必须返回一个`AccessResultInterface`。这是因为结果在`orIf()`组合中使用，与访问处理器的访问结果一起使用。
- en: 'So, let''s take a look at how we can implement these access hooks, especially
    their signatures. Hence, we begin with the first set:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，让我们看看我们如何实现这些访问钩子，特别是它们的签名。因此，我们从第一组开始：
- en: '[PRE41]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: This is the generic entity create access hook. To make it specific to an entity
    type, we replace the word `entity` from the function name with the actual ID of
    the entity type. The parameters, however, remain the same—the user account being
    checked for access, a context (an array containing the entity type ID and the
    langcode of the entity being created), and the bundle of the entity being created.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 这是通用的实体创建访问钩子。为了使其特定于一个实体类型，我们将函数名中的单词`entity`替换为实际的目标实体类型ID。然而，参数保持不变——被检查访问的用户账户，一个上下文（一个包含实体类型ID和正在创建的实体langcode的数组），以及正在创建的实体的捆绑包。
- en: 'The second set looks like this:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 第二组看起来像这样：
- en: '[PRE42]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Again, to make it specific to an entity type, we can just replace the word
    `entity` with the ID of the entity type we want. Once again, the parameters remain,
    in essence, consistent—the entity being accessed (type-hinted with the relevant
    entity interface if implementing the more specific hook), the operation being
    attempted (one of three strings: `view`, `update`, and `delete`), and the user
    account being checked for access.'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调，为了使它特定于一个实体类型，我们只需将单词`entity`替换为我们想要的目标实体类型的ID。再次强调，参数在本质上保持一致——被访问的实体（如果实现了更具体的钩子，则使用相关实体接口进行类型提示），尝试进行的操作（三个字符串之一：`view`、`update`和`delete`），以及被检查访问的用户账户。
- en: That's pretty much it. These hooks are invoked dynamically whenever access is
    being checked on an entity for the given operation. Let's talk about some examples
    of this.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 大致就是这样。这些钩子会在检查实体给定操作的访问时动态调用。让我们来谈谈一些这方面的例子。
- en: First, the entity routes that come out of the box are checking access against
    these operations, so no need to worry there. So, if we navigate to the canonical,
    form, or delete URL, access will be checked.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，默认的实体路由会检查这些操作，所以无需担心。因此，如果我们导航到规范、表单或删除URL，将会检查访问权限。
- en: 'Secondly, if we programmatically load an entity and render it as we saw in
    [Chapter 6](77cab458-5612-468c-8010-12385708eb81.xhtml), *Data Modeling and Storage*,
    using the view builder handler, the entity access with the `view` operation gets
    invoked. However, if we load the entity and simply retrieve some data from it
    and print it within our own template, we bypass access control. If we are doing
    this, we will need to make sure that we always check access manually:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 第二，如果我们以编程方式加载一个实体，并像在[第6章](77cab458-5612-468c-8010-12385708eb81.xhtml)“数据建模和存储”中看到的那样，使用视图构建器处理器渲染它，那么`view`操作的实体访问会被调用。然而，如果我们加载实体并简单地从中检索一些数据，并在我们自己的模板中打印它，我们将绕过访问控制。如果我们这样做，我们需要确保我们始终手动检查访问权限：
- en: '[PRE43]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: This will return a Boolean, unless you specify a third argument as TRUE, which
    will return an `AccessResultInterface` object; your call, depending on the circumstances.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 这将返回一个布尔值，除非你指定第三个参数为TRUE，这将返回一个`AccessResultInterface`对象；具体情况取决于环境。
- en: Thirdly, if we load an entity programmatically that we use inside a form builder
    and want to render the form, we again bypass the access check. So, we should perform
    it manually again using the `update` operation instead.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 第三，如果我们以编程方式加载一个在表单构建器内部使用的实体，并想要渲染表单，我们再次绕过访问检查。因此，我们应该再次手动使用`update`操作来执行它。
- en: When it comes to programmatically dealing with URLs and menu links to pages
    that have CRUD connotations with regard to entities, we will need to perform access
    checking ourselves, but we will discuss entity access in routes in a minute; first,
    a word of caution.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 当涉及到以编程方式处理与实体有CRUD关联的页面URL和菜单链接时，我们需要自己执行访问检查，但我们将稍后讨论路由中的实体访问；首先，提醒一下。
- en: Earlier, I made a note about extracting entity data and simply rendering field
    values. The same problem occurs when running entity queries—the results will contain
    entities that the current user may not have access to. So, we must be aware of
    this and handle it appropriately. This problem becomes even more prominent with
    Views, which makes custom database queries and will include potentially inaccessible
    entities in the result set. Compounded by the possibility of rendering field values
    with Views, this can cause quite unexpected behavior. So, keep in mind that for
    cases like this, the entity access hooks and access control handler do not fire.
    The Node module, however, has a complex grant system that takes care of all this,
    but, unfortunately, this is available only for node entities. We will talk about
    these soon as well.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 之前，我提到了关于提取实体数据并简单地渲染字段值的问题。当运行实体查询时，同样的问题会出现——结果将包含当前用户可能没有访问权限的实体。因此，我们必须意识到这一点，并适当地处理它。随着视图的出现，这个问题变得更加突出，视图可以执行自定义数据库查询，并将可能无法访问的实体包含在结果集中。加上视图渲染字段值的可能性，这可能会导致非常意外的行为。因此，请记住，在这种情况下，实体访问钩子和访问控制处理器不会触发。然而，Node模块有一个复杂的授权系统，负责处理所有这些，但遗憾的是，这仅适用于节点实体。我们很快也会讨论这些内容。
- en: Field access
  id: totrans-249
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 字段访问
- en: We've seen so far how the entity-level access works. However, a very similar
    system also exists for the fields inside entities. If you look inside the `EntityAccessControlHandler`,
    you'll note that there is a `fieldAccess()` method. This is called whenever access
    needs to be checked on a given field. For example, the `FieldItemList::access()`
    method does just that and delegates to the entity handler. Inside that, a call
    is made to `checkFieldAccess()`, which is what we can implement in our access
    handler subclass to customize access rules if we need to.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经看到了实体级别访问是如何工作的。然而，对于实体内部的字段，也存在一个非常类似的系统。如果你查看`EntityAccessControlHandler`内部，你会注意到有一个`fieldAccess()`方法。这个方法会在需要检查给定字段的访问权限时被调用。例如，`FieldItemList::access()`方法就是这样做，并将任务委托给实体处理器。在这个内部，会调用`checkFieldAccess()`，这是我们可以在我们的访问处理器子类中实现以自定义访问规则的地方。
- en: In a similar way, we have multiple operations that access can be checked for,
    but `view` will be your most common one. For example, when manually rendering
    an entity using the entity builder handler, as we've seen before, each field is
    being checked for access to the `view` operation. The same goes, **this time**,
    when an entity form is being built for the entity to edit it. Each field that
    is being rendered in the form gets checked for access first using the `edit` operation.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 以类似的方式，我们有多个操作可以检查访问权限，但 `view` 将是您最常见的一个。例如，当手动使用实体构建处理程序渲染实体时，就像我们之前看到的，每个字段都会被检查是否有
    `view` 操作的访问权限。同样，**这次**，当为编辑实体而构建实体表单时，每个在表单中渲染的字段都会首先使用 `edit` 操作进行检查访问权限。
- en: 'Again, we also have access hooks that other modules can implement to have a
    say in whether or not fields should be accessible:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调，我们也有访问钩子，其他模块可以实现这些钩子，以便在字段是否可访问的问题上有发言权：
- en: '`hook_entity_field_access()`'
  id: totrans-253
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`hook_entity_field_access()`'
- en: '`hook_entity_field_access_alter()`'
  id: totrans-254
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`hook_entity_field_access_alter()`'
- en: In this case, we don't have an entity type or a field type-specific hook that
    we can implement. However, we have an alter hook that we can use to alter the
    access rules proposed by other modules.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们没有实体类型或字段类型特定的钩子可以实施。然而，我们有一个可以用来修改其他模块提出的访问规则的修改钩子。
- en: Similar to the entity-level access handler, the field-level one takes its input
    from multiple sources—subclass and hook implementations. However, the order and
    combination of these are different. First, the access handler subclass is called
    (via the `checkFieldAccess()` method). Then, all the `hook_entity_field_access()`
    hooks are invoked to provide their input. Both of these in turn are then alterable
    by implementing `hook_entity_field_access_alter()`. Finally, the resulting access
    rules are combined into an `orIf()` and returned. So, the same principles are
    available as we saw at the entity level, but in a different order.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 与实体级访问处理程序类似，字段级处理程序从多个来源获取输入——子类和钩子实现。然而，它们的顺序和组合是不同的。首先，调用访问处理程序子类（通过 `checkFieldAccess()`
    方法）。然后，所有 `hook_entity_field_access()` 钩子被调用以提供它们的输入。这两个钩子随后都可以通过实现 `hook_entity_field_access_alter()`
    来修改。最后，生成的访问规则被组合成一个 `orIf()` 并返回。所以，与我们在实体级别看到的相同原则可用，但顺序不同。
- en: Entity access in routes
  id: totrans-257
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 路由中的实体访问
- en: Now that we understand how entity-level access control works, let's return to
    routes for a moment. If you remember, I mentioned the `_entity_access` route requirement
    and how we would talk about it once we had covered entity access.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了实体级访问控制是如何工作的，让我们暂时回到路由上。如果你还记得，我提到了 `_entity_access` 路由要求，以及在我们覆盖了实体访问之后我们将如何讨论它。
- en: 'The `_entity_access` route requirement is nothing more than a service-based
    access checker, much like the one we wrote ourselves. However, it is created by
    the entity system in order to control access to routes based on dynamic entity
    parameters in those routes. Let''s see a quick example of a route definition that
    can use the `_entity_access` requirement:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: '`_entity_access` 路由要求不过是一个基于服务的访问检查器，就像我们自己编写的那个一样。然而，它是实体系统创建的，以便根据那些路由中的动态实体参数来控制对这些路由的访问。让我们看看一个可以使用
    `_entity_access` 要求的快速路由定义示例：'
- en: '[PRE44]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: This route has a dynamic parameter called `product`. In the options, we map
    this parameter to the Product entity type, so that our Controller method (`showProduct()`)
    already receives the loaded product entity instead of just the ID. An added benefit
    of this is that if the product is not found, a 404 is thrown for us. Since this
    route is clearly dependent on that particular product, we also want to make sure
    that it can be accessible only if the user has access to view that product.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 这个路由有一个名为 `product` 的动态参数。在选项中，我们将这个参数映射到产品实体类型，这样我们的控制器方法（`showProduct()`）就已经接收到了加载的产品实体，而不仅仅是ID。这个附加的好处是，如果找不到产品，它会为我们抛出一个404错误。由于这个路由显然依赖于那个特定的产品，我们还想确保只有当用户有权查看该产品时，它才能被访问。
- en: 'One way we can ensure access is to add a permission requirement that matches
    the one for viewing the Product entities. However, this is not a good idea for
    two reasons:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以确保访问的一种方式是添加一个与查看产品实体权限相匹配的权限要求。然而，出于两个原因，这并不是一个好主意：
- en: If we change the permission used by the Product entity, we have to change it
    in this definition as well.
  id: totrans-263
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果我们更改产品实体的权限，我们也必须在这个定义中更改它。
- en: Even more importantly, if the entity access logic depends on something more,
    such as dynamic data from the user or entity, this won't work anymore.
  id: totrans-264
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更重要的是，如果实体访问逻辑依赖于更多内容，比如来自用户或实体的动态数据，那么这将不再有效。
- en: 'An alternative way to counter these problems is to implement an access checker
    service and check for the access on the entity inside that service:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种解决这些问题的方法是实现一个访问检查器服务，并在该服务内部检查实体的访问权限：
- en: '[PRE45]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: However, there's a lot of boilerplate setup involved for just this line of code.
    We'd have to do so for all entity types and operations.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，仅仅为了这一行代码，就需要大量的样板设置。我们必须为所有实体类型和操作都这样做。
- en: Instead, we use the built-in `_entity_access` access checker as in the example
    route definition. Instead of `TRUE` (what we've been using for our access checker),
    this one actually expects a value it will make use of, and that is a string with
    two parts separated by a period (`.`). The first part is the entity type, whereas
    the second is the operation. Under the hood, `EntityAccessCheck` will look in
    the route parameters and check for the found entity's access using the provided
    operation. Easy peasy.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，我们使用内置的`_entity_access`访问检查器，就像在示例路由定义中那样。与`TRUE`（我们一直在使用的访问检查器）不同，这个实际上期望一个它将使用的值，这是一个由点(`.`)分隔的两个部分组成的字符串。第一部分是实体类型，而第二部分是操作。在底层，`EntityAccessCheck`将检查路由参数，并使用提供的操作检查找到的实体的访问权限。简单易懂。
- en: Node access grants
  id: totrans-269
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 节点访问权限
- en: Earlier I warned about the entity access controls we've been talking about not
    being taken into account during queries (either written by us or Views). This
    is something to pay attention to. For example, if you make a listing of entities,
    you will need to ensure that users have access to these entities before printing
    the results out. The problem here occurs when using the built-in paging capabilities
    of either the entity query or database API. That's because the pager information
    will reflect all the query results. So, if you don't print the inaccessible entities,
    there will be a mismatch between the pager information and visible results.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 之前我警告过，我们一直在讨论的实体访问控制在我们编写的查询（无论是我们自己编写的还是通过Views编写的）中并没有被考虑。这是需要注意的一点。例如，如果你要列出实体，你需要在打印结果之前确保用户有权访问这些实体。这里的问题在于使用实体查询或数据库API内置的分页功能。这是因为分页信息将反映所有查询结果。所以，如果你不打印不可访问的实体，分页信息和可见结果之间将出现不匹配。
- en: If you remember, in [Chapter 6](77cab458-5612-468c-8010-12385708eb81.xhtml),
    *Data Modeling and Storage*, I mentioned that when it comes to nodes, the entity
    query takes access into account. If you want to avoid that, you should use the
    `accessCheck(FALSE)` method on the query builder. Let's elaborate a bit on this.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你记得，在[第6章](77cab458-5612-468c-8010-12385708eb81.xhtml)《数据建模与存储》中，我提到当涉及到节点时，实体查询会考虑访问权限。如果你想避免这种情况，你应该在查询构建器上使用`accessCheck(FALSE)`方法。让我们对此进行详细说明。
- en: First, this method is available on all entity types, not just nodes. However,
    it is really useful only for those that have defined a `status` field to denote
    that entities can be either published or unpublished (or/off, enabled/disabled,
    however you prefer). The query will simply add a condition to that field and only
    return the ones with the status that equals 1\. Passing FALSE to this method simply
    removes that condition.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，这个方法适用于所有实体类型，而不仅仅是节点。然而，它真正有用的地方仅限于那些定义了`status`字段以表示实体可以是已发布或未发布的实体（或/off，启用/禁用，根据你的喜好）。查询将简单地添加一个条件到该字段，并且只返回状态等于1的实体。将FALSE传递给这个方法简单地移除这个条件。
- en: Second, the Node entity type has a much more powerful built-in access system
    called *access grants*. These have been there from previous versions of Drupal
    and this is why we have it available in D8 as well. Unfortunately, it is not there
    for other entity types. However, if you really need it, you could technically
    write it yourself now that you know how the entity access system works in general,
    and can look into how the node access grants are built. But what is this system
    about?
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 其次，节点实体类型有一个更强大的内置访问系统，称为*访问权限*。这些功能从Drupal的早期版本就已经存在，这也是为什么我们在D8版本中也提供了它。不幸的是，它并不适用于其他实体类型。然而，如果你确实需要它，现在你了解了实体访问系统的工作原理，你可以自己编写它，并且可以研究节点访问权限是如何构建的。但这个系统究竟是什么呢？
- en: 'The node access grants system is a granular way by which we can control access
    to any of the operations on a node. This is done using a combination of *realms*
    and *grants*. When a node is saved, we have the opportunity to create *access
    records* for that node that contain the following information:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 节点访问权限系统是我们控制对节点上任何操作访问的一种细粒度方式。这是通过结合*领域*和*权限*来实现的。当一个节点被保存时，我们有创建该节点*访问记录*的机会，这些记录包含以下信息：
- en: '*realm* (string): A category for our access records. Typically, this is used
    to denote specific functionality under which the access control happens.'
  id: totrans-275
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*realm*（字符串）：我们访问记录的类别。通常，这用于表示访问控制发生的特定功能。'
- en: '*gid (grant ID)* (int): The ID of the grant by which we can verify the user
    trying to access the node. Typically, this will map to either a role or a custom-defined
    "group" that users belong to. For example, a *manager* user type (from the earlier
    example) can map to the grant ID 1\. You''ll understand this in a moment.'
  id: totrans-276
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*gid（权限ID）*（整数）：通过它可以验证尝试访问节点的用户的权限ID。通常，这会映射到一个角色或用户所属的自定义定义的“组”。例如，一个*经理*用户类型（从之前的例子中）可以映射到权限ID
    1。你很快就会明白这一点。'
- en: '*grant_view*, *grant_update*, *grant_delete* (int): Boolean indicating whether
    this access record is for this operation.'
  id: totrans-277
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*grant_view*，*grant_update*，*grant_delete*（整数）：布尔值，表示此访问记录是否用于此操作。'
- en: '*langcode* (string): The language of the node this access record should apply
    to.'
  id: totrans-278
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*langcode*（字符串）：此访问记录应应用的节点语言。'
- en: Then, we can return grant records for a given user when they try to access the
    node. For a given user, we can return multiple grants as part of multiple realms.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，当用户尝试访问节点时，我们可以为给定的用户返回权限记录。对于给定的用户，我们可以作为多个领域的一部分返回多个权限。
- en: The node access records get stored inside the `node_access` table and it's a
    good idea to keep checking that table while you are developing and preparing your
    access records. By default, if there are no modules that provide access records,
    there will be only one row in that table referencing the Node ID 0 and the realm
    `all`. This means that basically the node access grants system is not used, and
    all nodes are accessible for viewing in all realms. That is to say, default access
    rules apply. Once a module creates records, as we will see, this row is deleted.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 节点访问记录存储在`node_access`表中，在你开发和准备访问记录时，检查该表是个好主意。默认情况下，如果没有提供访问记录的模块，该表中将只有一行，引用节点ID
    0和领域`all`。这意味着基本上节点访问权限系统没有被使用，所有节点在所有领域中都可以查看。也就是说，默认访问规则适用。一旦模块创建记录，正如我们将看到的，这一行将被删除。
- en: To better understand how this system works, let's see a practical code example.
    For this, we'll get back to our User Types module and create some node access
    restrictions based on these user types. We'll start with an easy example and then
    expand on it to make it more complex (and more useful).
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更好地理解这个系统是如何工作的，让我们看看一个实际的代码示例。为此，我们将回到我们的用户类型模块，并基于这些用户类型创建一些节点访问限制。我们将从一个简单的例子开始，然后扩展它使其更复杂（也更实用）。
- en: To begin with, we want to make sure that Article nodes are only viewable by
    users of all three types (so there are still some restrictions, as users need
    to have a type). Page nodes, on the other hand, are restricted to managers and
    board members. So let's get it done.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们想要确保文章节点只能由所有三种类型的用户查看（因此仍然有一些限制，因为用户需要有一个类型）。另一方面，页面节点仅限于经理和董事会成员。所以让我们完成它。
- en: 'All the work we do now takes place inside the `.module` file of the module.
    First, let''s create a rudimentary mapping function to which we can provide a
    user type string (as we''ve seen before) and that returns a corresponding grant
    ID. We will then use this consistently to get the grant ID of a given user type:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在所做的所有工作都在模块的`.module`文件中进行。首先，让我们创建一个基本的映射函数，我们可以向它提供一个用户类型字符串（就像我们之前看到的），然后返回相应的权限ID。然后我们将一致地使用它来获取给定用户类型的权限ID：
- en: '[PRE46]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: It's nothing too complicated. We have our three user types that map to simple
    integers. Also, we throw an exception if a wrong user type is passed. Now comes
    the fun part.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 这并不复杂。我们有三种用户类型，它们对应简单的整数。如果传递了错误的用户类型，我们会抛出一个异常。现在到了有趣的部分。
- en: 'Working with node access grants restrictions involves the implementation of
    two hooks: one for creating the access records of the nodes and one to provide
    the grants of the current user. Let''s first implement `hook_node_access_records()`:'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: '与节点访问权限限制一起工作涉及两个钩子的实现：一个用于创建节点的访问记录，另一个用于提供当前用户的权限。让我们首先实现`hook_node_access_records()`:'
- en: '[PRE47]'
  id: totrans-287
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: This hook is invoked whenever a node is being saved and it needs to return an
    array of access records for that node. As expected, the parameter is the node
    entity.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 这个钩子会在节点保存时被调用，并且需要返回该节点的访问记录数组。正如预期的那样，参数是节点实体。
- en: The first thing we do is simply return an empty array if the node is not one
    of the ones we are interested in. If we return no access records, this node will
    be given one single record for the realm `all` with the grant ID of 1 for the
    `view` operation. This means that it is accessible in accordance with the default
    node access rules.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先做的事情是，如果节点不是我们感兴趣的节点之一，就简单地返回一个空数组。如果我们不返回任何访问记录，这个节点将为`all`领域分配一个带有ID为1的`view`操作的单一记录。这意味着它将按照默认的节点访问规则可访问。
- en: Then, we will create a simple map of the user types we want viewing our node
    bundles. Also, for each user type that corresponds to the current bundle, we create
    an access record for the `user_type` realm with the grant ID that maps to that
    user type, and with permission to view this node.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将创建一个简单的映射，映射出我们希望查看我们的节点包的用户类型。对于与当前包对应的每个用户类型，我们为`user_type`领域创建一个访问记录，其授权ID映射到该用户类型，并且具有查看此节点的权限。
- en: There are two ways we can trigger this hook and persist the access records.
    We can edit and save a node, which will create the records for that node. Or we
    can rebuild the permissions that will do so for all the nodes on the site. The
    link to do this can be found on the status report page.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有两种方法可以触发这个钩子并持久化访问记录。我们可以编辑并保存一个节点，这将为此节点创建记录。或者我们可以重建权限，这将为此站点的所有节点执行此操作。执行此操作的链接可以在状态报告页面上找到。
- en: 'It''s a good idea to rebuild the permissions while developing to make sure
    that your changes get applied to all the nodes. Once we do this, our nodes now
    become inaccessible to basically anyone (except the super user with the ID of
    1). That''s because we need to specify the grants a given user should have by
    implementing `hook_node_grants()`:'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 在开发过程中重建权限是个好主意，以确保您的更改应用于所有节点。一旦我们这样做，我们的节点现在基本上对任何人（除了ID为1的超级用户）都不可访问。这是因为我们需要通过实现`hook_node_grants()`来指定给定用户应拥有的授权：
- en: '[PRE48]'
  id: totrans-293
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: This hook is invoked by the node access system every time access is being checked
    on a given node (for a given operation). Moreover, it is also invoked when running
    entity queries against the node entity type and the access check has not been
    disabled. Finally, it is also invoked in database API queries when the `node_access`
    tag is used. Remember the query alters based on tags that we talked about in [Chapter
    8](c20b297a-3a37-46ff-a80c-bf83a21bbd5d.xhtml), *The Database API*?
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 每当在给定节点（针对给定操作）上进行访问检查时，节点访问系统都会调用这个钩子。此外，当对节点实体类型运行实体查询且未禁用访问检查时，它也会被调用。最后，当在数据库API查询中使用`node_access`标签时，它也会被调用。记得我们之前在[第8章](c20b297a-3a37-46ff-a80c-bf83a21bbd5d.xhtml)“数据库API”中讨论过的基于标签的查询会改变吗？
- en: As an argument, it receives the user account for which access needs to be checked
    (the grants that it has within the node access grants system of the given operation).
    So what we do here is start by returning an empty array (no grants) if the user
    is anonymous or the operation they are attempting to do is not `view`—they have
    not been granted access. The same thing happens if the user entity does not have
    any value in the `field_user_type` field. If they do, however, we get the corresponding
    grant ID and return an array of access grants keyed by the realm. For each realm,
    we can include more than one grant ID. In this case, though, it is only one since
    the user can only be of one type. We can also return multiple realms if needed,
    and, of course, other modules may do so as well, the results being centralized
    and used in the access logic.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 作为参数，它接收需要检查访问的用户账户（它在给定操作的节点访问授权系统中的授权）。所以我们在这里首先返回一个空数组（没有授权），如果用户是匿名用户或者他们尝试执行的操作不是`view`——他们没有被授予访问权限。如果用户实体在`field_user_type`字段中没有任何值，也会发生同样的事情。然而，如果他们有值，我们就获取相应的授权ID，并返回一个按领域键控的访问授权数组。对于每个领域，我们可以包括多个授权ID。但在这个情况下，只有一个，因为用户只能属于一种类型。如果需要，我们也可以返回多个领域，当然，其他模块也可以这样做，结果将被集中并用于访问逻辑。
- en: With this in place, all our page nodes are now available for viewing only to
    board member and manager users, whereas articles are available for viewing to
    employees as well. If users don't have any type, they don't have access. The great
    thing is that these restrictions are now being taken into account also when running
    queries. So, we can automatically exclude from query results the nodes to which
    users don't have access. This works with Views as well.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 在此基础上，我们所有的页面节点现在仅供董事会成员和管理员用户查看，而文章则可供员工查看。如果用户没有任何类型，他们将无法访问。好事是，这些限制现在在运行查询时也被考虑在内。因此，我们可以自动从查询结果中排除用户无法访问的节点。这也适用于视图。
- en: 'Let''s now enhance this solution with the following changes:'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们现在通过以下更改来增强这个解决方案：
- en: Unpublished article nodes are only available to managers and board members.
  id: totrans-298
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 未发布的文章节点仅对管理者和管理委员会成员可用。
- en: Managers also have access to update and delete articles and pages.
  id: totrans-299
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 管理者也有权更新和删除文章和页面。
- en: 'The first one is easy. After we define our internal map inside `user_types_node_access_records()`,
    we can unset the `employee` from the array in case the node is unpublished:'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 第一件事很简单。在我们定义`user_types_node_access_records()`内部的内部映射之后，我们可以从数组中取消设置`employee`，以防节点未发布：
- en: '[PRE49]'
  id: totrans-301
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: This was a very simple example, but one meant to draw your attention to an important
    but often forgotten point. If you create access records for a node, you will need
    to account for the node status yourself. This means that if you grant access to
    someone to view a node, they will have access to view that node regardless of
    the status. More often than not, this is not something you want. So just make
    sure that you consider this point when implementing access grants.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个非常简单的例子，但目的是引起你注意一个重要但经常被遗忘的点。如果你为节点创建访问记录，你需要自己考虑节点状态。这意味着，如果你授予某人查看节点的访问权限，他们将能够查看该节点，无论其状态如何。这种情况通常不是你想要的。所以，请确保在实现访问权限时考虑这一点。
- en: 'Now, let''s see how we can alter our logic to allow managers to update and
    delete nodes (both articles and pages). This is how `user_types_node_access_records()`
    looks like now:'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看我们如何修改我们的逻辑，以便让管理者能够更新和删除节点（包括文章和页面）。这就是现在的`user_types_node_access_records()`看起来像这样：
- en: '[PRE50]'
  id: totrans-304
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: What we are doing differently is, first, we rename the `$map` variable to `$view_map`
    in order to reflect the actual grant associations. Then, we create a `$manage_map`
    to hold the user types that can edit and delete the nodes. Based on this map,
    we can then set the `grant_update` and `grant_delete` values to 1 for the user
    types that are allowed. Otherwise, they stay as they were.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 我们所做不同的地方是，首先，我们将`$map`变量重命名为`$view_map`，以便反映实际的授权关联。然后，我们创建一个`$manage_map`来保存可以编辑和删除节点的用户类型。基于这个映射，我们可以为允许的用户类型设置`grant_update`和`grant_delete`值为1。否则，它们保持不变。
- en: 'All we need to do now is go back to the `hook_node_grants()` implementation
    and remove the following:'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们需要做的就是回到`hook_node_grants()`实现中，并删除以下内容：
- en: '[PRE51]'
  id: totrans-307
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: We are now interested in all operations so users should be provided all the
    possible grants. After rebuilding the permissions, manager user types will be
    able to update and delete articles and pages, while the other user types won't
    have these permissions. This doesn't have many implications for queries because
    those use the `view` operation.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在对所有操作都感兴趣，因此用户应该被提供所有可能的权限。在重建权限后，管理用户类型将能够更新和删除文章和页面，而其他用户类型则不会有这些权限。这对查询的影响不大，因为那些使用`view`操作。
- en: Before closing the topic on the node access grants, you should also know that
    there is an alter hook available that can be used to modify the access records
    created by other modules—`hook_node_access_records_alter()`. This is invoked after
    all the modules provide their records for a given node, and you can use it to
    alter whatever they provided before being stored.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 在关闭节点访问权限的主题之前，你还应该知道，有一个可用的alter钩子，可以用来修改由其他模块创建的访问记录——`hook_node_access_records_alter()`。这将在所有模块为给定节点提供其记录之后调用，并且你可以用它来修改在存储之前他们提供的任何内容。
- en: The access grants system, as mentioned, is limited to the node entity type.
    It has been there since previous versions of Drupal and it didn't quite make it
    to become standard across the entity system. There is talk, however, of doing
    this, but it's quite incipient.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，访问权限系统仅限于节点实体类型。它自Drupal的早期版本以来一直存在，并且并没有成为实体系统的标准。然而，有人提到要这样做，但这还处于初级阶段。
- en: To better understand how it works under the hood in case you want to write your
    own such system, I encourage you to explore the `NodeAccessControlHandler`. You'll
    note that its `checkAccess()` method delegates to the `NodeGrantDatabaseStorage`
    service responsible for invoking the grant hooks we've seen before. Moreover,
    you can also check out the `node_query_node_access_alter` implementation of `hook_query_QUERY_TAG_alter()`
    in which the Node module uses the same grant service to alter the query in order
    to take into account the access records. It's not the easiest system to dissect,
    especially if you are a beginner, but it's well worth going through to learn more.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更好地理解其内部工作原理，以便你在需要编写自己的系统时，我鼓励你探索`NodeAccessControlHandler`。你会注意到它的`checkAccess()`方法将委托给负责调用我们之前看到的授权钩子的`NodeGrantDatabaseStorage`服务。此外，你还可以查看`node_query_node_access_alter`实现，这是在`hook_query_QUERY_TAG_alter()`中实现的，节点模块使用相同的授权服务来修改查询，以便考虑访问记录。这不是一个最容易分解的系统，尤其是如果你是初学者，但它非常值得深入研究以了解更多。
- en: Block access
  id: totrans-312
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 块访问
- en: 'Another major area where you will deal with access is when trying to control
    access to a custom block. If you remember in [Chapter 2](601b4dd0-c521-459e-9342-2645a109642c.xhtml),
    *Creating Your First Module*, we created the `HelloWorldSalutationBlock` plugin
    so that our salutation can also be rendered using a block. Now that block can
    be placed in a region and even configured to show up only on certain pages, for
    certain user roles, or even on node pages restricted by bundle. This is all done
    in the UI:'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个你需要处理访问权限的主要领域是在尝试控制自定义块访问权限时。如果你还记得在[第二章](601b4dd0-c521-459e-9342-2645a109642c.xhtml)，“创建你的第一个模块”，我们创建了`HelloWorldSalutationBlock`插件，以便我们的问候语也可以通过块来渲染。现在这个块可以被放置在区域中，甚至可以配置为仅在特定页面上显示，针对特定用户角色，甚至可以限制在特定捆绑包的节点页面上显示。所有这些操作都在UI中完成：
- en: '![](img/9f181fd7-14a1-4147-b687-1278c15b4e82.png)'
  id: totrans-314
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/9f181fd7-14a1-4147-b687-1278c15b4e82.png)'
- en: However, this is oftentimes not enough, and you will want to have a block placed
    in a region and control yourself under what circumstances it should show up. Enter
    block access.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这通常是不够的，你可能希望将块放置在区域中，并自行控制它在什么情况下应该显示。这就是块访问的用武之地。
- en: Inside the `BlockBase` plugin base class, there is the `blockAccess()` method
    which always returns positively. This is because, by default, all blocks will
    be rendered once they are placed in a region. Unless, of course, they are configured
    to only show in certain cases, in which case a system of visibility based on the
    available contexts kicks in to control that. However, if we override this method
    in our block plugin class, we can control whether or not the block is shown. So
    we can leave the visibility options empty when placing the block in a region and
    then handle everything we want regarding its visibility inside the `blockAccess()`
    method. Neat, isn't it?
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 在`BlockBase`插件基类中，有一个`blockAccess()`方法，它总是返回正值。这是因为，默认情况下，一旦块被放置在区域中，它们就会被渲染。除非，当然，它们被配置为仅在特定情况下显示，在这种情况下，基于可用上下文的可见性系统就会启动来控制这一点。然而，如果我们在这个块插件类中重写这个方法，我们就可以控制块是否显示。因此，当我们把块放置在区域中时，我们可以留空可见性选项，然后在`blockAccess()`方法中处理关于其可见性的所有操作。这不是很酷吗？
- en: Also, as expected, the method has one parameter, namely the account being checked,
    and needs to return an `AccessResultInterface`. Since we can inject services into
    our block plugin (by implementing the `ContainerFactoryPluginInterface` as we
    saw in [Chapter 2](601b4dd0-c521-459e-9342-2645a109642c.xhtml), *Creating Your
    First Module*), we can use what we want to check whether the given user should
    see the block. If we deny access, the block is simply not rendered.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，正如预期的那样，该方法有一个参数，即被检查的账户，并需要返回一个`AccessResultInterface`。由于我们可以在我们的块插件中注入服务（通过实现我们在[第二章](601b4dd0-c521-459e-9342-2645a109642c.xhtml)，“创建你的第一个模块”中看到的`ContainerFactoryPluginInterface`），我们可以使用我们想要的来检查给定用户是否应该看到该块。如果我们拒绝访问，块将简单地不会被渲染。
- en: That is pretty much all there is to the block access control.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是块访问控制的主要内容。
- en: Summary
  id: totrans-319
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we talked about many access-related topics and techniques.
    In doing so, we covered what you need to know when starting Drupal 8 module development.
    Of course, as you progress, you'll dive deeper into the code and learn more subtle
    aspects and advanced concepts that you can employ in your modules. However, what
    we covered should set you well on your way. So, what exactly did we talk about?
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们讨论了许多与访问相关的主题和技术。在这个过程中，我们涵盖了在开始Drupal 8模块开发时你需要了解的内容。当然，随着你的进步，你将更深入地研究代码，并学习更多细微的方面和高级概念，这些你可以在你的模块中使用。然而，我们所涵盖的内容应该能让你顺利地开始。那么，我们究竟讨论了什么呢？
- en: We started by introducing the high-level Drupal 8 access system which is made
    up of the matrix between roles and permissions. In doing so, we've seen how we
    can define permissions in code and also how we can check whether a user has those
    permissions. Of course, we looked at other ways we can check a user's credentials
    and saw how we can use the `AccountInterface` for this.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先介绍了由角色和权限之间的矩阵组成的Drupal 8高级访问系统。在这个过程中，我们看到了如何在代码中定义权限，以及如何检查用户是否有这些权限。当然，我们还探讨了其他检查用户凭据的方法，并看到了如何使用`AccountInterface`来完成这项工作。
- en: Then, we moved on to routes and saw all the various ways we can ensure access
    control on these. In doing so, we covered simple checks such as permissions and
    roles, but also went into more advanced examples of using custom access checkers.
    We saw that these can be both static and service-based to make access checking
    fully dynamic. To demonstrate these concepts, we also looked at a case study of
    using route options to basically configure the access checker used on a group
    of similar routes.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们转向路由，并看到了确保这些路由上的访问控制的各种方法。在这个过程中，我们涵盖了简单的检查，如权限和角色，但也探讨了使用自定义访问检查器的更高级示例。我们看到这些可以是静态的，也可以是基于服务的，以使访问检查完全动态。为了展示这些概念，我们还研究了一个案例研究，即使用路由选项来基本配置在一系列类似路由上使用的访问检查器。
- en: Another major topic we covered was access on entities. We saw how we can create
    our own access control handler and check access for all the operations specific
    to entities. The access hooks invoked by the base access handler also go hand
    in hand with this, which allows other modules to have a say in the access to a
    given entity. Moreover, we also saw how we can use entity access checks on routes
    that have entity parameters.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还讨论了实体的访问问题。我们看到了如何创建自己的访问控制处理器并检查针对实体的所有特定操作的访问权限。基础访问处理器调用的访问钩子也与这一点密切相关，这允许其他模块对给定实体的访问发表意见。此外，我们还看到了如何在具有实体参数的路由上使用实体访问检查。
- en: Finally, we briefly covered the block access by which we can control the visibility
    of blocks based on whatever rules we want, including user credentials.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们简要介绍了通过规则控制块可见性的块访问，包括用户凭据。
- en: Apply these lessons in your code, and do not take access issues lightly. If
    there is one thing you should know a great deal about from the beginning, it is
    access. So, this chapter also serves as a reference point for when you are doing
    development; feel free to come back to it as many times as you need.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 将这些课程应用到你的代码中，不要轻视访问问题。如果你从一开始就应该非常了解的一件事，那就是访问。因此，本章也作为你在开发时的参考点；请随时多次查阅。
- en: In the next chapter, we will look at caching and how to ensure that our application
    is performant.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将探讨缓存以及如何确保我们的应用程序性能良好。
